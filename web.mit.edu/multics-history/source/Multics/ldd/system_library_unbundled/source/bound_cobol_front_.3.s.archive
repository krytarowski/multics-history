



		    cobol_pd_code.pl1               05/24/89  1046.0rew 05/24/89  0836.2      182142



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_pd_code.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 01/12/78 by FCH, [3.0-1], sort statement bug */
/* Changes made since version 3.0 */

/* format: style3 */
cobol_pd_code:
     proc (env_ptr);

initialize:
     entry (env_ptr);

	p = env_ptr;
	q = args.arg_6;

	data.end_stmt_ptr = arg_1;
	end_stmt_size = size (end_stmt_ptr -> end_stmt);
	end_stmt_ptr -> end_stmt.size = 4 * end_stmt_size;
	end_stmt_ptr -> end_stmt.type = 19;

	data.eos_ptr = arg_2;
	eos_size = size (eos_ptr -> end_stmt);
	eos_ptr -> end_stmt.size = 4 * eos_size;
	eos_ptr -> end_stmt.type = 19;

	data.proc_ref_ptr = arg_3;
	proc_ref_size = size (proc_ref_ptr -> proc_ref);
	proc_ref_ptr -> proc_ref.size = 4 * proc_ref_size;
	proc_ref_ptr -> proc_ref.type = 18;

	data.arg_ptr = arg_4;
	data.DATA_ptr = args.arg_6;

	data.option_ptr = arg_5;

	first_use = 0;

	return;

code:
     entry;

	p = data.arg_ptr;
	q = data.DATA_ptr;

	if first_use = 0
	then call code_alloc;

	go to G (option_ptr -> mode);

G (1):						/* sort_statement, giving file */
	if ^first_sort
	then call sort_alloc;

	call sort_merge_giving (49);
	return;

G (2):						/* sort statement, using file */
	call sort_using;
	return;

G (3):						/* sort procedure, p1 thru p2 */
	call sort_proc (arg_1, arg_2, 49, 91);
	return;

G (4):						/* sort procedure, p1 thru p1 */
	call sort_proc (arg_1, arg_1, 49, 91);
	return;

G (5):						/* alter */
	call alter_proc;
	return;

G (6):						/* cancel */
	call cancel_proc;
	return;

G (7):						/* initiate */
	call initiate_proc;
	return;

G (8):						/* close eos */
	call close_eos_proc;
	return;

G (9):						/* OPEN EOS */
	call open_eos_proc;
	return;

G (10):						/* OPEN EOS */
	call open_eos_proc;

	end_stmt_ptr -> end_stmt.d = "01"b;

	return;

G (11):						/* OPEN EOS */
	call open_eos_proc;

	end_stmt_ptr -> end_stmt.d = "10"b;

	return;

G (12):						/* OPEN EXT EOS */
	call open_ext_proc;

	return;

G (13):						/* SUSPEND */
	call suspend_proc;

	return;

G (14):						/* TERMINATE */
	call terminate_proc;

	return;

G (15):						/* THEN */
	call then_proc;

	return;

G (16):						/* GO TO */
	call go_proc;

	return;

G (17):						/* add */
	end_stmt_ptr -> end_stmt.h = end_stmt_ptr -> end_stmt.h + 1;

	call emit_code (arg_1);

	return;

G (18):						/* SORT EOS */
	call sort_eos_proc;

	return;

G (19):						/* SEARCH EOS */
	call search_eos_proc;

	return;

G (20):						/* SEARCH EOS4 */
	if ^first_search
	then call search_alloc;

	end_stmt_ptr -> end_stmt.e = 4;

	call emit_code (end_stmt_ptr);
	return;

G (21):						/* SEARCH EOS4 */
	if ^first_search
	then call search_alloc;

	end_stmt_ptr -> end_stmt.b = "1"b;
	end_stmt_ptr -> end_stmt.e = 4;

	call emit_code (end_stmt_ptr);
	return;

G (22):						/* SEARCH EOS2 */
	if ^first_search
	then call search_alloc;

	end_stmt_ptr -> end_stmt.c = "1"b;
	end_stmt_ptr -> end_stmt.verb = 26;
	end_stmt_ptr -> end_stmt.e = 2;

	call emit_code (end_stmt_ptr);
	return;

G (23):						/* SEARCH EOS2 */
	if ^first_search
	then call search_alloc;

	end_stmt_ptr -> end_stmt.verb = 26;
	end_stmt_ptr -> end_stmt.e = 2;
	end_stmt_ptr -> end_stmt.b = "1"b;

	call emit_code (end_stmt_ptr);
	return;

G (24):						/* SEARCH EOS2 */
	if ^first_search
	then call search_alloc;

	bit3 = end_stmt_ptr -> end_stmt.a;
	call set_end (26);

	end_stmt_ptr -> end_stmt.a = bit3;
	end_stmt_ptr -> end_stmt.e = 2;

	call emit_code (end_stmt_ptr);
	return;

G (25):						/* SEARCH EOS3 */
	if ^first_search
	then call search_alloc;

	call set_end (26);

	end_stmt_ptr -> end_stmt.a = "001"b;
	end_stmt_ptr -> end_stmt.e = 3;

	call emit_code (end_stmt_ptr);
	return;

G (26):						/* SEARCH EOS3 */
	if ^first_search
	then call search_alloc;

	call set_end (26);

	end_stmt_ptr -> end_stmt.b = "1"b;
	end_stmt_ptr -> end_stmt.a = "001"b;
	end_stmt_ptr -> end_stmt.e = 3;

	call emit_code (end_stmt_ptr);
	return;

G (27):						/* SEARCH */
	if ^first_search
	then call search_alloc;

	end_stmt_ptr -> end_stmt.verb = 26;
	end_stmt_ptr -> end_stmt.e = 2;
	end_stmt_ptr -> end_stmt.b = "1"b;
	end_stmt_ptr -> end_stmt.c = "1"b;


	call emit_code (end_stmt_ptr);
	return;

G (28):						/* merge_giving */
	if ^first_merge
	then call merge_alloc;

	call sort_merge_giving (15);
	return;

G (29):						/* default device, accept */
	if fixed_common.accept_device = 0
	then end_stmt_ptr -> end_stmt.e = 10;		/* sysin */
	else end_stmt_ptr -> end_stmt.e = 9;		/* console */

	call emit_code (end_stmt_ptr);

	return;

G (30):						/* default device, display */
	if fixed_common.display_device = 0
	then end_stmt_ptr -> end_stmt.a = "001"b;	/* sysout */
	else end_stmt_ptr -> end_stmt.a = "000"b;	/* console */

	call emit_code (end_stmt_ptr);

	return;

G (31):						/* divide */
	call emit_code (arg_1);

	end_stmt_ptr -> end_stmt.h = end_stmt_ptr -> end_stmt.h + 1;

	return;

G (32):						/* compute */
	call emit_code (arg_1);

	return;

G (33):
	call emit_code (arg_1);

	end_stmt_ptr -> end_stmt.e = end_stmt_ptr -> end_stmt.e + 1;

	return;

G (34):
	if end_stmt_ptr -> end_stmt.a = "001"b
	then end_stmt_ptr -> end_stmt.a = "011"b;
	else end_stmt_ptr -> end_stmt.a = "100"b;

	call emit_code (arg_1);

	return;

G (35):
	proc_ref_ptr -> proc_ref.type = 18;

	call emit_code (arg_1);

	call emit_code (end_stmt_ptr);

	return;

G (36):
	end_stmt_ptr -> end_stmt.a = "000"b;

	call emit_code (arg_1);

	return;

G (37):
	call emit_code (arg_1);

	call emit_code (end_stmt_ptr);

	return;

G (38):
	end_stmt_ptr -> end_stmt.b = "1"b;

	call emit_code (arg_1);

	call emit_code (end_stmt_ptr);

	return;

G (39):
	call sort_proc (arg_1, arg_2, 49, 90);

	return;

G (40):
	call sort_proc (arg_1, arg_1, 49, 90);

	return;

G (41):
	if ^first_merge
	then call merge_alloc;

	if end_stmt_ptr -> end_stmt.d = "10"b
	then do;
		call set_end (15);
		end_stmt_ptr -> end_stmt.d = "10"b;
	     end;
	else call set_end (15);

	end_stmt_ptr -> end_stmt.e = arg_1 -> mode;
	end_stmt_ptr -> end_stmt.i = arg_2 -> mode;

	call emit_code (end_stmt_ptr);

	call set_end (15);

	end_stmt_ptr -> end_stmt.h = 91;

	call emit_code (end_stmt_ptr);

	return;

G (42):
	call emit_code (arg_1);

	call emit_code (arg_2);

	call set_end (15);
	end_stmt_ptr -> end_stmt.h = 92;

	call emit_code (end_stmt_ptr);

	end_stmt_ptr -> end_stmt.h = 90;

	call emit_code (end_stmt_ptr);

	return;

G (43):
	call sort_proc (arg_1, arg_1, 15, 90);

	return;

G (44):
	call sort_proc (arg_1, arg_2, 15, 90);

	return;

/* CODE GENERATION PROCEDURES */

sort_merge_giving:
     proc (verb_num);

declare	verb_num		fixed bin;

	call emit_code (open_ptr);			/* OPEN */

	call emit_code (arg_1);			/* FILENAME */

	call set_end (19);				/* EOS */

	end_stmt_ptr -> end_stmt.d = "01"b;

	call emit_code (end_stmt_ptr);

	proc_ref_ptr -> proc_ref.type = 30;		/* PROCDEF */
	proc_ref_ptr -> proc_ref.proc_num = arg_2 -> spec_tag_counter - 1;

	call emit_code (proc_ref_ptr);

	call emit_code (return_ptr);			/* RETURN */

	call emit_code (arg_3);			/* FILENAME */

	call emit_code (arg_4);			/* RECORDNAME */

	end_stmt_ptr -> end_stmt.verb = 25;		/* EOS */
	end_stmt_ptr -> end_stmt.d = "00"b;
	end_stmt_ptr -> end_stmt.b = "1"b;		/*	end_stmt_ptr -> end_stmt.c = "1"b;	*/
						/*[3.0-1]*/

	call emit_code (end_stmt_ptr);

	eos_ptr -> end_stmt.verb = 13;		/* GOTOPROC */
	eos_ptr -> end_stmt.e = 63;
	eos_ptr -> end_stmt.h = arg_2 -> spec_tag_counter;

	call emit_code (eos_ptr);

	end_stmt_ptr -> end_stmt.verb = 3;		/* EOSATEND */
	end_stmt_ptr -> end_stmt.b = "0"b;
	end_stmt_ptr -> end_stmt.c = "0"b;

	call emit_code (end_stmt_ptr);

	call emit_code (write_ptr);			/* WRITE */

	call emit_code (arg_4);			/* RECORDNAME */

	end_stmt_ptr -> end_stmt.verb = 38;		/* EOS */

	call emit_code (end_stmt_ptr);

	eos_ptr -> end_stmt.h = arg_2 -> spec_tag_counter - 1;
						/* GOTOPROC */
	eos_ptr -> end_stmt.verb = 13;
	eos_ptr -> end_stmt.e = 63;

	call emit_code (eos_ptr);

	proc_ref_ptr -> proc_ref.type = 30;		/* PROCDEF */
	proc_ref_ptr -> proc_ref.proc_num = arg_2 -> spec_tag_counter;

	call emit_code (proc_ref_ptr);

	call emit_code (close_ptr);			/* CLOSE */

	call emit_code (arg_1);			/* FILENAME */

	end_stmt_ptr -> end_stmt.verb = 8;		/* EOS */

	call emit_code (end_stmt_ptr);

	end_stmt_ptr -> end_stmt.verb = verb_num;	/* EOS90 */
	end_stmt_ptr -> end_stmt.h = 90;

	call emit_code (end_stmt_ptr);

     end;

sort_using:
     proc;

	if ^first_sort
	then call sort_alloc;

	call emit_code (open_ptr);			/* OPEN */

	call emit_code (arg_1);			/* FILENAME */

	call set_end (19);

	call emit_code (end_stmt_ptr);

	proc_ref_ptr -> proc_ref.type = 30;		/* PROCDEF */
	proc_ref_ptr -> proc_ref.proc_num = arg_2 -> spec_tag_counter - 1;

	call emit_code (proc_ref_ptr);

	call emit_code (read_ptr);			/* READ */

	call emit_code (arg_1);			/* FILENAME */

	end_stmt_ptr -> end_stmt.verb = 21;		/* EOS */
	end_stmt_ptr -> end_stmt.a = "001"b;

	call emit_code (end_stmt_ptr);

	eos_ptr -> end_stmt.verb = 13;		/* GOTOPROC */
	eos_ptr -> end_stmt.e = 63;
	eos_ptr -> end_stmt.h = arg_2 -> spec_tag_counter;

	call emit_code (eos_ptr);

	end_stmt_ptr -> end_stmt.verb = 3;		/* EOSATEND */
	end_stmt_ptr -> end_stmt.a = "000"b;

	call emit_code (end_stmt_ptr);

	call emit_code (release_ptr);			/* RELEASE */

	call emit_code (arg_3);			/* SORTREC */

	call emit_code (arg_4);			/* FILEREC */

	end_stmt_ptr -> end_stmt.verb = 24;		/* EOS */
	end_stmt_ptr -> end_stmt.b = "1"b;		/*	end_stmt_ptr -> end_stmt.c = "1"b;	*/
						/*[3.0-1]*/

	call emit_code (end_stmt_ptr);

	eos_ptr -> end_stmt.verb = 13;		/* GOTOPROC */
	eos_ptr -> end_stmt.e = 63;
	eos_ptr -> end_stmt.h = arg_2 -> spec_tag_counter - 1;

	call emit_code (eos_ptr);

	proc_ref_ptr -> proc_ref.type = 30;		/* PROCDEF */
	proc_ref_ptr -> proc_ref.proc_num = arg_2 -> spec_tag_counter;

	call emit_code (proc_ref_ptr);

	call emit_code (close_ptr);			/* CLOSE */

	call emit_code (arg_1);			/* FILENAME */

	end_stmt_ptr -> end_stmt.verb = 8;		/* EOS */
	end_stmt_ptr -> end_stmt.b = "0"b;
	end_stmt_ptr -> end_stmt.c = "0"b;

	call emit_code (end_stmt_ptr);

     end;

sort_proc:
     proc (ptr_1, ptr_2, val1, val2);

declare	(ptr_1, ptr_2)	ptr;
declare	(val1, val2)	fixed bin;

	if ^first_sort
	then call sort_alloc;

	call emit_code (perform_ptr);			/* PERFORM */

	call emit_code (ptr_1);			/* PROCNAME */

	call emit_code (ptr_2);			/* PROCNAME */

	call set_end (20);

	end_stmt_ptr -> end_stmt.h = 1;

	call emit_code (end_stmt_ptr);

	end_stmt_ptr -> end_stmt.verb = val1;		/* EOS)  */
	end_stmt_ptr -> end_stmt.h = val2;

	call emit_code (end_stmt_ptr);

     end;

alter_proc:
     proc;

	if ^first_alter
	then call alter_alloc;

	addr (alter_ptr -> reserved_word.verb) -> bit36 = "1001001000000000001"b;

	call emit_code (alter_ptr);

     end;

cancel_proc:
     proc;

	if ^first_cancel
	then call cancel_alloc;

	call emit_code (cancel_ptr);

     end;

initiate_proc:
     proc;

	if ^first_initiate
	then call initiate_alloc;

	call emit_code (initiate_ptr);

     end;

close_eos_proc:
     proc;

	if ^first_close
	then call close_alloc;

	end_stmt_ptr -> end_stmt.a = "001"b;		/* EOS */

	call emit_code (end_stmt_ptr);

	alter_ptr -> reserved_word.key = 8;
	addr (alter_ptr -> reserved_word.verb) -> bit36 = "10010010000000000011"b;

	call set_end (0);

	addr (end_stmt_ptr -> end_stmt.a) -> bit18 = "0"b;

	end_stmt_ptr -> end_stmt.verb = alter_ptr -> reserved_word.key;

	call emit_code (alter_ptr);

     end;

set_end:
     proc (num);

declare	num		fixed bin;

	end_stmt_ptr -> end_stmt.verb = num;
	end_stmt_ptr -> end_stmt.e = 0;
	end_stmt_ptr -> end_stmt.h = 0;
	end_stmt_ptr -> end_stmt.i = 0;
	end_stmt_ptr -> end_stmt.j = 0;

	addr (end_stmt_ptr -> end_stmt.a) -> bit18 = "0"b;

     end;

suspend_proc:
     proc;

	if ^first_suspend
	then call suspend_alloc;

	call emit_code (eos_ptr);

	call emit_code (suspend_ptr);

	call set_end (35);

     end;

terminate_proc:
     proc;

	if ^first_terminate
	then call terminate_alloc;

	call emit_code (terminate_ptr);

     end;

then_proc:
     proc;

	if ^first_then
	then call then_alloc;

	call emit_code (then_ptr);

     end;

go_proc:
     proc;

	if ^first_go
	then call go_alloc;

	call set_end (go_ptr -> reserved_word.key);

	end_stmt_ptr -> end_stmt.e = 2;

	call emit_code (go_ptr);

	call emit_code (arg_1);

	call emit_code (arg_2);

     end;

open_eos_proc:
     proc;

	if ^first_open
	then call open_alloc;

	end_stmt_ptr -> end_stmt.a = "001"b;

	call emit_code (end_stmt_ptr);

	call OPEN;

	call set_end (19);

     end;

OPEN:
     proc;

	addr (open_ptr -> reserved_word.verb) -> bit36 = "10010010000000000011"b;

	call emit_code (open_ptr);

     end;

open_ext_proc:
     proc;

	if ^first_open
	then call open_alloc;

	end_stmt_ptr -> end_stmt.a = "001"b;

	call emit_code (end_stmt_ptr);

	call OPEN;

	call set_end (19);

	end_stmt_ptr -> end_stmt.d = "11"b;

     end;

sort_eos_proc:
     proc;

	if ^first_sort
	then call sort_alloc;

	call set_end (49);

	end_stmt_ptr -> end_stmt.h = 91;

	call emit_code (end_stmt_ptr);

     end;

search_eos_proc:
     proc;

	if ^first_search
	then call search_alloc;

	call set_end (26);

	end_stmt_ptr -> end_stmt.e = 3;

	call emit_code (end_stmt_ptr);

     end;

/* EMIT TOKEN */

emit_code:
     proc (code_loc);

declare	code_loc		ptr;

declare	st		bit (32);

declare	1 record		based (code_loc),
	  2 code_size	fixed bin;

	call cobol_swf_put (cobol_pdofp, st, code_loc, code_size);

     end;


/* FORM RESERVED WORD TOKEN */


res_word:
     proc (key, class);

declare	key		fixed bin,
	class		bit (36);

	call alloc (reserved_word_size);

	area_ptr -> reserved_word.size = reserved_byte_size;
	area_ptr -> reserved_word.type = 1;
	area_ptr -> reserved_word.key = key;
	addr (area_ptr -> reserved_word.verb) -> bit36 = class;

     end;

/* ALLOCATE SPACE IN CODE AREA */


alloc:
     proc (size);

declare	size		fixed bin;
declare	(i, j)		fixed bin;

	area_ptr = addr (code_area (code_area_loc + 1));
	j = code_area_loc;

	do i = 1 by 1 to size;

	     code_area (j + i) = 0;

	end;

	code_area_loc = code_area_loc + size;

     end;

/* INITIALIZATION PROCEDURES */


code_alloc:
     proc;

declare	i		fixed bin;

	first_use = 1;

	ind_ptr = addr (data.indicators);
	data.indicators = "0"b;

	code_area_loc = 0;

	do i = 1 by 1 to 100;

	     DATA.ptr (i) = null ();

	end;

	ptr_area_ptr = addr (DATA.ptr (1));

	reserved_word_size = size (ptr_area_ptr -> reserved_word);

	reserved_byte_size = reserved_word_size * 4;

     end;

alloc_test:
     proc (mode);

declare	mode		fixed bin;

	go to A (mode);

A (1):
	return;

A (2):
	if open_ptr = null ()
	then do;
		call res_word (19, "1"b);
		open_ptr = area_ptr;
	     end;

	return;


A (3):
	if close_ptr = null ()
	then do;
		call res_word (8, "1"b);
		close_ptr = area_ptr;
	     end;

	return;


A (4):
	if return_ptr = null ()
	then do;
		call res_word (25, "1"b);
		return_ptr = area_ptr;
	     end;

	return;


A (5):
	if write_ptr = null ()
	then do;
		call res_word (38, "1"b);
		write_ptr = area_ptr;
	     end;

	return;


A (6):
	if read_ptr = null ()
	then do;
		call res_word (21, "1"b);
		read_ptr = area_ptr;
	     end;

	return;


A (7):
	if release_ptr = null ()
	then do;
		call res_word (24, "1"b);
		release_ptr = area_ptr;
	     end;

	return;

A (8):
	return;

A (9):
	return;

A (10):
	if perform_ptr = null ()
	then do;
		call res_word (20, "1"b);
		perform_ptr = area_ptr;
	     end;

A (11):
	if alter_ptr = null ()
	then do;
		call res_word (4, "0"b);
		alter_ptr = area_ptr;
	     end;

	return;

A (12):
	if cancel_ptr = null ()
	then do;
		call res_word (7, "10010010000000000011"b);
		cancel_ptr = area_ptr;
	     end;

	return;

A (13):
	if initiate_ptr = null ()
	then do;
		call res_word (16, "0"b);
		initiate_ptr = area_ptr;
	     end;

	return;

A (14):
	if suspend_ptr = null ()
	then do;
		call res_word (35, "0"b);
		suspend_ptr = area_ptr;
	     end;

	return;

A (15):
	if terminate_ptr = null ()
	then do;
		call res_word (36, "0"b);
		terminate_ptr = area_ptr;
	     end;

	return;

     end;

A (16):
	if then_ptr = null ()
	then do;
		call res_word (194, "0"b);
		then_ptr = area_ptr;
	     end;

	return;

A (17):
	if go_ptr = null ()
	then do;
		call res_word (14, "01001001000000000001"b);
		go_ptr = area_ptr;
	     end;

	return;

sort_alloc:
     proc;

	call sort_merge_alloc;

	first_sort = "1"b;

     end;

sort_merge_alloc:
     proc;


	call alloc_test (2);
	call alloc_test (3);
	call alloc_test (4);
	call alloc_test (5);
	call alloc_test (6);
	call alloc_test (7);
	call alloc_test (10);


     end;

merge_alloc:
     proc;

	call sort_merge_alloc;

	first_merge = "1"b;

     end;

alter_alloc:
     proc;

	call alloc_test (11);
	first_alter = "1"b;

     end;

cancel_alloc:
     proc;

	call alloc_test (12);
	first_cancel = "1"b;

     end;

initiate_alloc:
     proc;

	call alloc_test (13);
	first_initiate = "1"b;

     end;

close_alloc:
     proc;

	call alloc_test (11);
	first_close = "1"b;

     end;

open_alloc:
     proc;

	call alloc_test (2);
	first_open = "1"b;

     end;

suspend_alloc:
     proc;

	call alloc_test (14);
	first_suspend = "1"b;

     end;

terminate_alloc:
     proc;

	call alloc_test (15);
	first_terminate = "1"b;

     end;

then_alloc:
     proc;

	call alloc_test (16);
	first_then = "1"b;

     end;

go_alloc:
     proc;

	call alloc_test (17);
	first_go = "1"b;

     end;

search_alloc:
     proc;

	first_search = "1"b;

     end;

declare	(addr, size, null)	builtin;

declare	(p, q, env_ptr)	ptr;

declare	(proc_ref_size, end_stmt_size, eos_size)
			fixed bin;

declare	cobol_swf_put	entry (ptr, bit (32), ptr, fixed bin);


declare	1 data		static internal,
	  2 first_use	fixed bin,
	  2 indicators	bit (72),
	  2 reserved_word_size
			fixed bin,
	  2 reserved_byte_size
			fixed bin,
	  2 area_ptr	ptr,
	  2 ptr_area_ptr	ptr,
	  2 end_stmt_ptr	ptr,
	  2 option_ptr	ptr,
	  2 arg_ptr	ptr,
	  2 eos_ptr	ptr,
	  2 proc_ref_ptr	ptr,
	  2 ind_ptr	ptr,
	  2 DATA_ptr	ptr,
	  2 code_area_loc	fixed bin;

declare	bit3		bit (3);

declare	1 args		based (p),
	  2 arg_1		ptr,
	  2 arg_2		ptr,
	  2 arg_3		ptr,
	  2 arg_4		ptr,
	  2 arg_5		ptr,
	  2 arg_6		ptr;


declare	1 DATA		based (q),
	  2 ptr		(100) ptr,
	  2 code_area	(5000) fixed bin (35);

declare	1 ptr_area	based (ptr_area_ptr),
	  2 open_ptr	ptr,
	  2 close_ptr	ptr,
	  2 return_ptr	ptr,
	  2 write_ptr	ptr,
	  2 read_ptr	ptr,
	  2 release_ptr	ptr,
	  2 perform_ptr	ptr,
	  2 alter_ptr	ptr,
	  2 cancel_ptr	ptr,
	  2 initiate_ptr	ptr,
	  2 suspend_ptr	ptr,
	  2 terminate_ptr	ptr,
	  2 then_ptr	ptr,
	  2 go_ptr	ptr;

declare	1 indicators	based (ind_ptr),
	  2 first_sort	bit (1),
	  2 first_alter	bit (1),
	  2 first_close	bit (1),
	  2 first_open	bit (1),
	  2 first_suspend	bit (1),
	  2 first_terminate bit (1),
	  2 first_then	bit (1),
	  2 first_go	bit (1),
	  2 first_search	bit (1),
	  2 first_initiate	bit (1),
	  2 first_cancel	bit (1),
	  2 first_merge	bit (1);

declare	bit18		bit (18) based;
declare	spec_tag_counter	fixed bin based;
declare	bit36		bit (36) based;
declare	mode		fixed bin based;


declare	1 reserved_word	based,
%include cobol_TYPE1;

declare	1 proc_ref	based,
%include cobol_TYPE18;

declare	1 end_stmt	based,
%include cobol_TYPE19;

%include cobol_ext_;

%include cobol_fixed_common;

     end;
  



		    cobol_pdst.alm                  05/24/89  1046.0rew 05/24/89  0837.5     1361808



" *********************************************************
" *                                                       *
" * Copyright, (C) BULL HN Information Systems Inc., 1989 *
" *                                                       *
" * Copyright (c) 1972 by Massachusetts Institute of      *
" * Technology and Honeywell Information Systems, Inc.    *
" *                                                       *
" *********************************************************

" HISTORY COMMENTS:
"  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8082),
"     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
"     MCR8082 cobol_pdst.alm Fix wild array subscript.
"                                                      END HISTORY COMMENTS


name	cobol_pdst
	entry	cobol_pdst
cobol_pdst:	save
	epp2	cobol_pdst
	spri2	ap|2,*
	return
		equ i_r,0
		equ i_c,1
		equ i_s,3
		equ i_n,2
		equ i_k,4
		equ i_K,5
		equ l_org,*-5
	fake1:	vfd a36/    ,36/i_n,36/0,36/(accept-l_org)/5,36/0
	fake2:	vfd a36/    ,36/i_n,36/0,36/(add-l_org)/5,36/0
	fake3:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake4:	vfd a36/    ,36/i_n,36/0,36/(alter-l_org)/5,36/0
	fake5:	vfd a36/    ,36/i_n,36/0,36/(call-l_org)/5,36/0
	fake6:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake7:	vfd a36/    ,36/i_n,36/0,36/(cancel-l_org)/5,36/0
	fake8:	vfd a36/    ,36/i_n,36/0,36/(close-l_org)/5,36/0
	fake9:	vfd a36/    ,36/i_n,36/0,36/(divide-l_org)/5,36/0
	fake10:	vfd a36/    ,36/i_n,36/0,36/(multiply-l_org)/5,36/0
	fake11:	vfd a36/    ,36/i_n,36/0,36/(subtract-l_org)/5,36/0
	fake12:	vfd a36/    ,36/i_n,36/0,36/(exit-l_org)/5,36/0
	fake13:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake14:	vfd a36/    ,36/i_n,36/0,36/(go-l_org)/5,36/0
	fake15:	vfd a36/    ,36/i_n,36/0,36/(merge-l_org)/5,36/0
	fake16:	vfd a36/    ,36/i_n,36/0,36/(initiate-l_org)/5,36/0
	fake17:	vfd a36/    ,36/i_n,36/0,36/(inspect-l_org)/5,36/0
	fake18:	vfd a36/    ,36/i_n,36/0,36/(move-l_org)/5,36/0
	fake19:	vfd a36/    ,36/i_n,36/0,36/(open-l_org)/5,36/0
	fake20:	vfd a36/    ,36/i_n,36/0,36/(perform-l_org)/5,36/0
	fake21:	vfd a36/    ,36/i_n,36/0,36/(read-l_org)/5,36/0
	fake22:	vfd a36/    ,36/i_n,36/0,36/(delete-l_org)/5,36/0
	fake23:	vfd a36/    ,36/i_n,36/0,36/(receive-l_org)/5,36/0
	fake24:	vfd a36/    ,36/i_n,36/0,36/(release-l_org)/5,36/0
	fake25:	vfd a36/    ,36/i_n,36/0,36/(return-l_org)/5,36/0
	fake26:	vfd a36/    ,36/i_n,36/0,36/(search-l_org)/5,36/0
	fake27:	vfd a36/    ,36/i_n,36/0,36/(rewrite-l_org)/5,36/0
	fake28:	vfd a36/s   ,36/i_n,36/0,36/(verb1-l_org)/5,36/0
	fake29:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake30:	vfd a36/    ,36/i_n,36/0,36/(send-l_org)/5,36/0
	fake31:	vfd a36/    ,36/i_n,36/0,36/(set-l_org)/5,36/0
	fake32:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake33:	vfd a36/    ,36/i_n,36/0,36/(stop-l_org)/5,36/0
	fake34:	vfd a36/    ,36/i_n,36/0,36/(string-l_org)/5,36/0
	fake35:	vfd a36/    ,36/i_n,36/0,36/(suspend-l_org)/5,36/0
	fake36:	vfd a36/    ,36/i_n,36/0,36/(terminate-l_org)/5,36/0
	fake37:	vfd a36/    ,36/i_n,36/0,36/(unstring-l_org)/5,36/0
	fake38:	vfd a36/    ,36/i_n,36/0,36/(write-l_org)/5,36/0
	fake39:	vfd a36/s   ,36/i_n,36/166,36/(rtwo_1-l_org)/5,36/0
	fake40:	vfd a36/    ,36/i_n,36/0,36/(compute-l_org)/5,36/0
	fake41:	vfd a36/    ,36/i_n,36/0,36/(disable-l_org)/5,36/0
	fake42:	vfd a36/    ,36/i_n,36/0,36/(display-l_org)/5,36/0
	fake43:	vfd a36/    ,36/i_n,36/0,36/(enable-l_org)/5,36/0
	fake44:	vfd a36/    ,36/i_n,36/0,36/(enter-l_org)/5,36/0
	fake45:	vfd a36/    ,36/i_n,36/0,36/(generate-l_org)/5,36/0
	fake46:	vfd a36/    ,36/i_n,36/0,36/(hold-l_org)/5,36/0
	fake47:	vfd a36/    ,36/i_n,36/0,36/(if-l_org)/5,36/0
	fake48:	vfd a36/    ,36/i_n,36/0,36/(process-l_org)/5,36/0
	fake49:	vfd a36/    ,36/i_n,36/0,36/(sort-l_org)/5,36/0
	fake50:	vfd a36/    ,36/i_n,36/0,36/(examine-l_org)/5,36/0
	fake51:	vfd a36/    ,36/i_n,36/0,36/(transform-l_org)/5,36/0
	fake52:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake53:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake54:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake55:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake56:	vfd a36/    ,36/i_n,36/0,36/(start-l_org)/5,36/0
	fake57:	vfd a36/    ,36/i_n,36/0,36/(suppress-l_org)/5,36/0
	fake58:	vfd a36/    ,36/i_n,36/0,36/(purge-l_org)/5,36/0
	fake59:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake60:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake61:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake62:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake63:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake64:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake65:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake66:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake67:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake68:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
	fake69:	vfd a36/s   ,36/i_n,36/300,36/(rtwo_1-l_org)/5,36/0
l_1:		vfd a36/so  ,36/i_r,36/r_procedure,36/(l_2-l_org)/5,36/a_127
		vfd a36/    ,36/i_n,36/001,36/(rone-l_org)/5,36/0
l_2:		vfd a36/s   ,36/i_r,36/r_division,36/(l_3-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/002,36/(rone-l_org)/5,36/0
l_3:		vfd a36/    ,36/i_r,36/r_using,36/(l_4-l_org)/5,36/a_21
		vfd a36/s   ,36/i_c,36/c_period,36/(pd_1-l_org)/5,36/a_274
		vfd a36/    ,36/i_n,36/3,36/(pd_1-l_org)/5,36/a_286
l_4:		vfd a36/ 2  ,36/i_n,36/80,36/(l_5-l_org)/5,36/13
l_5:		vfd a36/s   ,36/i_c,36/c_inbit,36/(l_6-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/004,36/(rone-l_org)/5,36/0
l_6:		vfd a36/so  ,36/i_c,36/c_lident,36/(l_7-l_org)/5,36/a_8
		vfd a36/    ,36/i_n,36/005,36/(rone-l_org)/5,36/0
l_7:		vfd a36/so  ,36/i_c,36/c_lident,36/(l_7-l_org)/5,36/a_8
l_8:		vfd a36/s   ,36/i_c,36/c_period,36/(l_9-l_org)/5,36/a_274
		vfd a36/    ,36/i_n,36/0,36/(l_9-l_org)/5,36/a_328
l_9:	pd_1:	vfd a36/so  ,36/i_r,36/r_declaratives,36/(l_10-l_org)/5,36/a_133
		vfd a36/    ,36/i_n,36/0,36/(nodeclp-l_org)/5,36/0
l_10:		vfd a36/    ,36/i_n,36/0,36/(l_11-l_org)/5,36/a_88
l_11:		vfd a36/s   ,36/i_c,36/c_period,36/(l_12-l_org)/5,36/a_274
		vfd a36/    ,36/i_n,36/0,36/(l_12-l_org)/5,36/a_328
l_12:		vfd a36/so  ,36/i_c,36/c_sechdr,36/(l_13-l_org)/5,36/a_128
		vfd a36/    ,36/i_n,36/008,36/(rthr-l_org)/5,36/0
l_13:	pd_2:	vfd a36/s   ,36/i_r,36/r_section,36/(l_14-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/129,36/(rthr-l_org)/5,36/0
l_14:		vfd a36/    ,36/i_c,36/c_numlit,36/(l_15-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(pd_3-l_org)/5,36/a_145
l_15:		vfd a36/s   ,36/i_c,36/c_ckdsegnum,36/(l_16-l_org)/5,36/a_145
		vfd a36/    ,36/i_n,36/245,36/(rthr-l_org)/5,36/0
l_16:		vfd a36/    ,36/i_n,36/0,36/(l_17-l_org)/5,36/a_332
l_17:	pd_3:	vfd a36/s   ,36/i_c,36/c_period,36/(l_18-l_org)/5,36/a_274
		vfd a36/    ,36/i_n,36/0,36/(l_18-l_org)/5,36/a_328
l_18:		vfd a36/    ,36/i_c,36/c_debug,36/(pd_6-l_org)/5,36/0
	pd_5:	vfd a36/    ,36/i_s,36/(use-l_org)/5,36/(l_19-l_org)/5,36/0
l_19:		vfd a36/    ,36/i_c,36/c_debug,36/(l_20-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(proc-l_org)/5,36/0
l_20:		vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(proc-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(proc-l_org)/5,36/0
	pd_6:	vfd a36/    ,36/i_s,36/(impseq-l_org)/5,36/(pd_5-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(pd_5-l_org)/5,36/0
	use:	vfd a36/s   ,36/i_r,36/r_use,36/(l_21-l_org)/5,36/a_318
		vfd a36/    ,36/i_n,36/009,36/(rthr-l_org)/5,36/0
l_21:		vfd a36/s   ,36/i_r,36/r_after,36/(l_22-l_org)/5,36/a_4
		vfd a36/s   ,36/i_r,36/r_before,36/(use2-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_for,36/(use3-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(use3-l_org)/5,36/0
l_22:		vfd a36/s   ,36/i_r,36/r_standard,36/(use4-l_org)/5,36/a_20
		vfd a36/    ,36/i_n,36/0,36/(use4-l_org)/5,36/0
	use2:	vfd a36/s   ,36/i_r,36/r_standard,36/(use13-l_org)/5,36/a_25
		vfd a36/s   ,36/i_r,36/r_reporting,36/(use14-l_org)/5,36/a_24
		vfd a36/    ,36/i_n,36/0,36/(use13-l_org)/5,36/a_13
	use3:	vfd a36/s   ,36/i_r,36/r_random,36/(l_23-l_org)/5,36/a_19
		vfd a36/s   ,36/i_r,36/r_debugging,36/(use18-l_org)/5,36/a_26
		vfd a36/    ,36/i_n,36/010,36/(rthr-l_org)/5,36/0
l_23:		vfd a36/s   ,36/i_r,36/r_processing,36/(use12-l_org)/5,36/a_94
		vfd a36/    ,36/i_n,36/0,36/(use12-l_org)/5,36/a_94
	use4:	vfd a36/s   ,36/i_r,36/r_error,36/(l_24-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_exception,36/(l_24-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(use13-l_org)/5,36/a_21
l_24:	use5:	vfd a36/s   ,36/i_r,36/r_procedure,36/(l_25-l_org)/5,36/a_94
		vfd a36/    ,36/i_n,36/001,36/(rthr-l_org)/5,36/0
l_25:		vfd a36/s   ,36/i_r,36/r_on,36/(l_26-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_26-l_org)/5,36/0
l_26:		vfd a36/    ,36/i_c,36/c_filenm,36/(use22-l_org)/5,36/a_7
		vfd a36/    ,36/i_r,36/r_input,36/(use7-l_org)/5,36/a_121
		vfd a36/    ,36/i_r,36/r_output,36/(use8-l_org)/5,36/a_120
		vfd a36/    ,36/i_r,36/r_i_o,36/(use9-l_org)/5,36/a_122
		vfd a36/    ,36/i_r,36/r_extend,36/(use10-l_org)/5,36/a_319
		vfd a36/    ,36/i_n,36/011,36/(rthr-l_org)/5,36/0
	use22:	vfd a36/    ,36/i_n,36/0,36/(l_27-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/032,36/(rthr-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_27-l_org)/5,36/a_319
		vfd a36/ 2  ,36/i_n,36/194,36/(l_27-l_org)/5,36/17
		vfd a36/ 4  ,36/i_n,36/194,36/(l_27-l_org)/5,36/19
		vfd a36/    ,36/i_n,36/032,36/(rthr-l_org)/5,36/0
		vfd a36/ 5  ,36/i_n,36/194,36/(l_27-l_org)/5,36/25
l_27:	use6:	vfd a36/    ,36/i_c,36/c_formtlb,36/(l_28-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/012,36/(rthr-l_org)/5,36/0
l_28:		vfd a36/s   ,36/i_c,36/c_ckerrex,36/(use11-l_org)/5,36/a_153
		vfd a36/s   ,36/i_n,36/249,36/(use11-l_org)/5,36/0
	use7:	vfd a36/s   ,36/i_c,36/c_ckinput,36/(use12-l_org)/5,36/a_253
		vfd a36/s   ,36/i_n,36/250,36/(use12-l_org)/5,36/0
	use8:	vfd a36/s   ,36/i_c,36/c_ckoutput,36/(use12-l_org)/5,36/a_254
		vfd a36/s   ,36/i_n,36/250,36/(use12-l_org)/5,36/0
	use9:	vfd a36/s   ,36/i_c,36/c_ckio,36/(use12-l_org)/5,36/a_255
		vfd a36/s   ,36/i_n,36/250,36/(use12-l_org)/5,36/0
	use10:	vfd a36/ 3  ,36/i_n,36/29,36/(l_29-l_org)/5,36/16
l_29:		vfd a36/s   ,36/i_c,36/c_ckextend,36/(use12-l_org)/5,36/a_256
		vfd a36/s   ,36/i_n,36/250,36/(use12-l_org)/5,36/0
	use11:	vfd a36/    ,36/i_c,36/c_filenm,36/(use23-l_org)/5,36/a_8
	use12:	vfd a36/s   ,36/i_c,36/c_period,36/(succ-l_org)/5,36/a_273
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/a_329
	use23:	vfd a36/    ,36/i_n,36/0,36/(l_30-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/032,36/(rthr-l_org)/5,36/0
		vfd a36/ 3  ,36/i_n,36/41,36/(use6-l_org)/5,36/16
		vfd a36/ 3  ,36/i_n,36/41,36/(use6-l_org)/5,36/18
		vfd a36/ 4  ,36/i_n,36/41,36/(use6-l_org)/5,36/20
		vfd a36/    ,36/i_n,36/032,36/(rthr-l_org)/5,36/0
		vfd a36/ 5  ,36/i_n,36/41,36/(use6-l_org)/5,36/26
l_30:	use13:	vfd a36/s   ,36/i_r,36/r_beginning,36/(l_31-l_org)/5,36/a_14
		vfd a36/s   ,36/i_r,36/r_ending,36/(l_31-l_org)/5,36/a_18
l_31:		vfd a36/s   ,36/i_r,36/r_reel,36/(l_32-l_org)/5,36/a_15
		vfd a36/s   ,36/i_r,36/r_file,36/(l_32-l_org)/5,36/a_16
		vfd a36/s   ,36/i_r,36/r_unit,36/(l_32-l_org)/5,36/a_17
		vfd a36/    ,36/i_n,36/0,36/(l_32-l_org)/5,36/0
l_32:		vfd a36/s   ,36/i_r,36/r_label,36/(use5-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/013,36/(rthr-l_org)/5,36/0
	use14:	vfd a36/s   ,36/i_c,36/c_repnm,36/(l_33-l_org)/5,36/a_8
		vfd a36/    ,36/i_n,36/14,36/(rtwo-l_org)/5,36/0
l_33:		vfd a36/s   ,36/i_c,36/c_repnm,36/(l_33-l_org)/5,36/a_8
		vfd a36/    ,36/i_n,36/0,36/(use12-l_org)/5,36/a_94
	use18:	vfd a36/s   ,36/i_r,36/r_on,36/(l_34-l_org)/5,36/0
l_34:		vfd a36/    ,36/i_c,36/c_deswz,36/(l_35-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(rthr-l_org)/5,36/0
l_35:		vfd a36/s   ,36/i_c,36/c_cdname,36/(l_36-l_org)/5,36/a_8
		vfd a36/s   ,36/i_c,36/c_prnm,36/(l_36-l_org)/5,36/a_8
		vfd a36/s   ,36/i_c,36/c_file,36/(l_36-l_org)/5,36/a_8
		vfd a36/s   ,36/i_c,36/c_dana,36/(use1-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_all,36/(use21-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/141,36/(rthr-l_org)/5,36/0
l_36:	use20:	vfd a36/s   ,36/i_c,36/c_cdname,36/(use20-l_org)/5,36/a_8
		vfd a36/s   ,36/i_c,36/c_prnm,36/(use20-l_org)/5,36/a_8
		vfd a36/s   ,36/i_c,36/c_file,36/(use20-l_org)/5,36/a_8
		vfd a36/s   ,36/i_c,36/c_dana,36/(use1-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_all,36/(l_37-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(use12-l_org)/5,36/0
l_37:	use21:	vfd a36/s   ,36/i_r,36/r_procedures,36/(use20-l_org)/5,36/a_8
		vfd a36/s   ,36/i_r,36/r_references,36/(l_38-l_org)/5,36/0
l_38:		vfd a36/s   ,36/i_r,36/r_of,36/(l_39-l_org)/5,36/0
l_39:		vfd a36/s   ,36/i_c,36/c_dana,36/(l_40-l_org)/5,36/a_95
		vfd a36/    ,36/i_n,36/185,36/(rthr-l_org)/5,36/0
l_40:	use1:	vfd a36/s   ,36/i_c,36/c_nonumlit,36/(use20-l_org)/5,36/a_8
		vfd a36/    ,36/i_n,36/0,36/(use20-l_org)/5,36/a_8
	proc:	vfd a36/so  ,36/i_c,36/c_sechdr,36/(pd_2-l_org)/5,36/a_128
		vfd a36/so  ,36/i_c,36/c_paranm,36/(sec3-l_org)/5,36/a_129
		vfd a36/so  ,36/i_c,36/c_enddec,36/(l_41-l_org)/5,36/a_300
		vfd a36/so  ,36/i_c,36/c_endcob,36/(proc1-l_org)/5,36/a_300
		vfd a36/    ,36/i_n,36/131,36/(rtwo-l_org)/5,36/0
l_41:		vfd a36/s   ,36/i_n,36/0,36/(l_42-l_org)/5,36/a_4
l_42:		vfd a36/s   ,36/i_c,36/c_period,36/(proc3-l_org)/5,36/a_274
		vfd a36/    ,36/i_n,36/0,36/(proc3-l_org)/5,36/a_328
	proc1:	vfd a36/    ,36/i_n,36/017,36/(l_43-l_org)/5,36/0
l_43:	proc2:	vfd a36/ o  ,36/i_n,36/0,36/(l_44-l_org)/5,36/a_273
l_44:		vfd a36/s   ,36/i_n,36/0,36/(l_45-l_org)/5,36/a_3
l_45:		vfd a36/    ,36/i_n,36/0,36/(l_46-l_org)/5,36/a_251
l_46:		vfd a36/s   ,36/i_c,36/c_period,36/(l_47-l_org)/5,36/a_273
l_47:		vfd a36/s   ,36/i_c,36/c_cktp25,36/(palp_3-l_org)/5,36/0
l_48:		vfd a36/    ,36/i_n,36/0,36/(l_48-l_org)/5,36/a_endjob
	proc3:	vfd a36/    ,36/i_n,36/0,36/(l_49-l_org)/5,36/a_96
l_49:		vfd a36/    ,36/i_c,36/c_debug,36/(proc5-l_org)/5,36/0
	proc4:	vfd a36/so  ,36/i_c,36/c_sechdr,36/(sec-l_org)/5,36/a_128
		vfd a36/    ,36/i_n,36/008,36/(rtwo-l_org)/5,36/0
	proc5:	vfd a36/    ,36/i_s,36/(impseq-l_org)/5,36/(proc4-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(proc4-l_org)/5,36/0
	nodeclp:	vfd a36/so  ,36/i_c,36/c_sechdr,36/(sec-l_org)/5,36/a_128
		vfd a36/    ,36/i_n,36/0,36/(sec2-l_org)/5,36/0
	sec:	vfd a36/s   ,36/i_r,36/r_section,36/(l_50-l_org)/5,36/a_89
		vfd a36/    ,36/i_n,36/129,36/(rfiv-l_org)/5,36/0
l_50:		vfd a36/    ,36/i_c,36/c_numlit,36/(l_51-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(sec1-l_org)/5,36/0
l_51:		vfd a36/s   ,36/i_c,36/c_prnum,36/(l_52-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/247,36/(rtwo-l_org)/5,36/0
l_52:		vfd a36/    ,36/i_n,36/0,36/(l_53-l_org)/5,36/a_332
l_53:	sec1:	vfd a36/s   ,36/i_c,36/c_period,36/(l_54-l_org)/5,36/a_274
		vfd a36/    ,36/i_n,36/0,36/(l_54-l_org)/5,36/a_328
l_54:		vfd a36/    ,36/i_c,36/c_debug,36/(l_55-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(nodeclp-l_org)/5,36/0
l_55:	sec4:	vfd a36/    ,36/i_s,36/(impseq-l_org)/5,36/(nodeclp-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(nodeclp-l_org)/5,36/0
	sec2:	vfd a36/so  ,36/i_c,36/c_paranm,36/(l_56-l_org)/5,36/a_129
		vfd a36/    ,36/i_n,36/0,36/(sec5-l_org)/5,36/0
l_56:	sec3:	vfd a36/s   ,36/i_c,36/c_period,36/(palp-l_org)/5,36/a_274
		vfd a36/    ,36/i_n,36/0,36/(palp-l_org)/5,36/a_328
	sec5:	vfd a36/so  ,36/i_c,36/c_endcob,36/(proc2-l_org)/5,36/a_300
		vfd a36/    ,36/i_n,36/131,36/(rtwo-l_org)/5,36/0
	palp:	vfd a36/so  ,36/i_r,36/r_go,36/(palp_1-l_org)/5,36/a_87
		vfd a36/so  ,36/i_r,36/r_exit,36/(palp_2-l_org)/5,36/a_318
		vfd a36/    ,36/i_n,36/0,36/(palp_3-l_org)/5,36/0
	palp_3a:	vfd a36/so  ,36/i_c,36/c_endcob,36/(proc2-l_org)/5,36/a_300
		vfd a36/so  ,36/i_c,36/c_sechdr,36/(palp_11-l_org)/5,36/a_128
		vfd a36/so  ,36/i_c,36/c_paranm,36/(sec3-l_org)/5,36/a_129
	palp_3:	vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(palp_10-l_org)/5,36/a_195
		vfd a36/so  ,36/i_c,36/c_paranm,36/(sec3-l_org)/5,36/a_129
		vfd a36/    ,36/i_c,36/c_deswon,36/(proc-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_sechdr,36/(palp_11-l_org)/5,36/a_128
		vfd a36/s   ,36/i_c,36/c_period,36/(palp_3-l_org)/5,36/a_273
		vfd a36/so  ,36/i_c,36/c_endcob,36/(proc2-l_org)/5,36/a_300
		vfd a36/    ,36/i_c,36/c_amarg,36/(l_57-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/133,36/(rtwo-l_org)/5,36/0
l_57:		vfd a36/    ,36/i_n,36/251,36/(rtwo-l_org)/5,36/0
	palp_1:	vfd a36/s   ,36/i_r,36/r_to,36/(palp_5-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(palp_5-l_org)/5,36/0
	palp_2:	vfd a36/    ,36/i_r,36/r_program,36/(palp_15-l_org)/5,36/a_37
		vfd a36/    ,36/i_n,36/0,36/(l_58-l_org)/5,36/a_319
l_58:		vfd a36/    ,36/i_n,36/0,36/(palp_9-l_org)/5,36/a_3
	palp_15:	vfd a36/s2  ,36/i_n,36/69,36/(palp_9-l_org)/5,36/13
	palp_5:	vfd a36/    ,36/i_c,36/c_prnm,36/(l_59-l_org)/5,36/a_8
		vfd a36/s   ,36/i_c,36/c_period,36/(palp_6-l_org)/5,36/a_275
		vfd a36/    ,36/i_n,36/0,36/(palp_6-l_org)/5,36/a_330
l_59:		vfd a36/    ,36/i_n,36/0,36/(l_60-l_org)/5,36/a_272
l_60:		vfd a36/so  ,36/i_c,36/c_decnondec,36/(l_61-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/188,36/(rtwo-l_org)/5,36/0
l_61:		vfd a36/s   ,36/i_c,36/c_period,36/(palp_6-l_org)/5,36/a_274
		vfd a36/    ,36/i_c,36/c_prnm,36/(palp_8-l_org)/5,36/a_8
		vfd a36/    ,36/i_n,36/0,36/(palp_6-l_org)/5,36/a_331
	palp_6:	vfd a36/    ,36/i_c,36/c_prdef,36/(palp-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_sechdr,36/(palp-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_endcob,36/(palp-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_enddec,36/(palp-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/125,36/(rtwo-l_org)/5,36/0
	palp_8:	vfd a36/    ,36/i_n,36/0,36/(l_62-l_org)/5,36/a_272
l_62:		vfd a36/so  ,36/i_c,36/c_decnondec,36/(l_63-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/188,36/(rtwo-l_org)/5,36/0
l_63:		vfd a36/    ,36/i_c,36/c_prnm,36/(palp_8-l_org)/5,36/a_8
		vfd a36/s   ,36/i_r,36/r_depending,36/(l_64-l_org)/5,36/a_21
		vfd a36/    ,36/i_n,36/044,36/(rtwo-l_org)/5,36/0
l_64:		vfd a36/s   ,36/i_r,36/r_on,36/(l_65-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_65-l_org)/5,36/0
l_65:		vfd a36/so  ,36/i_s,36/(elnumint-l_org)/5,36/(l_66-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/045,36/(rtwo-l_org)/5,36/0
l_66:		vfd a36/s   ,36/i_c,36/c_period,36/(palp_3-l_org)/5,36/a_274
		vfd a36/    ,36/i_n,36/0,36/(palp_3a-l_org)/5,36/a_274
	palp_9:	vfd a36/s   ,36/i_c,36/c_period,36/(palp_6-l_org)/5,36/a_273
		vfd a36/    ,36/i_n,36/007,36/(palp_6-l_org)/5,36/0
	palp_10:	vfd a36/s   ,36/i_c,36/c_period,36/(palp_3-l_org)/5,36/a_273
		vfd a36/    ,36/i_n,36/0,36/(palp_3a-l_org)/5,36/0
	palp_11:	vfd a36/    ,36/i_c,36/c_debug,36/(sec-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_secsw,36/(sec-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/132,36/(sec-l_org)/5,36/0
	accept:	vfd a36/so  ,36/i_r,36/r_accept,36/(l_67-l_org)/5,36/a_318
l_67:		vfd a36/so  ,36/i_s,36/(rid-l_org)/5,36/(acc3-l_org)/5,36/a_28
		vfd a36/so  ,36/i_c,36/c_incdnm,36/(acc1-l_org)/5,36/a_21
		vfd a36/s   ,36/i_c,36/c_xnm,36/(l_68-l_org)/5,36/0
		vfd a36/s   ,36/i_s,36/(xdname-l_org)/5,36/(l_68-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/220,36/(rtwo-l_org)/5,36/0
l_68:		vfd a36/    ,36/i_n,36/268,36/(rtwo-l_org)/5,36/0
	acc3:	vfd a36/    ,36/i_n,36/0,36/(l_69-l_org)/5,36/a_319
l_69:		vfd a36/s   ,36/i_r,36/r_from,36/(l_70-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_248
l_70:		vfd a36/ 3  ,36/i_c,36/c_acc_dev,36/(acc2-l_org)/5,36/21
		vfd a36/    ,36/i_r,36/r_date,36/(l_71-l_org)/5,36/0
		vfd a36/    ,36/i_r,36/r_time,36/(l_71-l_org)/5,36/a_101
		vfd a36/    ,36/i_r,36/r_day,36/(l_71-l_org)/5,36/a_64
		vfd a36/    ,36/i_r,36/r_day_of_week,36/(acc5-l_org)/5,36/a_161
		vfd a36/    ,36/i_n,36/023,36/(rtwo-l_org)/5,36/0
l_71:		vfd a36/ 3  ,36/i_n,36/22,36/(l_72-l_org)/5,36/2
l_72:	acc4:	vfd a36/s   ,36/i_c,36/c_sina,36/(verb1-l_org)/5,36/a_3
		vfd a36/    ,36/i_n,36/22,36/(verb1-l_org)/5,36/a_3
	acc5:	vfd a36/ 5  ,36/i_n,36/166,36/(acc4-l_org)/5,36/25
	acc1:	vfd a36/s   ,36/i_r,36/r_message,36/(l_73-l_org)/5,36/0
l_73:		vfd a36/    ,36/i_r,36/r_count,36/(l_74-l_org)/5,36/a_3
		vfd a36/    ,36/i_n,36/221,36/(rtwo-l_org)/5,36/0
l_74:		vfd a36/s3  ,36/i_n,36/70,36/(verb1-l_org)/5,36/23
	acc2:	vfd a36/s   ,36/i_c,36/c_acc_dev,36/(disp2-l_org)/5,36/a_160
		vfd a36/    ,36/i_n,36/223,36/(rtwo-l_org)/5,36/0
	add:	vfd a36/so  ,36/i_r,36/r_add,36/(l_75-l_org)/5,36/a_27
l_75:		vfd a36/so  ,36/i_c,36/c_unelnudn,36/(l_76-l_org)/5,36/a_33
		vfd a36/so  ,36/i_s,36/(elnuitem-l_org)/5,36/(l_76-l_org)/5,36/a_33
		vfd a36/so  ,36/i_c,36/c_figzero,36/(l_76-l_org)/5,36/a_33
		vfd a36/    ,36/i_n,36/024,36/(rtwo-l_org)/5,36/0
l_76:	add4:	vfd a36/s   ,36/i_r,36/r_to,36/(l_77-l_org)/5,36/0
		vfd a36/so  ,36/i_s,36/(elnuitem-l_org)/5,36/(add5-l_org)/5,36/a_33
		vfd a36/so  ,36/i_c,36/c_figzero,36/(add5-l_org)/5,36/a_33
		vfd a36/    ,36/i_n,36/025,36/(rtwo-l_org)/5,36/0
l_77:		vfd a36/s   ,36/i_c,36/c_unelnudn,36/(add6-l_org)/5,36/a_34
		vfd a36/s   ,36/i_s,36/(alel-l_org)/5,36/(add6-l_org)/5,36/a_34
		vfd a36/    ,36/i_n,36/024,36/(rtwo-l_org)/5,36/0
	add5:	vfd a36/s   ,36/i_r,36/r_giving,36/(add2-l_org)/5,36/a_21
		vfd a36/    ,36/i_n,36/0,36/(add4-l_org)/5,36/0
	add6:	vfd a36/    ,36/i_c,36/c_sterm,36/(add1-l_org)/5,36/a_102
		vfd a36/s   ,36/i_r,36/r_rounded,36/(l_78-l_org)/5,36/a_267
		vfd a36/    ,36/i_n,36/0,36/(l_78-l_org)/5,36/a_268
l_78:		vfd a36/    ,36/i_c,36/c_sterm,36/(add1-l_org)/5,36/a_3
l_79:		vfd a36/    ,36/i_s,36/(alel-l_org)/5,36/(add9-l_org)/5,36/a_269
l_80:		vfd a36/    ,36/i_s,36/(nos-l_org)/5,36/(add11-l_org)/5,36/a_87
		vfd a36/    ,36/i_n,36/0,36/(l_81-l_org)/5,36/a_102
l_81:	add1:	vfd a36/s   ,36/i_r,36/r_end_add,36/(verb1-l_org)/5,36/a_312
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/0
	add11:	vfd a36/    ,36/i_s,36/(osi-l_org)/5,36/(l_82-l_org)/5,36/0
l_82:		vfd a36/s   ,36/i_r,36/r_end_add,36/(verb1-l_org)/5,36/a_266
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_310
	add9:	vfd a36/s3  ,36/i_n,36/23,36/(add6-l_org)/5,36/2
	add2:	vfd a36/s   ,36/i_s,36/(edalel-l_org)/5,36/(l_83-l_org)/5,36/a_34
		vfd a36/    ,36/i_n,36/026,36/(rtwo-l_org)/5,36/0
l_83:	add3:	vfd a36/s   ,36/i_r,36/r_rounded,36/(l_84-l_org)/5,36/a_267
		vfd a36/    ,36/i_n,36/0,36/(l_84-l_org)/5,36/a_268
l_84:		vfd a36/    ,36/i_s,36/(edalel-l_org)/5,36/(add8-l_org)/5,36/a_269
		vfd a36/    ,36/i_s,36/(nos-l_org)/5,36/(add11-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(add1-l_org)/5,36/a_3
	add8:	vfd a36/s3  ,36/i_n,36/23,36/(add3-l_org)/5,36/2
	alter:	vfd a36/so  ,36/i_r,36/r_alter,36/(l_85-l_org)/5,36/a_87
l_85:	alt1:	vfd a36/so  ,36/i_c,36/c_altprnm,36/(l_86-l_org)/5,36/a_147
		vfd a36/    ,36/i_n,36/027,36/(rtwo-l_org)/5,36/0
l_86:		vfd a36/s   ,36/i_r,36/r_to,36/(l_87-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/028,36/(rtwo-l_org)/5,36/0
l_87:		vfd a36/s   ,36/i_r,36/r_proceed,36/(l_88-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(alt2-l_org)/5,36/0
l_88:		vfd a36/s   ,36/i_r,36/r_to,36/(alt2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/028,36/(rtwo-l_org)/5,36/0
	alt2:	vfd a36/so  ,36/i_c,36/c_prnm,36/(l_89-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/062,36/(rtwo-l_org)/5,36/0
l_89:		vfd a36/    ,36/i_c,36/c_altlegal,36/(l_90-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/188,36/(rtwo-l_org)/5,36/0
l_90:		vfd a36/    ,36/i_n,36/0,36/(l_91-l_org)/5,36/a_3
l_91:		vfd a36/    ,36/i_c,36/c_altprnm,36/(l_92-l_org)/5,36/a_104
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/0
l_92:		vfd a36/ 3  ,36/i_n,36/24,36/(alt1-l_org)/5,36/2
	call:	vfd a36/    ,36/i_r,36/r_call,36/(l_93-l_org)/5,36/a_42
l_93:		vfd a36/so  ,36/i_n,36/0,36/(l_94-l_org)/5,36/a_321
l_94:		vfd a36/ 2  ,36/i_c,36/c_nonumlit,36/(l_95-l_org)/5,36/66
		vfd a36/ 3  ,36/i_c,36/c_nonumdn,36/(call6-l_org)/5,36/147
		vfd a36/    ,36/i_n,36/238,36/(rtwo-l_org)/5,36/0
l_95:		vfd a36/so  ,36/i_c,36/c_cklit,36/(call7-l_org)/5,36/0
		vfd a36/ o  ,36/i_c,36/c_cklit1,36/(l_96-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_mcobol,36/(call5-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/238,36/(rtwo-l_org)/5,36/0
l_96:	call2:	vfd a36/s   ,36/i_n,36/256,36/(call7-l_org)/5,36/0
	call5:	vfd a36/ o  ,36/i_c,36/c_cklit2,36/(call2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/255,36/(rtwo-l_org)/5,36/0
	call6:	vfd a36/so  ,36/i_s,36/(ident-l_org)/5,36/(l_97-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/114,36/(rtwo-l_org)/5,36/0
l_97:	call7:	vfd a36/s   ,36/i_r,36/r_using,36/(l_98-l_org)/5,36/a_21
		vfd a36/    ,36/i_n,36/0,36/(call1-l_org)/5,36/0
l_98:		vfd a36/so  ,36/i_c,36/c_useid,36/(l_99-l_org)/5,36/a_8
		vfd a36/so  ,36/i_c,36/c_is_user_word,36/(l_99-l_org)/5,36/a_287
		vfd a36/    ,36/i_n,36/315,36/(rtwo-l_org)/5,36/0
l_99:		vfd a36/so  ,36/i_c,36/c_useid,36/(l_99-l_org)/5,36/a_8
		vfd a36/so  ,36/i_c,36/c_is_user_word,36/(l_99-l_org)/5,36/a_287
	call1:	vfd a36/    ,36/i_c,36/c_noo,36/(l_100-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(call3-l_org)/5,36/a_3
l_100:		vfd a36/ 3  ,36/i_n,36/67,36/(l_101-l_org)/5,36/14
l_101:		vfd a36/    ,36/i_s,36/(nov-l_org)/5,36/(l_102-l_org)/5,36/0
l_102:		vfd a36/    ,36/i_s,36/(ovi-l_org)/5,36/(l_103-l_org)/5,36/0
l_103:		vfd a36/s   ,36/i_r,36/r_end_call,36/(l_104-l_org)/5,36/a_266
		vfd a36/    ,36/i_n,36/0,36/(l_104-l_org)/5,36/a_310
l_104:		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_52
	call3:	vfd a36/s   ,36/i_r,36/r_end_call,36/(verb1-l_org)/5,36/a_312
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/0
	cancel:	vfd a36/ o  ,36/i_r,36/r_cancel,36/(l_105-l_org)/5,36/a_87
l_105:		vfd a36/s3  ,36/i_n,36/68,36/(l_106-l_org)/5,36/14
l_106:		vfd a36/so  ,36/i_s,36/(nonumid-l_org)/5,36/(l_107-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/029,36/(rtwo-l_org)/5,36/0
l_107:	can1:	vfd a36/    ,36/i_n,36/0,36/(l_108-l_org)/5,36/a_3
l_108:		vfd a36/so  ,36/i_s,36/(nonumid-l_org)/5,36/(can1-l_org)/5,36/a_105
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_192
	close:	vfd a36/so  ,36/i_r,36/r_close,36/(l_109-l_org)/5,36/a_318
l_109:		vfd a36/ o  ,36/i_c,36/c_nsfilnm,36/(l_110-l_org)/5,36/a_180
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
l_110:		vfd a36/    ,36/i_n,36/0,36/(l_111-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/0,36/(clos_ss1-l_org)/5,36/a_319
		vfd a36/s2  ,36/i_n,36/196,36/(clos_ri1-l_org)/5,36/17
		vfd a36/s4  ,36/i_n,36/196,36/(clos_ri1-l_org)/5,36/19
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/s5  ,36/i_n,36/196,36/(clos_ss1-l_org)/5,36/25
l_111:	clos_ss1:	vfd a36/s   ,36/i_r,36/r_reel,36/(clos_ss4-l_org)/5,36/a_4
		vfd a36/s   ,36/i_r,36/r_unit,36/(clos_ss4-l_org)/5,36/a_4
		vfd a36/s   ,36/i_r,36/r_with,36/(clos_ss9-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_no,36/(clos_ss8-l_org)/5,36/a_20
		vfd a36/    ,36/i_r,36/r_lock,36/(cl_lock-l_org)/5,36/a_14
	clos_ss2:	vfd a36/    ,36/i_c,36/c_nsfilnm,36/(l_112-l_org)/5,36/a_106
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
l_112:		vfd a36/    ,36/i_n,36/0,36/(l_113-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/ 3  ,36/i_n,36/41,36/(clos_ss3-l_org)/5,36/16
		vfd a36/    ,36/i_n,36/0,36/(clos_ri3-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(clos_ri3-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(clos_ss3-l_org)/5,36/0
l_113:	clos_ss3:	vfd a36/so  ,36/i_n,36/0,36/(clos_ss1-l_org)/5,36/a_180
	clos_ss4:	vfd a36/s   ,36/i_r,36/r_with,36/(clos_ss7-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_for,36/(clos_ss6-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_no,36/(clos_ss8-l_org)/5,36/a_20
		vfd a36/    ,36/i_r,36/r_removal,36/(cl_rem-l_org)/5,36/a_121
		vfd a36/    ,36/i_n,36/0,36/(clos_ss2-l_org)/5,36/0
	cl_rew:	vfd a36/s3  ,36/i_n,36/50,36/(clos_ss2-l_org)/5,36/16
	cl_rem:	vfd a36/s3  ,36/i_n,36/51,36/(clos_ss2-l_org)/5,36/16
	cl_lock:	vfd a36/s3  ,36/i_n,36/52,36/(clos_ss2-l_org)/5,36/16
	clos_ss6:	vfd a36/    ,36/i_r,36/r_removal,36/(cl_rem-l_org)/5,36/a_121
		vfd a36/    ,36/i_n,36/190,36/(rtwo-l_org)/5,36/0
	clos_ss7:	vfd a36/s   ,36/i_r,36/r_no,36/(l_114-l_org)/5,36/a_20
		vfd a36/    ,36/i_n,36/157,36/(rtwo-l_org)/5,36/0
l_114:	clos_ss8:	vfd a36/    ,36/i_r,36/r_rewind,36/(cl_rew-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/158,36/(rtwo-l_org)/5,36/0
	clos_ss9:	vfd a36/s   ,36/i_r,36/r_no,36/(clos_ss8-l_org)/5,36/a_20
		vfd a36/    ,36/i_r,36/r_lock,36/(cl_lock-l_org)/5,36/a_14
	clos_ri1:	vfd a36/s   ,36/i_r,36/r_with,36/(l_115-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_lock,36/(clos_ri2-l_org)/5,36/a_14
		vfd a36/    ,36/i_n,36/0,36/(clos_ri2-l_org)/5,36/0
l_115:		vfd a36/s   ,36/i_r,36/r_lock,36/(l_116-l_org)/5,36/a_14
		vfd a36/    ,36/i_n,36/144,36/(rtwo-l_org)/5,36/0
l_116:	clos_ri2:	vfd a36/    ,36/i_c,36/c_nsfilnm,36/(l_117-l_org)/5,36/a_106
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
l_117:		vfd a36/    ,36/i_n,36/0,36/(l_118-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/ 3  ,36/i_n,36/41,36/(clos_ss3-l_org)/5,36/16
		vfd a36/    ,36/i_n,36/0,36/(clos_ri3-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(clos_ri3-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(clos_ss3-l_org)/5,36/0
l_118:	clos_ri3:	vfd a36/ o  ,36/i_n,36/0,36/(l_119-l_org)/5,36/a_180
l_119:		vfd a36/    ,36/i_n,36/0,36/(l_120-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/0,36/(clos_ri1-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/0,36/(clos_ri1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
l_120:	compute:	vfd a36/ o  ,36/i_r,36/r_compute,36/(l_121-l_org)/5,36/a_27
l_121:		vfd a36/s3  ,36/i_n,36/20,36/(l_122-l_org)/5,36/2
l_122:		vfd a36/s   ,36/i_s,36/(edalel-l_org)/5,36/(l_123-l_org)/5,36/a_45
		vfd a36/    ,36/i_n,36/026,36/(rtwo-l_org)/5,36/0
l_123:	com1:	vfd a36/s   ,36/i_r,36/r_rounded,36/(l_124-l_org)/5,36/a_267
		vfd a36/    ,36/i_n,36/0,36/(l_124-l_org)/5,36/a_268
l_124:		vfd a36/s   ,36/i_s,36/(edalel-l_org)/5,36/(com1-l_org)/5,36/a_45
		vfd a36/s   ,36/i_r,36/r_from,36/(l_125-l_org)/5,36/a_90
		vfd a36/s   ,36/i_r,36/r_eq,36/(l_125-l_org)/5,36/a_90
		vfd a36/    ,36/i_n,36/033,36/(rtwo-l_org)/5,36/0
l_125:		vfd a36/    ,36/i_s,36/(arithexp-l_org)/5,36/(l_126-l_org)/5,36/a_108
		vfd a36/    ,36/i_n,36/159,36/(rtwo-l_org)/5,36/0
l_126:		vfd a36/    ,36/i_s,36/(nos-l_org)/5,36/(com2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_127-l_org)/5,36/a_3
l_127:		vfd a36/s   ,36/i_r,36/r_end_compute,36/(verb1-l_org)/5,36/a_312
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/0
	com2:	vfd a36/    ,36/i_s,36/(osi-l_org)/5,36/(l_128-l_org)/5,36/0
l_128:		vfd a36/s   ,36/i_r,36/r_end_compute,36/(verb1-l_org)/5,36/a_266
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_310
	disable:	vfd a36/ o  ,36/i_r,36/r_disable,36/(l_129-l_org)/5,36/a_87
l_129:		vfd a36/s3  ,36/i_n,36/71,36/(l_130-l_org)/5,36/23
l_130:	dis_3:	vfd a36/s   ,36/i_r,36/r_input,36/(l_131-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_output,36/(dis_1-l_org)/5,36/a_4
		vfd a36/    ,36/i_n,36/034,36/(rtwo-l_org)/5,36/0
l_131:		vfd a36/    ,36/i_r,36/r_terminal,36/(dis_4-l_org)/5,36/a_20
	dis_5:	vfd a36/so  ,36/i_c,36/c_incdnm,36/(dis_2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/036,36/(rtwo-l_org)/5,36/0
	dis_1:	vfd a36/so  ,36/i_c,36/c_outcdnm,36/(l_132-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/035,36/(rtwo-l_org)/5,36/0
l_132:	dis_2:	vfd a36/s   ,36/i_r,36/r_with,36/(l_133-l_org)/5,36/0
l_133:		vfd a36/s   ,36/i_r,36/r_key,36/(l_134-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/037,36/(rtwo-l_org)/5,36/0
l_134:		vfd a36/so  ,36/i_s,36/(nonumid-l_org)/5,36/(l_135-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/038,36/(rtwo-l_org)/5,36/0
l_135:		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
	dis_4:	vfd a36/s3  ,36/i_n,36/72,36/(dis_5-l_org)/5,36/24
	display:	vfd a36/so  ,36/i_r,36/r_display,36/(l_136-l_org)/5,36/a_87
l_136:		vfd a36/so  ,36/i_s,36/(ident-l_org)/5,36/(disp3-l_org)/5,36/a_8
		vfd a36/so  ,36/i_c,36/c_lit,36/(disp3-l_org)/5,36/a_8
		vfd a36/so  ,36/i_c,36/c_figconall,36/(disp3-l_org)/5,36/a_8
		vfd a36/s   ,36/i_c,36/c_xnm,36/(l_137-l_org)/5,36/0
		vfd a36/s   ,36/i_s,36/(xdname-l_org)/5,36/(l_137-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/039,36/(rtwo-l_org)/5,36/0
l_137:	disp5:	vfd a36/    ,36/i_n,36/268,36/(rtwo-l_org)/5,36/0
	disp3:	vfd a36/s3  ,36/i_r,36/r_upon,36/(disp4-l_org)/5,36/25
		vfd a36/so  ,36/i_s,36/(ident-l_org)/5,36/(disp3-l_org)/5,36/a_8
		vfd a36/so  ,36/i_c,36/c_lit,36/(disp3-l_org)/5,36/a_8
		vfd a36/so  ,36/i_c,36/c_figconall,36/(disp3-l_org)/5,36/a_8
		vfd a36/s   ,36/i_c,36/c_xnm,36/(disp5-l_org)/5,36/0
		vfd a36/s   ,36/i_s,36/(xdname-l_org)/5,36/(disp5-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_249
	disp4:	vfd a36/    ,36/i_c,36/c_disp_dev,36/(disp1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/040,36/(rtwo-l_org)/5,36/0
	disp1:	vfd a36/s   ,36/i_c,36/c_disp_dev,36/(disp2-l_org)/5,36/a_163
		vfd a36/    ,36/i_n,36/224,36/(rtwo-l_org)/5,36/0
	disp2:	vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
	divide:	vfd a36/so  ,36/i_r,36/r_divide,36/(l_138-l_org)/5,36/a_27
l_138:		vfd a36/so  ,36/i_s,36/(elnuitem-l_org)/5,36/(l_139-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/024,36/(rtwo-l_org)/5,36/0
l_139:		vfd a36/s   ,36/i_r,36/r_into,36/(l_140-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_by,36/(div2-l_org)/5,36/a_24
		vfd a36/    ,36/i_n,36/041,36/(rtwo-l_org)/5,36/0
l_140:		vfd a36/so  ,36/i_c,36/c_nlit,36/(div8-l_org)/5,36/a_21
		vfd a36/s   ,36/i_s,36/(elnuitem-l_org)/5,36/(l_141-l_org)/5,36/a_45
		vfd a36/    ,36/i_n,36/024,36/(rtwo-l_org)/5,36/0
l_141:		vfd a36/s   ,36/i_r,36/r_giving,36/(div9-l_org)/5,36/a_75
l_142:		vfd a36/    ,36/i_c,36/c_csstst,36/(l_143-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_143-l_org)/5,36/a_278
l_143:	div1:	vfd a36/s   ,36/i_r,36/r_rounded,36/(l_144-l_org)/5,36/a_267
		vfd a36/    ,36/i_n,36/0,36/(l_144-l_org)/5,36/a_268
l_144:		vfd a36/    ,36/i_s,36/(alel-l_org)/5,36/(div14-l_org)/5,36/a_271
	div5:	vfd a36/    ,36/i_s,36/(nos-l_org)/5,36/(div10-l_org)/5,36/a_87
		vfd a36/    ,36/i_n,36/0,36/(l_145-l_org)/5,36/a_3
l_145:		vfd a36/s   ,36/i_r,36/r_end_divide,36/(verb1-l_org)/5,36/a_312
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/0
	div10:	vfd a36/    ,36/i_s,36/(osi-l_org)/5,36/(l_146-l_org)/5,36/0
l_146:		vfd a36/s   ,36/i_r,36/r_end_divide,36/(verb1-l_org)/5,36/a_266
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_310
	div14:	vfd a36/s3  ,36/i_n,36/23,36/(div1-l_org)/5,36/2
	div6:	vfd a36/s   ,36/i_r,36/r_rounded,36/(l_147-l_org)/5,36/a_35
l_147:		vfd a36/    ,36/i_r,36/r_remainder,36/(div13-l_org)/5,36/a_48
		vfd a36/    ,36/i_n,36/0,36/(l_148-l_org)/5,36/a_268
l_148:	div7:	vfd a36/    ,36/i_s,36/(edalel-l_org)/5,36/(div15-l_org)/5,36/a_269
		vfd a36/    ,36/i_n,36/0,36/(div5-l_org)/5,36/0
	div2:	vfd a36/so  ,36/i_s,36/(elnuitem-l_org)/5,36/(l_149-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/24,36/(rtwo-l_org)/5,36/0
l_149:	div8:	vfd a36/s   ,36/i_r,36/r_giving,36/(l_150-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/058,36/(rtwo-l_org)/5,36/0
l_150:	div9:	vfd a36/s   ,36/i_s,36/(edalel-l_org)/5,36/(div6-l_org)/5,36/a_29
		vfd a36/    ,36/i_n,36/026,36/(rtwo-l_org)/5,36/0
	div13:	vfd a36/s3  ,36/i_n,36/26,36/(l_151-l_org)/5,36/2
l_151:		vfd a36/so  ,36/i_s,36/(edalel-l_org)/5,36/(div5-l_org)/5,36/a_45
		vfd a36/    ,36/i_n,36/026,36/(rtwo-l_org)/5,36/0
	div15:	vfd a36/s3  ,36/i_n,36/23,36/(l_152-l_org)/5,36/2
l_152:		vfd a36/s   ,36/i_r,36/r_rounded,36/(div7-l_org)/5,36/a_267
		vfd a36/    ,36/i_n,36/0,36/(div7-l_org)/5,36/a_268
	enable:	vfd a36/ o  ,36/i_r,36/r_enable,36/(l_153-l_org)/5,36/a_87
l_153:		vfd a36/s3  ,36/i_n,36/73,36/(dis_3-l_org)/5,36/23
	enter:	vfd a36/so  ,36/i_r,36/r_enter,36/(l_154-l_org)/5,36/a_87
l_154:		vfd a36/s   ,36/i_r,36/r_cobol,36/(verb1-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_nonumlit,36/(l_155-l_org)/5,36/a_38
l_155:		vfd a36/    ,36/i_c,36/c_is_lang,36/(l_156-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/276,36/(rtwo-l_org)/5,36/0
l_156:		vfd a36/s   ,36/i_c,36/c_is_cobol,36/(verb1-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/0,36/(l_157-l_org)/5,36/0
l_157:		vfd a36/so  ,36/i_c,36/c_nonumlit,36/(l_158-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_is_rout,36/(l_158-l_org)/5,36/a_38
		vfd a36/    ,36/i_n,36/278,36/(rtwo-l_org)/5,36/0
l_158:		vfd a36/    ,36/i_n,36/0,36/(l_159-l_org)/5,36/a_23
l_159:	exit:	vfd a36/    ,36/i_c,36/c_preospn,36/(l_160-l_org)/5,36/a_155
		vfd a36/    ,36/i_n,36/0,36/(l_160-l_org)/5,36/a_154
l_160:		vfd a36/so  ,36/i_r,36/r_exit,36/(l_161-l_org)/5,36/a_318
l_161:		vfd a36/    ,36/i_r,36/r_program,36/(exit1-l_org)/5,36/a_194
l_162:		vfd a36/    ,36/i_n,36/0,36/(l_163-l_org)/5,36/a_319
l_163:		vfd a36/    ,36/i_c,36/c_ckprpnbit,36/(verb1-l_org)/5,36/a_3
		vfd a36/    ,36/i_c,36/c_debug,36/(verb1-l_org)/5,36/a_3
		vfd a36/    ,36/i_n,36/146,36/(rtwo-l_org)/5,36/0
	exit1:	vfd a36/s2  ,36/i_n,36/69,36/(verb1-l_org)/5,36/13
	evaluate:	vfd a36/s   ,36/i_r,36/r_evaluate,36/(l_164-l_org)/5,36/a_50
l_164:		vfd a36/    ,36/i_s,36/(selsub-l_org)/5,36/(l_165-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/300,36/(rtwo-l_org)/5,36/0
l_165:	ev1:	vfd a36/s   ,36/i_r,36/r_also,36/(l_166-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(ev2-l_org)/5,36/0
l_166:		vfd a36/    ,36/i_s,36/(selsub-l_org)/5,36/(ev1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/300,36/(rtwo-l_org)/5,36/0
	ev2:	vfd a36/s   ,36/i_r,36/r_when,36/(l_167-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/300,36/(rtwo-l_org)/5,36/0
l_167:	ev3:	vfd a36/    ,36/i_s,36/(selobj-l_org)/5,36/(l_168-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/300,36/(rtwo-l_org)/5,36/0
l_168:		vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(l_169-l_org)/5,36/0
l_169:		vfd a36/s   ,36/i_r,36/r_when,36/(l_170-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(ev5-l_org)/5,36/0
l_170:		vfd a36/s   ,36/i_r,36/r_other,36/(l_171-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(ev3-l_org)/5,36/0
l_171:		vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(l_172-l_org)/5,36/0
l_172:	ev5:	vfd a36/s   ,36/i_r,36/r_end_evaluate,36/(verb1-l_org)/5,36/a_266
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_310
	selsub:	vfd a36/    ,36/i_s,36/(expr-l_org)/5,36/(l_173-l_org)/5,36/0
		vfd a36/s   ,36/i_s,36/(ident-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/s   ,36/i_c,36/c_lit,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_173:		vfd a36/    ,36/i_c,36/c_is_cond,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	selobj:	vfd a36/    ,36/i_s,36/(objt-l_org)/5,36/(l_174-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/300,36/(rtwo-l_org)/5,36/0
l_174:	so1:	vfd a36/s   ,36/i_r,36/r_also,36/(l_175-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
l_175:		vfd a36/    ,36/i_s,36/(objt-l_org)/5,36/(so1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/300,36/(rtwo-l_org)/5,36/0
	objt:	vfd a36/    ,36/i_r,36/r_any,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(condition-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(range-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	range:	vfd a36/s   ,36/i_r,36/r_not,36/(l_176-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(rt-l_org)/5,36/(rg1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_176:		vfd a36/    ,36/i_s,36/(rt-l_org)/5,36/(l_177-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/300,36/(rtwo-l_org)/5,36/0
l_177:	rg1:	vfd a36/s   ,36/i_r,36/r_thru,36/(l_178-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
l_178:		vfd a36/    ,36/i_s,36/(rt-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/300,36/(rtwo-l_org)/5,36/0
	rt:	vfd a36/    ,36/i_s,36/(arithexp-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/s   ,36/i_s,36/(ident-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/s   ,36/i_c,36/c_lit,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	generate:	vfd a36/s   ,36/i_r,36/r_generate,36/(l_179-l_org)/5,36/a_87
l_179:		vfd a36/    ,36/i_s,36/(rep_nam-l_org)/5,36/(verb1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/43,36/(rtwo-l_org)/5,36/0
	go:	vfd a36/s   ,36/i_c,36/c_gotod,36/(gotod-l_org)/5,36/a_148
		vfd a36/    ,36/i_c,36/c_preospn,36/(l_180-l_org)/5,36/0
		vfd a36/so  ,36/i_r,36/r_go,36/(go5-l_org)/5,36/a_87
l_180:		vfd a36/so  ,36/i_r,36/r_go,36/(l_181-l_org)/5,36/a_87
l_181:		vfd a36/s   ,36/i_r,36/r_to,36/(l_182-l_org)/5,36/0
l_182:		vfd a36/    ,36/i_c,36/c_prnm,36/(go1-l_org)/5,36/a_8
		vfd a36/    ,36/i_n,36/0,36/(l_183-l_org)/5,36/a_192
l_183:		vfd a36/ 3  ,36/i_n,36/27,36/(verb1-l_org)/5,36/2
	go4:	vfd a36/    ,36/i_c,36/c_prnm,36/(go2-l_org)/5,36/a_8
	go3:	vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_193
	go5:	vfd a36/s   ,36/i_r,36/r_to,36/(l_184-l_org)/5,36/0
l_184:		vfd a36/    ,36/i_c,36/c_prnm,36/(go1-l_org)/5,36/a_8
		vfd a36/    ,36/i_n,36/062,36/(rtwo-l_org)/5,36/0
	gotod:	vfd a36/s   ,36/i_r,36/r_depending,36/(go6-l_org)/5,36/a_21
		vfd a36/    ,36/i_c,36/c_prnm,36/(go2-l_org)/5,36/a_8
		vfd a36/    ,36/i_n,36/044,36/(rtwo-l_org)/5,36/0
	go1:	vfd a36/    ,36/i_n,36/0,36/(l_185-l_org)/5,36/a_272
l_185:		vfd a36/so  ,36/i_c,36/c_decnondec,36/(go4-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/188,36/(rtwo-l_org)/5,36/0
	go2:	vfd a36/    ,36/i_n,36/0,36/(l_186-l_org)/5,36/a_272
l_186:		vfd a36/so  ,36/i_c,36/c_decnondec,36/(gotod-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/188,36/(rtwo-l_org)/5,36/0
	go6:	vfd a36/s   ,36/i_r,36/r_on,36/(l_187-l_org)/5,36/0
l_187:		vfd a36/so  ,36/i_s,36/(elnuitem-l_org)/5,36/(go3-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/045,36/(rtwo-l_org)/5,36/0
	hold:	vfd a36/ o  ,36/i_r,36/r_hold,36/(l_188-l_org)/5,36/a_87
l_188:		vfd a36/s5  ,36/i_n,36/86,36/(l_189-l_org)/5,36/25
l_189:		vfd a36/s   ,36/i_r,36/r_all,36/(verb1-l_org)/5,36/a_3
		vfd a36/so  ,36/i_c,36/c_descnm,36/(l_190-l_org)/5,36/a_8
		vfd a36/    ,36/i_n,36/046,36/(rtwo-l_org)/5,36/0
l_190:		vfd a36/so  ,36/i_c,36/c_descnm,36/(l_190-l_org)/5,36/a_8
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_37
	if:	vfd a36/so  ,36/i_r,36/r_if,36/(l_191-l_org)/5,36/a_283
l_191:		vfd a36/    ,36/i_n,36/0,36/(l_192-l_org)/5,36/a_306
l_192:		vfd a36/    ,36/i_s,36/(condition-l_org)/5,36/(l_193-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/217,36/(rtwo-l_org)/5,36/0
l_193:		vfd a36/s   ,36/i_r,36/r_then,36/(l_194-l_org)/5,36/0
l_194:		vfd a36/    ,36/i_s,36/(ns-l_org)/5,36/(if3-l_org)/5,36/a_244
		vfd a36/    ,36/i_n,36/0,36/(l_195-l_org)/5,36/a_237
l_195:		vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(l_196-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/212,36/(rtwo-l_org)/5,36/0
l_196:		vfd a36/s   ,36/i_r,36/r_else,36/(if2-l_org)/5,36/a_239
	if1:	vfd a36/s   ,36/i_r,36/r_end_if,36/(verb1-l_org)/5,36/a_334
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/0
	if2:	vfd a36/    ,36/i_s,36/(ns-l_org)/5,36/(if1-l_org)/5,36/a_313
		vfd a36/    ,36/i_n,36/0,36/(l_197-l_org)/5,36/a_238
l_197:		vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(if1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/212,36/(rtwo-l_org)/5,36/0
	if3:	vfd a36/s   ,36/i_r,36/r_else,36/(l_198-l_org)/5,36/a_308
		vfd a36/    ,36/i_n,36/0,36/(if1-l_org)/5,36/a_240
l_198:		vfd a36/    ,36/i_s,36/(ns-l_org)/5,36/(if1-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(if1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/212,36/(rtwo-l_org)/5,36/0
	ns:	vfd a36/s   ,36/i_r,36/r_next,36/(l_199-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_199:		vfd a36/s   ,36/i_r,36/r_sentence,36/(succ-l_org)/5,36/a_333
		vfd a36/    ,36/i_n,36/216,36/(rtwo-l_org)/5,36/0
	initiate:	vfd a36/    ,36/i_r,36/r_initiate,36/(l_200-l_org)/5,36/a_87
l_200:		vfd a36/s4  ,36/i_n,36/87,36/(l_201-l_org)/5,36/21
l_201:	init_1:	vfd a36/    ,36/i_s,36/(rep_nam-l_org)/5,36/(l_202-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/47,36/(rtwo-l_org)/5,36/0
l_202:		vfd a36/    ,36/i_s,36/(rep_nam-l_org)/5,36/(l_202-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/0
	inspect:	vfd a36/so  ,36/i_r,36/r_inspect,36/(l_203-l_org)/5,36/a_87
l_203:		vfd a36/so  ,36/i_s,36/(usagid-l_org)/5,36/(l_204-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/048,36/(rtwo-l_org)/5,36/0
l_204:		vfd a36/so  ,36/i_r,36/r_tallying,36/(l_205-l_org)/5,36/a_8
		vfd a36/so  ,36/i_r,36/r_replacing,36/(ins7-l_org)/5,36/a_47
		vfd a36/    ,36/i_n,36/049,36/(rtwo-l_org)/5,36/0
l_205:		vfd a36/so  ,36/i_s,36/(alel-l_org)/5,36/(l_206-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/024,36/(rtwo-l_org)/5,36/0
l_206:	ins1:	vfd a36/s   ,36/i_r,36/r_for,36/(l_207-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/050,36/(rtwo-l_org)/5,36/0
l_207:		vfd a36/so  ,36/i_r,36/r_all,36/(l_208-l_org)/5,36/0
		vfd a36/so  ,36/i_r,36/r_leading,36/(l_208-l_org)/5,36/0
		vfd a36/so  ,36/i_r,36/r_characters,36/(ins3-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/051,36/(rtwo-l_org)/5,36/0
l_208:	ins2:	vfd a36/so  ,36/i_s,36/(elusid-l_org)/5,36/(l_209-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/052,36/(rtwo-l_org)/5,36/0
l_209:	ins3:	vfd a36/so  ,36/i_r,36/r_before,36/(l_210-l_org)/5,36/0
		vfd a36/so  ,36/i_r,36/r_after,36/(l_210-l_org)/5,36/a_4
		vfd a36/    ,36/i_n,36/0,36/(ins4-l_org)/5,36/0
l_210:		vfd a36/s   ,36/i_r,36/r_initial,36/(l_211-l_org)/5,36/0
l_211:		vfd a36/so  ,36/i_s,36/(elusid-l_org)/5,36/(l_212-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/231,36/(rtwo-l_org)/5,36/0
l_212:	ins4:	vfd a36/    ,36/i_c,36/c_edalit,36/(l_213-l_org)/5,36/0
		vfd a36/ o  ,36/i_r,36/r_all,36/(ins12-l_org)/5,36/a_8
		vfd a36/ o  ,36/i_r,36/r_leading,36/(ins12-l_org)/5,36/a_8
		vfd a36/so  ,36/i_r,36/r_characters,36/(ins3-l_org)/5,36/a_8
		vfd a36/so  ,36/i_r,36/r_replacing,36/(ins7-l_org)/5,36/a_22
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
l_213:		vfd a36/ o  ,36/i_s,36/(alelnuit-l_org)/5,36/(l_214-l_org)/5,36/a_8
		vfd a36/    ,36/i_n,36/101,36/(rtwo-l_org)/5,36/0
l_214:		vfd a36/s3  ,36/i_n,36/54,36/(ins1-l_org)/5,36/2
	ins12:	vfd a36/s3  ,36/i_n,36/53,36/(ins2-l_org)/5,36/2
	ins7:	vfd a36/so  ,36/i_r,36/r_all,36/(l_215-l_org)/5,36/0
		vfd a36/so  ,36/i_r,36/r_leading,36/(l_215-l_org)/5,36/0
		vfd a36/so  ,36/i_r,36/r_first,36/(l_215-l_org)/5,36/0
		vfd a36/so  ,36/i_r,36/r_characters,36/(ins9-l_org)/5,36/a_28
		vfd a36/    ,36/i_n,36/053,36/(rtwo-l_org)/5,36/0
l_215:	ins8:	vfd a36/so  ,36/i_s,36/(elusid-l_org)/5,36/(l_216-l_org)/5,36/a_28
		vfd a36/    ,36/i_n,36/052,36/(rtwo-l_org)/5,36/0
l_216:	ins14:	vfd a36/s   ,36/i_r,36/r_by,36/(l_217-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/054,36/(rtwo-l_org)/5,36/0
l_217:		vfd a36/    ,36/i_s,36/(elusid-l_org)/5,36/(l_218-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/052,36/(rtwo-l_org)/5,36/0
l_218:		vfd a36/so  ,36/i_c,36/c_sizlit,36/(l_219-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/056,36/(rtwo-l_org)/5,36/0
l_219:		vfd a36/so  ,36/i_r,36/r_before,36/(l_220-l_org)/5,36/0
		vfd a36/so  ,36/i_r,36/r_after,36/(l_220-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(ins10-l_org)/5,36/0
l_220:		vfd a36/s   ,36/i_r,36/r_initial,36/(l_221-l_org)/5,36/0
l_221:		vfd a36/so  ,36/i_s,36/(elusid-l_org)/5,36/(ins10-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/052,36/(rtwo-l_org)/5,36/0
	ins9:	vfd a36/s   ,36/i_r,36/r_by,36/(l_222-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/054,36/(rtwo-l_org)/5,36/0
l_222:		vfd a36/    ,36/i_s,36/(elusid-l_org)/5,36/(l_223-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/052,36/(rtwo-l_org)/5,36/0
l_223:		vfd a36/so  ,36/i_c,36/c_sizlit,36/(l_224-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/056,36/(rtwo-l_org)/5,36/0
l_224:		vfd a36/so  ,36/i_r,36/r_before,36/(l_225-l_org)/5,36/0
		vfd a36/so  ,36/i_r,36/r_after,36/(l_225-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
l_225:		vfd a36/s   ,36/i_r,36/r_initial,36/(l_226-l_org)/5,36/0
l_226:		vfd a36/so  ,36/i_s,36/(elusid-l_org)/5,36/(l_227-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/052,36/(rtwo-l_org)/5,36/0
l_227:		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
	ins10:	vfd a36/ o  ,36/i_r,36/r_all,36/(ins13-l_org)/5,36/a_78
		vfd a36/ o  ,36/i_r,36/r_leading,36/(ins13-l_org)/5,36/a_78
		vfd a36/ o  ,36/i_r,36/r_first,36/(ins13-l_org)/5,36/a_78
		vfd a36/ o  ,36/i_s,36/(elusid-l_org)/5,36/(l_228-l_org)/5,36/a_28
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
l_228:		vfd a36/s3  ,36/i_n,36/114,36/(l_229-l_org)/5,36/2
l_229:		vfd a36/    ,36/i_n,36/0,36/(ins14-l_org)/5,36/a_78
	ins13:	vfd a36/s3  ,36/i_n,36/55,36/(ins8-l_org)/5,36/2
	merge:	vfd a36/ o  ,36/i_r,36/r_merge,36/(l_230-l_org)/5,36/a_87
l_230:		vfd a36/s4  ,36/i_n,36/59,36/(l_231-l_org)/5,36/6
l_231:		vfd a36/so  ,36/i_c,36/c_srtfil,36/(l_232-l_org)/5,36/a_188
		vfd a36/    ,36/i_n,36/090,36/(rtwo-l_org)/5,36/0
l_232:		vfd a36/s   ,36/i_r,36/r_on,36/(l_233-l_org)/5,36/0
l_233:	merge_8:	vfd a36/s   ,36/i_r,36/r_ascending,36/(l_234-l_org)/5,36/a_4
		vfd a36/s   ,36/i_r,36/r_descending,36/(l_234-l_org)/5,36/a_9
		vfd a36/    ,36/i_n,36/091,36/(rtwo-l_org)/5,36/0
l_234:	merge_1:	vfd a36/s   ,36/i_r,36/r_key,36/(l_235-l_org)/5,36/0
l_235:		vfd a36/so  ,36/i_c,36/c_dninfl,36/(l_236-l_org)/5,36/a_74
		vfd a36/    ,36/i_n,36/92,36/(rtwo-l_org)/5,36/0
l_236:	merge_4:	vfd a36/so  ,36/i_c,36/c_dninfl,36/(merge_4-l_org)/5,36/a_74
		vfd a36/s   ,36/i_r,36/r_on,36/(merge_8-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_ascending,36/(merge_1-l_org)/5,36/a_4
		vfd a36/s   ,36/i_r,36/r_descending,36/(merge_1-l_org)/5,36/a_9
		vfd a36/s   ,36/i_r,36/r_collating,36/(mcs_1-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_sequence,36/(mcs_3-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_237-l_org)/5,36/a_156
l_237:	muse:	vfd a36/s   ,36/i_r,36/r_using,36/(l_238-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/275,36/(rtwo-l_org)/5,36/0
l_238:		vfd a36/    ,36/i_c,36/c_filenm,36/(l_239-l_org)/5,36/a_185
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
l_239:		vfd a36/so  ,36/i_c,36/c_seqfil,36/(l_240-l_org)/5,36/0
		vfd a36/s5  ,36/i_n,36/197,36/(l_240-l_org)/5,36/25
l_240:	merge_3:	vfd a36/so  ,36/i_n,36/0,36/(l_241-l_org)/5,36/a_186
l_241:		vfd a36/    ,36/i_c,36/c_filenm,36/(l_242-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_output,36/(merge_7-l_org)/5,36/a_189
		vfd a36/s   ,36/i_r,36/r_giving,36/(merge_2-l_org)/5,36/a_189
		vfd a36/    ,36/i_n,36/094,36/(rtwo-l_org)/5,36/0
l_242:		vfd a36/so  ,36/i_c,36/c_seqfil,36/(merge_3-l_org)/5,36/0
		vfd a36/s5  ,36/i_n,36/197,36/(merge_3-l_org)/5,36/25
	merge_7:	vfd a36/s   ,36/i_r,36/r_procedure,36/(l_243-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/001,36/(rtwo-l_org)/5,36/0
l_243:		vfd a36/s   ,36/i_r,36/r_is,36/(l_244-l_org)/5,36/0
l_244:		vfd a36/    ,36/i_c,36/c_debug,36/(merge_6-l_org)/5,36/0
	merge_5:	vfd a36/s   ,36/i_c,36/c_prnm,36/(l_245-l_org)/5,36/a_165
		vfd a36/    ,36/i_n,36/0,36/(rtwo-l_org)/5,36/a_62
l_245:		vfd a36/s   ,36/i_r,36/r_thru,36/(l_246-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_190
l_246:		vfd a36/s   ,36/i_c,36/c_prnm,36/(verb1-l_org)/5,36/a_40
		vfd a36/    ,36/i_n,36/062,36/(rtwo-l_org)/5,36/0
	merge_2:	vfd a36/    ,36/i_c,36/c_filenm,36/(l_247-l_org)/5,36/a_157
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
l_247:		vfd a36/s   ,36/i_c,36/c_seqfil,36/(l_248-l_org)/5,36/0
		vfd a36/s5  ,36/i_n,36/197,36/(l_248-l_org)/5,36/25
l_248:		vfd a36/s   ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_187
	merge_6:	vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(merge_5-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(merge_5-l_org)/5,36/0
	mcs_1:	vfd a36/s   ,36/i_r,36/r_sequence,36/(l_249-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/266,36/(l_249-l_org)/5,36/0
l_249:	mcs_3:	vfd a36/s   ,36/i_r,36/r_is,36/(l_250-l_org)/5,36/0
l_250:	mcs_2:	vfd a36/so  ,36/i_c,36/c_alphnm,36/(muse-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/267,36/(rtwo-l_org)/5,36/0
	move:	vfd a36/so  ,36/i_r,36/r_move,36/(l_251-l_org)/5,36/a_87
l_251:		vfd a36/so  ,36/i_c,36/c_undana,36/(mov6-l_org)/5,36/a_28
		vfd a36/so  ,36/i_s,36/(ident-l_org)/5,36/(mov6-l_org)/5,36/a_28
	mov4:	vfd a36/so  ,36/i_c,36/c_lit,36/(mov6-l_org)/5,36/a_28
	mov3:	vfd a36/so  ,36/i_c,36/c_figconall,36/(mov6-l_org)/5,36/a_28
		vfd a36/    ,36/i_r,36/r_all,36/(mov2-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_incdnm,36/(mov6-l_org)/5,36/a_28
		vfd a36/so  ,36/i_c,36/c_outcdnm,36/(mov6-l_org)/5,36/a_28
		vfd a36/    ,36/i_c,36/c_xnm,36/(l_252-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/039,36/(rtwo-l_org)/5,36/0
l_252:		vfd a36/    ,36/i_n,36/268,36/(rtwo-l_org)/5,36/0
	mov2:	vfd a36/s3  ,36/i_n,36/144,36/(l_253-l_org)/5,36/2
l_253:		vfd a36/so  ,36/i_c,36/c_figconall,36/(mov6-l_org)/5,36/a_28
		vfd a36/    ,36/i_c,36/c_nonumlit,36/(mov4-l_org)/5,36/a_149
		vfd a36/    ,36/i_n,36/172,36/(rtwo-l_org)/5,36/0
	mov6:	vfd a36/s   ,36/i_r,36/r_to,36/(l_254-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/028,36/(rtwo-l_org)/5,36/0
l_254:		vfd a36/    ,36/i_s,36/(rid-l_org)/5,36/(mov7-l_org)/5,36/a_8
		vfd a36/so  ,36/i_c,36/c_incdnm,36/(mov8-l_org)/5,36/a_8
		vfd a36/so  ,36/i_c,36/c_outcdnm,36/(mov8-l_org)/5,36/a_8
		vfd a36/    ,36/i_c,36/c_xnm,36/(l_255-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/39,36/(rtwo-l_org)/5,36/0
l_255:		vfd a36/    ,36/i_n,36/268,36/(rtwo-l_org)/5,36/0
	mov7:	vfd a36/so  ,36/i_c,36/c_nues,36/(l_256-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_anes,36/(l_256-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_group,36/(mov9-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_an,36/(mov11-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_alph,36/(mov13-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_snal,36/(mov14-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/152,36/(rtwo-l_org)/5,36/0
l_256:	mov8:	vfd a36/    ,36/i_c,36/c_sterm,36/(verb1-l_org)/5,36/a_3
		vfd a36/    ,36/i_s,36/(rid-l_org)/5,36/(mov7-l_org)/5,36/a_8
		vfd a36/so  ,36/i_c,36/c_incdnm,36/(mov8-l_org)/5,36/a_8
		vfd a36/so  ,36/i_c,36/c_outcdnm,36/(mov8-l_org)/5,36/a_8
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
	mov9:	vfd a36/    ,36/i_c,36/c_sler,36/(mov10-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_njustr,36/(mov1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/156,36/(mov10-l_org)/5,36/0
	mov1:	vfd a36/    ,36/i_n,36/148,36/(l_257-l_org)/5,36/0
l_257:	mov10:	vfd a36/so  ,36/i_c,36/c_snor,36/(mov8-l_org)/5,36/0
		vfd a36/so  ,36/i_n,36/147,36/(mov8-l_org)/5,36/a_137
	mov11:	vfd a36/    ,36/i_c,36/c_sndrdp,36/(l_258-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/149,36/(rtwo-l_org)/5,36/0
l_258:		vfd a36/    ,36/i_c,36/c_snos,36/(mov9-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/150,36/(mov9-l_org)/5,36/0
	mov13:	vfd a36/    ,36/i_c,36/c_snon,36/(mov9-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(rtwo-l_org)/5,36/0
	mov14:	vfd a36/    ,36/i_c,36/c_snae,36/(l_259-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_rae,36/(mov9-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/153,36/(rtwo-l_org)/5,36/0
l_259:		vfd a36/    ,36/i_c,36/c_snne,36/(l_260-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_rae,36/(mov9-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/154,36/(rtwo-l_org)/5,36/0
l_260:		vfd a36/    ,36/i_c,36/c_san,36/(l_261-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_rae,36/(mov9-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_ritdep,36/(mov18-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/155,36/(mov18-l_org)/5,36/0
l_261:		vfd a36/    ,36/i_c,36/c_rae,36/(mov9-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_slelef,36/(mov10-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/156,36/(mov10-l_org)/5,36/0
	mov18:	vfd a36/    ,36/i_c,36/c_lefdep,36/(l_262-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/156,36/(l_262-l_org)/5,36/0
l_262:		vfd a36/    ,36/i_c,36/c_stun,36/(l_263-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(mov10-l_org)/5,36/0
l_263:		vfd a36/    ,36/i_n,36/150,36/(mov10-l_org)/5,36/0
	multiply:	vfd a36/so  ,36/i_r,36/r_multiply,36/(l_264-l_org)/5,36/a_27
l_264:		vfd a36/so  ,36/i_s,36/(elnuitem-l_org)/5,36/(l_265-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/024,36/(rtwo-l_org)/5,36/0
l_265:		vfd a36/s   ,36/i_r,36/r_by,36/(l_266-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/054,36/(rtwo-l_org)/5,36/0
l_266:		vfd a36/    ,36/i_c,36/c_altst,36/(mul3-l_org)/5,36/0
l_267:		vfd a36/so  ,36/i_s,36/(elnuitem-l_org)/5,36/(mul5-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/024,36/(rtwo-l_org)/5,36/0
	mul3:	vfd a36/s   ,36/i_s,36/(ident-l_org)/5,36/(l_268-l_org)/5,36/a_45
l_268:		vfd a36/s   ,36/i_r,36/r_giving,36/(mul6-l_org)/5,36/a_75
		vfd a36/    ,36/i_c,36/c_csstst,36/(l_269-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_269-l_org)/5,36/a_278
l_269:	mul4:	vfd a36/s   ,36/i_r,36/r_rounded,36/(l_270-l_org)/5,36/a_267
		vfd a36/    ,36/i_n,36/0,36/(l_270-l_org)/5,36/a_268
l_270:		vfd a36/    ,36/i_s,36/(alel-l_org)/5,36/(mul9-l_org)/5,36/a_271
	mul1:	vfd a36/    ,36/i_s,36/(nos-l_org)/5,36/(mul7-l_org)/5,36/a_87
		vfd a36/    ,36/i_n,36/0,36/(l_271-l_org)/5,36/a_3
l_271:		vfd a36/s   ,36/i_r,36/r_end_multiply,36/(verb1-l_org)/5,36/a_312
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/0
	mul7:	vfd a36/    ,36/i_s,36/(osi-l_org)/5,36/(l_272-l_org)/5,36/0
l_272:		vfd a36/s   ,36/i_r,36/r_end_multiply,36/(verb1-l_org)/5,36/a_266
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_310
	mul9:	vfd a36/s3  ,36/i_n,36/23,36/(mul4-l_org)/5,36/2
	mul5:	vfd a36/s   ,36/i_r,36/r_giving,36/(l_273-l_org)/5,36/a_21
		vfd a36/    ,36/i_n,36/058,36/(rtwo-l_org)/5,36/0
l_273:	mul6:	vfd a36/s   ,36/i_s,36/(edalel-l_org)/5,36/(mul8-l_org)/5,36/a_34
		vfd a36/    ,36/i_n,36/026,36/(rtwo-l_org)/5,36/0
	mul8:	vfd a36/s   ,36/i_r,36/r_rounded,36/(l_274-l_org)/5,36/a_267
		vfd a36/    ,36/i_n,36/0,36/(l_274-l_org)/5,36/a_268
l_274:		vfd a36/    ,36/i_s,36/(edalel-l_org)/5,36/(l_275-l_org)/5,36/a_269
		vfd a36/    ,36/i_n,36/0,36/(mul1-l_org)/5,36/0
l_275:		vfd a36/s3  ,36/i_n,36/23,36/(mul8-l_org)/5,36/2
	open:	vfd a36/so  ,36/i_r,36/r_open,36/(l_276-l_org)/5,36/a_318
l_276:		vfd a36/s   ,36/i_c,36/c_open_mode,36/(l_277-l_org)/5,36/a_10
		vfd a36/    ,36/i_n,36/059,36/(rtwo-l_org)/5,36/0
l_277:		vfd a36/    ,36/i_c,36/c_filenm,36/(l_278-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(open_ss1-l_org)/5,36/a_319
		vfd a36/ 2  ,36/i_n,36/195,36/(open_ri1-l_org)/5,36/17
		vfd a36/ 4  ,36/i_n,36/195,36/(open_ri1-l_org)/5,36/19
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/ 5  ,36/i_n,36/195,36/(open_ss1-l_org)/5,36/25
l_278:	open_ss1:	vfd a36/    ,36/i_n,36/0,36/(l_279-l_org)/5,36/a_263
l_279:		vfd a36/    ,36/i_n,36/0,36/(l_280-l_org)/5,36/a_11
		vfd a36/    ,36/i_n,36/32,36/(rtwo-l_org)/5,36/0
		vfd a36/so  ,36/i_n,36/0,36/(open_ssi-l_org)/5,36/0
		vfd a36/so  ,36/i_n,36/0,36/(open_sso-l_org)/5,36/0
		vfd a36/so  ,36/i_n,36/0,36/(open_ssio-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(open_sse-l_org)/5,36/0
l_280:	open_ssi:	vfd a36/    ,36/i_r,36/r_reversed,36/(open_ssi1-l_org)/5,36/a_18
	open_sso:	vfd a36/s   ,36/i_r,36/r_with,36/(open_sso1-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_no,36/(open_sso2-l_org)/5,36/a_14
	open_ss3:	vfd a36/    ,36/i_c,36/c_filenm,36/(open_ss2-l_org)/5,36/a_119
		vfd a36/s   ,36/i_c,36/c_open_mode,36/(l_281-l_org)/5,36/a_320
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
l_281:		vfd a36/    ,36/i_c,36/c_filenm,36/(l_282-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
		vfd a36/ 3  ,36/i_n,36/43,36/(open_ss1-l_org)/5,36/16
		vfd a36/    ,36/i_n,36/0,36/(open_ri1-l_org)/5,36/a_319
		vfd a36/    ,36/i_n,36/0,36/(open_ri1-l_org)/5,36/a_319
		vfd a36/    ,36/i_n,36/32,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(open_ss1-l_org)/5,36/a_319
l_282:	open_ssi1:	vfd a36/    ,36/i_n,36/0,36/(l_283-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
		vfd a36/s3  ,36/i_n,36/49,36/(open_ss3-l_org)/5,36/16
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
l_283:	open_ssio:	vfd a36/    ,36/i_n,36/0,36/(l_284-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/32,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(open_ss3-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/32,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(open_ss3-l_org)/5,36/0
l_284:	open_sse:	vfd a36/    ,36/i_n,36/0,36/(l_285-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/32,36/(rtwo-l_org)/5,36/0
		vfd a36/so  ,36/i_n,36/0,36/(open_ssio-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/so  ,36/i_n,36/0,36/(open_ssio-l_org)/5,36/0
l_285:	open_sso1:	vfd a36/s   ,36/i_r,36/r_no,36/(l_286-l_org)/5,36/a_14
		vfd a36/    ,36/i_n,36/197,36/(rtwo-l_org)/5,36/0
l_286:	open_sso2:	vfd a36/    ,36/i_r,36/r_rewind,36/(l_287-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/158,36/(rtwo-l_org)/5,36/0
l_287:		vfd a36/    ,36/i_n,36/0,36/(l_288-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
		vfd a36/s3  ,36/i_n,36/50,36/(open_ssio-l_org)/5,36/16
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
l_288:	open_ss2:	vfd a36/    ,36/i_n,36/0,36/(l_289-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/ 3  ,36/i_n,36/41,36/(open_ss1-l_org)/5,36/16
		vfd a36/    ,36/i_n,36/0,36/(open_ri1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(open_ri1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/32,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(open_ss1-l_org)/5,36/0
l_289:	open_ri1:	vfd a36/so  ,36/i_n,36/0,36/(l_290-l_org)/5,36/a_263
l_290:		vfd a36/    ,36/i_n,36/0,36/(l_291-l_org)/5,36/a_11
		vfd a36/    ,36/i_n,36/32,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(open_ri2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(open_ri2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(open_ri2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/258,36/(rtwo-l_org)/5,36/0
l_291:	open_ri2:	vfd a36/    ,36/i_c,36/c_filenm,36/(open_ri3-l_org)/5,36/a_119
		vfd a36/s   ,36/i_c,36/c_open_mode,36/(l_292-l_org)/5,36/a_320
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
l_292:		vfd a36/    ,36/i_c,36/c_filenm,36/(l_293-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
		vfd a36/ 3  ,36/i_n,36/43,36/(open_ss1-l_org)/5,36/16
		vfd a36/    ,36/i_n,36/0,36/(open_ri1-l_org)/5,36/a_319
		vfd a36/    ,36/i_n,36/0,36/(open_ri1-l_org)/5,36/a_319
		vfd a36/    ,36/i_n,36/32,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(open_ss1-l_org)/5,36/a_319
l_293:	open_ri3:	vfd a36/    ,36/i_n,36/0,36/(l_294-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/ 3  ,36/i_n,36/41,36/(open_ss1-l_org)/5,36/16
		vfd a36/    ,36/i_n,36/0,36/(open_ri1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(open_ri1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/032,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(open_ss1-l_org)/5,36/0
l_294:	perform:	vfd a36/so  ,36/i_r,36/r_perform,36/(l_295-l_org)/5,36/a_50
l_295:		vfd a36/so  ,36/i_c,36/c_prnm,36/(l_296-l_org)/5,36/a_28
		vfd a36/    ,36/i_n,36/0,36/(per6-l_org)/5,36/a_289
l_296:		vfd a36/s   ,36/i_r,36/r_thru,36/(per4-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_297-l_org)/5,36/a_144
l_297:		vfd a36/    ,36/i_n,36/0,36/(per6-l_org)/5,36/a_32
	per4:	vfd a36/    ,36/i_c,36/c_prnm,36/(l_298-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/062,36/(rtwo-l_org)/5,36/0
l_298:		vfd a36/    ,36/i_c,36/c_ckdecpn,36/(l_299-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/239,36/(rtwo-l_org)/5,36/0
l_299:		vfd a36/so  ,36/i_c,36/c_cksegm,36/(l_300-l_org)/5,36/a_143
		vfd a36/    ,36/i_n,36/246,36/(rtwo-l_org)/5,36/0
l_300:	per6:	vfd a36/so  ,36/i_s,36/(elnumint-l_org)/5,36/(l_301-l_org)/5,36/a_21
		vfd a36/    ,36/i_r,36/r_until,36/(per12-l_org)/5,36/a_24
		vfd a36/    ,36/i_r,36/r_varying,36/(per14-l_org)/5,36/a_63
		vfd a36/    ,36/i_n,36/0,36/(per5-l_org)/5,36/a_3
l_301:		vfd a36/s   ,36/i_r,36/r_times,36/(l_302-l_org)/5,36/a_3
		vfd a36/    ,36/i_n,36/063,36/(rtwo-l_org)/5,36/0
l_302:	per5:	vfd a36/    ,36/i_c,36/c_pn_pres,36/(verb1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_303-l_org)/5,36/a_295
l_303:		vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(l_304-l_org)/5,36/a_296
l_304:		vfd a36/s   ,36/i_r,36/r_end_perform,36/(verb1-l_org)/5,36/a_305
		vfd a36/    ,36/i_n,36/310,36/(rtwo-l_org)/5,36/0
	per12:	vfd a36/s3  ,36/i_n,36/30,36/(l_305-l_org)/5,36/2
l_305:		vfd a36/    ,36/i_s,36/(condition-l_org)/5,36/(per2-l_org)/5,36/a_200
		vfd a36/    ,36/i_n,36/159,36/(rtwo-l_org)/5,36/0
	per14:	vfd a36/s3  ,36/i_n,36/31,36/(l_306-l_org)/5,36/2
l_306:	per8:	vfd a36/    ,36/i_c,36/c_elnudnint,36/(per3-l_org)/5,36/0
		vfd a36/so  ,36/i_s,36/(alel-l_org)/5,36/(per11-l_org)/5,36/a_28
		vfd a36/so  ,36/i_s,36/(xnm-l_org)/5,36/(l_307-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/064,36/(rtwo-l_org)/5,36/0
l_307:		vfd a36/s   ,36/i_r,36/r_from,36/(l_308-l_org)/5,36/a_64
		vfd a36/    ,36/i_n,36/065,36/(rtwo-l_org)/5,36/0
l_308:		vfd a36/so  ,36/i_s,36/(elnint-l_org)/5,36/(per15-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_posint,36/(per15-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/240,36/(rtwo-l_org)/5,36/0
	per11:	vfd a36/s   ,36/i_r,36/r_from,36/(l_309-l_org)/5,36/a_64
		vfd a36/    ,36/i_n,36/65,36/(rtwo-l_org)/5,36/0
l_309:	per9:	vfd a36/so  ,36/i_s,36/(elni-l_org)/5,36/(l_310-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_nlit,36/(l_310-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/242,36/(rtwo-l_org)/5,36/0
l_310:		vfd a36/s   ,36/i_r,36/r_by,36/(l_311-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/054,36/(rtwo-l_org)/5,36/0
l_311:		vfd a36/so  ,36/i_s,36/(elni-l_org)/5,36/(per17-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_nznumlit,36/(per17-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/243,36/(rtwo-l_org)/5,36/0
	per3:	vfd a36/so  ,36/i_s,36/(alel-l_org)/5,36/(l_312-l_org)/5,36/a_28
l_312:		vfd a36/s   ,36/i_r,36/r_from,36/(l_313-l_org)/5,36/a_64
		vfd a36/    ,36/i_n,36/065,36/(rtwo-l_org)/5,36/0
l_313:		vfd a36/so  ,36/i_c,36/c_xnm,36/(l_314-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(per9-l_org)/5,36/0
l_314:	per15:	vfd a36/s   ,36/i_r,36/r_by,36/(l_315-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/054,36/(rtwo-l_org)/5,36/0
l_315:		vfd a36/so  ,36/i_s,36/(elint-l_org)/5,36/(l_316-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_pigz_by,36/(l_316-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/241,36/(rtwo-l_org)/5,36/0
l_316:	per17:	vfd a36/s   ,36/i_r,36/r_until,36/(l_317-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/066,36/(rtwo-l_org)/5,36/0
l_317:		vfd a36/    ,36/i_s,36/(condition-l_org)/5,36/(l_318-l_org)/5,36/a_200
		vfd a36/    ,36/i_n,36/159,36/(rtwo-l_org)/5,36/0
l_318:		vfd a36/    ,36/i_c,36/c_ecnt,36/(per5-l_org)/5,36/a_3
		vfd a36/so  ,36/i_r,36/r_after,36/(per8-l_org)/5,36/0
	per2:	vfd a36/    ,36/i_n,36/0,36/(per5-l_org)/5,36/a_3
	process:	vfd a36/ o  ,36/i_r,36/r_process,36/(l_319-l_org)/5,36/a_87
l_319:		vfd a36/s5  ,36/i_n,36/88,36/(l_320-l_org)/5,36/25
l_320:		vfd a36/so  ,36/i_c,36/c_descnm,36/(l_321-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/067,36/(rtwo-l_org)/5,36/0
l_321:		vfd a36/s   ,36/i_r,36/r_from,36/(pro2-l_org)/5,36/a_4
	pro1:	vfd a36/s   ,36/i_r,36/r_using,36/(pro3-l_org)/5,36/a_20
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
	pro2:	vfd a36/so  ,36/i_s,36/(ident-l_org)/5,36/(pro1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
	pro3:	vfd a36/so  ,36/i_c,36/c_saanm,36/(l_322-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_said,36/(l_322-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/068,36/(rtwo-l_org)/5,36/0
l_322:		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
	purge:	vfd a36/ o  ,36/i_r,36/r_purge,36/(l_323-l_org)/5,36/a_87
l_323:		vfd a36/s5  ,36/i_n,36/89,36/(l_324-l_org)/5,36/25
l_324:		vfd a36/so  ,36/i_c,36/c_outcdnm,36/(l_325-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/191,36/(rtwo-l_org)/5,36/0
l_325:	pur1:	vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
	read:	vfd a36/so  ,36/i_r,36/r_read,36/(l_326-l_org)/5,36/a_44
l_326:		vfd a36/ o  ,36/i_c,36/c_filenm,36/(l_327-l_org)/5,36/a_28
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
l_327:		vfd a36/    ,36/i_c,36/c_ixfil,36/(l_328-l_org)/5,36/a_288
l_328:		vfd a36/    ,36/i_n,36/0,36/(l_329-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
l_329:		vfd a36/s1  ,36/i_n,36/100,36/(l_330-l_org)/5,36/15
		vfd a36/s2  ,36/i_n,36/100,36/(l_330-l_org)/5,36/17
		vfd a36/s4  ,36/i_n,36/100,36/(l_330-l_org)/5,36/19
		vfd a36/    ,36/i_n,36/32,36/(rtwo-l_org)/5,36/0
		vfd a36/s5  ,36/i_n,36/100,36/(l_330-l_org)/5,36/25
l_330:		vfd a36/    ,36/i_r,36/r_next,36/(rd5-l_org)/5,36/a_121
	rd6:	vfd a36/s   ,36/i_r,36/r_record,36/(l_331-l_org)/5,36/0
l_331:		vfd a36/s   ,36/i_r,36/r_into,36/(rd8-l_org)/5,36/a_4
	rd11:	vfd a36/    ,36/i_r,36/r_key,36/(rd12-l_org)/5,36/a_20
	rd15:	vfd a36/    ,36/i_c,36/c_seqnext,36/(rd16-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(nik-l_org)/5,36/(rd2-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_useformr,36/(l_332-l_org)/5,36/a_257
		vfd a36/    ,36/i_n,36/111,36/(rtwo-l_org)/5,36/0
l_332:	rd1:	vfd a36/    ,36/i_n,36/0,36/(l_333-l_org)/5,36/a_3
l_333:		vfd a36/s   ,36/i_r,36/r_end_read,36/(verb1-l_org)/5,36/a_312
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/0
	rd2:	vfd a36/    ,36/i_s,36/(iki-l_org)/5,36/(l_334-l_org)/5,36/0
l_334:	rd17:	vfd a36/s   ,36/i_r,36/r_end_read,36/(verb1-l_org)/5,36/a_266
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_310
	rd8:	vfd a36/    ,36/i_c,36/c_varsiz,36/(l_335-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/069,36/(rtwo-l_org)/5,36/0
l_335:		vfd a36/ o  ,36/i_s,36/(rid-l_org)/5,36/(l_336-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
l_336:		vfd a36/s   ,36/i_c,36/c_fileno,36/(rd11-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/070,36/(rtwo-l_org)/5,36/0
	rd16:	vfd a36/    ,36/i_s,36/(nae-l_org)/5,36/(l_337-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_useformr,36/(rd1-l_org)/5,36/a_257
		vfd a36/    ,36/i_n,36/139,36/(rtwo-l_org)/5,36/0
l_337:		vfd a36/    ,36/i_s,36/(aei-l_org)/5,36/(rd17-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(rd17-l_org)/5,36/0
	rd13:	vfd a36/s   ,36/i_r,36/r_is,36/(l_338-l_org)/5,36/0
l_338:		vfd a36/so  ,36/i_c,36/c_adrisadr,36/(rd15-l_org)/5,36/a_288
		vfd a36/    ,36/i_n,36/284,36/(rtwo-l_org)/5,36/0
	rd5:	vfd a36/    ,36/i_n,36/0,36/(l_339-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
l_339:		vfd a36/    ,36/i_n,36/272,36/(rtwo-l_org)/5,36/0
		vfd a36/s3  ,36/i_n,36/104,36/(l_340-l_org)/5,36/18
		vfd a36/s4  ,36/i_n,36/104,36/(l_340-l_org)/5,36/20
		vfd a36/    ,36/i_n,36/32,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/272,36/(rtwo-l_org)/5,36/0
l_340:		vfd a36/    ,36/i_c,36/c_sqacdyac,36/(rd6-l_org)/5,36/a_258
		vfd a36/    ,36/i_n,36/186,36/(rtwo-l_org)/5,36/0
	rd12:	vfd a36/    ,36/i_n,36/0,36/(l_341-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
l_341:		vfd a36/    ,36/i_n,36/272,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/272,36/(rtwo-l_org)/5,36/0
		vfd a36/ 4  ,36/i_n,36/106,36/(l_342-l_org)/5,36/20
		vfd a36/    ,36/i_n,36/32,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/272,36/(rtwo-l_org)/5,36/0
l_342:		vfd a36/s   ,36/i_c,36/c_ixfil,36/(rd13-l_org)/5,36/a_259
		vfd a36/    ,36/i_n,36/170,36/(rtwo-l_org)/5,36/0
	receive:	vfd a36/ o  ,36/i_r,36/r_receive,36/(l_343-l_org)/5,36/a_50
l_343:		vfd a36/s3  ,36/i_n,36/74,36/(l_344-l_org)/5,36/23
l_344:		vfd a36/so  ,36/i_c,36/c_incdnm,36/(l_345-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/036,36/(rtwo-l_org)/5,36/0
l_345:		vfd a36/s   ,36/i_r,36/r_message,36/(rec1-l_org)/5,36/0
		vfd a36/    ,36/i_r,36/r_segment,36/(l_346-l_org)/5,36/a_20
		vfd a36/    ,36/i_n,36/071,36/(rtwo-l_org)/5,36/0
l_346:		vfd a36/s3  ,36/i_n,36/75,36/(l_347-l_org)/5,36/24
l_347:	rec1:	vfd a36/s   ,36/i_r,36/r_into,36/(l_348-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/072,36/(rtwo-l_org)/5,36/0
l_348:		vfd a36/so  ,36/i_s,36/(rid-l_org)/5,36/(l_349-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
l_349:		vfd a36/    ,36/i_s,36/(wd-l_org)/5,36/(rec3-l_org)/5,36/a_315
		vfd a36/    ,36/i_s,36/(nd-l_org)/5,36/(rec4-l_org)/5,36/a_301
		vfd a36/    ,36/i_n,36/0,36/(l_350-l_org)/5,36/a_3
l_350:		vfd a36/s   ,36/i_r,36/r_end_receive,36/(verb1-l_org)/5,36/a_312
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/0
	rec4:	vfd a36/    ,36/i_n,36/0,36/(l_351-l_org)/5,36/a_87
l_351:		vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(l_352-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_352-l_org)/5,36/0
l_352:		vfd a36/    ,36/i_s,36/(wd-l_org)/5,36/(l_353-l_org)/5,36/a_317
		vfd a36/    ,36/i_n,36/0,36/(rec2-l_org)/5,36/0
l_353:		vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(l_354-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_354-l_org)/5,36/0
l_354:	rec2:	vfd a36/s   ,36/i_r,36/r_end_receive,36/(verb1-l_org)/5,36/a_266
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_310
	rec3:	vfd a36/    ,36/i_n,36/0,36/(l_355-l_org)/5,36/a_87
l_355:		vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(l_356-l_org)/5,36/a_293
		vfd a36/    ,36/i_n,36/0,36/(l_356-l_org)/5,36/0
l_356:		vfd a36/    ,36/i_s,36/(nd-l_org)/5,36/(l_357-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(rec2-l_org)/5,36/0
l_357:		vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(rec2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(rec2-l_org)/5,36/0
	release:	vfd a36/    ,36/i_r,36/r_release,36/(l_358-l_org)/5,36/a_87
l_358:		vfd a36/ 3  ,36/i_n,36/60,36/(l_359-l_org)/5,36/5
l_359:		vfd a36/so  ,36/i_c,36/c_inrng,36/(l_360-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/074,36/(rtwo-l_org)/5,36/0
l_360:		vfd a36/so  ,36/i_c,36/c_recnm,36/(l_361-l_org)/5,36/a_28
		vfd a36/    ,36/i_n,36/073,36/(rtwo-l_org)/5,36/0
l_361:		vfd a36/s   ,36/i_r,36/r_from,36/(l_362-l_org)/5,36/a_4
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
l_362:		vfd a36/ o  ,36/i_s,36/(ident-l_org)/5,36/(l_363-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
l_363:		vfd a36/s   ,36/i_c,36/c_fileno,36/(verb1-l_org)/5,36/a_3
		vfd a36/    ,36/i_n,36/070,36/(rtwo-l_org)/5,36/0
	return:	vfd a36/    ,36/i_r,36/r_return,36/(l_364-l_org)/5,36/a_42
l_364:		vfd a36/ 3  ,36/i_n,36/61,36/(l_365-l_org)/5,36/5
l_365:		vfd a36/so  ,36/i_c,36/c_outrng,36/(l_366-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/075,36/(rtwo-l_org)/5,36/0
l_366:		vfd a36/so  ,36/i_c,36/c_asfil,36/(l_367-l_org)/5,36/a_191
		vfd a36/    ,36/i_n,36/076,36/(rtwo-l_org)/5,36/0
l_367:		vfd a36/s   ,36/i_r,36/r_record,36/(l_368-l_org)/5,36/0
l_368:		vfd a36/s   ,36/i_r,36/r_into,36/(ret2-l_org)/5,36/a_4
	ret1:	vfd a36/s   ,36/i_r,36/r_not,36/(ret3-l_org)/5,36/a_292
		vfd a36/    ,36/i_s,36/(nae-l_org)/5,36/(l_369-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/139,36/(rtwo-l_org)/5,36/0
l_369:		vfd a36/    ,36/i_s,36/(aei-l_org)/5,36/(l_370-l_org)/5,36/0
l_370:	ret4:	vfd a36/s   ,36/i_r,36/r_end_return,36/(verb1-l_org)/5,36/a_266
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_310
	ret3:	vfd a36/    ,36/i_s,36/(ae-l_org)/5,36/(l_371-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/139,36/(rtwo-l_org)/5,36/0
l_371:		vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(l_372-l_org)/5,36/0
l_372:		vfd a36/    ,36/i_s,36/(ae-l_org)/5,36/(l_373-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/139,36/(rtwo-l_org)/5,36/0
l_373:		vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(ret4-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(ret4-l_org)/5,36/0
	ret2:	vfd a36/ o  ,36/i_s,36/(rid-l_org)/5,36/(l_374-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
l_374:		vfd a36/s   ,36/i_c,36/c_fileno,36/(ret1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/070,36/(rtwo-l_org)/5,36/0
	rewrite:	vfd a36/so  ,36/i_r,36/r_rewrite,36/(l_375-l_org)/5,36/a_44
l_375:		vfd a36/ o  ,36/i_c,36/c_nsrecnm,36/(l_376-l_org)/5,36/a_260
		vfd a36/    ,36/i_n,36/108,36/(rtwo-l_org)/5,36/0
l_376:		vfd a36/    ,36/i_n,36/0,36/(l_377-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
l_377:		vfd a36/    ,36/i_n,36/0,36/(l_378-l_org)/5,36/0
		vfd a36/ 2  ,36/i_n,36/97,36/(l_378-l_org)/5,36/17
		vfd a36/ 4  ,36/i_n,36/97,36/(l_378-l_org)/5,36/19
		vfd a36/    ,36/i_n,36/32,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/272,36/(rtwo-l_org)/5,36/0
l_378:		vfd a36/s   ,36/i_c,36/c_nstorg,36/(l_379-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/259,36/(rtwo-l_org)/5,36/0
l_379:		vfd a36/s   ,36/i_r,36/r_from,36/(rew3-l_org)/5,36/a_20
	rew5:	vfd a36/    ,36/i_c,36/c_sqrlsqac,36/(l_380-l_org)/5,36/a_3
		vfd a36/    ,36/i_c,36/c_ixrlrady,36/(rew7-l_org)/5,36/a_21
		vfd a36/    ,36/i_s,36/(nik-l_org)/5,36/(rew8-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_380-l_org)/5,36/a_3
l_380:	rew9:	vfd a36/s   ,36/i_r,36/r_end_rewrite,36/(verb1-l_org)/5,36/a_312
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/0
	rew8:	vfd a36/    ,36/i_s,36/(iki-l_org)/5,36/(l_381-l_org)/5,36/0
l_381:		vfd a36/s   ,36/i_r,36/r_end_rewrite,36/(verb1-l_org)/5,36/a_266
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_310
	rew7:	vfd a36/    ,36/i_s,36/(nik-l_org)/5,36/(rew8-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_useformr,36/(rew9-l_org)/5,36/a_3
		vfd a36/    ,36/i_n,36/211,36/(rtwo-l_org)/5,36/0
	rew3:	vfd a36/ o  ,36/i_s,36/(ident-l_org)/5,36/(l_382-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
l_382:		vfd a36/s   ,36/i_c,36/c_filnefil,36/(rew5-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/070,36/(rtwo-l_org)/5,36/0
	search:	vfd a36/ o  ,36/i_r,36/r_search,36/(l_383-l_org)/5,36/a_50
l_383:		vfd a36/s3  ,36/i_n,36/57,36/(l_384-l_org)/5,36/4
l_384:		vfd a36/so  ,36/i_c,36/c_srchid,36/(l_385-l_org)/5,36/a_64
		vfd a36/s   ,36/i_r,36/r_all,36/(sea12-l_org)/5,36/a_21
		vfd a36/    ,36/i_n,36/77,36/(rtwo-l_org)/5,36/0
l_385:		vfd a36/so  ,36/i_n,36/0,36/(l_386-l_org)/5,36/0
l_386:		vfd a36/s   ,36/i_r,36/r_varying,36/(l_387-l_org)/5,36/a_20
		vfd a36/    ,36/i_n,36/0,36/(sea4-l_org)/5,36/0
l_387:		vfd a36/so  ,36/i_s,36/(xnm-l_org)/5,36/(l_388-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_usornm,36/(sea10-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/78,36/(rtwo-l_org)/5,36/0
l_388:	sea4:	vfd a36/    ,36/i_s,36/(sae-l_org)/5,36/(l_389-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(sea7-l_org)/5,36/a_3
l_389:	sea5:	vfd a36/    ,36/i_n,36/0,36/(l_390-l_org)/5,36/a_301
l_390:		vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(l_391-l_org)/5,36/a_173
l_391:	sea7:	vfd a36/s   ,36/i_r,36/r_when,36/(l_392-l_org)/5,36/a_195
		vfd a36/    ,36/i_n,36/79,36/(rtwo-l_org)/5,36/0
l_392:	sea8:	vfd a36/    ,36/i_s,36/(condition-l_org)/5,36/(l_393-l_org)/5,36/a_164
		vfd a36/    ,36/i_n,36/217,36/(rtwo-l_org)/5,36/0
l_393:		vfd a36/    ,36/i_s,36/(ns-l_org)/5,36/(sea9-l_org)/5,36/a_171
		vfd a36/    ,36/i_n,36/0,36/(l_394-l_org)/5,36/a_172
l_394:		vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(l_395-l_org)/5,36/a_173
l_395:	sea9:	vfd a36/s   ,36/i_r,36/r_when,36/(sea8-l_org)/5,36/a_195
		vfd a36/    ,36/i_n,36/0,36/(sea18-l_org)/5,36/a_174
	sea10:	vfd a36/    ,36/i_s,36/(idxd-l_org)/5,36/(sea4-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/78,36/(rtwo-l_org)/5,36/0
	sea12:	vfd a36/    ,36/i_c,36/c_srchid,36/(l_396-l_org)/5,36/a_64
		vfd a36/    ,36/i_n,36/81,36/(rtwo-l_org)/5,36/0
l_396:		vfd a36/so  ,36/i_c,36/c_keylbl,36/(l_397-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/82,36/(rtwo-l_org)/5,36/0
l_397:		vfd a36/so  ,36/i_n,36/0,36/(l_398-l_org)/5,36/0
l_398:		vfd a36/    ,36/i_r,36/r_when,36/(sea13-l_org)/5,36/a_3
		vfd a36/    ,36/i_s,36/(sae-l_org)/5,36/(l_399-l_org)/5,36/a_142
l_399:		vfd a36/    ,36/i_n,36/0,36/(l_400-l_org)/5,36/a_301
l_400:		vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(l_401-l_org)/5,36/a_173
l_401:	sea13:	vfd a36/s   ,36/i_r,36/r_when,36/(l_402-l_org)/5,36/a_142
		vfd a36/    ,36/i_n,36/79,36/(rtwo-l_org)/5,36/0
l_402:	sea14:	vfd a36/s   ,36/i_r,36/r_lt,36/(l_403-l_org)/5,36/0
l_403:		vfd a36/    ,36/i_s,36/(idxd-l_org)/5,36/(l_404-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/78,36/(rtwo-l_org)/5,36/0
l_404:		vfd a36/s   ,36/i_r,36/r_is,36/(l_405-l_org)/5,36/0
		vfd a36/so  ,36/i_r,36/r_eq,36/(sea16-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/312,36/(rtwo-l_org)/5,36/0
l_405:		vfd a36/so  ,36/i_r,36/r_eq,36/(l_406-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/311,36/(rtwo-l_org)/5,36/0
l_406:	sea16:	vfd a36/s   ,36/i_r,36/r_to,36/(l_407-l_org)/5,36/0
l_407:		vfd a36/    ,36/i_s,36/(arithexp-l_org)/5,36/(l_408-l_org)/5,36/0
		vfd a36/so  ,36/i_s,36/(ident-l_org)/5,36/(l_408-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_lit,36/(l_408-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/313,36/(rtwo-l_org)/5,36/0
l_408:		vfd a36/s   ,36/i_r,36/r_rt,36/(l_409-l_org)/5,36/0
l_409:		vfd a36/so  ,36/i_r,36/r_and,36/(sea14-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(ns-l_org)/5,36/(sea18-l_org)/5,36/a_176
		vfd a36/    ,36/i_n,36/0,36/(l_410-l_org)/5,36/a_177
l_410:		vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(l_411-l_org)/5,36/a_178
		vfd a36/    ,36/i_n,36/168,36/(rtwo-l_org)/5,36/0
l_411:	sea18:	vfd a36/s   ,36/i_r,36/r_end_search,36/(verb1-l_org)/5,36/a_266
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/0
	idxd:	vfd a36/so  ,36/i_s,36/(ident-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/so  ,36/i_s,36/(xdname-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	sae:	vfd a36/s   ,36/i_r,36/r_at,36/(l_412-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_end,36/(succ-l_org)/5,36/a_139
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_412:		vfd a36/s   ,36/i_r,36/r_end,36/(succ-l_org)/5,36/a_139
		vfd a36/    ,36/i_n,36/306,36/(rtwo-l_org)/5,36/0
	send:	vfd a36/so  ,36/i_r,36/r_send,36/(l_413-l_org)/5,36/a_318
l_413:		vfd a36/so  ,36/i_c,36/c_outcdnm,36/(l_414-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/035,36/(rtwo-l_org)/5,36/0
l_414:		vfd a36/s   ,36/i_r,36/r_from,36/(l_415-l_org)/5,36/a_4
		vfd a36/    ,36/i_r,36/r_with,36/(send_2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/271,36/(rtwo-l_org)/5,36/0
l_415:		vfd a36/so  ,36/i_s,36/(ident-l_org)/5,36/(l_416-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
l_416:		vfd a36/    ,36/i_r,36/r_with,36/(send_2-l_org)/5,36/0
		vfd a36/ 3  ,36/i_n,36/221,36/(l_417-l_org)/5,36/24
l_417:		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_323
	send_2:	vfd a36/ 3  ,36/i_n,36/76,36/(l_418-l_org)/5,36/23
l_418:		vfd a36/s   ,36/i_r,36/r_with,36/(l_419-l_org)/5,36/a_321
l_419:		vfd a36/    ,36/i_r,36/r_esi,36/(l_420-l_org)/5,36/a_67
		vfd a36/s   ,36/i_r,36/r_emi,36/(send_3-l_org)/5,36/a_68
		vfd a36/s   ,36/i_r,36/r_egi,36/(send_3-l_org)/5,36/a_69
		vfd a36/ o  ,36/i_s,36/(ident-l_org)/5,36/(send_4-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/084,36/(rtwo-l_org)/5,36/0
l_420:		vfd a36/s3  ,36/i_n,36/78,36/(l_421-l_org)/5,36/24
l_421:	send_3:	vfd a36/    ,36/i_n,36/0,36/(l_422-l_org)/5,36/a_319
l_422:		vfd a36/s   ,36/i_r,36/r_before,36/(send_6-l_org)/5,36/a_71
		vfd a36/s   ,36/i_r,36/r_after,36/(send_6-l_org)/5,36/a_72
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_109
	send_4:	vfd a36/ 3  ,36/i_n,36/77,36/(l_423-l_org)/5,36/24
l_423:		vfd a36/s   ,36/i_c,36/c_onechnosn,36/(send_3-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/187,36/(rtwo-l_org)/5,36/0
	send_6:	vfd a36/s   ,36/i_r,36/r_advancing,36/(l_424-l_org)/5,36/0
l_424:		vfd a36/so  ,36/i_s,36/(elnumint-l_org)/5,36/(send_8-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_prt_con,36/(send_7-l_org)/5,36/0
		vfd a36/so  ,36/i_r,36/r_page,36/(send_7-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/179,36/(rtwo-l_org)/5,36/0
l_425:		vfd a36/s   ,36/i_c,36/c_elnuindi,36/(l_426-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/179,36/(rtwo-l_org)/5,36/0
l_426:	send_8:	vfd a36/s   ,36/i_r,36/r_lines,36/(verb1-l_org)/5,36/a_3
	send_7:	vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
	set:	vfd a36/ o  ,36/i_r,36/r_set,36/(l_427-l_org)/5,36/a_87
l_427:		vfd a36/s   ,36/i_n,36/0,36/(l_428-l_org)/5,36/a_282
l_428:		vfd a36/so  ,36/i_s,36/(xnm-l_org)/5,36/(set_4-l_org)/5,36/a_45
		vfd a36/    ,36/i_c,36/c_xint,36/(set_5-l_org)/5,36/0
		vfd a36/ o  ,36/i_c,36/c_ssnm,36/(l_429-l_org)/5,36/a_8
		vfd a36/    ,36/i_n,36/175,36/(rtwo-l_org)/5,36/0
l_429:		vfd a36/s5  ,36/i_n,36/105,36/(l_430-l_org)/5,36/25
l_430:	set_1:	vfd a36/so  ,36/i_c,36/c_ssnm,36/(set_1-l_org)/5,36/a_8
		vfd a36/s   ,36/i_r,36/r_to,36/(set_2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/264,36/(set_2-l_org)/5,36/0
	set_2:	vfd a36/s   ,36/i_c,36/c_on_off,36/(verb1-l_org)/5,36/a_3
		vfd a36/    ,36/i_n,36/265,36/(rtwo-l_org)/5,36/0
	set_4:	vfd a36/ o  ,36/i_s,36/(xnm-l_org)/5,36/(l_431-l_org)/5,36/a_8
		vfd a36/s   ,36/i_r,36/r_to,36/(set_7-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_up,36/(set_10-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_down,36/(set_10-l_org)/5,36/a_4
		vfd a36/    ,36/i_n,36/0,36/(set_6-l_org)/5,36/0
l_431:		vfd a36/s   ,36/i_n,36/0,36/(set_4-l_org)/5,36/a_252
	set_5:	vfd a36/so  ,36/i_s,36/(ident-l_org)/5,36/(l_432-l_org)/5,36/a_8
		vfd a36/so  ,36/i_s,36/(xdname-l_org)/5,36/(l_432-l_org)/5,36/a_8
l_432:	set_6:	vfd a36/    ,36/i_c,36/c_xint,36/(set_5-l_org)/5,36/0
		vfd a36/ o  ,36/i_s,36/(xnm-l_org)/5,36/(set_3-l_org)/5,36/a_8
		vfd a36/s   ,36/i_r,36/r_to,36/(set_7-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/177,36/(rtwo-l_org)/5,36/0
	set_3:	vfd a36/s   ,36/i_n,36/0,36/(set_6-l_org)/5,36/a_252
	set_7:	vfd a36/so  ,36/i_c,36/c_xnm,36/(set_8-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_set_xint,36/(set_12-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_set_pigz,36/(set_13-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/273,36/(rtwo-l_org)/5,36/0
	set_12:	vfd a36/    ,36/i_c,36/c_tst_xint,36/(set_9-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/270,36/(rtwo-l_org)/5,36/0
	set_13:	vfd a36/ o  ,36/i_c,36/c_tst_pigz,36/(l_433-l_org)/5,36/a_281
		vfd a36/    ,36/i_n,36/0,36/(rtwo-l_org)/5,36/0
l_433:		vfd a36/s   ,36/i_c,36/c_ckrng1,36/(l_434-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/236,36/(rtwo-l_org)/5,36/0
l_434:	set_8:	vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
	set_9:	vfd a36/so  ,36/i_s,36/(ident-l_org)/5,36/(set_8-l_org)/5,36/0
		vfd a36/so  ,36/i_s,36/(xdname-l_org)/5,36/(set_8-l_org)/5,36/0
	set_10:	vfd a36/s   ,36/i_r,36/r_by,36/(l_435-l_org)/5,36/a_21
		vfd a36/    ,36/i_n,36/054,36/(rtwo-l_org)/5,36/0
l_435:		vfd a36/    ,36/i_c,36/c_elnudnint,36/(l_436-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_elnuint,36/(set_11-l_org)/5,36/a_281
		vfd a36/    ,36/i_n,36/179,36/(rtwo-l_org)/5,36/0
l_436:		vfd a36/so  ,36/i_s,36/(ident-l_org)/5,36/(set_8-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
	set_11:	vfd a36/so  ,36/i_c,36/c_ckrng2,36/(set_8-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/236,36/(rtwo-l_org)/5,36/0
	sort:	vfd a36/ o  ,36/i_r,36/r_sort,36/(l_437-l_org)/5,36/a_87
l_437:		vfd a36/    ,36/i_n,36/0,36/(l_438-l_org)/5,36/a_322
l_438:		vfd a36/s3  ,36/i_n,36/62,36/(l_439-l_org)/5,36/5
l_439:		vfd a36/so  ,36/i_c,36/c_srtfil,36/(l_440-l_org)/5,36/a_41
		vfd a36/    ,36/i_n,36/090,36/(rtwo-l_org)/5,36/0
l_440:		vfd a36/s   ,36/i_n,36/0,36/(l_441-l_org)/5,36/a_170
l_441:		vfd a36/s   ,36/i_r,36/r_on,36/(l_442-l_org)/5,36/0
l_442:	sort_1:	vfd a36/s   ,36/i_r,36/r_ascending,36/(l_443-l_org)/5,36/a_4
		vfd a36/s   ,36/i_r,36/r_descending,36/(l_443-l_org)/5,36/a_9
		vfd a36/    ,36/i_n,36/091,36/(rtwo-l_org)/5,36/0
l_443:	sort_2:	vfd a36/s   ,36/i_r,36/r_key,36/(l_444-l_org)/5,36/0
l_444:		vfd a36/so  ,36/i_c,36/c_dninfl,36/(l_445-l_org)/5,36/a_74
		vfd a36/    ,36/i_n,36/092,36/(rtwo-l_org)/5,36/0
l_445:	sort_12:	vfd a36/so  ,36/i_c,36/c_dninfl,36/(sort_12-l_org)/5,36/a_74
		vfd a36/s   ,36/i_r,36/r_on,36/(sort_1-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_ascending,36/(sort_2-l_org)/5,36/a_4
		vfd a36/s   ,36/i_r,36/r_descending,36/(sort_2-l_org)/5,36/a_9
		vfd a36/s   ,36/i_r,36/r_collating,36/(sort_3-l_org)/5,36/a_321
		vfd a36/s   ,36/i_r,36/r_sequence,36/(sort_4-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_446-l_org)/5,36/a_156
l_446:	sort_5:	vfd a36/s   ,36/i_r,36/r_input,36/(l_447-l_org)/5,36/a_9
		vfd a36/s   ,36/i_r,36/r_using,36/(sort_11-l_org)/5,36/a_37
		vfd a36/    ,36/i_n,36/093,36/(rtwo-l_org)/5,36/0
l_447:		vfd a36/    ,36/i_n,36/0,36/(sort_6-l_org)/5,36/a_3
	sort_3:	vfd a36/s   ,36/i_r,36/r_sequence,36/(l_448-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/266,36/(rtwo-l_org)/5,36/0
l_448:	sort_4:	vfd a36/s   ,36/i_r,36/r_is,36/(l_449-l_org)/5,36/0
l_449:		vfd a36/ o  ,36/i_c,36/c_alphnm,36/(l_450-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/267,36/(rtwo-l_org)/5,36/0
l_450:	sort_14:	vfd a36/s4  ,36/i_n,36/63,36/(sort_5-l_org)/5,36/6
	sort_6:	vfd a36/s   ,36/i_r,36/r_procedure,36/(sort_7-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/001,36/(rtwo-l_org)/5,36/0
	sort_11:	vfd a36/    ,36/i_c,36/c_filenm,36/(l_451-l_org)/5,36/a_157
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
l_451:		vfd a36/s   ,36/i_c,36/c_seqfil,36/(l_452-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/301,36/(rtwo-l_org)/5,36/0
l_452:	sort_9:	vfd a36/s   ,36/i_n,36/0,36/(sort_8-l_org)/5,36/a_159
	sort_7:	vfd a36/s   ,36/i_r,36/r_is,36/(l_453-l_org)/5,36/0
l_453:		vfd a36/    ,36/i_c,36/c_debug,36/(sort_17-l_org)/5,36/0
	sort_15:	vfd a36/s   ,36/i_c,36/c_descnmra,36/(l_454-l_org)/5,36/a_165
		vfd a36/    ,36/i_n,36/67,36/(rtwo-l_org)/5,36/0
l_454:		vfd a36/s   ,36/i_r,36/r_thru,36/(l_455-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(sort_13-l_org)/5,36/a_167
l_455:		vfd a36/s   ,36/i_c,36/c_descnmra,36/(sort_13-l_org)/5,36/a_166
		vfd a36/    ,36/i_n,36/67,36/(rtwo-l_org)/5,36/0
	sort_8:	vfd a36/    ,36/i_c,36/c_filenm,36/(l_456-l_org)/5,36/a_157
		vfd a36/    ,36/i_n,36/0,36/(sort_13-l_org)/5,36/a_162
l_456:		vfd a36/ 4  ,36/i_n,36/41,36/(l_457-l_org)/5,36/6
l_457:		vfd a36/s   ,36/i_c,36/c_seqfil,36/(sort_9-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/301,36/(rtwo-l_org)/5,36/0
	sort_13:	vfd a36/s   ,36/i_r,36/r_output,36/(l_458-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_giving,36/(sort_10-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/094,36/(rtwo-l_org)/5,36/0
l_458:		vfd a36/s   ,36/i_r,36/r_procedure,36/(l_459-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/001,36/(rtwo-l_org)/5,36/0
l_459:		vfd a36/s   ,36/i_r,36/r_is,36/(l_460-l_org)/5,36/0
l_460:		vfd a36/    ,36/i_c,36/c_debug,36/(sort_18-l_org)/5,36/0
	sort_16:	vfd a36/s   ,36/i_c,36/c_descnmra,36/(l_461-l_org)/5,36/a_165
		vfd a36/    ,36/i_n,36/67,36/(rtwo-l_org)/5,36/0
l_461:		vfd a36/s   ,36/i_r,36/r_thru,36/(l_462-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_169
l_462:		vfd a36/s   ,36/i_c,36/c_descnmra,36/(verb1-l_org)/5,36/a_168
		vfd a36/    ,36/i_n,36/67,36/(rtwo-l_org)/5,36/0
	sort_10:	vfd a36/    ,36/i_c,36/c_filenm,36/(l_463-l_org)/5,36/a_157
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
l_463:		vfd a36/s   ,36/i_c,36/c_seqfil,36/(l_464-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/301,36/(rtwo-l_org)/5,36/0
l_464:		vfd a36/s   ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_158
	sort_17:	vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(sort_15-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(sort_15-l_org)/5,36/0
	sort_18:	vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(sort_16-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(sort_16-l_org)/5,36/0
	start:	vfd a36/so  ,36/i_r,36/r_start,36/(l_465-l_org)/5,36/a_44
l_465:		vfd a36/ o  ,36/i_c,36/c_filenm,36/(l_466-l_org)/5,36/a_28
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
l_466:		vfd a36/    ,36/i_c,36/c_ixfil,36/(l_467-l_org)/5,36/a_288
l_467:		vfd a36/    ,36/i_n,36/0,36/(l_468-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
l_468:		vfd a36/    ,36/i_n,36/272,36/(rtwo-l_org)/5,36/0
		vfd a36/ 3  ,36/i_n,36/95,36/(l_469-l_org)/5,36/18
		vfd a36/ 4  ,36/i_n,36/95,36/(l_469-l_org)/5,36/20
		vfd a36/    ,36/i_n,36/32,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/272,36/(rtwo-l_org)/5,36/0
l_469:		vfd a36/s   ,36/i_c,36/c_ixrlsqdy,36/(l_470-l_org)/5,36/a_262
		vfd a36/    ,36/i_n,36/227,36/(rtwo-l_org)/5,36/0
l_470:		vfd a36/s   ,36/i_r,36/r_key,36/(sta3-l_org)/5,36/a_21
	sta9:	vfd a36/    ,36/i_s,36/(nik-l_org)/5,36/(sta2-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_useformds,36/(l_471-l_org)/5,36/a_3
		vfd a36/    ,36/i_n,36/111,36/(rtwo-l_org)/5,36/0
l_471:	sta4:	vfd a36/s   ,36/i_r,36/r_end_start,36/(verb1-l_org)/5,36/a_312
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_312
	sta2:	vfd a36/    ,36/i_s,36/(iki-l_org)/5,36/(l_472-l_org)/5,36/0
l_472:		vfd a36/s   ,36/i_r,36/r_end_start,36/(verb1-l_org)/5,36/a_266
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_310
	sta3:	vfd a36/s   ,36/i_r,36/r_is,36/(l_473-l_org)/5,36/0
l_473:		vfd a36/s   ,36/i_r,36/r_eq,36/(l_474-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_gt,36/(sta8-l_org)/5,36/a_120
		vfd a36/s   ,36/i_r,36/r_not,36/(sta6-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/228,36/(rtwo-l_org)/5,36/0
l_474:		vfd a36/s   ,36/i_r,36/r_to,36/(l_475-l_org)/5,36/0
l_475:	sta7:	vfd a36/    ,36/i_c,36/c_undana,36/(sta11-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/185,36/(rtwo-l_org)/5,36/0
	sta6:	vfd a36/s   ,36/i_r,36/r_less,36/(l_476-l_org)/5,36/a_121
		vfd a36/    ,36/i_n,36/226,36/(rtwo-l_org)/5,36/0
l_476:	sta8:	vfd a36/s   ,36/i_r,36/r_than,36/(sta7-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(sta7-l_org)/5,36/0
	sta11:	vfd a36/    ,36/i_c,36/c_relfile,36/(l_477-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_adrisadr,36/(sta9-l_org)/5,36/a_288
		vfd a36/    ,36/i_n,36/284,36/(rtwo-l_org)/5,36/0
l_477:		vfd a36/so  ,36/i_c,36/c_keyiskey,36/(sta9-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/229,36/(rtwo-l_org)/5,36/0
	stop:	vfd a36/so  ,36/i_r,36/r_stop,36/(l_478-l_org)/5,36/a_87
l_478:		vfd a36/so  ,36/i_r,36/r_run,36/(l_479-l_org)/5,36/a_324
		vfd a36/so  ,36/i_c,36/c_lit,36/(l_479-l_org)/5,36/a_21
		vfd a36/so  ,36/i_c,36/c_figconall,36/(l_479-l_org)/5,36/a_21
		vfd a36/    ,36/i_n,36/127,36/(rtwo-l_org)/5,36/0
l_479:		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
	string:	vfd a36/ o  ,36/i_r,36/r_string,36/(l_480-l_org)/5,36/a_42
l_480:		vfd a36/s3  ,36/i_n,36/32,36/(l_481-l_org)/5,36/2
l_481:		vfd a36/ o  ,36/i_s,36/(ident-l_org)/5,36/(l_482-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_nonumlit,36/(str2-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_figconall,36/(str2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/029,36/(rtwo-l_org)/5,36/0
l_482:	str1:	vfd a36/s   ,36/i_c,36/c_usisds,36/(l_483-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/095,36/(rtwo-l_org)/5,36/0
l_483:	str2:	vfd a36/ o  ,36/i_s,36/(ident-l_org)/5,36/(str1-l_org)/5,36/0
		vfd a36/so  ,36/i_r,36/r_delimited,36/(l_484-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_nonumlit,36/(str2-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_figconall,36/(str2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/096,36/(rtwo-l_org)/5,36/0
l_484:		vfd a36/s   ,36/i_r,36/r_by,36/(l_485-l_org)/5,36/0
l_485:		vfd a36/ o  ,36/i_s,36/(ident-l_org)/5,36/(l_486-l_org)/5,36/0
		vfd a36/so  ,36/i_r,36/r_size,36/(str4-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_nonumlit,36/(str4-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_figconall,36/(str4-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/097,36/(rtwo-l_org)/5,36/0
l_486:		vfd a36/s   ,36/i_c,36/c_usisds,36/(l_487-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/098,36/(rtwo-l_org)/5,36/0
l_487:	str4:	vfd a36/ o  ,36/i_s,36/(ident-l_org)/5,36/(str1-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_nonumlit,36/(str2-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_figconall,36/(str2-l_org)/5,36/0
		vfd a36/so  ,36/i_r,36/r_into,36/(l_488-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/099,36/(rtwo-l_org)/5,36/0
l_488:		vfd a36/ o  ,36/i_s,36/(rid-l_org)/5,36/(l_489-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
l_489:		vfd a36/s   ,36/i_c,36/c_elneds,36/(l_490-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/100,36/(rtwo-l_org)/5,36/0
l_490:		vfd a36/s   ,36/i_r,36/r_with,36/(str7-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_pointer,36/(str8-l_org)/5,36/a_20
	str6:	vfd a36/    ,36/i_s,36/(nov-l_org)/5,36/(str3-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_491-l_org)/5,36/a_3
l_491:		vfd a36/s   ,36/i_r,36/r_end_string,36/(verb1-l_org)/5,36/a_312
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/0
	str3:	vfd a36/    ,36/i_s,36/(ovi-l_org)/5,36/(l_492-l_org)/5,36/0
l_492:		vfd a36/s   ,36/i_r,36/r_end_string,36/(verb1-l_org)/5,36/a_266
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_310
	str7:	vfd a36/s   ,36/i_r,36/r_pointer,36/(l_493-l_org)/5,36/a_20
		vfd a36/    ,36/i_n,36/174,36/(rtwo-l_org)/5,36/0
l_493:	str8:	vfd a36/ o  ,36/i_s,36/(rid-l_org)/5,36/(l_494-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
l_494:		vfd a36/s   ,36/i_c,36/c_elnuindi,36/(str6-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/101,36/(rtwo-l_org)/5,36/0
	subtract:	vfd a36/so  ,36/i_r,36/r_subtract,36/(l_495-l_org)/5,36/a_27
l_495:		vfd a36/so  ,36/i_s,36/(elnuitem-l_org)/5,36/(l_496-l_org)/5,36/a_33
		vfd a36/    ,36/i_n,36/102,36/(rtwo-l_org)/5,36/0
l_496:		vfd a36/s   ,36/i_r,36/r_from,36/(l_497-l_org)/5,36/0
		vfd a36/so  ,36/i_s,36/(elnuitem-l_org)/5,36/(l_496-l_org)/5,36/a_33
		vfd a36/    ,36/i_n,36/103,36/(rtwo-l_org)/5,36/0
l_497:		vfd a36/    ,36/i_c,36/c_altst,36/(l_498-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(sub10-l_org)/5,36/0
l_498:		vfd a36/s   ,36/i_s,36/(ident-l_org)/5,36/(sub11-l_org)/5,36/a_34
	sub10:	vfd a36/so  ,36/i_s,36/(elnuitem-l_org)/5,36/(l_499-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/102,36/(rtwo-l_org)/5,36/0
l_499:		vfd a36/s   ,36/i_r,36/r_giving,36/(l_500-l_org)/5,36/a_21
		vfd a36/    ,36/i_n,36/58,36/(rtwo-l_org)/5,36/0
l_500:		vfd a36/s   ,36/i_s,36/(edalel-l_org)/5,36/(sub4-l_org)/5,36/a_34
		vfd a36/    ,36/i_n,36/26,36/(rtwo-l_org)/5,36/0
	sub11:	vfd a36/s   ,36/i_r,36/r_giving,36/(l_501-l_org)/5,36/a_75
		vfd a36/    ,36/i_c,36/c_csstst,36/(sub1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(sub1-l_org)/5,36/a_278
l_501:		vfd a36/s   ,36/i_s,36/(edalel-l_org)/5,36/(sub4-l_org)/5,36/a_28
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
	sub1:	vfd a36/s   ,36/i_r,36/r_rounded,36/(l_502-l_org)/5,36/a_267
		vfd a36/    ,36/i_n,36/0,36/(l_502-l_org)/5,36/a_268
l_502:		vfd a36/    ,36/i_c,36/c_sterm,36/(sub12-l_org)/5,36/a_3
l_503:		vfd a36/    ,36/i_s,36/(alel-l_org)/5,36/(sub5-l_org)/5,36/a_269
l_504:		vfd a36/    ,36/i_s,36/(nos-l_org)/5,36/(sub13-l_org)/5,36/a_87
		vfd a36/    ,36/i_n,36/0,36/(l_505-l_org)/5,36/a_102
l_505:	sub12:	vfd a36/s   ,36/i_r,36/r_end_subtract,36/(verb1-l_org)/5,36/a_312
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/0
	sub13:	vfd a36/    ,36/i_s,36/(osi-l_org)/5,36/(l_506-l_org)/5,36/0
l_506:		vfd a36/s   ,36/i_r,36/r_end_subtract,36/(verb1-l_org)/5,36/a_266
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_310
	sub5:	vfd a36/s3  ,36/i_n,36/23,36/(l_507-l_org)/5,36/2
l_507:		vfd a36/    ,36/i_c,36/c_sterm,36/(sub12-l_org)/5,36/a_102
		vfd a36/    ,36/i_n,36/0,36/(sub1-l_org)/5,36/0
	sub4:	vfd a36/s   ,36/i_r,36/r_rounded,36/(l_508-l_org)/5,36/a_267
		vfd a36/    ,36/i_n,36/0,36/(l_508-l_org)/5,36/a_268
l_508:		vfd a36/    ,36/i_s,36/(edalel-l_org)/5,36/(l_509-l_org)/5,36/a_269
		vfd a36/    ,36/i_s,36/(nos-l_org)/5,36/(sub13-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(sub12-l_org)/5,36/a_3
l_509:		vfd a36/s3  ,36/i_n,36/23,36/(sub4-l_org)/5,36/2
	suspend:	vfd a36/so  ,36/i_r,36/r_suspend,36/(l_510-l_org)/5,36/a_87
l_510:	sus1:	vfd a36/so  ,36/i_c,36/c_file,36/(sus3-l_org)/5,36/0
	sus2:	vfd a36/so  ,36/i_c,36/c_repnm,36/(l_511-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/194,36/(rtwo-l_org)/5,36/0
l_511:	sus3:	vfd a36/so  ,36/i_c,36/c_lit,36/(l_512-l_org)/5,36/a_4
		vfd a36/so  ,36/i_s,36/(ident-l_org)/5,36/(l_512-l_org)/5,36/a_4
l_512:		vfd a36/    ,36/i_c,36/c_file,36/(sus1-l_org)/5,36/a_123
		vfd a36/    ,36/i_c,36/c_repnm,36/(sus2-l_org)/5,36/a_123
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
	terminate:	vfd a36/    ,36/i_r,36/r_terminate,36/(l_513-l_org)/5,36/a_87
l_513:		vfd a36/s4  ,36/i_n,36/90,36/(init_1-l_org)/5,36/21
	rep_nam:	vfd a36/    ,36/i_c,36/c_prnm,36/(l_514-l_org)/5,36/a_111
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_514:		vfd a36/so  ,36/i_n,36/0,36/(l_515-l_org)/5,36/a_28
l_515:		vfd a36/    ,36/i_n,36/0,36/(l_516-l_org)/5,36/a_144
l_516:		vfd a36/    ,36/i_n,36/0,36/(l_517-l_org)/5,36/a_32
l_517:		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/a_124
	unstring:	vfd a36/ o  ,36/i_r,36/r_unstring,36/(l_518-l_org)/5,36/a_42
l_518:		vfd a36/s3  ,36/i_n,36/33,36/(l_519-l_org)/5,36/2
l_519:		vfd a36/ o  ,36/i_s,36/(ident-l_org)/5,36/(l_520-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
l_520:		vfd a36/s   ,36/i_c,36/c_andait,36/(l_521-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/105,36/(rtwo-l_org)/5,36/0
l_521:		vfd a36/s   ,36/i_r,36/r_delimited,36/(l_522-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_into,36/(un2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/106,36/(rtwo-l_org)/5,36/0
l_522:		vfd a36/s   ,36/i_r,36/r_by,36/(l_523-l_org)/5,36/0
l_523:	un1:	vfd a36/ o  ,36/i_r,36/r_all,36/(un9-l_org)/5,36/0
	un14:	vfd a36/so  ,36/i_s,36/(nonumid-l_org)/5,36/(l_524-l_org)/5,36/a_8
		vfd a36/so  ,36/i_c,36/c_figconall,36/(l_524-l_org)/5,36/a_8
		vfd a36/    ,36/i_n,36/233,36/(rtwo-l_org)/5,36/0
l_524:		vfd a36/s   ,36/i_r,36/r_or,36/(un1-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_into,36/(l_525-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/234,36/(rtwo-l_org)/5,36/0
l_525:	un2:	vfd a36/ o  ,36/i_s,36/(rid-l_org)/5,36/(l_526-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
l_526:	un3:	vfd a36/s   ,36/i_s,36/(usnoned-l_org)/5,36/(l_527-l_org)/5,36/a_78
		vfd a36/    ,36/i_n,36/235,36/(rtwo-l_org)/5,36/0
l_527:		vfd a36/so  ,36/i_r,36/r_delimiter,36/(un8-l_org)/5,36/0
	un4:	vfd a36/so  ,36/i_r,36/r_count,36/(un10-l_org)/5,36/0
	un5:	vfd a36/ o  ,36/i_s,36/(rid-l_org)/5,36/(un3-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_with,36/(un11-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_pointer,36/(un12-l_org)/5,36/a_121
	un6:	vfd a36/s   ,36/i_r,36/r_tallying,36/(un13-l_org)/5,36/a_20
	un7:	vfd a36/    ,36/i_s,36/(nov-l_org)/5,36/(un15-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_528-l_org)/5,36/a_3
l_528:		vfd a36/s   ,36/i_r,36/r_end_unstring,36/(verb1-l_org)/5,36/a_312
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/0
	un15:	vfd a36/    ,36/i_s,36/(ovi-l_org)/5,36/(l_529-l_org)/5,36/0
l_529:		vfd a36/s   ,36/i_r,36/r_end_unstring,36/(verb1-l_org)/5,36/a_266
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_310
	un8:	vfd a36/    ,36/i_c,36/c_egrze,36/(l_530-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/107,36/(rtwo-l_org)/5,36/0
l_530:		vfd a36/s   ,36/i_r,36/r_in,36/(l_531-l_org)/5,36/0
l_531:		vfd a36/ o  ,36/i_s,36/(rid-l_org)/5,36/(l_532-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
l_532:		vfd a36/s   ,36/i_c,36/c_andait,36/(un4-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/105,36/(rtwo-l_org)/5,36/0
	un10:	vfd a36/    ,36/i_c,36/c_egrze,36/(l_533-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/107,36/(rtwo-l_org)/5,36/0
l_533:		vfd a36/s   ,36/i_r,36/r_in,36/(l_534-l_org)/5,36/0
l_534:		vfd a36/ o  ,36/i_s,36/(rid-l_org)/5,36/(l_535-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
l_535:		vfd a36/s   ,36/i_c,36/c_elnuindi,36/(un5-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/101,36/(rtwo-l_org)/5,36/0
	un11:	vfd a36/s   ,36/i_r,36/r_pointer,36/(l_536-l_org)/5,36/a_121
		vfd a36/    ,36/i_n,36/174,36/(rtwo-l_org)/5,36/0
l_536:	un12:	vfd a36/ o  ,36/i_s,36/(rid-l_org)/5,36/(l_537-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
l_537:		vfd a36/s   ,36/i_c,36/c_elnuindi,36/(un6-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/101,36/(rtwo-l_org)/5,36/0
	un13:	vfd a36/s   ,36/i_r,36/r_in,36/(l_538-l_org)/5,36/0
l_538:		vfd a36/ o  ,36/i_s,36/(rid-l_org)/5,36/(l_539-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
l_539:		vfd a36/s   ,36/i_c,36/c_elnuindi,36/(un7-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/101,36/(rtwo-l_org)/5,36/0
	un9:	vfd a36/s3  ,36/i_n,36/144,36/(un14-l_org)/5,36/2
	write:	vfd a36/so  ,36/i_r,36/r_write,36/(l_540-l_org)/5,36/a_44
l_540:		vfd a36/ o  ,36/i_c,36/c_filenm,36/(wf-l_org)/5,36/0
		vfd a36/ o  ,36/i_c,36/c_nsrecnm,36/(l_541-l_org)/5,36/a_261
		vfd a36/    ,36/i_n,36/108,36/(rtwo-l_org)/5,36/0
l_541:		vfd a36/    ,36/i_n,36/0,36/(l_542-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
l_542:		vfd a36/s1  ,36/i_n,36/107,36/(l_543-l_org)/5,36/15
		vfd a36/s2  ,36/i_n,36/107,36/(l_543-l_org)/5,36/17
		vfd a36/s4  ,36/i_n,36/107,36/(l_543-l_org)/5,36/19
		vfd a36/    ,36/i_n,36/32,36/(rtwo-l_org)/5,36/0
		vfd a36/s5  ,36/i_n,36/107,36/(l_543-l_org)/5,36/25
l_543:		vfd a36/s   ,36/i_r,36/r_from,36/(wr4-l_org)/5,36/a_20
	wr2:	vfd a36/    ,36/i_c,36/c_msfile,36/(wr10-l_org)/5,36/a_21
		vfd a36/    ,36/i_r,36/r_before,36/(wr1-l_org)/5,36/a_121
		vfd a36/    ,36/i_r,36/r_after,36/(wr1-l_org)/5,36/a_120
	wr3:	vfd a36/    ,36/i_c,36/c_nae,36/(l_544-l_org)/5,36/a_37
		vfd a36/    ,36/i_n,36/0,36/(wr12-l_org)/5,36/0
l_544:		vfd a36/    ,36/i_c,36/c_linage,36/(l_545-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/110,36/(rtwo-l_org)/5,36/0
l_545:		vfd a36/ 3  ,36/i_n,36/35,36/(l_546-l_org)/5,36/16
l_546:		vfd a36/    ,36/i_s,36/(neop-l_org)/5,36/(l_547-l_org)/5,36/a_87
		vfd a36/    ,36/i_n,36/0,36/(l_546-l_org)/5,36/0
l_547:		vfd a36/    ,36/i_s,36/(eopi-l_org)/5,36/(wr13-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(wr13-l_org)/5,36/0
	wr4:	vfd a36/ o  ,36/i_s,36/(ident-l_org)/5,36/(l_548-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
l_548:		vfd a36/s   ,36/i_c,36/c_filnefil,36/(wr2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/070,36/(rtwo-l_org)/5,36/0
	wr10:	vfd a36/    ,36/i_s,36/(nik-l_org)/5,36/(wr11-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_useformrw,36/(l_549-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/111,36/(rtwo-l_org)/5,36/0
l_549:	wr12:	vfd a36/s   ,36/i_r,36/r_end_write,36/(verb1-l_org)/5,36/a_3
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
	wr11:	vfd a36/    ,36/i_s,36/(iki-l_org)/5,36/(l_550-l_org)/5,36/0
l_550:	wr13:	vfd a36/s   ,36/i_r,36/r_end_write,36/(verb1-l_org)/5,36/a_266
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_310
	wr1:	vfd a36/    ,36/i_n,36/0,36/(l_551-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
l_551:		vfd a36/s   ,36/i_n,36/0,36/(l_552-l_org)/5,36/a_321
		vfd a36/    ,36/i_n,36/272,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/272,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/32,36/(rtwo-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/0,36/(l_552-l_org)/5,36/a_321
l_552:		vfd a36/s   ,36/i_r,36/r_advancing,36/(l_553-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(wr9-l_org)/5,36/0
l_553:		vfd a36/    ,36/i_c,36/c_seqstmfil,36/(l_554-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/283,36/(wr9-l_org)/5,36/0
l_554:		vfd a36/    ,36/i_c,36/c_devprt,36/(l_555-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/283,36/(l_555-l_org)/5,36/0
l_555:	wr9:	vfd a36/    ,36/i_c,36/c_elnudnint,36/(wr5-l_org)/5,36/0
		vfd a36/so  ,36/i_s,36/(elnumint-l_org)/5,36/(wr8-l_org)/5,36/a_319
	wr6:	vfd a36/ o  ,36/i_c,36/c_prt_con,36/(wr7-l_org)/5,36/0
		vfd a36/so  ,36/i_r,36/r_page,36/(wr3-l_org)/5,36/a_319
		vfd a36/    ,36/i_n,36/109,36/(rtwo-l_org)/5,36/0
	wr5:	vfd a36/ o  ,36/i_s,36/(ident-l_org)/5,36/(l_556-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(wr6-l_org)/5,36/0
l_556:		vfd a36/s3  ,36/i_n,36/111,36/(wr8-l_org)/5,36/16
	wr7:	vfd a36/s3  ,36/i_n,36/112,36/(l_557-l_org)/5,36/16
l_557:	wr8:	vfd a36/s   ,36/i_r,36/r_lines,36/(wr3-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(wr3-l_org)/5,36/0
	wf:	vfd a36/    ,36/i_n,36/0,36/(l_558-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/31,36/(rtwo-l_org)/5,36/0
l_558:		vfd a36/s   ,36/i_n,36/0,36/(wf1-l_org)/5,36/a_24
		vfd a36/    ,36/i_n,36/301,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/301,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/301,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/301,36/(rtwo-l_org)/5,36/0
	wf1:	vfd a36/s   ,36/i_r,36/r_from,36/(l_559-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/302,36/(rtwo-l_org)/5,36/0
l_559:		vfd a36/so  ,36/i_s,36/(ident-l_org)/5,36/(wr12-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/70,36/(rtwo-l_org)/5,36/0
	examine:	vfd a36/ o  ,36/i_r,36/r_examine,36/(l_560-l_org)/5,36/a_87
l_560:		vfd a36/s5  ,36/i_n,36/91,36/(l_561-l_org)/5,36/25
l_561:		vfd a36/so  ,36/i_s,36/(rid-l_org)/5,36/(l_562-l_org)/5,36/a_28
		vfd a36/    ,36/i_n,36/021,36/(rtwo-l_org)/5,36/0
l_562:		vfd a36/s   ,36/i_r,36/r_tallying,36/(l_563-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_replacing,36/(ex1-l_org)/5,36/a_21
		vfd a36/    ,36/i_n,36/049,36/(rtwo-l_org)/5,36/0
l_563:		vfd a36/s   ,36/i_r,36/r_all,36/(ex3-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_leading,36/(ex3-l_org)/5,36/a_121
		vfd a36/s   ,36/i_r,36/r_until,36/(ex4-l_org)/5,36/a_120
		vfd a36/    ,36/i_n,36/119,36/(rtwo-l_org)/5,36/0
	ex1:	vfd a36/    ,36/i_c,36/c_csstst,36/(ex10-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/260,36/(ex10-l_org)/5,36/0
	ex10:	vfd a36/s   ,36/i_r,36/r_all,36/(ex7-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_leading,36/(ex7-l_org)/5,36/a_121
		vfd a36/s   ,36/i_r,36/r_until,36/(ex8-l_org)/5,36/a_120
		vfd a36/s   ,36/i_r,36/r_first,36/(ex7-l_org)/5,36/a_122
		vfd a36/    ,36/i_n,36/121,36/(rtwo-l_org)/5,36/0
	ex3:	vfd a36/so  ,36/i_c,36/c_examlitid,36/(ex5-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/120,36/(rtwo-l_org)/5,36/0
	ex4:	vfd a36/s   ,36/i_r,36/r_first,36/(ex3-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/122,36/(rtwo-l_org)/5,36/0
	ex5:	vfd a36/s   ,36/i_r,36/r_replacing,36/(ex2-l_org)/5,36/a_4
	ex6:	vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
	ex2:	vfd a36/    ,36/i_c,36/c_csstst,36/(l_564-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/260,36/(l_564-l_org)/5,36/0
l_564:		vfd a36/s   ,36/i_r,36/r_by,36/(l_565-l_org)/5,36/0
l_565:		vfd a36/so  ,36/i_c,36/c_examlitid,36/(ex6-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/120,36/(rtwo-l_org)/5,36/0
	ex7:	vfd a36/so  ,36/i_c,36/c_examlitid,36/(ex9-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/120,36/(rtwo-l_org)/5,36/0
	ex8:	vfd a36/s   ,36/i_r,36/r_first,36/(ex7-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/122,36/(rtwo-l_org)/5,36/0
	ex9:	vfd a36/s   ,36/i_r,36/r_by,36/(l_566-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/054,36/(rtwo-l_org)/5,36/0
l_566:		vfd a36/so  ,36/i_c,36/c_examlitid,36/(ex6-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/120,36/(rtwo-l_org)/5,36/0
	transform:	vfd a36/ o  ,36/i_r,36/r_transform,36/(l_567-l_org)/5,36/a_87
l_567:		vfd a36/s5  ,36/i_n,36/92,36/(l_568-l_org)/5,36/25
l_568:		vfd a36/    ,36/i_c,36/c_elaanne,36/(l_569-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/181,36/(rtwo-l_org)/5,36/0
l_569:		vfd a36/so  ,36/i_s,36/(rid-l_org)/5,36/(l_570-l_org)/5,36/0
l_570:		vfd a36/s   ,36/i_r,36/r_characters,36/(l_571-l_org)/5,36/0
l_571:		vfd a36/s   ,36/i_r,36/r_from,36/(l_572-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/65,36/(rtwo-l_org)/5,36/0
l_572:		vfd a36/so  ,36/i_c,36/c_figconall,36/(l_573-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_nonumlit,36/(l_573-l_org)/5,36/0
		vfd a36/so  ,36/i_s,36/(ident-l_org)/5,36/(l_573-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/182,36/(rtwo-l_org)/5,36/0
l_573:		vfd a36/s   ,36/i_r,36/r_to,36/(l_574-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/028,36/(rtwo-l_org)/5,36/0
l_574:		vfd a36/so  ,36/i_c,36/c_figconall,36/(l_575-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_nonumlit,36/(l_575-l_org)/5,36/0
		vfd a36/so  ,36/i_s,36/(ident-l_org)/5,36/(l_575-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/182,36/(rtwo-l_org)/5,36/0
l_575:		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_3
	delete:	vfd a36/so  ,36/i_r,36/r_delete,36/(l_576-l_org)/5,36/a_44
l_576:		vfd a36/    ,36/i_c,36/c_filenm,36/(l_577-l_org)/5,36/a_12
		vfd a36/    ,36/i_n,36/031,36/(rtwo-l_org)/5,36/0
l_577:		vfd a36/    ,36/i_n,36/272,36/(rtwo-l_org)/5,36/0
		vfd a36/ 2  ,36/i_n,36/93,36/(l_578-l_org)/5,36/17
		vfd a36/ 4  ,36/i_n,36/93,36/(l_578-l_org)/5,36/19
		vfd a36/    ,36/i_n,36/32,36/(rtwo-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(rtwo-l_org)/5,36/0
l_578:		vfd a36/so  ,36/i_c,36/c_notseqfl,36/(l_579-l_org)/5,36/a_152
		vfd a36/    ,36/i_n,36/219,36/(rtwo-l_org)/5,36/0
l_579:		vfd a36/s   ,36/i_r,36/r_record,36/(l_580-l_org)/5,36/0
l_580:		vfd a36/    ,36/i_c,36/c_notseqac,36/(l_581-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(de2-l_org)/5,36/a_3
l_581:		vfd a36/    ,36/i_s,36/(nik-l_org)/5,36/(de1-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_useformds,36/(l_582-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/111,36/(rtwo-l_org)/5,36/0
l_582:	de2:	vfd a36/s   ,36/i_r,36/r_end_delete,36/(verb1-l_org)/5,36/a_312
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/0
	de1:	vfd a36/    ,36/i_s,36/(iki-l_org)/5,36/(l_583-l_org)/5,36/0
l_583:		vfd a36/s   ,36/i_r,36/r_end_delete,36/(verb1-l_org)/5,36/a_266
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_310
	suppress:	vfd a36/s   ,36/i_n,36/0,36/(l_584-l_org)/5,36/a_216
l_584:		vfd a36/s   ,36/i_r,36/r_printing,36/(verb1-l_org)/5,36/a_215
		vfd a36/    ,36/i_n,36/0,36/(verb1-l_org)/5,36/a_215
	xdname:	vfd a36/    ,36/i_c,36/c_unxdnm,36/(succ-l_org)/5,36/a_309
		vfd a36/s   ,36/i_c,36/c_suxdnm,36/(ident_5-l_org)/5,36/a_113
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	ident:	vfd a36/    ,36/i_c,36/c_undana,36/(succ-l_org)/5,36/a_309
		vfd a36/s   ,36/i_c,36/c_sudana,36/(l_585-l_org)/5,36/a_279
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_585:	ident_5:	vfd a36/s   ,36/i_r,36/r_lt,36/(l_586-l_org)/5,36/a_125
		vfd a36/    ,36/i_n,36/112,36/(rtwo-l_org)/5,36/0
l_586:	ident_1:	vfd a36/    ,36/i_c,36/c_ieqlvl,36/(l_587-l_org)/5,36/a_126
		vfd a36/    ,36/i_r,36/r_rt,36/(succ-l_org)/5,36/a_118
		vfd a36/    ,36/i_n,36/113,36/(rtwo-l_org)/5,36/0
l_587:		vfd a36/so  ,36/i_c,36/c_pigz,36/(ident_1-l_org)/5,36/a_280
		vfd a36/    ,36/i_c,36/c_indexed,36/(l_588-l_org)/5,36/0
		vfd a36/so  ,36/i_c,36/c_udneli,36/(ident_1-l_org)/5,36/a_131
		vfd a36/    ,36/i_n,36/114,36/(rtwo-l_org)/5,36/0
l_588:		vfd a36/    ,36/i_c,36/c_xnm,36/(l_589-l_org)/5,36/a_135
		vfd a36/so  ,36/i_c,36/c_undana,36/(ident_4-l_org)/5,36/a_136
		vfd a36/    ,36/i_n,36/114,36/(rtwo-l_org)/5,36/0
l_589:		vfd a36/    ,36/i_c,36/c_daib,36/(l_590-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/167,36/(rtwo-l_org)/5,36/0
l_590:		vfd a36/so  ,36/i_c,36/c_indeqind,36/(l_591-l_org)/5,36/a_132
		vfd a36/    ,36/i_n,36/116,36/(rtwo-l_org)/5,36/0
l_591:		vfd a36/so  ,36/i_r,36/r_pls,36/(l_592-l_org)/5,36/0
		vfd a36/so  ,36/i_r,36/r_sub,36/(l_592-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(ident_1-l_org)/5,36/0
l_592:		vfd a36/so  ,36/i_c,36/c_unsint,36/(ident_1-l_org)/5,36/a_114
		vfd a36/    ,36/i_n,36/117,36/(rtwo-l_org)/5,36/0
	ident_4:	vfd a36/    ,36/i_c,36/c_daib,36/(ident_1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/167,36/(rtwo-l_org)/5,36/0
	rid:	vfd a36/    ,36/i_c,36/c_type9,36/(l_593-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_593:		vfd a36/    ,36/i_c,36/c_cstst,36/(l_594-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/248,36/(l_594-l_org)/5,36/0
l_594:		vfd a36/    ,36/i_s,36/(ident-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	nonumid:	vfd a36/    ,36/i_c,36/c_nonumlit,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_nonumdn,36/(l_595-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_595:		vfd a36/    ,36/i_s,36/(ident-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	usnoned:	vfd a36/    ,36/i_c,36/c_usagid,36/(l_596-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_596:		vfd a36/    ,36/i_c,36/c_edick,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	elnumint:	vfd a36/    ,36/i_c,36/c_elnuint,36/(succ-l_org)/5,36/0
	elnint:	vfd a36/    ,36/i_c,36/c_elnudnint,36/(el_1-l_org)/5,36/0
	el_2:	vfd a36/    ,36/i_r,36/r_all,36/(l_597-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_figzero,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_597:		vfd a36/s3  ,36/i_n,36/144,36/(l_598-l_org)/5,36/2
l_598:		vfd a36/    ,36/i_c,36/c_figzero,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/277,36/(rtwo-l_org)/5,36/0
	el_1:	vfd a36/    ,36/i_s,36/(ident-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	elint:	vfd a36/    ,36/i_c,36/c_elnudnint,36/(el_1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	elni:	vfd a36/    ,36/i_c,36/c_elnuit,36/(el_1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(el_2-l_org)/5,36/0
	elnuitem:	vfd a36/    ,36/i_c,36/c_nlit,36/(succ-l_org)/5,36/a_285
		vfd a36/    ,36/i_c,36/c_elnuit,36/(eln_1-l_org)/5,36/a_265
		vfd a36/    ,36/i_r,36/r_all,36/(l_599-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_figzero,36/(succ-l_org)/5,36/a_285
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_599:		vfd a36/s3  ,36/i_n,36/144,36/(l_600-l_org)/5,36/2
l_600:		vfd a36/    ,36/i_c,36/c_figzero,36/(succ-l_org)/5,36/a_285
		vfd a36/    ,36/i_n,36/314,36/(rtwo-l_org)/5,36/0
	eln_1:	vfd a36/    ,36/i_s,36/(ident-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	elusid:	vfd a36/    ,36/i_c,36/c_nonumlit,36/(elus_1-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_figconall,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_eldis,36/(l_601-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_601:		vfd a36/    ,36/i_n,36/0,36/(l_602-l_org)/5,36/a_214
l_602:		vfd a36/    ,36/i_s,36/(ident-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	elus_1:	vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/a_214
	usagid:	vfd a36/    ,36/i_c,36/c_usagid,36/(alel2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	alelnuit:	vfd a36/    ,36/i_s,36/(alel-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	alel:	vfd a36/    ,36/i_c,36/c_altst,36/(l_603-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_603:	alel1:	vfd a36/    ,36/i_c,36/c_cstst,36/(l_604-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/248,36/(l_604-l_org)/5,36/0
l_604:	alel2:	vfd a36/    ,36/i_s,36/(ident-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	edalel:	vfd a36/    ,36/i_c,36/c_edaltst,36/(alel1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	xnm:	vfd a36/    ,36/i_c,36/c_xnm,36/(l_605-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_605:		vfd a36/    ,36/i_c,36/c_cstst,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/248,36/(succ-l_org)/5,36/0
	impseq:	vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(l_606-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_606:	imps1:	vfd a36/s   ,36/i_c,36/c_period,36/(l_607-l_org)/5,36/a_290
		vfd a36/    ,36/i_n,36/279,36/(rtwo-l_org)/5,36/0
l_607:		vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(imps1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	is_imp:	vfd a36/    ,36/i_s,36/(imp-l_org)/5,36/(l_608-l_org)/5,36/0
l_608:		vfd a36/    ,36/i_c,36/c_is_imp,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/145,36/(rtwo-l_org)/5,36/0
	imp:	vfd a36/    ,36/i_c,36/c_paranm,36/(fail-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_sechdr,36/(fail-l_org)/5,36/0
		vfd a36/    ,36/i_r,36/r_use,36/(fail-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_enddec,36/(fail-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_endcob,36/(fail-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_609-l_org)/5,36/a_90
l_609:		vfd a36/    ,36/i_c,36/c_verb,36/(l_610-l_org)/5,36/a_91
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_610:	imp1:	vfd a36/    ,36/i_c,36/c_preosp,36/(l_611-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_impvrb,36/(imp1-l_org)/5,36/a_112
		vfd a36/    ,36/i_n,36/145,36/(rtwo-l_org)/5,36/0
l_611:		vfd a36/    ,36/i_n,36/126,36/(rtwo-l_org)/5,36/0
	verb1:	vfd a36/    ,36/i_c,36/c_verb,36/(imp1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/a_93
	ae:	vfd a36/s   ,36/i_r,36/r_at,36/(l_612-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_end,36/(succ-l_org)/5,36/a_85
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_612:		vfd a36/s   ,36/i_r,36/r_end,36/(succ-l_org)/5,36/a_85
		vfd a36/    ,36/i_n,36/306,36/(rtwo-l_org)/5,36/0
	nae:	vfd a36/s   ,36/i_r,36/r_not,36/(l_613-l_org)/5,36/a_292
		vfd a36/    ,36/i_s,36/(ae-l_org)/5,36/(succ-l_org)/5,36/a_302
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_613:		vfd a36/    ,36/i_s,36/(ae-l_org)/5,36/(succ-l_org)/5,36/a_302
		vfd a36/    ,36/i_n,36/139,36/(rtwo-l_org)/5,36/0
	aei:	vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(l_614-l_org)/5,36/0
l_614:		vfd a36/    ,36/i_c,36/c_not_opt,36/(aei2-l_org)/5,36/a_293
		vfd a36/s   ,36/i_r,36/r_not,36/(l_615-l_org)/5,36/a_294
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
l_615:		vfd a36/    ,36/i_s,36/(ae-l_org)/5,36/(l_616-l_org)/5,36/a_195
		vfd a36/    ,36/i_n,36/139,36/(rtwo-l_org)/5,36/0
l_616:	aei1:	vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(l_617-l_org)/5,36/0
l_617:		vfd a36/s   ,36/i_r,36/r_not,36/(l_618-l_org)/5,36/a_294
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
l_618:		vfd a36/    ,36/i_s,36/(ae-l_org)/5,36/(l_619-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/139,36/(rtwo-l_org)/5,36/0
l_619:		vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	aei2:	vfd a36/    ,36/i_s,36/(ae-l_org)/5,36/(aei1-l_org)/5,36/a_195
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	ik:	vfd a36/s   ,36/i_r,36/r_invalid,36/(l_620-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_620:		vfd a36/s   ,36/i_r,36/r_key,36/(succ-l_org)/5,36/a_85
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/a_85
	nik:	vfd a36/s   ,36/i_r,36/r_not,36/(l_621-l_org)/5,36/a_292
		vfd a36/    ,36/i_s,36/(ik-l_org)/5,36/(succ-l_org)/5,36/a_110
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_621:		vfd a36/    ,36/i_s,36/(ik-l_org)/5,36/(succ-l_org)/5,36/a_110
		vfd a36/    ,36/i_n,36/111,36/(rtwo-l_org)/5,36/0
	iki:	vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(l_622-l_org)/5,36/0
l_622:		vfd a36/    ,36/i_c,36/c_not_opt,36/(iki2-l_org)/5,36/a_293
		vfd a36/s   ,36/i_r,36/r_not,36/(l_623-l_org)/5,36/a_294
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
l_623:		vfd a36/    ,36/i_s,36/(ik-l_org)/5,36/(l_624-l_org)/5,36/a_195
		vfd a36/    ,36/i_n,36/111,36/(rtwo-l_org)/5,36/0
l_624:	iki1:	vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(l_625-l_org)/5,36/0
l_625:		vfd a36/s   ,36/i_r,36/r_not,36/(l_626-l_org)/5,36/a_294
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
l_626:		vfd a36/    ,36/i_s,36/(ik-l_org)/5,36/(l_627-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/111,36/(rtwo-l_org)/5,36/0
l_627:		vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	iki2:	vfd a36/    ,36/i_s,36/(ik-l_org)/5,36/(iki1-l_org)/5,36/a_195
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	ov:	vfd a36/s   ,36/i_r,36/r_on,36/(l_628-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_overflow,36/(succ-l_org)/5,36/a_85
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_628:		vfd a36/s   ,36/i_r,36/r_overflow,36/(succ-l_org)/5,36/a_85
		vfd a36/    ,36/i_n,36/307,36/(rtwo-l_org)/5,36/0
	nov:	vfd a36/s   ,36/i_r,36/r_not,36/(l_629-l_org)/5,36/a_292
		vfd a36/    ,36/i_s,36/(ov-l_org)/5,36/(succ-l_org)/5,36/a_270
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_629:		vfd a36/    ,36/i_s,36/(ov-l_org)/5,36/(succ-l_org)/5,36/a_270
		vfd a36/    ,36/i_n,36/261,36/(rtwo-l_org)/5,36/0
	ovi:	vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(l_630-l_org)/5,36/0
l_630:		vfd a36/    ,36/i_c,36/c_not_opt,36/(ovi2-l_org)/5,36/a_293
		vfd a36/s   ,36/i_r,36/r_not,36/(l_631-l_org)/5,36/a_294
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
l_631:		vfd a36/    ,36/i_s,36/(ov-l_org)/5,36/(l_632-l_org)/5,36/a_195
		vfd a36/    ,36/i_n,36/261,36/(rtwo-l_org)/5,36/0
l_632:	ovi1:	vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(l_633-l_org)/5,36/0
l_633:		vfd a36/s   ,36/i_r,36/r_not,36/(l_634-l_org)/5,36/a_294
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
l_634:		vfd a36/    ,36/i_s,36/(ov-l_org)/5,36/(l_635-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/261,36/(rtwo-l_org)/5,36/0
l_635:		vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	ovi2:	vfd a36/    ,36/i_s,36/(ov-l_org)/5,36/(ovi1-l_org)/5,36/a_195
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	os:	vfd a36/s   ,36/i_r,36/r_on,36/(l_636-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_size,36/(os1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_636:		vfd a36/s   ,36/i_r,36/r_size,36/(l_637-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/308,36/(rtwo-l_org)/5,36/0
l_637:	os1:	vfd a36/s   ,36/i_r,36/r_error,36/(succ-l_org)/5,36/a_85
		vfd a36/    ,36/i_n,36/309,36/(rtwo-l_org)/5,36/0
	nos:	vfd a36/s   ,36/i_r,36/r_not,36/(l_638-l_org)/5,36/a_292
		vfd a36/    ,36/i_s,36/(os-l_org)/5,36/(succ-l_org)/5,36/a_301
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_638:		vfd a36/    ,36/i_s,36/(os-l_org)/5,36/(succ-l_org)/5,36/a_301
		vfd a36/    ,36/i_n,36/143,36/(rtwo-l_org)/5,36/0
	osi:	vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(l_639-l_org)/5,36/0
l_639:		vfd a36/    ,36/i_c,36/c_not_opt,36/(osi2-l_org)/5,36/a_293
		vfd a36/s   ,36/i_r,36/r_not,36/(l_640-l_org)/5,36/a_294
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
l_640:		vfd a36/    ,36/i_s,36/(os-l_org)/5,36/(l_641-l_org)/5,36/a_195
		vfd a36/    ,36/i_n,36/143,36/(rtwo-l_org)/5,36/0
l_641:	osi1:	vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(l_642-l_org)/5,36/0
l_642:		vfd a36/s   ,36/i_r,36/r_not,36/(l_643-l_org)/5,36/a_294
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
l_643:		vfd a36/    ,36/i_s,36/(os-l_org)/5,36/(l_644-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/143,36/(rtwo-l_org)/5,36/0
l_644:		vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	osi2:	vfd a36/    ,36/i_s,36/(os-l_org)/5,36/(osi1-l_org)/5,36/a_195
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	eop:	vfd a36/s   ,36/i_r,36/r_at,36/(l_645-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_eop,36/(succ-l_org)/5,36/a_85
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_645:		vfd a36/s   ,36/i_r,36/r_eop,36/(succ-l_org)/5,36/a_85
		vfd a36/    ,36/i_n,36/305,36/(rtwo-l_org)/5,36/0
	neop:	vfd a36/s   ,36/i_r,36/r_not,36/(l_646-l_org)/5,36/a_292
		vfd a36/    ,36/i_s,36/(eop-l_org)/5,36/(succ-l_org)/5,36/a_304
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_646:		vfd a36/    ,36/i_s,36/(eop-l_org)/5,36/(succ-l_org)/5,36/a_304
		vfd a36/    ,36/i_n,36/171,36/(rtwo-l_org)/5,36/0
	eopi:	vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(l_647-l_org)/5,36/0
l_647:		vfd a36/    ,36/i_c,36/c_not_opt,36/(eopi2-l_org)/5,36/a_293
		vfd a36/s   ,36/i_r,36/r_not,36/(l_648-l_org)/5,36/a_294
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
l_648:		vfd a36/    ,36/i_s,36/(eop-l_org)/5,36/(l_649-l_org)/5,36/a_195
		vfd a36/    ,36/i_n,36/171,36/(rtwo-l_org)/5,36/0
l_649:	eopi1:	vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(l_650-l_org)/5,36/0
l_650:		vfd a36/s   ,36/i_r,36/r_not,36/(l_651-l_org)/5,36/a_294
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
l_651:		vfd a36/    ,36/i_s,36/171,36/(rtwo-l_org)/5,36/0
l_652:		vfd a36/    ,36/i_s,36/(is_imp-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(succ-l_org)/5,36/(l_653-l_org)/5,36/0
l_653:	eopi2:	vfd a36/    ,36/i_s,36/(eop-l_org)/5,36/(eopi1-l_org)/5,36/a_195
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	wd:	vfd a36/s   ,36/i_r,36/r_with,36/(l_654-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_data,36/(succ-l_org)/5,36/a_85
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_654:		vfd a36/s   ,36/i_r,36/r_data,36/(succ-l_org)/5,36/a_85
		vfd a36/    ,36/i_n,36/333,36/(rtwo-l_org)/5,36/0
	nd:	vfd a36/s   ,36/i_r,36/r_no,36/(l_655-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_655:		vfd a36/s   ,36/i_r,36/r_data,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/333,36/(rtwo-l_org)/5,36/0
	rone:	vfd a36/    ,36/i_n,36/164,36/(rone_1-l_org)/5,36/0
	ronea:	vfd a36/    ,36/i_n,36/165,36/(pd_1-l_org)/5,36/0
	rone_1:	vfd a36/    ,36/i_c,36/c_prdef,36/(ronea-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_endcob,36/(ronea-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_verb,36/(ronea-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_per,36/(ronea-l_org)/5,36/a_274
		vfd a36/    ,36/i_r,36/r_declaratives,36/(ronea-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/0,36/(rone_1-l_org)/5,36/0
	rtwo:	vfd a36/    ,36/i_n,36/164,36/(rtwo_1-l_org)/5,36/0
	rtwob:	vfd a36/    ,36/i_n,36/165,36/(palp_3-l_org)/5,36/a_130
	rtwo_1:	vfd a36/    ,36/i_c,36/c_prdef,36/(rtwob-l_org)/5,36/a_274
		vfd a36/    ,36/i_c,36/c_endcob,36/(rtwob-l_org)/5,36/a_274
		vfd a36/    ,36/i_c,36/c_verb,36/(rtwob-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_per,36/(rtwob-l_org)/5,36/a_273
		vfd a36/    ,36/i_c,36/c_deswon,36/(l_656-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/0,36/(rtwo_1-l_org)/5,36/0
l_656:		vfd a36/    ,36/i_c,36/c_enddec,36/(rtwob-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/0,36/(rtwo_1-l_org)/5,36/0
	rthr:	vfd a36/    ,36/i_n,36/164,36/(rthr_1-l_org)/5,36/0
	rthrb:	vfd a36/    ,36/i_n,36/165,36/(proc-l_org)/5,36/a_130
	rthrc:	vfd a36/    ,36/i_n,36/165,36/(palp_3-l_org)/5,36/a_130
	rthre:	vfd a36/    ,36/i_n,36/165,36/(use-l_org)/5,36/a_130
	rthr_1:	vfd a36/    ,36/i_c,36/c_sechdr,36/(rthrb-l_org)/5,36/a_273
		vfd a36/    ,36/i_c,36/c_prdef,36/(rthrb-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_enddec,36/(rthrb-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_endcob,36/(rthrb-l_org)/5,36/a_273
		vfd a36/    ,36/i_r,36/r_use,36/(rthre-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_verb,36/(rthrc-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_per,36/(rthr_1-l_org)/5,36/a_273
		vfd a36/s   ,36/i_n,36/0,36/(rthr_1-l_org)/5,36/0
	rfiv:	vfd a36/    ,36/i_r,36/r_section,36/(sec-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/0,36/(rfiv-l_org)/5,36/0
	succ:	vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/a_1
	fail:	vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/a_2
	expr:	vfd a36/    ,36/i_n,36/0,36/(l_657-l_org)/5,36/a_220
l_657:		vfd a36/s   ,36/i_r,36/r_lt,36/(l_657-l_org)/5,36/a_221
		vfd a36/    ,36/i_s,36/(arithexp-l_org)/5,36/(l_658-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(ctrm-l_org)/5,36/0
l_658:		vfd a36/    ,36/i_c,36/c_is_rel,36/(infix_rel-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/a_258
	condition:	vfd a36/    ,36/i_n,36/0,36/(l_659-l_org)/5,36/a_220
l_659:	lpar:	vfd a36/s   ,36/i_r,36/r_lt,36/(lpar-l_org)/5,36/a_221
	ctrm:	vfd a36/    ,36/i_s,36/(relop-l_org)/5,36/(imp_subj-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_not,36/(not_cond-l_org)/5,36/a_297
		vfd a36/s   ,36/i_r,36/r_is,36/(is_cond-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(pos_rel-l_org)/5,36/(imp_subj-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_message,36/(l_660-l_org)/5,36/a_224
		vfd a36/    ,36/i_s,36/(condop-l_org)/5,36/(infix_rel-l_org)/5,36/a_264
		vfd a36/ o  ,36/i_c,36/c_sscondnm,36/(bop2-l_org)/5,36/a_219
		vfd a36/    ,36/i_n,36/210,36/(rtwo-l_org)/5,36/0
l_660:		vfd a36/s   ,36/i_r,36/r_for,36/(l_661-l_org)/5,36/0
l_661:		vfd a36/so  ,36/i_c,36/c_incdnm,36/(bop-l_org)/5,36/a_325
		vfd a36/    ,36/i_n,36/207,36/(rtwo-l_org)/5,36/0
	not_cond:	vfd a36/    ,36/i_r,36/r_lt,36/(not_cond1-l_org)/5,36/a_222
		vfd a36/    ,36/i_s,36/(relop-l_org)/5,36/(imp_subj-l_org)/5,36/a_223
		vfd a36/    ,36/i_n,36/0,36/(l_662-l_org)/5,36/a_222
l_662:		vfd a36/s   ,36/i_r,36/r_not,36/(rel-l_org)/5,36/a_223
		vfd a36/    ,36/i_n,36/0,36/(ctrm-l_org)/5,36/0
	not_cond1:	vfd a36/    ,36/i_n,36/0,36/(lpar-l_org)/5,36/a_298
	is_cond:	vfd a36/s   ,36/i_r,36/r_not,36/(rel-l_org)/5,36/a_223
		vfd a36/    ,36/i_s,36/(relop-l_org)/5,36/(imp_subj-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_unequal,36/(l_663-l_org)/5,36/a_224
		vfd a36/    ,36/i_n,36/201,36/(rtwo-l_org)/5,36/0
l_663:		vfd a36/s   ,36/i_r,36/r_to,36/(imp_subj-l_org)/5,36/a_325
		vfd a36/    ,36/i_n,36/0,36/(imp_subj-l_org)/5,36/a_325
	infix_rel:	vfd a36/    ,36/i_s,36/(relop-l_org)/5,36/(obj_op-l_org)/5,36/a_210
		vfd a36/s   ,36/i_r,36/r_not,36/(inf_rel-l_org)/5,36/a_223
		vfd a36/s   ,36/i_r,36/r_is,36/(inf_is-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(pos_rel-l_org)/5,36/(obj_op-l_org)/5,36/a_325
	inf_test:	vfd a36/    ,36/i_c,36/c_pnz,36/(l_664-l_org)/5,36/a_299
		vfd a36/    ,36/i_r,36/r_numeric,36/(notal-l_org)/5,36/a_224
		vfd a36/    ,36/i_r,36/r_alphabetic,36/(notnum-l_org)/5,36/a_224
		vfd a36/    ,36/i_c,36/c_is_sub_opt,36/(bop1-l_org)/5,36/a_228
		vfd a36/    ,36/i_n,36/215,36/(rtwo-l_org)/5,36/0
l_664:		vfd a36/ 3  ,36/i_n,36/15,36/(l_665-l_org)/5,36/2
l_665:		vfd a36/s   ,36/i_c,36/c_numstak,36/(bop-l_org)/5,36/a_325
		vfd a36/s   ,36/i_n,36/202,36/(bop-l_org)/5,36/a_325
	notal:	vfd a36/s   ,36/i_c,36/c_notalpstk,36/(bop-l_org)/5,36/a_150
		vfd a36/s   ,36/i_n,36/208,36/(bop-l_org)/5,36/a_150
	notnum:	vfd a36/s   ,36/i_c,36/c_notnumstk,36/(bop-l_org)/5,36/a_151
		vfd a36/s   ,36/i_n,36/206,36/(bop-l_org)/5,36/a_151
	inf_is:	vfd a36/s   ,36/i_r,36/r_not,36/(inf_rel-l_org)/5,36/a_223
		vfd a36/    ,36/i_s,36/(relop-l_org)/5,36/(obj_op-l_org)/5,36/a_327
		vfd a36/s   ,36/i_r,36/r_unequal,36/(l_666-l_org)/5,36/a_224
		vfd a36/    ,36/i_n,36/0,36/(inf_test-l_org)/5,36/0
l_666:		vfd a36/s   ,36/i_r,36/r_to,36/(obj_op-l_org)/5,36/a_325
		vfd a36/    ,36/i_n,36/0,36/(obj_op-l_org)/5,36/a_325
	inf_rel:	vfd a36/    ,36/i_s,36/(relop-l_org)/5,36/(obj_op-l_org)/5,36/a_327
		vfd a36/    ,36/i_n,36/0,36/(inf_test-l_org)/5,36/0
	obj_op:	vfd a36/    ,36/i_n,36/0,36/(obj_op3-l_org)/5,36/a_225
	rel:	vfd a36/    ,36/i_s,36/(relop-l_org)/5,36/(l_667-l_org)/5,36/0
l_667:	imp_subj:	vfd a36/    ,36/i_c,36/c_is_sub_opt,36/(l_668-l_org)/5,36/a_226
		vfd a36/    ,36/i_n,36/215,36/(rtwo-l_org)/5,36/0
l_668:	obj_op3:	vfd a36/    ,36/i_s,36/(condop-l_org)/5,36/(bop1-l_org)/5,36/a_229
		vfd a36/    ,36/i_n,36/218,36/(rtwo-l_org)/5,36/0
	bop2:	vfd a36/s3  ,36/i_n,36/14,36/(l_669-l_org)/5,36/2
l_669:	bop:	vfd a36/    ,36/i_n,36/0,36/(l_670-l_org)/5,36/a_227
l_670:	bop1:	vfd a36/    ,36/i_n,36/0,36/(l_671-l_org)/5,36/a_230
l_671:		vfd a36/    ,36/i_r,36/r_and,36/(bop4-l_org)/5,36/a_233
	bop3:	vfd a36/    ,36/i_r,36/r_or,36/(bop4-l_org)/5,36/a_234
		vfd a36/s   ,36/i_r,36/r_rt,36/(rpar-l_org)/5,36/a_325
		vfd a36/    ,36/i_c,36/c_lev_test,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/205,36/(rtwo-l_org)/5,36/0
	bop4:	vfd a36/s   ,36/i_c,36/c_cond_name,36/(lpar-l_org)/5,36/0
		vfd a36/s3  ,36/i_n,36/17,36/(lpar-l_org)/5,36/2
	rpar:	vfd a36/    ,36/i_c,36/c_actloglp,36/(l_672-l_org)/5,36/a_231
		vfd a36/    ,36/i_n,36/205,36/(rtwo-l_org)/5,36/0
l_672:	more_rpar:	vfd a36/s   ,36/i_r,36/r_rt,36/(test_lpar-l_org)/5,36/a_325
		vfd a36/    ,36/i_r,36/r_and,36/(bop4-l_org)/5,36/a_235
		vfd a36/    ,36/i_n,36/0,36/(l_673-l_org)/5,36/a_236
l_673:		vfd a36/    ,36/i_n,36/0,36/(bop3-l_org)/5,36/a_232
	test_lpar:	vfd a36/    ,36/i_c,36/c_lptopstk,36/(more_rpar-l_org)/5,36/a_232
		vfd a36/    ,36/i_n,36/205,36/(rtwo-l_org)/5,36/0
	pos_rel:	vfd a36/    ,36/i_r,36/r_equals,36/(pos_rel1-l_org)/5,36/a_224
		vfd a36/    ,36/i_r,36/r_exceeds,36/(pos_rel1-l_org)/5,36/a_224
		vfd a36/    ,36/i_r,36/r_unequal,36/(pos_rel2-l_org)/5,36/a_224
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	pos_rel1:	vfd a36/s5  ,36/i_n,36/156,36/(l_674-l_org)/5,36/25
l_674:		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	pos_rel2:	vfd a36/s5  ,36/i_n,36/156,36/(l_675-l_org)/5,36/25
l_675:		vfd a36/s   ,36/i_r,36/r_to,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	relop:	vfd a36/s   ,36/i_c,36/c_relop,36/(l_676-l_org)/5,36/a_224
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_676:		vfd a36/s   ,36/i_r,36/r_to,36/(succ-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_than,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	condop:	vfd a36/    ,36/i_n,36/0,36/(l_677-l_org)/5,36/a_209
l_677:		vfd a36/    ,36/i_r,36/r_all,36/(cop4-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(arithexp-l_org)/5,36/(succ-l_org)/5,36/a_212
		vfd a36/so  ,36/i_s,36/(ident-l_org)/5,36/(succ-l_org)/5,36/a_307
	cop3:	vfd a36/so  ,36/i_c,36/c_lit,36/(succ-l_org)/5,36/a_211
	cop2:	vfd a36/so  ,36/i_c,36/c_figconall,36/(succ-l_org)/5,36/a_211
		vfd a36/so  ,36/i_c,36/c_xnm,36/(succ-l_org)/5,36/a_211
		vfd a36/so  ,36/i_s,36/(xdname-l_org)/5,36/(succ-l_org)/5,36/a_307
		vfd a36/    ,36/i_r,36/r_all,36/(l_678-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_678:	cop4:	vfd a36/s3  ,36/i_n,36/144,36/(l_679-l_org)/5,36/2
l_679:		vfd a36/so  ,36/i_c,36/c_figconall,36/(succ-l_org)/5,36/a_211
		vfd a36/    ,36/i_c,36/c_nonumlit,36/(cop3-l_org)/5,36/a_149
		vfd a36/    ,36/i_n,36/172,36/(rtwo-l_org)/5,36/0
	arithexp:	vfd a36/    ,36/i_n,36/0,36/(l_680-l_org)/5,36/a_207
l_680:	aexp_1:	vfd a36/    ,36/i_r,36/r_pls,36/(l_681-l_org)/5,36/a_284
		vfd a36/    ,36/i_r,36/r_sub,36/(l_681-l_org)/5,36/a_201
		vfd a36/    ,36/i_n,36/0,36/(aexp_4-l_org)/5,36/0
l_681:		vfd a36/s   ,36/i_n,36/0,36/(l_682-l_org)/5,36/a_208
l_682:	aexp_4:	vfd a36/so  ,36/i_s,36/(elnuitem-l_org)/5,36/(l_683-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_lt,36/(aexp_1-l_org)/5,36/a_202
		vfd a36/    ,36/i_c,36/c_zerstk,36/(fail-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/214,36/(rtwo-l_org)/5,36/0
l_683:	aexp_2:	vfd a36/s   ,36/i_c,36/c_arop,36/(aexp_1-l_org)/5,36/a_203
		vfd a36/    ,36/i_n,36/0,36/(l_684-l_org)/5,36/a_204
l_684:		vfd a36/    ,36/i_r,36/r_rt,36/(l_685-l_org)/5,36/a_284
		vfd a36/    ,36/i_c,36/c_zerstk,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/214,36/(rtwo-l_org)/5,36/0
l_685:		vfd a36/s   ,36/i_c,36/c_lefparstk,36/(aexp_2-l_org)/5,36/a_205
		vfd a36/s   ,36/i_c,36/c_logbitstk,36/(aexp_2-l_org)/5,36/a_206
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_686-l_org)/5,36/0
l_686:		vfd a36/    ,36/i_r,36/r_records,36/(l_686-l_org)/5,36/0
l_687:		vfd a36/    ,36/i_r,36/r_in,36/(l_687-l_org)/5,36/0
l_688:		vfd a36/    ,36/i_r,36/r_of,36/(l_688-l_org)/5,36/0
l_689:		vfd a36/    ,36/i_r,36/r_end_of_page,36/(l_689-l_org)/5,36/0
l_690:		vfd a36/    ,36/i_r,36/r_equal,36/(l_690-l_org)/5,36/0
l_691:		vfd a36/    ,36/i_r,36/r_greater,36/(l_691-l_org)/5,36/0
l_692:		vfd a36/    ,36/i_r,36/r_copy,36/(l_692-l_org)/5,36/0
l_693:		vfd a36/    ,36/i_r,36/r_corr,36/(l_693-l_org)/5,36/0
l_694:		vfd a36/    ,36/i_r,36/r_corresponding,36/(l_694-l_org)/5,36/0
l_695:		vfd a36/    ,36/i_r,36/r_off,36/(l_695-l_org)/5,36/0
l_696:		vfd a36/    ,36/i_r,36/r_replace,36/(l_696-l_org)/5,36/0
l_697:		vfd a36/    ,36/i_r,36/r_high_value,36/(l_697-l_org)/5,36/0
l_698:		vfd a36/    ,36/i_r,36/r_high_values,36/(l_698-l_org)/5,36/0
l_699:		vfd a36/    ,36/i_r,36/r_low_value,36/(l_699-l_org)/5,36/0
l_700:		vfd a36/    ,36/i_r,36/r_low_values,36/(l_700-l_org)/5,36/0
l_701:		vfd a36/    ,36/i_r,36/r_zero,36/(l_701-l_org)/5,36/0
l_702:		vfd a36/    ,36/i_r,36/r_zeros,36/(l_702-l_org)/5,36/0
l_703:		vfd a36/    ,36/i_r,36/r_zeroes,36/(l_703-l_org)/5,36/0
l_704:		vfd a36/    ,36/i_r,36/r_quote,36/(l_704-l_org)/5,36/0
l_705:		vfd a36/    ,36/i_r,36/r_quotes,36/(l_705-l_org)/5,36/0
l_706:		vfd a36/    ,36/i_r,36/r_space,36/(l_706-l_org)/5,36/0
l_707:		vfd a36/    ,36/i_r,36/r_spaces,36/(l_707-l_org)/5,36/0
l_708:		vfd a36/    ,36/i_r,36/r_linage_counter,36/(l_708-l_org)/5,36/0
l_709:		vfd a36/    ,36/i_r,36/r_negative,36/(l_709-l_org)/5,36/0
l_710:		vfd a36/    ,36/i_r,36/r_positive,36/(l_710-l_org)/5,36/0
l_711:		vfd a36/    ,36/i_r,36/r_through,36/(l_711-l_org)/5,36/0
l_712:		vfd a36/    ,36/i_r,36/r_character,36/(l_712-l_org)/5,36/0
l_713:		vfd a36/    ,36/i_r,36/r_line,36/(l_713-l_org)/5,36/0
l_714:		vfd a36/    ,36/i_r,36/r_pls,36/(l_714-l_org)/5,36/0
l_715:		vfd a36/    ,36/i_r,36/r_sub,36/(l_715-l_org)/5,36/0
l_716:		vfd a36/    ,36/i_r,36/r_tim,36/(l_716-l_org)/5,36/0
l_717:		vfd a36/    ,36/i_r,36/r_div,36/(l_717-l_org)/5,36/0
l_718:		vfd a36/    ,36/i_r,36/r_exp,36/(l_718-l_org)/5,36/0
l_719:		vfd a36/    ,36/i_r,36/r_ls,36/(l_719-l_org)/5,36/0
l_720:		vfd a36/    ,36/i_r,36/r_gt,36/(l_720-l_org)/5,36/0
l_721:		vfd a36/    ,36/i_r,36/r_eq,36/(l_721-l_org)/5,36/0
l_722:		vfd a36/    ,36/i_r,36/r_initialize,36/(l_722-l_org)/5,36/0
l_723:		vfd a36/    ,36/i_r,36/r_alphanumeric,36/(l_723-l_org)/5,36/0
l_724:		vfd a36/    ,36/i_r,36/r_alphanumeric_edited,36/(l_724-l_org)/5,36/0
l_725:		vfd a36/    ,36/i_r,36/r_numeric_edited,36/(l_725-l_org)/5,36/0
	equ c_acc_dev,197
	equ c_actloglp,136
	equ c_adrisadr,158
	equ c_alelnuitm,117
	equ c_alph,105
	equ c_alphnm,195
	equ c_alphoral,122
	equ c_altlegal,191
	equ c_altprnm,13
	equ c_altst,188
	equ c_amarg,201
	equ c_an,102
	equ c_andait,68
	equ c_anes,98
	equ c_argscomp,135
	equ c_arop,80
	equ c_aroprp,123
	equ c_asfil,49
	equ c_cdname,87
	equ c_ckdecpn,167
	equ c_ckdsegnum,171
	equ c_ckerrex,172
	equ c_ckextend,176
	equ c_ckinput,173
	equ c_ckintbit,170
	equ c_ckio,175
	equ c_cklit,166
	equ c_cklit1,180
	equ c_cklit2,182
	equ c_ckoutput,174
	equ c_ckprpnbit,152
	equ c_ckrcpref,165
	equ c_ckrng1,163
	equ c_ckrng2,164
	equ c_cksegm,168
	equ c_cktp25,162
	equ c_cond_name,212
	equ c_csstst,190
	equ c_cstst,187
	equ c_daib,140
	equ c_dana,88
	equ c_debug,214
	equ c_decnondec,151
	equ c_descnm,26
	equ c_descnmra,35
	equ c_deswon,90
	equ c_deswz,86
	equ c_devprt,210
	equ c_disp_dev,198
	equ c_dninfl,61
	equ c_ecnt,34
	equ c_edalelnue,120
	equ c_edalit,116
	equ c_edaltst,189
	equ c_edick,161
	equ c_egrze,69
	equ c_elaanne,149
	equ c_eldis,95
	equ c_elemred,82
	equ c_elneds,64
	equ c_elnudnint,119
	equ c_elnuindi,65
	equ c_elnuint,118
	equ c_elnuit,66
	equ c_endcob,39
	equ c_enddec,115
	equ c_examlitid,81
	equ c_figconall,22
	equ c_figzero,216
	equ c_file,67
	equ c_filenm,5
	equ c_fileno,43
	equ c_filnefil,143
	equ c_filno,121
	equ c_flusisds,63
	equ c_formtlb,6
	equ c_gotod,145
	equ c_group,99
	equ c_ieqlvl,75
	equ c_impvrb,41
	equ c_inbit,1
	equ c_incdnm,18
	equ c_indeqind,77
	equ c_indev,153
	equ c_indexed,76
	equ c_indxfile,144
	equ c_inrng,47
	equ c_is_cobol,24
	equ c_is_cond,218
	equ c_is_imp,139
	equ c_is_lang,200
	equ c_is_rel,85
	equ c_is_rout,160
	equ c_is_sub_opt,126
	equ c_is_user_word,206
	equ c_ixfil,20
	equ c_ixrlrady,83
	equ c_ixrlsqdy,155
	equ c_keyiskey,157
	equ c_keylbl,52
	equ c_lefdep,112
	equ c_lefparstk,131
	equ c_lev_test,192
	equ c_lident,2
	equ c_linage,71
	equ c_linktot,3
	equ c_lit,21
	equ c_logbitstk,132
	equ c_logstk,133
	equ c_lptopstk,137
	equ c_mcobol,181
	equ c_mnenm,56
	equ c_msfile,72
	equ c_msfilnm,31
	equ c_nae,220
	equ c_noo,217
	equ c_not,221
	equ c_njustr,146
	equ c_nlit,208
	equ c_nomsss,30
	equ c_nonumdn,147
	equ c_nonumlit,15
	equ c_not_opt,215
	equ c_notalpstk,129
	equ c_notnumstk,128
	equ c_notseqac,29
	equ c_notseqfl,38
	equ c_nsfilnm,17
	equ c_nsrecnm,70
	equ c_nstorg,185
	equ c_nstream,183
	equ c_nues,97
	equ c_numlit,12
	equ c_numstak,127
	equ c_nznumlit,169
	equ c_on_off,196
	equ c_onechnosn,54
	equ c_open_mode,207
	equ c_outcdnm,19
	equ c_outdev,154
	equ c_outrng,48
	equ c_paranm,8
	equ c_period,219
	equ c_pigz,78
	equ c_pigz_by,209
	equ c_pn_pres,213
	equ c_pnz,125
	equ c_posint,59
	equ c_prdef,8
	equ c_preosp,40
	equ c_preospn,96
	equ c_prnm,14
	equ c_prnum,10
	equ c_prt_con,199
	equ c_rae,148
	equ c_rafl,45
	equ c_recnm,46
	equ c_relfile,156
	equ c_relop,124
	equ c_repnm,27
	equ c_resword,193
	equ c_rident,7
	equ c_ritdep,111
	equ c_rpid,25
	equ c_saanm,36
	equ c_said,37
	equ c_san,110
	equ c_sechdr,4
	equ c_secsw,84
	equ c_seqfil,53
	equ c_seqnext,91
	equ c_seqstmfil,211
	equ c_set_pigz,203
	equ c_set_xint,202
	equ c_sina,11
	equ c_sizlit,28
	equ c_slelef,114
	equ c_sler,100
	equ c_snae,108
	equ c_snal,107
	equ c_sndrdp,103
	equ c_snne,109
	equ c_snon,106
	equ c_snor,101
	equ c_snos,104
	equ c_sqacdyac,23
	equ c_sqfl,44
	equ c_sqrlsqac,55
	equ c_srchf2,142
	equ c_srchid,50
	equ c_srchverb,141
	equ c_srtfil,60
	equ c_sscondnm,134
	equ c_ssnm,159
	equ c_sterm,93
	equ c_stream,184
	equ c_stun,113
	equ c_sudana,74
	equ c_suxdnm,150
	equ c_tst_pigz,205
	equ c_tst_xint,204
	equ c_type9,194
	equ c_udneli,186
	equ c_undana,73
	equ c_unelnudn,92
	equ c_unsint,79
	equ c_unxdnm,138
	equ c_usagid,94
	equ c_useform1,32
	equ c_useform1a,57
	equ c_useform1b,89
	equ c_useformds,177
	equ c_useformr,178
	equ c_useformrw,179
	equ c_useid,16
	equ c_usisds,62
	equ c_usornm,51
	equ c_varsiz,42
	equ c_verb,9
	equ c_xint,58
	equ c_xnm,33
	equ c_zerstk,130
	equ a_1,1
	equ a_10,10
	equ a_100,100
	equ a_101,101
	equ a_102,102
	equ a_103,103
	equ a_104,104
	equ a_105,105
	equ a_106,106
	equ a_107,107
	equ a_108,108
	equ a_109,109
	equ a_11,11
	equ a_110,110
	equ a_111,111
	equ a_112,112
	equ a_113,113
	equ a_114,114
	equ a_115,115
	equ a_116,116
	equ a_117,117
	equ a_118,118
	equ a_119,119
	equ a_12,12
	equ a_120,120
	equ a_121,121
	equ a_122,122
	equ a_123,123
	equ a_124,124
	equ a_125,125
	equ a_126,126
	equ a_127,127
	equ a_128,128
	equ a_129,129
	equ a_13,13
	equ a_130,130
	equ a_131,131
	equ a_132,132
	equ a_133,133
	equ a_134,134
	equ a_135,135
	equ a_136,136
	equ a_137,137
	equ a_139,139
	equ a_14,14
	equ a_140,140
	equ a_141,141
	equ a_142,142
	equ a_143,143
	equ a_144,144
	equ a_145,145
	equ a_146,146
	equ a_147,147
	equ a_148,148
	equ a_149,149
	equ a_15,15
	equ a_150,150
	equ a_151,151
	equ a_152,152
	equ a_153,153
	equ a_154,154
	equ a_155,155
	equ a_156,156
	equ a_157,157
	equ a_158,158
	equ a_159,159
	equ a_16,16
	equ a_160,160
	equ a_161,161
	equ a_162,162
	equ a_163,163
	equ a_164,164
	equ a_165,165
	equ a_166,166
	equ a_167,167
	equ a_168,168
	equ a_169,169
	equ a_17,17
	equ a_170,170
	equ a_171,171
	equ a_172,172
	equ a_173,173
	equ a_174,174
	equ a_175,175
	equ a_176,176
	equ a_177,177
	equ a_178,178
	equ a_179,179
	equ a_18,18
	equ a_180,180
	equ a_181,181
	equ a_182,182
	equ a_183,183
	equ a_184,184
	equ a_185,185
	equ a_186,186
	equ a_187,187
	equ a_188,188
	equ a_189,189
	equ a_19,19
	equ a_190,190
	equ a_191,191
	equ a_192,192
	equ a_193,193
	equ a_194,194
	equ a_195,195
	equ a_196,196
	equ a_197,197
	equ a_198,198
	equ a_199,199
	equ a_199,199
	equ a_2,2
	equ a_20,20
	equ a_200,200
	equ a_201,201
	equ a_202,202
	equ a_203,203
	equ a_204,204
	equ a_205,205
	equ a_206,206
	equ a_207,207
	equ a_208,208
	equ a_209,209
	equ a_21,21
	equ a_210,210
	equ a_211,211
	equ a_212,212
	equ a_213,213
	equ a_214,214
	equ a_215,215
	equ a_216,216
	equ a_217,217
	equ a_218,218
	equ a_219,219
	equ a_22,22
	equ a_220,220
	equ a_221,221
	equ a_222,222
	equ a_223,223
	equ a_224,224
	equ a_225,225
	equ a_226,226
	equ a_227,227
	equ a_228,228
	equ a_229,229
	equ a_23,23
	equ a_230,230
	equ a_231,231
	equ a_232,232
	equ a_233,233
	equ a_234,234
	equ a_235,235
	equ a_236,236
	equ a_237,237
	equ a_238,238
	equ a_239,239
	equ a_24,24
	equ a_240,240
	equ a_241,241
	equ a_242,242
	equ a_243,243
	equ a_244,244
	equ a_245,245
	equ a_246,246
	equ a_247,247
	equ a_248,248
	equ a_249,249
	equ a_25,25
	equ a_250,250
	equ a_251,251
	equ a_252,252
	equ a_253,253
	equ a_254,254
	equ a_255,255
	equ a_256,256
	equ a_257,257
	equ a_258,258
	equ a_259,259
	equ a_26,26
	equ a_260,260
	equ a_261,261
	equ a_262,262
	equ a_263,263
	equ a_264,264
	equ a_265,265
	equ a_266,266
	equ a_267,267
	equ a_268,268
	equ a_269,269
	equ a_27,27
	equ a_270,270
	equ a_271,271
	equ a_272,272
	equ a_273,273
	equ a_274,274
	equ a_275,275
	equ a_276,276
	equ a_277,277
	equ a_278,278
	equ a_279,279
	equ a_28,28
	equ a_280,280
	equ a_281,281
	equ a_282,282
	equ a_283,283
	equ a_284,284
	equ a_285,285
	equ a_286,286
	equ a_287,287
	equ a_288,288
	equ a_289,289
	equ a_29,29
	equ a_290,290
	equ a_291,291
	equ a_292,292
	equ a_293,293
	equ a_294,294
	equ a_295,295
	equ a_296,296
	equ a_297,297
	equ a_298,298
	equ a_299,299
	equ a_3,3
	equ a_30,30
	equ a_300,300
	equ a_301,301
	equ a_302,302
	equ a_303,303
	equ a_304,304
	equ a_305,305
	equ a_306,306
	equ a_307,307
	equ a_308,308
	equ a_309,309
	equ a_31,31
	equ a_310,310
	equ a_311,311
	equ a_312,312
	equ a_313,313
	equ a_314,314
	equ a_315,315
	equ a_316,316
	equ a_317,317
	equ a_318,318
	equ a_319,319
	equ a_32,32
	equ a_320,320
	equ a_321,321
	equ a_322,322
	equ a_323,323
	equ a_324,324
	equ a_325,325
	equ a_326,326
	equ a_327,327
	equ a_328,328
	equ a_329,329
	equ a_33,33
	equ a_330,330
	equ a_331,331
	equ a_332,332
	equ a_333,333
	equ a_334,334
	equ a_34,34
	equ a_35,35
	equ a_36,36
	equ a_37,37
	equ a_38,38
	equ a_39,39
	equ a_4,4
	equ a_40,40
	equ a_41,41
	equ a_42,42
	equ a_43,43
	equ a_44,44
	equ a_45,45
	equ a_46,46
	equ a_47,47
	equ a_48,48
	equ a_49,49
	equ a_5,5
	equ a_50,50
	equ a_51,51
	equ a_52,52
	equ a_53,53
	equ a_54,54
	equ a_55,55
	equ a_56,56
	equ a_57,57
	equ a_58,58
	equ a_59,59
	equ a_6,6
	equ a_60,60
	equ a_61,61
	equ a_62,62
	equ a_63,63
	equ a_64,64
	equ a_65,65
	equ a_66,66
	equ a_67,67
	equ a_68,68
	equ a_69,69
	equ a_7,7
	equ a_70,70
	equ a_71,71
	equ a_72,72
	equ a_73,73
	equ a_74,74
	equ a_75,75
	equ a_76,76
	equ a_77,77
	equ a_78,78
	equ a_79,79
	equ a_8,8
	equ a_80,80
	equ a_81,81
	equ a_82,82
	equ a_83,83
	equ a_84,84
	equ a_85,85
	equ a_86,86
	equ a_87,87
	equ a_88,88
	equ a_89,89
	equ a_9,9
	equ a_90,90
	equ a_91,91
	equ a_92,92
	equ a_93,93
	equ a_94,94
	equ a_95,95
	equ a_96,96
	equ a_97,97
	equ a_98,98
	equ a_99,99
	equ a_endjob,138
	equ r_eq,102
	equ r_lt,187
	equ r_rt,188
	equ r_tim,184
	equ r_exp,186
	equ r_pls,182
	equ r_sub,183
	equ r_per,189
	equ r_div,185
	equ r_ls,123
	equ r_gt,113
	equ r_accept,1
	equ r_add,2
	equ r_advancing,71
	equ r_after,72
	equ r_all,73
	equ r_alphabetic,74
	equ r_alphanumeric,75
	equ r_alphanumeric_edited,76
	equ r_also,96
	equ r_alter,4
	equ r_and,77
	equ r_any,464
	equ r_ascending,78
	equ r_at,79
	equ r_before,80
	equ r_beginning,81
	equ r_by,82
	equ r_call,5
	equ r_cancel,7
	equ r_character,83
	equ r_characters,83
	equ r_close,8
	equ r_cobol,191
	equ r_collating,515
	equ r_compute,40
	equ r_copy,522
	equ r_corr,524
	equ r_corresponding,524
	equ r_count,84
	equ r_data,196
	equ r_date,86
	equ r_day,87
	equ r_day_of_week,326
	equ r_debugging,88
	equ r_declaratives,89
	equ r_delete,22
	equ r_delimited,90
	equ r_delimiter,91
	equ r_depending,92
	equ r_descending,93
	equ r_disable,41
	equ r_display,42
	equ r_divide,9
	equ r_division,94
	equ r_down,95
	equ r_egi,233
	equ r_else,96
	equ r_emi,97
	equ r_enable,43
	equ r_end,98
	equ r_end_add,466
	equ r_end_call,467
	equ r_end_compute,468
	equ r_end_delete,469
	equ r_end_divide,470
	equ r_end_evaluate,471
	equ r_end_if,472
	equ r_end_multiply,473
	equ r_end_of_page,100
	equ r_end_perform,474
	equ r_end_read,475
	equ r_end_receive,476
	equ r_end_return,477
	equ r_end_rewrite,478
	equ r_end_search,479
	equ r_end_start,480
	equ r_end_string,481
	equ r_end_subtract,482
	equ r_end_unstring,483
	equ r_end_write,484
	equ r_ending,99
	equ r_enter,44
	equ r_eop,100
	equ r_equal,102
	equ r_equals,102
	equ r_error,3
	equ r_esi,105
	equ r_evaluate,500
	equ r_examine,50
	equ r_exceeds,113
	equ r_exception,107
	equ r_exit,12
	equ r_extend,216
	equ r_file,108
	equ r_first,109
	equ r_for,110
	equ r_from,111
	equ r_generate,45
	equ r_giving,112
	equ r_go,14
	equ r_greater,113
	equ r_high_value,221
	equ r_high_values,221
	equ r_hold,46
	equ r_i_o,119
	equ r_if,47
	equ r_in,101
	equ r_initial,114
	equ r_initialize,13
	equ r_initiate,16
	equ r_input,115
	equ r_inspect,17
	equ r_into,116
	equ r_invalid,117
	equ r_is,118
	equ r_key,120
	equ r_label,121
	equ r_leading,122
	equ r_less,123
	equ r_linage_counter,564
	equ r_line,124
	equ r_lines,124
	equ r_lock,125
	equ r_low_value,229
	equ r_low_values,229
	equ r_merge,15
	equ r_message,126
	equ r_move,18
	equ r_multiply,10
	equ r_negative,127
	equ r_next,128
	equ r_no,129
	equ r_not,130
	equ r_numeric,131
	equ r_numeric_edited,132
	equ r_of,133
	equ r_off,574
	equ r_on,134
	equ r_open,19
	equ r_or,135
	equ r_other,443
	equ r_output,137
	equ r_overflow,6
	equ r_page,139
	equ r_perform,20
	equ r_pointer,140
	equ r_positive,141
	equ r_printing,559
	equ r_procedure,142
	equ r_procedures,143
	equ r_proceed,144
	equ r_process,48
	equ r_processing,145
	equ r_program,146
	equ r_purge,58
	equ r_quote,235
	equ r_quotes,235
	equ r_random,147
	equ r_read,21
	equ r_receive,23
	equ r_record,148
	equ r_records,195
	equ r_reel,149
	equ r_references,150
	equ r_release,24
	equ r_remainder,151
	equ r_removal,260
	equ r_replace,425
	equ r_replacing,152
	equ r_reporting,153
	equ r_return,25
	equ r_reversed,154
	equ r_rewind,155
	equ r_rewrite,27
	equ r_rounded,156
	equ r_run,157
	equ r_search,26
	equ r_section,158
	equ r_segment,159
	equ r_send,30
	equ r_sentence,160
	equ r_sequence,587
	equ r_set,31
	equ r_size,161
	equ r_sort,49
	equ r_space,192
	equ r_spaces,192
	equ r_standard,162
	equ r_start,56
	equ r_stop,33
	equ r_string,34
	equ r_subtract,11
	equ r_suspend,35
	equ r_tallying,163
	equ r_terminal,164
	equ r_terminate,36
	equ r_than,165
	equ r_then,300
	equ r_through,166
	equ r_thru,166
	equ r_time,168
	equ r_times,168
	equ r_to,170
	equ r_transform,51
	equ r_unequal,171
	equ r_unit,172
	equ r_unstring,37
	equ r_until,173
	equ r_up,174
	equ r_upon,175
	equ r_use,39
	equ r_using,176
	equ r_varying,177
	equ r_when,178
	equ r_with,179
	equ r_write,38
	equ r_zero,180
	equ r_zeroes,180
	equ r_zeros,180
	end
~~~




		    cobol_pdstax.pl1                05/24/89  1046.0rew 05/24/89  0835.9     1476126



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8063),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8063 cobol_pdstax.pl1 Fix bug in abbreviated conditionals.
  2) change(89-04-23,Zimmerman), approve(89-04-23,MCR8082),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8082 cobol_pdstax.pl1 Fix wild array subscript.
                                                   END HISTORY COMMENTS */


/* Modified on 01/24/85 by FCH, [5.3-2], RLS for cond statements drastically changed, BUG561 */
/* Modified on 11/04/83 by FCH, [5.3-1], illegal abbrev rel cond caused abort, BUG563(phx16292) */
/* Modified on 07/11/83 by FCH, [5.2-1], SUPPRESS verb does not work, BUG553(phx15481) */
/* Modified on 11/1/82 by FCH, [5.1-5], delete certain diags concerning files, BUG542(phx13372) */
/* Modified on 03/10/82 by FCH, [5.1-4], dont set file_table.read_next, BUG529 */
/* Modified on 03/05/82 by FCH, [5.1-3], NEXT STATEMENT sometimes blows conpiler, BUG527 */
/* Modified on 12/22/81 by FCH, [5.1-2], set LTP = "1"b, phx12120(BUG5.1) */
/* Modified on 12/17/81 by FCH, [5.1-1], fix bug in NOT(condition), BUG300 */
/* Modified on 10/02/81 by FCH, [5.0-1], fix flagging for validation-81, BUG501 */
/* Modified on 06/23/81 by FCH, [4.4-12], SUBJ_REQ saved in cstack, BUG487 */
/* Modified on 06/11/81 by FCH, [4.4-11], end_stmt.a = "010"b for STOP RUN if CD INITIAL, BUG468 */
/* Modified on 05/19/81 by FCH, [4.4-10], using param not 01 or 77 must begin on full word, TR9918(BUG483) */
/* Modified on 04/17/81 by FCH, [4.4-9], Format 1 SEND statement incorrectly parsed, BUG478 */
/* Modified on 04/06/81 by FCH, [4.4-8], fix bugs in leveling for validation-81, BUG477 */
/* Modified on 02/21/81 by FCH, [4.4-7], receive statement syntax incorrect, new actions added */
/* Modified on 01/17/81 by FCH, [4.4-6], bug 5-206 illegally issued on subscripted refs, BUG460(phx08894) */
/* Modified on 12/10/80 by FCH, [4.4-5], report writer added */
/* Modified on 12/08/80 by FCH, [4.4-4], reset UB_ind if end word */
/* Modified on 11/26/80 by FCH, [4.4-3] diag 5-274 added added, BUG456(phx08316) */
/* Modified on 11/04/80 by FCH, [4.4-2], BUG454(TR3324), action 300,diag 279 on prev tok */
/* Modified on 11/04/80 by FCH, [4.4-1], fix leveling diags in ae */
/* Modified on 04/08/80 by FCH, [4.2-8], diags not issued on class tests, BUG434(TR5876) */
/* Modified on 04/05/80 by FCH, [4.2-7], fix out-of-range checking, BUG430(TR4533) */
/* Modified on 03/22/80 by FCH, [4.2-6], corrections to leveling diags for conditions */
/* Modified on 03/13/80/by FCH, [4.2-5], num.edit to alphabetic move not detected, BUG431 */
/* Modified on 03/13/80 by FCH, [4.2-4], BUG429, L-11 issued illegally when two numeric items compared, SQ431 */
/* Modified on 02/08/80 by MHD,[4.2-3], fixed leveling problem on condition names and more than one SORT */
/* Modified on 12/20/79 by MHD,[4.2-2], fixed bug 416, OCCURS DEPENDING ON *
/* Modified on 11/20/79 by  MHD, [4.2-1], check for both debug and use_debug */
/* Modified on 10/30/79 by MHD, [4.1-1], diagnostic is put out on previous token if current line = 0 */
/* Modified on 09/27/79 by MHD, [4.1-7], put diagnostics on correct symbol */
/* Modified on 08/29/79 by FCH, [4.0-6], L-11 at correct token */
/* Modified on 06/26/79 by FCH, [4.0-5], stream files allowed in sort */
/* Modified on 05/11/79 by FCH, [4.0-4], debug */
/* Modified on 04/02/79 by FCH, [4.0-3], mixed subs and indexing illegal */
/* Modified on 03/28/79 by FCH, [4.0-2], fix leveling diags */
/* Modified on 03/21/79 by FCH, [4.0-1], dont test sizes if numeric */
/* Modified on 12/20/78 by RAL, [3.0-16] added check seqstmfil using savitmptr */
/* Modified on 10/27/78 by RAL, [3.0-15] rewote check (158) and added action (288) for alternate record keys */
/* Modified on 09/13/78 by RAL, [3.0-14] check(210) is file device suffix printer */
/* Modified on 06/15/78 by RAL, [3.0-13], action(287) check to issue leveling diag 172 */
/* Modified on 06/08/78 by RAL, [3.0-12], action(286) issue leveling diag 169 */
/* Modified on 05/16/78 by FCH, [3.0-11], diag 147 issued illegally */
/* Modified on 05/05/78 by FCH, [3.0-10], flag illegal comparisions as extensions */
/* Modified on 05/03/78 by FCH, [3.0-9], when(search) sets UB_ind to 0 */
/* Modified on 04/24/78 by FCH, [3.0-8], check for section name */
/* Modified on 04/20/78 by FCH, [3.0-7], check(28):sizlit, inspect statement */
/* Modified on 03/23/78 by FCH, [3.0-6],  lev diag, non-positive integer */
/* Modified on 03/08/78 by FCH, [3.0-5], action(211), test for index name */
/* Modified on 02/17/78 by FCH, [3.0-4], correct values for mnemonic_name.iw_key */
/* Modified on 01/05/78 by FCH, [3.0-3], check170(ckintbit) fixed, used by perform */
/* Modified on 12/27/77 by FCH, [3.0-2], write stream file required invalid option */
/* Modified on 09/08/77 by FCH, [3.0-1], emit level for levelling diags 11,12,13 fixed */
/* Changes made since Version 3.0 */








/* format: style3 */
cobol_pdstax:
     proc;

/*[4.1-7]*/
	prev_token_ptr = null ();			/*[4.1-7]*/
	mptr = null ();
	seg_usage_ptr = addr (seg_usage_string);
	sort_count = 0;
	O1_ptr = addr (O1);
	O2_ptr = addr (O2);
	message_ind = 0;
	comsrtrngptr = (null ());
	addr (stat.procdef) -> bit9 = "0"b;
	next_sent_label = 0;
	perflink, perflink1 = "00000";
	perfext = 0;
	gotodep, preospn_bit, srchfm2bit, ns_found = "0"b;


/*[5.3-2]*/
	nest_lev = 1;				/*[5.3-2]*/
	call reset_st;

	fircar = "1"b;
	dbp, drc = 1;
	common_eof = "0"b;

	act_log_ptr = addr (act_log);
	act_log_ptr -> bit16 = "0"b;			/*[5.3-2]*/
	addr (ST (0)) -> bit180 = "0"b;		/*[5.0-1]*/
	seg_limit = cobol_idedsyn$get_seg_limit ();

	cssub, assub, mod_num, decswitch, secswitch, debugsw, diagno, cursecnum = 0;

	i1 = 0;
	syntax_line_ptr = addr (sline);
	sline.s_exit = 70;

	end_stmt.size = 38;
	end_stmt.line = 0;
	end_stmt.column = 0;
	end_stmt.type = 19;
	end_stmt.verb = 0;

	seq, input, rewind = 1;
	output = 2;

	dumprocname.size = 49;
	dumprocname.line = 0;
	dumprocname.column = 0;
	dumprocname.type = 18;
	dumprocname.searched = "0"b;
	dumprocname.duplicate = "0"b;

	dpnptr = addr (dumprocname);			/*[5.2-1]*/
	end_decl_bit = "1"b;
	sav_ptr = addr (saveitem);
	head_ptr = addr (header);

	work_ptr = addr (work);
	subject_ptr = addr (subject);
	soperator_ptr = addr (soperator);
	coperator_ptr = addr (coperator);
	end_stmt_ptr = addr (end_stmt.verb);
	es_ptr = addr (end_stmt);
	sav_bit, arith_op = "0"b;

	c_ptr = addr (coperator.c);

	code_env_ptr = addr (code_env);
	code_env.arg_1 = addr (end_stmt);
	code_env.arg_2 = addr (opeos);
	code_env.arg_3 = addr (dumprocname);
	code_env.arg_4 = addr (code_env);
	code_env.arg_5 = addr (code_option);

	code_env.arg_6 = addr (DATA);
	call cobol_pd_code$initialize (code_env_ptr);

	addr_record = addr (header);
	cdtoken_ptr = addr_record;
	op_ptr = addr (op);				/*[3.0-10]*/
	left_ptr = addr (left);			/*[3.0-10]*/

/* end of init changed to assign */

	savidptr = addr (saveident);			/* init to saved identifier*/
	opeosptr = addr (opeos);			/*initialize opeosptr to addr of operation eos */
	savitmptr = addr (saveitem);
	eosptr = addr (end_stmt);			/*  used for i-o */


	call cobol_pdst (pointer_to_internal, dumfix);	/* initialize diag item */
	dg_ptr = addr (diag_item);
	diag_item.size = 28;
	diag_item.type = 5;
	diag_item.run = 5;				/*[4.4-5]*/
	eos_perform_ptr = addr (eos_perform);
	rw_perform_ptr = addr (rw_perform);		/*[5.2-1]*/
	rw_move_ptr = addr (rw_move);			/*[5.2-1]*/
	supp_lit_ptr = addr (supp_lit);		/*[5.2-1]*/
	eos_move_ptr = addr (eos_move);
	lev_dg_ptr = addr (lev_diag_item);
	lev_diag_item.size = 28;
	lev_diag_item.type = 5;
	lev_diag_item.run = 9;

	decswitch = 0;
	diag_item.info = "00000000"b;

	DIAG_NUM = 0;
	trace_ptr = addr (interp);
	tbit = fixed_common.syntax_trace;

	if tbit
	then call cobol_syntax_trace_$initialize_phase (trace_ptr, 3);

	call SCAN;

	current_line = syntax_line.s_exit;

	go to new_inst;

/*					*/
/*	 syntax interpreter			*/
/*					*/

fail:						/*failure */
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm2);

next_inst:
	current_line = current_line + 1;

new_inst:						/* new instruction */
	syntax_line_ptr = addr (syntax_table (current_line));

	go to test (syntax_line.t_type);

test (0):						/* reserved word test */
	if reserved_word.type ^= 1
	then go to fail;

	if reserved_word.key ^= syntax_line.t_field
	then go to fail;

success:						/* success */
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm1);

ucon:
	if syntax_line.o_bit ^= " "
	then if syntax_line.o_bit ^= "o"
	     then do;
		     if syntax_line.o_bit > fixed_common.comp_level
						/*[4.4-2]*/
		     then do;
			     if sav_bit		/*[4.4-2]*/
			     then call LEV_DIAG (syntax_line.a_num, sav.line, sav.column);
						/*[4.4-2]*/
			     else call lev_diag (syntax_line.a_num);

/*[4.4-2]*/
			end;

/*[4.4-2]*/
		     sav_bit = "0"b;

		     go to ret;
		end;

	go to action (syntax_line.a_num);

test (1):						/* check routine test */
	go to check (syntax_line.t_field);

test (2):						/* unconditional branch */
	DIAG_NUM = syntax_line.t_field;
	act_num = syntax_line.a_num;

	if syntax_line.o_bit ^= " "
	then if syntax_line.o_bit ^= "o"
	     then do;
		     if syntax_line.o_bit > fixed_common.comp_level
		     then do;
			     mod_num = syntax_line.a_num;

/*[4.4-2]*/
			     if sav_bit		/*[4.4-2]*/
			     then call LEV_DIAG (DIAG_NUM, sav.line, sav.column);
						/*[4.4-2]*/
			     else call lev_diag (DIAG_NUM);

			end;

		     DIAG_NUM = 0;
		     act_num = 0;			/*[4.4-2]*/
		     sav_bit = "0"b;
		end;

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm1);

	go to action (act_num);

test (3):
	i1 = i1 + 1;
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm3);

	if i1 > 75
	then go to comp_error;

	intrp_stack (i1) = current_line;
	current_line = syntax_line.t_field;

	go to new_inst;

ret:
action (0):
	if DIAG_NUM ^= 0
	then do;
		if message_ind = 0			/*[4.1-1]*/
		then if header.line ^= 0
		     then call diag (DIAG_NUM);	/*[4.1-1]*/
		     else call DIAG_PREV_TOKEN (DIAG_NUM);
		message_ind, DIAG_NUM = 0;
	     end;

	if syntax_line.o_bit = "o"
	then if ^ST.skip_ind (nest_lev)
	     then call put;

	if syntax_line.s_bit = "s"
	then call SCAN;

	current_line = syntax_line.s_exit;

	go to new_inst;

action (1):					/* exit true */
	current_line = intrp_stack (i1);

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm4);

	syntax_line_ptr = addr (syntax_table (current_line));
	i1 = i1 - 1;

	go to ucon;

action (2):					/* exit false */
	current_line = intrp_stack (i1);

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm5);

	i1 = i1 - 1;

	go to next_inst;

comp_error:
	diag_item.number = 183;
	diag_item.column = header.column;
	diag_item.line = header.line;

	call cobol_c_list (dg_ptr);

	return;

SCAN:
     proc;

	do while ("1"b);

/*[4.1-7]*/
	     prev_token_ptr = mptr;			/* saves pointer to previous token_ptr */

/*[4.4-2]*/
	     LTP = last_wd_per;			/*[4.4-2]*/
	     last_wd_per = "0"b;

	     call cobol_swf_get (cobol_rm2fp, st, mptr, tln);

	     if substr (st, 17, 16) ^= "0"b
	     then go to endint;

	     substr (addr_record -> itemsize1, 1, headerb.size) = mptr -> itemsize1;

	     if header.type = 5
	     then do;
		     call cobol_c_list (addr_record);

		     if message.rep_bit = "0"b
		     then message_ind = 1;

		     else if diag_file.diag_table.d_type (diag_file.run_table.base (message.run) + message.number) = 3
		     then return;

		end;

	     else if header.type = 6
	     then call cobol_c_list (addr_record);

/*[5.2-1]*/
	     else if header.type = 9 & ^end_decl_bit	/*[5.2-1]*/
	     then if substr (data_name.name, 1, 2) = "SS" /*[5.2-1]*/
		then data_name.type = 91;
	     return;
	end;

     end;

put:
     proc;					/* routine to output the window token */
	seqvarptr = addr_record;
	seqvarleng = header.size;
	call seqput;
     end put;

diag:
     proc (diag_num);

declare	diag_num		fixed bin;

	if header.type = 5 & (syntax_line.t_field = 7 | syntax_line.t_field ^= 164)
	then return;
	else do;
		diag_item.number = diag_num;
		diag_item.column = header.column;
		diag_item.line = header.line;
		call cobol_c_list (dg_ptr);
	     end;
     end diag;

lev_diag:
     proc (diag_num);

declare	diag_num		fixed bin;

	lev_diag_item.line = header.line;
	lev_diag_item.column = header.column;
	lev_diag_item.number = diag_num;
	lev_diag_item.module = mod_num;

	call cobol_c_list (lev_dg_ptr);

	mod_num = 0;

     end;

/*[4.1-7]*/
DIAG_PREV_TOKEN:
     proc (diag_num);

/* This procedure emits a diagnostic message referenced by diag_num and puts it at the */
/* previous token.  Used when look-ahead is needed to determine the error */

declare	diag_num		fixed bin;

	diag_item.number = diag_num;
	diag_item.column = prev_token_ptr -> source.column;
	diag_item.line = prev_token_ptr -> source.line;
	call cobol_c_list (dg_ptr);

     end DIAG_PREV_TOKEN;

/*[4.1-7]*/
DIAG:
     proc (diag_num);

/* This procedure emits a diagnostic message reference by diag_num and  puts it at locatiion */
/* represented in prev_diag.  This is used when look-ahead for more than 1 symbol  needed to determine the error */
/* For look-ahead for only 1 symbol see DIAG_PREV_TOKEN above */

declare	diag_num		fixed bin;

	diag_item.number = diag_num;
	diag_item.column = prev_diag.column_num;
	diag_item.line = prev_diag.line_num;
	call cobol_c_list (dg_ptr);

     end DIAG;

/*[4.0-1]*/
LEV_DIAG:
     proc (diag_num, line_num, col_num);

/*[4.0-1]*/
dcl	(diag_num, line_num, col_num)
			fixed bin;

/*[4.0-1]*/
	lev_diag_item.line = line_num;		/*[4.0-1]*/
	lev_diag_item.column = col_num;		/*[4.0-1]*/
	lev_diag_item.number = diag_num;		/*[4.0-1]*/
	lev_diag_item.module = mod_num;

/*[4.0-6]*/
	call cobol_c_list (lev_dg_ptr);

     end;						/*[4.0-1]*/

seqput:
     proc;

	if ^ST.skip_ind (nest_lev)
	then call cobol_swf_put (cobol_pdofp, st, seqvarptr, seqvarleng);

     end seqput;

seqputeos:
     proc;

	if ^ST.skip_ind (nest_lev)
	then call cobol_swf_put (cobol_pdofp, st, eosptr, end_stmt.size);

     end seqputeos;

vardget:
     proc;

	call cobol_vdwf_dget (cobol_cmfp, st, seqvarptr, common_recsize, varrecaddr);

     end vardget;

vardput:
     proc;

	if ^ST.skip_ind (nest_lev)
	then call cobol_vdwf_dput (cobol_cmfp, st, seqvarptr, seqvarleng, varrecaddr);

     end vardput;


/* the following are the check routines */

/* is dd cd initial bit not set */




check (1):
inbit:
	if ^init_cd
	then go to success;
	go to fail;

/* is item an 01 or 77 item in linkage section */



check (2):
lident:
	if (header.type = 9) & ((data_name.level = 01) | (data_name.level = 77)) & data_name.linkage_section
	then go to success;
	go to fail;
check (3):
linktot:
	if end_stmt.e = number_of_ls_pointers
	then go to success;
	go to fail;				/* is it a section header */
check (4):
sechdr:
	if (header.type = 7) & (proc_def.section_name = "1"b)
	then go to success;
	go to fail;				/* is it a non sort file name */



check (5):
filenm:
	if header.type = 12
	then if fd_token.file_no ^= 0
	     then do;
		     call cobol_read_ft_ (fd_token.file_no, ft_ptr);

		     file_org = file_table.organization;
		     go to success;
		end;

	go to fail;				/* is it not format 2 or
			is it format 2 without  labels are omitted clause */



check (6):
formtlb:
	if (end_stmt.a ^= "001"b)			/* chk filtbl for no labels if frmt 2 */
	then go to success;
	go to fail;				/* is it a report section  group item */
check (7):
rident:
	if header.type = 21
	then go to success;
	go to fail;				/* is it a procedure definition */
check (8):
paranm:
prdef:
	if (header.type = 7 & proc_def.section_name = "0"b)
	then go to success;
	go to fail;				/* is it a verb */



check (9):
verb:						/*[5.2-1]*/
	if ((header.type = 1) & (reserved_word.verb = "1"b)) | header.type = 91
	then do;
		if UB_ind
		then call diag (126);

		UB_ind = "0"b;
		go to success;
	     end;
	go to fail;				/* is section number legitimate */


check (10):
prnum:
	if header.type = 2 & numeric_lit.integral = "1"b & numeric_lit.sign = " " & numeric_lit.seg_range = "1"b
	then go to success;
	go to fail;				/* is saved item not alphabetic */
check (11):
sina:
	if (savitmptr -> data_name.numeric) | (savitmptr -> data_name.numeric_edited)
	     | (savitmptr -> data_name.alphanum)
	then go to success;
	go to fail;				/* is it a numeric literal */


check (12):
numlit:						/*[5.0-1]*/
	if header.type = 2				/*[5.0-1]*/
	then seg_num = fixed (numeric_lit.literal);	/*[5.0-1]*/
	else seg_num = 0;

	if fixed_common.comp_level < "4"
	then do;
		if last_seg_num ^= 1000
		then do;
			if seg_usage (seg_num) & seg_num ^= last_seg_num
			then call lev_diag (81);

		     end;

		last_seg_num = seg_num;
		seg_usage (seg_num) = "1"b;

	     end;

	if header.type = 2
	then go to success;
	go to fail;				/* is it an alterable procedure name reference */


check (13):
altprnm:
	if (header.type = 18 & proc_def.alterable = "1"b)
	then go to success;
	go to fail;				/* is it a procedure name reference */


check (14):
prnm:
	if header.type = 18
	then go to success;
	go to fail;				/* is it a non numeric literal */
check (15):
nonumlit:
	if header.type = 3
	then go to success;
	go to fail;				/* is it an 01 or 77 item within file working-storage communication or link section */


check (16):
useid:
	if header.type = 2 | header.type = 3
	then do;

		if fixed_common.comp_level < "5"
		then call lev_diag (153);

		go to success;
	     end;

	if header.type = 9
	then do;
		if ((data_name.level = 1 | data_name.level = 77)
		     & (data_name.file_section | data_name.working_storage | data_name.communication_section
		     | data_name.linkage_section | data_name.constant_section))
		then go to success;
	     end;

	go to fail;

/* is it a non sort file name */


check (17):
nsfilnm:
	if header.type = 12
	then if fd_token.file_no ^= 0
	     then do;
		     call cobol_read_ft_ (fd_token.file_no, ft_ptr);
		     file_org = file_table.organization;
		     go to success;
		end;
	go to fail;				/* is it an input cd name */


check (18):
incdnm:
	if (header.type = 13 & cdtoken.options.input)
	then go to success;
	go to fail;				/* is it an output cd name */


check (19):
outcdnm:
	if (cdtoken.type = 13 & cdtoken.output)
	then go to success;
	go to fail;

/*is saved file indexed */



check (20):
ixfil:
	if savitmptr -> fd_token.file_no = 0
	then go to fail;

	file_number = savitmptr -> fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);

	if organization = 3
	then go to success;
	go to fail;

/* is it a literal */



check (21):
lit:
	if header.type = 2 | header.type = 3
	then go to success;
	go to fail;				/* is item a figurative constant except all */
check (22):
figconall:
	if fixed_common.comp_level < "3"
	then do;
		if header.type = 1 & reserved_word.figcon
		then do;
			if reserved_word.end_dec
			then call lev_diag (154);
			go to success;
		     end;
	     end;
	else do;
		if header.type = 1 & reserved_word.figcon
		then go to success;
	     end;

	go to fail;

/* does file have sequential access or dynamic access */

check (23):
sqacdyac:
	if savitmptr -> fd_token.file_no = 0
	then go to fail;

	file_number = savitmptr -> fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);

	if access < 2 | access = 3
	then go to success;
	go to fail;

check (24):
is_cobol:
	if lang_num = 1
	then go to success;

	go to fail;

check (25):
rpid:						/*[4.4-5]*/
	if header.type = 18
	then go to success;
	go to fail;				/* is it a declarative section name reference */
check (26):
descnm:
	if header.type = 18 & proc_def.section_name & proc_def.declarative_proc
	then go to success;
	go to fail;				/* is it an rd report name */
check (27):
repnm:						/*[4.4-5]*/
	if header.type = 18
	then go to success;
	go to fail;				/* is current size = to saved item size */
check (28):
sizlit:						/*[3.0-7]*/
						/*[]*/
	if header.type = 1
	then go to success;				/* fig_con */
						/*[]*/
						/*[]*/
	if saveitem.type = 3			/*[]*/
	then do;
		LL = savitmptr -> alphanum_lit.lit_size;/*[]*/
						/*[]*/
		if header.type = 3			/*[]*/
		then do;
			if LL = alphanum_lit.lit_size
			then go to success;		/*[]*/
		     end;				/*[]*/
		else /*[]*/ /*[]*/
		     if header.type = 9		/*[]*/
		then do;
			call sizedn (addr_record);	/*[]*/
						/*[]*/
			if LL = L
			then go to success;		/*[]*/
		     end;				/*[]*/
	     end;					/*[]*/
	else /*[]*/ /*[]*/
	     if saveitem.type = 9			/*[]*/
	then do;
		call sizedn (savitmptr);		/*[]*/
						/*[]*/
		if header.type = 3			/*[]*/
		then do;
			if L = alphanum_lit.lit_size
			then go to success;		/*[]*/
		     end;				/*[]*/
		else /*[]*/ /*[]*/
		     if header.type = 9		/*[]*/
		then do;
			LL = L;			/*[]*/
			call sizedn (addr_record);	/*[]*/
						/*[]*/
			if LL = L
			then go to success;		/*[]*/
		     end;				/*[]*/
	     end;					/*[]*/
	else /*[]*/ /*[]*/
	     if saveitem.type = 1			/*[]*/
	then do;
		if header.type = 3			/*[]*/
		then do;
			if alphanum_lit.lit_size = 1
			then go to success;		/*[]*/
		     end;				/*[]*/
		else /*[]*/ /*[]*/
		     if header.type = 9		/*[]*/
		then do;
			call sizedn (addr_record);	/*[]*/
						/*[]*/
			if L = 1
			then go to success;		/*[]*/
		     end;				/*[]*/
	     end;

	go to fail;


sizedn:
     proc (p);

/*[]*/
declare	p		ptr;			/*[]*/
						/*[]*/
	if p -> data_name.numeric | p -> data_name.numeric_edited
						/*[]*/
	then L = p -> data_name.places_left + p -> data_name.places_right;
						/*[]*/
	else L = p -> data_name.item_length;

     end;						/*[3.0-7]*/

/*is file not sequentila access
	not file table already in core from check 38 */

check (29):
notseqac:
	if access > 1
	then go to success;
	go to fail;

/* is saved item not mass storage and
			is it sequential and is it single reel */


check (30):
nomsss:
	if savitmptr -> fd_token.file_no ^= 0
	then do;
		file_number = savitmptr -> fd_token.file_no;
		call cobol_read_ft_ (file_number, ft_ptr);
	     end;
	else go to fail;

	if organization = 1
	then go to success;
	go to fail;				/* is it a non sort mass storage file */
check (31):
msfilnm:						/*  according to ron ham we do not check for ms file regardless of codasyl rules */
	if header.type = 12
	then go to success;
	go to fail;

/* is there a format 1 use procedure associated with the delete statement
	note file table already in core from check 38 */

check (32):
useform1:
	if error_exit ^= 0
	then go to success;
	go to fail;

/* is it an index name */
check (33):
xnm:
	if header.type = 10
	then do;
		min_index = max (min_index, 0);	/*[4.2-7]*/
		max_index = min (max_index, index_name.max);
		go to success;
	     end;
	go to fail;

/* no more than 2 afters in a perform statement */

check (34):
ecnt:
	if end_stmt.e = 3
	then go to success;
	go to fail;				/* is item a declarative section name reference */
						/* and is it a random processing section */



check (35):
descnmra:
	if header.type = 18 & proc_def.section_name	/*[3.0-8]*/
	then go to success;
	go to fail;				/* is it an sa area name */
check (36):
saanm:
	if header.type = 15
	then go to success;
	go to fail;				/* is it an  01 data name under sa */
check (37):
said:
	if header.type = 9 & data_name.level_01 & data_name.exp_redefining
	then go to success;
	go to fail;

/* is file not sequential organization */

check (38):
notseqfl:
	if fd_token.file_no ^= 0
	then do;
		file_number = fd_token.file_no;
		call cobol_read_ft_ (file_number, ft_ptr);
	     end;
	else go to fail;

	if organization ^= 1 & organization ^= 5
	then go to success;				/*[3.0-2]*/
	go to fail;

/* is it end cobol statement */
check (39):
endcob:
	if header.type = 1 & reserved_word.end_cobol = "1"b
	then go to success;
	go to fail;				/* was previous eos a special case */


check (40):
preosp:
	if end_stmt.verb = 12 & reserved_word.imper_verb = "0"b
	then go to success;
	go to fail;				/* is verb an imperative verb */
check (41):
impvrb:						/*[5.3-2]*/
	if data_name.type = 91			/* suppress */
						/*[5.3-2]*/
	then go to success;				/*[5.3-2]*/
	else if reserved_word.type = 1		/*[5.3-2]*/
	then if reserved_word.verb			/*[5.3-2]*/
	     then go to success;			/*[5.3-2]*/
	     else if reserved_word.key = 500		/* evaluate */
						/*[5.3-2]*/
	     then go to success;			/*[5.3-2]*/
	     else ;				/*[5.3-2]*/
	else ;
	go to fail;

/* are records fixed length */



check (42):
varsiz:
	if savitmptr -> fd_token.file_no = 0
	then go to fail;

	file_number = savitmptr -> fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);

	if file_table.variable = "0"b
	then go to success;
	go to fail;

/* is item file no not equal to saved file no */
check (43):
fileno:
	if header.type = 9
	then if data_name.file_num ^= savitmptr -> data_name.file_num
	     then goto success;
	     else goto fail;
	else if data_name.file_num ^= savitmptr -> fd_token.file_no
	then go to success;
	go to fail;				/* is saved item filename isn sequential mode */



check (44):
sqfl:						/*	if savitmptr -> seqbit then go to success;
go to fail;	*/				/* is saved file in random access mode */
check (45):
rafl:
	if savitmptr -> fd_token.file_no ^= 0
	then do;
		file_number = savitmptr -> fd_token.file_no;
		call cobol_read_ft_ (file_number, ft_ptr);
	     end;
	else go to fail;

	if access = 2
	then go to success;
	go to fail;				/* is this item a record within the associated sort file */
check (46):
recnm:
	if header.type ^= 9
	then go to fail;

	sort_key = sort_in_info;

	do while ("1"b);
	     if sort_key = "00000"
	     then go to fail;

	     varrecaddr = sort_key;
	     call vardget;
	     srtrngptr = seqvarptr;

	     if (cursecnum > sstop) | (cursecnum < sstart) | (data_name.file_num ^= srtfilno)
	     then sort_key = sptr;
	     else go to success;
	end;

/* are we in an input sort range */
check (47):
inrng:
	if sv_isrbit
	then go to success;
	go to fail;

/* are we in an output sort range */
check (48):
outrng:
	if sv_osrbit
	then go to success;
	go to fail;

/* is this file the same as associated file in the sort statement */
check (49):
asfil:
	if header.type ^= 16
	then go to fail;

	sort_key = sort_out_info;

	do while ("1"b);
	     if sort_key = "00000"
	     then go to fail;

	     varrecaddr = sort_key;
	     call vardget;
	     srtrngptr = seqvarptr;

	     if (cursecnum > sstop) | (cursecnum < sstart) | (fd_token.file_no ^= srtfilno)
	     then sort_key = sptr;
	     else go to success;
	end;

/* is item not subscripted and not indexed */
/* but still has the occurs and indexed by clauses */
check (50):
srchid:
	if header.type = 9 & data_name.subscripted & data_name.indexed_by
	then go to success;
	else go to fail;				/* is item an integer type or is it usage is index */
check (51):
usornm:
	if header.type = 9 & (data_name.pic_integer | data_name.usage_index)
	then go to success;
	else go to fail;				/* does item have the key is clause */
check (52):
keylbl:
	if data_name.key_a | data_name.key_d
	then go to success;
	else go to fail;

/* is it a sequential file */



check (53):
seqfil:
	if fd_token.file_no = 0
	then go to fail;

	file_number = fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);

/*[4.0-5]*/
	if organization = 1 | organization = 5
	then go to success;
	go to fail;

/* is it a one character integer without an operational sign */



check (54):
onechnosn:
	if data_name.item_length = 1 & data_name.pic_integer & ^data_name.item_signed
	then go to success;
	go to fail;

/* is saved file sequential or relative and does it have sequential access mode */

check (55):
sqrlsqac:
	if savitmptr -> data_name.file_num = 0
	then go to fail;

	file_number = savitmptr -> data_name.file_num;
	call cobol_read_ft_ (file_number, ft_ptr);

	if (organization = 1 | organization = 2) & (access < 2)
	then go to success;
	go to fail;

/* is it a mneemonic name */
check (56):
mnenm:
	if header.type = 17
	then go to success;
	go to fail;

/* does the file have an associated format 1 use procedure */

check (57):
useform1a:
	if savitmptr -> data_name.file_num = 0
	then go to fail;
	go to useform1;

/* is it  an index data item or
			is it  an elementary integer item */
check (58):
xint:
	if header.type = 9 & data_name.elementary & data_name.usage_index = "1"b
	then do;
		set_sop.int_lit = "1"b;
		set_sop.int_data = "1"b;
		go to success;
	     end;

	if header.type = 9 & data_name.elementary = "1"b & data_name.pic_integer = "1"b
	then do;
		set_sop.int_lit = "1"b;
		set_sop.int_data = "1"b;
		set_sop.ind_data = "1"b;
		go to success;
	     end;
	go to fail;				/* is it a positive integer literal  */



check (59):
posint:
	if header.type = 2 & numeric_lit.integral = "1"b & numeric_lit.sign ^= "-"
	then go to success;
	go to fail;				/* is it a sortt file */



check (60):
srtfil:
	if header.type = 16
	then go to success;
	go to fail;				/* is itt a data_name within the saved file */


check (61):
dninfl:
	if header.type = 9 & data_name.file_num = savitmptr -> fd_token.file_no
	then go to success;
	go to fail;				/* does item have usage is display clause */

check (62):
usisds:
	if data_name.non_elementary | (data_name.elementary & data_name.display)
	then go to success;
	go to fail;				/* is item fixed length with usage is display clause */
check (63):
flusisds:
	if data_name.display & ^data_name.variable_length
	then go to success;
	go to fail;				/* is item an elementary data item with usage is display clause
			and with no edit symbols */
check (64):
elneds:
	if data_name.elementary & data_name.display & ^data_name.numeric_edited & ^data_name.alphanum_edited
	     & ^data_name.alphabetic_edited
	then go to success;
	go to fail;				/* is itt an elementary numeric integer data item */
check (65):
elnuindi:
	if data_name.elementary & data_name.numeric & data_name.pic_integer
	then go to success;
	go to fail;				/* is it an elementary numeric item */



check (66):
elnuit:
	if header.type = 9 & data_name.elementary & data_name.numeric
	then go to success;
	go to fail;				/* is it a file name */



check (67):
file:
	if header.type = 12 | header.type = 16
	then go to success;
	go to fail;				/* is it an alphanumeric data item */
check (68):
andait:
	if data_name.alphanum | data_name.alphanum_edited
	then go to success;
	go to fail;				/* is contents of e counter greater than 0 ? */
check (69):
egrze:
	if end_stmt.e > 0
	then go to success;
	go to fail;				/* is item a non_sort record name */



check (70):
nsrecnm:
	if header.type = 9 & data_name.file_section & data_name.file_num ^= 0 & data_name.level_01
	then go to check70a;
	go to fail;
check70a:
	file_number = data_name.file_num;
	call cobol_read_ft_ (file_number, ft_ptr);

	file_org = file_table.organization;

	if ^sort_file
	then go to success;
	go to fail;				/* does saved item have linage clause */
						/* not to be executed until common is all set */
check (71):
linage:
	if file_table.linage
	then go to success;

	go to fail;



/* is saved item a mass storage file */
/*  the filetable is already in core from doing check 70  */
/*  used by the write verb  */
check (72):
msfile:						/*  is saved item a mass storage file with other than sequential organization  */
						/*is file not stream organization */
	if organization ^= 1 & organization ^= 5
	then go to success;				/*[3.0-2]*/
	go to fail;

/* is item an unsubscripted data name excluding index data names */



check (73):
undana:
	if header.type = 9 & ^data_name.subscripted & ^data_name.usage_index
	then go to success;
	else go to fail;

/* is item a subscripted data name excluding  index data names */

check (74):
sudana:
	if header.type = 9 & data_name.subscripted & ^data_name.usage_index
	then go to success;
	else go to fail;

/* is subcnt less than level of occurs in the saved ident */
check (75):
ieqlvl:						/*[4.0-3]*/
	if subcnt = 0				/*[4.0-3]*/
	then do;
		if header.type = 2			/*[4.0-3]*/
		then format = 0;			/*[4.0-3]*/
		else if header.type = 10		/*[4.0-3]*/
		then format = 2;			/*[4.0-3]*/
		else format = 1;			/*[4.0-3]*/
		err = 0;				/*[4.0-3]*/
	     end;					/*[4.0-3]*/
	else do;
		if header.type ^= 1			/*[4.0-3]*/
		then /*[4.0-3]*/
		     if format = 0			/*[4.0-3]*/
		     then if header.type = 2		/*[4.0-3]*/
			then ;			/*[4.0-3]*/
			else if header.type = 10	/*[4.0-3]*/
			then format = 2;		/*[4.0-3]*/
			else format = 1;		/*[4.0-3]*/
		     else if format = 1		/*[4.0-3]*/
		     then if header.type = 10		/*[4.0-3]*/
			then err = 167;		/*[4.0-3]*/
			else ;			/*[4.0-3]*/
		     else if header.type ^= 10 & header.type ^= 2
						/*[4.0-3]*/
		     then err = 167;		/*[4.0-3]*/
		     else ;			/*[4.0-3]*/
	     end;

	if subcnt < dimensions
	then go to success;
	go to fail;				/* is the saved ident indexed at this level */
check (76):
indexed:
	if indexedno (subcnt) ^= 0
	then do;
		sub_loc = sub_loc + 1;
		go to success;
	     end;
	go to fail;				/* is index no of curent item = to
			index no of saved item */
check (77):
indeqind:
	if index_name.index_no = indexedno (subcnt)
	then go to success;
	go to fail;				/* is item a positive integer whose value is greater than zero */
check (78):
pigz:
	call pigz_sub;

	if pigz_res = 0
	then go to success;
	else go to fail;

pigz_sub:
     proc;

	pigz_res = 0;
	litcnt = 1;

	if header.type = 2 & numeric_lit.integral & numeric_lit.sign ^= "-"
	then do while ("1"b);

		if substr (numeric_lit.literal, litcnt, 1) ^= "0"
		then return;

		if litcnt = numeric_lit.places
		then do;
			pigz_res = 1;
			return;
		     end;

		litcnt = litcnt + 1;

	     end;

	pigz_res = 1;

     end;

/* is item an unsigned integer */
check (79):
unsint:
	if header.type = 2 & numeric_lit.integral & numeric_lit.sign = " "
	then go to success;
	go to fail;				/* is item an arithemetic operator */
check (80):
arop:
	if header.type = 1 & reserved_word.arith_op
	then go to success;
	go to fail;				/* is item a single character non numeric literal or a fig con */
check (81):
examlitid:
	if header.type = 9 & data_name.display & data_name.item_length = 1
	then go to check81a;

	if header.type = 1 & reserved_word.figcon
	then go to check81b;

	if header.type = 3 & alphanum_lit.lit_size = 1
	then go to check81d;

	if header.type = 2 & numeric_lit.places = 1 & numeric_lit.sign = " "
	then go to check81c;
	go to fail;

check81a:
	if savitmptr -> data_name.numeric = data_name.numeric
	then go to success;
	go to fail;

check81b:
	if savitmptr -> data_name.numeric & reserved_word.jump_index ^= 1
	then go to fail;
	go to success;

check81c:
	if savitmptr -> data_name.numeric
	then go to success;
	go to fail;

check81d:
	if ^savitmptr -> data_name.numeric
	then go to success;
	go to fail;				/* is item elementary or redefined */

check (82):
elemred:
	if data_name.elementary | data_name.s_of_rdf | data_name.o_of_rdf
	then go to success;
	go to fail;

/* is saved file indexed or relative and is access random or dynamic */

check (83):
ixrlrady:
	if savitmptr -> data_name.file_num = 0
	then go to fail;

	if (organization = 2 | organization = 3) & (access = 2 | access = 3)
	then go to success;
	go to fail;

/* does program contain sections */
check (84):
secsw:						/*[4.4-6]*/
	if fixed_common.report
	then go to success;
	if secswitch = 1
	then go to success;
	go to fail;				/* does imperative switch = 0 */


check (85):
is_rel:						/*[5.3-2]*/
	if reserved_word.type ^= 1
	then go to fail;

/*[5.3-2]*/
	ky = reserved_word.key;			/*[5.3-2]*/
	if ky = 130 | ky = 118 | ky = 113 | ky = 117 | ky = 141 | ky = 127 | ky = 180 | ky = 181 | ky = 74
						/*[5.3-2]*/
	then go to success;

/*  not,is,=,exceeds,unequal,positive,negative,zero,numeric,alphabetic */

	go to fail;				/* is there no previous sections within declaratives */



check (86):
deswz:
	if debugsw = 0
	then go to success;
	go to fail;				/* is it a cdname */
check (87):
cdname:
	if header.type = 13
	then go to success;
	go to fail;				/* is it a data name not in report section */
check (88):
dana:
	if header.type = 9 & data_name.report_section = "0"b
	then go to success;
	go to fail;

/* is there a format 1 use verb associated with this verb */



check (89):
useform1b:
	if savitmptr -> fd_token.file_no = 0
	then go to fail;

	file_number = savitmptr -> fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);

	go to useform1;

/*is declarative switch = 1 */

check (90):
deswon:
	if decswitch = 1
	then go to success;
	go to fail;

/* is saved file sequential  or was NEXT option used */

check (91):
seqnext:
	if end_stmt.d
	then go to success;

	if savitmptr -> fd_token.file_no = 0
	then go to fail;

	file_number = savitmptr -> fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);

	if access < 2
	then go to success;
	go to fail;

/* is it an unsubscripted elementary data name */

check (92):
unelnudn:
	if header.type = 9 & ^data_name.subscripted & data_name.elementary & ^data_name.constant_section
	     & data_name.numeric
	then go to success;
	go to fail;				/* is it a statement termiator */
check (93):
sterm:
	if header.type = 1 & reserved_word.terminator
	then go to success;

	if header.type = 7
	then go to success;
	go to fail;				/* is it a group item or does it have usage is display */



check (94):
usagid:
	if header.type = 9 & (data_name.non_elementary | data_name.display)
	then do;
		repcsbit = data_name.constant_section;	/*[4.1-7]*/
		prev_diag.line_num = header.line;	/*[4.1-7]*/
		prev_diag.column_num = header.column;
		go to success;
	     end;
	go to fail;

/*  is item an elementary item with usage is display clause */
check (95):
eldis:
	if header.type = 9 & data_name.display & data_name.elementary
	then go to success;
	go to fail;				/* was previous eos a paragraph definition */



check (96):
preospn:
	if end_stmt.verb = 55
	then go to success;
	go to fail;				/* are both saved and current item elementary numeric */
						/* and are both signed or unsigned */
						/* and is left of dp in saved item le than current item*/
						/* and is right of dp in saved item le than current item */
						/* and does saved item not share core with current item */
check (97):
nues:
	if saveitem.type = 2
	then if data_name.numeric_edited
	     then if savitmptr -> numeric_lit.places_left <= data_name.places_left
		     & savitmptr -> numeric_lit.places_right <= data_name.places_right
		then go to success;
		else go to fail;
	     else if data_name.alphanum | data_name.alphanum_edited
	     then if savitmptr -> numeric_lit.sign = " " & savitmptr -> numeric_lit.integral
		     & savitmptr -> numeric_lit.places_left <= data_name.places_left
		then go to success;
		else go to fail;
	     else if data_name.elementary & data_name.numeric
		& (data_name.item_signed | (^data_name.item_signed & savitmptr -> numeric_lit.sign = " "))
		& savitmptr -> numeric_lit.places_left <= data_name.places_left
		& savitmptr -> numeric_lit.places_right <= data_name.places_right
	     then go to success;
	     else go to fail;
	else if saveitem.type = 1 & savitmptr -> reserved_word.key = 192
						/*SPACES*/
	then go to fail;
	else if saveitem.type = 1 & savitmptr -> reserved_word.figcon
	then if data_name.numeric | ^data_name.alphabetic
	     then go to success;
	     else go to fail;
	else if saveitem.type = 3
	then if data_name.elementary & (data_name.numeric | data_name.numeric_edited)
		& savitmptr -> alphanum_lit.lit_size <= data_name.places_left
	     then go to success;
	     else go to fail;
	else if data_name.elementary & savitmptr -> data_name.elementary & data_name.numeric
	     & savitmptr -> data_name.numeric
	     & ((data_name.item_signed & savitmptr -> data_name.item_signed)
	     | (^data_name.item_signed & ^savitmptr -> data_name.item_signed))
	     & savitmptr -> data_name.places_left <= data_name.places_left
	     & savitmptr -> data_name.places_right <= data_name.places_right
	then do;
		call overlap;
		if res
		then go to success;
		else go to fail;
	     end;
	go to fail;

overlap:
     proc;

	if data_name.type ^= 9 | saveitem.type ^= 9
	then do;
		res = "1"b;
		return;
	     end;

	if data_name.seg_num ^= savitmptr -> data_name.seg_num | data_name.def_line = savitmptr -> data_name.def_line
	then do;
		res = "1"b;
		return;
	     end;

/*[3.0-11]*/
/*[]*/
	if data_name.linkage_section | savitmptr -> data_name.linkage_section
						/*[]*/
	then do;
		if data_name.linkage_section & savitmptr -> data_name.linkage_section
						/*[]*/
		then do;
			if data_name.linkage ^= savitmptr -> data_name.linkage
						/*[]*/
			then do;
				res = "1"b;	/*[]*/
				return;		/*[]*/
			     end;			/*[]*/
		     end;				/*[]*/
		else do;
			res = "1"b;		/*[]*/
			return;			/*[]*/
		     end;				/*[]*/
	     end;					/*[3.0-11]*/

	call get_pos (addr_record, O1_ptr);
	call get_pos (savitmptr, O2_ptr);

	if (O1.o1 < O2.o2 & O1.o1 + O1.l1 <= O2.o2) | O2.o2 + O2.l2 <= O1.o1
	then res = "1"b;
	else res = "0"b;

get_pos:
     proc (p, q);

declare	(p, q)		ptr;

declare	1 O		based (q),
	  2 o		fixed bin,
	  2 l		fixed bin;

	O.o = p -> data_name.offset;
	O.o = O.o + O.o;

	if p -> data_name.ascii_packed_dec_h
	then do;
		if p -> data_name.bit_offset
		then O.o = O.o + 1;			/* comp-8 */

		O.l = p -> data_name.places_left + p -> data_name.places_right;

		if p -> data_name.item_signed
		then O.l = O.l + 1;
	     end;
	else do;
		O.l = p -> data_name.item_length;
		O.l = O.l + O.l;
	     end;
     end;
     end;						/* are both saved and current item alphanumeic */
						/*and is saved item le current item */
						/* and does saved item not share core with current item */
check (98):
anes:
	if saveitem.type = 2
	then go to fail;
	else if saveitem.type = 1 & savitmptr -> reserved_word.figcon
	then if data_name.alphanum | data_name.non_elementary | data_name.alphanum_edited
	     then go to success;
	     else if savitmptr -> reserved_word.key = 180 /*ZERO*/
	     then go to fail;
	     else if data_name.alphabetic
	     then go to success;
	     else go to fail;
	else if saveitem.type = 3
	then if (data_name.alphanum | data_name.alphanum_edited)
		& data_name.item_length >= savitmptr -> alphanum_lit.lit_size
	     then go to success;
	     else if data_name.non_elementary & data_name.item_length >= savitmptr -> alphanum_lit.lit_size
	     then go to success;
	     else go to fail;
	else if savitmptr -> data_name.numeric_edited
	then if (data_name.alphanum | data_name.alphanum_edited)
		& data_name.item_length >= savitmptr -> data_name.item_length
	     then do;
		     call overlap;
		     if res
		     then go to success;
		     else go to fail;
		end;
	     else go to fail;
	else if (data_name.alphanum | data_name.alphanum_edited)
	     & (savitmptr -> data_name.alphanum | savitmptr -> data_name.alphanum_edited
	     | savitmptr -> data_name.alphabetic) & data_name.item_length >= savitmptr -> data_name.item_length
	then do;
		call overlap;
		if res
		then go to success;
		else go to fail;
	     end;
	go to fail;

/* is either saved item or current item a group item */
check (99):
group:
	if data_name.non_elementary
	then go to success;

	else if saveitem.type = 2
	then go to fail;

	else if saveitem.type = 9 & savitmptr -> data_name.non_elementary
	then go to success;
	go to fail;

/* is sending item size le receiving size + 1 */
check (100):
sler:
	if saveitem.type = 2
	then if savitmptr -> numeric_lit.places <= data_name.item_length
	     then go to success;
	     else go to fail;
	else if saveitem.type = 3
	then if savitmptr -> alphanum_lit.lit_size <= data_name.item_length
	     then go to success;
	     else go to fail;
	else if savitmptr -> data_name.item_length <= data_name.item_length
	then go to success;
	go to fail;

/* does sending item not overlap receiving item */

check (101):
snor:
	if saveitem.type = 3 | saveitem.type = 2
	then go to success;
	else do;
		call overlap;
		if res
		then go to success;
		else go to fail;
	     end;

/* is it alphaanumeric or alphanumeric_edited */

check (102):
an:
	if data_name.alphanum | data_name.alphanum_edited
	then go to success;
	go to fail;

/* does sending item not have any digits to right of dp */
check (103):
sndrdp:
	if saveitem.type = 3 | (saveitem.type = 2 & savitmptr -> numeric_lit.integral)
	     | (savitmptr -> data_name.numeric_edited | savitmptr -> data_name.places_right <= 0)
	then go to success;
	go to fail;

/* is sending item not signed */
check (104):
snos:
	if saveitem.type = 3 | ^(savitmptr -> data_name.item_signed)
	then go to success;
	go to fail;

/* is it alphabetic */
check (105):
alph:
	if data_name.alphabetic | data_name.alphabetic_edited
	then go to success;
	go to fail;

/* is sending item not numeric */
check (106):
snon:						/*[4.2-5]*/
	if saveitem.type = 9			/*[4.2-5]*/
	then do;
		if savitmptr -> data_name.numeric	/*[4.2-5]*/
		then do;
			call diag (151);		/*[4.2-5]*/
			go to fail;		/*[4.2-5]*/
		     end;

/*[4.2-5]*/
		if savitmptr -> data_name.numeric_edited/*[4.2-5]*/
		then do;
			call diag (136);		/*[4.2-5]*/
			go to fail;		/*[4.2-5]*/
		     end;

/*[4.2-5]*/
		go to success;			/*[4.2-5]*/
	     end;

/*[4.2-5]*/
	if saveitem.type = 3 | saveitem.type = 1
	then go to success;

/*[4.2-5]*/
	call diag (151);

	go to fail;

/* is sending field not alphabetic */
check (107):
snal:
	if saveitem.type = 3 | saveitem.type = 2 | (saveitem.type = 9 & ^(savitmptr -> data_name.alphabetic))
	then go to success;
	go to fail;

/* is sending field not alphanumeric edited */
check (108):
snae:
	if saveitem.type = 3 | saveitem.type = 2 | ^(savitmptr -> data_name.alphanum_edited)
	then go to success;
	go to fail;

/* is sending field not numeric edited */
check (109):
snne:
	if saveitem.type = 3
	then go to success;				/*  sending field is alphanumeric literal */

	if saveitem.type = 2
	then go to success;

	if ^savitmptr -> data_name.numeric_edited
	then go to success;
	go to fail;				/* is sending item alphanumeric */
check (110):
san:
	if saveitem.type = 2
	then go to fail;

	if saveitem.type = 3
	then go to success;				/* sending field is alphanumeric literal */

	if savitmptr -> data_name.alphanum
	then go to success;
	go to fail;				/* is sending right of dp le receiving right of dp */
check (111):
ritdep:
	if saveitem.type = 2
	then go to check111a;

	if savitmptr -> data_name.places_right <= data_name.places_right
	then go to success;
	go to fail;

check111a:
	if savitmptr -> numeric_lit.places_right <= data_name.places_right
	then go to success;
	go to fail;				/* is sending left of dp le receiving lift of dp */
check (112):
lefdep:
	if saveitem.type = 2
	then go to check112a;

	if savitmptr -> data_name.places_left <= data_name.places_left
	then go to success;
	go to fail;

check112a:
	if savitmptr -> numeric_lit.places_left <= data_name.places_left
	then go to success;
	go to fail;				/* is sending field signed and receiveng field unsigned */
check (113):
stun:
	if saveitem.type = 2
	then go to check113a;			/* numeric literal */

	if savitmptr -> data_name.item_signed & ^data_name.item_signed
	then go to success;
	go to fail;

check113a:					/* numeric literal */
	if savitmptr -> numeric_lit.sign ^= " " & ^data_name.item_signed
	then go to success;
	go to fail;				/* is sending item total size le left of dp redeiving field */
check (114):
slelef:
	if (saveitem.type = 3 & savitmptr -> alphanum_lit.lit_size <= data_name.places_left)
	     | (saveitem.type = 9 & savitmptr -> data_name.item_length <= data_name.places_left)
	then go to success;
	go to fail;

/* is it end declaratives */


check (115):
enddec:						/*[5.2-1]*/
	if header.type = 1 & reserved_word.key = 98 /*[5.2-1]*/ & reserved_word.end_dec = "1"b
	then do;
		end_decl_bit = "1"b;
		go to success;
	     end;
	go to fail;				/* is item alterable */

check (116):
edalit:
	if header.type = 9 & data_name.constant_section = "0"b
	then go to success;
	go to fail;				/* is it an alterable elementary numeric item */
check (117):
alelnuitm:
	if header.type = 9 & data_name.constant_section = "0"b & data_name.elementary = "1"b & data_name.numeric = "1"b
	then go to success;
	go to fail;				/* is it an integer */
check (118):
elnuint:
	if header.type = 2 & numeric_lit.integral
	then go to success;
	go to fail;				/*  is it an elementary numeric data name and an integer */
check (119):
elnudnint:
	if header.type = 9 & data_name.elementary & data_name.pic_integer
	then go to success;
	go to fail;				/* is it an edited or non edited alterable
			elementary numeric item */
check (120):
edalelnue:
	if header.type = 9 & ^data_name.constant_section & data_name.elementary
	     & (data_name.numeric | data_name.numeric_edited)
	then go to success;
	go to fail;				/* is curerent item file number not equal to saved item file number */

check (121):
filno:
	if data_name.file_num ^= savitmptr -> data_name.file_num
	then go to success;
	go to fail;				/* is item alphabetic or alphanumeric */
check (122):
alphoral:
	if data_name.alphanum | data_name.alphabetic
	then go to success;
	go to fail;				/* is item an arithmetic operator or right paren */
check (123):
aroprp:
	if header.type = 1 & reserved_word.arith_op
	then go to success;

	if header.type = 1 & reserved_word.key = 188
	then go to success;
	go to fail;				/* is item a relation operator */

check (124):
relop:
	if fixed_common.comp_level < "3"
	then do;
		if header.type = 1 & reserved_word.rel_op
		then do;
			if reserved_word.end_dec
			then call lev_diag (10);
			go to success;
		     end;

	     end;
	else do;
		if header.type = 1 & reserved_word.rel_op
		then go to success;
	     end;

	go to fail;				/* is token res word positive or negative or zero */
check (125):
pnz:
	if header.type = 1 & reserved_word.key = 141 | reserved_word.key = 127 | reserved_word.key = 180
	then go to success;
	go to fail;				/* is subject not = 0 --- do we have a subject present */
check (126):
is_sub_opt:
	if SUBJ_REQ
	then go to fail;
	else go to success;

/* is item on stack numeric */
check (127):					/* sign condition test */
numstak:						/*[4.2-8]*/
	if op.loc = null ()
	then go to success;

/*[4.2-8]*/
	if op.loc -> data_name.type ^= 9
	then go to fail;

/*[4.2-8]*/
	if op.loc -> data_name.non_elementary
	then go to fail;

/*[4.2-8]*/
	if ^op.loc -> data_name.numeric
	then go to fail;

/*[4.2-8]*/
	go to success;				/* is item on stack not numerical */
check (128):					/* alphabetic class condition */
notnumstk:					/*[4.2-8]*/
	if op.loc = null ()
	then go to fail;

/*[4.2-8]*/
	if op.loc -> data_name.type ^= 9
	then go to fail;

/*[4.2-8]*/
	if op.loc -> data_name.elementary		/*[4.2-8]*/
	then if ^op.loc -> data_name.display		/*[4.2-8]*/
	     then go to fail;			/*[4.2-8]*/
	     else if op.loc -> data_name.numeric	/*[4.2-8]*/
	     then go to fail;

/*[4.2-8]*/
	go to success;				/* is item on stack not alphabetic */
check (129):					/* numeric condition test */
notalpstk:					/*[4.2-8]*/
	if op.loc = null ()
	then go to fail;

/*[4.2-8]*/
	if op.loc -> data_name.type ^= 9
	then go to fail;

/*[4.2-8]*/
	if op.loc -> data_name.elementary		/*[4.2-8]*/
	then if ^op.loc -> data_name.display		/*[4.2-8]*/
	     then go to fail;			/*[4.2-8]*/
	     else if op.loc -> data_name.alphabetic	/*[4.2-8]*/
	     then go to fail;

/*[4.2-8]*/
	go to success;				/* is arithmetic stack = 0 */
check (130):
zerstk:
	if assub = 1 | assub = 0
	then go to success;
	go to fail;				/* does item on arithmetic stack = left parenthesis */
check (131):
lefparstk:
	if assub = 0
	then go to fail;
	if astack.lefpar (assub)
	then go to success;
	else go to fail;				/* is the logical stack = ( and is bit logical = 0   */
check (132):
logbitstk:
	if cssub = 0
	then go to fail;

	if cstack.leftpar (cssub) & ^cstack.logical (cssub)
	then go to success;
	go to fail;				/* is logical stack = ( */
check (133):
logstk:
	if cstack.leftpar (cssub)
	then go to success;
	go to fail;				/* is item a status switch condition name */
check (134):
sscondnm:
	if mnemonic_name.type = 17 & mnemonic_name.class.switch_condition
	then go to success;

	go to fail;

/* to be done later */

/* are the arguments of the relation compatible */
check (135):
argscomp:
	go to success;				/* is item in active logical a left parenthesis */
check (136):
actloglp:
	if act_log.leftpar
	then go to success;
	go to fail;				/* is top of stack a left parenthesis */
check (137):
lptopstk:
	if cstack.leftpar (cssub)
	then go to success;
	go to fail;

/* is item an unsubscripted index data name */

check (138):
unxdnm:
	if header.type = 9 & ^data_name.subscripted & data_name.usage_index
	then go to success;
	go to fail;				/* can we expect another else or a period at this point */
check (139):
is_imp:						/*[5.3-2]*/
	if ST.cond (nest_lev + 1)
	then go to fail;
	else go to success;

/* are the subscripts compatible */
check (140):
daib:
	if data_name_bit ^= index_name_bit
	then go to success;
	go to fail;


check (141):
	go to fail;				/* NOT USED */
						/* NOT USED */


check (142):
	go to fail;				/* NOT USED */
						/* NOT USED */

/*  is present file number not equal to saved file number  */

check (143):
filnefil:
	if data_name.file_num ^= savitmptr -> data_name.file_num
	then go to success;
	go to fail;

check (144):
indxfile:
	if data_name.file_num ^= 0
	then do;
		file_number = data_name.file_num;
		call cobol_read_ft_ (file_number, ft_ptr);
	     end;
	else go to fail;

	if organization = 3
	then go to success;
	go to fail;

check (145):
gotod:						/*  are we processing a go to depending in if statement */
	if gotodep
	then go to success;
	go to fail;				/*  is the justified right bit not set */
check (146):
njustr:
	if ^data_name.just_right
	then go to success;
	go to fail;

/* is item alphanumeric */

check (147):
nonumdn:
	if header.type = 9 & data_name.alphanum
	then go to success;
	go to fail;				/* is receiving field alphanumeric edited */



check (148):
rae:
	if data_name.alphanum_edited
	then go to success;
	go to fail;

/* is item elementary alphabetic,alphanumeric or numeric edited or a group item */



check (149):
elaanne:
	if header.type = 9
	     & ((data_name.elementary & (data_name.numeric_edited | data_name.alphanum | data_name.alphabetic))
	     | data_name.non_elementary)
	then go to success;
	go to fail;

/* is item a subscribted idndex data name */



check (150):
suxdnm:
	if header.type = 9 & data_name.subscripted & data_name.usage_index
	then go to success;
	go to fail;				/* does declarative portion reference non-declarative portion or vice versa */

check (151):
decnondec:
	if decswitch = 1 | ^proc_def.declarative_proc
	then go to success;
	go to fail;

/* was there a procedure definition before the EXIT verb */



check (152):
ckprpnbit:
	if preospn_bit
	then go to success;
	go to fail;

/* is this MNEMONIC NAME an input device */



check (153):
indev:
	if mnemonic_name.iw_key = 3 | mnemonic_name.iw_key = 1
	then go to success;				/*[3.0-4]*/
	go to fail;

/* is MNEMONIC NAME input device */

check (154):
outdev:
	if mnemonic_name.iw_key = 3 | mnemonic_name.iw_key = 2
	then go to success;				/*[3.0-4]*/
	go to fail;

/* is file either relative or INDEXED */
/* is ACCESS either SEQUENTIAL or DYNAMIC */
/* used for START verb */

check (155):
ixrlsqdy:
	if fd_token.file_no ^= 0
	then do;
		file_number = fd_token.file_no;
		call cobol_read_ft_ (file_number, ft_ptr);
	     end;
	else go to fail;

	if (organization = 2 & relative_key) | organization = 3
	then if access < 2 | access = 3
	     then go to success;
	go to fail;

/* is file ORGANIZATION RELATIVE */
/* used for START verb */
/* buffer already has record from common */

check (156):
relfile:
	if organization = 2
	then go to success;
	go to fail;

/* is ITEM NAME & ADDRESS same as info in KEY NAME in SELECT clause */
/* FILE TABLE already in core */
/* processing START verb */

check (157):
keyiskey:
	if r_key_info = "00000"
	then go to fail;

	varrecaddr = r_key_info;
	call vardget;
	fkey_ptr = seqvarptr;

	if substr (data_name.name, 1, data_name.name_size) = substr (fkname, 1, file_key.fkname_size)
	     & data_name.seg_num = fkseg_num & data_name.offset = fkoffset
	then go to success;
	go to fail;

/* is ADDRESS same as FILE KEY in COMMON */
/* FILE TABLE already in core */
/* processing START verb */

check (158):					/*[3.0-15]*/
adrisadr:						/*[]*/
	if alternate_keys = 0			/*[]*/
	then if r_key_info = "00000"			/*[]*/
	     then go to fail;			/*[]*/
	     else ;				/*[]*/
	else if alt_key_info = "00000"		/*[]*/
	then go to fail;				/*[]*/
						/*[]*/
	file_desc_1_ptr = addrel (cobol_$con_end_ptr, -(file_desc_1_offset - 1));
						/*[]*/
						/*[]*/
	if header.type = 9 /*[]*/ & /*[]*/ (data_name.file_num = file_table.file_no | alternate_keys = 0)
						/*[]*/
	then do;					/*[]*/
		if get_rel_offset (data_name.offset) = file_desc_1.prime_key.offset
						/*[]*/
		then do;				/*[]*/
			vfile_key = 511;		/* prime vfile_ key */
						/*[]*/
			go to success;		/*[]*/
		     end;				/*[]*/
		else do kc = 1 to alternate_keys;	/*[]*/
			if get_rel_offset (data_name.offset) = file_desc_1.alt_key (kc).offset
						/*[]*/
			then do;			/*[]*/
				vfile_key = kc;	/*[]*/
				go to success;	/*[]*/
			     end;			/*[]*/
		     end;				/*[]*/
	     end;					/*[]*/
						/*[]*/
						/*[]*/
	go to fail;


get_rel_offset:
     proc (abs_offset) /*[]*/ returns (fixed bin (24));

/*[]*/
dcl	abs_offset	fixed bin (24);		/*[]*/
dcl	rel_offset	fixed bin (24);		/*[]*/
						/*[]*/
	rel_offset = abs_offset - file_table.abs_record_offset;
						/*[]*/
	return (rel_offset);			/*[]*/
     end get_rel_offset;

check (159):
ssnm:
	if mnemonic_name.type = 17 & mnemonic_name.class.switch_name
	then go to success;

	go to fail;

check (160):					/* enter, routine name */
is_rout:
	if lang_num = 1
	then go to fail;

	if header.type = 8
	then go to success;

	go to fail;

check (161):
edick:
	if data_name.alphanum | data_name.alphabetic
	     | (data_name.numeric & data_name.places_left ^< 0 & data_name.places_right ^< 0)
	then go to success;
	go to fail;

check (162):
cktp25:
	if header.type = 25
	then go to success;
	go to fail;

/* range check for set verb format 1 */
check (163):
ckrng1:
	convtemp = 0;

	do ii = 1 to numeric_lit.places;
	     tempchar1 = substr (numeric_lit.literal, ii, 1);
	     convtemp = convtemp * 10 + fixed (unspec (tempchar1), 8) - convalue;
	end;

	if convtemp ^> savitmptr -> index_name.max
	then go to success;
	go to fail;

/* range check for set verb format 2 */
check (164):
ckrng2:
	convtemp = 0;

	do ii = 1 to numeric_lit.places;
	     tempchar1 = substr (numeric_lit.literal, ii, 1);
	     convtemp = convtemp * 10 + fixed (unspec (tempchar1), 8) - convalue;
	end;

	if convtemp < savitmptr -> index_name.max
	then go to success;
	go to fail;

/* check ssf or dof in file table - already in core from check(70) */

check (165):
ckrcpref:
	if (record_prefix = 2 | record_prefix = 3)
	then go to success;
	go to fail;

/* check to insure that the literal used for the program-id is less than 13 characters */



check (166):
cklit:
	if header.type = 3 & alphanum_lit.lit_size < 31
	then go to success;
	go to fail;

/* are both proc-names non-declaratives or both declaratives in same declarative section */

check (167):
ckdecpn:
	if ^proc_def.declarative_proc & ^(savitmptr -> proc_def.declarative_proc)
	then go to success;

	if (proc_def.declarative_proc & savitmptr -> proc_def.declarative_proc)
	     & (proc_def.section_num = savitmptr -> proc_def.section_num)
	then go to success;
	go to fail;

/* independent & non-independent segment checks for perform verb */
check (168):
cksegm:
	if secswitch = 0
	then go to success;
	if shprio > 99
	then go to fail;

	prio1 = fixed (unspec (savitmptr -> proc_def.priority), 16);

	if prio1 > 99
	then go to fail;

	prio2 = fixed (unspec (proc_def.priority), 16);

	if prio2 > 99
	then go to fail;
	if shprio > 49
	then go to check168a;
	if prio1 < 50 & prio2 < 50
	then go to success;
	if prio1 = prio2
	then go to success;
	go to fail;
check168a:
	if prio1 < 50 & prio2 < 50
	then go to success;

	if (prio1 = prio2) & (prio1 = shprio)
	then go to success;
	go to fail;

/* check for a nonzero numeric literal */
check (169):
nznumlit:
	if header.type = 2
	then do;
		litcnt = 1;

		do while ("1"b);

		     if substr (numeric_lit.literal, litcnt, 1) ^= "0"
		     then go to success;

		     if litcnt = numeric_lit.places
		     then go to fail;

		     litcnt = litcnt + 1;

		end;
	     end;

	go to fail;

/* check integer bit in saved identifier */
check (170):
ckintbit:
	if numeric_lit.integral
	then go to success;				/*[3.0-3]*/
	go to fail;

/* check segment number in declaratives */


check (171):
ckdsegnum:
	if perfprio < 50
	then go to success;
	go to fail;

/* is a use procedure already associated with this file */

check (172):
ckerrex:
	if end_stmt.a = "000"b & fd_token.file_no ^= 0
	then do;

		file_number = fd_token.file_no;
		call cobol_read_ft_ (file_number, ft_ptr);

		if error_exit = 0
		then go to success;
		else go to fail;

	     end;
	go to fail;

/* is a use procedure already associated with input */

check (173):
ckinput:
	if input_error_exit = 0
	then go to success;
	else go to fail;

/* is a use procedure already associated with output */

check (174):
ckoutput:
	if output_error_exit = 0
	then go to success;
	else go to fail;

/* is a use procedure already associated with i-o */

check (175):
ckio:
	if i_o_error_exit = 0
	then go to success;
	else go to fail;

/* is a use procedure already associated with extend */

check (176):
ckextend:
	if extend_error_exit = 0
	then go to success;
	else go to fail;

/* for delete and start verbs - does a use procedure exist */

check (177):
useformds:
	if error_exit ^= 0
	then go to success;
	if input_error_exit ^= 0
	then go to success;
	if output_error_exit ^= 0
	then go to success;
	if i_o_error_exit ^= 0
	then go to success;
	if extend_error_exit ^= 0
	then go to success;
	go to fail;

/* for read verb - does a use procedure exist */

check (178):
useformr:
	if error_exit ^= 0
	then go to success;
	if input_error_exit ^= 0
	then go to success;
	if i_o_error_exit ^= 0
	then go to success;
	go to fail;

/* for write and rewrite verbs - does a use procedure exist */

check (179):
useformrw:
	if error_exit ^= 0
	then go to success;
	if output_error_exit ^= 0
	then go to success;
	if i_o_error_exit ^= 0
	then go to success;
	if extend_error_exit ^= 0
	then go to success;
	go to fail;

/* is an lit < 32 chars for CALL */

check (180):
cklit1:
	if alphanum_lit.lit_size < 32
	then go to success;
	go to fail;

/* are we executing multics cobol compiler */

check (181):
mcobol:
	if compiler_id = 3
	then go to success;
	go to fail;

/* is an lit < 66 chars for CALL */

check (182):
cklit2:
	if alphanum_lit.lit_size < 66
	then go to success;
	go to fail;

/* is organization not stream */

check (183):
nstream:
	if header.type = 12
	then do;

		if fd_token.file_no ^= 0
		then do;

			file_number = fd_token.file_no;
			call cobol_read_ft_ (file_number, ft_ptr);

			if organization ^= 5
			then go to success;		/*[3.0-2]*/
			go to fail;

		     end;

	     end;
	go to fail;

/* is orgganization stream */

check (184):
stream:
	if fd_token.file_no = 0
	then go to fail;

	file_number = fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);

	if organization = 5
	then go to success;				/*[3.0-2]*/
	go to fail;

/* is organization not stream */

check (185):
nstorg:
	if organization ^= 5
	then go to success;				/*[3.0-2]*/
	go to fail;

/* is item unsubscripted data name excluding index data names, and,
		is it elementary, numeric ,integer data item. */
check (186):
udneli:
	if header.type = 9 & ^data_name.subscripted & ^data_name.usage_index & data_name.elementary
	     & data_name.numeric & data_name.pic_integer
	then do;
		sub_loc = sub_loc + 1;
		go to success;
	     end;
	go to fail;

check (187):
cstst:
	if ^data_name.constant_section
	then go to success;
	else go to fail;

check (188):
altst:
	if header.type = 9 & data_name.elementary & data_name.numeric
	then go to success;
	else go to fail;

check (189):
edaltst:
	if header.type = 9 & data_name.elementary & (data_name.numeric | data_name.numeric_edited)
	then go to success;
	else go to fail;

check (190):
csstst:
	if ^cssavebit
	then go to success;
	else go to fail;

check (191):
altlegal:
	if declprocbit | ^proc_def.declarative_proc
	then go to success;
	else go to fail;

check (192):
lev_test:
	if lev_save = cssub
	then go to success;
	else go to fail;

check (193):
resword:						/*[4.2-6]*/
	oploc.line = reserved_word.line;		/*[4.2-6]*/
	oploc.col = reserved_word.column;

/*[4.2-6]*/
	if reserved_word.type = 1			/*[4.2-6]*/
	then go to success;				/*[4.2-6]*/
	else go to fail;

check (194):
type9:
	if header.type = 9
	then go to success;
	else go to fail;

check (195):
alphnm:						/* check for alphabet name token */
	if alphabet_name.type = 40
	then do;
		end_stmt.i = alphabet_name.iw_key;
		end_stmt.d = "10"b;
	     end;
	else go to fail;

	go to success;

check (196):
on_off:						/* test for ON or OFF */
	if reserved_word.type ^= 1
	then go to fail;

	key = reserved_word.key;

	if key = 134
	then end_stmt.c = "1"b;			/* is_word("ON") */
	else if key = 574
	then end_stmt.c = "0"b;			/* is_word("OFF") */
	else go to fail;

	end_stmt.a = "010"b;

	go to success;

acc_dev:
check (197):					/* test for accept device */
	if mnemonic_name.type = 17 & mnemonic_name.class.accept_device
	then go to success;

	go to fail;

disp_dev:
check (198):					/* test for display device */
	if mnemonic_name.type = 17 & mnemonic_name.class.display_device
	then go to success;

	go to fail;

prt_con:
check (199):					/* test for printer control */
	if mnemonic_name.type = 17 & mnemonic_name.class.printer_control
	then go to success;

	go to fail;

check (200):					/* enter, language name */
is_lang:
	lang_num = cobol_imp_word$lang_name (addr_record);

	if lang_num = 0
	then go to fail;

	go to success;

check (201):
amarg:
	if header.column < 12
	then go to success;
	go to fail;

check (202):
set_xint:
	if header.type = 9 & data_name.elementary
	then go to success;

	go to fail;

check (203):
set_pigz:
	call pigz_sub;

	if pigz_res = 0
	then go to success;

	go to fail;

check (204):
tst_xint:
	if data_name.usage_index
	then do;
		if set_sop.ind_data
		then do;
			call diag (280);
			go to fail;
		     end;
		go to success;
	     end;

	if data_name.pic_integer
	then do;
		if set_sop.int_data
		then do;
			call diag (281);
			go to fail;
		     end;

		go to success;
	     end;

	call diag (178);

	go to fail;

check (205):
tst_pigz:
	if set_sop.int_lit
	then do;
		call diag (282);
		go to fail;
	     end;

	go to success;

check (206):
is_user_word:
	if data_name.type = 9
	then go to success;

	go to fail;

check (207):
open_mode:
	if reserved_word.type = 1
	then do;
		if reserved_word.key = 115
		then op_mode = 1;			/* input */
		else if reserved_word.key = 137
		then op_mode = 2;			/* output */
		else if reserved_word.key = 119
		then op_mode = 3;			/* i-o */
		else if reserved_word.key = 216	/* extend */
						/*[4.4-8]*/
		then do;
			op_mode = 4;		/*[4.4-8]*/
			if fixed_common.comp_level < "3"
			then call lev_diag (39);	/*[4.4-8]*/
		     end;
		else go to fail;
		go to success;
	     end;

	go to fail;

check (208):
nlit:
	if header.type = 2
	then go to success;

	go to fail;

check (209):					/*[3.0-6]*/
pigz_by:						/*[3.0-6]*/
	litcnt = 1;				/*[3.0-6]*/

	if header.type = 2 /*[3.0-6]*/ & /*[3.0-6]*/ numeric_lit.integral
						/*[3.0-6]*/
	then do while ("1"b);			/*[3.0-6]*/

		if substr (numeric_lit.literal, litcnt, 1) ^= "0"
						/*[3.0-6]*/
		then do;
			if numeric_lit.sign = "-"	/*[3.0-6]*/
			then do;
				if fixed_common.comp_level < "5"
						/*[3.0-6]*/
				then call lev_diag (40);
						/*[3.0-6]*/
			     end;			/*[3.0-6]*/

			go to success;		/*[3.0-6]*/
		     end;				/*[3.0-6]*/

		if litcnt = numeric_lit.places
		then go to fail;			/*[3.0-6]*/

		litcnt = litcnt + 1;		/*[3.0-6]*/

	     end;					/*[3.0-6]*/

	go to fail;				/*[3.0-10]*/

/* the following proc is used by the action routines
			ieo means exclusive or
			set coperator.not to coperator.not eo lognot eo parameter
			clear lognot
			if param = 0 move use (true of active ) to tag field of coperator and go to second next inst
			if param not 0 then move use (false of active ) to tag field of coperator and go to next inst
			output the coperator
			clear operator
			return*/

/*   	if file device suffix printer */

check (210):					/*[3.0-14]*/
devptr:						/*[3.0-14]*/
	if savitmptr -> data_name.file_num = 0		/*[3.0-14]*/
	then goto fail;				/*[3.0-14]*/

	file_number = savitmptr -> data_name.file_num;	/*[3.0-14]*/
	call cobol_read_ft_ (file_number, ft_ptr);	/*[3.0-14]*/

	if file_table.device = 1
	then goto success;				/*[3.0-14]*/

	goto fail;				/*[3.0-14]*/



/*[3.0-16]*/
/* check for sequential file using savitmptr */

check (211):
seqstmfil:
	if savitmptr -> data_name.file_num = 0
	then go to fail;

	file_number = savitmptr -> data_name.file_num;
	call cobol_read_ft_ (file_number, ft_ptr);

	if organization = 1 | organization = 5
	then go to success;

	go to fail;

/*[4.0-1]*/
check (212):
cond_name:					/*[4.0-1]*/
	if reserved_word.section_header
	then go to success;
	else go to fail;

check (213):
pn_pres:						/*[4.0-4]*/
	if end_stmt.d = "00"b
	then go to success;
	else go to fail;

check (214):
debug:						/*[4.4-5]*/
	if fixed_common.debug & fixed_common.use_debug
	then go to success;				/*[4.4-5]*/
	if fixed_common.use_reporting			/*[4.4-5]*/
	then do while (addr_record -> reserved_word.column = 9999);
						/*[4.4-5]*/
		call SCAN;			/*[4.4-5]*/
	     end;

/*[5.1-2]*/
	LTP, last_wd_per = "1"b;			/*[4.4-5]*/
	if fixed_common.report
	then go to success;
	else go to fail;

check (215):
not_opt:						/*[5.3-2]*/
	if ST.not_opt (nest_lev)
	then go to success;
	else go to fail;

check (216):					/* check for figurative constant ZERO */
figzero:						/*[4.2-3]*/
	if reserved_word.type = 1 & reserved_word.key = 180
	then if fixed_common.comp_level < "3" & reserved_word.end_dec
	     then call lev_diag (154);
	     else /* do nothing */
		;
	else go to fail;

	go to success;

check (217):
noo:						/*[5.3-2]*/
	if reserved_word.type = 1			/*[5.3-2]*/
	then if reserved_word.key = 130 | reserved_word.key = 134 | reserved_word.key = 6
						/*[5.3-2]*/
	     then go to success;			/*[5.3-2]*/
	     else go to fail;			/*[5.3-2]*/
	else go to fail;








check (218):
is_cond:
	if iscond
	then go to success;
	else go to fail;

check (219):
period:						/*[4.4-2]*/
	if reserved_word.type = 1			/*[4.4-2]*/
	then if reserved_word.key = 189		/* . */
						/*[4.4-2]*/
	     then do;
		     last_wd_per = "1"b;

/*[4.4-2]*/
		     go to success;			/*[4.4-2]*/
		end;				/*[4.4-2]*/
	go to fail;

check (220):
nae:						/*[5.3-2]*/
	if reserved_word.type = 1			/*[5.3-2]*/
	then if reserved_word.key = 130 | reserved_word.key = 79 | reserved_word.key = 100
						/*not,at,eop */
						/*[5.3-2]*/
	     then go to success;			/*[5.3-2]*/
	     else go to fail;



/***********************************************:*****************************/
/*****		PLACE NEW CHECKS BEFORE THIS COMMENT		********/
/*****************************************************************************/

EQ:
     proc (tag1, tag2);

/*[4.4-5]*/
declare	(tag1, tag2)	fixed bin;

/*[5.1-1]*/
	if tag1 = 0
	then return;				/*[5.1-1]*/
	if tag2 = 0				/*[5.1-1]*/
	then do;
		tag2 = tag1;
		return;
	     end;					/*[5.1-1]*/
	else call out_equiv (tag1, tag2);

     end;

TEST:
     proc (tag, bool_fcn);

/*[4.4-5]*/
declare	tag		fixed bin,
	bool_fcn		bit (4);

/*[5.1-1]*/
	coperator.not = bool (coperator.not, lognot, bool_fcn);

/*[4.4-5]*/
	if tag = 0				/*[4.4-5]*/
	then tag, coperator.tag = assign_value ();	/*[4.4-5]*/
	else coperator.tag = tag;

	lognot = "0"b;
	unspec (opeos.i) = cop_c_bits;

	call emit_type_13 (coperator.op, coperator.tag);

	coperator_bits = "0"b;

     end;						/* the param is usually a tag name
				if param = 0 return to caller
				if not output a pseudo-procedure-definition
				with param as an operand
				move t zero to param return to caller */

DEF:
     proc (param);


dcl	param		fixed bin;

	if param = 0
	then return;

	dumprocname.type = 30;

	dumprocname.proc_num = param;
	seqvarptr = dpnptr;
	seqvarleng = dumprocname.size;

	call seqput;

	param = 0;

     end DEF;					/* the parameters are usually tag names or procedure names
				if paramerer 1 = 0 return to caller
				if paramerer w 2   0 move paramerer 1 to parameter 2
				and return to caller
				all othe cases output an equivalence operator with
				paramerer1 and parameter2 as opearands then return
				to caller */

out_equiv:
     proc (param1, param2);

dcl	param1		fixed bin;
dcl	param2		fixed bin;

/*[4.4-5]*/
	if param1 = param2
	then return;

	if param1 = 0 | param2 = 0
	then return;

	opeos.e = param1;
	opeos.h = param2;
	opeos.type = 31;
	seqvarptr = opeosptr;
	seqvarleng = opeos.size;

	call seqput;

	opeos.type = 19;				/* restore to eos type */

     end out_equiv;

/*output eos */

action (3):
	call seqputeos;
	go to ret;

/* after in use verb */
/* reel or unit in close verb  */
/* invalid present in delete statement */
/* repeated tallying phrase in INSPECT verb */

action (4):
	end_stmt.b = "1"b;
	go to ret;

/* for INVALID clear eos, move 3 to verb type in eos*/

action (5):
	end_stmt_bits = "0"b;
	end_stmt.verb = 3;
	go to ret;

action (6):					/*NOT USED*/
	go to ret;

/* filename is present in use verb and add 1 to filename counter */

action (7):
	end_stmt.d = "00"b;
	end_stmt.e = end_stmt.e + 1;
	go to ret;

/* count params after using */
/* count procedure names for go to depending */
/* count operands after to in move statement */
/* count TALLYINGS in inspect statement */
/* count operands of display statement  and set statement*?*/

action (8):
	end_stmt.e = end_stmt.e + 1;
	go to ret;

/* descending bit for sort */

action (9):
	end_stmt.b = "0"b;
	go to ret;				/* set leading bit in eos for examine verb */
						/* input is present in use verb */
						/* REMOVAL is present in CLOSE verb */
						/* RANDOM is present in SORT verb */

action (10):
	go to IOM (op_mode);

IOM (1):
	end_stmt.d = "00"b;
	go to ret;				/* input */

IOM (2):
	end_stmt.d = "01"b;
	go to ret;				/* output */

IOM (3):
	end_stmt.d = "10"b;
	go to ret;				/* i-o */

IOM (4):
	end_stmt.d = "11"b;
	go to ret;				/* extend */

action (11):
	current_line = current_line + op_mode + 1;

	go to new_inst;

action (12):
	current_line = current_line + file_org + 1;

	go to new_inst;

/* format 2 and no standard in use verb */

action (13):
	end_stmt.a = "001"b;
	end_stmt.c = "0"b;
	go to ret;

/* beginning in use verb */
/* LOCK is present in CLOSE verb */

action (14):
	end_stmt.f = "01"b;
	go to ret;				/* reel in use verb */

action (15):
	end_stmt.g = "01"b;
	go to ret;				/* file in use verb */
action (16):
	end_stmt.g = "10"b;
	go to ret;				/* unit in use verb */
action (17):
	end_stmt.g = "11"b;
	go to ret;				/* ending in use verb */

action (18):
	end_stmt.f = "10"b;
	go to ret;

/* format 4 in use verb */
/* BCD-1400 is present in SORT verb */

action (19):
	end_stmt.a = "011"b;
	go to ret;

/* standard in use verb */
/* repeated replacing phrase in INSPECT verb */

action (20):					/*  from is present in write verb */
	end_stmt.c = "1"b;
	go to ret;

/* using is present */
/* all iis present in search verb */
/* ASCII is present in SORT verb */

action (21):
	end_stmt.a = "001"b;
	go to ret;

/* for INSPECT  format 3   add rePLACINGS  */

action (22):
	end_stmt.a = "010"b;
	end_stmt.h = end_stmt.h + 1;
	if repcsbit
	then call DIAG (248);
	go to ret;

action (23):					/* enter */
	end_stmt.a = "000"b;
	end_stmt.e = 0;
	end_stmt.verb = 5;
	end_stmt.h = lang_num;
	go to action (3);

/* format 3 in use verb */
/* H-200 is present in SORT verb */

action (24):
	end_stmt.a = "010"b;
	go to ret;

/*  format 2 in use verb and standard present */

action (25):
	end_stmt.a = "001"b;
	end_stmt.c = "1"b;
	go to ret;

/* format 5 in use verb */
/* JIS in SORT verb */

action (26):
	end_stmt.a = "100"b;
	go to ret;

action (27):					/*[4.0-1]*/
	if reserved_word.key = 2
	then END_WORD = 1;				/* add */
						/*[4.0-1]*/
	else if reserved_word.key = 11
	then END_WORD = 17;				/* subtract */
						/*[4.0-1]*/
	else if reserved_word.key = 40
	then END_WORD = 3;				/* compute */
						/*[4.0-1]*/
	else if reserved_word.key = 10
	then END_WORD = 8;				/* multiply */
						/*[4.0-1]*/
	else if reserved_word.key = 9
	then END_WORD = 5;				/* divide */
	call NL;
	go to ret;

NL:
     proc;					/*[5.3-2]*/
	ST.option (nest_lev), ST.not_opt (nest_lev) = "0"b;
	call sav_lin_col;				/*[5.3-2]*/
	ST.end_wd (nest_lev) = END_WORD;

/*[4.0-1]*/
	call act87;
     end;

action (28):
	call act28;
	go to ret;

act28:
     proc;
	substr (addr (saveitem) -> itemsize, 1, header.size) = substr (head_ptr -> itemsize, 1, header.size);
     end;

/* save item and add 1 to operand count after giving in divide verb */

action (29):
	substr (addr (saveitem) -> itemsize, 1, header.size) = substr (head_ptr -> itemsize, 1, header.size);
	end_stmt.h = end_stmt.h + 1;
	go to ret;

/* set rounded bit in saved item */

action (30):
	savitmptr -> data_name.rounded = "1"b;
	go to ret;

/* output saved item save current item
			add 1 to operand count after giving for divide verb */

action (31):
	arg_1 = savitmptr;
	code_option = 31;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	substr (addr (saveitem) -> itemsize, 1, header.size) = substr (head_ptr -> itemsize, 1, header.size);
	go to ret;

/* output saved item in compute verb */

action (32):
	call act32;
	go to ret;

act32:
     proc;
	arg_1 = savitmptr;
	code_option = 32;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
     end;

/* compute the composite */

action (33):
	if header.type = 1				/* fig con */
	then ;
	else if header.type = 2			/* num lit */
	then do;

		if numeric_lit.places_left > end_stmt.i
		then end_stmt.i = numeric_lit.places_left;
		if numeric_lit.places_right > end_stmt.j
		then end_stmt.j = numeric_lit.places_right;

	     end;
	else do;

		if data_name.places_left > end_stmt.i
		then end_stmt.i = data_name.places_left;
		if data_name.places_right > end_stmt.j
		then end_stmt.j = data_name.places_right;
	     end;

	end_stmt.e = end_stmt.e + 1;

	go to ret;

/* compute the composite count arguments and save item */

action (34):
	end_stmt.h = end_stmt.h + 1;
	cssavebit = data_name.constant_section;

/*[4.1-7]*/
	prev_diag.line_num = header.line;		/*[4.1-7]*/
	prev_diag.column_num = header.column;

	call act28;
	go to ret;

/* set rounded bit in saved item for add verb */
action (35):
	savitmptr -> data_name.rounded = "1"b;
	go to ret;				/* add 1 to operand count
			output saved item
			save current item for add verb*/

action (36):
	arg_1 = savitmptr;
	code_option = 17;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	substr (sav_ptr -> itemsize, 1, header.size) = substr (addr_record -> itemsize, 1, header.size);
	go to ret;

/* program in exit verb  or on size error in compute verb output eos */
/* or at end in search verb */

action (37):
	call act37;
	go to ret;

act37:
     proc;
	end_stmt.b = "1"b;
	call seqputeos;
     end;

action (38):					/* type 8 to type 3 */
	if alphanum_lit.type = 8
	then do;
		alphanum_lit.type = 3;
		alphanum_lit.lit_type = "0"b;
		alphanum_lit.all_lit = "0"b;
	     end;
	else alphanum_lit.type = 8;

	go to ret;

/* output eos */

action (39):
	call seqputeos;
	go to ret;

action (40):					/* merge statement */
	call PERF (44);
	call act145;
	go to ret;

action (41):					/* sort statement */
	end_stmt.d = "01"b;
	file_count, key_count = 0;
	call act28;
	go to ret;

action (42):					/*[4.0-1]*/
	if reserved_word.key = 47
	then END_WORD = 7;				/*if */
						/*[4.0-1]*/
	else if reserved_word.key = 5
	then END_WORD = 2;				/* call */
						/*[4.0-1]*/
	else if reserved_word.key = 34
	then END_WORD = 16;				/* string */
						/*[4.0-1]*/
	else if reserved_word.key = 37
	then END_WORD = 18;				/* unstring */
						/*[4.0-1]*/
	else if reserved_word.key = 25
	then END_WORD = 12;				/* return */

/*[4.0-1]*/
	call NL;
	go to ret;

/* lock present in close verb and output eos */
action (43):
	end_stmt.f = "01"b;
	call seqputeos;
	go to ret;

action (44):					/*[4.0-1]*/
	if reserved_word.key = 21
	then END_WORD = 10;				/* read */
						/*[4.0-1]*/
	else if reserved_word.key = 38
	then END_WORD = 19;				/* write */
						/*[4.0-1]*/
	else if reserved_word.key = 27
	then END_WORD = 13;				/* rewrite */
						/*[4.0-1]*/
	else if reserved_word.key = 56
	then END_WORD = 15;				/* start */
						/*[4.0-1]*/
	else if reserved_word.key = 22
	then END_WORD = 4;				/* delete */

/*[4.0-1]*/
	call NL;
	go to ret;


/* count operands to be computed for compute verb */
/* save item add 1 to operand count in format 1 of multiply verb */


action (45):
	substr (sav_ptr -> itemsize, 1, header.size) = substr (addr_record -> itemsize, 1, header.size);
	end_stmt.e = end_stmt.e + 1;
	cssavebit = data_name.constant_section;

/*[4.1-7]*/
	prev_diag.line_num = header.line;		/*[4.1-7]*/
	prev_diag.column_num = header.column;
	go to ret;				/* output saved item
			save current item
			add 1 to operand count in format 1 of multiply verb */
action (46):
	arg_1 = savitmptr;
	code_option = 33;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;

	substr (sav_ptr -> itemsize, 1, header.size) = substr (addr_record -> itemsize, 1, header.size);
	go to ret;

/* count REPLACINGS for insPECT verb */
/* set format 2 */

action (47):
	end_stmt.a = "001"b;
	end_stmt.h = end_stmt.h + 1;
	if repcsbit
	then call DIAG (248);
	go to ret;

/* set a to format 4 or format 5 for divide verb
			and ioutput saved item */
action (48):
	arg_1 = savitmptr;
	code_option = 34;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* output a generated procedure name reference and then an eos */

action (49):
	call act49;
	go to ret;

act49:
     proc;
	arg_1 = dpnptr;
	code_option = 35;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
     end;

action (50):					/*[4.0-4]*/
	if reserved_word.key = 20			/* perform */
						/*[4.0-4]*/
	then do;
		END_WORD = 9;			/*[4.0-4]*/
		end_stmt.d, end_stmt.f = "00"b;	/*[4.0-4]*/
	     end;					/*[4.0-1]*/
	else if reserved_word.key = 26
	then END_WORD = 14;				/* search */
						/*[4.0-1]*/
	else if reserved_word.key = 23
	then END_WORD = 11;				/* receive */
						/*[4.0-1]*/
	else if reserved_word.key = 500
	then END_WORD = 6;				/* evaluate */

/*[4.0-1]*/
	call NL;
	go to ret;

save_skip_ind:
     proc;					/*[5.3-2]*/
	ST.save_skip_ind (nest_lev) = ST.skip_ind (nest_lev);
						/*[5.3-2]*/
	ST.skip_ind (nest_lev) = "1"b;
     end;

action (52):					/*[5.3-2]*/
	ST.skip_ind (nest_lev) = ST.save_skip_ind (nest_lev);
	go to ret;

action (53):					/*NOT USED*/
	go to ret;

/* puts missing period diagnostic on correct line */

action (54):					/*[4.1-7]*/
	call DIAG_PREV_TOKEN (7);
	go to ret;

action (55):
action (56):
action (57):
action (58):
action (59):
action (60):
action (61):					/*NOT USED*/
	go to ret;

/* set a to format 1 and output saved item */

action (62):
	arg_1 = savitmptr;
	code_option = 36;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* format 4 in perform verb */

action (63):
	end_stmt.a = "011"b;
	go to ret;

/* day in accept verb */

action (64):
	end_stmt.e = end_stmt.e + 1;
	go to ret;

action (65):					/*NOT USED*/
	go to ret;

/* output a generated then */

action (66):
	code_option = 15;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* esi in send verb */
action (67):
	end_stmt.d = "01"b;
	go to ret;				/* emi in send verb */
action (68):
	end_stmt.d = "10"b;
	go to ret;				/* eti in send verb */
action (69):
	end_stmt.d = "11"b;
	go to ret;

action (70):					/*NOT USED*/
	go to ret;

/*  format 2 and before in send verb */

action (71):
	end_stmt.a = "001"b;
	end_stmt.f = "01"b;
	go to ret;

/* format 2 and after in send verb */

action (72):
	end_stmt.a = "001"b;
	end_stmt.f = "10"b;
	go to ret;

/* set ascending ascending bit in item
			add 1 to data item count for sort verb */
/* compute offset from beginning of record and put it in operand */

action (74):
	key_count = key_count + 1;
	data_name.ad_bit = end_stmt.b;
	data_name.linkage_section = "1"b;		/* set for generator */
	data_name.compare_argument = "1"b;		/* set for generator */
	linkage = 1;				/* argument no set for generator */
	end_stmt.e = end_stmt.e + 1;			/* count operands */

	if data_name.seg_num = 0
	then go to ret;				/* locate mode all done */

	file_number = data_name.file_num;
	call cobol_read_ft_ (file_number, ft_ptr);

/* above gets pointer to filetable */
	data_name.offset = data_name.offset - cra_offset;
	go to ret;

/* format 2 and output saved item in subtract verb */

action (75):
	end_stmt.a = "001"b;
	call act32;
	go to ret;

action (76):
action (77):					/*NOT USED*/
	go to ret;

/* count REPLACINGS in INSPECT verb */
/* count of operands after into for unstring verb */
/* count of file names after USING in SORT verb */

action (78):
	end_stmt.h = end_stmt.h + 1;
	go to ret;

action (79):
action (80):
action (81):
action (82):
action (83):					/*NOT USED*/
	go to ret;

/* set diagno to 1 */
action (84):
	diagno = 1;
	go to ret;

action (85):					/*[5.3-2]*/
	ST.cond (nest_lev) = "1"b;
	go to ret;

/* reset and clear diagnostic switch */

action (86):
	diagno = 0;
	go to ret;				/* clear eos, moven token to eos */

action (87):
	call act87;
	go to ret;

act87:
     proc;
	end_stmt_bits = "0"b;
	end_stmt.verb = reserved_word.key;
     end;

/* program has declaratives section */
/* set switch to indicate we are processing inside declarative section */

action (88):
	decswitch = 1;
	go to ret;

/* program contains sections */

action (89):
	secswitch = 1;
	go to ret;

/* save eos for write and compute  and error verb */

action (90):
	saveos = end_stmt_chars;
	go to ret;

action (91):					/*[5.3-2]*/
	call inc_nest_lev;
	go to ret;

action (92):					/*NOT USED*/
	go to ret;

action (93):					/*[5.3-2]*/
	call dec_nest_lev;
	go to ret;

/* turn on debug switch because use for debugging is present */

action (94):
	debugsw = 1;
	go to ret;

/* set all bit in data name for use verb */

action (95):
	data_name.debug_all = "1"b;
	go to ret;

/* the end declaratives has been reached */

action (96):
	decswitch = 2;
	go to ret;

/*[4.4-5]*/
declare	first		bit (1);

action (97):					/*NOT USED*/
	go to ret;

pop_perf:
     proc;

/*[5.3-2]*/
	if ST.e (nest_lev) ^= 0
	then call emit_eos_perf;

     end;

pop_if:
     proc;

/*[5.3-2]*/
	if ST.option (nest_lev)			/*[5.3-2]*/
	then call DEF (ST.h (nest_lev));		/*[5.3-2]*/
	else if cssub ^= 0				/*[5.3-2]*/
	then call DEF (cstack.false (cssub));		/*[5.3-2]*/
	else ;

     end;

pop_other:
     proc;

/*[5.3-2]*/
	end_stmt.a = "0"b;

/*[5.3-2]*/
	if ST.option (nest_lev)
	then call emit_eos;

     end;

pop_state:
     proc;

/*[5.3-2]*/
	END_WORD = ST.end_wd (nest_lev);

/*[5.3-2]*/
	if END_WORD = 7				/*[5.3-2]*/
	then call pop_if;				/*[5.3-2]*/
	else if END_WORD = 9			/*[5.3-2]*/
	then call pop_perf;				/*[5.3-2]*/
	else call pop_other;

     end;

emit_eos:
     proc;

/*[4.0-4]*/
	end_stmt.verb = 3;				/*[4.0-4]*/
	end_stmt.b = "0"b;				/*[4.0-4]*/
	end_stmt.e, end_stmt.h, end_stmt.i = 0;		/*[4.0-4]*/
	call seqputeos;

     end;

/* for accept   set device to default or console and output eos */

action (98):
	end_stmt.e = 9;
	call seqputeos;
	go to ret;

/* device 2 or card-reader in accept verband output eos */

action (99):
	end_stmt.e = 10;
	call seqputeos;
	go to ret;

/* device 3 in accept verb and output eos */

action (100):
	end_stmt.e = 11;
	call seqputeos;
	go to ret;

/* time in accept verb */

action (101):
	end_stmt.e = 2;
	go to ret;				/* output saved item and output eos */

action (102):
	arg_1 = savitmptr;
	code_option = 37;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* size error follows --output saved item--output eos for add verb */

action (103):
	arg_1 = savitmptr;
	code_option = 38;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* output a generaTED ALTER FOR ALTER VERB  */

action (104):
	code_option = 5;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;				/* output a generated cancel and an eos for cancel verb */
action (105):
	code_option = 6;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/*set chain bit for close verb
			put out eos */
/* output a generated close for the close verb */

action (106):
	code_option = 8;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

action (107):					/*NOT USED*/
	go to ret;

/* restore eos for compute verb */

action (108):
	end_stmt_chars = saveos;
	go to ret;

/* device no 2 or printer for display verb and output eos*/

action (109):
	call act109;
	go to ret;

act109:
     proc;
	end_stmt.a = "001"b;
	call seqputeos;
     end;

action (110):					/*[5.3-2]*/
	ST.option (nest_lev) = "1"b;			/*[5.3-2]*/
	EW = ST.end_wd (nest_lev);

/*[5.3-2]*/
	if EW = 10				/* read */
						/*[5.3-2]*/
	then end_stmt.a = "010"b;			/*[5.3-2]*/
	else end_stmt.b = "1"b;

/*[5.3-2]*/
	call seqputeos;				/*[5.3-2]*/
	end_stmt_bits = "0"b;			/*[5.3-2]*/
	end_stmt.verb = 3;
	go to ret;

/* output a generated initiate for initiate verb */

action (111):					/*[4.4-5]*/
	call cobol_swf_put (cobol_pdofp, st, rw_perform_ptr, rw_perform_size);

	go to ret;

action (112):					/*[5.3-2]*/
	if reserved_word.type = 1			/*[5.3-2]*/
	then if reserved_word.key < 70		/*[5.3-2]*/
	     then current_line = reserved_word.key;	/*[5.3-2]*/
	     else current_line = 29;			/* evaluate */
						/*[5.3-2]*/
	else current_line = 57;			/* suppress */

	go to new_inst;

/* save item inside saveident */
/* save offset for occurs extension */
/* compute address of occurs extension */
/* clear the subscript type bits */

action (113):
	call act113;
	go to ret;

act113:
     proc;
	substr (addr (saveident) -> itemsize, 1, header.size) = substr (head_ptr -> itemsize, 1, header.size);
	savoccptr = data_name.occurs_ptr;
	occptr = addr (savidptr -> exten (savoccptr));
	data_name_bit, index_name_bit = "0"b;		/*[4.4-6]*/
	call set_op_loc;
     end;

/* set bit to indicate this literal is a subscript */

action (114):
	numeric_lit.subscript = "1"b;
	go to ret;

action (115):
action (116):
action (117):					/*NOT USED*/
	go to ret;


/* restore item from saveident to its window position */


action (118):
	substr (addr_record -> savidsize, 1, saveident.size) =
	     substr (addr (saveident) -> savidsize, 1, saveident.size);

/*[4.0-3]*/
	if err ^= 0
	then call diag (err);

	call test_subs;

	if res
	then call diag (269);

	go to ret;

test_subs:
     proc;

declare	(i, val)		fixed bin;

	occptr = addr (addr_record -> exten (data_name.occurs_ptr));

	do i = 1 by 1 to occurs.dimensions;

	     val = subs (i);

	     if val = 0 | /*[4.2-2]*/ (val > 0 & val > occurs.level.max (i))
	     then do;
		     res = "1"b;
		     return;
		end;
	end;

	res = "0"b;
     end;

/* output eos-- output a generated open-clear eos-set eos to type open for open verb */
/* set chain bit for OPEN verb */

action (119):
	call act119;
	go to ret;
act119:
     proc;
	go to OM (op_mode);
OM (1):
	code_option = 9;
	go to OM1;				/* input */

OM (2):
	code_option = 10;
	go to OM1;				/* output */

OM (3):
	code_option = 11;
	go to OM1;				/* io */

OM (4):
	code_option = 12;
	go to OM1;				/* extend */

OM1:
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;

     end;

action (120):
	end_stmt.d = "10"b;
	go to ret;

action (121):
	end_stmt.d = "01"b;
	go to ret;

action (122):
	end_stmt.d = "11"b;
	go to ret;

/* output eos -- output a generated suspend --clear eos */
/* set eos to suspend type for suspend verb */


action (123):
	code_option = 13;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* output a generate terminate for terminate veb */

action (124):					/*[4.4-5]*/
	call cobol_swf_put (cobol_pdofp, st, eos_perform_ptr, eos_perform_size);
	go to ret;

/* reset subscript counter to zero */

action (125):
	subcnt = 0;
	subs (1), subs (2), subs (3) = -1;
	go to ret;

/* add 1 to subscript counter */

action (126):
	subcnt = subcnt + 1;
	go to ret;

/* clear eos set eos to procedure */

action (127):
	end_stmt_bits = "0"b;

	end_stmt.verb = 52;
	go to ret;

/* clear eos set type to section header and build entry for perform alter range table for use */

action (128):					/*[4.4-2]*/
	if ^LTP
	then call DIAG_PREV_TOKEN (279);

	if decswitch ^= 0
	then do;
		perfcode = 0;
		perfprocnum = proc_def.proc_num;
		perfprio = fixed (unspec (proc_def.priority));
	     end;

	shprio = fixed (unspec (proc_def.priority));

	end_stmt_bits = "0"b;

	end_stmt.verb = 54;
	cursecnum = proc_def.section_num;		/* save the current section number */
	addr (stat.procdef) -> bit9 = addr (proc_def.sort_range) -> bit9;
	go to ret;

/* clear eos set type to paragraph header */

action (129):					/*[4.4-2]*/
	if ^LTP
	then call DIAG_PREV_TOKEN (279);

	end_stmt_bits = "0"b;

	end_stmt.verb = 55;
	go to ret;

/* reset subroutine stack pointer to zero and also nested if counter  */
/* reset imp switch to show we are no longer looking for an imperative verb */
/* reset conditional stack pointer to zero */
/* reset eos verb type to 0 */

action (130):
	nest_lev = 1;
	i1, cssub, end_stmt.verb = 0;			/*[5.3-2]*/
	call reset_st;

	go to ret;

/* set bit to indicate this data name is a subscript */

action (131):
	data_name.used_as_sub = "1"b;
	go to ret;

/* set bit to indicate this index is a subscript */

action (132):
	index_name.subscript = "1"b;
	go to ret;

/* clear eos set eos to declaratives */

action (133):
	end_stmt_bits = "0"b;			/*[5.2-1]*/
	end_decl_bit = "0"b;
	end_stmt.verb = 53;
	go to ret;

/* add 1 to nested if statement counter */

action (134):					/*NOT USED*/
	go to ret;

/* index name is predent as  a subscript */

action (135):
	index_name_bit = "1"b;
	go to ret;

/* data name is present as a subscript */

action (136):
	data_name_bit = "1"b;
	data_name.used_as_sub = "1"b;
	go to ret;

/* overlap between sending and receiving item */


action (137):
	data_name.overlap = "1"b;
	go to ret;

/* end of job when end cobol is encountered */

action (138):
endjob:
	go to endint;

/* set bit to show we are processing a search verb */

action (139):					/*[4.4-5]*/
	ST.option (nest_lev) = "1"b;
	go to ret;

/* output a then eos */

action (140):
	end_stmt.verb = 64;
	call seqputeos;
	go to ret;

/* output a search eos
			show we are no longer processing a search verb
			show we are not looking for a imperative verb */

action (141):
	srchfm2bit = "0"b;				/* no longer in format 2 */
	end_stmt.verb = 26;
	call seqputeos;
	go to ret;

/* set bit to indicate we are processing format 2 of the search verb */
action (142):
	srchfm2bit = "1"b;
	UB_ind = "0"b;				/*[3.0-9]*/
	go to ret;

/* build an entry for the perform alter range table */

action (143):
	perfcode = 0;				/* end of perform range */
	call act143;
	go to ret;

act143:
     proc;

	perfprocnum = proc_def.proc_num;
	perfprio = fixed (unspec (proc_def.priority), 16);
	call act145;
     end;

/* build an entry for the perform alter range table */

action (144):
	perfprocnum = savitmptr -> proc_def.proc_num;
	perfcode = 0;
	perfprio = fixed (unspec (savitmptr -> proc_def.priority), 16);
	call act145;
	go to ret;

/* write the perform entry and update the old entry **/

action (145):
	call act145;
	go to ret;

act145:
     proc;
	perform_range_key = perf_alter_info;

	do while (perform_range_key ^= "00000");
	     varrecaddr = perform_range_key;
	     call vardget;
	     jkpfm_ptr = seqvarptr;

	     if (perfprocnum = jkperfprocnum) & (perfcode = jkperfcode)
	     then go to ret;
	     if jkperflink = "00000"
	     then do;
		     call act145b;
		     return;
		end;
	     perform_range_key = jkperflink;
	end;
	call act145b;
     end;

act145b:
     proc;

	call cobol_vdwf_sput (cobol_cmfp, st, addr (perfrange), fb26, common_key);

	if substr (st, 17, 16) ^= "0"b
	then go to write_error;

	if perf_alter_info = "00000"
	then do;
		perf_alter_info = common_key;
		addr (saveperfrange) -> c26 = addr (perfrange) -> c26;
		savlaskey = common_key;
	     end;
	else do;
		sperlin = common_key;
		varrecaddr = savlaskey;
		call vardget;
		junk_ptr = seqvarptr;
		seqvarptr = addr (saveperfrange);
		seqvarleng = fb26;
		varrecaddr = savlaskey;
		call vardput;
		addr (saveperfrange) -> c26 = addr (perfrange) -> c26;
		savlaskey = common_key;
	     end;
     end;

/* set argument no for sort and merge verb  for generatotr */

action (146):
	linkage = 2;				/* argument no */
	go to ret;

/* build entry for perform alter table */

action (147):
	declprocbit = proc_def.declarative_proc;
	perfcode = 1;				/* alter procedure name */

	call act143;				/*  continue building */
	go to ret;

action (148):					/*  output a go
	output a proc name
	output a proc name  */
	gotodep = "0"b;				/*  clear the switch */

	arg_1 = addr (store_label_1);
	arg_2 = addr (store_label_2);

	code_option = 16;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/*  set all bit in literal */

action (149):
	alphanum_lit.all_lit = "1"b;
	go to ret;

/* set numeric condition bit in common area */

action (150):					/*[4.4-12]*/
	num_cond = "1"b;
	is_not_rel = "1"b;
	SUBJ_REQ = "1"b;				/*[5.3-1]*/
	if cssub > 0
	then cstack.c.logical (cssub - 1) = "1"b;
	go to ret;

/* set alphabetic bit in common area */

action (151):					/*[4.4-12]*/
	alpha_cond = "1"b;
	is_not_rel = "1"b;
	SUBJ_REQ = "1"b;				/*[5.3-1]*/
	if cssub > 0
	then cstack.c.logical (cssub - 1) = "1"b;
	go to ret;

/* set delete bit in file table */

action (152):
	delete = "1"b;
	go to ret;

/* if we are processing a format 1 use statement put the error rroutine address
	in the associated file table - table already in core from check (172) */

action (153):
	error_exit = cursecnum;
	seqvarptr = ft_ptr;
	seqvarleng = common_recsize;
	file_number = fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);
	ft_ptr = seqvarptr;
	go to ret;

/* reset a bit to indicate that the EXIT verb
	was not preceded by a procedure definition */


action (154):
	preospn_bit = "0"b;
	go to ret;

/* set a bit to indicate that the EXIT verb
	was preceeded by a procedure definition */

action (155):
	preospn_bit = "1"b;
	go to ret;

/* get collating sequence from common
	and put it into EOS for sort verb*/

action (156):
	end_stmt.i = prog_coll_seq;
	end_stmt.d = "00"b;
	go to ret;

/* save the FILE  after GIVING or USING in SORT statement */

action (157):
	substr (addr (sv_usfil) -> itemsize, 1, header.size) = substr (addr_record -> itemsize, 1, header.size);
	go to ret;

/* output a OPEN, FILENAM, EOS, PROCDEF, RETURN, FILENAM, */
/* RECORDNAM, EOS, GOTOPROC, EOSATEND, WRITE, RECORDNAM, EOS, */
/* GOTOPROC, PROCDEF, CLOSE, FILENAM, EOS, EOS90  */

action (158):
	spec_tag_counter = spec_tag_counter + 2;
	save_gentag = spec_tag_counter - 1;

	arg_1 = addr (sv_usfil);
	arg_2 = addr (spec_tag_counter);
	arg_3 = savitmptr;
	arg_4 = addr_record;

	code_option = 1;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* output a OPEN, FILENAM, EOS, PROCDEF, READ, FILENAM, */
/* EOS, GOTOPROC, EOSATEND, RELEASE, SORTREC, FILEREC, */
/* EOS, GOTOPROC, PROCDEF, CLOSE, FILENAM, EOS, */

action (159):
	spec_tag_counter = spec_tag_counter + 2;
	save_gentag = spec_tag_counter - 1;

	arg_1 = addr (sv_usfil);
	arg_2 = addr (spec_tag_counter);
	arg_3 = addr (sv_srtfil_rec);
	arg_4 = addr_record;

	code_option = 2;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* set e to proper INPUT DEVICE */

action (160):
	if mnemonic_name.iw_key = 3
	then end_stmt.e = 9;			/*[3.0-4]*/
	else end_stmt.e = 10;
	go to ret;

/* set DAYOFWEEK for ACCEPT */

action (161):
	end_stmt.e = 3;
	go to ret;

/* output an EOS91 for the SORT statement */

action (162):
	code_option = 18;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;


/* set a to proper OUTPUT DEVICRE */

action (163):
	if mnemonic_name.iw_key = 3
	then end_stmt.a = "000"b;			/*[3.0-4]*/
	else end_stmt.a = "001"b;
	go to ret;

/* do out_operator with param =1*/
/* output EOS3 ffor SEARCH */
/* declare all true and false labels */

action (164):
	call TEST (act_log.false, "1001"b);

	code_option = 19;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;

	UB_ind = "0"b;				/*[3.0-9]*/
	call act200;
	go to ret;

/* save procedure definition in SORT statement */

action (165):
	substr (addr (sv_proc_def) -> itemsize, 1, header.size) = substr (addr_record -> itemsize, 1, header.size);
	perfcode = 2;
	perfprocnum = proc_def.proc_num;
	perfprio = fixed (unspec (proc_def.priority), 16);
	go to ret;

/* output a PERFORM, sec-nm, sec-nm2, performeos, EOS91 */

action (166):
	call PERF (3);
	call act145;
	go to ret;

/* output a PERFORM, PROCNAMR, procname, PERFORMeos, EOS91 */

action (167):
	arg_1 = addr (sv_proc_def);

	code_option = 4;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	call act145;
	go to ret;

/* output a PERFORM, PROCNAM, PROCNAM, EOSperform, EOS90 */

action (168):
	call PERF (39);
	call act145;
	go to ret;

PERF:
     proc (val);

declare	val		fixed bin;

	arg_1 = addr (sv_proc_def);
	arg_2 = addr_record;

	code_option = val;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;

	perfprocnum = proc_def.proc_num;
	perfprio = fixed (unspec (proc_def.priority), 16);
	perfcode = 2;

     end;

/* output a PERFORM, PROCNAM, PROCNAM, PERFORMeos, EOS90 */

action (169):
	arg_1 = addr (sv_proc_def);
	code_option = 40;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	call act145;
	go to ret;

/* save the SORTFILE RECORD */

action (170):
	substr (addr (sv_srtfil_rec) -> itemsize, 1, header.size) = substr (addr_record -> itemsize, 1, header.size);
	go to ret;

/*output EOS4 for SEARCH */

action (171):
	code_option = 20;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	call setabit;
	code_option = 24;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;

/* output EOS4 for SEARCH verb */

action (172):
	code_option = 21;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* output EOS2 for SEARCH */

action (173):
	call setabit;
	code_option = 22;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* output final EOS2 for SEARCH */

action (174):
	call act174;
	go to ret;

act174:
     proc;
	if ^srchfm2bit
	then end_stmt.a = "000"b;
	code_option = 23;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	srchfm2bit = "0"b;
     end;

action (175):					/*NOT USED*/
	go to ret;

/* output EOS3 for SEARCH */

action (176):
	code_option = 25;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	call act174;
	go to ret;

/* output EOS3 for SEARCH */

action (177):
	code_option = 26;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* output final EOS2 for SEARCH */

action (178):
	call setabit;
	code_option = 27;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	srchfm2bit = "0"b;
	go to ret;

setabit:
     proc;

	if srchfm2bit
	then end_stmt.a = "001"b;
	else end_stmt.a = "000"b;

     end;

/* set HISTORY bits in file tables */

action (179):
	call act179;
	go to ret;

act179:
     proc;
	if fd_token.file_no = 0
	then return;
	file_number = fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);
	go to subact (histno);

subact (1):
	close = "1"b;
	return;

subact (2):
	open_ext = "1"b;
	return;

subact (3):
	open_in = "1"b;
	return;

subact (4):
	open_out = "1"b;
	return;

subact (5):
	open_io = "1"b;
     end;

/* set CLOSE history bit in file table */

action (180):
	histno = 1;
	call act179;
	go to ret;

/* set OPEN_EX history bit in file table */

action (181):
	histno = 2;
	call act179;
	go to ret;

/* set OPEN_IN history bit in file table */

action (182):
	histno = 3;
	call act179;
	go to ret;

/* set OPEN OUT history bit in file table */

action (183):
	histno = 4;
	call act179;
	go to ret;

/* set OPEN_IO history bit in file table */

action (184):
	histno = 5;
	call act179;
	go to ret;

action (185):
	file_count = 0;

	go to ret;

action (186):
	file_count = file_count + 1;
	go to ret;

action (187):
	arg_1 = addr_record;
	arg_2 = addr (sv_usfil);
	code_option = 42;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

action (188):
	file_count, key_count = 0;
	call act28;
	go to ret;

action (189):
	arg_1 = addr (key_count);
	arg_2 = addr (file_count);
	code_option = 41;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

action (190):
	arg_1 = addr (sv_proc_def);

	code_option = 43;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	call act145;
	go to ret;

action (191):
	substr (end_stmt.f, 1, 1) = stat.procdef.mrg_range;
	substr (end_stmt.f, 2, 1) = stat.procdef.srt_range;
	call act28;
	go to ret;

action (192):
	UB_ind = "1"b;
	go to ret;

action (193):
	UB_ind = "1"b;
	call seqputeos;
	go to ret;

action (194):
	UB_ind = "1"b;
	call act37;
	go to ret;

action (195):
	UB_ind = "0"b;
	go to ret;

action (196):
action (197):
action (198):
action (199):					/*NOT USED*/
	go to ret;

/* do an out_operator with parameter = 1
	set dumprocname.searched and true bit for PERFORM verb
	do an DEFlaration with parameter = to true of active
	clear the bits
	put active on stack*/
/* declare all true and false labels for the PERFORM verb */


action (200):
	call TEST (act_log.false, "1001"b);
	call act200;
	go to ret;

act200:
     proc;
	dumprocname.searched = "1"b;
	dumprocname.duplicate = "1"b;
	if act_log.true ^= 0
	then call DEF (act_log.true);
	dumprocname.duplicate = "0"b;
	if act_log.false ^= 0
	then call DEF (act_log.false);
	dumprocname.searched = "0"b;
     end;

/* put unary - on arithmetic stack */

action (201):
	assub = assub + 1;
	SAE = "0"b;				/*[3.0-10]*/
						/* AS(assub) = 0 */

	astack_ptr = addr (astack (assub));
	astack_bits = "0"b;

	astack.unmin (assub) = "1"b;
	astack.key (assub) = 187;
	go to ret;

/* put left parenthesis on arithmetic stack */

action (202):					/*[4.2-3]*/
	if reserved_word.column ^= 0
	then do;
		expind = "1"b;			/*[4.4-1]*/
		arith_op = "1"b;
		SAE = "0"b;
	     end;

	assub = assub + 1;				/* AS(assub) = 0 */

	astack_ptr = addr (astack (assub));
	astack_bits = "0"b;

	astack.lefpar (assub) = "1"b;
	go to ret;

/* if the priority of the operator being processed
			id greater than hthe priority of operator
			on arithmetic stack put operator being
			processed on stack otherwise output one
			stack item and go back to beginning. */

action (203):
	expind = "1"b;
	SAE = "0"b;				/*[3.0-10]*/
						/*[4.4-1]*/
	arith_op = "1"b;

	do while ("1"b);

	     if (reserved_word.key = 185) | (reserved_word.key = 183)
	     then tempkey = reserved_word.key - 1;
	     else tempkey = reserved_word.key;

	     if tempkey > astack.key (assub)
	     then do;
		     assub = assub + 1;		/*AS(assub) = 0 */

		     astack_ptr = addr (astack (assub));
		     astack_bits = "0"b;

		     astack.key (assub) = reserved_word.key;
		     go to ret;
		end;
	     else do;
		     opeos.verb = 28;		/* arithmetic operatotr */
		     opeos.e = astack.key (assub);	/* actual operation */
		     seqvarptr = opeosptr;
		     seqvarleng = opeos.size;
		     call seqput;
		     assub = assub - 1;
		end;
	end;

/* output the arithmetic stack elements
			al long as they belong to class 1 */

action (204):
	do while ("1"b);

	     if assub = 0
	     then go to ret;

	     if astack.key (assub) = 0
	     then go to ret;

	     opeos.verb = 28;			/* arithmetic operation */
	     opeos.e = astack.key (assub);		/* specific operation */
	     seqvarptr = opeosptr;
	     seqvarleng = opeos.size;
	     call seqput;
	     assub = assub - 1;
	end;

/* pop the arithmetic stack */

action (205):					/*[4.2-6]*/
	if reserved_word.column ^= 0
	then expind = "1"b;
	assub = assub - 1;				/*[4.4-1]*/
	arith_op = "1"b;
	go to ret;

/* pop the logical stack and set lognot
			equal to not field from item that was judt
			popped */

action (206):					/*[4.2-6]*/
	if reserved_word.column ^= 0
	then expind = "1"b;
	lognot = cstack.not (cssub);
	cssub = cssub - 1;				/*[4.4-1]*/
	arith_op = "1"b;				/*[4.4-12]*/
	SUBJ_REQ = cstack.subj_req (cssub);
	go to ret;

/* put zero on arithmetic stack */

action (207):
	expind = "0"b;
	assub = 1;
	SAE = "1"b;				/*[3.0-10]*/
						/*[4.4-1]*/
	arith_op = "0"b;

/*[4.0-1]*/
	ae.line = header.line;			/*[4.0-1]*/
	ae.column = header.column;			/* AS(assub) = 0 */

	astack_ptr = addr (astack (assub));
	astack_bits = "0"b;

	op.op_lit = "1"b;
	go to ret;

action (208):					/*[4.4-1]*/
	arith_op = "1"b;
	go to ret;

action (209):					/*[4.4-1]*/
	arith_op = "0"b;
	go to ret;

action (210):					/*[4.4-12]*/
	SUBJ_REQ = "0"b;				/*[4.4-1]*/
	if arith_op				/*[4.4-1]*/
	then do;
		call ae_diag (13);			/* ae in rel cond */
						/*[4.4-1]*/
		arith_op = "0"b;			/*[4.4-1]*/
	     end;
	go to ret;

ae_diag:
     proc (dn);

/*[4.4-1]*/
declare	dn		fixed bin;

/*[4.4-1]*/
	if fixed_common.comp_level < "3"		/*[4.4-1]*/
	then if arith_op				/*[4.4-1]*/
	     then call LEV_DIAG (dn, ae.line, ae.column);

     end;

/* put the item on conditional stack */

action (211):					/*[4.4-6]*/
	call act211;				/*[4.4-6]*/
	op.loc = mptr;
	go to ret;

act211:
     proc;
	cssub = cssub + 1;
	cstack_ptr = addr (cstack (cssub));
	cstack_bits = "0"b;
	cstack.true (cssub) = header.type;
	cstack.operand (cssub) = "1"b;

	call TOK_TYPE;				/*[3.0-10]*/
     end;

TOK_TYPE:
     proc;					/*[3.0-10]*/



/*[4.4-6]*/
	string (op.descr) = "0"b;


/*[4.0-6]*/
	op.line = header.line;
	op.col = header.column;

	if reserved_word.type > 10
	then return;				/*[3.0-10]*/

	go to CS (reserved_word.type);		/*[3.0-10]*/

CS (1):						/* reserved word */
	op.op_lit = "1"b;

	if reserved_word.key = 180			/* zero */
	then do;
		op.numeric = "1"b;			/*[3.0-10]*/
		op.integer = "1"b;			/*[3.0-10]*/
	     end;					/*[3.0-10]*/
	else op.non_numeric = "1"b;			/*[3.0-10]*/

	return;

CS (2):						/* numeric literal */
	op.op_lit = "1"b;
	op.numeric = "1"b;				/*[3.0-10]*/
	if numeric_lit.places_right = 0
	then op.integer = "1"b;			/*[3.0-10]*/

	op.length = op.length + numeric_lit.places_right + numeric_lit.places_left;
						/*[3.0-10]*/

/*[4.0-1]*/
	op.length = 0;

	return;					/*[3.0-10]*/

CS (3):						/* alphanumeric literal */
	op.op_lit = "1"b;
	op.non_numeric = "1"b;			/*[3.0-10]*/

	op.length = alphanum_lit.lit_size;		/*[3.0-10]*/

	return;					/*[3.0-10]*/

CS (9):						/* data name */
	op.op_lit = "0"b;
	if data_name.usage_index			/*[3.0-10]*/
	then op.index = "1"b;			/*[3.0-10]*/
	else /*[3.0-10]*/
	     if data_name.non_elementary		/*[3.0-10]*/
	then op.non_numeric = "1"b;			/*[3.0-10]*/
	else if data_name.numeric | data_name.numeric_edited
						/*[3.0-10]*/
	then do;
		op.numeric = "1"b;			/*[3.0-10]*/
		if data_name.places_right = 0		/*[3.0-10]*/
		then op.integer = "1"b;		/*[3.0-10]*/
	     end;					/*[3.0-10]*/
	else op.non_numeric = "1"b;			/*[3.0-10]*/


	if fixed_common.comp_level < "5"
	then do;
		call field_length;			/*[3.0-1]*/
		op.length = L;
	     end;

	return;					/*[3.0-10]*/

CS (10):						/*[3.0-10]*/
	op.index = "1"b;				/*[3.0-10]*/


CS (4):
CS (5):
CS (6):
CS (7):
CS (8):
     end;

field_length:
     proc;

	L = 0;

	if data_name.non_elementary
	then L = data_name.item_length;
	else if data_name.numeric | data_name.numeric_edited
	then do;
		if data_name.item_signed
		then L = 1;

		L = L + data_name.places_left + data_name.places_right;
	     end;
	else if data_name.alphabetic | data_name.alphanum_edited | data_name.alphanum
	then L = data_name.item_length;

     end;

/* put the arithmetic expression symbol on stack */

action (212):
	cssub = cssub + 1;				/* CS(cssub) = 0 */

	cstack_ptr = addr (cstack (cssub));
	cstack_bits = "0"b;

/*[5.3-1]*/
	if SAE
	then go to ret;

/*[3.0-10]*/
	op_bits = "0"b;				/*[3.0-10]*/
	op.numeric = "1"b;
	op.loc = null ();

	go to ret;

/* pop the stack */

action (213):
	cssub = cssub - 1;
	go to ret;

action (214):
	if fixed_common.comp_level < "3"
	then do;
		if (header.type = 3 & alphanum_lit.lit_size ^= 1) | (header.type = 9 & data_name.item_length ^= 1)
		then call lev_diag (124);

	     end;

	go to ret;

action (215):					/*[5.2-1]*/
	call cobol_swf_put (cobol_pdofp, st, rw_move_ptr, rw_move_size);
						/*[5.2-1]*/
	call cobol_swf_put (cobol_pdofp, st, supp_lit_ptr, supp_lit_size);
						/*[5.2-1]*/
	call cobol_swf_put (cobol_pdofp, st, ss_tok_ptr, ss_tok_size);
						/*[5.2-1]*/
	call cobol_swf_put (cobol_pdofp, st, eos_move_ptr, eos_move_size);

	go to ret;

/*[5.2-1]*/
dcl	ss_tok_ptr	ptr,
	ss_tok_size	fixed bin;

action (216):					/*[5.2-1]*/
	ss_tok_ptr = mptr;				/*[5.2-1]*/
	ss_tok_size = data_name.size;			/*[5.2-1]*/
	data_name.type = 9;

	go to ret;

action (217):
action (218):					/*NOT USED*/
	go to ret;

/*  unknown at this time */

action (219):					/* SUB = 0 */
	subject_bits = "0"b;
	subject.true = 17;
	cstack.logical (cssub) = "1"b;
	coperator.comp = "0"b;
	coperator.op = 17;
	cssub = cssub + 1;				/*[4.4-12]*/
	SUBJ_REQ = "1"b;				/* CS(cssub) = 0 */
	cstack_ptr = addr (cstack (cssub));
	cstack_bits = "0"b;				/*[4.4-3]*/
	is_not_rel = "1"b;

	cstack.true (cssub) = 17;
	cstack.operand (cssub) = "1"b;
	soperator.op = coperator.op;
	soperator.not = coperator.not;

	go to ret;				/* initialize all conditions
			put an initialized item on condition stack
			clear log not switch
			clear the condition operator clear subject */

action (220):
	lev_save = cssub;
	cssub = cssub + 1;
	SUBJ_REQ = "1"b;				/* CS(cssub) = 0 */

	cstack_ptr = addr (cstack (cssub));
	cstack_bits, lognot, coperator_bits, subject_bits = "0"b;
						/*[5.3-2]*/
	iscond = "0"b;

	go to ret;				/* put on stack the following item
			(  logical  not  true  false
			within this item set not = log_not
			set logical true false = 0
			set log_not = 0 */

action (221):					/*[4.4-12]*/
	cstack.subj_req (cssub) = SUBJ_REQ;
	cssub = cssub + 1;
	SUBJ_REQ = "1"b;

	cstack_ptr = addr (cstack (cssub));
	cstack_bits = "0"b;

	cstack.leftpar (cssub) = "1"b;
	cstack.not (cssub) = lognot;
	cstack.parity (cssub) = bool (cstack.parity (cssub - 1), lognot, "0110"b);

	lognot = "0"b;
	go to ret;

/* set log_not = to 1 */

action (222):
	lognot = "1"b;
	go to ret;

/* set not field in operation = to 1 */

action (223):
	coperator.not = "1"b;
	go to ret;

/* move operation type from item in window to condition operator */

action (224):
	coperator.op = reserved_word.key;
	go to ret;

/* pop stack to subject
			set bit logical on cstack to 1
			set bit compare on type inside coperator to 0 normal compare
			move operation type from window to cop*/

action (225):					/* SUB = CS(cssub) */
	cstack_ptr = addr (cstack (cssub));
	subject_bits = cstack_bits;			/*[4.4-3]*/
	is_not_rel = "0"b;

	cssub = cssub - 1;
	cstack.logical (cssub) = "1"b;
	coperator.comp = "0"b;

	go to ret;

/* set bit compare type to 1 ( abbreviated relation ) */

action (226):
	coperator.comp = "1"b;

/*[4.4-3]*/
	if is_not_rel				/*[4.4-3]*/
	then call diag (274);			/*[4.4-3]*/
	else /*[4.2-6]*/
	     if fixed_common.comp_level <= "2"
	then call lev_diag (18);			/* abbrev rel cond */
	go to ret;

/* clear the subject */

action (227):					/* SUB = 0 */
	subject_bits = "0"b;

	go to ret;

/* move stored_operation to cop fields
			and set bit compare type to 1 for abbreviation */

action (228):
	coperator.op = soperator.op;
	coperator.not = soperator.not;
	coperator.comp = "1"b;

/*[4.2-6]*/
	if fixed_common.comp_level <= "2"
	then call LEV_DIAG (18, oploc.line, oploc.col);	/* abbrev rel cond */
	go to ret;

/* move cop and coperator.not fields from coperation to soperation */

action (229):
	if fixed_common.comp_level < "3"		/*[4.2-4]*/
	then do;
		if op.non_numeric | left.non_numeric	/*[4.2-4]*/
		then /*[4.2-4]*/
		     if op.length ^= 0 & left.length ^= 0 /*[4.2-4]*/ & /*[4.2-4]*/ op.length ^= left.length
						/*[4.0-6]*/
		     then call LEV_DIAG (11, left.line, left.col);
						/* unequal size operands */
	     end;

	if fixed_common.comp_level < "5"
	then call type_comp;			/*[3.0-10]*/

/*[4.4-1]*/
	if arith_op				/*[4.4-1]*/
	then do;
		call ae_diag (13);			/* ae in rel cond */
						/*[4.4-1]*/
		arith_op = "0"b;			/*[4.4-1]*/
	     end;

	soperator.op = coperator.op;
	soperator.not = coperator.not;
	go to ret;

/*[3.0-10]*/
type_comp:
     proc;

/*[]*/
	if left.index				/*[]*/
	then if op.index				/*[]*/
	     then return;				/*[]*/
	     else if op.numeric			/*[]*/
	     then if op.integer			/*[]*/
		then return;			/*[]*/
		else call lev_diag (171);		/*[]*/
	     else call lev_diag (170);		/*[]*/
	else /*[]*/
	     if op.index				/*[]*/
	then if left.numeric			/*[]*/
	     then if left.integer			/*[]*/
		then return;			/*[]*/
		else call lev_diag (171);		/*[]*/
	     else call lev_diag (170);		/*[]*/
	else /*[]*/
	     if left.numeric			/*[]*/
	then if op.numeric				/*[]*/
	     then return;				/*[]*/
	     else if left.integer			/*[]*/
	     then return;				/*[]*/
	     else call lev_diag (171);		/*[]*/
	else /*[]*/
	     if op.numeric				/*[]*/
	then if op.integer				/*[]*/
	     then return;				/*[]*/
	     else call lev_diag (171);		/*[]*/
						/*[]*/
	return;

     end;

/*[3.0-10]*/
/* pop condition stack by one
			move stack ite m to active logical */
action (230):					/*[4.0-6]*/
	if lognot					/*[4.0-6]*/
	then if fixed_common.comp_level <= "2"		/*[4.0-6]*/
	     then call LEV_DIAG (16, not.line, not.col);	/*negated simple condition */

	cssub = cssub - 1;

/* AL = CS(cssub) */

	cstack_ptr = addr (cstack (cssub));
	act_log_bits = cstack_bits;

	cssub = cssub - 1;
	go to ret;

/* if not field in active logical = 1 ,
			exchange true and false tag fields,
			and reverse the log_not switch*/
/* then set not in active logical to    */

action (231):
	if act_log.not
	then do;					/* act_log.true == act_log.false */
		holdatrue = act_log.true;
		act_log.true = act_log.false;
		act_log.false = holdatrue;
		lognot = ^lognot;
		act_log.not = "0"b;
	     end;
	go to ret;

/* pop stack to work.
			if bit not in work  = 1
			then exchange true and false in work .
			output equivalince ( true of work, tuue of active).
			output equivalince (false of work, false of active ) */

action (232):					/* WK = CS(cssub) */
	cstack_ptr = addr (cstack (cssub));
	work_bits = cstack_bits;

	cssub = cssub - 1;

/*[5.1-1]*/
	call EQ (work.true, act_log.true);

/*[5.1-1]*/
	call EQ (work.false, act_log.false);

/*[5.1-1]*/
	if work.not				/* work.true == work.false */
						/*[5.1-1]*/
	then do;
		holdatrue = act_log.true;		/*[5.1-1]*/
		act_log.true = act_log.false;		/*[5.1-1]*/
		act_log.false = holdatrue;		/*[5.1-1]*/
		lognot = ^lognot;			/*[5.1-1]*/
	     end;

	go to ret;

/* do an out_operator with param = 1
			put active logical on stack */

action (233):					/*[4.2-6]*/
	andor.line = reserved_word.line;
	andor.col = reserved_word.column;		/* save loc of ANDOR */

	call TEST (act_log.false, "1001"b);
	cssub = cssub + 1;				/* CS(cssub) = AL */

	cstack_ptr = addr (cstack (cssub));
	cstack_bits = act_log_bits;

	go to ret;				/* do an out_operator with parameter = 0 .
			do an out_odeclatation with paramerer = false of active.
			put active logical on stack */
action (234):					/*[4.2-6]*/
	andor.line = reserved_word.line;
	andor.col = reserved_word.column;		/* save loc of ANDOR */

	call TEST (act_log.true, "0110"b);
	if act_log.false ^= 0
	then call DEF (act_log.false);
	cssub = cssub + 1;				/* CS(cssub) = AL */

	cstack_ptr = addr (cstack (cssub));
	cstack_bits = act_log_bits;

	go to ret;

/* do an out_operator with parameter = 1.
			do an out_equivalence with parameter = false of active and false of stack.
			do an out declatation with paramiter =
			true of acteve */

action (235):					/*[4.2-6]*/
	andor.line = reserved_word.line;
	andor.col = reserved_word.column;		/* save loc of ANDOR */

	call TEST (act_log.false, "1001"b);

/*[4.4-5]*/
	call EQ (act_log.false, cstack.false (cssub));




	if act_log.true ^= 0
	then call DEF (act_log.true);
	go to ret;

/* exchange active with top of stack. */

action (236):					/* AL == CS(cssub) */
	cstack_ptr = addr (cstack (cssub));
	work_bits = act_log_bits;
	act_log_bits = cstack_bits;
	cstack_bits = work_bits;

	go to ret;				/* do an out operator with parameter = 1 */
						/* do an out declaration with parameter = true of active
			put active on stack*/
action (237):
	call TEST (act_log.false, "1001"b);

	if act_log.true ^= 0
	then call DEF (act_log.true);
	cssub = cssub + 1;				/* CS(cssub) = AL */
	cstack_ptr = addr (cstack (cssub));
	cstack_bits = act_log_bits;
	go to ret;

dcl	EOF		fixed bin;

action (238):					/*[4.4-5]*/
	call emit_type_13 (63, EOF);

/*[4.4-5]*/
	call def_false;



	go to ret;				/* pop stack to active */
action (239):					/* AL = CS(cssub) */
						/*[5.3-2]*/
	ST.option (nest_lev) = "1"b;			/*[5.3-2]*/
	if EOF ^= 0
	then call out_equiv (EOF, ST.h (nest_lev));	/*[5.3-2]*/
	EOF = ST.h (nest_lev);
	cstack_ptr = addr (cstack (cssub));
	act_log_bits = cstack_bits;
	cssub = cssub - 1;
	UB_ind = "0"b;
	go to ret;

/* do an out declaration with param = false of active
			put active logical on stack and sub 1 from nested if statenent counter  */

action (240):					/*[4.4-5]*/
	call def_false;



	go to ret;

/* move window item to store _label_1. */

action (241):
	substr (addr (store_label_1) -> itemsize, 1, header.size) = substr (head_ptr -> itemsize, 1, header.size);
	go to ret;

/* move window item to store_label_2.
			move special operator go depending to window.      not done noow
			note the go depending is recognized
			by verv subroutine and appropriate
			processing takes paace to deal
			with stored label_1 and label_2 . *?*/

action (242):
	substr (addr (store_label_2) -> itemsize, 1, header.size) = substr (head_ptr -> itemsize, 1, header.size);
	header.type = 1;
	reserved_word.verb = "1"b;
	reserved_word.imper_verb = "1"b;
	reserved_word.key = 14;
	gotodep = "1"b;
	go to ret;				/* do an out_operator with parameter = 0.
	do an out_equivalence with paaramiter  =
	true of active and stored_lavel_1.
	move zero to true of active . */

action (243):
	call TEST (act_log.true, "0110"b);

/*[4.4-5]*/
	call EQ (act_log.true, store_label_1.proc_num);




	act_log.true = 0;
	go to ret;				/* do an out operator with param = 0 */
action (244):
	call TEST (act_log.true, "0110"b);

	ST.h (nest_lev) = 0;

	call EQ (act_log.true, next_sent_label);




	act_log.true = 0;
	go to ret;

/* pop stack to logical active
			do an out declaration with param = false of active
			do an out declaration with param = true of active 
			and reset nested if statement counter*/

action (245):					/*NOT USED */
						/*[4.4-5]*/
	call act245;
	go to ret;

act245:
     proc;



/* AL = CS(cssub) */
	cstack_ptr = addr (cstack (cssub));
	act_log_bits = cstack_bits;

	cssub = cssub - 1;


	if act_log.false ^= 0
	then call DEF (act_log.false);
	if act_log.true ^= 0
	then call DEF (act_log.true);



     end;						/* output an unconditional branch to use(true of stack) */
action (246):
	if cssub = 0
	then go to ret;

	TAG = cstack.true (cssub);

	if TAG = 0
	then cstack.true (cssub), opeos.h = assign_value ();


	else opeos.h = TAG;

	opeos.verb = 13;
	opeos.e = 63;
	seqvarptr = opeosptr;
	seqvarleng = opeos.size;
	call seqput;
	go to ret;

/* declare all true and false labels for the PERFORM verb*/

action (247):
	dumprocname.searched = "1"b;
	dumprocname.duplicate = "1"b;

	if next_sent_label ^= 0
	then call DEF (next_sent_label);

	if cssub ^= 0
	then do;					/* AL = CS(cssub) */

		cstack_ptr = addr (cstack (cssub));
		act_log_bits = cstack_bits;

		cssub = cssub - 1;
		if act_log.true ^= 0
		then call DEF (act_log.true);
		dumprocname.duplicate = "0"b;
		if act_log.false ^= 0
		then call DEF (act_log.false);

	     end;

	dumprocname.searched = "0"b;

	go to ret;

action (248):					/* default device for accept */
	code_option = 29;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

action (249):					/* default device for display */
	code_option = 30;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* compiler error */
action (250):
	return;

action (251):
	if fatal_no ^= 0
	then go to endint;
	else go to ret;

/* save smallest range -- used for set verb */
action (252):
	if savitmptr -> index_name.max ^> index_name.max
	then go to ret;
	call act28;
	go to ret;				/* set input_error_exit for use procedure */

action (253):
	input_error_exit = cursecnum;
	go to ret;

/* set output_error_exit for use procedure */

action (254):
	output_error_exit = cursecnum;
	go to ret;

/* set i_o_error_exit for use procedure */

action (255):
	i_o_error_exit = cursecnum;
	go to ret;

/* set extend_error_exit for use procedure */

action (256):
	extend_error_exit = cursecnum;
	go to ret;

/* set read bit in file_table - in core from check (89) */

action (257):
	file_table.read = "1"b;
	go to ret;

/* set read_next bit in file_table - in core from check (23) */

action (258):					/*[5.3-2]*/
	iscond = "1"b;
	go to ret;

/* set read_key bit in file_table - in core from check (20) */

action (259):
	file_table.read_key = "1"b;
	go to ret;

/* set rewrite bit in file_table - in core from check (70) */

action (260):
	file_table.rewrite = "1"b;
	call act28;
	go to ret;				/* set write bit in file_table - in core from check (70) */

action (261):
	file_table.write = "1"b;
	call act28;
	go to ret;				/* set start bit in file_table - in core from check (155) */

action (262):
	file_table.start = "1"b;
	go to ret;

/* set open_in bit in file_table - not in core */

action (263):
	if fd_token.file_no = 0
	then go to ret;

	call cobol_read_ft_ (fd_token.file_no, ft_ptr);

	go to SM (op_mode);

SM (1):
	open_in = "1"b;
	go to SM1;				/* input */

SM (2):
	open_out = "1"b;
	go to SM1;				/* output */

SM (3):
	open_io = "1"b;
	go to SM1;				/* io */

SM (4):
	open_ext = "1"b;
	go to SM1;				/* extend */

SM1:
	go to action (28);

action (264):
	left_bits = op_bits;

	go to ret;

action (265):					/*[4.4-6]*/
	call set_op_loc;

	go to ret;

action (266):					/*[5.3-2]*/
	ST.cond (nest_lev) = "0"b;			/*[5.3-2]*/
	if ST.end_wd (nest_lev) = 14
	then if ST.ns (nest_lev)
	     then call diag (316);
	     else ;
	else call pop_state;

	go to ret;				/* set rounded bit in saved item --- output saved item */
action (267):
	savitmptr -> data_name.rounded = "1"b;
	seqvarptr = savitmptr;
	seqvarleng = saveitem.size;
	call seqput;
	go to ret;				/* output saved item */

action (268):
	seqvarptr = savitmptr;
	seqvarleng = saveitem.size;
	call seqput;
	go to ret;				/* add 1 to operand count
			save current item for add verb*/
action (269):
	end_stmt.h = end_stmt.h + 1;
	substr (sav_ptr -> itemsize, 1, header.size) = substr (addr_record -> itemsize, 1, header.size);
	go to ret;

action (270):					/*[5.3-2]*/
	ST.option (nest_lev) = "1"b;			/*[5.3-2]*/
	end_stmt.b = "1"b;				/*[5.3-2]*/
	call seqputeos;				/*[5.3-2]*/
	if ST.end_wd (nest_lev) = 2
	then call save_skip_ind;			/* CALL */


	go to ret;

/* add 1 to operand count in format 1 of multiply verb
	save current item */

action (271):
	end_stmt.e = end_stmt.e + 1;
	substr (sav_ptr -> itemsize, 1, header.size) = substr (addr_record -> itemsize, 1, header.size);
	cssavebit = data_name.constant_section;
	go to ret;

action (272):
	if decswitch = 1 & ^proc_def.declarative_proc
	then call diag (263);
	go to ret;

end_sent:
     proc;

/*[5.1-2]*/
	LTP, last_wd_per = "1"b;

/*[4.4-8]*/
	sav_bit = "0"b;

/*[4.4-5]*/
	if next_sent_label ^= 0
	then call DEF (next_sent_label);

/*[4.4-5]*/
	do while (cssub > 0);
	     call act245;
	end;

     end;

action (273):					/*[4.4-1]*/
	call end_sent;
	go to ret;

action (274):					/*[4.4-1]*/
	call end_sent;
	call seqputeos;
	go to ret;

action (275):
	call act275;
	go to ret;
act275:
     proc;

/*[5.3-2]*/
	nest_lev = 1;
	call reset_st;
	call act49;
     end;

action (276):
	coperator.not = "0"b;
	go to ret;

action (277):
	end_stmt.d = "01"b;
	go to ret;

action (278):					/*[4.1-7]*/
	call DIAG (248);				/* Item declared in CONSTANT section */
	go to ret;

action (279):					/*[4.4-6]*/
	sub_loc = 0;
	call set_op_loc;
	call act113;
	go to ret;

action (280):
	sub_loc = sub_loc + 1;

	subs (sub_loc) = fixed (numeric_lit.literal);
	numeric_lit.subscript = "1"b;
	go to ret;

action (281):
	key = fixed (numeric_lit.literal);

	if key < min_index | key > max_index
	then call diag (270);			/* DIAG(270) */

	go to ret;

action (282):
	min_index = 0;
	max_index = 99999;

	addr (set_sop) -> set_sop_mask = "0"b;

	go to ret;

action (283):					/*[5.3-2]*/
	if ST.nif (nest_lev) > 1			/*[5.3-2]*/
	then if fixed_common.comp_level < "3"		/*[5.3-2]*/
	     then call lev_diag (12);





	go to action (42);

action (284):
	SAE = "0"b;

	go to ret;

action (285):					/*[3.0-10]*/
	call set_op_loc;				/*[4.4-6]*/

	go to ret;				/*[3.0-10]*/

action (286):					/*[3.0-12] issue leveling diag 169 */
	if fixed_common.comp_level < "5"
	then call lev_diag (169);

	call end_sent;
	call seqputeos;
	go to ret;
action (287):					/*[3.0-13]  issue leveling diag 172 */
	if data_name.level ^= 1
	then if data_name.level ^= 77			/*[4.4-10]*/
	     then do;
		     if fixed_common.comp_level < "5"
		     then call lev_diag (172);

/*[4.4-10]*/
		     if mod (data_name.offset, 4) ^= 0
		     then call diag (30);

/*[4.4-10]*/
		end;

	end_stmt.e = end_stmt.e + 1;
	go to ret;


action (288):					/*[3.0-15] Set vfile_ key in opeos.e for start and read statements */
	if header.type = 12
	then end_stmt.e = 511;
	else end_stmt.e = vfile_key;

	go to ret;

action (289):					/* in-line perform */
						/*[4.0-4]*/
	end_stmt.d = "01"b;

/*[4.4-5]*/
	ST.e (nest_lev) = assign_value ();		/*[4.4-5]*/
	ST.h (nest_lev) = assign_value ();



/*[4.0-4]*/
	call emit_pn (ST.e (nest_lev));		/*[4.0-4]*/
	call emit_pn (ST.h (nest_lev));

	go to ret;

emit_pn:
     proc (tagno);

/*[4.0-4]*/
declare	tagno		fixed bin;

/*[4.0-4]*/
	dumprocname.type = 18;			/*[4.0-4]*/
	dumprocname.proc_num = tagno;

/*[4.0-4]*/
	seqvarptr = dpnptr;				/*[4.0-4]*/
	seqvarleng = dumprocname.size;

/*[4.0-4]*/
	call seqput;

     end;

action (290):					/*[5.3-2]*/
	if nest_lev > 1
	then call test_stack;

/*[5.3-2]*/
	nest_lev = 1;				/*[5.3-2]*/
	call reset_st;

	go to ret;

test_stack:
     proc;

/*[5.3-2]*/
dcl	i		fixed bin,
	res		bit (1);

/*[5.3-2]*/
	i = nest_lev;				/*[5.3-2]*/
	EW = ST.end_wd (i);

/*[5.3-2]*/
	if EW ^= 7				/* if */
						/*[5.3-2]*/
	then do;
		i = i - 1;			/*[5.3-2]*/
		EW = ST.end_wd (i);			/*[5.3-2]*/
	     end;

/*[5.3-2]*/
	res = "0"b;

/*[5.3-2]*/
	do i = i by -1 to 1 while (res = "0"b);		/*[5.3-2]*/
	     if ST.end_wd (nest_lev) ^= 7
	     then res = "1"b;			/*[5.3-2]*/
	end;

/*[5.3-2]*/
	if res
	then call diag (145);

     end;

emit_eos_perf:
     proc;

/*[4.0-4]*/
	end_stmt.verb = 20;				/*[4.0-4]*/
	if ST.a (nest_lev) = "000"b
	then end_stmt.a = "000"b;
	else end_stmt.a = "110"b;			/*[4.0-4]*/
	end_stmt.e = ST.e (nest_lev);			/* L1 */
						/*[4.0-4]*/
	end_stmt.h = ST.h (nest_lev);			/* L3 */

/*[4.0-4]*/
	call seqputeos;

     end;

action (291):					/* dispatch on end word */
	go to ret;

/*[4.0-4]*/

action (292):					/* not form of an option */
						/*[5.3-2]*/
	ST.not_opt (nest_lev) = "1"b;			/*[4.0-4]*/
	end_stmt.f = "01"b;
	go to ret;

action (293):					/* option code terminator, type=19, vt=3 */
						/*[5.3-2]*/
	call a294 ("00"b);

	go to ret;






action (294):					/* option code terminator, type=19, vt=3 */
	call a294 ("01"b);
	go to ret;

a294:
     proc (f);					/*[5.3-2]*/
dcl	f		bit (2);			/*[5.3-2]*/
	end_stmt_chars = saveos;			/*[5.3-2]*/
	end_stmt.verb = 3;				/*[4.0-4]*/
	end_stmt.b = "1"b;				/* option code follows */
						/*[5.3-2]*/
	end_stmt.f = f;				/*[4.0-4]*/
	call seqputeos;
     end;

action (295):					/*[4.0-4]*/
	string (ST.desc (nest_lev)) = addr (end_stmt.a) -> bit16;
	go to ret;

action (296):					/*[4.0-4]*/
	addr (end_stmt.a) -> bit16 = string (ST.desc (nest_lev));
	go to ret;

action (297):					/*[4.2-6]*/
	not.line = reserved_word.line;		/*[4.2-6]*/
	not.col = reserved_word.column;		/* save loc of NOT */

	go to ret;

action (298):					/*[4.2-6]*/
	if fixed_common.comp_level <= "2"		/*[4.2-6]*/
	then do;
		if reserved_word.section_header	/*[4.2-6]*/
		then call LEV_DIAG (16, not.line, not.col);
						/* negated simple condition */
						/*[4.2-6]*/
		else call LEV_DIAG (215, not.line, not.col);
						/* negated combined condition */
						/*[4.2-6]*/
	     end;
	go to ret;

action (299):					/*[4.4-3]*/
	is_not_rel = "1"b;

/*[5.3-1]*/
	if cssub > 0
	then cstack.c.logical (cssub - 1) = "1"b;

/*[4.4-1]*/
	if arith_op				/*[4.4-1]*/
	then do;
		call ae_diag (177);			/* ae in rel cond */
						/*[4.4-1]*/
		arith_op = "0"b;			/*[4.4-1]*/
	     end;					/*[4.4-1]*/
	go to action (224);

action (300):					/*[4.4-2]*/
	if ^LTP
	then call DIAG_PREV_TOKEN (279);		/* missing period */
	call act87;
	go to ret;

action (301):					/*[5.3-2]*/
	ST.option (nest_lev) = "1"b;
	call act37;
	go to ret;

action (302):					/*[5.3-2]*/
	ST.option (nest_lev) = "1"b;
	end_stmt.a = "001"b;
	call act109;
	go to ret;

action (303):					/*[5.3-2]*/
	ST.option (nest_lev) = "1"b;
	end_stmt.b = "1"b;
	call seqputeos;
	go to ret;
action (304):					/*[5.3-2]*/
	ST.option (nest_lev) = "1"b;
	end_stmt.b = "1"b;
	go to ret;

action (305):					/*[5.3-2]*/
	ST.cond (nest_lev - 1) = "0"b;

/*[5.3-2]*/
	if ST.e (nest_lev) ^= 0
	then call emit_eos_perf;
	go to ret;


action (306):					/*[4.4-5]*/
	ST.option (nest_lev) = "0"b;			/* else has not occurred */
						/*[5.3-2]*/
	ST.nif (nest_lev) = ST.nif (nest_lev) + 1;	/*[4.4-5]*/
	ST.h (nest_lev) = assign_value ();		/*[4.4-5]*/
	EOF = 0;
	go to ret;

set_op_loc:
     proc;					/*[4.4-6]*/
	call TOK_TYPE;				/*[4.4-6]*/
	op.loc = mptr;
     end;

action (307):					/*[4.4-6]*/
	call act211;
	go to ret;

emit_type_13:
     proc (op, tag);

declare	(op, tag)		fixed bin;

	opeos.verb = 13;
	opeos.e = op;
	opeos.h = tag;
	seqvarptr = opeosptr;
	seqvarleng = opeos.size;

	call seqput;

     end;

action (308):					/*[5.1-3]*/
	ST.h (nest_lev) = assign_value ();		/*[5.3-2]*/
	ST.option (nest_lev) = "1"b;			/*[4.4-5]*/
	if act_log.false ^= 0
	then call DEF (act_log.false);

/*[4.4-5]*/
	UB_ind = "0"b;

	go to ret;

def_false:
     proc;

/*[4.4-5]*/
	if act_log.false ^= 0
	then call DEF (act_log.false);		/*[4.4-5]*/
	UB_ind = "0"b;

     end;

action (309):					/*[4.4-6]*/
	call set_op_loc;
	go to ret;


action (310):					/*[5.3-2]*/
	end_stmt_bits = "0"b;
	end_stmt.verb = 3;
	call seqputeos;
	go to ret;

assign_value:
     proc returns (fixed bin);

	spec_tag_counter = spec_tag_counter + 1;

	return (spec_tag_counter);

     end;

action (311):
	if next_sent_label = 0
	then next_sent_label = assign_value ();

	go to ret;

action (312):					/*[5.3-2]*/
	ST.cond (nest_lev) = "0"b;

	go to ret;

action (313):
	call def_false;
	call DEF (ST.h (nest_lev));
	go to ret;

action (314):					/*NOT USED*/
	go to ret;

action (315):					/*[5.3-2]*/
	ST.not_opt (nest_lev) = "1"b;
	end_stmt.f = "01"b;
	ST.option (nest_lev) = "1"b;
	call act37;
	go to ret;

action (316):					/*NOT USED*/
	go to ret;

action (317):
	call a294 ("01"b);
	UB_ind = "0"b;
	go to ret;

action (318):					/*[4.4-8]*/
	call sav_lin_col;
	call act87;
	go to ret;

sav_lin_col:
     proc;

/*[4.4-8]*/
	sav.line = header.line;
	sav.column = header.column;			/*[4.4-8]*/
	sav_bit = "1"b;

     end;

action (319):					/*[4.4-8]*/
	sav_bit = "0"b;
	go to ret;

action (320):					/*[4.4-8]*/
	call sav_lin_col;
	call act119;
	go to ret;

action (321):					/*[4.4-8]*/
	call sav_lin_col;
	go to ret;

inc_nest_lev:
     proc;

/*[5.3-2]*/
	ST.srchfm2bit (nest_lev) = srchfm2bit;		/*[5.3-2]*/
	nest_lev = nest_lev + 1;			/*[5.3-2]*/
	call reset_st;				/*[5.3-2]*/
	ST.nif (nest_lev) = ST.nif (nest_lev - 1);	/*[5.3-2]*/
	ST.skip_ind (nest_lev) = ST.skip_ind (nest_lev - 1);
     end;

dec_nest_lev:
     proc;

/*[5.3-2]*/
	nest_lev = nest_lev - 1;			/*[5.3-2]*/
	ST.ns (nest_lev) = bool (ST.ns (nest_lev), ST.ns (nest_lev + 1), "0111"b);
						/*[5.3-2]*/
	if ST.end_wd (nest_lev) = 7
	then if ST.option (nest_lev)
	     then call DEF (ST.h (nest_lev));		/*[5.3-2]*/
	srchfm2bit = ST.srchfm2bit (nest_lev);
     end;

reset_st:
     proc;

/*[5.3-2]*/
	addr (ST (nest_lev)) -> bit180 = "0"b;



     end;

action (322):					/*[4.4-8]*/
	sort_count = sort_count + 1;			/*[4.4-8]*/
	if fixed_common.comp_level < "4"		/*[4.4-8]*/
	then if sort_count > 1			/*[4.4-8]*/
	     then call lev_diag (165);

	go to ret;

action (323):					/*[4.4-9]*/
	end_stmt.a = "000"b;
	go to action (3);

action (324):					/* STOP RUN */
						/*[4.4-11]*/
	if fixed_common.init_cd
	then end_stmt.a = "010"b;

/*[4.4-11]*/
	UB_ind = "1"b;
	go to ret;

action (325):					/*[4.4-12]*/
	SUBJ_REQ = "1"b;
	go to ret;

action (326):					/*[4.4-12]*/
	SUBJ_REQ = cstack.subj_req (cssub);
	go to ret;

action (327):					/*[4.4-12]*/
	SUBJ_REQ = "0"b;
	go to ret;

action (328):					/*[4.4-2]*/
	call DIAG_PREV_TOKEN (279);
	call end_sent;
	call seqputeos;
	go to ret;

action (329):					/*[4.4-2]*/
	call DIAG_PREV_TOKEN (279);
	go to ret;

action (330):					/*[4.4-2]*/
	call DIAG_PREV_TOKEN (279);
	call act275;
	go to ret;

action (331):					/*[4.4-2]*/
	call DIAG_PREV_TOKEN (279);
	call seqputeos;
	go to ret;

/*[5.0-1]*/
dcl	cobol_idedsyn$get_seg_limit
			entry returns (fixed bin);

/*[5.0-1]*/
dcl	seg_limit		fixed bin;

action (332):					/*[5.0-1]*/
	if seg_limit = 0				/*[5.0-1]*/
	then call ESD ("2", 7, 79);			/* 1SEG, LI */
						/*[5.0-1]*/
	else if seg_num ^= 0			/*[5.0-1]*/
	then if seg_num < seg_limit			/*[5.0-1]*/
	     then call ESD ("2", 7, 79);		/* 1SEG, LI */
						/*[5.0-1]*/
	     else call ESD ("4", 8, 222);		/* 2SEG, H */

/*[5.0-1]*/
	go to ret;

action (333):					/*[5.3-2]*/
	ST.ns (nest_lev) = "1"b;
	go to ret;

action (334):					/*[5.3-2]*/
	if ST.ns (nest_lev)				/*[5.1-3]*/
	then do;
		call diag (304);			/*[5.1-3]*/
		ns_found = "0"b;			/*[5.1-3]*/
	     end;					/*[5.3-2]*/
	ST.cond (nest_lev) = "0"b;			/*[5.3-2]*/
	call pop_if;
	go to ret;

ESD:
     proc (cl, md_num, dg_num);

/*[5.0-1]*/
dcl	cl		char (1),
	(md_num, dg_num)	fixed bin;

/*[5.0-1]*/
	if fixed_common.comp_level < cl		/*[5.0-1]*/
	then do;
		mod_num = md_num;			/*[5.0-1]*/
		call lev_diag (dg_num);		/*[5.0-1]*/
	     end;

     end;


declare	(key, min_index, max_index)
			fixed bin;


/* source card entry to print routine */

read_error:
	go to endint;

write_error:
	go to endint;

endint:						/* check all files for mismatches on history bits */
						/*[5.1-5]*/
						/* These diags were never issued and dont make much sense

	diag_item.line=0;
	diag_item.column=0;
	fi_ct=0;
nxtfilchk:
	fi_ct=fi_ct+1;

	if fi_ct > fixed_common.file_count then go to endhist;

	call cobol_read_ft_(fi_ct ,  ft_ptr);

	if file_table.external then go to nxtfilchk;

	if close & ( open_in | open_out |open_io | open_ext )
		then go to nxtfilchk;

	diag_item.number=192;
	if close then go to nxtdiag;

	diag_item.number=193;
	if (open_in | open_out | open_io | open_ext ) then go to nxtdiag;

	diag_item.number=194;
	if delete then go to nxtdiag;
	diag_item.number=195;
	if read then go to nxtdiag;
	diag_item.number=196;
	if rewrite then go to nxtdiag;
	diag_item.number=197;
	if write then go to nxtdiag;
	diag_item.number=198;
	if read_next then go to nxtdiag;
	diag_item.number=199;
	if read_key then go to nxtdiag;
	diag_item.number=200;
	if file_table.start then go to nxtdiag;

go to nxtfilchk;

nxtdiag:
	call cobol_c_list(dg_ptr);
go to nxtfilchk;

*/						/*[5.1-5]*/
endhist:
	diag_item.column = header.column;
	diag_item.line = header.line;
	call cobol_c_list (null ());
	return;


declare	(addr, fixed, null, substr, unspec, min, max, bool, string, abs, mod)
			builtin;

declare	(sav_ptr, head_ptr) ptr;

/* The following pointers are used to overlay structures as bit strings */

declare	(act_log_ptr, work_ptr, subject_ptr, soperator_ptr, es_ptr)
			ptr;
declare	(coperator_ptr, cstack_ptr, astack_ptr, end_stmt_ptr)
			ptr;

/* the following bit strings are used to overlay structures */

declare	act_log_bits	bit (124) based (act_log_ptr);
declare	work_bits		bit (124) based (work_ptr);
declare	subject_bits	bit (124) based (subject_ptr);
declare	soperator_bits	bit (124) based (soperator_ptr);
declare	coperator_bits	bit (124) based (coperator_ptr);
declare	cstack_bits	bit (124) based (cstack_ptr);
declare	astack_bits	bit (88) based (astack_ptr);
declare	end_stmt_bits	bit (197) based (end_stmt_ptr);
declare	op_bits		bit (185) based (op_ptr);
declare	left_bits		bit (185) based (left_ptr);

/*[5.3-2]*/
dcl	bit180		bit (180) based;		/*[5.3-2]*/
dcl	bit16		bit (16) based;		/*[5.3-2]*/
dcl	iscond		bit (1);			/*[5.3-2]*/
dcl	ky		fixed bin;

declare	(file_org, seg_num, op_mode, mod_num, act_num, EW)
			fixed bin;
declare	last_seg_num	fixed bin init (1000);	/*[3.0-10]*/
						/*[]*/
declare	(op_ptr, left_ptr)	ptr;			/*[]*/
declare	bit5		bit (5) based;		/*[]*/
						/*[]*/
declare	1 op,					/*[]*/
	  2 loc		ptr,			/*[]*/
	  2 length	fixed bin,		/*[]*/
	  2 line		fixed bin,		/*[]*/
	  2 col		fixed bin,		/*[]*/
	  2 descr,				/*[]*/
	    3 index	bit (1),			/*[]*/
	    3 numeric	bit (1),			/*[]*/
	    3 non_numeric	bit (1),			/*[]*/
	    3 integer	bit (1),			/*[]*/
	    3 op_lit	bit (1);			/*[]*/
						/*[]*/
declare	1 left,					/*[]*/
	  2 loc		ptr,			/*[]*/
	  2 length	fixed bin,		/*[]*/
	  2 line		fixed bin,		/*[]*/
	  2 col		fixed bin,		/*[]*/
	  2 descr,				/*[]*/
	    3 index	bit (1),			/*[]*/
	    3 numeric	bit (1),			/*[]*/
	    3 non_numeric	bit (1),			/*[]*/
	    3 integer	bit (1),			/*[]*/
	    3 left_lit	bit (1);			/*[3.0-10]*/

/*[4.2-6]*/
declare	1 not,					/*[4.2-6]*/
	  2 line		fixed bin,		/*[4.2-6]*/
	  2 col		fixed bin;

/*[4.2-6]*/
declare	1 andor,					/*[4.2-6]*/
	  2 line		fixed bin,		/*[4.2-6]*/
	  2 col		fixed bin;


declare	sort_count	fixed bin;


/*[4.2-6]*/
declare	1 oploc,					/*[4.2-6]*/
	  2 line		fixed bin,		/*[4.2-6]*/
	  2 col		fixed bin;

declare	seg_usage		(0:99) bit (1) based (seg_usage_ptr);

declare	seg_usage_string	bit (100) init ("0"b);
declare	seg_usage_ptr	ptr;

declare	expind		bit (1);

/*[4.0-1]*/
declare	1 ae,					/*[4.0-1]*/
	  2 line		fixed bin,		/*[4.0-1]*/
	  2 column	fixed bin;

declare	1 set_sop,
	  2 int_lit	bit (1),
	  2 int_data	bit (1),
	  2 ind_data	bit (1);

declare	set_sop_mask	bit (3) based;

declare	pigz_res		fixed bin;

/*[4.0-4]*/
dcl	(KEY, END_WORD, nest_lev)
			fixed bin;



/*[4.0-4]*/
declare	1 ST		(0:255),			/*[4.0-4]*/
	  2 end_wd	fixed bin,		/*[4.0-4]*/
	  2 desc,					/*[4.0-4]*/
	    3 a		bit (3),			/*[4.0-4]*/
	    3 b		bit (1),			/*[4.0-4]*/
	    3 c		bit (1),			/*[4.0-4]*/
	    3 d		bit (2),			/*[4.0-4]*/
	    3 f		bit (2),			/*[4.0-4]*/
	    3 g		bit (2),			/*[4.0-4]*/
	    3 k		bit (5),			/*[4.4-5]*/
	  2 option	bit (1),			/*[5.3-2]*/
	  2 not_opt	bit (1),			/*[5.3-2]*/
	  2 cond		bit (1),			/*[5.3-2]*/
	  2 ns		bit (1),			/*[5.3-2]*/
	  2 skip_ind	bit (1),			/*[5.3-2]*/
	  2 save_skip_ind	bit (1),			/*[5.3-2]*/
	  2 srchfm2bit	bit (1),			/*[5.3-2]*/
	  2 nif		fixed bin,		/*[4.0-4]*/
	  2 e		fixed bin,		/*[4.0-4]*/
	  2 h		fixed bin;


/* The following structure is used when look-ahead is needed to determine if the current symbol is in error */
/* It will contain the column and line number of the current symbol */
/* USED in: MULTIPLY - if identifier-2 followed by GIVING */
/*          DIVIDE - if identifier-2 followed by GIVING */
/*          INSPECT - if REPLACING is used */
/*[4.1-7]*/
declare	01 prev_diag,				/*[4.1-7]*/
	  02 line_num	fixed bin,		/*[4.1-7]*/
	  02 column_num	fixed bin;

/*  This pointer points to the previous token.  It is used when you need some */
/* information on the previous token.   */
/* USED in:	procedure DIAG_PREV_TOKEN */

/*[4.1-7]*/
declare	prev_token_ptr	pointer;
declare	cobol_syntax_trace_$trace
			entry (ptr, fixed bin (24));
declare	cobol_syntax_trace_$initialize_phase
			entry (ptr, fixed bin (24));
declare	(DIAG_NUM, message_ind)
			fixed bin;
declare	tm1		fixed bin (24) init (1),
	tm2		fixed bin (24) init (2),
	tm3		fixed bin (24) init (3),
	tm4		fixed bin (24) init (4),
	tm5		fixed bin (24) init (5);
declare	declprocbit	bit (1);
declare	fi_ct		fixed bin;

/*[3.0-15]*/
dcl	vfile_key		fixed bin;		/*[3.0-15]*/
dcl	kc		fixed bin;

declare	lev_save		fixed bin (24);
declare	subs		(3) fixed bin;
declare	sub_loc		fixed bin;


declare	1 indicators,
	  2 tbit		bit (1),
	  2 res		bit (1),
	  2 SAE		bit (1),			/*[3.0-10]*/
	  2 UB_ind	bit (1) init ("0"b),	/*[4.4-3]*/
	  2 is_not_rel	bit (1),
	  2 SUBJ_REQ	bit (1),
	  2 ns_found	bit (1);

dcl	cobol_swf_get	entry (ptr, bit (32), ptr, fixed bin) ext;
dcl	st		bit (32);
dcl	tln		fixed bin;
dcl	cobol_vdwf_dget	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;
dcl	cobol_swf_put	entry (ptr, bit (32), ptr, fixed bin) ext;
dcl	cobol_vdwf_sput	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;
dcl	cobol_vdwf_dput	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;

/* common area */
dcl	comsrtrngptr	ptr static;		/* points to sort range entry */
						/* the following is a description of common*/
declare	(O1_ptr, O2_ptr)	ptr;

declare	1 O1,
	  2 o1		fixed bin,
	  2 l1		fixed bin;

declare	1 O2,
	  2 o2		fixed bin,
	  2 l2		fixed bin;

declare	cobol_read_ft_	entry (fixed bin, ptr);
declare	cobol_pd_code$initialize
			entry (ptr);
declare	cobol_pd_code$code	entry;

declare	code_env_ptr	ptr;

declare	code_option	fixed bin;

declare	1 code_env,
	  2 arg_1		ptr,
	  2 arg_2		ptr,
	  2 arg_3		ptr,
	  2 arg_4		ptr,
	  2 arg_5		ptr,
	  2 arg_6		ptr;

declare	1 DATA,
	  2 ptr		(100) ptr,
	  2 code_area	(5000) fixed bin (35);

declare	file_number	fixed bin;


dcl	filtabptr		ptr;			/* used to base the file table above */
dcl	ft_ptr		ptr;

/* the following is a layout of the FILE KEY record in COMMON */

dcl	1 file_key	based (fkey_ptr),
	  2 fknext	char (5),
	  2 fknext_alt	char (5),
	  2 fkqual	char (5),
	  2 fkinfo	bit (8),
	  2 fkfile_no	fixed bin,
	  2 fkey_type	fixed bin,
	  2 fkline	fixed bin,
	  2 fkcolumn	fixed bin,
	  2 fb_seg	fixed bin,
	  2 fb_offset	fixed bin (24),
	  2 fklinkage	fixed bin,
	  2 fkfilenum	fixed bin,
	  2 fksize_rtn	fixed bin,
	  2 fklength	fixed bin (24),
	  2 fkplacesleft	fixed bin,
	  2 fkplacesright	fixed bin,
	  2 fkdescription	bit (36),
	  2 fkdescriptiona	bit (36),
	  2 fkseg_num	fixed bin,
	  2 fkoffset	fixed bin (24),
	  2 fkname_size	fixed bin,
	  2 fkname	char (30);

dcl	fkey_ptr		ptr;			/*[4.0-3]*/
dcl	(err, format)	fixed bin;		/* work area */

dcl	sort_key		char (5);			/* used for sort in common */

declare	1 stat		static internal,
	  2 procdef,
	    3 srt_range	bit (1),			/* sort */
	    3 sv_isrbit	bit (1),			/* input range */
	    3 sv_osrbit	bit (1),			/* output range */
	    3 mrg_range	bit (1);			/* merge */

declare	bit9		bit (9) based;

dcl	fi		fixed bin;		/* file index used by history check routine */
dcl	next_sent_label	fixed bin static;		/* uset to store tag number of next sentence after if */

dcl	gotodep		bit (1) static;		/*  for go to depending verb found in an if statement */

dcl	preospn_bit	bit (1) static;		/* used by EXIT verb */
dcl	(dg_ptr, lev_dg_ptr)
			ptr;			/* pointer to diag item passed to print routine*/
						/*  type 5 structure used to construct diagnostics issued by pdsyntax */
dcl	1 diag_item,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 run		fixed bin,
	  2 number	fixed bin,
	  2 info		bit (8),
	  2 multics	char (3);

declare	1 lev_diag_item,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 run		fixed bin,
	  2 number	fixed bin,
	  2 module	fixed bin;

dcl	01 jkperfrng	based (jkpfm_ptr),
	  02 jkperfprocnum	fixed bin,
	  02 jkperfcode	fixed bin,
	  02 jkperflink	char (5),
	  02 jkperflink1	char (5),
	  02 jkperfprio	fixed bin,
	  02 jkperfext	fixed bin;
dcl	jkpfm_ptr		ptr;			/*pointer to junk perform range structure*/
dcl	perform_range_key	char (5);			/*[4.4-1]*/
dcl	(sav_bit, arith_op) bit (1);			/*[5.2-1]*/
dcl	end_decl_bit	bit (1);			/*[4.4-1]*/
declare	1 sav,					/*[4.4-1]*/
	  2 line		fixed bin,		/*[4.4-1]*/
	  2 column	fixed bin;		/* entry for perform alter range table */
dcl	01 perfrange	static,
	  02 perfprocnum	fixed bin,
	  02 perfcode	fixed bin,
	  02 perflink	char (5),
	  02 perflink1	char (5),
	  02 perfprio	fixed bin,
	  02 perfext	fixed bin;


declare	cssavebit		bit (1);
dcl	01 saveperfrange,
	  02 sperpronum	fixed bin,
	  02 spercod	fixed bin,
	  02 sperlin	char (5),
	  02 sperlin1	char (5),
	  02 sperpri	fixed bin,
	  02 sperext	fixed bin;

dcl	savlaskey		char (5);			/* save last key of perform ranfe entry */
dcl	junk_ptr		ptr;			/* used to store ptr from dummy reads */
dcl	shprio		fixed bin;
dcl	prio1		fixed bin;
dcl	prio2		fixed bin;
dcl	srchfm2bit	bit (1) static;		/* format 2 of search verb */
dcl	data_name_bit	bit (1);			/* used by subscript routine */
dcl	index_name_bit	bit (1);			/* used by subscript routine */
dcl	fircar		bit (1) static;		/* firdt card switch for print routine */
dcl	dbp		fixed bin static;		/* diagnostic buffer pointer */
dcl	drc		fixed bin (9) static;	/* diagnostic reference counter */
dcl	common_key	char (5);			/* record no of common file just read or to be read */
dcl	common_recsize	fixed bin;		/* size of record just read from common file */
dcl	common_eof	bit (1) static;		/* set on if eof encountered on read of common */

/* needed for function call */
/* parmeter used for action 233 */
dcl	param		bit (1);			/* active logical */
						/* arithmetic stack */
declare	1 astack		(25),
	  2 key		fixed bin,
	  2 filler	fixed bin,
	  2 a,
	    3 unmin	bit (1),			/* unary minus */
	    3 lefpar	bit (1),			/* left paren */
	    3 filler	bit (14);

/* conditional stack */

declare	1 cstack		(75),
	  2 true		fixed bin,
	  2 false		fixed bin,
	  2 length	fixed bin,
	  2 c,
	    3 logical	bit (1),
	    3 not		bit (1),
	    3 numerical	bit (1),
	    3 operand	bit (1),
	    3 alphabetic	bit (1),
	    3 arithexp	bit (1),
	    3 leftpar	bit (1),
	    3 parity	bit (1),
	    3 data_name	bit (1),
	    3 subj_req	bit (1),
	    3 filler	bit (5);

/* active logical */

declare	1 act_log,
	  2 true		fixed bin,
	  2 false		fixed bin,
	  2 length	fixed bin,
	  2 a,
	    3 logical	bit (1),
	    3 not		bit (1),
	    3 numerical	bit (1),
	    3 operand	bit (1),
	    3 alphabetic	bit (1),
	    3 arithexp	bit (1),
	    3 leftpar	bit (1),
	    3 parity	bit (1),
	    3 filler1	bit (8);

/* work area */

declare	1 work,
	  2 true		fixed bin,
	  2 false		fixed bin,
	  2 length	fixed bin,
	  2 w,
	    3 logical	bit (1),
	    3 not		bit (1),
	    3 filler1	bit (5),
	    3 parity	bit (1),
	    3 filler	bit (8);

/* subject of relation */

declare	1 subject,
	  2 true		fixed bin,
	  2 false		fixed bin,
	  2 length	fixed bin,
	  2 s,
	    3 logical	bit (1),
	    3 not		bit (1),
	    3 filler1	bit (5),
	    3 parity	bit (1),
	    3 filler	bit (8);

/* stored operator */

declare	1 soperator,
	  2 op		fixed bin,
	  2 filler	fixed bin,
	  2 length	fixed bin,
	  2 s,
	    3 logical	bit (1),
	    3 not		bit (1),
	    3 filler1	bit (5),
	    3 parity	bit (1),
	    3 filler	bit (8);

/* condition operator */

declare	1 coperator,
	  2 op		fixed bin,
	  2 tag		fixed bin,
	  2 length	fixed bin,
	  2 c,
	    3 logical	bit (1),
	    3 not		bit (1),
	    3 comp	bit (1),
	    3 filler1	bit (4),
	    3 parity	bit (1),
	    3 filler2	bit (8);

declare	lang_num		fixed bin;
declare	(L, LL, L1, L2)	fixed bin;

declare	cobol_imp_word$lang_name
			entry (ptr) returns (fixed bin);

/* used for transposing */
dcl	holdatrue		fixed bin;		/* used for conditional stack */
declare	cop_c_bits	bit (16) based (c_ptr);

/* arithemetic stack */

dcl	cssub		fixed bin static;		/* conditional stack subscript */
dcl	TAG		fixed bin;
dcl	c_ptr		ptr;			/*[4.4-2]*/
dcl	(lognot, last_wd_per, LTP)
			bit (1);
dcl	assub		fixed bin static;		/* arithemetic stack subscript */
dcl	tempkey		fixed bin;		/* used to hold res word key */
dcl	itemsize1		char (512) based;		/*length in bytes of based current record*/
dcl	savidsize		char (512) based;		/* length in bytes of saved identifier record */
dcl	opeosptr		ptr;			/* pointer for operation eos */
dcl	litcnt		fixed bin;		/* used for size of numeric literal */
dcl	daptr		ptr;			/* pointer for dummy alter verb */
dcl	saveos		char (44);		/* used to save eos record */
dcl	end_stmt_chars	char (44) based (es_ptr);	/* used for eos record */
dcl	savoccptr		fixed bin;		/* used to save offset of occurs extension */
						/* used to save the subscript count */
dcl	subcnt		fixed bin;
dcl	decswitch		fixed bin static;		/* if prog has sectons */
dcl	secswitch		fixed bin static;		/* used for sections */
						/* used for debugging sections */
dcl	debugsw		fixed bin static;
dcl	curmax		fixed bin;		/* upper bound of current type 9 item */
dcl	savmax		fixed bin;		/* upper bound plus one of saved type 9 item */
						/* above used for overlapping */
						/* used for diagnostics in note routine */
dcl	diagno		fixed bin static;
dcl	srtrngptr		ptr;			/* used for sort range chain */
						/* an entry in sor range chain*/
dcl	01 srtrng		based (srtrngptr),
	  02 sptr		char (5),			/* points to next entry */
	  02 sstart	fixed bin,		/* start section number of sort range */
	  02 s_start	char (30),
	  02 sstop	fixed bin,		/* stop section number of sort range */
	  02 s_stop	char (30),
	  02 savsecnum	fixed bin,		/* save current section number */
	  02 srtfilno	fixed bin,		/* associated sort file number */
	  02 s_srtfilename	char (30),
	  02 sio		bit (1),			/* input output indicator  0=in  1=out */
	  02 srel		bit (1),			/* release fond within range */
	  02 sret		bit (1);			/* return found within range */

dcl	cursecnum		fixed bin static;		/* save current section number */
						/* this routine is the interpreter for the pd syntax */
						/* label arrays */


/* syntax line work area */
dcl	cobol_c_list	entry (ptr) ext;		/*  cal.led to print sources and diags */
dcl	(pp, id_loc)	ptr;
dcl	x		bit (8) based;		/* length of one line in syntax table */
dcl	bit18		bit (18) based;		/* used for eos record */

declare	1 interp,
	  2 current_line	fixed bin (24),
	  2 phase		fixed bin (24),
	  2 addr_record	ptr,
	  2 pointer_to_internal
			ptr,
	  2 directory_ptr	ptr,
	  2 source_ptr	ptr;

/* the following dcls are used in conjunction with the syntax table subroutines */
/* the current nested limit is 75 */
declare	intrp_stack	(75) fixed bin (24),	/* used for syntax subroutine */
	i1		fixed bin static;		/* syntax table */
dcl	p		ptr;
declare	trace_ptr		ptr;
dcl	dumfix		fixed bin;
dcl	tempchar1		char (1);

declare	1 syntax_table	(0:10000) based (pointer_to_internal),
	  2 b1		fixed bin,
	  2 b2		fixed bin,
	  2 b3		fixed bin,
	  2 b4		fixed bin,
	  2 b5		fixed bin;

declare	1 syntax_line	based (syntax_line_ptr),
	  2 s_bit		char (1),
	  2 o_bit		char (1),
	  2 t_type	fixed bin,
	  2 t_field	fixed bin,
	  2 s_exit	fixed bin,
	  2 a_num		fixed bin;

declare	syntax_line_ptr	ptr;

declare	1 sline,
	  2 s_bit		char (1),
	  2 o_bit		char (1),
	  2 t_type	fixed bin,
	  2 t_field	fixed bin,
	  2 s_exit	fixed bin,
	  2 a_num		fixed bin;

/*[5.3-2]*/
declare	(ii, key_count, file_count)
			fixed bin;


declare	1 header,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 body		char (2000);

dcl	1 message		based (addr_record),	/* 2 header */
	  02 size		fixed bin,
	  02 line		fixed bin,
	  02 column	fixed bin,
	  02 type		fixed bin,
	  02 run		fixed bin,		/*  phase no issuing diagnostic   for pd it is  */
						/* 2 body */
	  02 number	fixed bin,
	  02 info		bit (15),			/*  bit1 means parameter to be inserted  */
	  02 rep_bit	bit (15),			/*  bit2 maans token has been replaced */
	  02 infoa	bit (6),
	  02 length	fixed bin,
	  02 body		char (message.length);


dcl	01 source		based (addr_record),	/* 2 header */
	  02 size		fixed bin,
	  02 line		fixed bin,
	  02 column	fixed bin,
	  02 type		fixed bin,		/* 2 body */
	  02 info		bit (8),
	  02 length	fixed bin,
	  02 image	char (source.length);

dcl	01 satoken	based (addr_record),	/* 2 header */
	  03 size		fixed bin,
	  02 line		fixed bin,
	  02 column	fixed bin,
	  02 type		fixed bin,		/* 2 body */
	  02 stringptr	ptr,
	  02 defline	fixed bin,
	  02 address	bit (32),
	  02 sanum	fixed bin,
	  02 numrecs	fixed bin,
	  02 minchars	fixed bin,
	  02 maxchars	fixed bin,
	  02 namesize	fixed bin,
	  02 name		char (30);

declare	eosptr		ptr;

/* based area to get pointer */
dcl	01 headerb	based (mptr),
	  02 size		fixed bin,
	  02 line		fixed bin,
	  02 column	fixed bin,
	  02 type		fixed bin,
	  02 body		char (header.size - 16);	/* general form of internal record */
						/* current word buffer */
						/* used for i-o operations */
dcl	seq		fixed bin static;
dcl	mptr		ptr;			/* points to record of input minpral file */
dcl	input		fixed bin static;
dcl	rewind		fixed bin static;
dcl	output		fixed bin static;

dcl	itemsize		char (512) based;		/*length in bytes of current record */
dcl	savitmptr		ptr;			/* a dummy procedure name reference type 18 used for go to  action 49 */
						/* pointer for dummy procedure name */
dcl	dpnptr		ptr;			/* pointer for dummy procedure name */
						/* used to save the item for ident subrouttines */

declare	1 saveident	static internal,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 body		char (430);

dcl	savidptr		ptr;			/* pointer for saved identifier */
						/* used to reference the extensions of type 9 records */
dcl	exten		(430) char (1) based;
dcl	occptr		ptr;			/* used to reference the subscript extension of type 9 */

/* save the SORTFILE RECORD here */

dcl	01 sv_srtfil_rec	static internal,		/* header */
	  2 size		fixed bin,
	  2 body		char (300);

/* temp patch*/
dcl	convtemp		fixed bin;
dcl	histno		fixed bin;		/* used for IO verbs */

/* save  procedure definition from sort statement here */

dcl	01 sv_proc_def	static internal,
	  2 size		fixed bin,
	  2 body		char (300);

/* save the FILE after USING or GIVING in SORT statement here */

dcl	01 sv_usfil	static internal,		/* header */
	  2 size		fixed bin,
	  2 body		char (300);

/* save the generated tag number here */

dcl	save_gentag	fixed bin;
dcl	seqvarptr		ptr;
dcl	seqvarleng	fixed bin;
dcl	varrecaddr	char (5);
declare	repcsbit		bit (1);

declare	cobol_pdst	entry (ptr, fixed bin) ext;



dcl	c26		char (28) based;		/* used to move perform range entry */

dcl	fb26		fixed bin static init (28);	/* used to write perform range entry */

dcl	convalue		fixed bin static init (48);	/* used for range check in set verb */


dcl	01 line		static internal,
	  02 scan_bit	char (1),
	  02 output_bit	char (1),
	  02 test_type	fixed bin,
	  02 test_field	fixed bin,
	  02 success_exit	fixed bin,
	  02 action_number	fixed bin;

declare	1 saveitem	static internal,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 boby		char (512);

/*[4.4-5]*/
declare	eos_perform_ptr	ptr,
	eos_perform_size	fixed bin init (40);

/*[4.4-5]*/
declare	1 eos_perform,				/*[4.4-5]*/
	  2 size		fixed bin init (40),	/*[4.4-5]*/
	  2 line		fixed bin init (0),		/*[4.4-5]*/
	  2 column	fixed bin init (0),		/*[4.4-5]*/
	  2 type		fixed bin init (19),	/*[4.4-5]*/
	  2 verb		fixed bin init (20),	/*[4.4-5]*/
	  2 e		fixed bin init (0),		/*[4.4-5]*/
	  2 h		fixed bin init (0),		/*[4.4-5]*/
	  2 i		fixed bin init (0),		/*[4.4-5]*/
	  2 j		fixed bin init (0),		/*[4.4-5]*/
	  2 status	bit (36) init ("0"b);

/*[4.4-5]*/
declare	rw_perform_ptr	ptr,
	rw_perform_size	fixed bin init (28);

/*[4.4-5]*/
declare	1 rw_perform,				/*[4.4-5]*/
	  2 size		fixed bin init (28),	/*[4.4-5]*/
	  2 line		fixed bin init (0),		/*[4.4-5]*/
	  2 column	fixed bin init (0),		/*[4.4-5]*/
	  2 type		fixed bin init (1),		/*[4.4-5]*/
	  2 key		fixed bin init (20),	/*[4.4-5]*/
	  2 status	bit (36) init ("10010010000000001"b),
						/*[4.4-5]*/
	  2 jmp_ndx	fixed bin init (0);

/*[5.2-1]*/
dcl	rw_move_ptr	ptr,
	rw_move_size	fixed bin init (28);

/*[5.2-1]*/
dcl	1 rw_move,				/*[5.2-1]*/
	  2 size		fixed bin init (28),	/*[5.2-1]*/
	  2 line		fixed bin init (0),		/*[5.2-1]*/
	  2 column	fixed bin init (0),		/*[5.2-1]*/
	  2 type		fixed bin init (1),		/*[5.2-1]*/
	  2 key		fixed bin init (18),	/*[5.2-1]*/
	  2 status	bit (36) init ("10010010000000001"b),
						/*[5.2-1]*/
	  2 jmp_ndx	fixed bin init (0);

/*[5.2-1]*/
dcl	supp_lit_ptr	ptr,
	supp_lit_size	fixed bin init (37);

/*[5.2-1]*/
dcl	1 supp_lit,				/*[5.2-1]*/
	  2 size		fixed bin init (37),	/*[5.2-1]*/
	  2 line		fixed bin init (0),		/*[5.2-1]*/
	  2 column	fixed bin init (0),		/*[5.2-1]*/
	  2 type		fixed bin init (2),		/*[5.2-1]*/
	  2 lit_type	bit (36) init ("1000000000001000000001"b),
						/*[5.2-1]*/
	  2 exp_places	fixed bin init (0),		/*[5.2-1]*/
	  2 places_left	fixed bin init (1),		/*[5.2-1]*/
	  2 places_right	fixed bin init (0),		/*[5.2-1]*/
	  2 places	fixed bin init (1),		/*[5.2-1]*/
	  2 literal	char (1) init ("1");

/*[5.2-1]*/
dcl	eos_move_ptr	ptr,
	eos_move_size	fixed bin init (40);

/*[5.2-1]*/
dcl	1 eos_move,				/*[5.2-1]*/
	  2 size		fixed bin init (40),	/*[5.2-1]*/
	  2 line		fixed bin init (0),		/*[5.2-1]*/
	  2 column	fixed bin init (0),		/*[5.2-1]*/
	  2 type		fixed bin init (19),	/*[5.2-1]*/
	  2 verb		fixed bin init (18),	/*[5.2-1]*/
	  2 e		fixed bin init (0),		/*[5.2-1]*/
	  2 h		fixed bin init (0),		/*[5.2-1]*/
	  2 i		fixed bin init (0),		/*[5.2-1]*/
	  2 j		fixed bin init (0),		/*[5.2-1]*/
	  2 status	bit (36) init ("0"b);

%include cobol_ext_;


/* the following is a description of common*/

%include cobol_fixed_common;


/* the layout of a file table */


%include cobol_file_table;
%include cobol_diag_file;
%include cobol_;

declare	1 alphabet_name	based (addr_record),
%include cobol_TYPE40;


dcl	1 reserved_word	based (addr_record),
%include cobol_TYPE1;

dcl	1 numeric_lit	based (addr_record),
%include cobol_TYPE2;

dcl	1 alphanum_lit	based (addr_record),
%include cobol_TYPE3;


dcl	1 proc_def	based (addr_record),
%include cobol_TYPE7;

dcl	1 data_name	based (addr_record),
%include cobol_TYPE9;

dcl	1 occurs		based (occptr),
%include cobol_OCCURS;

dcl	1 index_name	based (addr_record),
%include cobol_TYPE10;

dcl	1 fd_token	based (addr_record),
%include cobol_TYPE12;


%include cobol_type13;

dcl	1 mnemonic_name	based (addr_record),
%include cobol_TYPE17;


dcl	1 end_stmt	static,
%include cobol_TYPE19;



/* a dummy procedure name reference type 18 used for go to  action 49 */
dcl	01 dumprocname	static,
%include cobol_TYPE18;

dcl	01 opeos		static,
%include cobol_TYPE19;
/* dummy open verb for acton 119 */
/* type18 procedure name stored here for go to depending */
dcl	01 store_label_1	static internal,
%include cobol_TYPE18;
/* store type 18 for go dependig */
dcl	01 store_label_2	static internal,
%include cobol_TYPE18;
%include cobol_file_desc_1;

     end cobol_pdstax;
  



		    cobol_pic_val_comp.pl1          05/24/89  1046.0rew 05/24/89  0835.8       49752



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_pic_val_comp.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 04/13/778 by FCH, [3.0-1], fig con in level 88 item */
/* Modified since version 3.0 */

/* format: style3 */
cobol_pic_val_comp:
     proc (dn_ptr, veptr) returns (fixed bin);

/*This procedure compares the data attributes in the type 9 token
  addressed by dn_ptr against the attributes of the value in the
  initial value extension addressed by veptr*/



	status = 0;

	if ^dn_ptr -> data_name.numeric
	then do;

/*non_numeric dn*/

		if init.numeric			/* [3.0-1] */
		then do;				/*non-numeric dn, numeric value*/
			status = 185;
		     end;

		else if init.fig_con & init.non_numeric /* [3.0-1] */
		then do;
			substr (alpha.type, 6, 2) = substr (a_init.type, 6, 2);
						/* [3.0-1] */
			substr (veptr -> based_char_string, 1, 9) = /* [3.0-1] */ addr (alpha) -> alpha_string;
						/* [3.0-1] */

			status = -1;		/* [3.0-1] */


		     end;				/* [3.0-1] */

		else if init.non_numeric		/* [3.0-1] */
						/*alpha init val or ALL literal*/
		then if dn_ptr -> data_name.item_length < veptr -> a_init.length
		     then status = 182;

	     end;

	else do;

		if init.numeric & ^init.fig_con	/* [3.0-1] */
		then do;

/*numeric dn, numeric lit val*/

			if dn_ptr -> data_name.places_left < veptr -> n_init.places_left
			then do;
				if dn_ptr -> data_name.places_left >= 0
				then do;
					status = 182;
					go to retrn;
				     end;
			     end;

			if dn_ptr -> data_name.places_right < veptr -> n_init.places_right
			then do;
				if dn_ptr -> data_name.places_right >= 0
				then do;
					status = 182;
					go to retrn;
				     end;
			     end;

			if veptr -> n_init.sign ^= " "
			then do;
				if (^dn_ptr -> data_name.bin_18 | ^dn_ptr -> data_name.bin_36
				     | ^dn_ptr -> data_name.bin_16 | ^dn_ptr -> data_name.bin_32)
				     & dn_ptr -> data_name.item_signed = "0"b
				then do;

/* warning: pic no sign value sign */

					status = 211;
					go to retrn;
				     end;

			     end;

		     end;

/*numeric dn, val not numeric lit*/

		else if init.fig_con		/* [3.0-1] */
		then do;				/*val is fig con*/

			if substr (veptr -> a_init.info, 2, 7) ^= "0000001"b
			then status = 184;		/*numeric item has non-numeric value*/

/*val is fig con zero*/
/*change alphanumeric initial value extension to numeric*/

			else do;			/* [3.0-1] */
				substr (zero_ext.type, 6, 2) = substr (a_init.type, 6, 2);

				substr (veptr -> based_char_string, 1, 21) = addr (zero_ext) -> zero_ext_string;

/*tell caller that token needs update to Name Table*/

				status = -1;
			     end;
		     end;

/*numeric dn, val not numeric lit or fig con zero*/

		else if init.non_numeric		/* [3.0-1] */
						/*numeric dn, alphanumeric literal value*/
		then status = 184;

	     end;

retrn:
	return (status);





declare	dn_ptr		ptr,
	veptr		ptr;			/*input*/
%include cobol_type9;




declare	1 init		based (veptr),		/* [3.0-1] */
	  2 numeric	bit (1),			/* [3.0-1] */
	  2 non_numeric	bit (1),			/* [3.0-1] */
	  2 fig_con	bit (1),			/* [3.0-1] */
	  2 all_lit	bit (1),			/* [3.0-1] */
	  2 single	bit (1),			/* [3.0-1] */
	  2 thru1		bit (1),			/* [3.0-1] */
	  2 thru2		bit (1),			/* [3.0-1] */
	  2 filler	bit (1);			/* [3.0-1] */

declare	1 a_init		based (veptr),
	  2 type		bit (8),
	  2 info		bit (8),
	  2 length	fixed bin,
	  2 string	char (0 refer (a_init.length));

declare	1 n_init		based (veptr),
	  2 type		bit (8),
	  2 info		bit (8),
	  2 sign		char (1),
	  2 expsign	char (1),
	  2 explaces	fixed bin,
	  2 places_left	fixed bin,
	  2 places_right	fixed bin,
	  2 places	fixed bin,
	  2 string	char (0 refer (n_init.places));

declare	based_char_string	char (1000) based;
declare	zero_ext_constant	fixed bin internal static init (21);

declare	zero_ext_string	char (21) based;
declare	alpha_string	char (9) based;		/* [3.0-1] */

declare	1 zero_ext	internal static,
	  2 type		bit (8) init ("10000000"b),
	  2 info		bit (8) init ("00000000"b),
	  2 sign		char (1) init (" "),
	  2 expsign	char (1) init (" "),
	  2 explaces	fixed bin init (0),
	  2 places_left	fixed bin init (1),
	  2 places_right	fixed bin init (0),
	  2 places	fixed bin init (1),
	  2 string	char (1) init ("0");

declare	1 alpha		static internal,		/* [3.0-1] */
	  2 type		bit (8) init ("0"b),	/* [3.0-1] */
	  2 info		bit (8) init ("0"b),	/* [3.0-1] */
	  2 length	fixed bin init (1),		/* [3.0-1] */
	  2 string	char (1) init ("0");	/* [3.0-1] */

declare	tempbin		fixed bin;
declare	status		fixed bin;		/*output: zero or diagnostic number*/
declare	addr		builtin;
declare	substr		builtin;

     end cobol_pic_val_comp;




		    cobol_print_diag.pl1            05/24/89  1046.0rew 05/24/89  0835.7      248598



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_print_diag.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 10/29/82 by FCH, [5.1-3], last diag was being suppressed, BUG542(phx13372) */
/* Modified on 12/28/81 by FCH, [5.1-2], print generated RW source line if diags, phx12121(BUG525) */
/* Modified on 11/25/81 by FCH, [5.1-1], add main prog to include file table, BUG519(phx11818) */
/* Modified on 09/01/81 by FCH, [5.0-1], check for eof while ignoring report writer lines, BUG498 */
/* Modified on 12/26/79 by MHD, [4.2-3], change to aid readability */
/* Modified on 12/06/79 by MHD, [4.2-2], set 1INX leveling message to high */
/* Modified on 11/20/79 by MHD, [4.2-1], check for eof when ignoring debug lines */
/* Modified on 10/18/79 by MHD, [4.1-1], deleted unused parameter */
/* Modified on 07/11/79 by FCH, [4.0-3], debug statement */
/* Modified on 04/09/78 by FCH, [4.0-2], [3.0-2] wiped out */
/* Modified on 02/26/79 by FCH, [4.0-1], option -levsv added */
/* Modified on 10/31/78 by RAL, [3.0-2], Added leveling from expand_cobol_source for listing */
/* Modified on 07/26/78 by RAL, [3.0-1], Corrected length of diag */
/* Modified since Version 3.0.     */







/* format: style3 */
cobol_print_diag:
     proc;


/* This program accepts as input a pointer to a source or diag token.  Information from the source token starts */
/* a stack, and all diags for that source line are added to the stack  in column number, diag number order. */
/* When a new source token is encountered, the stack is put out  as a source line, diag reference line and */
/* diags(if any), and the new source starts another stack.  The diags are looked up in a separate diag */
/* file, which is creates and maintained by a separate program ("dfile").  A diag may contain 1 parameter. */
/* Page headers are put out as required.  Any diags not associated with the current source line are put out */
/* immediatly after the line number and column number. */

/*	1	1NUC(1)		2	2NUC(3)
	3	1TBL(1)		4	2TBL(3)
	5	1SRT(3)		6	2SRT(4)
	7	1SEG(2)		8	2SEG(4)
	9	1LIB(2)		10	2LIB(4)
	11	1DEB(2)		12	2DEB(3)
	13	1IPC(2)		14	2IPC(3)
	15	1SEQ(1)		16	2SEQ(3)
	17	1REL(2)		18	2REL(3)
	19	1INX(4)		20	2INX(4)
	21	1RPW(4)		22	2RPW(4)
	23	1COM(3)		24	2COM(3)
	25	1EXT(5)		26	2EXT(5)
*/

declare	fm_name		(26) char (4)
			init ("1NUC", "2NUC", "1TBL", "2TBL", "1SRT", "2SRT", "1SEG", "2SEG", "1LIB", "2LIB",
			"1DEB", "2DEB", "1IPC", "2IPC", "1SEQ", "2SEQ", "1REL", "2REL", "1INX", "2INX", "1RPW",
			"2RPW", "1COM", "2COM", "1EXT", "2EXT");

declare	level_num		(26) fixed bin init (1, 3, 1, 3, 3, 4, 2, 4, 2, 4, 2, 3, 2, 3, 1, 3,
						/*[4.2-2]*/
			2, 3, 4, 4, 4, 4, 3, 3, 5, 5);



	pbuf_ptr = addr (p_buf);
	st_ptr = addr (status);

	do i = 1 to 8;
	     dno_run_index (i) = 0;
	end;

	dno_count = 0;
	t_flag = "0"b;
	run_no = 0;
	all_done = "0"b;
	eof_prt = "0"b;
	no_diag = "0"b;
	addr (new_line_character) -> bit9 = "000001010"b;

	i = 0;
	s = 1;

	call sort_diag;

	if no_diag & ^fixed_common.options.exs
	then return;

	d_ref = "0"b;
	l_first = null ();
	l_current = null ();
	ad_nl = addr (nl);
	ad_hof = addr (hof);

	d_string_ptr = addr (diag_file.diag_table (d_t_size + 1));

	if fixed_common.options.exs
	then do;

		call cobol_version$header (multics_hdr, multics_hdr_len);
		call cobol_put_rec (st, cobol_ext_$cobol_hfp, 0, addr (multics_hdr), multics_hdr_len);

	     end;

	i_limit = i;
	i = 1;

	do while ("1"b);

rd:
	     call cobol_swf_get (cobol_pfp, status, in_ptr, ln);

/*[4.2-1]*/
	     if status_right ^= "0"b			/*[4.2-1]*/
	     then eof_prt = "1"b;			/*[4.2-1]*/
	     else if substr (source.image, 1, 6) = "~~~~~~"
						/*[4.2-1]*/
	     then go to rd;				/*[5.1-3]*/
	     else if i <= i_limit			/*[5.1-2]*/
	     then if substr (source.image, 1, 6) = "::::::"
						/*[5.1-2]*/
		then if ^sev3 ()			/*[5.1-2]*/
		     then go to rd;			/*[5.1-2]*/
		     else ;			/*[5.1-2]*/
		else ;				/*[5.1-2]*/
	     else if substr (source.image, 1, 6) = "::::::"
						/*[5.1-2]*/
	     then go to rd;

	     call proc_source;

	     if status_right ^= "0"b
	     then do;
		     call close_it;
		     return;
		end;

/*[5.1-3]*/
	     if i <= i_limit
	     then if ptr_array (i) -> message.line = l_source.line
		then call proc_diag;

	end;					/* END MAIN LOOP */

sev3:
     proc returns (bit (1));

/*[5.1-2]*/
dcl	(j, N, R)		fixed bin,
	P		ptr;

/*[5.1-2]*/
	do j = i by 1 to i_limit;

/*[5.1-2]*/
	     P = ptr_array (j);

/*[5.1-2]*/
	     if source.line > P -> message.line
	     then return ("0"b);

/*[5.1-2]*/
	     R = P -> message.run;			/*[5.1-2]*/
	     N = P -> message.number;

/*[5.1-2]*/
	     if diag_file.diag_table.d_type (diag_file.run_table.base (R) + N) = 3
	     then return ("1"b);

/*[5.1-2]*/
	end;

/*[5.1-2]*/
	return ("0"b);

     end;


proc_diag:
     proc;

/* Process diagnostic token. */

	l_current = l_first;

	do while ("1"b);

	     diag_cnt = diag_cnt + 1;

	     if diag_cnt > 9
	     then do while ("1"b);

		     i = i + 1;

/*[5.1-3]*/
		     if i > i_limit
		     then return;

		     if ptr_array (i) -> message.line ^= l_diag.line
		     then return;

		end;

	     p = l_current;
	     l_current = l_diag.next;

	     if l_current = null ()
	     then do;
		     p2 = l_current;
		     old_sw = "1"b;

		     call al_dt;

		     p -> l_diag.next = l_current;
		     l_diag.next = p2;
		end;

	     i = i + 1;

/*[5.1-3]*/
	     if i > i_limit
	     then return;

	     if ptr_array (i) -> message.line ^= l_diag.line
	     then return;

	end;

     end;



proc_source:
     proc;


	if l_first ^= null ()
	then do;					/* Put out the previous source and diagnostics. */

		call start_proc_source;

/* Construct the diagnostic in a temp. */

		l_current = l_source.next;
		diag_sw = "0"b;

		if l_current = null ()
		then call last_diag;
		else call next_diag;

	     end;					/* Start a new stack with a new source line. */

	if eof_prt
	then do;
		status_right = "1"b;
		return;
	     end;

	if in_ptr = null ()
	then return;

	if fixed_common.date_comp_ln ^= 0
	then if source.line = fixed_common.date_comp_ln
	     then do;

		     call date_time_ (cobol_$sym_base_ptr -> symbol_block_header.object_creation_time, date_time);

		     s_start = index (source.image, "-") + 9;
		     s_length = s_start + 27;

		end;

	     else s_length = source.length;

	else s_length = source.length;

	call cobol_allo_tm (l_ptr, 24 + s_length);

	l_first = l_ptr;
	l_source.next = null ();
	l_source.type = source.type;
	l_source.line = source.line;
	l_source.info = source.info;
	l_source.length = s_length;

	substr (l_source.image, 1, s_length) = substr (source.image, 1, s_length);

	if fixed_common.date_comp_ln ^= 0
	then if source.line = fixed_common.date_comp_ln
	     then substr (l_source.image, s_start, 28) = ". " || date_time || "." || new_line_character;

	diag_cnt = 0;

     end;

sort_diag:
     proc;

declare	(LINE, ICOL, JCOL, ILEN, JLEN)
			fixed bin;

declare	p		ptr;

declare	1 fake_message,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin;

	p = addr (fake_message);
	p -> message.line = 0;
	p -> message.column = 0;
	ptr_array (0) = p;

/*[4.2-3]*/
/* Rewrote to aid readability */

	do i = 1 by 1 to 3000;

	     LINE = 0;

	     do while (LINE = 0);

		call cobol_swf_get (cobol_dfp, status, in_ptr, ln);

		if status_right ^= "0"b
		then do;
			if i = 1
			then no_diag = "1"b;	/*[5.3-1]*/
			i = i - 1;
			return;
		     end;

		LINE = in_ptr -> message.line;


	     end;


	     if i ^= 1
	     then do;
		     j = i - 1;

		     ILEN = in_ptr -> message.line;
		     JLEN = ptr_array (j) -> message.line;
		     ICOL = in_ptr -> message.column;
		     JCOL = ptr_array (j) -> message.column;

		     do while (ILEN < JLEN | (ILEN = JLEN & ICOL < JCOL));

			ptr_array (j + 1) = ptr_array (j);

			j = j - 1;

			JLEN = ptr_array (j) -> message.line;
			JCOL = ptr_array (j) -> message.column;

		     end;

		     ptr_array (j + 1) = in_ptr;
		end;

	     else ptr_array (1) = in_ptr;

	end;

	call ioa_ ("cobol: There are over 3000 diagnostics in this program, only the first 3000 will be printed");

     end;


start_proc_source:
     proc;

/* set up the print line */

	string (source_ln.front) = "";

	if l_source.line > 0
	then do;
		eln_index = l_source.line;
		reln_ptr = addr (eln_tab (eln_index));
		part1 = " ";
		t_fno = eln_tab.fno (eln_index);

		if t_fno ^= 0
		then call ioa_$rsnnl ("^d", part1, 4, t_fno);

		source_ln.margin = part1;
		t_lno = eln_tab.lno (eln_index);

		call ioa_$rsnnl ("^d", source_ln.isn, 7, t_lno);

	     end;

	if l_source.next ^= null ()			/* set up diag reference line */
	then do;
		l_current = l_source.next;
		diag_ref = 0;
		save_col = 0;
		ref_line = " ";

		do while (l_current ^= null ());	/* scan the diags in the stack */

		     if l_diag.col = 0
		     then l_diag.col = 1;

		     if save_col ^= l_diag.col
		     then do;			/* set a ref no if col no different */

			     diag_ref = diag_ref + 1;
			     call ioa_$rsnnl ("^d", ch1, ioa_len, diag_ref);

			     substr (ref_line, l_diag.col, 1) = ch1;
			     save_col = l_diag.col;

			end;

		     call ioa_$rsnnl ("^d", l_diag.ref, ioa_len, diag_ref);

		     l_current = l_diag.next;
		end;

		ref_cur_char = 1;

	     end;

	cur_char = 1;

/* put the source line in as many print lines as necessary */

	do while ("1"b);

	     str_len = l_source.length;
	     substr (source_ln.text, 1, str_len) = substr (l_source.image, cur_char, str_len);
	     pbuf_len = str_len + 12;

	     if fixed_common.options.exs
	     then do;

		     if substr (l_source.image, 7, 1) = "/"
		     then if str_len > 6
			then call cobol_put_rec (st, cobol_ext_$cobol_hfp, 0, addr (ff_char), 1);

		     call cobol_put_rec (st, cobol_ext_$cobol_hfp, 0, pbuf_ptr, pbuf_len);

		end;

	     if l_source.next ^= null ()
	     then do;				/* Put source and diag reference line out. */

		     t_buf = p_buf;
		     len_t1 = pbuf_len;		/* [3.0-1] */
		     t_flag = "1"b;
		     string (source_ln.front) = "";

		     substr (source_ln.text, 1, str_len) = substr (ref_line, ref_cur_char, str_len);

		     pbuf_len = str_len + 12;

/*[4.0-1]*/
		     if fixed_common.options.exs & diag_ref > 0
		     then call cobol_put_rec (st, cobol_ext_$cobol_hfp, 0, pbuf_ptr, pbuf_len);

		     len_t2 = pbuf_len;
		     ref_cur_char = ref_cur_char + str_len;

		end;

	     l_source.length = l_source.length - str_len;

	     if l_source.length = 0
	     then return;

	     string (source_ln.front) = "";
	     cur_char = cur_char + str_len;
	end;

     end;

next_diag:
     proc;

	do while ("1"b);

	     if l_current = null ()
	     then do;
		     call last_diag;
		     return;
		end;
	     else call proc_dt;

	end;
     end;

last_diag:
     proc;

	if l_first ^= null ()
	then do;
		l_ptr = l_first;
		call cobol_allo_tm$free_tm (l_ptr);

	     end;

	if diag_sw
	then do;
		string (source_ln.front) = "";

/*[4.0-1]*/
		if fixed_common.options.exs & diag_ref > 0
		then call cobol_put_rec (st, cobol_ext_$cobol_hfp, 0, pbuf_ptr, 1);

	     end;

     end;

proc_dt:
     proc;

/* This routine formats and issues a diagnostic to the listing file */

	run_no = l_diag.run;

	if run_no < 0 | run_no > diag_file.r_t_size
	then do;
		call DEL_DIAG_ENTRY;
		return;
	     end;

	if l_diag.num > diag_file.run_table.size (run_no) | l_diag.num < 0
	then do;
		call DEL_DIAG_ENTRY;
		return;
	     end;

	ac_diag = diag_file.run_table.base (run_no) + l_diag.num;

	if l_diag.num ^= 0
	then if diag_table.d_len (ac_diag) = 0
	     then do;
		     call DEL_DIAG_ENTRY;
		     return;
		end;

/* Set up beginning of print line. */

	string (source_ln.front) = "";

/*	if ^diag_sw
/*	then do;
/*		pbuf_len = 2;
/*		if  fixed_common.options.exs
/*			then call cobol_put_rec(st,cobol_ext_$cobol_hfp,0,pbuf_ptr,pbuf_len);
/*		end;
/* */

	diag_sw = "1"b;
	diag_line.ref = l_diag.ref;

	if run_no ^= 9				/*[4.0-3]*/
	then do;
		if run_no > 15
		then run_no = 15;			/*[4.0-3]*/
		diag_line.run = substr ("12345678LDXXXXX", run_no, 1);
						/*[4.0-3]*/
	     end;
	else do;
		diag_line.run = "L";
		mod_num = fixed (l_diag.info, 27);

		if mod_num = 0
		then mod_num = diag_table.d_type (ac_diag);
	     end;

	diag_line.dash = "-";

	call ioa_$rsnnl ("^d", diag_line.diag_no, ioa_len, l_diag.num);

	if l_diag.num = 0
	then do;					/* Pick up diag text from the stack entry. */

		d_temp = substr (l_diag.image, 1, l_diag.length);
		d_temp_len = l_diag.length;
		diag_line.type = "   *";

		call put_diag;

		return;

	     end;

	if run_no ^= 9				/*[4.0-1]*/
	then do;
		diag_ref = diag_table.d_type (ac_diag);

/*[4.0-1]*/
		if fixed_common.comp_level < "5"	/*[4.0-1]*/
		then if diag_ref < 3
		     then diag_ref = 0;		/*[4.0-1]*/
	     end;					/*[4.0-1]*/
	else do;
		if substr (fixed_common.levsv, 1, 1)	/*[4.0-1]*/
		then diag_ref = 1;			/*[4.0-1]*/
		else if substr (fixed_common.levsv, 2, 1)
						/*[4.0-1]*/
		then diag_ref = 2;			/*[4.0-1]*/
		else diag_ref = 3;			/*[4.0-1]*/
	     end;

	if diag_ref = 2
	then fixed_common.warn_no = fixed_common.warn_no + 1;

	diag_line.type = substr ("   ****", diag_ref, 4);
	dline_1_sw = "1"b;

	if substr (l_diag.info, 1, 1)
	then do;					/* Insert the parameter. */

		if diag_table.d_param (ac_diag) = 0
		then do;
			call no_param;
			return;
		     end;

		if l_diag.run = 6 & l_diag.num = 39
		then do;
			d_temp =
			     substr (d_string, diag_table.d_start (ac_diag), diag_table.d_param (ac_diag) - 1)
			     || substr (l_diag.image, 1, l_diag.length) || " IS "
			     || substr (l_diag.image, 1, l_diag.length)
			     ||
			     substr (d_string, diag_table.d_start (ac_diag) + diag_table.d_param (ac_diag),
			     diag_table.d_len (ac_diag) - diag_table.d_param (ac_diag));

			d_temp_len = diag_table.d_len (ac_diag) + l_diag.length * 2 + 4;

			call put_diag;

			return;

		     end;

		if l_diag.run = 3 & l_diag.num = 9	/* ddsyntax special diag */
		then do;
			substr (char_13, 4, 11) = l_diag.image;
			BL = " ";

			do k = 1 to 28 while (BL = " ");

			     bsi = 28 - k;

			     BL = substr (d3_9p (cobol_d3_9.p1), bsi, 1);

			end;

			l_diag.length = bsi + 4;
			l_diag.image = d3_9p (cobol_d3_9.p1);
			l_diag.image = substr (l_diag.image, 1, bsi) || ":
		";
			do jj = 1 to 83;

			     if cobol_d3_9.pv (jj)
			     then do;

				     BL = " ";

				     do k = 1 to 28 while (BL = " ");

					bsi = 28 - k;
					BL = substr (d3_9p (jj), bsi, 1);

				     end;

				     plen = bsi + 4;

				     if l_diag.length + plen <= 200
				     then do;
					     substr (l_diag.image, l_diag.length + 1, plen) = d3_9p (jj) || ",";
					     l_diag.length = l_diag.length + plen;
					end;

				end;
			end;

			substr (l_diag.image, l_diag.length - 1, 1) = ".";

		     end;

		d_temp =
		     substr (d_string, diag_table.d_start (ac_diag), diag_table.d_param (ac_diag) - 1)
		     || substr (l_diag.image, 1, l_diag.length)
		     ||
		     substr (d_string, diag_table.d_start (ac_diag) + diag_table.d_param (ac_diag),
		     diag_table.d_len (ac_diag) - diag_table.d_param (ac_diag));

		d_temp_len = diag_table.d_len (ac_diag) + l_diag.length;

	     end;

	else do;
		call no_param;
		return;
	     end;

	call put_diag;

     end;

no_param:
     proc;

	d_temp_len = diag_table.d_len (ac_diag);
	d_temp_st = diag_table.d_start (ac_diag);

	if run_no ^= 9
	then d_temp = substr (d_string, d_temp_st, d_temp_len);
	else call lev_diag;

	call put_diag;

     end;

lev_diag:
     proc;

declare	lev_nam		char (20) varying;
declare	lev_mess		char (256) varying;

	lev_mess = substr (d_string, d_temp_st, d_temp_len);

	sev_lev = level_num (mod_num);

	go to L (sev_lev);

L (1):						/* low */
	lev_nam = "low";

	go to L1;

L (2):						/* low intermediate */
	lev_nam = "low intermediate";

	go to L1;

L (3):						/* high intermediate */
	lev_nam = "high intermediate";

	go to L1;

L (4):						/* high */
	lev_nam = "high";

	go to L1;

L (5):						/* extension */
	lev_mess = "FIPS level restriction [extension]: " || lev_mess;

	go to L2;

L1:
	lev_mess = "FIPS level restriction [" || fm_name (mod_num) || "- " || lev_nam || " level]: " || lev_mess;

L2:
	d_temp_len = length (lev_mess);
	d_temp = substr (lev_mess, 1, d_temp_len);

     end;

put_diag:
     proc;

/* put the diag in as many print lines as necessary */

	cur_char = 1;
	dup = "0"b;

	if m_bf
	then do;
		not_done = "1"b;
		di = dno_run_index (run_no);

		if di = 0				/* first diag */
		then do;
			dno_count = dno_count + 1;

			if dno_count <= 60		/* start diag number chain */
			then do;
				dno_run_index (run_no) = dno_count;
				dno (dno_count) = l_diag.num;
				dno_next (dno_count) = 0;

			     end;
		     end;

		else do while (not_done);		/* search chain for match */

			if dno (di) = l_diag.num
			then do;
				not_done = "0"b;
				dup = "1"b;
			     end;
			else if dno_next (di) = 0	/* search exhausted */
			then do;
				not_done = "0"b;
				dno_count = dno_count + 1;

				if dno_count <= 60
				then do;
					dno_next (di) = dno_count;
					dno (dno_count) = l_diag.num;
					dno_next (dno_count) = 0;
				     end;
			     end;

			else di = dno_next (di);	/* continue search */

		     end;
	     end;

	do while ("1"b);

	     str_len = d_temp_len;
	     substr (diag_line.text, 1, str_len) = substr (d_temp, cur_char, str_len);
	     diag_line.fill2 = " ";
	     pbuf_len = str_len + 13;

/*[4.0-1]*/
	     if fixed_common.options.exs & diag_ref > 0
	     then call cobol_put_rec (st, cobol_ext_$cobol_hfp, 0, pbuf_ptr, pbuf_len);

	     if dup
	     then do;
		     pbuf_len = 13;
		     str_len = 13;
		     d_temp_len = 13;
		end;

	     if (m_fat & diag_ref = 3) | (m_wn & diag_ref = 2) | (m_obs & diag_ref = 1)
	     then do;				/* Print the diag on the user-console. */

		     if t_flag = "1"b
		     then do;
			     t_flag = "0"b;
			     call ioa_ ("^/^a", substr (t_buf, 1, len_t1));
			     call ioa_ ("^12x^a", substr (ref_line, 1, len_t2));

			end;

		     call ioa_ ("^a", substr (p_buf, 1, pbuf_len));
		end;

	     d_temp_len = d_temp_len - str_len;

	     if d_temp_len = 0
	     then do;
		     call del_diag_entry;
		     return;
		end;

	     string (source_ln.front) = "";
	     cur_char = cur_char + str_len;

	end;

     end;

DEL_DIAG_ENTRY:
     proc;

	call del_diag_entry;

	string (source_ln.front) = "";
	cur_char = cur_char + str_len;

     end;

del_diag_entry:
     proc;

	p = l_diag.next;
	l_ptr = l_current;

/* remove this diag entry from stack */

	call cobol_allo_tm$free_tm (l_ptr);

	l_current = p;

     end;

al_dt:
     proc;

/* This routine allocates a token in the current or out-of-line diagnostic stack. */

dcl	tempbit		bit (1);
dcl	tempmno		fixed bin;

	tempbit = substr (ptr_array (i) -> message.info, 1, 1);
	tempmno = ptr_array (i) -> message.number;

	if tempbit | tempmno = 0
	then do;					/* get diag parameter or whole diag */

		call cobol_allo_tm (l_ptr, 232);	/* 200 is for DDSYNTAX special diags */

		l_current = l_ptr;
		l_diag.length = ptr_array (i) -> message.image_size;
		l_diag.image = substr (ptr_array (i) -> message.image, 1, ptr_array (i) -> message.image_size);

	     end;
	else do;
		call cobol_allo_tm (l_ptr, 32);
		l_current = l_ptr;
		l_diag.length = 0;
	     end;


	l_diag.next = null ();
	l_diag.line = ptr_array (i) -> message.line;

	if (ptr_array (i) -> message.column < 0) | (ptr_array (i) -> message.column > l_source.length)
	then l_diag.col = 0;
	else l_diag.col = ptr_array (i) -> message.column;


	l_diag.run = ptr_array (i) -> message.run;

	if l_diag.run ^= 9
	then l_diag.info = ptr_array (i) -> message.info;
	else l_diag.info = ptr_array (i) -> message.module;

	l_diag.num = ptr_array (i) -> message.number;
	l_diag.ref = " ";

     end al_dt;

close_it:
     proc;

	if cobol_$include_cnt > 0
	then if fixed_common.options.exs
	     then do;

		     call cobol_put_rec (st, cobol_ext_$cobol_hfp, 0, addr (incl_hdr), 73);

/*[5.1-1]*/
		     do i = 0 to cobol_$include_cnt;

			call hcs_$fs_get_path_name (include_ptr (i), dirname, ldn, ename, code);
			call hcs_$fs_get_ref_name (include_ptr (i), 1, rname, code);

			if rname = (32)" "
			then rname = ename;

			call ioa_$rs ("^7d^3x^6d^4x^40a^a", incl_line, incl_line_len,
			     fixed (rel (include_ptr (i)), 17), i, rname, substr (dirname, 1, ldn) || ">" || ename);

			call cobol_put_rec (st, cobol_ext_$cobol_hfp, 0, addr (incl_line), incl_line_len);

		     end;

		end;

     end;

declare	(BL, ch1)		char (1);
declare	dbin		char (13);
declare	(sev_lev, mod_num)	fixed bin;

dcl	1 source		based (in_ptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 6 */
	  2 info		bit (8),
	  2 length	fixed bin,
	  2 image		char (120);

dcl	diag_sw		bit (1) static;
dcl	old_sw		bit (1) static;

dcl	hof		bit (9) static init ("000001100"b);

dcl	ad_hof		pointer static;
dcl	st		bit (32);
dcl	cobol_allo_tm	entry (ptr, fixed bin) ext;
dcl	cobol_allo_tm$free_tm
			entry (ptr) ext;
dcl	date_time_	entry (fixed bin (71), char (*));
dcl	date_time		char (24);
dcl	new_line_character	char (1);
dcl	bit9		bit (9) based;

dcl	s_length		fixed bin;
dcl	s_start		fixed bin;
dcl	(l_current, l_first, p, p2)
			pointer static;
dcl	l_ptr		ptr;
dcl	1 l_source	based (l_first),		/* stack source entry */
	  2 next		pointer,
	  2 type		fixed bin,
	  2 line		fixed bin,
	  2 info		bit (8),
	  2 length	fixed bin,
	  2 image		char (120);
dcl	1 l_diag		based (l_current),		/* stack diag entry */
	  2 next		pointer,
	  2 line		fixed bin,
	  2 col		fixed bin,
	  2 run		fixed bin,
	  2 num		fixed bin,
	  2 ref		char (1),
	  2 info		bit (27),
	  2 length	fixed bin,
	  2 image		char (120);

dcl	p_buf		char (255);


dcl	nl		bit (9) static init ("000001010"b);

dcl	ad_nl		pointer static;
dcl	dline_1_sw	bit (1) static;
dcl	1 source_ln	based (pbuf_ptr),		/* source print line */
	  2 front,
	    3 margin	char (4),
	    3 isn		char (7),
	    3 fill	char (1),
	  2 text		char (247);
dcl	1 diag_line	based (pbuf_ptr),		/* diag print line */
	  2 type		char (4),
	  2 fill1		char (1),
	  2 ref		char (1),
	  2 fill3		char (1),
	  2 run		char (1),
	  2 dash		char (1),
	  2 diag_no	char (3),
	  2 fill2		char (1),
	  2 text		char (1);
dcl	ref_line		char (200);
dcl	ref_cur_char	fixed bin static;
dcl	(diag_ref, cur_char, str_len, save_col)
			fixed bin static;
dcl	db_len		fixed bin;
dcl	t_flag		bit (1);
dcl	(len_t1, len_t2, ioa_len)
			fixed bin;

dcl	t_buf		char (255);
dcl	d_string		char (100000) based (d_string_ptr);
dcl	d_string_ptr	ptr;

dcl	d_ref		bit (64) static;
dcl	(run_no, d_temp_len, d_temp_st, ac_diag, diag_cnt, plen, bsi)
			fixed bin static;
dcl	1 cobol_d3_9	static,
	  2 p1		fixed bin init (0),
	  2 pv		(88) bit (1) init ((88) (1)""b);
dcl	char_13		char (15) based (addr (cobol_d3_9.p1));


dcl	d3_9p		(88) char (28) static
			init ("FILE section item", "WORKING-STORAGE section item", "CONSTANT section item",
			"LINKAGE section item", "COMMUNICATION section item", "REPORT section item", "77 level",
			"01 level", "non-elementary", "elementary", "FILLER", "subject of redefines",
			"object of redefines", "usage comp-7", "usage comp-6", "picture contains l",
			"picture is depending on", "numeric", "numeric-edited", "alphanumeric",
			"alphanumeric-edited", "alphabetic", "alphabetic-edited", "picture contains p",
			"* suppresion", "signed", "sign is separate", "usage display", "usage comp", "usage comp-8",
			"usage comp-5", "usage comp-3", "usage comp-1", "usage comp-2", "usage index",
			"justified right", "level 88", "sync", "temporary", "blank when zero", "variable length",
			"subscripted", "occurences depending on", "key ascending", "key descending", "indexed by",
			"numeric value", "non-numeric value", "signed value", " ", " ", " ", "integer",
			"asterisk when zero", "label", " ", "occurs key data-name", "subject of key is clause",
			"subject of redefines clause", "synchronized", "rounded", "sort on ascending key",
			"debug all", "overlap", "sum counter", "occurrence", "linage counter",
			"level 01 object of renames", "aligned", "not user writable", "database key",
			"database data item", "unsigned", "picture clause exists", "sign clause exists",
			"code set class 1", "value clause exists", "usage clause exists", "no picture clause",
			"no value clause", "figurative zero value", "value clause applies",
			"FD has code-set clause", "associated with picture s", " ", " ", " ", " ");


dcl	d_temp		char (200) static;
dcl	t_isn		char (13) static;
dcl	temp_ptr		ptr;
dcl	eof_prt		bit (1);
dcl	(t_fno, t_lno)	fixed bin;
dcl	part1		char (4);

/*  EXTERNAL COBOL I/O ENTRIES  */

dcl	cobol_swf_get	ext entry (ptr, bit (32), ptr, fixed bin);

/*  DECLARATION OF SOME VARIABLES USED IN COMPILER I/O CALLS  */

dcl	keyno		char (5);
dcl	key1		char (5);
dcl	curr_input	ptr;
dcl	curr_output	ptr;
dcl	recsize		fixed bin;
dcl	recsize2		fixed bin;
dcl	status		bit (32);
dcl	1 status_word	based (st_ptr),
	  2 status_left	bit (16),
	  2 status_right	bit (16);

dcl	st_ptr		ptr;

dcl	sarea		char (10000) based (sarea_ptr),
	ptr_array		(0:3000) ptr,
	(sarea_ptr, in_ptr) ptr,
	template		char (ln) based (sarea_ptr),
	in_record		char (ln) based (in_ptr),
	(ln, i, j, k, s, i_limit, jj)
			fixed bin;
dcl	no_diag		bit (1);
dcl	all_done		bit (1);

declare	(addr, divide, fixed, rel, string, index, mod, null)
			builtin;
declare	(substr, length)	builtin;

declare	ioa_$rs		entry options (variable);
declare	ioa_$rsnnl	entry options (variable);

dcl	dup		bit (1);
dcl	not_done		bit (1);
dcl	di		fixed bin;
dcl	dno_run_index	(8) fixed bin;
dcl	dno_count		fixed bin;
dcl	1 dno_element	(60),
	  2 dno		fixed bin,
	  2 dno_next	fixed bin;

dcl	elng_sw		bit (1);
dcl	reln_ptr		ptr;
dcl	code		fixed bin (35);
dcl	ioa_		entry options (variable);

dcl	pbuf_ptr		ptr;
dcl	pbuf_len		fixed bin;
dcl	ff_char		char (1) static options (constant) init ("");
dcl	multics_hdr	char (256);
dcl	multics_hdr_len	fixed bin;
dcl	cobol_version$header
			entry (char (*), fixed bin);
dcl	cobol_put_rec	entry (bit (32), ptr, fixed bin, ptr, fixed bin);
dcl	hcs_$fs_get_path_name
			entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
dcl	hcs_$fs_get_ref_name
			entry (ptr, fixed bin, char (*), fixed bin (35));
						/*[5.1-1]*/
dcl	include_ptr	(0:1000) ptr based (cobol_$include_info_ptr);
dcl	dirname		char (168),
	ename		char (32),
	rname		char (32),
	incl_line		char (150),
	incl_line_len	fixed bin,
	ldn		fixed bin;
dcl	incl_hdr		char (73) static init ("	INCLUDE FILES USED IN THIS COMPILATION.

  LINE	NUMBER	NAME				PATHNAME");



/*************************************/
/* INCLUDE FILES */
%include cobol_diag_file;
%include cobol_type5;
%include cobol_ext_;
%include cobol_;
%include cobol_sbh;
%include cobol_eln_table;
%include cobol_fixed_common;

     end cobol_print_diag;
  



		    cobol_proc_copy.pl1             05/24/89  1046.0rew 05/24/89  0835.5      120996



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_proc_copy.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 11/25/81 by FCH, [5.1-2], main prog added to include file table, BUG519(phx11818) */
/* Modified on 11/19/81 by FCH, [5.1-1], line number in source map incorrect, BUG519(phx11818) */
/* Modified on 04/09/80 by FCH, [4.2-2], fix problems with leveling diags */
/* Modified on 12/7/79 by MHD, [4.2-1], corrected leveling problems from validation */
/* Modified on 04/09/79 by FCH, [4.0-3], [3.0-2] wiped out */
/* Modified on 02/23/79 by FCH, [4.0-1], copy file name qualification */
/* Modified on 11/02/78 by RAL, [3.0-2], COPY REPLACING and REPLACE added for MR7.0 */
/* Modified 06/19/77 [3.0-1] by RAL to save include names for symbol table */
/* Modified since Version 3.0.     */





/* format: style3 */
cobol_proc_copy:
     proc;

/* ========================================================================== */
/*                                                                            */
/* This routine is intended to process the COPY verb and load the tables      */
/* with the replacement text.  After loading the tables with text, it will    */
/* cause the named library file to become active.                             */
/*                                                                            */
/* ========================================================================== */





start:
	fn_len = 0;
	ln_len = 0;

/* COPY processing */

/*[4.0-3]*/
	if reserved_word.key = 425			/* replace */
						/*[4.0-3]*/
	then do;
		if fixed_common.options.exp		/*[4.0-3]*/
		then do;
			if fixed_common.comp_level < "5"
						/*[4.2-2]*/
			then call diag (173, reserved_word.line, reserved_word.column);
						/*[4.0-3]*/
		     end;				/*[4.0-3]*/
		else call cobol_lexerr (35, "0"b, 0, " ");

/*[4.0-3]*/
		go to scan_off;			/*[4.0-3]*/
	     end;

/*[4.2-2]*/
	copy.line = reserved_word.line;		/* copy */
						/*[4.2-2]*/
	copy.col = reserved_word.column;

	if cobol_copy_active
	then do;
		call cobol_lexerr (7, "0"b, 0, " ");
		goto scan_off;
	     end;

	save_card = cobol_cards.name;
	save_clen = cobol_cards.column;
	cobol_stack_sw = "1"b;
	cobol_lu_sw = "0"b;				/* don't convert next word to upper case */
	substr (token.l_info, 3, 1) = "1"b;

	call cobol_gns1;

	substr (token.l_info, 3, 1) = "1"b;
	cobol_lu_sw = "1"b;

	if user_word.type ^= 8
	then do;					/* error - should be file name */
		call cobol_lexerr (10, "0"b, 0, " ");
		call cobol_lexerr (11, "0"b, 0, " ");

scan_off:
		do while ("1"b);			/*[4.0-3]*/
		     if reserved_word.type = 1	/*[4.0-3]*/
		     then do;
			     if reserved_word.key = 256
						/* == */
						/*[4.0-3]*/
			     then do while ("1"b);

/*[4.0-3]*/
				     substr (token.l_info, 3, 1) = "1"b;
						/*[4.0-3]*/
				     call cobol_gns;

/*[4.0-3]*/
				     if reserved_word.type = 1 & reserved_word.key = 256
						/* == */
						/*[4.0-3]*/
				     then go to scan_1;

/*[4.0-3]*/
				end;

/*[4.0-3]*/
			     else /*[4.0-3]*/
				if reserved_word.key = 189
						/* . */
						/*[4.0-3]*/
			     then do;
				     substr (token.l_info, 3, 1) = "1"b;
						/*[4.0-3]*/
				     cobol_stack_sw = "0"b;

/*[4.0-3]*/
				     return;	/*[4.0-3]*/
				end;		/*[4.0-3]*/
			end;

		     if user_word.type = 8
		     then if user_word.column < 12
			then do;			/* if period missing stop on procedure name */

				call cobol_lexerr (12, "0"b, 0, " ");

				cobol_stack_sw = "0"b;
				return;
			     end;
scan_1:
		     substr (token.l_info, 3, 1) = "1"b;

		     call cobol_gns;
		end;
	     end;

	fn_len = user_word.length;
	file_name = substr (user_word.word, 1, fn_len);

	call cobol_gns1;

	substr (token.l_info, 3, 1) = "1"b;

	if reserved_word.type = 1
	then if (reserved_word.key = 133) | (reserved_word.key = 101)
						/* OF or IN */
	     then do;				/* library file will be specified */

		     cobol_lu_sw = "0"b;		/* don't convert next word to upper case */

/*[4.2-2]*/
		     lib.line = reserved_word.line;	/*[4.2-2]*/
		     lib.col = reserved_word.column;

		     call cobol_gns1;

		     substr (token.l_info, 3, 1) = "1"b;
		     cobol_lu_sw = "1"b;

		     if user_word.type = 8
		     then do;			/* save pointer to name of library file */

			     lib_name = substr (user_word.word, 1, user_word.length);
			     ln_len = user_word.length;

			     call cobol_gns1;

			     substr (token.l_info, 3, 1) = "1"b;
			     goto ck_rep;
			end;

		     call cobol_lexerr (10, "0"b, 0, " ");
						/* error in library entry specification */
		     call cobol_lexerr (11, "0"b, 0, " ");

		     goto scan_off;
		end;				/*[4.0-1]*/
	     else lib_name = "";

ck_rep:						/*[4.2-1]*/
	if fixed_common.comp_level = "1"		/*[4.2-2]*/
	then call diag (64, copy.line, copy.col);	/* COPY statement */

/*[4.2-1]*/
	if fixed_common.comp_level < "4"		/*[4.2-1]*/
	then if lib_name ^= ""			/*[4.2-2]*/
	     then call diag (209, lib.line, lib.col);	/* library-name phrase */

/*[4.0-3]*/
	if reserved_word.type = 1 & reserved_word.key = 152
						/* replacing */
						/*[4.0-3]*/
	then do;
		if fixed_common.options.exp		/*[4.0-3]*/
		then if fixed_common.comp_level < "4"	/*[4.2-2]*/
		     then call diag (65, reserved_word.line, reserved_word.column);
						/* REPLACING phrase */
						/*[4.2-1]*/
		     else ;			/*[4.0-3]*/
		else call cobol_lexerr (36, "0"b, 0, " ");

/*[4.0-3]*/
		go to scan_off;			/*[4.0-3]*/
	     end;


/*[4.0-3]*/
	if fixed_common.options.exp
	then go to scan_off;

	if reserved_word.type = 1
	then if reserved_word.key = 189
	     then goto copy_ready;			/* then	if "." ... */

	call cobol_lexerr (14, "0"b, 1, ".");

	goto scan_off;

/* text portion of file built here */

copy_ready:
	if fn_len ^= 0
	then do;					/* we have a file to access */


/*[4.0-1]*/
		call expand_cobol_source$find_incl_file
		     /*[4.0-1]*/ (substr (file_name, 1, fn_len), lib_name, cobol_sfp, cobol_cfp, code);

		if code = 0 | code = error_table_$zero_length_seg
		then go to cpy_fnd;
		else go to copy_file_error;		/* abort */

cpy_fnd:
		call hcs_$fs_get_path_name (cobol_cfp, dir_name, ldn, entry_name, code);
						/* [3.0-1] */
		call cobol$push_name (dir_name, entry_name);
						/* [3.0-1] */

		cobol_$include_cnt = cobol_$include_cnt + 1;

		if cobol_$include_cnt > 1000
		then goto excess_copy_error;

/*[5.1-1]*/
		include_ptr (cobol_$include_cnt) = pointer (cobol_cfp, copy.line - cobol_merge$copy_line_count ());

		if cobol_cards.nr_char ^= 8
		then do;
			cobol_cards.nr_char = cobol_cards.nr_char - 1;
			substr (cobol_cards.name, cobol_cards.nr_char, 1) = cobol_new_line_character;

		     end;
		else cobol_cards.nr_char = cobol_cards.column;

		cobol_copy_found = "1"b;
		substr (token.l_info, 3, 1) = "1"b;

/*[5.1-1]*/
		call cobol_merge$incr_line_count;

	     end;
	else call cobol_lexerr (28, "0"b, 0, " ");

	cobol_stack_sw = "0"b;

	return;

/*======================================*/

declare	cobol_merge$copy_line_count
			entry returns (fixed bin);
declare	cobol_merge$incr_line_count
			entry;

dcl	cobol_c_list	entry (ptr);
dcl	lev_message_ptr	ptr;
dcl	1 lev_message	internal static,
	  2 size		fixed bin init (28),
	  2 line		fixed bin init (0),
	  2 column	fixed bin init (0),
	  2 type		fixed bin init (5),
	  2 run		fixed bin init (9),
	  2 number	fixed bin init (0),
	  2 info		bit (32) init ("0"b);

/*[4.2-2]*/
declare	1 lib,					/*[4.2-2]*/
	  2 line		fixed bin,		/*[4.2-2]*/
	  2 col		fixed bin;

/*[4.2-2]*/
declare	1 copy,					/*[4.2-2]*/
	  2 line		fixed bin,		/*[4.2-2]*/
	  2 col		fixed bin;

diag:
     proc (num, line, col);
dcl	(num, line, col)	fixed bin;

/*[4.0-3]*/
	lev_message.line = line;			/*[4.0-3]*/
	lev_message.column = col;
	lev_message.number = num;
	lev_message_ptr = addr (lev_message);

	call cobol_c_list (lev_message_ptr);

     end;

dcl	ioa_$rsnnl	entry options (variable);
dcl	signal_		entry (char (*), ptr, ptr);

copy_file_error:
	call ioa_$rsnnl ("COPY file ^a not found", error_info.message, error_info.message_len, file_name);
	go to abort;

excess_copy_error:
	call ioa_$rsnnl ("EXCESS 1000 copy files in a cobol program.", error_info.message, error_info.message_len);
	goto abort;

abort:
	error_info.name = "library";
	call signal_ ("command_abort_", null (), addr (error_info));
exit_abort:
	return;

/*   reserved_word    */
dcl	1 reserved_word	based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 1 */
	  2 key		fixed bin,
	  2 class		bit (26),
	  2 jump_index	fixed bin;

/*   alphanum_lit    */
dcl	1 alphanum_lit	based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 3 */
	  2 info		bit (8),
	  2 length	fixed bin,
	  2 string	char (200);

/*   user_word    */
dcl	1 user_word	based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 8 */
	  2 info		bit (8),
	  2 length	fixed bin,
	  2 word		char (30);

/*   message    */
dcl	1 message		based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 5 */
	  2 run		fixed bin,
	  2 number	fixed bin,
	  2 info		bit (8),
	  2 length	fixed bin,
	  2 image		char (200);

/*   general overlay for any token    */
dcl	1 token		based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin;

/*   general overlay for any replacement token    */
dcl	1 rtoken		based (rep_point),
	  2 chain		pointer,
	  2 back_link	pointer,
	  2 lev_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin;


/*   source    */
dcl	1 source		based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 6 */
	  2 info		bit (8),
	  2 length	fixed bin,
	  2 image		char (200);

dcl	1 source1		based (cobol_current),
	  2 fwd_link	ptr,
	  2 back_link	ptr,
	  2 rep_link	ptr,
	  2 l_info	bit (8),
	  2 size		fixed bin (17),
	  2 fill1		fixed bin (17),
	  2 fill		char (1),
	  2 sm		bit (1),
	  2 copy		bit (1),
	  2 sln		bit (22),
	  2 type		fixed bin (17);

/* save area for library file <-> source file transfer */
dcl	rep_point		pointer;

/*  replacement table */

dcl	n_c		char (200) based;		/*  source card images */
						/*[5.1-2]*/
dcl	include_ptr	(0:1000) ptr based (cobol_$include_info_ptr);


dcl	cobol_gns1	entry external;
dcl	find_include_file_$initiate_count
			entry (char (*), ptr, char (*), fixed bin (24), ptr, fixed bin (35));
dcl	error_table_$zero_length_seg
			fixed bin (35) ext;
dcl	code		fixed bin (35);
dcl	bc		fixed bin (24);
dcl	cobol_lexerr	entry (fixed bin, bit (1), fixed bin, char (50)) external;
dcl	cobol_gns		entry external;
dcl	cobol_insert_token	entry (fixed bin, fixed bin) external;
dcl	cobol_delete_tokens$unlnk
			entry (ptr) external;
dcl	cobol_allo_tm	entry (ptr, fixed bin) ext;

dcl	st		bit (32);
dcl	(pn_len, fn_len, ln_len, save_clen, i)
			fixed bin;
dcl	(file_name, lib_name)
			char (44);
dcl	pname		char (168) aligned;
dcl	pnb		char (pn_len) based (addr (pname));
dcl	get_wdir_		entry returns (char (168) aligned) ext;
dcl	p		pointer;
dcl	err		bit (1);
dcl	save_card		char (256) static;
dcl	fnb		char (fn_len) based (addr (file_name));
dcl	lnb		char (ln_len) based (addr (lib_name));

dcl	pointer		builtin;
dcl	addr		builtin;
dcl	null		builtin;
dcl	substr		builtin;


dcl	hcs_$fs_get_path_name
			entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
						/* [3.0-1] */
dcl	expand_cobol_source$find_incl_file
			entry (char (*), char (*), ptr, ptr, fixed bin (35));
						/*[4.0-1]*/
dcl	dir_name		char (168);		/* [3.0-1] */
dcl	ldn		fixed bin;		/* [3.0-1] */
dcl	entry_name	char (168);		/* [3.0-1] */
dcl	cobol$push_name	entry (char (168), char (168));
						/* [3.0-1] */



%include cobol_fixed_common;
%include cobol_error_info;
%include cobol_;
%include cobol_ext_lex;
%include cobol_ext_;

     end cobol_proc_copy;




		    cobol_proc_sort.pl1             05/24/89  1046.0rew 05/24/89  0835.5       51372



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_proc_sort.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* 6/16/77, FCH, fixed bin decls standardized */
/* Modified on 11/16/76 to set corst.s_info4 for merge (in conjunction with cobol_repl3 change) */
/* Modified since Version 2.0 */

/* format: style3 */
cobol_proc_sort:
     proc;

dcl	1 sio,
	  2 chain		char (5),
	  2 bsns		fixed bin,
	  2 bsn		char (30),
	  2 esns		fixed bin,
	  2 esn		char (30),
	  2 ssn		fixed bin,
	  2 sfns		fixed bin,
	  2 sfn		char (30),
	  2 io		bit (1),
	  2 bits,
	    3 pdsyn,
	      4 rel	bit (1),
	      4 ret	bit (1),
	    3 repl,
	      4 info_1	bit (1),
	      4 info_2	bit (1),
	      4 info_3	bit (1),
	      4 merge	bit (1),
	      4 info_5	bit (1);
dcl	1 sio_b		based (oe_ptr),
	  2 chain		char (5),
	  2 bsns		fixed bin,
	  2 bsn		char (30),
	  2 esns		fixed bin,
	  2 esn		char (30),
	  2 ssn		fixed bin,
	  2 sfns		fixed bin,
	  2 sfn		char (30),
	  2 io		bit (1),
	  2 bits,
	    3 pdsyn,
	      4 rel	bit (1),
	      4 ret	bit (1),
	    3 repl,
	      4 info_1	bit (1),
	      4 info_2	bit (1),
	      4 info_3	bit (1),
	      4 merge	bit (1),
	      4 info_5	bit (1);			/*   reserved_word    */
dcl	1 reserved_word	based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 1 */
	  2 key		fixed bin,
	  2 class		bit (26),
	  2 jump_index	fixed bin;		/*   user_word    */
dcl	1 user_word	based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 8 */
	  2 info		bit (8),
	  2 length	fixed bin,
	  2 word		char (30);
dcl	cobol_gns1	entry ext;
dcl	sio_t		char (125);
dcl	sio_tb		char (oe_len) based (oe_ptr);
dcl	(oe_key, ne_key)	char (5);
dcl	st		bit (32);
dcl	(oe_ptr, siot_ad)	ptr;
dcl	oe_len		fixed bin;
dcl	cobol_vdwf_sput	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;
dcl	cobol_vdwf_dget	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;
dcl	cobol_vdwf_dput	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;

dcl	addr		builtin;
dcl	substr		builtin;


/*************************************/

start:
	siot_ad = addr (sio_t);
	sio.chain = "00000";
	sio.bsns = 0;
	sio.esns = 0;
	sio.ssn = 0;
	string (sio.bits) = ""b;
	sio.bits.repl.merge = reserved_word.key = reswd_MERGE;

	call cobol_gns1;

	if user_word.type ^= 8
	then return;

	sio.sfns = user_word.length;
	sio.sfn = substr (user_word.word, 1, user_word.length);

get_io:
	call cobol_gns1;

get_io1:
	if reserved_word.type = 1
	then do;
		if reserved_word.key = reswd_INPUT
		then do;
			sio.io = "0"b;
			goto proc_com_ent;
		     end;

		if reserved_word.key = reswd_OUTPUT
		then do;
			sio.io = "1"b;
			goto proc_com_ent;
		     end;

		if substr (reserved_word.class, 4, 1) = "1"b
		then return;

/* if end of statement... */
	     end;

	if user_word.type = 8
	then if user_word.column < 12
	     then return;				/* if procedure name... */

	goto get_io;

proc_com_ent:
	call cobol_gns1;

	if reserved_word.type ^= 1
	then return;

	if reserved_word.key ^= reswd_PROCEDURE
	then return;

	call cobol_gns1;

	if reserved_word.type = 1
	then call cobol_gns1;			/* if IS... */

	if user_word.type ^= 8
	then return;

	sio.bsns = user_word.length;
	sio.bsn = substr (user_word.word, 1, user_word.length);
	sio.esns = user_word.length;
	sio.esn = substr (user_word.word, 1, user_word.length);

	call cobol_gns1;

	if reserved_word.type = 1
	then if reserved_word.key = reswd_THRU
	     then do;
		     call cobol_gns1;

		     if user_word.type ^= 8
		     then return;

		     sio.esns = user_word.length;
		     sio.esn = substr (user_word.word, 1, user_word.length);
		end;

	call cobol_vdwf_sput (cobol_cmfp, st, addr (sio), 119, ne_key);

	if sio.io = "0"b
	then do;

		if cobol_si_key = "00000"
		then do;
			fixed_common.sort_in_info = ne_key;
			cobol_si_key = ne_key;
			goto get_io1;
		     end;

		call cobol_vdwf_dget (cobol_cmfp, st, oe_ptr, oe_len, cobol_si_key);

		sio_t = sio_tb;
		siot_ad -> sio_b.chain = ne_key;

		call cobol_vdwf_dput (cobol_cmfp, st, siot_ad, oe_len, cobol_si_key);

		cobol_si_key = ne_key;
		goto get_io1;
	     end;

	if cobol_so_key = "00000"
	then do;
		fixed_common.sort_out_info = ne_key;
		cobol_so_key = ne_key;
		goto get_io1;
	     end;

	call cobol_vdwf_dget (cobol_cmfp, st, oe_ptr, oe_len, cobol_so_key);

	sio_t = sio_tb;
	siot_ad -> sio_b.chain = ne_key;

	call cobol_vdwf_dput (cobol_cmfp, st, siot_ad, oe_len, cobol_so_key);

	cobol_so_key = ne_key;

	goto get_io1;

%include cobol_fixed_common;
%include cobol_ext_;
%include cobol_ext_lex;
%include cobol_reswd_values;

     end cobol_proc_sort;




		    cobol_repl3.pl1                 05/24/89  1046.0rew 05/24/89  0835.4      388035



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_repl3.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 10/16/79 by MHD, [4.1-1], increase size of key66area to 200 pointers */
/* Modified on 10/16/78 by RAL, [3.0-1], alternate record keys for MR7.0 */
/* Modified on 10/07/77 by GM to fix check on  qualified search  keys */
/* Modified on 10/06/77 by FH  to prevent abort when search key not in table */
/* 9/19/77, FCH, leveling diags added */
/* Modified on 06/01/77 by GM to fix test on catalog name and additional catalog name.	*/
/* Modified on 03/01/77 by Bob Chang to fix the bug for deletion of name table  buffer.	*/
/* Modified on 02/24/77 by Bob Chang to fix the bug rename clause with qualification.	*/
/* Modified on 01/26/77 by ORN to eliminate name table buffer and process directly from name table */
/* Modified on 12/30/76 by ORN to correct bad diag for OCCURS DEP ON range error and clean up fixed bins */
/* Modified on 11/22/76 by ORN to set cobol_$same_sort_merge_proc when applicable */
/* Modified on 11/18/76 by ORN to eliminate cobol_version_unique include file */
/* Modified on 11/16/76 by ORN to distinguish between sort and merge in setting procname.repl_bits */
/* Modified since Version 2.0 */

/* format: style3 */
cobol_repl3:
     proc (mem_size, ntbuff_ptr);

/*  DECLARATIONS OF THE PARAMETERS  */


dcl	mem_size		fixed bin (24);		/*  contains the number of characters allocated to the replacement name table buffer 
		for this execution of replacement  (input)  */

dcl	ntbuff_ptr	ptr;			/*  contains a pointer to the buffer space used by replacement as
		the name table buffer.  (input)  */

dcl	(linage_ptr, name_ptr, ft_ptr, fkey_ptr)
			ptr;
dcl	com2_ptr		ptr;

/*  INTERNAL VARIABLES  */

dcl /*  pointers used in this procedure  */
	(ntptr, ntprevptr, ntshiftptr, ntendptr, auxptr1)
			ptr;

/*  STRING BASE TABLE  */
dcl	arrpntr		(512) ptr;

/*  name stack pointer table  */
dcl	ptrtable		(50) ptr;

dcl	hashno		fixed bin;
dcl	s		fixed bin (24);


dcl	work_ptr		ptr;
dcl	ntptr2		ptr;
dcl	odo_ptr		ptr;

/*  name table buffer  */
dcl	1 anarea		based (ntbuff_ptr),
	  2 dummy_ptr	ptr,
	  2 ntarea	char (64000);
dcl	1 tntarea		based (ntbuff_ptr),
	  2 dumm_ptr	ptr,
	  2 tarea		(64000) char (1);
dcl	1 bit_ntarea	based (ntbuff_ptr),
	  2 dummy_pntr	ptr,
	  2 ntarea_bits	bit (64000);

/*  DECLARATION OF EXTERNAL ENTRIES  */
dcl	ioa_		entry options (variable);	/* [3.0-1] */
dcl	cobol_usrwd	entry (ptr, fixed bin, ptr, fixed bin, ptr, bit (1), bit (1), bit (1), fixed bin, ptr);
dcl	(diag_no, diag_count, sectno, ln, counter, topstack)
			fixed bin;
dcl	(stackptr, stackbegptr)
			ptr;
dcl	(name_stack_overflow, too_many_qualifiers, was_found, not_found)
			bit (1);
dcl	cobol_replb	entry (ptr, ptr);

dcl	1 procname	based (ntptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 string_ptr	pointer,
	  2 prev_rec	pointer,
	  2 info1		bit (1),
	  2 info2		bit (1),
	  2 info3		bit (1),
	  2 info4		bit (1),
	  2 info5		bit (1),
	  2 info6		bit (1),
	  2 info7		bit (1),
	  2 info8		bit (1),
	  2 priority	char (2),
	  2 repl_bits	bit (8),
	  2 section_num	fixed bin,
	  2 proc_num	fixed bin,
	  2 def_line	fixed bin,
	  2 length	fixed bin,
	  2 name		char (30),
	1 data_name	based (ntptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 string_ptr	pointer,
	  2 prev_rec	pointer,
	  2 info1		bit (1),
	  2 info2		bit (1),
	  2 info3		bit (1),
	  2 info4		bit (5),
	  2 def_line	fixed bin,
	  2 level		fixed bin,
	  2 linkage	fixed bin,
	  2 file_num	fixed bin,
	  2 size_rtn	fixed bin,
	  2 length	fixed bin (24),
	  2 places_left	fixed bin,
	  2 places_right	fixed bin,
	  2 descr_bit	bit (64),
	  2 descr1	bit (8),
	  2 seg_num	fixed bin,
	  2 offset	fixed bin (24),
	  2 init_ptr	fixed bin,
	  2 edit_ptr	fixed bin,
	  2 occurs_ptr	fixed bin,
	  2 do_rec	char (5),
	  2 do_bit	bit (8),
	  2 max_red_size	fixed bin (24),
	  2 name_size	fixed bin,
	  2 name		char (30);




dcl	save_last_line	fixed bin;
dcl	save_last_column	fixed bin;
dcl	repla_abort	bit (1);

dcl	1 adiag		int static,
	  2 size		fixed bin init (28),
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin init (5),
	  2 run_number	fixed bin init (6),
	  2 diag_number	fixed bin,
	  2 info		bit (8) init ("00000000"b);
dcl	1 temp_fld	based (ntptr),
	  2 tempfld1	char (44),
	  2 temp_desc	char (40),
	  2 tempfld2	char (62);
dcl	curr_work		ptr;
dcl	stack		char (1000);
dcl	temp_stack	(1000) char (1) based (addr (stack));

dcl	addr		builtin;
dcl	addrel		builtin;
dcl	divide		builtin;
dcl	fixed		builtin;
dcl	mod		builtin;
dcl	null		builtin;
dcl	substr		builtin;
dcl	unspec		builtin;

dcl	(i, n, n1)	fixed bin;
dcl	bname		char (30);
dcl	cn1		char (4);
dcl	template		char (recsize) based (ntptr);
dcl	null_key		char (5) static options (constant) init ("00000");
dcl	cobol_c_list	entry (ptr);
dcl	cobol_read_ft_	entry (fixed bin, ptr);
dcl	continue		bit (1);			/* [3.0-1] */
dcl	type_two_sw	bit (1);			/* [3.0-1] */
dcl	file_desc_1_area	char (4200);		/* [3.0-1] */
dcl	1 file_info	based (fkey_ptr),		/* [3.0-1] */
	  2 fill1		char (16),
	  2 file_no	fixed bin,
	  2 type		fixed bin,
	  2 fill2		char (28),
	  2 size		fixed bin (24),
	  2 fill3		char (16),
	  2 seg_num	fixed bin,
	  2 offset	fixed bin (24);


/*************************************/
start:
	file_desc_1_ptr = addr (file_desc_1_area);	/* [3.0-1] */
	stackbegptr = addr (stack);
	mcobol = "1"b;
	mcobol_xref = fixed_common.options.xrn;
	if mcobol_xref
	then do;
		cobol_$xref_bypass = "0"b;
		token_count = 0;
		chain_count = 0;
	     end;

	if fixed_common.rename_info ^= null_key
	then call repl3a;				/* process renames */

	do i = 1 to 512;
	     arrpntr (i) = null ();
	end;
	ntprevptr = null ();
	status = ""b;
	do while (status = ""b);			/* until end of file */
	     call cobol_vdwf_sget (cobol_ext_$cobol_name_fileno_ptr, status, ntptr, recsize, key1);
	     if status = ""b
	     then do;
		     xref_ptr = addrel (ntptr, divide (recsize + 3, 4, 17, 0));
		     xref_ptr -> xref_chain.first = 0;
		     xref_ptr -> xref_chain.last = 0;
		     data_name.info1 = "0"b;
		     data_name.info2 = "0"b;
		     data_name.info3 = "0"b;
		     if procname.type ^= 7
		     then do;
			     data_name.info4 = "0"b;
			end;
		     else do;
			     procname.type = 18;
			     procname.repl_bits = "00000000"b;
			end;
		     n = size_TOKEN (procname.type) - 3;
		     if mcobol_xref
		     then do;
			     token_count = token_count + 1;
			     token_area.token_ptr (token_count) = ntptr;
			     token_area.name_ptr (token_count) = addrel (ntptr, divide (n, 4, 17, 0));
			end;			/* string name table entry */
		     cn1 = substr (template, n, 4);
		     n1 = fixed (unspec (cn1));
		     bname = substr (template, n + 4, n1);
		     hashno = 0;
		     do i = 1 to n1;
			hashno = hashno + fixed (unspec (substr (bname, i, 1)));
		     end;
		     hashno = mod (hashno, 512) + 1;
		     procname.string_ptr = arrpntr (hashno);
		     procname.prev_rec = ntprevptr;
		     arrpntr (hashno) = ntptr;
		     ntprevptr = ntptr;
		     ntptr = addrel (ntptr, divide (recsize + 11, 8, 17, 0) * 2);
		end;
	     else ntendptr = addrel (ntptr, divide (recsize + 11, 8, 17, 0) * 2);
	end;

	if fixed_common.linage_info ^= null_key
	then call repl3ln;				/* process linage info */
	if fixed_common.odo_info ^= null_key
	then call process_odo_keys;
	if fixed_common.file_keys ^= null_key
	then call process_file_keys;
	if fixed_common.search_keys ^= null_key
	then call repl3sk;
	if fixed_common.sort_in_info ^= null_key
	then call repl3s (fixed_common.sort_in_info, "1"b);
	if fixed_common.sort_out_info ^= null_key
	then call repl3s (fixed_common.sort_out_info, "0"b);

	call cobol_replb (ntendptr, addr (arrpntr (1)));

	return;

/*************************************/
repl3a:
     proc;
dcl	cm_ptr		ptr;
dcl	(key, next_key, prev_key)
			char (5);
dcl	1 auser_wd	based (stackptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 info_bit	bit (8),
	  2 length	fixed bin,
	  2 name		char (30);
dcl	rename_tempsize	fixed bin;
dcl	rename_tempname	char (30);
dcl	recsize2		fixed bin;
dcl	obj2_key		char (5);
dcl	(obj1_level, obj2_level, obj1_length, obj2_length, obj1_seg_num, obj1_offset, obj2_offset, obj1_name_size)
			fixed bin;
dcl	(obj1_init_ptr, obj1_edit_ptr, obj1_pleft, obj1_pright)
			fixed bin;
dcl	extension_bit	bit (1);
dcl	extension_size	fixed bin;
dcl	extension_temp	char (434);
dcl	n		fixed bin;
dcl	template		char (recsize) based (ntptr);
dcl	(obj1_descr_bit, obj2_descr_bit)
			bit (64);
dcl	obj1_flag		bit (1);
dcl	(obj1ptr, obj2ptr, rename_ptr)
			ptr;
dcl	key66_area	char (1000);		/*[4.1-1]*/
dcl	k66area		(1000) char (1) based (addr (key66_area));
dcl	keyvalue		char (5) based (key66ptr);
dcl	key66ptr		ptr;
dcl	n66		fixed bin;

	obj1_flag = "0"b;
	prev_key = null_key;			/* Get first rename_rec in common */
	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, cm_ptr, ln, fixed_common.rename_info);
la:
	com2_ptr = cm_ptr;
	next_key = rename_rec.next;
	key = rename_rec.rec_no_66;
	obj2_key = rename_rec.obj2;
	rename_tempsize = rename_rec.size;
	substr (rename_tempname, 1, rename_tempsize) = rename_rec.name;

/* Loading name_table buff */
	if key ^= prev_key
	then do;
		key66ptr = addr (key66_area);
		n66 = 1;
		call load_01_66;
	     end;

/* Get object_1 of the rename in common */

	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, cm_ptr, ln, rename_rec.obj1);
	obj1_flag = "1"b;
la1:
	counter = 0;
	topstack = 1;
	stackptr = stackbegptr;
	name_stack_overflow = "0"b;
	too_many_qualifiers = "0"b;
	com2_ptr = cm_ptr;
	auser_wd.length = obj_rec.size;
	substr (auser_wd.name, 1, auser_wd.length) = substr (obj_rec.name, 1, auser_wd.length);
	recsize2 = 24 + auser_wd.length;

/* push name into stack */

	call pushx;
	if obj_rec.qual = null_key
	then go to lb1;

/* Get qualifier of rename object in common */

	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, cm_ptr, ln, obj_rec.qual);
la2:
	com2_ptr = cm_ptr;
	stackptr = addr (temp_stack (topstack));
	auser_wd.length = qual_rec.size;
	substr (auser_wd.name, 1, auser_wd.length) = substr (qual_rec.name, 1, auser_wd.length);
	recsize2 = 24 + auser_wd.length;
	topstack = topstack + recsize2 + 8 - mod (recsize2, 8);
	counter = counter + 1;
	ptrtable (counter) = stackptr;
	if qual_rec.next = null_key
	then go to lb1;

/* Get next qualifier in common */

	call cobol_vdwf_sget (cobol_ext_$cobol_cmfp, status, cm_ptr, ln, qual_rec.next);
	go to la2;

lb1:						/* Look up object of rename in name table buff */
	call cobol_usrwd (addr (ptrtable (1)), counter, addr (arrpntr (1)), sectno, ntendptr, "0"b, was_found,
	     not_found, diag_no, ntptr2);
	if was_found
	then do;
		ntptr = ntptr2;
		if substr (data_name.descr_bit, 42, 1) | substr (data_name.descr1, 2, 1)
		then do;
			adiag.diag_number = 26;
			adiag.line = data_name.line;
			adiag.column = data_name.column;
			call issue_diag;
		     end;
		if obj1_flag
		then do;
			obj1_level = data_name.level;
			obj1_length = data_name.length;
			obj1_seg_num = data_name.seg_num;
			obj1_offset = data_name.offset;
			obj1_descr_bit = data_name.descr_bit;
			obj1_pleft = data_name.places_left;
			obj1_pright = data_name.places_right;
			if substr (data_name.descr_bit, 10, 1) & obj2_key = null_key
			then do;			/* only elementary item with init or edit extension needs  processing */
				if data_name.init_ptr ^= 0 | data_name.edit_ptr ^= 0
				then do;
					extension_bit = "1"b;
					obj1_name_size = data_name.name_size;
					obj1_init_ptr = data_name.init_ptr;
					obj1_edit_ptr = data_name.edit_ptr;
					if obj1_init_ptr ^= 0
					then do;
						extension_size = data_name.size - obj1_init_ptr;
						extension_temp =
						     substr (template, obj1_init_ptr, extension_size);
					     end;
					else do;
						extension_size = data_name.size - obj1_edit_ptr;
						extension_temp =
						     substr (template, obj1_edit_ptr, extension_size);
					     end;
				     end;
			     end;
		     end;
		else do;
			obj2_level = data_name.level;
			obj2_length = data_name.length;
			obj2_offset = data_name.offset;
			obj2_descr_bit = data_name.descr_bit;
		     end;
	     end;
	else do;
		if diag_no = 0
		then adiag.diag_number = 2;
		else adiag.diag_number = diag_no;
		adiag.line = obj_rec.line;
		adiag.column = obj_rec.column;
		call issue_diag;
	     end;
	if obj2_key = null_key
	then go to lc1;

/* Get object_2 of rename in common */

	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, cm_ptr, ln, obj2_key);
	obj2_key = null_key;
	obj1_flag = "0"b;
	go to la1;
lc1:
	counter = 0;
	topstack = 1;
	stackptr = stackbegptr;
	name_stack_overflow = "0"b;
	too_many_qualifiers = "0"b;
	auser_wd.length = rename_tempsize;
	substr (auser_wd.name, 1, rename_tempsize) = substr (rename_tempname, 1, rename_tempsize);
	recsize2 = 24 + auser_wd.length;
	call pushx;

/* Look up 66 in name table buff */

	call cobol_usrwd (addr (ptrtable (1)), counter, addr (arrpntr (1)), sectno, ntendptr, "0"b, was_found,
	     not_found, diag_no, ntptr2);
	if was_found
	then do;
		ntptr = ntptr2;
		if obj1_level = 01 | obj1_level > 49
		then do;
			adiag.diag_number = 27;
			adiag.line = data_name.line;
			adiag.column = data_name.column;
			call issue_diag;
		     end;
		if obj1_flag
		then do;
			data_name.length = obj1_length;
			data_name.seg_num = obj1_seg_num;
			data_name.offset = obj1_offset;
			data_name.descr_bit = obj1_descr_bit;
			data_name.places_left = obj1_pleft;
			data_name.places_right = obj1_pright;
			if extension_bit = "1"b
			then do;
				extension_bit = "0"b;
				n = size_TOKEN (9) + 1 + data_name.name_size;
				n = n + 4 - mod (n, 4);
				n = n + 1;
				if obj1_init_ptr ^= 0
				then data_name.init_ptr = n;
				if obj1_edit_ptr ^= 0
				then data_name.edit_ptr = n;
				substr (template, n, extension_size) = substr (extension_temp, 1, extension_size);
			     end;
		     end;
		else do;
			if obj2_level = 01 | obj2_level > 49
			then do;
				adiag.diag_number = 27;
s_diag:
				adiag.line = data_name.line;
				adiag.column = data_name.column;
				call issue_diag;
				go to s_exit;
			     end;
			if obj1_offset ^< obj2_offset
			then do;

				adiag.diag_number = 28;
				go to s_diag;
			     end;
			data_name.seg_num = obj1_seg_num;
			data_name.offset = obj1_offset;
			data_name.length = obj2_offset - obj1_offset + obj2_length;
			substr (data_name.descr_bit, 1, 6) = substr (obj1_descr_bit, 1, 6);
			substr (data_name.descr_bit, 9, 1) = "1"b;
			substr (data_name.descr_bit, 20, 1) = "1"b;
s_exit:
		     end;
	     end;
	else do;
		if diag_no = 0
		then adiag.diag_number = 2;
		else adiag.diag_number = diag_no;
		adiag.line = data_name.line;
		adiag.column = data_name.column;
		call issue_diag;
		obj1_flag = "0"b;
		go to s_recover;
	     end;
	recsize = data_name.size;
	call cobol_vdwf_dput (cobol_ext_$cobol_name_fileno_ptr, status, ntptr, recsize, keyvalue);
s_recover:
	n66 = n66 + 5;
	key66ptr = addr (k66area (n66));
	if next_key = null_key
	then go to lc2;
	prev_key = key;

/* Get next rename in  common */

	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, cm_ptr, ln, next_key);
	go to la;
lc2:
	call cobol_vdwf_close (cobol_ext_$cobol_name_fileno_ptr, status, ntptr, 0);
	call cobol_vdwf_open (cobol_ext_$cobol_name_fileno_ptr, status);

/* Clear the name table buffer area if mcobol_xref, so cross-reference info
	   at end of each name table buffer entry will initially be zero. */

	if mcobol_xref
	then substr (ntarea_bits, 1, 9 * s) = "0"b;

	return;
pushx:
     proc;
	stackptr = addr (temp_stack (topstack));
	topstack = topstack + recsize2 + 8 - mod (recsize2, 8);
	counter = counter + 1;
	ptrtable (counter) = stackptr;
     end pushx;

load_01_66:
     proc;
dcl	template		char (recsize) based (ntptr),
	newrecord		char (recsize) based (ptr1),
	(i, n, n1, n2)	fixed bin,
	bname		char (30),
	levlim		fixed bin,
	tb_counter	fixed bin,
	ptr1		ptr,
	flag_66		bit (1);

	flag_66 = "0"b;
	s = 1;
	do i = 1 to 512;
	     arrpntr (i) = null ();
	end;

	ntptr = addr (ntarea);
	ntprevptr = null ();
	ntshiftptr = ntptr;
l2:
	call cobol_vdwf_dget (cobol_ext_$cobol_name_fileno_ptr, status, ntptr, recsize, key);

l3:						/* stringnt */
	n = size_TOKEN (procname.type) - 3;
	cn1 = substr (template, n, 4);
	n1 = fixed (unspec (cn1), 15);

	bname = substr (template, n + 4, n1);

	hashno = 0;
	do i = 1 to n1;
	     hashno = hashno + fixed (unspec (substr (bname, i, 1)), 15);
	end;
	hashno = mod (hashno, 512) + 1;
	procname.string_ptr = arrpntr (hashno);
	procname.prev_rec = ntprevptr;
	ntprevptr = ntptr;
	arrpntr (hashno) = ntptr;
	levlim = data_name.level;
	if levlim = 66
	then do;
		flag_66 = "1"b;
		key66ptr = addr (k66area (n66));
		keyvalue = key1;
		n66 = n66 + 5;
	     end;					/* stringnt */
	call cobol_vdwf_sget (cobol_ext_$cobol_name_fileno_ptr, status, ntptr, recsize, key1);
	if status ^= "0"b
	then go to finish_up;

	if flag_66
	then do;
		if levlim ^= 66
		then go to finish_up;
	     end;
	go to l3;
finish_up:
	ntendptr = addrel (ntptr, divide (recsize + 11, 8, 17, 0) * 2);
	ntptr = addr (ntarea);
end1:
	key66ptr = addr (key66_area);
	n66 = 1;
	return;
     end load_01_66;
     end repl3a;


/* This procedure processes sort information */

repl3s:
     proc (sort_info_key, input_proc);

dcl	sort_info_key	char (5);
dcl	input_proc	bit (1);
dcl	sortnext		char (5);
dcl	start_name	char (30);
dcl	fill_sort_info	bit (1);
dcl	not_done		bit (1);
dcl	stop_sec_num	fixed bin;
dcl	template		(200) char (1) based (work_ptr);
dcl	snamearea		char (56);
dcl	srtptr		ptr;
dcl	1 srtname		based (srtptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 bit8		bit (8),
	  2 slength	fixed bin,
	  2 sname		char (30);

	srtptr = addr (snamearea);
	ptrtable (1) = srtptr;
	sortnext = sort_info_key;
	do while (sortnext ^= null_key);
	     call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, sortnext);
	     sortnext = s_ptr;
	     fill_sort_info = ^(s_info1 & s_info2);
	     work_ptr = addr (ntarea);		/* Set work ptr to start of name table buffer. */
	     start_name = " ";
	     stop_sec_num = 32767;			/* phoney high value */
	     if ^s_info1
	     then do;				/* Process start section name. */
		     slength = s_start_size;
		     sname = substr (s_start, 1, slength);
		     start_name = sname;
		     call cobol_usrwd (addr (ptrtable (1)), 1, addr (arrpntr (1)), 0, ntendptr, "1"b, was_found,
			not_found, diag_no, ntptr);
		     if was_found
		     then do;
			     s_info1 = "1"b;
			     work_ptr = ntptr;	/* Set work ptr to start section entry in name table. */
			     s_start_size = procname.section_num;
			end;
		end;
	     if ^s_info2
	     then do;				/* Process stop section name */
		     if s_stop_size = 0
		     then do;
			     s_info2 = "1"b;
			     stop_sec_num = s_start_size;
			end;
		     else do;
			     slength = s_stop_size;
			     sname = substr (s_stop, 1, slength);
			     if sname = start_name
			     then do;
				     s_info2 = "1"b;
				     s_stop_size = s_start_size;
				     stop_sec_num = s_start_size;
				end;
			     else do;
				     call cobol_usrwd (addr (ptrtable (1)), 1, addr (arrpntr (1)), 0, ntendptr,
					"1"b, was_found, not_found, diag_no, ntptr);
				     if was_found
				     then do;
					     s_info2 = "1"b;
					     s_stop_size = procname.section_num;
					     stop_sec_num = s_stop_size;
					end;
				end;
			end;
		end;
	     if ^s_info3
	     then do;				/* Process sort file name. */
		     slength = s_srtfilename_size;
		     sname = substr (s_srtfilename, 1, slength);
		     call cobol_usrwd (addr (ptrtable (1)), 1, addr (arrpntr (1)), 0, ntendptr, "0"b, was_found,
			not_found, diag_no, ntptr);
		     if was_found
		     then do;
			     s_info3 = "1"b;
			     s_srtfilename_size = ntptr -> fd_token.file_no;
			end;
		end;
	     if fill_sort_info
	     then do;
		     not_done = "1"b;
		     do while (not_done);
			if work_ptr -> procname.section_num >= s_start_size
			then do;
				if s_info4
				then substr (work_ptr -> procname.repl_bits, 4, 1) = "1"b;
						/* MERGE */
				else substr (work_ptr -> procname.repl_bits, 1, 1) = "1"b;
						/*-11/16/76-*/
				if input_proc
				then substr (work_ptr -> procname.repl_bits, 2, 1) = "1"b;
				else do;
					substr (work_ptr -> procname.repl_bits, 3, 1) = "1"b;
					if substr (work_ptr -> procname.repl_bits, 1, 1)
					     & substr (work_ptr -> procname.repl_bits, 4, 1)
					then cobol_$same_sort_merge_proc = "1"b;
				     end;
			     end;
			work_ptr = addrel (work_ptr, divide (work_ptr -> procname.size + 11, 8, 17, 0) * 2);
			if work_ptr = ntendptr
			then not_done = "0"b;
			else if work_ptr -> procname.type ^= 18
			then not_done = "0"b;
			else if work_ptr -> procname.section_num > stop_sec_num
			then not_done = "0"b;
		     end;
		end;
	end;

     end repl3s;

repl3sk:
     proc;					/* process search keys */

dcl	skptr		ptr;
dcl	recsize2		fixed bin;
dcl	1 auser_wd	based (stackptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 info_bit	bit (8),
	  2 length	fixed bin,
	  2 name		char (30);
dcl	(nextsk, nextocc)	char (5);
dcl	(save_line, save_column)
			fixed bin;
dcl	template		(200) char (1) based (work_ptr);

/* get  search_keys in common */

	nextocc = search_keys;
sklop:
	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, nextocc);
	nextocc = occ_key.next;
	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, occ_key.first_key);

skloop:
	counter = 0;
	topstack = 1;
	stackptr = stackbegptr;
	name_stack_overflow = "0"b;
	too_many_qualifiers = "0"b;
	save_line = skey_rec.ref_line;
	save_column = skey_rec.ref_column;
	auser_wd.length = skey_rec.size;
	substr (auser_wd.name, 1, auser_wd.length) = substr (skey_rec.name, 1, auser_wd.length);
	recsize2 = 24 + auser_wd.length;
	nextsk = skey_rec.next;



	counter = counter + 1;
	ptrtable (counter) = stackptr;
	topstack = topstack + recsize2 + 8 - mod (recsize2, 8);
	stackptr = addr (temp_stack (topstack));


skloop1:
	if skey_rec.qual = null_key
	then go to skloop3;
	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, skey_rec.qual);


skloop2:
	auser_wd.length = qual_rec.size;
	substr (auser_wd.name, 1, auser_wd.length) = substr (qual_rec.name, 1, auser_wd.length);
	recsize2 = 24 + auser_wd.length;
	counter = counter + 1;
	ptrtable (counter) = stackptr;
	topstack = topstack + recsize2 + 8 - mod (recsize2, 8);
	stackptr = addr (temp_stack (topstack));


	if qual_rec.next = null_key
	then go to skloop3;


	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, qual_rec.next);
	go to skloop2;


skloop3:
	call cobol_usrwd (addr (ptrtable (1)), counter, addr (arrpntr (1)), sectno, ntendptr, "0"b, was_found,
	     not_found, diag_no, skptr);


	if was_found
	then do;
		if substr (skey_rec.info, 1, 1)
		then do;
			adiag.diag_number = 1;
			adiag.line = save_line;
			adiag.column = save_column;
			call issue_diag;
			go to skloop4;
		     end;
		substr (skey_rec.info, 1, 1) = "1"b;
		ntptr = skptr;
		if asc_dsc = 1
		then substr (data_name.descr_bit, 44, 1) = "1"b;
		else substr (data_name.descr_bit, 45, 1) = "1"b;
						/* later need to test if both bits are on and issue warning diag */

		work_ptr = ntptr;
		if data_name.occurs_ptr ^= 0
		then do;
			work_ptr = addr (template (data_name.occurs_ptr));
			work_ptr -> occurs.key_number = skey_rec.key_number;
		     end;
	     end;
	else do;
		if substr (skey_rec.info, 1, 1)
		then go to skloop4;

		if not_found
		then adiag.diag_number = 2;
		else adiag.diag_number = diag_no;
		adiag.line = save_line;
		adiag.column = save_column;
		call issue_diag;
	     end;

skloop4:
	if nextsk = null_key
	then go to skexit;

	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, nextsk);


	go to skloop;

skexit:
	if nextocc ^= null_key
	then go to sklop;

	return;
     end repl3sk;
repl3ln:
     proc;					/* this procedure process linage info */
dcl	1 linage_temp	based (work_ptr),
	  2 body		fixed bin,
	  2 footing	fixed bin,
	  2 top		fixed bin,
	  2 bottom	fixed bin,
	  2 body_int	fixed bin,
	  2 footing_int	fixed bin,
	  2 top_int	fixed bin,
	  2 bottom_int	fixed bin,
	  2 body_name	char (5),
	  2 footing_name	char (5),
	  2 top_name	char (5),
	  2 bottom_name	char (5),
	  2 name_count	fixed bin,
	  2 gen_seg	fixed bin,
	  2 gen_offset	fixed bin (24),
	  2 name_desc	(name_count) char (40);
dcl	1 auser_wd	based (lname_ptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 bit8		bit (8),
	  2 length	fixed bin,
	  2 name		char (30);
dcl	lnamearea		char (56);
dcl	(lname_ptr, ntptrln, linage_ptr)
			ptr;
dcl	(save_desc, save_line, save_column)
			fixed bin;
dcl	ln		fixed bin;
dcl	cur_fileno	fixed bin;
dcl	nextln		char (5);
dcl	outkey		char (5);
dcl	temp_in		char (200) based (linage_ptr);
dcl	template		char (200);


	work_ptr = addr (template);
	lname_ptr = addr (lnamearea);
	ptrtable (1) = lname_ptr;


/* get first linage_name_rec in common */

	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, fixed_common.linage_info);
	nextln = linage_name_rec.next;
	cur_fileno = linage_name_rec.fileno;
	save_desc = linage_name_rec.desc;
	save_line = linage_name_rec.line;
	save_column = linage_name_rec.column;
	auser_wd.length = linage_name_rec.size;
	auser_wd.name = linage_name_rec.name;


/* get file table */

lloop:
	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, ft_ptr, recsize, filedescr_offsets (cur_fileno));


/* get linage_info of this file */


	outkey = file_table.linage_info;

	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, linage_ptr, ln, file_table.linage_info);

	template = temp_in;

lloop1:
	call cobol_usrwd (addr (ptrtable (1)), 1, addr (arrpntr (1)), sectno, ntendptr, "0"b, was_found, not_found,
	     diag_no, ntptrln);
	if was_found
	then do;
		ntptr = ntptrln;
		if save_desc = 1
		then linage_temp.name_desc (1) = temp_fld.temp_desc;
		else if save_desc = 2
		then linage_temp.name_desc (linage_temp.footing) = temp_fld.temp_desc;
		else if save_desc = 3
		then linage_temp.name_desc (linage_temp.top) = temp_fld.temp_desc;
		else linage_temp.name_desc (linage_temp.bottom) = temp_fld.temp_desc;
		go to lloop2;
	     end;
	else do;
		if not_found
		then adiag.diag_number = fatal_DATANAME_NOT_DECLARED;
		else adiag.diag_number = diag_no;
		adiag.line = save_line;
		adiag.column = save_column;
		call issue_diag;
	     end;
lloop2:
	if nextln ^= null_key
	then do;
		call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, nextln);
		nextln = linage_name_rec.next;
		save_desc = linage_name_rec.desc;
		save_line = linage_name_rec.line;
		save_column = linage_name_rec.column;
		auser_wd.length = linage_name_rec.size;
		auser_wd.name = linage_name_rec.name;
		if linage_name_rec.fileno = cur_fileno
		then go to lloop1;
		cur_fileno = linage_name_rec.fileno;
		call cobol_vdwf_dput (cobol_ext_$cobol_cmfp, status, work_ptr, ln, outkey);
		go to lloop;
	     end;
	call cobol_vdwf_dput (cobol_ext_$cobol_cmfp, status, work_ptr, ln, outkey);
	return;
     end repl3ln;

/*********************************************************/
process_keys:
     proc;
	return;

dcl	1 qual_rec1	based (com2_ptr),
	  2 next		char (5),
	  2 size		fixed bin,
	  2 name		char (30);
dcl	odo_ptr		ptr;
dcl	dn_ptr		ptr;
dcl	1 dn_key		based (addr (dn_ptr)),
	  2 fill		char (4),
	  2 keychars	char (2);
dcl	key		char (5);
dcl	qual_key		char (5);
dcl	1 auser_wd	based (stackptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 info_bit	bit (8),
	  2 length	fixed bin,
	  2 name		char (30);

/*************************************/
process_file_keys:
     entry;					/* PROCESS FILE KEYS */

	key = fixed_common.file_keys;
	file_desc_1.alt_key_count = 0;		/* [3.0-1] */
	type_two_sw = "0"b;				/* [3.0-1] */
	do while (key ^= null_key);
	     call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, fkey_ptr, recsize, key);
	     if file_key.key_type < 100
	     then do;				/* non-literal key */
		     counter = 0;
		     stackptr = stackbegptr;
		     auser_wd.line = file_key.line;
		     auser_wd.column = file_key.column;
		     auser_wd.length = file_key.name_size;
		     auser_wd.name = file_key.name;
		     call push;
		     qual_key = file_key.qual;
		     do while (qual_key ^= null_key);
			call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, qual_key);
			auser_wd.length = qual_rec1.size;
			auser_wd.name = qual_rec1.name;
			call push;
			qual_key = qual_rec.next;
		     end;

		     call find;
		     if was_found
		     then do;
			     if data_name.type ^= 9
			     then call put (fatal_DATANAME_EXPECTED);
			     else do;
				     file_key.desc = dn_ptr -> temp_fld.temp_desc;
				     call check_dataname;
				     if file_key.key_type = 1
				     then do;	/* relative key */
					     call check_cnst_com_rprt_section;
					     call check_integer;
					     if data_name.file_num = file_key.file_no
					     then do;
						     call put (obs_KEY_NOT_IN_RECORD);

						     if fixed_common.comp_level < "5"
						     then call lev_diag (56);

						end;

					end;
				     else if file_key.key_type = 2 /* record key */ | file_key.key_type = 5
				     then do;	/* alternate record key */
					     call check_cnst_com_rprt_section;
					     if ^data_name.alphanum
					     then call put (warn_DATANAME_NOT_ALPHANUM);
						/*[3.0-1]*/
					     call cobol_read_ft_ (file_key.file_no, ft_ptr);
					     if data_name.file_num ^= file_key.file_no
						/*[3.0-1]*/
					     then do;
						/*[3.0-1]*/
						     if file_table.alternate_keys = 0
						/*[3.0-1]*/
						     then call put (obs_KEY_NOT_IN_RECORD);
						/*[3.0-1]*/
						     else call put (fatal_KEY_NOT_IN_RECORD);

						     if fixed_common.comp_level < "5"
						     then call lev_diag (58);

						end;



					     call build_file_desc (dn_ptr);
						/* [3.0-1] */

					end;
				     else if file_key.key_type = 3
				     then do;	/* file status key 1-2 */
					     if data_name.file_section
					     then call put (warn_ITEM_IN_FILE_SECTION);
					     else call check_cnst_com_rprt_section;
					     if data_name.item_length ^= 2 | ^data_name.alphanum
					     then call put (warn_BAD_STATUS_KEY);
					end;
				     else if file_key.key_type = 4 /* file status key 3 */ | file_key.key_type = 6
				     then do;	/* record contains key */
					     call check_cnst_com_rprt_section;
					     call check_integer;
					end;
				     else if file_key.key_type = 7 /* catalogue name */ | file_key.key_type = 12
				     then do;	/* additional catalogue name */
					     call cobol_read_ft_ (file_key.file_no, ft_ptr);
					     if file_table.device = 5
					     then do;
						/* tape */
						     if (^data_name.alphanum & ^data_name.numeric)
							| data_name.item_length > 6
						     then call put (warn_BAD_TAPE_CATALOG_NAME);
						end;
					     else do;
						     if ^data_name.alphanum | data_name.item_length > 200
						     then call put (warn_BAD_CATALOG_NAME);
						end;
					end;
				     else if file_key.key_type = 8
				     then do;	/* attach-options */
					     if ^data_name.alphanum | data_name.item_length > 256
					     then call put (warn_BAD_ATTACH_OPTIONS);
					end;
				     else if file_key.key_type = 9 /* tape replacement name */
					| file_key.key_type = 13
				     then do;	/* value of id name */
					     if ^data_name.alphanum | data_name.item_length > 17
					     then call put (warn_BAD_VALUE_OF_ID);
					end;
				     else if file_key.key_type = 10
				     then do;	/* device */
					     call check_integer;
					end;
				     else if file_key.key_type = 14
				     then do;	/* value of retention */
					     if data_name.item_length > 3
					     then call put (warn_BAD_VALUE_OF_RETENTION);
					     else call check_integer;
					end;
				end;
			end;
		end;				/* file_key.key_type < 100 */
	     key = file_key.next;
	end;
	return;

/************************************/
process_odo_keys:
     entry;					/* PROCESS OCCURS DEPENDING ON KEYS */

	key = fixed_common.odo_info;
	do while (key ^= null_key);
	     call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, odo_ptr, recsize, key);
	     call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, ln, odo_ptr -> odo_rec.descr);
	     counter = 0;
	     stackptr = stackbegptr;
	     auser_wd.line = obj_rec.line;
	     auser_wd.column = obj_rec.column;
	     auser_wd.length = obj_rec.size;
	     substr (auser_wd.name, 1, auser_wd.length) = substr (obj_rec.name, 1, auser_wd.length);
	     call push;
	     qual_key = obj_rec.qual;
	     do while (qual_key ^= null_key);
		call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, ln, qual_key);
		auser_wd.line = qual_rec.line;
		auser_wd.column = qual_rec.column;
		auser_wd.length = qual_rec.size;
		substr (auser_wd.name, 1, auser_wd.length) = substr (qual_rec.name, 1, auser_wd.length);
		call push;
		qual_key = qual_rec.next;
	     end;

	     call find;
	     if was_found
	     then do;
		     if data_name.type ^= 9
		     then call put (fatal_DATANAME_EXPECTED);
		     else do;
			     odo_ptr -> odo_rec.descr = "  " || dn_key.keychars;
						/* design change for SEARCH */
			     call check_dataname;
			     call check_integer;
			     if data_name.seg_num = 2
			     then do;
				     if data_name.offset <= odo_ptr -> odo_rec.offset_r
					& data_name.offset + data_name.item_length > odo_ptr -> odo_rec.offset_l
				     then call put (warn_ODO_RANGE);
				end;
			     else if data_name.constant_section
			     then call put (warn_CONSTANT_ILLOGICAL);
			end;
		end;
	     key = odo_ptr -> odo_rec.next;
	end;
	return;

/*************************************/
/* INTERNAL PROCEDURES */

push:
     proc;
	counter = counter + 1;
	ptrtable (counter) = stackptr;
	stackptr = addrel (stackptr, divide (size_TOKEN (8) + 11 + auser_wd.length, 8, 17, 0) * 2);
	return;
     end push;

find:
     proc;
	call cobol_usrwd (addr (ptrtable (1)), counter, addr (arrpntr (1)), 0, ntendptr, "0"b, was_found, not_found,
	     diag_no, dn_ptr);
	if ^was_found
	then if not_found
	     then call put (fatal_DATANAME_NOT_DECLARED);
	     else call put (fixed (diag_no));
	return;
     end find;

put:
     proc (diag);
dcl	diag		fixed bin;
	adiag.diag_number = diag;
	adiag.line = stackbegptr -> auser_wd.line;
	adiag.column = stackbegptr -> auser_wd.column;
	call cobol_c_list (addr (adiag));
	return;
     end put;

check_dataname:
     proc;
	if data_name.subscripted
	then call put (fatal_DATANAME_SUBSCRIPTED);
	if data_name.variable_length
	then call put (warn_DATANAME_VARLEN);
     end check_dataname;
check_integer:
     proc;
	if ^data_name.numeric
	then call put (fatal_DATANAME_NOT_NUMERIC);
	else if ^data_name.pic_integer | data_name.sign_type ^= ""b
	then call put (warn_DATANAME_NOT_INTEGER);
     end check_integer;
check_cnst_com_rprt_section:
     proc;
	if data_name.constant_section
	then call put (fatal_ITEM_IN_CONSTANT_SECTION);
	else if data_name.communication_section
	then call put (fatal_ITEM_IN_COM_SECTION);
	else if data_name.report_section
	then call put (fatal_ITEM_IN_REPORT_SECTION);
     end check_cnst_com_rprt_section;

/*************************************************/
build_file_desc:
     proc (data_name_ptr);				/* [3.0-1] */
						/*[]*/
						/*[]*/
dcl	data_name_ptr	ptr;			/*[]*/
dcl	word_offset	fixed bin (24),
	i		fixed bin;		/*[]*/
dcl	cobol_pool_	entry (char (*), fixed bin, fixed bin (24));
						/*[]*/
						/*[]*/
	if file_key.key_type = 2			/*[]*/
	then do;					/*[]*/
		type_two_sw = "1"b;			/*[]*/
		file_desc_1.type = 1;		/* always set to 1 */
						/*[]*/
		file_desc_1.prime_key.size = file_info.size;
						/*[]*/
		file_desc_1.prime_key.offset = get_rel_offset (file_info.offset, data_name_ptr);
						/*[]*/
		if file_table.alternate_keys = 0 /*[]*/ | /*[]*/ file_table.alternate_keys = file_desc_1.alt_key_count
						/*[]*/
		then do;				/*[]*/
			call cobol_pool_ (substr (file_desc_1_area, 1, (16 + (file_desc_1.alt_key_count * 8))), 2,
			     word_offset);		/*[]*/
			file_table.file_desc_1_offset = word_offset;
						/*[]*/
			type_two_sw = "0"b;		/*[]*/
			if file_desc_1.alt_key_count > 0
						/*[]*/
			then call check_dup_offset (data_name_ptr);
						/*[]*/
			file_desc_1.alt_key_count = 0;/*[]*/
		     end;				/*[]*/
	     end;					/*[]*/
	else if file_key.key_type = 5			/*[]*/
	then do;					/*[]*/
		file_desc_1.alt_key_count = file_desc_1.alt_key_count + 1;
						/*[]*/
		i = file_table.alternate_keys - file_desc_1.alt_key_count + 1;
						/*[]*/
		file_desc_1.alt_key (i).size = file_info.size;
						/*[]*/
		file_desc_1.alt_key (i).offset = get_rel_offset (file_info.offset, data_name_ptr);
						/*[]*/
		if file_key.duplicates		/*[]*/
		then file_desc_1.alt_key (i).size = file_desc_1.alt_key (i).size * -1;
						/*[]*/
						/*[]*/
		if type_two_sw /*[]*/ & /*[]*/ file_table.alternate_keys = file_desc_1.alt_key_count
						/*[]				Last alternate record key: write table to constants section. */
						/*[]*/
		then do;				/*[]*/
			call cobol_pool_ (substr (file_desc_1_area, 1, (16 + (file_desc_1.alt_key_count * 8))), 2,
			     word_offset);		/*[]*/
			file_table.file_desc_1_offset = word_offset;
						/*[]*/
			call check_dup_offset (data_name_ptr);
						/*[]*/
			type_two_sw = "0"b;		/*[]*/
			file_desc_1.alt_key_count = 0;/*[]*/
		     end;				/*[]*/
	     end;					/*[]*/
	return;					/*[]*/
     end build_file_desc;

check_dup_offset:
     proc (data_name_ptr);				/* [3.0-1] */
						/*[]*/
						/*[]*/
dcl	(j, jj)		fixed bin;		/*[]*/
dcl	data_name_ptr	ptr;			/*[]*/
						/*[]*/
						/* Check prime record key against alternates. */
						/*[]*/
						/*[]*/
	do j = 1 to file_desc_1.alt_key_count;		/*[]*/
	     if file_desc_1.prime_key.offset = file_desc_1.alt_key (j).offset
						/*[]*/
	     then do;				/*[]*/
		     call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, fkey_ptr, recsize, file_table.r_key_info);
						/*[]*/
		     adiag.diag_number = fatal_SAME_RECORD_OFFSET;
						/*[]*/
		     adiag.line = file_key.line;	/*[]*/
		     adiag.column = file_key.column;	/*[]*/
		     call cobol_c_list (addr (adiag));	/*[]*/
		     call put_dup_offset_diag (file_desc_1.prime_key.offset, data_name_ptr);
						/*[]*/
		     go to check_alts;		/*[]*/
		end;				/*[]*/
	end;					/*[]*/
						/*[]*/
check_alts:					/*[]*/
						/*[]*/
						/* Check alternate records keys against alterrnates.  */
						/*[]*/
	do j = 1 to (file_desc_1.alt_key_count - 1);	/*[]*/
	     do jj = (j + 1) to file_desc_1.alt_key_count;/*[]*/
		if file_desc_1.alt_key (j).offset = file_desc_1.alt_key (jj).offset
						/*[]*/
						/*[]*/
		then do;				/*[]*/
			call put_dup_offset_diag (file_desc_1.alt_key (j).offset, data_name_ptr);
						/*[]*/
			return;			/*[]*/
		     end;				/*[]*/
	     end;					/*[]*/
	end;					/*[]*/
     end check_dup_offset;

put_dup_offset_diag:
     proc (dup_offset, data_name_ptr);			/* [3.0-1] */
						/*[]*/
						/*[]*/
dcl	dup_offset	fixed bin;		/*[]*/
dcl	data_name_ptr	ptr;			/*[]*/
						/*[]*/
	key = file_table.alt_key_info;		/*[]*/
	do while (key ^= null_key);			/*[]*/
	     call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, fkey_ptr, recsize, key);
						/*[]*/
						/*[]*/
	     if get_rel_offset (file_info.offset, data_name_ptr) = dup_offset
						/*[]*/
	     then do;
		     adiag.diag_number = fatal_SAME_RECORD_OFFSET;
						/*[]*/
		     adiag.line = file_key.line;	/*[]*/
		     adiag.column = file_key.column;	/*[]*/
		     call cobol_c_list (addr (adiag));	/*[]*/
		end;				/*[]*/
	     key = file_key.next_alt;			/*[]*/
	end;					/*[]*/
     end put_dup_offset_diag;


get_rel_offset:
     proc (input_offset, data_name_ptr) /* [3.0-1] */ /*[]*/ returns (fixed bin (24));
						/*[]*/
						/*[]*/
dcl	input_offset	fixed bin (24);		/*[]*/
dcl	rel_offset	fixed bin (24);		/*[]*/
dcl	data_name_ptr	ptr;			/*[]*/
						/*[]*/
	work_ptr = data_name_ptr;			/*[]*/
	if work_ptr -> data_name.level > 1		/*[]*/
	then do;
		work_ptr = work_ptr -> data_name.prev_rec;
						/*[]*/
		continue = "1"b;			/*[]*/
		do while (continue);		/*[]*/
		     if work_ptr -> data_name.level = 1 /*[]*/
		     then continue = "0"b;		/*[]*/
		     else work_ptr = work_ptr -> data_name.prev_rec;
						/*[]*/
		end;				/*[]*/
		rel_offset = input_offset - (work_ptr -> data_name.offset);
						/*[]*/
		file_table.abs_record_offset = work_ptr -> data_name.offset;
						/*[]*/
	     end;					/*[]*/
	else do;					/*[]*/
		rel_offset = 0;			/*[]*/
		file_table.abs_record_offset = work_ptr -> data_name.offset;
						/*[]*/
	     end;					/*[]*/
						/*[]*/
						/*[]*/
	return (rel_offset);			/*[]*/
     end get_rel_offset;

%include cobol_type9;
     end process_keys;


issue_diag:
     proc;
	call cobol_swf_put (cobol_ext_$cobol_curr_out, status, addr (adiag), adiag.size);
     end issue_diag;





lev_diag:
     proc (diag_num);

declare	diag_num		fixed bin,
	lev_diag_ptr	ptr;

declare	1 lev_diag_item,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 run		fixed bin,
	  2 number	fixed bin,
	  2 info		bit (36);

declare	1 auser_wd	based,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 info_bit	bit (8),
	  2 length	fixed bin,
	  2 name		char (30);

	lev_diag_item.size = 28;
	lev_diag_item.type = 5;
	lev_diag_item.run = 9;
	lev_diag_item.info = "0"b;
	lev_diag_item.line = stackbegptr -> auser_wd.line;
	lev_diag_item.column = stackbegptr -> auser_wd.column;
	lev_diag_item.number = diag_num;

	lev_diag_ptr = addr (lev_diag_item);

	call cobol_c_list (lev_diag_ptr);

     end;

%include cobol_ext_;
%include cobol_file_table;
%include cobol_type12;
%include cobol_file_key;
%include cobol_linage_rec;
%include cobol_fixed_common;
%include cobol_com2;
%include cobol_cirst;
%include cobol_io_info;
%include cobol_;
%include cobol_xref;
%include cobol_repl_diag_values;
%include cobol_size_values;
%include cobol_file_desc_1;

     end cobol_repl3;
 



		    cobol_repl3_expand.pl1          05/24/89  1046.0rew 05/24/89  0835.4      143019



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_repl3_expand.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 03/28/79 by FCH, [4.0-1], flag AND,OR as genereted code */
/* Modified since Version 4.0 */

/* format: style3 */
cobol_repl3_expand:
     proc (cname_ptr, cvar_ptr, ss_stack_ptr, curr_line, curr_column);

/*  This procedure is called by the replacement phase to expand a condition name to a
conditional expression that references the conditional variable associated with the
condition name.  When called, the reference to the condition name has been syntactically
checked, and if any subscripts were present, they have also been syntactically checked
and stored in a subscript stack.
*/


/*  DECLARATION OF THE PARAMETERS  */

dcl	cname_ptr		ptr;			/*  points to the condition name entry in the name table to be expanded  */

dcl	cvar_ptr		ptr;			/*  points to the condition variable entry in the name table associated with the
		condition name  */

dcl	ss_stack_ptr	ptr;			/*  points to the subscript stack  */

dcl	curr_line		fixed bin;		/*  contains the line on which the token being expanded occurs  */

dcl	curr_column	fixed bin;		/*  contains the column in which the token being expanded starts  */

/*  numeric initial value extension  */

dcl	extension_ptr	ptr;

dcl	1 no_in		based (extension_ptr),
	  2 inittype	bit (8),
	  2 info		bit (8),
	  2 sign		char (1),
	  2 exp_sign	char (1),
	  2 exp_places	fixed bin,
	  2 places_left	fixed bin,
	  2 places_right	fixed bin,
	  2 places	fixed bin,
	  2 literal	char (30);




/*  NUMERIC LITERAL TOKEN IMAGE  */

dcl	1 numeric_lit	based (cbuff_ptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 info		bit (8),
	  2 sign		char (1),
	  2 exp_sign	char (1),
	  2 exp_places	fixed bin,
	  2 places_left	fixed bin,
	  2 places_right	fixed bin,
	  2 places	fixed bin,
	  2 literal	char (30);


/*  ALPHANUMERIC LITERAL TOKEN IMAGE  */

dcl	1 alphanum_lit	based (cbuff_ptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 info		bit (8),
	  2 length	fixed bin,
	  2 string	char (256);


/*  RESERVED WORD TOKEN IMAGE  */

dcl	1 reserved_word	based (cbuff_ptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 key		fixed bin,
	  2 class		bit (26),
	  2 jump_index	fixed bin;


/*  alphanumeric initial value extension  */

dcl	1 al_in		based (extension_ptr),
	  2 inittype	bit (8),
	  2 info		bit (8),
	  2 length	fixed bin,
	  2 string	char (256);

/*  Common work buffer in which output records are built  */

dcl	cbuff		char (100);
dcl	cbuff_ptr		ptr;
dcl	cbuff_size	fixed bin;



/*  initial condition name  */

dcl	1 c_n		based (cname_ptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 string_ptr	ptr,
	  2 prev_rec	ptr,
	  2 info		bit (8),
	  2 def_line	fixed bin,
	  2 level		fixed bin,
	  2 num_lits	fixed bin,
	  2 name_size	fixed bin,
	  2 name		char (30);

/*  relational reserved word structure  */

/*  USED TO CREATE THE FOLLOWING RESERVED WORDS:  EQUAL, LESS, GREATER  */

dcl	1 relational_res_word
			int static,
	  2 size		fixed bin init (0),
	  2 line		fixed bin init (0),
	  2 column	fixed bin init (0),
	  2 type		fixed bin init (1),
	  2 key		fixed bin init (0),
	  2 class1	bit (8) init ("00000100"b),
	  2 class2	bit (8) init ("0"b),
	  2 class3	bit (4) init ("0001"b),
	  2 class4	bit (4) init ("0"b),
	  2 jump_index	fixed bin init (0);


/*  logical reserved word structure  */

/*  USED TO CREATE THE FOLLOWING RESERVED WORD TOKENS:  AND, OR, NOT  */

dcl	1 logical_res_word	int static,
	  2 size		fixed bin init (0),
	  2 line		fixed bin init (0),
	  2 column	fixed bin init (0),
	  2 type		fixed bin init (1),
	  2 key		fixed bin init (0),
	  2 class1	bit (16) init ("000000001"b), /*[4.0-1]*/
	  2 class2	bit (4) init ("0001"b),
	  2 class3	bit (4) init ("0"b),
	  2 jump_index	fixed bin init (0);



/*  INTERNAL VARIABLES  */

dcl	exp_counter	fixed bin;
dcl	template1		char (500) based (cname_ptr);
dcl	template2		(500) char (1) based (cname_ptr);

dcl	lrw_ptr		ptr;			/*  logical reserved word pointer  */
dcl	rrw_ptr		ptr;			/*  relational reserved word pointer  */
dcl	nlit_ptr		ptr;			/*   numericeric literal pointer  */

dcl	s		fixed bin;
dcl	y		fixed bin;
dcl	t1		fixed bin;

dcl	save_line		fixed bin;
dcl	save_column	fixed bin;


dcl	i		fixed bin;
dcl	ss_ptrtable	(1:50) ptr based (tptr1);
dcl	tptr1		ptr;
dcl	tptr2		ptr;
dcl	1 header		based (tptr2),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin;

dcl	1 ss_stack	based (ss_stack_ptr),
	  2 no_entries	fixed bin,
	  2 dummy_ptr	ptr,
	  2 stack		char (500);

dcl	addr		builtin;
dcl	fixed		builtin;
dcl	mod		builtin;
dcl	substr		builtin;

dcl	1 switch_type9	static,
	  2 header,
	    3 length	fixed bin init (112),
	    3 line	fixed bin,
	    3 column	fixed bin,
	    3 type	fixed bin init (9),
	  2 repl_ptr	(2) ptr init ((2) null ()),
	  2 fill1		bit (108) init (""b),
	  2 file_key_info,
	    3 fb1		(3) fixed bin init (0, 0, 0),
	    3 size	fixed bin init (4),
	    3 fb2		(2) fixed bin init (0, 0),
	    3 flags1	bit (36) init ("010000100100000000010000000100000000"b),
	    3 flags2	bit (36) init (""b),
	    3 seg		fixed bin init (-10),	/* cobol_fixed_static.controlp */
	    3 off		fixed bin,		/* offset from cobol_control_seg_|0 */
	  2 fill2		(7) fixed bin init (0, 0, 0, 0, 0, 0, 0);


unload_ss:
     proc;

	tptr1 = ss_stack.dummy_ptr;

	do i = 1 to ss_stack.no_entries;		/*  unload the subscript stack  */
	     tptr2 = ss_ptrtable (i);
	     call cobol_swf_put (cobol_ext_$cobol_curr_out, status, tptr2, header.size);
	end;					/*  unload the subscript stack  */

     end unload_ss;



load_nlit:
     proc;


	numeric_lit.size = numeric_literal_size + no_in.places;

	numeric_lit.line = curr_line;
	numeric_lit.column = curr_column;
	numeric_lit.type = 2;
	numeric_lit.info = "0"b;
	numeric_lit.sign = no_in.sign;
	numeric_lit.exp_sign = no_in.exp_sign;
	numeric_lit.exp_places = no_in.exp_places;
	numeric_lit.places_left = no_in.places_left;
	numeric_lit.places_right = no_in.places_right;
	numeric_lit.places = no_in.places;
	substr (numeric_lit.literal, 1, no_in.places) = substr (no_in.literal, 1, no_in.places);


	t1 = numeric_extension_size + no_in.places;
	y = mod (t1, 4);
	if y ^= 0
	then y = 4 - y;
	s = s + t1 + y;

	cbuff_size = numeric_lit.size;

     end load_nlit;


load_alit:
     proc;


	alphanum_lit.size = alphanumeric_literal_size + al_in.length;


	alphanum_lit.line = curr_line;
	alphanum_lit.column = curr_column;
	alphanum_lit.type = 3;
	alphanum_lit.info = "0"b;
	alphanum_lit.length = al_in.length;
	substr (alphanum_lit.string, 1, al_in.length) = substr (al_in.string, 1, al_in.length);



	t1 = alpha_extension_size + al_in.length;
	y = mod (t1, 4);
	if y ^= 0
	then y = 4 - y;
	s = s + t1 + y;

	cbuff_size = alphanum_lit.size;

     end load_alit;


load_resword:
     proc;

dcl	keytab		(1:7) fixed bin int static init (180,
						/*  ZERO  */
			192,			/*  SPACE  */
			256,			/*  UPPER-BOUND  */
			566,			/*  LOWER-BOUND  */
			221,			/*  HIGH-VALUE  */
			229,			/*  LOW-VALUE  */
			235 /*  QUOTE  */);


	reserved_word.size = reserved_word_size;

	reserved_word.line = curr_line;
	reserved_word.column = curr_column;
	reserved_word.type = 1;
	reserved_word.class = "001"b;			/*  set "figurative constant" bit  */
	reserved_word.key = keytab (fixed (substr (al_in.info, 6, 3), 3));
	reserved_word.jump_index = 0;


	t1 = alpha_extension_size;

	y = mod (t1, 4);
	if y ^= 0
	then y = 4 - y;
	s = s + t1 + y;

	cbuff_size = reserved_word.size;

     end load_resword;


load_all_lit:
     proc;


	alphanum_lit.size = alphanumeric_literal_size + al_in.length;

	alphanum_lit.line = curr_line;
	alphanum_lit.column = curr_column;
	alphanum_lit.type = 3;
	alphanum_lit.info = "01"b;			/*  set "preceded by ALL" bit  */
	alphanum_lit.length = al_in.length;
	substr (alphanum_lit.string, 1, al_in.length) = substr (al_in.string, 1, al_in.length);


	t1 = alpha_extension_size + al_in.length;
	y = mod (t1, 4);
	if y ^= 0
	then y = 4 - y;
	s = s + t1 + y;

	cbuff_size = alphanum_lit.size;

     end load_all_lit;





expand:
	exp_counter = 0;
	cbuff_ptr = addr (cbuff);

	lrw_ptr = addr (logical_res_word);
	rrw_ptr = addr (relational_res_word);

	logical_res_word.size = reserved_word_size;
	relational_res_word.size = reserved_word_size;

	if cname_ptr -> mnemonic_name.type = 17
	then do;					/*-07/01/76-*/
		switch_type9.line = curr_line;
		switch_type9.column = curr_column;
		switch_type9.off = 4 * (cname_ptr -> mnemonic_name.iw_key - 1);
						/* seg4|4*switchno */
		call cobol_swf_put (cobol_ext_$cobol_curr_out, status, addr (switch_type9),
		     switch_type9.header.length);

		logical_res_word.line, relational_res_word.line = curr_line;
		logical_res_word.column, relational_res_word.column = curr_column;
		if ^cname_ptr -> mnemonic_name.off_status
		then do;
			logical_res_word.key = reswd_NOT;
			call cobol_swf_put (cobol_ext_$cobol_curr_out, status, lrw_ptr, logical_res_word.size);
		     end;
		relational_res_word.key = reswd_EQUAL;
		call cobol_swf_put (cobol_ext_$cobol_curr_out, status, rrw_ptr, relational_res_word.size);

		cbuff_size, alphanum_lit.size = alphanumeric_literal_size + 4;
		alphanum_lit.line = curr_line;
		alphanum_lit.column = curr_column;
		alphanum_lit.type = 3;
		alphanum_lit.info = ""b;
		alphanum_lit.length = 4;
		substr (alphanum_lit.string, 1, 4) = "    ";
		call cobol_swf_put (cobol_ext_$cobol_curr_out, status, cbuff_ptr, cbuff_size);

		return;

	     end;


/*  calculate the character offset of the 1st numeric extension in the condition name entry  */


	t1 = numeric_extension_offset + c_n.name_size;

	y = mod (t1, 4);
	if y ^= 0
	then y = 4 - y;
	s = t1 + y + 1;

exp_loop:
	if exp_counter = c_n.num_lits
	then goto expand_cleanup;

	extension_ptr = addr (template2 (s));

	if exp_counter ^= 0
	then do;					/*  write  out the reserved word "OR"  */
		logical_res_word.line = curr_line;
		logical_res_word.column = curr_column;
		logical_res_word.key = 135;		/*  OR  */

		call cobol_swf_put (cobol_ext_$cobol_curr_out, status, lrw_ptr, logical_res_word.size);

	     end;					/*  write out the reserved word"OR"  */

/*  write out the name table entry for the conditional variable  */

	dn_ptr = cvar_ptr;

/*  save the line and column info from the name table entry  */

	save_line = data_name.line;
	save_column = data_name.column;
	data_name.column = curr_column;
	data_name.line = curr_line;


	call cobol_swf_put (cobol_ext_$cobol_curr_out, status, dn_ptr, data_name.size);

	if ss_stack.no_entries ^= 0
	then call unload_ss;			/*  unload the subscript stack  */

	if substr (no_in.inittype, 6, 2) = "00"b
	then do;					/*  This literal not associated with a "THRU"  clause  */

/*  write out the reserved word token "EQUAL"  */

		relational_res_word.line = curr_line;
		relational_res_word.column = curr_column;
		relational_res_word.key = 102;	/*  EQUAL  */

		call cobol_swf_put (cobol_ext_$cobol_curr_out, status, rrw_ptr, relational_res_word.size);

/*  write out the literal value  */


		if substr (no_in.inittype, 1, 1)	/*  numeric literal extension  */
		then call load_nlit;

		else if substr (no_in.inittype, 2, 1) & ^substr (no_in.inittype, 4, 1)
						/*  alphanumeric literal extension  */
		then call load_alit;

		else if substr (no_in.inittype, 3, 1)	/*  figurative constant extension  */
		then call load_resword;

		else call load_all_lit;		/*  assume an "ALL" literal  */

/*  write out the record just built in the common buffer  */

		call cobol_swf_put (cobol_ext_$cobol_curr_out, status, cbuff_ptr, cbuff_size);

		exp_counter = exp_counter + 1;


		goto exp_loop;

	     end;					/*  This literal not associated with a "THRU" clause  */

	else do;					/*  Must be associated with a "THRU" clause  */

/*  write out "NOT LESS"  (2 tokens)  */

		logical_res_word.line = curr_line;
		logical_res_word.column = curr_column;
		logical_res_word.key = 130;		/*  NOT  */

		call cobol_swf_put (cobol_ext_$cobol_curr_out, status, lrw_ptr, logical_res_word.size);

		relational_res_word.line = curr_line;
		relational_res_word.column = curr_column;
		relational_res_word.key = 123;	/*  LESS  */

		call cobol_swf_put (cobol_ext_$cobol_curr_out, status, rrw_ptr, relational_res_word.size);

/*  write out the literal value  */


		if substr (no_in.inittype, 1, 1)	/*  numeric literal extension  */
		then call load_nlit;

		else if substr (no_in.inittype, 2, 1) & ^substr (no_in.inittype, 4, 1)
						/*  alphanumeric literal extension  */
		then call load_alit;

		else if substr (no_in.inittype, 3, 1)	/*  figurative constant extension  */
		then call load_resword;

		else call load_all_lit;		/*  assume an "ALL" literal  */

/*  write out the record just built in the common buffer  */

		call cobol_swf_put (cobol_ext_$cobol_curr_out, status, cbuff_ptr, cbuff_size);



		extension_ptr = addr (template2 (s));

/*  write out "AND"  */

		logical_res_word.key = 77;		/*  AND  */

		call cobol_swf_put (cobol_ext_$cobol_curr_out, status, lrw_ptr, logical_res_word.size);

/*  write out the name table entry for the conditional variable  */

		dn_ptr = cvar_ptr;
		call cobol_swf_put (cobol_ext_$cobol_curr_out, status, dn_ptr, data_name.size);

		if ss_stack.no_entries ^= 0
		then call unload_ss;		/*  unload the subscript stack  */

/*  Write out  "NOT GREATER"  (2 tokens)  */

		logical_res_word.key = 130;		/*  NOT  */

		call cobol_swf_put (cobol_ext_$cobol_curr_out, status, lrw_ptr, logical_res_word.size);

		relational_res_word.key = 113;	/*  GREATER  */

		call cobol_swf_put (cobol_ext_$cobol_curr_out, status, rrw_ptr, relational_res_word.size);

/*  Write out the literal  */


		if substr (no_in.inittype, 1, 1)	/*  numeric literal extension  */
		then call load_nlit;

		else if substr (no_in.inittype, 2, 1) & ^substr (no_in.inittype, 4, 1)
						/*  alphanumeric literal extension  */
		then call load_alit;

		else if substr (no_in.inittype, 3, 1)	/*  figurative constant extension  */
		then call load_resword;

		else call load_all_lit;		/*  assume an "ALL" literal  */

/*  write out the record just built in the common buffer  */

		call cobol_swf_put (cobol_ext_$cobol_curr_out, status, cbuff_ptr, cbuff_size);

/*  increment literal processed counter  */

		exp_counter = exp_counter + 2;

		goto exp_loop;

	     end;					/*  must be associated with a "THRU" clause  */

expand_cleanup:					/*  restore the line and column info to the name table entry  */
	if c_n.num_lits > 0
	then do;					/* otherwise dn_ptr won't be set */
		data_name.line = save_line;
		data_name.column = save_column;
	     end;
exit:
	return;


/* INCLUDE FILES */
dcl	dn_ptr		ptr;
%include cobol_type9;
%include cobol_ext_;
%include cobol_io_info;
%include cobol_repl_unique;
dcl	name_ptr		ptr;
%include cobol_type17;
%include cobol_reswd_values;

     end cobol_repl3_expand;
 



		    cobol_replb.pl1                 05/24/89  1046.0rew 05/24/89  0835.4      592236



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_replb.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 07/11/81 by FCH, [4.4-3], work files incorrectly written, phx10380(BUG492) */
/* Modified on 04/09/81 by FCH, [4.4-2], fix bugs in leveling for validation-81, BUG477 */
/* Modified on 12/10/80 by FCH, [4.4-1], report writer added */
/* Modified on 03/24/80 by FCH, [4.2-7], Emit correct line number with L-14 */
/* Modified on 03/24/80 by FCH, [4.2-6], flag "(" as generated by cond-name ref */
/* Modified on 07/11/79 by FCH, [4.0-5], debug statement */
/* Modified on 06/26/79 by MD, [4.0-4], in-line perform */
/* Modified on 06/02/78 by RAL, [3.0-3], check lnk for redefines in linkage section */
/* Modified on 01/03/78 by FCH, [3.0-2], leveling diag 14 issued */
/* Modified on 12/28/77 by FCH, [3.0-1], numeric procedure names handled correctly */
/* Modified since Version 3.0 */






/* format: style3 */
cobol_replb:
     proc (ntendptr, string_ptr);

/*  DECLARATION OF THE PARAMETERS  */

dcl	ntendptr		ptr;			/*  points to the byte following the last entry in the name table buffer (input)  */
dcl	string_ptr	ptr;			/*  points to the string base table (input)  */


/*  INTERNAL VARIABLES  */

dcl	eof		bit (1) int static init ("0"b);
dcl	ntptr		ptr;
dcl	s		fixed bin (15);		/*[4.0-5]*/
declare	sz		fixed bin;		/*[4.0-5]*/
declare	ch32		char (32) based;

declare	(P1, P2)		ptr;			/*[3.0-2]*/

/*  the name stack pointer table  */

dcl	ptrtable		(50) ptr;


/*  INTERNAL STATIC  */

dcl	false		bit (1) int static init ("0"b);
dcl	true		bit (1) int static init ("1"b);





/*  DECLARATION OF EXTERNAL ENTRIES  */


dcl	cobol_usrwd	ext
			entry (ptr, fixed bin (15), ptr, fixed bin (15), ptr, bit (1), bit (1), bit (1),
			fixed bin (15), ptr);

dcl	cobol_repl3_expand	ext entry (ptr, ptr, ptr, fixed bin (15), fixed bin (7));


dcl	cobol_find_secdef	ext entry (ptr, fixed bin (15), ptr, ptr);

dcl	dn_ptr		ptr;
dcl	temp_ptr		ptr;
dcl	1 shdr		based (cobol_curr_out),
	  2 filler	char (12),
	  2 next		fixed bin (24);
dcl	1 picture		based (ptr2),
	  2 size		fixed bin (15),
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7),
	  2 length	fixed bin (7),
	  2 string	char (120),
	1 message		based (ptr2),
	  2 size		fixed bin (15),
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7),
	  2 number	fixed bin (15),
	  2 info		fixed bin (15),
	1 source		based (ptr2),
	  2 size		fixed bin (15),
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7),
	  2 info		fixed bin (7),
	  2 length	fixed bin (7),
	  2 image		char (200),
	1 user_word	based (ptr2),
	  2 size		fixed bin (15),
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7),
	  2 info1		bit (1),
	  2 info2		bit (1),
	  2 info3		bit (6),			/*  2 multics char(3),  */
	  2 length	fixed bin (7),
	  2 word		char (30);


dcl	1 db_token	based (ptr2),
	  2 size		fixed bin (15),
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7),
	  2 db_index	fixed bin (15),
	  2 db_switch	bit (8);



dcl	minpr_record	char (recsize2) based (ptr2),
	stackrecord	char (recsize2) based (stackptr),
	template		char (500) based (ntptr),
	(stackptr, stackbegptr, ptr2, ptr2_1, save_ptr2)
			pointer,
	(counter, topstack) fixed bin (15),
	(ntptr1, ntptr2)	pointer,
	(i, j)		fixed bin,
	was_found		bit (1),
	not_found		bit (1);			/*[4.4-2]*/
declare	qualif		bit (1),
	sav_ptr		ptr;

dcl	stack		char (1000);
dcl	temp_stack	(1000) char (1) based (addr (stack));
dcl	template1		(500) char (1) based (addr (template));

dcl	1 auser_word	based (stackptr),
	  2 size		fixed bin (15),
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7),
	  2 info1		bit (1),
	  2 info2		bit (1),
	  2 info3		bit (6),			/*  2 multics char(3),  */
	  2 length	fixed bin (7),
	  2 word		char (30);

dcl	1 res_word_of	auto,
	  2 size		fixed bin (15) init (28),
	  2 line		fixed bin (15) init (0),
	  2 column	fixed bin (7) init (0),
	  2 type		fixed bin (7) init (1),
	  2 key		fixed bin (15) init (133),
	  2 class1	bit (16) init ("000000001"b), /*[4.2-6]*/
	  2 class2	bit (4) init ("0001"b),
	  2 class3	bit (1) init ("1"b),
	  2 class4	bit (3) init ("0"b),	/*  2 multics char(1) init(" "),  */
	  2 jump_index	fixed bin (7) init (0);

dcl	1 adiag		auto,
	  2 size		fixed bin init (28),
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin init (5),
	  2 run_number	fixed bin init (6),
	  2 number	fixed bin,
	  2 info		bit (8) initial ("01000000"b),
	  2 image_size	fixed bin init (0),
	  2 image		char (8);

dcl	sectno		fixed bin (15),
	rw_switch		bit (1),
	ptr3		pointer,
	levstack		(50) fixed bin (15);


dcl	1 data_based	based,
	  02 filler	char (24),
	  02 offset	fixed bin;

dcl	startlevel	fixed bin (31);
dcl	tlevel		fixed bin (31);
dcl	continue		bit (1);
dcl	diag_no		fixed bin (15);
dcl	save_line		fixed bin (15);
dcl	save_column	fixed bin (7);
dcl	save_length	fixed bin (31);
dcl	first_time	bit (1);
dcl	first_workfile_ref	bit (1) int static init ("1"b);



dcl	t26_ptr		ptr;
dcl	t26_size		fixed bin (15) int static init (16);

dcl	1 t26_token	int static,
	  2 size		fixed bin (15) init (16),
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7) init (26);	/*  =26  */




dcl	1 t88_token	int static,
	  2 size		fixed bin (15) init (16),
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7) init (88);

dcl	t88_ptr		ptr;


dcl	rw_corresponding	bit (1);
dcl	rw_initialize	bit (1);
dcl	expand_condition_names
			bit (1);
dcl	rw_sort_etc	bit (1);			/* 2/26/74 */
						/*[4.4-1]*/
dcl	(rw_debugging, rw_initterm, rw_generate)
			bit (1);
dcl	rw_perform	bit (1);
dcl	rw_search		bit (1);
dcl	rw_exception	bit (1);
dcl	already_replaced	bit (1);
dcl	processing_subscript
			bit (1);
dcl	lev_from_srchloop	bit (1);
dcl	too_many_qualifiers bit (1);
dcl	name_stack_overflow bit (1);
dcl	subscript_stack_overflow
			bit (1);
dcl	recovered_to_thru	bit (1);
dcl	ss_recovered	bit (1);
dcl	num_literal	bit (1);

dcl	ft_ptr		ptr;

/*  VARIABLES REQUIRED FOR PROCESSING CONDITION NAMES  */

dcl	cname_ptr		ptr;
dcl	cvar_ptr		ptr;
dcl	temp_cname_ptr	ptr;
dcl	temp_cvar_ptr	ptr;
dcl	cname_size	fixed bin (15);
dcl	cvar_size		fixed bin (15);
dcl	ss_stack_ptr	ptr;
dcl	ssname_ptr	ptr;

dcl	cobol_cvar_record	char (500);
dcl	cobol_cname_record	char (500);
dcl	cobol_ss_name	char (500);

dcl	1 cobol_ss_stack,
	  2 no_entries	fixed bin (15),
	  2 dummy_ptr	ptr,
	  2 stack		char (1000);












dcl	ss_template	(1000) char (1) based (addr (cobol_ss_stack.stack));

dcl	ss_recsize	fixed bin (15);
dcl	cobol_ss_stackrecord
			char (ss_recsize) based (ss_stack_ptr);
dcl	ss_ptrtable	(1:50) ptr;
dcl	ss_topstack	fixed bin (15);

dcl	next_state	fixed bin (15);
dcl	rwkey		fixed bin (15);

dcl	name_stack_size	fixed bin (15) int static init (1000);
dcl	subscript_stack_size
			fixed bin (15) int static init (1000);





/*  DECLARATIONS REQUIRED FOR PROCESSINNG DEBUGGING STATEMENTS  */

dcl	call_scan		bit (1);
dcl	recover_code	fixed bin (15);
dcl	stmt_term		fixed bin (15) int static init (1),
	a_dataname	fixed bin (15) int static init (2),
	resword_all	fixed bin (15) int static init (3),
	eof_found		fixed bin (15) int static init (4);


dcl	1 debug_alit	based (ss_stack_ptr),
	  2 size		fixed bin (15),
	  2 line		fixed bin (15),
	  2 column	fixed bin (15),
	  2 type		fixed bin (15),
	  2 info		bit (8),
	  2 multics	char (3),
	  2 length	fixed bin (15),
	  2 string	char (31);

dcl	lit_of		char (4) int static init (" of ");
dcl	inext		fixed bin (15);
dcl	ilength		fixed bin (15);
dcl	all_flag		bit (1);


/*  DECLARAATIONS REQUIRED FOR PROCESSING "PROCEDURE DIVISION USING"  */

dcl	rw_using		bit (1);
dcl	using_count	fixed bin (15);




/*  VARIABLES REQUIRED FOR PROCESSING TYPE 1 RECORDS WITH REPLACEMENT JUMP INDEX=7  */


dcl	1 special_usrwd	int static,
	  2 size		fixed bin (15),		/*  MUST CHANGE INIT VALUE FOR NPL VERSION  */
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7) init (8),
	  2 info		bit (8) init ("0"b),
	  2 multics	char (3),
	  2 length	fixed bin (7),
	  2 name		char (30);		/*  large enough to hold maximum size name  */


dcl	clinage_counter	char (14) int static init ("LINAGE-COUNTER"),
	cline_counter	char (12) int static init ("LINE-COUNTER"),
	cpage_counter	char (12) int static init ("PAGE-COUNTER"),
	csystem_status	char (13) int static init ("SYSTEM-STATUS"),
	ctally		char (5) int static init ("TALLY");


/*  VARIABLES REQUIRED FOR PROCESSING "SEARCH {ALL}"  */

dcl	error_cond	bit (1);
dcl	search_all	bit (1);
dcl	save_ntptr	ptr;
dcl	save_type10_ptr	ptr;





/*  DEFINE MNEMONIC RETURN CODES FOR THE INTERNAL SCAN PROCEDURE  */


dcl	rcode_NO_INTEREST	fixed bin static options (constant) init (1);
dcl	rcode_RESWORD_REC	fixed bin static options (constant) init (2);
dcl	rcode_DNAME_REC	fixed bin static options (constant) init (3);
dcl	rcode_ERROR_DETECTED
			fixed bin static options (constant) init (4);
dcl	rcode_SCAN_CURRENT	fixed bin static options (constant) init (5);
dcl	rcode_SCAN_NEXT	fixed bin static options (constant) init (6);


dcl	type25_flag	bit (1);






dcl	saved_storage_type	bit (1);
dcl	searching_for_another
			bit (1);
dcl	return_code	fixed bin (15);
dcl	string		builtin;
dcl	addr		builtin;
dcl	addrel		builtin;
dcl	divide		builtin;
dcl	fixed		builtin;
dcl	mod		builtin;
dcl	null		builtin;
dcl	(substr, size)	builtin;

dcl	1 linage_counter_type9
			static,
	  2 size		fixed bin init (112),
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin init (9),
	  2 repl_ptr	(2) ptr init ((2) null ()),
	  2 fill1		bit (108) init (""b),
	  2 file_key_info,
	    3 fb1		(3) fixed bin init (0, 0, 0),
	    3 size	fixed bin init (6),
	    3 places_left	fixed bin init (6),
	    3 places_right	fixed bin init (0),
	    3 flags1	bit (36) init ("001000100100000001000000000100000000"b),
						/* constant lev77 elem numeric display */
	    3 flags2	bit (36) init (""b),
	    3 seg		fixed bin,
	    3 off		fixed bin init (352),
	  2 fill2		(7) fixed bin init (0, 0, 0, 0, 0, 0, 0);
dcl	1 type17		static,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin init (17),
	  2 string_ptr	ptr init (null ()),
	  2 prev_rec	ptr init (null ()),
	  2 info		bit (8) init (""b),
	  2 class,
	    3 switch_condition
			bit (1),
	    3 switch_name	bit (1),
	    3 accept_device bit (1),
	    3 display_device
			bit (1),
	    3 printer_control
			bit (1),
	    3 alphabet_name bit (1),
	  2 on_status	bit (1) init (""b),
	  2 off_status	bit (1) init (""b),
	  2 def_line	fixed bin init (0),
	  2 iw_key	fixed bin,
	  2 reserved	bit (36) init (""b),
	  2 alphabet_offset fixed bin init (0),
	  2 name_size	fixed bin,
	  2 name		char (8);
dcl	1 type40		auto,			/* due to size */
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 string_ptr	ptr,
	  2 prev_rec	ptr,
	  2 info		bit (10),
	  2 hival_char	char (1),
	  2 loval_char	char (1),
	  2 iw_key	fixed bin,
	  2 def_line	fixed bin,
	  2 char_size	fixed bin,
	  2 he_value	char (1),
	  2 segno		fixed bin,
	  2 offset	fixed bin,
	  2 dn_offset	fixed bin,
	  2 table		char (512),
	  2 name_size	fixed bin,
	  2 name		char (8);

dcl	temp_char		char (1);
dcl	rw_key		fixed bin;
dcl	replb_compile_count fixed bin static init (0);
dcl	cobol_read_ft_	entry (fixed bin, ptr);
dcl	cobol_c_list	entry (ptr);
dcl	cobol_set_type40_$ebcdic
			entry (ptr);


/*************************************/
start:
	mcobol = fixed_common.compiler_id = 3;
	rw_sort_etc = "0"b;
	rw_corresponding = "0"b;
	rw_initialize = "0"b;
	rw_search = "0"b;
	expand_condition_names = "0"b;		/*[4.0-5]*/
	rw_debugging = "0"b;
	rw_perform = "0"b;
	rw_using = "0"b;
	rw_exception = "0"b;
	already_replaced = "0"b;
	processing_subscript = "0"b;
	lev_from_srchloop = "0"b;
	subscript_stack_overflow = "0"b;
	name_stack_overflow, too_many_qualifiers = "0"b;	/*[3.0-1]*/
	ss_stack_ptr = addr (cobol_ss_stack.stack);
	cobol_ss_stack.no_entries = 0;
	st_ptr = addr (status);
	sectno = 1;
	using_count = 0;
	search_all = "0"b;
	type25_flag = "0"b;
	t26_ptr = addr (t26_token);
	t88_ptr = addr (t88_token);
	ssname_ptr = addr (cobol_ss_name);
	stackbegptr = addr (stack);
	rw_switch = false;

	call swfget;				/* Read the first record from the input file. */
	do while (user_word.type = 5);		/* Scan over diagnostic records writing them to output file. */
	     call swfput;
	     call swfget;
	end;

	next_state = 1;
	go to using_scan;

using_read:
	call swfget;
using_scan:
	call repl3_scan (status, return_code);
	if status_right ^= "0"b
	then go to rend;
using_switch:
	go to using_state (next_state);

using_state (1):
	if return_code = rcode_RESWORD_REC & ptr2 -> reserved_word.key = 142
						/* PROCEDURE */
	then do;
		next_state = 2;
		call swfput;			/* Write the reserved word to the output file. */
		go to using_read;
	     end;
	else go to using_exit;
using_state (2):
	if return_code = rcode_RESWORD_REC & ptr2 -> reserved_word.key = 94
						/* DIVISION */
	then do;
		next_state = 3;
		call swfput;			/* Write the reserved word to the output file. */
		go to using_read;
	     end;
	else go to using_exit;
using_state (3):
	if return_code = rcode_RESWORD_REC & ptr2 -> reserved_word.key = 176
						/* USING */
	then do;
		next_state = 4;
		rw_using = "1"b;
		call swfput;			/* Write the reserved word to the output file. */
		go to using_read;
	     end;
	else go to using_exit;
using_state (4):
	if return_code = rcode_ERROR_DETECTED | return_code = rcode_SCAN_CURRENT
	then go to using_scan;			/* The current record in the read buffer is to be scanned next. */
	if return_code = rcode_NO_INTEREST & user_word.type = 5
	then do;					/* diagnostic record */
		call swfput;
		go to using_read;
	     end;
	if return_code = rcode_DNAME_REC
	then do;					/* The record scanned is an identifier following "USING". */
		using_count = using_count + 1;
		if ^ntptr -> data_name.saved & ntptr -> data_name.linkage ^= 0
		then do;				/* This name has not been in the name table buffer on a
					   previous load, but the linkage entry has already been set.
					   Therefore, this name must have appeared already in the
					   using clause and this occurrence is illegal. */

			adiag.number = 14;		/* Identifier must not appear in "using" more than once. */
			adiag.line = stackbegptr -> auser_word.line;
			adiag.column = stackbegptr -> auser_word.column;
			call issue_diag;
			go to using_scan;
		     end;				/*		call unload;		/* Unload the user words from the name stack. */
		if ntptr -> data_name.linkage_section
		then ntptr -> data_name.linkage = using_count;
		save_line = ntptr -> data_name.line;
		save_column = ntptr -> data_name.column;
		ntptr -> data_name.line = stackbegptr -> auser_word.line;
		ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
		call swfput2 (ntptr);		/* Write out the name table buffer entry. */
		ntptr -> data_name.line = save_line;	/* Restore correct line and column numbers */
		ntptr -> data_name.column = save_column;/* to name table buffer entry. */

		if (ntptr -> data_name.level = 1 | ntptr -> data_name.level = 77) & ntptr -> data_name.linkage_section
		then do;				/* Level 1 entry in the linkage section. Step linearly thru the name table buffer
			   marking all subordinate type 9 entries with the relative position of this
			   identifier in the using clause. */

/* If redefine, back up the name table buffer          [3.0-3]
                                          until level 1 of an object of redefine is found. */

/*[]*/
			if ntptr -> data_name.s_of_rdf = "1"b
						/*[]*/
			then do;			/*[]*/
				ntptr = ntptr -> data_name.prev_rec;
						/*[]*/
				continue = "1"b;	/*[]*/
				do while (continue);/*[]*/
				     if ntptr -> data_name.level = 1 | ntptr -> data_name.level = 77
						/*[]*/
				     then if ntptr -> data_name.o_of_rdf = "1"b
						/*[]*/
					then continue = "0"b;
						/*[]*/
					else ntptr = ntptr -> data_name.prev_rec;
						/*[]*/
				     else ntptr = ntptr -> data_name.prev_rec;
						/*[]*/
				end;		/*[]*/
				ntptr -> data_name.linkage = using_count;
			     end;			/*[3.0-3]*/


			continue = "1"b;
			do while (continue);
			     ntptr = addrel (ntptr, divide (ntptr -> data_name.size + 11, 8, 17, 0) * 2);
			     if ntptr = ntendptr
			     then continue = "0"b;	/* end of name table buffer */
			     else if ntptr -> data_name.level < 2 | ntptr -> data_name.level = 77
			     then continue = "0"b;
			     else if ntptr -> data_name.type = 9
			     then ntptr -> data_name.linkage = using_count;
			end;

/* Step thru name table buffer to handle all subject          [3.0-3]
                                of redefines and their subordinates. */


/*[]*/
			do while ((ntptr -> data_name.level = 1 | ntptr -> data_name.level = 77)
			     & ntptr -> data_name.s_of_rdf = "1"b);
						/*[]*/
			     ntptr -> data_name.linkage = using_count;
						/*[]*/
			     continue = "1"b;	/*[]*/
			     do while (continue);	/*[]*/
				ntptr = addrel (ntptr, divide (ntptr -> data_name.size + 11, 8, 17, 0) * 2);
						/*[]*/
				if ntptr = ntendptr /*[]*/
				then continue = "0"b;
						/* end of name table buffer */
						/*[]*/
				else if ntptr -> data_name.level < 2 /*[]*/ | ntptr -> data_name.level = 77
						/*[]*/
				then continue = "0"b;
						/*[]*/
				else if ntptr -> data_name.type = 9
						/*[]*/
				then ntptr -> data_name.linkage = using_count;
						/*[]*/
			     end;			/*[]*/
			end;			/*[3.0-3]*/


		     end;
		if user_word.type > 8
		then go to using_read;		/* This user word has been replaced before. The read
					   buffer contains type 9 (or greater) record that
					   replaced it during a previous load of the name table buffer. */
		else go to using_scan;
	     end;
	else rw_using = "0"b;			/* Record just scanned is a reserved word or some rcode_NO_INTEREST
					   type other than a diagnistic record. */
using_exit:
	call swfput;				/* Write out the current record in the read buffer. */
rloop:
	call swfget;
rloop1:
	call repl3_scan (status, return_code);
rloop2:
	if status_right ^= "0"b
	then go to rend;
	if return_code = rcode_NO_INTEREST
	     | (return_code = rcode_RESWORD_REC & ^rw_perform & ^rw_search & ^rw_exception)
	then do;					/* Simply write out this record. */
		call swfput;
		go to rloop;
	     end;
	if return_code = rcode_ERROR_DETECTED | return_code = rcode_SCAN_CURRENT
	then go to rloop1;				/* Record in read buffer is the one to be processed next. */
	if return_code = rcode_SCAN_NEXT
	then go to rloop;

	if rw_search
	then do;					/* Process "SEARCH". */
		call swfput;			/* Write out reserved word for "SEARCH". */
		call swfget;			/* Read next record and check for "ALL". */
		if ptr2 -> reserved_word.type = 1 & ptr2 -> reserved_word.key = 73
						/* "ALL" */
		then do;				/* "all" follows "SEARCH" */
			search_all = "1"b;
			call swfput;		/* Write out reserved word record "ALL". */
			call swfget;		/* Read next record. */
		     end;
		call repl3_scan (status, return_code);
		if status_right ^= "0"b
		then go to rend;
		if return_code = rcode_DNAME_REC
		then do;				/* data name follows "SEARCH {ALL}" */
			error_cond = "0"b;
			if ^ntptr -> data_name.subscripted
			then do;			/* Identifier following "SEARCH {ALL}" must have an
					   OCCURS clause in its description. */

				adiag.number = 15;
				error_cond = "1"b;
			     end;
			else if ^ntptr -> data_name.indexed_by
			then do;			/* Identifier following "SEARCH {ALL}" must have an
					   INDEXED BY clause in its description. */

				adiag.number = 16;
				error_cond = "1"b;
			     end;
			else if search_all
			then do;			/* "ALL" present, check that "KEY IS" is also present. */
				if ^ntptr -> data_name.subject_of_keyis
				then do;
					adiag.number = 17;
					error_cond = "1"b;
				     end;
				search_all = "0"b;
			     end;
			if ^error_cond
			then do;			/* Check if identifier has an index associated with it. */
				save_ntptr = ntptr; /* save ptr to identifier following "SEARCH ALL". */
				ntptr = ntptr -> data_name.prev_rec;
				if ntptr -> data_name.type = 10
				then do;		/* The identifier has an INDEXED BY clause. */
					do while (ntptr -> data_name.type = 10);
						/* Find 1st index name. */
					     save_type10_ptr = ntptr;
					     ntptr = ntptr -> data_name.prev_rec;
					end;
					ntptr = save_ntptr;
						/* Point at the identifier. */
					save_line = ntptr -> data_name.line;
					save_column = ntptr -> data_name.column;
					ntptr -> data_name.line = stackbegptr -> auser_word.line;
					ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
					call swfput2 (ntptr);
						/* Write out data name record. */
					ntptr -> data_name.line = save_line;
						/* Restore line and column */
					ntptr -> data_name.column = save_column;
					ntptr = save_type10_ptr;
						/* Point to 1st index name. */
					save_line = ntptr -> data_name.line;
					save_column = ntptr -> data_name.column;
					ntptr -> data_name.line = stackbegptr -> auser_word.line;
					ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
					call swfput2 (ntptr);
						/* Write index name record. */
					ntptr -> data_name.line = save_line;
						/* Restore line and column. */
					ntptr -> data_name.column = save_column;
				     end;
				else do;		/* INDEXED BY clause is missing. */
					adiag.number = 16;
					error_cond = "1"b;
				     end;
			     end;
			if error_cond
			then call issue_diag;
			rw_search = "0"b;		/* Turn off "SEARCH" flag. */
			go to rloop1;		/* Read buffer contains next record. */
		     end;
		else do;				/* Some other type record follows "SEARCH {ALL}". */
			rw_search = "0"b;		/* Turn off "SEARCH" flag. */
			if return_code = rcode_NO_INTEREST & ptr2 -> reserved_word.type = 5
						/* diagnostic */
			then call swfput;		/* Write out the diagnostic record. */
			else if return_code = rcode_RESWORD_REC | return_code = rcode_NO_INTEREST
			then do;			/* Must issue diagnostic. */
				adiag.number = 18;	/* Identifier expected here */
				adiag.line = user_word.line;
				adiag.column = user_word.column;
				ptr3 = addr (adiag);
				call swfput1 (ptr3);
			     end;
			if return_code = rcode_NO_INTEREST | return_code = rcode_RESWORD_REC
			then go to rloop;		/* Read next record and continue. */
			else go to rloop1;		/* Process current record in read buffer. */
		     end;
	     end;					/* Process "SEARCH". */

	if rw_exception
	then do;

		rw_exception = "0"b;
		call swfput;			/* Write out the reserved word. */
		call swfget;			/* Get the next token. */
		call repl3_scan (status, return_code);
		if status_right ^= "0"b
		then go to rend;
		if return_code = rcode_RESWORD_REC & ptr2 -> reserved_word.key = 142
						/* "PROCEDURE" */
		then do;
			call swfput;
			rw_switch = "0"b;		/* Next token should be either a file name or a
						   reserved word, but never a section or paragraph name.
						   See the writeup on the "USE" verb. */
			go to rloop;
		     end;
		else go to rloop1;			/* Rescan the current token. */

	     end;

	if rw_perform
	then do;					/* Process "PERFORM". */
		next_state = 1;
perform_write:
		call swfput;
perform_read:
		call swfget;
perform_scan:
		call repl3_scan (status, return_code);
		if status_right ^= "0"b
		then go to rend;
perform_switch:
		go to perform_state (next_state);

perform_state (1):
		if return_code = rcode_DNAME_REC
		then do;				/* a data name */
						/*[4.4-1]*/
			if ^rw_initterm & ^rw_generate
			then next_state = 2;
			rw_switch = "0"b;		/* Turn off the switch so that if a numeric literal is the next
					   record, it is treated like a numeric literal, and not like
					   a numeric paragraph name. */
perform_write_dname:
			save_line = ntptr -> data_name.line;
			save_column = ntptr -> data_name.column;
			ntptr -> data_name.line = stackbegptr -> auser_word.line;
			ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
			call swfput2 (ntptr);
			ntptr -> data_name.line = save_line;
			ntptr -> data_name.column = save_column;
						/*[4.4-1]*/
			if rw_initterm | rw_generate
			then do;
				rw_switch = "1"b;
				go to perform_scan;
			     end;
			go to perform_scan;
		     end;
		else if return_code = rcode_ERROR_DETECTED
		then do;				/* Error detected by repl3_scan. */
			next_state = 2;
			go to perform_scan;
		     end;
		else do;				/* any other return code */
			call perform_recover (status, recovered_to_thru);
			if status_right ^= "0"b
			then go to rend;
			if recovered_to_thru
			then do;			/* Recovered to "THRU". */
				next_state = 3;
				go to perform_write;
			     end;
			else go to perform_exit;
		     end;
perform_state (2):
		if return_code = rcode_RESWORD_REC & ptr2 -> reserved_word.key = 166
						/* "THRU" */
		then do;
			next_state = 3;
			rw_switch = "1"b;		/* Turn on this switch so that if a numeric literal is the
					   next record, the numeric literal will be treated as a
					   numeric paragraph name. */
			go to perform_write;
		     end;
		else if return_code = rcode_ERROR_DETECTED
		then do;				/* Error detected by repl3_scan. */
			next_state = 4;
			go to perform_scan;
		     end;
		else go to perform_exit;		/* any other type record */
perform_state (3):
		if return_code = rcode_DNAME_REC
		then do;				/* a data name */
			next_state = 4;
			rw_switch = "0"b;		/* Turn off the switch that tells repl3_scan to process
					   numeric literals as numeric paragraph names. */
			go to perform_write_dname;
		     end;
		else if return_code = rcode_ERROR_DETECTED
		then do;				/* Error detected by repl3_scan. */
			next_state = 4;
			rw_switch = "0"b;
			go to perform_scan;
		     end;
		else go to perform_exit;		/* any other type record */
perform_state (4):
		;				/*  EMPTY STATEMENT  */

perform_exit:
		rw_perform = "0"b;
		rw_switch = "0"b;
		if return_code = rcode_DNAME_REC
		then do;
			next_state = 4;
			go to perform_write_dname;
		     end;
		else go to rloop1;			/* Rescan the current token. */
	     end;					/* Processing "PERFORM". */

/* At this point, a data name has been successfully processed and the following conditions are true:
		1. ntptr points to the name table entry of the data name.
		2. The data name stack has already been unloaded.
		3. The record currently in the read buffer is the record following the data name. */

	if ntptr -> data_name.type = 11 & expand_condition_names
	then do;					/* process condition-name */
		cname_size = ntptr -> data_name.size;
		cname_ptr = ntptr;			/* save ptr to the condition name */
cvar_loop:					/* find the condition variable */
		ntptr = ntptr -> data_name.prev_rec;
		if ntptr -> data_name.type = 11
		then go to cvar_loop;
		else cvar_ptr = ntptr;		/* save ptr to the condition variable */
		cvar_size = ntptr -> data_name.size;	/* save size of the condition variable */
						/* We drop thru to here on the final iteration when the condition-name must be expanded
		   into a CONDITION which references the CONDITIONAL VARIABLE. */

		cobol_ss_stack.no_entries = 0;	/* MUST set to zero. Repl3_expand interprets
						   non-zero value to mean there is a subscript. */
		if user_word.type = 1
		then if ptr2 -> reserved_word.key = reschar_LPARENS
		     then do;			/* process SUBSCRIPT */
			     call process_subscript ("1"b);
			     if subscript_stack_overflow | ss_recovered
			     then go to rloop1;
			end;

/* Expand the CONDITION NAME to the CONDITIONAL RELATION. */
		ss_stack_ptr = addr (cobol_ss_stack);
		cobol_ss_stack.dummy_ptr = addr (ss_ptrtable);

/* Insert "(" & ")" for PDSYN. */
		res_word_of.key = reschar_LPARENS;
		call swfput1 (addr (res_word_of));
		call cobol_repl3_expand (cname_ptr, cvar_ptr, ss_stack_ptr, stackbegptr -> auser_word.line,
		     stackbegptr -> auser_word.column + stackbegptr -> auser_word.length);
		res_word_of.key = reschar_RPARENS;
		call swfput1 (addr (res_word_of));
		res_word_of.key = reswd_OF;		/* restore key value of OF */

		if fixed_common.comp_level < "3"	/*[3.0-2]*/
		then do;
			P1 = ptr2;		/*[3.0-2]*/
			ptr2 = P2;		/*[3.0-2]*/
						/*[4.4-2]*/
			call lev_diag (14, ptr2);	/*[3.0-2]*/
			ptr2 = P1;		/*[3.0-2]*/
		     end;				/*[3.0-2]*/

		go to rloop1;
	     end;					/* process condition-name */

	if ntptr -> data_name.type = 17 & expand_condition_names
	then /*-07/01/76-*/
	     if ntptr -> mnemonic_name.class.switch_condition
	     then do;				/* process conditional mnemonic-name */
		     res_word_of.key = reschar_LPARENS;
		     call swfput1 (addr (res_word_of));
		     call cobol_repl3_expand (ntptr, null (), null (), stackbegptr -> auser_word.line,
			stackbegptr -> auser_word.column + stackbegptr -> auser_word.length);
		     res_word_of.key = reschar_RPARENS;
		     call swfput1 (addr (res_word_of));
		     res_word_of.key = reswd_OF;	/* restore to original value */
		     go to rloop1;
		end;

/* Write the name table entry to the output file. */

	save_line = ntptr -> data_name.line;
	save_column = ntptr -> data_name.column;
	ntptr -> data_name.line = stackbegptr -> auser_word.line;
	ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
	call swfput2 (ntptr);
	ntptr -> data_name.line = save_line;		/* Restore correct line and column to name table buffer entry. */
	ntptr -> data_name.column = save_column;

	if rw_sort_etc & (ntptr -> data_name.type = 12 | ntptr -> data_name.type = 16)
	then do;					/* We have just written the record for a FILE or SORT FILE, follow this
			   with the token for the 1st file record immediately following it in the
			   name table, but change the file record length to reflect the largest
			   record size (variable length records). */

		ntptr = addrel (ntptr, divide (ntptr -> data_name.size + 11, 8, 17, 0) * 2);
		save_line = ntptr -> data_name.line;
		ntptr -> data_name.line = stackbegptr -> auser_word.line;
		save_length = ntptr -> data_name.item_length;
		call cobol_vdwf_dget (cobol_cmfp, status, ft_ptr, recsize2,
		     filedescr_offsets (ntptr -> data_name.file_num));
		ntptr -> data_name.item_length = file_table.max_cra_size;
						/*[4.0-5]*/
		call swfput2 (ntptr);
		ntptr -> data_name.line = save_line;
		ntptr -> data_name.item_length = save_length;
	     end;

	if rw_corresponding | rw_initialize
	then do;					/* Output subordinate entries for CORRESPONDING or INITIALIZE. */

		if ntptr -> data_name.saved
		then do;				/* This name table entry has been in memory before. */
			startlevel = ntptr -> data_name.level;
read_more:
			call swfget;		/* Read next record from input file. */
			if user_word.type ^= 26
			then do;			/* Write the record to the output file. */
				startlevel = ptr2 -> data_name.level;
				call swfput;
				go to read_more;
			     end;

/* The last record read was a type 26 record. All of the data-name records placed
			   onto the input file by previous iterations of replacement have been written
			   onto the output file. Now process the record following the type 26 record. */

			call swfget;
			if startlevel ^= ntptr -> data_name.level
			then do;			/* Search linearly thru the name table for the 1st entry that
					   has the same level number as the last entry read. */

srchloop:
				ntptr = addrel (ntptr, divide (ntptr -> data_name.size + 11, 8, 17, 0) * 2);
				if startlevel ^= ntptr -> data_name.level
				then go to srchloop;
			     end;
			if ntptr -> data_name.level ^= 1
			then startlevel = ntptr -> data_name.level - 1;
			else startlevel = 1;
			lev_from_srchloop = "1"b;
		     end;

/* Ntptr points to the name table entry just written onto the output file. 
		   We now write all of that entry's subordinate items. */

		if ntptr -> data_name.level <= 49
		then do;				/* Current qualified name not a condition-name. */
			if lev_from_srchloop
			then lev_from_srchloop = "0"b;/* Already have startlevel. */
			else startlevel = ntptr -> data_name.level;
						/* Get startlevel from current entry. */
			continue = "1"b;
			do while (continue);
			     ntptr = addrel (ntptr, divide (ntptr -> data_name.size + 11, 8, 17, 0) * 2);
			     if ntptr = ntendptr
			     then continue = "0"b;	/* end of name table */
			     else if ntptr -> data_name.type ^= 9 & ntptr -> data_name.type ^= 10
				& ntptr -> data_name.type ^= 11
						/* condition name */
			     then continue = "0"b;
			     else do;
				     tlevel = ntptr -> data_name.level;
				     if tlevel > startlevel & tlevel ^= 77
				     then do;	/* Write entry out if not a level 88. */
					     if tlevel ^> 50 & ^ntptr -> data_name.filler_item
					     then do;
						     ntptr -> data_name.line = stackbegptr -> auser_word.line;
						     ntptr -> data_name.column =
							stackbegptr -> auser_word.column;
						/*[4.0-5]*/
						     call swfput2 (ntptr);
						end;
					end;
				     else continue = "0"b;
				end;
			end;
			if user_word.type = 1	/* reserved word */
			then if ptr2 -> reserved_word.key = 187
						/* "(" */
			     then call process_subscript ("0"b);
		     end;

/* All subordinate entries have been written. Now write the type 26 token. */

		t26_token.line = stackbegptr -> auser_word.line;
		t26_token.column = stackbegptr -> auser_word.column;
		call swfput1 (t26_ptr);
	     end;					/* Output subordinate entries for CORRESPONDING or INITIALIZE. */

	go to rloop1;

repl3_scan:
     proc (status, return_code);

dcl	status		bit (32);
dcl	return_code	fixed bin (15);
dcl	1 status_word	based (st_ptr),
	  2 status_left	bit (16),
	  2 status_right	bit (16);
dcl	st_ptr		ptr;

	st_ptr = addr (status);			/*[4.0-4]*/
	num_literal = "0"b;
	if user_word.type > 8
	then do;					/* Check for type 24 token. */
		if user_word.type = 25
		then type25_flag = "1"b;		/* Set indicator for DDALLOC Append Item. */
		go to put;
	     end;
	go to replab (user_word.type);


/*************************************/
replab (1):					/* RESERVED WORD */
	if ptr2 -> reserved_word.key = 49 /* sort */ | ptr2 -> reserved_word.key = 112 /* giving */
	     | ptr2 -> reserved_word.key = 176		/* using */
	then rw_sort_etc = "1"b;
	else rw_sort_etc = "0"b;

	if rw_corresponding
	then do;
		s = ptr2 -> reserved_word.key;
		if s ^= 182 /* "+" */ & s ^= 183 /* "-" */ & s ^= 187 /* "(" */ & s ^= 188 /* ")" */
		     & s ^= 170 /* "TO" */ & s ^= 111	/* "FROM" */
		then rw_corresponding = "0"b;

	     end;
	if rw_initialize
	then do;
		s = ptr2 -> reserved_word.key;
		if s ^= 182 /* "+" */ & s ^= 183 /* "-" */ & s ^= 187 /* "(" */ & s ^= 188
						/* ")" */
		then do;
			rw_initialize = "0"b;
			call swfput1 (t26_ptr);	/* Write type 26 token to terminate INITIALIZE string. */
		     end;
	     end;
	if ptr2 -> reserved_word.key = 47 /* "IF" */ | ptr2 -> reserved_word.key = 173 /* "UNTIL" */
	     | ptr2 -> reserved_word.key = 77 /* "AND" */ | ptr2 -> reserved_word.key = 178
						/* "WHEN" */
	then expand_condition_names = "1"b;
	else if ptr2 -> reserved_word.terminator
	then expand_condition_names = "0"b;		/* statement terminator (other than "IF") */
	if ptr2 -> reserved_word.key ^= 170		/* "TO" - go to numeric paragraph needs switch on */
	then if ptr2 -> reserved_word.key ^= 144	/* "PROCEED" */
	     then if ptr2 -> reserved_word.key ^= 118	/* "IS" , "ARE" */
		then if ptr2 -> reserved_word.key ^= 166/* THRU */
		     then rw_switch = false;		/* rw_switch="1"b means the next token is expected to be
						   a parname - interpret type 2 tokens as such */
	if ptr2 -> reserved_word.key = 107 /* "EXCEPTION" */ | ptr2 -> reserved_word.key = 3
						/* "ERROR" */
	then rw_exception = "1"b;

	go to rw (fixed (ptr2 -> reserved_word.repl_jump_ind, 15));

rw (0):						/* Nothing required of REPLACEMENT. */
						/*[4.0-5]*/
	if ptr2 -> reserved_word.key = 189
	then rw_debugging = "0"b;			/* . */
	go to put1;
rw (1):						/* Nothing required of REPLACEMENT. */
	go to put1;
rw (2):						/* Reserved word which numeric paragraph name may follow. */
	rw_switch = true;
	go to put1;

rw (3):						/* Reserved word which only non-numeric data names may follow. */
	rw_switch = false;
	go to put1;

rw (4):						/* Reserved word "INITIALIZE" */
	rw_initialize = "1"b;
	go to put1;
rw (5):						/* Reserved word "CORRESPONDING" */
	rw_corresponding = "1"b;
	go to put1;
rw (6):						/* Reserved word "DEBUGGING" */
						/*[4.0-5]*/
	rw_debugging = "1"b;
	go to put1;

rw (7):						/* One of the following reserved words:
				   DEBUG-CONTENTS, DEBUG-ITEM, DEBUG-LINE, DEBUG-NAME,
				   DEBUG-SUB-1, DEBUG-SUB-2, DEBUG-SUB-3,
				   LINAGE-COUNTER, LINE-COUNTER, PAGE-COUNTER, TALLY. */
	special_usrwd.line = ptr2 -> reserved_word.line;
	special_usrwd.column = ptr2 -> reserved_word.column;
	s = ptr2 -> reserved_word.key;

/*[4.4-2]*/
	if fixed_common.comp_level < "3"
	then call lev_diag (42, ptr2);

	adiag.number = 0;				/* none yet */
	linage_counter_type9.line = ptr2 -> reserved_word.line;
	linage_counter_type9.column = ptr2 -> reserved_word.column;
	linage_counter_type9.seg = 0;
	adiag.line = user_word.line;
	adiag.column = user_word.column;
	call swfget;
	if user_word.type = 1 & (ptr2 -> reserved_word.key = reswd_IN | ptr2 -> reserved_word.key = reswd_OF)
	then do;
		return_code = rcode_SCAN_NEXT;
		call swfget;
		if user_word.type ^= 8
		then adiag.number = fatal_INVALID_QUALIFIER;
		else do;
			adiag.line = user_word.line;
			adiag.column = user_word.column;
			counter = 1;
			ptrtable (1) = ptr2;
			call cobol_usrwd (addr (ptrtable (1)), counter, string_ptr, 0, ntendptr, "0"b, was_found,
			     not_found, diag_no, ntptr2);
			if not_found
			then adiag.number = fatal_FILE_NAME_EXPECTED;
			else if ^was_found
			then adiag.number = diag_no;
			else do;
				if ntptr2 -> fd_token.type = 12
				then do;
					call cobol_read_ft_ (ntptr2 -> fd_token.file_no, ft_ptr);
					if file_table.linage
					then linage_counter_type9.seg = file_table.fsb.seg;
					else adiag.number = fatal_NO_LINAGE_FOR_THIS_FILE;
				     end;
				else adiag.number = fatal_FILE_NAME_EXPECTED;
			     end;
		     end;
	     end;					/* qualifier specified */
	else do;					/* there must be only one file with linage then */
		return_code = rcode_SCAN_CURRENT;
		do i = 1 to fixed_common.file_count;
		     call cobol_read_ft_ (i, ft_ptr);
		     if file_table.linage
		     then do;
			     if linage_counter_type9.seg ^= 0
			     then do;
				     adiag.number = fatal_AMBIGUOUS_LINAGE_REF;
				     i = fixed_common.file_count;
				end;
			     else linage_counter_type9.seg = file_table.fsb.seg;
			end;
		end;
		if linage_counter_type9.seg = 0
		then adiag.number = fatal_NO_LINAGE_FOR_ANY_FILE;
	     end;					/* no qualifier specified */
	call swfput1 (addr (linage_counter_type9));
	if adiag.number ^= 0
	then call swfput1 (addr (adiag));
	return;					/*		     end;
/*	else	if s = 565
/*		then do;		/* LINE-COUNTER */
						/*			special_usrwd.length = 12;
/*			special_usrwd.name = cline_counter;
/*		    end;
/*	else	if s = 578
/*		then do;		/* PAGE-COUNTER */
						/*			special_usrwd.length = 12;
/*			special_usrwd.name = cpage_counter;
/*		    end;
/*	else	if s = 440
/*		then do;		/* SYSTEM-STATUS */
						/*			special_usrwd.length = 13;
/*			special_usrwd.name = csystem_status;
/*		    end;
/*	else do;			/* Assume TALLY. */
						/*		special_usrwd.length = 5;
/*		special_usrwd.name = ctally;
/*	    end;
/*	special_usrwd.size = size_TOKEN(8) + special_usrwd.length;
/*	recsize2 = special_usrwd.size;
/*	ptr2 = addr(special_usrwd);
/*	go to replab(8);		/* Process as a user word. */
						/* RFI */

rw (9):						/* Reserved word "SEARCH" */
	rw_search = "1"b;
	go to put1;

rw (8):
	rw_initterm, rw_generate = "0"b;		/* Reserved words PERFORM, INITIATE, TERMINATE, GENERATE */
	rw_switch = "1"b;
	rw_perform = "1"b;				/*[4.4-1]*/
	if ptr2 -> reserved_word.key = reswd_INITIATE | ptr2 -> reserved_word.key = reswd_TERMINATE
						/*[4.4-1]*/
	then rw_initterm = "1"b;
	else if ptr2 -> reserved_word.key = reswd_GENERATE
	then rw_generate = "1"b;
	go to put1;
rw (10):						/* Reserved words SEQUENCE, UPON, FROM, SET */
	rw_key = ptr2 -> reserved_word.key;
	call swfput;
	call swfget;
	return_code = rcode_SCAN_CURRENT;
	if rw_key = reswd_UPON
	then do;					/* DISPLAY UPON {SYSOUT | CONSOLE} */
		if user_word.type = 8
		then if substr (user_word.word, 1, user_word.length) = "console"
			| substr (user_word.word, 1, user_word.length) = "sysout"
		     then do;
			     counter = 1;
			     ptrtable (1) = ptr2;
			     call cobol_usrwd (addr (ptrtable (1)), counter, string_ptr, 0, ntendptr, "0"b,
				was_found, not_found, diag_no, ntptr2);
			     if not_found
			     then do;
				     call issue_obsolete_warning;
				     string (type17.class) = "000100"b;
						/* display device */
				     if user_word.length = 6
				     then type17.iw_key = 10;
						/* SYSOUT */
				     else type17.iw_key = 11;
						/* CONSOLE */
				     call put_type17;
				end;
			end;
	     end;

	else if rw_key = reswd_FROM
	then do;					/* ACCEPT FROM {SYSIN | CONSOLE} */
		rw_switch = "0"b;			/* as with rw(3) */
		if user_word.type = 8
		then if substr (user_word.word, 1, user_word.length) = "console"
			| substr (user_word.word, 1, user_word.length) = "sysin"
		     then do;
			     counter = 1;
			     ptrtable (1) = ptr2;
			     call cobol_usrwd (addr (ptrtable (1)), counter, string_ptr, 0, ntendptr, "0"b,
				was_found, not_found, diag_no, ntptr2);
			     if not_found
			     then do;
				     call issue_obsolete_warning;
				     string (type17.class) = "001000"b;
						/* accept device */
				     if user_word.length = 5
				     then type17.iw_key = 9;
						/* SYSIN */
				     else type17.iw_key = 11;
						/* CONSOLE */
				     call put_type17;
				end;
			end;
	     end;

	else if rw_key = reswd_SET
	then do;					/* SET SWITCH-n */
		rw_switch = "0"b;			/* as with rw(3) */
		if user_word.type = 8
		then if user_word.length = 8 & substr (user_word.word, 1, 7) = "switch-"
		     then do;
			     temp_char = substr (user_word.word, 8, 1);
			     if temp_char >= "1" & temp_char <= "8"
			     then do;
				     counter = 1;
				     ptrtable (1) = ptr2;
				     call cobol_usrwd (addr (ptrtable (1)), counter, string_ptr, 0, ntendptr,
					"0"b, was_found, not_found, diag_no, ntptr2);
				     if not_found
				     then do;
					     call issue_obsolete_warning;
					     string (type17.class) = "010000"b;
						/* switch_name */
					     type17.iw_key = fixed (temp_char);
					     call put_type17;
					end;
				end;
			end;
	     end;

	else if rw_key = reswd_SEQUENCE
	then do;					/* {SORT | MERGE} ... SEQUENCE {IS} {ASCII | EBCDIC} */
		if user_word.type = 1
		then if ptr2 -> reserved_word.key = reswd_IS
		     then do;
			     call swfput;
			     call swfget;
			end;
		if user_word.type = 8
		then if substr (user_word.word, 1, user_word.length) = "ascii"
			| substr (user_word.word, 1, user_word.length) = "ebcdic"
		     then do;
			     counter = 1;
			     ptrtable (1) = ptr2;
			     call cobol_usrwd (addr (ptrtable (1)), counter, string_ptr, 0, ntendptr, "0"b,
				was_found, not_found, diag_no, ntptr2);
			     if not_found
			     then do;
				     call issue_obsolete_warning;
				     type40.line, type40.def_line = adiag.line;
				     type40.column = adiag.column;
				     type40.type = 40;
				     type40.name_size = user_word.length;
				     type40.name = substr (user_word.word, 1, user_word.length);
				     type40.size = size_TOKEN (40) + type40.name_size;
				     if user_word.length = 5
				     then type40.iw_key = 11;
						/* ASCII */
				     else call cobol_set_type40_$ebcdic (addr (type40));
						/* EBCDIC */
						/*-07/26/76-*/
				     call swfput1 (addr (type40));
				     return_code = rcode_SCAN_NEXT;
				end;
			end;
	     end;

	return;


put_type17:
     proc;
	type17.line, type17.def_line = user_word.line;
	type17.column = user_word.column;
	type17.name_size = user_word.length;
	type17.name = substr (user_word.word, 1, user_word.length);
	type17.size = size_TOKEN (17) + type17.name_size;
	call swfput1 (addr (type17));
	return_code = rcode_SCAN_NEXT;
	return;
     end put_type17;

issue_obsolete_warning:
     proc;
	adiag.line = user_word.line;
	adiag.column = user_word.column;
	adiag.number = warn_OBSOLETE_MNEMONIC_NAME;
	call cobol_c_list (addr (adiag));
	if cobol_$compile_count ^= replb_compile_count
	then do;					/* once per compilation */
		adiag.number = obs_SPECIAL_NAMES_NOTE;
		call cobol_c_list (addr (adiag));

/*[4.4-2]*/
		if fixed_common.comp_level < "5"
		then call lev_diag (125, ptr2);

		replb_compile_count = cobol_$compile_count;
	     end;
	adiag.number = warn_SPECIAL_NAMES_RECOVERY;
	adiag.size = 40;
	substr (adiag.info, 1, 1) = "1"b;
	adiag.image_size = user_word.length;
	adiag.image = substr (user_word.word, 1, user_word.length);
	call cobol_c_list (addr (adiag));
	adiag.size = 28;
	substr (adiag.info, 1, 1) = "0"b;
	adiag.image_size = 0;
	return;
     end issue_obsolete_warning;			/*-07/07/76-*/


/*************************************/
replab (2):					/* numeric literal */
	if rw_switch
	then if ptr2 -> numeric_lit.sign = " " & ptr2 -> numeric_lit.exp_sign = " " & ptr2 -> numeric_lit.integral
	     then do;				/* unsigned integer with no exponent */
		     ptr2_1 = ptr2;
		     num_literal = "1"b;
		     counter = 0;
		     topstack = 1;
		     call push1;
		     go to usw1;
		end;
	go to put;
replab (3):
	;
replab (4):
	;
replab (5):
	;
replab (6):					/* alphanumeric literal, picture string, message, source card */
	go to put;
replab (7):					/* section or paragraph name definition */
	if type25_flag
	then go to put;				/* Simply write out DDALLOC appended type 7 */
	if ^ptr2 -> proc_def.searched
	then do;					/* This section or paragraph name not replaced yet. */
		special_usrwd.column = ptr2 -> proc_def.proc_num;
		special_usrwd.length = ptr2 -> proc_def.name_size;
		substr (special_usrwd.name, 1, special_usrwd.length) =
		     substr (ptr2 -> proc_def.name, 1, ptr2 -> proc_def.name_size);
		save_ptr2 = ptr2;
		ptr2 = addr (special_usrwd);

/* Try to find this section or paragraph name in the name table buffer. */

		call cobol_find_secdef (ptr2, sectno, string_ptr, ntptr);
		if ntptr ^= null ()
		then do;				/* found the name table buffer entry */
						/*			ntptr->proc_def.searched = "1"b;  /* Mark as "already replaced". */
						/*-11/11/76-*/
			ntptr -> proc_def.type = 7;
			call swfput1 (ntptr);	/* Write out entry from name table buffer. */
			ntptr -> proc_def.type = 18;	/* Restore type in name table buffer to 18. */
			call swfget;		/* Read next record from input file. */
			return_code = rcode_SCAN_CURRENT;
						/* Scan current record next. */
			return;
		     end;
		else ptr2 = save_ptr2;		/* Section or paragraph name not found - Restore ptr2. */
	     end;
	go to put;
replab (8):
	counter = 0;
	topstack = 1;
	stackbegptr = addr (stack);
	name_stack_overflow = "0"b;
	too_many_qualifiers = "0"b;			/*[4.2-7]*/
	P2 = ptr2;				/* save loc of user word token */
uswo:
	call push;
usw1:
	sav_ptr = ptr2;
	call swfget;
	qualif = "0"b;				/*[4.4-2]*/
usw2:
	if ptr2 -> reserved_word.type = 1 /*[4.4-2]*/
	     & (ptr2 -> reserved_word.key = 133 | ptr2 -> reserved_word.key = 101)
						/* "OF" or "IN" */
	then do;					/*[4.0-4]*/
		num_literal = "0"b;
again:
		call swfget;
		if user_word.type = 8
		then do;				/* Qualification test for leveling*/
			if fixed_common.comp_level < "3"
			then qualif = "1"b;		/*[4.4-1]*/
			call push;
			call swfget;
			go to usw2;
		     end;
		if user_word.type = 2 & rw_switch
		then do;
			if ptr2 -> numeric_lit.sign = " " & ptr2 -> numeric_lit.exp_sign = " "
			     & ptr2 -> numeric_lit.integral
			then do;			/* unsigned integer with no exponent */
						/*[4.4-2]*/
				call push1;
				call swfget;	/*[4.4-2]*/
				go to usw2;
			     end;
		     end;
		if ptr2 -> reserved_word.type = 1 & ptr2 -> reserved_word.key = 531
						/* DEBUG-ITEM */
		then go to rw (7);			/* special processing for reserved word "DEBUG-ITEM" */

/* The current record follows "OF" or "IN", but is not a type 8 token. */

diag1:
		adiag.number = 10;
		adiag.line = user_word.line;
		adiag.column = user_word.column;
		ptr3 = addr (adiag);
		call swfput1 (ptr3);		/* Write out the diagnostic record. */
		return_code = rcode_ERROR_DETECTED;
		return;
	     end;

	if name_stack_overflow | too_many_qualifiers
	then do;
		return_code = rcode_ERROR_DETECTED;
		return;
	     end;

/*[4.0-4]*/
	if ptr2 -> reserved_word.type = 1 & ptr2 -> reserved_word.key = 168
						/* times */
						/*[4.0-4]*/
	then do;					/*[4.0-4]*/
		rw_switch = "0"b;			/*[4.0-4]*/
		if num_literal			/*[4.0-4]*/
		then do;				/*[4.0-4]*/
			num_literal = "0"b;		/*[4.0-4]*/
			ntptr = ptr2_1;		/*[4.0-4]*/
			go to found1;		/*[4.0-4]*/
		     end;				/*[4.0-4]*/
	     end;

	call cobol_usrwd (addr (ptrtable (1)), counter, string_ptr, sectno, ntendptr, rw_switch, was_found, not_found,
	     diag_no, ntptr2);

	if was_found
	then go to found;
	if not_found				/*[4.0-5]*/
	then if rw_debugging			/*[4.0-5]*/
	     then do;
		     call cobol_usrwd (addr (ptrtable (1)), counter, string_ptr, sectno,
						/*[4.0-5]*/
			ntendptr, ^rw_switch,	/*[4.0-5]*/
			was_found, not_found, diag_no, ntptr2);

/*[4.0-5]*/
		     if was_found
		     then go to found;		/*[4.0-5]*/
		     if not_found
		     then go to notfound;		/*[4.0-5]*/
		end;

/*[4.0-5]*/
	     else go to notfound;

	adiag.number = diag_no;
	call issue_diag;
	return_code = rcode_ERROR_DETECTED;
	return;

notfound:
	if ^rw_switch
	then adiag.number = fatal_DATANAME_NOT_DECLARED;
	else adiag.number = fatal_PROCNAME_NOT_DECLARED;
	call issue_diag;
	return_code = rcode_ERROR_DETECTED;
	return;

put:
	return_code = rcode_NO_INTEREST;
	return;
put1:
	return_code = rcode_RESWORD_REC;
	return;
found:						/*[4.4-2]*/
	if qualif
	then call lev_diag (5, sav_ptr);		/*[4.4-2]*/
	call l66_test;

	ntptr = ntptr2;
found1:
	if fixed_common.options.xrn
	then if auser_word.line > 0
	     then do;
		     chain_count = chain_count + 1;
		     chain_area.ref_line (chain_count) = auser_word.line;
		     chain_area.next (chain_count) = 0;
		     xref_ptr = addrel (ntptr, divide (ntptr -> data_name.size + 3, 4, 17, 0));
		     if xref_chain.last = 0
		     then xref_chain.first = chain_count;
		     else chain_area.next (xref_chain.last) = chain_count;
		     xref_chain.last = chain_count;
		end;				/**/
						/*	if ^rw_using
/*	then call unload;
/**/
	return_code = rcode_DNAME_REC;
	return;
     end repl3_scan;

rend:
	return;					/* Have just read an End Of File - Exit from REPLB. */

push:
     proc;

	if name_stack_overflow | too_many_qualifiers
	then return;

	if counter = 50
	then do;					/* too many qualifiers in this reference */
		adiag.number = 11;
		call issue_diag;
		too_many_qualifiers = "1"b;
		return;
	     end;
	stackptr = addr (temp_stack (topstack));
	topstack = topstack + recsize2 + 4 - mod (recsize2, 4);

	if topstack > name_stack_size
	then do;					/* NAME STACK OVERFLOW */
		adiag.number = 12;
		call issue_diag;
		name_stack_overflow = "1"b;
		return;
	     end;
	stackrecord = minpr_record;
	counter = counter + 1;
	ptrtable (counter) = stackptr;

     end push;

/**/
/*unload:	proc;
/*
/*	if final_iter
/*	then return;
/*
/*	do j = 1 to counter;
/*		ptr3 = ptrtable(j);
/*		stackptr = ptrtable(j);
/*		call swfput1(ptr3);
/*		if j ^= counter
/*		then call swfput1(addr(res_word_of));
/*	end;
/*	return;
/*
/*end unload;
/**/

swfget:
     proc;

	call cobol_swf_get (cobol_curr_in, status, ptr2, recsize2);
	if status_right ^= "0"b
	then go to rend;
	return;

     end swfget;

swfput:
     proc;

	temp_ptr = addrel (cobol_curr_out, shdr.next + 1);
	call cobol_swf_put (cobol_curr_out, status, ptr2, ptr2 -> data_name.size);
	if temp_ptr -> data_name.type = 9
	then temp_ptr -> data_based.offset = binary (rel (ptr2));
	return;

     end swfput;

swfput1:
     proc (out_ptr);

dcl	out_ptr		ptr;

	temp_ptr = addrel (cobol_curr_out, shdr.next + 1);
	call cobol_swf_put (cobol_curr_out, status, out_ptr, out_ptr -> data_name.size);
	if temp_ptr -> data_name.type = 9
	then temp_ptr -> data_based.offset = binary (rel (out_ptr));
	return;

     end swfput1;

swfput2:
     proc (out_ptr);

/*[4.0-5]*/
/* obtain name as qualified in the	*/
/*[4.0-5]*/
/* source program when debugging mode	*/
/*[4.0-5]*/
/* used				*/

/*[4.0-5]*/
declare	out_ptr		ptr;			/*[4.0-5]*/
declare	sz		fixed bin,
	p		ptr;

/*[4.0-5]*/
declare	nt_entry		char (2048);		/*[4.0-5]*/
declare	nam_tab		char (2048) based;

/*[4.4-3]*/
	if ^fixed_common.debug | (fixed_common.debug & counter = 1)
						/*[4.0-5]*/
	then do;
		call swfput1 (out_ptr);		/* debugging not used */
						/*[4.0-5]*/
		return;				/*[4.0-5]*/
	     end;

/*[4.0-5]*/
	p = addr (nt_entry);

/*[4.4-3]*/
	sz = out_ptr -> data_name.size;		/*[4.4-3]*/
	substr (nt_entry, 1, sz) = substr (out_ptr -> nam_tab, 1, sz);

/* qualify the data name */

/*[4.4-3]*/
	substr (addr (p -> data_name.name) -> ch32, 1, 32) =
	     /*[4.4-3]*/ substr (addr (ptrtable (1) -> user_word.word) -> ch32, 1, 32);
						/*[4.4-3]*/
	p -> data_name.name_size = 32;

/*[4.0-5]*/
	call swfput1 (p);

     end;

issue_diag:
     proc;

	adiag.line = stackbegptr -> auser_word.line;
	adiag.column = stackbegptr -> auser_word.column;
	ptr3 = addr (adiag);
	call swfput1 (ptr3);
     end issue_diag;

push1:
     proc;

	if name_stack_overflow | too_many_qualifiers
	then return;

	if counter = 50
	then do;					/* too many qualifiers in this reference */
		adiag.number = 11;
		call issue_diag;
		too_many_qualifiers = "1"b;
		return;
	     end;
	stackptr = addr (temp_stack (topstack));
	if topstack > name_stack_size
	then do;					/* NAME STACK OVERFLOW */
		adiag.number = 12;
		call issue_diag;
		name_stack_overflow = "1"b;
		return;
	     end;
	auser_word.line = ptr2 -> numeric_lit.line;
	auser_word.column = ptr2 -> numeric_lit.column;
	auser_word.type = 8;
	auser_word.info1 = false;
	auser_word.info2 = false;
	auser_word.length = ptr2 -> numeric_lit.places;
	auser_word.word = ptr2 -> numeric_lit.literal;
	auser_word.size = 24 + ptr2 -> numeric_lit.places;

	counter = counter + 1;
	topstack = topstack + auser_word.size + mod (-auser_word.size, 4);
						/*[3.0-1]*/
	ptrtable (counter) = stackptr;

     end push1;

process_subscript:
     proc (stack);

/* Processes subscripts in cases where speciaal processing is required.
		   (i.e.:
			1) expand_condition_names - the subscript tokens are stacked for special
			   processing by repl3_expand.
			2) INITIALIZE - the subscript tokens should be written out with no
			   intervening type 26 tokens.) */

dcl	stack		bit (1);			/* if "1"b, stack tokens in ss_stack, else write to output file. */

	processing_subscript = "1"b;
	ss_recovered = "0"b;
	next_state = 1;
	if stack
	then do;					/* Initialize ss_stack variables and stack "(" token. */
		cobol_ss_stack.no_entries = 0;
		subscript_stack_overflow = "0"b;
		ss_topstack = 1;
		call push_special;
	     end;
	else call swfput;				/* Write "(" token. */
ss_read:
	call swfget;
ss_scan:
	call repl3_scan (status, return_code);
	if return_code = rcode_NO_INTEREST & user_word.type > 4
	then do;
		call swfput;			/* Write out current record in read buffer. */
		if user_word.type = 5
		then do;				/* diagnostic record */
			call swfget;
			go to ss_recover;
		     end;
		else go to ss_read;
	     end;
	go to ss_state (next_state);
ss_state (1):
	if return_code = rcode_NO_INTEREST & user_word.type = 2
						/* numeric literal */
	then do;
		next_state = 1;
		if stack
		then call push_special;
		else call swfput;
		go to ss_read;
	     end;
	else if return_code = rcode_RESWORD_REC
	then do;					/* a reserved word */
		if ptr2 -> reserved_word.key = 188	/* ")" */
		then do;
			if stack
			then call push_special;
			else call swfput;
			call swfget;
			go to ss_finish;
		     end;
		else if ptr2 -> reserved_word.key = 182 /* "+" */
		then do;
			next_state = 4;
			if stack
			then call push_special;
			else call swfput;
			go to ss_read;
		     end;
		else do;				/* Bad component in subscript */
			adiag.number = 7;
			go to ss_error;
		     end;
	     end;
	else if return_code = rcode_DNAME_REC
	then do;					/* a user name */
		next_state = 2;
		if stack
		then call push_name;
		else do;
			save_line = ntptr -> data_name.line;
			save_column = ntptr -> data_name.column;
			ntptr -> data_name.line = stackbegptr -> auser_word.line;
			ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
			call swfput2 (ntptr);
			ntptr -> data_name.line = save_line;
			ntptr -> data_name.column = save_column;
		     end;
		go to ss_scan;
	     end;
	else do;					/* Bad component in subscript */
		adiag.number = 7;
		go to ss_error;
	     end;
ss_state (2):
	if return_code = rcode_RESWORD_REC & ptr2 -> reserved_word.key = 183
						/* "-" */
	then do;
		next_state = 3;
		if stack
		then call push_special;
		else call swfput;
		go to ss_read;
	     end;
	else do;
		next_state = 1;
		if return_code = rcode_DNAME_REC
		then if stack
		     then call push_name;
		     else do;
			     save_line = ntptr -> data_name.line;
			     save_column = ntptr -> data_name.column;
			     ntptr -> data_name.line = stackbegptr -> auser_word.line;
			     ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
			     call swfput2 (ntptr);
			     ntptr -> data_name.line = save_line;
			     ntptr -> data_name.column = save_column;
			end;
		go to ss_scan;
	     end;
ss_state (3):
	if return_code = rcode_NO_INTEREST & user_word.type = 2
						/* numeric literal */
	then do;
		next_state = 1;
		if stack
		then call push_special;
		else call swfput;
		go to ss_read;
	     end;
	else do;
		adiag.number = 9;			/* numeric literal expected here */
		go to ss_error;
	     end;
ss_state (4):
	if return_code = rcode_NO_INTEREST & user_word.type = 2
						/* numeric literal */
	then do;
		next_state = 1;
		if stack
		then call push_special;
		else call swfput;
		go to ss_read;
	     end;
	else if return_code = rcode_DNAME_REC
	then do;					/* a data name */
		next_state = 1;
		if stack
		then call push_name;
		else do;
			save_line = ntptr -> data_name.line;
			save_column = ntptr -> data_name.column;
			ntptr -> data_name.line = stackbegptr -> auser_word.line;
			ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
			call swfput2 (ntptr);
			ntptr -> data_name.line = save_line;
			ntptr -> data_name.column = save_column;
		     end;
		go to ss_scan;
	     end;
	else do;					/* numeric literal, data-name, or index-name expected here */
		adiag.number = 8;
		go to ss_error;
	     end;
ss_error:
	if return_code = rcode_ERROR_DETECTED
	then go to ss_recover;			/* An error message has already been issued. */
	if return_code = rcode_DNAME_REC
	then do;
		adiag.line = stackbegptr -> auser_word.line;
		adiag.column = stackbegptr -> auser_word.column;
	     end;
	else do;
		adiag.line = user_word.line;
		adiag.column = user_word.column;
	     end;
	ptr3 = addr (adiag);
	call swfput1 (ptr3);			/* Write out the diagnostic. */
ss_recover:					/* Attempt to recover to the 1st statement terminator,
				   or to a suitable key reserved word. */
	do while (^ss_recovered);
	     call repl3_scan (status, return_code);
	     if return_code = rcode_RESWORD_REC
	     then do;
		     if ptr2 -> reserved_word.terminator
		     then ss_recovered = "1"b;
		     else do;
			     rwkey = ptr2 -> reserved_word.key;
			     if expand_condition_names
			     then do;
				     if rwkey = 77 /* "AND" */ | rwkey = 135
						/* "OR" */
				     then ss_recovered = "1"b;
				end;
			     else if rw_corresponding
			     then do;
				     if rwkey = 170 /* "TO" */ | rwkey = 111
						/* "FROM" */
				     then ss_recovered = "1"b;
				end;
			end;
		end;
	     else if return_code = rcode_NO_INTEREST
	     then if user_word.type = 5
		then call swfput;			/* Write out diagnostic */
	     if ^ss_recovered
	     then call swfget;
	end;
ss_finish:
	processing_subscript = "0"b;

     end process_subscript;

push_special:
     proc;

	if subscript_stack_overflow
	then return;

	ss_stack_ptr = addr (ss_template (ss_topstack));
	ss_recsize = recsize2;
	ss_topstack = ss_topstack + ss_recsize + 4 - mod (ss_recsize, 4);

	if ss_topstack > subscript_stack_size
	then do;					/* SUBSCRIPT STACK OVERFLOW */
		stackbegptr = ptr2;
		adiag.number = 13;
		call issue_diag;
		subscript_stack_overflow = "1"b;
		return;
	     end;
	cobol_ss_stackrecord = minpr_record;
	cobol_ss_stack.no_entries = cobol_ss_stack.no_entries + 1;
	ss_ptrtable (cobol_ss_stack.no_entries) = ss_stack_ptr;
						/**/
						/*	if ^final_iter
/*	then call swfput;
/**/
     end push_special;

push_name:
     proc;

dcl	ntrecord		char (ss_recsize) based (ntptr);

	if subscript_stack_overflow
	then return;

	save_line = ntptr -> data_name.line;
	save_column = ntptr -> data_name.column;
	ntptr -> data_name.line = stackbegptr -> auser_word.line;
	ntptr -> data_name.column = stackbegptr -> auser_word.column;
	ss_recsize = ntptr -> data_name.size;
	ss_stack_ptr = addr (ss_template (ss_topstack));
	ss_topstack = ss_topstack + ss_recsize + 4 - mod (ss_recsize, 4);

	if ss_topstack > subscript_stack_size
	then do;					/* SUBSCRIPT STACK OVERFLOW */
		stackbegptr = ptr2;
		adiag.number = 13;
		call issue_diag;
		subscript_stack_overflow = "1"b;
		return;
	     end;
	cobol_ss_stackrecord = ntrecord;
	cobol_ss_stack.no_entries = cobol_ss_stack.no_entries + 1;
	ss_ptrtable (cobol_ss_stack.no_entries) = ss_stack_ptr;
	ntptr -> data_name.line = save_line;		/* Restore correct line & column to name table entry. */
	ntptr -> data_name.column = save_column;

     end push_name;

/* RFI */

perform_recover:
     proc (status, recovered_to_thru);

dcl	status		bit (32);
dcl	recovered_to_thru	bit (1);			/* Set to "1"b by this procedure if a "THRU" is found before
					   any occurrence of:
						TIMES, UNTIL, VARYING, or a statement terminator. */
dcl	1 status_word	based (st_ptr),
	  2 status_left	bit (16),
	  2 status_right	bit (16);
dcl	st_ptr		ptr;

	st_ptr = addr (status);
	status = "0"b;
	recovered_to_thru = "0"b;
recover_analysis:
	if return_code = rcode_RESWORD_REC
	then do;					/* a reserved word */
		if ptr2 -> reserved_word.key = 166	/* "THRU" */
		then do;
			recovered_to_thru = "1"b;
			return;
		     end;
		else if ptr2 -> reserved_word.key = 168 /* "TIMES" */
		     | ptr2 -> reserved_word.key = 173 /* "UNTIL" */
		     | ptr2 -> reserved_word.key = 177 /* "VARYING" */ | ptr2 -> reserved_word.terminator
		then return;
		else go to recover_write;
	     end;
	if return_code = rcode_ERROR_DETECTED
	then go to recover_scan;
	if return_code = rcode_DNAME_REC
	then do;					/* Write out the name table entry. */
		save_line = ntptr -> data_name.line;
		save_column = ntptr -> data_name.column;
		ntptr -> data_name.line = stackbegptr -> auser_word.line;
		ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
		call swfput2 (ntptr);
		ntptr -> data_name.line = save_line;	/* Restore correct line and column to name table entry. */
		ntptr -> data_name.column = save_column;
		go to recover_scan;
	     end;

/* The current record is a no interest record and is simply written out. */

recover_write:
	call swfput;
recover_read:
	call swfget;
	if status_right ^= "0"b
	then go to rend;
recover_scan:
	call repl3_scan (status, return_code);
	if status_right ^= "0"b
	then go to rend;
	else go to recover_analysis;

     end perform_recover;

/*======================================*/

lev_diag:
     proc (diag_num, p);				/*[4.4-2]*/
declare	p		ptr;
dcl	diag_num		fixed bin;
dcl	lev_diag_ptr	ptr;
dcl	1 lev_diag_item,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 run		fixed bin,
	  2 number	fixed bin,
	  2 info		bit (32);

	lev_diag_item.size = 28;
	lev_diag_item.type = 5;
	lev_diag_item.run = 9;
	lev_diag_item.info = "0"b;			/*[4.4-2]*/
	lev_diag_item.line = p -> user_word.line;	/*[4.4-2]*/
	lev_diag_item.column = p -> user_word.column;
	lev_diag_item.number = diag_num;

	lev_diag_ptr = addr (lev_diag_item);
	call cobol_c_list (lev_diag_ptr);

     end lev_diag;

/*[4.4-2]*/
l66_test:
     proc;					/* emit lev diag 220 if ref to level 66 item found */
						/*[4.4-2]*/
	if fixed_common.comp_level < "3"		/*[4.4-2]*/
	then if ntptr2 -> data_name.type = 9 & ntptr2 -> data_name.level = 66
						/*[4.4-2]*/
	     then call lev_diag (220, sav_ptr);

     end;						/*[4.4-2]*/





/*************************************/
/* INCLUDE FILES */

%include cobol_ext_;
%include cobol_io_info;
%include cobol_fixed_common;
%include cobol_file_table;
%include cobol_type17;
%include cobol_type1;
%include cobol_type2;
%include cobol_type7;
%include cobol_type9;
%include cobol_type12;
%include cobol_xref;
%include cobol_;

%include cobol_repl_diag_values;
%include cobol_size_values;
%include cobol_reswd_values;
     end cobol_replb;




		    cobol_report_writer.pl1         05/24/89  1046.0rew 05/24/89  0835.4      680364



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_report_writer.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 10/22/82 by FCH, [5.1-3], test for PIC  clauses, phx13531 */
/* Modified on 12/28/81 by FCH, [5.1-2], illegal syntax in report description sometimes causes abort, phx12123(BUG523) */
/* Modified on 12/23/81 by FCH, [5.1-1], wrong file selected for writing report, phx12125(BUG524) */
/* Modified on 08/17/81 by FCH, [5.0-1], reset clause improperly searched for in reset clause chain, BUG507(phx11578) */
/* Modified on 06/29/81 by FCH, [4.4-1], control final without other footing groups caused abort, BUG479(TR09695) */
/* Modified since Version 4.4 */






/* format: style3 */
cobol_report_writer:
     proc;

/*	This program prepares the description of the reports defined by the Report Section.
	The source code which comprises the report is produced from these descriptions by
	cobol_generate_report.pl1. The following trace codes are used:

		-tracerw(10000):	report table (produced by cobol_report_writer)


*/

declare	cobol_rw		entry (ptr);
declare	cobol_class_table_	entry (ptr);
declare	cobol_c_list	entry (ptr);
declare	cobol_syntax_trace_$trace
			entry (ptr, fixed bin (24));
declare	cobol_syntax_trace_$initialize_phase
			entry (ptr, fixed bin (24));
declare	cobol_generate_report
			entry (ptr, fixed bin, bit (1));
declare	cobol_swf_get	entry (ptr, bit (32), ptr, fixed bin);
declare	cobol_io_$cobol_msf_start
			entry (ptr, ptr);
declare	cobol_io_$cobol_save_pos
			entry (ptr, ptr);
declare	cobol_display_report$display_report_tables
			entry (ptr);
declare	cobol_syntax_trace_$trace_loc
			entry returns (ptr);

declare	(addr, string, substr, fixed, size, index, mod, null)
			builtin;


	report_SIZE = size (report);

	sum_ctr_ctr = 0;
	user_word_size = 40;
	non_term_node_SIZE = size (non_term_node);
	term_node_SIZE = size (term_node);

	reset_clause_SIZE = size (reset_clause);
	sum_SIZE = size (sum);
	reset_chain_entry_SIZE = size (reset_chain_entry);
	chain_entry_SIZE = size (chain_entry);
	ident_SIZE = size (ident);

	list_def_SIZE = size (list_def);
	list_link_SIZE = size (list_link);
	root_SIZE = size (root);
	ST.entry.level (0), rep_num = 0;

	integer_spec_size = 36 * size (integer_spec);
	non_term_node_line_size = 36 * size (non_term_node_line);
	term_node_line_size = 36 * size (term_node_line);

	rt_ptr, tn_ptr, ntn_ptr = null ();
	q_ptr = null ();
	prev_token_ptr = null ();
	current_report_loc = null ();
	list_def_ptr, list_link_ptr = null ();


	rwfp1 = cobol_m1fp;
	rwfp2 = cobol_m2fp;
	call cobol_io_$cobol_msf_start (rwfp1, report_first_token);
	ae_addr = addr (ae);

	NODE_line_ptr = addr (NODE.line);

	alloc_area.aa_loc = cobol$alloc (1024);
	alloc_area.aa_size = 1;
	alloc_area.aa_cap = 1024;

	stk_lev = 1;
	token_count = 0;

	call cobol_rw (pointer_to_internal);
	call cobol_class_table_ (class_tab_ptr);

/* initialize diag item */

	dg_ptr = addr (diag_item);
	diag_item.size = 28;
	diag_item.type = 5;
	diag_item.run = 4;

	diag_item.module = 0;

	success = S;
	fail = F;
	DIAG_NUM = 0;

	trace_ptr = addr (interp);
	tbit = fixed_common.syntax_trace;

	if tbit
	then call cobol_syntax_trace_$initialize_phase (trace_ptr, 5);
	trace_env_ptr = cobol_syntax_trace_$trace_loc ();
	current_line = 1;
	rwfp = rwfp1;
	call scan;

	go to new_inst;


/*					*/
/*	 syntax interpreter			*/
/*					*/

declare	(success, fail)	label;

declare	1 cl_token,
	  2 line		fixed bin,
	  2 column	fixed bin;



dcl	1 diag_item,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 run		fixed bin,
	  2 number	fixed bin,
	  2 module	fixed bin;

declare	1 syntax_table	(0:10000) based (pointer_to_internal),
	  2 b1		fixed bin,
	  2 b2		fixed bin,
	  2 b3		fixed bin,
	  2 b4		fixed bin,
	  2 b5		fixed bin;

declare	1 syntax_line	based (syntax_line_ptr),
	  2 s_bit		char (1),
	  2 o_bit		char (1),
	  2 t_type	fixed bin,
	  2 t_field	fixed bin,
	  2 s_exit	fixed bin,
	  2 a_num		fixed bin;

declare	1 c_t		based (class_tab_ptr),
	  2 filler	char (20),
	  2 ct		(1024) fixed bin (18) unal unsigned;
declare	CT		(0:8191) fixed bin based (class_tab_ptr);
declare	cd		(256) fixed bin (9) unal unsigned based;

declare	(rwfp, rwfp1, rwfp2)
			ptr;


declare	1 header		based (addr_record),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin;


declare	1 interp,
	  2 current_line	fixed bin (24),
	  2 phase		fixed bin (24),
	  2 addr_record	ptr,
	  2 pointer_to_internal
			ptr,
	  2 directory_ptr	ptr,
	  2 source_ptr	ptr;

declare	1 trace		based (trace_env_ptr),
	  2 curr_first	fixed bin,
	  2 curr_last	fixed bin,
	  2 phase,
	    3 first	(5) fixed bin,
	    3 last	(5) fixed bin;

declare	1 intrp_stack	(128),
	  2 ret_loc	fixed bin,
	  2 recov_loc	fixed bin;

declare	(DIAG_NUM, tln, act_num, stk_lev, status, token_count)
			fixed bin;
declare	trace_env_ptr	ptr;

declare	tm1		fixed bin (24) init (1);
declare	tm2		fixed bin (24) init (2);
declare	tm3		fixed bin (24) init (3);
declare	tm4		fixed bin (24) init (4);
declare	tm5		fixed bin (24) init (5);

declare	(tbit, ch_bit)	bit (1),
	st		bit (32);


F:						/*failure */
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm2);

/* next syntax instruction */
next_inst:
	current_line = current_line + 1;

new_inst:						/* new syntax instruction */
	syntax_line_ptr = addr (syntax_table (current_line));

	go to test (syntax_line.t_type);

test (0):						/* reserved word test */
						/* r= son= a= */
						/* r= sn= m= */
	if reserved_word.type ^= 1
	then go to fail;

	if reserved_word.key ^= syntax_line.t_field
	then go to fail;

S:						/* success */
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm1);

ucon:
	if syntax_line.o_bit ^= " "
	then do;
		if syntax_line.o_bit > fixed_common.comp_level
		then call diag (syntax_line.a_num);
		go to ret;
	     end;

	go to action (syntax_line.a_num);

test (1):						/* check routine test */
						/* c= son= a= */
						/* c= sn= m= */
	go to check (syntax_line.t_field);

test (2):						/* unconditional branch */
						/* son= a= d= */
						/* sn= m= */
	DIAG_NUM = syntax_line.t_field;
	act_num = syntax_line.a_num;

	if syntax_line.o_bit ^= " "
	then do;
		if syntax_line.o_bit > fixed_common.comp_level
		then do;
			diag_item.module = syntax_line.a_num;
			call diag (DIAG_NUM);
		     end;

		DIAG_NUM = 0;
		act_num = 0;
	     end;

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm1);
						/* execute action routine */
	go to action (act_num);			/* syntax procedure */
						/* s= son= a= */
						/* s= sn= m= */
test (3):
	stk_lev = stk_lev + 1;
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm3);

	if stk_lev > 128
	then do;
		diag_item.number = 183;
		diag_item.column = header.column;
		diag_item.line = header.line;

		call cobol_c_list (dg_ptr);

		return;
	     end;

	intrp_stack.ret_loc (stk_lev) = current_line;
	intrp_stack.recov_loc (stk_lev) = 0;
	current_line = syntax_line.t_field;

	go to new_inst;

test (4):						/* class test */
						/* k = son = a = */
						/* k = sn = m = */
	call class_test;

	if res = "0"b
	then go to fail;

	go to success;

test (5):						/* class dispatch */
						/* K = n = */
	call class_test;



	if res = "0"b
	then do;
		if tbit
		then call cobol_syntax_trace_$trace (trace_ptr, tm2);

		current_line = syntax_line.s_exit;

		go to new_inst;

	     end;

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm1);

	current_line = current_line + cl_off;

	go to new_inst;				/* action routines return here */
ret:
action (0):
	if DIAG_NUM ^= 0
	then call diag (DIAG_NUM);

	if syntax_line.s_bit = "s"
	then call scan;

	current_line = syntax_line.s_exit;

	go to new_inst;

action (1):					/* exit true from syntax procedure */
	current_line = intrp_stack.ret_loc (stk_lev);

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm4);

	syntax_line_ptr = addr (syntax_table (current_line));
	stk_lev = stk_lev - 1;

	go to ucon;

action (2):					/* exit false from syntax procedure */
	current_line = intrp_stack.ret_loc (stk_lev);

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm5);

	stk_lev = stk_lev - 1;

	go to next_inst;

recov_loc:
action (3):					/* establish recovery routine */
						/* n = RECOV_LOC a = recov_loc */
	intrp_stack.recov_loc (stk_lev) = syntax_line.s_exit;

	go to next_inst;

recvy:
action (4):
	call recovery;

	go to ret;

class_test:
     proc;

	res = "0"b;



	if reserved_word.type ^= 1
	then return;

	cl_off = c_t.ct (reserved_word.key);

	if cl_off = 0
	then return;

	cl_off = addr (CT (cl_off)) -> cd (syntax_line.t_field);


	if cl_off = 0
	then return;

	res = "1"b;
	cl_token.line = header.line;
	cl_token.column = header.column;
     end;

recovery:
     proc;					/* error recovery routine */


	success = S1;
	fail = F1;
	call diag (45);

	do while ("1"b);

	     do i = stk_lev by -1 to 1;

		res = "0"b;
		rl = intrp_stack.recov_loc (i);

		if rl ^= 0
		then do;
			syntax_line_ptr = addr (syntax_table (rl));

			go to RC (syntax_line.t_type);

RC (0):						/* r = */
			if reserved_word.type = 1
			then if reserved_word.key = syntax_line.t_field
			     then res = "1"b;

			go to RC0;

RC (1):						/* c = */
			go to check (syntax_line.t_field);

RC (4):						/* k = */
RC (5):						/* K = */
			call class_test;

			go to RC0;

S1:
			res = "1"b;
F1:
RC (2):
RC (3):
RC0:
		     end;

		if res
		then do;
			syntax_line_ptr = addr (syntax_table (rl));
			success = S;
			fail = F;
			stk_lev = i;

			return;
		     end;


	     end;

	     call scan;

	end;
     end;


diag:
     proc (diag_num);

declare	diag_num		fixed bin;

	diag_item.number = diag_num;
	diag_item.column = header.column;
	diag_item.line = header.line;

	call cobol_c_list (dg_ptr);

	diag_item.module = 0;
     end diag;

DIAG:
     proc (diag_num, line, column);

declare	(diag_num, line, column)
			fixed bin;

	diag_item.number = diag_num;
	diag_item.line = line;
	diag_item.column = column;

	call cobol_c_list (dg_ptr);

	diag_item.module = 0;

     end;						/* get the next token */
scan:
     proc;

declare	st		bit (32),
	rec_size		fixed bin;

	call cobol_swf_get (rwfp, st, addr_record, rec_size);
	token_count = token_count + 1;
	if substr (st, 17, 16) ^= "0"b
	then addr_record = addr (eof_token);

     end;



declare	1 eof_token,
	  2 (size, line, column, type)
			fixed bin init (9999);


/*
	Report Writer Diagnostic Messages

	1: a(14), a(56), a(63)		2:				3:
	4:				5:				6:
	7: a(66)				8: classify_node			9: classify_node
	10: classify_node			11:				12: classify_node
	13: check_line_clause		14:				15: classify_node
	16: classify_node			17:				18: test_for_fields
									    process_present_node
	19: check_line_clause		20: check_line_clause		21:
	22:				23:				24: check_page
	25:				26: form_subseq_fields		27: form_subseq_fields
	28:				29:				30:
	31:				32: check_page			33: check_page,...
	34: check_page			35: check_page			36:
	37:				38:				39:
	40:				41: process_cf_sum_clause		42: process_cf_sum_clause
	43:				44: a(66)				45:
	46: process_cf_reset_clause		47: process_control_group		48:
	49:				50: process_cf_reset_clause		51:
	52:				53:				54:
	55:				56:				57:
	58:				59:				60:
	61: find_use				62:				63:
	64:				65:				66:
	67:				68:				69:
	70:				71:				72:
	73:				74:				75:
	76: check_field_clause		77: check_field_clause		78:
	79:				80:				81: process_control_group
	82: process_control_group		83:				84:
	85:				86:				87:
	88:				89:				90:
	91:				92:				93:
	94:				95:				96:
	97:				98:				99:
	100:				101:				102:
	103:				104:				105:
	106:
*/

declare	(i, rl)		fixed bin;
declare	(trace_ptr, dg_ptr, syntax_line_ptr, class_tab_ptr)
			ptr;
declare	cl_off		fixed bin,
	class_def_ptr	ptr;
declare	(cssub, line_position)
			fixed bin;



declare	(subj_req, line_clause_found)
			bit (1);
declare	prev_token_ptr	ptr;
declare	(rd_clnum, rg_cl_num, pg_clnum)
			fixed bin;
declare	(lv_line, lv_col)	fixed bin;
declare	(node_ptr, up_entry)
			ptr;
declare	(prev_node_ptr, NODE_line_ptr)
			ptr;
declare	gch		char (32) varying;


declare	def_entry_ptr	ptr;
declare	(int_val, def_entry_size)
			fixed bin;
declare	(par_1, par_2)	fixed bin;
declare	(ptr_1, ptr_2)	ptr;
declare	(group_type, sum_count, id_count)
			fixed bin;
declare	(s_ptr, q_ptr)	ptr;
declare	(sum_first_ptr, sum_last_ptr, sum_reset_ptr)
			ptr;
declare	control_ptr	ptr;
declare	(rg_line, rg_column, pg_line, pg_column)
			fixed bin;
declare	(rd_line, rd_column)
			fixed bin;
declare	cd_lit		char (2);
declare	ae_addr		ptr;
declare	(not_found, found, res)
			bit (1);
declare	(ht_ptr, df_ptr, p, q, DF_ptr, HT_ptr, up_ptr)
			ptr;
declare	(control_count, group_number, line_number, field_number)
			fixed bin;

declare	1 group_bits,
	  2 RH		bit (1),			/* RH group */
	  2 PH		bit (1),			/* PH group */
	  2 CH		bit (1),			/* CH group */
	  2 DE		bit (1),			/* DE group */
	  2 CF		bit (1),			/* CF group */
	  2 PF		bit (1),			/* PF group */
	  2 RF		bit (1),			/* RF group */
	  2 BG		bit (1);			/* body group */

declare	rg_cl		bit (18);
declare	rg_cl_bits	(18) bit (1) unal defined rg_cl;

declare	rd_cl		bit (4);
declare	rd_cl_bits	(4) bit (1) unal defined rd_cl;

declare	pg_cl		bit (5);
declare	pg_cl_bits	(5) bit (1) defined pg_cl;

declare	rt_cl		bit (4);
declare	rt_cl_bits	(4) bit (1) defined rt_cl;

/* ACTION ROUTINES */

action (5):
c0s1:
	cssub = 0;
	subj_req = "1"b;
	go to ret;

action (6):
s0:
	subj_req = "0"b;
	go to ret;

action (7):
cdecrs1:
	cssub = cssub - 1;
	subj_req = "1"b;
	go to ret;

action (8):
cincrs1:
	cssub = cssub + 1;
	subj_req = "1"b;
	go to ret;

action (9):
cincr:
	cssub = cssub - 1;
	go to ret;

action (10):
rep_init:						/* initialize report list */
	report_list.count = 0;
	report_list.first, report_list.last = null ();
	prev_node_ptr, sum_chain_ptr = null ();
	group_number = 0;
	go to ret;

action (11):
rep_add:						/* add report to list */
	report_list.count = report_list.count + 1;	/*[5.1-2]*/
	if fatal_no ^= fixed_common.fatal_no
	then report.page.count = 0;			/* fatals occurred */
	call form_de_table;

	call set_cf_sum_chain;

	if last_root_ptr ^= null ()
	then call form_group_tables;

	if report_list.first = null ()
	then report_list.first, report_list.last = current_report_loc;
	else report_list.last -> report.rep_next, report_list.last = current_report_loc;

	current_report_loc = null ();
	go to ret;

action (12):
rg_init:						/* initialize for a report group entry */
	NODE.nd_tok_line = header.line;
	NODE.nd_tok_column = header.column;

	rg_cl = "0"b;				/* set to non term node */

	NODE.nd_name_ptr = null ();

	NODE.nd_level, NODE.next_group.type = 0;
	NODE.line.value = 0;
	NODE.line.type, NODE.column.type = 0;

	addr (NODE.usage_disp) -> bit12 = "0"b;

	NODE.nd_loc, NODE.picture = null ();		/*[5.1-2]*/
	NODE.control_name_ptr, NODE.rep_sum_ptr, NODE.rep_group_ptr = null ();
						/*[5.1-2]*/
	NODE.column.type, NODE.node_type = 0;


	par_1, group_type = 0;
	ptr_1, ptr_2 = null ();

	go to ret;

action (13):
rg_clnum:						/* rg clauses */
	rg_cl_num = cl_off;				/* clause number */
	rg_line = header.line;
	rg_column = header.column;
	go to ret;


action (14):
rg_clause:					/* process report group clause */
	if rg_cl_bits (rg_cl_num)
	then do;
		call DIAG (1, rg_line, rg_column);	/* clause previously defined */

		go to ret;
	     end;

	rg_cl_bits (rg_cl_num) = "1"b;		/* dispatch on clause type */

	go to RG (rg_cl_num);

RG (0):						/* illegal */
	go to RG0;

RG (1):						/* . */
	go to RG0;

RG (2):						/* LINE clause */
	NODE.line.type = par_1;
	NODE.line.value = par_2;
	go to RG0;

RG (3):						/* NEXT GROUP clause */
	NODE.next_group.type = par_1;
	NODE.next_group.value = par_2;
	go to RG0;

RG (4):						/*TYPE clause */
	group_type = par_1;
	go to RG0;

RG (5):						/* USAGE clause */
	NODE.usage_disp = "1"b;
	go to RG0;

RG (6):						/* PRESENT clause */
	go to RG0;

RG (7):						/* BLANK WHEN ZERO clause */
	NODE.blank_zero = "1"b;
	go to RG0;

RG (8):						/* GROUP INDICATE clause */
	NODE.group_ind = "1"b;
	go to RG0;

RG (9):						/* JUSTIFIED clause */
	NODE.just_right = "1"b;
	go to RG0;

RG (10):						/* COLUMN clause */
	NODE.column.type = par_1;
	NODE.column.value = par_2;
	go to RG0;

RG (11):						/* PICTURE clause */
	NODE.picture = addr_record;
	go to RG0;

RG (12):						/* SOURCE clause */
	NODE.data_type = 1;				/* type */
	NODE.nd_loc = ident_ptr;
	go to RG0;

RG (13):						/* VALUE clause */
	NODE.data_type = 2;				/* type */
	NODE.nd_loc = list_def_ptr;
	go to RG0;

RG (14):						/* SUM clause */
	NODE.data_type = 3;				/* type */

/* allocate space for a sum counter */

	call get_space (size (sum_counter), sum_counter_ptr);


	sum_counter.sct_reset_loc = reset_clause_ptr;	/* reset clause loc */
	sum_counter.sct_size = sum_counter_size;	/* sum clause count */

	do i = sum_counter_size by -1 to 1;

	     sum_counter.sct_loc (i) = sum_counter_lifo_ptr -> list_link.loc;
	     sum_counter_lifo_ptr = sum_counter_lifo_ptr -> list_link.next;

	end;

	NODE.nd_loc = sum_counter_ptr;

	go to RG0;

RG (15):						/* sign clause */
	go to RG0;

RG0:
	go to ret;

action (15):
rg_line_1:
	par_2 = int_val;
	if int_val > 999
	then call DIAG (24, cl_token.line, cl_token.column);
	go to ret;

action (16):
rg_line_2:
	par_1 = 1;				/* integer */
	go to ret;

action (17):
rg_line_3:
	par_1 = 2;				/* PLUS integer */
	go to rg_line_1;

action (18):
rg_line_4:
	par_1 = 3;				/* PAGE integer */
	go to ret;

action (19):
rg_group_1:
	par_1 = 3;				/* PLUS integer */
	go to ret;

action (20):
rg_group_2:
	par_1 = 1;				/* NEXT PAGE */
	go to ret;

action (21):
rg_group_3:
	par_1 = 2;				/* integer */
	go to ret;

action (22):
rg_group_4:
	par_2 = int_val;
	if int_val > 999
	then call DIAG (24, cl_token.line, cl_token.column);
	go to ret;

action (23):
rg_type_1:
	par_1 = cl_off;				/* rh,ph,ch,de,cf,pf,rf */
	go to ret;

action (24):
rg_type_2:
	par_1 = 1;				/* REPORT HEADING */
	go to ret;

action (25):
rg_type_3:
	par_1 = 7;				/* REPORT FOOTING */
	go to ret;

action (26):
rg_type_4:
	par_1 = 3;				/* CONTROL HEADING */
	go to ret;

action (27):
rg_type_5:
	par_1 = 5;				/* CONTROL FOOTING */
	go to ret;

action (28):
rg_type_6:
	NODE.control_name_ptr = null ();		/* CONTROL FINAL */
	go to ret;

action (29):
rg_type_7:
	par_1 = 2;				/* PAGE HEADING */
	go to ret;

action (30):
rg_type_8:
	par_1 = 6;				/* PAGE FOOTING */
	go to ret;

action (31):
rg_pres_1:
	par_1 = token_count;
	ptr_1 = addr_record;
	go to ret;

action (32):
rg_pres_2:
	ptr_2 = prev_token_ptr;
	go to ret;

action (33):
rg_col_1:
	par_1 = 2;				/* PLUS integer */
	go to ret;

action (34):
rg_col_2:
	par_1 = 1;				/* integer */
	go to ret;

action (35):
rg_col_3:
	par_2 = int_val;
	if int_val > 999
	then call DIAG (24, cl_token.line, cl_token.column);
	go to ret;

action (36):
q_name_1:						/* count comps in qual name */
	qual_name_size = 0;

	go to ret;

action (37):
q_name_2:						/* allocate space for qual name */
	call get_space (size (qual_name), qual_name_ptr);

	qual_name.qn_size = qual_name_size;

	do i = 1 by 1 to qual_name_size;		/* fill table */

	     qual_name.qn_loc (i) = QUAL_NAME.QN_loc (i);

	end;

	go to ret;

action (38):
id_1:
	call get_space (ident_SIZE, ident_ptr);

	ident.id_name_loc = null ();
	ident.count = 0;

	go to ret;

action (39):
id_2:
	ident.count = token_count - ident.count + 1;	/* compute token count */
	ident.last = addr_record;

	go to ret;

action (40):
sum_1:
	sum_counter_size = 0;
	sum_ctr_ctr = sum_ctr_ctr + 1;

	if NODE.nd_name_ptr = null ()
	then call form_sum_name;

	reset_clause_ptr, sum_counter_lifo_ptr = null ();

	go to ret;

action (41):
sum_2:
	sum_counter_size = sum_counter_size + 1;	/* sum clause count */

	call get_space (list_link_SIZE, list_link_ptr);

	list_link.loc = sum_clause_ptr;
	list_link.next = sum_counter_lifo_ptr;

	sum_counter_lifo_ptr = list_link_ptr;

	go to ret;

action (42):
sum_3:
	reset_clause.rc_loc = qual_name_ptr;


	go to ret;

action (43):
sum_4:
	reset_clause.rc_final = "1"b;

	go to ret;

action (44):
id_4:						/* initialize for subscript parse */
	ident.count = token_count;
	ident.first = addr_record;


	go to ret;

action (45):
sum_ph_1:
	sum_clause_size = 0;
	sum_clause_lifo_ptr, upon_clause_ptr = null ();


	go to ret;

action (46):
sum_ph_2:
	call get_space (size (sum_clause), sum_clause_ptr);

	sum_clause.sc_upon_loc = upon_clause_ptr;	/* upon_clause */
	sum_clause.sc_size = sum_clause_size;		/* ident count */

	do i = sum_clause_size by -1 to 1;

	     sum_clause.sc_loc (i) = sum_clause_lifo_ptr -> list_link.loc;
	     sum_clause_lifo_ptr = sum_clause_lifo_ptr -> list_link.next;

	end;


	go to ret;

action (47):
sum_ph_3:
	sum_clause_size = sum_clause_size + 1;

	call get_space (list_link_SIZE, list_link_ptr);

	list_link.loc = ident_ptr;
	list_link.next = sum_clause_lifo_ptr;

	sum_clause_lifo_ptr = list_link_ptr;


	go to ret;

action (48):
sum_ph_4:
	upon_clause_ptr = qual_name_seq_ptr;


	go to ret;

action (49):
sign_1:						/* TRAILING SEPARATE */
	term_node.sign = 4;
	go to ret;

action (50):
sign_2:						/* TRAILING */
	term_node.sign = 2;
	go to ret;

action (51):
sign_3:						/* LEADING SEPARATE */
	term_node.sign = 3;
	go to ret;

action (52):
sign_4:						/* LEADING */
	term_node.sign = 1;
	go to ret;
declare	rep_num		fixed bin;
action (53):
rd_init:						/* RD clause initialization */
	if current_report_loc = null ()
	then call get_space (report_SIZE, current_report_loc);
						/*[5.1-2]*/
	fatal_no = fixed_common.fatal_no;
	report.rep_next, report.rep_name_ptr = null ();
	report.de, report.ch, report.cf = null ();
	report.rh, report.rf, report.ph, report.pf, report.rep_sum_ptr = null ();
	report.code = " ";
	report.rep_tok_line = header.line;
	report.rep_tok_column = header.column;
	rep_num = rep_num + 1;
	report.rep_num = rep_num;
	report.rep_up = null ();
	report.rep_type, report.rep_level, report.g_i_count = 0;
	report.page.type, report.heading.type, report.footing.type = 0;
	report.first_detail.type, report.last_detail.type = 0;
	report.heading.count, report.footing.count = 0;
	report.page.count = 999;
	report.first_detail.count, report.last_detail.count = 0;
	report.file_name, report.controls.loc = null ();
	string (report.indicators) = "0"b;
	de_table_size = 0;
	ST.entry.node_ptr (0) = current_report_loc;
	rd_cl = "0"b;
	go to ret;

action (54):
rd_name:						/* report name */
	report.rep_name_ptr = addr_record;

	go to ret;

action (55):
rd_cl_num:					/* RD clause number */
	rd_clnum = cl_off;
	rd_line = header.line;
	rd_column = header.column;

	go to ret;

action (56):
rd_clause:					/* process RD clause */
	if rd_cl_bits (rd_clnum)
	then do;
		call DIAG (1, rg_line, rg_column);	/* clause previously defined */
		go to ret;
	     end;

	rd_cl_bits (rd_clnum) = "1"b;

	go to RD (rd_clnum);

RD (0):						/* illegal */
	go to RD0;

RD (1):						/* . */
	go to RD0;

RD (2):						/* CODE clause */
	report.code = cd_lit;
	go to RD0;

RD (3):						/* CONTROL clause */
	report.controls.loc = qual_name_seq_ptr;

	go to RD0;

RD (4):						/* PAGE clause */
	call check_page;
	go to RD0;

RD0:
	go to ret;

action (57):
code:						/* code literal */
	cd_lit = alphanum_lit.string;

	go to ret;

action (58):
con_2:						/* FINAL present 		*/
	report.controls.final = "1"b;

/*[4.4-1]*/
	call form_control_table (qual_name_seq.qns_size); /* form ch_table and cf_table */

	go to ret;

action (59):
con_init:						/*[4.4-1]*/
	qual_name_seq_ptr = null ();
	go to ret;

action (60):
con_name:
	qual_name_seq_size = 0;			/* count qual names in a sequence */
	qual_name_seq_lifo_ptr = null ();

	go to ret;

action (61):
pg_init:
	pg_cl = "0"b;
	report.page.type = 1;
	go to ret;

action (62):
pg_cl_num:
	pg_clnum = cl_off;
	pg_line = header.line;
	pg_column = header.column;
	go to ret;

action (63):
pg_clause:
	if pg_cl_bits (pg_clnum)
	then do;
		call DIAG (1, pg_line, pg_column);
		go to ret;
	     end;

	pg_cl_bits (pg_clnum) = "1"b;

	go to PG (pg_clnum);

PG (0):						/* illegal */
	go to PG0;





PG (1):						/* HEADING */
	report.heading.count = int_val;
	report.heading.type = 1;
	go to PG0;

PG (2):						/* FIRST DETAIL */
	report.first_detail.count = int_val;
	report.first_detail.type = 1;
	go to PG0;

PG (3):						/* LAST DETAIL */
	report.last_detail.count = int_val;
	report.last_detail.type = 1;
	go to PG0;

PG (4):						/* FOOTING */
	report.footing.count = int_val;
	report.footing.type = 1;
	go to PG0;

PG0:
	go to ret;

declare	1 ae		like integer_spec;

action (64):
ae_init:
	ae.count = token_count;
	ae.first = addr_record;
	go to ret;

action (65):
ae_final:
	ae.count = token_count - ae.count;
	ae.last = prev_token_ptr;

	if token_count = 1 & ae.first -> header.type = 2
	then ae.type = 1;
	else ae.type = 2;

	go to ret;

/* process the report node after the	*/
/* clauses have been parsed		*/


check_page:
     proc;					/* establish defaults */

	if report.heading.count = 0
	then report.heading.count = 1;

	if report.first_detail.count = 0
	then report.first_detail.count = report.heading.count;

	if report.last_detail.count = 0 & report.footing.count = 0
	then report.last_detail.count, report.footing.count = report.page.count;

	if report.footing.count ^= 0 & report.last_detail.count = 0
	then report.last_detail.count = report.footing.count;

	if report.last_detail.count ^= 0 & report.footing.count = 0
	then report.footing.count = report.last_detail.count;

	if report.heading.count > 999
	then call DIAG (24, pg_line, pg_column);
	if report.heading.count < 1
	then call DIAG (32, pg_line, pg_column);
	if report.first_detail.count < report.heading.count
	then call DIAG (33, pg_line, pg_column);
	if report.last_detail.count < report.first_detail.count
	then call DIAG (34, pg_line, pg_column);
	if report.footing.count < report.last_detail.count
	then call DIAG (35, pg_line, pg_column);
	if report.page.count < report.footing.count
	then call DIAG (36, pg_line, pg_column);

     end;


action (66):
rep_group:					/* dispatch on the node type:	*/
						/* (1)root, (2)non-term, (3)term	*/
	go to RNT (NODE.node_type);			/*[5.1-2]*/
RNT (0):
	go to RNT0;
RNT (1):						/* root node */
	root.group_type = group_type;

	call set_cf_sum_chain;

	go to REP (group_type);			/*[5.1-2]*/
REP (0):
	go to REP0;
REP (1):						/* RH */
	if report.rh ^= null ()
	then call DIAG (7, rg_line, rg_column);
	report.rh = node_ptr;

	go to REP0;

REP (2):						/* PH */
	if report.ph ^= null ()
	then call DIAG (7, rg_line, rg_column);
	report.ph = node_ptr;

	go to REP0;

REP (6):						/* PF */
	if report.pf ^= null
	then call DIAG (7, rg_line, rg_column);
	report.pf = node_ptr;

	go to REP0;

REP (7):						/* RF */
	if report.rf ^= null ()
	then call DIAG (7, rg_line, rg_column);
	report.rf = node_ptr;

	go to REP0;

REP (3):						/* ch chain */
	call process_control_group (report.ch);


	go to REP0;

REP (5):						/* cf chain */
	call process_control_group (report.cf);

	last_control_num = seq_pos;

	sum_counter_count = 0;

	sum_chain_ptr = null ();


	go to REP0;

REP (4):						/* de chain */
	de_table_size = de_table_size + 1;

	call enter_group_chain (report.de, node_ptr, node_ptr);

	go to REP0;

REP0:
	if last_root_ptr ^= null ()
	then call form_group_tables;

	last_root_ptr = rt_ptr;
	root.nodes.count = 1;
	rt_ptr = null ();


	go to RNT0;

RNT (2):						/* non term node */
	call link_node;
	ntn_ptr = null ();


	go to RNT0;

RNT (3):						/* term node */
	if term_node.data_type = 3			/* sum counter */
	then if last_root_ptr -> root.group_type ^= 5	/* not CF group */
	     then call DIAG (44, term_node.tn_tok_line, term_node.tn_tok_column);

	     else do;				/* add new entry to sum counter chain for the CF group */

		     call enter_group_chain (sum_chain_ptr, sum_counter_ptr, node_ptr);


		     sum_counter_count = sum_counter_count + 1;
		end;


	call link_node;
	tn_ptr = null ();










	go to RNT0;

RNT0:
	go to ret;



link_node:
     proc;

	last_root_ptr -> root.nodes.count = last_root_ptr -> root.nodes.count + 1;

	if last_root_ptr -> root.nodes.first = null ()
	then last_root_ptr -> root.nodes.first, last_root_ptr -> root.nodes.last = node_ptr;
	else last_root_ptr -> root.nodes.last -> term_node.tn_next, last_root_ptr -> root.nodes.last = node_ptr;










     end;



action (67):
id_3:						/* name of identifier */
	ident.id_name_loc = qual_name_ptr;

	go to ret;

action (68):
q_name_3:
	qual_name_size = qual_name_size + 1;		/* save comp in qual name */

	QUAL_NAME (qual_name_size) = addr_record;

	go to ret;

/* initialize for processing a report */


action (69):
rep_group_1:
	ST.st_depth, sum_counter_count = 0;
	last_control_num = 10000;
	last_root_ptr = null ();
	go to ret;



action (70):
rg_entry_1:
	NODE.nd_name_ptr = addr_record;
	go to ret;


find_st_depth:
     proc;

declare	(i, lev)		fixed bin;


	do i = ST.st_depth by -1 to 1;

	     lev = ST.entry.level (ST.st_depth);

	     if NODE.nd_level > lev
	     then do;
		     ST.st_depth = i + 1;
		     return;
		end;
	     else if NODE.nd_level = lev
	     then do;
		     ST.st_depth = i;
		     return;
		end;
	end;

	ST.st_depth = 1;
     end;




/* process the report node after all of	*/
/* the clauses have been parsed	*/

action (71):
rg_entry_2:					/* exit from rg_entry */
	if ST.st_depth = 0
	then ST.st_depth = 1;
	else call find_st_depth;


/* establish the type of the report node	*/
/* (1)root, (2)non-term, (3)term. allocate	*/
/* space for the node, set node_ptr to point	*/
/* to the node				*/


	call classify_node;

	go to NDT (NODE.node_type);			/*[5.1-2]*/
NDT (0):
	go to NDT0;
NDT (1):						/* root node */
	call def_node (root_SIZE, rt_ptr);


	root.rt_type = 3;
	root.next_group.type = NODE.next_group.type;
	root.line.type = NODE.line.type;
	root.next_group.value = NODE.next_group.value;
	root.line.value = NODE.line.value;
	root.usage_disp = NODE.usage_disp;

	root.nodes.count = 0;
	root.nodes.first = null ();


	group_number = group_number + 1;
	root.group_number = group_number;

	root.field_table_ptr, root.line_table_ptr = null ();
	root.use_proc.use_proc_name_ptr, prev_node_ptr = null ();
	root.group_desc.type = 0;



	go to NDT0;

NDT (2):						/* non terminal node */
	call def_node (non_term_node_SIZE, ntn_ptr);


	non_term_node.ntn_type = 1;
	addr (non_term_node.line) -> non_term_node_line_bits = non_term_node_line_bits;



	go to NDT0;

NDT (3):						/* term node */
	call def_node (term_node_SIZE, tn_ptr);


	term_node.tn_type = 2;
	addr (term_node.line) -> term_node_line_bits = term_node_line_bits;

	term_node.data_type = NODE.data_type;


	if NODE.data_type = 3
	then do;
		if report.rep_sum_ptr = null ()
		then term_node.rep_sum_ptr = null ();
		else term_node.rep_sum_ptr = report.rep_sum_ptr;


		report.rep_sum_ptr = tn_ptr;
	     end;
	term_node.nd_loc = NODE.nd_loc;

	if term_node.group_ind
	then do;
		report.g_i_count = report.g_i_count + 1;
		term_node.g_i_count = report.g_i_count;
	     end;
	else term_node.g_i_count = 0;

	term_node.rep_group_ptr = last_root_ptr;




	go to NDT0;

NDT0:						/* complete the entry */
	if prev_node_ptr ^= null ()
	then prev_node_ptr -> term_node.tn_next = node_ptr;

	node_ptr -> term_node.tn_next = null ();
	node_ptr -> term_node.tn_tok_line = NODE.nd_tok_line;
	node_ptr -> term_node.tn_tok_column = NODE.nd_tok_column;
	node_ptr -> term_node.tn_name_ptr = NODE.nd_name_ptr;
	node_ptr -> term_node.tn_level = ST.st_depth;



	if ST.st_depth > 0
	then node_ptr -> term_node.tn_up = ST.node_ptr (ST.st_depth - 1);
	else node_ptr -> term_node.tn_up = null ();



/* maintain up chain, needed to get	*/
/* completely qualified sum counter	*/
/* names				*/
	prev_node_ptr = node_ptr;

/* maintain node chain */

	ST.entry.level (ST.st_depth) = NODE.nd_level;


	ST.entry.node_ptr (ST.st_depth) = node_ptr;

	go to ret;



action (72):
con_name_1:					/* add qual name to lifo chain */
	qual_name_seq_size = qual_name_seq_size + 1;	/* count of entries in chain */
	call get_space (list_link_SIZE, list_link_ptr);

	list_link.loc = qual_name_ptr;		/* qual name chain link */
	list_link.next = qual_name_seq_lifo_ptr;

	qual_name_seq_lifo_ptr = list_link_ptr;		/* head of lifo chain */

	go to ret;

declare	qual_name_seq_lifo_ptr
			ptr;

action (73):
con_name_2:					/* form table describing a sequence	*/
						/* of qual names 			*/
	call get_space (size (qual_name_seq), qual_name_seq_ptr);

	qual_name_seq.qns_size = qual_name_seq_size;	/* size of the chain */

	do i = qual_name_seq_size by -1 to 1;

	     qual_name_seq.qns_loc (i) = qual_name_seq_lifo_ptr -> list_link.loc;

	     qual_name_seq_lifo_ptr = qual_name_seq_lifo_ptr -> list_link.next;

	end;

	go to ret;




action (74):
con_1:						/* form control tables	*/
	report.controls.final = "0"b;

/*[4.4-1]*/
	call form_control_table (qual_name_seq.qns_size); /* form ch_table and cf_table */

	go to ret;








action (75):
rg_type_9:					/* type clause, control name */
	NODE.control_name_ptr = qual_name_ptr;

	go to ret;


action (76):
sum_5:						/* alloc space for reset clause descr */
	call get_space (reset_clause_SIZE, reset_clause_ptr);

	reset_clause.rc_loc = null ();
	reset_clause.rc_final = "0"b;

	go to ret;

action (77):
rs_exit:						/* exit from report section */
	call process_sum_counters;
	call process_report_clauses;

	if report_list.first ^= null ()
	then call cobol_generate_report (report_list.first, trace.phase.first (5), tbit);

	call cobol_io_$cobol_msf_start (rwfp, report_first_token);
	call scan;				/* report section */

	return;
action (78):
	go to ret;




action (79):					/* DETAIL */
rg_type_a:
	par_1 = 4;
	go to ret;


action (80):
pg_set:
	report.page.count = int_val;
	go to ret;

action (81):
lit_1:
	call get_space (list_def_SIZE, list_def_ptr);

	list_def.count = 1;
	list_def.first = addr_record;

	go to ret;

action (82):
lit_2:
	list_def.count = 2;
	list_def.last = addr_record;

	go to ret;

action (83):
con_3:						/*[4.4-1]*/
	report.controls.final = "1"b;			/*[4.4-1]*/
	call form_control_table (0);
	go to ret;




























/* CHECK ROUTINES */




check (1):
eof:
	if header.type = 9999
	then go to success;
	go to fail;




check (2):
lev_num:
	if header.type ^= 2
	then go to fail;

	if numeric_lit.sign ^= " " | ^numeric_lit.integral
	then go to fail;

	NODE.nd_level = fixed (numeric_lit.literal);

	if NODE.nd_level = 0 | NODE.nd_level > 49
	then go to fail;

	lv_line = header.line;
	lv_col = header.column;
	res = "0"b;
	go to success;




check (3):
type2:
	if header.type = 2
	then go to success;
	go to fail;




check (4):
type8:
	if header.type = 8
	then go to success;
	go to fail;




check (5):
code_lit:
	if header.type ^= 3
	then go to fail;

	if alphanum_lit.lit_size > 2
	then go to fail;
	go to success;




check (6):
pic:
	if header.type = 4
	then go to success;
	go to fail;




check (7):
integer:
	if header.type = 1 & reserved_word.key = 180	/* zero */
	then do;
		int_val = 0;
		go to success;
	     end;
	if header.type ^= 2
	then go to fail;

	if numeric_lit.sign ^= " " | ^numeric_lit.integral
	then go to fail;

	int_val = fixed (numeric_lit.literal);
	go to success;


check (8):
literal:
	if header.type = 2 | header.type = 3
	then go to success;
	go to fail;



check (9):
type1:
	if header.type = 1
	then go to success;
	go to fail;




check (10):
is_sub_opt:
	if subj_req
	then go to fail;
	go to success;




check (11):
lptopstk:
	if cssub >= 0
	then go to success;
	go to fail;




check (12):
relop:
	if header.type ^= 1
	then go to fail;

	if reserved_word.rel_op
	then go to success;
	go to fail;




check (13):
type3:
	if header.type = 3
	then go to success;
	go to fail;




check (14):
figconall:
	if header.type ^= 1
	then go to fail;

	if reserved_word.figcon
	then go to success;
	go to fail;




check (15):
arop:
	if header.type ^= 1
	then go to fail;

	if reserved_word.arith_op
	then go to success;
	go to fail;

check (16):
nonumlit:
	if header.type = 3
	then go to success;
	go to fail;

check (17):
illeg_ln:
	if res
	then go to success;
	else go to fail;





























declare	AA		(1024) fixed bin based (alloc_area.aa_loc);

declare	01 alloc_area,
	  02 aa_loc	ptr,			/* aa_location of area */
	  02 aa_size	fixed bin,		/* aa_size of allocated data */
	  02 aa_cap	fixed bin;		/* size of area */








/* allocate space */

get_space:
     proc (size, loc);

declare	sz		fixed bin;
declare	size		fixed bin,
	loc		ptr;

	sz = size + mod (-size, 2);
	loc = addr (AA (alloc_area.aa_size));
	alloc_area.aa_size = alloc_area.aa_size + sz;

	if alloc_area.aa_size > alloc_area.aa_cap
	then do;

		alloc_area.aa_loc, loc = cobol$alloc (1024);
		alloc_area.aa_size = sz + 1;
	     end;

     end;








/* see if a qual name (defined by FIND_name_ptr)	*/
/* appears in a qual name sequence (defined	*/
/* by FIND_seq_ptr):			*/
/*     seq_pos:	>0 found once		*/
/*		=0 not found		*/
/*		<0 found more than once	*/






declare	(FIND_ptr, FIND_name_ptr, FIND_seq_ptr)
			ptr;
declare	(seq_pos, FIND_ctr) fixed bin;



FIND:
     proc (p, q);

declare	(p, q)		ptr;



	FIND_name_ptr = p;
	FIND_seq_ptr = q;
	seq_pos = 0;


	do FIND_ctr = 1 by 1 to FIND_seq_ptr -> qual_name.qn_size;

	     FIND_ptr = FIND_seq_ptr -> qual_name.qn_loc (FIND_ctr);

	     call COMP;

	end;

     end;


def_node:
     proc (sz, p);

declare	sz		fixed bin,
	p		ptr;

	if p = null ()
	then call get_space (sz, p);

	node_ptr = p;
     end;






COMP:
     proc;

declare	(i, j)		fixed bin;
declare	(lp, rp)		ptr,
	(lsz, rsz, lct)	fixed bin;

	lct = FIND_name_ptr -> qual_name.qn_size;
	i = 1;

	lp = FIND_name_ptr -> qual_name.qn_loc (1);
	lsz = lp -> user_word.length;

	do j = 1 by 1 to FIND_ptr -> qual_name.qn_size;

	     rp = FIND_ptr -> qual_name.qn_loc (j);

	     if substr (lp -> user_word.word, 1, lsz) = substr (rp -> user_word.word, 1, rp -> user_word.length)
	     then do;
		     i = i + 1;

		     if i > lct
		     then do;
			     if seq_pos = 0
			     then seq_pos = FIND_ctr;
			     else seq_pos = -seq_pos;

			     return;

			end;

		     lp = FIND_name_ptr -> qual_name.qn_loc (i);
		     lsz = lp -> user_word.length;

		end;
	end;
     end;



declare	(last_control_num, sum_counter_count)
			fixed bin,
	sum_chain_ptr	ptr;

set_cf_sum_chain:
     proc;

	if sum_chain_ptr ^= null () & last_control_num ^= 10000
	then do;

		call form_name_seq (sum_chain_ptr, sum_counter_count, cf_table.cf_sum_name_seq_ptr (last_control_num))
		     ;

		cf_table.cf_sum_chain (last_control_num) = sum_chain_ptr;

	     end;


	last_control_num = 10000;

     end;



classify_node:
     proc;

	NODE.node_type = 0;				/* 0(illegal)1(root)2(non_term)3(term) */

	if substr (rg_cl, 3, 2) ^= "0"b
	then do;
		NODE.node_type = 1;			/* root node */

		if substr (rg_cl, 6) ^= "0"b
		then call DIAG (9, lv_line, lv_col);	/* term node clauses illegal */

		if NODE.nd_level ^= 1
		then call DIAG (10, lv_line, lv_col);	/* should be level 1 */

		if substr (rg_cl, 4, 1) = "0"b
		then call DIAG (8, lv_line, lv_col);	/* TYPE clause missing */

		return;
	     end;

	if substr (rg_cl, 7) ^= "0"b
	then do;
		NODE.node_type = 3;			/* term node */

/*[5.1-3]*/
		if substr (rg_cl, 11, 1) = "0"b	/*[5.1-3]*/
		then call DIAG (126, lv_line, lv_col);	/* PIC clause missing */

		if substr (rg_cl, 12, 3) = "0"b
		then call DIAG (16, lv_line, lv_col);	/* SOURCE/SUM/VALUE missing */

		if NODE.nd_level = 1
		then call DIAG (15, lv_line, lv_col);	/* should not be level 1 */

		return;
	     end;

	if NODE.nd_level = 1
	then do;
		NODE.node_type = 1;			/* root.node */

		call DIAG (8, lv_line, lv_col);	/* TYPE clause missing */

		if substr (rg_cl, 6, 1) ^= "0"b
		then call DIAG (9, lv_line, lv_col);	/* PRESENT illegal */

		return;
	     end;

	NODE.node_type = 2;				/* non_term_NODE.node */

     end;





/* form the line and field tables for 	*/
/* a report group			*/

declare	(ltl, ftl)	fixed bin;		/* pos in line and field tables */

declare	line_status	fixed bin;		/* 0(initial)1(abs)2(rel) */
declare	line_value	fixed bin;		/* line clause parameter */

declare	(lt, lv)		fixed bin;
declare	(ct, cv)		fixed bin;

declare	col_clause	bit (1),
	(last_line_value, TYPE, LINE, SIZE)
			fixed bin;

declare	col_status	fixed bin;		/* 0(initial)1(abs)2(rel) */
declare	col_value		fixed bin;		/* column clause parameter */

declare	line_size		fixed bin;		/* size of the current line */
declare	line_count	fixed bin;		/* number of lines in the group */
declare	field_count	fixed bin;		/* number of fields in the line */



form_group_tables:
     proc;

/* form line and field tables */
declare	ct		fixed bin;


	ct = last_root_ptr -> root.nodes.count;
	line_table_size, field_table_size = ct + 1;

	call get_space (size (LINE_table), LINE_table_ptr);
	call get_space (size (FIELD_table), FIELD_table_ptr);

	LINE_table.LT_size = line_table_size;
	FIELD_table.FT_size = field_table_size;

	ltl, ftl = 0;
	line_status, line_value, line_count = 0;
	node_ptr = last_root_ptr;
	call lt_reset;
	col_clause = "0"b;
	TYPE, LINE, SIZE = 0;

	call group_node;				/* group_node */

	if ct ^= 0
	then do;
		node_ptr = last_root_ptr -> root.nodes.first;

		do while (node_ptr ^= null ());

		     call group_node;		/* subordinate node */

		     node_ptr = node_ptr -> root.rt_next;

		end;
	     end;

	if col_clause
	then SIZE = SIZE + 1;

	last_root_ptr -> root.group_desc.type = TYPE;
	last_root_ptr -> root.group_desc.line = LINE;
	last_root_ptr -> root.group_desc.size = SIZE;


	call set_count_and_size;

	last_root_ptr -> root.field_table_ptr = FIELD_table_ptr;
	last_root_ptr -> root.line_table_ptr = LINE_table_ptr;

	FIELD_table.FT_size = ftl;
	LINE_table.LT_size = ltl;

     end;




group_node:
     proc;

	go to GN (node_ptr -> root.rt_type);

GN (0):
	go to GN0;

GN (1):						/* non_term_node */
GN (3):						/* root node */
	call line_table_entry;

	go to GN0;

GN (2):						/* term node */
	call line_table_entry;

	ct = node_ptr -> term_node.column.type;

	if ct ^= 0
	then do;
		cv = node_ptr -> term_node.column.value;

		call check_field_clause;

	     end;
	go to GN0;

GN0:
     end;




line_table_entry:
     proc;

	lt = node_ptr -> root.line.type;

	if lt ^= 0
	then do;					/* LINE clause exists */
		call set_count_and_size;
		ltl = ltl + 1;
		line_count = line_count + 1;

		LINE_table.LT_first_field (ltl), LINE_table.LT_field_count (ltl), LINE_table.LT_line_size (ltl),
		     LINE_table.LT_line_num (ltl) = 0;

		lv = node_ptr -> root.line.value;

		call check_line_clause;
		call lt_reset;
	     end;
     end;
lt_reset:
     proc;

	col_status, col_value = 0;
	field_count, line_size = 0;
     end;

check_line_clause:
     proc;

	go to CLC (lt);				/* 1(i)2(+i)3(PAGE i) */

CLC (1):						/* LINE integer */
	go to LS1 (line_status);

LS1 (0):						/* undefined */
	line_status = 1;
	call set_line_num (-lv);
	TYPE = 1;
	LINE = lv;
	go to LS10;

LS1 (1):						/* abs */
	call line_incr_test (-lv);
	SIZE = SIZE + lv - last_line_value;
	go to LS10;

LS1 (2):						/* rel */
	call dg (19);
	go to LS10;

LS10:
	col_clause = "0"b;
	last_line_value = lv;

	go to CLC0;

CLC (2):						/* LINE PLUS integer */
	go to LS2 (line_status);

LS2 (0):						/* undefined */
	line_status = 2;
	TYPE = 2;
	LINE = lv;
	go to LS20;

LS2 (1):						/* abs */
	SIZE = SIZE + lv - last_line_value;

	if col_clause
	then SIZE = SIZE + 1;

	go to LS20;

LS2 (2):						/* rel */
	SIZE = SIZE + lv - last_line_value;

	if col_clause
	then SIZE = SIZE + 1;

	go to LS20;

LS20:
	col_clause = "0"b;
	last_line_value = lv;
	call set_line_num (lv);
	go to CLC0;

CLC (3):						/* LINE integer PAGE */
	go to LS3 (line_status);

LS3 (0):						/* undefined */
	call set_line_num (-lv - report.page.count);
	line_status = 1;
	TYPE = 3;
	LINE = lv;
	go to LS30;

LS3 (1):						/* abs */
	SIZE = SIZE + lv - last_line_value;

	go to LS30;

LS3 (2):						/* rel */
	call dg (20);
	go to LS30;

LS30:
	col_clause = "1"b;
	last_line_value = lv;

	go to CLC0;

CLC0:
     end;

dg:
     proc (dn);

declare	dn		fixed bin;

	call DIAG (dn, node_ptr -> term_node.tn_tok_line, node_ptr -> term_node.tn_tok_column);
     end;

set_count_and_size:
     proc;

	if ltl ^= 0
	then do;
		LINE_table.LT_field_count (ltl) = field_count;
		LINE_table.LT_line_size (ltl) = line_size;
	     end;
     end;

set_line_num:
     proc (s);

declare	s		fixed bin;

	line_value = lv;
	LINE_table.LT_line_num (ltl) = s;
     end;

line_incr_test:
     proc (s);

declare	s		fixed bin;

	if lv <= line_value
	then call dg (13);
	else call set_line_num (s);
     end;




check_field_clause:
     proc;

declare	p		ptr;			/*[5.1-3]*/
						/*[5.1-3]*/
dcl	1 PIC		static,			/*[5.1-3]*/
	  2 size		fixed bin init (0),		/*[5.1-3]*/
	  2 line		fixed bin init (0),		/*[5.1-3]*/
	  2 column	fixed bin init (0),		/*[5.1-3]*/
	  2 type		fixed bin init (0),		/*[5.1-3]*/
	  2 length	fixed bin init (1),		/*[5.1-3]*/
	  2 string	char (1) init ("X");


	p = node_ptr -> term_node.picture;		/*[5.1-3]*/
	if p = null ()
	then p = addr (PIC);
	pic_string_ptr = addr (p -> picture.string);
	pic_string_size = p -> picture.length;

	call get_pic_size;
	node_ptr -> term_node.non_num = non_num;
	go to CFC (ct);				/* 1(i)2(+i) */

CFC (1):						/* COLUMN integer */
	go to CS1 (col_status);

CS1 (0):						/* undefined */
	col_status = 1;

	call first_field;

	call set_fields (cv, pic_size, cv - 1);
	line_size = cv + pic_size - 1;
	col_clause = "1"b;

	go to CS10;

CS1 (1):						/* abs */
	if cv <= line_size
	then call dg (77);
	else do;
		call subseq_field;
		call set_fields (cv, pic_size, cv - line_size - 1);
		line_size = cv + pic_size - 1;
		col_clause = "1"b;
	     end;

	go to CS10;

CS1 (2):						/* rel */
	call dg (76);
	go to CS10;

CS10:
	go to CFC0;

CFC (2):						/* COLUMN PLUS integer */
	go to CS2 (col_status);

CS2 (0):						/* undefined */
	col_status = 2;

	call first_field;

	call set_fields (cv + 1, pic_size, cv);
	line_size = cv + pic_size;

	go to CS20;

CS2 (1):						/* abs */
	col_status = 2;
	call subseq_field;
	call set_fields (line_size + cv, pic_size, cv);
	line_size = line_size + cv + pic_size;

	go to CS20;

CS2 (2):						/* rel */
	call subseq_field;
	call set_fields (line_size + cv, pic_size, cv);
	line_size = line_size + cv + pic_size;
	go to CS20;

CS20:
	col_clause = "1"b;

	go to CFC0;

CFC0:
     end;

first_field:
     proc;

	ftl = ftl + 1;
	field_count = field_count + 1;

	LINE_table.LT_first_field (ltl) = ftl;
     end;

subseq_field:
     proc;

	ftl = ftl + 1;
	field_count = field_count + 1;
     end;

set_fields:
     proc (fp, fs, lf);

declare	(fp, fs, lf)	fixed bin;

	FIELD_table.FT_loc (ftl) = node_ptr;
	FIELD_table.FT_field_pos (ftl) = fp;
	FIELD_table.FT_field_size (ftl) = fs;
	FIELD_table.FT_left_fill_size (ftl) = lf;
     end;






declare	pic_string	char (pic_string_size) based (pic_string_ptr);

declare	(pic_loc, pic_size, ch_type, pic_string_size)
			fixed bin;
declare	(rep_spec_size, left_par_loc, right_par_loc, int_size)
			fixed bin;
declare	sep_sign		bit (1);
declare	next_char		char (1);
declare	pic_string_ptr	ptr;
declare	(s_exists, non_num) bit (1);
declare	pic_chars		char (18) init (".SVCDA,X9PZ*B/0+-""");








get_pic_size:
     proc;					/* compute size of field described by a picture string */

	pic_size = 0;				/* size of field */
	pic_loc = 1;				/* picture char being examined */
	s_exists = "0"b;
	non_num = "0"b;
	do while ("1"b);

	     ch_type = index (pic_chars, substr (pic_string, pic_loc, 1));

/* type of picture character */
	     go to PIC (ch_type);




PIC (6):						/* A */
PIC (8):						/* X */
PIC (13):						/* B */
	     non_num = "1"b;
PIC (0):						/* unspecified character */
PIC (1):						/* . */
PIC (7):						/* , */
PIC (9):						/* 9 */
PIC (11):						/* Z */
PIC (12):						/* * */
PIC (14):						/* / */
PIC (15):						/* 0 */
PIC (16):						/* + */
PIC (17):						/* - */
PIC (18):						/* $ */
	     call rep_spec;

	     pic_size = pic_size + rep_spec_size;

	     go to PIC0;

PIC (2):						/* S */
	     if node_ptr -> term_node.sign > 2
	     then pic_size = pic_size + 1;

	     pic_loc = pic_loc + 1;
	     s_exists = "1"b;
	     go to PIC0;

PIC (3):						/* V */
	     pic_loc = pic_loc + 1;

	     go to PIC0;

PIC (4):						/* C */
	     next_char = "r";

	     call test_next;

	     go to PIC0;

PIC (5):						/* D */
	     next_char = "b";

	     call test_next;

	     go to PIC0;

PIC (10):						/* P */
	     call rep_spec;

	     go to PIC0;

PIC0:
	     if pic_loc > pic_string_size
	     then return;

	end;

	if ^s_exists
	then node_ptr -> term_node.sign = 0;

     end;



test_next:
     proc;

	pic_loc = pic_loc + 1;

	if pic_loc > pic_string_size
	then do;
		pic_size = pic_size + 1;		/* ends in C or D */
		return;
	     end;

	if substr (pic_string, pic_loc, 1) = next_char
	then do;
		pic_size = pic_size + 1;		/* CR or DB */
		pic_loc = pic_loc + 1;
	     end;
	else do;
		call rep_spec;			/* not CR or DB */

		pic_size = pic_size + rep_spec_size;
	     end;
     end;








rep_spec:
     proc;

	rep_spec_size = 1;				/* one repetition */
	pic_loc = pic_loc + 1;

	if pic_loc > pic_string_size
	then return;				/* end of string */
	else if substr (pic_string, pic_loc, 1) ^= "("
	then return;				/* not ( */

	left_par_loc = pic_loc;			/* loc of ( */
	right_par_loc = index (substr (pic_string, pic_loc + 1), ")");
						/* loc of ) */

	if right_par_loc = 0
	then return;				/* ) not found */

	right_par_loc = right_par_loc + pic_loc - 1;
	int_size = right_par_loc - left_par_loc;

	if int_size = 0
	then return;				/* () found */

	do i = left_par_loc + 1 by 1 to right_par_loc - 1;

	     if index ("0123456789", substr (pic_string, i, 1)) = 0
	     then return;

/* non-digit found */
	end;

	rep_spec_size = fixed (substr (pic_string, left_par_loc + 1, int_size));
	pic_loc = right_par_loc + 2;

     end;









form_de_table:
     proc;

declare	i		fixed bin;


	call get_space (size (de_table), de_table_ptr);



	de_table.det_size = de_table_size;
	de_table.det_name_seq_ptr = null ();
	de_table.det_subtot_all.count = 0;

	if de_table_size = 0
	then return;

	call form_name_seq (report.de, de_table_size, de_table.det_name_seq_ptr);

	i = de_table_size;
	sum_ptr = report.de;

	do while (sum_ptr ^= null ());

	     de_table.det_loc (i) = sum.sum_loc;
	     de_table.det_subtot.count (i) = 0;

	     i = i - 1;
	     sum_ptr = sum.sum_next;

	end;
	report.de = de_table_ptr;


     end;

/* process the sum counters defined	*/
/* for all of the reports		*/

declare	(current_control_level, sum_clause_num, ident_num, de_table_loc, upon_num)
			fixed bin;

process_sum_counters:
     proc;

	current_report_loc = report_list.first;

	do while (current_report_loc ^= null ());

	     call process_rep_sc;			/* process sum counters for a	*/
						/* particular report	*/
	     current_report_loc = report.rep_next;

	end;
     end;

process_rep_sc:
     proc;

	de_table_ptr = report.de;

	if report.cf ^= null ()
	then do;
		cf_table_ptr = report.cf;


		do current_control_level = 0 by 1 to cf_table.cf_size;

		     call process_cf_sum_chain;

/* process the sum counter chain	*/
/* for a particular CF report group	*/

		end;
	     end;
     end;


process_cf_sum_chain:
     proc;

	sum_ptr = cf_table.cf_sum_chain (current_control_level);

	do while (sum_ptr ^= null ());

	     sum_counter_ptr = sum.sum_loc;

	     if sum_counter_ptr ^= null ()
	     then call process_cf_sum_counter;

	     sum_ptr = sum.sum_next;

	end;
     end;

process_cf_sum_counter:
     proc;

	if sum_counter.sct_size ^= 0
	then do sum_clause_num = 1 by 1 to sum_counter.sct_size;

		sum_clause_ptr = sum_counter.sct_loc (sum_clause_num);


		if sum_clause.sc_size ^= 0
		then call process_cf_sum_clause;
	     end;

	reset_clause_ptr = sum_counter.sct_reset_loc;

	if reset_clause_ptr ^= null ()
	then call process_cf_reset_clause;
	else call enter_reset_chain (current_control_level);
     end;

process_cf_sum_clause:
     proc;

	upon_clause_ptr = sum_clause.sc_upon_loc;

	if upon_clause_ptr = null ()
	then do ident_num = 1 by 1 to sum_clause.sc_size;

		ident_ptr = sum_clause.sc_loc (ident_num);

		call is_sum_counter;

		if hit_count = 1			/* sum counter found */
		then if addend_level < current_control_level
		     then call DIAG (41, report.rep_tok_line, report.rep_tok_column);
		     else if addend_level = current_control_level
		     then call enter_chain (addr (cf_table.cf_crossfoot (addend_level)), ident_ptr, sum.sum_qn_ptr);
		     else call enter_chain (addr (cf_table.cf_rollfwd (addend_level)), ident_ptr, sum.sum_qn_ptr);


		else call enter_chain (addr (de_table.det_subtot_all), ident_ptr, sum.sum_qn_ptr);

/* sum_counter not found */

	     end;
	else do;					/* upon clause missing */

		do upon_num = 1 by 1 to upon_clause.upon_size;

		     qual_name_ptr = upon_clause.upon_loc (upon_num);

		     call FIND (qual_name_ptr, de_table.det_name_seq_ptr);

		     if seq_pos = 0
		     then call DIAG (43, report.rep_tok_line, report.rep_tok_column);

		     else do;
			     de_table_loc = seq_pos;

			     do ident_num = 1 by 1 to sum_clause.sc_size;

				ident_ptr = sum_clause.sc_loc (ident_num);

				call is_sum_counter;

				if hit_count = 1
				then call DIAG (42, report.rep_tok_line, report.rep_tok_column);
				else call enter_chain (addr (de_table.det_subtot (de_table_loc)), ident_ptr,
					sum.sum_qn_ptr);

			     end;

			end;

		end;

	     end;
     end;



process_cf_reset_clause:
     proc;



/* process reset clause */

	if reset_clause.rc_final
	then do;
		seq_pos = 0;

		call enter_reset_chain (seq_pos);

	     end;

	else do;					/*[5.0-1]*/
		call FIND (reset_clause.rc_loc, report.controls.loc);


		if seq_pos = 0
		then call DIAG (50, report.rep_tok_line, report.rep_tok_column);
		else if seq_pos > current_control_level
		then call DIAG (46, report.rep_tok_line, report.rep_tok_column);
		else call enter_reset_chain (seq_pos);
	     end;

     end;



enter_reset_chain:
     proc (pos);
declare	pos		fixed bin;		/* place entry in the reset chain	*/
						/* seq_pos: control level at which to	*/
						/* reset				*/

	call get_space (reset_chain_entry_SIZE, reset_chain_entry_ptr);

	reset_chain_entry.loc = sum.sum_qn_ptr;

	call add_to_list (reset_chain_entry_ptr, addr (cf_table.cf_reset (pos)));

     end;






enter_group_chain:
     proc (entry_loc, data_ptr, chain_ptr);

/* add new entry to a group chain(de,sum)	*/
/* and initialize the entry			*/


declare	(entry_loc, data_ptr, chain_ptr)
			ptr;

	call get_space (sum_SIZE, sum_ptr);		/* allocate space for entry */

	sum.sum_next = entry_loc;
	sum.sum_loc = data_ptr;
	entry_loc = sum_ptr;

	call tree_to_qual (chain_ptr, sum.sum_qn_ptr);	/* qualif name */

     end;

enter_chain:
     proc (list_ptr, ident_ptr, sum_ptr);

declare	(list_ptr, ident_ptr, sum_ptr)
			ptr;

	call get_space (chain_entry_SIZE, chain_entry_ptr);

	chain_entry.ce_loc = ident_ptr;
	chain_entry.ce_sum_loc = sum_ptr;

	call add_to_list (chain_entry_ptr, list_ptr);

     end;


form_control_table:
     proc (siz);

/* allocate the control tables	*/
/*     ch_table and cf_table		*/
/* initialize the tables		*/

/*[4.4-1]*/
declare	(i, siz)		fixed bin;

/*[4.4-1]*/
	ch_table_size, cf_table_size = siz;

	call get_space (size (ch_table), report.ch);
	ch_table_ptr = report.ch;

	ch_table.ch_size = ch_table_size;

	call get_space (size (cf_table), report.cf);
	cf_table_ptr = report.cf;

	cf_table.cf_size = cf_table_size;

	do i = 0 by 1 to ch_table_size;

	     ch_table.ch_loc (i), ch_table.ch_sum_name_seq_ptr (i) = null ();
	     ch_table.ch_sum_chain (i) = null ();
	     ch_table.ch_crossfoot.count (i), ch_table.ch_rollfwd.count (i), ch_table.ch_reset.count (i) = 0;

	     cf_table.cf_loc (i), cf_table.cf_sum_name_seq_ptr (i) = null ();
	     cf_table.cf_sum_chain (i) = null ();
	     cf_table.cf_crossfoot.count (i), cf_table.cf_rollfwd.count (i), cf_table.cf_reset.count (i) = 0;

	end;

     end;

form_name_seq:
     proc (chain_ptr, chain_size, name_seq_ptr);

/* form a qualified name sequence from a chain	*/
/* of qualified names. chain_ptr specifies the	*/
/* location of the chain and chain_size		*/
/* specifies the size of the chain. The location	*/
/* of the qualif name sequence is placed in	*/
/* name_seq_ptr				*/

declare	(chain_ptr, name_seq_ptr)
			ptr;
declare	chain_size	fixed bin;

declare	i		fixed bin,
	p		ptr;






	qual_name_seq_size = chain_size;

	call get_space (size (qual_name_seq), qual_name_seq_ptr);

	qual_name_seq.qns_size = qual_name_seq_size;
	p = chain_ptr;


	do i = qual_name_seq_size by -1 to 1;

	     qual_name_seq.qns_loc (i) = p -> sum.sum_qn_ptr;

	     p = p -> sum.sum_next;

	end;

	name_seq_ptr = qual_name_seq_ptr;

     end;







process_control_group:
     proc (p);

declare	p		ptr;

	if NODE.control_name_ptr = null ()		/* FINAL */
	then do;
		if ^report.controls.final		/* not spec by controls clause */
		then do;
			call DIAG (47, root.rt_tok_line, root.rt_tok_column);

/* FINAL not in CONTROL clause */

			return;

		     end;

		seq_pos = 0;

	     end;
	else do;
		call FIND (NODE.control_name_ptr, report.controls.loc);

		if seq_pos = 0
		then do;
			call DIAG (50, root.rt_tok_line, root.rt_tok_column);

/* data-name not in CONTROL clause */
			seq_pos = 10000;
			return;

		     end;
		else if seq_pos < 0
		then do;
			call DIAG (82, root.rt_tok_line, root.rt_tok_column);

/* data-name appears more than once in CONTROL clause */
			seq_pos = 10000;
			return;

		     end;
	     end;

	if p -> ch_table.ch_loc (seq_pos) ^= null ()	/* already defined */
	then do;
		call DIAG (81, root.rt_tok_line, root.rt_tok_column);

/* data-name appears more than once in CH/CF group */

		return;

	     end;

	p -> ch_table.ch_loc (seq_pos) = node_ptr;
	p -> ch_table.ch_sum_chain (seq_pos) = sum_chain_ptr;
						/* control number to seq_pos */

     end;


declare	(hit_count, addend_level)
			fixed bin;


is_sum_counter:
     proc;

/* is the qual name specified by p a sum	*/
/* counter in the report specified by q. Set	*/
/* hit_count = 0(not found),1(found once),2(found	*/
/* more than once). Set addend_level to the level*/
/* of the CF group containing the sum counter	*/


declare	i		fixed bin;
declare	p		ptr;


	hit_count = 0;

	if cf_table.cf_size = 0 | ident.subscripts.count ^= 0
	then return;

	do i = 1 by 1 to cf_table.cf_size;

	     p = cf_table.cf_sum_name_seq_ptr (i);

	     if p ^= null ()
	     then do;

		     call FIND (ident.id_name_loc, p);

		     if seq_pos < 0
		     then do;
			     hit_count = 2;

			     return;

			end;

		     else if seq_pos > 0
		     then do;
			     hit_count = hit_count + 1;

			     addend_level = i;

			end;

		     if hit_count = 2
		     then return;

		end;

	end;

     end;





add_to_list:
     proc (p, q);

/* add the item specified by p to	*/
/* the list specified by q		*/

declare	(p, q)		ptr;







	p -> list_link.next = null ();

	if q -> list_def.count = 0
	then do;
		q -> list_def.count = 1;
		q -> list_def.first, q -> list_def.last = p;
	     end;
	else do;
		q -> list_def.count = q -> list_def.count + 1;
		q -> list_def.last -> list_link.next, q -> list_def.last = p;
	     end;

     end;

tree_to_qual:
     proc (p, q);

/* transform a tree node specified by p		*/
/* into a qualified name table, store loc of	*/
/* the qualified name table in q. Set q = null()	*/
/* if no qualif name defined			*/

declare	(p, q)		ptr;
declare	r		ptr,
	i		fixed bin;

/* count comps in qualif name */

	r = p;
	qual_name_size = 0;

	do while (r ^= null ());

	     if r -> root.rt_name_ptr ^= null ()
	     then qual_name_size = qual_name_size + 1;

	     r = r -> root.rt_up;

	end;

	if qual_name_size = 0
	then do;
		q = null ();

		return;

	     end;

	call get_space (size (qual_name), qual_name_ptr);

	qual_name.qn_size = qual_name_size;

	r = p;

	i = 1;

	do while (r ^= null ());

	     if r -> root.rt_name_ptr ^= null ()
	     then do;
		     qual_name.qn_loc (i) = r -> root.rt_name_ptr;

		     i = i + 1;

		end;

	     r = r -> root.rt_up;

	end;

	q = qual_name_ptr;

     end;




declare	program		(36) ptr based (directory_ptr);

declare	1 fd_object	based (fd_object_ptr),
	  2 next		ptr,
	  2 loc		ptr,
	  2 rep_loc	ptr;

declare	fd_object_ptr	ptr;

declare	1 use_reporting_object
			based (use_reporting_object_ptr),
	  2 next		ptr,
	  2 loc		ptr,
	  2 proc_loc	ptr,
	  2 suppress	bit (1);

declare	use_reporting_object_ptr
			ptr;

declare	1 use_table	based (use_table_ptr),
	  2 use_size	fixed bin,
	  2 use		(use_table_size refer (use_table.use_size)),
	    3 comp_count	fixed bin,
	    3 usage_count	fixed bin,
	    3 gnl		fixed bin,
	    3 rnl		fixed bin,
	    3 gn_loc	ptr,
	    3 rn_loc	ptr,
	    3 proc_loc	ptr,
	    3 suppress	bit (1);

declare	use_table_ptr	ptr;
declare	use_table_size	fixed bin;

declare	cobol_output_tokens$directory_loc
			entry returns (ptr);

declare	directory_ptr	ptr;
declare	TAB_pos		fixed bin,
	TAB_res		bit (1),
	TAB_ptr		ptr,
	TABTAB_pos	fixed bin;
declare	uwl		fixed bin,
	uw		char (32);
declare	(fd_table_ptr, rep_clause_table_ptr, rep_table_ptr, rd_table_ptr)
			ptr;

process_report_clauses:
     proc;

	directory_ptr = cobol_output_tokens$directory_loc ();


	if program (24) ^= null ()
	then call form_fd_table;
	rwfp = cobol_m2fp;
	call cobol_io_$cobol_save_pos (rwfp2, rwfp2);
	call form_use_table;
	rwfp = cobol_m1fp;
	call cobol_io_$cobol_msf_start (cobol_m2fp, rwfp2);
	call tabtab_to_tab (rep_clause_table_ptr, rep_table_ptr);
	call are_tab_nams_unique (rep_table_ptr, 38);

	if program (22) ^= null ()
	then call form_name_table (program (22), rd_table_ptr);

	call find_rep_names;

	use_table_size = 0;

	call find_file_and_use;

     end;

form_name_table:
     proc (chain_ptr, table_ptr);			/* construct a name table (table_ptr)	*/
						/* from a name chain (chain_ptr)	*/

declare	(chain_ptr, table_ptr)
			ptr;
declare	i		fixed bin;

	if chain_ptr = null ()
	then return;

	list_link_ptr = chain_ptr;
	qual_name_size = 0;

	do while (list_link_ptr ^= null ());		/* find the size of the table */

	     qual_name_size = qual_name_size + 1;
	     list_link_ptr = list_link.next;

	end;

	call get_space (size (qual_name), qual_name_ptr); /* allocate space for the table */
	qual_name.qn_size = qual_name_size;
	list_link_ptr = chain_ptr;

	do i = 1 by 1 to qual_name_size;		/* initialize the table */

	     call get_token (list_link.loc);
	     qual_name.qn_loc (i) = addr_record;
	     list_link_ptr = list_link.next;

	end;

	table_ptr = qual_name_ptr;

     end;

are_tab_nams_unique:
     proc (table_ptr, diag_num);			/* if a non-unique name is found in the		*/
						/* table (table_ptr) then issue a diagnostic	*/
						/* (diag_num)				*/
declare	table_ptr		ptr,
	diag_num		fixed bin;
declare	(line, col)	fixed bin;

	qual_name_ptr = table_ptr;

	if qual_name.qn_size < 2
	then return;

	do TAB_pos = 2 by 1 to qual_name.qn_size;

	     addr_record = qual_name.qn_loc (TAB_pos);
	     uwl = user_word.length;
	     line = user_word.line;
	     col = user_word.column;
	     substr (uw, 1, uwl) = user_word.word;

	     call dup_test;

	     if TAB_res
	     then call DIAG (diag_num, line, col);

	end;
     end;

dup_test:
     proc;

declare	i		fixed bin;

	TAB_res = "0"b;

	do i = TAB_pos - 1 by -1 to 1;

	     addr_record = qual_name.qn_loc (i);

	     if uwl = user_word.length
	     then if substr (uw, 1, uwl) = user_word.word
		then do;
			TAB_res = "1"b;
			return;
		     end;
	end;
     end;

tabtab_to_tab:
     proc (tabtab_ptr, tab_ptr);

declare	(tabtab_ptr, tab_ptr)
			ptr;
declare	(i, j, k)		fixed bin,
	p		ptr;

	qual_name_size = 0;
	qual_name_ptr = tabtab_ptr;

/* compute size of table */


	do i = 1 by 1 to qual_name.qn_size;


	     p = qual_name.qn_loc (i);

	     if p ^= null ()
	     then qual_name_size = qual_name_size + p -> qual_name.qn_size;

	end;

/* allocate space for table */

	call get_space (size (qual_name), tab_ptr);
	tab_ptr -> qual_name.qn_size = qual_name_size;

/* initialize the table */

	k = 1;
	do i = 1 by 1 to qual_name.qn_size;

	     p = qual_name.qn_loc (i);
	     if p ^= null ()
	     then do j = 1 by 1 to p -> qual_name.qn_size;

		     tab_ptr -> qual_name.qn_loc (k) = p -> qual_name.qn_loc (j);
		     k = k + 1;

		end;
	end;
     end;

is_nam_in_tab:
     proc (table_ptr);				/* is name specified by (uwl,uw)	*/
						/* in table (table_ptr)		*/
declare	table_ptr		ptr;
declare	i		fixed bin,
	p		ptr;

	TAB_pos = 0;
	qual_name_ptr = table_ptr;

	do i = 1 by 1 to qual_name.qn_size;

	     p = qual_name.qn_loc (i);

/* compare the names */

	     if uwl = p -> user_word.length
	     then if substr (uw, 1, uwl) = p -> user_word.word
		then do;
			TAB_pos = i;
			return;
		     end;
	end;
     end;

form_fd_table:
     proc;

/* form the fd table */

	call form_name_table (program (24), fd_table_ptr);/* table of pointers to FD names */

/* table of pointers to report clause descriptors */
	qual_name_size = fd_table_ptr -> qual_name.qn_size;
	call get_space (size (qual_name), rep_clause_table_ptr);
	rep_clause_table_ptr -> qual_name.qn_size = qual_name_size;
	fd_object_ptr = program (24);

	do TAB_pos = 1 by 1 to qual_name_size;

	     if fd_object.rep_loc ^= null ()
	     then call form_rep_table;
	     else qual_name_ptr = null ();

	     rep_clause_table_ptr -> qual_name.qn_loc (TAB_pos) = qual_name_ptr;

	     fd_object_ptr = fd_object.next;

	end;
     end;

form_rep_table:
     proc;

/* form the rd table */

declare	i		fixed bin;

	call get_token (fd_object.rep_loc);		/* position to rep name seq */
	if header.type = 1
	then call scan;

	qual_name_size = 0;

	do while (header.type = 8);			/* count the rep names */

	     qual_name_size = qual_name_size + 1;
	     call scan;

	end;

	if qual_name_size = 0
	then return;

	call get_space (size (qual_name), qual_name_ptr); /* allocate space */
	qual_name.qn_size = qual_name_size;

	call get_token (fd_object.rep_loc);		/* position to rep name seq */
	if header.type = 1
	then call scan;

	do i = 1 by 1 to qual_name_size;

	     qual_name.qn_loc (i) = addr_record;
	     call scan;
	end;
     end;

first_token:
     proc (ft);

declare	ft		ptr;

	call cobol_io_$cobol_msf_start (rwfp, ft);
	call scan;
     end;

get_token:
     proc (type_ptr);

declare	type_ptr		ptr;

	call first_token (type_ptr);
	if header.type ^= 1
	then return;

	call scan;

     end;

form_use_table:
     proc;

/* form the use before reporting table */

declare	i		fixed bin;

	use_reporting_object_ptr = program (25);
	use_table_size = 0;				/* get size of table */

	do while (use_reporting_object_ptr ^= null ());

	     use_table_size = use_table_size + 1;
	     use_reporting_object_ptr = use_reporting_object.next;

	end;

/* allocate space for table */

	call get_space (size (use_table), use_table_ptr);
	use_table.use_size = use_table_size;

	use_reporting_object_ptr = program (25);
	if use_table_size ^= 0
	then do TAB_pos = 1 by 1 to use_table_size;

		call get_use_name;
		use_table.usage_count (TAB_pos) = 0;
		use_table.proc_loc (TAB_pos) = use_reporting_object.proc_loc;
		use_table.suppress (TAB_pos) = use_reporting_object.suppress;

		use_reporting_object_ptr = use_reporting_object.next;

	     end;
     end;

get_use_name:
     proc;

/* find a qualified group name */
	use_table.comp_count (TAB_pos) = 0;
	call cobol_io_$cobol_msf_start (rwfp, use_reporting_object.loc);
	if header.type = 1
	then call scan;
	call scan;
	if header.type ^= 8
	then return;

/* group name */

	use_table.gnl (TAB_pos) = user_word.length;
	use_table.gn_loc (TAB_pos) = addr_record;
	use_table.comp_count (TAB_pos) = 1;

	call scan;
	if header.type ^= 1
	then return;

	if reserved_word.key ^= 101 /* in */ & reserved_word.key ^= 133
						/* of */
	then return;

	call scan;
	if header.type ^= 8
	then return;

/* report name */

	use_table.rnl (TAB_pos) = user_word.length;
	use_table.rn_loc (TAB_pos) = addr_record;
	use_table.comp_count (TAB_pos) = 2;

     end;

find_file_and_use:
     proc;

declare	i		fixed bin;

	current_report_loc = report_list.first;

	do while (current_report_loc ^= null ());

/* find the report file */

	     call find_file;

/* find the use before reporting sections */

	     if report.rh ^= null ()
	     then call find_use (report.rh);
	     if report.rf ^= null ()
	     then call find_use (report.rf);
	     if report.ph ^= null ()
	     then call find_use (report.ph);
	     if report.pf ^= null ()
	     then call find_use (report.pf);
	     de_table_ptr = report.de;

	     if de_table_ptr ^= null ()
	     then do i = 1 by 1 to de_table.det_size;

		     if de_table.det_loc (i) ^= null ()
		     then call find_use (de_table.det_loc (i));

		end;

	     ch_table_ptr = report.ch;

	     if ch_table_ptr ^= null ()
	     then do i = 0 by 1 to ch_table.ch_size;

		     if ch_table.ch_loc (i) ^= null ()
		     then call find_use (ch_table.ch_loc (i));

		end;

	     cf_table_ptr = report.cf;

	     if cf_table_ptr ^= null ()
	     then do i = 0 by 1 to cf_table.cf_size;

		     if cf_table.cf_loc (i) ^= null ()
		     then call find_use (cf_table.cf_loc (i));

		end;
	     current_report_loc = report.rep_next;
	end;
     end;
find_rep_names:
     proc;					/* see if names in the reports are clauses	*/
						/* also appear in an RD clause		*/
declare	(line, col)	fixed bin;

	do TABTAB_pos = 1 by 1 to rep_table_ptr -> qual_name.qn_size;

	     TAB_ptr = rep_table_ptr -> qual_name.qn_loc (TABTAB_pos);

	     uwl = TAB_ptr -> user_word.length;
	     substr (uw, 1, uwl) = TAB_ptr -> user_word.word;
	     line = TAB_ptr -> user_word.line;
	     col = TAB_ptr -> user_word.column;

	     call is_nam_in_tab (rd_table_ptr);

	     if TAB_pos = 0
	     then call DIAG (37, line, col);

	end;
     end;

find_use:
     proc (p);					/* see if a group name appears in the	*/
						/* use  before reporting table	*/
declare	p		ptr;
declare	(line, col, use_count)
			fixed bin;

	if use_table.use_size = 0
	then return;

	rt_ptr = p;
	line = root.rt_tok_line;
	col = root.rt_tok_column;
	use_count = 0;
	if root.rt_name_ptr = null ()
	then return;
	do TAB_pos = 1 by 1 to use_table.use_size;

	     call compare_use_name;

	     if TAB_res
	     then do;
		     use_count = use_count + 1;
		     use_table.usage_count (TAB_pos) = use_table.usage_count (TAB_pos) + 1;

		     if use_count = 1
		     then do;
			     root.use_proc.use_proc_name_ptr = use_table.proc_loc (TAB_pos);
			     root.use_proc.suppress = use_table.suppress (TAB_pos);
			end;
		     else do;
			     call DIAG (61, line, col);
			     return;
			end;

		end;
	end;
     end;

compare_use_name:
     proc;

declare	comp_count	fixed bin;

	TAB_res = "0"b;
	comp_count = use_table.comp_count (TAB_pos);

	if comp_count = 1
	then call comp_group_name;
	else if comp_count = 2
	then do;
		call comp_group_name;

		if ^TAB_res
		then return;

		TAB_res = "0"b;
		call comp_rep_name;
	     end;
     end;

comp_group_name:
     proc;

declare	gnl		fixed bin;

	gnl = use_table.gnl (TAB_pos) - 1;

	if gnl = root.rt_name_ptr -> user_word.length
	then if substr (use_table.gn_loc (TAB_pos) -> user_word.word, 2, gnl) = root.rt_name_ptr -> user_word.word
	     then TAB_res = "1"b;
     end;

comp_rep_name:
     proc;

declare	rnl		fixed bin;

	rnl = use_table.rnl (TAB_pos);

	if rnl = report.rep_name_ptr -> user_word.length
	then if substr (use_table.rn_loc (TAB_pos) -> user_word.word, 1, rnl) = report.rep_name_ptr -> user_word.word
	     then TAB_res = "1"b;
     end;

find_file:
     proc;

/* find name of file used	*/
/* by the report		*/

declare	i		fixed bin,
	(p, q)		ptr;

	uwl = report.rep_name_ptr -> user_word.length;
	substr (uw, 1, uwl) = report.rep_name_ptr -> user_word.word;
	q = rep_clause_table_ptr;

	do i = 1 by 1 to q -> qual_name.qn_size;

	     p = q -> qual_name.qn_loc (i);		/*[5.1-1]*/
	     if p ^= null ()
	     then call is_nam_in_tab (p);
	     else TAB_pos = 0;

	     if TAB_pos ^= 0
	     then do;
		     report.file_name = fd_table_ptr -> qual_name.qn_loc (i);
		     return;
		end;
	end;

	call DIAG (108, report.rep_tok_line, report.rep_tok_column);
     end;




declare	ioa_$rsnnl	entry options (variable);

form_sum_name:
     proc;

declare	sum_number	char (4),
	sum_number_size	fixed bin;

	call ioa_$rsnnl ("^d", sum_number, sum_number_size, sum_ctr_ctr);

	call get_space (user_word_size, user_word_ptr);

	user_word_ptr -> user_word.size = user_word_size;
	user_word_ptr -> user_word.line = NODE.nd_tok_line;
	user_word_ptr -> user_word.column = NODE.nd_tok_column;
	user_word_ptr -> user_word.type = 8;
	user_word_ptr -> user_word.length = sum_number_size + 4;
	user_word_ptr -> user_word.word = "SUM-" || substr (sum_number, 1, sum_number_size);

	NODE.nd_name_ptr = user_word_ptr;

     end;







declare	bit12		bit (12) based;

declare	non_term_node_line_bits
			bit (non_term_node_line_size) based (NODE_line_ptr);
declare	term_node_line_bits bit (term_node_line_size) based (NODE_line_ptr);
declare	def_entry_bits	bit (def_entry_size) based (def_entry_ptr);

/* report description chain */


declare	1 report_list	like list_def;








declare	last_root_ptr	ptr;






declare	1 NODE,					/* current node data */
	  2 nd_name_ptr	ptr,
	  2 control_name_ptr
			ptr,
	  2 nd_tok_line	fixed bin,
	  2 nd_tok_column	fixed bin,
	  2 nd_level	fixed bin,
	  2 node_type	fixed bin,
	  2 next_group,
	    3 value	fixed bin,
	    3 type	fixed bin,
	  2 line,
	    3 value	fixed bin,
	    3 type	fixed bin,
	  2 usage_disp	bit (1) unal,
	  2 blank_zero	bit (1) unal,
	  2 group_ind	bit (1) unal,
	  2 just_right	bit (1) unal,
	  2 reset		bit (1) unal,
	  2 non_num	bit (1) unal,
	  2 sign		fixed bin (4) unal unsigned,
	  2 data_type	fixed bin (2) unal unsigned,
	  2 g_i_count	fixed bin,
	  2 rep_sum_ptr	ptr,
	  2 column,
	    3 value	fixed bin,
	    3 type	fixed bin,
	  2 picture	ptr,
	  2 nd_loc	ptr,
	  2 rep_group_ptr	ptr;

declare	1 QUAL_NAME	(50),			/* temp table, comps of qual name */
	  2 QN_loc	ptr;






/* structure sizes */


declare	(root_SIZE, non_term_node_SIZE, term_node_SIZE)
			fixed bin;
declare	(list_def_SIZE, report_SIZE)
			fixed bin;
declare	list_link_SIZE	fixed bin;
declare	(ht_entry_SIZE, def_entry_SIZE, fatal_no)
			fixed bin;

declare	integer_spec_size	fixed bin;
declare	(non_term_node_line_size, term_node_line_size)
			fixed bin;

declare	cobol$alloc	entry (fixed bin) returns (ptr);




declare	1 ST,
	  2 st_depth	fixed bin,		/* current structure depth */
	  2 entry		(0:50),			/* current structure table */
	    3 level	fixed bin,		/* level number */
	    3 node_ptr	ptr;			/* loc of node */








declare	1 reserved_word	based (addr_record),
%include cobol_TYPE1;

declare	1 numeric_lit	based (addr_record),
%include cobol_TYPE2;

declare	1 alphanum_lit	based (addr_record),
%include cobol_TYPE3;

%include cobol_fixed_common;
%include cobol_ext_;
%include cobol_report_writer;

     end cobol_report_writer;




		    cobol_res_words.pl1             05/24/89  1046.0rew 05/24/89  0835.3      325584



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_res_words.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 07/11/83 by FCH, [5.2-1], SUPPRESS verb does not work, BUG553(phx15481) */
/* Modified on 01/04/82 by FCH, [5.1-1], call special debug io entries only once, phx11819(BUG517) */
/* Modified on 06/30/81 by FCH, [4.4-2], reserved word token formed incorrectly, BUG480(phx09696) */
/* Modified on 06/14/80 by FCH, [4.4-1], REPORT WRITER facility */
/* Modified on 12/12/79 by MHD, [4.2-1], added lex_proc(14) - reconize SD and save sort file name */
/* Modified on 10/11/79 by MHD, [4.1-1], deleted lines 653,657 - don't diag multiple DATA (it assumes DIVISION) */
/* Modified on 02/15/79 by FCH, [4.0-1],  debug statement */
/* Modified on 10/31/78 by RAL, [3.0-2], have REPLACE trigger proc_copy like COPY for copy replacing */
/* Modified on 05/17/78 by FCH, [3.0-1], fix bug for priority onumber */
/* Modified since Version 3.0 */





/* format: style3 */
cobol_res_words:
     proc;

/* This run checks each user word for a reserved word and initiates any special processing required */


/*************************************/

start:
	if firsttime
	then do;

		call hcs_$make_ptr (null (), "cobol_reswd_table_", "cobol_reswd_table_", reswd_table_ptr, mcode);

		if reswd_table_ptr = null ()
		then do;
			call ioa_ ("HELP");
			return;
		     end;

		do i = 1 to 30;
		     g2_ptr (i) = addrel (reswd_table_ptr, reswd_table.g2_offset (i));
		end;

		firsttime = "0"b;			/*[4.0-1]*/
		DS = "0"b;			/*[4.2-1]*/
		last_sort_file = 0;
	     end;



	if cobol_rwt_init_sw = "1"b
	then do;
		cobol_rwt_init_sw = "0"b;
		area_a_sw = "0"b;
		user_word.line = 1;
		procname.type = 7;
		procname.repl_bits = "00000000"b;
		ad_attn = addr (fixed_common.options);
		fixed_common.phase_name = "LEX";
		h_w_count = 0;
		dclr_sec = 0;
		increment_dclr_sec = "0"b;
		secint = 0;

		if substr (user_word.word, 1, user_word.length) = "copy"
		then c_f_sw = "1"b;			/* if COPY first word in program... */
		else c_f_sw = "0"b;

	     end;

	if c_f_sw
	then goto start_search;			/* if copy first line in prog and still scanning it... */

	if cobol_head_words (1) = "0"b
	then do;
ck_ci:
		if substr (user_word.word, 1, user_word.length) ^= "control"
		then if substr (user_word.word, 1, user_word.length) ^= "identification"
		     then do;
			     len = 2;

			     call gen_head;

			     cobol_head_words (1) = "1"b;
			     cobol_head_words (2) = "1"b;
			end;
	     end;

start_search:
	reswd_len, len = user_word.length;
	g1_off = g2_ptr (reswd_len) -> g2 (fixed (unspec (substr (user_word.word, 1, 1))));

	if g1_off = 0
	then go to fail;

	g1_ptr = addrel (reswd_table_ptr, g1_off);

/*[4.0-1]*/
	if g1.name = substr (user_word.word, 1, reswd_len)
	then go to tph;

	do while (g1.name < substr (user_word.word, 1, reswd_len));

	     g1_ptr = addr (g1.next);

	end;

	if g1_stop = stop_bits | g1.name ^= substr (user_word.word, 1, reswd_len)
	then go to fail;

tph:						/*[4.4-1]*/
	if g3.key >= 530 & g3.key <= 537		/* debug register */
						/*[4.4-1]*/
	then do;
		if cobol_debug_mode & fixed_common.comp_level < "2" & DS
						/*[4.4-1]*/
		then call diag (g3.key - 329);	/*[4.4-1]*/
	     end;					/*[4.4-1]*/
	else if g3.key = 565			/* line-counter */
						/*[4.4-1]*/
	then ;					/*[4.4-1]*/
	else if g3.key = 578			/* page-counter */
						/*[4.4-1]*/
	then ;					/*[4.4-1]*/
	else go to hit;




/* 
   * * * * *
   SPECIAL PROCESSING FOR USER WORDS
   * * * * *
    */




fail:						/* still a user word */
	if cobol_head_words (5) = "0"b
	then return;				/* exit--not in procedure division */

	if user_word.column < 12
	then do;					/* paragraph name */
		if p_n
		then return;

		p_n = "1"b;			/* bypass this code for recursive calls */

next_pn:
		procname.line = user_word.line;
		procname.def_line = procname.line;
		procname.column = user_word.column;
		procname.length = user_word.length;

		substr (procname.name, 1, procname.length) = substr (user_word.word, 1, procname.length);

		procname.size = 52 + procname.length;
		procname.info = "0"b;
		procname.proc_num = cobol_name_number;
		procname.section_num = cobol_section_number;
						/* [3.0-1] */

		if cobol_stack_sw = "0"b
		then substr (user_word.l_info, 3, 1) = "1"b;

		p = cobol_current;

		call cobol_insert_token (7, procname.length);

		addr (user_word.size) -> tmvr = tmvr;

		if cobol_stack_sw = "1"b
		then call cobol_delete_tokens (p, p);

		area_a_sw = "1"b;

		call cobol_gns1;

/* a [.] [goto | section [#] | note ] [.] */

		if reserved_word.type = 1
		then if reserved_word.key = reschar_PERIOD
		     then call cobol_gns1;

		if token.type = 1
		then if reserved_word.key = reswd_GO
		     then do;			/* check for alterable go */

			     call cobol_gns1;

			     if token.type = 1
			     then if reserved_word.key = reswd_TO
				then do;

					call cobol_gns1;

					if token.type = 1
					then if reserved_word.key = reschar_PERIOD
					     then do;
						     if fixed_common.comp_level < "3"
						/* for leveling, An alterable GO TO */
						     then call diag (27);
						     call cobol_gns1;
						end;

					if token.type = 8 | token.type = 2
					then if token.column < 12
						/* another paragraph or section name */
					     then substr (procname.info, 8, 1) = "1"b;
						/* alterable */
					     else do;

						     call cobol_gns1;

						     if token.type = 1
						     then if reserved_word.key = 101 /* "IN" */
							     | reserved_word.key = 133
						/* "OF" */
							then do;
						/* qualified */

								call cobol_gns1;

								if token.type = 8 | token.type = 2
								then if token.column > 11
								     then do;
									     call cobol_gns1;
									     if token.type = 1
									     then if reserved_word.key
										     = reschar_PERIOD
										then call cobol_gns1;

									     if token.type = 8
										| token.type = 2
									     then if token.column < 12
										then substr (procname
											.info, 8, 1)
											= "1"b;
										else ;
									     else if token.type = 1
									     then if reserved_word.key
										     = 89
										     | reserved_word
										     .key = 191
										then substr (procname
											.info, 8, 1)
											= "1"b;
									end;
							     end;
							else do;
								if reserved_word.key = reschar_PERIOD
								then call cobol_gns1;

								if token.type = 8 | token.type = 2
								then if token.column < 12
						/* another parag or sec */
								     then substr (procname.info, 8, 1) =
									     "1"b;
						/* alterable */
								     else ;
								else if token.type = 1
								then if reserved_word.key
									= 89 /* end DECLARATIVES */
									| reserved_word.key = 191
						/* end COBOL */
								     then substr (procname.info, 8, 1) =
									     "1"b;
							     end;
						end;
					else if token.type = 1
					then if reserved_word.key = 89 /* end DECLARATIVES */
						| reserved_word.key = 191
						/* end COBOL */
					     then substr (procname.info, 8, 1) = "1"b;
						/* alterable */
				     end;
			end;
		     else if reserved_word.key = reswd_SECTION
		     then do;			/* a section name */

			     cobol_section_number = cobol_name_number;
			     substr (procname.info, 5, 1) = "1"b;
						/* indicate section name */
			     save_stsw = cobol_stack_sw;
			     cobol_stack_sw = "1"b;

			     call cobol_gns1;

			     cobol_stack_sw = save_stsw;

			     if reserved_word.type = 1 & reserved_word.key = reschar_PERIOD
			     then p = user_word.back_link;
			     else p = cobol_current;

			     secint = 0;		/* convert section number */

			     if p -> numeric_lit.type = 2
			     then do;

				     do i = 1 to p -> numeric_lit.places;

					secint =
					     10 * secint
					     + fixed (unspec (substr (p -> numeric_lit.literial, i, 1)), 15)
					     - 48;/* [3.0-1] */

				     end;

				     if secint > 99 | p -> numeric_lit.sign = "-"
				     then secint = 100;
				     else substr (p -> numeric_lit.info, 3, 1) = "1"b;

				end;

			end;
p_n_exit:
		if dclr_sec = 1
		then substr (procname.info, 6, 1) = "1"b;
						/* indicate if declr sec */

		if increment_dclr_sec
		then do;				/* increment dclr_sec....END DECLARATIVES already processed. */

			dclr_sec = dclr_sec + 1;
			increment_dclr_sec = "0"b;
		     end;

		procname.priority = sint.char2;
		procname.section_num = cobol_section_number;
		procname.proc_num = cobol_name_number;

/* Update fixed_common fields here every time, in case this paragraph/section name
		   immediately preceeds "end cobol". */

		fixed_common.proc_counter = cobol_name_number;
		fixed_common.spec_tag_counter = cobol_name_number;
		cobol_name_number = cobol_name_number + 1;

		call cobol_vdwf_sput (cobol_ntfp, st, addr (procname.size), procname.size, rec_ad);

		if token.line ^= procname.line
		then if token.type = 8
		     then if token.column < 12
			then go to next_pn;

		p_n = "0"b;
		area_a_sw = "0"b;
	     end;
	return;

initialize:
     entry;

/*[4.0-1]*/
	ph_num = 1;
	p_n = "0"b;				/*[5.1-1]*/
	string (indicators) = "111111"b;


/*[4.0-1]*/
	state = 0;				/*[4.0-1]*/
	fixed_common.debug, fixed_common.use_debug, cobol_debug_mode = "0"b;

/*[4.0-1]*/
	return;

/* 
   * * * * *
   SPECIAL PROCESSING FOR RESERVED WORDS
   * * * * *
    */

hit:						/* located a reserved word */
	if g3.rfi
	then do;
		if g3.key = reswd_COMP_1
		then reserved_word.key = reswd_COMP_7;
		else if g3.key = reswd_COMP_2
		then reserved_word.key = reswd_COMP_6;
		else do;
			call cobol_lexerr (24, "1"b, 0, " ");
			return;
		     end;
	     end;
	else reserved_word.key = g3.key;

/*[4.4-1]*/
	if report_exists				/*[4.4-2]*/
	then do;
		rwl = user_word.length;

/*[4.4-2]*/
		substr (reserved_word.name, 1, rwl) = substr (user_word.word, 1, rwl);

/*[4.4-2]*/
		reserved_word.size = 32 + rwl;	/*[4.4-2]*/
		reserved_word.length = rwl;

/*[4.4-1]*/
	     end;					/*[4.4-1]*/
	else reserved_word.size = 28;

	reserved_word.type = 1;
	reserved_word.class.pd = g3.class.pd;
	reserved_word.class.dd = g3.class.dd;

	string (reserved_word.class.others) = string (g3.class.others);

	reserved_word.jump_index = fixed (g3.ji);

	if cobol_head_words (5) = "1"b
	then /* if in procedure division... */
	     if reserved_word.column < 12
	     then /* if in area A... */
		if (reserved_word.key ^= 98)
		then /* if not END... */
		     if (reserved_word.key ^= 89)
		     then /* if not DECLARATIVES... */
			if (reserved_word.key ^= 522)
			then /* if not COPY... */
			     if (reserved_word.key ^= 425)
			     then /* in not REPLACE... */ /* [3.0-2]*/
				if g3.s_p_key = "0"b
				then return;	/* return if no special processing */

	s_p_i = 0;

s_p_loop:
	s_p_i = s_p_i + 1;				/* select each special process indicated */

	if s_p_i > 6
	then return;

	if substr (g3.s_p_key, s_p_i, 1) = "0"b
	then goto s_p_loop;

	goto s_p_proc (s_p_i);

/* SPECIAL PROCESSING FOR GROUPS OF RESERVED WORDS */

s_p_proc (1):					/* major reserved word, further processing by	*/
						/* cobol_output_tokens			*/
						/*[4.4-1]*/
	substr (reserved_word.l_info, 8, 1) = "1"b;
	goto s_p_loop;

s_p_proc (2):
	goto s_p_loop;

s_p_proc (3):					/* attention words */
						/* corr,debugging,initialize,section */
	if cobol_head_words (2) & ^cobol_head_words (3)
	then goto s_p_loop;

/* if in identification division... */

	if g3.attn = "1001"b /* 9 */ & ^cobol_head_words (5)
	then go to s_p_loop;			/* section in procedure division only */

/*[4.0-1]*/
	if g3.attn = "0110"b
	then go to s_p_loop;
	else at_wd (fixed (g3.attn)) = "1"b;

	goto s_p_loop;

s_p_proc (4):					/* missing division detection */
						/* add,go,move,perform */
	tm_d_ck = fixed (m_d_ck, 15);

	if cobol_head_words (tm_d_ck)
	then goto s_p_loop;				/* ignore if not in right division */

	h_w_count = h_w_count + 1;

	if h_w_count > 3
	then do;
		h_w_count = 0;
		len = tm_d_ck;
		goto gen_hdr;
	     end;

	goto s_p_loop;

s_p_proc (5):					/* division headers */
	tm_d_ck = fixed (m_d_ck, 15);

	if cobol_head_words (tm_d_ck)
	then do;
		goto s_p_loop;
	     end;

	h_w_count = 0;				/* reset missing division header detector */

/*[4.0-1]*/
	if tm_d_ck <= 5				/*[4.0-1]*/
	then do;
		go to MDH (tm_d_ck);

MDH (1):
MDH (2):
MDH (3):						/*[4.0-1]*/
		ph_num = 1;
		go to MD;

MDH (4):						/*[4.0-1]*/
		ph_num = 2;
		go to MD;

MDH (5):						/*[4.0-1]*/
		ph_num = 3;
		go to MD;

MD:
		cobol_head_words (tm_d_ck) = "1"b;

/*[4.0-1]*/
	     end;

	if (tm_d_ck = 1) | (tm_d_ck = 2)
	then goto div_head (tm_d_ck);

	len = tm_d_ck - 1;

	if cobol_head_words (len) = "0"b		/* if previous header is not present... */
	then do;
gen_hdr:
		do len = 2 to tm_d_ck - 1;		/*-09/17/76-*/

		     if ^cobol_head_words (len)
		     then do;
			     call gen_head;
			     cobol_head_words (len) = "1"b;
						/*						tm_d_ck = len;	*/
			end;
		end;
	     end;

	goto div_head (tm_d_ck);


s_p_proc (6):					/* individual word processing */
	goto lex_proc (fixed (g3.indv));

/* SPECIAL PROCESSING FOR DIVISION HEADERS */

div_head (1):					/* control division */
	cobol_head_words (1) = "1"b;			/*[4.0-1]*/
	goto s_p_loop;

div_head (2):					/* identification division */
	cobol_head_words (1) = "1"b;
	cobol_head_words (2) = "1"b;			/*[4.0-1]*/

div_head (3):					/* environment division */
div_head (4):					/* data division */
	goto s_p_loop;

div_head (5):					/* procedure division */
						/*[4.4-1]*/
	if processing_report
	then go to s_p_loop;


	cobol_stack_sw = "1"b;
	cobol_mfp = cobol_m2fp;			/* Put out all before procedure division and open new minpral. */
	call cobol_gns1;

	if ^(reserved_word.type = 1 & reserved_word.key = reswd_DIVISION)
	then do;					/* Error in "procedure division" header. */
		len = 5;
		call gen_head;
	     end;

	cobol_head_words (5) = "1"b;

/*[4.0-1]*/
	ph_num = 3;

/*[4.0-1]*/
	if fixed_common.debug & decl_bit		/*[5.1-1]*/
	then do;
		if ss_2
		then do;
			call cobol_io_$set_state (2);
			ss_2 = "0"b;
		     end;				/* set cobol_get_rec to use cobol_db_phase$get_tok */
						/*[4.0-1]*/
		decl_bit = "0"b;			/*[4.0-1]*/
	     end;

	call cobol_gns1;

	cobol_stack_sw = "0"b;

	goto s_p_loop;

/* SPECIAL PROCESSING FOR INDIVIDUAL RESERVED WORDS */

lex_proc (1):					/* picture */
	if ^cobol_head_words (4) | cobol_head_words (5)
	then goto s_p_loop;				/* if not in data division... */
	cobol_pic_switch = "1"b;

	call cobol_gns1;

	if reserved_word.type = 1
	then if reserved_word.key = reswd_IS
	     then call cobol_gns1;

	cobol_pic_switch = "0"b;

	goto s_p_loop;

lex_proc (2):					/* decimal point */
	if ^cobol_head_words (3) | cobol_head_words (4)
	then goto s_p_loop;				/* if not in environment division... */
						/*bypass DECIMAL-POINT in OBJECT IS phrase*/
	if cobol_dp_sw
	then goto s_p_loop;				/*if already processed "decimal-point is..."*/

l_p2a:
	cobol_dp_sw = "1"b;				/*bypass this code for recursive calls*/

	call cobol_gns1;

	cobol_dp_sw = "0"b;				/*re-enable*/

	if reserved_word.type = 1
	then do;
		if reserved_word.key = 118		/* IS */
		then do;
			cobol_dp_sw = "1"b;		/*disable*/

			call cobol_gns1;

			cobol_dp_sw = "0"b;		/*re-enable*/

			if reserved_word.type ^= 1
			then goto l_p2c;
		     end;

		if reserved_word.key = 517		/*COMMA*/
		then do;
			cobol_decimal_point_character = ",";
			cobol_comma_character = ".";
			fixed_common.dec_comma = "1"b;
l_p2b:
			cobol_dp_sw = "1"b;		/*see lex_proc(2)*/
			goto s_p_loop;
		     end;



		if reserved_word.key = 538
		then goto l_p2b;			/*DECIMAL-POINT*/
	     end;

l_p2c:
	call cobol_lexerr (22, "0"b, 13, "DECIMAL-POINT");

	goto s_p_loop;

lex_proc (3):					/* copy,replace */
	call cobol_proc_copy;

	c_f_sw = "0"b;

	goto s_p_loop;

lex_proc (4):					/* merge,sort */
	if ^cobol_head_words (5)
	then goto s_p_loop;				/* if not in procedure division... */

	call cobol_proc_sort;

	goto s_p_loop;

lex_proc (5):					/* ASSIGN processing */
	if ^cobol_head_words (3) | cobol_head_words (4)
	then goto s_p_loop;

/*if not environment division... */
	cobol_lu_sw = "0"b;

	call cobol_gns1;

	if user_word.type = 8
	then if user_word.length = 2
	     then if substr (user_word.word, 1, 2) = "TO" | substr (user_word.word, 1, 2) = "to"
		then do;
			substr (user_word.l_info, 3, 1) = "1"b;
			call cobol_gns1;
		     end;

	if reserved_word.type = 1 & reserved_word.key = reswd_TO
	then call cobol_gns1;

	cobol_lu_sw = "1"b;

	goto s_p_loop;

lex_proc (6):					/* declaratives */
	if ^cobol_head_words (5)
	then goto s_p_loop;				/* if not in procedure division... */

/* If we are processing a paragraph or section name then do not increment dclr_sec.
	   We want to mark the present paragraph/section name as being in the declaritive section.
	   dclr_sec will be incremented after paragraph/section name is so marked. */

/*[4.0-1]*/
	DS = "1"b;

	if p_n
	then increment_dclr_sec = "1"b;
	else dclr_sec = dclr_sec + 1;

	goto s_p_loop;

lex_proc (7):					/* end */
	cobol_stack_sw = "1"b;

	call cobol_gns1;

	p = cobol_frst;

	if reserved_word.type = 1
	then do;

		if reserved_word.key = 89		/* declaratives */
		then do;

			substr (p -> reserved_word.class.pd, 4, 1) = "1"b;
						/*-11/15/76-*/
			substr (p -> reserved_word.class.pd, 5, 1) = "1"b;
						/*-11/15/76-*/

/*[5.1-1]*/
			if ss_3
			then do;
				call cobol_io_$set_state (3);
				ss_3 = "0"b;
			     end;			/* set cobol_get_rec to use cobol_db_phase$get_perf */

		     end;

		else if reserved_word.key = 191	/* cobol */
		then do;

			substr (p -> reserved_word.class.pd, 4, 1) = "1"b;
						/*-11/15/76-*/
			substr (p -> reserved_word.class.pd, 8, 1) = "1"b;
						/*-11/15/76-*/

/* end of program processing */

			token.line = token.line - 1;

			do len = 2 to 5;

			     if ^cobol_head_words (len)
			     then do;
				     if len = 5
				     then cobol_mfp = cobol_m2fp;
				     call gen_head;
				end;
			end;
			token.line = token.line + 1;

/*[4.4-1]*/
			if report_exists & ^real_end_report
						/*[4.4-1]*/
			then do;
				token.l_info = "00100000"b;
				p -> token.l_info = "00100000"b;
			     end;
			else /*do nothing*/
			     ;
			cobol_endprog_sw = "1"b;	/*[4.0-1]*/
			if fixed_common.debug & db_bit/*[4.0-1]*/
			then call cobol_lexerr (37, "0"b, 0, " ");

		     end;
	     end;

	cobol_stack_sw = "0"b;

	goto s_p_loop;

lex_proc (8):					/* date compiled */
	if ^cobol_head_words (2) | cobol_head_words (3)
	then goto s_p_loop;

/* if not in identification division... */

	if reserved_word.column > 11
	then goto s_p_loop;

	fixed_common.date_comp_ln = reserved_word.line;
	cobol_$date_compiled_sw = 1;

	goto scanoff_id;

lex_proc (9):					/* currency sign */
	if ^cobol_head_words (3) | cobol_head_words (4)
	then goto s_p_loop;

/* if not in environment division... */

l_p9a:
	call cobol_gns1;

	if reserved_word.type = 1
	then do;
		if reserved_word.key = 118
		then goto l_p9a;
		if reserved_word.key = 245
		then goto l_p9a;
	     end;

	if alphanum_lit.type ^= 3
	then do;
		call cobol_lexerr (22, "0"b, 13, "CURRENCY SIGN");
		goto s_p_loop;
	     end;

	fixed_common.currency = alphanum_lit.string;

	goto s_p_loop;

lex_proc (10):					/* debugging */
						/*[4.0-1]*/
	if cobol_head_words (3) & ^cobol_head_words (4)	/*[4.0-1]*/
	then do;
		call cobol_gns1;			/* ED */

/*[4.0-1]*/
		if reserved_word.type = 1 & reserved_word.key = 230
						/*DEBUGGING MODE */
						/*[4.4-1]*/
		then do;
			fixed_common.debug = "1"b;

/*[4.4-1]*/
			cobol_debug_mode = "1"b;	/* used by cobol_merge */
						/*[4.0-1]*/
		     end;

/*[4.0-1]*/
	     end;


/*[4.0-1]*/
	if cobol_head_words (5)			/*[4.0-1]*/
	then do;
		fixed_common.use_debug = "1"b;	/* USE FOR DEBUGGING */

/*[4.0-1]*/
		if fixed_common.debug		/*[4.0-1]*/
		then do;
			call cobol_output_tokens$proc_def_ptr (PDF);

/*[4.0-1]*/
			call cobol_db_phase$proc_def_ptr (PDF);
						/*[4.0-1]*/
		     end;

/*[4.0-1]*/
	     end;

	goto s_p_loop;

lex_proc (11):					/* program-id */
	if ^cobol_head_words (2) | cobol_head_words (3)
	then goto s_p_loop;

	if reserved_word.column > 11
	then goto s_p_loop;

	call cobol_gns1;

	if reserved_word.type ^= 1
	then goto l_p11a;

	if reserved_word.key ^= reschar_PERIOD
	then goto l_p11a;

	cobol_lu_sw = "0"b;

	if fixed_common.compiler_id = 3
	then cobol_progid_sw = "1"b;

	call cobol_gns1;

	cobol_progid_sw = "0"b;

	if reserved_word.type ^= 8
	then do;
l_p11a:
		call cobol_lexerr (22, "0"b, 10, "PROGRAM-ID");
	     end;
	else fixed_common.prog_name = substr (user_word.word, 1, user_word.length);

	cobol_lu_sw = "1"b;

	goto scanoff_id;

lex_proc (12):					/* identification division comment scanoff routine */
						/* author,date-written,installation,security */
	if ^cobol_head_words (2) | cobol_head_words (3)
	then goto s_p_loop;

	if reserved_word.column > 11
	then goto s_p_loop;

scanoff_id:
	cobol_scanoff_sw = "1"b;

	call cobol_gns;

	cobol_scanoff_sw = "0"b;
	cobol_$date_compiled_sw = 0;

	goto s_p_loop;

lex_proc (13):					/* working-storage */
						/*[4.0-1]*/
	if cobol_head_words (4) & ^cobol_head_words (5) & reserved_word.column <= 11
						/*[4.0-1]*/
	then do;
		call cobol_gns1;

/*[4.0-1]*/
		if reserved_word.type ^= 1
		then go to s_p_loop;		/*[4.0-1]*/
		if reserved_word.key ^= reswd_SECTION
		then go to s_p_loop;

/*[5.1-1] */
		if ss_1
		then do;
			call cobol_io_$set_state (1);
			ss_1 = "0"b;
		     end;				/* set cobol_get_rec to use cobol_db_phase$get_rec */

/*[4.0-1]*/
		call cobol_gns1;			/* . */

/*[4.0-1]*/
		if reserved_word.type ^= 1
		then go to s_p_loop;		/*[4.0-1]*/
		if reserved_word.key ^= 189
		then go to s_p_loop;		/* . */

/*[4.0-1]*/
		db_bit = "0"b;

/*[4.0-1]*/
	     end;

/*[4.0-1]*/
	go to s_p_loop;

/*[4.2-1]*/

/* Following added to help diagnosis sort errors.  Gets the file name associated with the SD and saves
   in in  sort_file_list.  Maximum of SD pre program */
/* SD */
lex_proc (14):
	if ^cobol_head_words (4) | cobol_head_words (5)
	then goto s_p_loop;

	if reserved_word.column > 11
	then goto s_p_loop;

	call cobol_gns1;

	last_sort_file = last_sort_file + 1;
	sort_file_list (last_sort_file) = substr (user_word.word, 1, user_word.length);


	goto s_p_loop;

lex_proc (15):					/* REPORT, REPORTING, GENERATE, TERMINATE, INITIATE, SUPPRESS */
						/*[4.4-1]*/
	if reserved_word.key = reswd_REPORT		/* REPORT */
						/*[4.4-1]*/
	then do;


/*[4.4-1]*/
		if cobol_head_words (4) & ^cobol_head_words (5) & reserved_word.column <= 11
						/*[4.4-1]*/
		then do;

/*[4.4-1]*/
			call cobol_gns1;

/*[4.4-1]*/
			if reserved_word.type ^= 1
			then go to s_p_loop;

/*[4.4-1]*/
			if reserved_word.key ^= reswd_SECTION
			then go to s_p_loop;

/*[4.4-1]*/
			call cobol_gns1;

			if reserved_word.type ^= 1
			then go to s_p_loop;

/*[4.4-1]*/
			if reserved_word.key ^= reschar_PERIOD
			then go to s_p_loop;

/*[4.4-1]*/
			if report_exists		/*[4.4-1]*/
			then call cobol_lexerr (39, "0"b, 6, "REPORT");
						/*[4.4-1]*/
			else report_exists, fixed_common.report = "1"b;

/*[4.4-1]*/
		     end;				/*[4.4-1]*/
	     end;					/*[4.4-1]*/
	else /*[4.4-1]*/
	     if reserved_word.key = reswd_REPORTING	/* REPORTING */
						/*[4.4-1]*/
	then do;

/*[4.4-1]*/
		if cobol_head_words (5)		/*[4.4-1]*/
		then do;
			fixed_common.use_reporting = "1"b;
						/* USE BEFORE REPORTING */

/*[4.4-1]*/
			if report_exists		/*[4.4-1]*/
			then do;
				call cobol_output_tokens$proc_def_ptr (PDF);

/*[4.4-1]*/
				call cobol_db_phase$proc_def_ptr (PDF);
						/*[4.4-1]*/
			     end;

/*[4.4-1]*/
			call prefix_qual_name;

/*[4.4-1]*/
		     end;

/*[4.4-1]*/
	     end;					/*[4.4-1]*/
	else /*[4.4-1]*/
	     if reserved_word.key = reswd_INITIATE	/* INITIATE */
						/*[4.4-1]*/
	then do;
		if ^cobol_head_words (5)
		then go to s_p_loop;		/* not in PD */


/*[4.4-1]*/
		call name_seq ("I");		/*[4.4-1]*/
	     end;					/*[4.4-1]*/
	else /*[4.4-1]*/
	     if reserved_word.key = reswd_TERMINATE	/* TERMINATE */
						/*[4.4-1]*/
	then do;
		if ^cobol_head_words (5)
		then go to s_p_loop;		/* not in PD */

/*[4.4-1]*/
		call name_seq ("T");		/*[4.4-1]*/
	     end;					/*[4.4-1]*/
	else /*[4.4-1]*/
	     if reserved_word.key = reswd_GENERATE	/* GENERATE */
						/*[4.4-1]*/
	then do;					/*[4.4-1]*/
		if cobol_head_words (5)
		then call prefix_qual_name;		/*[4.4-1]*/
	     end;					/*[4.4-1]*/
	else /*[4.4-1]*/
	     if reserved_word.key = reswd_SUPPRESS	/*[4.4-1]*/
	then do;
		if ^cobol_head_words (5)
		then go to s_p_loop;

/*[5.2-1]*/
/* call cobol_gns1; */
/*[5.2-1]*/
/* if reserved_word.type ^= 1 then go to s_p_loop; */
/*[5.2-1]*/
/* if reserved_word.key ^= reswd_PRINTING then go to s_p_loop; */

/*[4.4-1]*/
		user_word.type = 8;			/* change to type 8 token */
						/*[4.4-2]*/
		user_word.length = 2;		/*[4.4-1]*/
		user_word.size = 26;		/*[4.4-1]*/
		substr (user_word.word, 1, 2) = "SS";	/*[4.4-1]*/
	     end;

/*[4.4-1]*/
	go to s_p_loop;

prefix_name:
     proc (ch);

/*[4.4-1]*/
declare	ch		char (1),
	len		fixed bin;

/*[4.4-1]*/
	len = user_word.length;			/*[4.4-1]*/
	substr (user_word.word, 1, len + 1) = ch || substr (user_word.word, 1, len);
						/*[4.4-1]*/
	user_word.length = len + 1;
	user_word.size = user_word.size + 1;

     end;

prefix_qual_name:
     proc;

/*[4.4-1]*/
	call cobol_gns1;

/*[4.4-1]*/
	if user_word.type ^= 8
	then return;

/*[4.4-1]*/
	if report_exists
	then call prefix_name ("G");
	else call prefix_name ("g");

/*[4.4-1]*/
	call cobol_gns1;

/*[4.4-1]*/
	if reserved_word.type ^= 1
	then return;

/*[4.4-1]*/
	if reserved_word.key ^= reswd_OF & reserved_word.key ^= reswd_IN
	then return;				/*[4.4-1]*/
	call cobol_gns1;

/*[4.4-1]*/
	if user_word.type ^= 8
	then return;

/*[4.4-1]*/
	if report_exists
	then call prefix_name ("R");
	else call prefix_name ("r");

     end;

name_seq:
     proc (ch);

/*[4.4-1]*/
declare	ch		char (1);

/*[4.4-1]*/
	do while ("1"b);

/*[4.4-1]*/
	     call cobol_gns1;			/*[4.4-1]*/
	     if user_word.type ^= 8
	     then return;

/*[4.4-1]*/
	     call prefix_name (ch);

/*[4.4-1]*/
	end;

     end;

/* This routine generates missing headers and inserts them at the beginning of the token stack */

gen_head:
     proc;

dcl	div_no		fixed bin;
dcl	h_key		(5) fixed bin static init (520, 552, 540, 196, 142);
dcl	h_class		(5) bit (26) static
			init ("00000000000000000001"b, "00000000000000000011"b, "00000000000000000011"b,
			"000000000010000000011"b, "000000001000000000101"b);
dcl	h_ji		(5) fixed bin static init (0, 0, 0, 0, 6);

	if fixed_common.comp_level < "5"
	then call diag (160);			/* for levelling, A DIVISION is missing*/
	tfirst = cobol_frst;
	tcurrent = cobol_current;
	ttop = cobol_top;
	save_stsw = cobol_stack_sw;
	cobol_stack_sw = "1"b;
	cobol_frst = null ();

	if len = 5
	then call cobol_lexerr (21, "0"b, hdr_len (len), (hdr (len)));
	else call cobol_lexerr (19, "0"b, hdr_len (len), (hdr (len)));

/* 		call cobol_insert_token(6, 18 + hdr_lngth(len));
/* 		source.column = 0;
/* 		source.length = 18 + hdr_lngth(len);
/* 		source.image = "	  " || substr(hdr(len),1,hdr_lngth(len))
/*			 || " DIVISION." || cobol_new_line_character;
/**/


	call cobol_insert_token (1, 0);

	source.column = 8;
	reserved_word.key = h_key (len);
	string (reserved_word.class) = h_class (len);	/*-11/15/76-*/
	reserved_word.jump_index = h_ji (len);

	call cobol_insert_token (1, 0);

	source.column = 23;
	reserved_word.key = reswd_DIVISION;
	reserved_word.class.mer = "0011"b;		/*-11/15/76-*/

	call cobol_insert_token (1, 0);

	source.column = 31;
	reserved_word.key = reschar_PERIOD;
	string (reserved_word.class) = "0001"b;		/*-11/15/76-*/

	call cobol_output_tokens;

	cobol_frst = tfirst;
	cobol_current = tcurrent;
	cobol_top = ttop;
	cobol_stack_sw = save_stsw;

     end gen_head;

/*[4.2-1]*/

/* This entry is used by idedsyn and checks to see if sort_name is a
   file that was mentioned in a SD clause */

check_sort_list:
     entry (sort_name) returns (bit (1));

dcl	sort_name		char (*);

	do i = 1 to last_sort_file;

	     if sort_name = sort_file_list (i)
	     then return ("1"b);

	end;

	return ("0"b);


/*======================================*/


/* general token */

dcl	1 token		based (cobol_current),
	  2 fwd_link	ptr,
	  2 back_link	ptr,
	  2 rep_link	ptr,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin;

/*   source    */
dcl	1 source		based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 6 */
	  2 info		bit (8),
	  2 length	fixed bin,
	  2 image		char (source.length);


/*   user_word    */
dcl	1 user_word	based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 8 */
	  2 info		bit (8),
	  2 length	fixed bin,
	  2 word		char (30);


/*   procname    */
dcl	1 procname	static,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 7 */
	  2 st_ptr_1	fixed bin,
	  2 st_ptr_2	fixed bin,
	  2 pr_rec_1	fixed bin,
	  2 pr_rec_2	fixed bin,
	  2 info		bit (8),
	  2 priority	char (2),
	  2 repl_bits	bit (8),
	  2 section_num	fixed bin,
	  2 proc_num	fixed bin,
	  2 def_line	fixed bin,
	  2 length	fixed bin,
	  2 name		char (30);

/*   reserved_word    */
dcl	1 reserved_word	based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 1 */
	  2 key		fixed bin,
	  2 class		aligned,
	    3 pd		bit (8) unal,
	    3 dd		bit (8) unal,
	    3 others	unal,
	      4 mer	bit (4) unal,
	      4 ie	bit (1) unal,
	      4 rw	bit (5) unal,
	  2 jump_index	fixed bin aligned,		/*[4.4-1]*/
	  2 length	fixed bin,		/*[4.4-1]*/
	  2 name		char (32);		/*   alphanum_lit    */
dcl	1 alphanum_lit	based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 3 */
	  2 info		bit (8),
	  2 length	fixed bin,
	  2 string	char (200);

/*   numeric_lit    */
dcl	1 numeric_lit	based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 2 */
	  2 info		bit (8),
	  2 sign		char (1),
	  2 exp_sign	char (1),
	  2 exp_places	fixed bin,
	  2 places_left	fixed bin,
	  2 places_right	fixed bin,
	  2 places	fixed bin,
	  2 literial	char (30);

dcl	cobol_io_$set_state entry (fixed bin);
dcl	cobol_lexerr	entry (fixed bin, bit (1), fixed bin, char (60)) external;
dcl	(cobol_gns1, cobol_gns, cobol_proc_sort, cobol_output_tokens)
			entry external;
dcl	cobol_vdwf_sput	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;
dcl	cobol_insert_token	entry (fixed bin, fixed bin) external;
dcl	cobol_delete_tokens entry (pointer, pointer) external;
dcl	cobol_proc_copy	entry external;		/*[4.0-1]*/
declare	cobol_db_phase$initialize
			entry;			/*[4.0-1]*/
declare	cobol_output_tokens$proc_def_ptr
			entry (ptr);		/*[4.0-1]*/
declare	cobol_db_phase$proc_def_ptr
			entry (ptr);
dcl	xdepending_key	fixed bin static init (92);
dcl	xnote_key		fixed bin static init (201);
dcl	xcomma_key	fixed bin static init (517);
dcl	tcur		ptr;
dcl	rw_dscr		(200) char (9) based;
dcl	dscr_indx		fixed bin;		/*[4.0-1]*/
declare	PDF		ptr;
dcl	dscr_indx_b	char (4) based (addr (dscr_indx));
dcl	hv1c		char (1) static;
dcl	st		bit (32);
dcl	save_stsw		bit (1);
dcl	init_error	bit (1);
dcl	rec_ad		char (5);
dcl	tmvr		char (procname.size) based (addr (procname));
dcl	base		fixed bin static;
dcl	len		fixed bin static;
dcl	delta		fixed bin static;
dcl	mult_adj		fixed bin;
dcl	p_n		bit (1) static init ("0"b),	/* paragraph name processing in progress */
	init_tab		bit (1) static init ("1"b),
	c_f_sw		bit (1) static,
	area_a_sw		bit (1) static,
	(p, dt1, dt2)	pointer static,
	(secint, i)	fixed bin static;
dcl	1 f_c_ind		based (ad_attn),
	  2 std_opts	bit (32),
	  2 at_wd		(9) bit (1);
dcl	1 sint		based (addr (secint)),
	  2 fill		char (2),
	  2 char2		char (2);
dcl	(h_w_count, dclr_sec, tm_d_ck)
			fixed bin static;
dcl	increment_dclr_sec	bit (1) static;
dcl	(tfirst, tcurrent, ttop, ad_attn)
			ptr static;
dcl	hdr		(5) char (14) init ("CONTROL", "IDENTIFICATION", "ENVIRONMENT", "DATA", "PROCEDURE")
			static options (constant);
dcl	hdr_len		(5) fixed bin init (7, 14, 11, 4, 9) static options (constant);
dcl	hdr_lngth		(5) fixed bin static init (7, 14, 11, 4, 9);
dcl	s_p_i		fixed bin static;


dcl	addr		builtin;
dcl	fixed		builtin;
dcl	mod		builtin;
dcl	null		builtin;
dcl	substr		builtin;
dcl	unspec		builtin;


/*[5.1-1]*/
dcl	1 indicators	static int,		/*[5.1-1]*/
	  2 decl_bit	bit (1),			/*[5.1-1]*/
	  2 firsttime	bit (1),			/*[5.1-1]*/
	  2 db_bit	bit (1),			/*[5.1-1]*/
	  2 ss_1		bit (1),			/*[5.1-1]*/
	  2 ss_2		bit (1),			/*[5.1-1]*/
	  2 ss_3		bit (1);

dcl	state		fixed bin static int;
dcl	reswd_len		fixed bin;
dcl	reswd_table_ptr	ptr static init (null ());
dcl	1 reswd_table	based (reswd_table_ptr),
	  2 stop_word	bit (36),
	  2 g2_offset	(30) fixed bin;
dcl	g2_ptr		(30) ptr static;		/*[4.0-1]*/
declare	DS		bit (1) internal static;
dcl	g2		(48:122) fixed bin based;
dcl	g1_ptr		ptr;
dcl	g1_stop		bit (36) based (g1_ptr) aligned;
dcl	stop_bits		bit (36) static options (constant) init ((36)"1"b);

declare	1 shdr		based (cobol_m1fp),
	  2 x1		char (12),
	  2 next		fixed bin;


dcl	1 g1		based (g1_ptr) aligned,
	  2 name		char (reswd_len) aligned,
	  2 g3		aligned,			/* item in reserved word table */
	    3 key		fixed bin (17) unal,
	    3 class	unal,
	      4 pd	bit (7) unal,
	      4 dd	bit (6) unal,
	      4 others	unal,
	        5 mer	bit (4) unal,
	        5 ie	bit (1) unal,
	        5 rw	bit (5) unal,
	    3 ji		bit (4) unal,
	    3 s_p_key	bit (6) unal,
	    3 old_lvl_rstr	unal,
	      4 non_ansi	bit (1) unal,
	      4 lvl_rstr	bit (3) unal,
	    3 inst_rstr	bit (4) unal,
	    3 attn	bit (4) unal,
	    3 m_d_ck	bit (4) unal,
	    3 indv	bit (4) unal,
	    3 rfi		bit (1) unal,
	    3 division	bit (3) unal,
	    3 dialect	bit (5) unal,
	  2 next		aligned;
dcl	mcode		fixed bin (35);
dcl	(g1_off, rwl)	fixed bin;

dcl	ioa_		entry options (variable);
dcl	hcs_$make_ptr	entry (ptr, char (*), char (*), ptr, fixed bin (35));

dcl	string		builtin;


/*[4.2-1]*/
dcl	sort_file_list	(20) char (30) varying internal static,
	last_sort_file	fixed bin internal static;

dcl	cobol_c_list	entry (ptr);
dcl	lev_message_ptr	ptr;
dcl	1 lev_message	internal static,
	  2 size		fixed bin init (28),
	  2 line		fixed bin init (0),
	  2 column	fixed bin init (0),
	  2 type		fixed bin init (5),
	  2 run		fixed bin init (9),
	  2 number	fixed bin init (0),
	  2 info		bit (32) init ("0"b);
diag:
     proc (num);
dcl	num		fixed bin;

	lev_message.line = user_word.line;
	lev_message.column = user_word.column;
	lev_message.number = num;
	lev_message_ptr = addr (lev_message);

	call cobol_c_list (lev_message_ptr);

     end;


%include cobol_reswd_values;
%include cobol_ext_;
%include cobol_fixed_common;
%include cobol_ext_lex;
%include cobol_;

     end cobol_res_words;




		    cobol_reswd_table_.alm          05/24/89  1046.0rew 05/24/89  0837.4      666423



" *********************************************************
" *                                                       *
" * Copyright, (C) BULL HN Information Systems Inc., 1989 *
" *                                                       *
" * Copyright (c) 1972 by Massachusetts Institute of      *
" * Technology and Honeywell Information Systems, Inc.    *
" *                                                       *
" *********************************************************

" HISTORY COMMENTS:
"  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8082),
"     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
"     MCR8082 cobol_reswd_table_.alm Fix wild array subscript.
"                                                      END HISTORY COMMENTS


name	cobol_reswd_table_
cobol_reswd_table_:
	segdef	cobol_reswd_table_
	oct	777777777777
	oct	000000000037
	oct	000000000153
	oct	000000000450
	oct	000000000773
	oct	000000001466
	oct	000000002262
	oct	000000003146
	oct	000000003753
	oct	000000004421
	oct	000000005064
	oct	000000005544
	oct	000000006116
	oct	000000006430
	oct	000000006663
	oct	000000007104
	oct	000000007347
	oct	000000000037
	oct	000000000037
	oct	000000007472
	oct	000000000037
	oct	000000000037
	oct	000000007616
	oct	000000000037
	oct	000000000037
	oct	000000000037
	oct	000000000037
	oct	000000000037
	oct	000000000037
	oct	000000000037
	oct	000000000037
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	777777777777
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000266
	oct	000000000273
	oct	000000000300
	oct	000000000315
	oct	000000000000
	oct	000000000326
	oct	000000000333
	oct	000000000000
	oct	000000000340
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000355
	oct	000000000362
	oct	000000000377
	oct	000000000000
	oct	000000000410
	oct	000000000425
	oct	000000000436
	oct	000000000443
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	141164000000
	oct	000117000002
	oct	000004000000
	oct	700000000000
	oct	777777777777
	oct	142171000000
	oct	000122000002
	oct	000004000000
	oct	700000000000
	oct	777777777777
	oct	143144000000
	oct	000316000002
	oct	000404000000
	oct	200000000000
	oct	143146000000
	oct	000777000002
	oct	051004000000
	oct	040000000000
	oct	143150000000
	oct	001000000002
	oct	050004000000
	oct	000000000000
	oct	777777777777
	oct	144142000000
	oct	000406000000
	oct	000404000000
	oct	040000000000
	oct	144145000000
	oct	001021000002
	oct	043004000000
	oct	000000000000
	oct	777777777777
	oct	146144000000
	oct	000333001002
	oct	000404000000
	oct	200000000000
	oct	777777777777
	oct	147157000000
	oct	000016444004
	oct	000044000240
	oct	100000000000
	oct	777777777777
	oct	151146000000
	oct	000057440006
	oct	000004000000
	oct	100000000000
	oct	151156000000
	oct	000145000002
	oct	000004000000
	oct	700000000000
	oct	151163000000
	oct	000166000002
	oct	000004000000
	oct	740000000000
	oct	777777777777
	oct	156157000000
	oct	000201000002
	oct	000004000000
	oct	500000000000
	oct	777777777777
	oct	157146000000
	oct	000205000002
	oct	000004000000
	oct	740000000000
	oct	157156000000
	oct	000206000002
	oct	000004000000
	oct	700000000000
	oct	157162000000
	oct	000207000002
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	160146000000
	oct	001103000002
	oct	047004000000
	oct	000000000000
	oct	160150000000
	oct	001104000002
	oct	046004000000
	oct	000000000000
	oct	777777777777
	oct	162144000000
	oct	001110000002
	oct	000404000000
	oct	200000000000
	oct	162146000000
	oct	001117000002
	oct	042004000000
	oct	000000000000
	oct	162150000000
	oct	001120000002
	oct	044004000000
	oct	000000000000
	oct	777777777777
	oct	163141000000
	oct	000362001002
	oct	002004000001
	oct	234000000000
	oct	163144000000
	oct	000363001002
	oct	001414000034
	oct	200000000000
	oct	777777777777
	oct	164157000000
	oct	000252000002
	oct	000004000000
	oct	760000000000
	oct	777777777777
	oct	165160000000
	oct	000256000002
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000563
	oct	000000000610
	oct	000000000000
	oct	000000000621
	oct	000000000626
	oct	000000000657
	oct	000000000670
	oct	000000000000
	oct	000000000675
	oct	000000000000
	oct	000000000702
	oct	000000000000
	oct	000000000000
	oct	000000000707
	oct	000000000714
	oct	000000000721
	oct	000000000000
	oct	000000000726
	oct	000000000733
	oct	000000000750
	oct	000000000755
	oct	000000000762
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	141144144000
	oct	000002444006
	oct	000044000240
	oct	140000000000
	oct	141154154000
	oct	000111000002
	oct	000004000000
	oct	740000000000
	oct	141156144000
	oct	000115000002
	oct	000004000000
	oct	100000000000
	oct	141156171000
	oct	000720000000
	oct	000004000000
	oct	100000000000
	oct	141162145000
	oct	000166000002
	oct	000004000000
	oct	600000000000
	oct	777777777777
	oct	142151164000
	oct	000302000000
	oct	000004000001
	oct	000000000000
	oct	142163156000
	oct	000635000000
	oct	000004000000
	oct	400000000000
	oct	777777777777
	oct	144141171000
	oct	000127000002
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	145147151000
	oct	000351000002
	oct	000004000000
	oct	100000000000
	oct	145155151000
	oct	000141000002
	oct	000004000000
	oct	100000000000
	oct	145156144000
	oct	000142000102
	oct	003014000016
	oct	700000000000
	oct	145157160000
	oct	000144000002
	oct	000004000000
	oct	140000000000
	oct	145163151000
	oct	000151000002
	oct	000004000000
	oct	140000000000
	oct	145170164000
	oct	000667000000
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	146154162000
	oct	000420000000
	oct	000004000000
	oct	400000000000
	oct	146157162000
	oct	000156000002
	oct	000004000000
	oct	740000000000
	oct	777777777777
	oct	147145164000
	oct	000652000000
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	151055157000
	oct	000167000002
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	153145171000
	oct	000170000002
	oct	000004000000
	oct	740000000000
	oct	777777777777
	oct	156157164000
	oct	000202000002
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	157146146000
	oct	001076000002
	oct	000004000000
	oct	500000000000
	oct	777777777777
	oct	160151143000
	oct	000350000202
	oct	020014000002
	oct	260000000000
	oct	777777777777
	oct	162165156000
	oct	000235000002
	oct	000004000000
	oct	134000000000
	oct	777777777777
	oct	163145164000
	oct	000037444024
	oct	000004000000
	oct	100000000000
	oct	163163146000
	oct	000125000000
	oct	000004000000
	oct	460000000000
	oct	163165155000
	oct	001133000002
	oct	031004000000
	oct	060000000000
	oct	777777777777
	oct	164157160000
	oct	000276000002
	oct	000004000000
	oct	260000000000
	oct	777777777777
	oct	165163145000
	oct	000047040006
	oct	000004000000
	oct	160000000000
	oct	777777777777
	oct	166151141000
	oct	000464000000
	oct	000004000000
	oct	060000000000
	oct	166154162000
	oct	000311000000
	oct	000004000000
	oct	460000000000
	oct	777777777777
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000001106
	oct	000000001117
	oct	000000001124
	oct	000000001151
	oct	000000001166
	oct	000000001177
	oct	000000000000
	oct	000000001214
	oct	000000001221
	oct	000000001226
	oct	000000000000
	oct	000000001233
	oct	000000001260
	oct	000000001271
	oct	000000001302
	oct	000000001313
	oct	000000000000
	oct	000000001330
	oct	000000001341
	oct	000000001402
	oct	000000001437
	oct	000000000000
	oct	000000001450
	oct	000000000000
	oct	000000000000
	oct	000000001461
	oct	141154163157
	oct	000140000000
	oct	000004000000
	oct	562000000000
	oct	141162145141
	oct	000312000002
	oct	000004000000
	oct	600000000000
	oct	777777777777
	oct	142151164163
	oct	000302000000
	oct	000004240001
	oct	400000000000
	oct	777777777777
	oct	143141154154
	oct	000005444006
	oct	000004000000
	oct	136000000000
	oct	143157144145
	oct	001002000002
	oct	402004000000
	oct	000000000000
	oct	143157155160
	oct	000152000202
	oct	001004000000
	oct	640000000000
	oct	143157160171
	oct	001012000002
	oct	000014000006
	oct	740000000000
	oct	143157162162
	oct	001014000012
	oct	000104024000
	oct	140000000000
	oct	777777777777
	oct	144141164141
	oct	000304000403
	oct	006424000200
	oct	740000000000
	oct	144141164145
	oct	000126000002
	oct	000004000000
	oct	340000000000
	oct	144157167156
	oct	000137000002
	oct	000004000000
	oct	160000000000
	oct	777777777777
	oct	145154163145
	oct	000140000002
	oct	000004000000
	oct	100000000000
	oct	145170151164
	oct	000014444002
	oct	000004000000
	oct	140000000000
	oct	777777777777
	oct	146151154145
	oct	000154002002
	oct	000404000000
	oct	700000000000
	oct	146151156144
	oct	000417000000
	oct	000004000000
	oct	000000000000
	oct	146162157155
	oct	000157000024
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	150157154144
	oct	000056444004
	oct	000004000001
	oct	100000000000
	oct	777777777777
	oct	151156164157
	oct	000164000002
	oct	000004000000
	oct	140000000000
	oct	777777777777
	oct	152165163164
	oct	000340000202
	oct	022004000000
	oct	240000000000
	oct	777777777777
	oct	154141163164
	oct	001054000002
	oct	202004000000
	oct	040000000000
	oct	154145146164
	oct	000341000002
	oct	000004000000
	oct	240000000000
	oct	154145163163
	oct	000173010002
	oct	000004000000
	oct	140000000000
	oct	154151156145
	oct	000174000002
	oct	123004000000
	oct	340000000000
	oct	154157143153
	oct	000175000002
	oct	000004000000
	oct	140000000000
	oct	777777777777
	oct	155157144145
	oct	000346000002
	oct	000004000000
	oct	640000000000
	oct	155157166145
	oct	000022444006
	oct	000044000240
	oct	140000000000
	oct	777777777777
	oct	156145170164
	oct	000200000002
	oct	102004000000
	oct	140000000000
	oct	156165154154
	oct	000666000000
	oct	000004000000
	oct	002000000000
	oct	777777777777
	oct	157156154171
	oct	000670000000
	oct	000004000000
	oct	000000000000
	oct	157160145156
	oct	000023444006
	oct	000004000000
	oct	140000000000
	oct	777777777777
	oct	160141147145
	oct	000213000002
	oct	441004000000
	oct	100000000000
	oct	160141164150
	oct	000675000000
	oct	000004000000
	oct	000000000000
	oct	160154165163
	oct	001105000002
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	162145141144
	oct	000025444006
	oct	000004000000
	oct	140000000000
	oct	162145145154
	oct	000225000002
	oct	000004000000
	oct	500000000000
	oct	777777777777
	oct	163141155145
	oct	001121000003
	oct	000004000000
	oct	440000000000
	oct	163145156144
	oct	000036444006
	oct	000004000000
	oct	100000000000
	oct	163145164163
	oct	000437000000
	oct	000004000000
	oct	000000000000
	oct	163151147156
	oct	000365000202
	oct	007004000000
	oct	600000000000
	oct	163151172145
	oct	000241000002
	oct	000004000000
	oct	500000000000
	oct	163157162164
	oct	000061444006
	oct	000014120010
	oct	500000000000
	oct	163164157160
	oct	000041444006
	oct	000004000000
	oct	100000000000
	oct	163171156143
	oct	000374000202
	oct	006004000000
	oct	200000000000
	oct	777777777777
	oct	164141160145
	oct	001136000002
	oct	000004000000
	oct	460000000000
	oct	164145170164
	oct	001137000142
	oct	002004000000
	oct	200000000000
	oct	164150141156
	oct	000245000002
	oct	000004000000
	oct	100000000000
	oct	164150145156
	oct	000454000000
	oct	000004000000
	oct	100000000000
	oct	164150162165
	oct	000246000002
	oct	000004000000
	oct	700000000000
	oct	164151155145
	oct	000250000002
	oct	000004000000
	oct	346000000000
	oct	164171160145
	oct	001140000002
	oct	100004000000
	oct	060000000000
	oct	777777777777
	oct	165156151164
	oct	000254000002
	oct	000004000000
	oct	560000000000
	oct	165160157156
	oct	000257000024
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	167150145156
	oct	000262000006
	oct	000004000000
	oct	360000000000
	oct	167151164150
	oct	000263000002
	oct	000004000000
	oct	700000000000
	oct	777777777777
	oct	172145162157
	oct	000264100002
	oct	001004000000
	oct	746000000000
	oct	777777777777
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000001601
	oct	000000001626
	oct	000000001641
	oct	000000000000
	oct	000000001700
	oct	000000001737
	oct	000000001764
	oct	000000000000
	oct	000000001772
	oct	000000000000
	oct	000000002005
	oct	000000002013
	oct	000000002040
	oct	000000000000
	oct	000000002046
	oct	000000002066
	oct	000000002101
	oct	000000002114
	oct	000000002146
	oct	000000002166
	oct	000000002213
	oct	000000002233
	oct	000000002241
	oct	000000000000
	oct	000000000000
	oct	000000002254
	oct	141146164145
	oct	162000000000
	oct	000110000002
	oct	000004000000
	oct	102000000000
	oct	141154164145
	oct	162000000000
	oct	000004444004
	oct	000004040000
	oct	132000000000
	oct	141160160154
	oct	171000000000
	oct	000774000003
	oct	000004000000
	oct	400000000000
	oct	141162145141
	oct	163000000000
	oct	000312000002
	oct	000004000000
	oct	600000000000
	oct	777777777777
	oct	142154141156
	oct	153000000000
	oct	000314000202
	oct	025004000000
	oct	600000000000
	oct	142154157143
	oct	153000000000
	oct	000315000402
	oct	001004000000
	oct	600000000000
	oct	777777777777
	oct	143150145143
	oct	153000000000
	oct	000703000000
	oct	000004000000
	oct	000000000000
	oct	143154157163
	oct	145000000000
	oct	000010444006
	oct	000004000000
	oct	500000000000
	oct	143157142157
	oct	154000000000
	oct	000277020002
	oct	000004000000
	oct	300000000000
	oct	143157155155
	oct	141000000000
	oct	001005000002
	oct	000004000000
	oct	400000000000
	oct	143157155160
	oct	154000000000
	oct	000704000000
	oct	000004000000
	oct	000000000000
	oct	143157165156
	oct	164000000000
	oct	000124000102
	oct	005004000000
	oct	300000000000
	oct	777777777777
	oct	145155160164
	oct	171000000000
	oct	000414000000
	oct	000004000000
	oct	000000000000
	oct	145156164145
	oct	162000000000
	oct	000054444006
	oct	000004000000
	oct	140000000000
	oct	145161165141
	oct	154000000000
	oct	000146010002
	oct	000004000000
	oct	140000000000
	oct	145162141163
	oct	145000000000
	oct	000415000000
	oct	000004000000
	oct	040000000000
	oct	145162162157
	oct	162000000000
	oct	000003000042
	oct	001004000000
	oct	300000000000
	oct	145166145162
	oct	171000000000
	oct	001036000002
	oct	000004000000
	oct	400000000000
	oct	777777777777
	oct	146151154145
	oct	163000000000
	oct	000427000000
	oct	000004000001
	oct	072000000000
	oct	146151156141
	oct	154000000000
	oct	001042000002
	oct	000004000000
	oct	000000000000
	oct	146151162163
	oct	164000000000
	oct	000155000002
	oct	201004000000
	oct	100000000000
	oct	146157162143
	oct	145000000000
	oct	000641000000
	oct	000004000000
	oct	400000000000
	oct	777777777777
	oct	147162157165
	oct	160000000000
	oct	001045000002
	oct	026004000000
	oct	000000000000
	oct	777777777777
	oct	151156144145
	oct	170000000000
	oct	000336000202
	oct	001004000000
	oct	276000000000
	oct	151156160165
	oct	164000000000
	oct	000163000002
	oct	000004000000
	oct	300000000000
	oct	777777777777
	oct	153145171145
	oct	144000000000
	oct	000640000000
	oct	000004000000
	oct	040000000000
	oct	777777777777
	oct	154141142145
	oct	154000000000
	oct	000171000402
	oct	003004000000
	oct	340000000000
	oct	154151155151
	oct	164000000000
	oct	001061000002
	oct	000004000000
	oct	640000000000
	oct	154151156145
	oct	163000000000
	oct	000174000002
	oct	123004000000
	oct	340000000000
	oct	154157143153
	oct	163000000000
	oct	000676000000
	oct	000004000000
	oct	040000000000
	oct	777777777777
	oct	155145162147
	oct	145000000000
	oct	000017444006
	oct	000014140010
	oct	140000000000
	oct	777777777777
	oct	157162144145
	oct	162000000000
	oct	000672000000
	oct	000004000000
	oct	000000000000
	oct	157164150145
	oct	162000000000
	oct	000673000000
	oct	000004000000
	oct	100000000000
	oct	157167156145
	oct	162000000000
	oct	000674000000
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	160162151157
	oct	162000000000
	oct	000421000000
	oct	000004000000
	oct	014000000000
	oct	160165162147
	oct	145000000000
	oct	000072444006
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	161165145165
	oct	145000000000
	oct	000352000102
	oct	000004000000
	oct	600000000000
	oct	161165157164
	oct	145000000000
	oct	000353100002
	oct	007004000000
	oct	700000000000
	oct	777777777777
	oct	162145141144
	oct	171000000000
	oct	000424000000
	oct	000004000000
	oct	000000000000
	oct	162145141154
	oct	155000000000
	oct	000425000000
	oct	000004000000
	oct	000000000000
	oct	162145162165
	oct	156000000000
	oct	001114000003
	oct	000004000000
	oct	456000000000
	oct	162145163145
	oct	164000000000
	oct	001116000002
	oct	000004000000
	oct	000000000000
	oct	162151147150
	oct	164000000000
	oct	000361000002
	oct	000004000000
	oct	240000000000
	oct	777777777777
	oct	163160141143
	oct	145000000000
	oct	000300100002
	oct	002004000000
	oct	700000000000
	oct	163164141162
	oct	164000000000
	oct	000070444006
	oct	000004000000
	oct	100000000000
	oct	163164157162
	oct	145000000000
	oct	000450000000
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	164141142154
	oct	145000000000
	oct	000375000002
	oct	000004000000
	oct	260000000000
	oct	164141154154
	oct	171000000000
	oct	000301000016
	oct	000004000001
	oct	060000000000
	oct	164151155145
	oct	163000000000
	oct	000250000002
	oct	000004000000
	oct	360000000000
	oct	164151164154
	oct	145000000000
	oct	000455000000
	oct	000004000000
	oct	060000000000
	oct	777777777777
	oct	165156164151
	oct	154000000000
	oct	000255000006
	oct	000004000000
	oct	100000000000
	oct	165163141147
	oct	145000000000
	oct	000401000202
	oct	121004000000
	oct	200000000000
	oct	165163151156
	oct	147000000000
	oct	000260000002
	oct	000004000000
	oct	160000000000
	oct	777777777777
	oct	166141154165
	oct	145000000000
	oct	000402000602
	oct	024004000000
	oct	260000000000
	oct	777777777777
	oct	167157162144
	oct	163000000000
	oct	001141000002
	oct	000004000000
	oct	400000000000
	oct	167162151164
	oct	145000000000
	oct	000046444006
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	172145162157
	oct	163000000000
	oct	000264120002
	oct	001004000000
	oct	760000000000
	oct	777777777777
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000002375
	oct	000000002427
	oct	000000002442
	oct	000000002532
	oct	000000002571
	oct	000000002623
	oct	000000002643
	oct	000000000000
	oct	000000002651
	oct	000000000000
	oct	000000000000
	oct	000000002657
	oct	000000002677
	oct	000000002717
	oct	000000002732
	oct	000000002752
	oct	000000002760
	oct	000000002766
	oct	000000003032
	oct	000000003110
	oct	000000003116
	oct	000000003124
	oct	000000003132
	oct	000000000000
	oct	000000000000
	oct	000000003140
	oct	141143143145
	oct	160164000000
	oct	000001444006
	oct	000004000000
	oct	576000000000
	oct	141143143145
	oct	163163000000
	oct	000765000002
	oct	000004000000
	oct	440000000000
	oct	141163163151
	oct	147156000000
	oct	000775000003
	oct	000014000012
	oct	400000000000
	oct	141164164141
	oct	143150000000
	oct	000623000000
	oct	000004000000
	oct	440000000000
	oct	141165164150
	oct	157162000000
	oct	000776000002
	oct	000014000030
	oct	400000000000
	oct	777777777777
	oct	142145146157
	oct	162145000000
	oct	000120000002
	oct	000004000000
	oct	100000000000
	oct	142157164164
	oct	157155000000
	oct	000354000002
	oct	000004000000
	oct	200000000000
	oct	777777777777
	oct	143141156143
	oct	145154000000
	oct	000007444006
	oct	000004000000
	oct	100000000000
	oct	143157154165
	oct	155156000000
	oct	001004000002
	oct	027004000000
	oct	000000000000
	oct	143157155160
	oct	055061000000
	oct	000324000202
	oct	001004000001
	oct	646000000000
	oct	143157155160
	oct	055062000000
	oct	000325000202
	oct	001004000001
	oct	600000000000
	oct	143157155160
	oct	055063000000
	oct	000323000202
	oct	001004000001
	oct	600000000000
	oct	143157155160
	oct	055064000000
	oct	000321000202
	oct	001004000001
	oct	654000000000
	oct	143157155160
	oct	055065000000
	oct	000322000202
	oct	001004000000
	oct	600000000000
	oct	143157155160
	oct	055066000000
	oct	000444000202
	oct	001004000000
	oct	600000000000
	oct	143157155160
	oct	055067000000
	oct	000442000202
	oct	001004000000
	oct	600000000000
	oct	143157155160
	oct	055070000000
	oct	001142000202
	oct	001004000000
	oct	600000000000
	oct	143157160151
	oct	145163000000
	oct	000707000000
	oct	000004000000
	oct	040000000000
	oct	777777777777
	oct	144142055153
	oct	145171000000
	oct	000331000000
	oct	000004000000
	oct	040000000000
	oct	144145154145
	oct	164145000000
	oct	000026444006
	oct	000004000000
	oct	100000000000
	oct	144145164141
	oct	143150000000
	oct	000625000000
	oct	000004000000
	oct	400000000000
	oct	144145164141
	oct	151154000000
	oct	001033000002
	oct	043004000000
	oct	076000000000
	oct	144145166151
	oct	143145000000
	oct	000626000000
	oct	000004000000
	oct	440000000000
	oct	144151166151
	oct	144145000000
	oct	000011444006
	oct	000004000000
	oct	110000000000
	oct	777777777777
	oct	145156141142
	oct	154145000000
	oct	000053444006
	oct	000004000000
	oct	100000000000
	oct	145156144055
	oct	151146000000
	oct	000730000000
	oct	000004000000
	oct	104000000000
	oct	145156144151
	oct	156147000000
	oct	000143000002
	oct	000004000001
	oct	140000000000
	oct	145161165141
	oct	154163000000
	oct	000146000002
	oct	000004000000
	oct	144000000000
	oct	145170164145
	oct	156144000000
	oct	000330000002
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	146151154154
	oct	145162000000
	oct	000334000002
	oct	000004000000
	oct	250000000000
	oct	146151156151
	oct	163150000000
	oct	000677000000
	oct	000004000000
	oct	000000000000
	oct	146157162155
	oct	141164000000
	oct	000624000000
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	147151166151
	oct	156147000000
	oct	000160000002
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	151156163151
	oct	144145000000
	oct	000653000000
	oct	000004000000
	oct	040000000000
	oct	777777777777
	oct	154145156147
	oct	164150000000
	oct	000342000002
	oct	000004000000
	oct	240000000000
	oct	154151155151
	oct	164163000000
	oct	001062000002
	oct	000004000000
	oct	600000000000
	oct	154151156141
	oct	147145000000
	oct	001063000402
	oct	007004000000
	oct	240000000000
	oct	777777777777
	oct	155145155142
	oct	145162000000
	oct	000661000000
	oct	000004000000
	oct	040000000000
	oct	155145155157
	oct	162171000000
	oct	001070000002
	oct	000004000000
	oct	440000000000
	oct	155157144151
	oct	146171000000
	oct	000665000000
	oct	000004000000
	oct	040000000000
	oct	777777777777
	oct	156141164151
	oct	166145000000
	oct	000440000000
	oct	005004000000
	oct	440000000000
	oct	156165155142
	oct	145162000000
	oct	001073000002
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	157142152145
	oct	143164000000
	oct	000443000000
	oct	000004000000
	oct	400000000000
	oct	157143143165
	oct	162163000000
	oct	000347000202
	oct	003004000000
	oct	214000000000
	oct	157165164160
	oct	165164000000
	oct	000211000002
	oct	000004000000
	oct	300000000000
	oct	777777777777
	oct	160162145146
	oct	151170000000
	oct	000445000000
	oct	000004000000
	oct	076000000000
	oct	777777777777
	oct	161165157164
	oct	145163000000
	oct	000353120002
	oct	007004000000
	oct	700000000000
	oct	777777777777
	oct	162141156144
	oct	157155000000
	oct	000223000002
	oct	000004000000
	oct	500000000000
	oct	162145141154
	oct	155163000000
	oct	000431000000
	oct	000004000000
	oct	000000000000
	oct	162145143157
	oct	162144000000
	oct	000224000402
	oct	002004000000
	oct	700000000000
	oct	162145160157
	oct	162164000000
	oct	000360002402
	oct	045414060036
	oct	200000000000
	oct	162145164141
	oct	151156000000
	oct	000637000000
	oct	000004000000
	oct	400000000000
	oct	162145164165
	oct	162156000000
	oct	000031440006
	oct	000004000000
	oct	100000000000
	oct	162145167151
	oct	156144000000
	oct	000233000002
	oct	000004000000
	oct	176000000000
	oct	777777777777
	oct	163143141154
	oct	141162000000
	oct	000210000000
	oct	000004000000
	oct	400000000000
	oct	163145141162
	oct	143150000000
	oct	000032440022
	oct	000004000000
	oct	100000000000
	oct	163145154145
	oct	143164000000
	oct	001124000003
	oct	000404000000
	oct	400000000000
	oct	163157165162
	oct	143145000000
	oct	000366000302
	oct	030004000000
	oct	200000000000
	oct	163160141143
	oct	145163000000
	oct	000300120002
	oct	002004000000
	oct	700000000000
	oct	163164141164
	oct	165163000000
	oct	000367000142
	oct	004004000000
	oct	600000000000
	oct	163164162145
	oct	141155000000
	oct	000627000000
	oct	000004000000
	oct	446000000000
	oct	163164162151
	oct	156147000000
	oct	000042444006
	oct	000004000000
	oct	160000000000
	oct	163171163164
	oct	145155000000
	oct	000452000000
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	164145156141
	oct	156164000000
	oct	000453000000
	oct	000004000000
	oct	060000000000
	oct	777777777777
	oct	165160144141
	oct	164145000000
	oct	000460000000
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	166141154165
	oct	145163000000
	oct	000402000002
	oct	000004000000
	oct	260000000000
	oct	777777777777
	oct	167151164150
	oct	151156000000
	oct	000465000000
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	172145162157
	oct	145163000000
	oct	000264120002
	oct	001004000000
	oct	760000000000
	oct	777777777777
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000003261
	oct	000000003267
	oct	000000003302
	oct	000000003327
	oct	000000003361
	oct	000000003401
	oct	000000003407
	oct	000000003415
	oct	000000003423
	oct	000000000000
	oct	000000000000
	oct	000000003450
	oct	000000003470
	oct	000000003515
	oct	000000003523
	oct	000000003531
	oct	000000000000
	oct	000000003607
	oct	000000003672
	oct	000000003724
	oct	000000003732
	oct	000000003740
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	141144144162
	oct	145163163000
	oct	000767000002
	oct	000004000001
	oct	000000000000
	oct	777777777777
	oct	142145143157
	oct	155145163000
	oct	000721000000
	oct	000004000000
	oct	000000000000
	oct	142157157154
	oct	145141156000
	oct	000212000000
	oct	000004000001
	oct	000000000000
	oct	777777777777
	oct	143157155160
	oct	165164145000
	oct	000050444006
	oct	000004000000
	oct	140000000000
	oct	143157156156
	oct	145143164000
	oct	000706000000
	oct	000004000000
	oct	040000000000
	oct	143157156164
	oct	162157154000
	oct	001010000002
	oct	440024300040
	oct	400000000000
	oct	143165162162
	oct	145156164000
	oct	000712000000
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	144145146141
	oct	165154164000
	oct	000447000000
	oct	000004000000
	oct	400000000000
	oct	144145156163
	oct	151164171000
	oct	000636000000
	oct	000004000000
	oct	400000000000
	oct	144151163141
	oct	142154145000
	oct	000051444006
	oct	000004000000
	oct	100000000000
	oct	144151163160
	oct	154141171000
	oct	000052444206
	oct	001004000000
	oct	700000000000
	oct	144171156141
	oct	155151143000
	oct	000251000002
	oct	000004000000
	oct	444000000000
	oct	777777777777
	oct	145156144055
	oct	141144144000
	oct	000722000000
	oct	000004000000
	oct	100000000000
	oct	145170141155
	oct	151156145000
	oct	000062440006
	oct	000004200001
	oct	100000000000
	oct	145170143145
	oct	145144163000
	oct	000161000002
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	146157157164
	oct	151156147000
	oct	001043000002
	oct	203004000000
	oct	200000000000
	oct	777777777777
	oct	147162145141
	oct	164145162000
	oct	000161010002
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	150145141144
	oct	151156147000
	oct	001044000002
	oct	200004000000
	oct	000000000000
	oct	777777777777
	oct	151156144145
	oct	170145144000
	oct	000337000002
	oct	000004220000
	oct	600000000000
	oct	151156151164
	oct	151141154000
	oct	000162000002
	oct	000004000000
	oct	340000000000
	oct	151156163160
	oct	145143164000
	oct	000021444006
	oct	000004160000
	oct	140000000000
	oct	151156166141
	oct	154151144000
	oct	000165000002
	oct	000004000000
	oct	140000000000
	oct	777777777777
	oct	154145141144
	oct	151156147000
	oct	000172000202
	oct	007004000000
	oct	740000000000
	oct	154151156153
	oct	141147145000
	oct	000344002002
	oct	003404000000
	oct	240000000000
	oct	154157143141
	oct	154154171000
	oct	000656000000
	oct	000004000000
	oct	040000000000
	oct	777777777777
	oct	155141170151
	oct	155165155000
	oct	000456000000
	oct	000004000000
	oct	000000000000
	oct	155145155142
	oct	145162163000
	oct	000662000000
	oct	000004000000
	oct	040000000000
	oct	155145163163
	oct	141147145000
	oct	000176000102
	oct	001004000000
	oct	740000000000
	oct	155157144165
	oct	154145163000
	oct	001071000002
	oct	000004000000
	oct	440000000000
	oct	777777777777
	oct	156165155145
	oct	162151143000
	oct	000203000002
	oct	000004000000
	oct	500000000000
	oct	777777777777
	oct	157155151164
	oct	164145144000
	oct	000313000002
	oct	000004000000
	oct	600000000000
	oct	777777777777
	oct	160141144144
	oct	151156147000
	oct	000515000000
	oct	000004000000
	oct	000000000000
	oct	160145162146
	oct	157162155000
	oct	000024444020
	oct	000044000240
	oct	100000000000
	oct	160151143164
	oct	165162145000
	oct	000350000202
	oct	020014000002
	oct	250000000000
	oct	160157151156
	oct	164145162000
	oct	000214000002
	oct	000004000000
	oct	100000000000
	oct	160162145163
	oct	145156164000
	oct	000772000000
	oct	000004000000
	oct	000000000000
	oct	160162157143
	oct	145145144000
	oct	000220000002
	oct	000004000000
	oct	100000000000
	oct	160162157143
	oct	145163163000
	oct	000060444004
	oct	000004000001
	oct	100000000000
	oct	160162157147
	oct	162141155000
	oct	000222000002
	oct	000004000000
	oct	500000000000
	oct	160162157164
	oct	145143164000
	oct	000642000000
	oct	000004000000
	oct	400000000000
	oct	777777777777
	oct	162145143145
	oct	151166145000
	oct	000027444006
	oct	000004000000
	oct	100000000000
	oct	162145143157
	oct	162144163000
	oct	000303000002
	oct	000004000000
	oct	700000000000
	oct	162145154145
	oct	141163145000
	oct	000030444006
	oct	000004000000
	oct	100000000000
	oct	162145155157
	oct	166141154000
	oct	000404000002
	oct	000004000000
	oct	100000000000
	oct	162145156141
	oct	155145163000
	oct	000357000002
	oct	000004000000
	oct	200000000000
	oct	162145160154
	oct	141143145000
	oct	000651000040
	oct	000014000006
	oct	700000000000
	oct	162145160157
	oct	162164163000
	oct	000360000402
	oct	005414060036
	oct	200000000000
	oct	162145163145
	oct	162166145000
	oct	001115000002
	oct	000004000000
	oct	400000000000
	oct	162145167162
	oct	151164145000
	oct	000033444006
	oct	000004000000
	oct	100000000000
	oct	162157165156
	oct	144145144000
	oct	000234000002
	oct	000004000000
	oct	114000000000
	oct	777777777777
	oct	163145143164
	oct	151157156000
	oct	000236000006
	oct	000104011000
	oct	700000000000
	oct	163145147155
	oct	145156164000
	oct	000237000002
	oct	000004000000
	oct	504000000000
	oct	163160141156
	oct	156145144000
	oct	001131000000
	oct	000004000000
	oct	400000000000
	oct	163164141164
	oct	151157156000
	oct	000446000000
	oct	000004000000
	oct	000000000000
	oct	163165163160
	oct	145156144000
	oct	000043444006
	oct	000004000001
	oct	100000000000
	oct	777777777777
	oct	164150162157
	oct	165147150000
	oct	000246000002
	oct	000004000000
	oct	700000000000
	oct	777777777777
	oct	165156145161
	oct	165141154000
	oct	000253000002
	oct	000004000000
	oct	160000000000
	oct	777777777777
	oct	166141162171
	oct	151156147000
	oct	000261000006
	oct	000004000000
	oct	100000000000
	oct	166151162164
	oct	165141154000
	oct	000433000000
	oct	000004000000
	oct	060000000000
	oct	777777777777
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000004066
	oct	000000000000
	oct	000000004101
	oct	000000004145
	oct	000000004153
	oct	000000000000
	oct	000000004200
	oct	000000000000
	oct	000000004206
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000004226
	oct	000000004241
	oct	000000004247
	oct	000000004262
	oct	000000000000
	oct	000000004302
	oct	000000004322
	oct	000000004373
	oct	000000004413
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	141154160150
	oct	141142145164
	oct	000770000002
	oct	000004000000
	oct	440000000000
	oct	141154164145
	oct	162151156147
	oct	000717000000
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	143157144145
	oct	055163145164
	oct	000462000400
	oct	010004000000
	oct	200000000000
	oct	143157156163
	oct	164141156164
	oct	000326002002
	oct	002004000000
	oct	240000000000
	oct	143157156164
	oct	141151156163
	oct	000327000002
	oct	000004000000
	oct	640000000000
	oct	143157156164
	oct	151156165145
	oct	000034444006
	oct	000004000000
	oct	000000000000
	oct	143157156164
	oct	162157154163
	oct	001011000002
	oct	440004000000
	oct	440000000000
	oct	143163055142
	oct	141163151143
	oct	000710000000
	oct	000004000000
	oct	040000000000
	oct	143165162162
	oct	145156143171
	oct	001015000003
	oct	000014000022
	oct	406000000000
	oct	777777777777
	oct	144151166151
	oct	163151157156
	oct	000136000006
	oct	000004000000
	oct	700000000000
	oct	777777777777
	oct	145156144055
	oct	143141154154
	oct	000723000000
	oct	000004000000
	oct	100000000000
	oct	145156144055
	oct	162145141144
	oct	000733000000
	oct	000004000000
	oct	100000000000
	oct	145166141154
	oct	165141164145
	oct	000764000000
	oct	000004000000
	oct	100000000000
	oct	145170164145
	oct	162156141154
	oct	000463000000
	oct	000004000000
	oct	400000000000
	oct	777777777777
	oct	147145156145
	oct	162141164145
	oct	000055444020
	oct	000014000036
	oct	500000000000
	oct	777777777777
	oct	151156144151
	oct	143141164145
	oct	001051000002
	oct	000004000000
	oct	000000000000
	oct	151156151164
	oct	151141164145
	oct	000020444020
	oct	000014000036
	oct	140000000000
	oct	151156166157
	oct	153151156147
	oct	000654000000
	oct	000004000000
	oct	040000000000
	oct	777777777777
	oct	155165154164
	oct	151160154145
	oct	001072000003
	oct	000004000000
	oct	440000000000
	oct	155165154164
	oct	151160154171
	oct	000012444006
	oct	000004000000
	oct	140000000000
	oct	777777777777
	oct	156145147141
	oct	164151166145
	oct	000177000002
	oct	000004000000
	oct	140000000000
	oct	777777777777
	oct	157160164151
	oct	157156141154
	oct	001100000000
	oct	000004000000
	oct	400000000000
	oct	157166145162
	oct	146154157167
	oct	000006000002
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	160157163151
	oct	164151157156
	oct	001106000002
	oct	000004000000
	oct	400000000000
	oct	160157163151
	oct	164151166145
	oct	000215000002
	oct	000004000000
	oct	100000000000
	oct	160162151156
	oct	164151156147
	oct	001057000002
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	162145141154
	oct	155055151144
	oct	000426000000
	oct	000004000000
	oct	000000000000
	oct	162145154141
	oct	164151166145
	oct	000247000002
	oct	000004000000
	oct	400000000000
	oct	162145166145
	oct	162163145144
	oct	000232000002
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	163145143165
	oct	162151164171
	oct	001122000002
	oct	000014000030
	oct	400000000000
	oct	163145156164
	oct	145156143145
	oct	000240000002
	oct	000004000000
	oct	100000000000
	oct	163145160141
	oct	162141164145
	oct	000364000002
	oct	000004000000
	oct	640000000000
	oct	163145161165
	oct	145156143145
	oct	001113000024
	oct	000004000000
	oct	500000000000
	oct	163164141156
	oct	144141162144
	oct	000242000002
	oct	000004000000
	oct	700000000000
	oct	163165142164
	oct	162141143164
	oct	000013444006
	oct	000004000000
	oct	160000000000
	oct	163165160160
	oct	162145163163
	oct	000071444002
	oct	000414000036
	oct	000000000000
	oct	163171155142
	oct	157154151143
	oct	000373000142
	oct	000004000000
	oct	600000000000
	oct	777777777777
	oct	164141154154
	oct	171151156147
	oct	000243000002
	oct	000004000000
	oct	160000000000
	oct	164145162155
	oct	151156141154
	oct	000244000002
	oct	000004000000
	oct	160000000000
	oct	164162141151
	oct	154151156147
	oct	000377000202
	oct	007004000000
	oct	600000000000
	oct	777777777777
	oct	165156163164
	oct	162151156147
	oct	000045444006
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000004534
	oct	000000004565
	oct	000000004574
	oct	000000004611
	oct	000000004656
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000004707
	oct	000000004716
	oct	000000000000
	oct	000000004725
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000004734
	oct	000000000000
	oct	000000004751
	oct	000000005024
	oct	000000005041
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	141144166141
	oct	156143151156
	oct	147000000000
	oct	000107000002
	oct	000004000000
	oct	100000000000
	oct	141147147162
	oct	145147141164
	oct	145000000000
	oct	000150000000
	oct	000004000000
	oct	440000000000
	oct	141154164145
	oct	162156141164
	oct	145000000000
	oct	000773000002
	oct	000004000000
	oct	400000000000
	oct	141163143145
	oct	156144151156
	oct	147000000000
	oct	000116000002
	oct	000004000000
	oct	300000000000
	oct	777777777777
	oct	142145147151
	oct	156156151156
	oct	147000000000
	oct	000121000002
	oct	000004000001
	oct	100000000000
	oct	777777777777
	oct	143150141162
	oct	141143164145
	oct	162000000000
	oct	000123000002
	oct	000004000000
	oct	740000000000
	oct	143157154154
	oct	141164151156
	oct	147000000000
	oct	001003000002
	oct	000004000000
	oct	540000000000
	oct	777777777777
	oct	144142055163
	oct	164141164165
	oct	163000000000
	oct	000455000000
	oct	000004000000
	oct	040000000000
	oct	144145142165
	oct	147147151156
	oct	147000000000
	oct	000130000015
	oct	020114326024
	oct	500000000000
	oct	144145154151
	oct	155151164145
	oct	144000000000
	oct	000132000002
	oct	000004000000
	oct	156000000000
	oct	144145154151
	oct	155151164145
	oct	162000000000
	oct	000133000002
	oct	000004000000
	oct	100000000000
	oct	144145160145
	oct	156144151156
	oct	147000000000
	oct	000134000006
	oct	000004000000
	oct	300000000000
	oct	144165160154
	oct	151143141164
	oct	145000000000
	oct	000413000000
	oct	000004000000
	oct	040000000000
	oct	777777777777
	oct	145156144055
	oct	163164141162
	oct	164000000000
	oct	000740000000
	oct	000004000000
	oct	144000000000
	oct	145156144055
	oct	167162151164
	oct	145000000000
	oct	000744000000
	oct	000004000000
	oct	140000000000
	oct	145170143145
	oct	160164151157
	oct	156000000000
	oct	000153000002
	oct	000004000000
	oct	100000000000
	oct	145170143154
	oct	165163151166
	oct	145000000000
	oct	000416000000
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	151156143154
	oct	165144151156
	oct	147000000000
	oct	000647000000
	oct	000004000000
	oct	040000000000
	oct	777777777777
	oct	152165163164
	oct	151146151145
	oct	144000000000
	oct	000340000202
	oct	022004000000
	oct	240000000000
	oct	777777777777
	oct	154157167055
	oct	166141154165
	oct	145000000000
	oct	000345100002
	oct	006004000000
	oct	740000000000
	oct	777777777777
	oct	160145162155
	oct	141156145156
	oct	164000000000
	oct	000632000000
	oct	000004000000
	oct	400000000000
	oct	160162157143
	oct	145144165162
	oct	145000000000
	oct	000216002005
	oct	006424000240
	oct	740000000000
	oct	777777777777
	oct	162145143157
	oct	162144151156
	oct	147000000000
	oct	000355000402
	oct	000004000000
	oct	200000000000
	oct	162145144145
	oct	146151156145
	oct	163000000000
	oct	000356000202
	oct	010004000000
	oct	200000000000
	oct	162145155141
	oct	151156144145
	oct	162000000000
	oct	000227000002
	oct	000004000000
	oct	100000000000
	oct	162145160154
	oct	141143151156
	oct	147000000000
	oct	000230000002
	oct	000004000000
	oct	700000000000
	oct	162145160157
	oct	162164151156
	oct	147000000000
	oct	000231000004
	oct	000414000036
	oct	100000000000
	oct	162145164141
	oct	151156151156
	oct	147000000000
	oct	000467000000
	oct	000004000000
	oct	000000000000
	oct	162145164162
	oct	151145166141
	oct	154000000000
	oct	000435000000
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	163145143157
	oct	156144141162
	oct	171000000000
	oct	000525000000
	oct	000004000000
	oct	000000000000
	oct	163145154145
	oct	143164151157
	oct	156000000000
	oct	000436000000
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	164145155160
	oct	157162141162
	oct	171000000000
	oct	000631000000
	oct	000004000000
	oct	460000000000
	oct	164145162155
	oct	151156141164
	oct	145000000000
	oct	000044444020
	oct	000014000036
	oct	160000000000
	oct	164162141156
	oct	163146157162
	oct	155000000000
	oct	000063440006
	oct	000004260001
	oct	160000000000
	oct	777777777777
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000005177
	oct	000000000000
	oct	000000005214
	oct	000000005253
	oct	000000005320
	oct	000000000000
	oct	000000005357
	oct	000000005366
	oct	000000005375
	oct	000000000000
	oct	000000000000
	oct	000000005404
	oct	000000005413
	oct	000000000000
	oct	000000000000
	oct	000000005422
	oct	000000000000
	oct	000000005445
	oct	000000005462
	oct	000000000000
	oct	000000005535
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	141144144151
	oct	164151157156
	oct	141154000000
	oct	000643000000
	oct	000004000000
	oct	440000000000
	oct	141154160150
	oct	141142145164
	oct	151143000000
	oct	000112000002
	oct	000004000000
	oct	140000000000
	oct	777777777777
	oct	143141164141
	oct	154157147165
	oct	145144000000
	oct	000701000000
	oct	000004000000
	oct	000000000000
	oct	143150141162
	oct	141143164145
	oct	162163000000
	oct	000123000002
	oct	000004000000
	oct	700000000000
	oct	143157156143
	oct	165162162145
	oct	156164000000
	oct	000705000000
	oct	000004000000
	oct	000000000000
	oct	143157156166
	oct	145162163151
	oct	157156000000
	oct	001007000002
	oct	000004000001
	oct	040000000000
	oct	143163055147
	oct	145156145162
	oct	141154000000
	oct	000711000000
	oct	000004000000
	oct	040000000000
	oct	777777777777
	oct	144145142165
	oct	147055151164
	oct	145155000000
	oct	001023000016
	oct	000004320000
	oct	000000000000
	oct	144145142165
	oct	147055154151
	oct	156145000000
	oct	001024000016
	oct	000004320000
	oct	040000000000
	oct	144145142165
	oct	147055156141
	oct	155145000000
	oct	001031000016
	oct	000004320000
	oct	040000000000
	oct	144145163143
	oct	145156144151
	oct	156147000000
	oct	000135000002
	oct	000004000000
	oct	300000000000
	oct	144151163143
	oct	157156156145
	oct	143164000000
	oct	000412000000
	oct	000004000000
	oct	000000000000
	oct	144165160154
	oct	151143141164
	oct	145163000000
	oct	000343000002
	oct	000004000000
	oct	440000000000
	oct	777777777777
	oct	145156144055
	oct	144145154145
	oct	164145000000
	oct	000725000000
	oct	000004000000
	oct	100000000000
	oct	145156144055
	oct	144151166151
	oct	144145000000
	oct	000726000000
	oct	000004000000
	oct	140000000000
	oct	145156144055
	oct	162145164165
	oct	162156000000
	oct	000735000000
	oct	000004000000
	oct	100000000000
	oct	145156144055
	oct	163145141162
	oct	143150000000
	oct	000737000000
	oct	000004000000
	oct	100000000000
	oct	145156144055
	oct	163164162151
	oct	156147000000
	oct	000741000000
	oct	000004000000
	oct	140000000000
	oct	777777777777
	oct	147145156145
	oct	162141164151
	oct	157156000000
	oct	000644000000
	oct	000004000000
	oct	400000000000
	oct	777777777777
	oct	150151147150
	oct	055166141154
	oct	165145000000
	oct	000335100002
	oct	005004000000
	oct	700000000000
	oct	777777777777
	oct	151156151164
	oct	151141154151
	oct	172145000000
	oct	000015444010
	oct	000104005001
	oct	140000000000
	oct	777777777777
	oct	154157167055
	oct	166141154165
	oct	145163000000
	oct	000345120002
	oct	006004000000
	oct	700000000000
	oct	777777777777
	oct	155145155142
	oct	145162163150
	oct	151160000000
	oct	000664000000
	oct	000004000000
	oct	040000000000
	oct	777777777777
	oct	160162157143
	oct	145144165162
	oct	145163000000
	oct	000217000002
	oct	000004000000
	oct	100000000000
	oct	160162157143
	oct	145163163151
	oct	156147000000
	oct	000221000002
	oct	000004000001
	oct	100000000000
	oct	160162157147
	oct	162141155055
	oct	151144000000
	oct	001107000002
	oct	000414000026
	oct	400000000000
	oct	777777777777
	oct	162145141154
	oct	155055156141
	oct	155145000000
	oct	000430000000
	oct	000004000000
	oct	000000000000
	oct	162145146145
	oct	162145156143
	oct	145163000000
	oct	000226000002
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	163145161165
	oct	145156164151
	oct	141154000000
	oct	001125000002
	oct	000004000000
	oct	400000000000
	oct	163157162164
	oct	055155145162
	oct	147145000000
	oct	001126000002
	oct	000004000000
	oct	400000000000
	oct	163164141156
	oct	144141162144
	oct	055061000000
	oct	000771000000
	oct	006004000000
	oct	400000000000
	oct	163164141156
	oct	144141162144
	oct	055062000000
	oct	000320000000
	oct	000004000001
	oct	460000000000
	oct	163165142055
	oct	163143150145
	oct	155141000000
	oct	000451000000
	oct	000404000000
	oct	000000000000
	oct	163165142163
	oct	164151164165
	oct	164145000000
	oct	000307000000
	oct	000004000000
	oct	060000000000
	oct	163165160145
	oct	162166151163
	oct	157162000000
	oct	001134000000
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	165163141147
	oct	145055155157
	oct	144145000000
	oct	000461000000
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000005657
	oct	000000005666
	oct	000000005741
	oct	000000000000
	oct	000000000000
	oct	000000006006
	oct	000000006015
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000006032
	oct	000000006047
	oct	000000000000
	oct	000000006056
	oct	000000006073
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	143154157143
	oct	153055165156
	oct	151164163000
	oct	001001000002
	oct	000004000000
	oct	440000000000
	oct	777777777777
	oct	144141171055
	oct	157146055167
	oct	145145153000
	oct	000506000000
	oct	000004000000
	oct	100000000000
	oct	144142055163
	oct	145164055156
	oct	141155145000
	oct	000716000000
	oct	000004000000
	oct	040000000000
	oct	144145142165
	oct	147055163165
	oct	142055061000
	oct	001025000016
	oct	000004320000
	oct	040000000000
	oct	144145142165
	oct	147055163165
	oct	142055062000
	oct	001026000016
	oct	000004320000
	oct	006000000000
	oct	144145142165
	oct	147055163165
	oct	142055063000
	oct	001027000016
	oct	000004320000
	oct	000000000000
	oct	144145163143
	oct	162151160164
	oct	157162163000
	oct	000305000000
	oct	000004000000
	oct	400000000000
	oct	144145163164
	oct	151156141164
	oct	151157156000
	oct	000332000042
	oct	003004000000
	oct	240000000000
	oct	777777777777
	oct	145156144055
	oct	143157155160
	oct	165164145000
	oct	000724000000
	oct	000004000000
	oct	100000000000
	oct	145156144055
	oct	157146055160
	oct	141147145000
	oct	000144000002
	oct	000004000000
	oct	140000000000
	oct	145156144055
	oct	160145162146
	oct	157162155000
	oct	000732000000
	oct	000004000000
	oct	140000000000
	oct	145156144055
	oct	162145143145
	oct	151166145000
	oct	000734000000
	oct	000004000000
	oct	100000000000
	oct	145156144055
	oct	162145167162
	oct	151164145000
	oct	000736000000
	oct	000004000000
	oct	150000000000
	oct	145156166151
	oct	162157156155
	oct	145156164000
	oct	001034000002
	oct	000424000140
	oct	414000000000
	oct	777777777777
	oct	150151147150
	oct	055166141154
	oct	165145163000
	oct	000335120002
	oct	005004000000
	oct	700000000000
	oct	777777777777
	oct	151055157055
	oct	143157156164
	oct	162157154000
	oct	001047000003
	oct	000404000000
	oct	400000000000
	oct	151156164145
	oct	162143150141
	oct	156147145000
	oct	000507000000
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	157160145162
	oct	141164151157
	oct	156141154000
	oct	000671000000
	oct	000004000000
	oct	040000000000
	oct	157165164160
	oct	165164055155
	oct	157144145000
	oct	000630000000
	oct	000004000000
	oct	400000000000
	oct	777777777777
	oct	160162145141
	oct	164164141143
	oct	150145144000
	oct	000310000000
	oct	000004000000
	oct	022000000000
	oct	777777777777
	oct	162145143157
	oct	162144055156
	oct	141155145000
	oct	000432000000
	oct	000004000000
	oct	000000000000
	oct	162145160154
	oct	141143145155
	oct	145156164000
	oct	000660000000
	oct	000004000000
	oct	462000000000
	oct	777777777777
	oct	163165142055
	oct	161165145165
	oct	145055061000
	oct	000370000102
	oct	000004000000
	oct	260000000000
	oct	163165142055
	oct	161165145165
	oct	145055062000
	oct	000371000102
	oct	000004000000
	oct	200000000000
	oct	163165142055
	oct	161165145165
	oct	145055063000
	oct	000372000102
	oct	000004000000
	oct	200000000000
	oct	777777777777
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000006231
	oct	000000000000
	oct	000000006240
	oct	000000006247
	oct	000000006264
	oct	000000006315
	oct	000000000000
	oct	000000000000
	oct	000000006324
	oct	000000000000
	oct	000000006341
	oct	000000006350
	oct	000000006357
	oct	000000000000
	oct	000000006366
	oct	000000006375
	oct	000000000000
	oct	000000000000
	oct	000000006404
	oct	000000006421
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	141154160150
	oct	141156165155
	oct	145162151143
	oct	000113000002
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	143141164141
	oct	154157147055
	oct	156141155145
	oct	000513000000
	oct	000004000000
	oct	600000000000
	oct	777777777777
	oct	144141164145
	oct	055167162151
	oct	164164145156
	oct	001020000002
	oct	000014000030
	oct	400000000000
	oct	144145143154
	oct	141162141164
	oct	151166145163
	oct	000131000002
	oct	000454000254
	oct	140000000000
	oct	777777777777
	oct	145156144055
	oct	145166141154
	oct	165141164145
	oct	000727000000
	oct	000004000000
	oct	140000000000
	oct	145156144055
	oct	155165154164
	oct	151160154171
	oct	000731000000
	oct	000004000000
	oct	100000000000
	oct	145156144055
	oct	163165142164
	oct	162141143164
	oct	000742000000
	oct	000004000000
	oct	176000000000
	oct	145156144055
	oct	165156163164
	oct	162151156147
	oct	000743000000
	oct	000004000000
	oct	140000000000
	oct	777777777777
	oct	146151154145
	oct	055143157156
	oct	164162157154
	oct	001037000003
	oct	000404000000
	oct	400000000000
	oct	777777777777
	oct	151156160165
	oct	164055157165
	oct	164160165164
	oct	000167000003
	oct	000404000000
	oct	440000000000
	oct	151156163164
	oct	141154154141
	oct	164151157156
	oct	001052000002
	oct	000014000030
	oct	440000000000
	oct	777777777777
	oct	153145171055
	oct	154157143141
	oct	164151157156
	oct	000655000000
	oct	000004000000
	oct	040000000000
	oct	777777777777
	oct	154151156145
	oct	055143157165
	oct	156164145162
	oct	001065000016
	oct	000004000000
	oct	040000000000
	oct	777777777777
	oct	155157144151
	oct	146151143141
	oct	164151157156
	oct	000645000000
	oct	000004000000
	oct	440000000000
	oct	777777777777
	oct	157162147141
	oct	156151172141
	oct	164151157156
	oct	000265000002
	oct	000004000000
	oct	400000000000
	oct	777777777777
	oct	160141147145
	oct	055143157165
	oct	156164145162
	oct	001102000016
	oct	000004000000
	oct	000000000000
	oct	777777777777
	oct	163165142163
	oct	164151164165
	oct	164151157156
	oct	000663000000
	oct	000004000000
	oct	460000000000
	oct	163171156143
	oct	150162157156
	oct	151172145144
	oct	000374000202
	oct	006004000000
	oct	200000000000
	oct	777777777777
	oct	164141160145
	oct	055157160164
	oct	151157156163
	oct	000633000000
	oct	000004000000
	oct	400000000000
	oct	777777777777
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000006543
	oct	000000006607
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000006644
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	143141164141
	oct	154157147055
	oct	156141155145
	oct	163000000000
	oct	000513000000
	oct	000004000000
	oct	600000000000
	oct	143157155155
	oct	165156151143
	oct	141164151157
	oct	156000000000
	oct	000317002002
	oct	004404100000
	oct	200000000000
	oct	143157155160
	oct	165164141164
	oct	151157156141
	oct	154000000000
	oct	000152000202
	oct	001004000000
	oct	600000000000
	oct	143157156146
	oct	151147165162
	oct	141164151157
	oct	156000000000
	oct	001006000003
	oct	000404000000
	oct	476000000000
	oct	143157162162
	oct	145163160157
	oct	156144151156
	oct	147000000000
	oct	001014000012
	oct	000104024000
	oct	100000000000
	oct	777777777777
	oct	144141164145
	oct	055143157155
	oct	160151154145
	oct	144000000000
	oct	001017000002
	oct	000014000020
	oct	440000000000
	oct	144142055145
	oct	170143145160
	oct	164151157156
	oct	163000000000
	oct	000713000000
	oct	000004000000
	oct	040000000000
	oct	144142055162
	oct	145141154155
	oct	055156141155
	oct	145000000000
	oct	000376000000
	oct	000004000000
	oct	000000000000
	oct	144145143151
	oct	155141154055
	oct	160157151156
	oct	164000000000
	oct	001032000003
	oct	000014000004
	oct	440000000000
	oct	777777777777
	oct	163145147155
	oct	145156164055
	oct	154151155151
	oct	164000000000
	oct	001123000003
	oct	000004000000
	oct	400000000000
	oct	163160145143
	oct	151141154055
	oct	156141155145
	oct	163000000000
	oct	001130000003
	oct	000404000000
	oct	400000000000
	oct	777777777777
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000006776
	oct	000000000000
	oct	000000007006
	oct	000000007016
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000007044
	oct	000000000000
	oct	000000000000
	oct	000000007054
	oct	000000000000
	oct	000000007064
	oct	000000007074
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	141164164141
	oct	143150055157
	oct	160164151157
	oct	156163000000
	oct	000634000000
	oct	000004000000
	oct	400000000000
	oct	777777777777
	oct	143141164141
	oct	154157147165
	oct	145055156141
	oct	155145000000
	oct	000513000000
	oct	000004000000
	oct	400000000000
	oct	777777777777
	oct	144142055160
	oct	162151166141
	oct	143171055153
	oct	145171000000
	oct	000714000000
	oct	000004000000
	oct	040000000000
	oct	144142055162
	oct	145143157162
	oct	144055156141
	oct	155145000000
	oct	000715000000
	oct	000004000000
	oct	040000000000
	oct	144145142165
	oct	147055143157
	oct	156164145156
	oct	164163000000
	oct	001022000016
	oct	000004320000
	oct	000000000000
	oct	777777777777
	oct	151144145156
	oct	164151146151
	oct	143141164151
	oct	157156000000
	oct	001050000006
	oct	000424000100
	oct	400000000000
	oct	777777777777
	oct	154151156141
	oct	147145055143
	oct	157165156164
	oct	145162000000
	oct	001064000016
	oct	000004000000
	oct	300000000000
	oct	777777777777
	oct	156165155145
	oct	162151143055
	oct	145144151164
	oct	145144000000
	oct	000204000002
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	157142152145
	oct	143164055160
	oct	162157147162
	oct	141155000000
	oct	001075000000
	oct	000004000001
	oct	000000000000
	oct	777777777777
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000007217
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000007317
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000007327
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000007337
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	143141164141
	oct	154157147165
	oct	145055156141
	oct	155145163000
	oct	000513000000
	oct	000004000000
	oct	400000000000
	oct	143157155160
	oct	165164141164
	oct	151157156141
	oct	154055061000
	oct	000324000202
	oct	001004000001
	oct	622000000000
	oct	143157155160
	oct	165164141164
	oct	151157156141
	oct	154055062000
	oct	000325000202
	oct	001004000001
	oct	640000000000
	oct	143157155160
	oct	165164141164
	oct	151157156141
	oct	154055063000
	oct	000323000202
	oct	001004000001
	oct	600000000000
	oct	143157155160
	oct	165164141164
	oct	151157156141
	oct	154055064000
	oct	000321000202
	oct	001004000001
	oct	600000000000
	oct	143157155160
	oct	165164141164
	oct	151157156141
	oct	154055065000
	oct	000322000202
	oct	001004000000
	oct	600000000000
	oct	143157155160
	oct	165164141164
	oct	151157156141
	oct	154055066000
	oct	000444000202
	oct	001004000000
	oct	600000000000
	oct	143157155160
	oct	165164141164
	oct	151157156141
	oct	154055067000
	oct	000442000202
	oct	001004000000
	oct	640000000000
	oct	143157155160
	oct	165164141164
	oct	151157156141
	oct	154055070000
	oct	001142000202
	oct	001004000000
	oct	600000000000
	oct	777777777777
	oct	157142152145
	oct	143164055143
	oct	157155160165
	oct	164145162000
	oct	001074000003
	oct	000404000000
	oct	400000000000
	oct	777777777777
	oct	163157165162
	oct	143145055143
	oct	157155160165
	oct	164145162000
	oct	001127000003
	oct	000404000000
	oct	400000000000
	oct	777777777777
	oct	167157162153
	oct	151156147055
	oct	163164157162
	oct	141147145000
	oct	000403002002
	oct	001414000032
	oct	200000000000
	oct	777777777777
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000007462
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	144151162145
	oct	143164055162
	oct	145146145162
	oct	145156143145
	oct	000411000000
	oct	000004000000
	oct	040000000000
	oct	777777777777
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000007605
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	141154160150
	oct	141156165155
	oct	145162151143
	oct	055145144151
	oct	164145144000
	oct	000114000002
	oct	000004000000
	oct	100000000000
	oct	777777777777
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000007731
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	000000000000
	oct	144145142165
	oct	147055156165
	oct	155145162151
	oct	143055143157
	oct	156164145156
	oct	164163000000
	oct	000410000000
	oct	000004000000
	oct	000000000000
	oct	777777777777
	end
 



		    cobol_rw.alm                    11/11/82  1510.4rew 11/11/82  0955.0      240948



" ***********************************************************
" *                                                         *
" * Copyright, (C) Honeywell Information Systems Inc., 1982 *
" *                                                         *
" ***********************************************************
	name	cobol_rw
	entry	cobol_rw
cobol_rw:	save
	epp2	cobol_rw
	spri2	ap|2,*
	return
		equ i_r,0
		equ i_c,1
		equ i_s,3
		equ i_n,2
		equ i_k,4
		equ i_K,5
		equ l_org,*-5
	rs:	vfd a36/    ,36/i_n,36/0,36/(r1-l_org)/5,36/a_recov_loc
l_1:		vfd a36/    ,36/i_s,36/(reports-l_org)/5,36/(l_2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(l_2-l_org)/5,36/0
l_2:	rs_1:	vfd a36/    ,36/i_n,36/0,36/(rs_1-l_org)/5,36/a_rs_exit
	reports:	vfd a36/    ,36/i_n,36/0,36/(r2-l_org)/5,36/a_recov_loc
l_3:		vfd a36/    ,36/i_s,36/(rep_hdr-l_org)/5,36/(l_4-l_org)/5,36/a_rep_init
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_4:		vfd a36/    ,36/i_s,36/(report-l_org)/5,36/(l_5-l_org)/5,36/a_rep_add
		vfd a36/    ,36/i_n,36/0,36/(l_5-l_org)/5,36/a_recvy
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_5:	reps_1:	vfd a36/    ,36/i_c,36/c_eof,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(report-l_org)/5,36/(reps_1-l_org)/5,36/a_rep_add
		vfd a36/    ,36/i_n,36/0,36/(l_6-l_org)/5,36/a_recvy
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_6:	rep_hdr:	vfd a36/s   ,36/i_r,36/r_report,36/(l_7-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_7:		vfd a36/s   ,36/i_r,36/r_section,36/(l_8-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_8:		vfd a36/s   ,36/i_r,36/r_per,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	report:	vfd a36/    ,36/i_n,36/0,36/(r6-l_org)/5,36/a_recov_loc
l_9:		vfd a36/    ,36/i_s,36/(rd-l_org)/5,36/(l_10-l_org)/5,36/a_rep_group_1
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_10:		vfd a36/    ,36/i_c,36/c_lev_num,36/(rep_2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/123,36/(fail-l_org)/5,36/0
	rep_1:	vfd a36/    ,36/i_c,36/c_lev_num,36/(l_11-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
l_11:	rep_2:	vfd a36/    ,36/i_s,36/(rg_entry-l_org)/5,36/(rep_1-l_org)/5,36/a_rep_group
		vfd a36/    ,36/i_n,36/0,36/(l_12-l_org)/5,36/a_recvy
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_12:	rd:	vfd a36/    ,36/i_n,36/0,36/(r3-l_org)/5,36/a_recov_loc
l_13:		vfd a36/s   ,36/i_r,36/r_rd,36/(l_14-l_org)/5,36/a_rd_init
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_14:		vfd a36/s   ,36/i_c,36/c_type8,36/(l_15-l_org)/5,36/a_rd_name
l_15:		vfd a36/    ,36/i_k,36/k_rw_rd,36/(l_16-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/124,36/(rd_5-l_org)/5,36/0
l_16:	rd_1:	vfd a36/    ,36/i_K,36/k_rw_rd,36/(rd_5-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/0,36/(succ-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/0,36/(rd_2-l_org)/5,36/a_rd_cl_num
		vfd a36/s   ,36/i_n,36/0,36/(rd_3-l_org)/5,36/a_rd_cl_num
		vfd a36/s   ,36/i_n,36/0,36/(rd_4-l_org)/5,36/a_rd_cl_num
	rd_2:	vfd a36/    ,36/i_s,36/(code-l_org)/5,36/(rd_1-l_org)/5,36/a_rd_clause
		vfd a36/    ,36/i_n,36/120,36/(rd_5-l_org)/5,36/0
	rd_3:	vfd a36/    ,36/i_s,36/(control-l_org)/5,36/(rd_1-l_org)/5,36/a_rd_clause
		vfd a36/    ,36/i_n,36/121,36/(rd_5-l_org)/5,36/0
	rd_4:	vfd a36/    ,36/i_s,36/(page-l_org)/5,36/(rd_1-l_org)/5,36/a_rd_clause
		vfd a36/    ,36/i_n,36/122,36/(rd_5-l_org)/5,36/0
	rd_5:	vfd a36/    ,36/i_n,36/0,36/(l_17-l_org)/5,36/a_recvy
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_17:	code:	vfd a36/s   ,36/i_c,36/c_code_lit,36/(succ-l_org)/5,36/a_code
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	control:	vfd a36/    ,36/i_n,36/0,36/(l_18-l_org)/5,36/a_con_init
l_18:		vfd a36/s   ,36/i_r,36/r_is,36/(l_19-l_org)/5,36/0
l_19:		vfd a36/s   ,36/i_r,36/r_final,36/(c_1-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_type8,36/(l_20-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_20:		vfd a36/    ,36/i_s,36/(q_names-l_org)/5,36/(succ-l_org)/5,36/a_con_1
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	c_1:	vfd a36/    ,36/i_c,36/c_type8,36/(l_21-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/a_con_3
l_21:		vfd a36/    ,36/i_s,36/(q_names-l_org)/5,36/(succ-l_org)/5,36/a_con_2
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	q_names:	vfd a36/    ,36/i_n,36/0,36/(l_22-l_org)/5,36/a_con_name
l_22:		vfd a36/    ,36/i_s,36/(q_name-l_org)/5,36/(l_23-l_org)/5,36/a_con_name_1
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_23:	q_names_1:	vfd a36/    ,36/i_c,36/c_type8,36/(l_24-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/a_con_name_2
l_24:		vfd a36/    ,36/i_s,36/(q_name-l_org)/5,36/(q_names_1-l_org)/5,36/a_con_name_1
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	q_name:	vfd a36/    ,36/i_n,36/0,36/(l_25-l_org)/5,36/a_q_name_1
l_25:		vfd a36/s   ,36/i_c,36/c_type8,36/(l_26-l_org)/5,36/a_q_name_3
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_26:	q_1:	vfd a36/s   ,36/i_r,36/r_of,36/(l_27-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_in,36/(l_27-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/a_q_name_2
l_27:		vfd a36/s   ,36/i_c,36/c_type8,36/(q_1-l_org)/5,36/a_q_name_3
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	page:	vfd a36/    ,36/i_n,36/0,36/(r4-l_org)/5,36/a_recov_loc
l_28:		vfd a36/    ,36/i_n,36/0,36/(l_29-l_org)/5,36/a_pg_init
l_29:		vfd a36/    ,36/i_s,36/(pg-l_org)/5,36/(l_30-l_org)/5,36/a_pg_set
		vfd a36/    ,36/i_n,36/122,36/(pg_5-l_org)/5,36/0
l_30:	pg_1:	vfd a36/    ,36/i_K,36/k_rw_pg,36/(succ-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/0,36/(pg_3-l_org)/5,36/a_pg_cl_num
		vfd a36/s   ,36/i_n,36/0,36/(pg_4-l_org)/5,36/a_pg_cl_num
		vfd a36/s   ,36/i_n,36/0,36/(pg_4-l_org)/5,36/a_pg_cl_num
		vfd a36/s   ,36/i_n,36/0,36/(pg_3-l_org)/5,36/a_pg_cl_num
	pg_3:	vfd a36/s   ,36/i_c,36/c_integer,36/(pg_1-l_org)/5,36/a_pg_clause
		vfd a36/    ,36/i_n,36/0,36/(pg_5-l_org)/5,36/0
	pg_4:	vfd a36/s   ,36/i_r,36/r_detail,36/(l_31-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(pg_5-l_org)/5,36/0
l_31:		vfd a36/s   ,36/i_c,36/c_integer,36/(pg_1-l_org)/5,36/a_pg_clause
	pg_5:	vfd a36/    ,36/i_n,36/0,36/(l_32-l_org)/5,36/a_recvy
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_32:	pg:	vfd a36/s   ,36/i_r,36/r_limit,36/(l_33-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_limits,36/(l_33-l_org)/5,36/0
l_33:		vfd a36/s   ,36/i_r,36/r_is,36/(l_34-l_org)/5,36/0
l_34:		vfd a36/s   ,36/i_c,36/c_integer,36/(l_35-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_35:		vfd a36/s   ,36/i_r,36/r_line,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	rg_entry:	vfd a36/    ,36/i_n,36/0,36/(r5-l_org)/5,36/a_recov_loc
l_36:		vfd a36/    ,36/i_n,36/0,36/(l_37-l_org)/5,36/a_rg_init
l_37:		vfd a36/s   ,36/i_c,36/c_lev_num,36/(l_38-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/123,36/(rg_16-l_org)/5,36/0
l_38:		vfd a36/s   ,36/i_c,36/c_type8,36/(l_39-l_org)/5,36/a_rg_entry_1
l_39:		vfd a36/    ,36/i_k,36/k_rw_rg,36/(l_40-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/125,36/(rg_16-l_org)/5,36/0
l_40:	rg_1:	vfd a36/    ,36/i_K,36/k_rw_rg,36/(fail-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/0,36/(succ-l_org)/5,36/a_rg_entry_2
		vfd a36/s   ,36/i_n,36/0,36/(rg_2-l_org)/5,36/a_rg_clnum
		vfd a36/s   ,36/i_n,36/0,36/(rg_3-l_org)/5,36/a_rg_clnum
		vfd a36/s   ,36/i_n,36/0,36/(rg_4-l_org)/5,36/a_rg_clnum
		vfd a36/    ,36/i_n,36/0,36/(rg_5-l_org)/5,36/a_rg_clnum
		vfd a36/s   ,36/i_n,36/0,36/(rg_6-l_org)/5,36/a_rg_clnum
		vfd a36/s   ,36/i_n,36/0,36/(rg_7-l_org)/5,36/a_rg_clnum
		vfd a36/s   ,36/i_n,36/0,36/(rg_8-l_org)/5,36/a_rg_clnum
		vfd a36/s   ,36/i_n,36/0,36/(rg_9-l_org)/5,36/a_rg_clnum
		vfd a36/s   ,36/i_n,36/0,36/(rg_10-l_org)/5,36/a_rg_clnum
		vfd a36/s   ,36/i_n,36/0,36/(rg_11-l_org)/5,36/a_rg_clnum
		vfd a36/s   ,36/i_n,36/0,36/(rg_12-l_org)/5,36/a_rg_clnum
		vfd a36/s   ,36/i_n,36/0,36/(rg_13-l_org)/5,36/a_rg_clnum
		vfd a36/s   ,36/i_n,36/0,36/(rg_14-l_org)/5,36/a_rg_clnum
		vfd a36/    ,36/i_n,36/0,36/(rg_15-l_org)/5,36/a_rg_clnum
	rg_2:	vfd a36/    ,36/i_s,36/(line-l_org)/5,36/(rg_1-l_org)/5,36/a_rg_clause
		vfd a36/    ,36/i_n,36/107,36/(rg_16-l_org)/5,36/0
	rg_3:	vfd a36/    ,36/i_s,36/(next-l_org)/5,36/(rg_1-l_org)/5,36/a_rg_clause
		vfd a36/    ,36/i_n,36/108,36/(rg_16-l_org)/5,36/0
	rg_4:	vfd a36/    ,36/i_s,36/(type-l_org)/5,36/(rg_1-l_org)/5,36/a_rg_clause
		vfd a36/    ,36/i_n,36/109,36/(rg_16-l_org)/5,36/0
	rg_5:	vfd a36/    ,36/i_s,36/(usage-l_org)/5,36/(rg_1-l_org)/5,36/a_rg_clause
		vfd a36/    ,36/i_n,36/110,36/(rg_16-l_org)/5,36/0
	rg_6:	vfd a36/    ,36/i_s,36/(present-l_org)/5,36/(rg_1-l_org)/5,36/a_rg_clause
		vfd a36/    ,36/i_n,36/0,36/(rg_16-l_org)/5,36/0
	rg_7:	vfd a36/    ,36/i_s,36/(blank-l_org)/5,36/(rg_1-l_org)/5,36/a_rg_clause
		vfd a36/    ,36/i_n,36/111,36/(rg_16-l_org)/5,36/0
	rg_8:	vfd a36/s   ,36/i_r,36/r_indicate,36/(rg_1-l_org)/5,36/a_rg_clause
		vfd a36/    ,36/i_n,36/112,36/(rg_16-l_org)/5,36/0
	rg_9:	vfd a36/s   ,36/i_r,36/r_right,36/(rg_1-l_org)/5,36/a_rg_clause
		vfd a36/    ,36/i_n,36/113,36/(rg_16-l_org)/5,36/0
	rg_10:	vfd a36/    ,36/i_s,36/(column-l_org)/5,36/(rg_1-l_org)/5,36/a_rg_clause
		vfd a36/    ,36/i_n,36/114,36/(rg_16-l_org)/5,36/0
	rg_11:	vfd a36/s   ,36/i_r,36/r_is,36/(l_41-l_org)/5,36/0
l_41:		vfd a36/s   ,36/i_c,36/c_pic,36/(rg_1-l_org)/5,36/a_rg_clause
		vfd a36/    ,36/i_n,36/115,36/(rg_16-l_org)/5,36/0
	rg_12:	vfd a36/s   ,36/i_r,36/r_is,36/(l_42-l_org)/5,36/0
l_42:		vfd a36/    ,36/i_s,36/(ident-l_org)/5,36/(rg_1-l_org)/5,36/a_rg_clause
		vfd a36/    ,36/i_n,36/116,36/(rg_16-l_org)/5,36/0
	rg_13:	vfd a36/s   ,36/i_r,36/r_is,36/(l_43-l_org)/5,36/0
l_43:		vfd a36/    ,36/i_s,36/(literal-l_org)/5,36/(rg_1-l_org)/5,36/a_rg_clause
		vfd a36/    ,36/i_n,36/117,36/(rg_16-l_org)/5,36/0
	rg_14:	vfd a36/    ,36/i_s,36/(sum-l_org)/5,36/(rg_1-l_org)/5,36/a_rg_clause
		vfd a36/    ,36/i_n,36/118,36/(rg_16-l_org)/5,36/0
	rg_15:	vfd a36/    ,36/i_s,36/(sign-l_org)/5,36/(rg_1-l_org)/5,36/a_rg_clause
		vfd a36/    ,36/i_n,36/119,36/(rg_16-l_org)/5,36/0
	rg_16:	vfd a36/    ,36/i_n,36/0,36/(l_44-l_org)/5,36/a_recvy
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_44:	line:	vfd a36/s   ,36/i_r,36/r_number,36/(l_45-l_org)/5,36/0
l_45:		vfd a36/s   ,36/i_r,36/r_is,36/(l_46-l_org)/5,36/0
l_46:		vfd a36/s   ,36/i_c,36/c_integer,36/(l_47-l_org)/5,36/a_rg_line_1
		vfd a36/s   ,36/i_r,36/r_plus,36/(line_2-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_47:		vfd a36/s   ,36/i_r,36/r_on,36/(l_48-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_next,36/(line_1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/a_rg_line_2
l_48:		vfd a36/s   ,36/i_r,36/r_next,36/(l_49-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_49:	line_1:	vfd a36/s   ,36/i_r,36/r_page,36/(succ-l_org)/5,36/a_rg_line_4
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	line_2:	vfd a36/s   ,36/i_c,36/c_integer,36/(succ-l_org)/5,36/a_rg_line_3
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	next:	vfd a36/s   ,36/i_r,36/r_group,36/(l_50-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_50:		vfd a36/s   ,36/i_r,36/r_is,36/(l_51-l_org)/5,36/0
l_51:		vfd a36/s   ,36/i_r,36/r_plus,36/(l_52-l_org)/5,36/a_rg_group_1
		vfd a36/s   ,36/i_r,36/r_next,36/(n_1-l_org)/5,36/a_rg_group_2
		vfd a36/    ,36/i_n,36/0,36/(l_52-l_org)/5,36/a_rg_group_3
l_52:		vfd a36/s   ,36/i_c,36/c_integer,36/(succ-l_org)/5,36/a_rg_group_4
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	n_1:	vfd a36/s   ,36/i_r,36/r_page,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	type:	vfd a36/s   ,36/i_r,36/r_is,36/(l_53-l_org)/5,36/0
l_53:		vfd a36/    ,36/i_K,36/k_rw_type,36/(fail-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/0,36/(succ-l_org)/5,36/a_rg_type_1
		vfd a36/s   ,36/i_n,36/0,36/(succ-l_org)/5,36/a_rg_type_1
		vfd a36/s   ,36/i_n,36/0,36/(t_3-l_org)/5,36/a_rg_type_1
		vfd a36/s   ,36/i_n,36/0,36/(succ-l_org)/5,36/a_rg_type_1
		vfd a36/s   ,36/i_n,36/0,36/(t_3-l_org)/5,36/a_rg_type_1
		vfd a36/s   ,36/i_n,36/0,36/(succ-l_org)/5,36/a_rg_type_1
		vfd a36/s   ,36/i_n,36/0,36/(succ-l_org)/5,36/a_rg_type_1
		vfd a36/s   ,36/i_n,36/0,36/(t_1-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/0,36/(t_4-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/0,36/(t_2-l_org)/5,36/0
		vfd a36/s   ,36/i_n,36/0,36/(succ-l_org)/5,36/a_rg_type_a
	t_1:	vfd a36/s   ,36/i_r,36/r_heading,36/(succ-l_org)/5,36/a_rg_type_2
		vfd a36/s   ,36/i_r,36/r_footing,36/(succ-l_org)/5,36/a_rg_type_3
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	t_2:	vfd a36/s   ,36/i_r,36/r_heading,36/(l_54-l_org)/5,36/a_rg_type_4
		vfd a36/s   ,36/i_r,36/r_footing,36/(l_54-l_org)/5,36/a_rg_type_5
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_54:	t_3:	vfd a36/s   ,36/i_r,36/r_final,36/(succ-l_org)/5,36/a_rg_type_6
		vfd a36/    ,36/i_s,36/(q_name-l_org)/5,36/(succ-l_org)/5,36/a_rg_type_9
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	t_4:	vfd a36/s   ,36/i_r,36/r_heading,36/(succ-l_org)/5,36/a_rg_type_7
		vfd a36/s   ,36/i_r,36/r_footing,36/(succ-l_org)/5,36/a_rg_type_8
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	usage:	vfd a36/s   ,36/i_r,36/r_usage,36/(l_55-l_org)/5,36/0
l_55:		vfd a36/s   ,36/i_r,36/r_is,36/(l_56-l_org)/5,36/0
l_56:		vfd a36/s   ,36/i_r,36/r_display,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	present:	vfd a36/s   ,36/i_r,36/r_when,36/(l_57-l_org)/5,36/0
l_57:		vfd a36/    ,36/i_n,36/0,36/(l_58-l_org)/5,36/a_rg_pres_1
l_58:		vfd a36/    ,36/i_s,36/(condition-l_org)/5,36/(succ-l_org)/5,36/a_rg_pres_2
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	blank:	vfd a36/s   ,36/i_r,36/r_when,36/(l_59-l_org)/5,36/0
l_59:		vfd a36/s   ,36/i_r,36/r_zero,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	column:	vfd a36/s   ,36/i_r,36/r_number,36/(l_60-l_org)/5,36/0
l_60:		vfd a36/s   ,36/i_r,36/r_is,36/(l_61-l_org)/5,36/0
l_61:		vfd a36/s   ,36/i_r,36/r_plus,36/(l_62-l_org)/5,36/a_rg_col_1
		vfd a36/    ,36/i_n,36/0,36/(l_62-l_org)/5,36/a_rg_col_2
l_62:		vfd a36/s   ,36/i_c,36/c_integer,36/(succ-l_org)/5,36/a_rg_col_3
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	sum:	vfd a36/    ,36/i_n,36/0,36/(l_63-l_org)/5,36/a_sum_1
l_63:	sum_1:	vfd a36/    ,36/i_s,36/(sum_ph-l_org)/5,36/(l_64-l_org)/5,36/a_sum_2
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_64:		vfd a36/s   ,36/i_r,36/r_reset,36/(l_65-l_org)/5,36/a_sum_5
		vfd a36/s   ,36/i_r,36/r_sum,36/(sum_1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
l_65:		vfd a36/s   ,36/i_r,36/r_on,36/(l_66-l_org)/5,36/0
l_66:		vfd a36/s   ,36/i_r,36/r_final,36/(succ-l_org)/5,36/a_sum_4
		vfd a36/    ,36/i_s,36/(q_name-l_org)/5,36/(succ-l_org)/5,36/a_sum_3
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	sum_ph:	vfd a36/    ,36/i_n,36/0,36/(l_67-l_org)/5,36/a_sum_ph_1
l_67:	sum_ph3:	vfd a36/    ,36/i_s,36/(ident-l_org)/5,36/(l_68-l_org)/5,36/a_sum_ph_3
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_68:	sum_ph1:	vfd a36/s   ,36/i_r,36/r_upon,36/(l_69-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_type8,36/(sum_ph3-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/a_sum_ph_2
l_69:	sum_ph2:	vfd a36/    ,36/i_s,36/(q_names-l_org)/5,36/(l_70-l_org)/5,36/a_sum_ph_4
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_70:		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/a_sum_ph_2
	sign:	vfd a36/s   ,36/i_r,36/r_sign,36/(sign_2-l_org)/5,36/0
	sign_1:	vfd a36/s   ,36/i_r,36/r_leading,36/(sign_3-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_trailing,36/(l_71-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_71:		vfd a36/s   ,36/i_r,36/r_separate,36/(l_72-l_org)/5,36/a_sign_1
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/a_sign_2
l_72:	sign_4:	vfd a36/s   ,36/i_r,36/r_character,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	sign_2:	vfd a36/s   ,36/i_r,36/r_is,36/(sign_1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(sign_1-l_org)/5,36/0
	sign_3:	vfd a36/s   ,36/i_r,36/r_separate,36/(sign_4-l_org)/5,36/a_sign_3
		vfd a36/    ,36/i_n,36/0,36/(sign_4-l_org)/5,36/a_sign_4
	literal:	vfd a36/s   ,36/i_c,36/c_literal,36/(succ-l_org)/5,36/a_lit_1
		vfd a36/s   ,36/i_c,36/c_figconall,36/(succ-l_org)/5,36/a_lit_1
		vfd a36/s   ,36/i_r,36/r_all,36/(l_73-l_org)/5,36/a_lit_1
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_73:		vfd a36/s   ,36/i_c,36/c_figconall,36/(succ-l_org)/5,36/a_lit_2
		vfd a36/s   ,36/i_c,36/c_nonumlit,36/(succ-l_org)/5,36/a_lit_2
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	ident:	vfd a36/    ,36/i_n,36/0,36/(l_74-l_org)/5,36/a_id_1
l_74:		vfd a36/    ,36/i_s,36/(q_name-l_org)/5,36/(l_75-l_org)/5,36/a_id_3
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_75:		vfd a36/s   ,36/i_r,36/r_lt,36/(l_76-l_org)/5,36/a_id_4
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
l_76:		vfd a36/    ,36/i_s,36/(sub-l_org)/5,36/(l_77-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_77:		vfd a36/s   ,36/i_r,36/r_rt,36/(succ-l_org)/5,36/a_id_2
		vfd a36/    ,36/i_s,36/(sub-l_org)/5,36/(l_77-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	sub:	vfd a36/s   ,36/i_c,36/c_type2,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(q_name-l_org)/5,36/(l_78-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_78:		vfd a36/s   ,36/i_r,36/r_pls,36/(l_79-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_sub,36/(l_79-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
l_79:		vfd a36/s   ,36/i_c,36/c_type2,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	elnuitem:	vfd a36/s   ,36/i_c,36/c_type2,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_type8,36/(el_1-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_all,36/(l_80-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_zero,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_80:		vfd a36/s   ,36/i_r,36/r_zero,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	el_1:	vfd a36/    ,36/i_s,36/(ident-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	condition:	vfd a36/    ,36/i_n,36/0,36/(l_81-l_org)/5,36/a_c0s1
l_81:	lpar:	vfd a36/s   ,36/i_r,36/r_lt,36/(lpar-l_org)/5,36/a_cincrs1
	lpar2:	vfd a36/    ,36/i_c,36/c_type1,36/(res-l_org)/5,36/0
	res1:	vfd a36/    ,36/i_s,36/(condop-l_org)/5,36/(infix_rel-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	res:	vfd a36/    ,36/i_s,36/(relop-l_org)/5,36/(imp_subj-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_not,36/(not_cond-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_is,36/(is_cond-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(pos_rel-l_org)/5,36/(imp_subj-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_message,36/(l_82-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(res1-l_org)/5,36/0
l_82:		vfd a36/s   ,36/i_r,36/r_for,36/(l_83-l_org)/5,36/0
l_83:		vfd a36/s   ,36/i_c,36/c_type8,36/(bop-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	not_cond:	vfd a36/    ,36/i_r,36/r_lt,36/(lpar-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(relop-l_org)/5,36/(imp_subj-l_org)/5,36/0
l_84:		vfd a36/s   ,36/i_r,36/r_not,36/(rel-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(lpar2-l_org)/5,36/0
	is_cond:	vfd a36/s   ,36/i_r,36/r_not,36/(rel-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(relop-l_org)/5,36/(imp_subj-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_unequal,36/(l_85-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_85:		vfd a36/s   ,36/i_r,36/r_to,36/(imp_subj-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(imp_subj-l_org)/5,36/0
	rel:	vfd a36/    ,36/i_s,36/(relop-l_org)/5,36/(l_86-l_org)/5,36/0
l_86:	imp_subj:	vfd a36/    ,36/i_c,36/c_is_sub_opt,36/(obj_op-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	infix_rel:	vfd a36/    ,36/i_s,36/(relop-l_org)/5,36/(obj_op-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_not,36/(inf_rel-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_is,36/(inf_is-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(pos_rel-l_org)/5,36/(obj_op-l_org)/5,36/0
	inf_test:	vfd a36/s   ,36/i_k,36/k_ae_test,36/(bop-l_org)/5,36/0
		vfd a36/    ,36/i_c,36/c_is_sub_opt,36/(bop-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	inf_is:	vfd a36/s   ,36/i_r,36/r_not,36/(inf_rel-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(relop-l_org)/5,36/(obj_op-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_unequal,36/(l_87-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(inf_test-l_org)/5,36/0
l_87:		vfd a36/s   ,36/i_r,36/r_to,36/(obj_op-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(obj_op-l_org)/5,36/0
	inf_rel:	vfd a36/    ,36/i_s,36/(relop-l_org)/5,36/(l_88-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(inf_test-l_org)/5,36/0
l_88:	obj_op:	vfd a36/    ,36/i_s,36/(condop-l_org)/5,36/(l_89-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_89:	bop:	vfd a36/    ,36/i_n,36/0,36/(l_90-l_org)/5,36/a_s0
l_90:		vfd a36/s   ,36/i_r,36/r_and,36/(lpar-l_org)/5,36/0
	bop3:	vfd a36/s   ,36/i_r,36/r_or,36/(lpar-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_rt,36/(more_rpar-l_org)/5,36/a_cdecrs1
		vfd a36/    ,36/i_c,36/c_lptopstk,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	more_rpar:	vfd a36/s   ,36/i_r,36/r_rt,36/(l_91-l_org)/5,36/a_cincr
		vfd a36/s   ,36/i_r,36/r_and,36/(lpar-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(bop3-l_org)/5,36/0
l_91:		vfd a36/    ,36/i_c,36/c_lptopstk,36/(more_rpar-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	pos_rel:	vfd a36/s   ,36/i_r,36/r_equals,36/(succ-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_exceeds,36/(succ-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_unequal,36/(l_92-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_92:		vfd a36/s   ,36/i_r,36/r_to,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	relop:	vfd a36/s   ,36/i_c,36/c_relop,36/(l_93-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_93:		vfd a36/s   ,36/i_r,36/r_to,36/(succ-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_than,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/0
	condop:	vfd a36/s   ,36/i_r,36/r_all,36/(l_94-l_org)/5,36/0
		vfd a36/s   ,36/i_c,36/c_figconall,36/(succ-l_org)/5,36/0
		vfd a36/s   ,36/i_c,36/c_type3,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_s,36/(arithexp-l_org)/5,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_94:		vfd a36/s   ,36/i_c,36/c_figconall,36/(succ-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	arithexp:	vfd a36/    ,36/i_n,36/0,36/(l_95-l_org)/5,36/a_ae_init
l_95:		vfd a36/s   ,36/i_r,36/r_pls,36/(ae_3-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_sub,36/(ae_3-l_org)/5,36/0
l_96:		vfd a36/s   ,36/i_s,36/(elnuitem-l_org)/5,36/(ae_1-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_lt,36/(l_97-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_97:	ae_2:	vfd a36/s   ,36/i_r,36/r_pls,36/(l_98-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_sub,36/(l_98-l_org)/5,36/0
l_98:	ae_3:	vfd a36/s   ,36/i_s,36/(elnuitem-l_org)/5,36/(l_99-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_lt,36/(ae_2-l_org)/5,36/a_cincrs1
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
l_99:	ae_1:	vfd a36/s   ,36/i_c,36/c_arop,36/(ae_2-l_org)/5,36/0
		vfd a36/s   ,36/i_r,36/r_rt,36/(l_100-l_org)/5,36/a_cincr
		vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/a_ae_final
l_100:		vfd a36/    ,36/i_c,36/c_lptopstk,36/(ae_1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	succ:	vfd a36/    ,36/i_n,36/0,36/(succ-l_org)/5,36/a_s_exit
	fail:	vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/a_f_exit
	r1:	vfd a36/    ,36/i_c,36/c_eof,36/(rs_1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	r2:	vfd a36/    ,36/i_r,36/r_rd,36/(reps_1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	r6:	vfd a36/s   ,36/i_r,36/r_per,36/(rep_1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	r3:	vfd a36/    ,36/i_K,36/k_rw_rd,36/(rd_1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	r4:	vfd a36/    ,36/i_K,36/k_rw_pg,36/(pg_1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/0
	r5:	vfd a36/    ,36/i_K,36/k_rw_rg,36/(rg_1-l_org)/5,36/0
		vfd a36/    ,36/i_n,36/0,36/(fail-l_org)/5,36/a_rg_entry_2
	equ c_arop,15
	equ c_code_lit,5
	equ c_eof,1
	equ c_figconall,14
	equ c_illeg_ln,17
	equ c_integer,7
	equ c_is_sub_opt,10
	equ c_lev_num,2
	equ c_literal,8
	equ c_lptopstk,11
	equ c_nonumlit,16
	equ c_pic,6
	equ c_relop,12
	equ c_type1,9
	equ c_type2,3
	equ c_type3,13
	equ c_type8,4
	equ a_ae_final,65
	equ a_ae_init,64
	equ a_c0s1,5
	equ a_cdecrs1,7
	equ a_cincr,9
	equ a_cincrs1,8
	equ a_code,57
	equ a_con_1,74
	equ a_con_2,58
	equ a_con_3,83
	equ a_con_init,59
	equ a_con_name,60
	equ a_con_name_1,72
	equ a_con_name_2,73
	equ a_f_exit,2
	equ a_id_1,38
	equ a_id_2,39
	equ a_id_3,67
	equ a_id_4,44
	equ a_lit_1,81
	equ a_lit_2,82
	equ a_pg_cl_num,62
	equ a_pg_clause,63
	equ a_pg_init,61
	equ a_pg_set,80
	equ a_q_name_1,36
	equ a_q_name_2,37
	equ a_q_name_3,68
	equ a_rd_cl_num,55
	equ a_rd_clause,56
	equ a_rd_init,53
	equ a_rd_name,54
	equ a_recov_loc,3
	equ a_recvy,4
	equ a_rep_add,11
	equ a_rep_group,66
	equ a_rep_group_1,69
	equ a_rep_init,10
	equ a_rg_clause,14
	equ a_rg_clnum,13
	equ a_rg_col_1,33
	equ a_rg_col_2,34
	equ a_rg_col_3,35
	equ a_rg_entry_1,70
	equ a_rg_entry_2,71
	equ a_rg_group_1,19
	equ a_rg_group_2,20
	equ a_rg_group_3,21
	equ a_rg_group_4,22
	equ a_rg_init,12
	equ a_rg_line_1,15
	equ a_rg_line_2,16
	equ a_rg_line_3,17
	equ a_rg_line_4,18
	equ a_rg_pres_1,31
	equ a_rg_pres_2,32
	equ a_rg_type_1,23
	equ a_rg_type_2,24
	equ a_rg_type_3,25
	equ a_rg_type_4,26
	equ a_rg_type_5,27
	equ a_rg_type_6,28
	equ a_rg_type_7,29
	equ a_rg_type_8,30
	equ a_rg_type_9,75
	equ a_rg_type_a,79
	equ a_rs_exit,77
	equ a_s0,6
	equ a_s_exit,1
	equ a_sign_1,49
	equ a_sign_2,50
	equ a_sign_3,51
	equ a_sign_4,52
	equ a_sum_1,40
	equ a_sum_2,41
	equ a_sum_3,42
	equ a_sum_4,43
	equ a_sum_5,76
	equ a_sum_ph_1,45
	equ a_sum_ph_2,46
	equ a_sum_ph_3,47
	equ a_sum_ph_4,48
	equ r_lt,187
	equ r_rt,188
	equ r_pls,182
	equ r_sub,183
	equ r_per,189
	equ r_all,73
	equ r_and,77
	equ r_character,83
	equ r_detail,539
	equ r_display,42
	equ r_equals,102
	equ r_exceeds,113
	equ r_final,546
	equ r_footing,547
	equ r_for,110
	equ r_group,549
	equ r_heading,548
	equ r_in,101
	equ r_indicate,553
	equ r_is,118
	equ r_leading,122
	equ r_limit,561
	equ r_limits,562
	equ r_line,124
	equ r_message,126
	equ r_next,128
	equ r_not,130
	equ r_number,571
	equ r_of,133
	equ r_on,134
	equ r_or,135
	equ r_page,139
	equ r_plus,581
	equ r_rd,584
	equ r_report,240
	equ r_reset,590
	equ r_right,241
	equ r_section,158
	equ r_separate,244
	equ r_sign,245
	equ r_sum,603
	equ r_than,165
	equ r_to,170
	equ r_trailing,255
	equ r_unequal,171
	equ r_upon,175
	equ r_usage,257
	equ r_when,178
	equ r_zero,180
	equ k_ae_test,5
	equ k_rw_pg,2
	equ k_rw_rd,1
	equ k_rw_rg,3
	equ k_rw_type,4
	end
~~~




		    cobol_syntax_trace_.pl1         05/24/89  1046.0rew 05/24/89  0835.3       83268



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_syntax_trace_.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 03/31/83 by FCH, [5.3-1], shorten line for vip */
/* Modified on 11/20/80 by FCH, [4.4-2], new  entry trace_loc */
/* Modified on ??/??/?? by FCH, [4.4-1], report writer phase */
/* Modified since Version 4.4 */


/* format: style3 */
cobol_syntax_trace_:
     proc (arg_ptr, trace_mode);

/*	perform a trace in the syntax interpreter	*/

declare	arg_ptr		ptr,
	trace_mode	fixed bin (31);

declare	ioa_		entry options (variable);

dcl	tssi_$clean_up_segment
			entry (ptr);
dcl	tssi_$get_segment	entry (char (*), char (*), ptr, ptr, fixed bin (35));
dcl	get_pdir_		entry returns (char (168));
dcl	expand_pathname_	entry (char (*), char (*), char (*), fixed bin (35));
dcl	hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
dcl	com_err_		entry options (variable);


declare	(mode, line_offset) static internal;


declare	trace_on		fixed bin static internal;

declare	1 trace		static internal,
	  2 curr_first	fixed bin (31) init (0),
	  2 curr_last	fixed bin (31) init (0),
	  2 phase,
	    3 first	(5) fixed bin (31) init (0, 0, 0, 0, 0),
	    3 last	(5) fixed bin (31) init (0, 0, 0, 0, 0);

declare	arc_name		char (32);
declare	NAME		char (32);
declare	line		char (118);
declare	dec		char (16);
declare	digs		char (10) init ("0123456789");

declare	(i, curr_offset, curr_line, line_count)
			fixed bin (31);
declare	(siz, loc, tloc, POS)
			fixed bin;
declare	(first, last, val, pos, CL)
			fixed bin (31);
declare	off		ptr;
declare	phase_num		fixed bin (31);

dcl	(null, addr, substr, unspec, fixed, mod, index, divide)
			builtin;

dcl	code		fixed bin (35);
dcl	aclinfo_ptr	ptr;
dcl	bc		fixed bin (24);
dcl	cleanup		condition;
dcl	dn		char (168),
	en		char (32);

declare	1 interp		based (arg_ptr),
	  2 current_line	fixed bin (31),
	  2 phase		fixed bin (31),
	  2 addr_record	ptr,
	  2 filler	ptr,
	  2 dir_ptr	ptr,
	  2 source_ptr	ptr;

declare	1 header		based (addr_record),
	  2 size		fixed bin (31),
	  2 line		fixed bin (31),
	  2 column	fixed bin (31),
	  2 type		fixed bin (31);

declare	1 rl_dir		(10000) based (interp.dir_ptr),
	  2 offset	ptr,
	  2 size		fixed bin (31),
	  2 line		fixed bin (31);

declare	char_string	char (100000) based (source_ptr);

declare	char_array	(100000) char (1) based (source_ptr);
declare	bit_array		(100000) bit (9) based (source_ptr);

declare	arg		char (32) based (arg_ptr);

trace_loc:
     entry returns (ptr);

/*[4.4-2]*/
	return (addr (trace));

reset_trace:
     entry;



	trace.curr_first = 0;
	trace.curr_last = 0;

	do i = 1 by 1 to 5;

	     trace.phase.first (i), trace.phase.last (i) = 0;

	end;

	return;

trace:
     entry (arg_ptr, trace_mode);


	go to T (trace_on);

T (0):
	if header.line = 0
	then return;
	else if header.line < trace.curr_first
	then return;
	else trace_on = 1;

	go to T1;

T (1):
	if trace.curr_last ^= 0
	then do;
		if header.line > trace.curr_last
		then do;
			trace_on = 2;
			return;
		     end;
	     end;

	go to T1;

T (2):
	return;

T1:
	if mode = 0 & addr_record ^= null ()
	then do;
		CL = current_line + line_offset;
		line = " ";
		siz = rl_dir.size (CL);
		off = rl_dir.offset (CL);

		dec = char (rl_dir.line (CL) * 10);
		substr (line, 1, 5) = substr (dec, 12, 5);

		substr (line, 41, siz) = substr (off -> char_string, 1, siz);

		dec = char (header.line * 10);
		substr (line, 13, 6) = substr (dec, 11, 6);
		dec = char (header.column * 10);
		substr (line, 20, 6) = substr (dec, 11, 6);
		dec = char (header.type * 10);
		substr (line, 27, 6) = substr (dec, 11, 6);

		if (trace_mode = 1 | trace_mode = 4)
		then substr (line, 33, 1) = "~";

		if trace_mode = 4 | trace_mode = 5
		then substr (line, 7, 6) = ">>>>>>";

		if trace_mode = 3
		then substr (line, 7, 6) = "<<<<<<";

/* [5.3-1] */
		call ioa_ (substr (line, 1, 38));	/* [5.3-1] */
		call ioa_ ("        " || substr (line, 39));

	     end;

	return;

make_dir:
     proc;

declare	(loc, nb_loc)	fixed bin;
declare	ch		char (1);

	call tssi_$get_segment (get_pdir_ (), "RED_DIR_QJZW", interp.dir_ptr, aclinfo_ptr, code);

	if code ^= 0
	then go to error;

	i, line_count, curr_offset, curr_line = 1;

	do while (substr (char_string, i, 3) ^= "~~~");

	     loc = index (substr (char_string, i, 256), "
");


	     if loc ^= 1 & char_array (i) ^= "~"
	     then do;
		     nb_loc = 1;
		     ch = substr (char_string, 1, 1);

		     do while (ch = " " | ch = "	");

			nb_loc = nb_loc + 1;
			ch = substr (char_string, nb_loc, 1);

		     end;

		     if nb_loc < loc
		     then do;

			     rl_dir.offset (curr_line) = addr (char_array (curr_offset));

			     tloc = index (substr (char_string, i, loc), "~");

			     if tloc = 0
			     then rl_dir.size (curr_line) = loc - 1;
			     else rl_dir.size (curr_line) = tloc - 1;

			     rl_dir.line (curr_line) = line_count;

			     curr_line = curr_line + 1;

			end;

		end;

	     i = i + loc;
	     curr_offset = i;
	     line_count = line_count + 1;
	end;

	if code ^= 0
	then go to error;

     end;

initialize:
     entry (arg_ptr);

/*[4.4-1]*/
	POS = index ("id**dd**pd**db**rw**", substr (arg, 6, 2) || "**");

/*[4.4-1]*/
	if POS = 0
	then return;

/*[4.4-1]*/
	POS = divide (POS - 1, 4, 31, 0) + 1;

/*[4.4-1]*/
	call limits;

/*[4.4-1]*/
	trace.phase.first (POS) = first;		/*[4.4-1]*/
	trace.phase.last (POS) = last;

	return;

dec_to_bin:
     proc;

declare	(orig, size)	fixed bin (31);

	orig = i;
	pos = index (digs, substr (arg, i, 1));

	do while (pos ^= 0);
	     i = i + 1;
	     pos = index (digs, substr (arg, i, 1));
	end;

	size = i - orig;

	if size ^= 0
	then val = fixed (substr (arg, orig, size));
	else val = 0;

     end;

arc_entry:
     proc;

/*	char(12)	014 012 012 012				*/
/*		017 012 011 011				*/
/*		b   b   b   b				*/

/*	char(32)	component name(left justified , blank padding)	*/

/*	char(36)	MM/DD/YYbb	date			*/
/*		TTTT.T		time			*/
/*		AAAA		access mode		*/
/*		MM/DD/YYbb	date			*/
/*		TTTT.T		time			*/
/*	char(8)	017 017 017 017				*/
/*		012 012 012 012				*/

/*	char(*)	data (padded with 000 to half word boundry)	*/


declare	ent_ptr		ptr;
declare	size		fixed bin (36);

declare	1 entry		based (ent_ptr),
	  2 flag1		char (12),
	  2 name		char (32),
	  2 desc		char (36),
	  2 size		char (12),
	  2 flag2		char (8),
	  2 data		(100000) char (1);

	ent_ptr = source_ptr;

	do while ("1"b);

	     if NAME = entry.name
	     then do;
		     source_ptr = addr (entry.data (1));
		     return;
		end;

	     if unspec (substr (entry.flag1, 1, 1)) ^= "000001100"b
	     then do;
		     source_ptr = null ();
		     return;
		end;

	     size = fixed (entry.size);
	     size = size / 9;
	     size = size + mod (-size, 4);

	     ent_ptr = addr (entry.data (size + 1));

	end;

     end;

limits:
     proc;

	first = 0;
	last = 0;

	i = 8;
	call dec_to_bin;

	first = val;
	if substr (arg, i, 1) ^= ","
	then return;

	i = i + 1;
	call dec_to_bin;

	last = val;

     end;

error:
	call com_err_ (code, "cobol_syntax_trace_");
	return;

cl:
     proc;

	call tssi_$clean_up_segment (aclinfo_ptr);

     end;

initialize_phase:
     entry (arg_ptr, phase_num);

	line_offset = 0;

	on cleanup call cl;

	go to ph (phase_num);

ph (1):
	NAME = "IDEDTABLE.reductions";
	arc_name = "IDEDTABLE.archive";
	go to pha;

ph (2):
	NAME = "DDTABLE.reductions";
	arc_name = "DDTABLE.archive";
	go to pha;

ph (3):
	NAME = "PDTABLE.reductions";
	arc_name = "PDTABLE.archive";
	go to pha;

ph (4):
	NAME = "DB.reductions";
	arc_name = "DB.archive";
	go to pha;

/*[4.4-1]*/
ph (5):						/*[4.4-1]*/
	NAME = "RW.reductions";
	arc_name = "RW.archive";			/*[4.4-1]*/
	go to pha;

pha:
	mode = 0;

	call expand_pathname_ (NAME, dn, en, code);

	if code ^= 0
	then go to error;

	call hcs_$initiate_count (dn, en, "", bc, 1, source_ptr, code);

	if source_ptr = null ()
	then do;
		call expand_pathname_ (arc_name, dn, en, code);

		if code ^= 0
		then go to error;

		call hcs_$initiate_count (dn, en, "", bc, 1, source_ptr, code);

		if source_ptr = null ()
		then mode = 1;
		else do;
			call arc_entry;

			if source_ptr = null ()
			then go to error;

		     end;
	     end;

	call make_dir;

	trace.curr_first = trace.first (phase_num);
	trace.curr_last = trace.last (phase_num);

	trace_on = 0;


     end cobol_syntax_trace_;




		    cobol_usrwd.pl1                 05/24/89  1046.0rew 05/24/89  0835.3      141912



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_usrwd.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 04/24/78 by FCH, [3.0-1], delete inherited usage on non-elem dn */
/* Modified since Version 3.0 */

/* format: style3 */
cobol_usrwd:
     proc (ptrtab_ptr, counter, hashptr, sectno, ntendptr, ref_type, was_found, not_found, diag_no, ntptr2);


/*  DECLARATION OF THE PARAMETERS  */

dcl	ptrtab_ptr	ptr;			/* points to data name stack pointer table (input) */
dcl	counter		fixed bin (15);		/* number of entries in data name stack pointer table (input) */
dcl	hashptr		ptr;			/* points to string base table array (input) */
dcl	sectno		fixed bin (15);		/* current section number (input) */
dcl	ntendptr		ptr;			/* points to word following last name table buffer entry (input) */
dcl	ref_type		bit (1);			/* reference type: "0"b - data, "1"b - procedure (input) */
dcl	was_found		bit (1);			/* set to "1"b if name found without error (output) */
dcl	not_found		bit (1);			/* set to "1"b if name not found and no error (output) */
dcl	diag_no		fixed bin (15);		/* error type (out) */
dcl	ntptr2		ptr;			/* points to name table buffer entry for a found name (output) */

dcl	1 auser_word	based (stackptr),
	  2 size		fixed bin (15),
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7),
	  2 searched	bit (1),
	  2 duplicate	bit (1),
	  2 info3		bit (6),
	  2 length	fixed bin (7),
	  2 word		char (30);

dcl	template		char (500) based (ntptr);
dcl	template1		(500) char (1) based (addr (template));
declare	BIT36		bit (36) based;

/*  DECLARATION OF INTERNAL VARIABLES  */

dcl	alength		fixed bin (15);
dcl	blength		fixed bin (15);
dcl	(i, k, n, s)	fixed bin (15);
dcl	prev_k		fixed bin (15);
dcl	hashno		fixed bin (15);
dcl	psectno		fixed bin (15);
dcl	this_sectno	fixed bin (15);
dcl	levstack		(50) fixed bin (15);
dcl	cn1		char (4);
dcl	aname		char (30);
dcl	bname		char (30);
dcl	ntptr		ptr;
dcl	ntptr1		ptr;
dcl	(ptr1, dn_ptr)	ptr;
dcl	not_done		bit (1);
dcl	found_one		bit (1);
dcl	still_searching	bit (1);
dcl	section_not_finished
			bit (1);


dcl	ptrtable		(1:50) ptr based (ptrtab_ptr);
dcl	arrpntr		(1:512) ptr based (hashptr);
dcl	stackptr		ptr;
dcl	stackbegptr	ptr;

dcl	fileno		fixed bin;
dcl	name_ptr		ptr;			/* for fd_token include file */

dcl	addr		builtin;
dcl	fixed		builtin;
dcl	mod		builtin;
dcl	null		builtin;
dcl	substr		builtin;
dcl	unspec		builtin;


/************************************/
start:
	fileno = 0;
restart:
	stackptr = ptrtable (counter);		/*  point at the highest qualifier in the name stack  */
	was_found = "0"b;
	not_found = "1"b;
	not_done = "1"b;
	alength = auser_word.length;
	substr (aname, 1, alength) = substr (auser_word.word, 1, alength);

	hashno = 0;				/* hash user word to get ntptr */
	do i = 1 to alength;
	     hashno = hashno + fixed (unspec (substr (aname, i, 1)), 15);
	end;
	ntptr = arrpntr (mod (hashno, 512) + 1);

	if ^ref_type
	then do;					/* IDENTIFIER REFERENCE */
		call search;
		if ntptr = null ()
		then go to notfound;
		if ntptr -> data_name.type = 18
		then go to notfound;		/* proc-names are last in hash string */

		if counter = 1
		then do;				/* UNQUALIFIED DATA-NAME */

			if fileno ^= 0
			then do;			/* file-name (> 0) or cd-name (< 0) qualification */
				do while (ntptr ^= null ());
				     if ntptr -> data_name.type = 9 & ntptr -> data_name.file_num = fileno
				     then do;
					     if was_found
					     then do;
						     diag_no = fatal_AMBIGUOUS_QUAL_REF;
						     go to duplicate_error;
						end;
					     else do;
						     was_found = "1"b;
						     ntptr2 = ntptr;
						end;
					end;
				     ntptr = ntptr -> data_name.string_ptr;
				     call search;
				end;
				if was_found
				then go to found;
				else go to notfound;
			     end;

			ntptr2 = ntptr;
			if ^ntptr2 -> data_name.searched
			then do;
				ntptr2 -> data_name.searched = "1"b;
				ntptr = ntptr2 -> data_name.string_ptr;
				call search;	/* see if there's another */
				if ntptr ^= null ()
				then ntptr2 -> data_name.duplicate = "1"b;
			     end;
			if ntptr2 -> data_name.duplicate
			then do;
				if ntptr2 -> data_name.type = 9
				then do;
					if ntptr2 -> data_name.level = 1
					then diag_no = fatal_DATANAME_MULTIPLY_DECLARED;
					else diag_no = fatal_AMBIGUOUS_UNQUAL_REF;
				     end;
				else if ntptr2 -> data_name.type = 12 | ntptr2 -> data_name.type = 16
				then diag_no = fatal_FILENAME_MULTIPLY_DECLARED;
				else if ntptr2 -> data_name.type = 13
				then diag_no = fatal_CDNAME_MULTIPLY_DECLARED;
				else diag_no = fatal_DATANAME_MULTIPLY_DECLARED;
				go to duplicate_error;
			     end;
			else go to found;
		     end;

		else do;				/* QUALIFIED DATA-NAME */
			if (ntptr -> data_name.type = 12 | ntptr -> data_name.type = 16
			     | ntptr -> data_name.type = 13) & fileno = 0
			then do;			/* file or cd-name qualification */
				ntptr1 = ntptr;
				ntptr = ntptr1 -> data_name.string_ptr;
				call search;
				if ntptr = null ()
				then do;		/* found a unique file-name */
					ntptr = ntptr1;
					if ntptr -> data_name.type = 13
					then fileno = ntptr -> cdtoken.cd_num;
					else fileno = ntptr -> fd_token.file_no;
					levstack (counter) = 0;
					counter = counter - 1;
					go to restart;
				     end;
				else do;
					if ntptr -> data_name.type = 12 | ntptr -> data_name.type = 16
					then diag_no = fatal_FILENAME_MULTIPLY_DECLARED;
					else if ntptr -> data_name.type = 13
					then diag_no = fatal_CDNAME_MULTIPLY_DECLARED;
					else diag_no = fatal_DATANAME_MULTIPLY_DECLARED;
					go to duplicate_error;
				     end;
			     end;
			levstack (counter + 1) = 0;	/* dummy level higher than all legal vlevels */
			do while (not_done);	/* use string technique to search all occurrences of highest qualifier */
			     ntptr1 = ntptr;	/* save ptr to highest qualifier */
			     k = counter - 1;
			     prev_k = counter;
			     still_searching = "1"b;
			     if ntptr -> data_name.type = 9
			     then levstack (counter) = ntptr -> data_name.level;
						/*   else if ntptr->data_name.type = 13 then levstack(counter) = ntptr->cdtoken.level;  */
			     else do;
				     if ntptr -> data_name.type = 17
				     then diag_no = fatal_MNEMONIC_NAME_QUALIFIER;
				     else if ntptr -> data_name.type = 10
				     then diag_no = fatal_INDEX_NAME_QUALIFIER;
				     else if ntptr -> data_name.type = 40
				     then diag_no = fatal_ALPHABET_NAME_QUALIFIER;
				     else diag_no = fatal_INVALID_QUALIFIER;
				     not_found = "0"b;
				     go to fail_exit;
				end;
			     do while (still_searching);
						/* linear search for rest starting at 2nd highest level */
				ntptr = addrel (ntptr, divide (ntptr -> data_name.size + 11, 8, 17, 0) * 2);
				if ntptr = ntendptr
				then still_searching = "0"b;
						/* abandon search but check if found */
				else if ntptr -> data_name.type ^= 10
				then do;		/* skip type 10's */
					do while (ntptr -> data_name.level <= levstack (k + 1));
					     k = k + 1;
					end;
					still_searching = k < counter;
						/* search until backed up to highest qualifier */
					if still_searching
					then do;
						if k ^= prev_k
						then do;
							prev_k = k;
							stackptr = ptrtable (k);
							blength = auser_word.length;
							substr (bname, 1, blength) =
							     substr (auser_word.word, 1, blength);
						     end;
						n = size_TOKEN (ntptr -> data_name.type) - 3;
						cn1 = substr (template, n, 4);
						if blength = fixed (unspec (cn1), 15)
						then if substr (bname, 1, blength)
							= substr (template, n + 4, blength)
						     then if k = 1
							then /* at lowest level */
							     if was_found
							     then do;
						/* full name already found */
								     diag_no = fatal_AMBIGUOUS_QUAL_REF;
								     go to duplicate_error;
								end;
							     else do;
						/* first time full name found */
								     if fileno = 0
									| (ntptr -> data_name.type = 9
									& ntptr -> data_name.file_num
									= fileno)
								     then do;
									     was_found = "1"b;
									     ntptr2 = ntptr;
									end;
								end;
							else do;
						/* found a qualifier, look for next lower qualifier */
								levstack (k) = ntptr -> data_name.level;
								k = k - 1;
							     end;
					     end; /* if still_searching  */
				     end;		/* if data_name.type ^= 10 */
			     end;			/* while(still_searching) */
			     ntptr = ntptr1 -> data_name.string_ptr;
			     call search;
			     if ntptr = null ()
			     then not_done = "0"b;
			     else if ntptr -> data_name.type = 18
			     then not_done = "0"b;
			end;			/* while(not_done) */
		     end;				/* if counter ^= 1 */
	     end;					/* if ^ref_type */

	else do;					/* SECTION or PARAGRAPH-NAME REFERENCE */
		stackbegptr = ptrtable (1);		/* point at the qualified name in the name stack */
		do while (not_done);		/* get first type 18 token */
		     call search;
		     if ntptr = null ()
		     then return;			/* section or paragraph-name not found */
		     else if ntptr -> proc_ref.type = 18
		     then not_done = "0"b;
		     else ntptr = ntptr -> proc_ref.string_ptr;
		end;
		if counter = 1
		then do;				/* UNQUALIFIED SECTION or PARAGRAPH-NAME REFERENCE */
			ntptr1 = ntptr;
			psectno = ntptr -> proc_ref.section_num;

/* try to find an occurrence of this section or paragraph-name in the referencing section */

			do while (psectno > sectno);
			     ntptr = ntptr -> proc_ref.string_ptr;
			     call search;
			     if ntptr = null ()
			     then psectno = -1;	/* exit do loop with failure */
			     else psectno = ntptr -> proc_ref.section_num;
			end;
			if psectno = sectno
			then do;			/* Found first occurrence of this section or paragraph-name in the
				   referencing section. Now look for a duplicate in the same section */

				ntptr2 = ntptr;
				if ntptr -> proc_ref.searched
						/* was this string searched before? */
				then if ntptr -> proc_ref.duplicate
				     then do;	/* duplicate found in previous search */
					     diag_no = fatal_PROCNAME_MULTIPLY_DECLARED;
					     go to duplicate_error;
					end;
				     else was_found = "1"b;
						/* no duplicate found */
				else do;		/* first time string searched */
					ntptr -> proc_ref.searched = "1"b;
					ntptr = ntptr -> proc_ref.string_ptr;
					call search;
					if ntptr ^= null ()
					then if ntptr -> proc_ref.section_num = sectno
					     then do;
						/* duplicate found in this section */
						     diag_no = fatal_PROCNAME_MULTIPLY_DECLARED;
						     ntptr2 -> proc_ref.duplicate = "1"b;
						     go to duplicate_error;
						end;
					     else was_found = "1"b;
					else was_found = "1"b;
				     end;
			     end;
			else do;			/* Section or paragraph-name not found in referencing section,
					   search for a duplicate in any section. */

				ntptr = ntptr1 -> proc_ref.string_ptr;
				call search;
				if ntptr ^= null ()
				then do;		/* found another occurrence of this section or paragraph-name */
					diag_no = fatal_AMBIGUOUS_PROCNAME_REF;
					go to duplicate_error;
				     end;
				else do;		/* no other occurrence of this section or paragraph name found */
					was_found = "1"b;
					ntptr1 -> proc_ref.searched = "1"b;
					ntptr2 = ntptr1;
				     end;
			     end;			/* Section or paragraph-name not found in referencing section... */
		     end;				/* UNQUALIFIED SECTION or PARAGRAPH-NAME REFERENCE */
		else if counter = 2 & ntptr -> proc_ref.section_name
		then do;				/* ONLY ONE QUALIFIER AND THAT QUALIFIER IS A SECTION-NAME */
			ntptr1 = ntptr;		/* save ptr to first occurrence of section-name */
			not_done = "1"b;
			do while (not_done);	/* search all occurrences of this section-name */
			     found_one = "0"b;
			     if ntptr -> proc_ref.section_name
			     then do;		/* linearly search this section for all occurrences of the paragraph-name */
				     this_sectno = ntptr -> proc_ref.section_num;
				     section_not_finished = "1"b;
				     do while (section_not_finished);
					ntptr =
					     addrel (ntptr, divide (ntptr -> proc_ref.size + 11, 8, 17, 0) * 2);
					if ntptr = ntendptr
					then section_not_finished = "0"b;
					else if ntptr -> proc_ref.type ^= 18
					then section_not_finished = "0"b;
					else if ntptr -> proc_ref.section_num ^= this_sectno
					then section_not_finished = "0"b;
					else if ntptr -> proc_ref.name_size = stackbegptr -> auser_word.length
					then if substr (ntptr -> proc_ref.name, 1, ntptr -> proc_ref.name_size)
						=
						substr (stackbegptr -> auser_word.word, 1,
						ntptr -> proc_ref.name_size)
					     then if found_one
						then do;
						/* found duplicate in this section */
							diag_no = fatal_PROCNAME_MULTIPLY_DECLARED;
							ntptr2 -> proc_ref.duplicate = "1"b;
							go to duplicate_error;
						     end;
						else do;
						/* found first occurrence of
								   paragraph, search for
								   another in this section */

							found_one = "1"b;
							ntptr -> proc_ref.searched = "1"b;
							ntptr2 = ntptr;
						     end;
				     end;		/* do while(section_not_finished) */
				     if was_found & found_one
				     then do;	/* entire qualified name was already found */
					     diag_no = fatal_AMBIGUOUS_PROCNAME_REF;
					     go to duplicate_error;
					end;
				     else was_found = found_one;
				end;		/* linearly search this section for all occurrences of the paragraph-name */
			     ntptr = ntptr1 -> proc_ref.string_ptr;
			     call search;
			     not_done = ntptr ^= null ();
			end;			/* do while(not_done) */
		     end;				/* ONLY ONE QUALIFIER AND THAT QUALIFIER IS A SECTION-NAME */
	     end;
	return;

search:
     procedure;

	do while (ntptr ^= null ());
	     n = size_TOKEN (ntptr -> data_name.type) - 3;
	     cn1 = substr (template, n, 4);
	     if alength = fixed (unspec (cn1), 15)
	     then if substr (aname, 1, alength) = substr (template, n + 4, alength)
		then return;
	     ntptr = ntptr -> data_name.string_ptr;
	end;

     end search;


/*************************************/
/* EXITS */
/*************************************/
found:
	if ntptr2 -> data_name.type = 9 & ntptr2 -> data_name.non_elementary
						/* [3.0-1] */
	then addr (ntptr2 -> data_name.file_section) -> BIT36 =
		/* [3.0-1] */ addr (ntptr2 -> data_name.file_section) -> BIT36 /* [3.0-1] */
		& /* [3.0-1] */ "111111111111100111111111111110000001"b;
						/* [3.0-1] */
	was_found = "1"b;
	not_found = "0"b;
success_exit:
	return;

notfound:
	was_found = "0"b;
	not_found = "1"b;
fail_exit:
	return;

duplicate_error:
	was_found = "0"b;
	not_found = "0"b;
	go to fail_exit;

/************************************/
/* INCLUDE FILES */
/************************************/
%include cobol_repl_diag_values;
%include cobol_size_values;
%include cobol_type12;
%include cobol_ext_;
%include cobol_type9;
%include cobol_type13;
%include cobol_type18;

     end cobol_usrwd;




		    cobol_version.pl1               10/19/90  1707.0rew 10/19/90  1655.0       19512



/****^  *********************************************************
        *                                                       *
        * Copyright, (C) BULL HN Information Systems Inc., 1989 *
        *                                                       *
        * Copyright (c) 1972 by Massachusetts Institute of      *
        * Technology and Honeywell Information Systems, Inc.    *
        *                                                       *
        ********************************************************* */


/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_version.pl1 Reformatted code to new Cobol standard.
  2) change(90-10-03,Zimmerman), approve(90-10-03,MCR8218),
     audit(90-10-10,Gray), install(90-10-19,MR12.4-1048):
     Update Cobol version for object segment compatibility fix  (Cobol 588,
     phx21360
                                                   END HISTORY COMMENTS */


/* Modified since Version 5.3 */

/* format: style3 */
cobol_version:
     proc;

dcl	ioa_		entry options (variable);

/*************************************/
set:
     entry;
start_set:
	fixed_common.compiler_rev_no = "5.4 of October 1, 1990";
	return;

/*************************************/
print:
     entry;
start_print:
	call ioa_ ("COBOL, Version 5.4");
	return;

/*************************************/
header:
     entry (hdr_lines, hdr_len);
dcl	hdr_lines		char (*);
dcl	hdr_len		fixed bin;
dcl	ioa_$rs		entry options (variable);
dcl	date_time_	entry (fixed bin (71), char (*));
dcl	dt		char (24);
dcl	substr		builtin;

start_header:
	sym_ptr = cobol_$sym_base_ptr;
	call date_time_ (symbol_block_header.object_creation_time, dt);
	call ioa_$rs (
	     "COMPILATION LISTING OF SEGMENT ^a^/Compiled by: Multics COBOL, Version ^a^/Compiled on: ^a^/    Options: ^a^/",
	     hdr_lines, hdr_len, cobol_$obj_seg_name, fixed_common.compiler_rev_no, dt,
	     substr (cobol_options, 1, cobol_options_len));
	return;

%include cobol_fixed_common;
%include cobol_ext_;
%include cobol_sbh;
%include cobol_;
     end cobol_version;

*/
                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group Bull including Bull HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell Bull Inc., Groupe Bull
and Bull HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture for 
managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, Bull or Bull HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by Bull HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved

*/
