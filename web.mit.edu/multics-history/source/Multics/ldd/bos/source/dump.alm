" ***********************************************************
" *                                                         *
" * Copyright, (C) Honeywell Information Systems Inc., 1982 *
" *                                                         *
" ***********************************************************
" The BOS dump program.
" Modified 5/11/75 by Noel I. Morris.
" Last modified 2/11/81 by Sherman D.Sprague for DPS8 support.
	name	dump


"  ******************************************************
"  *                                                    *
"  *                                                    *
"  * Copyright (c) 1972 by Massachusetts Institute of   *
"  * Technology and Honeywell Information Systems, Inc. *
"  *                                                    *
"  *                                                    *
"  ******************************************************


	equ	dmpbufl,64	Length of dump buffer

	include	bosequ

" 
	stx2	x2
	tsx2	initint			Initialize the fault and interrupts
	arg	execint

	tsx2	init_io			" Initialize the IOM routines.
	tsx2	cvinit			init disk addr conversion prog

	tsx2	ttyinit
	arg	ttyrequest

	lda	=h  apnd		"apnd" in A
	eaq	apnd_org		origin of appending package in QU
	tsx2	ldcom		load in the appending package
	tra	x2		..

	ldaq	com|dbr
	staq	cmdbr			"use possible new dbr
	eaa	dmpbufl			"length of apnd buffer in AU
	tsx2	getinit			"and get new sdws

	lda	=h  sstn
	eaq	sstn_org		origin of SST name table filler
	tsx2	ldcom		load package
	tra	*+2
	tsx2	sstn_org		execute package

	tsx2	initsstnt		initialize SST name table package

	lda	=h ptpkg
	eaq	pt_org		origin of print package in QU
	tsx2	ldcom		load the print package
	tra	x2

	mlr	(),()		copy the page heading
	desc6a	nheading,nheading_lth*6
	desc6a	pthdr,nheading_lth*6

	tsx2	rdclock			"convert clock and put time in header.
	sta	pthdr+4
	stq	pthdr+5


execint:
ttyrequest:
	stz	ptsegno
	tra	cycle

qm:	tsx2	erpt			"print ?
	acc	'^g'
	arg	=h!!????

cycle:	tsx2	nextline

	mlr	(),()			Move card to header line.
	desc6a	line,72
	desc6a	pthdr+6,72

	ldx1	0,du
	lda	arg
	rpt	ncoms/2,2,tze
	cmpa	comtab,1
	tze	command_found
	tsx2	initprint			"command not found
	tsx2	headform			"print it
	tra	qm

command_found:
	lda	-1,1			"tra to routine indicated
	cana	=1,dl			"if bit on, don't print header
	tnz	*+3
	tsx2	initprint			"print header
	tsx2	headform
	lda	-1,1
	tsx2	0,au			"may be subroutine
	tra	cycle

" 

comtab:	null
	bci	"  dump"
	zero	dump			"default dump
	bci	"   abs"
	zero	octaldump			"abs oct dump
	bci	"   seg"
	zero	oneseg,1			"single segment
	bci	"   dbr"
	zero	newdbr			"set dbr and dump
	bci	"  cont"
	zero	contin,1			"dump from segno
	bci	" stack"
	zero	stackdump,1		"dump stack frames
	bci	"  tape"
	zero	tapeon,1			"dump to tape
	bci	"   prt"
	zero	printon,1			"dump to printer
	bci	"   reg"
	zero	dumpreg			"dump regs and desc seg
	bci	"   eof"
	zero	wteof			"write eof
	bci	"   dev"
	zero	devdump
	bci	"  quit"
	zero	quit,1			"return to bos
	oct	777777777777		"null command
	zero	cycle			"comment
	bci	"  fill"
	zero	call_fill
	bci	"    go"
	zero	go,1
patchw:	bci	" patch"
	zero	patch,1
	bci	"  proc"
	zero	proc
	bci	"config"
	zero	configp

	equ	ncoms,*-comtab


"
go:	lda	=hcontin
	tra	bosret

patch:	lda	patchw			"pathc
	tra	bosret

quit:	lca	=1,dl			"none

bosret:
x2:	eax2	*			"if so, return
	tra	mem|1,2

"
"fill certain variables

call_fill:
	tsx2	fill
	tra	qm

	tra	cycle


"
"dumpreg to dump regs and desc seg
dumpreg:	tsx2	printreg
	tsx2	descrseg			"dump desc seg
	tra	cycle

"
" To print out the configuration deck.

configp:	stx2	conf_x2
	eax0	0		" Set up loop on all config cards.

	tsx2	space		" Clear line buffer.
	tsx2	print		" Print one line.

config_loop:
	lda	com|conf,0	" Get next parameter.
	tmi	conf_x2		" Test for completion.

	tsx2	config_print	" Convert card for printing.

	tsx2	print		" Print the card.

	eax0	confl,0		" Step to next card.
	cmpx0	econf-conf,du	" Are we finished?
	tmi	config_loop	" If not, loop.

conf_x2:	eax2	*		" Restore X2.
	tra	0,2		" And return.

"
"entry when switches indicate to take an octal dump

octaldump: null
	lda	arg+1			"get starting loc
	cmpa	=-1
	tnz	*+2
	lda	=0,dl
	arl	6			"get block addr
	eax0	0,al

	lda	arg+2			"get count
	tze	*+3
	cmpa	=-1
	tnz	*+2
	lda	=o100,dl
	ada	=o77,dl			"go to next 64
	arl	6
	eax1	0,al
	tsx2	space

octalloop: eaa	0,0			"block addr to a
	tsx2	octwd			"edit location
	sta	line+1

	stz	fetchin
	stx0	fetchin			"get block location
	tsx2	fetch
	arg	octalend

	tsx2	ptblock			"print 64 words
	zero	fetchout,64

octalend:	eax0	1,0			"go to next block
	eax1	-1,1
	tnz	octalloop
	tra	cycle			"dump is finished

"
"dump 1 seg only
oneseg:	null
	eax7	1		arg number for collect segname
	tsx2	collect_segname
	cmpa	=-1
	tze	qm			"if not given, ignore
	als	18
	sta	segno
	tsx2	segprint			"edit the segment
	tra	onesegno			"if error
	tra	cycle			"done
onesegno:	null				"requested segemnt not present
	tsx2	space
	ldaq	nsegno			"print message
	sta	line+4
	stq	line+4+1
	lda	segno
	tsx2	octwd
	sta	line+6			"store edited segment number
	ldaq	notincore
	sta	line+8
	stq	line+8+1
	tsx2	print			"print message
	tra	cycle			"we are done

"
" Start dump from a given segment number.

contin:	null
	lda	arg+1			" Get starting segno
	cmpa	=-1
	tnz	*+2
	lda	=0,dl
	cmpa	=o200000,du		"if a alpha
	tpl	contal
	eax7	-9			"move args down if segno given
	ldq	arg+9+2,7
	stq	arg+9+1,7
	eax7	1,7
	tmi	*-3
	tra	*+2
contal:	lda	=0,dl			"use zero
	als	18
	sta	segno
	tsx2	allsegsn			"start print
	tra	cycle

"
" Get new dbr and initiate print.
" Where necessary turn  ON  bits to make the  DBR  look like a valid SDW.

newdbr:	null
	lda	arg+1			"get dbr val
	cmpa	=-1
	tze	dbrpt			"if not given, ignore

	ana	=o000077777777		Zero all but  DBR.ADDR
	als	12			Shift into DBR.ADDR position.
	ora	sdw.df,dl			Turn on  F  bit.
	sta	cmdbr			Store  DBR word 1.

	lda	arg+2			"get bound and bits
	cmpa	=-1
	tze	dbrpt			"if not given use old

	ana	=o377770207777		Mask off all but BOUND, U and STACK.
	ora	=o000005,du		Turn on R and W bits.
	sta	cmdbr+1

dbrpt:	tsx2	print_dbr
	tsx2	getinit
	tra	cycle

"
"entry to dump everything
dump:	null
	tsx2	printreg			"print registers
	tsx2	descrseg			"dump desc segment
	tsx2	headform
	tsx2	configp			"print config deck.
	tsx2	allsegs			"dump all segments
	tsx2	sptrace			"and print stack
	tra	cycle

"
" Called with  ASCII  type in  A.

"	DEV VOL <pv> <recno>
"	DEV PHY <ss> <drive> <sector>
"	DEV PART <part> <recno>

devdump:	eax0	1		Here to dump disks or bulk store
	tsx2	argbos		scan args
	arg	dmpdid		will return did
	arg	dmpps		sector number to be printed
	tra	qm		if error

	eax7	0,al		length of sector in X7
	anx7	=o7777,du		Mask the sector length.
	stz	devmult		clear Multics switch
	cmpx7	2,du		Multics address?
	tmi	*+2		if not, don't set switch
	stc2	devmult		set Multics address switch
	stx7	dmpol		set offset limit

	ldq	0,dl		quit after first unless more args
dev_garg:
	lda	arg,0		Look for number or for  "for".
	cmpa	=-1
	tze	nofor
	cmpa	=h   for
	tnz	*+3
	eax0	1,0		for found get number of sectors
	tra	dev_garg

	cmpa	=1,du		if not too big
	tpl	nofor
	ada	dmpps		add to produce sector limit
	lrl	36
nofor:	stq	dmpsl
	stz	read_args		"we will clobber dmpbuf

sectl1:	eax0	0		zero offset
	szn	devmult		Multics address?
	tze	sectl		if not, skip conversion and pd_check

	lda	dmpps		get Multics address
	tsx2	mulbos		convert to BOS address
	arg	dmpdid
	tra	qm

	tsx2	pd_check		Search for  pdmap  entry.
	arg	dmpdid
	arg	pdmep
	tra	*+1

	stca	dmprs,74		set BOS sector number

sectl:	lda	dmprs		get bos sector for read
	tsx2	rdev
	nop	dmpdid
	nop	bf|0
	tra	rdbad
	tra	rdok

rdbad:	sta	bf|0		"save error code
	tsx2	space
	lda	=hsector		Print sector number
	sta	line+2
	lda	dmpps
	tsx2	octwd
	stq	line+4
	stca	line+3,03
	lda	bf|0		Get error code
	tsx2	octwd		"otherwise print error word
	sta	line+6
	stq	line+6+1
	tsx2	print		and print line

rdok:	lda	dmpps		get sector
	tsx2	octwd
	lls	24
	sta	line		store sector
	stq	line+1

	eaa	0,0		get offset
	tsx2	octwd
	ora	=h00  00
	stca	line+1,17		store offset

	tsx2	ptblock		Print 64 words
	zero	dmpfet,64

	lda	=o10000,dl	Go to new sector
	asa	dmprs		bump bos sector
	eax0	1,0		bump offset
dmpol:	cmpx0	*,du
	tmi	sectl

	aos	dmpps		bump sector
	lda	dmpps
	cmpa	dmpsl		compare against sector limit
	tmi	sectl1
	tra	cycle		done

	even
dmpfet:	its	bf,0		"its pointer to dump buffer.

pdmep:	oct	0
devmult:	oct	0
dmpdid:	oct	0
dmpps:	oct	0
dmprs:	vfd	24/0,12/1
dmpsl:	oct	0

"
"print the registers

printreg:	null
	stx2	regsretn



" Print  DBR.
	tsx2	print_dbr


" Print  PPR

	tsx2	print_hdr		Print  PPR  header line.
	desc6a	nppr_hdr,22

	lda	com|scu		Get  PPR.PRR and PPR.PSR
	tsx2	octwd		Convert to  GEBCD.
	stca	line+4,40		Store  PPR.PRR.
	lrl	18		Position for  PSR.
	stca	line+4,03		Store  PPR.PSR.
	stcq	line+5,70

	lda	com|scu+scu.ilc_word	Get  PPR.IC.
	tsx2	octwd
	sta	line+6		Store the  PPR.IC.
	tsx2	print		Now print the PPR.
	tsx2	space		Skip two lines.
	tsx2	print
	tsx2	print


" Print time of machine conditions.

	lda	=htime  "
	sta	line+3
	ldaq	com|mctime	Get time BOS entered.
	tsx2	cvclock		Convert.
	sta	line+4
	stq	line+5
	tsx2	print
	tsx2	space
	tsx2	print


" Now print the Ring Alarm Register.

	lda	=hralr   "	Set up RALR name.
	sta	line+3
	lda	com|regs+7	Get RALR.
	tsx2	octwd
	qls	30		Position RALR field.
	stcq	line+4,40		Store RALR.
	tsx2	print		And now print the RALR line.


" Now print the registers from the table.

	eax0	0			"do simple regs driven from table
pregl:	tsx2	space			"blank line
	lda	regtab,0			"get control word
	arl	15			Right justify bits (0-2).
	eax1	0,au			"blank, left, right, both code

	lda	regtab,0			Get control word again.
	ana	=o077777,du		Zero code field.

" The following code is used to print words from the  dump  program itself -
" segment  pgm.   This feature is currently not being used.   If it is ever
" needed just reinstate the following 5 instructions and the label seg_com.

"	"	"	"	"	"	"	"	"
"
"	cana	=o040000,du		If bit (3) is  ON  then get the word
"					to be printed from segment  (pgm).
"	tze	seg_com			If OFF get word from bos_common.
"	ana	=o037777,du		Turn OFF the segment (pgm) bit.
"	lda	pgm|0,au			Get word from dump itself (pgm).
"	tra	convert_word
"
"seg_com:
"
"	"	"	"	"	"	"	"	"

	lda	com|0,au			Get word from  bos_common (com).
convert_word:
	tsx2	octwd
	xec	*+2,1			Execute according to code in X1.
	tra	regnam			Come here if inst XECd not a  "tra".

	tra	regblk			Code = 0  =>  blank line
	sta	line+4			Code = 1  =>  left half
	stq	line+4			Code = 2  =>  right half
	tra	*+1			Code = 3  =>  both, grab control
	sta	line+4			Store  left half.
	lda	=h      "			Insert one blank between  left and
	llr	36-6			right halves.  Three blanks now
	sta	line+5			on end of right half.
	stq	line+6

regnam:	lda	regtab,0			"get name from table
	lda	0,al
	sta	line+3

regblk:	tsx2	print			"print line
	eax0	1,0
	cmpx0	nregs,du
	tnz	pregl


" Dump the  8  pointer registers.

	tsx2	print_hdr			Print  PR  header line.
	desc6a	npr_hdr,29

	eax1	0			Initialize loop index.

pr_loop:
	lda	npr0,1			Get name of  PR.
	sta	line+2
	lda	npr0+1,1
	sta	line+3

	lda	com|prs,1			Get first word of  PR.
	tsx2	octwd
	stcq	line+4,40			Store  RNR  field.
	lrl	18			Position  SNR  field.
	stca	line+4,03			Store  SNR  field.
	stcq	line+5,70

	lda	com|prs+1,1		Get second word of PR.
	tsx2	octwd
	sta	line+6			Store  ADDR (word) field.
	qrl	6			Position  ADDR (char-bit) field.
	stcq	line+7,14			Now store it.

	tsx2	print			Now print one pointer register.
	tsx2	space

	eax1	2,1			Up index to next PR. (takes 2 words)
	cmpx1	8*2,du			Have we printed all of the  PRs?
	tnz	pr_loop			Tra if no.


" Print  Associative Memory.
" Start by printing the AMSDW Registers and Pointers.

	tsx2	headform			Start on a new page.

	tsx2	print_hdr			Print  SDW  Ass.Mem  header line.
	desc6a	namsdw_hdr,61

	eax1	0			Index to  SDW  Registers.
	eax0	0			Index to  SDW  Pointers.

amsdw_loop:
	ldaq	com|amsdwregs,1		Get an Ass.Mem SDW reg.
	orq	=o400000,du		Tell prt_sdw_seg this is from A.M.
	tsx2	prt_sdw_reg		Move it into "line" but don't print.

	lda	com|amsdwptr,0		Get an Ass.Mem SDW pointer.
	cana	=o000400,dl		First test the  F  bit.
	tze	*+3			Tra if off.
	ldq	=h    f "			It is on so store  "F".
	tra	*+2
	ldq	=h    e "			It is off so store "E".
	stq	line+11

	tsx2	octwd
	arl	6
	stca	line+10,37		Store  POINTER  field.

	qls	6			Position and store USAGE field.
	stcq	line+12,06

	tsx2	print			Now print one Ass. Mem. SDW.
	tsx2	space

	eax0	1,0			Up pointer index by 1.
	eax1	2,1			But register index by 2.
	lda	com|aphist+1		check machine type dump made on
	ana	=o1,dl
	tnz	amsdw_l68			move on if L68
	cmpx0	=64,du			compare used if dps8
	tnz	amsdw_loop		tra if no
	tsx2	headform
	tra	*+3			transfer on if dps8
amsdw_l68: 
	cmpx0	=16,du			Printed all 16  SDWs?
	tnz	amsdw_loop		Tra if no.


" Now print the AMPTW Registers and Pointers.

	tsx2	print_hdr			Print Ass.Mem.  PTW header line.
	desc6a	namptw_hdr,42

	eax1	0			Reset index for this next loop.

amptw_loop:
	lda	com|amptwregs,1		Get a  PTW  Register word.
	tsx2 	octwd
	sta	line+3			Store  ADDR field.

	lda	com|amptwregs,1		Get the  PTW  reg again.
	ana	-1,dl			Zero  ADDR  field.
	arl	6			Shift  M  bit into low order A bit.
	lda	nno,al			Now use it as an index.
	sta	line+4			M = 0 => "no",  M = 1 => "yes".

	lda	com|amptwptr,1		Get a  PTW  pointer word.
	cana	=o000400,dl		1st test F bit while we know where it is
	tze	*+3			Tra if off.
	ldq	=h   f  "			It is on.
	tra	*+2
	ldq	=h   e  "			It is off so store an "E".
	stq	line+8			Store  "F" or "E".

	tsx2	octwd			Now convert pointer register to GEBCD.
	llr	24			Shift to position POINTER field.
	stcq	line+5,17			Store POINTER field.
	stca	line+6,40

	llr	6			Shift to position PAGE_NO field.
	stca	line+7,74

	llr	18			Shift to position USAGE field.
	stca	line+9,14

	tsx2	print			Now print one Ass. Mem. PTW.
	tsx2	space

	eax1	1,1			Increment index to point to next words.
	lda	com|aphist+1		check machine type dump made on
	ana	=o1,dl
	tnz	amptw_l68			move on if L68
	cmpx1	=64,du			compare used if dps8
	tnz	amptw_loop		tra if no
	tsx2	headform
	tra	*+3			transfer on if dps8
amptw_l68: 
	cmpx1	=16,du			Have all 16 PTW regs & ptrs been printed?
	tnz	amptw_loop		Tra if no.


" Now print the coreblocks, memory controller masks, and the history registers.
" First the coreblocks.

	tsx2	headform			Start on a new page.

	tsx2	print_hdr			Print coreblocks header line.
	desc6a	ncb_hdr,24

	ldx1	0,du			Set loop index.
cb_loop:
	lda	com|coreblocks,1		Get a coreblocks word.
	cmpa	=-1			If word = -1 then port has no mem.
	tnz	port_has_mem		..

	lda	=hno mem			No memory on this port.
	ldq	=h      "
	sta	line+5
	stq	line+6
	tra	print_port

port_has_mem:
	tsx2	octwd			Port has mem so convert word.

	stq	line+6			Save number of blocks.
	tsx2	bzel			Suppress zeros .
	sta	line+5
	lda	line+6			Get num of 1st block again.
	tsx2	bzel			Suppress its leading zeros too.
	sta	line+6

print_port:
	tsx2	print			Now print one coreblocks word.
	tsx2	space

	eax1	1,1
	cmpx1	=8,du			Have we printed all 8  ports?
	tnz	cb_loop			Tra if no.


" Now print the memory controller masks.

	tsx2	print_hdr			Print mem controller header line.
	desc6a	nmcm_hdr,23
	stc1	ptbfirst
	tsx2	ptblock			Print it as one block.
	zero	mcmp1,16			Print 16 words.


" Now print the history registers.  They will be printed as one block.

" print the ou history regs
	tsx2	print_hdr			Print ou regs header line.
	desc6a	nouhistreg_hdr,41
	tsx2	space

	stc1	ptbfirst
	tsx2	ptblock
	zero	ouhrits,128		Print 128 words as one block.
	tsx2	space
	
" print the cu history regs
	tsx2	print_hdr			Print cu regs header line.
	desc6a	ncuhistreg_hdr,41
	tsx2	space

	stc1	ptbfirst
	tsx2	ptblock
	zero	cuhrits,128		Print 128 words as one block.

" print the du history regs
	
	lda	com|aphist+1
	ana	=o1,dl
	tze	dptapu

	tsx2	print_hdr			Print eis regs header line.
	desc6a	neishistreg_hdr,41
	tsx2	space
	
	stc1	ptbfirst
	tsx2	ptblock
	zero	duhrits,128		Print 128 words as one block.

" print the apu history regs
	tsx2	print_hdr			Print apu regs header line.
	desc6a	napuhistreg_hdr,41
	tsx2	space

	stc1	ptbfirst
	tsx2	ptblock
	zero	apuhrits,128		Print 128 words as one block.
	tra	regsretn

" print the DPS8 apu and apu extended history registers
dptapu:	tsx2	headform

	tsx2	print_hdr			Print apu regs header line.
	desc6a	napuhistreg_hdr,41
	tsx2	space

	ldx4	0,du
dptlp:	eaa	0,4
	arl	1+18
	tsx2	octwd
	stcq	line+1,03
	lda	com|aphist,4
	tsx2	octwd
	staq	dtemp_buff

	eax3	24
	mlr	(),(x3)		lets put out the seg number
	desc6a	dtemp_buff,5
	desc6a	line,5

	eax3	7,3		lets allow 2 spaces between fields
	mlr	(),(x3)
	desc6a	dtemp_buff(5),4	the next 4 char of the apu hist 
	desc6a	line,4

	eax3	6,3		stick in some more spaces
	mlr	(),(x3)
	desc6a    dtemp_buff+1(3),3		last 3 char of 1 st apu hist 
	desc6a	line,3
	
	lda	com|aphist+1,4
	tsx2	octwd
	staq 	dtemp_buff		get the next word

	eax3	9,3			put in 6 spaces
	mlr 	(),(x3)
	desc6a	dtemp_buff,8
	desc6a	line,8

	eax3	10,3
	mlr	(),(x3)
	desc6a	dtemp_buff+1(2),4		last 4 char of 2nd word
	desc6a	line,4
	
	lda	com|eishist,4
	tsx2	octwd
	staq	dtemp_buff

	eax3	16,3
	mlr	(),(x3)
	desc6a	dtemp_buff,6		get offset from apu ext reg
	desc6a	line,6

	eax3	8,3
	mlr	(),(x3)
	desc6a	dtemp_buff+1,3		pick up the op-code
	desc6a	line,3

	eax3	5,3
	mlr	(),(x3)
	desc6a	dtemp_buff+1(3),3
	desc6a	line,3
	
	lda	com|eishist+1,4
	tsx2	octwd
	staq	dtemp_buff
	
	eax3	9,3
	mlr	(),(x3)
	desc6a	dtemp_buff,12		dump out the last word of the
	desc6a	line,12			apu ext reg. 

	tsx2	print			
	eax4	2,4
	cmpx4	64*2,du
	tnz	dptlp
	
regsretn:	tra	*			Now return from  printreg.
	even
dtemp_buff:
	bss	,2	
"
" These are the subroutines used to print the  6180  registers.


" This subroutine prints a header line.  Word after tsx2 must contain the descriptor of
" the header to be printed.  The header will be padded to 66 characters.  The header
" will be stored in "line" starting at word (3).  There will be two blank lines before
" the header line and one blank line printed after the header line.  When print_hdr
" returns  "line" will be blank.

print_hdr:
	stx2	ph_ret			Save return address.

	tsx2	space			Print 2 blank lines before header line.
	tsx2	print
	tsx2	print

	ldx7	ph_ret			Get address of header to be printed.

	mlr	(id),(),fill(20)		Copy the header
	arg	0,7
	desc6a	line+3,66

	tsx2	print			Now print the header line.
	tsx2	space			Then a blank line.
	tsx2	print

ph_ret:	eax2	*			Restore X2.
	tra	1,2			Return - skip over  arg used in call.



"
" This subroutine will print a  DBR.  The  DBR to be printed is assumed to
" be in  "cmdbr".

print_dbr:
	stx2	pdbr_ret			Save return address.
	tsx2	print_hdr			Print  DBR  header line.
	desc6a	ndbr_hdr,24

	lda	cmdbr			Get first word of  DBR.
	tsx2	octwd

	lrl	12			Position to store  ADDR  field.
	stca	line+3,17
	stcq	line+4,74

	lda	cmdbr+1			Get second word of  DBR.
	tsx2	octwd

	llr	6			Position  BOUND and U fields.
	stcq	line+4,01			Store  BOUND  field.
	stca	line+5,74

	arl	1			Make U field a "1" if it is on.
	ana	=o1,dl			..
	stca	line+5,01

	qrl	6			Reposition  STACK field.
	stcq	line+6,17

	tsx2	print			Now print the  DBR.

pdbr_ret:	tra	*			Return.
"
" This subroutine will edit an  SDW  "register" and put it in  "line" for printing.
" This subroutine will not actually print the line.  It is called to set up both
" regular  SDW and Ass. Mem. SDW  registers.  The subroutine assumes that the caller
" has placed the  SDW to be processed in  AQ.  

prt_sdw_reg:
	stx2	psdw_ret
	staq	save_sdw			Save SDW for future use.
	tsx2	space			Clear line before doing any work.
	lda	save_sdw			restor first word of sdw to A
	tsx2	octwd			Convert the first word of the SDW.

	sta	line+3			Store the  ADDR  field.
	stcq	line+4,60

	lls	24			Position and store R1 field.
	stca	line+4,02
	qrl	6			Separate R2 and R3 fields by 1 char.
	lrl	6			Move them both into position.
	stcq	line+5,50			Store R2 and R3 fields.


" Note: the F bit requires a little special processing.  The  F bit and the
" F code are not part of an  Ass. Mem. SDW register and are thus not
" printed.  When prt_sdw_reg is called to setup an  Ass. Mem. SDW register
" bit 0 of SDW word 2 should be ON.  Note: the  F bit in an Ass. Mem. SDW
" register will never be  ON.

	lda	save_sdw+1		Get SDW word 2 in A.
	ldq	save_sdw			Get SDW word 1 in Q.
	anq	=o000007,dl		Zero all but F bit and F code.
	canq	sdw.df,dl			Is  F  bit  on?
	tze	F_bit_off			Tra if no.
	ldq	=h      "			F bit  ON  - print blank.
	tra	set_F			F on => not from Ass. Mem.
F_bit_off:
	cana	=o400000,du		Is special A.M. bit set?
	tze	set_F			NO - print F_CODE field.
	ldq	=h      "			Yes, A.M. SDW - print blanks.
	era	=o400000,du		Turn off Ass. Mem. bit.

set_F:	stcq	line+5,01			Store F_CODE, or " ".

" Now set up to store characters representing the  REWPUG  bits.

	ldq	=hpugrew			Get access characters "PUGREW"
"					They are backward because of the way
"					they are stored in  "line".
	cana	sdw.read,du		Test for R bit, store "R" if on.
	tze	*+2
	stcq	line+7,04
	cana	sdw.execute,du		Test for E bit, store "E" if on.
	tze	*+2
	stcq	line+7,02
	cana	sdw.write,du		Test for W bit, store "W" if on.
	tze	*+2
	stcq	line+7,01
	cana	sdw.privileged,dl		Test for P bit, store "P" if on.
	tze	*+2
	stcq	line+8,40
	cana	sdw.unpaged,dl		Test for U bit, store "U" if on.
	tze	*+2
	stcq	line+8,20
	cana	sdw.entry_bound_sw,dl	Test for G bit, store "G" if on.
	tze	*+2
	stcq	line+8,10

	ldq	=h      "
	cana	sdw.cache,dl		is cache bit ON?
	tze	*+2
	ldq	=h   c  "
	stcq	line+8,04

	ana	=o377770037777		remove undesirable bits
	tsx2	octwd			Now convert SDW word 2.
	alr	24			Position and store  BOUND field.
	stca	line+6,17
	stca	line+7,40

	lls	6			Position and store  CL  field.
	stcq	line+9,76

psdw_ret:	tra	*			Return.

"
" These are data items used in dumping the 6180 registers.

	even
mcmp1:	its	com,mcm			Pointer to mcm info.

ouhrits:	its	com,ouhist		Pointer to ou history regs

cuhrits:	its	com,cuhist		Pointer to cu history regs

duhrits:	its	com,eishist		Pointer to du history regs

apuhrits: its	com,aphist		Pointer to apu history regs
	
save_sdw:	oct	0,0			Used by prt_sdw_reg.


" This table is used to print some of the  645F registers.  Some subtle features
" of the table are:  The value of bits 0 - 2 tell what to do with the register -
"		000 - 0  =>  print a blank line
"		001 - 1  =>  print only the left half of the word
"		010 - 2  =>  print only the right half of the word
"		011 - 3  =>  print both halves of the word
"
" Bit 3 of each word in the table determines whether the word is to come from
" the segment  bos_common  ( com )  or from this program - the segment ( pgm ).
"
"		0  =>  com
"		1  =>  pgm
"
" Note, currently no regesters are printed from this segment (pgm).  However, the
" code to do this has been left in the  "pregl"  loop  in case it is ever needed.

regtab:
	zero
	vfd	3/2,1/0,14/scu+4,18/nind	"ind
	zero
	vfd	3/3,1/0,14/regs+4,18/na	"a
	vfd	3/3,1/0,14/regs+5,18/nq	"q
	vfd	3/1,1/0,14/regs+6,18/nexp	"exp
	vfd	3/3,1/0,14/regs+7,18/ntimer	"timer
	zero
	vfd	3/1,1/0,14/bar,18/nbar	"bar
	zero
	vfd	3/1,1/0,14/regs,18/nx0	"x0
	vfd	3/2,1/0,14/regs,18/nx1
	vfd	3/1,1/0,14/regs+1,18/nx2
	vfd	3/2,1/0,14/regs+1,18/nx3
	vfd	3/1,1/0,14/regs+2,18/nx4
	vfd	3/2,1/0,14/regs+2,18/nx5
	vfd	3/1,1/0,14/regs+3,18/nx6
	vfd	3/2,1/0,14/regs+3,18/nx7	"x7
	zero
	vfd	3/3,1/0,14/modereg,18/nmode	"mode
	vfd	3/3,1/0,14/modereg+1,18/nmode	"cache mode
	vfd	3/3,1/0,14/faultreg,18/nfault
	zero
	vfd	3/3,1/0,14/intrpts,18/nintrps	"interrupts
	zero
	vfd	3/3,1/0,14/mctime,18/nclock	"clock
	vfd	3/3,1/0,14/mctime+1,18/nclock
	zero
	equ	nregs,*-regtab
"
"print the descriptor segment
descrseg:	null
	stx2	descrsegretn		"save return
	tsx2	initsstnt			make sure we have correct KST
	tsx2	headform

	tsx2	print_hdr
	desc6a	ndseg_hdr1,40

	tsx2	print_hdr
	desc6a	ndseg_hdr2,60

	stz	segno			"set segment number to zero

desnext:	null				get another sdw
	lda	segno
	tsx2	getsdw			SDW returned in  A,Q.
	tra	segnotpres		"return for not found
	tra	endprdesc			"return for end of desc seg

desfound:	null				"sdw is in cursdw

	tsx2	ptsdw			"print sdw

	lda	=1,du
	asa	segno
	tra	desnext			"get next sdw

segnotpres: null				"missing segment
	cana	=o777777770000		test the address field
	tnz	desfound			print SDW if any bits on
	tsx2	space
	tsx2	print			"skip one line

snotpres2:
	lda	=1,du
	asa	segno
	lda	segno
	tsx2	getsdw
	tra	snotpres3			"another missing segment
	tra	endprdesc			"end of desc segm
	tra	desfound			Have sdw, edit it.

snotpres3:
	cana	=o777777770000		test the address field
	tnz	desfound			print if any bits on
	tra	snotpres2

endprdesc: 				"end of printing of desc seg
descrsegretn: tra	*			Return
"
" Note:  ptsdw is called with the  SDW  in  A,Q.

ptsdw:	stx2	psx2			"save x2

	tsx2	prt_sdw_reg		Move SDW data into "line".

	lda	segno
	tsx2	octwd
	alr	18			Position segment number.
	stca	line+10,01		Only print 4 digits.
	stca	line+11,70

	lda	save_sdw
	tsx2	getsstntname		"get name of seg from SST name table
	desc6a	line+12,56
	tra	*+2
	tra	psegnm
	lda	segno
	tsx2	getsltname		"get name of seg from SLT
	desc6a	line+12,56
	tra	*+1
psegnm:
	tsx2	print			"print the line

psx2:	eax2	*
	tra	0,2
"
"allsegs prints all the segments (subject to mode)
allsegs:	null
	stz	segno			"set segment number to zero
allsegsn:	null				"entry with initial segno set
	stx2	allsegsretn		"save return


" These option argument words come in pairs.  The first (even) option
" contains the  SDW bits that must be ON.  The 2nd option arg contains
" the  SDW  bits that must be  OFF.

	eax1	1			"get options
	eax2	0
	ldq	=o777777777700
opt_arg_loop:
	lda	arg,1			Get one option word.
	cmpa	=-1
	tze	optend			"last arg


	eax0	0			"check each char in arg
opt_char_loop:
	eax7	noptch			Get length of table.
search_tab:
	cmk	optl-1,7			Loop thru table until char found.
	tnz	*+3			"tra if no match
	orx0	optl-1,7			OR bit => by this character.
	tra	*+3
	eax7	-1,7
	tnz	search_tab		Test next entry in table.

" Unrecognized character options are ignored.

	arl	6			"get new char
	tze	*+3
	cmk	=o20,dl			Test for blank => no more chars.
	tnz	opt_char_loop		Not blank => test next char.


	eaa	0,0			"end of arg, put bits into a
"					MAKE SURE BITS LINE UP WITH  SDW.
	arl	3			Put access bits in position.
	canx2	=1,du			Is this an even or odd option wd?
	tze	even_arg			Tra if even.

" If this is the 2nd word of the pair (odd) then  OR the two words
" together to get a mask which will determine all of the SDW bits
" to be tested.
	ora	options-1,2		OR if odd.
even_arg:
	sta	options,2
	eax2	1,2
" At most 5 pairs will be processed.  All arguments beyond that will be
" stored in the slot for the fifth pair and will overlay one another.
	cmpx2	=10,du			Test for fifth pair.
	tmi	*+2
	eax2	10-1			Too many - use 5th slot.
	eax1	1,1			"go to next arg
	tra	opt_arg_loop



optend:	cmpx2	=0,du			"if no options
	tnz	there_are_options
	lda	=o000001,du		W  is the default.
	sta	options,2
	eax2	1,2

" If X2 is odd then the last option pair had no 2nd  (OFF) word.  We will
" use the  ON word in its place.

there_are_options:
	canx2	=1,du			Test if odd.
	tze	last_option_paired
	lda	options-1,2		Use ON wrd as test bits.
	sta	options,2
	eax2	1,2			Make it look like it was paired
last_option_paired:
	stx2	nopt			"save number of options



" Now that we have all of the options setup we can start processing the segments
" in this descriptor segment.

segment_loop:
	lda	segno			Get segment number.
	tsx2	getsdw			"get a segment descriptor word
	tra	segmissing		"return if not present
	tra	endofseg			"at end of descriptor segment,

	lls	36			SDW returned in A,Q.  Put SDW word
"					2 in A so we can test R,E,W,P bits.
nopt:	eax2	*			"load number of options
test_sdw_bits:
	ldq	options+1-2,2		Even wd has bits to test.
	erq	=o777777777777		Make mask for  cmk.
" Now compare the  SDW  bits with the bits that were supposed to be ON.  WE
" also are testing the bits that are supposed to be OFF.
	cmk	options-2,2		
	tze	good_match
	eax2	-2,2			Try next option pair.
	tnz	test_sdw_bits		If there are any.
	tra	segmissing		No pairs match so skip seg.

good_match:
	tsx2	segprint			"print the segment 
	tra	*+1			Ignore any errors.

segmissing: null				"get the next segment
	lda	=1,du
	asa	segno			"increment the segment numbef
	tra	segment_loop		"get another segment descr word

endofseg:	null				All SDWs for this DBR printed.
allsegsretn: tra	*			Return.



" This is a table of  DUMP and CONT option characters.  The right 6 bits are
" the GEBCD value of the one character option.  Bits 12-17 represent  SDW
" bits  15-20.

optl:	oct	000074000021		A => ALL
	oct	000040000061		R => READ
	oct	000020000025		E => EXECUTE
	oct	000010000066		W => WRITE
	oct	000004000047		P => PRIVILEGED
	equ	noptch,*-optl

	bss	options,10
"
"segprint prints one segment
"
" The  calling sequence is:
"	set   segno		
"	tsx2	segprint
"	tra	error		Error return location.
"

segprint:	null
	stx2	segx2			"save return
	stx0	segx0			"and x0

	lda	segno
	sta	ptsegno			set seg # to print
	tsx2	ptprint			print segment header and page table
	tra	segerr

	szn	cursdw+1			Get word 2 of  DBR.
	tmi	segend			Ignore if high-order bit ON.

	eax0	0

segnewpg:					" Here to get new page to dump.
	lda	=h      "			Blank out absolute address.
	sta	line			..

	eaq	0,0			Get offset.
	tsx2	apnd			Get first word of this block.
	arg	cursdw
	tra	seger-1,au		if error, dispatch on it

	cmpa	=-1			(-1) => page not in core.
	tze	no_abs_addr		If not in core blank addr.
	ldq	cursdw+1			Second word of SDW in Q
	canq	sdw.unpaged,dl		Unpaged segment?
	tze	*+2			If not, print high-order address
	als	6			Make addr on a zero bound again.
	tsx2	octwd			fill in abs addr
	sta	line
no_abs_addr:
	eaa	0,0			add offset to line
	tsx2	octwd
	ldq	=h      "
	llr	72-12
	sta	line+1
	stq	line+2

	tsx2	ptblock			"print 8 words
	zero	fetchout,8

	eax0	8,0			Up offset to next 8 word block.
	tnz	segnewpg

segend:					"end of segment
segx2:	eax2	*			"restore xrs
segx0:	eax0	*
	stz	ptsegno
	tra	1,2

segerr:	ldx2	=-1,du			"move back x2 for error return
	asx2	segx2
	tra	segend

seger:	tra	segerr			"trouble with segment
	tra	segbmpp			"trouble with page
	tra	segend			"off end

segbmpp:	eax0	1024,0			go to next page
	anx0	=o776000,du
	tze	segend

	tsx2	space			say page missing
	lda	nsegpm			set missing page message
	sta	line+3			..
	lda	nsegpm+1			..
	sta	line+4			..
	tsx2	print
	tra	segnewpg

segno:	bss	,1

	even
cursdw:	bss	,2

"
" Print segment heading and page table.

ptprint:	
	stx2	ptpx2			save XRs
	stx1	ptpx1

	tsx2	headform			start new page
	tsx2	print_hdr			Print SDW header.
	desc6a	ndseg_hdr2,60		..

	lda	segno			Get SDW for segment.
	tsx2	getsdw			..
	tra	ptperr
	tra	ptperr
	staq	cursdw			Save SDW.

	ana	-1,du			Mask address.
	cmpa	-1,du			If it is -1, skip this segment.
	tze	ptperr			..

	lda	cursdw			print the SDW.
	tsx2	ptsdw			..
	tsx2	space			..
	tsx2	print			..

	ldaq	cursdw
	canq	sdw.unpaged,dl		If not paged, return
	tnz	ptpend
	cana	sdw.df,dl			or if segment fault
	tze	ptpend			return
	cana	=o777777770000		Check if segfault happened
	tze	ptpend			Tra if SDW.ADDR = 0.

	anq	sdw.bound,du		Clear all but BOUND field.
	qrl	3+6			Bound/64 in QU.
	eaq	1+ast_size,qu		QU contains number of words in ASTE + PT.
	stq	ptstop			Save for checking end.

	tsx2	print

	lda	cursdw			Get addr of 1st PTW.
	arl	sdw.add_shift		Right justify in A.
	sbla	ast_size,dl		Get absolute address of ASTE.
	als	12			Position for address of SDW.
	stca	ptpsdw,74			Set SDW to ASTE and page table.

	lda	=haste  "			Print ASTE header
	sta	line+1
	stc1	ptpastsw			Set AST entry switch

	eax1	0			X1 is offset into AST + PT.
	tra	ptp8			print block of AST entry

ptloop:	eax1	8,1			Count 8 words
	cmpx1	ptstop			Are we finished?
	tpl	ptpend			Exit when finished

	cmpx1	ast_size,du		Still printing ASTE?
	tmi	ptpnohd			If so, continue.

	szn	ptpastsw			Did we just print AST entry
	tze	ptpnohd			if not, skip printing header
	stz	ptpastsw			clear AST entry switch
	tsx2	space			Now print page table line heading
	ldaq	npagetab
	sta	line+4
	stq	line+5
	tsx2	print
	tsx2	space

	eax1	ast_size			Set X1 to beginning of page table.

ptpnohd:	eaa	-ast_size,1		Get page table offset
	tsx2	octwd			Convert to octal
	tsx2	bzel
	sta	line+1

ptp8:	eaq	0,1			Offset in QU.
	tsx2	get			Grab 8 words.
	arg	ptpsdw
	zero	ptbuff,8
	tra	ptpend

	tsx2	ptblock			print the block of 8 words
	zero	ptpiw,8			..
	tra	ptloop			and continue

ptperr:	ldx2	-1,du			Force error return.
	asx2	ptpx2			..

ptpend:
	tsx2	space
	tsx2	print			"slew

ptpx2:	eax2	*			Restore XRs.
ptpx1:	eax1	*
	tra	1,2

ptstop:	arg	0
ptpastsw:	bss	,1

	even
ptpsdw:	vfd	24/0,9/0,3/sdw.df,1/0,14/((256+ast_size+8)/16)-1,o6/72
ptpiw:	its	pgm,ptbuff
ptbuff:	bss	,8

"
"entry form switch reading to dump stack

stackdump: null
	lda	arg+1			see if ring req.
	cmpa	=h  ring
	tnz	sknoring
	lda	arg+2			is there 2nd arg?
	cmpa	=-1
	tze	qm

	lda	cmdbr+1			get dbr stack base
	ana	sdw.entry_bound,dl
	als	3
	tze	nostackbase
	adla	arg+2			get stack this ring
	ldq	arg+3			move offset down
	stq	arg+2
	tra	skgotsegno

sknoring:				"come here to sknore
	eax7	1			get arg #
	tsx2	collect_segname
skgotsegno:
	cmpa	=-1
	tnz	*+3			"if not given
	tsx2	sptrace			Use  sp
	tra	cycle

	als	18
	ldq	arg+2			"get stack offset
	qls	18
	cmpq	=-1,du			"if no offset given,
	tnz	sktrace
	eax2	0,au
	cmpx2	com|prs+6*2		"is this stack in mach. cond.?
	tnz	sktrace			"if so,
	ldq	com|prs+6*2+1		"use that offset
sktrace:
	tsx2	stacktrace		"trace the stack
	tra	cycle

nostackbase:
	tsx2	erpt
	acc	"no dbr stack base"
	tra	cycle

" 

sptrace:	null				"here to trace from sp
	ldaq	com|prs+6*2		Get PR6 (sp).
	canq	=o000017,du		Check for mod 16
	tnz	0,2

stacktrace: stx2	skx2			"here to trace stack
	ana	=-1,du
	sta	segno
	anq	=-1,du
	stq	skoff
	tsx2	ptprint			print header and page table
	tra	skx2

	lda	=o43,dl			Make ITS modifier in segment number.
	stca	segno,07			..

	ldq	skoff
	cmpq	=-1,du			if offset not given, find one
	tnz	skng
	eaq	stack_header.stack_begin_ptr	No offset, assume stack_begin_ptr.
	tsx2	stackfetch		Fetch and check ITS pair.
	nop	skx2			..
	stq	skoff			Set stack offset.

skng:	eax0	0			zero stack counter

" Follow stack back to the beginning.

skbkl:	ldq	skoff			Get current offset.
	eaq	stack_frame.prev_sp,qu	Get pointer to previous frame.
	tsx2	stackfetch		..
	tpl	skbkdn			Must be < current offset.
	stq	skoffn			Save offset of previous frame.

	eaq	stack_frame.next_sp,qu	Get foward pointer of back frame
	tsx2	stackfetch		..
	tnz	skbkdn			Must be same as current offset.

	lda	skoffn			Passed tests, go back one
	sta	skoff
	eax0	-1,0
	tra	skbkl

" At beginning of stack. Go forward, printing each frame.

skbkdn:	szn	skoff			First frame found, is it a zero
	tze	skflp
	eax0	-1,0			if not, print 0 th here as a frame
	lda	skoff
	sta	skoffn
	stz	skoff
	tra	skpt

skflp:	ldq	skoff			Get bound of stack frame
	eaq	stack_frame.next_sp,qu
	tsx2	stackfetch
	tmoz	sklst			Must be > current offset.
	stq	skoffn			if ok, set as next

skpt:	tsx2	frameprint		print stack frame

	lda	skoffn			move ahead
	sta	skoff
	eax0	1,0
	tra	skflp

sklst:	lda	=o377777,du		"print remainder of stack
	sta	skoffn
	tsx2	frameprint

skx2:	tra	*

skoff:	oct	0			"offset of current stack frame
skoffn:	oct	0			"offset of next stack frame


"

stackfetch:
	stx2	skfx2		Save X2.

	tsx2	apnd		Perform appending simulation.
	arg	cursdw
	tra	skferr

	ldaq	fetchout,*	Get ITS pair.
	ana	=o777777000077	Mask segno and modifier.
	cmpa	segno		Must be correct segno and ITS modifier.
	tnz	skferr		..

	canq	=o17,du		Offset must be 0 mod 16.
	tnz	skferr		..

skfx2:	eax2	*		Restore X2.

	anq	=-1,du		Mask to leave only offset.
	cmpq	skoff		Compare against offset.
	tra	0,2		Return with indicators set.

skferr:	ldx2	skfx2		Restore X2.
	tra	0,2*		Force error return.

" 
"frameprint subroutine
"print segno from skoff to skoffn, x0 =frameno

frameprint: 
	stx2	frameretn
	tsx2	space
	tsx2	print
	ldaq	nframe			"frame heading
	sta	line+5
	stq	line+5+1
	ldq	=hplus  "
	eaa	0,0
	tpl	*+3			"stack position is positive
	ldq	=hminus "
	neg
	stq	line+7
	tsx2	octwd
	sta	line+8

	ldq	skoff
	eaq	stack_frame.return_ptr,qu	Use return pointer
	tsx2	apnd			get control double word
	arg	cursdw
	tra	nofrnm

	ldaq	fetchout,*
	sta	framecr

	tsx2	getsdw			get SDW for segment
	tra	frameslt
	tra	frameslt
	tsx2	getsstntname		"get segment name
	desc6a	line+9(4),72
	tra	*+2
	tra	nofrnm
frameslt:	lda	framecr
	tsx2	getsltname
	desc6a	line+9(4),72
	tra	*+1

nofrnm:	tsx2	print			frame heading
	tsx2	space
	tsx2	print			"slew
	ldx1	skoff
frameline: 				"new line to be printed
	eaa	0,1			"fill offset in line
	tsx2	octwd
	sta	line
	eaa	0,1
	sbla	skoff			"relative locn within frame
	tsx2	octwd
	ldq	=h      "
	llr	72-12
	sta	line+1
	stq	line+2

	eaq	0,1			Get pointer to this line.
	tsx2	apnd
	arg	cursdw
	tra	framer

	tsx2	ptblock			"print line
	zero	fetchout,8

framenl:	eax1	8,1			"go to next line
	cmpx1	skoffn
	tmi	frameline

frameretn: tra	0			return

framer:	cmpa	=2,du			"if page error, try again
	tze	framenl
	tra	frameretn			"else give up

framecr:	bss	,1

"
" These are GE BCD constants.

npr_hdr:	bci	'pr    r    seg     word  bits'

ndbr_hdr:	bci	'dbr  addr  bound u stack'

nppr_hdr:	bci	'ppr  prr   psr      ic'

ncb_hdr:	bci	'coreblocks:   first  num'

nmcm_hdr:	bci	'memory controller masks'

namptw_hdr:
	bci	' addr    m   pointer    page    f/e  usage'

namsdw_hdr:
	bci	'  addr   r1r2r3     bound  access     cl  pointer  f/e  usage'

nouhistreg_hdr:
	bci	'                  ou   history registers '
ncuhistreg_hdr:
	bci	'                  cu   history registers '
neishistreg_hdr:
	bci	'                  du   history registers '
napuhistreg_hdr:
	bci	'                 apu   history registers '

ndseg_hdr1:
	bci	'                     descriptor  segment'

ndseg_hdr2:
	bci	'  addr   r1r2r3  f  bound  access     cl    segment     name'


npr0:	bci	'   ap (0)   '
npr1:	bci	'   ab (1)   '
npr2:	bci	'   bp (2)   '
npr3:	bci	'   bb (3)   '
npr4:	bci	'   lp (4)   '
npr5:	bci	'   lb (5)   '
npr6:	bci	'   sp (6)   '
npr7:	bci	'   sb (7)   '


	even
npagetab:	bci	' page table '
	even
nframe:	bci	'stack frame '
	even
notincore: bci	'not in core '
na:	bci	'a     '
nq:	bci	'q     '
nexp:	bci	'exp   '
ntimer:	bci	'timer '
nind:	bci	'ind   '
nx0:	bci	'x0    '
nx1:	bci	'x1    '
nx2:	bci	'x2    '
nx3:	bci	'x3    '
nx4:	bci	'x4    '
nx5:	bci	'x5    '
nx6:	bci	'x6    '
nx7:	bci	'x7    '
nmode:	bci	'mode  '
nfault:	bci	'fault '
nintrps:	bci	'inter '
nbar:	bci	'bar   '
nclock:	bci	'clock '

	even
nno:	bci	'   no '
nyes:	bci	'  yes '
	even
nsegno:	bci	'segment     '
nsegpm:	bci	'page missing'
nheading:	bci	'1  Multics segment dump '
	equ	nheading_lth,*-nheading

" 

	include	stack_header
	include	stack_frame
	include	bos_sdw
	include	mc

" 
	include	bos_page_info
	include	apte
	include	state_equs
	include	proc
	include	fill

" 
	include	sst
	include	aste
	include	sstnt
" 
	include	eis_micro_ops

	include	configp
	include	bos_sstnt_man
	include	segname
	include	apnd_equ
	include	pt_equ
	include	sstn_equ
	include	bos_tv
	include	bos_common


	end
"
"
"                                          -----------------------------------------------------------
"
"
"
" Historical Background
"
" This edition of the Multics software materials and documentation is provided and donated
" to Massachusetts Institute of Technology by Group Bull including Bull HN Information Systems Inc. 
" as a contribution to computer science knowledge.  
" This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
" Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell Bull Inc., Groupe Bull
" and Bull HN Information Systems Inc. to the development of this operating system. 
" Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
" renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
" of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture for
" managing computer hardware properly and for executing programs. Many subsequent operating systems
" incorporated Multics principles.
" Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
" as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .
"
"                                          -----------------------------------------------------------
"
" Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
" fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
" and that both the copyright notice and historical background and this permission notice appear in supporting
" documentation, and that the names of MIT, HIS, Bull or Bull HN not be used in advertising or publicity pertaining
" to distribution of the programs without specific prior written permission.
"    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
"    Copyright 2006 by Bull HN Information Systems Inc.
"    Copyright 2006 by Bull SAS
"    All Rights Reserved
"
"