" ***********************************************************
" *                                                         *
" * Copyright, (C) Honeywell Information Systems Inc., 1982 *
" *                                                         *
" * Copyright (c) 1972 by Massachusetts Institute of        *
" * Technology and Honeywell Information Systems, Inc.      *
" *                                                         *
" ***********************************************************

"	TST3BT  - Bossified by BSG and SDS, 12/17/79
"
" Last modified by Sherman D. Sprague 2/11/81 
" Last modified by Sherman D. Sprague 7/16/81 to fix a bug when using a connsole on a channel higher than 27.
" Modified November 1981 by C. Hornig to not use IOM rel mode.


"	Layout of buffers in tmp

	equ	inbuflen,8192
	equ	outbuflen,8192
	equ	inbuf,0
	equ	otbuf,inbuf+inbuflen
	equ	bufend,otbuf+outbuflen

"	Tape opcodes

	bool	rewind,70
	bool	forward_space_file,45
	bool	back_space_record,46
	bool	read_tape_binary,5

	bool	write_tty,13

"
	include	bosequ
	include	bos_toequ
	include	pt_equ

"
	macro	tape_io
	tsx2	xio_wait
	zero	&2
	zero	tapeno,&1
	tra	*-3	      retry on error
	&end

"
"      no revision, modification, or changes shall be made to this
"      document without the approval of a manager of test and
"      diagnostics, computer operations phoenix.
"
"      suggestions and criticisms relative to content, purpose, or
"      use of this program are invited.  information on the
"      applicable items listed below is requested.
"
"      1.  program hang-ups, errors, include
"          console log, memory dump, and field
"          engineers description of the problem.
"
"      2.  options that dont work as described in the
"          documentation.
"
"      3.  incorrect printouts.
"
"      4.  incorrect or incomplete documentation.
"
"      all correspondence should be directed on form ck97 to
"
"                   manager of systems t&d engineering
"                   honeywell information systems inc.
"                   computer operations phoenix  b-111
"                   13430 north black canyon highway
"                   phoenix, arizona. 85029
"
"*******************
"	ttls	3bt program description
	rem	
"                         *table of contents*
"
"**********************************************************************
"                   **section a - program abstract**                  *
"**********************************************************************
"
"   1.0  identification
"   2.0  purpose
"   3.0  restrictions
"   4.0  operating procedures
"   5.0  error indications
"
"
"
"**********************************************************************
"           **section b - detailed program description**              *
"**********************************************************************
"
"   1.0   3bt program description
"
"
"

"**********************************************************************
"                    section a - program abstract                     *
"**********************************************************************
"
"   1.0  identification
"     1.1  3bt - 6000/355 t&d bootload             58008404
"     1.2  related drawings
"       1.2.1  eps-1 device interface adapter      58001131
"       1.2.2  eps-1 355 intercomputer adapter     43a219612
"       1.2.3  eps-1 6000b direct channel          43a239853
"
"   2.0  purpose
"
"     2.1  this program functions as a loader or 355 off-line t&d
"          executives and test programs.  it allows the operator to
"          test the 355 from the 6000.
"
"
"   3.0  restrictions
"
"     3.1  this program runs in the single program mode under mon-4
"          control.  it cannot run in conert with other programs.
"
"
"   4.0  operating instructions
"
"     4.1  both the off-line t&d tape and the 355 pol binary deck
"          tape must be mounted to run 3bt.  pgm 3bt is configu-
"          red and called in as follows
"
"             if a dia is utilized in the 355,
"                config dia cc(t,s)mbx base, ^pgm3bt^
"
"             if a n ica,
"                config ica cc(t,s)mbx base, p^pgm3bt^
"
"           where - cc is channel number (psuedo ch# in case of ica)
"                   t is terminate int cell no.
"                   s is special int cel no.
"                   mbx base is base adrs of interrupt vectors
"                   p is system controller port no. (ica is attached
"                     to s.c. port)
"
"
"   5.0  error indications
"
"     5.1  if an error occurs, the 355 io package sends an interrupt
"          to the 6000.  3bt reads the communications area in 355
"          core (see sec b, para 1.0) which indicates output to the
"          printer, performs the service (outputs error msg) and goes
"          to "wait".
"

"**********************************************************************
"            **section b - detailed program description               *
"**********************************************************************
"
"   1.0  3bt detailed program description
"
"        3bt starts by setting a flag to indicate primitive function
"        tests will be sent to the 355 first.  the 6000 system con-
"        figuration is then obtained from monitor.  at this point,
"        3bt determines whether the 355 is connected to the 6000
"        through a dia or an ica.  the dia is connected to the 6000
"        iom via a direct channel.  the ica is connected directly
"        to a system controller port.
"
"        3bt next determines the iom & channel number of the tape
"        system on which the 355 program tape (pol) resides.  the
"        operator is asked the device number of the pol tape.  at
"        this point, 3bt asks the operator which executive he wishes
"        to load (ios or bos).
"
"
"        primitive function tests
"
"        with the exec id in hand, 3bt rewinds the pol tape, and reads
"        in the vector file.  the card image vector data is converted
"        to full binary & sent to the 355 memory, location zero.  in
"        the same manner, the primitive function test (pft), file-1
"        is read from the pol tape, converted and sent to 355 memory
"        (adrs 4000).  the pft's are executed by sending a lvl-3 inter-
"        rupt to the 355 (which causes control to be vectored to
"        the pft).  when they have run to completion, a routine at the
"        end of pft-1 sends a lvl-3 to the 6000 to signal completion.
"        if this fails to arrive in 4 seconds, an error is assumed and
"        a message is output on the console.
"
"        file pft-2 is sent over and executed in the same way.  however,
"        pft-2 is loaded starting at location 1000 in 355 core.
"
"
"        loader, io package and executive
"
"        before the loader is sent to the 355, a vector is sent over
"        to location 63.  this vectors control to the loader when
"        the lvl-3 is sent after the loader is sent.  the loader resides
"        at location 1000 in the 355.
"
"        at this point, the io package is read from the pol tape and
"        sent to the 355 in card image format.  the loader, just prev-
"        iously sent to the 355 accepts the io package in 308 word
"        blocks, strips the card image information out, stores the
"        data in the appropriate buffer location (starting at 4000),
"        sends a lvl-3 interrupt to the 6000 indicating readiness for
"        the next block of data, and sits in a disconnect waiting for
"        the 6000 to send a lvl-3 interrupt.  this interrupt vectors
"        control back to the loader.  when the loader encounters a
"        transfer card, it branches to the address on the transfer
"        card which starts the io pkg functioning.
"
"        finally, the indicated exec is read from tape by 3bt.  the
"        io pkg contains a duplicate of the loader, and this routine
"        accepts and stores the exec in the 355 in the same manner
"        as the io pkg is loaded, except the exec is loaded at 1000.
"        at completion of exec load, control is given to the exec
"        which then initializes in preparation for io testing.  3bt
"        then goes into a "wait" routine, where it stays until inter-
"        rupted with a lvl-7 interrupt.
"
"        if the operator wants to run a specific test or communicate
"        with the 355 software, he must press the request button.
"        this causes monitor to vetor into 3bt at subroutine "fnp_opt".
"        "fnp_opt" sends a lvl-7 interrupt to the 355 which tells the
"        355 software that the operator wishes to communicate, and
"        goes back into "wait".
"
"        the 355 then sends  lvl-7 interrupt back, which causes moni-
"        tor to vector into subroutine "lvl-7".  this routine reads
"        a 4-word communication block in the 355 which is established
"        by the io package to identify 355 requests.  word 1 is 355
"        internal info, word 2 is the address of the buffer where the
"        data is to be obtained from or written into, word 3 is the
"        number of words to tranfer and word 4 is a code which identi-
"        fies the action to be taken as follows
"
"             1 = console write
"             2 = console read
"             3 = output message to printer
"             4 = read a program from pol tape & send to 355.
"                 program id is in word 3 in this case.
"             5 = signal to 6000 that an error occurred with
"                 the last buffer received.
"
"        3bt evaluates the 4 word comm area & performs the request as
"        described above
	rem	
	rem	
"
start:	absa	0		get abs program base
	als	6
	sta	base

	stx2	x2
	tsx2	initint
	arg	fnp_opt
	tsx2	init_io
	tsx2	ttyinit
	arg	fnp_opt

	lda	com|ttychanno
	sta	tty_chan	      save tty chan no
	als	9
	stba	typcw+1,40

	ldx2	x2	 pick up command line args
	ldx7	mem|0,2	 address parsed args
	lda	mem|1,7	 get possible fnp tag
	cmpa	=-1
	tze	default_fnp_tag
	cmpa	=h     a
	tmi	bad_fnp_tag
	cmpa	=h     h
	tpnz	bad_fnp_tag
	tra	*+2
default_fnp_tag:
	lda	=h     a
	sbla	=h     a
	adla	1,dl
	sta	fnp_tag

	lda	mem|arglen+3,7 get possible tape no. in decimal
	tpl	*+2
	lda 	2,dl	 default tape 2
	als	12
	stca	tapeno,04	 store device no.
"
"	Find appropriate info from FNP card.
"
	stc1	conf355err      set error switch
	lda	fnp_tag	      get FNP tag
	tsx2	conf355	      get FNP info
	tra	finish	      error return

	lda	mbx_offset
	als	18
	adla	=o3400,du
	sta	mbxptr+1

	lda	diapcw+1	      get iom and chan no
	arl	9
	ana	=o777,du
	sta	fnp_chan_info

"
"	Get room for tape and FNP buffers.
"
	lda	outbuflen+inbuflen,du
	tsx2	makesdw
	tra	finish		check with operator

	staq	ds|2*tmp	      store in DSEG
	cams	0	      clear associative memory

	absa	tmp|0
	als	6
	sta	buffer_base     save abs addr of buffer seg

	lda	=h ptpkg		load printer package
	eaq	pt_org
	tsx2	ldcom
	tra	finish

	tsx2	initprint		initialize the printer pkg

	tsx2	itaper	      set up tape for reading
	arg	tapeno

askex:	tsx2	erpt
	acc	"input exec you wish (ios or bos)..xxx"
	tsx2	readtty
	tra	askex		null response
	tsx2	scan		parse answer
	lda	arg
	cmpa	=h   bos
	tnz	*+4             no
	lda	bos
	sta	exec            store exec id
	tra	denck
	cmpa	=h   ios
	tnz	*+4
	lda	ios             yes...get pgm no.
	sta	exec
	tra	denck
	cmpa	=h  quit
	tze	finish
	tra	askex
"
denck:	tape_io	rewind
	lda	vect            vector id
	sta	testid          store it for tape read
	tsx7	tpread          go read vectors for xfer to 355
	tsx2	connect_iom
	zero	maskpcw
	stz	ldcon
	tsx7	fbc             convert file to full binary
"	ttls	** 6000 to 355 program transmission **
"
"**********************************************************************
"              transmit int & fault vectors to 355
"**********************************************************************
	tsx7	cwbld           build "dcw" list
	lda	=o100000,du     355 char adrs & data adrs
	sta	ctrwd           store it
	ldx6	0,du            zero index
vlp:	szn	dcwcnt          more io?
	tze	p1send
	tsx7	dxfr            build ctrwd & 6000 mbx word
	tsx7	store_mbx_word  store mbx word in core
	lcq	1,du
	asq	dcwcnt
	tsx2	dio_wait
	tra	vlp
"
"
"**********************************************************************
"      read & transfer prim function test #1                          *
"**********************************************************************
p1send:	lda	pft1            pft #1 id (96)
	sta	testid
	tsx7	tpread          go read pft #1
	stz	ldcon
	tsx7	fbc             convert to full binary
	tsx7	cwbld           build "dcw" list
	lda	=o104000,du
	sta	ctrwd           355 adrs
	ldx6	0,du
p1lp:	szn	dcwcnt          more io?
	tze	p1lp1           no..done..go send lvl-3 to kick pft1 off
	tsx7	dxfr            build ctrwd & 6000 mbx word
	tsx7	store_mbx_word  store mailbox word in core
	lcq	1,du
	asq	dcwcnt
	tsx2	dio_wait
	tra	p1lp
"
p1lp1:	tsx7	l3              send lvl-3 int & exp one in return
"
"**********************************************************************
"      read pft-2 in & transmit to 355 then set ti to 355 to run it   *
"**********************************************************************
p2send:	lda	pft2            pft #2 id (97)
	sta	testid
	tsx7	tpread          read in pft #2
	stz	ldcon
	tsx7	fbc             convert to full binary
	tsx7	cwbld           build "dcw" list
	lda	=o101000,du
	sta	ctrwd           355 adrs of core pft
	ldx6	0,du
p2lp:	szn	dcwcnt          more io?
	tze	p2lp2           done-go send l3 to execute pft2
	tsx7	dxfr            build ctrwd & 6000 mbx word
	tsx7	store_mbx_word  store mbx word
	lcq	1,du
	asq	dcwcnt
	tsx2	dio_wait
	tra	p2lp

p2lp2:	tsx7	l3              send lvl-3 int. exp ti in return
"
"**********************************************************************
"      read loader in & transmit to 355-then send loader              *
"**********************************************************************
"
"
"
ldrs:	stz	execin
	tsx7	ivl             send vector and loader
"
"**********************************************************************
"      read io package and exec in & transmit to 355                  *
"**********************************************************************
rdioe:	lda	iopkg
	sta	testid
	stc1	ldcon           set loader present flag
	tsx7	blkio           perform io to send io pkg
"
"  *** now send requested exec ***
"
	lda	exec            exec id
	sta	testid          put appropriate exec id in "testid"
	stc1	ldcon           loader present flag
	tsx7	blkio           io to send exec
	tra	wait            when returned here, 355 is fully loaded
"**********************************************************************
prog:	szn	nxtst           next test?
	tnz	progn           yes
	lda	testid          see if prg 85 or 86
	cmpa	=h850000        prg85?
	tze	prog1           yes
	cmpa	=h860000        prg86?
	tze	prog2           yes
	cmpa	=h200000        bos exec?
	tze	prog3           yes
	cmpa	=hio0000        ios exec?
	tze	prog3           yes
progn:	stc1	ldcon           none of the above
	tsx7	blkio           get & send requested pgm
	tra	wait            go to sleep
"
prog1:	tsx7	ivl             send vector & loader
	lda	=h850000
	sta	testid          restore correct id
	stz	execin
	stc1	ldcon           set loader present flag
	tsx7	blkio           send pgm85
	stc1	p8586           set flag which indicates pgm85 or pgm86
	tra	wait            go to sleep
prog2:	tsx7	ivl
	lda	=h860000
	sta	testid
	stc1	ldcon
	stz	execin
	tsx7	blkio           send pgm86
	stc1	p8586           set pgm85 or 86 flag
	tra	wait            go to sleep
prog3:	lda	testid          load exec id
	sta	exec            save it
	tra	ldrs            send vect-loader-iopkg-exec
"	ttls	** level 7 entry point **
"**********************************************************************
"      this routine is entered if a lvl-7 interrupt occurs when no    *
"      slave io is in progress.  it signals a service request from    *
"      the 355.  3bt reads the 4 word communication block in the 355  *
"      core & performs the required service.                          *
"**********************************************************************
lvl7:	tsx7	rdidb           go read 4-word block
	lda	idb+2           get key wd
	ana	7,dl
	cmpa	1,dl            1=console wrt
	tze	cpwrt           yes..
	cmpa	2,dl            2=console read
	tze	conrd           yes..
	cmpa	3,dl            3=output msg to printer
	tze	cpwrt           yes..
	cmpa	4,dl            4=read req program
	tze	rdpgm
	sta	temp		save for error mess
	tsx2	erpt
	acc	"undefined service request from 355  ^d"
	arg	temp
	tra	finish
"
"**********************************************************************
"           ** read a program from tape (key value = 4) **            *
"
rdpgm:	ldx1	idb+2           pgm id in upper half
	tnz	spec            id present
	stc1	nxtst           value = 0. means next pgm on tape.
	tra	prog            read next test in
"
spec:	anx1	=o777700,du
	stx1	testid
	stz	nxtst           zero next test flag
	tra	prog            go read req test in
"
"**********************************************************************
"           ** output message on printer or typewriter **             *
"
cpwrt:	lda	=h??????        pad buffer
	ldx1	0,du
	sta	conb1,1
	adlx1	1,du
	cmpx1	64,du           done?
	tmi	*-3             no
	stz	ign             zero ignore flag
	lxl1	idb+1           355 msg adrs
	orx1	=o100000,du     char adrs
	stx1	ccw             adrs in control word
	lda	idb+2           get tally
	arl	18              to a-lower
	cana	1,dl            odd tally?
	tze	*+3             even
	ada	1,dl            odd-make even
	stc1	ign             set ignore flag
	arl	1               halve tally (6000 equiv)
	stca	ccw,03          store tally in 355 control word
	als	18
	sta	wktal           store working tally
	eaa	ccw             buffer adrs
	adla	base
	ora	=o75,dl         or in read cmd
	sta	mbxwd
	tsx7	store_mbx_word  store mbx word
	tsx2	dio_wait	      read msg into interim buffer
	szn	ign             odd 355 tally?
	tze	*+5             no
	ldx1	=o171717,du     yes-store ignores
	lda	wktal           tally
	sba	1,du            less 1
	sxl1	conb1,au        store ignores
"  put appropriate addresses in instructions for console wrt or print
	lda	idb+2
	ana	7,dl            isol key
	cmpa	1,dl            console key?
	tnz	cn1a            no..printer

	lda	wktal	      get tally
	arl	18
	stca	tydcw,07	      put in dcw

ttyretry: tsx2	connect_iom
	zero	typcw,tydcw

	tsx2	check_status
	arg	tty_chan
	zero
	tra	ttyretry

	tra	cr1
"
cn1a:	mlr	(),(),fill(020)
	desc6a	conb1,64*6
	desc6a	line,31*6
	tsx2	print_edited
"
"      now send lvl-3 int to wake 355 up & let him know were done
"
	tra	cr1             to l-3 routine & then "wait"
"
"**********************************************************************
"      console read routine
"
conrd:	stz	ign             zero ignore flag
	mlr	(),(),fill(020)
	desc6a	*,0
	desc6a	line,80

	tsx2	readtty
	stz	line

	tsx2	scan	      check for quit
	lda	arg
	cmpa	=h  quit
	tze	finish

	tsx2	stripg
	desc6a	line,80
	
	mlr	(rl),(),fill(0)	I just write these pgms,
				"not invent them.
	desc6a	line,al
	desc6a	crdbf,32*6

"
	lda	idb+2           get 355 tally
	arl	18
	cana	1,dl            odd tally?
	tze	*+3             no
	adla	1,dl            yes-incr by 1
	stc1	ign             set ignore flag
	arl	1               halve tally(6000 equiv)
	stca	crcw,07         store tally in icw
	lxl1	idb+1           355 store adrs
	orx1	=o100000,du     char adrs
	stx1	crcw            put in 355 dcw
	eaa	crcw
	ora	=o76,dl         wrt cmd
	adla	base
	sta	mbxwd
	tsx7	store_mbx_word
	szn	ign             ign set?
	tze	*+4             no
	ldx1	=o171717,du     yes
	lxl2	crcw
	sxl1	crdbf-1,2
	tsx2	dio_wait	      send console msg to 355
"
"  send lvl-3 int to 355 to let him know we're done
"
cr1:	lda	=o371,dl
	sta	mbxwd
	tsx7	store_mbx_word  store 6000 mbx word
	tsx7	dio
	tra	wait
"	ttls	** common subroutines **
"**********************************************************************
"              tape read io subroutine                                *
"**********************************************************************
"
tpread:	stx7	rdout           zero flags
	stz	past
tpr1:	stz	frec
	stz	delta
	ldx1	0,du            zero data buffers
	stz	tmp|inbuf,1
	adlx1	1,du
	cmpx1	bufend-inbuf,du
	tmi	*-3
	ldx3	0,du
	lda	=v18/inbuf,18/320"
read_more_tape:
	ora	32768*tmp,du    make it be in seg tmp !
	stca	*+2,70
rdio:	tsx2	xio_wait
	vfd	18/*-*,12/320,6/0
	zero	tapeno,read_tape_binary
	tra	*+2
	tra	no_tape_error
	staq	status_temp
	ana	=o170000,du     isolate major sts
	tze	sfchk           ms=0 chk for sys flts
	cmpa	=o010000,du     Subsystem busy?
	tze	rdio	      Yes, loop.
	cmpa	=o040000,du     not rdy...eof?
	tze	endrd           yes...done reading
	cmpa	=o030000,du     data alert?
	tnz	tperr           no-something else
	lda	status_temp     yes-is it parity?
	ana	=o003400,du     check for any parity
	tze	tperr           not parity-make full error check
	adlx3	1,du            par err-incr counter
	cmpx3	10,du           10 times?
	tmi	retry           no-try again
	tsx2	erpt
	acc	"Can't read the tape, PARITIES !"
	tra	finish

retry:	tape_io	back_space_record
	tra	rdio            try again
"
"
tperr:	tsx7	error	      a tape error other than parity occurred
"		                go check for errors & output msg
"
"   only take xfer above if error...should not return
"
sfchk:	lda	status_temp+1   check for other faults
	ana	=o007777,du
	tnz	tperr           got errors
	lda	status_temp
	ana	=o770000,dl     chnl errors
	tnz	tperr           got errors
no_tape_error:
"**********************************************************************
"          tape read data handling                                    *
"**********************************************************************
datah:	szn	frec            first record?
	tnz	cont            no
	stc1	frec            set flag
	eaa	inbuf
	sta	delta
	ldq	delta           rel bfr adrs
	lda	tmp|3,qu        4th word sb  objec
	cmpa	=h objec        object card?
	tnz	prob1           1st rec but no object card
	lda	tmp|14,qu       id word
	ana	=o777700,du     retain 2-char name
	szn	nxtst           next prg on tape to be sent?
	tze	datah1          no-specific test
	cmpa	=h850000        prg 85?
	tze	datah2          yes
	cmpa	=h860000        prg 86?
	tze	datah2          yes
	sta	testid
datah1:	cmpa	testid          correct id?
	tze	cont            yes
	tnc	fsftry          its further along on tape
	szn	past            past it..were we before?
	tze	daa             no..set flag & rewind
	lda	testid          yes...not on tape
	ana	-1,du
	ora	=o202020,dl
	sta	temp
	stz	past            zero flag
	tsx2	erpt
	acc	"cannot find prg ^g on this tape. press request then input 'opt355' to get 355 options."
	arg	temp
	tra	wait            go yo wait
daa:	stc1	past            set flag
	tape_io	rewind
	tra	tpr1
"
prob1:	tsx2	erpt
	acc	"pgm with no object card. press eom to rewind & retry"
	tsx2	readtty
	nop
	tra	daa+1           rewind & retry
"
"
"
datah2:	sta	testid          85 or 86 id
	tape_io	back_space_record
	stz	nxtst           zero flag
	tra	prog
"
"
"
cont:	ldq	delta
	lda	tmp|0,qu            get record size
	ana	=o777,dl
	als	18
	ada	1,du            add 1 to account for record id & size
	asa	delta           start of next load point
	ldx3	0,du            zero parity counter
	lda	delta
	tra	read_more_tape
"
"
fsftry:	tsx2	xio_wait
	zero
	zero	tapeno,forward_space_file
	tra	*+2	      error
	tra	tpr1        go read next start of file

	tra	tpr1	      SOMEBODY SHOULD FIGURE THIS OUT
	ana	=o770000,du
	cmpa	=o400000,du
	tnz	fsftry
	tra	tpr1
"
"**********************************************************************
"   if eof encountered come here to see if rec flag set-if not it's a *
"   double eof & end of tape                                          *
"**********************************************************************
"
endrd:	szn	frec            check 1st rec flag
rdout:	tnz	*               set..done with read-return
	lda	testid          not set..dbl eof-end
	ana	=o777700,du
	ora	=o000020202020
	sta	temp
	tsx2	erpt
	acc	"could not find program ^g on tape.. eom to retry"
	arg	temp
	tsx2	readtty
	nop
	tape_io	rewind
	tra	tpr1
"

error:	tsx2	erpt
	acc	"Tape error: ^w ^w"
	arg	status_temp
	arg	status_temp+1

	tsx2	erpt
	acc	"EOM to rewind"
	tsx2	readtty
	nop	0

	tape_io	rewind
	tra	tpr1
"
	even
status_temp:
	oct	0
	oct	0

"**********************************************************************
"       converts input data to send format                            *
"**********************************************************************
fbc:	stx7	fbcr            return
	ldx3	0,du            tally count
	ldx1	0,du            input bfr count
fbl:	lda	tmp|inbuf,1     get a word
	cmpa	=o000016000200  bci?
	tze	bcicd           yes
	cmpa	=o000033000100  binary card?
	tze	bincd           yes
	adlx1	1,du            neither...get next
	cmpx1	otbuf-inbuf,du  in bounds?
	tpl	otside          no..output trouble msg
	tra	fbl             ok
"**********************************************************************
bcicd:	adlx1	2,du
	lda	tmp|inbuf,1     load card type
	cmpa	=h objec        obj card? 
	tze	*+2             yes
	tra	fbcr-1          must be dkend..done
	adlx1	1,du
	tra	fbl             continue
"**********************************************************************
bincd:	ldx2	0,du            card word count
	szn	ldcon           loader conversion?
	tnz	*+2             yes
binl:	adlx1	1,du
	lda	tmp|inbuf,1     get word
	sta	tmp|otbuf,3     store in output buffer
	adlx2	1,du
	adlx3	1,du
	szn	ldcon           loader convert
	tze	*+3             no
	cmpx2	28,du           yes
	tra	*+2
	cmpx2	26,du           basic convert
	tmi	binl            next word
	tra	fbl             done this card
"
	stx3	tally           save tally
fbcr:	tra	*
"
"
otside:	lda	testid          get prg id
	ana	=o777777,du
	ora	=o202020,dl
	sta	temp
	tsx2	erpt
	acc	"exceeded input buffer size while converting prg-^g  indicates bad data from tape."
	arg	temp
	tra	finish

tpdcw:	oct	0               dcw list

"**********************************************************************
"              generates parity bit for mbxwd                         *
"**********************************************************************
parity:	stx7	parr
	ldx1	0,du
	stz	pbit            zero par ctr
	lda	mbxwd           fetch mbx word
par1:	tmi	count           xfer if bit set
	adlx1	1,du
	cmpx1	36,du           bit count-done?
	tze	par2            done
	als	1               no-shift again
	tra	par1
"
count:	aos	pbit            add count
	tra	par1+1
"
par2:	lda	pbit            check for odd or even count
	ana	1,dl
	tnz	parr            odd no. bits
	lda	=o020000,dl     set bit 22 of mbxwd
	orsa	mbxwd
parr:	tra	*               return
"
"
pbit:	oct	0
"**********************************************************************
"              store 6000 mailbox word                                *
"**********************************************************************
store_mbx_word:
	stx7	m45r
	tsx7	parity          go gen parity on mailbox word
	lda	mbxwd
	sta	mbxptr,*
m45r:	tra	*               return
"
"**********************************************************************
"              set-up control words for a write to 355 cmd            *
"**********************************************************************
dxfr:	stx7	dxfrr
	stz	mbxwd           zero mailbox word
	lda	dcwl,6          get correct control word
	stca	mbxwd,70        store adrs of ctrwd
	stca	ctrwd,07        store tally
	ldq	=o76,dl
	stcq	mbxwd,01
	ldx4	mbxwd           get adrs of data or buffer
	lda	ctrwd           get control word
	sta	mem|0,4         store it
dxfrr:	tra	*
"**********************************************************************
"      routine to build a list of pre-control words                   *
"**********************************************************************
cwbld:	stx7	cwr
	ldx6	0,du            zero cw list to start
	stz	dcwl,6
	adlx6	1,du
	cmpx6	32,du           done?
	tmi	*-3             no
	ldx6	0,du
	stz	dao             zero dcw offset
	stz	dcwcnt
dcwl.1:	cmpx3	4096,du         establish tally size
	tze	equ4k           tal=4k
	tmi	les4k           tal<4k
	eaa	otbuf-1         tal>4k
	ada	dao             add adrs offset
	adla	buffer_base
	sta	dcwl,6          store updated adrs
	lda	4096,du
	asa	dao             incr dcw adrs offset
	adlx6	1,du            incr dcw count
	sblx3	4096,du         decr tally
	tra	dcwl.1          restart
"
equ4k:	eaa	otbuf-1         bfr base adrs
	ada	dao             adrs offset
	adla	buffer_base
	sta	dcwl,6          store it
	adlx6	1,du            incr dcw count
	tra	out             done
"
les4k:	eaa	otbuf-1         bfr base adrs
	ada	dao             adrs off set
	adla	buffer_base
	sta	dcwl,6          adrs
	sxl3	dcwl,6          tal
	adlx6	1,du
	tra	out             done
"
out:	stx6	dcwcnt          no. of dcw's
cwr:	tra	*
"
dcwcnt:	oct	0
dao:	oct	0
dcwl:	bss	,32
"**********************************************************************
"              dia i/o routine                                        *
"**********************************************************************
dio:	stx7	dior
	stx6	dio_save_x6
	tsx2	check_fnp_status
	stz	simulated_interrupts
	tsx2	connect_iom
	vfd	18/diapcw
dio_save_x6:
	eax6	*-*
dior:	tra	*
"
comsts:	oct	0
"
"**********************************************************************
"              checks for lvl-7 interrupts                            *
"    Although I changed this to level 3 for Multics - bsg
"**********************************************************************
ic:	stx7	icr
	stx6	ic_save_x6
	rccl	com|low_order_port,* read the clock
	staq	time_temp
	stz	simulated_interrupts
ic_loop:	tsx2	check_fnp_status
	lda	simulated_interrupts
	cana	=o4040,dl		Check for l3
	tnz	ic1             si occurred
	rccl	com|low_order_port,*
	sbaq	time_temp
	div	=1000000
	cmpq	10,dl	      wait ten sec
	tmi	ic_loop
	tsx2	erpt
	acc	"No response from DIA."
	tra	finish
"
ic1:	lda	mbxptr,*	      get mailbox word
	tnz	ic2             error condition
	tra	icr
ic2:	tsx2	erpt
	acc	"Problem with DIA or FNP."
	tra	finish
"
icr:	eax7	*-*
ic_save_x6:
	eax6	*-*
	tra	0,7             return

"	New better subr by BSG

dio_wait:	stx2	diowait_x2
	tsx7	dio
	tsx7	ic
diowait_x2:
	tra	*-*
"
"
"**********************************************************************
"      send lvl-3 int.                                                *
"              will cause pgm sent to 355 to execute. will wait       *
"              while it executes & expect terminate when execution    *
"              complete                                               *
"**********************************************************************
l3:	stx7	l3r
	lda	=o371,dl        set up int lvl & cmd
	sta	mbxwd           store in 6000 mbx word
	tsx7	store_mbx_word  gen cmd parity & store mbx word
	tsx7	dio
	rccl	com|low_order_port,*
	staq	time_temp
l3_loop:	tsx2	check_fnp_status
	lda	simulated_interrupts
	cana	=o40,dl	      lvl-3
	tnz	l3r
	rccl	com|low_order_port,*
	sbaq	time_temp
	div	=1000000	      wait for 10 sec
	cmpq	10,dl
	tmi	l3_loop
	szn	execin          ecec in core?
	tze	l32
	tsx7	rdidb           lvl-3 not there..rd idb in 355
	lda	idb+2
	ana	7,dl            isolate request key
	cmpa	5,dl            data error?
	tze	de              yes
l32:	lda	testid
	ana	=o777700,du
	ora	=o000020202020
	sta	temp
	tsx2	erpt
	acc	"test ^g missing lvl-3 on data block xfer: reason not known"
	arg	temp
	tra	finish
"
de:	aos	ecount          incr error count
	lda	ecount
	cmpa	4,dl            3 times tried?
	tze	de1             yes..output msg & go to wait
	eaa	blkot           no-resend
	ora	=o76,dl
	sta	mbxwd
	tsx7	store_mbx_word
	tra	ioblk           go resend data block
de1:	tsx2	erpt
	acc	"3 tries at transfering data block..recall pgm."
	tra	wait

l3r:	tra	*               return
"
"
"**********************************************************************
"         moves 308 word block of data to blkot                       *
"**********************************************************************
movda:	ldq	noio            no of full block io's performed
	mpy	308*4,dl
	mlr	(pr,ql),()
	desc9a	tmp|otbuf,4*308
	desc9a	blkot,4*308
	aos	noio            done..incr number of io's
	tra	0,7
"**********************************************************************
"       determine no. io's                                            *
"**********************************************************************
talit:	stx7	talitr
	ldq	tally           get total tally
	qrl	18              position in ql
	div	308,dl          will determine no. full block xfers
	stq	dcwcnt          block count
	sta	talrem          remainder is last io tally
talitr:	tra	*               return
"**********************************************************************
"      this routine takes the testid, reads it from tape, converts    *
"      it, sets up the required number of io's & transmits the pgm    *
"      over to the 355 & finally kicks the 355 loader into execution  *
"      after each io.  when 355 sees xfer card it will execute test.  *
"**********************************************************************
blkio:	stx7	blkior          save return adrs
	szn	execin          exec loaded?
	tze	blk0            no-input 1500 buffer
	lda	idb+1           yes-input iopkg indicated buffer adrs
	als	18
	ora	=o100000,du     char adrs
	stca	blk2,70
	stca	blk3,70
	tra	blk1
"
blk0:	lda	=o101500,du
	stca	blk2,70
	stca	blk3,70
blk1:	stz	dcwcnt
	stz	noio
	tsx7	tpread          read pgm from tape
	tsx7	fbc             conversion routine
	tsx7	talit           determine no. io's
blkio1:	szn	dcwcnt          done?
	tze	remio           yes..go see if remaining tally
blk2:	lda	=o101500,du
	ora	=o464,dl
	sta	blkot_cw
	eaa	blkot_cw         io bfr adrs
	ora	=o76,dl         wrt cmd
	ada	base
	sta	mbxwd
	tsx7	store_mbx_word  store mbxwd
	tsx7	movda           move data to blkot
	stz	ecount
	lcq	1,dl
	asq	dcwcnt
ioblk:	tsx2	dio_wait
	tsx7	l3              send lvl-3 to kick ldr off
	tra	blkio1          go see if more
"
remio:	szn	talrem          partial block left?
	tze	blkior          no-return
	lda	talrem          send partial block
blk3:	ora	=o101500,du
	sta	blkot_cw
	ldq	noio
	mpy	308*4,dl        form offset
	lda	talrem
	als	2	      get word count in chars
	mlr	(pr,ql,rl),(rl)
	desc9a	tmp|otbuf,al
	desc9a	blkot,al
	eaa	blkot_cw        6000 mbxwd
	ora	=o76,dl         wrt cmd
	ada	base
	sta	mbxwd
	tsx7	store_mbx_word  gen par & store 6000 mbx word
	tsx2	dio_wait
"
	tsx7	l3              kick off loader with lvl-3
blkior:	tra	*               done-return
"**********************************************************************
"      wait for special from dn355 to establish communications or     *
"      special from operator pushing request.                         *
"**********************************************************************
wait:	stz	simulated_interrupts
wait_some_more:
	stc1	execin          set exec in core flag
	lda	=o10000000
	sta	timout
here:	tsx2	check_fnp_status
	lda	simulated_interrupts
	cana	=o4000,dl	      use silly T&D convention
	tnz	lvl7
	lda	timout
	sbla	1,dl
	sta	timout
	tpl	here
	tsx2	erpt
	acc	"still sleeping ........."
	tra	wait_some_more

"**********************************************************************
"      come here when oper requests fnp_opts.                          *
"**********************************************************************
fnp_opt:	szn	p8586           if 85/86 in, must reload iopkg & an exec
	tze	three_opt            normal communications
	stz	p8586           first zero 85/86 flag
exreq:	tsx2	erpt
	acc	"must reload io pkg and exec. which exec do you want (ios or bos)..."
	tsx2	readtty
	tra	exreq
	tsx2	scan
	lda	arg
	cmpa	=h   bos
	tnz	*+4             no
	lda	=h200000        yes-put test no in exec
	sta	exec
	tra	three_opivl          go load iopkg & bos
	cmpa	=h   ios
	tnz	exreq           no..incorrect input-ask again
	lda	=hio0000        yes..go load iopkg & ios
	sta	exec
	tra	three_opivl          go load 355
"
three_opt:
	lda	=o771,dl        do lvl-7 int to 355
	sta	mbxwd
	tsx7	store_mbx_word  store 6000 mbx word
	tsx7	dio
	tra	wait
"**********************************************************************
"
"
three_opivl:
	tsx7	ivl             set int cell & send loader
	tra	rdioe           load io pkg & exec
"**********************************************************************
"          routine to read idb block from 355                         *
"**********************************************************************
rdidb:	stx7	rdidbr
	stz	idb             zero buffer
	stz	idb+1
	stz	idb+2
	lda	=v18/idb,o18/75
	ada	base
	sta	mbxwd           6000 mbx word
	tsx7	store_mbx_word  gen par & store it
	lda	=o104004000002  355 control word
	sta	idb
	tsx2	dio_wait	      Read 4 word IDB
rdidbr:	tra	*
"**********************************************************************
"      routine to set-up interrupt vector & xmit the loader           *
"**********************************************************************
ivl:	stx7	ivlr
	lda	=o000334000777  vector
	sta	blkot
	lda	=o100062000001
	sta	blkot_cw
	lda	=v18/blkot_cw,o18/76    wrt cmd
	ada	base
	sta	mbxwd
	tsx7	store_mbx_word
	tsx2	dio_wait	      Send vector
	lda	crldr           loader id
	sta	testid
	tsx7	tpread
	stz	ldcon
	tsx7	fbc             conversion routine
	tsx7	cwbld           build "list" of control words
	ldx6	0,du
ivl2:	szn	dcwcnt
	tze	ivl3            done..go send lvl-3
	tsx7	dxfr            build 355 cw & 6000 mbx word
	tsx7	store_mbx_word  store 6000 mbx wd
	lcq	1,du
	asq	dcwcnt
	tsx2	dio_wait	      send loader
	tra	ivl2
ivl3:	tsx7	l3              send lvl-3 int to 355
"
ivlr:	tra	*               return from whence thou cometh

bad_fnp_tag:
	sta	temp
	tsx2	erpt
	acc	"Invalid FNP tag: ^g"
	arg	temp

finish:	lca	1,dl	
x2:	eax2	*-*
	tra	mem|1,2	      return to setup
"
check_fnp_status:
	sreg	cfs_regs
	tsx2	check_special_status
	arg	fnp_chan_info
	tra	cfs_no_special
	lda	=o4000,dl
	orsa	simulated_interrupts
cfs_no_special: 
	tsx2	check_status_no_stat
	arg	fnp_chan_info
	tra	cfn_exit	      no status yes
	nop	0
	lda	=o40,dl
	orsa	simulated_interrupts
cfn_exit:	lreg	cfs_regs
	tra	0,2

	eight
cfs_regs: bss	,8

"
	include	conf355	
"	ttls	** definitions & messages **
vect:	bci	"950000"
pft1:	bci	"960000"
pft2:	bci	"970000"
crldr:	bci	"980000"
iopkg:	bci	"990000"
	bci	"99a000"	       used to 355pkg
bos:	bci	"200000"
ios:	bci	"io0000"
execin:	oct	0
past:	oct	0
testid:	oct	0
frec:	oct	0
mbxwd:	oct	0
time:	oct	0
tapeno:   oct	0
iomno:	oct	0
temp:	oct	0
work:	oct	0
delta:	oct	0
tally:	oct	0
exec:	oct	0
ldcon:	oct	0
noio:	oct	0
talrem:	oct	0

"	These two must be paired: crcw is a cw for crdbf

crcw:	oct	0
crdbf:	bss	,32              console input buffer

"	Ditto.

ccw:	oct	0
conb1:	bss	,64

"	Same here.

blkot_cw: oct	0
blkot:	bss	,310             block buffer


p8586:	oct	0
nxtst:	oct	0
wktal:	oct	0
ign:	oct	0
timout:	oct	0
	oct	0		used to be 355cw
fnp_chan_info:
	oct	0
ecount:	oct	0
buffer_base:
	oct	0
tty_chan: oct	0
ctrwd:	oct	0
base:	oct	0
fnp_tag:	oct	0
fnp_iom:	oct	0
fnp_chn:	oct	0
simulated_interrupts:
	oct	0

	even

typcw:	vfd	6/write_tty,6/0,6/0,o3/7,3/0,6/0,6/0
	oct	0

mbxptr:	itp	mem,*-*		FNP mailbox ptr
time_temp:
	oct	0,0

tydcw:	vfd	18/conb1+pgmorg,6/0,12/*-*

idb:	bss	,3
patch:	bss	,100
"
	include	bos_tv
	include	bos_common
	end
"
"
"                                          -----------------------------------------------------------
"
"
"
" Historical Background
"
" This edition of the Multics software materials and documentation is provided and donated
" to Massachusetts Institute of Technology by Group Bull including Bull HN Information Systems Inc. 
" as a contribution to computer science knowledge.  
" This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
" Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell Bull Inc., Groupe Bull
" and Bull HN Information Systems Inc. to the development of this operating system. 
" Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
" renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
" of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture for
" managing computer hardware properly and for executing programs. Many subsequent operating systems
" incorporated Multics principles.
" Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
" as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .
"
"                                          -----------------------------------------------------------
"
" Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
" fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
" and that both the copyright notice and historical background and this permission notice appear in supporting
" documentation, and that the names of MIT, HIS, Bull or Bull HN not be used in advertising or publicity pertaining
" to distribution of the programs without specific prior written permission.
"    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
"    Copyright 2006 by Bull HN Information Systems Inc.
"    Copyright 2006 by Bull SAS
"    All Rights Reserved
"
"