



		    accept_rpv.pl1                  11/11/89  1108.3r w 11/11/89  0827.9       76581



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */
accept_rpv:
     procedure;

/****^  HISTORY COMMENTS:
  1) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1056):
     Correct error message documentation.
  2) change(86-05-19,Lippard), approve(85-12-02,MCR7309),
     audit(86-05-21,Coppola), install(86-07-17,MR12.0-1097):
     Modified by Jim Lippard to base determination of whether this volume is a
     root PV on the new root_lv flag in the pvt rather than on hc_part_used,
     since root PVs need not have hardcore partitions now.
  3) change(86-05-20,Fawcett), approve(86-04-11,MCR7383),
     audit(86-05-21,Coppola), install(86-07-17,MR12.0-1097):
     Add subvolume support.
  4) change(87-01-08,Farley), approve(87-01-12,MECR0008),
     audit(87-01-09,GDixon), install(87-01-12,MR12.0-1268):
     Changed to reset pvt$rpvs_requested after successfully accepting all the
     rlv. This will then allow system_startup_ to do a salvage_dirs when
     required.
  5) change(87-01-14,Farley), approve(87-01-14,MCR7608),
     audit(87-01-14,GDixon), install(87-01-14,MR12.0-1279):
     Offical installation of above corrections.
                                                   END HISTORY COMMENTS */
/*
   This procedure accepts the RPV during system initialization.

   Stolen from accept_fs_disk August 1980 by C. Hornig
   Modified March 1982, J. Bongiovanni, to eliminate use of FSDCT
   Modified '82 for english error codes.
   Modified 1985-03-28, BIM: pre-accept non-partition volumes.
*/

	dcl     pvt$n_entries	 fixed bin external;
	dcl     pvt$root_lvid	 bit (36) aligned external;
	dcl     pvt$root_pvtx	 fixed bin external;
	dcl     pvt$rlv_needs_salv	 bit (1) aligned external;
	dcl     pvt$rpv_needs_salv	 bit (1) aligned external;
	dcl     pvt$rpvs_requested	 bit (1) aligned external;
	dcl     salv_data$rpv	 bit (1) aligned external;

	dcl     accept_fs_disk	 entry (fixed bin, fixed bin (35));
	dcl     config_$find	 entry (char (4) aligned, ptr);
	dcl     config_$find_parm	 entry (char (4) aligned, ptr);
	dcl     make_sdw$reset_hcp	 entry;
	dcl     read_disk		 entry (fixed bin, fixed bin, ptr, fixed bin (35));
	dcl     salvager$volume_salvage entry (fixed bin, bit (36) aligned, fixed bin (35));
	dcl     (syserr, syserr$error_code) entry options (variable);
	dcl     wired_shutdown$enable	 entry;

	dcl     all_root_vols_accepted bit (1);
	dcl     code		 fixed bin (35);
	dcl     i			 fixed bin;
	dcl     pvtx		 fixed bin;
	dcl     severity		 fixed bin;
	dcl     n_hc_volmap_pages	 fixed bin;
	dcl     salv_rlv_request	 bit (1);
	dcl     1 buffer		 aligned like label;

	dcl     (addr, hbound, null, string) builtin;
%page;
	labelp = addr (buffer);
	pvt_arrayp = addr (pvt$array);

	call config_$find_parm ("hcpt", intk_cardp);
	if intk_cardp = null ()
	then severity = LOG;
	else severity = ANNOUNCE;

/* Check all the claimed "RLV" volumes for brotherhood of the RPV. */

	do pvtx = 1 to pvt$n_entries;			/* Scan the PVT */
	     pvtep = addr (pvt_array (pvtx));
	     if pvte.hc_part_used & ^pvte.rpv then do;
		     call read_disk (pvtx, LABEL_ADDR, labelp, code);
		     if code ^= 0
		     then call syserr$error_code (CRASH, code, "accept_rpv: Cannot read label of ^a.", name (pvte));

		     if label.lvid ^= pvt$root_lvid
		     then call syserr (CRASH, "accept_rpv: pv ^a lv ^a (^a) is not part of root.", label.pv_name,
			     label.lv_name, name (pvte));
		end;
	end;

/* With this in hand, deal with the RPV personally. */

	pvt$rpvs_requested = "0"b;
	salv_rlv_request = "0"b;
	intk_cardp = null ();			/* search config deck */
	call config_$find ("intk", intk_cardp);		/* for the INTK card */
	if intk_cardp ^= null ()
	then do i = 1 to hbound (intk_card.parms, 1);	/* search the card for RPVS and RLVS */
		if intk_card.parms (i) = "rpvs" then do;
			intk_card.parms (i) = "";	/* clear it out */
			pvt$rpvs_requested = "1"b;
		     end;
		else if intk_card.parms (i) = "rlvs" then do; /* Salvage all PVs in RLV */
			intk_card.parms (i) = "";
			pvt$rpvs_requested = "1"b;
			salv_rlv_request = "1"b;
		     end;
	     end;

	pvtx = pvt$root_pvtx;			/* Init_pvt left this here */
	pvtep = addr (pvt_array (pvtx));

	salv_data$rpv = "1"b;

	if pvt$rpv_needs_salv | pvt$rpvs_requested
	then pvt$rlv_needs_salv = "1"b;		/* Salvage critical directories */

	if pvt$rpvs_requested			/* Explicit salvage RPV */
	then call salvager$volume_salvage (pvtx, ""b, code);

	do pvtx = 1 to pvt$n_entries;
	     pvtep = addr (pvt_array (pvtx));
	     if pvte.hc_part_used
	     then do;
		     n_hc_volmap_pages = pvte.volmap_stock_ptr -> record_stock.n_volmap_pages;
		     call syserr (severity, "accept_rpv: HC part on ^a used ^d out of ^d records.", name (pvte),
			(pvte.totrec - pvte.nleft + n_hc_volmap_pages), pvte.totrec + n_hc_volmap_pages);
		end;
	end;

	call accept_fs_disk (pvt$root_pvtx, code);	/* Do the standard trip on the RPV */
	if code ^= 0 then call syserr$error_code (CRASH, code, "accept_rpv: Error accepting RPV");

	call wired_shutdown$enable;			/* Now if we crash clean it up */

	fgbxp = addr (flagbox$);			/* Set bit in the flagbox. */
	fgbx.ssenb = "1"b;

/* Flush the pvt brother threads that we had been using for HC part chain. */
/* They tend to bother logical_volume_manager. */

	call make_sdw$reset_hcp;

	do i = 1 to pvt$n_entries;
	     pvtep = addr (pvt_array (i));
	     pvte.brother_pvtx = 0;
	end;

/* Now try to get all those "root volumes" accepted. */

	all_root_vols_accepted = "1"b;		/* assume success */
	do pvtx = 1 to pvt$n_entries;
	     pvtep = addr (pvt_array (pvtx));
	     if pvte.root_lv & ^pvte.rpv then do;
		     if salv_rlv_request
		     then call salvager$volume_salvage (pvtx, ""b, code);
		     call accept_fs_disk (pvtx, code);
		     if code ^= 0 then all_root_vols_accepted = "0"b;
						/* rlv incomplete */
		end;
	end;

	salv_data$rpv = "0"b;

	if all_root_vols_accepted then pvt$rpvs_requested = "0"b; /* nolonger needed, if rlv accepted */

	return;

/* * * * * * * * * NAME * * * * * * * * * */

name:
     procedure (Pvte) returns (char (8) aligned);

	dcl     1 Pvte		 aligned like pvte parameter;
	dcl     1 dname		 aligned,
		2 dev		 char (4) unaligned,
		2 u		 char (1) unaligned,
		2 num		 pic "99" unaligned,
		2 sv		 char (1) unaligned;


	dname.dev = Pvte.devname;
	dname.u = "_";
	dname.num = Pvte.logical_area_number;
	if Pvte.is_sv then dname.sv = valid_sv_array (Pvte.sv_num);
	else dname.sv = "";
	return (string (dname));
     end name;
%page;
%include disk_pack;
%include flagbox;
%include fs_vol_label;
%include fs_dev_types;
%include config_intk_card;
%include pvte;
%include stock_seg;
%include syserr_constants;
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   accept_rpv: pv PVNAME lv LVNAME (DSKX_NN) is not part of root.

   S: $crash

   T: $init

   M: The pack on the drive DSKX_NN, with pv name and lv name as read
   from its label, is specified on the ROOT CONFIG card, but is not
   part of the same logical volume as the RPV.

   A: Check the ROOT CONFIG card for errors. Check for the proper
   packs.  Reboot the system.


   Message:
   accept_rpv: Error ERRORMESSAGE accepting RPV

   S: $crash

   T: $init

   M: Some problem was encountered trying to set up the use of the RPV for
   normal segment creation and activation.  The label of the RPV may have been
   damaged, or encountered disk errors, as indicated by the ERRORMESSAGE.

   A: Make sure that the RPV label area (first eight records), or a dump of it,
   is available for system programmer inspection.
   $note

   Message: 
   accept_rpv: HC part on dskX_NN used XXX out of YYY records.

   S: This message is printed on the console if an HCPT card is in the config
   deck. Otherwise, it is logged into the syserr_log.

   T: $init

   M: The message appears for each disk volume which contains a Hardcore 
   Partition (PART HC). It indicates how many records  were actually used
   (XXX) in the partition, which had size YYY.

   A: $ignore

   END MESSAGE DOCUMENTATION */

     end accept_rpv;
   



		    create_root_dir.pl1             11/11/89  1108.3rew 11/11/89  0826.9       26703



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */
create_root_dir:
     procedure (Dp);

dcl  Dp ptr parameter;

/* Written by C. Hornig, February 1982. */

dcl  active_hardcore_data$alloc_sizes (2) fixed bin external;
dcl  active_hardcore_data$nalloc_sizes fixed bin external;
dcl  active_hardcore_data$cold_boot_switch bit (1) aligned external;
dcl  active_hardcore_data$dir_arearp fixed bin (18) external;
dcl  pvt$root_lvid bit (36) aligned external;
dcl  pvt$root_pvid bit (36) aligned external;
dcl  sys_info$default_dir_max_length fixed bin external;

dcl  allocate_dir_ht_ entry (ptr, fixed bin, fixed bin (35));
dcl  fs_alloc$init entry (pointer, fixed bin, pointer, fixed bin);
dcl  lock$dir_lock_write entry (pointer, fixed bin (35));
dcl  lock$dir_unlock entry (pointer);
dcl  syserr$error_code entry options (variable);

dcl  code fixed bin (35);
%page;
	dp = Dp;
	dir.uid = "777777777777"b3;
	call lock$dir_lock_write (dp, code);		/* Lock the root. */
	if code ^= 0 then call syserr$error_code (1, code, "create_root_dir: lock error on ^p.", dp);

	active_hardcore_data$cold_boot_switch = "1"b;	/* set flag indicating cold boot */
	dir.pvid = pvt$root_pvid;			/* get info left by init_pvt */
	dir.sons_lvid = pvt$root_lvid;
	dir.master_dir = "1"b;

/* The below calculations set the relative pointers in the directory structure. They are based
   on the assumption that directories have a max length of ROOT_MAX_SIZE and that
   the relative pointers in the directory have been set in active_hardcore_data.
*/
	dir.arearp = bit (active_hardcore_data$dir_arearp, 18);
	call fs_alloc$init (pointer (dp, dir.arearp),
	     (sys_info$default_dir_max_length - active_hardcore_data$dir_arearp),
	     addr (active_hardcore_data$alloc_sizes), active_hardcore_data$nalloc_sizes);
	call allocate_dir_ht_ (dp, 0, code);
	if code ^= 0 then call syserr$error_code (1, code, "create_root_dir: allocating hash table");
	call lock$dir_unlock (dp);			/* Unlock the root */
	return;
%page;
%include dir_header;
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   create_root_dir: lock error on PPP

   S:	$crash

   T:	$init

   M:	The supervisor was unable to lock the root.
   $err

   A:	$recover
   $boot_tape


   Message:
   create_root_dir: allocating hash table ERROR_MESSAGE

   S:	$crash

   T:	Cold boot of Multics hierarchy.

   M:	$err
   An error has occurred allocating the hash table for the root directory.

   A:	Reboot with a different version of the system.


   END MESSAGE DOCUMENTATION */

     end create_root_dir;
 



		    create_root_vtoce.pl1           11/11/89  1108.3r w 11/11/89  0826.9       47844



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */
create_root_vtoce:
     procedure;

/* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */


/****^  HISTORY COMMENTS:
  1) change(82-02-01,Hornig), approve(), audit(), install():
      Written by C. Hornig.
  2) change(84-11-01,Loepere), approve(), audit(), install():
      Modified by Keith Loepere to update label when done.
  3) change(86-02-01,Fawcett), approve(86-05-27,MCR7417),
     audit(86-08-18,Hartogs), install(86-08-19,MR12.0-1120):
      Modified to check for root vtoce not a zero.
                                                   END HISTORY COMMENTS */


dcl  pvt$root_pvid			bit (36) aligned external;
dcl  pvt$root_pvtx			fixed bin external;
dcl  pvt$root_vtocx			fixed bin external;
dcl  sys_info$default_dir_max_length	fixed bin external;
dcl  sys_info$time_of_bootload	fixed bin (71) external;

dcl  dbm_man$set_incr		entry (fixed bin, fixed bin, fixed bin (35));
dcl  read_disk			entry (fixed bin, fixed bin (17), ptr, fixed bin (35));
dcl  syserr			entry options (variable);
dcl  syserr$error_code		entry options (variable);
dcl  vtoc_man$alloc_and_put_vtoce	entry (bit (36) aligned, fixed bin, ptr, fixed bin (35)) returns (fixed bin);
dcl  write_disk			entry (fixed bin, fixed bin (17), ptr, fixed bin (35));

dcl  code				fixed bin (35);
dcl  1 local_label			aligned like label;
dcl  1 local_vtoce			aligned like vtoce;

dcl  (addr, binary, bit, clock, divide, unspec) builtin;

/* * * * * * * * * * CREATE_ROOT_VTOCE * * * * * * * * * */

	unspec (local_vtoce) = ""b;
	local_vtoce.uid = "777777777777"b3;		/* Fill in new VTOC entry */
	local_vtoce.msl = bit (divide (sys_info$default_dir_max_length, 1024, 9, 0));
	local_vtoce.csl = "0"b;
	local_vtoce.records = "0"b;
	local_vtoce.dtm, local_vtoce.dtu = bit (binary (sys_info$time_of_bootload, 52));
	local_vtoce.nqsw = "1"b;			/* The root's immune (saves nasty recursion) */
	local_vtoce.dirsw = "1"b;
	local_vtoce.master_dir = "1"b;
	local_vtoce.quota (*) = binary ("777777"b3, 18);	/* Biggest quota possible */
	local_vtoce.used (*) = 0;
	local_vtoce.received (*) = 0;
	local_vtoce.trp (*) = 0;
	local_vtoce.trp_time (*) = local_vtoce.dtm;
	local_vtoce.primary_name = ">";		/* Fill in info for salvager */
	local_vtoce.branch_rp = "0"b;
	local_vtoce.time_created = local_vtoce.dtm;
	local_vtoce.par_pvid = pvt$root_pvid;
	local_vtoce.par_vtocx = -1;
	local_vtoce.uid_path (*) = "0"b;
	local_vtoce.fm (*) = create_vtoce_null_addr;

	pvt$root_vtocx = vtoc_man$alloc_and_put_vtoce ("0"b, pvt$root_pvtx, addr (local_vtoce), code);
	if code ^= 0 then call syserr$error_code (SYSERR_CRASH_SYSTEM, code, "create_root_vtoce: Cannot alloc-write root VTOCE.");

/* if the first free vtoce on rpv is not vtoc 0 then the cold boot was not preceeded by an rpv init_vol */

	if pvt$root_vtocx ^= 0 then
	     call syserr (SYSERR_CRASH_SYSTEM, "create_root_vtoce: Root vtoce not allocated at 0, RPV not initialized.");

	call read_disk (pvt$root_pvtx, LABEL_ADDR, addr (local_label), code);
	if code ^= 0 then go to RPV_error;

	local_label.root_vtocx = pvt$root_vtocx;
	local_label.time_registered = clock;

	call write_disk (pvt$root_pvtx, LABEL_ADDR, addr (local_label), code);
	if code ^= 0 then
RPV_error:
	     call syserr$error_code (SYSERR_CRASH_SYSTEM, code, "create_root_vtoce: Cannot set root_vtocx in RPV label.");

	call dbm_man$set_incr (pvt$root_pvtx, pvt$root_vtocx, code);
	if code ^= 0 then call syserr (SYSERR_PRINT_ON_CONSOLE, "create_root_vtoce: Cannot set dmpr bit map for root.");
	return;
%page;
%include disk_pack;
%page;
%include fs_vol_label;
%page;
%include null_addresses;
%page;
%include syserr_constants;
%page;
%include vtoce;
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   create_root_vtoce: Cannot alloc-write root vtoce ERROR_MESSAGE

   S:	$crash

   T:	Cold boot of Multics hierarchy.

   M:	The system is unable to write out the VTOC entry for the root directory.

   A:	Correct the disk problem if one exists and reboot.
   Otherwise reboot with a different version of the system.


   Message:
   create_root_vtoce: Cannot set dmpr bit map for root ERROR_MESSAGE

   S:	$info

   T:	Cold boot of Multics hierarchy.

   M:	$err

   A:	$inform


   Message: create_root_vtoce: Cannot set root_vtocx in RPV label.

   S:	$crash

   T:	Cold boot of Multics hierarchy.

   M:	The system is unable to update the RPV label for the 
   root directory.

   A:	Correct the disk problem if one exists and reboot.
   Otherwise reboot with a different version of the system.

   Message: create_root_vtoce: Root vtoce not allocated at 0, RPV not initialized.

   S:	$crash

   T:	Cold boot of Multics hierarchy.

   M:     A boot -cold was attempted without init_vol for RPV.

   A:     Reboot system answering the find_rpv_subsystem with cold instead of rpv.

   END MESSAGE DOCUMENTATION */

     end create_root_vtoce;




		    dir_lock_init.pl1               11/11/89  1108.3rew 11/11/89  0826.9       28359



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */
/* dir_lock_init.pl1 -- intialization (collection 2) of dir_lock_seg. */
/* format: style2 */

dir_lock_init:
     procedure;

/* BIM 830212 */
/* Modified 831107 BIM for readers seperate from locks proper */
/* Modified 831111 BIM to remove threads. */

	declare make_sdw$unthreaded	 entry (fixed binary (18), fixed binary (71), pointer, pointer);
	declare pmut$swap_sdw	 entry (ptr, ptr);
	declare syserr		 entry options (variable);

	declare dir_lock_seg_size	 fixed bin;
	declare n_dir_locks		 fixed bin;
	declare code		 fixed bin (35);
	declare tsdw		 fixed bin (71);
	declare ptp		 pointer;
	declare astep		 pointer;
	declare i			 fixed bin;

	declare slt$		 external static;
	declare tc_data$max_max_eligible
				 fixed bin (35, 18) external static;
	declare active_all_rings_data$max_tree_depth
				 fixed bin external static;

	declare (addr, divide, segno, size)
				 builtin;

	declare 1 local_dir_lock_header
				 aligned like dir_lock_seg_header;


	dir_lock_segp = addr (local_dir_lock_header);
	dir_lock_seg.max_readers = tc_data$max_max_eligible;
	n_dir_locks, dir_lock_seg.n_dir_locks = tc_data$max_max_eligible * active_all_rings_data$max_tree_depth;
	dir_lock_seg_size = size (dir_lock_seg);	/* auto header makes reference to size of dir_lock possible */

	dir_lock_segp = addr (dir_lock_seg$);
	sltp = addr (slt$);
	sltep = addr (slt.seg (segno (dir_lock_segp)));

	slte_uns.abs_seg = "0"b;
	slte_uns.cur_length, slte_uns.max_length = divide (dir_lock_seg_size + 1023, 1024, 18, 0);
	call make_sdw$unthreaded (segno (dir_lock_segp), tsdw, astep, ptp);

	if astep = null ()
	then call syserr (CRASH, "dir_lock_init: Cannot get ASTE for dir_lock_seg.");
	call pmut$swap_sdw (dir_lock_segp, addr (tsdw));

	unspec (dir_lock_seg.header) = ""b;

	dir_lock_seg.n_dir_locks = n_dir_locks;
	dir_lock_seg.header.highest_in_use = 0;
	dir_lock_seg.header.max_readers = tc_data$max_max_eligible;
	dir_lock_seg.header.readers_ptr = addr (dir_lock_seg.readers);
	dir_lock_seg.header.locks_ptr = addr (dir_lock_seg.dir_locks);
	unspec (dir_lock_seg.dir_locks) = ""b;
	dir_lock_seg.readers (*, *) = ""b;

	unspec (dir_lock_seg.seg_lock.event) = unspec (DIR_LOCK_SEG_EVENT);
	return;

/* format: off */
%page; %include slt;
%page; %include slte;
%page; %include dir_lock_seg_;
%page; %include hc_lock;
%page; %include syserr_constants;

/* BEGIN MESSAGE DOCUMENTATION

Message:
dir_lock_init: cannot get ASTE for dir_lock_seg.

S:       $crash

T:       $init

M:       No space could be obtained for dir_lock_seg. This can result from inadequate ASTE pools or hardcore partition.

A:       $recover
$boot_tape

END MESSAGE DOCUMENTATION */

       end dir_lock_init;
 



		    fnp_init.pl1                    11/11/89  1108.3rew 11/11/89  0826.9      130302



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(88-06-14,Berno), approve(88-07-13,MCR7928),
     audit(88-06-14,Parisek), install(88-07-19,MR12.2-1061):
     Add support for the uncp multiplexer to implement the DSA gateway
     interface.
  2) change(89-03-20,Parisek), approve(89-06-01,MCR8110),
     audit(89-10-09,Farley), install(89-10-25,MR12.3-1100):
     Add support of protocol mpx.
                                                   END HISTORY COMMENTS */


/* format: style4,delnl,insnl,tree,ifthenstmt,indnoniterend */
fnp_init:
     procedure;					/* FNP initialization for hardcore */

/* extracted from fnp_init on 5/11/76 by Robert S. Coren */
/* Modified 9/12/78 by J. Stern to initialize tty_buf, tty_area, and tty_tables */
/* Modified January 1980 by C. Hornig for MCM tracing */
/* Modified April 1981 by Chris Jones for io_manager conversion */
/* Modified February 1982 by C. Hornig for MR10 io_manager */
/* Modified November 1982 by Robert Coren to explicitly clear dn355_mailbox */
/* Modified 83-12-14 BIM to leave iom_manager assignment for FNP bootload time. */
/* Modified 84-07-09 MMP (and BIM) to insert model in prph fnp card. */
/* Modified 1984-07-30 BIM for paged mode IOM. */
/* Modified 1984-10-18 BIM to abs_wire tty_buf. *BLUSH!* */
/* Modified November 1984 by Robert Coren to initialize tty_area_lock.event. */
/*                         UNCP MPX                                         */ 
/* Report modifications for the Datanet 7100, August 85 */

/**** NOTE: two undocumented parameters are checked here:

      dfnp turns on dn355_data.debug_stop,
      tfnp turns on dn533_data.trace.

      See the code of fnp_util and fnp_multiplexer to see what they do. */


dcl  astep pointer;
dcl  i fixed bin;
dcl  j fixed bin;
dcl  bufsize fixed bin;
dcl  cptr ptr;
dcl  prot_ptr ptr;
dcl  p ptr;
dcl  tsdw fixed bin (71);
dcl  tty_area_size fixed bin (18);
dcl  code fixed bin (35);
dcl  cl fixed bin;
dcl  ptp pointer;
dcl  modelx fixed bin (17);
dcl  uncp_fnp_configured bit (1);

dcl  syserr entry options (variable);
dcl  syserr$error_code entry options (variable);
dcl  config_$find_2 entry (character (4) aligned, character (4) aligned, pointer);
dcl  config_$find_parm entry (char (*), ptr);
dcl  make_sdw$unthreaded entry (fixed bin (18), fixed bin (71), ptr, ptr);
dcl  pc_abs$wire_abs entry (ptr, fixed bin, fixed bin, fixed bin (35));
dcl  pmut$swap_sdw entry (ptr, ptr);
dcl  get_fnp_name_ entry (fixed bin) returns (char (32));
dcl  tty_space_man$get_perm_space entry (fixed bin, ptr);

dcl  slt$ external;
dcl  sys_info$page_size fixed bin external;

dcl  (addr, addrel, bin, currentsize, divide, empty, hbound, lbound,
     mod, null, pointer, ptr, rel, segno, size, string, substr, unspec) builtin;

dcl  1 prot_parm aligned based (prot_ptr),
       2 name char (4),
       2 size fixed bin;

dcl  1 tty_parm aligned based (cptr),
       2 name char (4),
       2 size fixed bin;

dcl  dn355_mailbox$ fixed bin ext;

dcl  1 dn355mbx_array (max_no_355s) based (addr (dn355_mailbox$)) aligned,
       2 actual_mbx (192) fixed bin (35);		/* allow 300(8) per mbx */

dcl  tty_area area (tty_area_size) based (addr (tty_area$));
dcl  tty_area$ external;

declare  FNP_CONFIG_EVENT char (4) aligned init ("fnpc");

/* CONSTANTS */

dcl  DEFAULT_BUFSIZE fixed bin int static options (constant) init (5120);
dcl  MAX_PROT_CHNLS fixed bin int static options (constant) init (128);
dcl  MIN_BUFSIZE fixed bin int static options (constant) init (256);
dcl  TTY_PERM_SPACE fixed bin int static options (constant) init (2048);
dcl  UNCP_CQ_SIZE fixed bin int static options (constant) init (2000);
dcl  EXPECTED_FIELDS fixed bin int static options (constant) init (5);
dcl  PAGE fixed bin int static options (constant) init (1024);
dcl  WORD15 fixed bin int static options (constant) init (15);
dcl  BIT36 fixed bin int static options (constant) init (36);
dcl  TRACE_INDEX bit (36) int static options (constant) init ("000000000001"b3);
     


	ttybp = addr (tty_buf$);			/* get ptrs to tty_buf and dn355_data */
	infop = addr (dn355_data$);

/* allocate and setup tty_buf now. */

	call config_$find_parm ("ttyb", cptr);		/* get ptr to ttyb parameter */
	if cptr = null
	then bufsize = DEFAULT_BUFSIZE;		/* default size of tty_buf is 5K */
	else bufsize = tty_parm.size;			/* unless TTYB nnnn was given */
	sltp = addr (slt$);
	sltep = addr (slt.seg (segno (ttybp)));

	cl = divide (bufsize + sys_info$page_size - 1, sys_info$page_size, 18, 0);

	slte_uns.bit_count = cl * BIT36 * PAGE;
	slte_uns.max_length, slte_uns.cur_length = cl;
	slte_uns.wired = "0"b;			/* make_sdw will not wire the right way */

	call make_sdw$unthreaded (segno (ttybp), tsdw, astep, ptp);
	call pc_abs$wire_abs (astep, 0, cl, code);
	if code ^= 0 then call syserr$error_code (CRASH, code, "fnp_init: Unable to abs_wire tty_buf.");

	call pmut$swap_sdw (ttybp, addr (tsdw));	/* swap in the sdw setup by get_main */
	begin;
declare  tty_buf_pages (slte_uns.cur_length, 1024) bit (36) aligned based (ttybp);
	     tty_buf_pages = ""b;
	end;

	tty_buf.absorig = sys_info$page_size * FIRST_TTY_BUF_PAGEX;
						/* origin in IO segment */
	tty_buf.lct_ptr = null;

	p = addr (tty_buf.free_space);		/* get ptr to start of free space */

/**** tty_buf is not at location 0 of the I/O segment */

	i = bin (rel (p), 18);			/* mod pointer to next 16 words */

	string (tty_buf.trace) = ""b;
	call config_$find_parm ("ttyt", cptr);		/* need a trace table be allocated */
	if cptr ^= null () then do;
	     i = i + mod (i, 2);			/* must be at even word */
	     trace_array_ptr = pointer (ttybp, i);
	     trace_array.num_entries = tty_parm.size;
	     trace_array.idx = TRACE_INDEX;
	     tty_buf.trace.data_offset = rel (trace_array_ptr);
	     i = bin (rel (addrel (trace_array_ptr, currentsize (trace_array))));
	     end;

	i = i + WORD15;
	i = i - mod (i, WORD15+1);
	p = ptr (p, i);
	tty_buf.borig, tty_buf.free = rel (p);		/* free list of blocks starts here */

	tty_buf.bleft = bufsize - bin (tty_buf.borig);
	if tty_buf.bleft < MIN_BUFSIZE
	then call syserr (CRASH, "fnp_init: Less than 256 words of free space in tty_buf:  ^d", tty_buf.bleft);
	free_blockp = p;
	free_block.next = "0"b;			/* one block */
	free_block.size = tty_buf.bleft;

	tty_buf.tty_area_lock.event = TTY_AREA_LOCK_EVENT;

/* initialize tty_area */

	tty_area_size = get_seg_size (addr (tty_area$));
	tty_area = empty ();

/* initialize tty_tables segment */

	ttytp = addr (tty_tables$);
	tty_tables_hdr.event = tty_ev;		/* init wait event for tty_tables lock */
	tty_tables_hdr.table_area_size = get_seg_size (ttytp) - currentsize (tty_tables_hdr);
	tty_tables_hdr.table_area = empty ();		/* init table area */

/* search for protocol "prot" parameter in the config deck then do
   allocation/initialization of protocol_data if one is found */ 

	call config_$find_parm ("prot", prot_ptr);	/* get ptr to PROT parameter */
	if prot_ptr = null				/* site not running "protocol_mpx" software */
	     then datanet_info.protocol_datap = null;
	else do;
               if prot_parm.size > MAX_PROT_CHNLS then
	          call syserr (CRASH, "fnp_init: The number of configured protocol channels of ^d^/^-exceeds the maximum allowed of ^d.",
                         prot_parm.size, MAX_PROT_CHNLS);
               else protocol_channels = prot_parm.size;
	     call tty_space_man$get_perm_space (size (protocol_data), protocol_data_ptr);
	     protocol_data.max_channels = protocol_channels;
	     datanet_info.protocol_datap = protocol_data_ptr;
          end;


/* read FNP cards and do init */

	tty_buf.fnp_config_flags (*) = "0"b;		/* start with no fnps configured */
	datanet_info.configuration_lock.pid = ""b;
	datanet_info.configuration_lock.event = unspec (FNP_CONFIG_EVENT);
	datanet_info.configuration_lock.flags = "0"b;
	uncp_fnp_configured = "0"b;
	do i = 1 to max_no_355s;			/* set up la indices */
	     fnpp = addr (datanet_info.per_datanet (i));
	     fnp_info.mbx_pt = null;			/* start null */
	     fnp_info.lcte_ptr = null;
	     do j = lbound(fnp_info.lsla_idx, 1) to hbound(fnp_info.lsla_idx, 1);
						/* initialize HSLA/LSLA indices */
		if j <= hbound(fnp_info.hsla_idx, 1) then
		     fnp_info.hsla_idx (j) = -1;
		fnp_info.lsla_idx (j) = -1;
	     end;

	     mbxp = addr (dn355mbx_array (i));		/* get addr of this mbx */
	     unspec (datanet_mbx) = ""b;		/* make sure whole mailbox starts out 0 */

	     prph_fnp_cardp = null ();
	     call config_$find_2 ("prph", "fnp" || substr (get_fnp_name_ (i), 1, 1), prph_fnp_cardp);
	     if prph_fnp_cardp ^= null () then do;
		if prph_fnp_card.n_fields ^= EXPECTED_FIELDS | (prph_fnp_card.field_type (5) ^= CONFIG_STRING_TYPE)
		     | (prph_fnp_card.state ^= "on" & prph_fnp_card.state ^= "off")
		then call syserr (CRASH, "fnp_init: Invalid state on prph ^a card.", prph_fnp_card.name);

		do modelx = 1 to hbound (fnp_models, 1) while (prph_fnp_card.model ^= fnp_models (modelx));
		end;
		if modelx > hbound (fnp_models, 1) | ^supported_fnp (modelx)
		     then call syserr (CRASH, "fnp_init: Invalid model # (^d) on prph ^a card.",
		     prph_fnp_card.model, prph_fnp_card.name);
		if modelx = DN7100 then uncp_fnp_configured = "1"b;

		fnpp = addr (datanet_info.per_datanet (i));
		tty_buf.fnp_config_flags (i) = "1"b;	/* its in the config deck */
		fnp_info.available = prph_fnp_card.state = "on";
		fnp_info.mbx_pt = mbxp;		/* place ptr to mbx in per dn slot */
		fnp_info.fnp_number = i;
		fnp_info.fnp_tag = substr (get_fnp_name_ (i), 1, 1);
		fnp_info.ptx = -1;			/* not yet known */
		fnp_info.ptp = null ();		/* don't allocate until/unless loaded */
		datanet_info.no_of_355s = datanet_info.no_of_355s + 1;

		call io_chnl_util$iom_to_name (prph_fnp_card.iom, (prph_fnp_card.chan), fnp_info.io_chanid, code);
		if code ^= 0 then call syserr (CRASH, "fnp_init: code ^o from io_chnl_util$iom_to_name.", code);
						/* something wrong here... */

		end;
	end;
	if datanet_info.no_of_355s = 0 then call syserr (ANNOUNCE, "fnp_init: Warning: no FNP's configured.");

 /* Add for the Datanet 7100. */

	if uncp_fnp_configured then do;
	     call tty_space_man$get_perm_space (TTY_PERM_SPACE, datanet_info.uncp_bufp);

	     uncpbp = datanet_info.uncp_bufp;
	     uncp_buf.cq_max_size = UNCP_CQ_SIZE;
	     uncp_buf.cq_free = uncp_buf.cq_max_size;	/* Start of the free space */
	     uncp_buf.cq_hbound = uncp_buf.cq_max_size - 1;
						/* The circular queue is a table (0:cq_max_size - 1) */
	end;
	else datanet_info.uncp_bufp = null ();

	cptr = null ();
	call config_$find_parm ("tfnp", cptr);
	datanet_info.trace = (cptr ^= null ());
	cptr = null ();
	call config_$find_parm ("dfnp", cptr);
	datanet_info.debug_stop = (cptr ^= null ());

	return;
%page;
get_seg_size:
     proc (segp) returns (fixed bin (18));		/* gets segment sizes from the slt */

dcl  segp ptr;					/* ptr to seg whose size is wanted */
dcl  seg_no fixed bin (18);


	seg_no = segno (segp);
	sltp = addr (slt$);
	sltep = addr (slt.seg (seg_no));

	return (slte_uns.max_length * sys_info$page_size);

     end get_seg_size;
%page;
%include tty_buf;
%include uncp_buf;
%include mcs_trace_data;
%include tty_buffer_block;
%include tty_tables;
%include config_deck;
%include config_prph_fnp_card;
%include dn355_data;
%include slt;
%include slte;
%include syserr_constants;
%include dn355_mailbox;
%include io_chnl_util_dcls;
%include fnp_types;
%include protocol_data;
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   fnp_init: Less than 256 words of free space in tty_buf:  N

   S:  $crash

   T:  $init

   M:  Only N words of free space remain in tty_buf after
   allocating the header and circular queue.  A minimum of
   256 words is required and ordinarily more free
   space is desirable.  Either the size of tty_buf, as specified
   by the PARM TTYB config card, must be increased or the
   circular queue size, as specified by the PARM TTYQ config
   card, must be decreased.

   A:  Correct the config deck and reboot the system.


   Message:
   fnp_init: no fnp cards in config deck

   S:  $info

   T:  $init

   M:  There are no fnp cards in the config deck and therefore,
   no FNP will be initialized.  Usually this indicates an error,
   although it is possible to run Multics without an FNP.

   A:  If an FNP is wanted, reboot the system with an appropriate
   config deck.


   Message:
   fnp_init: FNP number N > max allowed number (MAX) of FNPs

   S:  $crash

   T:  $init

   M:  An fnp card from the config deck specifies an FNP tag
   other than A, B, C, D, E, F, G, or H.

   A:  Replace the bad fnp card and reboot.


   Message:
   fnp_init: inconsistent fnp cards.

   S:  $crash

   T:  $init

   M:  Two or more fnp cards from the config deck specify the same
   FNP tag.

   A:  Replace or remove the bad fnp card(s) and reboot.


   Message:
   fnp_init: Unable to abs_wire tty_buf. ERROR_CODE_MESSAGE

   S:  $crash

   T:  $init

   M:  The call to allocate memory in the bootload memory controller
   for tty_buf failed.

   A:  $contact


   Message:
   fnp_init: Invalid state on prph fnpX card.

   S:  $crash

   T:  $init

   M:  The only valid states are "on" or "off".

   A:  $contact


   Message:
   fnp_init: Invalid model # (MODELN) on prph fnpX card.

   S:  $crash

   T:  $init

   M:  The current fnp model number MODELN, is not a supported number.

   A:  $contact


   Message:
   fnp_init: The number of configured protocol channels of N
   exceeds the maximum allowed of N.

   S:  $crash

   T:  $init

   M:  The prot parm from the config deck specifies too many protocol channels.

   A:  $contact

   END MESSAGE DOCUMENTATION */


     end fnp_init;
  



		    init_dm_journal_seg.pl1         11/11/89  1108.3rew 11/11/89  0826.9       39573



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */
/* format: style3 */
init_dm_journal_seg:
     proc;

/*  Program to initialize the Page Control data base dm_journal_seg_

    Written October 1982 by J. Bongiovanni
    Modified January 1983 by J. Bongiovanni to call make_sdw instead of get_main
*/

/*  Automatic  */

dcl	dm_journal_astep	ptr;
dcl	dm_journal_segno	fixed bin (18);
dcl	journalx		fixed bin;
dcl	pagex		fixed bin;
dcl	seg_pages		fixed bin;
dcl	sx		fixed bin;
dcl	tsdw		fixed bin (71);

/*  Static  */

dcl	DBMJ_CARD_FIELDS	fixed bin internal static options (constant) init (6);
dcl	JOURNAL_WAIT_EVENT	bit (36) aligned internal static options (constant) init ("666000000000"b3);

/*  External  */

dcl	slt$		external;
dcl	sst$dm_enabled	bit (1) aligned external static;
dcl	1 sst$level	(0:3) aligned external,
	  2 ausedp	bit (18) unaligned,
	  2 no_aste	fixed bin (18) unsigned unaligned;
dcl	sst$nused		fixed bin (19) external static;
dcl	tc_data$end_of_time fixed bin (71) external static;

/*  Entry  */

dcl	config$find	entry (char (4) aligned, ptr);
dcl	make_sdw		entry (fixed bin (18), fixed bin (71), ptr, ptr);
dcl	pmut$swap_sdw	entry (ptr, ptr);
dcl	syserr		entry options (variable);

/*  Builtin  */

dcl	addr		builtin;
dcl	divide		builtin;
dcl	null		builtin;
dcl	rel		builtin;
dcl	size		builtin;
%page;

/*  Parse DBMJ config card, if there is one  */

	dbmj_cardp = null ();
	call config$find (DBMJ_CARD_WORD, dbmj_cardp);

	if dbmj_cardp = null ()
	then return;

	if dbmj_card.type_word.n_fields ^= DBMJ_CARD_FIELDS
	then do;
BAD_DBMJ_CARD:
		call syserr (CRASH, "init_dm_journal_seg: Invalid DBMJ config card.");
	     end;
	else do;
		if (dbmj_card.n_journals <= 0) | (dbmj_card.max_held_pages <= 0)
		then goto BAD_DBMJ_CARD;
		do sx = lbound (dbmj_card.per_aste_pool, 1) to hbound (dbmj_card.per_aste_pool, 1);
		     if sst$level (sx).no_aste <= dbmj_card.per_aste_pool (sx)
		     then goto BAD_DBMJ_CARD;
		end;
		n_dm_journals = dbmj_card.n_journals;
		max_dm_pages = dbmj_card.max_held_pages;
	     end;



/*  Get memory for dm_journal_seg_  */

	dm_journal_segp = addr (dm_journal_seg_$);
	seg_pages = divide (size (dm_journal) + 1023, 1024, 17);
	dm_journal_segno = bin (baseno (dm_journal_segp));
	sltp = addr (slt$);
	sltep = addr (slt.seg (dm_journal_segno));
	slte_uns.cur_length = seg_pages;
	slte.wired = "1"b;
	call make_sdw (dm_journal_segno, tsdw, dm_journal_astep, (null ()));
	if dm_journal_astep = null ()
	then call syserr (CRASH, "init_dm_journal_seg: make_sdw failed for dm_journal_seg_");
	call pmut$swap_sdw (dm_journal_segp, addr (tsdw));


/*  Initialize dm_journal_seg_  */

	dm_journal.n_journals = n_dm_journals;
	dm_journal.max_held_pages_mem = max_dm_pages;
	dm_journal.per_aste_pool (*).threshold = dbmj_card.per_aste_pool (*);
	dm_journal.free_list_relp = rel (addr (dm_journal.page_entry));
	dm_journal.wait_event = JOURNAL_WAIT_EVENT;

	do journalx = 1 to n_dm_journals;
	     dm_journal.per_journal (journalx).time_stamp = tc_data$end_of_time;
	end;

	do pagex = 1 to max_dm_pages - 1;
	     dm_journal.page_entry (pagex).fp = rel (addr (dm_journal.page_entry (pagex + 1)));
	end;


	sst$dm_enabled = "1"b;

	return;

/* format: off */
%page;  %include config_dbmj_card;
%page;  %include dm_journal_seg_;
%page;  %include slt;
%page;  %include slte;
%page;  %include syserr_constants;
%page;
/*  BEGIN MESSAGE DOCUMENTATION


Message:
init_dm_journal_seg: Invalid DBMJ config card.

S:        $crash

T:	$init

M:	The DBMJ configuration card is not in proper format.
This could be a format error, or one of the following criteria may not
be satisfied. The limit on active segments for a pool must be smaller than
the pool size.

A:	Correct the configuration deck and reboot.


Message:
init_dm_journal_seg: make_sdw failed for dm_journal_seg_

S:        $crash

T:	$init

M:	The ASTE for dm_journal_seg_ could not be created.

A:	$contact


END MESSAGE DOCUMENTATION  */

end init_dm_journal_seg;
   



		    init_hardcore_gates.pl1         11/11/89  1108.3rew 11/11/89  0826.9       50139



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */
/* INIT_HARDCORE_GATES - Initialize all gates into the hardcore ring. */

/* This program is called to set up the linkage pointers stored in all hardcore gates.
   The only reason is efficiency, i.e. to make normal execution thru the gate faster.
   The program also sets up the entry bounds (call limiters) within the SDWs for
   the hardcore gates.
   Ring brackets are also put in the hardcore descriptors for
   restart_fault and return_to_ring_0_. */

/****^  HISTORY COMMENTS:
  1) change(77-06-01,Morris), approve(), audit(), install():
      Library maintenance installation.
      Rewritten to determine hardcore gates automatically from
      ring brackets in the SLT.  6/77 by Noel I. Morris
                                                   END HISTORY COMMENTS */

/* ******************************************************
   *                                                    *
   *                                                    *
   * Copyright (c) 1972 by Massachusetts Institute of   *
   * Technology and Honeywell Information Systems, Inc. *
   *                                                    *
   *                                                    *
   ****************************************************** */


init_hardcore_gates: proc;

dcl  tsdw fixed bin (71),				/* temporary for SDW */
     segno fixed bin (18),				/* gate segment number */
     segp ptr,					/* pointer to gate segment */
     lp ptr,					/* pointer to gate's linkage */
     dp ptr,					/* pointer to gate's definitions */
     lp_ptr ptr,					/* pointer to linkage pointer within gate */
     tv_ptr ptr;					/* pointer to call limiter within gate */

dcl  based_ptr ptr based,				/* based pointer */
     tv_end bit (14) aligned based;			/* based call limiter value */

dcl 1 segname_acc aligned,
   (2 l fixed bin (8),
    2 s char (31)) unal;

dcl 1 my_lp_acc static aligned options (constant),
   (2 l fixed bin (8) init (6),
    2 s char (6) init (".my_lp")) unal;

dcl 1 tv_end_acc static aligned options (constant),
   (2 l fixed bin (8) init (7),
    2 s char (7) init (".tv_end")) unal;

dcl  lot$ (0: 1023) ptr unaligned ext,
     dseg$ (0: 1) fixed bin (71) ext,
     slt$ ext,
     restart_fault$ ext,
     return_to_ring_0_$ ext;

dcl  pmut$swap_sdw entry (ptr, ptr),
     get_defptr_ entry (ptr, ptr, ptr, ptr, fixed bin (35));

dcl (addr, baseno, baseptr, bin, length, ptr, rtrim, substr, unspec) builtin;



% include sdw;



% include slt;



% include slte;



% include definition;



	sltp = addr (slt$);				/* Get ptr to slt */
	sdwp = addr (tsdw);				/* and pointer to temporary SDW */

	do segno = slt.first_sup_seg to slt.last_sup_seg; /* Iterate through all supervisor segments. */
	     sltep = addr (slt.seg (segno));		/* Get pointer to SLT entry. */
	     if slte.ringbrack (3) ^= "0"b3 &		/* If a hardcore gate ... */
		slte.ringbrack (2) = "0"b3 &
		slte.ringbrack (1) = "0"b3 then do;

		segp = baseptr (segno);		/* Get pointer to base of segment. */
		lp = lot$ (segno);			/* Get pointer to linkage for gate. */
		dp = lp -> based_ptr;		/* Get pointer to definitions. */

		namep = ptr (slt.name_seg_ptr, slte.names_ptr);  /* Get name of segment. */
		unspec (segname_acc) = "0"b;		/* Clear name ACC string. */
		segname_acc.l = length (rtrim (segnam.names (1).name));
		substr (segname_acc.s, 1, length (rtrim (segnam.names (1).name))) = segnam.names (1).name;

		lp_ptr = getadr (addr (my_lp_acc));	/* Get pointer to lp to be filled in. */
		tv_ptr = getadr (addr (tv_end_acc));	/* Get pointer to call limiter. */

		tsdw = dseg$ (segno);		/* Grab the SDW for segment. */
		sdw.write = "1"b;			/* Give write access. */
		call pmut$swap_sdw (segp, sdwp);

		lp_ptr -> based_ptr = lp;		/* Set linkage pointer in segment. */
		sdw.entry_bound_sw = "0"b;		/* Enable call limiter. */
		sdw.entry_bound = tv_ptr -> tv_end;	/* Set call limiter. */

		sdw.write = "0"b;			/* Take away write access. */
		call pmut$swap_sdw (segp, sdwp);	/* Insert new SDW in descriptor segment. */
	     end;
	end;

/* Now set the ringbrackets in the SDWs for
   restart_fault and return_to_ring_0_.		*/

	call set_sdw (addr (restart_fault$));		/* Set ring brackets and put in dseg */
	call set_sdw (addr (return_to_ring_0_$));

	return;



set_sdw:	procedure (segptr);				/* This procedure inserts ring brackets
						   from the SLT into hardcore descriptors */
dcl  segptr ptr;

	segno = bin (baseno (segptr), 18);		/* Get number of segment. */
	sltep = addr (slt.seg (segno));		/* access SLT entry */
	tsdw = dseg$ (segno);			/* grab the SDW */

	sdwp -> sdw.r1 = slte.ringbrack (1);		/* copy ring brackets */
	sdwp -> sdw.r2 = slte.ringbrack (2);
	sdwp -> sdw.r3 = slte.ringbrack (3);

	call pmut$swap_sdw (segptr, sdwp);		/* actually place SDW */

     end set_sdw;



getadr: proc (accp) returns (ptr);			/* procedure to search for definition symbol */

dcl  accp ptr;

dcl  defsp ptr,
     code fixed bin (35);

	call get_defptr_ (dp, addr (segname_acc), accp, defsp, code);

	return (ptr (segp, defsp -> definition.value));

     end getadr;


     end;
 



		    init_lvt.pl1                    11/11/89  1108.3r w 11/11/89  0826.9       23256



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


init_lvt: proc ();

/****^  HISTORY COMMENTS:
  1) change(76-02-17,Bratt), approve(), audit(), install():
   Modified March 1982 by J. Bongiovanni to eliminate use of FSDCT
   This module initializes the lvt and defines the RLV as containing
   the RPV which is assumed to be already accepted.
                                                   END HISTORY COMMENTS */

dcl 1 local_label like label aligned;
dcl 1 local_lvte like lvte aligned;
dcl  code fixed bin (35);
dcl  pvt$root_pvtx fixed bin external;
dcl  pvt$root_lvid bit (36) aligned external;
dcl  read_disk entry (fixed bin, fixed bin, ptr, fixed bin (35));
dcl  logical_volume_manager$add entry (ptr, fixed bin (35));
dcl  syserr entry options (variable);

/* initialize lvt */

	lvtp = addr (lvt$);
	lvt.max_lvtex = 50;
	lvt.high_water_lvtex = 0;
	lvt.free_lvtep = null ();
	lvt.ht (*) = null ();

/* get RLV together */

	call read_disk (pvt$root_pvtx, LABEL_ADDR, addr (local_label), code);
	if code ^= 0 then call syserr (1, "init_lvt: unable to read RPV label, code = ^o", code);
	local_lvte.lvid = pvt$root_lvid;
	local_lvte.access_class.min = local_label.min_access_class;
	local_lvte.access_class.max = local_label.max_access_class;
	unspec (local_lvte.flags) = (36)"0"b;
	local_lvte.flags.public = "1"b;
	call logical_volume_manager$add (addr (local_lvte), code);
	if code ^= 0 then call syserr (1, "init_lvt: unable to define RLV, code = ^o", code);
	return;

/*  */

%include fs_vol_label;

/*  */

%include disk_pack;

/*  */

%include lvt;


/* BEGIN MESSAGE DOCUMENTATION

Message:
init_lvt: unable to read RPV label, code = WWWW

S:	$crash

T:	$init

M:	The RPV label,
which was successfully read a few seconds ago,
cannot be read.

A:	$recover
$boot_tape


Message:
init_lvt: unable to define RLV, code = WWWW

S:	$crash

T:	$init

M:	$err

A:	$recover
$boot_tape


END MESSAGE DOCUMENTATION */

     end init_lvt;




		    init_root_dir.pl1               11/11/89  1108.3r w 11/11/89  0826.9       48609



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */
init_root_dir:
     procedure;

/*
   USAGE: call init_root_dir;

   NOTES: Called during system initialization "init_root_dir"  creates
   and initializes the root directory if the system is being cold booted.
   Various directory variables are set/preset such as the root id
   and all self referencing pointers. If the system is being
   warm booted these variables are not reset. In either case the root
   directory is made known to the initializer process.


   modified 4/75 for NSS by THVV
   modified 8/76 for variable size hash tables by S.E. Barr
   Modified by D. Vinograd 6/76 to set volume dumper bit map
   Modified 4/77 by M. Weaver to replace makeknown with makeknown_
   Modified 18 Feb 79 by D. Spector to extend root quota from 17 to 18 bits
   Modified February 1982 by C. Hornig to salvage root when necessary
   Modified March 1982 by J. Bongiovanni to eliminate use of FSDCT
   Modified October 1984 by K. Loepere for explicit activation of root.
*/

dcl  vtocx fixed bin;
dcl  pvtx fixed bin;
dcl  segno fixed bin;
dcl  code fixed bin (35);
dcl  cold bit (1) aligned;

dcl  pvt$rlv_needs_salv bit (1) aligned external;
dcl  pvt$root_pvtx fixed bin external;
dcl  pvt$root_vtocx fixed bin external;
dcl  sst$root_astep ptr external;

dcl  ROOT_UID bit (36) int static options (constant) init ((36)"1"b);

dcl  (addr, baseptr, binary, null, unspec) builtin;

dcl  create_root_dir entry (ptr);
dcl  create_root_vtoce entry;
dcl  find entry (char (*), ptr);
dcl  get_aste entry (fixed bin (9)) returns (ptr);
dcl  initialize_kst entry ();
dcl  makeknown_ entry (ptr, fixed bin, fixed bin, fixed bin (35));
dcl  pathname_am$initialize entry ();
dcl  pc$fill_page_table entry (ptr, ptr, fixed bin (9));
dcl  salvager$dir_salv_boot entry (char (*));
dcl  search_ast$hash_in entry (ptr);
dcl  syserr entry options (variable);
dcl  syserr$error_code entry options (variable);
dcl  vtoc_man$get_vtoce entry (bit (36) aligned, fixed bin, fixed bin, bit (3), ptr, fixed bin (35));

dcl  1 mk_info aligned like makeknown_info;

dcl  1 local_vtoce like vtoce aligned;
%page;
	intk_cardp = null ();
	call find ("intk", intk_cardp);		/* see if hierarchy is intact */
	cold = (intk_card.warm_or_cold = "cold");

	if cold then call create_root_vtoce;		/* Create the root */

	pvtx = pvt$root_pvtx;			/* Find the pack where the root is */
	vtocx = pvt$root_vtocx;			/* CONVENTION: root vtocx always 0 */
	vtocep = addr (local_vtoce);
	call vtoc_man$get_vtoce ("0"b, pvtx, vtocx, "111"b, vtocep, code);
	if code ^= 0 then call syserr$error_code (1, code, "init_root_dir: Error on root vtoce");

	sst$root_astep, astep = get_aste (64);		/* Obtain proper VTOC entry */
	aste.msl = vtoce.msl;			/* and activate the ROOT */
	aste.vtocx = vtocx;
	aste.pvtx = pvtx;
	aste.usedf, aste.gtus, aste.gtms, aste.nqsw, aste.dirsw, aste.master_dir, aste.ehs, aste.gtpd, aste.dnzp = "1"b;
	aste.dtu = vtoce.dtu;
	aste.dtm = vtoce.dtm;
	aste.csl = vtoce.csl;
	aste.records = vtoce.records;
	aste.quota (*) = vtoce.quota (*);
	aste.used (*) = vtoce.used (*);
	aste.tqsw (*) = "1"b;
	call pc$fill_page_table (astep, addr (vtoce.fm), binary (aste.csl, 9));
	aste.uid = ROOT_UID;
	call search_ast$hash_in (astep);

/* Set up Initializer's KST. Must be done after sys_info is initialized & before call to makeknown. */

	call initialize_kst;
	call pathname_am$initialize;

	unspec (mk_info) = "0"b;
	mk_info.uid = ROOT_UID;
	mk_info.entryp = null ();
	mk_info.dirsw = "1"b;
	mk_info.allow_write = "1"b;
	mk_info.activate = "1"b;
	call makeknown_ (addr (mk_info), segno, (0), code);
	if code ^= 0 then call syserr$error_code (1, code, "init_root_dir: Error from makeknown on root.");
	dp = baseptr (segno);

/* If this is a cold boot, set up the root directory. Code assumes new pages are zero. */

	if cold then call create_root_dir (dp);

	if dir.uid ^= ROOT_UID then call syserr (1, "init_root_dir: Root damaged.");

	if pvt$rlv_needs_salv | (dir.uid ^= ROOT_UID) | (dir.modify ^= ""b) then call salvager$dir_salv_boot (">");

	return;
%page;
%include aste;
%include config_intk_card;
%include dir_header;
%include makeknown_info;
%include vtoce;
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   init_root_dir: Error on root vtoce ERROR_MESSAGE

   S:	$crash

   T:	$init

   M:	The supervisor cannot locate the VTOC entry for the root directory.
   The RPV may have been damaged.

   A:	$recover
   A recovery of the RPV may be required.


   Message:
   init_root_dir: Error from makeknown on root ERROR_MESSAGE

   S:	$crash

   T:	$init

   M:	$err

   A:	Reboot with a different version of the system.


   Message:
   init_root_dir: Root damaged.

   S:	$crash

   T:	$init

   M:	The unique ID of the root directory
   in the directory header is incorrect.
   The contents of the RPV may have been damaged.

   A:	$recover
   A recovery of the RPV may be required.


   END MESSAGE DOCUMENTATION */

     end init_root_dir;
   



		    init_scavenger_data.pl1         11/11/89  1108.3r w 11/11/89  0826.9       41985



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(86-01-15,Fawcett), approve(86-04-11,MCR7383),
     audit(86-05-21,Coppola), install(86-07-17,MR12.0-1097):
     Add subvolume support.
                                                   END HISTORY COMMENTS */


/* format: style3 */
init_scavenger_data:
     proc;


/*  Program to initialize scavenger_data. The number of processes allowed
    to scavenge simultaneously is based on the size of scavenger_data,
    which may be changed by a TBLS SCAV card. 

    Written July 1982 by J. Bongiovanni
    Modified November 1982 by J. Bongiovanni for static process memory assignment
*/

/*  Automatic  */


dcl	first_free_page	fixed bin;
dcl	max_rec_per_sv	fixed bin;
dcl	n_free_pages	fixed bin;
dcl	pages_per_process	fixed bin;
dcl	processx		fixed bin;
dcl	pvtx		fixed bin;
dcl	sc_data_pages	fixed bin;
dcl	sc_data_words	fixed bin (19);

/*  Static  */

dcl	N_OVFL		fixed bin int static options (constant) init (1023);
dcl	N_OVERHEAD_PAGES	fixed bin int static options (constant) init (1);
dcl	SCAVENGER_WAIT_EVENT
			bit (36) aligned int static options (constant) init ("555000000000"b3);

/*  External  */

dcl	dseg$		(0:1023) fixed bin (71) external;

/*  Entry  */

dcl	sdw_util_$get_size	entry (ptr, fixed bin (19));
dcl	syserr		entry options (variable);

/*  Builtin  */

dcl	addr		builtin;
dcl	baseno		builtin;
dcl	bin		builtin;
dcl	divide		builtin;
dcl	hbound		builtin;
dcl       lbound		builtin;
dcl	rel		builtin;
dcl	size		builtin;

%page;
	max_rec_per_sv = 0;
	pvt_arrayp = addr(pvt$array);
	/* set the max record number for the largest device configured */
	do pvtx = lbound (pvt_array, 1) to hbound (pvt_array, 1);
	     pvtep = addr(pvt_array(pvtx));
	     if rec_per_sv (pvte.device_type) > max_rec_per_sv
	     then max_rec_per_sv = rec_per_sv (pvte.device_type);
	end;

	scavenger_n_records = max_rec_per_sv;
	scavenger_n_ovfl = N_OVFL;
	pages_per_process = divide (size (scavenger_block) + 1023, 1024, 17);

	scavenger_datap = addr (scavenger_data$);

	call sdw_util_$get_size (addr (dseg$ (bin (baseno (scavenger_datap)))), sc_data_words);
	sc_data_pages = divide (sc_data_words, 1024, 17);

	scavenger_data.lock.wait_event = SCAVENGER_WAIT_EVENT;

	sc_n_processes = divide (sc_data_pages - N_OVERHEAD_PAGES, pages_per_process, 17);
						/* Assume header is 1 page */
	if sc_n_processes < 1
	then call syserr (CRASH, "init_scavenger_data: scavenger_data is too small.");

	sc_process_tablep = addr (scavenger_data.free);
	scavenger_data.process_table_ptr = sc_process_tablep;
	sc_process_table.max_n_processes = sc_n_processes;

	first_free_page = divide (bin (rel (addr (scavenger_data.free))) + size (sc_process_table) + 1023, 1024, 17);
	n_free_pages = sc_data_pages - first_free_page + 1;
	if first_free_page > N_OVERHEAD_PAGES
	then call syserr (CRASH, "init_scavenger_data: scavenger_data inconsistency.");

	do processx = 1 to sc_n_processes;
	     sc_process_table.process (processx).blockp = addr (scavenger_data_pages.page (first_free_page));
	     sc_process_table.process (processx).first_block_page = first_free_page;
	     first_free_page = first_free_page + pages_per_process;
	     n_free_pages = n_free_pages - pages_per_process;
	     if n_free_pages < 0
	     then call syserr (CRASH, "init_scavenger_data: scavenger_data inconsistency.");
	end;

	scavenger_data.error_severity = ANNOUNCE;


	return;					/* format: off */
%page;  %include fs_dev_types;
%page;  %include pvte;
%page;  %include scavenger_data;
%page;  %include syserr_constants;
%page;
/* BEGIN MESSAGE DOCUMENTATION

Message:
init_scavenger_data: scavenger_data too small.

S:        $crash

T:        $init

M:        The size of the scavenger_data segment is too small. It can be 
increased by the TBLS SCAV config card. It must be at least 68KW, with an
additional 67KW for each additional process (beyond 1) which is to be
scavenging simultaneously.

A:        Correct the configuration deck and reboot.

Message:
init_scavenger_data: scavenger_data inconsistency.

T:        $init

S:	$crash

M:	An error was encountered initializing the scavenger's data base.

A:	$contact

END MESSAGE DOCUMENTATION */

     end init_scavenger_data;
   



		    init_sst_name_seg.pl1           11/11/89  1108.3rew 11/11/89  0826.9       33030



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


init_sst_name_seg: procedure;

/* This procedure is called by initialization to set up the names of the hardcore
   segments in the SST name table, if selected via the DEBG card.

   The SLT is scanned, and the names of all segments who are IN FACT (not necessarily in the SLT)
   paged are placed in the SST name table.  This must be done before the
   first seg_fault to tell BOS of the validity of this segment.

   Last Modified and Reason:

   Coded by Bernard Greenberg, 10/10/74
   Modified 03/21/81, W. Olin Sibert, for ADP PTWs and get_ptrs_$given_sdw
   Modified 9/83, Keith Loepere for paged, wired segs.
   Modified 8/84, Keith Loepere to rename sstnt.multics_or_bos.
   */

	dcl     slt$		 external static;
	dcl     sst_seg$		 external static;
	dcl     dseg$		 (0:1023) fixed bin (71) external static;
	dcl     sst$ast_track	 bit (1) aligned external static;
	dcl     sst$pts		 (0:3) fixed bin external static;
	dcl     unpaged_page_tables$	 external static;
	dcl     get_ptrs_$given_sdw	 entry (pointer) returns (pointer);
	dcl     sdw_util_$dissect	 entry (pointer, pointer);

	dcl     (pts, ptsi, segnum, segnam_size) fixed bin;

	dcl     1 sdwi		 aligned like sdw_info aligned automatic;

	dcl     (addr, bin, divide, ptr, rel, reverse, segno, substr, verify) builtin;


	if ^sst$ast_track then return;		/* No work called for */
	sstnp = addr (sst_names_$);			/* get ptr to SLT's name table seg */
	sltp = addr (slt$);				/* and the current 'name table */
	names_ptr = sltp -> slt.name_seg_ptr;		/* Get SLT name seg ptr. */

	sstnp -> sstnt.valid = "1"b;			/* Signify to BOS not to fill in */
	sstnp -> sstnt.multics_or_bce = "mult";
	upt_ptr = addr (unpaged_page_tables$);

	do segnum = sltp -> slt.first_sup_seg to sltp -> slt.last_sup_seg,
	     sltp -> slt.first_init_seg to sltp -> slt.last_init_seg;

	     sltep = addr (sltp -> slt.seg (segnum));	/* get ptr to SLTE of segment */
	     namep = ptr (names_ptr, sltep -> slte.names_ptr); /* get ptr to seg name block */
	     call sdw_util_$dissect (addr (dseg$ (segnum)), addr (sdwi));
	     if ^sdwi.faulted & sdwi.paged & (upt.sst_absloc <= sdwi.address & sdwi.address <= upt.sst_last_loc) then do; /* process segs with page tables in sst */
		     astep = get_ptrs_$given_sdw (addr (dseg$ (segnum))); /* Get the AST entry ptr */
		     ptsi = bin (astep -> aste.ptsi, 3);/* get pt size index from ASTE */
		     pts = sst$pts (ptsi);		/* and real Page Table size. */
		     segnam_size = 32 - verify (reverse (namep -> segnam.name (1)), " ") + 1;
		     sstnp -> sstnt.names (divide (bin (rel (astep), 18) - sstnp -> sstnt.ast_offsets (ptsi),
			sstnp -> sstnt.ast_sizes (ptsi), 17, 0) + sstnp -> sstnt.ast_name_offsets (ptsi))
			= substr (namep -> segnam.name (1), 1, segnam_size);
						/* Copy primary name into SST name table */
		end;
	end;

%page; %include sstnt;
%page; %include aste;
%page; %include slt;
%page; %include slte;
%page; %include sdw_info;
%page; %include unpaged_page_tables;
     end;
  



		    init_stack_0.pl1                11/11/89  1108.3r w 11/11/89  0826.9       74997



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


init_stack_0:
     proc;

/* Program to build stack 0 segs to be shared by users */
/* Created May 79 by Mike Grady */
/* Modified June 81 by J. Bongiovanni to call update_vtoce for each stack,
     retry by deleting on error */
/* Modified December 1981 by J. Bongiovanni to clear usage count in ASTE */
/* Modified November 1984 by Keith Loepere to rename terminate to terminate_ */

dcl  append$branchx entry (char (*), char (*), fixed bin (5), (*) fixed bin, char (*), fixed bin, fixed bin, fixed bin, fixed bin (35));
dcl  chname$cfile entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  delentry$dfile entry (char (*), char (*), fixed bin (35));
dcl  initiate entry (char (*), char (*), char (*), fixed bin, fixed bin, ptr, fixed bin (35));
dcl  truncate$trseg entry (ptr, fixed bin, fixed bin (35));
dcl  asd_$replace_sall entry (char (*), char (*), ptr, fixed bin, bit (1), fixed bin (35));
dcl  terminate_$noname entry (ptr, fixed bin (35));
dcl  grab_aste$prewithdraw entry (ptr, fixed bin, fixed bin (35)) returns (ptr);
dcl  get_ptrs_$given_astep entry (ptr) returns (bit (72) aligned);
dcl  syserr$error_code entry options (variable);
dcl  syserr entry options (variable);
dcl  unique_chars_ entry (bit(*)) returns(char(15));
dcl  update_vtoce entry (ptr);

dcl  error_table_$namedup fixed bin (35) ext;
dcl  dseg$ fixed bin ext;
dcl  active_all_rings_data$stack_base_segno fixed bin ext;
dcl  pds$apt_ptr ptr aligned ext;
dcl  pds$stack_0_sdwp ptr ext;
dcl  pds$stack_0_ptr ptr ext;

dcl  indx fixed bin;
dcl  count fixed bin;
dcl  stk_no fixed bin;
dcl  stk_segp ptr;
dcl  dirname char (20) int static options (constant) init (">system_library_1");
dcl  stack_name char (32);
dcl  pic picture "999";
dcl  new_stkp ptr;
dcl  code fixed bin (35);
dcl 1 tsdw like sdw;
dcl  seg_rb (3) fixed bin init (0, 0, 0) static options (constant);
dcl  retry bit (1);

dcl 1 acl (1) aligned,
    2 name char (32),
    2 mode bit (36),
    2 zp bit (36) init ("0"b),
    2 code fixed bin (35);

dcl 1 stack aligned based (sb),
    2 header like stack_header,
    2 frame_start fixed bin;

dcl  (addr, baseno, baseptr, fixed, null, ptr, rel, size, string) builtin;

/*  */

	new_stkp = baseptr (active_all_rings_data$stack_base_segno);
	sdtp = addr (stack_0_data$);

	count = sdt.num_stacks;
	indx = 1;					/* setup count and index for stack creation */
	stk_no = 1;
	stk_segp = null ();

	do while (count ^= 0);			/* build stack segs */
	     sdtep = addr (sdt.stacks (indx));		/* ptr to this entry */
	     retry = "1"b;				/* retry by deleting on error			*/

	     pic = stk_no;
	     stack_name = "stack_0." || pic;

retry_stack:
	     call append$branchx (dirname, stack_name, 01010b, seg_rb, "*.*.*", 0, 0, 0, code);
	     if code ^= 0 then do;
		if code = error_table_$namedup then;
		else call error ("append", code);
	     end;

	     acl.name = "Initializer.SysDaemon.*";
	     acl.mode = "101"b;
	     call asd_$replace_sall (dirname, stack_name, addr (acl), 1, "1"b, code);
	     if code ^= 0 then
		call error ("asd_", code);

	     call initiate (dirname, stack_name, "", 0, 0, stk_segp, code);
	     if code ^= 0 then
		call error ("initiate", code);

	     call truncate$trseg (stk_segp, 0, code);
	     if code ^= 0 then
		call error ("truncate", code);

	     astep = grab_aste$prewithdraw (stk_segp, 16*1024, code); /* get the correct aste */
	     if code ^= 0 then
		call error ("grab_aste", code);

	     seg_aste.usage = 0;			/* counts only meaningful since bootload, anyway */

	     call update_vtoce (astep);

	     string (tsdw) = get_ptrs_$given_astep (astep); /* get a real SDW for the stack seg */
	     tsdw.cache = "1"b;			/* stacks go in the cache */

	     sdte.sdw = string (tsdw);		/* fill in the sdte */
	     sdte.astep = rel (astep);
	     sdte.nextp = sdt.freep;			/* thread this guy into list */
	     sdt.freep = rel (sdtep);			/* and point free to this */

	     stk_segp -> stack_header_overlay = pds$stack_0_ptr -> stack_header_overlay;
	     sb = stk_segp;				/* for header re_build */
	     stack_header.stack_begin_ptr,
		stack_header.stack_end_ptr = ptr (new_stkp, rel (addr (stack.frame_start)));

	     call terminate_$noname (stk_segp, code);	/* we don't need this anymore */
	     stk_segp = null ();
	     call asd_$replace_sall (dirname, stack_name, addr (acl), 0, "1"b, code); /* delete ACL */

	     count = count - 1;
	     indx = indx + 1;

try_again:     stk_no = stk_no + 1;
	end;


	sdtep = ptr (sdtp, sdt.freep);		/* take first stack for Initializer */
	sdt.freep = sdte.nextp;			/* re-thread free list */
	sdte.nextp = "0"b;				/* claim this one */
	sdte.aptep = rel (pds$apt_ptr);		/* Initializers APTE */
	pds$apt_ptr -> apte.flags.shared_stack_0 = "1"b;	/* Has a shared ring-0 stack */

	sdwp = addr (dseg$);
	pds$stack_0_sdwp = addr (sdwa (fixed (baseno (new_stkp))));
	pds$stack_0_ptr = new_stkp;

	sdwp = pds$stack_0_sdwp;
	string (sdw) = sdte.sdw;			/* fill in correct SDW for Initializer's stack 0 */
	return;



error:	proc (who, code);

dcl  who char (*);
dcl  code fixed bin (35);

dcl  ecode fixed bin (35);
dcl  temp_stack_name char (32);

	if retry then do;
	     retry = "0"b;
	     call syserr (0, "init_stack_0: Error creating >sl1>^a from ^a. Retrying.",
		stack_name, who);
	     call syserr$error_code (0, code, "init_stack_0: ");
	     if stk_segp ^= null () then do;
		call terminate_$noname (stk_segp, ecode);
		stk_segp = null ();
	     end;
	     temp_stack_name = "stack_0." || unique_chars_ (""b);
	     call chname$cfile (dirname, stack_name, stack_name, temp_stack_name, ecode);
	     if ecode ^= 0 then call error ("chname", ecode);
	     call delentry$dfile (dirname, temp_stack_name, ecode);
	     if ecode ^= 0 then call error ("delentry", ecode);
	     goto retry_stack;
	end;
	else do;
	     call syserr (3, "init_stack_0: Error creating >sl1>^a from ^a. Stack skipped.", stack_name, who);
	     call syserr$error_code (0, code, "init_stack_0: ");
	     go to try_again;
	end;

	end;



%include apte;
%include aste;
%include stack_0_data;
%include sdw;
%include stack_header;

%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   init_stack_0: Error creating >sl1>XXXXXX from YYYYY. Retrying.

   S: $info

   T: $init

   M: An error was encountered in creating the stack_0 segment XXXXXX.  The 
   error was returned by module YYYYYY, and is described in detail in the
   following message.  init_stack_0 will attempt to correct the problem
   by renaming the segment XXXXXX to stack_0.<unique name>, deleting it,
   and retrying the creation of segment XXXXXX once.

   A: No action is required if the above actions correct the problem.
   If the message persists, it may be symptomatic of hardware or
   software problems, and it should be brought to the attention of
   the System Programming Staff.

   Message:
   init_stack_0: Error creating >sl1>XXXXXX from YYYYYY. Stack skipped.

   S: $info

   T: $init

   M: An error was encountered in creating the stack_0 segment XXXXXX.
   The error was returned by module YYYYYY, and is described in detail in the
   following message.  This error could not be corrected by renaming 
   the segment XXXXXX to stack_0.<unique name>, deleting it, and retrying
   the creation of segment XXXXXX once.  The stack_0 represented by
   segment XXXXXX is skipped, and there will be one fewer stack_0 than
   specified by the max_max_eligible tuning parameter for each message of
   this sort.

   A: This message may be symptomatic of hardware or software problems.
   It should be brought to the attention of the System Programming Staff.

   END MESSAGE DOCUMENTATION */

     end;
   



		    init_str_seg.pl1                11/11/89  1108.3r w 11/11/89  0826.9       16407



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


init_str_seg: proc;

/* Procedure to init trailer segment. */

/* Modified 04/17/81, WOS, to record the number of trailers created in the sst */

dcl  trp pointer;
dcl  idx fixed bin;

dcl  slt$ external static;

dcl  sst$tfreep pointer external static;
dcl  sst$strsize fixed bin external static;
dcl  sst$n_trailers fixed bin external static;
dcl  sys_info$page_size fixed bin external static;

dcl (addr, baseno, binary, divide, rel, size) builtin;

/*  */

	sst$tfreep = addr(str_seg$);			/* Pointer to trailer segment. */
	trp = sst$tfreep;

	sst$strsize = size (str);
	sltep = addr (addr (slt$) -> slt.seg (binary (baseno (trp))));
	sst$n_trailers = divide ((binary (slte.cur_length, 9) * sys_info$page_size), sst$strsize, 17, 0);

	do idx = 1 to sst$n_trailers; 		/* Initialize them all */
	     strp = addr (trp -> stra (idx - 1));	/* Pointer to this entry. */
	     strp -> str.dstep = "777777"b3;		/* set pattern in dstep */
	     strp -> str.fp = rel (sst$tfreep); 	/* Thread onto free list. */
	     sst$tfreep = strp;
	     end;

	return;

%page; %include str;
%page; %include slt;
%page; %include slte;

	end init_str_seg;
 



		    init_sys_var.pl1                11/11/89  1108.3rew 11/11/89  0826.9       42012



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/* format: style2 */
init_sys_var:
     procedure;

/* Updated for NSS 4/75 THVV */
/* Modified by E. Stone 10/73 to correct bug in construction of initializer's channel */
/* OPTY support removed April 1981 by Benson I. Margulies */
/* Modified for ADP SDWs, 05/01/81, W. Olin Sibert */
/* Modified by J. Bongiovanni, December 1981, to remove sst$asthtp setup */
/* Modified by J. Bongiovanni, February 1982, to eliminate FSDCT */
/* Modified by J. Bongiovanni, October 1982, for sst$checksum_filemap */
/* Modified BIM 830312 to move dir_lock initialization to its own program. */
/* Modified by Keith Loepere, January 1985 for sst$seg_state_chg_operation. */

/* This program used to parse a channel name like tty_NNN off of
   the now undocumented config card OPTY. Channel names do not look
   like that any more. FNP's are not loaded from BOS. 
   Therefore this has been decommissioned. If it is restored
   it should use config and not find to look at the deck. */

	dcl     dbrp		 pointer;
	dcl     stack_base		 fixed bin (14) unsigned;
	dcl     chn_name		 char (12);
	dcl     parm_ptr		 ptr;

	dcl     sst$seg_state_chg_operation
				 bit (36) aligned external static;
	dcl     sst$pvhtp		 pointer unaligned external static;
	dcl     sst$rqover		 fixed bin (35) external static;
	dcl     sst$checksum_filemap	 fixed bin external static;

	dcl     sys_info$system_type	 fixed bin external static;
	dcl     sys_info$time_of_bootload
				 fixed bin (71) ext;
	dcl     pvt$time_of_bootload	 fixed bin (71) ext;
	dcl     pds$apt_ptr		 ptr ext;
	dcl     active_all_rings_data$hcscnt
				 fixed bin ext;
	dcl     tc_data$max_hproc_segno
				 fixed bin ext;
	dcl     active_all_rings_data$stack_base_segno
				 fixed bin (18) ext;
	dcl     dseg$		 (0:1024) fixed bin (71) ext;
	dcl     access_operations_$excessive_seg_state_chg
				 bit (36) aligned external;
	dcl     error_table_$rqover	 fixed bin (35) external;
	dcl     slt$		 fixed bin ext;


	dcl     (addr, bin, mod, bit, divide, segno, size)
				 builtin;

	dcl     get_pvtx$ret_pvhtp	 entry returns (ptr);
	dcl     config_$find_parm	 entry (char (4) aligned, ptr);
	dcl     syserr		 entry options (variable);
%include syserr_constants;


	sltp = addr (slt$);
	stack_base = slt.last_sup_seg;		/* calculate hard core seg count */
	stack_base = 8 + stack_base - mod (stack_base, 8);/* Make it 0 mod 8 (for stack segno's). */
	active_all_rings_data$stack_base_segno, active_all_rings_data$hcscnt = stack_base;

	if tc_data$max_hproc_segno < stack_base
	then /* make sure hproc dsegs will be large enough */
	     call syserr (CRASH, "init_sys_var: max_hproc_segno < hcscnt of ^o.", stack_base);

	dbrp = addr (dseg$ (segno (addr (dseg$))));
	if sys_info$system_type = ADP_SYSTEM
	then do;					/* Set the stack base in the DSBR. */
		dbrp -> adp_dbr.stack_base_segno = divide (stack_base, 8, 14, 0);
		addr (pds$apt_ptr -> apte.dbr) -> adp_dbr.stack_base_segno = dbrp -> adp_dbr.stack_base_segno;
	     end;

	else do;
		dbrp -> l68_dbr.stack_base_segno = divide (stack_base, 8, 14, 0);
		addr (pds$apt_ptr -> apte.dbr) -> l68_dbr.stack_base_segno = dbrp -> l68_dbr.stack_base_segno;
	     end;					/* Set the stack base in the DSBR. */

	sys_info$time_of_bootload = pvt$time_of_bootload; /* get bootload time */

	sst$pvhtp = get_pvtx$ret_pvhtp ();

	sst$rqover = error_table_$rqover;		/* set up RQO error code */
	sst$seg_state_chg_operation = access_operations_$excessive_seg_state_chg;

	call config_$find_parm ("nock", parm_ptr);
	if parm_ptr = null ()
	then sst$checksum_filemap = 1;

	return;

/* format: off */
%page; %include apte;
%page; %include slt;
%page; %include "dbr.l68";
%page; %include "dbr.adp";
%page; %include system_types;



/* BEGIN MESSAGE DOCUMENTATION

Message:
init_sys_var: max_hproc_segno < hcscnt of XXX

S:	$crash

T:	$init

M:	The upper bound of the descriptor segment for hardcore processes is too small.
$err

A:	$recover
$boot_tape


END MESSAGE DOCUMENTATION */

     end init_sys_var;




		    init_syserr_log.pl1             11/11/89  1108.3r w 11/11/89  0826.9      221949



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        *                                                         *
        *********************************************************** */

/* format: style4 */

init_syserr_log:
     procedure ();

/* *	INIT_SYSERR_LOG
   *
   *	This procedure is called early in collection II initialization.
   *	It performs the following major initialization tasks:
   *	1.  Sets up the log partition so it can be referenced as paged segments.
   *	2.  If the version in the paged syserr_log_data segment is not
   *	    correct, then we initialize the paged syserr_log_data segment.
   *	3.  Initializes the wired log buffer in syserr_data$syserr_area
   *	4.  Creates the syserr HPROC.
   *
   *	Modification history:
   *	73-08-11, Bill Silver: Initial coding
   *	75-11-02, Larry Johnson: Modified for new log and message format
   *	76-03-23, Steve Webber: Modified to create HPROC for logging
   *	77-04-11, Bernard Greenberg: Modified for syserr_daemon segments
   *	79-05-26, Mike Grady: Modified for ring zero stack sharing
   *	81-07-09, Ellie Donner: Modified for new format of event channel names
   *	82-03-20, John Bongiovanni: Eliminated use of FSDCT
   *	84-08-24, W. Olin Sibert: Modifications (part 1) for new syserr log format:
   *	   Three segments in the partition, new log format, name changed from
   *	   syserr_log_init to init_syserr_log, diagnose no PART LOG card.
   *      84-11-16 by E. Swenson: Changed for new IPC validation.
   *      1984-12-03, BIM: change to a fast lock.
   *      1984-12-05 by E. Swenson:  Fixed to not use regular event channel.
   *	1984-12-10 by Keith Loepere: To force LOG part onto RPV until
   *	   init_branches becomes smarter.
   *	1985-03-03, EJ Sharpe: added check for service bit, format,
   *	   and set history_dir in log header at partition initialization
   *	1985-03-25, EJ Sharpe: fixed subscript error, cleanup syserr messages
*/

declare  code fixed bin (35);
declare  log_part_pvtx fixed bin;
declare  log_part_start fixed bin (18);
declare  log_part_size fixed bin (18);
declare  part_idx fixed bin;
declare  r_offset fixed bin (18);			/* used in IPC event channel creation and validation */
declare  r_factor fixed bin (35);			/* ditto */
declare  rpv_label bit (36 * 1024) aligned;
declare  special_channel fixed bin (71);		/* event channel for syserr copy wakeups */

declare  initializing bit (1) aligned;			/* Set if we are reinitializing partition */
declare  test_mode bit (1) aligned;			/* Sets up a ring four test environment */

declare  log_data_$syserr_log_dir char (32) external static;
declare  log_data_$syserr_log_history_dir char (168) external static;
declare  log_data_$syserr_log_partition char (4) external static;
declare  log_data_$syserr_log_daemon char (32) external static;
declare  pds$process_id bit (36) aligned external static;
declare  pds$process_group_id char (32) external static;
declare  pvt$root_pvtx fixed bin external static;
declare  sys_info$page_size fixed bin external static;
declare  syserr_data$log_meters fixed bin external static;
declare  syserr_data$wired_log_size fixed bin external static;
declare  syserr_data$logger_proc_id bit (36) aligned external static;
declare  syserr_data$logger_ec fixed bin (71) external static;

declare  syserr_log_laurel$ fixed bin external static;
declare  syserr_log_hardy$ fixed bin external static;

declare  create_hproc$early_hproc entry (char (*),
	    bit (1) aligned, pointer, pointer, pointer, pointer, pointer, fixed bin (35));
declare  ipc_validate_$encode_event_channel_name entry (fixed bin (18), fixed bin (35), bit (3) aligned, fixed bin (15), fixed bin (3), bit (1) aligned, fixed bin (18), fixed bin (71));
declare  log_initialize_ entry (pointer, pointer, fixed bin (18), char (*), fixed bin (35));
declare  log_segment_$create_message entry (pointer, fixed bin, fixed bin, char (10) varying, pointer, fixed bin (35));
declare  log_segment_$finish_message entry (pointer, pointer, fixed bin (35));
declare  log_segment_$get_service_bit entry (ptr, bit (1) aligned, fixed bin (35));
declare  log_segment_$last_message_info entry (pointer, fixed bin (35), fixed bin (18), fixed bin (35));
declare  log_segment_$place_in_service entry (pointer, fixed bin (35));
declare  log_segment_$remove_from_service entry (pointer, fixed bin (35));
declare  map_onto_disk entry (fixed bin, fixed bin (20), fixed bin, pointer, bit (1) aligned);
declare  read_disk entry (fixed bin, fixed bin (18), ptr, fixed bin (35));
declare  syserr entry options (variable);
declare  syserr$error_code entry options (variable);
declare  syserr_log_daemon entry ();
declare  tc_util$get_ipc_operands_priv entry (bit (36) aligned, fixed bin (18), fixed bin (35), fixed bin (35));

declare  FAST_CHANNEL_TYPE bit (1) aligned internal static options (constant) initial ("0"b);
declare  WHOAMI char (32) internal static options (constant) init ("init_syserr_log");

declare  (abs, addr, baseno, binary, clock, codeptr, copy, dimension, divide, length, null, rel, sign, size, sum, unspec) builtin;
%page;

	test_mode = "0"b;
	goto BEGIN_INITIALIZATION;



init_syserr_log$test:
     entry ();

	test_mode = "1"b;				/* This entrypoint sets up a ring four test environment */

/* First, locate and check out the wired data area. */
/* NOTE: THIS CHANGES WHEN THE WIRED AREA IS CONVERTED TO LOG SEGMENTS */

BEGIN_INITIALIZATION:
	wlog_ptr = addr (syserr_data$wired_log_area);
	sd_ptr = addr (syserr_data$syserr_area);
	if (size (wlog) > syserr_data$wired_log_size) then
	     call syserr (SYSERR_CRASH_SYSTEM, "^a: Size of wired log is inconsistent.", WHOAMI);

/* Next, locate the LOG partition. If none, we do no logging, but we
   say so (a new message) because it's almost sure to be a mistake. */

	if ^test_mode then do;			/* Don't play with the partition in test mode */

/*	     call partition_io$find_partition (log_data_$syserr_log_partition,
   log_part_pvtx, (""b), log_part_start, log_part_size, code); */
	     labelp = addr (rpv_label);
	     log_part_pvtx = pvt$root_pvtx;
	     call read_disk (log_part_pvtx, 0, labelp, code);
	     if code ^= 0 then go to log_part_error;
	     do part_idx = 1 to label.nparts while (label.parts (part_idx).part ^= log_data_$syserr_log_partition);
	     end;
	     if part_idx > dimension (label.parts, 1) then do;
log_part_error:	call syserr (SYSERR_CRASH_SYSTEM, "^a: No LOG partition found, syserr logging disabled.", WHOAMI);
		return;
	     end;
	     log_part_start = label.parts (part_idx).frec;
	     log_part_size = label.parts (part_idx).nrec;
	end;

	else log_part_size = 3;			/* Give each segment 1 record */

/* Next, setup the syserr_log_data segment. It is always one page long,
   and located in the first record of the partition. */

	syserr_log_data_ptr = addr (syserr_log_data$);
	call setup_segment (syserr_log_data_ptr, 0, 1);

/* See if it has valid contents. If not, reinitialize it; if so, re-use it */

	initializing = ^syserr_data_valid ();		/* See if there's anything useful there now */
	if initializing then			/* If not, rebuild syserr_dta first */
	     call initialize_syserr_data ();

/* Set up the two alternating buffer segments; their locations may have been
   remembered, or set up by initialize_syserr_data if we reinitialize */

	syserr_log_data.log_ptr (1) = addr (syserr_log_laurel$);
	syserr_log_data.log_ptr (2) = addr (syserr_log_hardy$);

	syserr_log_data.log_name (1) = "syserr_log_laurel";
	syserr_log_data.log_name (2) = "syserr_log_hardy";
	syserr_log_data.log_dir = log_data_$syserr_log_dir;
	call setup_segment (syserr_log_data.log_ptr (1), syserr_log_data.log_start (1), syserr_log_data.log_size (1));
	call setup_segment (syserr_log_data.log_ptr (2), syserr_log_data.log_start (2), syserr_log_data.log_size (2));

	unspec (syserr_log_data.lock) = ""b;
	syserr_log_data.lock.event_id = binary ("105"b3); /* Initialize per-bootload items */

	if initializing then			/* If we are rebuilding, re-set the log segments */
	     call initialize_log_segments ();		/* In both cases, these set wlog.seq_num appropriately */
	else call check_log_segments ();		/* Otherwise, just check the contents */

	wlog.next = rel (addr (wlog.buffer));		/* Also set some other variables in the wired buffer */
	wlog.count = 0;
	addr (syserr_data$log_meters) -> olm.last_time = clock ();

	if test_mode then				/* Set up IPC event-call kludge */
	     call create_ring_four_test_logger ();
	else call create_syserr_daemon ();		/* Create the daemon, and, if we make it this far, */
	syserr_log_data.test_mode = test_mode;		/* Keep track of test mode operation */

	if initializing then			/* If we are rebuilding, make it be finally valid */
	     syserr_log_data.version = SYSERR_LOG_DATA_V1;

	sd.log_flag = "1"b;				/* tell the daemon to start logging messages. */

MAIN_RETURN:
	return;
%page;

setup_segment:
     procedure (P_seg_ptr, P_first_rec, P_seg_lth);

declare  P_seg_ptr pointer parameter;
declare  P_first_rec fixed bin parameter;
declare  P_seg_lth fixed bin parameter;

declare  segno fixed bin;

declare  slt$ fixed bin external static;

/* This procedure is used to set up an ASTE for the specified hardcore
   segment (P_seg_ptr), the pages of which map onto a particular portion
   of the LOG partition. */


	if test_mode then				/* This has no meaning in test mode */
	     return;

	segno = binary (baseno (P_seg_ptr));

	sltp = addr (slt$);				/* Check to see that the resulting page table will */
	sltep = addr (slt.seg (segno));		/* be large enough; that is, was declared large */
	if (P_seg_lth > binary (slte.max_length)) then	/* enough in the header. */
	     call syserr (SYSERR_CRASH_SYSTEM, "^a: Size of ^p larger on disk than in header.", WHOAMI, P_seg_ptr);

	call map_onto_disk				/* Pop the abs-seg onto the right place in the partition */
	     (log_part_pvtx, (log_part_start + P_first_rec), P_seg_lth, P_seg_ptr, "1"b);

	return;
     end setup_segment;
%page;

syserr_data_valid:
     procedure () returns (bit (1) aligned);

declare  allocation_error bit (1) aligned;


	if (syserr_log_data.version ^= SYSERR_LOG_DATA_V1) then
	     return ("0"b);

/* These tests verify that the first log segment thinks it starts immediately
   after the one-page header, that the second starts immediately after that,
   that no values are negative, that they don't overflow the partition, and
   that they are evenly balanced */

	if (syserr_log_data.log_start (1) ^= 1) then
	     allocation_error = "1"b;
	else if (syserr_log_data.log_start (2) ^= (1 + syserr_log_data.log_size (1))) then
	     allocation_error = "1"b;
	else if (sum (sign (syserr_log_data.log_start)) ^= 2) then
	     allocation_error = "1"b;
	else if (sum (sign (syserr_log_data.log_size)) ^= 2) then
	     allocation_error = "1"b;
	else if ((sum (syserr_log_data.log_size) + 1) > log_part_size) then
	     allocation_error = "1"b;
	else if (abs (syserr_log_data.log_size (1) - syserr_log_data.log_size (2)) > 2) then
	     allocation_error = "1"b;
	else if (syserr_log_data.live_log ^= 1) & (syserr_log_data.live_log ^= 2) then
	     allocation_error = "1"b;
	else allocation_error = "0"b;

	if allocation_error then do;
	     call syserr (SYSERR_PRINT_WITH_ALARM, "^a: LOG partition damaged. Reinitializing.", WHOAMI);
	     return ("0"b);
	end;

/* If the syserr_log_data appears to be valid, then we reinitialize the
   per-bootload values before returning; if not, this job will be taken
   care of by initialize_syserr_data. */

	unspec (syserr_log_data.per_bootload) = ""b;
	syserr_log_data.log_ptr (*) = null ();

	return ("1"b);
     end syserr_data_valid;
%page;

initialize_syserr_data:
     procedure ();

declare  segment_size fixed bin;

/* This procedure reinitializes the contents of the partition, splitting it
   as evenly as possible between the two segments. It initializes all the
   permanent information in syserr_log_data EXCEPT the version number,
   which gets set after everything else is correct. */


	if (syserr_log_data.old_init_word = "INIT") then
	     call syserr (SYSERR_PRINT_ON_CONSOLE, "^a: Converting MR10.2 syserr partition", WHOAMI);

	unspec (syserr_log_data) = ""b;		/* Clean it out */

	segment_size = divide ((log_part_size - 1), 2, 17, 0); /* Remember a page for the header */

	syserr_log_data.log_start (1) = 1;
	syserr_log_data.log_start (2) = 1 + segment_size;
	syserr_log_data.log_size (*) = segment_size;

	syserr_log_data.old_init_word = "*NEW";

	syserr_log_data.live_log = 1;
	syserr_log_data.swap_time = 0;		/* This marks the other log as empty */

	syserr_log_data.log_ptr (*) = null ();		/* Just to catch errors */

	return;
     end initialize_syserr_data;
%page;

initialize_log_segments:
     procedure ();

declare  log_idx fixed bin;
declare  sys_log_ptr pointer;
declare  log_size fixed bin (18);
declare  INITIAL_MESSAGE char (100) varying internal static options (constant) init
	    ("init_syserr_log: Syserr LOG partition reinitialized.");


	do log_idx = 1, 2;				/* Two segments */
	     sys_log_ptr = syserr_log_data.log_ptr (log_idx);
	     log_size = syserr_log_data.log_size (log_idx) * sys_info$page_size;

	     call log_initialize_ (null (), sys_log_ptr, log_size, "", code);
	     if (code ^= 0) then
		call syserr (SYSERR_CRASH_SYSTEM, "^a: Cannot initialize paged syserr log ^p", WHOAMI, sys_log_ptr);
	     call log_segment_$remove_from_service (sys_log_ptr, (0));
	end;

	sys_log_ptr = syserr_log_data.log_ptr (syserr_log_data.live_log);
	call log_segment_$place_in_service (sys_log_ptr, (0));
	sys_log_ptr -> log_segment.previous_log_dir = log_data_$syserr_log_history_dir;
	call log_segment_$create_message (sys_log_ptr, length (INITIAL_MESSAGE), 0, "", log_message_ptr, code);
	if (code ^= 0) then
	     call syserr (SYSERR_CRASH_SYSTEM, "^a: Cannot write initial message to paged syserr log ^p", WHOAMI, sys_log_ptr);

	log_message.time = clock ();
	log_message.severity = 0;
	log_message.process_id = pds$process_id;
	log_message.text = INITIAL_MESSAGE;

	call log_segment_$finish_message (sys_log_ptr, log_message_ptr, (0));

	wlog.seq_num = log_message.sequence;

	call syserr (SYSERR_PRINT_ON_CONSOLE, log_message.text);

	return;
     end initialize_log_segments;
%page;

check_log_segments:
     procedure ();

declare  last_log_ptr pointer;
declare  last_message_number fixed bin (35);
declare  service_bit bit (1) aligned;

	last_log_ptr = syserr_log_data.log_ptr (syserr_log_data.live_log);
	call log_segment_$last_message_info (last_log_ptr, last_message_number, (0), code);
	if (code ^= 0) then do;
	     call syserr$error_code (SYSERR_PRINT_ON_CONSOLE, code,
		"^a: Cannot get last message info from paged syserr log ^p", WHOAMI, last_log_ptr);

	     initializing = "1"b;
	     call initialize_log_segments ();

	     return;
	end;

	call log_segment_$get_service_bit (last_log_ptr, service_bit, code);
	if (code ^= 0) then do;
	     call syserr$error_code (SYSERR_PRINT_ON_CONSOLE, code,
		"^a: Cannot get service bit from paged syserr log ^p", WHOAMI, last_log_ptr);
	     initializing = "1"b;
	     call initialize_log_segments ();
	     return;
	end;

	if (service_bit ^= "1"b) then do;
	     call syserr (SYSERR_PRINT_ON_CONSOLE, "^a: Service bit off for live paged syserr log ^p.", WHOAMI, last_log_ptr);
	     initializing = "1"b;
	     call initialize_log_segments ();
	     return;
	end;

	wlog.seq_num = last_message_number;

	return;
     end check_log_segments;
%page;

create_syserr_daemon:
     procedure ();

/* This procedure creates the HPROC and fills in variables so syserr_real knows
   how to call upon it. Note that its stack, PDS, and DSEG are defined in the header  */

declare  1 syserr_stk aligned based (sb),		/* Overlay for initializing daemon's stack */
	 2 header like stack_header,
	 2 frame like stack_frame;

declare  syserr_daemon_dseg$ fixed bin external static;
declare  syserr_daemon_pds$ fixed bin external static;
declare  syserr_daemon_stack$ fixed bin external static;
declare  pds$stack_0_ptr pointer external static;


	sb = addr (syserr_daemon_stack$);		/* base of syserr's ring 0 stack */
	stack_header_overlay = pds$stack_0_ptr -> stack_header_overlay; /* copy the stack header */

	stack_header.stack_begin_ptr = addr (syserr_stk.frame); /* setup first frame ptrs */
	stack_header.stack_end_ptr = addr (syserr_stk.frame);

	call create_hproc$early_hproc (log_data_$syserr_log_daemon, "0"b, aptep, codeptr (syserr_log_daemon),
	     addr (syserr_daemon_dseg$), addr (syserr_daemon_pds$), addr (syserr_daemon_stack$), code);
	if code ^= 0 then do;
	     call syserr (SYSERR_PRINT_ON_CONSOLE, "^a: Cannot create logger process.", WHOAMI);
	     goto MAIN_RETURN;
	end;

	syserr_data$logger_proc_id = apte.processid;	/* for use by syserr_real */

/**** In order to create an event channel, a process must know its values
      of R-Offset and R-Factor.  These were set up when the process was
      created. Retrieve then now from the APTE.  create_hproc set them. */

	call tc_util$get_ipc_operands_priv (apte.processid, r_offset, r_factor, code);
	if code ^= 0 then do;
	     call syserr (SYSERR_PRINT_ON_CONSOLE, "^a: Unable to retrieve IPC operands from APTE.  Syserr log copying disabled.", WHOAMI);
	     goto MAIN_RETURN;
	end;

/**** Create a valid (encoded) event channel name. */

	call ipc_validate_$encode_event_channel_name (r_offset, r_factor, "000"b /* flags */, 1 /* index */, 0 /* ring */, FAST_CHANNEL_TYPE, 1 /* unique id */, special_channel);

	syserr_data$logger_ec = special_channel;

	return;
     end create_syserr_daemon;
%page;

create_ring_four_test_logger:
     procedure ();

/* This procedure causes all sorts of nasty error messages if it is included
   as-is on the system tape, because it goes in a temp-seg, yet contains
   links to things not in ring zero. So, we have a nasty kludge to avoid it,
   using comments instead of pl1_macro just to make the thing easier to
   compile.  The real (external) entry declarations are commented out in
   the installed version, and replaced by entry variable declarations that
   all turn into calls to pxss$block (no special reason, save that it's
   guaranteed not to be found).

   To run this in the outer ring, just un-comment the first set of
   declarations, and comment out the second. */

/* COMMENTED OUT FOR RING ZERO INSTALLED VERSION

   declare	com_err_ entry options (variable);
   declare	get_group_id_ entry () returns (char (32) aligned);
   declare	get_lock_id_ entry () returns (bit (36) aligned);
   declare	get_process_id_ entry () returns (bit (36) aligned);
   declare	ioa_ entry options (variable);
   declare	ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
   declare	ipc_$decl_event_call_chn entry (fixed bin(71), entry, pointer, fixed bin, fixed bin (35));

   COMMENTED OUT FOR RING ZERO INSTALLED VERSION */

/* KLUDGE DECLARATIONS LEFT IN RING ZERO INSTALLED VERSION */

declare  1 kludge_entries variable automatic,
	 2 com_err_ entry options (variable),
	 2 get_group_id_ entry () returns (char (32) aligned),
	 2 get_lock_id_ entry () returns (bit (36) aligned),
	 2 get_process_id_ entry () returns (bit (36) aligned),
	 2 ioa_ entry options (variable),
	 2 ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35)),
	 2 ipc_$decl_event_call_chn entry (fixed bin (71), entry, pointer, fixed bin, fixed bin (35));

	unspec (kludge_entries) = copy ("040"b3, (4 * size (kludge_entries))); /* Force fault_tag_1 */

/* KLUDGE DECLARATIONS LEFT IN RING ZERO INSTALLED VERSION */

declare  pds$processid bit (36) aligned external static;


	call ipc_$create_ev_chn (syserr_data$logger_ec, code);
	if (code ^= 0) then goto IPC_ERROR;

	call ipc_$decl_event_call_chn (syserr_data$logger_ec, syserr_log_daemon, null (), 0, code);
	if (code ^= 0) then do;
IPC_ERROR:     call com_err_ (code, WHOAMI, "Cannot create IPC channel for test logger.");
	     return;
	end;

	syserr_data$logger_proc_id = get_process_id_ ();
	pds$processid = get_lock_id_ ();
	pds$process_group_id = get_group_id_ ();
	sd.ocdcm_init_flag = "1"b;			/* Let's claim that ocdcm_ works, too */
						/* syserr message MUST come BEFORE the log flag is turned on
						   because logging is not really operational until after
						   collection 1 is done */

	call ioa_ ("^a: Syserr log test environment initialized", WHOAMI);

	return;
     end create_ring_four_test_logger;

/* format: off */
%page; %include add_type;
%page; %include apte;
%page; %include ect_structures;
%page; %include oc_log_meters;
%page; %include slt;
%page; %include slte;
%page; %include stack_frame;
%page; %include stack_header;
%page; %include syserr_data;
%page; %include syserr_log_dcls;
%page; %include syserr_constants;
%page; %include log_segment;
%page; %include log_message;
%page; %include fs_vol_label;
%page;

/* BEGIN MESSAGE DOCUMENTATION

   Message:
   init_syserr_log: Size of wired log is inconsistent.

   S:     $crash

   T:     $init

   M:     The definitions in syserr_data.cds are inconsistent with those
in syserr_data.incl.pl1.  This indicates a programming error.

   A:     $recover


   Message:
   init_syserr_log: No LOG partition found, syserr logging disabled.

   S:     $crash

   T:     $init

   M:     The system requires a LOG partition on the RPV disk to hold
syserr messages before they are copied into >sc1>syserr_log. This partition
must exist on the volume, and be defined by a "PART LOG" card in the config deck.

   A:     Create a LOG partition on the RPV and define it in the config
deck, then re-boot. The LOG partition should be at least 200 records long,
and may be as large as 513.


   Message:
   init_syserr_log: Size of PTR larger on disk than in header.

   S:     $crash

   T:     $init

   M:     The LOG partition has been damaged. Some messages may be lost
if the previous shutdown was caused by a crash.

   A:     Reinitialize the LOG partition with the BCE test_disk command and re-boot.


   Message:
   init_syserr_log: LOG partition damaged. Reinitializing.

   S:     $beep

   T:     $init

   M:     The LOG partition has been damaged. Some messages may be lost
if the previous shutdown was caused by a crash. The partition is automatically
reinitialized.

   A:     $recover


   Message:
   init_syserr_log: Converting MR10.2 syserr partition.

   S:     $info

   T:     $init

   M:     This message occurs during the first bootload with an MR11.0 system
tape, and indicates that the LOG partition is now in the new format.

   A:     $ignore


   Message:
   init_syserr_log: Cannot initialize paged syserr log PTR.

   S:     $crash

   T:     $init

   M:     $err

   A:     $recover


   Message:
   init_syserr_log: Cannot write initial message to paged syserr log PTR.  ERROR-MESSAGE

   S:     $crash

   T:     $init

   M:     $err

   A:     $recover
It may be necessary to reinitialize the LOG partition with the BCE
test_disk command after this error.


   Message:
   init_syserr_log: Cannot get last message info from paged syserr log PTR.  ERROR-MESSAGE

   S:     $info

   T:     $init

   M:     $err

   A:     $recover
It may be necessary to reinitialize the LOG partition with the BCE
test_disk command after this error.


   Message:
   init_syserr_log: Cannot create logger process. ERROR-MESSAGE

   S:     $info

   T:     $init

   M:     $err
No syserr messages will be logged during this bootload.

   A:     $recover


   Message:
   init_syserr_log: Unable to retrieve IPC operands from APTE.  Syserr log copying disabled.

   S:	$info

   T:	$init

   M:	$err
No syserr messages will be logged during this bootload.

   A:	$recover


   Message:
   init_syserr_log: Cannot get service bit from paged syserr log PTR.  MESSAGE

   S:	$info

   T:	$init

   M:	$err
	Some error occurred when attempting to check the in service bit
	for the specified ring 0 paged log segment.

   A:	$ignore
	The log partition will be automatically reinitialized.


   Message:
   init_syserr_log: Service bit off for live paged syserr log PTR.

   S:	$info

   T:	$init

   M:	The in service flag for the specified ring 0 paged log segment
	was found off.  Being this is supposed to be the live log, an
	error is indicated.  This may occur when booting after a system
	crash.

   A:	$ignore
	The syserr log partition will be automatically reinitialized.


   END MESSAGE DOCUMENTATION
   */

          end init_syserr_log;
   



		    init_vtoc_man.pl1               11/11/89  1108.3r w 11/11/89  0826.9       30303



/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */
/* format: style3 */
init_vtoc_man:
     proc;

/*



				init_vtoc_man	





             The "init_vtoc_man" procedure initializes all constants located  in
          the  header  of the vtoc buffer segment. 

	It gets the number of buffers to use from the vtb parameter found
	on one of the parm cards.


	Modified by :

          07/09/82  J. Bongiovanni for new VTOC buffer strategy
	02/14/76	Steve Webber to call get_main
	06/20/75	Andre Bensoussan.

	*/


/*  Automatic  */

dcl	code		fixed bin (35);
dcl	mask		bit (36) aligned;
dcl	tsdw		fixed bin (71);

/*  Static  */

dcl	DEFAULT_MASK	bit (36) aligned int static options (constant) init ("000000000037"b3);
dcl	DEFAULT_N_BUCKETS	fixed bin int static options (constant) init (32);
dcl	DEFAULT_N_BUFFERS	fixed bin int static options (constant) init (30);
dcl	WAIT_EVENT	bit (36) aligned int static options (constant) init ("333000000000"b3);

/*  Entry  */

dcl	absadr		entry (ptr, fixed bin (35)) returns (fixed bin (24));
dcl	find_parm		entry (char (4) aligned, ptr);
dcl	get_main		entry (ptr, fixed bin (18), fixed bin (71));
dcl	pmut$swap_sdw	entry (ptr, ptr);
dcl	syserr		entry options (variable);

%page;
	vtoc_buffer_segp = addr (vtoc_buffer_seg$);

/* Determine the number of VTOCE buffers */

	call find_parm ("vtb ", parm_ptr);
	if parm_ptr = null ()
	then vtoc_buf_n_buffers = DEFAULT_N_BUFFERS;
	else vtoc_buf_n_buffers = numeric_parm.value;

/* Determine the number of hash buckets (currently constant)  */

	vtoc_buf_n_buckets = DEFAULT_N_BUCKETS;
	mask = DEFAULT_MASK;

/* Get contiguous memory for vtoc_buffer_seg and establish its SDW */

	call get_main (vtoc_buffer_segp, size (vtoc_buffer), tsdw);
	call pmut$swap_sdw (vtoc_buffer_segp, addr (tsdw));

/* Fill in vtoc_buffer_seg */

	vtoc_buffer.lock.wait_event = WAIT_EVENT;
	vtoc_buffer.n_bufs = vtoc_buf_n_buffers;
	vtoc_buffer.n_hash_buckets = vtoc_buf_n_buckets;
	vtoc_buffer.hash_mask = mask;

	vtoc_buffer.abs_addr = absadr (vtoc_buffer_segp, code);
	if code ^= 0
	then call syserr (CRASH, "init_vtoc_man: Unexpected error from absadr. Code ^o", code);

	vtoc_buffer.wait_event_constant = bin (WAIT_EVENT, 36);

	vtoc_buf_desc_arrayp = addr (vtoc_buffer.buf_desc);
	vtoc_buf_arrayp = addr (vtoc_buffer.buffer);

	vtoc_buffer.buf_desc_offset = rel (vtoc_buf_desc_arrayp);
	vtoc_buffer.buf_offset = rel (vtoc_buf_arrayp);
	vtoc_buffer.hash_table_offset = rel (addr (vtoc_buffer.hash_table));
	vtoc_buffer.search_index = 1;

	return;
%page;
%include config_parm_card;
%page;
%include syserr_constants;
%page;
%include vtoc_buffer;
%page;
/* BEGIN MESSAGE DOCUMENTATION


Message:
init_vtoc_man: Unexpected error from absadr. Code XX.

S:        $crash

T:	$init

M:	The absolute address of vtoc_buffer_seg could not be determined.
This indicates hardware or software malfunction.

A:        $recover


END MESSAGE DOCUMENTATION */

     end init_vtoc_man;




		    bull_copyright_notice.txt       08/30/05  1008.4r   08/30/05  1007.3    00020025

                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group Bull including Bull HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell Bull Inc., Groupe Bull
and Bull HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato.Users consider that Multics provided the best software architecture for 
managing computer hardware properly and for executing programs. Many subsequent operating systems
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, Bull or Bull HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by Bull HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
