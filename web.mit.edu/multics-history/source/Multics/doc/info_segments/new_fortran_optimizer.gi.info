05/28/80  new_fortran optimizer

With the new_fortran (fortran, ft) command, the -optimize (-ot)
control argument invokes a loop optimizer and a machine dependant
global optimizer (register optimizer).


Loop optimizer:
A loop optimizer is an optimizer that is cognizant of the flow of
control in a program and uses that information to improve the code
generated by the compiler.


Examples of loop optimization:
Calculations can be moved out of do-loops if the calculation is not
dependent on the do-loop index.  Identical sub-expressions can be
combined, and therefore only be calculated once, if the value of the
sub-expression does not change in between its uses.  Whole assignment
statements can be removed if the variable is assigned a new value
before it is used.  Assignment statements can also be removed if they
set automatic variables and are immediately followed by a return
statement.


This optimizer is considerably more powerful than the previous
new_fortran optimizer (New Fortran Release 3 or earlier) and provides
several new types of optimization, including strength reduction, test
replacement, dead assignment removal, expansion of statement functions
in-line, partial evaluation of logical expressions in logical if
statements, removal of unused assignments, removal of invariant code
from do-loops, and combining of identical sub-expressions.


Strength reduction:
A variable that is a simple arithmetic function of the do-loop index
can be calculated as repeated additions instead of a multiplication.


Test replacement:
If a do-loop index is not used at all, either within the do-loop or
within the extended range of that do-loop, and there is a variable
within the loop that is a simple arithmetic function of the do-loop
index, then the do-loop end condition test is changed to use that
variable, rather than the do-loop index.


Dead assignment removal:
Assignments to do-loop index are not performed if the do-loop index is
not used at all, either within the do-loop or within the extended
range of that do-loop.


Removal of invariants:
Expressions that are invariant within a do-loop are moved to the next
higher loop.


Partial evaluation of expressions:
Expressions in logical if statements are only evaluated until the
truth value of the expression is completely known.


Array subscripting has been vastly improved.


Statement function references:
References to statement functions are expanded in-line and are
therefore subject to combined sub-expression optimization.


Combining identical sub-expressions:
Whenever the flow of the program allows, identical sub-expressions are
pooled, that is, the expression is calculated once and stored in a
temporary where it can be referenced as needed.


Assignment removal:
Useless assignment statements are removed from the code entirely!!!
The two major causes of useless assignments are assignments to a
variable that are immediately followed by another assignment to the
same variable and assignment statements referencing automatic
variables immediately preceding a return statement.  The optimizer
warns the user whenever a block of code is removed.


Machine dependant optimizations:
In addition to the machine independant optimizations performed by the
loop optimizer, the -optimize (-ot) control argument also invokes a
machine dependant global optimizer (register optimizer) to perform
such optimizations as global register allocation and pulling register
loads out of loops.


Pointers to common blocks:
Pointers to frequently used common blocks are loaded into pointer
registers before the loops in which they are frequently used and are
kept loaded throughout these loops.


Invariant index values:
Loop invariant values used in indexing (subscripting) are loaded into
index registers before the loops in which they are invariant and are
kept loaded throughout these loops.


Induction variables:
Induction variables that are only used for addressing within a loop
are loaded into index registers before the loop and are incremented in
the index registers directly.  An induction variable that is globally
assigned to an index register in this way is not stored within the
loop unless the loop contains contexts which might erase the register,
such as a subroutine call, or unless the induction variable's value is
needed after loop termination or exit.


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
