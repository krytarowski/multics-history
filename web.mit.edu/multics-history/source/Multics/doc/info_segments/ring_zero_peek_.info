02/13/84  ring_zero_peek_

The ring_zero_peek_ subroutine is used to copy information out of an
inner ring segment.  The user must have access to either the phcs_ gate
or the metering_ring_zero_peek_ gate in order to use any of the entry
points in this subroutine.  The phcs_ gate allows unrestricted access
to all inner ring segments; metering_ring_zero_peek_ allows the user to
examine specifically those data bases that are useful for metering the
system.  The program chooses the appropriate gate depending on the
user's access and the segments being examined.


Entry points in ring_zero_peek_:
   (List is generated by the help command)


:Entry: ring_zero_peek_: 02/13/84 ring_zero_peek_

Function: copies information out of a segment in the Multics
supervisor, given a pointer to it.


Syntax:
declare ring_zero_peek_ entry (ptr, ptr, fixed bin(19), fixed bin(35));
call ring_zero_peek_ (ptr0, ptr_user, nwords, code);


Arguments:
ptr0
   is a pointer to the data in ring 0 that is to be copied out.
   (Input)
ptr_user
   is a pointer to the region in the user's address space where the
   data is to be copied.  (Input)
nwords
   is the number of words to be copied.  (Input)
code
   is the standard status code that is nonzero if the user did not have
   access to the requested data.  (Output)


:Entry:  by_definition:  02/13/84 ring_zero_peek_$by_definition


Function: copies information out of a named segment in the Multics
supervisor, starting at a named symbol.  It is like
ring_zero_peek_$by_name, except that the copying is done from the
specified definition, rather than from the base of the segment.


Syntax:
declare ring_zero_peek_$by_definition entry (char(*), char(*),
     fixed bin(18), pointer, fixed bin(19), fixed bin(35));
call ring_zero_peek_$by_definition (segment_name, symbol_name, offset,
     ptr_user, word_count, code);


Arguments:
segment_name
   is the name of the supervisor segment from which words are to be
   copied.  (Input).  It cannot be a pathname.
symbol_name
   is the name of the external symbol in the specified segment at which
   copying is to start.  (Input)
offset
   is the offset from the specified definition at which copying is to
   start.  (Input).  It can be specified as zero to cause copying to
   start at the specified definition.


ptr_user
   is a pointer to the area in the outer ring where the data is to be
   copied.  (Input)
word_count
   is the number of words to be copied.  (Input)
code
   is a standard status code.  (Output).  It is nonzero if the segment
   cannot be found, if the specified external symbol does not exist or
   is ambiguous, or if the user does not have sufficient access to copy
   the requested data.


Notes:  This entry point can be used to avoid a call to ring0_get_.
For examining segments in the supervisor, this entry point and the
by_name entry point are recommended because they are much simpler
to use than ring0_get_, and they are only minimally less efficient.
Generally, it is nearly as efficient to use this entry point as it is
to save static pointers to inner ring objects.


:Entry:  by_name:  02/13/84 ring_zero_peek_$by_name


Function: copies information out of a named segment in the Multics
supervisor.  It is like ring_zero_peek_, except that the name of the
ring zero segment is provided, rather than a pointer to it.


Syntax:
declare ring_zero_peek_$by_name entry (char(*), fixed bin(18), pointer,
     fixed bin(19), fixed bin(35));
call ring_zero_peek_$by_name (segment_name, offset, copy_ptr,
     word_count, code);


Arguments:
segment_name
   is the name of the supervisor segment from which data is to be
   copied.  It cannot be a pathname.  (Input)
offset
   is the offset from the beginning of the segment at which copying is
   to start.  (Input).  It can be specified as zero to cause copying to
   start from the base of the segment.
copy_ptr
   is a pointer to the area in the outer ring where the data is to be
   copied.  (Input)


word_count
   is the number of words to be copied.  (Input)
code
   is a standard status code.  (Output).  It is nonzero if the segment
   cannot be found, or if the user does not have sufficient access to
   copy the requested data from it.


Notes:  This entry point can be used to avoid a call to ring0_get_.
For examining segments in the supervisor, this entry point and the
by_definition entry point are recommended because they are much simpler
to use than ring0_get_, and they are only minimally less efficient.
Generally, it is nearly as efficient to use this entry point as it is
to save static pointers to inner ring objects.


:Entry:  get_max_length:  02/13/84 ring_zero_peek_$get_max_length


Function: determines the maximum length of a named ring zero segment.


Syntax:
declare ring_zero_peek_$get_max_length entry (char(*), fixed bin(19),
     fixed bin(35));
call ring_zero_peek_$get_max_length (seg_name, max_length, code);


Arguments:
seg_name
   is the name of the ring zero segment.  (Input)
max_length
   is the maximum length (in words) of the segment.  (Output)
code
   is a standard status code.  (Output).  It is nonzero if the user
   does not have sufficient access to copy the requested data, or if
   the segment does not exist.


:Entry:  get_max_length_ptr:
02/13/84 ring_zero_peek_$get_max_length_ptr


Function: determines the maximum length of a specified segment by
examining its SDW.  The user must have sufficient access to examine
the SDW for the segment.


Syntax:
declare ring_zero_peek_$get_max_length_ptr entry (pointer,
     fixed bin(19), fixed bin(35));
call ring_zero_peek_$get_max_length_ptr (seg_ptr, max_length, code);


Arguments:
seg_ptr
   is a pointer to the segment for which the max length is to be
   returned.  (Input).  If the segment is not active at the time of the
   call, the user must have sufficient access to reference the segment,
   and this reference causes a segment fault.
max_length
   is the maximum length (in words) of the segment.  (Output)
code
   is a standard status code.  (Output).  It is nonzero if the user
   does not have sufficient access to copy the requested data, or if
   the segment does not exist.


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
