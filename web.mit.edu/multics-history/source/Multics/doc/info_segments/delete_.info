03/05/85  delete_


The delete_ subroutine deletes segments, directories, multisegment
files, and data management files and unlinks links.  If the segment,
directory, multisegment file or data management file to be deleted is
protected (i.e., the safety switch or copy switch is on), the
subroutine requires user verification before attempting to remove the
protection.  There are two entry points:  one called with a pathname,
the other with a pointer to a segment.  Both have a set of switches
that specify the actions to be taken by the subroutine.  If the
specified entry is a segment, it is terminated using the term_
subroutine.  In general, users should call the delete_ subroutine
rather than directly addressing entry points in hcs_.  If a data
management file is subject to a pending transaction, the data
management file can not be deleted until the transaction is completed.


Entry points in delete_:
   (List is generated by the help command)


:Entry:  path:  03/05/85 delete_$path


Function:  This entry point is called with the pathname of the segment,
directory, multisegment file, data management file, or link to be
deleted.


Syntax:
declare delete_$path entry (char(*), char(*), bit(6), char(*),
     fixed bin(35));
call delete_$path (dir_name, entryname, switches, caller, code);


Arguments:
dir_name
   is the pathname of the containing directory.  (Input)
entryname
   is the entryname of the segment, directory, multisegment file, data
   management file, or link.  (Input)
switches
   are six switches that specify the actions to be taken.  (Input) The
   switches must be given in the order listed below.
   force_sw
      "1"b allows the entry to be deleted even if it is protected.
      "0"b acts according to question_sw if the entry is protected.


   question_sw
      "1"b asks the user if a protected entry should be deleted if the
           force_sw is "0"b; if the user gives a negative response, the
           subroutine returns the code
           error_table_$action_not_performed.  If question_sw is "1"b
           and the entryname argument is the name of a directory, the
           delete_ subroutine prints an error message for the first
           entry under the directory that cannot be deleted.
      "0"b deletes the entry without interrogating the user; if unable
           to delete the entry, the subroutine returns an appropriate
           storage system status code.


   The following switches allow control by the caller over which
   storage system entry types can be deleted:
   directory_sw
      "1"b allow the entryname argument to refer to a directory.
      "0"b return the code error_table_$dirseg if the entryname
           argument refers to a directory.
   segment_sw
      "1"b allow the entryname argument to refer to a segment,
           multisegment file, or data management file.
      "0"b return the code error_table_$nondirseg if the entryname
           argument refers to a segment on a multisegment file.
   link_sw
      "1"b allow the entryname argument to refer to a link (see
           chase_sw).
      "0"b return the code error_table_$not_a_branch if the entryname
           argument refers to a link.


   chase_sw
      "1"b allow the target of a link to be deleted, if link_sw = "1"b
           and the entryname argument refers to a link; the deletion of
           the segment or directory pointed to by the link is governed
           by the settings of directory_sw and segment_sw.
      "0"b unlink the link if link_sw ="1"b and the entryname argument
           refers to a link.
caller
   is the name of the calling procedure, to be used when questions are
   asked.  (Input)
code
   is a storage system status code.  (Output)


:Entry:  ptr:  03/05/85 delete_$ptr


Function:  The delete_$ptr entry point is similar to the delete_$path
entry point, except that the caller has a pointer to the actual segment
to be deleted.  Directories, multisegment files, Data Management files,
and links cannot be deleted with the delete_$ptr entry point.  The
directory_sw, link_sw, and chase_sw switches are not examined by this
entry point, but must be present.


Syntax:
declare delete_$ptr entry (ptr, bit(6), char(*), fixed bin(35));
call delete_$ptr (seg_ptr, switches, caller, code);


Arguments:
seg_ptr
   is a pointer to the segment to be deleted.  (Input)
switches
   are switches that specify the actions to be taken.  (Input) (See the
   delete_$path entry point).
caller
   is the name of the calling procedure, to be used when questions are
   asked.  (Input)
code
   is a storage system status code.  (Output)


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
