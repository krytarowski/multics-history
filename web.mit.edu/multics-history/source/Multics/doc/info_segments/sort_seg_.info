01/30/84  sort_seg_

The sort_seg_ subroutine provides entry points for sorting segments and
character strings.  It is the subroutine interface used by the sort_seg
command, and provides all of the facilities of this command at a
subroutine level.


Entry points in sort_seg_:
   (List is generated by the help command)


:Entry:  seg:  09/07/83 sort_seg_$seg


Function:  This entry point sorts an entire segment.  The sorted output
can either replace the original segment or be written into a new
segment.


Syntax:
declare sort_seg_$seg entry (char(*), ptr, char(*), char(*), char(*),
     char(*), fixed bin(21), fixed bin(21), fixed bin(35));
call sort_seg_$seg (caller, ss_info_ptr, in_dir, in_ent, out_dir,
     out_ent, out_len, undelim_char_index, code);


Arguments:
caller
   specifies the name of the calling procedure.  Temporary segments
   used for sort work space will be obtained in the caller's name, and
   the user may be asked questions in the caller's name when errors
   occur.  (Input)
ss_info_ptr
   points to a structure which defines the type of sorting to be
   performed, the sort field specifications, and so forth.  The caller
   must set all structure elements before calling sort_seg_ entry
   points.  This info structure is declared in sort_seg_info.incl.pl1.
   (Input)
in_dir
   pathname of the directory containing the segment to be sorted.
   (Input)


in_ent
   entryname of the segment to be sorted.  (Input)
out_dir
   pathname of the directory in which the sorted results are to be
   placed.  (Input)
out_ent
   entryname of the segment in which the sorted results are placed.
   The same segment may be identified by in_dir/in_ent and
   out_dir/out_ent, in which case the input segment is replaced by the
   sorted results.  (Input)
out_len
   the length in characters of the sorted results.  This may be useful
   if the caller wants to examine or print the sorted results.
   However, the caller need not truncate or set the bit count for the
   output segment.  sort_seg_ performs these functions.  (Output)


undelim_char_index
   if characters are found following the last sort string delimiter in
   the input segment, then this is the character index of the first
   such character in the sorted output results.  Such undelimited
   characters always appear at the end of the sorted output.  It is 0
   if no such undelimited characters are found in the input segment.
   Output)
code
   is a system status code.  If code is nonzero, then sort_seg_ will
   already have printed an error message via sub_err_.  (Output)


Access required:
To use the sort_seg_$seg interface, the user must have read access to
the segment being sorted, and rw access to the output segment.  If the
user lacks rw access to the output segment, sort_seg_$seg will ask if
access should be temporarily set to allow sorting.


:Entry:  string:  09/07/83 sort_seg_$string


Function:  This entry point sorts the contents of a character string.
The sorted output can either replace the original string or be written
into another string.


Syntax:
declare sort_seg_$string entry (char(*), ptr, char(*), char(*),
     fixed bin(21), fixed bin(21), fixed bin(35));
call sort_seg_$string (caller, ss_info_ptr, in_string, out_string,
     out_len, undelim_char_index, code);


Arguments:
caller
   specifies the name of the calling procedure.  Temporary segments
   used for sort work space will be obtained in the caller's name, and
   the user may be asked questions in the caller's name when errors
   occur.  (Input)
ss_info_ptr
   points to a structure which defines the type of sorting to be
   performed, the sort field specifications, and so forth.  The caller
   must set all structure elements before calling sort_seg_ entry
   points.  This info structure is declared in sort_seg_info.incl.pl1.
   (Input)


in_string
   the string to be sorted.  (Input)
out_string
   the string in which the sorted results are placed.  The same string
   may be given for both in_string and out_string, in which case the
   sorted results overwrite the in_string.  The out_string may also
   overlap part of the storage for in_string.  When the overlapping is
   partial or complete, the in_string is copied into a temporary
   segment prior to being sorted.  (Output)
out_len
   the length in characters of the sorted results.  (Output)


undelim_char_index
   if characters are found following the last sort string delimiter in
   the input string, then this is the character index of the first such
   character in the sorted output results.  Such undelimited characters
   always appear at the end of the sorted output.  It is 0 if no such
   undelimited characters are found in the input string.  (Output)
code
   is a system status code.  If code is nonzero, then sort_seg_ will
   already have printed an error message via sub_err_.  (Output)


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
