	COMPILATION LISTING OF SEGMENT rmdb_delete_domain
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 12/07/87  1320.5 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: ^inddcls,^indattr,indnoniterend,^indnoniterdo,indend,tree,^case,insnl,comcol61,dclind5,declareind5,delnl */
       10 
       11 /*DESCRIPTION
       12*  This subroutine deletes one or more domains from a MRDS database. Each of the
       13*  domains is examined, and a list of relations to be operated upon is created.
       14*  This is so that if more than one referenced domain is being deleted, each
       15*  relation is only reformatted once. If a domain is unreferenced, it is simply
       16*  removed from the db_model linked list. If it is referenced, the attributes
       17*  defined upon the domains must be deleted, and the relations that contain those
       18*  attribute must be reformatted.
       19**/
       20 
       21 /****^  HISTORY COMMENTS:
       22*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
       23*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
       24*     written
       25*  2) change(86-10-30,Blair), approve(86-10-30,PBF7311), audit(86-12-05,Dupuis),
       26*     install(86-12-09,MR12.0-1237):
       27*     Re-arrange the quit handler so that we only hold quits during the time we
       28*     are cleaning up - rename the relations, delete old model, update history
       29*     and xref files.  Everywhere else, once the model is marked inconsistent,
       30*     the salvager will do our cleanup if necessary so we don't need to worry
       31*     about the user typing something which would make the model and relations
       32*     inconsistent.
       33*  3) change(87-11-03,Blair), approve(87-11-03,MCR7792), audit(87-11-30,Dupuis),
       34*     install(87-12-07,MR12.2-1008):
       35*     Initialize mstxn_txn_id so that we don't get caught trying to abort a txn
       36*     that doesn't exist during cleanup.  This happens if there is garbage in
       37*     the field and dm is not available.
       38*                                                   END HISTORY COMMENTS */
       39 
       40 rmdb_delete_domain:
       41      proc (Irmdb_ctl_ptr, Idelete_object_info_ptr, Oerror_message, Ocode);
       42 
       43 	rmdb_ctl_ptr = Irmdb_ctl_ptr;
       44 	delete_object_info_ptr = Idelete_object_info_ptr;
       45 
       46 	last_unreferenced_attribute_ptr, user_area_ptr = null;
       47 	
       48 	if delete_object_info.version ^= delete_object_info_version_1
       49 	then call error (error_table_$unimplemented_version,
       50 		"Version " || delete_object_info.version || " for delete_object_info structure.");
       51 
       52 	db_path = rmdb_ctl.absolute_db_path;		/* Create the xref file if not already created. */
       53 	if rmdb_ctl.crossref_file_info.iocb_ptr = null
       54 	then do;
       55 	     call mdbm_util_$xref_build (rmdb_ctl.temp_dir_path, db_path, rmdb_ctl.db_model_ptr,
       56 		rmdb_ctl.crossref_file_info.name, rmdb_ctl.crossref_file_info.iocb_ptr, error_message, code);
       57 	     if code ^= 0
       58 	     then call error (code, error_message);
       59 	     end;
       60 
       61 	local_iocb = rmdb_ctl.crossref_file_info.iocb_ptr;
       62 
       63 	mstxn_txn_id = "0"b;
       64 	on cleanup call cleaner;
       65 
       66 	dbm_ptr = rmdb_ctl.db_model_ptr;
       67 
       68 	if delete_object_info.all
       69 	then call rmdb_delete_all$domains (rmdb_ctl_ptr, error_message, code);
       70 	else do;
       71 
       72 /* Create a non-freeing, non-zeroing extensible area to allocate structures in.
       73*   When we return and finish using these structures, we will simply throw away
       74*   the area. */
       75 	     call mdbm_util_$get_temp_segment_path (rmdb_ctl.temp_dir_path, myname, user_area_ptr, code);
       76 	     if code ^= 0
       77 	     then call error (code, "Unable to get a temp segment in the temp dir.");
       78 
       79 	     unspec (ai) = "0"b;
       80 	     ai.version = area_info_version_1;
       81 	     ai.extend = "1"b;
       82 	     ai.dont_free = "1"b;
       83 	     ai.no_freeing = "1"b;
       84 	     ai.owner = myname;
       85 	     ai.size = sys_info$max_seg_size;
       86 	     ai.areap = user_area_ptr;
       87 
       88 	     call define_area_ (addr (ai), code);
       89 	     if code ^= 0
       90 	     then call error (code, "Defining a user area.");
       91 
       92 	     domain_list_ptr, attribute_list_ptr, relation_list_ptr = null;
       93 	     if delete_object_info.unreferenced
       94 	     then call make_unreferenced_domain_delete_list;
       95 	     else do;
       96 		call rmdb_relations_used$domains (rmdb_ctl_ptr, delete_object_info_ptr, user_area_ptr,
       97 		     domain_list_ptr, attribute_list_ptr, relation_list_ptr, error_message, code);
       98 		if code ^= 0
       99 		then call error (code, error_message);
      100 
      101 		if ^delete_object_info.force
      102 		then do;
      103 		     unspec (query_info) = "0"b;
      104 		     query_info.version = query_info_version_6;
      105 		     query_info.yes_or_no_sw = "1"b;
      106 		     query_info.suppress_name_sw = "1"b;
      107 		     query_info.question_iocbp = delete_object_info.check_iocb_ptr;
      108 		     query_info.answer_iocbp = delete_object_info.query_iocb_ptr;
      109 		     query_info.explanation_ptr = addr (QUERY_MSG);
      110 		     query_info.explanation_len = length (QUERY_MSG);
      111 		     end;
      112 
      113 		call print_information;
      114 
      115 		if (delete_object_info.long = UNSPEC & delete_object_info.check)
      116 		then do;
      117 		     code = 0;
      118 		     call error (code, error_message);
      119 		     end;
      120 		end;
      121 
      122 /* Make sure we won't be creating a relation with no primary key. */
      123 	     call check_for_deletion_of_primary_key;
      124 
      125 	      make_consistent_msg = "";
      126 		
      127 	     call mdbm_util_$inconsistent_set (dbm_ptr, "delete_domain", "Deleting domains", rtrim (make_consistent_msg));
      128 
      129 
      130 /* Invalidate the resultant. */
      131 	     if ^delete_object_info.unreferenced
      132 	     then do;
      133 		rmdb_ctl.saved_res_version_ptr -> based_char8 = "RESTRUCT";
      134 
      135 		last_unreferenced_attribute_ptr = null;
      136 		relation_good_count, save_code = 0;
      137 
      138 		do relation_index = 1 to relation_list.count;
      139 		     relation_ptr = relation_list.relation_ptr (relation_index);
      140 		     relation_good_count = relation_good_count + 1;
      141 		     call process_single_relation;
      142 		     if code ^= 0
      143 		     then do;
      144 			save_code = code;
      145 			goto cleanup_directory;
      146 			end;                               /* do code ^= 0 */
      147 		     end;                                    /* do relation_index */
      148 		end;                                         /* do referenced objects */
      149 
      150 /* If we get here, we have copied all the relations, so now we need to clean
      151*   up by deleting the copies of the file model and the old relations.       */
      152 
      153 cleanup_directory:	
      154 
      155 /* The real work starts here - hold quits till we're done */
      156 
      157 	     quit_occurred = "0"b;			/* BEGIN CRITICAL CODE */
      158 	     on quit quit_occurred = "1"b;  
      159 
      160 	     do relation_index = 1 to relation_good_count;
      161 		     relation_ptr = relation_list.relation_ptr (relation_index);
      162 		     fm_ptr = relation.file_model_ptr;
      163 		     call transaction_in_progress;
      164 		     if mstxn_transactions_needed
      165 		     then do;
      166 			on cleanup
      167 			     begin;
      168 			     call mstxn_cleanup;
      169 			     call cleaner;
      170 			     end;
      171 			on any_other call mstxn_any_other;
  1     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the changes made on 85-05-06 and
  1     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
  1    10*     was removed because not all modules need the dbcb, and the
  1    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
  1    12*     list #136).
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 /*
  1    17*                    BEGIN_DESCRIPTION
  1    18*
  1    19*   A generalized routine accessed by all MRDS modules (with the temporary 
  1    20*   (perhaps) exception of restructuring modules) that must start transactions 
  1    21*   if none are present.  The intent is that it be executed as inline code.
  1    22*   The variable mstxn_transactions_needed must be set prior to entering this
  1    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
  1    24*   will suffice.  Included are procedures called mstxn_cleanup and 
  1    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
  1    26*   handlers in the program.  Such handlers should be established just prior to
  1    27*   the inclusion of this code and disabled just following the inclusion of
  1    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
  1    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
  1    30*   include file does the same, because this code might not have been entered 
  1    31*   yet when the handler is invoked.  Directly following this include file the 
  1    32*   contents of mstxn_code should be examined.  If zero, then either the 
  1    33*   transaction was successfully started or no transaction was required.  If the
  1    34*   mrds_finish_transaction code is referenced in general error handling 
  1    35*   situations where the possibility exists that the code in this include file 
  1    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
  1    37*   the beginning of the program.
  1    38*
  1    39*                    END_DESCRIPTION
  1    40*
  1    41*   Written 82-09-28 by Paul W. Benjamin.
  1    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
  1    43*   Modified 83-01-07 by PWB to not reference the dbcb.
  1    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
  1    45*		 any_other handler in situations where the module did
  1    46*		 not start the transaction.
  1    47*   Modified 83-05-05 by PWB to abandon when abort fails.
  1    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
  1    49*		 and abort.
  1    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
  1    51*		 transaction_bj_full conditions.
  1    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
  1    53*		 and to handle transaction_lock_timeout_.
  1    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
  1    55*                     dbcb.user_started_transaction flag.
  1    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
  1    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
  1    58*                     directory >ldd>include and >exl>mrd>i
  1    59**/
  1    60 
  1    61 dcl continue_to_signal_ entry (fixed bin(35));
  1    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
  1    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
  1    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
  1    65 dcl mstxn_code fixed bin (35);
  1    66 dcl mstxn_retries fixed;
  1    67 dcl mstxn_temp_code fixed bin (35);
  1    68 dcl mstxn_transactions_needed bit (1) aligned;
  1    69 dcl user_started_transaction bit (1) aligned;
  1    70 dcl mstxn_txn_id bit (36) aligned;
  1    71 dcl user_transaction_id bit (36) aligned;
  1    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
  1    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
  1    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
  1    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
  1    76 dcl transaction_manager_$handle_conditions entry ();
  1    77 dcl 1 mstxn_condition_info like condition_info;
  1    78 
  2     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*Designed by Matthew C. Pierret, 01/26/82.
  2     6*Coded by Jeffrey D. Ives, 04/30/82.
  2     7*Modified:
  2     8*10/18/82 by Steve Herbst: Names changed.
  2     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  2    10**/
  2    11 
  2    12 dcl (LOWEST_MODE init (1),
  2    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  2    14 
  2    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  2    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  2    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  2    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  2    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  2    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  2    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  2    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  2    23 
  2    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    79 

  1    80 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
  1    81 
  1    82 
  1    83 	mstxn_code = 0;
  1    84 	mstxn_txn_id = "0"b;
  1    85 	
  1    86 	if ^mstxn_transactions_needed			/* only need transactions */
  1    87 	     then goto mstxn_exit;			/* for protected page files */
  1    88 	mstxn_retries = 0;
  1    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
  1    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
  1    91 	     then do;				
  1    92 	     user_started_transaction = "1"b;
  1    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
  1    95 	     goto mstxn_exit;	
  1    96 	end;
  1    97 
  1    98 	user_started_transaction = "0"b;
  1    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
  1   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1   101 
  1   102 mstxn_cleanup:
  1   103 proc;
  1   104 
  1   105 /*  This procedure MUST be called by a cleanup handler. */
  1   106 
  1   107           if mstxn_txn_id ^= "0"b
  1   108           then do;
  1   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
  1   110 	     if mstxn_temp_code ^= 0
  1   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
  1   112 	end;
  1   113 	
  1   114      end mstxn_cleanup;
  1   115 
  1   116 mstxn_any_other:
  1   117 proc;
  1   118 
  1   119 /*  This procedure MUST be called by an any_other handler. */
  1   120 
  1   121           if mstxn_txn_id ^= "0"b
  1   122           then do;
  1   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
  1   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
  1   125 		then do;
  1   126 		mftxn_code = dm_error_$lock_deadlock;
  1   127 		goto mftxn_check_code;
  1   128 	     end;
  1   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
  1   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
  1   131 		then do;
  1   132 		mftxn_code = dm_error_$bj_journal_full;
  1   133 		goto mftxn_check_code;
  1   134 	     end;
  1   135 	     else call transaction_manager_$handle_conditions;
  1   136 	end;
  1   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
  1   138      end mstxn_any_other;
  1   139      
  1   140 mstxn_exit:
  1   141      
  1   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
      172 
      173                               if mstxn_code ^= 0
      174 			then call error (mstxn_code, "Could not start a transaction.");
      175 			end;
      176 		     call switch_names;
      177 		     if mstxn_transactions_needed
      178 		     then do;
      179 			mftxn_code = 0;
  4     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
  4     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*                    BEGIN_DESCRIPTION
  4    15*
  4    16*   A generalized routine accessed by all MRDS modules that begin and commit 
  4    17*   transactions.  The intent is that it be executed as inline code. It is 
  4    18*   assumed that mrds_start_transaction was executed previously in the 
  4    19*   procedure.  Prior to this include file the program should assign the value 
  4    20*   of its local error code to mftxn_code.  The program utilizing this
  4    21*   include file must supply a function labeled should_rollback that returns
  4    22*   bit (1).  This routine should examine the error code mftxn_code and whether
  4    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
  4    24*   means rollback.  This procedure may choose to simply return "0"b as it 
  4    25*   appears that MRDS will generally NOT rollback transactions.  This routine
  4    26*   does rollback and restart if the before journal is full but only attempts it
  4    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
  4    28*   where any data that was saved prior to the transaction is restored.  A 
  4    29*   procedure consisting solely of a return statement can be supplied if 
  4    30*   necessary.  After execution of this include file, mftxn_code must be
  4    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
  4    32*   then the commit has failed.  Otherwise it will be unchanged.
  4    33*
  4    34*                    END_DESCRIPTION
  4    35*
  4    36*   Written 82-09-30 by Paul W. Benjamin.
  4    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
  4    38*                     error code only when the transaction is in an error state.
  4    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
  4    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
  4    41*		 fails, and to abort rather than rollback when bj is full.
  4    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
  4    43*		 and rollback.
  4    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
  4    45*		 to by the mstxn_any_other procedure.
  4    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
  4    47*                     the user already started his own transaction.
  4    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
  4    49*                     the directory >ldd>include and >exl>mrd>i.
  4    50**/
  4    51 
  4    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
  4    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
  4    54 dcl mftxn_code fixed bin (35);
  4    55 dcl mftxn_temp_code fixed bin (35);
  4    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
  4    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
  4    58 	
  4    59 
  4    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
  4    61 	     then do;
  4    62 	     mftxn_code = 0;
  4    63 	     goto mftxn_exit;
  4    64 	end;
  4    65 mftxn_check_code:
  4    66 	if mftxn_code = 0
  4    67 	     then do;
  4    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
  4    69 	     if mftxn_code ^= 0
  4    70 		then do;
  4    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    72 		if mftxn_temp_code ^= 0
  4    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    74 	     end;
  4    75 	end;
  4    76 	else do;
  4    77 	     call restore_significant_data;
  4    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
  4    79 		& mstxn_retries < 1		
  4    80 		then do;
  4    81 		     mstxn_retries = mstxn_retries + 1;
  4    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    83 		     if mftxn_temp_code ^= 0
  4    84 			then do;
  4    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    86 			if mftxn_temp_code ^= 0
  4    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    88 		     end;
  4    89 		     else do;
  4    90 			mstxn_code = 0;
  4    91 			goto mstxn_exit;		/* go back and try again */
  4    92 		     end;
  4    93 		end;
  4    94 	     else if should_rollback ()		/* let the program decide */
  4    95 		then do;
  4    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    97 		if mftxn_temp_code ^= 0
  4    98 		     then do;
  4    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   100 		     if mftxn_temp_code ^= 0
  4   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   102 		end;
  4   103 		else do;
  4   104 		     mstxn_code = 0;
  4   105 		     goto mstxn_exit;		/* go back and try again */
  4   106 		end;
  4   107 	     end;
  4   108 	     else do;
  4   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   110 		if mftxn_temp_code ^= 0
  4   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   112 	     end;
  4   113 	end;
  4   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
  4   115 mftxn_exit:
  4   116      
  4   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
      180 
      181                               end;			         /* end mstxn_transactions_needed */
      182 		     
      183 		     end;                               /* do relation_index */
      184 		 
      185 
      186 /* Continue after cleaning up the directory and the model... */
      187 	     if save_code ^= 0 
      188 	     then do;
      189 		call mdbm_util_$xref_destroy (rmdb_ctl.crossref_file_info.iocb_ptr, rmdb_ctl.temp_dir_path,
      190 		     rmdb_ctl.crossref_file_info.name, (""), (0));
      191 		call error (save_code, error_message);
      192 		end;
      193 
      194 	     call unlink_deleted_domains;
      195 	     call mdbm_util_$inconsistent_reset (dbm_ptr);
      196 	     call delete_xref_records;
      197 
      198 /* Now we're done cleaning up xref and model and history is written */
      199 	     revert quit; 
      200 	     if quit_occurred
      201 	     then signal quit; 
      202 
      203 	     code = 0;
      204 	     end;                                        /* end ^delete_object_info.all */
      205 
      206 	call error (code, error_message);
      207 
      208 /*DESCRIPTION
      209*  Error handler and cleanup handler. This is the only way to exit these
      210*  subroutines.
      211**/
      212 
      213 error:
      214      proc (code, msg);
      215 
      216 dcl  code fixed bin (35) parameter;
      217 dcl  msg char (*) parameter;
      218 
      219 	Ocode = code;
      220 	if code = 0
      221 	then Oerror_message = "";
      222 	else Oerror_message = msg;
      223 	goto RETURN_TO_CALLER;
      224      end error;
      225 
      226 RETURN_TO_CALLER:
      227 	call cleaner;
      228 	return;
      229 
      230 cleaner:
      231      proc;
      232 
      233 	if user_area_ptr ^= null
      234 	then do;
      235 	     call release_area_ (user_area_ptr);
      236 	     call mdbm_util_$free_temp_segment (myname, user_area_ptr, (0));
      237 	     end;
      238 
      239 	if mstxn_txn_id ^= "0"b
      240 	then do;
      241 	     call transaction_manager_$abort_txn (mstxn_txn_id, code);
      242 	     if code ^= 0
      243 	     then call transaction_manager_$abandon_txn (mstxn_txn_id, (0));
      244 	     end;
      245 
      246 	return;
      247      end cleaner;
      248 
      249 restore_significant_data:
      250      proc;
      251 	return;
      252      end restore_significant_data;
      253 
      254 should_rollback:
      255      proc returns (bit (1) aligned);
      256 	return ("0"b);
      257      end should_rollback;
      258 
      259 /*DESCRIPTION
      260*  This internal subroutine displays the crossreference information that we
      261*  have previously gathered. It then queries (if necessary) to see if we are
      262*  allowed to delete each domain. If any domain deletion is cancelled, we have
      263*  to recalculate the list of attributes deleted in each relation. */
      264 
      265 print_information:
      266      proc;
      267 
      268 dcl  cancel_domain bit (domain_list.count);		/* 1 ::= we don't really want to delete this one */
      269 dcl  first_cancel_domain fixed bin;			/* idx of first of deleted domains cancelled */
      270 dcl  printed_names (2) char (32);
      271 dcl  relations_printed bit (relation_list.count);		/* 1 ::= we already printed the name of this relation */
      272 dcl  relations_printed_count fixed bin;			/* number of relation names printed */
      273 dcl  relations_to_be_printed bit (1) aligned;		/* indicates there is at least one relation name to be printed */
      274 
      275 	cancel_domain = "0"b;
      276 	first_cancel_domain = 0;
      277 
      278 	do domain_list_idx = 1 to domain_list.count;
      279 	     relations_to_be_printed = "0"b;
      280 	     attribute_list_ptr = domain_list.attribute_list_ptr (domain_list_idx);
      281 	     domain_name = unmake_name (domain_list.name (domain_list_idx));
      282 	     if delete_object_info.check
      283 	     then do;
      284 	     if attribute_list_ptr = null
      285 	     then call ioa_$ioa_switch (delete_object_info.check_iocb_ptr, "^/Domain ""^a"" is unreferenced.",
      286 		     domain_name);
      287 	     else do;
      288 		do attribute_list_idx = 1 to attribute_list.count;
      289 		     attribute_ptr = attribute_list.attribute_ptr (attribute_list_idx);
      290 		     attribute_name = unmake_name (attribute_list.name (attribute_list_idx));
      291 		     if attribute_list_idx = 1
      292 		     then call ioa_$ioa_switch_nnl (delete_object_info.check_iocb_ptr,
      293 			     "^/Domain ""^a"" is used in attribute^[s^] ""^a""", domain_name,
      294 			     (attribute_list.count > 1), attribute_name);
      295 		     else call ioa_$ioa_switch_nnl (delete_object_info.check_iocb_ptr, "^[ and^;,^] ""^a""",
      296 			     (attribute_list.count = attribute_list_idx), attribute_name);
      297 
      298 		     if attribute_ptr ^= null
      299 		     then relations_to_be_printed = "1"b;
      300 
      301 		     end;				/* do attribute_list_idx */
      302 		if relations_to_be_printed
      303 		then do;
      304 		     relations_printed = "0"b;
      305 		     relations_printed_count = 0;
      306 		     do attribute_list_idx = 1 to attribute_list.count;
      307 			attribute_ptr = attribute_list.attribute_ptr (attribute_list_idx);
      308 			if attribute_ptr ^= null
      309 			then do attribute_idx = 1 to attribute.count;
      310 				relation_index = attribute.relation_idx (attribute_idx);
      311 				if ^substr (relations_printed, relation_index, 1)
      312 				then do;
      313 				     substr (relations_printed, relation_index, 1) = "1"b;
      314 				     relation_name = unmake_name (relation_list.name (relation_index));
      315 				     relations_printed_count = relations_printed_count + 1;
      316 				     if relations_printed_count < 3
      317 				     then printed_names (relations_printed_count) = relation_name;
      318 				     else do;
      319 					call ioa_$ioa_switch_nnl (delete_object_info.check_iocb_ptr,
      320 					     "^[ which ^[is^;are^] referenced in relations^;^s,^] ""^a""",
      321 					     (relations_printed_count = 3), (attribute_list.count = 1),
      322 					     printed_names (1));
      323 					printed_names (1) = printed_names (2);
      324 					printed_names (2) = relation_name;
      325 					end;
      326 				     end;
      327 				end;		/* do attribute_idx */
      328 			end;			/* do attribute_list_idx */
      329 		     if relations_printed_count > 0
      330 		     then if relations_printed_count < 3
      331 			then call ioa_$ioa_switch_nnl (delete_object_info.check_iocb_ptr,
      332 				"^[ which ^[is^;are^] referenced in relation ""^a""^; which ^[is^;are^] referenced in relations ""^a"" and ""^a""",
      333 				(relations_printed_count = 1), (attribute_list.count = 1), printed_names (1),
      334 				printed_names (2));
      335 			else call ioa_$ioa_switch_nnl (delete_object_info.check_iocb_ptr, ", ""^a"" and ""^a""",
      336 				printed_names (1), printed_names (2));
      337 		     end;				/* relations_to_be_printed */
      338 
      339 		call ioa_$ioa_switch_nnl (delete_object_info.check_iocb_ptr, ".^/");
      340 		end;
      341 	     end;                                         /* delete_object_info.check = TRUE */
      342 	
      343 	     if (delete_object_info.check & (delete_object_info.long = UNSPEC)) then;
      344 	     else if ^delete_object_info.force
      345 	     then if ^query ()
      346 		then do;
      347 		     substr (cancel_domain, domain_list_idx, 1) = "1"b;
      348 		     if first_cancel_domain = 0
      349 		     then first_cancel_domain = domain_list_idx;
      350 		     end;
      351 
      352 	     end;					/* do domain_list_idx */
      353 
      354 	if first_cancel_domain ^= 0
      355 	then call recalculate_attributes_deleted;
      356 
      357 	return;
      358 
      359 query:
      360      proc returns (bit (1) aligned);
      361 
      362 	call command_query_ (addr (query_info), answer, delete_object_info.request_name,
      363 	     "     Do you wish to delete the domain ^a ?", rtrim(domain_name));
      364 	if answer = "no"
      365 	then return ("0"b);
      366 	else return ("1"b);
      367 
      368      end query;
      369 
      370 /*DESCRIPTION
      371*  Take the list of canceled domain deletions in the cancel_domain bit string
      372*  and process it by marking all attributes in each indicated domain in each
      373*  relation to be deleted. This subroutine must be internal to print_information
      374*  so we can access the cancel_domain string. */
      375 
      376 recalculate_attributes_deleted:
      377      proc;
      378 
      379 dcl  have_domains_to_process bit (1) aligned;
      380 dcl  position fixed bin;
      381 dcl  search_name char (33);
      382 
      383 /* First mark all attributes in all referenced relations undeleted. */
      384 	do relation_index = 1 to relation_list.count;
      385 	     relation_ptr = relation_list.relation_ptr (relation_index);
      386 	     unspec (relation.attribute (*).delete) = "0"b;
      387 	     end;					/* do relation_index */
      388 
      389 	do domain_list_idx = 1 to first_cancel_domain - 1;
      390 	     domain_list.name (domain_list_idx) = "";
      391 	     end;					/* do domain_list_idx */
      392 
      393 /* Now walk through the domain list -> attributes, marking each attribute in the
      394*   relation structures deleted or not. */
      395 	have_domains_to_process = "0"b;
      396 	do domain_list_idx = first_cancel_domain to domain_list.count;
      397 	     if substr (cancel_domain, domain_list_idx, 1)
      398 	     then domain_list.name (domain_list_idx) = "";
      399 	     else do;
      400 		have_domains_to_process = "1"b;
      401 		attribute_list_ptr = domain_list.attribute_list_ptr (domain_list_idx);
      402 		do attribute_list_idx = 1 to attribute_list.count;
      403 		     attribute_ptr = attribute_list.attribute_ptr (attribute_list_idx);
      404 		     if attribute_ptr ^= null
      405 		     then do;			/* the attribute was referenced in at least a single relation */
      406 			search_name = attribute_list.name (attribute_list_idx);
      407 			do attribute_idx = 1 to attribute.count;
      408 			     relation_ptr = relation_list.relation_ptr (attribute.relation_idx (attribute_idx));
      409 			     position = index (relation_attribute_names, search_name);
      410 			     if position ^= 0
      411 			     then do;		/* found the place, mark the attribute to be deleted */
      412 				position = divide (position, 33, 17, 0) + 1;
      413 				relation.attribute (position).flags.delete = "1"b;
      414 				end;
      415 			     end;			/* do attribute_idx */
      416 			end;
      417 		     end;				/* do attribute_list_idx */
      418 		end;
      419 	     end;					/* do domain_list_ptr */
      420 
      421 	if ^have_domains_to_process
      422 	then call error (0, "");			/* nothing to do, return to caller */
      423 	return;
      424 
      425      end recalculate_attributes_deleted;
      426 
      427      end print_information;
      428 
      429 make_unreferenced_domain_delete_list:
      430      proc;
      431 
      432 /* Allocate the new domain_list structure to be the number of domains
      433*   defined in size. Unless all domains are unreferenced, some of the entries
      434*   will not be used. Remember to adjust the refer extent of the structure. */
      435 	domain_list_count = db_model.num_domains;
      436 	allocate domain_list in (user_area) set (domain_list_ptr);
      437 	domain_list.count = 0;
      438 
      439 /* Run through all domains defined in the model. */
      440 	do di_ptr = ptr (dbm_ptr, db_model.domain_ptr) repeat ptr (dbm_ptr, domain_info.fwd_thread)
      441 	     while (rel (di_ptr) ^= NULL_OFFSET);
      442 
      443 	     if domain_info.unreferenced
      444 	     then do;				/* found a candidate */
      445 		domain_list.count = domain_list.count + 1;
      446 		domain_list.name (domain_list.count) = make_name ((domain_info.name));
      447 		end;
      448 	     end;					/* do di_ptr */
      449 	domain_list.attribute_list_ptr (*) = null;
      450 
      451 	if domain_list.count = 0
      452 	then if delete_object_info.inhibit_errors
      453 	     then call error (0, "");
      454 	     else call error (mrds_error_$no_unref_domain, "");
      455 
      456 	return;
      457      end make_unreferenced_domain_delete_list;
      458 
      459 make_name:
      460      proc (input_name) returns (char (33));
      461 
      462 dcl  input_name char (*) parameter;
      463 
      464 	return (OBJECT_HEAD || input_name);
      465      end make_name;
      466 
      467 unmake_name:
      468      proc (input_name) returns (char (32));
      469 
      470 dcl  input_name char (*) parameter;
      471 
      472 	return (substr (input_name, 2, 32));
      473      end unmake_name;
      474 
      475 /*DESCRIPTION
      476*  This subroutine ensures that no transaction is in progress, and sets a flag
      477*  bit for use later. */
      478 
      479 transaction_in_progress:
      480      proc;
      481 
      482 	if db_model.db_type_flags.transactions_needed
      483 	then do;
      484 	     mstxn_transactions_needed = "1"b;
      485 	     call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
      486 	     if mstxn_code = 0
      487 	     then do;
      488 		mstxn_txn_id = "0"b;
      489 		call error (error_table_$action_not_performed,
      490 		     "A transaction is in progress. Commit or abort the transaction and try the operation again.");
      491 		end;
      492 	     end;
      493 	else mstxn_transactions_needed = "0"b;
      494 
      495 	return;
      496      end transaction_in_progress;
      497 
      498 check_for_deletion_of_primary_key:
      499      proc;
      500 
      501 dcl attr_idx fixed bin;
      502 dcl deletion_attributes char (500);
      503 dcl no_primary_key bit (1) aligned;
      504 
      505           deletion_attributes = "";
      506 	no_primary_key = "1"b;
      507 	do domain_list_idx = 1 to domain_list.count;
      508 	     attribute_list_ptr = domain_list.attribute_list_ptr (domain_list_idx);
      509 	     domain_name = unmake_name (domain_list.name (domain_list_idx));
      510 	     do attribute_list_idx = 1 to attribute_list.count;
      511 		attribute_ptr = attribute_list.attribute_ptr (attribute_list_idx);
      512 		if attribute_ptr ^= null then do attr_idx = 1 to attribute.count;
      513 		     relation_ptr = relation_list.relation_ptr (attribute.relation_idx (attr_idx));
      514 		     do attribute_idx = 1 to relation.attribute_count;
      515 			if relation.attribute(attribute_idx).flags.part_of_key 
      516 			     & relation.attribute_names (attribute_idx) = attribute_list.name (attribute_list_idx)
      517 			     then do;
      518 			     no_primary_key = "0"b;
      519 			     relation.attribute(attribute_idx).flags.to_be_deleted = "1"b;
      520 			     end;
      521 			end;
      522 		     end;
      523 		end;
      524 	     end;
      525 	if ^no_primary_key 
      526 	then do relation_index = 1 to relation_list.count while (^no_primary_key);
      527 	     relation_ptr = relation_list.relation_ptr(relation_index);
      528 	     do attribute_idx = 1 to relation.attribute_count while (^no_primary_key);
      529 		if relation.attribute(attribute_idx).flags.part_of_key 
      530 		then if ^relation.attribute(attribute_idx).flags.to_be_deleted
      531 		     then no_primary_key = "1"b;
      532 		     else do;
      533 			attribute_name = unmake_name (relation.attribute_names (attribute_idx));
      534 			relation.attribute(attribute_idx).flags.to_be_deleted = "0"b;
      535 			deletion_attributes = rtrim(deletion_attributes) || " " || rtrim(attribute_name);
      536 			end;
      537 		end;
      538 	     if ^no_primary_key 
      539 	     then do;
      540 		code = mrds_error_$no_primary_key;
      541 		call error (code, "Deletion of the domain " || rtrim(domain_name) || " would result in no primary key in relation "  || rtrim(relation.name) || ".");
      542 		end;
      543 	end;
      544 	end check_for_deletion_of_primary_key;
      545 
      546 /*DESCRIPTION
      547*  This subroutine either deletes all information pertaining to a relation (if
      548*  all domains are deleted) or reformats it according to the list of deleted
      549*  domains. */
      550 
      551 process_single_relation:
      552      proc;
      553 
      554      
      555 	if all_attributes_are_deleted ()
      556 	then call delete_relation_information;
      557 	else call rmdb_copy_relation (dbm_ptr, db_path, rmdb_ctl.temp_dir_path, addr (rmdb_ctl.relmgr_entries),
      558 		relation_ptr, error_message, code);
      559 	if code ^= 0
      560 	then do;
      561 	     if code = mrds_error_$no_primary_key
      562 	     then	call mdbm_util_$inconsistent_reset (dbm_ptr);
      563 	     if delete_object_info.inhibit_errors | code = dm_error_$key_duplication
      564 	     then goto skip_relation;
      565 	     else call error (code, error_message);
      566 	     end;
      567 skip_relation:
      568 	return;
      569 
      570 all_attributes_are_deleted:
      571      proc returns (bit (1) aligned);
      572 
      573 dcl  attribute_idx fixed bin;
      574 
      575 	do attribute_idx = 1 to relation.attribute_count;
      576 	     if ^relation.attribute (attribute_idx).flags.delete
      577 	     then return ("0"b);
      578 	     end;					/* do relation_index */
      579 
      580 	return ("1"b);
      581      end all_attributes_are_deleted;
      582 
      583 
      584 delete_relation_information:
      585      proc;
      586 
      587 /* Unlink the file_info structure. */
      588 	save_ptr, previous_ptr = null;
      589 	do fi_ptr = ptr (dbm_ptr, db_model.file_ptr) repeat ptr (dbm_ptr, file_info.fwd_ptr)
      590 	     while ((save_ptr = null) & (rel (fi_ptr) ^= NULL_OFFSET));
      591 	     if file_info.file_name = relation.name
      592 	     then save_ptr = fi_ptr;
      593 	     else previous_ptr = fi_ptr;
      594 	     end;					/* do fi_ptr */
      595 
      596 	if save_ptr ^= null
      597 	then do;
      598 	     if previous_ptr = null
      599 	     then db_model.file_ptr = save_ptr -> file_info.fwd_ptr;
      600 	     else previous_ptr -> file_info.fwd_ptr = save_ptr -> file_info.fwd_ptr;
      601 
      602 	     free save_ptr -> file_info in (dbm_area);
      603 
      604 	     call mdbm_util_$xref_delete_record (local_iocb, RELATION_KEY_HEAD, relation.name, error_message, (0));
      605 	     end;
      606 
      607 /* Now delete the relation and relation.m files. */
      608 	call delete_file (relation.name);
      609 	call delete_file (rtrim (relation.name) || ".m");
      610 
      611 	db_model.num_blk_files = db_model.num_blk_files - 1;
      612 	db_model.num_rels = db_model.num_rels - 1;
      613 
      614 	call rmdb_add_rmdb_history (dbm_ptr, RMDB_REL_TYPE, relation.name, RMDB_DEL_REL_OP, "", (""), (0));
      615 	return;
      616 
      617 delete_file:
      618      proc (file_name);
      619 
      620 dcl  delete_$path entry (char (*), char (*), bit (36) aligned, char (*), fixed bin (35));
      621 dcl  error_table_$unsupported_operation fixed bin (35) ext static;
      622 dcl  file_name char (*) parameter;
      623 dcl  fs_util_$delentry_file entry (char (*), char (*), fixed bin (35));
      624 
      625 	call fs_util_$delentry_file (db_path, file_name, code);
      626 	if code = error_table_$unsupported_operation
      627 	then call delete_$path (db_path, file_name, "101111"b, myname, code);
      628 
      629 	if (code ^= 0) & (^delete_object_info.inhibit_errors)
      630 	then call error (code, "Deleting " || file_name);
      631 
      632 	return;
      633      end delete_file;
      634 
      635      end delete_relation_information;
      636 
      637      end process_single_relation;
      638 
      639 /* DESCRIPTION
      640**  This module was brought over from rmdb_copy_relation since we can't really 
      641**  clean up before we have finished with ALL the relations.  It performs 
      642**  several steps;  initiate the copy of the file_model (.k), get the name of
      643**  the associated relation, copy contents of new file_model to the old one,
      644**  move the data from the old file to the new one, delete the old relation,
      645**  rename the new relation to the old name (or physically copy to old name if
      646**  dm file), remove the copy of the file_info from the db_model and free the
      647**  space.  Finally, we must update the xref file to show that the relation is
      648**  no longer in the attribute key record. */
      649 	 
      650 
      651 switch_names:
      652      proc;
      653 
      654 dcl  1 local_status_branch like status_branch;
      655 dcl  create_model_name char (32);
      656 dcl  create_relation_name char (32);
      657 dcl  data_acl_ptr ptr;
      658 dcl  index builtin;
      659 dcl  move_string char (move_string_length) based;
      660 dcl  move_string_length fixed bin (35);
      661 dcl  new_model_bit_count fixed bin (24);
      662 dcl  new_file_model_ptr ptr;
      663 dcl  last_file_info_ptr ptr;
      664 dcl  1 co aligned like copy_options;
      665 dcl  cvds bit (1) aligned;
      666 dcl  ivds bit (1) aligned;
      667 dcl  to_char fixed bin;
      668 
      669           create_model_name = rtrim (relation.name) || ".k";
      670 	status_area_ptr = user_area_ptr;
      671 	status_ptr = addr (local_status_branch);
      672 	call hcs_$status_ (db_path, create_model_name, 0, status_ptr, status_area_ptr, code);
      673 	to_char = index(status_entry_names (1), ".m");
      674 	to_char = to_char -1;
      675 	create_relation_name = rtrim(substr(status_entry_names (1), 1, to_char));
      676           call initiate_file_ (db_path, create_model_name, RW_ACCESS, new_file_model_ptr, new_model_bit_count, code);
      677 	if code ^= 0
      678           then call error (code, "While initiating the new_file_model for relation " || relation.name);
      679 	rmdb_relmgr_entries_ptr = addr (rmdb_ctl.relmgr_entries);
      680 
      681 /* Move the contents of the new relation.m to old relation.m. */
      682 	if (file_model.file_model_copy_good & file_model.relation_copy_good & save_code = 0)
      683 	then do;
      684 	     move_string_length = divide (new_model_bit_count, 9, 35, 0);
      685 	     fm_ptr -> move_string = new_file_model_ptr -> move_string;
      686 
      687 /* Move the contents of the data relation. First we must get the attributes of
      688*   the old data file (ACL, mode switches) and move them to the new data file. */
      689 	     data_acl_ptr = null;
      690 	     call fs_util_$list_acl (db_path, relation.name, GENERAL_ACL_VERSION_1, user_area_ptr, data_acl_ptr, code);
      691 	     if code ^= 0
      692 	     then call error (code, "Getting the ACL to relation " || relation.name);
      693 
      694 	     call fs_util_$replace_acl (db_path, create_relation_name, data_acl_ptr, "1"b, code);
      695 	     if code ^= 0
      696 	     then call error (code, "Setting the ACL on relation " || create_relation_name);
      697 
      698 	     cvds, ivds = "0"b;
      699 	     call fs_util_$get_switch (db_path, relation.name, "complete_volume_dump", cvds, (0));
      700 	     call fs_util_$get_switch (db_path, relation.name, "incremental_volume_dump", ivds, (0));
      701 
      702                call fs_util_$set_switch (db_path, create_relation_name, "complete_volume_dump", cvds, (0));
      703 	     call fs_util_$set_switch (db_path, create_relation_name, "incremental_volume_dump", ivds, (0));
      704 
      705 /* Now get rid of the old data file. */
      706 	     call rmdb_relmgr_entries.delete_relation (db_path, relation.name, code);
      707 	     if code ^= 0
      708 	     then call error (code, "Deleting relation " || relation.name);
      709 
      710 /* If we are dealing with DM files, we need to physically copy the relation
      711*   file. If not, then we can simply rename the new one to the old name. */
      712 	     if mstxn_transactions_needed
      713 	     then do;
      714 		co.version = COPY_OPTIONS_VERSION_1;
      715 		co.caller_name = myname;
      716 		co.source_dir, co.target_dir = db_path;
      717 		co.source_name = create_relation_name;
      718 		co.target_name = relation.name;
      719 
      720 		unspec (co.flags) = "0"b;
      721 		unspec (co.copy_items) = "0"b;
      722 		
      723 		call fs_util_$copy (addr (co), code);
      724 		if code ^= 0
      725 		then call error (code, "Copying the new data file onto the old data file for relation " || relation.name);
      726 		end;
      727 	     else do; 
      728 		call hcs_$chname_file (db_path, create_relation_name, create_relation_name, relation.name, code);
      729 		if code ^= 0
      730 		then call error (code, "Renaming relation file from " || rtrim (create_relation_name) || " to " || relation.name);
      731 		end;
      732 	     end;                      /* file_model and relation good */
      733 /* Since we renamed the new to the old, we can get rid of the new names. */
      734 /* We also replaced the original file_model with the new_one. */
      735 	call rmdb_relmgr_entries.delete_relation (db_path, create_relation_name, (0));
      736 
      737 	call delete_$path (db_path, create_model_name, "101111"b, myname, (0));
      738 /* Take the copy of the file_model out of the db_model */
      739 	if relation.copy_file_model_ptr ^= null
      740 	then do;
      741 	     do fi_ptr = ptr (dbm_ptr, db_model.file_ptr) repeat ptr (dbm_ptr, file_info.fwd_ptr)
      742 		while (rel (fi_ptr) ^= rel (copy_file_model_ptr));
      743 		last_file_info_ptr = fi_ptr;
      744 		end;
      745 	     
      746 	     last_file_info_ptr -> file_info.fwd_ptr = copy_file_model_ptr -> file_info.fwd_ptr;
      747 	     free relation.copy_file_model_ptr -> file_info in (dbm_area);
      748 	     end;
      749 
      750 	if (code ^= 0)
      751 	then if ^delete_object_info.inhibit_errors
      752 	     then call error (code, error_message);
      753 	     else ;				/* ignore the error */
      754 	else if save_code = 0
      755 	then call modify_xref;
      756 	return;
      757 
      758 modify_xref:
      759      proc;
      760 
      761 dcl index fixed bin;
      762 
      763 /* Now we have to update the crossreference file records for all attributes and
      764*   domains that were updated in this relation. */
      765 
      766 	do index = 1 to relation.attribute_count;
      767 	     if relation.attribute (index).flags.delete
      768 	     then do;
      769 		attribute_name = unmake_name (relation.attribute_names (index));
      770 		call mdbm_util_$xref_dereference (local_iocb, ATTRIBUTE_KEY_HEAD, attribute_name, relation.name,
      771 		     reference_count, error_message, code);
      772 		if code ^= 0
      773 		then if delete_object_info.inhibit_errors
      774 		     then goto finish_relation;
      775 
      776 		di_ptr = ptr (dbm_ptr, relation.attribute(index).domain_info_ptr);
      777 		if reference_count = 0 & attribute_name ^= domain_info.name
      778 		then do;				/* attribute became unreferenced */
      779 
      780 /* Find the last unreferenced_attribute structure in the db_model. */
      781 		     if last_unreferenced_attribute_ptr = null
      782 		     then do ua_ptr = ptr (dbm_ptr, db_model.unreferenced_attribute_ptr)
      783 			     repeat ptr (dbm_ptr, unreferenced_attribute.fwd_thread)
      784 			     while (rel (ua_ptr) ^= NULL_OFFSET);
      785 			     last_unreferenced_attribute_ptr = ua_ptr;
      786 			     end;			/* do ua_ptr */
      787 
      788 /* Make a new unreferenced_attribute structure and populate it. */
      789 		     allocate unreferenced_attribute in (dbm_area) set (ua_ptr);
      790 		     unreferenced_attribute.name = attribute_name;
      791 		     unreferenced_attribute.domain_ptr = relation.attribute (index).domain_info_ptr;
      792 		     unreferenced_attribute.fwd_thread = NULL_OFFSET;
      793 		     unreferenced_attribute.unused (*) = NULL_OFFSET;
      794 
      795 /* Add it on the end of the linked list. */
      796 		     if last_unreferenced_attribute_ptr = null
      797 		     then db_model.unreferenced_attribute_ptr = rel (ua_ptr);
      798 		     else last_unreferenced_attribute_ptr -> unreferenced_attribute.fwd_thread = rel (ua_ptr);
      799 
      800 		     last_unreferenced_attribute_ptr = ua_ptr;
      801 		     end;
      802 		end;
      803 	     end;					/* do index */
      804 finish_relation:
      805          	return;
      806      end modify_xref;
      807      end switch_names;
      808 
      809 /*DESCRIPTION
      810*  Delete the crossreference records for all deleted domains. */
      811 
      812 delete_xref_records:
      813      proc;
      814 
      815 	do domain_list_idx = 1 to domain_list.count;
      816 	     if domain_list.name (domain_list_idx) ^= ""
      817 	     then do;
      818 		domain_name = unmake_name (domain_list.name (domain_list_idx));
      819 		call mdbm_util_$xref_delete_record (local_iocb, DOMAIN_KEY_HEAD, domain_name, error_message, code);
      820 		if code ^= 0
      821 		then if code ^= error_table_$no_record
      822 		     then call error (code, error_message);
      823 
      824 /* An artifact of a domain is that there is an attribute crossreference record
      825*   for each domain also, as a domain can also be used as an attribute without
      826*   explicitly creating the attribute. We must also delete this record from the
      827*   crossreference file. */
      828 		call mdbm_util_$xref_delete_record (local_iocb, ATTRIBUTE_KEY_HEAD, domain_name, error_message, code);
      829 		if code ^= 0
      830 		then if code ^= error_table_$no_record
      831 		     then call error (code, error_message);
      832 
      833 /* we got rid of the "generated" attribute, now get rid of any others */
      834 		attribute_list_ptr = domain_list.attribute_list_ptr(domain_list_idx); 
      835 		if attribute_list_ptr ^= null 	
      836 		then do attribute_list_idx = 1 to attribute_list.count;	
      837 		     attribute_name = unmake_name(attribute_list.name(attribute_list_idx));
      838 		     call mdbm_util_$xref_delete_record (local_iocb, ATTRIBUTE_KEY_HEAD, attribute_name, error_message, code);
      839 		     if code ^= 0
      840 		     then if code ^= error_table_$no_record
      841 			then call error (code, error_message);
      842 		     end;                               /* do attribute_list_idx */
      843 		end;				/* do domain_list_idx */
      844 	     end;
      845 
      846 	return;
      847      end delete_xref_records;
      848 
      849 /*DESCRIPTION
      850*  Unlink the domain_info structures for the deleted domains in the db_model.
      851*  Add a history entry for each deleted domain. */
      852 
      853 unlink_deleted_domains:
      854      proc;
      855 
      856 	do domain_list_idx = 1 to domain_list.count;
      857 	     if domain_list.name (domain_list_idx) ^= ""
      858 	     then do;
      859 		domain_name = unmake_name (domain_list.name (domain_list_idx));
      860 
      861 /* Since we just made all the attributes based on this domain unreferenced
      862*   in the model, we need to unlink all the attributes on the attribute_list
      863*   from the unreferenced attribute chain and free the ua structures. Skip
      864*   the list entry that has the same name as the domain name, because the
      865*   generated attribute has no structures in the model.                     */
      866 
      867 		attribute_list_ptr = domain_list.attribute_list_ptr (domain_list_idx);
      868 		if attribute_list_ptr ^= null
      869 		then do attribute_list_idx = 1 to attribute_list.count;
      870 		     if attribute_list.name (attribute_list_idx) ^= domain_list.name (domain_list_idx)
      871 		     then do;		/* all but the generated one */
      872 			previous_ptr, save_ptr = null;
      873 			attribute_name = unmake_name (attribute_list.name (attribute_list_idx));
      874 			do ua_ptr = ptr (dbm_ptr, db_model.unreferenced_attribute_ptr)
      875 			     repeat ptr (dbm_ptr, unreferenced_attribute.fwd_thread)
      876 			     while ((save_ptr = null) & (rel (ua_ptr) ^= NULL_OFFSET));
      877 			     if unreferenced_attribute.name = attribute_name
      878 			     then save_ptr = ua_ptr;
      879 			     else previous_ptr = ua_ptr;
      880 			     end;		/* do ua_ptr */
      881 
      882 			if save_ptr ^= null
      883 			then do;
      884 			     if previous_ptr = null
      885 			     then db_model.unreferenced_attribute_ptr =
      886 				     save_ptr -> unreferenced_attribute.fwd_thread;
      887 			     else previous_ptr -> unreferenced_attribute.fwd_thread =
      888 				     save_ptr -> unreferenced_attribute.fwd_thread;
      889 
      890 			     free save_ptr -> unreferenced_attribute in (dbm_area);
      891 
      892 			     call rmdb_add_rmdb_history (dbm_ptr, RMDB_ATTR_TYPE, attribute_name,
      893 				RMDB_DEL_ATTR_OP, "", (""), (0));
      894 			     end;
      895 			end;
      896 		end;			/* do attribute_list_idx */
      897 
      898 /* Now that we have gotten rid of all the unreferenced attributes based upon
      899*   this domain, we can get rid of the domain_info structure. */
      900 		previous_ptr, save_ptr = null;
      901 		do di_ptr = ptr (dbm_ptr, db_model.domain_ptr) repeat ptr (dbm_ptr, domain_info.fwd_thread)
      902 		     while ((save_ptr = null) & (rel (di_ptr) ^= NULL_OFFSET));
      903 		     if domain_info.name = domain_name
      904 		     then save_ptr = di_ptr;
      905 		     else previous_ptr = di_ptr;
      906 		     end;				/* do di_ptr */
      907 
      908 		if save_ptr ^= null
      909 		then do;
      910 		     if previous_ptr = null
      911 		     then db_model.domain_ptr = save_ptr -> domain_info.fwd_thread;
      912 		     else previous_ptr -> domain_info.fwd_thread = save_ptr -> domain_info.fwd_thread;
      913 
      914 		     free save_ptr -> domain_info in (dbm_area);
      915 		     db_model.num_domains = db_model.num_domains - 1;
      916 
      917 		     call rmdb_add_rmdb_history (dbm_ptr, RMDB_DOMAIN_TYPE, domain_name, RMDB_DEL_DMN_OP, "", (""),
      918 			(0));
      919 
      920 		     end;
      921 
      922 		end;
      923 	     end;					/* do domain_list_idx */
      924 
      925 	return;
      926      end unlink_deleted_domains;
      927 
  5     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  5     2*
  5     3*   Values for the "access mode" argument so often used in hardcore
  5     4*   James R. Davis 26 Jan 81  MCR 4844
  5     5*   Added constants for SM access 4/28/82 Jay Pattin
  5     6*   Added text strings 03/19/85 Chris Jones
  5     7**/
  5     8 
  5     9 
  5    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  5    11 dcl	(
  5    12 	N_ACCESS		   init ("000"b),
  5    13 	R_ACCESS		   init ("100"b),
  5    14 	E_ACCESS		   init ("010"b),
  5    15 	W_ACCESS		   init ("001"b),
  5    16 	RE_ACCESS		   init ("110"b),
  5    17 	REW_ACCESS	   init ("111"b),
  5    18 	RW_ACCESS		   init ("101"b),
  5    19 	S_ACCESS		   init ("100"b),
  5    20 	M_ACCESS		   init ("010"b),
  5    21 	A_ACCESS		   init ("001"b),
  5    22 	SA_ACCESS		   init ("101"b),
  5    23 	SM_ACCESS		   init ("110"b),
  5    24 	SMA_ACCESS	   init ("111"b)
  5    25 	)		   bit (3) internal static options (constant);
  5    26 
  5    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  5    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  5    29 
  5    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  5    31 			   static options (constant);
  5    32 
  5    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  5    34 			   static options (constant);
  5    35 
  5    36 dcl	(
  5    37 	N_ACCESS_BIN	   init (00000b),
  5    38 	R_ACCESS_BIN	   init (01000b),
  5    39 	E_ACCESS_BIN	   init (00100b),
  5    40 	W_ACCESS_BIN	   init (00010b),
  5    41 	RW_ACCESS_BIN	   init (01010b),
  5    42 	RE_ACCESS_BIN	   init (01100b),
  5    43 	REW_ACCESS_BIN	   init (01110b),
  5    44 	S_ACCESS_BIN	   init (01000b),
  5    45 	M_ACCESS_BIN	   init (00010b),
  5    46 	A_ACCESS_BIN	   init (00001b),
  5    47 	SA_ACCESS_BIN	   init (01001b),
  5    48 	SM_ACCESS_BIN	   init (01010b),
  5    49 	SMA_ACCESS_BIN	   init (01011b)
  5    50 	)		   fixed bin (5) internal static options (constant);
  5    51 
  5    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      928 
  6     1 /* Begin include file -- acl_structures.incl.pl1 BIM 3/82 */
  6     2 /* format: style3,indcomtxt,idind30 */
  6     3 
  6     4 declare   acl_ptr                       pointer;
  6     5 declare   acl_count                     fixed bin;
  6     6 
  6     7 declare 1 general_acl                   aligned based (acl_ptr), /* for fs_util_ */
  6     8           2 version                     char (8) aligned,
  6     9           2 count                       fixed bin,
  6    10           2 entries                     (acl_count refer (general_acl.count)) aligned like general_acl_entry;
  6    11 
  6    12 declare 1 general_acl_entry             based,
  6    13           2 access_name                 character (32) unaligned,
  6    14           2 mode                        bit (36) aligned,
  6    15           2 status_code                 fixed bin (35);
  6    16 
  6    17 
  6    18 declare 1 general_extended_acl          aligned based (acl_ptr), /* for fs_util_ */
  6    19           2 version                     char (8) aligned,
  6    20           2 count                       fixed bin,
  6    21           2 entries                     (acl_count refer (general_extended_acl.count)) aligned like general_extended_acl_entry;
  6    22 
  6    23 declare 1 general_extended_acl_entry    aligned based,
  6    24           2 access_name                 character (32) unaligned,
  6    25           2 mode                        bit (36) aligned,
  6    26           2 extended_mode               bit (36) aligned,
  6    27           2 status_code                 fixed bin (35);
  6    28 
  6    29 
  6    30 declare 1 general_delete_acl            aligned based (acl_ptr), /* for file_system_ */
  6    31           2 version                     char (8) aligned,
  6    32           2 count                       fixed bin,
  6    33           2 entries                     (acl_count refer (general_delete_acl.count)) aligned like delete_acl_entry;
  6    34 
  6    35 declare 1 general_delete_acl_entry      aligned based,
  6    36           2 access_name                 character (32) unaligned,
  6    37           2 status_code                 fixed bin (35);
  6    38 
  6    39 
  6    40 declare 1 segment_acl                   aligned based (acl_ptr),
  6    41           2 version                     fixed bin,
  6    42           2 count                       fixed bin,
  6    43           2 entries                     (acl_count refer (segment_acl.count)) aligned like segment_acl_entry;
  6    44 
  6    45 declare 1 segment_acl_entry             like general_extended_acl_entry aligned based;
  6    46 declare 1 segment_acl_array             (acl_count) aligned like segment_acl_entry based (acl_ptr);
  6    47 
  6    48 
  6    49 declare 1 directory_acl                 aligned based (acl_ptr),
  6    50           2 version                     fixed bin,
  6    51           2 count                       fixed bin,
  6    52           2 entries                     (acl_count refer (directory_acl.count)) aligned like directory_acl_entry;
  6    53 
  6    54 declare 1 directory_acl_entry           like general_acl_entry aligned based;
  6    55 declare 1 directory_acl_array           (acl_count) aligned like directory_acl_entry based (acl_ptr);
  6    56 
  6    57 
  6    58 declare 1 delete_acl                    based (acl_ptr) aligned,
  6    59           2 version                     fixed bin,
  6    60           2 count                       fixed bin,
  6    61           2 entries                     (acl_count refer (delete_acl.count)) aligned like delete_acl_entry;
  6    62 
  6    63 declare 1 delete_acl_entry              like general_delete_acl_entry aligned based;
  6    64 declare 1 delete_acl_array              (acl_count) aligned like delete_acl_entry based (acl_ptr);
  6    65 
  6    66 
  6    67 declare  (SEG_ACL_VERSION_1             init ("sga1"),
  6    68           DIR_ACL_VERSION_1             init ("dra1"),
  6    69           DELETE_ACL_VERSION_1          init ("dla1"))
  6    70                                         char (4) int static options (constant);
  6    71 
  6    72 declare  (GENERAL_ACL_VERSION_1         init ("gacl001"),
  6    73           GENERAL_EXTENDED_ACL_VERSION_1 init ("gxacl001"),
  6    74           GENERAL_DELETE_ACL_VERSION_1  init ("gdacl001"))
  6    75                                         char (8) internal static options (constant);
  6    76 
  6    77 declare   ACL_VERSION_1                 fixed bin init (1) int static options (constant);
  6    78 
  6    79 /* End include file acl_structures.incl.pl1 */
      929 
  7     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  7     2 
  7     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  7     4 
  7     5 dcl  area_infop ptr;
  7     6 
  7     7 dcl 1 area_info aligned based (area_infop),
  7     8     2 version fixed bin,				/* version number for this structure is 1 */
  7     9     2 control aligned like area_control,		/* control bits for the area */
  7    10     2 owner char (32) unal,				/* creator of the area */
  7    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  7    12     2 size fixed bin (18),				/* size of the area in words */
  7    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  7    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  7    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  7    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  7    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  7    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  7    19 
  7    20 dcl 1 area_control aligned based,
  7    21     2 extend bit (1) unal,				/* says area is extensible */
  7    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  7    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  7    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  7    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  7    26     2 system bit (1) unal,				/* says area is managed by system */
  7    27     2 pad bit (30) unal;
  7    28 
  7    29 /* END INCLUDE FILE area_info.incl.pl1 */
      930 
  8     1 /* BEGIN INCLUDE FILE:  copy_flags.incl.pl1 */
  8     2 
  8     3 /* Flags for attributes that should/may be copied by the copy_ subroutine. This include file is
  8     4*   required by suffix_info.incl.pl1 and copy_options.incl.pl1
  8     5*
  8     6*   Jay Pattin 6/23/83 */
  8     7 
  8     8 declare   1 copy_flags                  aligned based,      /* ON means that this attribute may be copied by copy_ */
  8     9           2 names                       bit (1) unaligned,
  8    10           2 acl                         bit (1) unaligned,
  8    11           2 ring_brackets               bit (1) unaligned,
  8    12           2 max_length                  bit (1) unaligned,
  8    13           2 copy_switch                 bit (1) unaligned,
  8    14           2 safety_switch               bit (1) unaligned,
  8    15           2 dumper_switches             bit (1) unaligned,
  8    16           2 entry_bound                 bit (1) unaligned,  /* only for vanilla object segments */
  8    17           2 extend                      bit (1) unaligned,  /* copy_ may append to end of existing object */
  8    18           2 update                      bit (1) unaligned,  /* copy_ may replace contents of existing object */
  8    19           2 mbz                         bit (26) unaligned;
  8    20 
  8    21 /* END INCLUDE FILE:  copy_flags.incl.pl1 */
      931 
  9     1 /* BEGIN INCLUDE FILE: copy_options.incl.pl1 */
  9     2 
  9     3 /* This structure declares the input structure used by the copy_ subroutine.
  9     4*
  9     5*   NOTE: This include file depends on declarations in the include file
  9     6*   copy_flags.incl.pl1.
  9     7*
  9     8*   Jay Pattin 6/1/83 */
  9     9 
  9    10 declare   copy_options_ptr              ptr;
  9    11 
  9    12 declare   1 copy_options                aligned based (copy_options_ptr),
  9    13           2 version                     char (8),           /* currently COPY_OPTIONS_VERSION_1 */
  9    14           2 caller_name                 char (32) unal,     /* Used in nd_handler_ call */
  9    15           2 source_dir                  char (168) unal,
  9    16           2 source_name                 char (32) unal,
  9    17           2 target_dir                  char (168) unal,
  9    18           2 target_name                 char (32) unal,
  9    19           2 flags,
  9    20             3 no_name_dup               bit (1) unaligned,  /* ON = don't call nd_handler_ */
  9    21             3 raw                       bit (1) unaligned,  /* ON = don't call object_type_, use hcs_ */
  9    22             3 force                     bit (1) unaligned,  /* ON = delete or force access to target */
  9    23             3 delete                    bit (1) unaligned,  /* ON = delete original after copy (for move) */
  9    24             3 target_err_switch         bit (1) unaligned,
  9    25             3 mbz                       bit (31) unaligned,
  9    26           2 copy_items                  like copy_flags;    /* see copy_flags.incl.pl1 */
  9    27 
  9    28 declare   COPY_OPTIONS_VERSION_1        char (8) static options (constant) init ("CPOPT001");
  9    29 
  9    30 /* END INCLUDE FILE: copy_options.incl.pl1 */
      932 
 10     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
 10     2 
 10     3 
 10     4 /****^  HISTORY COMMENTS:
 10     5*  1) change(79-02-01,Gray), approve(), audit(), install():
 10     6*     modified to save space occupied by model
 10     7*  2) change(80-11-03,Gray), approve(), audit(), install():
 10     8*     to add mdbm_secured bit in db_model
 10     9*  3) change(82-04-09,Davids), approve(), audit(), install():
 10    10*     collapsed the following into an unused_offset array:
 10    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
 10    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
 10    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
 10    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
 10    15*       unused_1
 10    16*     Also changed the name of unused_2 to restructuring_history_offset
 10    17*     and changed the comment on the changer structure to indicate
 10    18*     that it will contain on database creation information.
 10    19*  4) change(82-04-14,Davids), approve(), audit(), install():
 10    20*     used one of the unused_offsets to point to a message which indicates
 10    21*     why the db is inconsistent. The offset will be null when the db is created
 10    22*     and set the first time the message is used. this is so it will be
 10    23*     consistent with existing data bases. Also added the message structure.
 10    24*  5) change(82-04-28,Davids), approve(), audit(), install():
 10    25*     added the undo_request element to the message structure
 10    26*  6) change(82-05-04,Davids), approve(), audit(), install():
 10    27*     changed unused_offset (12) to last_restructruring_history_offset and
 10    28*     changed restructuring_history_offset to first_restructuring_history_offset
 10    29*  7) change(82-08-19,Davids), approve(), audit(), install():
 10    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
 10    31*     1 => vfile database and 2 => page_file database. Up to this point all
 10    32*     database types were equal to 1.
 10    33*  8) change(83-02-14,Davids), approve(), audit(), install():
 10    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
 10    35*     flags. This will allow information about transactions and dm_file
 10    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
 10    37*     change is compatable with all datamodels created by the released version
 10    38*     of mrds.
 10    39*  9) change(83-02-15,Davids), approve(), audit(), install():
 10    40*     added the rollback_on flag to the db_type_flags since it appears that you
 10    41*     can have a dmfile database that requires transactions but does not have any
 10    42*     journalizing. Also switched the order of the transactions_needed and
 10    43*     concurrency_on flags - this makes the change compatable with existing
 10    44*     dmfile databases except when displaying the model since concurrency_on and
 10    45*     rollback_on will be off in the model even though the dmfile relations had
 10    46*     them on during creation.
 10    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
 10    48*      Removed ctl_file_path_ptr.
 10    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
 10    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 10    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
 10    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
 10    53*      in the flag word for rmdb copying.
 10    54*                                                   END HISTORY COMMENTS */
 10    55 
 10    56 
 10    57 /* this include file contains the structures that go into the make up
 10    58*   of the "db_model" segment in the model for the database.
 10    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
 10    60*
 10    61*   the db_model structure goes at the base of the segment, and contains items unique to
 10    62*   the whole databse. in addition, it has an area of size to fill the
 10    63*   rest of a segment, that holds the lists of files and domains in the database.
 10    64*   these lists are singly forward linked lists. all "pointers" in the database model
 10    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
 10    66*   since actual pointers are process dependent on segment number.
 10    67*   the remaining structures are first a path_entry one to save pathnames in,
 10    68*   and the stack_item and constent structures, used to save a boolean
 10    69*   expression in polish form, with the stack represented by a linked list.
 10    70*   the final structure is one for identifying the status of version information */
 10    71 
 10    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
 10    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
 10    74 	     2 db_type_flags      unal,
 10    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
 10    76 	       3 unused	      (13) bit (1) unal,
 10    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
 10    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
 10    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
 10    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
 10    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
 10    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
 10    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
 10    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
 10    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
 10    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
 10    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
 10    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
 10    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
 10    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
 10    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
 10    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
 10    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
 10    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
 10    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
 10    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
 10    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
 10    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
 10    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
 10   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
 10   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
 10   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
 10   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
 10   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
 10   105 
 10   106      dcl	   dbm_ptr	      ptr;
 10   107 
 10   108 /* the files in the database each have a file_info containing
 10   109*   their name, the file_model for each file is found by initiating the
 10   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
 10   111*   the file_info list is a singly linked list in definition order */
 10   112 
 10   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
 10   114 	     2 file_name	      char (30),		/* name of file */
 10   115 	     2 file_id	      bit (36),		/* id number of file */
 10   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
 10   117 	     2 unused	      unal bit (18);	/* for future expansion */
 10   118 
 10   119      dcl	   fi_ptr		      ptr;
 10   120 
 10   121 /* each domain used in the database will have a domain info saved in the db_model
 10   122*   segment. it describes the domain of the given name, and it's options.
 10   123*   the domain_info's form a singly linked list in definition order */
 10   124 
 10   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
 10   126 	     2 name	      char (32),		/* name of domain */
 10   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
 10   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
 10   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
 10   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
 10   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
 10   132 	     2 reserved	      bit (31) unal,
 10   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
 10   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
 10   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
 10   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
 10   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
 10   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
 10   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
 10   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
 10   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
 10   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
 10   143 	     2 str_err_path_ptr   unal bit (18),
 10   144 	     2 str_after_path_ptr unal bit (18),
 10   145 	     2 get_before_path_ptr unal bit (18),
 10   146 	     2 get_err_path_ptr   unal bit (18),
 10   147 	     2 get_after_path_ptr unal bit (18),
 10   148 	     2 mod_before_path_ptr unal bit (18),
 10   149 	     2 mod_err_path_ptr   unal bit (18),
 10   150 	     2 mod_after_path_ptr unal bit (18),
 10   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
 10   152 	     2 unused_2	      unal bit (18),
 10   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
 10   154 
 10   155      dcl	   di_ptr		      ptr;
 10   156 
 10   157 /* information necessary for attributes that are not used in any relation */
 10   158 
 10   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
 10   160 	     2 name char (32),			/* name of attribute */
 10   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
 10   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
 10   163 	     2 unused (2) bit (18) unal;
 10   164 
 10   165      dcl     ua_ptr ptr;
 10   166 
 10   167 
 10   168 /* space saving pathname$entryname structure, to be allocated
 10   169*   only when a path$entry has to be saved, else only a bit(18)
 10   170*   offset takes up space in the main model structure */
 10   171 
 10   172      declare 1 path_entry	      based (path_entry_ptr),
 10   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
 10   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
 10   175 	     2 reserved	      unal bit (36);	/* for future use */
 10   176 
 10   177      declare path_entry_ptr	      ptr;
 10   178 
 10   179 
 10   180 
 10   181 
 10   182 
 10   183 /* declarations for model of postfix stack holding the check option boolean expression
 10   184*   the following encoding values indicate the corresponding type of stack element
 10   185*
 10   186*   1  =
 10   187*   2  ^=
 10   188*   3  >
 10   189*   4  <
 10   190*   5  >=
 10   191*   6  <=
 10   192*
 10   193*   10  and
 10   194*   20  or
 10   195*   30  not
 10   196*
 10   197*   40  - (minus)
 10   198*
 10   199*   50  domain variable(same name as domain)
 10   200*
 10   201*   60  constant(number, bit string, or character string)
 10   202*
 10   203**/
 10   204 
 10   205 
 10   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
 10   207 	     2 next	      bit (18),		/* link to next in list */
 10   208 	     2 type	      fixed binary,		/* code for this element type */
 10   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
 10   210*						   if this is a constant element type */
 10   211 
 10   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
 10   213 
 10   214 
 10   215 
 10   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
 10   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
 10   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
 10   219 
 10   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
 10   221 
 10   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
 10   223 
 10   224 /* version structure, giving status of source for CMDB/RMDB,
 10   225*   status of model, and status of resultant */
 10   226 
 10   227 /* version number is in form MM.N.Y
 10   228*   where MM is the major version number, N is the minor version alteration,
 10   229*   and Y is the lastest modification to that alteration,
 10   230*   where M and N represent numbers 0-9, and Y is a letter */
 10   231 
 10   232      declare 1 version_status	      unal based (version_status_ptr),
 10   233 	     2 cmdb_rmdb,
 10   234 	       3 major	      fixed bin,
 10   235 	       3 minor	      fixed bin,
 10   236 	       3 modification     char (4),
 10   237 	     2 model,
 10   238 	       3 major	      fixed bin,
 10   239 	       3 minor	      fixed bin,
 10   240 	       3 modification     char (4),
 10   241 	     2 resultant,
 10   242 	       3 major	      fixed bin,
 10   243 	       3 minor	      fixed bin,
 10   244 	       3 modification     char (4);
 10   245 
 10   246      declare version_status_ptr     ptr;
 10   247 
 10   248 
 10   249 /* maintains information only about the db creation */
 10   250 
 10   251      declare 1 changer	      unal based (changer_ptr),
 10   252 	     2 id		      char (32),
 10   253 	     2 time	      fixed bin (71),
 10   254 	     2 next	      bit (18);		/* to next in the singly linked list */
 10   255 
 10   256      declare changer_ptr	      ptr;
 10   257 
 10   258 
 10   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
 10   260 	     02 len	      fixed bin,		/* length of the message */
 10   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
 10   262 	     02 name	      char (32),		/* name of thing that set the message */
 10   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
 10   264*                                                               that caused the database to become inconsistent */
 10   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
 10   266 
 10   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
 10   268 
 10   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
 10   270 
 10   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
 10   272 
 10   273 
      933 
 11     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
 11     2 
 11     3 
 11     4 /****^  HISTORY COMMENTS:
 11     5*  1) change(79-02-01,JGray), approve(), audit(), install():
 11     6*     modified to save space occupied by model
 11     7*  2) change(82-05-19,Davids), approve(), audit(), install():
 11     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
 11     9*     the number of secondary indices in the relation - it was always zero.
 11    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
 11    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
 11    12*     DMS conversion.
 11    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
 11    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
 11    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
 11    16*     for relation manager changes.
 11    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
 11    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 11    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
 11    20*     <rel> files are good (for rmdb)
 11    21*                                                   END HISTORY COMMENTS */
 11    22 
 11    23 
 11    24 /* each file in the database will have a model segment with the name
 11    25*   file_name.m (i.e. the files name plus a suffix of ".m")
 11    26*   the file_model structure is allocated at the base of the segment for a given file.
 11    27*   it contains an area with which all other structures in this include file are allocated.
 11    28*   these structures contain the information about which relations, foreign keys,
 11    29*   and attributes are members of this file. all lists are singly linked lists in
 11    30*   definition order. pointers to these structures are obtained by using the "pointer"
 11    31*   builtin function with arguments of the segment base pointer, and the
 11    32*   offset (bit (18)) relative to that pointer that is actually stored in
 11    33*   the file model itself. this is because pointer segment numbers are
 11    34*   per process dependent. the major lists pointed to by the file_model structure
 11    35*   are the list of relations in this file(each with a contained attribute list),
 11    36*   and the list of foreign keys whose parent relation resides in this file
 11    37*   (along with a participating attribute sublist, and the child relation list,
 11    38*   if they are also in this file) */
 11    39 
 11    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
 11    41     2 temporary bit (1) unal,				/* on if file not part of db. */
 11    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
 11    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
 11    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
 11    45     2 reserved bit (32) unal,				/* reserved for future flags */
 11    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
 11    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
 11    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
 11    49     2 pad_1 fixed bin (35),				/* for future use */
 11    50     2 pad_2 fixed bin (35),
 11    51     2 ratd_len fixed bin (21),			/* length of above */
 11    52     2 mratd_len fixed bin (21),			/* length of above */
 11    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
 11    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
 11    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
 11    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
 11    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
 11    58     2 block_size unal fixed bin,			/* no. pages in block */
 11    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
 11    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
 11    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
 11    62     2 num_rels unal fixed bin,			/* number of relations in file */
 11    63     2 num_links unal fixed bin,			/* number of links in file */
 11    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
 11    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
 11    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
 11    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
 11    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
 11    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
 11    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
 11    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
 11    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
 11    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
 11    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
 11    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
 11    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
 11    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
 11    78     2 open_eu_err_path_ptr unal bit (18),
 11    79     2 open_eu_after_path_ptr unal bit (18),
 11    80     2 open_er_before_path_ptr unal bit (18),
 11    81     2 open_er_err_path_ptr unal bit (18),
 11    82     2 open_er_after_path_ptr unal bit (18),
 11    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
 11    84     2 open_neu_err_path_ptr unal bit (18),
 11    85     2 open_neu_after_path_ptr unal bit (18),
 11    86     2 open_ner_before_path_ptr unal bit (18),
 11    87     2 open_ner_err_path_ptr unal bit (18),
 11    88     2 open_ner_after_path_ptr unal bit (18),
 11    89     2 open_pu_before_path_ptr unal bit (18),
 11    90     2 open_pu_err_path_ptr unal bit (18),
 11    91     2 open_pu_after_path_ptr unal bit (18),
 11    92     2 open_pr_before_path_ptr unal bit (18),
 11    93     2 open_pr_err_path_ptr unal bit (18),
 11    94     2 open_pr_after_path_ptr unal bit (18),
 11    95     2 open_cu_before_path_ptr unal bit (18),
 11    96     2 open_cu_err_path_ptr unal bit (18),
 11    97     2 open_cu_after_path_ptr unal bit (18),
 11    98     2 open_cr_before_path_ptr unal bit (18),
 11    99     2 open_cr_err_path_ptr unal bit (18),
 11   100     2 open_cr_after_path_ptr unal bit (18),
 11   101     2 close_before_path_ptr unal bit (18),
 11   102     2 close_err_path_ptr unal bit (18),
 11   103     2 close_after_path_ptr unal bit (18),
 11   104     2 unused_1 unal bit (18),				/* for future expansion */
 11   105     2 unused_2 unal bit (18),
 11   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
 11   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
 11   108 dcl  fm_ptr ptr;
 11   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
 11   110 dcl  atd_ptr ptr;
 11   111 dcl  atd_len fixed bin;
 11   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
 11   113     2 ncomponents fixed bin,
 11   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
 11   115 dcl  cna_ptr ptr;
 11   116 dcl  ncomp_init fixed bin;
 11   117 
 11   118 /* a rel_info structure contains information describing a relation.
 11   119*   a relation may only occur in one file, thus there is one rel_info
 11   120*   per relation per database, each stored in the file_model area for
 11   121*   the file that contains it. the list of rel_info's in this file
 11   122*   form a singly linked list in definition order.
 11   123*   the rel_info itself points to a list of the attributes it contains,
 11   124*   and to any parent_link or child_link info's that involve it in a foreign key */
 11   125 
 11   126 dcl 1 rel_info aligned based (ri_ptr),
 11   127     2 name char (32),				/* relation name */
 11   128     2 id  bit (36) aligned,				/* relation id number */
 11   129     2 hashed bit (1) unal,				/* on if hashed */
 11   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
 11   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
 11   132     2 system bit (1) unal,				/* on if dont care how stored */
 11   133     2 indexed bit (1) unal,				/* on if secondary index */
 11   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
 11   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
 11   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
 11   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
 11   138     2 reserved bit (27) unal,				/* for future flags */
 11   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
 11   140     2 num_links_child unal fixed bin,			/* no. links in which child */
 11   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
 11   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
 11   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
 11   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
 11   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
 11   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
 11   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
 11   148     2 unused_3 unal fixed bin,			/* element that was never used */
 11   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
 11   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
 11   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
 11   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
 11   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
 11   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
 11   155     2 attr_ptr unal bit (18),				/* to attr. info */
 11   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
 11   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
 11   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
 11   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
 11   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
 11   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
 11   162     2 link_err_path_ptr unal bit (18),
 11   163     2 link_after_path_ptr unal bit (18),
 11   164     2 unlk_before_path_ptr unal bit (18),
 11   165     2 unlk_err_path_ptr unal bit (18),
 11   166     2 unlk_after_path_ptr unal bit (18),
 11   167     2 str_before_path_ptr unal bit (18),
 11   168     2 str_err_path_ptr unal bit (18),
 11   169     2 str_after_path_ptr unal bit (18),
 11   170     2 del_before_path_ptr unal bit (18),
 11   171     2 del_err_path_ptr unal bit (18),
 11   172     2 del_after_path_ptr unal bit (18),
 11   173     2 mod_before_path_ptr unal bit (18),
 11   174     2 mod_err_path_ptr unal bit (18),
 11   175     2 mod_after_path_ptr unal bit (18),
 11   176     2 find_before_path_ptr unal bit (18),
 11   177     2 find_err_path_ptr unal bit (18),
 11   178     2 find_after_path_ptr unal bit (18),
 11   179     2 retr_before_path_ptr unal bit (18),
 11   180     2 retr_err_path_ptr unal bit (18),
 11   181     2 retr_after_path_ptr unal bit (18),
 11   182     2 unused_1 unal bit (18),				/* for future expansion */
 11   183     2 unused_2 unal bit (18),
 11   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
 11   185 dcl  ri_ptr ptr;
 11   186 
 11   187 /* a attr_info structure contains information about an attribute in a given relation.
 11   188*   since attributes may appear in more than one relation, each occurence of an attribute
 11   189*   means that an attr_info for it will be put in that relations sublist of attributes.
 11   190*   the list is singly linked in definition order. the attr_info describes
 11   191*   the data it represents, and how that data is used during a database search. */
 11   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
 11   193     2 name char (32),				/* name of attribute */
 11   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
 11   195     2 index_attr bit (1) unal,			/* on if a secondary index */
 11   196     2 link_attr bit (1) unal,				/* on if participates in link */
 11   197     2 reserved bit (33) unal,
 11   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
 11   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
 11   200     2 key_order unal fixed bin,			/* relative posit. in key */
 11   201     2 bit_offset fixed bin (35),			/* position in tuple */
 11   202     2 bit_length fixed bin (35),			/* length if fixed */
 11   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
 11   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
 11   205     2 domain_ptr unal bit (18),			/* to domain info */
 11   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
 11   207     2 fwd_thread unal bit (18),			/* to next in list */
 11   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
 11   209 dcl  ai_ptr ptr;
 11   210 
 11   211 /* a parent_link_info structure is the carrier of foreign key definition info.
 11   212*   each time a foreign key definition indicates a relation as it's parent,
 11   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
 11   214*   a relation can be parent and/or child in any number of foreign keys.
 11   215*   the parent_link_info structure describes the foreign key, and also points
 11   216*   to a list of the attributes that participate in this foreign key.
 11   217*   (this could be from 1 up to all attributes in the relation)
 11   218*   the attr_list structures are in a singly linked list in definition order
 11   219*   for this purpose. also pointed to is a list of child_link_info's
 11   220*   that describe the child relations in this foreign key. since foreign keys
 11   221*   may span files, not all related child_link_info's have to be in this file's
 11   222*   model area. */
 11   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
 11   224     2 name char (32),				/* name of link */
 11   225     2 singular bit (1) unal,				/* on if system owned link */
 11   226     2 temp bit (1) unal,				/* on if temp. order */
 11   227     2 first bit (1) unal,				/* insertion indicators */
 11   228     2 last bit (1) unal,
 11   229     2 next bit (1) unal,
 11   230     2 prior bit (1) unal,
 11   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
 11   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
 11   233     2 dup_first bit (1) unal,				/* duplicates first */
 11   234     2 dup_last bit (1) unal,				/* duplicates last */
 11   235     2 indexed bit (1) unal,				/* locate parent via index */
 11   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
 11   237     2 thread_36 bit (1) unal,				/* thread size indicators */
 11   238     2 thread_27 bit (1) unal,
 11   239     2 thread_18 bit (1) unal,
 11   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
 11   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
 11   242     2 reserved bit (19) unal,				/* reserved for future flags */
 11   243     2 index_id aligned bit (8),			/* id of index if indexed */
 11   244     2 thread_index unal fixed bin,			/* index to threads in parent */
 11   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
 11   246     2 n_children unal fixed bin,			/* no. children in link */
 11   247     2 child_fn char (30),				/* file name for first child in list */
 11   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
 11   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
 11   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
 11   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
 11   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
 11   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
 11   254     2 sort_err_path_ptr unal bit (18),
 11   255     2 sort_after_path_ptr unal bit (18),
 11   256     2 srch_before_path_ptr unal bit (18),
 11   257     2 srch_err_path_ptr unal bit (18),
 11   258     2 srch_after_path_ptr unal bit (18),
 11   259     2 link_before_path_ptr unal bit (18),
 11   260     2 link_err_path_ptr unal bit (18),
 11   261     2 link_after_path_ptr unal bit (18),
 11   262     2 unlk_before_path_ptr unal bit (18),
 11   263     2 unlk_err_path_ptr unal bit (18),
 11   264     2 unlk_after_path_ptr unal bit (18),
 11   265     2 unused_1 unal bit (18),				/* for future expansion */
 11   266     2 unused_2 unal bit (18),
 11   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
 11   268 dcl  pli_ptr ptr;
 11   269 
 11   270 /* a child_link_info structure is the counter part of a parent_link_info
 11   271*   for foreign key child relations. each time a relation is defined to be
 11   272*   a child in a foreign key, it's list of child_link_infos will be added to.
 11   273*   this list is singly linked in foreign key definition order.
 11   274*   the child_link_info points to a list of participating attributes from the
 11   275*   child relation by means of a singly linked list of attr_list structures
 11   276*   in definition order. the number of attributes in the parent attr_list
 11   277*   and the child attr_list lists are the same with corresponding attr_list
 11   278*   attributes having the same domain. all child_link_infos in this file
 11   279*   are on a seperately linked list. this may not include all
 11   280*   child_link_infos for foreign keys whose parent relation resides in this file,
 11   281*   since foreign keys may span files, and the child_link_info will
 11   282*   reside in the file containing it's associated relation_info. */
 11   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
 11   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
 11   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
 11   286     2 fixed bit (1) unal,				/* on if membership fixed */
 11   287     2 optional bit (1) unal,				/* on if membership optional */
 11   288     2 auto bit (1) unal,				/* on if insertion automatic */
 11   289     2 manual bit (1) unal,				/* on if insertion manual */
 11   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
 11   291     2 range_sel bit (1) unal,				/* on if range type selection */
 11   292     2 key_dup_first bit (1) unal,			/* sort key flags */
 11   293     2 key_dup_last bit (1) unal,
 11   294     2 key_null bit (1) unal,				/* on if null allowed */
 11   295     2 sel_system bit (1) unal,			/* selection criteria flags */
 11   296     2 sel_current bit (1) unal,
 11   297     2 sel_key bit (1) unal,
 11   298     2 sel_proc bit (1) unal,
 11   299     2 no_null bit (1) unal,				/* if null key values not allowed */
 11   300     2 reserved bit (21) unal,
 11   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
 11   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
 11   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
 11   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
 11   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
 11   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
 11   307     2 parent_fn char (30),				/* file name for parent info */
 11   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
 11   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
 11   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
 11   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
 11   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
 11   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
 11   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
 11   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
 11   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
 11   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
 11   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
 11   319     2 link_err_path_ptr unal bit (18),
 11   320     2 link_after_path_ptr unal bit (18),
 11   321     2 unlk_before_path_ptr unal bit (18),
 11   322     2 unlk_err_path_ptr unal bit (18),
 11   323     2 unlk_after_path_ptr unal bit (18),
 11   324     2 srch_before_path_ptr unal bit (18),
 11   325     2 srch_err_path_ptr unal bit (18),
 11   326     2 srch_after_path_ptr unal bit (18),
 11   327     2 unused_1 unal bit (18),				/* for future expansion */
 11   328     2 unused_2 unal bit (18) ;
 11   329 dcl  cli_ptr ptr;
 11   330 
 11   331 /* the attr_list structure is associated with the parent_link_info
 11   332*   and child_link_info structures to represent by means of a singly linked list
 11   333*   the participating attributes from relations in a foreign key.
 11   334*   the parent_link_info has a list for the parent relation,
 11   335*   and the child_link_info has a list for the child relation.
 11   336*   the participating attributes are a subset(not necessary proper) of
 11   337*   those attributes contained in a relation definition.
 11   338*   there are equal numbers of attr_list structures in the parent and
 11   339*   child lists of the same foreign key. the corresponding attributes in these
 11   340*   lists must have the same domain. */
 11   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
 11   342     2 attr_fn char (30),				/* file name for attr. */
 11   343     2 attr_ptr unal bit (18),				/* to attr info block */
 11   344     2 fwd_thread unal bit (18);			/* to next in list */
 11   345 dcl  al_ptr ptr;
 11   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
 11   347     2 ascend bit (1) unal,				/* ascending order */
 11   348     2 descend bit (1) unal,				/* descending order */
 11   349     2 reserved bit (34) unal,
 11   350     2 attr_ptr unal bit (18),				/* to attr info */
 11   351     2 fwd_thread unal bit (18);			/* to next in list */
 11   352 dcl  sk_ptr ptr;
 11   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
 11   354     2 attr_ptr unal bit (18),				/* to attr info */
 11   355     2 fwd_thread unal bit (18);			/* to next in list */
 11   356 dcl  dp_ptr ptr;
 11   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
 11   358     2 link_fn char (30),				/* file name for thru link */
 11   359     2 link_ptr unal bit (18),				/* to parent link info */
 11   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
 11   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
 11   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
 11   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
 11   364     2 fwd_thread unal bit (18);			/* to next in chain */
 11   365 dcl  sc_ptr ptr;
 11   366 
 11   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
 11   368 
 11   369 
      934 
 12     1 /* BEGIN - mrds_rmdb_ctl.incl.pl1 */
 12     2 
 12     3 
 12     4 
 12     5 /****^  HISTORY COMMENTS:
 12     6*  1) change(82-03-26,Davids), approve(), audit(), install():
 12     7*     created
 12     8*  2) change(82-05-26,Davids), approve(), audit(), install():
 12     9*     added db_model_ptr
 12    10*  3) change(82-06-09,Harvey), approve(), audit(), install():
 12    11*     deleted ssu_ routines ptr storage
 12    12*  4) change(82-08-20,Davids), approve(), audit(), install():
 12    13*     added the relmgr like reference and included the rmdb_relmgr_entries
 12    14*     include file
 12    15*  5) change(83-05-24,Davids), approve(), audit(), install():
 12    16*     added the saved_res_version_ptr element
 12    17*  6) change(84-10-23,Benjamin), approve(), audit(), install():
 12    18*     added flags (just database_readied_by_rmdb for now).
 12    19*  7) change(85-11-08,Spitzer), approve(85-11-08,MCR7311),
 12    20*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 12    21*     added crossref_file_info.
 12    22*                                                   END HISTORY COMMENTS */
 12    23 
 12    24 
 12    25 dcl 01 rmdb_ctl based (rmdb_ctl_ptr),
 12    26     02 version fixed bin,
 12    27     02 rmdb_version char (16) varying,
 12    28     02 absolute_db_path char (168),
 12    29     02 temp_dir_path char (168),
 12    30     02 work_area_ptr ptr,
 12    31     02 db_model_ptr ptr,
 12    32     02 saved_res_version_ptr ptr,
 12    33     02 crossref_file_info,
 12    34        03 iocb_ptr ptr,
 12    35        03 name char (32),
 12    36     02 relmgr_entries like rmdb_relmgr_entries,
 12    37     02 flags,
 12    38        03 database_readied_by_rmdb bit (1) unal,
 12    39        03 unused bit (35) unal;
 12    40     	
 12    41 dcl  RMDB_CTL_VERSION_1 fixed bin init (1) internal static options (constant);
 12    42 
 12    43 dcl  rmdb_ctl_ptr ptr;
 12    44 
 12    45 
 13     1 /*  START OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 13     2 
 13     3 
 13     4 /****^  HISTORY COMMENTS:
 13     5*  1) change(82-08-20,Davids), approve(), audit(), install():
 13     6*     written
 13     7*  2) change(86-01-28,Spitzer), approve(86-01-28,MCR7311),
 13     8*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
 13     9*     add get_tuples_by_spec, put_tuple, put_tuples, create_cursor entry points.
 13    10*  3) change(86-08-21,Blair), approve(86-08-21,MCR7311),
 13    11*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
 13    12*     Back out the entries get_tuples_by_spec and put_tuples since they aren't
 13    13*     sufficiently well tested to be reliable.  Replace with get_tuple_id and
 13    14*     get_tuple_by_id.
 13    15*                                                   END HISTORY COMMENTS */
 13    16 
 13    17 
 13    18 dcl 01 rmdb_relmgr_entries based (rmdb_relmgr_entries_ptr),
 13    19      02 create_relation entry (char (*), char (*), ptr, ptr, bit (36) aligned,
 13    20 	bit (36) aligned, fixed bin (35)),
 13    21      02 delete_relation entry (char (*), char (*), fixed bin (35)),
 13    22      02 open entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
 13    23      02 close entry (bit (36) aligned, fixed bin (35)),
 13    24      02 create_index entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17),
 13    25 	bit (36) aligned, fixed bin (35)),
 13    26      02 delete_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35)),
 13    27      02 put_tuple entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
 13    28      02 get_tuple_id entry (ptr, ptr, ptr, ptr, fixed bin (35)),
 13    29      02 get_tuple_by_id entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
 13    30      02 create_cursor entry (bit (36) aligned, ptr, ptr, fixed bin (35));
 13    31 
 13    32 dcl rmdb_relmgr_entries_ptr ptr;
 13    33 
 13    34 /*  END OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 12    46 
 12    47 
 12    48 
 12    49 /* END - mrds_rmdb_ctl.incl.pl1 */
      935 
 14     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
 14     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
 14     3 /*	version number changed to 4, 08/10/78 WOS */
 14     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
 14     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
 14     6 
 14     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
 14     8     2 version fixed bin,				/* version of this structure - must be set, see below */
 14     9     2 switches aligned,                                     /* various bit switch values */
 14    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
 14    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
 14    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
 14    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
 14    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
 14    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
 14    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
 14    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
 14    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
 14    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
 14    20 
 14    21 /*  Limit of data defined for version 2 */
 14    22 
 14    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
 14    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
 14    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
 14    26 						/* minimum of 30 seconds required for repeat */
 14    27 						/* otherwise, no repeat will occur */
 14    28 /* Limit of data defined for version 4 */
 14    29 
 14    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
 14    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
 14    32 
 14    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
 14    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
 14    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
 14    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
 14    37 
 14    38 /*	END INCLUDE FILE query_info.incl.pl1 */
      936 
 15     1 /*  START OF:	rmdb_delete_object_info.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 15     2 
 15     3 
 15     4 /****^  HISTORY COMMENTS:
 15     5*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
 15     6*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
 15     7*     Contains the list of domains or attributes to delete. If flags.check is on,
 15     8*     query the user on the switch indicated by check_iocb_ptr.
 15     9*                                                   END HISTORY COMMENTS */
 15    10 
 15    11 dcl delete_object_info_count fixed bin (17);
 15    12 dcl delete_object_info_ptr ptr;
 15    13 dcl delete_object_info_version_1 char (8) int static options (constant) init ("doi 1.0");
 15    14 
 15    15 dcl 1 delete_object_info based (delete_object_info_ptr),
 15    16      2 version char (8),
 15    17      2 check_iocb_ptr ptr,				/* switch to use for check output */
 15    18      2 query_iocb_ptr ptr,				/* switch to use for query input */
 15    19      2 flags aligned,
 15    20       3 all bit (1) unaligned,
 15    21       3 unreferenced bit (1) unaligned,			/* delete only unreferenced object */
 15    22       3 check bit (1) unaligned,			/* display actions to take when deleting, don't actually delete */
 15    23       3 long bit (2) unaligned,			/* if flags.check, do delete operations */
 15    24       3 force bit (1) unaligned,			/* don't query user */
 15    25       3 inhibit_errors bit (1) unaligned,		/* don't display errors if an object isn't found */
 15    26       3 pad bit (29) unaligned,
 15    27      2 request_name char (32),			/* name to use in queries and error messages */
 15    28      2 count fixed bin (17),
 15    29      2 name (delete_object_info_count refer (delete_object_info.count))
 15    30 	  char (32);
 15    31 
 15    32 /*  END OF:	rmdb_delete_object_info.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      937 
 16     1 /*  START OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 16     2 
 16     3 /****^  HISTORY COMMENTS:
 16     4*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
 16     5*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
 16     6*     written.
 16     7*                                                   END HISTORY COMMENTS */
 16     8 
 16     9 /*DESCRIPTION
 16    10*  The following structures are the definition of the records with the keyed
 16    11*  vfile that is built during restructuring. This file serves as a crossreference
 16    12*  of unique attributes and domains used within the specified MRDS database. Each
 16    13*  object is a char (33); the first byte is set to an unprintable character so we
 16    14*  can use the index builtin to find a specific object.
 16    15**/
 16    16 
 16    17 dcl crossref_info_record_ptr ptr;
 16    18 dcl crossref_info_record_count fixed bin (21);
 16    19 dcl 1 crossref_info_record based (crossref_info_record_ptr),
 16    20      2 offset bit (18) unal,
 16    21      2 pad bit (18) unal,
 16    22      2 count fixed bin (21),
 16    23      2 entry (crossref_info_record_count refer (crossref_info_record.count)) unaligned,
 16    24       3 object_head char (1),
 16    25       3 object char (32);
 16    26 
 16    27 dcl crossref_info_record_objects char (33*crossref_info_record.count)
 16    28 			   based (addr (crossref_info_record.entry(1)));
 16    29 dcl OBJECT_HEAD char (1) int static options (constant) init (" ");
 16    30 
 16    31 dcl ATTRIBUTE_KEY_HEAD char (10) int static options (constant) init ("attribute:");
 16    32 dcl DOMAIN_KEY_HEAD char (7) int static options (constant) init ("domain:");
 16    33 dcl RELATION_KEY_HEAD char (9) int static options (constant) init ("relation:");
 16    34 
 16    35 /*DESCRIPTION
 16    36*  The following structures are used to contain sufficient crossreference
 16    37*  information for the delete_attribute and delete_domain requests. These
 16    38*  requests require a more complete view of a crossreference tree, associating
 16    39*  domains, attributes and relations in 2 directions.
 16    40**/
 16    41 
 16    42 dcl domain_list_ptr ptr;
 16    43 dcl domain_list_count fixed bin;
 16    44 dcl domain_list_names char (33*domain_list.count) based (addr (domain_list.name(1)));
 16    45 dcl 1 domain_list based (domain_list_ptr),
 16    46      2 count fixed bin,				/* number of domains in the list */
 16    47      2 name (domain_list_count refer (domain_list.count))
 16    48 	  char (33) unaligned,			/* name of this domain */
 16    49      2 attribute_list_ptr (domain_list_count refer (domain_list.count))
 16    50 		      ptr;			/* -> attribute_list structure */
 16    51 
 16    52 dcl attribute_list_ptr ptr;
 16    53 dcl attribute_list_count fixed bin;
 16    54 dcl attribute_list_names char (33*attribute_list.count) based (addr (attribute_list.name(1)));
 16    55 dcl 1 attribute_list based (attribute_list_ptr),
 16    56      2 count fixed bin,				/* number of attributes in the list */
 16    57      2 name (attribute_list_count refer (attribute_list.count))
 16    58 	  char (33) unaligned,			/* name of this attribute */
 16    59      2 domain_info_ptr (attribute_list_count refer (attribute_list.count))
 16    60 		   bit (18) unal,			/* offset in db_model of the domain_info structure for this attribute */
 16    61      2 attribute_ptr (attribute_list_count refer (attribute_list.count))
 16    62 		 ptr;				/* -> attribute structure */
 16    63 
 16    64 dcl relation_list_ptr ptr;
 16    65 dcl relation_list_count fixed bin;
 16    66 dcl relation_list_names char (33*relation_list.count) based (addr (relation_list.name (1)));
 16    67 dcl 1 relation_list based (relation_list_ptr),
 16    68      2 count fixed bin,				/* number of relations that are to be touched in this operation */
 16    69      2 name (relation_list_count refer (relation_list.count))
 16    70 	  char (33) unaligned,			/* name of this relation */
 16    71      2 relation_ptr (relation_list_count refer (relation_list.count))
 16    72 		ptr;				/* -> relation structure */
 16    73 
 16    74 dcl relation_ptr ptr;
 16    75 dcl relation_attribute_count fixed bin;
 16    76 dcl relation_attribute_names char (33*relation.attribute_count) based (addr (relation.attribute_names (1)));
 16    77 dcl 1 relation based (relation_ptr),
 16    78      2 name char (32),				/* name of the relation */
 16    79      2 file_model_ptr ptr,				/* -> relation.m segment */
 16    80      2 copy_file_model_ptr ptr,
 16    81      2 attribute_count fixed bin,			/* number of attributes defined for this relation */
 16    82      2 mbz fixed bin (35),
 16    83      2 attribute (relation_attribute_count refer (relation.attribute_count)),
 16    84       3 flags aligned,
 16    85         4 delete bit (1) unaligned,			/* ON: delete this attribute */
 16    86         4 new bit (1) unaligned,			/* ON: this attribute is added to the relation */
 16    87         4 part_of_key bit (1) unaligned,                    /* ON: this attribute is part of the primary key */
 16    88         4 to_be_deleted bit (1) unaligned,
 16    89         4 pad bit (32) unaligned,
 16    90       3 domain_info_ptr bit (18) aligned,		/* -> db_model domain_info structure */
 16    91       3 attribute_info_ptr ptr,			/* -> file_model attribute_info structure */
 16    92       3 value_ptr ptr,				/* if flags.new, this -> the value of the column to be stored */
 16    93 						/*   it must be of the correct data type as specified by the domain */
 16    94      2 attribute_names (relation_attribute_count refer (relation.attribute_count))
 16    95 		   char (33) unaligned;
 16    96 
 16    97 dcl attribute_ptr ptr;
 16    98 dcl attribute_count fixed bin;
 16    99 dcl 1 attribute based (attribute_ptr),
 16   100      2 count fixed bin,				/* number of relations this attribute is used in */
 16   101      2 relation_idx (attribute_count refer (attribute.count))
 16   102 		fixed bin;			/* index into list of relation names */
 16   103 
 16   104 /*  END OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      938 
 17     1 /* BEGIN INCLUDE FILE rmdb_history_entry.incl.pl1 -- nsd, 82-04-09 */
 17     2 
 17     3 
 17     4 
 17     5 /****^  HISTORY COMMENTS:
 17     6*  1) change(75-01-01,WhoKnows), approve(), audit(), install():
 17     7*     Written.
 17     8*  2) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
 17     9*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 17    10*     Added RMDB_ADD_(ATTR DMN)_OP, RMDB_RN_(ATTR DMN REL)_OP.
 17    11*                                                   END HISTORY COMMENTS */
 17    12 
 17    13 
 17    14 /*
 17    15*   This include file contains the rmdb_history_entry structure which
 17    16*   is  used for maintaining a history of the databases restructuring
 17    17*   events. It also contains a set of constants used in  loading  the
 17    18*   structure.
 17    19*
 17    20*   The restructuring history is applied against the  database  as  a
 17    21*   whole  instead of against each structure in the db_model and file
 17    22*   models which was the approach originally  implemented  but  never
 17    23*   really  used  (except  to  record the database creation). This is
 17    24*   because 1 database restructuring event, i.e. adding a  new  index
 17    25*   to a relation will change several of the structures in the model.
 17    26*
 17    27*   For a detailed explaination of the use of this structure and  the
 17    28*   constants see the rmdb_add_rmdb_event module.
 17    29**/
 17    30 
 17    31 dcl 01 rmdb_history_entry aligned based (rmdb_history_entry_ptr),
 17    32     02 user_id char (32),				/* person_id.project_id.tag */
 17    33     02 date_time_restructured fixed bin (71),
 17    34     02 type_of_object_restructured fixed bin,		/* taken from constants below */
 17    35     02 object_name char (32),
 17    36     02 operation fixed bin,				/* taken from constants below */
 17    37     02 secondary_object_name char (32),			/* i.e. name of attr just indexed in a restructured relation */
 17    38     02 offset_to_next_entry bit (18) unal,
 17    39     02 offset_to_previous_entry bit (18) unal;
 17    40 	
 17    41 
 17    42 dcl  rmdb_history_entry_ptr ptr;
 17    43 
 17    44 
 17    45 dcl  RMDB_DOMAIN_TYPE init (1) fixed bin internal static options (constant);
 17    46 dcl  RMDB_ATTR_TYPE init (2) fixed bin internal static options (constant);
 17    47 dcl  RMDB_REL_TYPE init (3) fixed bin internal static options (constant);
 17    48 
 17    49 
 17    50 dcl  RMDB_ADD_REL_OP init (1) fixed bin internal static options (constant);
 17    51 dcl  RMDB_DEL_REL_OP init (2) fixed bin internal static options (constant);
 17    52 dcl  RMDB_ADD_IDX_OP init (3) fixed bin internal static options (constant);
 17    53 dcl  RMDB_DEL_IDX_OP init (4) fixed bin internal static options (constant);
 17    54 dcl  RMDB_ADD_ATTR_OP init (5) fixed bin int static options (constant);
 17    55 dcl  RMDB_DEL_ATTR_OP init (6) fixed bin int static options (constant);
 17    56 dcl  RMDB_ADD_DMN_OP init (7) fixed bin int static options (constant);
 17    57 dcl  RMDB_DEL_DMN_OP init (8) fixed bin int static options (constant);
 17    58 dcl  RMDB_RN_ATTR_OP init (9) fixed bin int static options (constant);
 17    59 dcl  RMDB_RN_DMN_OP init (10) fixed bin int static options (constant);
 17    60 dcl  RMDB_RN_REL_OP init (11) fixed bin int static options (constant);
 17    61 
 17    62 /* END INCLUDE FILE rmdb_history_entry.incl.pl1 */
      939 
 18     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
 18     2 
 18     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
 18     4 
 18     5 /* This include file contains branch and link structures returned by
 18     6*   hcs_$status_ and hcs_$status_long. */
 18     7 
 18     8 dcl 1 status_branch aligned based (status_ptr),
 18     9     2 short aligned,
 18    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
 18    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
 18    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
 18    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
 18    14       3 dtu bit (36) unaligned,			/* date/time last used */
 18    15       3 mode bit (5) unaligned,			/* caller's effective access */
 18    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
 18    17       3 pad1 bit (8) unaligned,
 18    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
 18    19 
 18    20 /* Limit of information returned by hcs_$status_ */
 18    21 
 18    22     2 long aligned,
 18    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
 18    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
 18    25       3 lvid bit (36) unaligned,			/* logical volume ID */
 18    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
 18    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
 18    28       3 pad2 bit (8) unaligned,
 18    29       3 copy_switch bit (1) unaligned,			/* copy switch */
 18    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
 18    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
 18    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
 18    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
 18    34       3 pad3 bit (5) unaligned,
 18    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
 18    36       3 uid bit (36) unaligned;			/* unique ID */
 18    37 
 18    38 dcl 1 status_link aligned based (status_ptr),
 18    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
 18    40     2 nnames fixed bin (16) unaligned unsigned,
 18    41     2 names_relp bit (18) unaligned,
 18    42     2 dtem bit (36) unaligned,
 18    43     2 dtd bit (36) unaligned,
 18    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
 18    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
 18    46 
 18    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
 18    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
 18    49 						/* array of names returned */
 18    50      status_pathname character (status_link.pathname_length) aligned
 18    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
 18    52 						/* link target path */
 18    53      status_area_ptr pointer,
 18    54      status_ptr pointer;
 18    55 
 18    56 dcl (Link initial (0),
 18    57      Segment initial (1),
 18    58      Directory initial (2)) fixed bin internal static options (constant);
 18    59 						/* values for type fields declared above */
 18    60 
 18    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
      940 
      941 
      942 dcl  addr builtin;
      943 dcl  1 ai like area_info aligned;
      944 dcl  answer char (3);
      945 dcl  any_other condition;
      946 dcl  attribute_idx fixed bin;
      947 dcl  attribute_list_idx fixed bin;
      948 dcl  attribute_name char (32);
      949 dcl  based_char8 char (8) based;
      950 dcl  cleanup condition;
      951 dcl  code fixed bin (35);
      952 dcl  command_query_ entry () options (variable);
      953 dcl  db_path char (168);
      954 dcl  define_area_ entry (ptr, fixed bin (35));
      955 dcl  delete_$path entry (char(*), char(*), bit(36) aligned, char(*), fixed bin(35));
      956 dcl  divide builtin;
      957 dcl  domain_list_idx fixed bin;
      958 dcl  domain_name char (32);
      959 dcl  dm_error_$key_duplication fixed bin (35) ext static;
      960 dcl  error_message char (500);
      961 dcl  error_table_$action_not_performed fixed bin (35) ext static;
      962 dcl  error_table_$no_record fixed bin (35) ext static;
      963 dcl  error_table_$unimplemented_version fixed bin (35) ext static;
      964 dcl  fixed builtin;
      965 dcl  fs_util_$copy entry (ptr, fixed bin(35));
      966 dcl  fs_util_$get_switch entry (char(*), char(*), char(*), bit(1) aligned, fixed bin(35));
      967 dcl  fs_util_$list_acl entry (char(*), char(*), char(*), ptr, ptr, fixed bin(35));
      968 dcl  fs_util_$replace_acl entry (char(*), char(*), ptr, bit(1), fixed bin(35));
      969 dcl  fs_util_$set_switch entry (char(*), char(*), char(*), bit(1) aligned, fixed bin(35));
      970 dcl  hcs_$chname_file entry (char(*), char(*), char(*), char(*), fixed bin(35));
      971 dcl  hcs_$status_ entry (char(*), char(*), fixed bin(1), ptr, ptr, fixed bin(35));
      972 dcl  Idelete_object_info_ptr ptr parameter;
      973 dcl  index builtin;
      974 dcl  initiate_file_ entry (char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35));
      975 dcl  ioa_$ioa_switch entry () options (variable);
      976 dcl  ioa_$ioa_switch_nnl entry () options (variable);
      977 dcl  Irmdb_ctl_ptr ptr parameter;
      978 dcl  last_unreferenced_attribute_ptr ptr;
      979 dcl  length builtin;
      980 dcl  local_iocb ptr;
      981 dcl  make_consistent_msg char (500);
      982 dcl  mdbm_util_$free_temp_segment entry (char (*), ptr, fixed bin (35));
      983 dcl  mdbm_util_$get_temp_segment_path entry (char (*), char (*), ptr, fixed bin (35));
      984 dcl  mdbm_util_$inconsistent_reset entry (ptr);
      985 dcl  mdbm_util_$inconsistent_set entry (ptr, char (*), char (*), char (*));
      986 dcl  mdbm_util_$xref_build entry (char (*), char (*), ptr, char (*), ptr, char (*), fixed bin (35));
      987 dcl  mdbm_util_$xref_delete_record entry (ptr, char (*), char (*), char (*), fixed bin (35));
      988 dcl  mdbm_util_$xref_dereference entry (ptr, char (*), char (*), char (*), fixed bin (21), char (*), fixed bin (35));
      989 dcl  mdbm_util_$xref_destroy entry (ptr, char (*), char (*), char (*), fixed bin (35));
      990 dcl  mrds_error_$no_primary_key fixed bin (35) ext static;
      991 dcl  mrds_error_$no_unref_domain fixed bin (35) ext static;
      992 dcl  myname char (32) int static options (constant) init ("rmdb_delete_domain");
      993 dcl  null builtin;
      994 dcl  NULL_OFFSET bit (18) unaligned int static options (constant) init ((18)"1"b);
      995 dcl  Ocode fixed bin (35) parameter;
      996 dcl  Oerror_message char (*) parameter;
      997 dcl  previous_ptr ptr;
      998 dcl  (ptr, pointer) builtin;
      999 dcl  QUERY_MSG char (110) int static options (constant)
     1000 	init ("Answering yes will cause the specified domain to be deleted from the currently
     1001 readied MRDS database.");
     1002 dcl  quit condition;
     1003 dcl  quit_occurred bit (1) aligned;
     1004 dcl  reference_count fixed bin (21);
     1005 dcl  rel builtin;
     1006 dcl  relation_good_count fixed bin (21);
     1007 dcl  relation_index fixed bin;
     1008 dcl  relation_name char (32);
     1009 dcl  release_area_ entry (ptr);
     1010 dcl  rmdb_add_rmdb_history entry (ptr, fixed bin, char (32), fixed bin, char (32), char (500), fixed bin (35));
     1011 dcl  rmdb_copy_relation entry (ptr, char (*), char (*), ptr, ptr, char (*), fixed bin (35));
     1012 dcl  rmdb_delete_all$domains entry (ptr, char (*), fixed bin (35));
     1013 dcl  rmdb_relations_used$domains entry (ptr, ptr, ptr, ptr, ptr, ptr, char (*), fixed bin (35));
     1014 dcl  rtrim builtin;
     1015 dcl  save_code fixed bin (35);
     1016 dcl  save_ptr ptr;
     1017 dcl  substr builtin;
     1018 dcl  sys_info$max_seg_size fixed bin (35) ext static;
     1019 dcl  unspec builtin;
     1020 dcl  UNSPEC bit (2) aligned int static options (constant) init ("00"b);
     1021 dcl  user_area area based (user_area_ptr);
     1022 dcl  user_area_ptr ptr;
     1023 
     1024      end rmdb_delete_domain;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/07/87  1320.5  rmdb_delete_domain.pl1            >spec>install>MR12.2-1008>rmdb_delete_domain.pl1
172          1    02/05/86  1416.4  mrds_start_transaction.incl.pl1   >ldd>include>mrds_start_transaction.incl.pl1
1-79         2    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
1-81         3    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
180          4    02/05/86  1416.4  mrds_finish_transaction.incl.pl1  >ldd>include>mrds_finish_transaction.incl.pl1
928          5    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
929          6    10/14/83  1606.6  acl_structures.incl.pl1           >ldd>include>acl_structures.incl.pl1
930          7    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
931          8    10/14/83  1606.7  copy_flags.incl.pl1               >ldd>include>copy_flags.incl.pl1
932          9    10/14/83  1606.7  copy_options.incl.pl1             >ldd>include>copy_options.incl.pl1
933         10    10/17/86  1404.3  mdbm_db_model.incl.pl1            >ldd>include>mdbm_db_model.incl.pl1
934         11    10/17/86  1404.5  mdbm_file_model.incl.pl1          >ldd>include>mdbm_file_model.incl.pl1
935         12    10/17/86  1404.4  mrds_rmdb_ctl.incl.pl1            >ldd>include>mrds_rmdb_ctl.incl.pl1
12-46       13    10/17/86  1404.6  rmdb_relmgr_entries.incl.pl1      >ldd>include>rmdb_relmgr_entries.incl.pl1
936         14    03/11/83  1204.3  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
937         15    10/17/86  1404.6  rmdb_delete_object_info.incl.pl1  >ldd>include>rmdb_delete_object_info.incl.pl1
938         16    10/17/86  1404.6  rmdb_crossref_info.incl.pl1       >ldd>include>rmdb_crossref_info.incl.pl1
939         17    10/17/86  1404.4  rmdb_history_entry.incl.pl1       >ldd>include>rmdb_history_entry.incl.pl1
940         18    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTRIBUTE_KEY_HEAD              000052 constant        char(10)                 initial unaligned dcl 16-31 set ref 770* 828* 838*
COPY_OPTIONS_VERSION_1          000060 constant        char(8)                  initial unaligned dcl 9-28 ref 714
DOMAIN_KEY_HEAD                 000050 constant        char(7)                  initial unaligned dcl 16-32 set ref 819*
GENERAL_ACL_VERSION_1           000062 constant        char(8)                  initial unaligned dcl 6-72 set ref 690*
Idelete_object_info_ptr                parameter       pointer                  dcl 972 ref 40 44
Irmdb_ctl_ptr                          parameter       pointer                  dcl 977 ref 40 43
NULL_OFFSET                            constant        bit(18)                  initial unaligned dcl 994 ref 440 589 781 792 793
                                                                                  874 901
OBJECT_HEAD                     010276 constant        char(1)                  initial unaligned dcl 16-29 ref 464
Ocode                                  parameter       fixed bin(35,0)          dcl 995 set ref 40 219*
Oerror_message                         parameter       char                     unaligned dcl 996 set ref 40 220* 222*
QUERY_MSG                       000000 constant        char(110)                initial unaligned dcl 999 set ref 109 110
RELATION_KEY_HEAD               000044 constant        char(9)                  initial unaligned dcl 16-33 set ref 604*
RMDB_ATTR_TYPE                  000135 constant        fixed bin(17,0)          initial dcl 17-46 set ref 892*
RMDB_DEL_ATTR_OP                000133 constant        fixed bin(17,0)          initial dcl 17-55 set ref 892*
RMDB_DEL_DMN_OP                 000134 constant        fixed bin(17,0)          initial dcl 17-57 set ref 917*
RMDB_DEL_REL_OP                 000135 constant        fixed bin(17,0)          initial dcl 17-51 set ref 614*
RMDB_DOMAIN_TYPE                000142 constant        fixed bin(17,0)          initial dcl 17-45 set ref 917*
RMDB_REL_TYPE                   000136 constant        fixed bin(17,0)          initial dcl 17-47 set ref 614*
RW_ACCESS                       000064 constant        bit(3)                   initial unaligned dcl 5-11 set ref 676*
TM_NORMAL_MODE                  000142 constant        fixed bin(17,0)          initial dcl 2-15 set ref 1-99*
UNSPEC                                 constant        bit(2)                   initial dcl 1020 ref 115 343
absolute_db_path          6            based           char(168)                level 2 packed unaligned dcl 12-25 ref 52
addr                                                   builtin function         dcl 942 ref 88 88 109 1-123 1-123 362 362 409 557
                                                                                  557 671 679 723 723
ai                              000222 automatic       structure                level 1 dcl 943 set ref 79* 88 88
all                       6            based           bit(1)                   level 3 packed unaligned dcl 15-15 ref 68
answer                          000246 automatic       char(3)                  unaligned dcl 944 set ref 362* 364
answer_iocbp              6     000162 automatic       pointer                  initial level 2 dcl 14-7 set ref 108* 14-7*
any_other                       000250 stack reference condition                dcl 945 ref 171
area_control                           based           structure                level 1 dcl 7-20
area_info                              based           structure                level 1 dcl 7-7
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 7-3 ref 80
areap                    16     000222 automatic       pointer                  level 2 dcl 943 set ref 86*
attr_idx                        001064 automatic       fixed bin(17,0)          dcl 501 set ref 512* 513*
attribute                16            based           structure                array level 2 in structure "relation" unaligned
                                                                                  dcl 16-77 in procedure "rmdb_delete_domain"
attribute                              based           structure                level 1 unaligned dcl 16-99 in procedure
                                                                                  "rmdb_delete_domain"
attribute_count          14            based           fixed bin(17,0)          level 2 dcl 16-77 ref 409 409 514 515 528 533 575
                                                                                  766 769
attribute_idx                   001306 automatic       fixed bin(17,0)          dcl 573 in procedure "all_attributes_are_deleted"
                                                                                  set ref 575* 576*
attribute_idx                   000256 automatic       fixed bin(17,0)          dcl 946 in procedure "rmdb_delete_domain" set ref
                                                                                  308* 310* 407* 408* 514* 515 515 519* 528* 529 529
                                                                                  533 534*
attribute_list                         based           structure                level 1 unaligned dcl 16-55
attribute_list_idx              000257 automatic       fixed bin(17,0)          dcl 947 set ref 288* 289 290 291 295* 306* 307* 402*
                                                                                  403 406* 510* 511 515* 835* 837* 868* 870 873*
attribute_list_ptr                     based           pointer                  array level 2 in structure "domain_list" dcl 16-45
                                                                                  in procedure "rmdb_delete_domain" set ref 280 401
                                                                                  449* 508 834 867
attribute_list_ptr              000206 automatic       pointer                  dcl 16-52 in procedure "rmdb_delete_domain" set ref
                                                                                  92* 96* 280* 284 288 289 290 291 295 306 307 319
                                                                                  329 401* 402 403 406 508* 510 511 515 834* 835 835
                                                                                  837 867* 868 868 870 873
attribute_name                  000260 automatic       char(32)                 unaligned dcl 948 set ref 290* 291* 295* 533* 535
                                                                                  769* 770* 777 790 837* 838* 873* 877 892*
attribute_names                        based           char(33)                 array level 2 packed unaligned dcl 16-77 set ref 409
                                                                                  515 533* 769*
attribute_ptr                          based           pointer                  array level 2 in structure "attribute_list"
                                                                                  dcl 16-55 in procedure "rmdb_delete_domain" ref
                                                                                  289 307 403 511
attribute_ptr                   000214 automatic       pointer                  dcl 16-97 in procedure "rmdb_delete_domain" set ref
                                                                                  289* 298 307* 308 308 310 403* 404 407 408 511*
                                                                                  512 512 513
based_char8                            based           char(8)                  unaligned dcl 949 set ref 133*
caller_name               2     001366 automatic       char(32)                 level 2 packed unaligned dcl 664 set ref 715*
cancel_domain                   000100 automatic       bit                      unaligned dcl 268 set ref 275* 347* 397
check                     6(02)        based           bit(1)                   level 3 packed unaligned dcl 15-15 ref 115 282 343
check_iocb_ptr            2            based           pointer                  level 2 dcl 15-15 set ref 107 284* 291* 295* 319*
                                                                                  329* 335* 339*
cleanup                         000270 stack reference condition                dcl 950 ref 64 166
co                              001366 automatic       structure                level 1 dcl 664 set ref 723 723
code                            000276 automatic       fixed bin(35,0)          dcl 951 in procedure "rmdb_delete_domain" set ref
                                                                                  55* 57 57* 68* 75* 76 76* 88* 89 89* 96* 98 98*
                                                                                  117* 118* 142 144 203* 206* 241* 242 540* 541*
                                                                                  557* 559 561 563 565* 625* 626 626* 629 629* 672*
                                                                                  676* 677 677* 690* 691 691* 694* 695 695* 706* 707
                                                                                  707* 723* 724 724* 728* 729 729* 750 750* 770* 772
                                                                                  819* 820 820 820* 828* 829 829 829* 838* 839 839
                                                                                  839*
code                                   parameter       fixed bin(35,0)          dcl 216 in procedure "error" ref 213 219 220
command_query_                  000040 constant        entry                    external dcl 952 ref 362
condition_info                         based           structure                level 1 dcl 3-14
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 1-77 set ref 1-124 1-129 1-129
continue_to_signal_             000010 constant        entry                    external dcl 1-61 ref 1-137
control                   1     000222 automatic       structure                level 2 dcl 943
copy_file_model_ptr      12            based           pointer                  level 2 dcl 16-77 ref 739 741 746 747
copy_flags                             based           structure                level 1 dcl 8-8
copy_items              157     001366 automatic       structure                level 2 dcl 664 set ref 721*
copy_options                           based           structure                level 1 dcl 9-12
count                                  based           fixed bin(17,0)          level 2 in structure "relation_list" dcl 16-67
                                                                                  in procedure "rmdb_delete_domain" ref 138 139 161
                                                                                  271 384 385 408 513 525 527
count                                  based           fixed bin(17,0)          level 2 in structure "domain_list" dcl 16-45
                                                                                  in procedure "rmdb_delete_domain" set ref 268 278
                                                                                  280 396 401 436* 437* 445* 445 446 449 449 451 507
                                                                                  508 815 834 856 867
count                                  based           fixed bin(17,0)          level 2 in structure "attribute_list" dcl 16-55
                                                                                  in procedure "rmdb_delete_domain" ref 288 289 289
                                                                                  291 295 306 307 307 319 329 402 403 403 510 511
                                                                                  511 835 868
count                                  based           fixed bin(17,0)          level 2 in structure "attribute" dcl 16-99
                                                                                  in procedure "rmdb_delete_domain" ref 308 407 512
cp_escape_control         1(02) 000162 automatic       bit(2)                   initial level 3 packed unaligned dcl 14-7 set ref
                                                                                  14-7*
create_model_name               001336 automatic       char(32)                 unaligned dcl 655 set ref 669* 672* 676* 737*
create_relation_name            001346 automatic       char(32)                 unaligned dcl 656 set ref 675* 694* 695 702* 703*
                                                                                  717 728* 728* 729 735*
crossref_file_info      140            based           structure                level 2 unaligned dcl 12-25
cvds                            001546 automatic       bit(1)                   dcl 665 set ref 698* 699* 702*
data_acl_ptr                    001356 automatic       pointer                  dcl 657 set ref 689* 690* 694*
db_model                               based           structure                level 1 dcl 10-72
db_model_ptr            134            based           pointer                  level 2 dcl 12-25 set ref 55* 66
db_path                         000277 automatic       char(168)                unaligned dcl 953 set ref 52* 55* 557* 625* 626*
                                                                                  672* 676* 690* 694* 699* 700* 702* 703* 706* 716
                                                                                  728* 735* 737*
db_type_flags             0(18)        based           structure                level 2 packed unaligned dcl 10-72
dbm_area                 34            based           area                     level 2 dcl 10-72 ref 602 747 789 890 914
dbm_ptr                         000144 automatic       pointer                  dcl 10-106 set ref 66* 127* 195* 435 440 440 448 482
                                                                                  557* 561* 589 589 594 598 602 611 611 612 612 614*
                                                                                  741 741 744 747 776 781 781 786 789 796 874 874
                                                                                  880 884 890 892* 901 901 906 910 914 915 915 917*
define_area_                    000042 constant        entry                    external dcl 954 ref 88
delete                   16            based           bit(1)                   array level 4 packed unaligned dcl 16-77 set ref
                                                                                  386* 413* 576 767
delete_$path                    000044 constant        entry                    external dcl 955 in procedure "rmdb_delete_domain"
                                                                                  ref 737
delete_$path                    000142 constant        entry                    external dcl 620 in procedure "delete_file" ref 626
delete_acl_entry                       based           structure                level 1 dcl 6-63
delete_object_info                     based           structure                level 1 unaligned dcl 15-15
delete_object_info_ptr          000200 automatic       pointer                  dcl 15-12 set ref 44* 48 48 68 93 96* 101 107 108
                                                                                  115 115 131 282 284 291 295 319 329 335 339 343
                                                                                  343 344 362 451 563 629 750 772
delete_object_info_version_1    000056 constant        char(8)                  initial unaligned dcl 15-13 ref 48
delete_relation           4            based           entry variable           level 2 dcl 13-18 ref 706 735
deletion_attributes             001065 automatic       char(500)                unaligned dcl 502 set ref 505* 535* 535
di_ptr                          000150 automatic       pointer                  dcl 10-155 set ref 440* 440* 443 446* 448 776* 777
                                                                                  901* 901* 903 903 905* 906
directory_acl_entry                    based           structure                level 1 dcl 6-54
divide                                                 builtin function         dcl 956 ref 412 684
dm_error_$bj_journal_full       000030 external static fixed bin(35,0)          dcl 4-52 ref 1-132
dm_error_$key_duplication       000046 external static fixed bin(35,0)          dcl 959 ref 563
dm_error_$lock_deadlock         000032 external static fixed bin(35,0)          dcl 4-53 ref 4-78 1-126
dm_error_$no_current_transaction
                                000012 external static fixed bin(35,0)          dcl 1-62 ref 1-90
domain_info                            based           structure                level 1 dcl 10-125 set ref 914
domain_info_ptr          17            based           bit(18)                  array level 3 dcl 16-77 ref 776 791
domain_list                            based           structure                level 1 unaligned dcl 16-45 set ref 436
domain_list_count               000204 automatic       fixed bin(17,0)          dcl 16-43 set ref 435* 436 436 436
domain_list_idx                 000351 automatic       fixed bin(17,0)          dcl 957 set ref 278* 280 281 347 348* 389* 390* 396*
                                                                                  397 397 401* 507* 508 509* 815* 816 818 834* 856*
                                                                                  857 859 867 870*
domain_list_ptr                 000202 automatic       pointer                  dcl 16-42 set ref 92* 96* 268 278 280 281 390 396
                                                                                  397 401 436* 437 445 445 446 446 449 451 507 508
                                                                                  509 815 816 818 834 856 857 859 867 870
domain_name                     000352 automatic       char(32)                 unaligned dcl 958 set ref 281* 284* 291* 362 362
                                                                                  509* 541 818* 819* 828* 859* 903 917*
domain_ptr               10            based           bit(18)                  level 2 in structure "unreferenced_attribute" packed
                                                                                  unaligned dcl 10-159 in procedure
                                                                                  "rmdb_delete_domain" set ref 791*
domain_ptr               22(18)        based           bit(18)                  level 2 in structure "db_model" packed unaligned
                                                                                  dcl 10-72 in procedure "rmdb_delete_domain" set
                                                                                  ref 440 901 910*
dont_free                 1(03) 000222 automatic       bit(1)                   level 3 packed unaligned dcl 943 set ref 82*
error_message                   000362 automatic       char(500)                unaligned dcl 960 set ref 55* 57* 68* 96* 98* 118*
                                                                                  191* 206* 557* 565* 604* 750* 770* 819* 820* 828*
                                                                                  829* 838* 839*
error_table_$action_not_performed
                                000050 external static fixed bin(35,0)          dcl 961 set ref 489*
error_table_$no_record          000052 external static fixed bin(35,0)          dcl 962 ref 820 829 839
error_table_$unimplemented_version
                                000054 external static fixed bin(35,0)          dcl 963 set ref 48*
error_table_$unsupported_operation
                                000144 external static fixed bin(35,0)          dcl 621 ref 626
explanation_len          14     000162 automatic       fixed bin(21,0)          initial level 2 dcl 14-7 set ref 110* 14-7*
explanation_ptr          12     000162 automatic       pointer                  initial level 2 dcl 14-7 set ref 109* 14-7*
extend                    1     000222 automatic       bit(1)                   level 3 packed unaligned dcl 943 set ref 81*
fi_ptr                          000146 automatic       pointer                  dcl 10-119 set ref 589* 589* 591 591 593* 594 741*
                                                                                  741* 743* 744
file_info                              based           structure                level 1 dcl 10-113 set ref 602 747
file_model                             based           structure                level 1 dcl 11-40
file_model_copy_good      0(02)        based           bit(1)                   level 2 packed unaligned dcl 11-40 ref 682
file_model_ptr           10            based           pointer                  level 2 dcl 16-77 ref 162
file_name                              based           char(30)                 level 2 in structure "file_info" dcl 10-113
                                                                                  in procedure "rmdb_delete_domain" ref 591
file_name                              parameter       char                     unaligned dcl 622 in procedure "delete_file" set ref
                                                                                  617 625* 626* 629
file_ptr                 22            based           bit(18)                  level 2 packed unaligned dcl 10-72 set ref 589 598*
                                                                                  741
find_condition_info_            000014 constant        entry                    external dcl 1-64 ref 1-123
first_cancel_domain             000100 automatic       fixed bin(17,0)          dcl 269 set ref 276* 348 348* 354 389 396
flags                    16            based           structure                array level 3 in structure "relation" dcl 16-77
                                                                                  in procedure "rmdb_delete_domain"
flags                     6            based           structure                level 2 in structure "delete_object_info" dcl 15-15
                                                                                  in procedure "rmdb_delete_domain"
flags                   156     001366 automatic       structure                level 2 in structure "co" dcl 664 in procedure
                                                                                  "switch_names" set ref 720*
fm_ptr                          000154 automatic       pointer                  dcl 11-108 set ref 162* 682 682 685
force                     6(05)        based           bit(1)                   level 3 packed unaligned dcl 15-15 ref 101 344
fs_util_$copy                   000056 constant        entry                    external dcl 965 ref 723
fs_util_$delentry_file          000146 constant        entry                    external dcl 623 ref 625
fs_util_$get_switch             000060 constant        entry                    external dcl 966 ref 699 700
fs_util_$list_acl               000062 constant        entry                    external dcl 967 ref 690
fs_util_$replace_acl            000064 constant        entry                    external dcl 968 ref 694
fs_util_$set_switch             000066 constant        entry                    external dcl 969 ref 702 703
fwd_ptr                  11            based           bit(18)                  level 2 packed unaligned dcl 10-113 set ref 594 598
                                                                                  600* 600 744 746* 746
fwd_thread               14(18)        based           bit(18)                  level 2 in structure "domain_info" packed unaligned
                                                                                  dcl 10-125 in procedure "rmdb_delete_domain" set
                                                                                  ref 448 906 910 912* 912
fwd_thread               10(18)        based           bit(18)                  level 2 in structure "unreferenced_attribute" packed
                                                                                  unaligned dcl 10-159 in procedure
                                                                                  "rmdb_delete_domain" set ref 786 792* 798* 880 884
                                                                                  887* 887
general_acl_entry                      based           structure                level 1 unaligned dcl 6-12
general_delete_acl_entry               based           structure                level 1 dcl 6-35
general_extended_acl_entry             based           structure                level 1 dcl 6-23
have_domains_to_process         000154 automatic       bit(1)                   dcl 379 set ref 395* 400* 421
hcs_$chname_file                000070 constant        entry                    external dcl 970 ref 728
hcs_$status_                    000072 constant        entry                    external dcl 971 ref 672
index                                                  builtin function         dcl 658 in procedure "switch_names" ref 673
index                                                  builtin function         dcl 973 in procedure "rmdb_delete_domain" ref 409
index                           001560 automatic       fixed bin(17,0)          dcl 761 in procedure "modify_xref" set ref 766* 767
                                                                                  769 776 791*
inhibit_errors            6(06)        based           bit(1)                   level 3 packed unaligned dcl 15-15 ref 451 563 629
                                                                                  750 772
initiate_file_                  000074 constant        entry                    external dcl 974 ref 676
input_name                             parameter       char                     unaligned dcl 470 in procedure "unmake_name" ref 467
                                                                                  472
input_name                             parameter       char                     unaligned dcl 462 in procedure "make_name" ref 459
                                                                                  464
ioa_$ioa_switch                 000076 constant        entry                    external dcl 975 ref 284
ioa_$ioa_switch_nnl             000100 constant        entry                    external dcl 976 ref 291 295 319 329 335 339
iocb_ptr                140            based           pointer                  level 3 dcl 12-25 set ref 53 55* 61 189*
ivds                            001547 automatic       bit(1)                   dcl 666 set ref 698* 700* 703*
last_file_info_ptr              001364 automatic       pointer                  dcl 663 set ref 743* 746
last_unreferenced_attribute_ptr 000560 automatic       pointer                  dcl 978 set ref 46* 135* 781 785* 796 798 800*
length                                                 builtin function         dcl 979 ref 110
literal_sw                1(05) 000162 automatic       bit(1)                   initial level 3 packed unaligned dcl 14-7 set ref
                                                                                  14-7*
local_iocb                      000562 automatic       pointer                  dcl 980 set ref 61* 604* 770* 819* 828* 838*
local_status_branch             001324 automatic       structure                level 1 unaligned dcl 654 set ref 671
long                      6(03)        based           bit(2)                   level 3 packed unaligned dcl 15-15 ref 115 343
make_consistent_msg             000564 automatic       char(500)                unaligned dcl 981 set ref 125* 127 127
mdbm_util_$free_temp_segment    000102 constant        entry                    external dcl 982 ref 236
mdbm_util_$get_temp_segment_path
                                000104 constant        entry                    external dcl 983 ref 75
mdbm_util_$inconsistent_reset   000106 constant        entry                    external dcl 984 ref 195 561
mdbm_util_$inconsistent_set     000110 constant        entry                    external dcl 985 ref 127
mdbm_util_$xref_build           000112 constant        entry                    external dcl 986 ref 55
mdbm_util_$xref_delete_record   000114 constant        entry                    external dcl 987 ref 604 819 828 838
mdbm_util_$xref_dereference     000116 constant        entry                    external dcl 988 ref 770
mdbm_util_$xref_destroy         000120 constant        entry                    external dcl 989 ref 189
mftxn_code                      000142 automatic       fixed bin(35,0)          dcl 4-54 set ref 179* 4-62* 4-65 4-68* 4-69 4-78
                                                                                  1-126* 1-132*
mftxn_temp_code                 000143 automatic       fixed bin(35,0)          dcl 4-55 set ref 4-71* 4-72 4-72* 4-82* 4-83 4-85*
                                                                                  4-86 4-86* 4-96* 4-97 4-99* 4-100 4-100* 4-109*
                                                                                  4-110 4-110*
move_string                            based           char                     unaligned dcl 659 set ref 685* 685
move_string_length              001360 automatic       fixed bin(35,0)          dcl 660 set ref 684* 685 685
mrds_error_$no_primary_key      000122 external static fixed bin(35,0)          dcl 990 ref 540 561
mrds_error_$no_unref_domain     000124 external static fixed bin(35,0)          dcl 991 set ref 454*
msg                                    parameter       char                     unaligned dcl 217 ref 213 222
mstxn_code                      000100 automatic       fixed bin(35,0)          dcl 1-65 set ref 1-83* 1-89* 1-90 1-99* 1-140 1-140*
                                                                                  4-90* 4-104* 1-137* 485* 486
mstxn_condition_info            000110 automatic       structure                level 1 unaligned dcl 1-77 set ref 1-123 1-123
mstxn_retries                   000101 automatic       fixed bin(17,0)          dcl 1-66 set ref 1-88* 4-78 4-81* 4-81
mstxn_temp_code                 000102 automatic       fixed bin(35,0)          dcl 1-67 set ref 1-109* 1-110 1-110* 1-123*
mstxn_transactions_needed       000103 automatic       bit(1)                   dcl 1-68 set ref 164 1-86 177 484* 493* 712
mstxn_txn_id                    000105 automatic       bit(36)                  dcl 1-70 set ref 63* 1-84* 1-89* 1-93 1-94* 1-99*
                                                                                  1-100 4-60 4-68* 4-71* 4-72* 4-82* 4-85* 4-86*
                                                                                  4-96* 4-99* 4-100* 4-109* 4-110* 4-114* 1-107
                                                                                  1-109* 1-110* 1-121 239 241* 242* 485* 488*
myname                          000034 constant        char(32)                 initial unaligned dcl 992 set ref 75* 84 236* 626*
                                                                                  715 737*
name                                   based           char(32)                 level 2 in structure "relation" packed unaligned
                                                                                  dcl 16-77 in procedure "rmdb_delete_domain" set
                                                                                  ref 541 591 604* 608* 609 614* 669 677 690* 691
                                                                                  699* 700* 706* 707 718 724 728* 729 770*
name                    142            based           char(32)                 level 3 in structure "rmdb_ctl" packed unaligned
                                                                                  dcl 12-25 in procedure "rmdb_delete_domain" set
                                                                                  ref 55* 189*
name                      1            based           char(33)                 array level 2 in structure "domain_list" packed
                                                                                  unaligned dcl 16-45 in procedure
                                                                                  "rmdb_delete_domain" set ref 281* 390* 397* 446*
                                                                                  509* 816 818* 857 859* 870
name                      1            based           char(33)                 array level 2 in structure "relation_list" packed
                                                                                  unaligned dcl 16-67 in procedure
                                                                                  "rmdb_delete_domain" set ref 314*
name                                   based           char(32)                 level 2 in structure "domain_info" dcl 10-125
                                                                                  in procedure "rmdb_delete_domain" ref 446 777 903
name                                   based           char(32)                 level 2 in structure "unreferenced_attribute"
                                                                                  dcl 10-159 in procedure "rmdb_delete_domain" set
                                                                                  ref 790* 877
name                      1            based           char(33)                 array level 2 in structure "attribute_list" packed
                                                                                  unaligned dcl 16-55 in procedure
                                                                                  "rmdb_delete_domain" set ref 290* 406 515 837* 870
                                                                                  873*
names_relp                0(18)        based           bit(18)                  level 3 packed unaligned dcl 18-8 ref 673 675
new_file_model_ptr              001362 automatic       pointer                  dcl 662 set ref 676* 685
new_model_bit_count             001361 automatic       fixed bin(24,0)          dcl 661 set ref 676* 684
no_freeing                1(04) 000222 automatic       bit(1)                   level 3 packed unaligned dcl 943 set ref 83*
no_primary_key                  001262 automatic       bit(1)                   dcl 503 set ref 506* 518* 525 525 528 529* 538
null                                                   builtin function         dcl 993 ref 46 53 92 135 14-7 14-7 14-7 1-123 1-123
                                                                                  233 284 298 308 404 449 512 588 589 596 598 689
                                                                                  739 781 796 835 868 872 874 882 884 900 901 908
                                                                                  910
num_blk_files            13            based           fixed bin(17,0)          level 2 packed unaligned dcl 10-72 set ref 611* 611
num_domains              14(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 10-72 set ref 435 915*
                                                                                  915
num_rels                 14            based           fixed bin(17,0)          level 2 packed unaligned dcl 10-72 set ref 612* 612
owner                     2     000222 automatic       char(32)                 level 2 packed unaligned dcl 943 set ref 84*
padding                   1(07) 000162 automatic       bit(29)                  initial level 3 packed unaligned dcl 14-7 set ref
                                                                                  14-7*
part_of_key              16(02)        based           bit(1)                   array level 4 packed unaligned dcl 16-77 ref 515 529
pointer                                                builtin function         dcl 998 ref 673 675
position                        000155 automatic       fixed bin(17,0)          dcl 380 set ref 409* 410 412* 412 413
previous_ptr                    000762 automatic       pointer                  dcl 997 set ref 588* 593* 598 600 872* 879* 884 887
                                                                                  900* 905* 910 912
printed_names                   000101 automatic       char(32)                 array unaligned dcl 270 set ref 316* 319* 323* 323
                                                                                  324* 329* 329* 335* 335*
prompt_after_explanation
                          1(06) 000162 automatic       bit(1)                   initial level 3 packed unaligned dcl 14-7 set ref
                                                                                  14-7*
ptr                                                    builtin function         dcl 998 ref 440 448 589 594 741 744 776 781 786 874
                                                                                  880 901 906
query_code                3     000162 automatic       fixed bin(35,0)          initial level 2 dcl 14-7 set ref 14-7*
query_info                      000162 automatic       structure                level 1 dcl 14-7 set ref 103* 362 362
query_info_version_6                   constant        fixed bin(17,0)          initial dcl 14-36 ref 104
query_iocb_ptr            4            based           pointer                  level 2 dcl 15-15 ref 108
question_iocbp            4     000162 automatic       pointer                  initial level 2 dcl 14-7 set ref 107* 14-7*
quit                            000764 stack reference condition                dcl 1002 ref 158 199 200
quit_occurred                   000772 automatic       bit(1)                   dcl 1003 set ref 153* 158* 200
reference_count                 000773 automatic       fixed bin(21,0)          dcl 1004 set ref 770* 777
rel                                                    builtin function         dcl 1005 ref 440 589 741 741 781 796 798 874 901
relation                               based           structure                level 1 unaligned dcl 16-77
relation_attribute_names               based           char                     unaligned dcl 16-76 ref 409
relation_copy_good        0(03)        based           bit(1)                   level 2 packed unaligned dcl 11-40 ref 682
relation_good_count             000774 automatic       fixed bin(21,0)          dcl 1006 set ref 136* 140* 140 160
relation_idx              1            based           fixed bin(17,0)          array level 2 dcl 16-99 ref 310 408 513
relation_index                  000775 automatic       fixed bin(17,0)          dcl 1007 set ref 138* 139* 160* 161* 310* 311 313
                                                                                  314 384* 385* 525* 527*
relation_list                          based           structure                level 1 unaligned dcl 16-67
relation_list_ptr               000210 automatic       pointer                  dcl 16-64 set ref 92* 96* 138 139 161 271 314 384
                                                                                  385 408 513 525 527
relation_name                   000776 automatic       char(32)                 unaligned dcl 1008 set ref 314* 316 324
relation_ptr                           based           pointer                  array level 2 in structure "relation_list" dcl 16-67
                                                                                  in procedure "rmdb_delete_domain" ref 139 161 385
                                                                                  408 513 527
relation_ptr                    000212 automatic       pointer                  dcl 16-74 in procedure "rmdb_delete_domain" set ref
                                                                                  139* 161* 162 385* 386 408* 409 409 413 513* 514
                                                                                  515 515 519 527* 528 529 529 533 534 541 557* 575
                                                                                  576 591 604 608 609 614 669 677 690 691 699 700
                                                                                  706 707 718 724 728 729 739 741 746 747 766 767
                                                                                  769 770 776 791
relations_printed               000121 automatic       bit                      unaligned dcl 271 set ref 304* 311 313*
relations_printed_count         000121 automatic       fixed bin(17,0)          dcl 272 set ref 305* 315* 315 316 316 319 329 329
                                                                                  329
relations_to_be_printed         000122 automatic       bit(1)                   dcl 273 set ref 279* 298* 302
release_area_                   000126 constant        entry                    external dcl 1009 ref 235
relmgr_entries          152            based           structure                level 2 unaligned dcl 12-25 set ref 557 557 679
repeat_time              10     000162 automatic       fixed bin(71,0)          initial level 2 dcl 14-7 set ref 14-7*
request_name              7            based           char(32)                 level 2 packed unaligned dcl 15-15 set ref 362*
rmdb_add_rmdb_history           000130 constant        entry                    external dcl 1010 ref 614 892 917
rmdb_copy_relation              000132 constant        entry                    external dcl 1011 ref 557
rmdb_ctl                               based           structure                level 1 unaligned dcl 12-25
rmdb_ctl_ptr                    000156 automatic       pointer                  dcl 12-43 set ref 43* 52 53 55 55 55 55 61 66 68* 75
                                                                                  96* 133 189 189 189 557 557 557 679
rmdb_delete_all$domains         000134 constant        entry                    external dcl 1012 ref 68
rmdb_relations_used$domains     000136 constant        entry                    external dcl 1013 ref 96
rmdb_relmgr_entries                    based           structure                level 1 unaligned dcl 13-18
rmdb_relmgr_entries_ptr         000160 automatic       pointer                  dcl 13-32 set ref 679* 706 735
rtrim                                                  builtin function         dcl 1014 ref 127 127 362 362 535 535 541 541 609 669
                                                                                  675 729
save_code                       001006 automatic       fixed bin(35,0)          dcl 1015 set ref 136* 144* 187 191* 682 754
save_ptr                        001010 automatic       pointer                  dcl 1016 set ref 588* 589 591* 596 598 600 602 872*
                                                                                  874 877* 882 884 887 890 900* 901 903* 908 910 912
                                                                                  914
saved_res_version_ptr
                        136            based           pointer                  level 2 dcl 12-25 ref 133
search_name                     000156 automatic       char(33)                 unaligned dcl 381 set ref 406* 409
segment_acl_entry                      based           structure                level 1 dcl 6-45
short                                  based           structure                level 2 dcl 18-8
size                     13     000222 automatic       fixed bin(18,0)          level 2 dcl 943 set ref 85*
source_dir               12     001366 automatic       char(168)                level 2 packed unaligned dcl 664 set ref 716*
source_name              64     001366 automatic       char(32)                 level 2 packed unaligned dcl 664 set ref 717*
status_area_ptr                 000216 automatic       pointer                  dcl 18-47 set ref 670* 672* 673 675
status_branch                          based           structure                level 1 dcl 18-8
status_code               2     000162 automatic       fixed bin(35,0)          initial level 2 dcl 14-7 set ref 14-7*
status_entry_names                     based           char(32)                 array dcl 18-47 ref 673 675
status_ptr                      000220 automatic       pointer                  dcl 18-47 set ref 671* 672* 673 675
substr                                                 builtin function         dcl 1017 set ref 311 313* 347* 397 472 675
suppress_name_sw          1(01) 000162 automatic       bit(1)                   initial level 3 packed unaligned dcl 14-7 set ref
                                                                                  106* 14-7*
suppress_spacing          1(04) 000162 automatic       bit(1)                   initial level 3 packed unaligned dcl 14-7 set ref
                                                                                  14-7*
switches                  1     000162 automatic       structure                level 2 dcl 14-7
sys_info$max_seg_size           000140 external static fixed bin(35,0)          dcl 1018 ref 85
target_dir               74     001366 automatic       char(168)                level 2 packed unaligned dcl 664 set ref 716*
target_name             146     001366 automatic       char(32)                 level 2 packed unaligned dcl 664 set ref 718*
temp_dir_path            60            based           char(168)                level 2 packed unaligned dcl 12-25 set ref 55* 75*
                                                                                  189* 557*
to_be_deleted            16(03)        based           bit(1)                   array level 4 packed unaligned dcl 16-77 set ref
                                                                                  519* 529 534*
to_char                         001550 automatic       fixed bin(17,0)          dcl 667 set ref 673* 674* 674 675
transaction_manager_$abandon_txn
                                000016 constant        entry                    external dcl 1-72 ref 4-72 4-86 4-100 4-110 1-110
                                                                                  242
transaction_manager_$abort_txn  000020 constant        entry                    external dcl 1-73 ref 4-71 4-85 4-99 4-109 1-109 241
transaction_manager_$begin_txn  000022 constant        entry                    external dcl 1-74 ref 1-99
transaction_manager_$commit_txn 000034 constant        entry                    external dcl 4-56 ref 4-68
transaction_manager_$get_current_txn_id
                                000024 constant        entry                    external dcl 1-75 ref 1-89 485
transaction_manager_$handle_conditions
                                000026 constant        entry                    external dcl 1-76 ref 1-135
transaction_manager_$rollback_txn
                                000036 constant        entry                    external dcl 4-57 ref 4-82 4-96
transactions_needed       0(34)        based           bit(1)                   level 3 packed unaligned dcl 10-72 ref 482
ua_ptr                          000152 automatic       pointer                  dcl 10-165 set ref 781* 781* 785* 786 789* 790 791
                                                                                  792 793 796 798 800 874* 874* 877 877 879* 880
unreferenced             10(04)        based           bit(1)                   level 2 in structure "domain_info" packed unaligned
                                                                                  dcl 10-125 in procedure "rmdb_delete_domain" ref
                                                                                  443
unreferenced              6(01)        based           bit(1)                   level 3 in structure "delete_object_info" packed
                                                                                  unaligned dcl 15-15 in procedure
                                                                                  "rmdb_delete_domain" ref 93 131
unreferenced_attribute                 based           structure                level 1 dcl 10-159 set ref 789 890
unreferenced_attribute_ptr
                         23            based           bit(18)                  level 2 packed unaligned dcl 10-72 set ref 781 796*
                                                                                  874 884*
unspec                                                 builtin function         dcl 1019 set ref 79* 103* 386* 720* 721*
unused                   11            based           bit(18)                  array level 2 packed unaligned dcl 10-159 set ref
                                                                                  793*
user_area                              based           area(1024)               dcl 1021 ref 436
user_area_ptr                   001012 automatic       pointer                  dcl 1022 set ref 46* 75* 86 96* 233 235* 236* 436
                                                                                  670 690*
user_started_transaction        000104 automatic       bit(1)                   dcl 1-69 set ref 1-92* 1-98* 4-60
user_transaction_id             000106 automatic       bit(36)                  dcl 1-71 set ref 1-93* 1-100*
version                                based           char(8)                  level 2 in structure "delete_object_info" packed
                                                                                  unaligned dcl 15-15 in procedure
                                                                                  "rmdb_delete_domain" ref 48 48
version                         001366 automatic       char(8)                  level 2 in structure "co" dcl 664 in procedure
                                                                                  "switch_names" set ref 714*
version                         000162 automatic       fixed bin(17,0)          level 2 in structure "query_info" dcl 14-7
                                                                                  in procedure "rmdb_delete_domain" set ref 104*
version                         000222 automatic       fixed bin(17,0)          level 2 in structure "ai" dcl 943 in procedure
                                                                                  "rmdb_delete_domain" set ref 80*
yes_or_no_sw              1     000162 automatic       bit(1)                   initial level 3 packed unaligned dcl 14-7 set ref
                                                                                  105* 14-7*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACL_VERSION_1                          internal static fixed bin(17,0)          initial dcl 6-77
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
DELETE_ACL_VERSION_1                   internal static char(4)                  initial unaligned dcl 6-67
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-33
DIR_ACL_VERSION_1                      internal static char(4)                  initial unaligned dcl 6-67
Directory                              internal static fixed bin(17,0)          initial dcl 18-56
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
GENERAL_DELETE_ACL_VERSION_1           internal static char(8)                  initial unaligned dcl 6-72
GENERAL_EXTENDED_ACL_VERSION_1         internal static char(8)                  initial unaligned dcl 6-72
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 2-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 2-12
Link                                   internal static fixed bin(17,0)          initial dcl 18-56
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
RMDB_ADD_ATTR_OP                       internal static fixed bin(17,0)          initial dcl 17-54
RMDB_ADD_DMN_OP                        internal static fixed bin(17,0)          initial dcl 17-56
RMDB_ADD_IDX_OP                        internal static fixed bin(17,0)          initial dcl 17-52
RMDB_ADD_REL_OP                        internal static fixed bin(17,0)          initial dcl 17-50
RMDB_CTL_VERSION_1                     internal static fixed bin(17,0)          initial dcl 12-41
RMDB_DEL_IDX_OP                        internal static fixed bin(17,0)          initial dcl 17-53
RMDB_RN_ATTR_OP                        internal static fixed bin(17,0)          initial dcl 17-58
RMDB_RN_DMN_OP                         internal static fixed bin(17,0)          initial dcl 17-59
RMDB_RN_REL_OP                         internal static fixed bin(17,0)          initial dcl 17-60
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
R_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-30
SEG_ACL_VERSION_1                      internal static char(4)                  initial unaligned dcl 6-67
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
Segment                                internal static fixed bin(17,0)          initial dcl 18-56
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 2-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 2-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 2-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 2-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 2-20
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
acl_count                              automatic       fixed bin(17,0)          dcl 6-5
acl_ptr                                automatic       pointer                  dcl 6-4
ai_ptr                                 automatic       pointer                  dcl 11-209
al_ptr                                 automatic       pointer                  dcl 11-345
alloc_length                           internal static fixed bin(35,0)          dcl 10-222
area_infop                             automatic       pointer                  dcl 7-5
atd                                    based           char                     unaligned dcl 11-109
atd_len                                automatic       fixed bin(17,0)          dcl 11-111
atd_ptr                                automatic       pointer                  dcl 11-110
attr_info                              based           structure                level 1 dcl 11-192
attr_list                              based           structure                level 1 dcl 11-341
attribute_count                        automatic       fixed bin(17,0)          dcl 16-98
attribute_list_count                   automatic       fixed bin(17,0)          dcl 16-53
attribute_list_names                   based           char                     unaligned dcl 16-54
changer                                based           structure                level 1 packed unaligned dcl 10-251
changer_ptr                            automatic       pointer                  dcl 10-256
child_link_info                        based           structure                level 1 dcl 11-283
cli_ptr                                automatic       pointer                  dcl 11-329
cna_ptr                                automatic       pointer                  dcl 11-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 11-112
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
constant                               based           structure                level 1 unaligned dcl 10-216
constant_ptr                           automatic       pointer                  dcl 10-220
copy_options_ptr                       automatic       pointer                  dcl 9-10
crossref_info_record                   based           structure                level 1 unaligned dcl 16-19
crossref_info_record_count             automatic       fixed bin(21,0)          dcl 16-18
crossref_info_record_objects           based           char                     unaligned dcl 16-27
crossref_info_record_ptr               automatic       pointer                  dcl 16-17
delete_acl                             based           structure                level 1 dcl 6-58
delete_acl_array                       based           structure                array level 1 dcl 6-64
delete_object_info_count               automatic       fixed bin(17,0)          dcl 15-11
directory_acl                          based           structure                level 1 dcl 6-49
directory_acl_array                    based           structure                array level 1 dcl 6-55
domain_list_names                      based           char                     unaligned dcl 16-44
dp_ptr                                 automatic       pointer                  dcl 11-356
dup_prev                               based           structure                level 1 dcl 11-353
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 1-63
fixed                                                  builtin function         dcl 964
general_acl                            based           structure                level 1 dcl 6-7
general_delete_acl                     based           structure                level 1 dcl 6-30
general_extended_acl                   based           structure                level 1 dcl 6-18
message_str                            based           structure                level 1 packed unaligned dcl 10-259
message_str_len                        automatic       fixed bin(17,0)          dcl 10-269
message_str_ptr                        automatic       pointer                  dcl 10-267
ncomp_init                             automatic       fixed bin(17,0)          dcl 11-116
parent_link_info                       based           structure                level 1 dcl 11-223
path_entry                             based           structure                level 1 packed unaligned dcl 10-172
path_entry_ptr                         automatic       pointer                  dcl 10-177
pli_ptr                                automatic       pointer                  dcl 11-268
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 14-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 14-34
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 14-35
rel_info                               based           structure                level 1 dcl 11-126
relation_attribute_count               automatic       fixed bin(17,0)          dcl 16-75
relation_list_count                    automatic       fixed bin(17,0)          dcl 16-65
relation_list_names                    based           char                     unaligned dcl 16-66
ri_ptr                                 automatic       pointer                  dcl 11-185
rmdb_history_entry                     based           structure                level 1 dcl 17-31
rmdb_history_entry_ptr                 automatic       pointer                  dcl 17-42
sc_ptr                                 automatic       pointer                  dcl 11-365
segment_acl                            based           structure                level 1 dcl 6-40
segment_acl_array                      based           structure                array level 1 dcl 6-46
select_chain                           based           structure                level 1 dcl 11-357
sk_ptr                                 automatic       pointer                  dcl 11-352
sort_key                               based           structure                level 1 dcl 11-346
stack_item                             based           structure                level 1 unaligned dcl 10-206
stack_item_ptr                         automatic       pointer                  dcl 10-212
status_link                            based           structure                level 1 dcl 18-38
status_pathname                        based           char                     dcl 18-47
version_status                         based           structure                level 1 packed unaligned dcl 10-232
version_status_ptr                     automatic       pointer                  dcl 10-246

NAMES DECLARED BY EXPLICIT CONTEXT.
RETURN_TO_CALLER                002233 constant        label                    dcl 226 ref 223
all_attributes_are_deleted      005246 constant        entry                    internal dcl 570 ref 555
check_for_deletion_of_primary_key
                                004411 constant        entry                    internal dcl 498 ref 123
cleaner                         002434 constant        entry                    internal dcl 230 ref 64 169 226
cleanup_directory               001464 constant        label                    dcl 153 ref 145
delete_file                     005534 constant        entry                    internal dcl 617 ref 608 609
delete_relation_information     005277 constant        entry                    internal dcl 584 ref 555
delete_xref_records             007336 constant        entry                    internal dcl 812 ref 196
error                           002370 constant        entry                    internal dcl 213 ref 48 57 76 89 98 118 1-140 191
                                                                                  206 421 451 454 489 541 565 629 677 691 695 707
                                                                                  724 729 750 820 829 839
finish_relation                 007335 constant        label                    dcl 804 ref 772
make_name                       004267 constant        entry                    internal dcl 459 ref 446
make_unreferenced_domain_delete_list
                                004075 constant        entry                    internal dcl 429 ref 93
mftxn_check_code                001704 constant        label                    dcl 4-65 ref 1-127 1-133
mftxn_exit                      002124 constant        label                    dcl 4-115 ref 4-63
modify_xref                     007077 constant        entry                    internal dcl 758 ref 754
mstxn_any_other                 002272 constant        entry                    internal dcl 1-116 ref 171
mstxn_cleanup                   002240 constant        entry                    internal dcl 1-102 ref 168
mstxn_exit                      001650 constant        label                    dcl 1-140 ref 1-86 1-95 4-91 4-105
print_information               002540 constant        entry                    internal dcl 265 ref 113
process_single_relation         005134 constant        entry                    internal dcl 551 ref 141
query                           003502 constant        entry                    internal dcl 359 ref 344
recalculate_attributes_deleted  003605 constant        entry                    internal dcl 376 ref 354
restore_significant_data        002531 constant        entry                    internal dcl 249 ref 4-77
rmdb_delete_domain              000557 constant        entry                    external dcl 40
should_rollback                 002533 constant        entry                    internal dcl 254 ref 4-94
skip_relation                   005245 constant        label                    dcl 567 ref 563
switch_names                    005677 constant        entry                    internal dcl 651 ref 176
transaction_in_progress         004344 constant        entry                    internal dcl 479 ref 163
unlink_deleted_domains          007660 constant        entry                    internal dcl 853 ref 194
unmake_name                     004322 constant        entry                    internal dcl 467 ref 281 290 314 509 533 769 818 837
                                                                                  859 873

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11202       11352   10303       11212
Length     12256   10303       150         670     676           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rmdb_delete_domain                 1612 external procedure  is an external procedure.  
on unit on line 64                   64 on unit               
on unit on line 158                  64 on unit               
on unit on line 166                  76 on unit               
on unit on line 171                  82 on unit               
mstxn_cleanup                           internal procedure  shares stack frame of on unit on line 166.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 171.  
error                                65 internal procedure  is called during a stack extension.  
cleaner                              84 internal procedure  is called by several nonquick procedures.  
restore_significant_data                internal procedure  shares stack frame of external procedure rmdb_delete_domain.  
should_rollback                         internal procedure  shares stack frame of external procedure rmdb_delete_domain.  
print_information                   282 internal procedure  uses auto adjustable storage.  
query                                   internal procedure  shares stack frame of internal procedure print_information.  
recalculate_attributes_deleted
                                        internal procedure  shares stack frame of internal procedure print_information.  
make_unreferenced_domain_delete_list
                                        internal procedure  shares stack frame of external procedure rmdb_delete_domain.  
make_name                               internal procedure  shares stack frame of external procedure rmdb_delete_domain.  
unmake_name                          65 internal procedure  is called by several nonquick procedures.  
transaction_in_progress                 internal procedure  shares stack frame of external procedure rmdb_delete_domain.  
check_for_deletion_of_primary_key
                                        internal procedure  shares stack frame of external procedure rmdb_delete_domain.  
process_single_relation                 internal procedure  shares stack frame of external procedure rmdb_delete_domain.  
all_attributes_are_deleted              internal procedure  shares stack frame of external procedure rmdb_delete_domain.  
delete_relation_information             internal procedure  shares stack frame of external procedure rmdb_delete_domain.  
delete_file                         106 internal procedure  is called during a stack extension.  
switch_names                            internal procedure  shares stack frame of external procedure rmdb_delete_domain.  
modify_xref                             internal procedure  shares stack frame of external procedure rmdb_delete_domain.  
delete_xref_records                     internal procedure  shares stack frame of external procedure rmdb_delete_domain.  
unlink_deleted_domains                  internal procedure  shares stack frame of external procedure rmdb_delete_domain.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
print_information        000100 cancel_domain               print_information
                         000100 first_cancel_domain         print_information
                         000101 printed_names               print_information
                         000121 relations_printed           print_information
                         000121 relations_printed_count     print_information
                         000122 relations_to_be_printed     print_information
                         000154 have_domains_to_process     recalculate_attributes_deleted
                         000155 position                    recalculate_attributes_deleted
                         000156 search_name                 recalculate_attributes_deleted
rmdb_delete_domain       000100 mstxn_code                  rmdb_delete_domain
                         000101 mstxn_retries               rmdb_delete_domain
                         000102 mstxn_temp_code             rmdb_delete_domain
                         000103 mstxn_transactions_needed   rmdb_delete_domain
                         000104 user_started_transaction    rmdb_delete_domain
                         000105 mstxn_txn_id                rmdb_delete_domain
                         000106 user_transaction_id         rmdb_delete_domain
                         000110 mstxn_condition_info        rmdb_delete_domain
                         000142 mftxn_code                  rmdb_delete_domain
                         000143 mftxn_temp_code             rmdb_delete_domain
                         000144 dbm_ptr                     rmdb_delete_domain
                         000146 fi_ptr                      rmdb_delete_domain
                         000150 di_ptr                      rmdb_delete_domain
                         000152 ua_ptr                      rmdb_delete_domain
                         000154 fm_ptr                      rmdb_delete_domain
                         000156 rmdb_ctl_ptr                rmdb_delete_domain
                         000160 rmdb_relmgr_entries_ptr     rmdb_delete_domain
                         000162 query_info                  rmdb_delete_domain
                         000200 delete_object_info_ptr      rmdb_delete_domain
                         000202 domain_list_ptr             rmdb_delete_domain
                         000204 domain_list_count           rmdb_delete_domain
                         000206 attribute_list_ptr          rmdb_delete_domain
                         000210 relation_list_ptr           rmdb_delete_domain
                         000212 relation_ptr                rmdb_delete_domain
                         000214 attribute_ptr               rmdb_delete_domain
                         000216 status_area_ptr             rmdb_delete_domain
                         000220 status_ptr                  rmdb_delete_domain
                         000222 ai                          rmdb_delete_domain
                         000246 answer                      rmdb_delete_domain
                         000256 attribute_idx               rmdb_delete_domain
                         000257 attribute_list_idx          rmdb_delete_domain
                         000260 attribute_name              rmdb_delete_domain
                         000276 code                        rmdb_delete_domain
                         000277 db_path                     rmdb_delete_domain
                         000351 domain_list_idx             rmdb_delete_domain
                         000352 domain_name                 rmdb_delete_domain
                         000362 error_message               rmdb_delete_domain
                         000560 last_unreferenced_attribute_ptr
                                                            rmdb_delete_domain
                         000562 local_iocb                  rmdb_delete_domain
                         000564 make_consistent_msg         rmdb_delete_domain
                         000762 previous_ptr                rmdb_delete_domain
                         000772 quit_occurred               rmdb_delete_domain
                         000773 reference_count             rmdb_delete_domain
                         000774 relation_good_count         rmdb_delete_domain
                         000775 relation_index              rmdb_delete_domain
                         000776 relation_name               rmdb_delete_domain
                         001006 save_code                   rmdb_delete_domain
                         001010 save_ptr                    rmdb_delete_domain
                         001012 user_area_ptr               rmdb_delete_domain
                         001064 attr_idx                    check_for_deletion_of_primary_key
                         001065 deletion_attributes         check_for_deletion_of_primary_key
                         001262 no_primary_key              check_for_deletion_of_primary_key
                         001306 attribute_idx               all_attributes_are_deleted
                         001324 local_status_branch         switch_names
                         001336 create_model_name           switch_names
                         001346 create_relation_name        switch_names
                         001356 data_acl_ptr                switch_names
                         001360 move_string_length          switch_names
                         001361 new_model_bit_count         switch_names
                         001362 new_file_model_ptr          switch_names
                         001364 last_file_info_ptr          switch_names
                         001366 co                          switch_names
                         001546 cvds                        switch_names
                         001547 ivds                        switch_names
                         001550 to_char                     switch_names
                         001560 index                       modify_xref

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ext_out_desc
call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc call_int_other      return_mac
tra_ext_1           alloc_auto_adj      signal_op           enable_op           shorten_stack       ext_entry_desc
int_entry           int_entry_desc      set_chars_eis       index_chars_eis     op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
command_query_                continue_to_signal_           define_area_                  delete_$path
delete_$path                  find_condition_info_          fs_util_$copy                 fs_util_$delentry_file
fs_util_$get_switch           fs_util_$list_acl             fs_util_$replace_acl          fs_util_$set_switch
hcs_$chname_file              hcs_$status_                  initiate_file_                ioa_$ioa_switch
ioa_$ioa_switch_nnl           mdbm_util_$free_temp_segment  mdbm_util_$get_temp_segment_path
mdbm_util_$inconsistent_reset mdbm_util_$inconsistent_set   mdbm_util_$xref_build         mdbm_util_$xref_delete_record
mdbm_util_$xref_dereference   mdbm_util_$xref_destroy       release_area_                 rmdb_add_rmdb_history
rmdb_copy_relation            rmdb_delete_all$domains       rmdb_relations_used$domains
transaction_manager_$abandon_txn                            transaction_manager_$abort_txn
transaction_manager_$begin_txn                              transaction_manager_$commit_txn
transaction_manager_$get_current_txn_id                     transaction_manager_$handle_conditions
transaction_manager_$rollback_txn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$key_duplication     dm_error_$lock_deadlock
dm_error_$no_current_transaction                            error_table_$action_not_performed
error_table_$no_record        error_table_$unimplemented_version
error_table_$unsupported_operation                          mrds_error_$no_primary_key    mrds_error_$no_unref_domain
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     40 000552   14    7 000572        43 000622        44 000626        46 000631        48 000634        52 000672
     53 000677        55 000703        57 000742        61 000760        63 000763        64 000764        66 001006
     68 001011        75 001037        76 001065        79 001106        80 001111        81 001113        82 001115
     83 001117        84 001121        85 001124        86 001127        88 001131        89 001143        92 001164
     93 001170        96 001176        98 001236       101 001254       103 001260       104 001263       105 001265
    106 001267       107 001271       108 001273       109 001275       110 001277       113 001301       115 001305
    117 001314       118 001315       123 001331       125 001332       127 001335       131 001412       133 001417
    135 001424       136 001426       138 001430       139 001437       140 001454       141 001455       142 001456
    144 001460       145 001461       147 001462       153 001464       158 001465       160 001505       161 001515
    162 001532       163 001534       164 001535       166 001537       168 001553       169 001554       170 001561
    171 001562    1   83 001600    1   84 001601    1   86 001602    1   88 001604    1   89 001605    1   90 001616
 1   92 001622    1   93 001624    1   94 001626    1   95 001627    1   98 001630    1   99 001631    1  100 001646
 1  140 001650       176 001671       177 001672       179 001674    4   60 001675    4   62 001702    4   63 001703
 4   65 001704    4   68 001706    4   69 001717    4   71 001721    4   72 001732    4   75 001745    4   77 001746
 4   78 001747    4   81 001756    4   82 001757    4   83 001772    4   85 001774    4   86 002005    4   88 002020
 4   90 002021    4   91 002022    4   93 002023    4   94 002024    4   96 002031    4   97 002045    4   99 002047
 4  100 002060    4  102 002073    4  104 002074    4  105 002075    4  107 002076    4  109 002077    4  110 002110
 4  114 002123       183 002124       187 002126       189 002130       191 002163       194 002177       195 002200
    196 002207       199 002210       200 002211       203 002216       206 002217       226 002233       228 002237
 1  102 002240    1  107 002241    1  109 002244    1  110 002255    1  114 002271    1  116 002272    1  121 002273
 1  123 002276    1  124 002315    1  126 002323    1  127 002326    1  129 002331    1  132 002343    1  133 002346
 1  135 002351    1  136 002356    1  137 002357    1  138 002366       213 002367       219 002403       220 002410
    222 002420       223 002430       230 002433       233 002441       235 002446       236 002454       239 002477
    241 002502       242 002513       246 002530       249 002531       251 002532       254 002533       256 002535
    265 002537       268 002545       271 002555       275 002564       276 002573       278 002574       279 002604
    280 002605       281 002622       282 002647       284 002654       288 002705       289 002716       290 002740
    291 002765       295 003032       298 003070       301 003077       302 003101       304 003103       305 003112
    306 003113       307 003124       308 003146       310 003162       311 003164       313 003171       314 003174
    315 003221       316 003222       319 003234       323 003277       324 003302       327 003306       328 003311
    329 003313       335 003366       339 003417       343 003440       344 003451       347 003461       348 003467
    352 003473       354 003476       357 003501       359 003502       362 003504       364 003564       366 003601
    376 003605       384 003606       385 003620       386 003635       387 003637       389 003641       390 003652
    391 003657       395 003661       396 003662       397 003672       400 003705       401 003707       402 003724
    403 003734       404 003756       406 003762       407 003770       408 004000       409 004016       410 004037
    412 004040       413 004043       415 004046       417 004050       419 004052       421 004054       423 004074
    429 004075       435 004076       436 004103       437 004124       440 004125       443 004137       445 004143
    446 004144       448 004171       449 004200       451 004225       454 004251       456 004266       459 004267
    464 004300       467 004321       472 004335       479 004344       482 004345       484 004350       485 004352
    486 004363       488 004365       489 004366       492 004406       493 004407       495 004410       498 004411
    505 004412       506 004415       507 004417       508 004427       509 004444       510 004470       511 004477
    512 004521       513 004535       514 004553       515 004563       518 004612       519 004613       521 004616
    522 004620       523 004622       524 004624       525 004626       527 004641       528 004656       529 004667
    533 004702       534 004733       535 004740       536 005012       537 005013       538 005015       540 005017
    541 005022       542 005130       543 005131       544 005133       551 005134       555 005135       557 005144
    559 005206       561 005210       563 005221       565 005231       567 005245       570 005246       575 005250
    576 005261       578 005271       580 005273       584 005277       588 005300       589 005303       591 005321
    593 005331       594 005332       596 005340       598 005344       600 005355       602 005361       604 005363
    608 005415       609 005425       611 005464       612 005473       614 005500       615 005532       617 005533
    625 005547       626 005571       629 005632       632 005675       651 005677       669 005700       670 005727
    671 005732       672 005734       673 005771       674 006006       675 006010       676 006025       677 006062
    679 006107       682 006112       684 006120       685 006123       689 006130       690 006132       691 006166
    694 006213       695 006246       698 006272       699 006274       700 006331       702 006366       703 006423
    706 006460       707 006501       712 006526       714 006530       715 006532       716 006535       717 006546
    718 006551       720 006555       721 006556       723 006557       724 006572       726 006617       728 006620
    729 006646       731 006733       735 006734       737 006756       739 007011       741 007016       743 007032
    744 007034       746 007042       747 007046       750 007050       753 007072       754 007073       756 007076
    758 007077       766 007100       767 007111       769 007116       770 007147       772 007207       776 007215
    777 007224       781 007232       785 007247       786 007251       789 007257       790 007265       791 007270
    792 007275       793 007277       796 007316       798 007326       800 007332       803 007333       804 007335
    812 007336       815 007337       816 007347       818 007355       819 007377       820 007430       828 007451
    829 007502       834 007523       835 007541       837 007555       838 007601       839 007632       842 007653
    844 007655       846 007657       853 007660       856 007661       857 007671       859 007677       867 007721
    868 007737       870 007753       872 007766       873 007771       874 010011       877 010027       879 010036
    880 010037       882 010045       884 010051       887 010063       890 010067       892 010071       896 010123
    900 010125       901 010130       903 010145       905 010154       906 010155       908 010163       910 010167
    912 010200       914 010204       915 010206       917 010214       923 010246       925 010250


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
