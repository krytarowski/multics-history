	COMPILATION LISTING OF SEGMENT dfast_basic_resequence_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 01/19/88  1503.8 mst Tue
	    Options: optimize map

        1 /****^  ******************************************************
        2*        *                                                    *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987           *
        4*        *                                                    *
        5*        * Copyright (c) 1972 by Massachusetts Institute of   *
        6*        * Technology and Honeywell Information Systems, Inc. *
        7*        *                                                    *
        8*        ****************************************************** */
        9 
       10 
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(87-12-03,TLNguyen), approve(87-12-03,MCR7806),
       14*     audit(87-12-10,Lippard), install(88-01-19,MR12.2-1015):
       15*     - Remove the "search" from the source because it is not referenced
       16*       anywhere within the source program.
       17*                                                   END HISTORY COMMENTS */
       18 
       19 
       20 dfast_basic_resequence_: proc (max_seg_size, line_table_ptr, input_segment, resequence_lines, temp_ptr, temp_length, code);
       21 
       22 /* *	This procedure is given a block of Basic source lines and a table of line numbers.
       23*   *	The table has two numbers for each line that is to be changed -- old_number, the current number for the
       24*   *	line; and new_number, the number that the line will have after resequencing.  The source code is
       25*   *	parsed and all Basic references to lines in the line table are edited.  the procedure can be called
       26*   *	in two ways:
       27*   *
       28*   *	     resequence_lines = "1"b		The line numbers will be checked against the line table in addition
       29*   *					to the editing for line number references.
       30*   *
       31*   *	     resequence_lines = "0"b		Only the line reference editing will be done.
       32*   *
       33*   *
       34*   *	Statements with possible line number references:
       35*   *
       36*   *	     if ---- then NUMBER
       37*   *	     if ---- goto NUMBER
       38*   *	     gosub NUMBER
       39*   *	     goto NUMBER
       40*   *	     on ---- goto NUMBER, NUMBER . . .
       41*   *	     on ---- gosub NUMBER, NUMBER . . .
       42*   *	     on ---- then NUMBER, NUMBER . . .
       43*   *
       44*   *	Keywords may contain blanks and may be uppercase or lowercase.
       45*   *   Modified 10/28/83 C Spitzer. phx8299. fix so doesn't remove whitespace at
       46*		end of line or end of statement but before comment.
       47**/
       48 
       49 /* parameters */
       50 
       51 dcl  max_seg_size fixed bin (21);			/* max number of characters in segment */
       52 dcl  line_table_ptr ptr;
       53 dcl  input_segment char (*);
       54 dcl  resequence_lines bit (1);
       55 dcl  temp_ptr ptr;
       56 dcl  temp_length fixed bin (21);
       57 dcl  code fixed bin (35);
       58 
       59 /* automatic */
       60 
       61 dcl  char char (1);
       62 dcl  line char (256) var;				/* lowercase image of one line */
       63 dcl  line_start fixed bin (21);			/* index in input_segment of line being edited */
       64 dcl  line_length fixed bin (21);			/* number of characters in input segment */
       65 dcl  input_segment_length fixed bin (21);		/* number of characters to be edited */
       66 dcl  number_string char (12);				/* scratch space for formatting new numbers */
       67 dcl  number_length fixed bin (21);			/* number of ditits in line number */
       68 dcl  number_pic pic "99999";
       69 
       70 dcl (index, length, substr, translate, verify) builtin;
       71 
       72 /* constants */
       73 
       74 dcl  LEADING_ZERO bit (1) unal int static options (constant) init ("1"b);
       75 dcl  NEW_LINE char (1) int static options (constant) init ("
       76 ");
       77 dcl  DIGITS char (10) int static options (constant) init ("0123456789");
       78 dcl  MAX_NUM_DIGITS int static options (constant) init (5); /* number of digits in a line number */
       79 dcl  WHITE_SPACE char (2) int static options (constant) init ("	 "); /* tab & blank */
       80 dcl  APOSTROPHE char (1) int static options (constant) init ("'"); /* ' = rest of line is comment */
       81 dcl  QUOTE char (1) int static options (constant) init (""""); /* "string" is ignored by resequencer */
       82 
       83 /* based */
       84 
       85 dcl 1 t aligned based (line_table_ptr),
       86     2 num_lines fixed bin (21),
       87     2 line_table (t.num_lines),
       88       3 old_number fixed bin (17) unal,
       89       3 new_number fixed bin (17) unal;
       90 
       91 dcl  temp_seg char (max_seg_size) based (temp_ptr);
       92 
       93 /* entries */
       94 
       95 dcl  ioa_$rsnnl entry options (variable);
       96 
  1     1 /*  BEGIN INCLUDE ... dfast_error_codes.incl.pl1  */
  1     2 
  1     3 dcl  error_alt_empty fixed bin (35) int static init (1)options (constant);
  1     4 dcl  error_max_size fixed bin (35) int static init (2)options (constant);
  1     5 dcl  error_cur_empty fixed bin (35) int static init (3)options (constant);
  1     6 dcl  error_not_saved fixed bin (35) int static init (4)options (constant);
  1     7 dcl  error_name_dup fixed bin (35) int static init (5)options (constant);
  1     8 dcl  error_long_rec fixed bin (35) int static init (6)options (constant);
  1     9 dcl  error_unknown_arg fixed bin (35) int static init (7)options (constant);
  1    10 dcl  error_no_expl fixed bin (35) int static init (8)options (constant);
  1    11 dcl  error_bad_name fixed bin (35) int static init (9)options (constant);
  1    12 dcl  error_bad_req fixed bin (35) int static init (10)options (constant);
  1    13 dcl  error_syntax_string fixed bin (35) int static init (11)options (constant);
  1    14 dcl  error_name_miss fixed bin (35) int static init (12)options (constant);
  1    15 dcl  error_no_comp fixed bin (35) int static init (13)options (constant);
  1    16 dcl  error_no_main fixed bin (35) int static init (14)options (constant);
  1    17 dcl  error_block_spec fixed bin (35) int static init (15)options (constant);
  1    18 dcl  error_obj_nop fixed bin (35) int static init (16)options (constant);
  1    19 dcl  error_sav_cur fixed bin (35) int static init (17)options (constant);
  1    20 dcl  error_bad_type fixed bin (35) int static init (18)options (constant);
  1    21 dcl  error_unkn_sys fixed bin (35) int static init (19)options (constant);
  1    22 dcl  error_no_suffix fixed bin (35) int static init (20)options (constant);
  1    23 dcl  error_no_nl fixed bin (35) int static init (21)options (constant);
  1    24 dcl  error_bad_sort fixed bin (35) int static init (22)options (constant);
  1    25 dcl  error_no_num fixed bin (35) int static init (23)options (constant);
  1    26 dcl  error_line_miss fixed bin (35) int static init (24)options (constant);
  1    27 dcl  error_request_miss fixed bin (35) int static init (25)options (constant);
  1    28 dcl  error_bad_line fixed bin (35) int static init (26)options (constant);
  1    29 dcl  error_no_string fixed bin (35) int static init (27)options (constant);
  1    30 dcl  error_line_order fixed bin (35) int static init (28)options (constant);
  1    31 dcl  error_max_lines fixed bin (35) int static init (29)options (constant);
  1    32 dcl  error_bad_pathname fixed bin (35) int static init (30)options (constant);
  1    33 dcl  error_access_mode fixed bin (35) int static init (31)options (constant);
  1    34 dcl  error_delimiter_miss fixed bin (35) int static init (32)options (constant);
  1    35 dcl  error_size_fixed_record fixed bin (35) int static init (33)options (constant);
  1    36 dcl  error_bad_rec_len fixed bin (35) int static init (34)options (constant);
  1    37 dcl  error_string_size fixed bin (35) int static init (35)options (constant);
  1    38 dcl  error_max_line_number  fixed bin (35) int static init (36)options (constant);
  1    39 dcl  error_max_args fixed bin (35) int static init (37)options (constant);
  1    40 dcl  error_name_sys fixed bin (35) int static init (38)options (constant);
  1    41 dcl  error_dprint_map fixed bin (35) int static init (39)options (constant);
  1    42 dcl  error_max_num fixed bin (35) int static options (constant) init (40);
  1    43 dcl  error_edit_max_num fixed bin (35) int static options (constant) init (41);
  1    44 dcl  error_un_num_text fixed bin (35) int static options (constant) init (42);
  1    45 dcl  error_no_new_line fixed bin (35) int static options (constant) init (43);
  1    46 
  1    47 /* END INCLUDE ... dfast_error_codes.incl.pl1 */
       97 
       98 /*  */
       99 /* *	The source code is parsed one line at a time and the edited version is put in temp_seg.
      100*   *
      101*   *	The line begins with a number:
      102*   *
      103*   *	     1.  The line number is edited and copied into temp_seg.
      104*   *	     2.  The portion of the line following the line number is converted to lowercase and stored in line.
      105*   *	     3.  The line image is parsed for line number references and the original is copied into temp_seg
      106*   *	         with the line references changed.
      107*   *
      108*   *	The line does not begin with a number:
      109*   *
      110*   *	     The line is copied as is.
      111**/
      112 
      113 	line_start = 1;
      114 	input_segment_length = length (input_segment);
      115 
      116 	do while (line_start <= input_segment_length & code = 0);
      117 
      118 	     line_length = index (substr (input_segment, line_start), NEW_LINE);
      119 	     if line_length > 0 then do;
      120 
      121 		number_length = verify (substr (input_segment, line_start, line_length), DIGITS) -1;
      122 		if number_length > 0 then do;
      123 		     if resequence_lines then do;
      124 			if ^store_new_number (LEADING_ZERO, substr (input_segment, line_start, number_length))
      125 			then call move (line_start, number_length);
      126 		     end;
      127 		     else call move (line_start, number_length);
      128 		     line_start = line_start + number_length;
      129 		     line_length = line_length - number_length;
      130 
      131 		     line = translate (substr (input_segment, line_start, line_length),
      132 			"abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
      133 
      134 		     call edit_line;
      135 		end;
      136 
      137 		else call move (line_start, line_length);
      138 
      139 		line_start = line_start + line_length;
      140 	     end;
      141 
      142 	     else code = error_no_nl;
      143 	end;
      144 
      145 	return;
      146 
      147 /*  */
      148 /*  This procedure copies a portion of the input segment into the temporary segment.
      149**/
      150 move:	proc (start, num_chars);
      151 
      152 dcl  start fixed bin (21);				/* index on input segment of first character to move */
      153 dcl  num_chars fixed bin (21);			/* number of characters to move */
      154 
      155 	     if num_chars > 0 then do;
      156 		substr (temp_seg, temp_length + 1, num_chars) = substr (input_segment, start, num_chars);
      157 		temp_length = temp_length + num_chars;
      158 	     end;
      159 
      160 	     return;
      161 
      162 	end move;
      163 
      164 /*  */
      165 /*  This procedure checks line which contains a lowercase image of one basic source line.
      166*   If it locates a basic statement that refers to a line number, the new line number (if it exits)
      167*   is substituted.  If it does not find a line number reference, no change is made.
      168**/
      169 edit_line: proc;
      170 
      171 dcl  i fixed bin (21);
      172 dcl  replace_number bit (1);
      173 dcl  multiple_numbers bit (1);			/* ON if more than on number expected */
      174 
      175 	     i = 1;
      176 	     replace_number = "0"b;
      177 	     multiple_numbers = "0"b;
      178 
      179 /* if ---- then NUMBER */
      180 
      181 	     if next_word (i, "if") then do;
      182 
      183 		if search_word (i, "then") then replace_number = "1"b;
      184 		else if search_word (i, "go") then
      185 		     if next_word (i, "to") | next_word (i, "sub") then replace_number = "1"b;
      186 	     end;
      187 
      188 /* goto NUMBER */
      189 
      190 	     else if next_word (i, "go") then do;
      191 		if next_word (i, "to") | next_word (i, "sub") then replace_number = "1"b;
      192 	     end;
      193 
      194 /* on ---- goto NUMBER, NUMBER . . . */
      195 
      196 	     else if next_word (i, "on") then do;
      197 		multiple_numbers = "1"b;
      198 		if search_word (i, "go") then do;
      199 		     if next_word (i, "to") | next_word (i, "sub") then replace_number = "1"b;
      200 		end;
      201 		else if search_word (i, "then") then replace_number = "1"b;
      202 	     end;
      203 
      204 	     if replace_number then do;
      205 
      206 		call move (line_start, i -1);
      207 
      208 		call store_multiple_numbers (i, multiple_numbers);
      209 
      210 		call move (line_start + i -1, line_length - i + 1);
      211 	     end;
      212 
      213 	     else call move (line_start, line_length);
      214 
      215 	     return;
      216 
      217 	end edit_line;
      218 
      219 /*  */
      220 /* *	This procedure parses line (which contains a lowercase image of a Basic source line) beginning at start.
      221*   *	It ignores blanks and tabs.  There are two returns:
      222*   *
      223*   *	     "1"b		The next word is 'word'
      224*   *			start = index on line following 'word'
      225*   *
      226*   *	     "0"b		The next word is not 'word'
      227*   *			start is unchanged.
      228**/
      229 next_word: proc (start, word) returns (bit (1));
      230 
      231 dcl  start fixed bin (21);
      232 dcl  word char (*);
      233 
      234 dcl  word_length fixed bin (21);
      235 dcl  word_index fixed bin (21);
      236 dcl  line_index fixed bin (21);
      237 
      238 	     word_length = length (word);
      239 	     line_index = start;
      240 
      241 	     do word_index = 1 to word_length;
      242 
      243 		if get_char (line_index, char) then do;
      244 
      245 		     if char ^= substr (word, word_index, 1) then return ("0"b);
      246 		     line_index = line_index + 1;
      247 		end;
      248 		else return ("0"b);
      249 	     end;
      250 
      251 	     start = line_index;
      252 	     return ("1"b);
      253 
      254 	end next_word;
      255 
      256 /*  */
      257 /*  This procedure looks for a word in line beginning at start.  The word may have imbedded blanks.
      258*
      259*   *	returns	"1"b	The word was found.
      260*   *			start = index of character following word.
      261*   *	returns	"0"b	The word was not found.
      262*   *			start is unchanged.
      263*   *
      264*   * The procedure skips quoted strings and stops checking if an apostrophy is found
      265*   * indicating the rest of the line is a comment.
      266**/
      267 search_word: proc (start, word) returns (bit (1));
      268 
      269 dcl  start fixed bin (21);
      270 dcl  word char (*);
      271 
      272 dcl  word_length fixed bin (21);
      273 dcl  word_index fixed bin (21);
      274 dcl (i, j) fixed bin (21);
      275 
      276 	     i = start;
      277 	     word_length = length (word);
      278 	     word_index = 1;
      279 
      280 	     do while (i <= line_length);
      281 		if get_char (i, char) then do;
      282 		     if char = substr (word, word_index, 1) then do;
      283 			if word_index = word_length then do;
      284 			     start = i + 1;
      285 			     return ("1"b);
      286 			end;
      287 
      288 			else word_index = word_index + 1;
      289 		     end;
      290 
      291 		     else do;
      292 			word_index = 1;
      293 
      294 			if char = QUOTE then do;
      295 			     j = index (substr (line, i + 1), QUOTE); /* This also covers "" inside a string */
      296 			     if j > 0 then i = i + j;
      297 			     else return ("0"b);
      298 			end;
      299 			else if char = APOSTROPHE then i = line_length; /* omit rest of line */
      300 		     end;
      301 
      302 		     i = i + 1;
      303 		end;
      304 
      305 		else return ("0"b);
      306 	     end;
      307 
      308 	     return ("0"b);
      309 
      310 	end search_word;
      311 
      312 
      313 
      314 /*  */
      315 /*  This procedure finds the next non_blank character on the line.  If the end of the line is
      316*   *  reached "0"b is returned.
      317**/
      318 get_char:	proc (start, char) returns (bit (1));
      319 
      320 dcl  start fixed bin (21);
      321 dcl  char char (1);
      322 
      323 dcl  i fixed bin (21);
      324 
      325 	     if start <= line_length then do;
      326 
      327 		i = verify (substr (line, start), WHITE_SPACE);
      328 
      329 		if i > 0 then do;
      330 		     start = start + i -1;
      331 		     char = substr (line, start, 1);
      332 		     return ("1"b);
      333 		end;
      334 	     end;
      335 
      336 	     start = line_length;
      337 
      338 	     return ("0"b);
      339 
      340 	end get_char;
      341 
      342 /*  */
      343 
      344 /*  This procedure expects a line segment of the form:
      345*   *
      346*   *	[<blanks> <digit>] . . .
      347*   *
      348*   *  It forms a number from the digits and if the number is in the line table, the corresponding
      349*   *  new number is used instead.  If the number is not in the line table or if a number is not
      350*   *  found on the line, the line is copied as is.
      351**/
      352 edit_number: proc (start) returns (bit (1));
      353 
      354 dcl  start fixed bin (21);
      355 
      356 dcl  index_first_digit fixed bin (21);
      357 dcl  num_digits fixed bin;
      358 dcl  i fixed bin (21);
      359 dcl  not_eol bit (1) aligned;
      360 
      361 	     num_digits = 0;
      362 	     i = start;
      363 	     not_eol = get_char (i, char);
      364 
      365 	     do while (not_eol);
      366 
      367 		if index (DIGITS, char) > 0 then do;
      368 
      369 		     num_digits = num_digits + 1;
      370 		     if num_digits <= MAX_NUM_DIGITS then do;
      371 			if num_digits = 1 then index_first_digit = i;
      372 			substr (number_string, num_digits, 1) = char;
      373 			i = i + 1;
      374 			if i > line_length
      375 			then not_eol = "0"b;
      376 			else char = substr (line, i, 1);
      377 		     end;
      378 
      379 		     else return ("0"b);
      380 		end;
      381 
      382 		else do;
      383 		     if num_digits > 0 then do;
      384 			call move (line_start + start -1, index_first_digit - start);
      385 			if store_new_number (^LEADING_ZERO, substr (number_string, 1, num_digits)) then start = i;
      386 			else do;
      387 			     call move (line_start + index_first_digit -1, i - index_first_digit);
      388 			     start = i;
      389 			end;
      390 			return ("1"b);
      391 		     end;
      392 
      393 		     else return ("0"b);
      394 
      395 		end;
      396 
      397 	     end;
      398 
      399 
      400 	     return ("0"b);
      401 
      402 	end edit_number;
      403 
      404 /*  */
      405 
      406 store_multiple_numbers: proc (start, multiple_numbers);
      407 
      408 dcl  start fixed bin (21);
      409 dcl  j fixed bin (21);
      410 dcl  multiple_numbers bit (1);
      411 
      412 	     do while (edit_number (start));
      413 		j = start;
      414 		if get_char (j, char) then do;
      415 		     if char = "," then do;
      416 			call move (line_start + start -1, j - start + 1);
      417 			start = j + 1;
      418 		     end;
      419 		     else return;
      420 		end;
      421 		else return;
      422 
      423 		if ^multiple_numbers then return;
      424 	     end;
      425 
      426 	     return;
      427 
      428 	end store_multiple_numbers;
      429 
      430 /*  */
      431 /* *	This procedure is given a string of digits.  It converts the string into a number and looks
      432*   *	the number up in the line table.  If the number is in the line table, it puts the corresponding
      433*   *	new number in the temporary segment.  If the number is not in the line table, it does nothing.
      434*   *
      435*   *	There are two returns:
      436*   *
      437*   *	     "1"b		The number was found.
      438*   *	     "0"b		The number was not found.
      439**/
      440 store_new_number: proc (leading_zero, string) returns (bit (1));
      441 
      442 dcl  leading_zero bit (1) unal;			/* ON for leading zeros */
      443 dcl  string char (*);
      444 
      445 dcl  number fixed bin (21);
      446 dcl  j fixed bin (21);
      447 dcl  i fixed bin;
      448 
      449 	     number_pic = 0;
      450 	     substr (number_pic, MAX_NUM_DIGITS + 1 - length (string), length (string)) = string;
      451 	     number = number_pic;
      452 
      453 	     do j = 1 to num_lines;
      454 		if number = line_table (j).old_number then do;
      455 		     if leading_zero then do;
      456 
      457 			number_pic = line_table (j).new_number;
      458 			substr (temp_seg, temp_length + 1, MAX_NUM_DIGITS) = number_pic;
      459 			temp_length = temp_length + MAX_NUM_DIGITS;
      460 		     end;
      461 		     else do;
      462 			call ioa_$rsnnl ("^d", number_string, i, line_table (j).new_number);
      463 			substr (temp_seg, temp_length + 1, i) = number_string;
      464 			temp_length = temp_length + i;
      465 		     end;
      466 
      467 		     return ("1"b);
      468 		end;
      469 	     end;
      470 
      471 
      472 	     return ("0"b);
      473 
      474 	end store_new_number;
      475 
      476      end dfast_basic_resequence_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/19/88  1500.7  dfast_basic_resequence_.pl1       >spec>install>MR12.2-1015>dfast_basic_resequence_.pl1
97           1    03/27/82  0439.4  dfast_error_codes.incl.pl1        >ldd>include>dfast_error_codes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
APOSTROPHE                             constant        char(1)                  initial unaligned dcl 80 ref 299
DIGITS                          000000 constant        char(10)                 initial unaligned dcl 77 ref 121 367
LEADING_ZERO                    000012 constant        bit(1)                   initial unaligned dcl 74 set ref 124* 385
MAX_NUM_DIGITS                         constant        fixed bin(17,0)          initial dcl 78 ref 370 450 458 459
NEW_LINE                               constant        char(1)                  initial unaligned dcl 75 ref 118
QUOTE                                  constant        char(1)                  initial unaligned dcl 81 ref 294 295
WHITE_SPACE                            constant        char(2)                  initial unaligned dcl 79 ref 327
char                            000100 automatic       char(1)                  unaligned dcl 61 in procedure
                                                                                  "dfast_basic_resequence_" set ref 243* 245 281*
                                                                                  282 294 299 363* 367 372 376* 414* 415
char                                   parameter       char(1)                  unaligned dcl 321 in procedure "get_char" set ref
                                                                                  318 331*
code                                   parameter       fixed bin(35,0)          dcl 57 set ref 20 116 142*
error_no_nl                            constant        fixed bin(35,0)          initial dcl 1-23 ref 142
i                               000256 automatic       fixed bin(21,0)          dcl 274 in procedure "search_word" set ref 276* 280
                                                                                  281* 284 295 296* 296 299* 302* 302
i                               000300 automatic       fixed bin(21,0)          dcl 358 in procedure "edit_number" set ref 362* 363*
                                                                                  371 373* 373 374 376 385 387 388
i                               000266 automatic       fixed bin(21,0)          dcl 323 in procedure "get_char" set ref 327* 329 330
i                               000230 automatic       fixed bin(21,0)          dcl 171 in procedure "edit_line" set ref 175* 181*
                                                                                  183* 184* 184* 184* 190* 191* 191* 196* 198* 199*
                                                                                  199* 201* 206 208* 210 210
i                               000102 automatic       fixed bin(17,0)          dcl 447 in procedure "store_new_number" set ref 462*
                                                                                  463 464
index                                                  builtin function         dcl 70 ref 118 295 367
index_first_digit               000276 automatic       fixed bin(21,0)          dcl 356 set ref 371* 384 387 387
input_segment                          parameter       char                     unaligned dcl 53 ref 20 114 118 121 124 124 131 156
input_segment_length            000204 automatic       fixed bin(21,0)          dcl 65 set ref 114* 116
ioa_$rsnnl                      000010 constant        entry                    external dcl 95 ref 462
j                               000101 automatic       fixed bin(21,0)          dcl 446 in procedure "store_new_number" set ref 453*
                                                                                  454 457 462*
j                               000310 automatic       fixed bin(21,0)          dcl 409 in procedure "store_multiple_numbers" set
                                                                                  ref 413* 414* 416 417
j                               000257 automatic       fixed bin(21,0)          dcl 274 in procedure "search_word" set ref 295* 296
                                                                                  296
leading_zero                           parameter       bit(1)                   unaligned dcl 442 ref 440 455
length                                                 builtin function         dcl 70 ref 114 238 277 450 450
line                            000101 automatic       varying char(256)        dcl 62 set ref 131* 295 327 331 376
line_index                      000244 automatic       fixed bin(21,0)          dcl 236 set ref 239* 243* 246* 246 251
line_length                     000203 automatic       fixed bin(21,0)          dcl 64 set ref 118* 119 121 129* 129 131 137* 139
                                                                                  210 213* 280 299 325 336 374
line_start                      000202 automatic       fixed bin(21,0)          dcl 63 set ref 113* 116 118 121 124 124 124* 127*
                                                                                  128* 128 131 137* 139* 139 206* 210 213* 384 387
                                                                                  416
line_table                1            based           structure                array level 2 dcl 85
line_table_ptr                         parameter       pointer                  dcl 52 ref 20 453 454 457 462
max_seg_size                           parameter       fixed bin(21,0)          dcl 51 ref 20 156 458 463
multiple_numbers                       parameter       bit(1)                   unaligned dcl 410 in procedure
                                                                                  "store_multiple_numbers" ref 406 423
multiple_numbers                000232 automatic       bit(1)                   unaligned dcl 173 in procedure "edit_line" set ref
                                                                                  177* 197* 208*
new_number                1(18)        based           fixed bin(17,0)          array level 3 packed unaligned dcl 85 set ref 457
                                                                                  462*
not_eol                         000301 automatic       bit(1)                   dcl 359 set ref 363* 365 374*
num_chars                              parameter       fixed bin(21,0)          dcl 153 ref 150 155 156 156 157
num_digits                      000277 automatic       fixed bin(17,0)          dcl 357 set ref 361* 369* 369 370 371 372 383 385
                                                                                  385
num_lines                              based           fixed bin(21,0)          level 2 dcl 85 ref 453
number                          000100 automatic       fixed bin(21,0)          dcl 445 set ref 451* 454
number_length                   000210 automatic       fixed bin(21,0)          dcl 67 set ref 121* 122 124 124 124* 127* 128 129
number_pic                      000212 automatic       picture(5)               unaligned dcl 68 set ref 449* 450* 451 457* 458
number_string                   000205 automatic       char(12)                 unaligned dcl 66 set ref 372* 385 385 462* 463
old_number                1            based           fixed bin(17,0)          array level 3 packed unaligned dcl 85 ref 454
replace_number                  000231 automatic       bit(1)                   unaligned dcl 172 set ref 176* 183* 184* 191* 199*
                                                                                  201* 204
resequence_lines                       parameter       bit(1)                   unaligned dcl 54 ref 20 123
start                                  parameter       fixed bin(21,0)          dcl 408 in procedure "store_multiple_numbers" set
                                                                                  ref 406 412* 413 416 416 417*
start                                  parameter       fixed bin(21,0)          dcl 354 in procedure "edit_number" set ref 352 362
                                                                                  384 384 385* 388*
start                                  parameter       fixed bin(21,0)          dcl 231 in procedure "next_word" set ref 229 239
                                                                                  251*
start                                  parameter       fixed bin(21,0)          dcl 269 in procedure "search_word" set ref 267 276
                                                                                  284*
start                                  parameter       fixed bin(21,0)          dcl 320 in procedure "get_char" set ref 318 325 327
                                                                                  330* 330 331 336*
start                                  parameter       fixed bin(21,0)          dcl 152 in procedure "move" ref 150 156
string                                 parameter       char                     unaligned dcl 443 ref 440 450 450 450
substr                                                 builtin function         dcl 70 set ref 118 121 124 124 131 156* 156 245 282
                                                                                  295 327 331 372* 376 385 385 450* 458* 463*
t                                      based           structure                level 1 dcl 85
temp_length                            parameter       fixed bin(21,0)          dcl 56 set ref 20 156 157* 157 458 459* 459 463 464*
                                                                                  464
temp_ptr                               parameter       pointer                  dcl 55 ref 20 156 458 463
temp_seg                               based           char                     unaligned dcl 91 set ref 156* 458* 463*
translate                                              builtin function         dcl 70 ref 131
verify                                                 builtin function         dcl 70 ref 121 327
word                                   parameter       char                     unaligned dcl 232 in procedure "next_word" ref 229
                                                                                  238 245
word                                   parameter       char                     unaligned dcl 270 in procedure "search_word" ref 267
                                                                                  277 282
word_index                      000243 automatic       fixed bin(21,0)          dcl 235 in procedure "next_word" set ref 241* 245*
word_index                      000255 automatic       fixed bin(21,0)          dcl 273 in procedure "search_word" set ref 278* 282
                                                                                  283 288* 288 292*
word_length                     000242 automatic       fixed bin(21,0)          dcl 234 in procedure "next_word" set ref 238* 241
word_length                     000254 automatic       fixed bin(21,0)          dcl 272 in procedure "search_word" set ref 277* 283

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
error_access_mode                      internal static fixed bin(35,0)          initial dcl 1-33
error_alt_empty                        internal static fixed bin(35,0)          initial dcl 1-3
error_bad_line                         internal static fixed bin(35,0)          initial dcl 1-28
error_bad_name                         internal static fixed bin(35,0)          initial dcl 1-11
error_bad_pathname                     internal static fixed bin(35,0)          initial dcl 1-32
error_bad_rec_len                      internal static fixed bin(35,0)          initial dcl 1-36
error_bad_req                          internal static fixed bin(35,0)          initial dcl 1-12
error_bad_sort                         internal static fixed bin(35,0)          initial dcl 1-24
error_bad_type                         internal static fixed bin(35,0)          initial dcl 1-20
error_block_spec                       internal static fixed bin(35,0)          initial dcl 1-17
error_cur_empty                        internal static fixed bin(35,0)          initial dcl 1-5
error_delimiter_miss                   internal static fixed bin(35,0)          initial dcl 1-34
error_dprint_map                       internal static fixed bin(35,0)          initial dcl 1-41
error_edit_max_num                     internal static fixed bin(35,0)          initial dcl 1-43
error_line_miss                        internal static fixed bin(35,0)          initial dcl 1-26
error_line_order                       internal static fixed bin(35,0)          initial dcl 1-30
error_long_rec                         internal static fixed bin(35,0)          initial dcl 1-8
error_max_args                         internal static fixed bin(35,0)          initial dcl 1-39
error_max_line_number                  internal static fixed bin(35,0)          initial dcl 1-38
error_max_lines                        internal static fixed bin(35,0)          initial dcl 1-31
error_max_num                          internal static fixed bin(35,0)          initial dcl 1-42
error_max_size                         internal static fixed bin(35,0)          initial dcl 1-4
error_name_dup                         internal static fixed bin(35,0)          initial dcl 1-7
error_name_miss                        internal static fixed bin(35,0)          initial dcl 1-14
error_name_sys                         internal static fixed bin(35,0)          initial dcl 1-40
error_no_comp                          internal static fixed bin(35,0)          initial dcl 1-15
error_no_expl                          internal static fixed bin(35,0)          initial dcl 1-10
error_no_main                          internal static fixed bin(35,0)          initial dcl 1-16
error_no_new_line                      internal static fixed bin(35,0)          initial dcl 1-45
error_no_num                           internal static fixed bin(35,0)          initial dcl 1-25
error_no_string                        internal static fixed bin(35,0)          initial dcl 1-29
error_no_suffix                        internal static fixed bin(35,0)          initial dcl 1-22
error_not_saved                        internal static fixed bin(35,0)          initial dcl 1-6
error_obj_nop                          internal static fixed bin(35,0)          initial dcl 1-18
error_request_miss                     internal static fixed bin(35,0)          initial dcl 1-27
error_sav_cur                          internal static fixed bin(35,0)          initial dcl 1-19
error_size_fixed_record                internal static fixed bin(35,0)          initial dcl 1-35
error_string_size                      internal static fixed bin(35,0)          initial dcl 1-37
error_syntax_string                    internal static fixed bin(35,0)          initial dcl 1-13
error_un_num_text                      internal static fixed bin(35,0)          initial dcl 1-44
error_unkn_sys                         internal static fixed bin(35,0)          initial dcl 1-21
error_unknown_arg                      internal static fixed bin(35,0)          initial dcl 1-9

NAMES DECLARED BY EXPLICIT CONTEXT.
dfast_basic_resequence_         000052 constant        entry                    external dcl 20
edit_line                       000262 constant        entry                    internal dcl 169 ref 134
edit_number                     001001 constant        entry                    internal dcl 352 ref 412
get_char                        000731 constant        entry                    internal dcl 318 ref 243 281 363 414
move                            000237 constant        entry                    internal dcl 150 ref 124 127 137 206 210 213 384 387
                                                                                  416
next_word                       000511 constant        entry                    internal dcl 229 ref 181 184 184 190 191 191 196 199
                                                                                  199
search_word                     000600 constant        entry                    internal dcl 267 ref 183 184 198 201
store_multiple_numbers          001200 constant        entry                    internal dcl 406 ref 208
store_new_number                001267 constant        entry                    internal dcl 440 ref 124 385

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2702        2714    2634        2712
Length      3120    2634        12         167      46           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dfast_basic_resequence_             262 external procedure  is an external procedure.  
move                                    internal procedure  shares stack frame of external procedure dfast_basic_resequence_.  
edit_line                               internal procedure  shares stack frame of external procedure dfast_basic_resequence_.  
next_word                               internal procedure  shares stack frame of external procedure dfast_basic_resequence_.  
search_word                             internal procedure  shares stack frame of external procedure dfast_basic_resequence_.  
get_char                                internal procedure  shares stack frame of external procedure dfast_basic_resequence_.  
edit_number                             internal procedure  shares stack frame of external procedure dfast_basic_resequence_.  
store_multiple_numbers                  internal procedure  shares stack frame of external procedure dfast_basic_resequence_.  
store_new_number                     92 internal procedure  is called during a stack extension.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dfast_basic_resequence_  000100 char                        dfast_basic_resequence_
                         000101 line                        dfast_basic_resequence_
                         000202 line_start                  dfast_basic_resequence_
                         000203 line_length                 dfast_basic_resequence_
                         000204 input_segment_length        dfast_basic_resequence_
                         000205 number_string               dfast_basic_resequence_
                         000210 number_length               dfast_basic_resequence_
                         000212 number_pic                  dfast_basic_resequence_
                         000230 i                           edit_line
                         000231 replace_number              edit_line
                         000232 multiple_numbers            edit_line
                         000242 word_length                 next_word
                         000243 word_index                  next_word
                         000244 line_index                  next_word
                         000254 word_length                 search_word
                         000255 word_index                  search_word
                         000256 i                           search_word
                         000257 j                           search_word
                         000266 i                           get_char
                         000276 index_first_digit           edit_number
                         000277 num_digits                  edit_number
                         000300 i                           edit_number
                         000301 not_eol                     edit_number
                         000310 j                           store_multiple_numbers
store_new_number         000100 number                      store_new_number
                         000101 j                           store_new_number
                         000102 i                           store_new_number

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_int_this_desc  return_mac          shorten_stack       ext_entry_desc
int_entry_desc      unpack_picture

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_$rsnnl

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     20 000044       113 000065       114 000067       116 000071       118 000100       119 000120       121 000121
    122 000132       123 000133       124 000140       126 000173       127 000175       128 000177       129 000201
    131 000203       134 000223       135 000225       137 000226       139 000230       140 000232       142 000233
    143 000235       145 000236       150 000237       155 000241       156 000243       157 000257       160 000261
    169 000262       175 000263       176 000265       177 000266       181 000267       183 000277       184 000312
    186 000345       190 000346       191 000356       192 000401       196 000402       197 000412       198 000414
    199 000424       200 000447       201 000450       204 000462       206 000464       208 000471       210 000473
    211 000505       213 000506       215 000510       229 000511       238 000522       239 000523       241 000526
    243 000535       245 000542       246 000556       247 000557       248 000560       249 000566       251 000570
    252 000573       267 000600       276 000611       277 000614       278 000616       280 000620       281 000623
    282 000630       283 000637       284 000641       285 000644       288 000651       289 000652       292 000653
    294 000655       295 000661       296 000675       297 000700       298 000705       299 000706       302 000712
    303 000713       305 000714       306 000722       308 000723       318 000731       325 000733       327 000736
    329 000755       330 000756       331 000761       332 000765       336 000772       338 000774       352 001001
    361 001003       362 001004       363 001006       365 001013       367 001016       369 001027       370 001030
    371 001033       372 001037       373 001043       374 001044       376 001051       377 001054       379 001055
    380 001063       383 001064       384 001066       385 001100       386 001141       387 001142       388 001153
    390 001156       393 001163       397 001171       400 001172       406 001200       412 001202       413 001216
    414 001221       415 001226       416 001232       417 001245       418 001251       419 001252       420 001253
    421 001254       423 001255       424 001264       426 001265       440 001266       449 001302       450 001310
    451 001320       453 001327       454 001341       455 001350       457 001356       458 001373       459 001402
    460 001404       462 001405       463 001442       464 001453       467 001455       469 001463       472 001465


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
