	COMPILATION LISTING OF SEGMENT compile_gdt
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-17_1944.37_Mon_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 compile_gdt: cg: proc;
       12 
       13 /* This routine will compile a graphic device table. */
       14 /* Written June 30, 1973 by C. D. Tavares */
       15 /* Last modified 03/26/75 by CDT to add open and close keywords */
       16 
       17 dcl  cu_$arg_ptr ext entry (fixed bin, pointer, fixed bin, fixed bin),
       18      cu_$arg_count ext entry returns (fixed bin),
       19      ap pointer,
       20      al fixed bin,
       21      arg based (ap) char (al),
       22      com_err_ ext entry options (variable),
       23      code fixed bin;
       24 
       25 dcl  error_table_$translation_failed ext fixed bin (35),
       26      error_table_$inconsistent ext fixed bin (35),
       27      error_table_$badopt ext fixed bin (35);
       28 
       29 dcl  expand_path_ ext entry (pointer, fixed bin, pointer, pointer, fixed bin),
       30      suffixed_name_$make ext entry (char (*), char (*), char (*), fixed bin),
       31      suffixed_name_$new_suffix ext entry (char (*), char (*), char (*), char (*), fixed bin),
       32      get_wdir_ ext entry returns (char (168)),
       33      dirname char (168),
       34      ename char (33) initial (""),
       35      object_ename char (32);
       36 
       37 dcl  tssi_$get_segment entry (char (*), char (*), pointer, pointer, fixed bin),
       38      tssi_$finish_segment ext entry (pointer, fixed bin, bit (36) aligned, pointer, fixed bin),
       39      tssi_$clean_up_segment ext entry (pointer),
       40      cleanup condition;
       41 
       42 dcl  parse_file_$parse_file_init_name ext entry (char (*), char (*), pointer, fixed bin),
       43      parse_file_$parse_file_cur_line ext entry (fixed bin, fixed bin),
       44      parse_file_$parse_file_unset_break ext entry (char (*));
       45 
       46 dcl  acl_ptr pointer initial (null),
       47     (null, hbound, substr, length) builtin;
       48 
       49 dcl  outdx fixed bin,
       50      segp pointer,
       51     (i, j) fixed bin,
       52      semicolon char (1) static options (constant) initial (";"),
       53      colon char (1) static options (constant) initial (":"),
       54      comma char (1) static options (constant) initial (",");
       55 
  1     1 /* -------- BEGIN include file graphic_device_table.incl.pl1 ----------- */
  1     2 
  1     3 dcl  gdt_version_2 fixed bin static initial (2);
  1     4 
  1     5 dcl  gdt_pointer pointer;
  1     6 
  1     7 dcl 1 graphic_device_table aligned based (gdt_pointer),
  1     8      2 device_data aligned,
  1     9       3 version_number fixed bin,
  1    10       3 terminal_name char (32) aligned,
  1    11       3 terminal_type char (4) aligned,
  1    12       3 charsizes (3) float bin,
  1    13       3 message_size fixed bin (35) aligned,
  1    14       3 points_per_inch float bin (63),
  1    15       3 pad (10) fixed bin aligned,
  1    16     2 effector_data (32 : 70) aligned,
  1    17       3 force_alignment aligned,
  1    18         4 (expand, call, ignore, error, flush) bit (1) unaligned;
  1    19 
  1    20 dcl (Reference initial (37),
  1    21      Process_input initial (64),
  1    22      Prepare_for_graphics initial (65),
  1    23      Prepare_for_text initial (66),
  1    24      Expansion initial (67),
  1    25      Open initial (68),
  1    26      Close initial (69),
  1    27      Modes initial (70)) fixed bin static options (constant);
  1    28 
  1    29 /* --------- END include file graphic_device_table.incl.pl1 ------------ */
       56 
       57 
       58 dcl  keywords (32 : 70) static options (constant) char (12) initial
       59     ("not used",
       60      "not used",
       61      "not used",
       62      "not used",
       63      "pause",
       64      "reference",
       65      "increment",
       66      "alter",
       67      "node_begin",
       68      "node_end",
       69      "control",
       70      "display",
       71      "query",
       72      "erase",
       73      "synchronize",
       74      "delete",
       75      "setposition",
       76      "setpoint",
       77      "vector",
       78      "shift",
       79      "point",
       80      "scaling",
       81      "rotation",
       82      "clipping",
       83      "intensity",
       84      "line_type",
       85      "blinking",
       86      "sensitivity",
       87      "color",
       88      "symbol",
       89      "text",
       90      "data",
       91      "input",
       92      "graphic_mode",
       93      "text_mode",
       94      "expansion",
       95      "open",
       96      "close",
       97      "modes");
       98 
       99 dcl  major_keywords (7) char (17) static options (constant) initial
      100     ("Name",
      101      "Type",
      102      "Default",
      103      "Procedure",
      104      "Character_size",
      105      "Message_size",
      106      "Points_per_inch");
      107 
      108 dcl  values (6) char (12) static options (constant) initial
      109     ("pass",
      110      "expand",
      111      "call",
      112      "ignore",
      113      "error",
      114      "flush");
      115 
      116 dcl (device_name, device_type, main_proc) char (32) aligned varying initial (""),
      117      token char (32) aligned varying,
      118      explanation char (80) varying aligned initial (""),
      119      default_flags char (168) aligned varying initial (""),
      120      temp_string char (400) varying;
      121 
      122 dcl  title_string char (100) aligned varying initial
      123     (""" Created by:  compile_gdt, Version of 22 December 1977.
      124 ") static options (constant),
      125 
      126      header_string char (200) aligned varying initial
      127     ("
      128 	name	^a_table
      129 
      130 	segdef	table_start
      131 
      132 table_start:
      133 	dec	^d		""version number
      134 	aci	""^32a""
      135 	aci	""^a""
      136 	dec	^e,^e,^e	""character parameters
      137 	dec	^d		""message size
      138 	dec	^a		""points per inch
      139 	bss	.pad,^d
      140 ") static options (constant),
      141 
      142      flag_string char (40) varying aligned static options (constant) initial
      143     ("	arg	^32a "" ^a"),
      144 
      145      transfer_header char (100) static options (constant) varying aligned initial
      146     ("
      147 	entry	gdt_proc
      148 
      149 gdt_proc:
      150 	ldq	ap|2,*
      151 	sbq	31,dl
      152 	tra	*,ql
      153 "),
      154 
      155      transfer_string char (40) static options (constant) varying aligned initial
      156     ("	tra	<^30a	""^a"),
      157      finishing_string char (8) static options (constant) varying initial ("
      158 	end
      159 "),
      160 
      161      NL char (1) static options (constant) initial ("
      162 ");
      163 
      164 dcl  charsizes float bin dimension (3) initial ((3) -1),
      165      sys_info$max_seg_size ext fixed bin (35),
      166      max_string_size fixed bin (21) initial (sys_info$max_seg_size * 4),
      167      message_size fixed bin (21) initial (sys_info$max_seg_size * 4),
      168      points_per_inch float bin (63) initial (-1e0),
      169      ppi_string char (32);
      170 
      171 dcl 1 effector_table (32 : hbound (keywords, 1)) aligned,
      172     2 flags char (168) aligned varying,
      173     2 proc_name char (32) aligned varying,
      174     2 entry_name char (32) aligned varying;
      175 
      176 dcl (ioa_$ioa_stream, ioa_$rs, ioa_, ioa_$rsnnl) ext entry options (variable),
      177      pf_ptr pointer initial (null),
      178      pf_string char (max_string_size) aligned based (pf_ptr);
      179 
      180 dcl  delete_$path ext entry (char (*), char (*), bit (6), char (*), fixed bin),
      181     (list_switch, no_assembly) bit (1) aligned,
      182      bitstring bit (36) aligned,
      183      alm ext entry options (variable);
      184 
      185 dcl  conversion condition,
      186     (binary, float) builtin;
      187 
      188 
      189 
      190 	call ioa_ ("COMPILE_GDT");			/* crow */
      191 	call cu_$arg_ptr (1, ap, al, code);		/* get name of input file */
      192 	if code ^= 0 then do;			/* not there */
      193 	     call com_err_ (code, "compile_gdt",	/* give advice */
      194 		"Usage is 'compile_gdt segname' where segname.gdt is a graphic device table.");
      195 returner:
      196 	     call clean_up;				/* close out output file */
      197 	     return;
      198 	end;
      199 
      200 	call expand_path_ (ap, al, addr (dirname), addr (ename), code); /* get full pathname of input file */
      201 	if code ^= 0 then call error ((arg), ""b);	/* couldn't */
      202 
      203 	call suffixed_name_$make ((ename), "gdt", ename, code);
      204 	if code ^= 0 then call error ((ename), ""b);
      205 
      206 	list_switch, no_assembly = ""b;
      207 
      208 	do i = 2 to cu_$arg_count ();
      209 	     call cu_$arg_ptr (i, ap, al, code);
      210 	     if substr (arg, 1, 1) ^= "-" then goto badopt;
      211 	     if arg = "-check" | arg = "-ck" then no_assembly = "1"b;
      212 	     else if arg = "-list" | arg = "-ls" then list_switch = "1"b;
      213 	     else do;
      214 badopt:		call com_err_ (error_table_$badopt, "compile_gdt", "");
      215 		goto returner;
      216 	     end;
      217 	end;
      218 
      219 	if list_switch & no_assembly then do;
      220 	     call com_err_ (error_table_$inconsistent, "compile_gdt", "-check, -list");
      221 	     goto returner;
      222 	end;
      223 
      224 	call suffixed_name_$new_suffix (ename, "gdt", "alm", object_ename, code); /* make new name */
      225 	if code ^= 0 then call error ((object_ename), ""b);
      226 
      227 	on cleanup call clean_up;
      228 
      229 	call parse_file_$parse_file_init_name (dirname, ename, pf_ptr, code); /* initiate parsing program */
      230 	if code ^= 0 then call error ((ename), ""b);
      231 
      232 	call tssi_$get_segment (get_wdir_ (), (object_ename), segp, acl_ptr, code); /* create output segment */
      233 	if code ^= 0 then call error ((object_ename), ""b);
      234 
      235 	call parse_file_$parse_file_unset_break ("_.");	/* we want "_." to be valid in a token */
      236 
      237 	outdx = 1;				/* output string index */
      238 	do while ("1"b);				/* "forever" until we encounter non-major keywords */
      239 
      240 	     call get_token;			/* get a keyword */
      241 
      242 	     do i = 1 to hbound (major_keywords, 1) while (major_keywords (i) ^= token); /* look it up */
      243 	     end;
      244 
      245 	     if i > hbound (major_keywords, 1) then goto end_major_keywords; /* not a major keyword, assume minor keyword */
      246 
      247 	     call get_break (colon, crump);
      248 
      249 	     goto major_label (i);			/* process individually */
      250 
      251 major_label (1):					/* Name */
      252 	     if length (device_name) ^= 0 then call error ("Multiple 'Name' statements encountered.", "1"b);
      253 
      254 	     call get_token;			/* get the device name */
      255 
      256 	     device_name = token;
      257 	     call get_break (semicolon, crump);		/* get expected semicolon */
      258 
      259 	     goto major_loop_end;
      260 
      261 major_label (2):					/* Type */
      262 
      263 	     if length (device_type) ^= 0 then call error ("Multiple 'Type' statements encountered.", "1"b);
      264 
      265 	     call get_token;			/* get device type */
      266 
      267 	     device_type = token;
      268 	     call get_break (semicolon, crump);
      269 
      270 	     goto major_loop_end;
      271 
      272 major_label (3):					/* Default */
      273 	     if default_flags ^= "" then call error ("Multiple 'Default' statements encountered.", "1"b);
      274 
      275 more_defaults:
      276 	     call get_token;			/* get a default */
      277 
      278 	     do i = 1 to hbound (values, 1) while (values (i) ^= token); /* find it */
      279 	     end;
      280 
      281 	     if i > hbound (values, 1) then call error ("Unrecognized default '" || token || "'.", "1"b);
      282 
      283 	     if token = "call" then call error ("The 'call' keyword is not allowed as a default.", "1"b);
      284 						/* No real reason, if it is useful, we may take */
      285 						/* this restriction out. */
      286 
      287 	     if length (default_flags) > 0 then default_flags = default_flags || "+";
      288 	     default_flags = default_flags || token;
      289 
      290 	     call get_break (semicolon, more_defaults);	/* if next break not semi, assume it is comma. */
      291 	     goto major_loop_end;
      292 
      293 major_label (4):
      294 	     if length (main_proc) > 0 then call error ("Multiple 'Procedure' statements encountered.", "1"b);
      295 
      296 	     call get_token;
      297 	     main_proc = token;			/* get procedure name */
      298 
      299 	     call get_break (semicolon, crump);
      300 	     goto major_loop_end;
      301 
      302 major_label (5):
      303 	     if charsizes (1) ^= -1 then call error ("Multiple 'Character_size' statements encountered.", "1"b);
      304 
      305 	     on conversion call error ("Non-numeric character in Character_size specification.", "1"b);
      306 
      307 	     do i = 1 to 3;
      308 		call get_token;
      309 		charsizes (i) = float (token);
      310 		if i = 3 then call get_break (semicolon, crump);
      311 		else call get_break (comma, crump);
      312 	     end;
      313 
      314 	     revert conversion;
      315 	     goto major_loop_end;
      316 
      317 major_label (6):
      318 	     if message_size ^= sys_info$max_seg_size * 4
      319 	     then call error ("Multiple 'Message_size' statements encountered.", "1"b);
      320 
      321 	     on conversion call error ("Non-numeric character in message size specification.", "1"b);
      322 
      323 	     call get_token;
      324 	     message_size = binary (token);
      325 
      326 	     call get_break (semicolon, crump);
      327 
      328 	     revert conversion;
      329 	     goto major_loop_end;
      330 
      331 major_label (7):					/* points per inch */
      332 	     if points_per_inch ^= -1 then call error ("Multiple 'Points_per_inch' statements encountered.", "1"b);
      333 
      334 	     on conversion call error ("Non-numeric character in Points_per_inch statement.", "1"b);
      335 
      336 	     call get_token;
      337 	     points_per_inch = float (token);
      338 
      339 	     call get_break (semicolon, crump);
      340 
      341 	     revert conversion;
      342 	     goto major_loop_end;
      343 
      344 major_loop_end:
      345 	end;
      346 
      347 end_major_keywords:
      348 	if length (device_name) = 0 then call error ("Graphic device table contains no 'Name' statement.", ""b);
      349 
      350 	if length (device_type) = 0 then call error ("Graphic device table contains no 'Type' statement.", ""b);
      351 
      352 	if length (main_proc) = 0 then main_proc = device_name || "_util_"; /* again no real reason -- */
      353 						/* a really intelligent graphics processor needs no */
      354 						/* supporting procedure! */
      355 
      356 	if charsizes (1) = -1 then call ioa_ ("Warning:  no 'Character_size' statement encountered.");
      357 	if points_per_inch = -1 then call ioa_ ("Warning:  no 'Points_per_inch' statement encountered.");
      358 
      359 /* Begin to create source segment for ALM assembler. */
      360 
      361 	call put_out ((title_string), length (title_string));
      362 
      363 	call ioa_$rsnnl ("^e", ppi_string, 0, points_per_inch);
      364 	ppi_string = translate (ppi_string, "d", "e");	/* make exponent signify "double precision" */
      365 
      366 	call ioa_$rs (header_string, temp_string, i, device_name, gdt_version_2,
      367 	     device_name, substr (device_type, 1, 4), charsizes (1), charsizes (2), charsizes (3),
      368 	     message_size, ppi_string, hbound (null -> graphic_device_table.pad, 1));
      369 						/* if I don't put null there, compiler says */
      370 						/* gdt_pointer referenced & unset! */
      371 						/* output happy header */
      372 	call put_out (temp_string, i);
      373 
      374 	do i = 1 to hbound (values, 1);
      375 	     bitstring = ""b;
      376 	     if i > 1 then substr (bitstring, 17+i, 1) = "1"b;
      377 	     j = binary (bitstring, 35);
      378 	     call ioa_$rs ("^w", temp_string, 0, j);
      379 	     call ioa_$rs ("	bool	^a,^a", temp_string, j, values (i), substr (temp_string, 7, 6));
      380 	     call put_out (temp_string, j);
      381 	end;
      382 
      383 	call put_out ((NL), 1);
      384 
      385 	effector_table (*).flags = default_flags;	/* set up defaults for all effectors */
      386 	effector_table (*).proc_name = "graphic_dim_";	/* default is error */
      387 	effector_table (*).entry_name = "no_entry";	/* error entry */
      388 
      389 	do while ("1"b);				/* again "forever" until we see "end" */
      390 
      391 	     if token = "end" then do;		/* finish up parse */
      392 		call get_break (semicolon, crump);	/* a parting check on the poor user */
      393 		goto output_info;
      394 	     end;
      395 
      396 	     do i = 32 to hbound (keywords, 1) while (keywords (i) ^= token); /* find the token */
      397 	     end;
      398 
      399 	     if i > hbound (keywords, 1) then call error ("Unrecognized keyword '" || token || "'.", "1"b);
      400 
      401 	     call get_break (colon, crump);
      402 
      403 	     effector_table (i).flags = "";		/* erase defaults, use only ones specified */
      404 more_values:
      405 	     call get_token;			/* get an action for this effector */
      406 
      407 	     do j = 1 to hbound (values, 1) while (values (j) ^= token); /* look it up */
      408 	     end;
      409 
      410 	     if j > hbound (values, 1) then call error ("Unrecognized value '" || token || "'.", "1"b);
      411 
      412 	     if length (effector_table (i).flags) > 0 then
      413 		effector_table (i).flags = effector_table (i).flags || "+";
      414 	     effector_table.flags (i) = effector_table.flags (i) || token;
      415 
      416 	     if token = "call" then do;		/* one more token expected before comma or semi */
      417 		call get_token;
      418 		effector_table (i).proc_name = main_proc; /* construct auxiliary procedure name */
      419 		effector_table (i).entry_name = token;
      420 	     end;
      421 
      422 	     call get_break (semicolon, more_values);	/* if not semi, assume comma */
      423 	     call get_token;			/* prepare for next looparound */
      424 
      425 	end;
      426 
      427 output_info:
      428 	do i = 32 to hbound (keywords, 1);		/* output all effectors in ALM */
      429 	     if length (effector_table (i).flags) = 0 then effector_table (i).flags = values (1);
      430 	     call ioa_$rs (flag_string, temp_string, j, effector_table (i).flags, keywords (i));
      431 						/* format one flag indicator block */
      432 	     call put_out (temp_string, j);		/* put it out */
      433 	end;
      434 
      435 	call ioa_$rs (transfer_header, temp_string, j);
      436 	call put_out (temp_string, j);
      437 
      438 	do i = 32 to hbound (keywords, 1);
      439 	     call ioa_$rs (transfer_string, temp_string, j,
      440 		effector_table (i).proc_name || ">|[" || effector_table (i).entry_name || "]", keywords (i));
      441 						/* format one instruction in transfer vector */
      442 	     call put_out (temp_string, j);
      443 	end;
      444 
      445 	call put_out (finishing_string, length (finishing_string)); /* cap it off */
      446 
      447 	call tssi_$finish_segment (segp, outdx * 9 - 9, "1011"b, acl_ptr, code); /* shine it up */
      448 	revert cleanup;
      449 	if code ^= 0 then call error ((ename), ""b);	/* too bad. after all that. */
      450 
      451 	if no_assembly then return;
      452 
      453 	if list_switch then call alm (object_ename, "-list");
      454 	else call alm (object_ename);
      455 
      456 	call delete_$path (get_wdir_ (), object_ename, "100111"b, "compile_gdt", code);
      457 	if code ^= 0 then call error ("Cannot delete " || object_ename, ""b);
      458 
      459 	return;
      460 
      461 crump:						/* here is where errors go */
      462 	call error (explanation, "1"b);		/* confess */
      463 
      464 
      465 clean_up:	proc;
      466 
      467 	     if acl_ptr ^= null then call tssi_$clean_up_segment (acl_ptr);
      468 
      469 	end;
      470 
      471 
      472 error:	proc (explanation, print_line);		/* the snitcher */
      473 
      474 dcl  explanation char (*) varying aligned parameter,
      475      print_line bit (1) aligned parameter;
      476 
      477 dcl (ci, cc) fixed bin;
      478 
      479 	     call com_err_ (code, "compile_gdt", explanation); /* report the error */
      480 
      481 	     if print_line then do;			/* print out the source line of input file */
      482 		call parse_file_$parse_file_cur_line (ci, cc);
      483 		call ioa_$ioa_stream ("error_output", "^-SOURCE:  ^a", substr (pf_string, ci, cc));
      484 	     end;
      485 	     call com_err_ (error_table_$translation_failed, "compile_gdt", ""); /* one chance is all we give */
      486 	     goto returner;
      487 	end;
      488 
      489 
      490 get_token: proc;					/* gets tokens from input file */
      491 
      492 dcl  parse_file_$parse_file_ptr ext entry (pointer, fixed bin, fixed bin, fixed bin),
      493      tokenp pointer,
      494      b_token char (count) based (tokenp),
      495      count fixed bin,
      496      break fixed bin,
      497      eof fixed bin;
      498 
      499 dcl (space initial (" "),
      500      tab initial ("	"),
      501      nl initial ("
      502 ")) char (1) aligned static options (constant);
      503 
      504 loop:
      505 	     call parse_file_$parse_file_ptr (tokenp, count, break, eof); /* get a token */
      506 
      507 	     token = b_token;
      508 
      509 	     if eof > 0 then call error ("Unexpected end of file encountered", ""b); /* oops */
      510 
      511 	     if break > 0 then if token = space then goto loop; /* harmless */
      512 		else if token = tab then goto loop;	/* harmless */
      513 		else if token = nl then goto loop;	/* harmless */
      514 		else call error ("Illegal character " || token || " encountered", "1"b); /* yell */
      515 
      516 	     return;
      517 
      518 get_break:     entry (char, errlab);			/* gets break tokens, goes to errlab if fails */
      519 
      520 dcl  char char (1),
      521      errlab label;
      522 
      523 bloop:
      524 	     call parse_file_$parse_file_ptr (tokenp, count, break, eof); /* get a token */
      525 
      526 	     if eof > 0 then call error ("Unexpected end of file encountered", ""b); /* oops */
      527 
      528 	     if break > 0 then if b_token = space then goto bloop; /* harmless */
      529 		else if b_token = tab then goto bloop;	/* harmless */
      530 		else if b_token = nl then goto bloop;	/* harmless */
      531 		else if b_token = char then return;	/* it's the one we wanted */
      532 		else do;				/* it's not */
      533 bad_break:
      534 		     explanation = "Illegal token " || b_token || " found instead of expected token " || char;
      535 		     goto errlab;			/* we don't call error, because */
      536 						/* it may not be an error condition. */
      537 		end;
      538 
      539 	     else goto bad_break;			/* wasn't a break token */
      540 
      541 	end;
      542 
      543 put_out:	proc (string, string_len);			/* writes string into output file */
      544 
      545 dcl  string char (*) varying,
      546      string_len fixed bin;
      547 
      548 dcl  outstring char (65536) based (segp);
      549 
      550 	     substr (outstring, outdx, string_len) = string; /* copy into output file */
      551 	     outdx = outdx + string_len;
      552 
      553 	     return;
      554 	end;
      555 
      556      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/17/00  1944.3  compile_gdt.pl1                   >udd>sm>ds>w>ml>compile_gdt.pl1
56           1    03/27/82  0539.2  graphic_device_table.incl.pl1     >ldd>incl>graphic_device_table.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NL                              005776 constant        char(1)                  initial packed unaligned dcl 122 ref 383
acl_ptr                         000206 automatic       pointer                  initial dcl 46 set ref 46* 232* 447* 467 467*
al                              000102 automatic       fixed bin(17,0)          dcl 17 set ref 191* 200* 201 209* 210 211 211 212
                                                                                  212
alm                             000066 constant        entry                    external dcl 180 ref 453 454
ap                              000100 automatic       pointer                  dcl 17 set ref 191* 200* 201 209* 210 211 211 212
                                                                                  212
arg                                    based           char                     packed unaligned dcl 17 ref 201 210 211 211 212 212
b_token                                based           char                     packed unaligned dcl 492 ref 507 528 529 530 531 533
binary                                                 builtin function         dcl 185 ref 324 377
bitstring                       000552 automatic       bit(36)                  dcl 180 set ref 375* 376* 377
break                           000603 automatic       fixed bin(17,0)          dcl 492 set ref 504* 511 523* 528
cc                              000101 automatic       fixed bin(17,0)          dcl 477 set ref 482* 483 483
char                                   parameter       char(1)                  packed unaligned dcl 520 ref 518 531 533
charsizes                       000527 automatic       float bin(27)            initial array dcl 164 set ref 164* 164* 164* 302
                                                                                  309* 356 366* 366* 366*
ci                              000100 automatic       fixed bin(17,0)          dcl 477 set ref 482* 483 483
cleanup                         000200 stack reference condition                dcl 37 ref 227 448
code                            000103 automatic       fixed bin(17,0)          dcl 17 set ref 191* 192 193* 200* 201 203* 204 209*
                                                                                  224* 225 229* 230 232* 233 447* 449 456* 457 479*
colon                           000455 constant        char(1)                  initial packed unaligned dcl 49 set ref 247* 401*
com_err_                        000016 constant        entry                    external dcl 17 ref 193 214 220 479 485
comma                           000454 constant        char(1)                  initial packed unaligned dcl 49 set ref 311*
conversion                      000554 stack reference condition                dcl 185 ref 305 314 321 328 334 341
count                           000602 automatic       fixed bin(17,0)          dcl 492 set ref 504* 507 523* 528 529 530 531 533
cu_$arg_count                   000014 constant        entry                    external dcl 17 ref 208
cu_$arg_ptr                     000012 constant        entry                    external dcl 17 ref 191 209
default_flags                   000307 automatic       varying char(168)        initial dcl 116 set ref 116* 272 287 287* 287 288*
                                                                                  288 385
delete_$path                    000064 constant        entry                    external dcl 180 ref 456
device_data                            based           structure                level 2 dcl 1-7
device_name                     000216 automatic       varying char(32)         initial dcl 116 set ref 116* 251 256* 347 352 366*
                                                                                  366*
device_type                     000227 automatic       varying char(32)         initial dcl 116 set ref 116* 261 267* 350 366 366
dirname                         000104 automatic       char(168)                packed unaligned dcl 29 set ref 200 200 229*
effector_table                  000546 automatic       structure                array level 1 dcl 171
ename                           000156 automatic       char(33)                 initial packed unaligned dcl 29 set ref 29* 200 200
                                                                                  203 203* 204 224* 229* 230 449
entry_name               64     000546 automatic       varying char(32)         array level 2 dcl 171 set ref 387* 419* 439
eof                             000604 automatic       fixed bin(17,0)          dcl 492 set ref 504* 509 523* 526
errlab                                 parameter       label variable           dcl 520 ref 518 535
error_table_$badopt             000024 external static fixed bin(35,0)          dcl 25 set ref 214*
error_table_$inconsistent       000022 external static fixed bin(35,0)          dcl 25 set ref 220*
error_table_$translation_failed 000020 external static fixed bin(35,0)          dcl 25 set ref 485*
expand_path_                    000026 constant        entry                    external dcl 29 ref 200
explanation                     000262 automatic       varying char(80)         initial dcl 116 in procedure "cg" set ref 116* 461*
                                                                                  533*
explanation                            parameter       varying char             dcl 474 in procedure "error" set ref 472 479*
finishing_string                000007 constant        varying char(8)          initial dcl 122 set ref 445* 445 445
flag_string                     000057 constant        varying char(40)         initial dcl 122 set ref 430*
flags                           000546 automatic       varying char(168)        array level 2 dcl 171 set ref 385* 403* 412 412* 412
                                                                                  414* 414 429 429* 430*
float                                                  builtin function         dcl 185 ref 309 337
gdt_version_2                   000010 internal static fixed bin(17,0)          initial dcl 1-3 set ref 366*
get_wdir_                       000034 constant        entry                    external dcl 29 ref 232 232 456 456
graphic_device_table                   based           structure                level 1 dcl 1-7
hbound                                                 builtin function         dcl 46 ref 171 242 245 278 281 366 366 374 396 399
                                                                                  407 410 427 438
header_string                   000072 constant        varying char(200)        initial dcl 122 set ref 366*
i                               000214 automatic       fixed bin(17,0)          dcl 49 set ref 208* 209* 242* 242* 245 249 278* 278*
                                                                                  281 307* 309 310* 366* 372* 374* 376 376 379* 396*
                                                                                  396* 399 403 412 412 412 414 414 418 419 427* 429
                                                                                  429 430 430* 438* 439 439 439*
ioa_                            000060 constant        entry                    external dcl 176 ref 190 356 357
ioa_$ioa_stream                 000054 constant        entry                    external dcl 176 ref 483
ioa_$rs                         000056 constant        entry                    external dcl 176 ref 366 378 379 430 435 439
ioa_$rsnnl                      000062 constant        entry                    external dcl 176 ref 363
j                               000215 automatic       fixed bin(17,0)          dcl 49 set ref 377* 378* 379* 380* 407* 407* 410
                                                                                  430* 432* 435* 436* 439* 442*
keywords                        000267 constant        char(12)                 initial array packed unaligned dcl 58 set ref 171
                                                                                  396 396 399 427 430* 438 439*
length                                                 builtin function         dcl 46 ref 251 261 287 293 347 350 352 361 361 412
                                                                                  429 445 445
list_switch                     000550 automatic       bit(1)                   dcl 180 set ref 206* 212* 219 453
main_proc                       000240 automatic       varying char(32)         initial dcl 116 set ref 116* 293 297* 352 352* 418
major_keywords                  000231 constant        char(17)                 initial array packed unaligned dcl 99 ref 242 242
                                                                                  245
max_string_size                 000532 automatic       fixed bin(21,0)          initial dcl 164 set ref 164* 483 483
message_size                    000533 automatic       fixed bin(21,0)          initial dcl 164 set ref 164* 317 324* 366*
nl                              005776 constant        char(1)                  initial dcl 499 ref 513 530
no_assembly                     000551 automatic       bit(1)                   dcl 180 set ref 206* 211* 219 451
null                                                   builtin function         dcl 46 ref 46 176 366 366 467
object_ename                    000167 automatic       char(32)                 packed unaligned dcl 29 set ref 224* 225 232 233
                                                                                  453* 454* 456* 457
outdx                           000210 automatic       fixed bin(17,0)          dcl 49 set ref 237* 447 550 551* 551
outstring                              based           char(65536)              packed unaligned dcl 548 set ref 550*
pad                      20            based           fixed bin(17,0)          array level 3 dcl 1-7 ref 366 366
parse_file_$parse_file_cur_line 000046 constant        entry                    external dcl 42 ref 482
parse_file_$parse_file_init_name
                                000044 constant        entry                    external dcl 42 ref 229
parse_file_$parse_file_ptr      000070 constant        entry                    external dcl 492 ref 504 523
parse_file_$parse_file_unset_break
                                000050 constant        entry                    external dcl 42 ref 235
pf_ptr                          000546 automatic       pointer                  initial dcl 176 set ref 176* 229* 483 483
pf_string                              based           char                     dcl 176 ref 483 483
points_per_inch                 000534 automatic       float bin(63)            initial dcl 164 set ref 164* 331 337* 357 363*
ppi_string                      000536 automatic       char(32)                 packed unaligned dcl 164 set ref 363* 364* 364 366*
print_line                             parameter       bit(1)                   dcl 474 ref 472 481
proc_name                53     000546 automatic       varying char(32)         array level 2 dcl 171 set ref 386* 418* 439
segp                            000212 automatic       pointer                  dcl 49 set ref 232* 447* 550
semicolon                       000456 constant        char(1)                  initial packed unaligned dcl 49 set ref 257* 268*
                                                                                  290* 299* 310* 326* 339* 392* 422*
space                           006000 constant        char(1)                  initial dcl 499 ref 511 528
string                                 parameter       varying char             dcl 545 ref 543 550
string_len                             parameter       fixed bin(17,0)          dcl 545 ref 543 550 551
substr                                                 builtin function         dcl 46 set ref 210 366 366 376* 379 379 483 483 550*
suffixed_name_$make             000030 constant        entry                    external dcl 29 ref 203
suffixed_name_$new_suffix       000032 constant        entry                    external dcl 29 ref 224
sys_info$max_seg_size           000052 external static fixed bin(35,0)          dcl 164 ref 164 164 317
tab                             005777 constant        char(1)                  initial dcl 499 ref 512 529
temp_string                     000362 automatic       varying char(400)        dcl 116 set ref 366* 372* 378* 379* 379 379 380*
                                                                                  430* 432* 435* 436* 439* 442*
title_string                    000155 constant        varying char(100)        initial dcl 122 ref 361 361 361
token                           000251 automatic       varying char(32)         dcl 116 set ref 242 256 267 278 281 283 288 297 309
                                                                                  324 337 391 396 399 407 410 414 416 419 507* 511
                                                                                  512 513 514
tokenp                          000600 automatic       pointer                  dcl 492 set ref 504* 507 523* 528 529 530 531 533
transfer_header                 000025 constant        varying char(100)        initial dcl 122 set ref 435*
transfer_string                 000012 constant        varying char(40)         initial dcl 122 set ref 439*
tssi_$clean_up_segment          000042 constant        entry                    external dcl 37 ref 467
tssi_$finish_segment            000040 constant        entry                    external dcl 37 ref 447
tssi_$get_segment               000036 constant        entry                    external dcl 37 ref 232
values                          000207 constant        char(12)                 initial array packed unaligned dcl 108 set ref 278
                                                                                  278 281 374 379* 407 407 410 429

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Close                                  internal static fixed bin(17,0)          initial dcl 1-20
Expansion                              internal static fixed bin(17,0)          initial dcl 1-20
Modes                                  internal static fixed bin(17,0)          initial dcl 1-20
Open                                   internal static fixed bin(17,0)          initial dcl 1-20
Prepare_for_graphics                   internal static fixed bin(17,0)          initial dcl 1-20
Prepare_for_text                       internal static fixed bin(17,0)          initial dcl 1-20
Process_input                          internal static fixed bin(17,0)          initial dcl 1-20
Reference                              internal static fixed bin(17,0)          initial dcl 1-20
gdt_pointer                            automatic       pointer                  dcl 1-5

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_break                       005452 constant        label                    dcl 533 ref 528
badopt                          001632 constant        label                    dcl 214 ref 210
bloop                           005361 constant        label                    dcl 523 ref 528 529 530
cg                              001275 constant        entry                    external dcl 11
clean_up                        005013 constant        entry                    internal dcl 465 ref 195 227
compile_gdt                     001305 constant        entry                    external dcl 11
crump                           004773 constant        label                    dcl 461 ref 247 247 257 257 268 268 299 299 310 310
                                                                                  311 311 326 326 339 339 392 392 401 401
end_major_keywords              003200 constant        label                    dcl 347 ref 245
error                           005035 constant        entry                    internal dcl 472 ref 201 204 225 230 233 251 261 272
                                                                                  281 283 293 302 305 317 321 331 334 347 350 399
                                                                                  410 449 457 461 509 514 526
get_break                       005357 constant        entry                    internal dcl 518 ref 247 257 268 290 299 310 311 326
                                                                                  339 392 401 422
get_token                       005212 constant        entry                    internal dcl 490 ref 240 254 265 275 296 308 323 336
                                                                                  404 417 423
loop                            005213 constant        label                    dcl 504 ref 511 512 513
major_label                     000000 constant        label                    array(7) dcl 251 ref 249
major_loop_end                  003200 constant        label                    dcl 344 ref 259 270 291 300 315 329 342
more_defaults                   002367 constant        label                    dcl 275 ref 290 290
more_values                     004105 constant        label                    dcl 404 ref 422 422
output_info                     004266 constant        label                    dcl 427 ref 393
put_out                         005523 constant        entry                    internal dcl 543 ref 361 372 380 383 432 436 442 445
returner                        001402 constant        label                    dcl 195 ref 215 221 486

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 200 200 200 200
translate                                              builtin function         ref 364

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6362        6454    6005        6372
Length      6732    6005        72         241     355           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cg                                  708 external procedure  is an external procedure.  
on unit on line 227                  64 on unit               
on unit on line 305                  92 on unit               
on unit on line 321                  92 on unit               
on unit on line 334                  92 on unit               
clean_up                             68 internal procedure  is called by several nonquick procedures.  
error                               102 internal procedure  is called during a stack extension.  
get_token                               internal procedure  shares stack frame of external procedure cg.  
put_out                              65 internal procedure  is called during a stack extension.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 gdt_version_2               cg

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cg                       000100 ap                          cg
                         000102 al                          cg
                         000103 code                        cg
                         000104 dirname                     cg
                         000156 ename                       cg
                         000167 object_ename                cg
                         000206 acl_ptr                     cg
                         000210 outdx                       cg
                         000212 segp                        cg
                         000214 i                           cg
                         000215 j                           cg
                         000216 device_name                 cg
                         000227 device_type                 cg
                         000240 main_proc                   cg
                         000251 token                       cg
                         000262 explanation                 cg
                         000307 default_flags               cg
                         000362 temp_string                 cg
                         000527 charsizes                   cg
                         000532 max_string_size             cg
                         000533 message_size                cg
                         000534 points_per_inch             cg
                         000536 ppi_string                  cg
                         000546 effector_table              cg
                         000546 pf_ptr                      cg
                         000550 list_switch                 cg
                         000551 no_assembly                 cg
                         000552 bitstring                   cg
                         000600 tokenp                      get_token
                         000602 count                       get_token
                         000603 break                       get_token
                         000604 eof                         get_token
error                    000100 ci                          error
                         000101 cc                          error

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     realloc_char_temp   cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other_desc call_int_other      return_mac          tra_ext_1           tra_ext_2
alloc_auto_adj      enable_op           shorten_stack       ext_entry           int_entry           int_entry_desc
real_to_real_round_ any_to_any_round_   any_to_any_truncate_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
alm                           com_err_                      cu_$arg_count                 cu_$arg_ptr
delete_$path                  expand_path_                  get_wdir_                     ioa_
ioa_$ioa_stream               ioa_$rs                       ioa_$rsnnl
parse_file_$parse_file_cur_line                             parse_file_$parse_file_init_name
parse_file_$parse_file_ptr    parse_file_$parse_file_unset_break                          suffixed_name_$make
suffixed_name_$new_suffix     tssi_$clean_up_segment        tssi_$finish_segment          tssi_$get_segment

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$inconsistent     error_table_$translation_failed
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     29 001224        46 001227       116 001231       164 001236       171 001260       176 001266       430 001270
     11 001274       190 001313       191 001331       192 001350       193 001352       195 001402       197 001406
    200 001407       201 001432       203 001462       204 001515       206 001542       208 001544       209 001561
    210 001576       211 001603       212 001617       214 001632       215 001657       217 001660       219 001662
    220 001666       221 001721       224 001722       225 001756       227 002003       229 002025       230 002052
    232 002077       233 002141       235 002166       237 002201       238 002203       240 002204       242 002205
    243 002221       245 002223       247 002226       249 002233       251 002235       254 002262       256 002263
    257 002270       259 002275       261 002276       265 002323       267 002324       268 002331       270 002336
    272 002337       275 002367       278 002370       279 002404       281 002406       283 002457       287 002510
    288 002521       290 002533       291 002540       293 002541       296 002566       297 002567       299 002574
    300 002601       302 002602       305 002630       307 002671       308 002677       309 002700       310 002721
    311 002732       312 002737       314 002741       315 002742       317 002743       321 002776       323 003037
    324 003040       326 003052       328 003057       329 003060       331 003061       334 003107       336 003150
    337 003151       339 003171       341 003176       342 003177       347 003200       350 003225       352 003252
    356 003276       357 003316       361 003335       363 003361       364 003412       366 003423       372 003516
    374 003532       375 003537       376 003540       377 003546       378 003551       379 003601       380 003645
    381 003661       383 003663       385 003704       386 003730       387 003750       389 003767       391 003770
    392 003775       393 004002       396 004003       397 004020       399 004022       401 004073       403 004101
    404 004105       407 004106       408 004122       410 004124       412 004175       414 004215       416 004231
    417 004236       418 004237       419 004251       422 004257       423 004264       425 004265       427 004266
    429 004273       430 004307       432 004343       433 004357       435 004361       436 004402       438 004416
    439 004423       442 004522       443 004537       445 004541       447 004557       448 004604       449 004605
    451 004632       453 004634       454 004656       456 004667       457 004735       459 004771       461 004773
    556 005011       465 005012       467 005020       469 005033       472 005034       479 005050       481 005076
    482 005102       483 005113       484 005161       485 005162       486 005207       490 005212       504 005213
    507 005230       509 005241       511 005266       512 005275       513 005302       514 005307       516 005355
    518 005357       523 005361       526 005376       528 005423       529 005433       530 005437       531 005443
    533 005452       535 005517       543 005522       550 005536       551 005550       553 005552


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
