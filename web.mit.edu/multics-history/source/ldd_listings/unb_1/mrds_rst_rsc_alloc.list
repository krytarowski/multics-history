	COMPILATION LISTING OF SEGMENT mrds_rst_rsc_alloc
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1347.6 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 /* HISTORY:
       19*
       20*   originally written by jim gray - - February 1979
       21*
       22*   82-06-28 Roger Lackey: Removed code for struct type 52 thru 58
       23*   chnaged the way type 25 was handled since no longer used.
       24*
       25**/
       26 
       27 mrds_rst_rsc_alloc: procedure (rsc_ptr, struct_type, struct_ptr);
       28 
       29 /*
       30*   .                        BEGIN_DESCRIPTION
       31*   this routine does all allocations in working storage known as "rsc"
       32*   for restructure control. modules that create, modify, or display
       33*   the mrds database model all use this working storage, which is structured
       34*   as a directory with a common segment, and several segments acting as
       35*   extensible areas. allocations are made in the segments according to
       36*   type of structure and the policy as defined by the logic of this module.
       37*   two additional entries are $variable, and $free for variable
       38*   length allocations, and freeing of previously allocated space.
       39*   .                        END_DESCRIPTION
       40**/
       41 
       42 /* PARAMETERS:
       43*
       44*   normal entry ===
       45*   rsc_ptr - - (input) pointer to the common segment under the working
       46*   storage directory created under the user specified directory
       47*
       48*   struct_type - - (input) fixed binary number that indicates which structure
       49*   is to be allocated, and according to the internal policy, where it will be allocated
       50*   as well. the include file mrds_rst_struct_types.incl.pl1 gives the constants
       51*   that are used for this purpose.
       52*
       53*   struct_ptr - - (output) pointer to the newly allocated structure of the type
       54*   given by struct_type.
       55*
       56*   $variable entry ===
       57*   struct_size - - (input) a fixed binary (35) number, in addition to those above,
       58*   that gives the length for the current allocation of this
       59*   structure type that has a variable length.
       60*
       61*   $free entry ===
       62*   same as the normal entry, except struct_ptr is an input parameter,
       63*   and it points to the allocation instance to be freed
       64**/
       65 
       66 /* normal allocation entry point */
       67 
       68 	FREE = OFF;
       69 	goto common;
       70 
       71 
       72 /* freeing entry point */
       73 
       74 mrds_rst_rsc_alloc$free: entry (rsc_ptr, struct_type, struct_ptr);
       75 
       76 	FREE = ON;
       77 
       78 /* determine if we are freeing a variable length allocation */
       79 
       80 	if struct_type <= hbound (case, 1) then
       81 	     goto common;
       82 	else goto var_common;
       83 
       84 
       85 common:
       86 
       87 	if ^rsc.trace_sw then ;
       88 	else call trace (ON);			/* input call */
       89 
       90 /* check that the encoding for structure type is within the legal range */
       91 
       92 	if struct_type < lbound (case, 1) | struct_type > hbound (case, 1) then
       93 	     call bad_struct_code ();
       94 
       95 	else do;
       96 
       97 /* good structure type code, go to the allocate that it indicates for the
       98*   given structure to be allocated, and the area in which it will reside */
       99 
      100 		goto case (struct_type);
      101 
      102 /* parse info structures */
      103 
      104 case (1):
      105 
      106 		if FREE then
      107 		     free struct_ptr -> domain in (parse_info_area);
      108 		else allocate domain set (struct_ptr) in (parse_info_area);
      109 		goto return_label;
      110 
      111 case (2):
      112 
      113 		if FREE then
      114 		     free struct_ptr -> attribute_domain in (parse_info_area);
      115 		else allocate attribute_domain set (struct_ptr) in (parse_info_area);
      116 		goto return_label;
      117 
      118 case (3):
      119 
      120 		if FREE then
      121 		     free struct_ptr -> relation in (parse_info_area);
      122 		else allocate relation set (struct_ptr) in (parse_info_area);
      123 		goto return_label;
      124 
      125 case (4):
      126 
      127 		if FREE then
      128 		     free struct_ptr -> attribute in (parse_info_area);
      129 		else allocate attribute set (struct_ptr) in (parse_info_area);
      130 		goto return_label;
      131 
      132 case (5):
      133 
      134 		if FREE then
      135 		     free struct_ptr -> file in (parse_info_area);
      136 		else allocate file set (struct_ptr) in (parse_info_area);
      137 		goto return_label;
      138 
      139 case (6):
      140 
      141 		if FREE then
      142 		     free struct_ptr -> item in (parse_info_area);
      143 		else allocate item set (struct_ptr) in (parse_info_area);
      144 		goto return_label;
      145 
      146 case (7):
      147 
      148 		if FREE then
      149 		     free struct_ptr -> link in (parse_info_area);
      150 		else allocate link set (struct_ptr) in (parse_info_area);
      151 		goto return_label;
      152 
      153 case (8):
      154 
      155 		if FREE then
      156 		     free struct_ptr -> foreign_key in (parse_info_area);
      157 		else allocate foreign_key set (struct_ptr) in (parse_info_area);
      158 		goto return_label;
      159 
      160 case (9):
      161 
      162 		if FREE then
      163 		     free struct_ptr -> children in (parse_info_area);
      164 		else allocate children set (struct_ptr) in (parse_info_area);
      165 		goto return_label;
      166 
      167 case (10):
      168 
      169 		if FREE then
      170 		     free struct_ptr -> rel_index in (parse_info_area);
      171 		else allocate rel_index set (struct_ptr) in (parse_info_area);
      172 		goto return_label;
      173 
      174 case (11):
      175 
      176 		if FREE then
      177 		     free struct_ptr -> delete_name in (parse_info_area);
      178 		else allocate delete_name set (struct_ptr) in (parse_info_area);
      179 		goto return_label;
      180 
      181 case (12):
      182 
      183 		if FREE then
      184 		     free struct_ptr -> dom_list in (parse_info_area);
      185 		else allocate dom_list set (struct_ptr) in (parse_info_area);
      186 		goto return_label;
      187 
      188 /* semantic structures */
      189 
      190 case (13):
      191 
      192 		if FREE then
      193 		     free struct_ptr -> directive in (static_info_area);
      194 		else allocate directive set (struct_ptr) in (static_info_area);
      195 		goto return_label;
      196 
      197 case (14):
      198 
      199 		if FREE then
      200 		     free struct_ptr -> stmt in (static_info_area);
      201 		else allocate stmt set (struct_ptr) in (static_info_area);
      202 		goto return_label;
      203 
      204 /* parsing structures */
      205 
      206 case (15):
      207 
      208 		if FREE then
      209 		     free struct_ptr -> lex_stack in (static_info_area);
      210 		else allocate lex_stack set (struct_ptr) in (static_info_area);
      211 		goto return_label;
      212 
      213 case (16):
      214 
      215 		if FREE then
      216 		     free struct_ptr -> p_struct in (static_info_area);
      217 		else allocate p_struct set (struct_ptr) in (static_info_area);
      218 		goto return_label;
      219 
      220 case (17):
      221 
      222 		if FREE then
      223 		     free struct_ptr -> cur_lex_top in (static_info_area);
      224 		else allocate cur_lex_top set (struct_ptr) in (static_info_area);
      225 		goto return_label;
      226 
      227 case (18):
      228 
      229 		if FREE then
      230 		     free struct_ptr -> token in (static_info_area);
      231 		else allocate token set (struct_ptr) in (static_info_area);
      232 		goto return_label;
      233 
      234 case (19):
      235 
      236 		if FREE then
      237 		     free struct_ptr -> output_text in (static_info_area);
      238 		else allocate output_text set (struct_ptr) in (static_info_area);
      239 		goto return_label;
      240 
      241 /* global list structures */
      242 
      243 case (20):
      244 
      245 		if FREE then
      246 		     free struct_ptr -> gl in (global_list_area);
      247 		else allocate gl set (struct_ptr) in (global_list_area);
      248 		goto return_label;
      249 
      250 case (21):
      251 
      252 		if FREE then
      253 		     free struct_ptr -> sl in (sublist_area);
      254 		else allocate sl set (struct_ptr) in (sublist_area);
      255 		goto return_label;
      256 
      257 case (22):
      258 
      259 		if FREE then
      260 		     free struct_ptr -> seg_info in (seg_info_area);
      261 		else allocate seg_info set (struct_ptr) in (seg_info_area);
      262 		goto return_label;
      263 
      264 case (23):
      265 
      266 		if FREE then
      267 		     free struct_ptr -> node in (tree_node_area);
      268 		else allocate node set (struct_ptr) in (tree_node_area);
      269 		goto return_label;
      270 
      271 /* other structures */
      272 
      273 case (24):
      274 
      275 		if FREE then
      276 		     free struct_ptr -> saved_child_count in (other_area);
      277 		else allocate saved_child_count set (struct_ptr) in (other_area);
      278 		goto return_label;
      279 
      280 case (25):
      281 
      282 		if FREE then
      283 		     call bad_struct_code ();		/* No longer implemented */
      284 		else call bad_struct_code ();		/* No longer implemented */
      285 		goto return_label;
      286 
      287 
      288 	     end;
      289 
      290 mrds_rst_rsc_alloc$variable: entry (rsc_ptr, struct_type, struct_size, struct_ptr);
      291 
      292 /* entry to handle structures whose length is variable */
      293 
      294 	FREE = OFF;
      295 
      296 var_common:
      297 
      298 	if ^rsc.trace_sw then ;
      299 	else call trace (ON);			/* input call */
      300 
      301 	if struct_type < lbound (var_case, 1) | struct_type > hbound (var_case, 1) then
      302 	     call bad_struct_code ();
      303 	else if struct_size < 1 then
      304 	     call bad_struct_size ();
      305 
      306 
      307 /* good encoding and size given, go allocate the given structure
      308*   with the specified size, and place it according to area policy */
      309 
      310 	else do;
      311 
      312 		goto var_case (struct_type);
      313 
      314 var_case (50):
      315 
      316 		if FREE then
      317 		     free struct_ptr -> fixup_token in (variable_length_area);
      318 		else do;
      319 			token_length = struct_size;
      320 			allocate fixup_token set (struct_ptr) in (variable_length_area);
      321 		     end;
      322 		goto return_label;
      323 
      324 var_case (51):
      325 
      326 		if FREE then
      327 		     free struct_ptr -> string_source in (variable_length_area);
      328 		else do;
      329 			source_size = struct_size;
      330 			allocate string_source set (struct_ptr) in (variable_length_area);
      331 		     end;
      332 		goto return_label;
      333 
      334 	     end;
      335 
      336 return_label:
      337 
      338 	if ^rsc.trace_sw then ;
      339 	else call trace (OFF);			/* output call */
      340 
      341 
      342 	return;
      343 
      344 bad_struct_code: procedure ();
      345 
      346 /* report bad structure type encoding error */
      347 
      348 	call ioa_$rs ("^a ^d ^a", message, message_length,
      349 	     "LOGIC ERROR in mrds_rst_rsc_alloc,", struct_type, "is an invalid code for structure type.");
      350 	call mrds_rst_error (rsc_ptr, 4 /* severity */, mrds_error_$rst_logic_error, (message));
      351 
      352      end;
      353 
      354 bad_struct_size: procedure ();
      355 
      356 /* report bad structure allocation size */
      357 
      358 	call ioa_$rs ("^a ^d ^a", message, message_length,
      359 	     "LOGIC ERROR in mrds_rst_rsc_alloc,", struct_size, "is an illegal structure allocation size.");
      360 	call mrds_rst_error (rsc_ptr, 4 /* severity */, mrds_error_$rst_logic_error, (message));
      361 
      362 
      363      end;
      364 
      365 trace: procedure (in_out);
      366 
      367 /* common call to the metering routine */
      368 
      369 	struct_type_picture = struct_type;
      370 	call mrds_rst_meter (rsc_ptr, "mrds_rst_rsc_alloc", in_out, (struct_type_picture));
      371 
      372 	dcl     in_out		 bit (1);		/* on => input, off => output call */
      373 	dcl     struct_type_picture	 picture "99";	/* for integer to char conversion */
      374 
      375      end;
      376 
      377 
      378 	dcl     mrds_rst_meter	 entry (ptr, char (*), bit (1), char (*)); /* trace routine */
      379 	dcl     parse_info_area	 area based (rsc.parse_info_area_ptr); /* location for parsing structures */
      380 	dcl     seg_info_area	 area based (rsc.tree_data.seg_info_area_ptr); /* segment list location */
      381 	dcl     global_list_area	 area based (rsc.tree_data.gl_area_ptr); /* global element location */
      382 	dcl     sublist_area	 area based (rsc.tree_data.sl_area_ptr); /* sub list element location */
      383 	dcl     tree_node_area	 area based (rsc.tree_node_area_ptr); /* location of tree head portion */
      384 	dcl     static_info_area	 area based (rsc.static_info_area_ptr); /* static type info location */
      385 	dcl     variable_length_area	 area based (rsc.variable_length_area_ptr); /* location for variable length allocations */
      386 	dcl     other_area		 area based (rsc.other_area_ptr); /* all other information */
      387 	dcl     struct_type		 fixed bin;	/* number corresponding to structure to be allocated */
      388 	dcl     struct_size		 fixed bin (35);	/* number of words to allocate for varying types */
      389 	dcl     struct_ptr		 ptr;		/* pointer to allocated structure */
      390 	dcl     mrds_rst_error	 entry (ptr, fixed bin, fixed bin (35), char (*)); /* general error routine */
      391 	dcl     ioa_$rs		 entry options (variable); /* string manipulator routine */
      392 	dcl     FREE		 bit (1);		/* on => free structure, off => allocate */
      393 	dcl     ON		 bit (1) internal static options (constant) init ("1"b); /* true value */
      394 	dcl     OFF		 bit (1) internal static options (constant) init ("0"b); /* false value */
      395 	dcl     mrds_error_$rst_logic_error fixed bin (35) external; /* bad program */
      396 	dcl     message		 char (96) varying; /* returned formatted specifics of error */
      397 	dcl     message_length	 fixed bin (21);	/* length of returned message */
      398 	dcl     sys_info$max_seg_size	 fixed bin (35) external; /* max system segment length */
      399 	dcl     (addr, lbound, hbound, rel, fixed) builtin;
      400 
  1     1 /* BEGIN INCLUDE FILE mrds_rst_struct_types.incl.pl1 - - Jim Gray 2/20/79 */
  1     2 
  1     3 /* these constants are used to identify structures to be allocated
  1     4*   to the general purpose allocation routines */
  1     5 
  1     6 /*  HISTORY:
  1     7*    82-06-28 Roger Lackey : Removed struct types 52, 53, 54, 55, 56, 57, 58
  1     8*    Type 25 is no longer used and is handled with special code so bounds of 
  1     9*    array could continue to work */
  1    10 
  1    11 /* PARSE INFO STRUCTURES */
  1    12 
  1    13 declare  DOMAIN fixed bin internal static options (constant) init (1) ;
  1    14 declare  ATTRIBUTE_DOMAIN fixed bin internal static options (constant) init (2) ;
  1    15 declare  RELATION fixed bin internal static options (constant) init (3) ;
  1    16 declare  ATTRIBUTE fixed bin internal static options (constant) init (4) ;
  1    17 declare  FILE fixed bin internal static options (constant) init (5) ;
  1    18 declare  ITEM fixed bin internal static options (constant) init (6) ;
  1    19 declare  LINK fixed bin internal static options (constant) init (7) ;
  1    20 declare  FOREIGN_KEY fixed bin internal static options (constant) init (8) ;
  1    21 declare  CHILDREN fixed bin internal static options (constant) init (9) ;
  1    22 declare  INDEX fixed bin internal static options (constant) init (10) ;
  1    23 declare  DELETE_NAME fixed bin internal static options (constant) init (11) ;
  1    24 declare  DOM_LIST fixed bin internal static options (constant) init (12) ; /* in link handler */
  1    25 
  1    26 /* SEMANTIC STRUCTURES */
  1    27 
  1    28 declare  DIRECTIVE fixed bin internal static options (constant) init (13) ;
  1    29 declare  STMT fixed bin internal static options (constant) init (14) ;
  1    30 
  1    31 
  1    32 /* PARSING STRUCTURES */
  1    33 
  1    34 declare  LEX_STACK fixed bin internal static options (constant) init (15) ;
  1    35 declare  P_STRUCT fixed bin internal static options (constant) init (16) ;
  1    36 declare  CUR_LEX_TOP fixed bin internal static options (constant) init (17) ;
  1    37 declare  FIXUP_TOKEN fixed bin internal static options (constant) init (50) ; /* scanner */
  1    38 declare  STRING_SOURCE fixed bin internal static options (constant) init (51) ; /* semantics */
  1    39 declare  TOKEN fixed bin internal static options (constant) init (18) ;
  1    40 declare  OUTPUT_TEXT fixed bin internal static options (constant) init (19) ;
  1    41 
  1    42 
  1    43 /* DB_MODEL STRUCTURES */
  1    44 
  1    45 declare  DB_MODEL fixed bin internal static options (constant) init (0) ;
  1    46 declare  FILE_INFO fixed bin internal static options (constant) init (1) ;
  1    47 declare  DOMAIN_INFO fixed bin internal static options (constant) init (2) ;
  1    48 declare  PATH_ENTRY fixed bin internal static options (constant) init (3) ;
  1    49 declare  STACK_ITEM fixed bin internal static options (constant) init (4) ;
  1    50 declare  CONSTANT fixed bin internal static options (constant) init (30) ;
  1    51 declare  VERSION_STATUS fixed bin internal static options (constant) init (5) ;
  1    52 declare  CHANGER fixed bin internal static options (constant) init (6) ;
  1    53 
  1    54 
  1    55 /* FILE_MODEL STRUCTURES */
  1    56 
  1    57 declare  FILE_MODEL fixed bin internal static options (constant) init (7) ;
  1    58 declare  REL_INFO fixed bin internal static options (constant) init (8) ;
  1    59 declare  ATTR_INFO fixed bin internal static options (constant) init (9) ;
  1    60 declare  PARENT_LINK_INFO fixed bin internal static options (constant) init (10) ;
  1    61 declare  CHILD_LINK_INFO fixed bin internal static options (constant) init (11) ;
  1    62 declare  ATTR_LIST fixed bin internal static options (constant) init (12) ;
  1    63 declare  ATD fixed bin internal static options (constant) init (31) ;
  1    64 declare  COMP_NO_ARRAY fixed bin internal static options (constant) init (32) ;
  1    65 declare  SORT_KEY fixed bin internal static options (constant) init (13) ;
  1    66 declare  DUP_PREV fixed bin internal static options (constant) init (14) ;
  1    67 declare  SELECT_CHAIN fixed bin internal static options (constant) init (15) ;
  1    68 
  1    69 
  1    70 /* GLOBAL LIST STRUCTURES */
  1    71 
  1    72 declare  GL fixed bin internal static options (constant) init (20) ;
  1    73 declare  SL fixed bin internal static options (constant) init (21) ;
  1    74 declare  SEGINFO fixed bin internal static options (constant) init (22) ;
  1    75 declare  LIST_OVRLY fixed bin internal static options (constant) init (26) ;
  1    76 declare  SAVED_CHILD_COUNT fixed bin internal static options (constant) init (24) ; /* in global list build */
  1    77 declare  NODE fixed bin internal static options (constant) init (23) ;
  1    78 
  1    79 
  1    80 /* DISPLAY STRUCTURES */
  1    81 
  1    82 declare  DISPLAY_INFO fixed bin internal static options (constant) init (25) ;
  1    83 
  1    84 /*   Remove because nolonger used 82-06-28        
  1    85*  NAME_LIST fixed bin internal static options (constant) init (52) ;
  1    86*  PAI_ARRAY fixed bin internal static options (constant) init (53) ;
  1    87*  PAR_LK_ATTR_INFO fixed bin internal static options (constant) init (54) ;
  1    88*  CAI_ARRAY fixed bin internal static options (constant) init (55) ;
  1    89*  CHILD_LK_ATTR_INFO fixed bin internal static options (constant) init (56) ;
  1    90*  NAME_TABLE fixed bin internal static options (constant) init (57) ;
  1    91*  ATTR_TABLE fixed bin internal static options (constant) init (58) ;
  1    92**/
  1    93 
  1    94 /* END INCULDE FILE mrds_rst_struct_types */
  1    95 
      401 
      402 
  2     1 /* BEGIN INCLUDE FILE mrds_rst_tree.incl.pl1   jeg 7/19/78 */
  2     2 
  2     3 /* common declarations for threaded binary tree routines
  2     4*
  2     5*   The tree maintains an inorder list of it's keys.
  2     6*   this means that for a given node, any key in it's left subtree
  2     7*   is "less" than the given node's key and that any key in it's
  2     8*   right subtree is "greater" than the given node's key.
  2     9*
  2    10*   Threads are maintained to allow fast and easy traversal of the tree.
  2    11*   threads occupy the position of null pointers of an straight binary tree,
  2    12*   thus they only occur in leaf nodes.
  2    13*   left threads point to that nodes inorder predecessor.
  2    14*   right threads point to that nodes inorder successor.
  2    15*
  2    16*   note: root_ptr must be passed by reference
  2    17*   ( not by value ) so it can be changed .
  2    18*   Also, each parameter must be a different
  2    19*   variable. The same variable used for two
  2    20*   or more arguments when any of the tree
  2    21*   routines are called will produce errors */
  2    22 
  2    23 
  2    24 declare  key char (32) aligned ;			/* data key directing search */
  2    25 
  2    26 declare  root_ptr ptr ;				/* pointer to head of desired list */
  2    27 declare  node_ptr ptr ;				/* pointer to key node, when success */
  2    28 declare  parent_ptr ptr ;				/* pointer to direct parent of current node */
  2    29 declare  data_ptr ptr ;				/* pointer from tree node to data structure headed by node */
  2    30 declare  successor_ptr ptr ;				/* pointer to inorder successor of current node in tree */
  2    31 declare  successor_parent_ptr ptr ;			/* pointer to immediate tree parent of inorder successor node */
  2    32 declare  predecessor_ptr ptr ;			/* pointer to inorder predecessor of current node */
  2    33 declare  predecessor_parent_ptr ptr ;			/* pointer to direct parent of predecessor */
  2    34 declare  area_ptr ptr ;				/* pointer to based area for node allocation/freeing */
  2    35 
  2    36 declare  work_area area based (area_ptr) ;		/* area of storage for tree */
  2    37 
  2    38 declare  success bit (1) ;				/* on if operation successful */
  2    39 declare  thread bit (1) aligned ;			/* current thread indicator, on = thread, off = pointer */
  2    40 
  2    41 declare 1 node based (node_ptr) aligned,		/* tree element */
  2    42         2 data ptr,					/* data field link */
  2    43         2 key char (32),				/* data key */
  2    44         2 right,					/* right branch link */
  2    45 	3 thread bit (1),				/* indicates whether link is thread or pointer */
  2    46 	3 link ptr,				/* pointer to right descendent or thread to successor */
  2    47         2 left,					/* left branch link */
  2    48 	3 thread bit (1),				/* indicates whether link is thread or pointer */
  2    49 	3 link ptr,				/* pointer to left descendent or thread to predecessor */
  2    50         2 pad bit (34) ;				/* reserved for future flags */
  2    51 
  2    52 /* END INCLUDE FILE mrds_rst_tree.incl.pl1  */
  2    53 
  2    54 
  2    55 
  2    56 
      403 
      404 
  3     1 /* BEGIN INCLUDE FILE mrds_rst_rsc.incl.pl1		RDL  7/7/78	*/
  3     2 
  3     3 /* Modified 8/21/78 by RDL */
  3     4 
  3     5 /* Modified 9/11/78 	by RDL to add directive and stmt pointers */
  3     6 
  3     7 /* Modified 11/4/78		by RDL to add debug,trace,meter switches
  3     8*
  3     9*   Modified 3/29/79 by RDL to change s_seg_info_ptr to source_seg_ptr
  3    10*
  3    11*   Modified by Jim Gray - - Jan. 1980, to add flags to disallow blocked files, forieng keys, and restructuring.
  3    12*
  3    13*   Modified by Jim Gray - - Feb. 1980, to add command level flag for cmdb subroutine interface.
  3    14*
  3    15*   Modified by Jim Gray - - 80-11-06, to add bit for cmdb -secure option.
  3    16*
  3    17*   81-05-18 Jim Gray : added bit for max_attributes error message, so that
  3    18*   it would only be issued on first occurence.
  3    19*
  3    20*   82-08-19 Davids: added the db_type field.
  3    21*
  3    22*   83-02-18 Mike Kubicar : Removed the db_type field and added the 
  3    23*   db_relation_mode_flags substructure to define the modes applicable
  3    24*   to the database's relations.  Also removed assorted unsed fields
  3    25*   (names that included the word unused).
  3    26*
  3    27**/
  3    28 
  3    29 dcl 1 rsc based (rsc_ptr),				/* Restructuring control info */
  3    30     2 rsc_dir char (200),				/* pathname of directory containing rsc segment */
  3    31     2 dbp char (168),				/* Database absolute path */
  3    32     2 temp_dir char (168),				/* Path name of temp restrucuring directory */
  3    33     2 temp_dir_sw bit (1) unal,			/* On => temp dir has been created */
  3    34     2 db_quiesced_sw bit (1) unal,			/* On => database has been quiesced */
  3    35     2 o_db_open_sw bit (1) unal,			/* On => old database has been opened */
  3    36     2 n_db_open_sw bit (1) unal,			/* On => temp database is open */
  3    37     2 listing_seg_sw bit (1) unal,			/* On => listing segment has been created */
  3    38     2 skip_scanner_conversion bit (1) unal,		/* Skip conversion in scanner */
  3    39     2 cmdb_option bit (1) unal,			/* ON => this is a cmdb source, not restructuring */
  3    40     2 trace_sw bit (1) unal,				/* On -> trace mode in affect */
  3    41     2 debug_sw bit (1) unal,				/* On = debug mode (NOT IMPLEMENTED) */
  3    42     2 meter_sw bit (1) unal,				/* On = procedures call metering procedure */
  3    43     2 delete_db_sw bit (1) unal,			/* On = delete data base in cleanup */
  3    44     2 model_consistent_sw bit (1) unal,			/* On => Model is consistent */
  3    45     2 physical_started_sw bit (1) unal,			/* On => Physical restructuring started */
  3    46     2 physical_complete_sw bit (1) unal,		/* On => Physical restructuring completed */
  3    47     2 model_overflow bit (1) unal,			/* ON => model segment area condition occurred */
  3    48     2 max_files bit (1) unal,				/* ON => maximum number of files reached */
  3    49     2 allow_foreign_keys bit (1) unal,			/* on => allow foreign key statment */
  3    50     2 foreign_key_seen bit (1) unal,			/* on => foreign key definition in source */
  3    51     2 allow_blocked_files bit (1) unal,			/* on => allow file statement with blocked option */
  3    52     2 blocked_file_seen bit (1) unal,			/* on => blocked file definition in source */
  3    53     2 allow_restructuring bit (1) unal,			/* on => allow RMDB entry point */
  3    54     2 command_level bit (1) unal,			/* on => called from command unal, not subroutine level */
  3    55     2 secure bit (1) unal,				/* on => -secure option given for cmdb */
  3    56     2 max_attrs bit (1) unal,				/* on => max attrs/rel or max indexes/rel exceeded */
  3    57     2 db_relation_mode_flags,
  3    58       3 dm_file_type bit (1) unal,			/* on => relations are dm files */
  3    59       3 protection_on bit (1) unal,			/* on => relations need transactions */
  3    60       3 concurrency_on bit (1) unal,			/* on => concurrency control enabled */
  3    61       3 rollback_on bit (1) unal,			/* on => before journalling is enabled */
  3    62     2 severity_high fixed bin,			/* Highest severity level error encountered */
  3    63     2 phase fixed bin,				/* 000 = init
  3    64*						   100 = global list init
  3    65*						   200 = parse
  3    66*						   300 = physical init
  3    67*						   400 = physical */
  3    68     2 h_o_seg_info_ls_ptr ptr,			/* Pointer to head of old db seg_info list */
  3    69     2 h_n_seg_info_ls_ptr ptr,			/* Pointer to head of new db seg_info list */
  3    70     2 h_gfile_ptr ptr,				/* Pointer to head of global file list */
  3    71     2 h_gdom_ptr ptr,				/* Pointer to head of global domain list */
  3    72     2 h_gattr_ptr ptr,				/* Pointer to head of global attribute list */
  3    73     2 h_grel_ptr ptr,				/* Pointer to head of global relation list */
  3    74     2 h_glink_ptr ptr,				/* Pointer to head of global link list */
  3    75     2 o_dm_ptr ptr,					/* Pointer to old data model seg  (dm_model ) */
  3    76     2 n_dm_ptr ptr,					/* Pointer to temp data model seg */
  3    77     2 o_fn_hdr_ptr ptr,				/* Pointer to head of original file list (fn structure) */
  3    78     2 source_seg_ptr ptr,				/* Pointer to source_seg */
  3    79     2 listing_iocb_ptr ptr,				/* Pointer to listing segment iocb */
  3    80     2 directive_ptr ptr,				/* Pointer to directive type str in mrds_rst_semactics.incl.pl1 */
  3    81     2 stmt_ptr ptr,					/* Pointer to statement str in mrds_rst_sematics.incl.pl1 */
  3    82     2 trace_metering_iocb_ptr ptr,			/* Pointer to seg used by trace and metering */
  3    83     2 tree_node_area_ptr ptr,				/* pointer to working storage for tree nodes */
  3    84     2 tree_data,
  3    85       3 seg_info_area_ptr ptr,			/* seg info working storage area */
  3    86       3 gl_area_ptr ptr,				/* global list data work storage area */
  3    87       3 sl_area_ptr ptr,				/* sublist data work storage area */
  3    88     2 parse_info_area_ptr ptr,			/* parse interface work area storage */
  3    89     2 static_info_area_ptr ptr,			/* directive, stmt and other static work storage area */
  3    90     2 variable_length_area_ptr ptr,			/* varibale allocates work storage area */
  3    91     2 other_area_ptr ptr,				/* unspecified work area storage */
  3    92     2 wa area (sys_info$max_seg_size - fixed (rel (addr (rsc.wa))) + 1); /* Work area */
  3    93 
  3    94 dcl  rsc_ptr ptr;					/* Pointer to base of rsc segment */
  3    95 
  3    96 
  3    97 
  3    98 /* END INCLUDE FILE mrds_rst_rsc.incl.pl1				*/
  3    99 
      405 
      406 
  4     1 /* BEGIN INCLUDE FILE mrds_rst_global_lists.incl.pl1	jeg	7/17/78	*/
  4     2 
  4     3 /* note: mrds_rst_list_element$add and delete entries
  4     4*   makes use of the following structure type correspondence
  4     5*
  4     6*   structure_type = 1  refers to gl (global list element)
  4     7*
  4     8*   structure_type = 2 refers to sl (global sublist element)
  4     9*
  4    10*   structure_type = 3  refers to seg_info(segment information element)
  4    11*
  4    12**/
  4    13 
  4    14 
  4    15 dcl 1 gl aligned based (gl_ptr),			/* Template for global list entry */
  4    16     2 type fixed bin,				/* structure_type, usefull when overlay used */
  4    17     2 name char (32),				/* Item name */
  4    18     2 item_info_ptr ptr,				/* Pointer to info structure for this item */
  4    19     2 parse_info_ptr ptr,				/* Pointer to info obtained by parsing source */
  4    20     2 other_info_ptr ptr,				/* Pointer to additional info str if needed */
  4    21     2 item_sub_list_ptr ptr,				/* Pointer to sub list of items if neccessary for this his item */
  4    22     2 file_info_ptr ptr,				/* Pointer to file info for this entry */
  4    23     2 file_model_ptr ptr,				/* Pointer to file model for this entry */
  4    24     2 affected bit (1) unal,				/* ON => affected by some directive */
  4    25     2 cmdb bit (1) unal,				/* ON => affected by cmdb directive */
  4    26     2 undefine bit (1) unal,				/* ON => affected by undefine directive */
  4    27     2 define bit (1) unal,				/* ON => affected by define directive */
  4    28     2 redefine bit (1) unal,				/* ON => affected by redefine directive */
  4    29     2 superior_assigned bit (1) unal,			/* ON => has parent */
  4    30     2 inferior_assigned bit (1) unal,			/* ON => child present */
  4    31     2 complete bit (1) unal,				/* ON => all things present */
  4    32     2 consistant bit (1) unal,			/* ON => correct model */
  4    33     2 reserved bit (26) unal,				/* for future use */
  4    34     2 child_defined bit (1) unal ;			/* ON => global element entered by child */
  4    35 
  4    36 dcl  gl_ptr ptr;					/* Pointer to gl structure */
  4    37 
  4    38 
  4    39 
  4    40 dcl 1 sl aligned based (sl_ptr),			/* Template of sub list entry for global list */
  4    41     2 type fixed bin,				/* structure_type, usefull when overlay used */
  4    42     2 name char (32),				/* Name of item */
  4    43     2 item_info_ptr ptr,				/* Pointer to info structure for this entry */
  4    44     2 parse_info_ptr ptr,				/* Pointer to info obtained by parsing source */
  4    45     2 old_other_info_ptr ptr,				/* Pointer to old version of other info */
  4    46     2 new_other_info_ptr ptr,				/* Pointer to new version of other info */
  4    47     2 global_list_ptr ptr,				/* pointer to corresponding global list element */
  4    48     2 reserved bit (36) unal;				/* Reserved for future use */
  4    49 
  4    50 dcl  sl_ptr ptr;					/* Pointer to sub list structure */
  4    51 
  4    52 
  4    53 dcl 1 seg_info based (seg_info_ptr),			/* Info about segment initiated */
  4    54     2 name char (32),				/* Segment name */
  4    55     2 dir char (168),				/* Absolute path of containing directory */
  4    56     2 seg_ptr ptr,					/* Pointer to base of segment */
  4    57     2 bcnt fixed bin (24);				/* Bit count of segment */
  4    58 
  4    59 dcl  seg_info_ptr ptr;				/* Pointer to seg_info str */
  4    60 
  4    61 
  4    62 
  4    63 dcl  MAIN_LIST fixed bin internal static options (constant) init (1);
  4    64 dcl  SUB_LIST fixed bin internal static options (constant) init (2);
  4    65 dcl  SEG_INFO fixed bin internal static options (constant) init (3);
  4    66 
  4    67 declare 1 list_ovrly aligned based (list_ovrly_ptr),	/* overlay for top part of gl and sl list elements */
  4    68         2 type fixed bin,				/* structure_type, 1 => gl, 2 => sl */
  4    69         2 name char (32),				/* Name of item */
  4    70         2 item_info_ptr ptr,				/* pointer to info structure for this entry */
  4    71         2 parse_info_ptr ptr,				/* pointer to info obtained by parsing source */
  4    72         2 other_info_ptr ptr ;			/* pointer to additional info structure if needed */
  4    73 
  4    74 declare  list_ovrly_ptr ptr ;				/* pointer to overlay structure */
  4    75 
  4    76 
  4    77 declare  saved_child_count fixed bin based (saved_child_count_ptr) ; /* parent link structure child count */
  4    78 declare  saved_child_count_ptr ptr ;			/* pointer to remembered number of children */
  4    79 
  4    80 
  4    81 /* USES AND MEANING OF LIST ELEMENT ENTRIES
  4    82*
  4    83*   DOMAIN GLOBAL LIST --------------------------
  4    84*
  4    85*   gl.type - - MAIN_LIST
  4    86*   gl.name - - 32 char domain name
  4    87*   gl.item_info_ptr - - pointer to domain_info for this domain
  4    88*   gl.parse_info_ptr - - pointer to parse info structure
  4    89*   gl.other_info_ptr - - dbm_ptr, pointer to mdbm_db_model
  4    90*   gl.item_sub_list_ptr - - pointer to sublist of attributes using this domain
  4    91*   gl.file_info_ptr - - null ()
  4    92*   gl.file_model_ptr - - null ()
  4    93*   gl.superior_assigned - - ON => domain referenced by some relation
  4    94*   gl.inferior_assigned - - ON => referencing attribute present
  4    95*   gl.complete - - ON => domain_info present
  4    96*   gl.consistant - - always ON
  4    97*
  4    98*   DOMAIN GLOBAL LIST "REFERENCING ATTRIBUTES" SUBLIST ----------------
  4    99*
  4   100*   sl.type - - SUB_LIST
  4   101*   sl.name - - 32 char attribute name
  4   102*   sl.item_info_ptr - - pointer to this attribute's attribute_info
  4   103*   sl.parse_info_ptr - - pointer to parse info structure
  4   104*   sl.old_other_info_ptr - - null ()
  4   105*   sl.new_other_info_ptr - - pointer to this domain's global list element
  4   106*   sl.global_list_ptr - - pointer to attribute's global list element
  4   107*
  4   108*   ATTRIBUTE GLOBAL LIST -----------------
  4   109*
  4   110*   gl.type - - MAIN_LIST
  4   111*   gl.name - - 32 char attribute name
  4   112*   gl.item_info_ptr - - pointer to corresponding domain sublist element for this attribute
  4   113*   gl.parse_info_ptr - - pointer to parse info structure
  4   114*   gl.other_info_ptr - - domain_info of domain for this attribute
  4   115*   gl.item_sub_list_ptr - - pointer to sublist of relations that use this attribute
  4   116*   gl.file_info_ptr - - null (), use pointer(fm_ptr,file_model.fi_ptr)
  4   117*   gl.file_model_ptr - - null (), use pointer(ai_ptr,0), ai_ptr from corres. rel's attr sublist
  4   118*   gl.superior_assigned - - ON => relation contains this attribute
  4   119*   gl.inferior_assigned - - ON => attribute references known domain
  4   120*   gl.complete - - ON => attr_info present for this attribute
  4   121*   gl.consistant - - OFF => no domain for this attribute
  4   122*
  4   123*   ATTRIBUTE GLOBAL LIST "USED IN RELATION" SUBLIST ------------------
  4   124*
  4   125*   sl.type - - SUB_LIST
  4   126*   sl.name - - 32 char relation name
  4   127*   sl.item_info_ptr - - pointer to this relation's rel_info
  4   128*   sl.parse_info_ptr - - pointer to parse info structure
  4   129*   sl.old_other_info_ptr - - pointer to attribute's attr_info in this relation
  4   130*   sl.new_other_info_ptr - - pointer to this attribute's global list element
  4   131*   sl.global_list_ptr - - pointer to relation's global list element
  4   132*
  4   133*   RELATION GLOBAL LIST -------------------
  4   134*
  4   135*   gl.type - - MAIN_LIST
  4   136*   gl.name - - 32 char relation name
  4   137*   gl.item_info_ptr - - pointer to rel_info for this relation
  4   138*   gl.parse_info_ptr - - pointer to parse info structure
  4   139*   gl.other_info_ptr - - pointer to global list element of file containing this relation
  4   140*   gl.item_sub_list_ptr - - pointer to sublist of attributes in this relation
  4   141*   gl.file_info_ptr - - pointer to file_info of this relation's file
  4   142*   gl.file_model_ptr - - pointer to file_model of this relation's file
  4   143*   gl.superior_assigned - - ON => file present to hold this relation
  4   144*   gl.inferior_assigned - - ON => attribute's present in this relation
  4   145*   gl.complete - - ON => rel_info assigned to this relation
  4   146*   gl.consistant - - OFF => no attributes for this relation
  4   147*
  4   148*   RELATION GLOBAL LIST "CONTAINED ATTRIBUTE" SUBLIST ----------------
  4   149*
  4   150*   sl.type - - SUB_LIST
  4   151*   sl.name - - 32 char attribute name
  4   152*   sl.item_info_ptr - - pointer to this attribute's attribute_info
  4   153*   sl.parse_info_ptr - - pointer to parse info structure
  4   154*   sl.old_other_info_ptr - - pointer to domain_info for this attribute in old model
  4   155*   sl.new_other_info_ptr - - pointer to domain_info for this attribute in new model
  4   156*   sl.global_list_ptr - - pointer to attribute's global list element
  4   157*
  4   158*   FILE GLOBAL LIST -----------------------
  4   159*
  4   160*   gl.type - - MAIN_LIST
  4   161*   gl.name - - 30 char file name plus 2 trailing blanks
  4   162*   gl.item_info_ptr - - pointer to file_info for this file
  4   163*   gl.parse_info_ptr - - pointer to parse info structure
  4   164*   gl.other_info_ptr - - null ()
  4   165*   gl.item_sub_list_ptr - - pointer to sublist of relations contained in this file
  4   166*   gl.file_info_ptr - - pointer to file_info for this file
  4   167*   gl.file_model_ptr - - pointer to file_model for this file
  4   168*   gl.superior_assigned - - ON => file_model present for this file
  4   169*   gl.inferior_assigned - - ON => relation present for this file
  4   170*   gl.complete - - OFF => not formatted yet
  4   171*   gl.consistant - - ON => no relations present
  4   172*
  4   173*   FILE GLOBAL LIST "CONTAINED RELATION" SUBLIST ----------------
  4   174*
  4   175*   sl.type - - SUB_LIST
  4   176*   sl.name - - 32 char relation name
  4   177*   sl.item_info_ptr - - relation's rel_info pointer
  4   178*   sl.parse_info_ptr - - pointer to parse info structure
  4   179*   sl.old_other_info_ptr - - null ()
  4   180*   sl.new_other_info_ptr - - pointer to file global list element
  4   181*   sl.global_list_ptr - - pointer to relation's global list element
  4   182*
  4   183*   FOREIGN KEY GLOBAL LIST --------------------
  4   184*
  4   185*   gl.type - - MAIN_LIST
  4   186*   gl.name - - 32 char link(foreign key) name, parent_link_info.name
  4   187*   gl.item_info_ptr - - pointer to parent_link_info for this foreign key
  4   188*   gl.parse_info_ptr - - pointer to parse info structure
  4   189*   gl.other_info_ptr - - pointer to parent relation global list element
  4   190*   gl.item_sub_list_ptr - - pointer to sublist of child relations for this parent
  4   191*   gl.file_info_ptr - - pointer to file_info for parent relation's file
  4   192*   gl.file_model_ptr - - pointer to file_model for parent relation's file
  4   193*   gl.superior_assigned - - ON => parent present
  4   194*   gl.inferior_assigned - - ON => child present
  4   195*   gl.complete - - ON => pli_info and cli_info present
  4   196*   gl.consistant - - ON => rels/attrs found and corres domains match
  4   197*   gl.child_defined - - ON => not defined by parent, but by one of it's children
  4   198*
  4   199*   FOREIGN KEY GLOBAL LIST CHILDREN SUBLIST
  4   200*
  4   201*   sl.type - - SUB_LIST
  4   202*   sl.name - - 32 char name of relation representing this child
  4   203*   sl.item_info_ptr - - pointer to child_link_info for this child
  4   204*   sl.parse_info_ptr - - pointer to parse info structure
  4   205*   sl.old_other_info_ptr - - pointer to file_model holding this child relation
  4   206*   sl.new_other_info_ptr - - pointer to rel_info for this child
  4   207*   sl.global_list_ptr - - pointer to child relation global list element
  4   208*
  4   209*   NOTE: all pointers are to the new model unless otherwise indicated
  4   210*
  4   211**/
  4   212 
  4   213 /* END INCLUDE FILE mrds_rst_global_lists.incl.pl1	*/
  4   214 
      407 
      408 
  5     1 /* BEGIN INCLUDE FILE mrds_rst_parse_info.incl.pl1 -- oris, 6/30/78 */
  5     2 /* modified 9/6/78 -- jeg, for lrk parser - cmdb interface */
  5     3 /* modified 12/20/78 - - jeg, to add line number info for handlers */
  5     4 /* modified 3/15/79 - - jeg, to add scanner, semantic, and link handler variables to be allocated in rsc */
  5     5 /* Modified by Jim Gray - - 23-June-80, to separate max_string_size,
  5     6*   and max_line_size mrds_data_ items. */
  5     7 
  5     8 
  5     9 
  5    10 
  5    11 declare 1 domain aligned based (domain_ptr),
  5    12         2 name char (32),				/* name of this domain */
  5    13         2 descriptor bit (36),			/* Multics pl1 descriptor for domain type */
  5    14         2 varying_avg_length fixed bin (24),		/* average length of varying strings */
  5    15         2 options bit (1) unal,			/* ON => some option is present */
  5    16         2 pad bit (35) unal,
  5    17         2 check,
  5    18 	3 flag bit (1) unal,			/* ON => check option present */
  5    19 	3 pad bit (35) unal,
  5    20 	3 stack_ptr ptr,				/* pointer to postfix stack
  5    21*						   holding boolean expression */
  5    22 	3 stack_size fixed binary,			/* number of stack elements */
  5    23         2 check_proc,
  5    24 	3 flag bit (1) unal,			/* ON => check_proc option is present */
  5    25 	3 pad bit (35) unal,
  5    26 	3 path char (168),				/* check procedure pathname */
  5    27 	3 entry char (32),				/* check procedure entryname */
  5    28         2 encode_proc,
  5    29 	3 flag bit (1) unal,			/* ON => encode_proc option is present */
  5    30 	3 pad bit (35) unal,
  5    31 	3 path char (168),				/* encode procedure pathname */
  5    32 	3 entry char (32),				/* encode procedure entryname */
  5    33         2 decode_proc,
  5    34 	3 flag bit (1) unal,			/* ON => decode_proc option is present */
  5    35 	3 pad bit (35) unal,
  5    36 	3 path char (168),				/* decode procedure pathname */
  5    37 	3 entry char (32),				/* decode procedure entryname */
  5    38         2 decode_dcl,
  5    39 	3 flag bit (1) unal,			/* ON => decode declaration is present */
  5    40 	3 pad bit (35) unal,
  5    41 	3 descriptor bit (36),			/* decode declaration pl1 descriptor */
  5    42         2 line_num fixed bin (24) ;			/* line of domain name in source */
  5    43 
  5    44 
  5    45 declare  domain_ptr ptr ;
  5    46 
  5    47 
  5    48 
  5    49 
  5    50 
  5    51 dcl 1 relation aligned based (relation_ptr),
  5    52     2 a_ptr ptr,					/* ptr to attribute list for this relation */
  5    53     2 name char (32),				/* relation name */
  5    54     2 max_tup fixed bin,				/* maximum tuples for this relation if a blocked file */
  5    55     2 num_items fixed bin,				/* number of attributes in this relation */
  5    56     2 unused bit (36) unal,				/* future flags */
  5    57     2 line_num fixed bin (24) ;			/* line of relation name in source */
  5    58 
  5    59 
  5    60 dcl  relation_ptr ptr;
  5    61 
  5    62 
  5    63 dcl 1 attribute aligned based (attribute_ptr),
  5    64     2 next ptr,					/* ptr to next in list */
  5    65     2 name char (32),				/* name of attribute */
  5    66     2 pr_key bit (1) unal,				/* ON => part of primary key */
  5    67     2 pad bit (35) unal,
  5    68     2 defn_order fixed bin,				/* position within the relation */
  5    69     2 key_order fixed bin,				/* position within the primary key, if a key */
  5    70     2 line_num fixed bin (24) ;			/* line of attribute name in source */
  5    71 
  5    72 
  5    73 dcl  attribute_ptr ptr;
  5    74 
  5    75 
  5    76 
  5    77 dcl 1 attribute_domain aligned based (attdom_ptr),
  5    78     2 attr char (32),				/* attribute name */
  5    79     2 dom char (32),				/* domain name */
  5    80     2 default bit (1) unal,				/* on => defined as default attr, not by source */
  5    81     2 unused bit (35) unal,				/* future flags */
  5    82     2 line_num fixed bin (24) ;			/* line of attribute name in source */
  5    83 
  5    84 dcl  attdom_ptr ptr;				/* ptr to attribute_domain structure */
  5    85 
  5    86 
  5    87 
  5    88 
  5    89 dcl 1 file aligned based (file_ptr),
  5    90     2 i_ptr ptr,					/* ptr to item containing relation name */
  5    91     2 name char (30),				/* file name */
  5    92     2 type fixed bin,				/* blocked or unblocked */
  5    93 						/* type = 1 => unblocked,
  5    94*						   type = 2 => blocked */
  5    95     2 ppb fixed bin,				/* pages per block, if blocked */
  5    96     2 hbh fixed bin,				/* hash bucket headers per block */
  5    97     2 block fixed bin,				/* blocks per hash bucket headers */
  5    98     2 num_items fixed bin,				/* nbr. items -- relations -- in file */
  5    99     2 default bit (1) unal,				/* on => defined as default file, not by source */
  5   100     2 unused bit (35) unal,				/* future flags */
  5   101     2 line_num fixed bin (24) ;			/* line of file name in source */
  5   102 
  5   103 
  5   104 dcl  file_ptr ptr;					/* ptr to file structure */
  5   105 
  5   106 
  5   107 dcl 1 rel_index aligned based (index_ptr),
  5   108     2 i_ptr ptr,					/* ptr. to item containing index attr. name */
  5   109     2 rel_name char (32),				/* name of relation being indexed */
  5   110     2 num_items fixed bin,				/* nbr. items -- attributes -- indexed for a relation */
  5   111     2 unused bit (36) unal,				/* future flags */
  5   112     2 line_num fixed bin (24) ;			/* line of relation name in source */
  5   113 
  5   114 
  5   115 dcl  index_ptr ptr;					/* ptr to index structure */
  5   116 
  5   117 
  5   118 dcl 1 link aligned based (link_ptr),
  5   119     2 parent_ptr ptr,				/* ptr to foreign_key structure cont. parent rel. name */
  5   120     2 children_ptr ptr,				/* ptr. to list of children names for this link */
  5   121     2 clust_fl bit (1) unal,				/* ON => link is clustered in one file */
  5   122     2 pad bit (35) unal,
  5   123     2 name char (32),				/* name of this link */
  5   124     2 num_children fixed bin,				/* number of children for this link's parent */
  5   125     2 line_num fixed bin (24) ;			/* line of link name occurence in source */
  5   126 
  5   127 
  5   128 dcl  link_ptr ptr;					/* ptr to link structure */
  5   129 
  5   130 
  5   131 dcl 1 children aligned based (children_ptr),
  5   132     2 next ptr,					/* ptr to next in list */
  5   133     2 child_ptr ptr;				/* ptr. to foreign_key struct. containing child rel. name */
  5   134 
  5   135 
  5   136 dcl  children_ptr ptr;				/* ptr to children structure */
  5   137 
  5   138 
  5   139 dcl 1 foreign_key aligned based (forkey_ptr),
  5   140     2 i_ptr ptr,					/* ptr to item list containing foreign key attributes */
  5   141     2 rel_name char (32),				/* name of parent/child relation */
  5   142     2 num_items fixed bin,				/* nbr of attributes defining this foreign key */
  5   143     2 unused bit (36) unal,				/* future flags */
  5   144     2 line_num fixed bin (24) ;			/* line of relation occurence in source */
  5   145 
  5   146 
  5   147 dcl  forkey_ptr ptr;				/* ptr to foreign_key structure */
  5   148 
  5   149 
  5   150 dcl 1 item aligned based (item_ptr),
  5   151     2 next ptr,					/* ptr to next item in the list */
  5   152     2 name char (32),				/* name of item -- relation name or attribute name */
  5   153     2 unused bit (36) unal,				/* future flags */
  5   154     2 line_num fixed bin (24) ;			/* line of item occurence in source */
  5   155 
  5   156 
  5   157 dcl  item_ptr ptr;					/* ptr to item structure */
  5   158 
  5   159 
  5   160 declare 1 delete_name aligned based (delete_name_ptr),	/* overlay for  undefine parse information */
  5   161         2 overlay char (32),				/* name portion */
  5   162         2 unused bit (36) unal,			/* future flags */
  5   163         2 line_num fixed bin (24) ;			/* line number of name occurence in source */
  5   164 
  5   165 declare  delete_name_ptr ptr ;
  5   166 
  5   167 /* scanner variables */
  5   168 
  5   169 declare  token char (mrds_data_$max_string_size) varying
  5   170          based (accum_token_ptr) ;			/* temp store for accumulating the token */
  5   171 declare  accum_token_ptr ptr internal static ;		/* pointer to allocated accumulator store */
  5   172 declare  mrds_data_$max_string_size fixed bin (35) external ; /* max token  size in chars */
  5   173 declare  mrds_data_$max_line_size fixed bin (35) ext ;	/* max output listing line size */
  5   174 declare  token_length fixed binary (24) ;		/* current length of token */
  5   175 declare  output_text char (mrds_data_$max_line_size) varying
  5   176          based (output_text_ptr) ;			/* body of text for this line in output listing */
  5   177 declare  output_text_ptr ptr internal static ;		/* pointer to allocated output line storage */
  5   178 declare  fixup_token char (token_length) based ;		/* saved fixed up version of token */
  5   179 
  5   180 /* semantic variables */
  5   181 
  5   182 declare  source_size fixed bin (35) ;			/* length of source char string for any_to_any */
  5   183 declare  string_source_ptr ptr ;			/* pointer to source for any_to_any conversion */
  5   184 declare  string_source char (source_size) based (string_source_ptr) ; /* storage for expanded string constant */
  5   185 
  5   186 /* link handler variable */
  5   187 
  5   188 declare  dom_list_ptr ptr ;				/* pointer to domain list element */
  5   189 declare 1 dom_list based (dom_list_ptr),		/* element of parent attr domain ptr list */
  5   190         2 next ptr,					/* pointer to next in order on list */
  5   191         2 attr_name char (32) aligned,			/* parent attr's name */
  5   192         2 dom_info_ptr ptr ;				/* parent attr's domain ptr */
  5   193 
  5   194 /* END INCLUDE FILE mrds_rst_parse_info.incl.pl1 */
  5   195 
      409 
      410 
  6     1 /*  BEGIN INCLUDE  mrds_dm_display_info.incl.pl1       */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(85-12-07,Spitzer), approve(85-12-07,MCR7311),
  6     7*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  6     8*     Add flag fields for unreferenced objects and crossrefs.
  6     9*                                                   END HISTORY COMMENTS */
  6    10 
  6    11 
  6    12 dcl 1 mrds_dm_display_info aligned based (mrds_dm_display_info_ptr),
  6    13     2 version fixed bin,
  6    14     2 output_iocb_ptr ptr,				/* Output iocb pointer */
  6    15     2 db_path char (168) unal,			/* Absolute pathname of the database */
  6    16     2 temp_dir_path char (168) unal,			/* Absolute pathname of temp dir */
  6    17     2 work_area_ptr ptr,				/* Pointer to freeing area */
  6    18     2 dbm_ptr ptr,					/* Pointer to the db_model of the database */
  6    19     2 sw,						/* Control switches */
  6    20       3 default bit (1) unal,				/* Neither -long or -brief */
  6    21       3 long bit (1) unal,				/* On = long mode */
  6    22       3 cmdb bit (1) unal,				/* On = cmdb type output */
  6    23       3 names_only bit (1) unal,			/* Only the name for either relation, attribute, domain, index
  6    24*						   name_list is pointer to by mrds_dm_display_info.name_list_ptr */
  6    25       3 domains bit (1) unal,				/* Domain info only */
  6    26       3 attribute bit (1) unal,			/* Attibute info only */
  6    27       3 relation bit (1) unal,			/* Relation info only */
  6    28       3 index bit (1) unal,				/* Index relation info only */
  6    29       3 history bit (1) unal,				/* On = list history */
  6    30       3 header bit (1) unal,				/* On = display header */
  6    31       3 unreferenced_domains bit (1) unal,		/* On = display only unreferenced domains */
  6    32       3 unreferenced_attributes bit (1) unal,		/* On = display only unreferenced attributes */
  6    33       3 domain_xref bit (1) unal,			/* On = display a domain crossreference */
  6    34       3 attribute_xref bit (1) unal,			/* On = display an attribute crossreference */
  6    35       3 all_xref bit (1) unal,			/* On = display a complete crossreference */
  6    36       3 mbz bit (21) unal,				/* Unnused  must be zeros */
  6    37 						/* The following  are pointer to name list like
  6    38*						   name_list  structure below */
  6    39 
  6    40     2 dom_name_list_ptr ptr,				/* Pointer to domain name list */
  6    41     2 attr_name_list_ptr ptr,				/* Pointer to attribute name list */
  6    42     2 rel_name_list_ptr ptr,				/* Pointer to relation name list */
  6    43     2 index_name_list_ptr ptr,			/* Pointer to index rel name list */
  6    44 
  6    45     2 xref_iocb_ptr ptr,				/* Pointer to database xref */
  6    46     2 xref_name char (32) unaligned;			/* Name of xref file created */
  6    47 
  6    48 dcl 1 name_list aligned based (name_list_ptr),		/* General name list */
  6    49     2 num_names fixed bin,				/* Number of names in list */
  6    50     2 name (num_names_alloc refer (name_list.num_names)) char (32);
  6    51 
  6    52 dcl  mrds_dm_display_info_ptr pointer;
  6    53 dcl  name_list_ptr pointer;
  6    54 dcl  MRDS_DM_DISPLAY_INFO_VERSION_1 int static options (constant) init (1);
  6    55 dcl  num_names_alloc fixed bin;
  6    56 
  6    57 /*  END INCLUDE  mrds_dm_display_info.incl.pl1       */
      411 
      412 
  7     1 /* BEGIN INCLUDE FILE mrds_rst_semantics.incl.pl1 jeg 8/31/78 */
  7     2 
  7     3 /* structure to remember what directives have been seen and are active */
  7     4 
  7     5 declare 1 directive based (directive_ptr),
  7     6         2 type fixed binary,				/* stmt structure index for given directive */
  7     7         2 undefine,
  7     8 	3 active bit (1) unal,
  7     9 	3 seen bit (1) unal,
  7    10 	3 pad bit (34) unal,
  7    11         2 define,
  7    12 	3 active bit (1) unal,
  7    13 	3 seen bit (1) unal,
  7    14 	3 pad bit (34) unal,
  7    15         2 redefine,
  7    16 	3 active bit (1) unal,
  7    17 	3 seen bit (1) unal,
  7    18 	3 pad bit (34) unal,
  7    19         2 cmdb,
  7    20 	3 active bit (1) unal,
  7    21 	3 seen bit (1) unal,
  7    22 	3 pad bit (34) unal ;
  7    23 
  7    24 declare  directive_ptr ptr internal static ;
  7    25 
  7    26 /* encoding for directive types */
  7    27 
  7    28 declare  UNDEFINE fixed bin internal static options (constant) init (1) ;
  7    29 declare  DEFINE fixed bin internal static options (constant) init (2) ;
  7    30 declare  REDEFINE fixed bin internal static options (constant) init (3) ;
  7    31 declare  CMDB fixed binary internal static options (constant) init (4) ;
  7    32 
  7    33 
  7    34 /* structure to remember what statements have been seen, are active,
  7    35*   and how many items are in the statement, and how big the list for the last item was */
  7    36 
  7    37 declare 1 stmt (4) based (stmt_ptr),
  7    38         2 domain,
  7    39 	3 active bit (1) unal,
  7    40 	3 pad bit (35) unal,
  7    41 	3 number fixed binary,
  7    42         2 attribute,
  7    43 	3 active bit (1) unal,
  7    44 	3 pad bit (35) unal,
  7    45 	3 number fixed binary,
  7    46         2 relation,
  7    47 	3 active bit (1) unal,
  7    48 	3 pad bit (35) unal,
  7    49 	3 number fixed binary,
  7    50         2 file,
  7    51 	3 active bit (1) unal,
  7    52 	3 pad bit (35) unal,
  7    53 	3 number fixed binary,
  7    54         2 foreign_key,
  7    55 	3 active bit (1) unal,
  7    56 	3 pad bit (35) unal,
  7    57 	3 number fixed binary,
  7    58         2 index,
  7    59 	3 active bit (1) unal,
  7    60 	3 pad bit (35) unal,
  7    61 	3 number fixed binary ;
  7    62 
  7    63 /* NOTE:
  7    64*   active ON => this stmt/directive is currently being processed
  7    65*   seen ON => this stmt/directive was or is being processed
  7    66**/
  7    67 
  7    68 declare  stmt_ptr ptr internal static ;
  7    69 
  7    70 /* END INCLUDE FILE mrds_rst_semantics.incl.pl1 */
  7    71 
      413 
      414 
  8     1 /* INCLUDE	mrds_rst_scan.incl.pl1	Jim Gray	August, 1978	*/
  8     2 /* 81-06-04 Jim Gray : removed unused constants, and assigned new values
  8     3*   according to the -order option in the lrk input */
  8     4 
  8     5 dcl  LETTER fixed bin internal static options (constant) init (1);
  8     6 dcl  DIGIT fixed bin internal static options (constant) init (2);
  8     7 dcl  SPECIAL fixed bin internal static options (constant) init (3);
  8     8 dcl  A_PATH_ENTRY fixed bin internal static options (constant) init (4) ;
  8     9 dcl  NL fixed bin internal static options (constant) init (5);
  8    10 dcl  WHITE_SPACE fixed bin internal static options (constant) init (6);
  8    11 dcl  ILLEGAL fixed bin internal static options (constant) init (7);
  8    12 dcl  EOF fixed bin internal static options (constant) init (8);
  8    13 
  8    14 declare  START fixed binary internal static options (constant) init (0) ;
  8    15 declare  CASE_END fixed binary internal static options (constant) init (9) ;
  8    16 
  8    17 
  8    18 /* parser token encoding */
  8    19 
  8    20 declare  EOI fixed binary internal static options (constant) init (0) ;
  8    21 declare  PATH_NAME fixed binary internal static options (constant) init (9) ;
  8    22 declare  ENTRY_NAME fixed binary internal static options (constant) init (10) ;
  8    23 declare  INTEGER fixed binary internal static options (constant) init (11) ;
  8    24 declare  IDENTIFIER fixed binary internal static options (constant) init (12) ;
  8    25 
  8    26 /* encoding for specials "(", ")", ",", ";", ":", "-", "*", "+" */
  8    27    declare  SPECIAL_LIST char (8) internal static options (constant) init ("(),;:-*+") ; /* special characters */
  8    28 declare  CODE (8) fixed binary internal static options (constant) init (1, 2, 3, 4, 5, 6, 7, 8) ;
  8    29 
  8    30 /* static variables for scanner */
  8    31 
  8    32 declare  static_rsc_ptr ptr internal static ;		/* static storage for restructure control seg ptr */
  8    33 
  8    34 declare  char char (1) internal static ;		/* character returned by get_next_char */
  8    35 declare  char_type fixed binary internal static ;		/* integer encoding for this class of characters */
  8    36 declare  char_ptr ptr internal static ;			/* pointer to current character in source */
  8    37 declare  line_ptr ptr internal static ;			/* pointer to start of current line */
  8    38 declare  line_number fixed binary (24) internal static ;	/* current number of source line */
  8    39 declare  line_length fixed binary (24) internal static ;	/* current length of line */
  8    40 declare  token_count fixed binary (24) internal static ;	/* index in line(countber of) current token */
  8    41 
  8    42 /* END mrds_rst_scan.incl.pl1		*/
  8    43 
      415 
      416 
  9     1 /* BEGIN INCLUDE FILE mrds_rst_parse_stack.incl.pl1  jeg 8/8/78 */
  9     2 
  9     3 declare 1 lex_stack (-5:50) based (lex_stack_ptr),
  9     4         2 symptr ptr,				/* pointer to terminal symbol in source input */
  9     5         2 symlen fixed binary (24),			/* length of terminal symbol in input */
  9     6         2 line fixed binary (24),			/* line number in source for this symbol */
  9     7         2 symbol fixed binary (24),			/* parser's encoding value for the terminal symbol */
  9     8         2 val fixed binary (71),			/* conversion value for numbers */
  9     9         2 float float binary (63),			/* conversion value if floating point number */
  9    10         2 line_strt ptr,				/* pointer to start of current line */
  9    11         2 line_size fixed binary (24),			/* current length of line */
  9    12         2 token_num fixed binary (24) ;			/* number of this token in current line,
  9    13*						   0 if <error_symbol> for missing or wrong symbol */
  9    14 
  9    15 declare  lex_stack_ptr ptr ;				/* pointer to lexical stack */
  9    16 
  9    17 declare  debug_sw bit (1) static init ("0"b) ;		/* on => output debug messages */
  9    18 
  9    19 dcl 1 p_struct (50) aligned based (p_struct_ptr),
  9    20     2 parse_stack fixed bin (24),			/* * parse stack */
  9    21     2 parse_stack2 fixed bin (24);			/* * copy of parse stack used
  9    22*						   with local error recovery */
  9    23 
  9    24 dcl  p_struct_ptr ptr ;
  9    25 
  9    26 
  9    27 dcl  cur_lex_top (50) fixed bin (24) aligned based (cur_lex_top_ptr) ; /* current lex top stack (with parse_stack) */
  9    28 
  9    29 declare  cur_lex_top_ptr ptr ;
  9    30 
  9    31 
  9    32 /* END INCLUDE FILE mrds_rst_parse_stack.incl.pl1 */
  9    33 
      417 
      418 
 10     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
 10     2 
 10     3 
 10     4 /****^  HISTORY COMMENTS:
 10     5*  1) change(79-02-01,Gray), approve(), audit(), install():
 10     6*     modified to save space occupied by model
 10     7*  2) change(80-11-03,Gray), approve(), audit(), install():
 10     8*     to add mdbm_secured bit in db_model
 10     9*  3) change(82-04-09,Davids), approve(), audit(), install():
 10    10*     collapsed the following into an unused_offset array:
 10    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
 10    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
 10    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
 10    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
 10    15*       unused_1
 10    16*     Also changed the name of unused_2 to restructuring_history_offset
 10    17*     and changed the comment on the changer structure to indicate
 10    18*     that it will contain on database creation information.
 10    19*  4) change(82-04-14,Davids), approve(), audit(), install():
 10    20*     used one of the unused_offsets to point to a message which indicates
 10    21*     why the db is inconsistent. The offset will be null when the db is created
 10    22*     and set the first time the message is used. this is so it will be
 10    23*     consistent with existing data bases. Also added the message structure.
 10    24*  5) change(82-04-28,Davids), approve(), audit(), install():
 10    25*     added the undo_request element to the message structure
 10    26*  6) change(82-05-04,Davids), approve(), audit(), install():
 10    27*     changed unused_offset (12) to last_restructruring_history_offset and
 10    28*     changed restructuring_history_offset to first_restructuring_history_offset
 10    29*  7) change(82-08-19,Davids), approve(), audit(), install():
 10    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
 10    31*     1 => vfile database and 2 => page_file database. Up to this point all
 10    32*     database types were equal to 1.
 10    33*  8) change(83-02-14,Davids), approve(), audit(), install():
 10    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
 10    35*     flags. This will allow information about transactions and dm_file
 10    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
 10    37*     change is compatable with all datamodels created by the released version
 10    38*     of mrds.
 10    39*  9) change(83-02-15,Davids), approve(), audit(), install():
 10    40*     added the rollback_on flag to the db_type_flags since it appears that you
 10    41*     can have a dmfile database that requires transactions but does not have any
 10    42*     journalizing. Also switched the order of the transactions_needed and
 10    43*     concurrency_on flags - this makes the change compatable with existing
 10    44*     dmfile databases except when displaying the model since concurrency_on and
 10    45*     rollback_on will be off in the model even though the dmfile relations had
 10    46*     them on during creation.
 10    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
 10    48*      Removed ctl_file_path_ptr.
 10    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
 10    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 10    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
 10    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
 10    53*      in the flag word for rmdb copying.
 10    54*                                                   END HISTORY COMMENTS */
 10    55 
 10    56 
 10    57 /* this include file contains the structures that go into the make up
 10    58*   of the "db_model" segment in the model for the database.
 10    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
 10    60*
 10    61*   the db_model structure goes at the base of the segment, and contains items unique to
 10    62*   the whole databse. in addition, it has an area of size to fill the
 10    63*   rest of a segment, that holds the lists of files and domains in the database.
 10    64*   these lists are singly forward linked lists. all "pointers" in the database model
 10    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
 10    66*   since actual pointers are process dependent on segment number.
 10    67*   the remaining structures are first a path_entry one to save pathnames in,
 10    68*   and the stack_item and constent structures, used to save a boolean
 10    69*   expression in polish form, with the stack represented by a linked list.
 10    70*   the final structure is one for identifying the status of version information */
 10    71 
 10    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
 10    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
 10    74 	     2 db_type_flags      unal,
 10    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
 10    76 	       3 unused	      (13) bit (1) unal,
 10    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
 10    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
 10    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
 10    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
 10    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
 10    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
 10    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
 10    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
 10    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
 10    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
 10    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
 10    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
 10    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
 10    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
 10    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
 10    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
 10    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
 10    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
 10    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
 10    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
 10    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
 10    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
 10    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
 10   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
 10   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
 10   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
 10   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
 10   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
 10   105 
 10   106      dcl	   dbm_ptr	      ptr;
 10   107 
 10   108 /* the files in the database each have a file_info containing
 10   109*   their name, the file_model for each file is found by initiating the
 10   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
 10   111*   the file_info list is a singly linked list in definition order */
 10   112 
 10   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
 10   114 	     2 file_name	      char (30),		/* name of file */
 10   115 	     2 file_id	      bit (36),		/* id number of file */
 10   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
 10   117 	     2 unused	      unal bit (18);	/* for future expansion */
 10   118 
 10   119      dcl	   fi_ptr		      ptr;
 10   120 
 10   121 /* each domain used in the database will have a domain info saved in the db_model
 10   122*   segment. it describes the domain of the given name, and it's options.
 10   123*   the domain_info's form a singly linked list in definition order */
 10   124 
 10   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
 10   126 	     2 name	      char (32),		/* name of domain */
 10   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
 10   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
 10   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
 10   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
 10   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
 10   132 	     2 reserved	      bit (31) unal,
 10   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
 10   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
 10   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
 10   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
 10   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
 10   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
 10   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
 10   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
 10   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
 10   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
 10   143 	     2 str_err_path_ptr   unal bit (18),
 10   144 	     2 str_after_path_ptr unal bit (18),
 10   145 	     2 get_before_path_ptr unal bit (18),
 10   146 	     2 get_err_path_ptr   unal bit (18),
 10   147 	     2 get_after_path_ptr unal bit (18),
 10   148 	     2 mod_before_path_ptr unal bit (18),
 10   149 	     2 mod_err_path_ptr   unal bit (18),
 10   150 	     2 mod_after_path_ptr unal bit (18),
 10   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
 10   152 	     2 unused_2	      unal bit (18),
 10   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
 10   154 
 10   155      dcl	   di_ptr		      ptr;
 10   156 
 10   157 /* information necessary for attributes that are not used in any relation */
 10   158 
 10   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
 10   160 	     2 name char (32),			/* name of attribute */
 10   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
 10   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
 10   163 	     2 unused (2) bit (18) unal;
 10   164 
 10   165      dcl     ua_ptr ptr;
 10   166 
 10   167 
 10   168 /* space saving pathname$entryname structure, to be allocated
 10   169*   only when a path$entry has to be saved, else only a bit(18)
 10   170*   offset takes up space in the main model structure */
 10   171 
 10   172      declare 1 path_entry	      based (path_entry_ptr),
 10   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
 10   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
 10   175 	     2 reserved	      unal bit (36);	/* for future use */
 10   176 
 10   177      declare path_entry_ptr	      ptr;
 10   178 
 10   179 
 10   180 
 10   181 
 10   182 
 10   183 /* declarations for model of postfix stack holding the check option boolean expression
 10   184*   the following encoding values indicate the corresponding type of stack element
 10   185*
 10   186*   1  =
 10   187*   2  ^=
 10   188*   3  >
 10   189*   4  <
 10   190*   5  >=
 10   191*   6  <=
 10   192*
 10   193*   10  and
 10   194*   20  or
 10   195*   30  not
 10   196*
 10   197*   40  - (minus)
 10   198*
 10   199*   50  domain variable(same name as domain)
 10   200*
 10   201*   60  constant(number, bit string, or character string)
 10   202*
 10   203**/
 10   204 
 10   205 
 10   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
 10   207 	     2 next	      bit (18),		/* link to next in list */
 10   208 	     2 type	      fixed binary,		/* code for this element type */
 10   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
 10   210*						   if this is a constant element type */
 10   211 
 10   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
 10   213 
 10   214 
 10   215 
 10   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
 10   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
 10   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
 10   219 
 10   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
 10   221 
 10   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
 10   223 
 10   224 /* version structure, giving status of source for CMDB/RMDB,
 10   225*   status of model, and status of resultant */
 10   226 
 10   227 /* version number is in form MM.N.Y
 10   228*   where MM is the major version number, N is the minor version alteration,
 10   229*   and Y is the lastest modification to that alteration,
 10   230*   where M and N represent numbers 0-9, and Y is a letter */
 10   231 
 10   232      declare 1 version_status	      unal based (version_status_ptr),
 10   233 	     2 cmdb_rmdb,
 10   234 	       3 major	      fixed bin,
 10   235 	       3 minor	      fixed bin,
 10   236 	       3 modification     char (4),
 10   237 	     2 model,
 10   238 	       3 major	      fixed bin,
 10   239 	       3 minor	      fixed bin,
 10   240 	       3 modification     char (4),
 10   241 	     2 resultant,
 10   242 	       3 major	      fixed bin,
 10   243 	       3 minor	      fixed bin,
 10   244 	       3 modification     char (4);
 10   245 
 10   246      declare version_status_ptr     ptr;
 10   247 
 10   248 
 10   249 /* maintains information only about the db creation */
 10   250 
 10   251      declare 1 changer	      unal based (changer_ptr),
 10   252 	     2 id		      char (32),
 10   253 	     2 time	      fixed bin (71),
 10   254 	     2 next	      bit (18);		/* to next in the singly linked list */
 10   255 
 10   256      declare changer_ptr	      ptr;
 10   257 
 10   258 
 10   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
 10   260 	     02 len	      fixed bin,		/* length of the message */
 10   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
 10   262 	     02 name	      char (32),		/* name of thing that set the message */
 10   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
 10   264*                                                               that caused the database to become inconsistent */
 10   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
 10   266 
 10   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
 10   268 
 10   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
 10   270 
 10   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
 10   272 
 10   273 
      419 
      420 
      421      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1144.0  mrds_rst_rsc_alloc.pl1            >special_ldd>install>MR12.0-1187>mrds_rst_rsc_alloc.pl1
401          1    10/14/83  1609.0  mrds_rst_struct_types.incl.pl1    >ldd>include>mrds_rst_struct_types.incl.pl1
403          2    10/14/83  1608.6  mrds_rst_tree.incl.pl1            >ldd>include>mrds_rst_tree.incl.pl1
405          3    10/14/83  1609.1  mrds_rst_rsc.incl.pl1             >ldd>include>mrds_rst_rsc.incl.pl1
407          4    10/14/83  1608.4  mrds_rst_global_lists.incl.pl1    >ldd>include>mrds_rst_global_lists.incl.pl1
409          5    10/14/83  1608.6  mrds_rst_parse_info.incl.pl1      >ldd>include>mrds_rst_parse_info.incl.pl1
411          6    10/16/86  1140.1  mrds_dm_display_info.incl.pl1     >special_ldd>install>MR12.0-1187>mrds_dm_display_info.incl.pl1
413          7    10/14/83  1608.4  mrds_rst_semantics.incl.pl1       >ldd>include>mrds_rst_semantics.incl.pl1
415          8    10/14/83  1608.9  mrds_rst_scan.incl.pl1            >ldd>include>mrds_rst_scan.incl.pl1
417          9    10/14/83  1608.4  mrds_rst_parse_stack.incl.pl1     >ldd>include>mrds_rst_parse_stack.incl.pl1
419         10    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
FREE                            000100 automatic       bit(1)                   unaligned dcl 392 set ref 68* 76* 104 111 118 125
                                                                                  132 139 146 153 160 167 174 181 190 197 206 213
                                                                                  220 227 234 243 250 257 264 273 280 294* 314 324
OFF                             000033 constant        bit(1)                   initial unaligned dcl 394 set ref 68 294 339*
ON                              000034 constant        bit(1)                   initial unaligned dcl 393 set ref 76 88* 299*
attribute                              based           structure                level 1 dcl 5-63 ref 125 129
attribute_domain                       based           structure                level 1 dcl 5-77 ref 111 115
children                               based           structure                level 1 dcl 5-131 ref 160 164
cur_lex_top                            based           fixed bin(24,0)          array dcl 9-27 ref 220 224
delete_name                            based           structure                level 1 dcl 5-160 ref 174 178
directive                              based           structure                level 1 unaligned dcl 7-5 ref 190 194
dom_list                               based           structure                level 1 unaligned dcl 5-189 ref 181 185
domain                                 based           structure                level 1 dcl 5-11 ref 104 108
file                                   based           structure                level 1 dcl 5-89 ref 132 136
fixup_token                            based           char                     unaligned dcl 5-178 ref 314 320
foreign_key                            based           structure                level 1 dcl 5-139 ref 153 157
gl                                     based           structure                level 1 dcl 4-15 ref 243 247
gl_area_ptr             254            based           pointer                  level 3 dcl 3-29 ref 243 247
global_list_area                       based           area(1024)               dcl 381 ref 243 247
hbound                                                 builtin function         dcl 399 ref 80 92 301
in_out                                 parameter       bit(1)                   unaligned dcl 372 set ref 365 370*
ioa_$rs                         000014 constant        entry                    external dcl 391 ref 348 358
item                                   based           structure                level 1 dcl 5-150 ref 139 143
lbound                                                 builtin function         dcl 399 ref 92 301
lex_stack                              based           structure                array level 1 unaligned dcl 9-3 ref 206 210
link                                   based           structure                level 1 dcl 5-118 ref 146 150
message                         000101 automatic       varying char(96)         dcl 396 set ref 348* 350 358* 360
message_length                  000132 automatic       fixed bin(21,0)          dcl 397 set ref 348* 358*
mrds_data_$max_line_size        000022 external static fixed bin(35,0)          dcl 5-173 ref 234 238
mrds_data_$max_string_size      000020 external static fixed bin(35,0)          dcl 5-172 ref 227 231
mrds_error_$rst_logic_error     000016 external static fixed bin(35,0)          dcl 395 set ref 350* 360*
mrds_rst_error                  000012 constant        entry                    external dcl 390 ref 350 360
mrds_rst_meter                  000010 constant        entry                    external dcl 378 ref 370
node                                   based           structure                level 1 dcl 2-41 ref 264 268
other_area                             based           area(1024)               dcl 386 ref 273 277
other_area_ptr          266            based           pointer                  level 2 dcl 3-29 ref 273 277
output_text                            based           varying char             dcl 5-175 ref 234 238
p_struct                               based           structure                array level 1 dcl 9-19 ref 213 217
parse_info_area                        based           area(1024)               dcl 379 ref 104 108 111 115 118 122 125 129 132 136
                                                                                  139 143 146 150 153 157 160 164 167 171 174 178
                                                                                  181 185
parse_info_area_ptr     260            based           pointer                  level 2 dcl 3-29 ref 104 108 111 115 118 122 125 129
                                                                                  132 136 139 143 146 150 153 157 160 164 167 171
                                                                                  174 178 181 185
rel_index                              based           structure                level 1 dcl 5-107 ref 167 171
relation                               based           structure                level 1 dcl 5-51 ref 118 122
rsc                                    based           structure                level 1 unaligned dcl 3-29
rsc_ptr                                parameter       pointer                  dcl 3-94 set ref 27 74 85 104 108 111 115 118 122
                                                                                  125 129 132 136 139 143 146 150 153 157 160 164
                                                                                  167 171 174 178 181 185 190 194 197 201 206 210
                                                                                  213 217 220 224 227 231 234 238 243 247 250 254
                                                                                  257 261 264 268 273 277 290 296 314 320 324 330
                                                                                  336 350* 360* 370*
saved_child_count                      based           fixed bin(17,0)          dcl 4-77 ref 273 277
seg_info                               based           structure                level 1 unaligned dcl 4-53 ref 257 261
seg_info_area                          based           area(1024)               dcl 380 ref 257 261
seg_info_area_ptr       252            based           pointer                  level 3 dcl 3-29 ref 257 261
sl                                     based           structure                level 1 dcl 4-40 ref 250 254
sl_area_ptr             256            based           pointer                  level 3 dcl 3-29 ref 250 254
source_size                     000134 automatic       fixed bin(35,0)          dcl 5-182 set ref 324 324 329* 330 330
static_info_area                       based           area(1024)               dcl 384 ref 190 194 197 201 206 210 213 217 220 224
                                                                                  227 231 234 238
static_info_area_ptr    262            based           pointer                  level 2 dcl 3-29 ref 190 194 197 201 206 210 213 217
                                                                                  220 224 227 231 234 238
stmt                                   based           structure                array level 1 unaligned dcl 7-37 ref 197 201
string_source                          based           char                     unaligned dcl 5-184 ref 324 330
struct_ptr                             parameter       pointer                  dcl 389 set ref 27 74 104 108* 111 115* 118 122* 125
                                                                                  129* 132 136* 139 143* 146 150* 153 157* 160 164*
                                                                                  167 171* 174 178* 181 185* 190 194* 197 201* 206
                                                                                  210* 213 217* 220 224* 227 231* 234 238* 243 247*
                                                                                  250 254* 257 261* 264 268* 273 277* 290 314 320*
                                                                                  324 330*
struct_size                            parameter       fixed bin(35,0)          dcl 388 set ref 290 303 319 329 358*
struct_type                            parameter       fixed bin(17,0)          dcl 387 set ref 27 74 80 92 92 100 290 301 301 312
                                                                                  348* 369
struct_type_picture             000162 automatic       picture(2)               unaligned dcl 373 set ref 369* 370
sublist_area                           based           area(1024)               dcl 382 ref 250 254
token                                  based           varying char             dcl 5-169 ref 227 231
token_length                    000133 automatic       fixed bin(24,0)          dcl 5-174 set ref 314 314 319* 320 320
trace_sw                206(07)        based           bit(1)                   level 2 packed unaligned dcl 3-29 ref 85 296 336
tree_data               252            based           structure                level 2 unaligned dcl 3-29
tree_node_area                         based           area(1024)               dcl 383 ref 264 268
tree_node_area_ptr      250            based           pointer                  level 2 dcl 3-29 ref 264 268
variable_length_area                   based           area(1024)               dcl 385 ref 314 320 324 330
variable_length_area_ptr
                        264            based           pointer                  level 2 dcl 3-29 ref 314 320 324 330

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ATD                                    internal static fixed bin(17,0)          initial dcl 1-63
ATTRIBUTE                              internal static fixed bin(17,0)          initial dcl 1-16
ATTRIBUTE_DOMAIN                       internal static fixed bin(17,0)          initial dcl 1-14
ATTR_INFO                              internal static fixed bin(17,0)          initial dcl 1-59
ATTR_LIST                              internal static fixed bin(17,0)          initial dcl 1-62
A_PATH_ENTRY                           internal static fixed bin(17,0)          initial dcl 8-8
CASE_END                               internal static fixed bin(17,0)          initial dcl 8-15
CHANGER                                internal static fixed bin(17,0)          initial dcl 1-52
CHILDREN                               internal static fixed bin(17,0)          initial dcl 1-21
CHILD_LINK_INFO                        internal static fixed bin(17,0)          initial dcl 1-61
CMDB                                   internal static fixed bin(17,0)          initial dcl 7-31
CODE                                   internal static fixed bin(17,0)          initial array dcl 8-28
COMP_NO_ARRAY                          internal static fixed bin(17,0)          initial dcl 1-64
CONSTANT                               internal static fixed bin(17,0)          initial dcl 1-50
CUR_LEX_TOP                            internal static fixed bin(17,0)          initial dcl 1-36
DB_MODEL                               internal static fixed bin(17,0)          initial dcl 1-45
DEFINE                                 internal static fixed bin(17,0)          initial dcl 7-29
DELETE_NAME                            internal static fixed bin(17,0)          initial dcl 1-23
DIGIT                                  internal static fixed bin(17,0)          initial dcl 8-6
DIRECTIVE                              internal static fixed bin(17,0)          initial dcl 1-28
DISPLAY_INFO                           internal static fixed bin(17,0)          initial dcl 1-82
DOMAIN                                 internal static fixed bin(17,0)          initial dcl 1-13
DOMAIN_INFO                            internal static fixed bin(17,0)          initial dcl 1-47
DOM_LIST                               internal static fixed bin(17,0)          initial dcl 1-24
DUP_PREV                               internal static fixed bin(17,0)          initial dcl 1-66
ENTRY_NAME                             internal static fixed bin(17,0)          initial dcl 8-22
EOF                                    internal static fixed bin(17,0)          initial dcl 8-12
EOI                                    internal static fixed bin(17,0)          initial dcl 8-20
FILE                                   internal static fixed bin(17,0)          initial dcl 1-17
FILE_INFO                              internal static fixed bin(17,0)          initial dcl 1-46
FILE_MODEL                             internal static fixed bin(17,0)          initial dcl 1-57
FIXUP_TOKEN                            internal static fixed bin(17,0)          initial dcl 1-37
FOREIGN_KEY                            internal static fixed bin(17,0)          initial dcl 1-20
GL                                     internal static fixed bin(17,0)          initial dcl 1-72
IDENTIFIER                             internal static fixed bin(17,0)          initial dcl 8-24
ILLEGAL                                internal static fixed bin(17,0)          initial dcl 8-11
INDEX                                  internal static fixed bin(17,0)          initial dcl 1-22
INTEGER                                internal static fixed bin(17,0)          initial dcl 8-23
ITEM                                   internal static fixed bin(17,0)          initial dcl 1-18
LETTER                                 internal static fixed bin(17,0)          initial dcl 8-5
LEX_STACK                              internal static fixed bin(17,0)          initial dcl 1-34
LINK                                   internal static fixed bin(17,0)          initial dcl 1-19
LIST_OVRLY                             internal static fixed bin(17,0)          initial dcl 1-75
MAIN_LIST                              internal static fixed bin(17,0)          initial dcl 4-63
MRDS_DM_DISPLAY_INFO_VERSION_1         internal static fixed bin(17,0)          initial dcl 6-54
NL                                     internal static fixed bin(17,0)          initial dcl 8-9
NODE                                   internal static fixed bin(17,0)          initial dcl 1-77
OUTPUT_TEXT                            internal static fixed bin(17,0)          initial dcl 1-40
PARENT_LINK_INFO                       internal static fixed bin(17,0)          initial dcl 1-60
PATH_ENTRY                             internal static fixed bin(17,0)          initial dcl 1-48
PATH_NAME                              internal static fixed bin(17,0)          initial dcl 8-21
P_STRUCT                               internal static fixed bin(17,0)          initial dcl 1-35
REDEFINE                               internal static fixed bin(17,0)          initial dcl 7-30
RELATION                               internal static fixed bin(17,0)          initial dcl 1-15
REL_INFO                               internal static fixed bin(17,0)          initial dcl 1-58
SAVED_CHILD_COUNT                      internal static fixed bin(17,0)          initial dcl 1-76
SEGINFO                                internal static fixed bin(17,0)          initial dcl 1-74
SEG_INFO                               internal static fixed bin(17,0)          initial dcl 4-65
SELECT_CHAIN                           internal static fixed bin(17,0)          initial dcl 1-67
SL                                     internal static fixed bin(17,0)          initial dcl 1-73
SORT_KEY                               internal static fixed bin(17,0)          initial dcl 1-65
SPECIAL                                internal static fixed bin(17,0)          initial dcl 8-7
SPECIAL_LIST                           internal static char(8)                  initial unaligned dcl 8-27
STACK_ITEM                             internal static fixed bin(17,0)          initial dcl 1-49
START                                  internal static fixed bin(17,0)          initial dcl 8-14
STMT                                   internal static fixed bin(17,0)          initial dcl 1-29
STRING_SOURCE                          internal static fixed bin(17,0)          initial dcl 1-38
SUB_LIST                               internal static fixed bin(17,0)          initial dcl 4-64
TOKEN                                  internal static fixed bin(17,0)          initial dcl 1-39
UNDEFINE                               internal static fixed bin(17,0)          initial dcl 7-28
VERSION_STATUS                         internal static fixed bin(17,0)          initial dcl 1-51
WHITE_SPACE                            internal static fixed bin(17,0)          initial dcl 8-10
accum_token_ptr                        internal static pointer                  dcl 5-171
addr                                                   builtin function         dcl 399
alloc_length                           internal static fixed bin(35,0)          dcl 10-222
area_ptr                               automatic       pointer                  dcl 2-34
attdom_ptr                             automatic       pointer                  dcl 5-84
attribute_ptr                          automatic       pointer                  dcl 5-73
changer                                based           structure                level 1 packed unaligned dcl 10-251
changer_ptr                            automatic       pointer                  dcl 10-256
char                                   internal static char(1)                  unaligned dcl 8-34
char_ptr                               internal static pointer                  dcl 8-36
char_type                              internal static fixed bin(17,0)          dcl 8-35
children_ptr                           automatic       pointer                  dcl 5-136
constant                               based           structure                level 1 unaligned dcl 10-216
constant_ptr                           automatic       pointer                  dcl 10-220
cur_lex_top_ptr                        automatic       pointer                  dcl 9-29
data_ptr                               automatic       pointer                  dcl 2-29
db_model                               based           structure                level 1 dcl 10-72
dbm_ptr                                automatic       pointer                  dcl 10-106
debug_sw                               internal static bit(1)                   initial unaligned dcl 9-17
delete_name_ptr                        automatic       pointer                  dcl 5-165
di_ptr                                 automatic       pointer                  dcl 10-155
directive_ptr                          internal static pointer                  dcl 7-24
dom_list_ptr                           automatic       pointer                  dcl 5-188
domain_info                            based           structure                level 1 dcl 10-125
domain_ptr                             automatic       pointer                  dcl 5-45
fi_ptr                                 automatic       pointer                  dcl 10-119
file_info                              based           structure                level 1 dcl 10-113
file_ptr                               automatic       pointer                  dcl 5-104
fixed                                                  builtin function         dcl 399
forkey_ptr                             automatic       pointer                  dcl 5-147
gl_ptr                                 automatic       pointer                  dcl 4-36
index_ptr                              automatic       pointer                  dcl 5-115
item_ptr                               automatic       pointer                  dcl 5-157
key                                    automatic       char(32)                 dcl 2-24
lex_stack_ptr                          automatic       pointer                  dcl 9-15
line_length                            internal static fixed bin(24,0)          dcl 8-39
line_number                            internal static fixed bin(24,0)          dcl 8-38
line_ptr                               internal static pointer                  dcl 8-37
link_ptr                               automatic       pointer                  dcl 5-128
list_ovrly                             based           structure                level 1 dcl 4-67
list_ovrly_ptr                         automatic       pointer                  dcl 4-74
message_str                            based           structure                level 1 packed unaligned dcl 10-259
message_str_len                        automatic       fixed bin(17,0)          dcl 10-269
message_str_ptr                        automatic       pointer                  dcl 10-267
mrds_dm_display_info                   based           structure                level 1 dcl 6-12
mrds_dm_display_info_ptr               automatic       pointer                  dcl 6-52
name_list                              based           structure                level 1 dcl 6-48
name_list_ptr                          automatic       pointer                  dcl 6-53
node_ptr                               automatic       pointer                  dcl 2-27
num_names_alloc                        automatic       fixed bin(17,0)          dcl 6-55
output_text_ptr                        internal static pointer                  dcl 5-177
p_struct_ptr                           automatic       pointer                  dcl 9-24
parent_ptr                             automatic       pointer                  dcl 2-28
path_entry                             based           structure                level 1 packed unaligned dcl 10-172
path_entry_ptr                         automatic       pointer                  dcl 10-177
predecessor_parent_ptr                 automatic       pointer                  dcl 2-33
predecessor_ptr                        automatic       pointer                  dcl 2-32
rel                                                    builtin function         dcl 399
relation_ptr                           automatic       pointer                  dcl 5-60
root_ptr                               automatic       pointer                  dcl 2-26
saved_child_count_ptr                  automatic       pointer                  dcl 4-78
seg_info_ptr                           automatic       pointer                  dcl 4-59
sl_ptr                                 automatic       pointer                  dcl 4-50
stack_item                             based           structure                level 1 unaligned dcl 10-206
stack_item_ptr                         automatic       pointer                  dcl 10-212
static_rsc_ptr                         internal static pointer                  dcl 8-32
stmt_ptr                               internal static pointer                  dcl 7-68
string_source_ptr                      automatic       pointer                  dcl 5-183
success                                automatic       bit(1)                   unaligned dcl 2-38
successor_parent_ptr                   automatic       pointer                  dcl 2-31
successor_ptr                          automatic       pointer                  dcl 2-30
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 398
thread                                 automatic       bit(1)                   dcl 2-39
token_count                            internal static fixed bin(24,0)          dcl 8-40
ua_ptr                                 automatic       pointer                  dcl 10-165
unreferenced_attribute                 based           structure                level 1 dcl 10-159
version_status                         based           structure                level 1 packed unaligned dcl 10-232
version_status_ptr                     automatic       pointer                  dcl 10-246
work_area                              based           area(1024)               dcl 2-36

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_struct_code                 001103 constant        entry                    internal dcl 344 ref 92 280 284 301
bad_struct_size                 001214 constant        entry                    internal dcl 354 ref 303
case                            000000 constant        label                    array(25) dcl 104 ref 80 92 92 100
common                          000155 constant        label                    dcl 85 ref 69 80
mrds_rst_rsc_alloc              000122 constant        entry                    external dcl 27
mrds_rst_rsc_alloc$free         000136 constant        entry                    external dcl 74
mrds_rst_rsc_alloc$variable     000754 constant        entry                    external dcl 290
return_label                    001071 constant        label                    dcl 336 ref 109 116 123 130 137 144 151 158 165 172
                                                                                  179 186 195 202 211 218 225 232 239 248 255 262
                                                                                  269 278 285 322 332
trace                           001325 constant        entry                    internal dcl 365 ref 88 299 339
var_case                        000031 constant        label                    array(50:51) dcl 314 ref 301 301 312
var_common                      000765 constant        label                    dcl 296 ref 82

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1556        1602    1412        1566
Length      2222    1412        24         404     143           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_rst_rsc_alloc                  238 external procedure  is an external procedure.  
bad_struct_code                         internal procedure  shares stack frame of external procedure mrds_rst_rsc_alloc.  
bad_struct_size                         internal procedure  shares stack frame of external procedure mrds_rst_rsc_alloc.  
trace                                   internal procedure  shares stack frame of external procedure mrds_rst_rsc_alloc.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_rst_rsc_alloc       000100 FREE                        mrds_rst_rsc_alloc
                         000101 message                     mrds_rst_rsc_alloc
                         000132 message_length              mrds_rst_rsc_alloc
                         000133 token_length                mrds_rst_rsc_alloc
                         000134 source_size                 mrds_rst_rsc_alloc
                         000162 struct_type_picture         trace

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   return_mac          shorten_stack       ext_entry           op_alloc_
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_$rs                       mrds_rst_error                mrds_rst_meter

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mrds_data_$max_line_size      mrds_data_$max_string_size    mrds_error_$rst_logic_error




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     27 000116        68 000132        69 000133        74 000134        76 000146        80 000150        82 000154
     85 000155        88 000163        92 000165       100 000175       104 000176       108 000203       109 000213
    111 000214       115 000221       116 000231       118 000232       122 000237       123 000247       125 000250
    129 000255       130 000265       132 000266       136 000273       137 000303       139 000304       143 000311
    144 000321       146 000322       150 000327       151 000337       153 000340       157 000345       158 000355
    160 000356       164 000363       165 000373       167 000374       171 000401       172 000411       174 000412
    178 000417       179 000427       181 000430       185 000435       186 000445       190 000446       194 000453
    195 000463       197 000464       201 000471       202 000501       206 000502       210 000507       211 000517
    213 000520       217 000525       218 000535       220 000536       224 000543       225 000553       227 000554
    231 000566       232 000602       234 000603       238 000615       239 000631       243 000632       247 000637
    248 000647       250 000650       254 000655       255 000665       257 000666       261 000673       262 000703
    264 000704       268 000711       269 000721       273 000722       277 000727       278 000737       280 000740
    284 000744       285 000745       290 000746       294 000764       296 000765       299 000774       301 000776
    303 001006       312 001013       314 001015       319 001025       320 001030       322 001042       324 001043
    329 001053       330 001056       332 001070       336 001071       339 001100       342 001102       344 001103
    348 001104       350 001152       352 001212       354 001214       358 001215       360 001263       363 001323
    365 001325       369 001327       370 001341       375 001377


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
