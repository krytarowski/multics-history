	COMPILATION LISTING OF SEGMENT mrds_rst_proc_ctl_args
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 09/26/88  1247.9 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-09-19,Blair), approve(88-09-19,MCR7995), audit(88-09-20,Dupuis),
       16*     install(88-09-26,MR12.2-1119):
       17*     Make sure that arg_info.relation_mode_flags has a null value when we
       18*     process -vf so that if vfile was specified after -dm it will
       19*     successfully override any previously set modes. TR 21051.
       20*                                                   END HISTORY COMMENTS */
       21 
       22 
       23 mrds_rst_proc_ctl_args: proc (arg_list_ptr, ai_ptr, suffix_flag,
       24 	default_relation_mode_flags, fatal_sw);
       25 
       26 /* 
       27*                   BEGIN_DESCRIPTION
       28*   The purpose of this procedure is to process the command level control
       29*   arguments for the rmdb and cmdb commands.
       30*
       31*   arg_list_ptr	ptr;		(INPUT)  Pointer to Multics command level argument list
       32*   ai_ptr		ptr;		(INPUT) Pointer to arg_info structure
       33*   suffix_flag	bit(1);		(input) ON => enforce ".db" suffix in database pathname
       34*   default_relation_mode_flags struct   (input)  Defaults for creating relations
       35*   fatal_sw	bit (1);		(OUTPUT) On = fatal error occured during argument processing
       36*   (do not continue after return).
       37*
       38*   All error messages will be reported from this procedure via com_err_
       39*   What to do upon return from this procedure should be decided
       40*   as a result of the fatal_sw (If ON do not continue)
       41*
       42*   If the fatal_sw is OFF then arg_info will reflect the argument info supplied
       43*   and any defaults not supplied.
       44*                   END_DESCRIPTION
       45*
       46*                   HISTORY
       47*   Written by R. D. Lackey March 1979
       48*
       49*   Modified by Jim Gray - - June 1979 to enforce MR7.0 database pathname suffix ".db"
       50*
       51*   Modified by Jim Gray - - June 1980, to remove -control from usage
       52*   statment to agree with documentation for this release.
       53*
       54*   Modified by Jim Gray - - 80-11-06, to add "-secure" option to cmdb control arg processing.
       55*
       56*   81-04-28 Jim Gray : added -no_list, -no_secure, and -force options.
       57*
       58*   81-09-25 Davids: changed the internal procedure get_source so that it no longer
       59*   determines if the source arg had a suffix and if not added it instead it just
       60*   calls expand_pathname_$add_suffix. A stringrange error was occuring on source
       61*   names less than 5 characters. Also changed the declaration of entry_name from
       62*   char (32) varying to char (4). It is being used to hold the suffix "cmdb" or "rmdb"
       63*
       64*   82-08-19 Davids: added processing for control arguments -page_file (-pf)
       65*   and -vfile (-vf)
       66*
       67*   82-11-23 Davids: added the default_db_type parameter and changed so that
       68*   arg_info.db_type is set from default_db_type instead of the constant "vf".
       69*
       70*   83-02-18 Mike Kubicar : Ripped out all code relating to the obsolete
       71*   restructure_mrds_db.  Added the -dm_file option and its corresponding
       72*   mode string to describe the properties for creating relations.
       73*
       74*   83-10-04 Paul Benjamin: to check whether or not the offending arg is a
       75*   control arg before returning et$badopt and return et$bad_arg instead.
       76*
       77*   84-09-06 Paul Benjamin: to  change -dm_file to -data_management_file but
       78*   retain the former as undocumented form.
       79**/
       80 
       81 /* START */
       82 
       83 	fatal_sw = OFF;
       84 	call init_arg_info;				/* Init arg_info structure */
       85 
       86 	call cu_$arg_count_rel (nargs, arg_list_ptr);	/* Get the number of arguments in list */
       87 
       88 	entry_name = "cmdb";
       89 	dm_file_mode_string = "";
       90 	if nargs < 1 then /* Got to have at least the cmdb source path */
       91 	     call error (error_table_$wrong_no_of_args, "create_mrds_db
       92 Usage:  cmdb source_path {database_path -control_args...}^/");
       93 
       94 	else call cu_$arg_ptr_rel (1, arg_ptr, arg_len, code, arg_list_ptr);
       95 	if code ^= 0 then call error (code, "Argument number 1");
       96 
       97 	call get_source (arg, entry_name);		/* Stuff absolute path name of source in arg_info */
       98 
       99 	rel_db_path = before (arg_info.source_entry, "." || entry_name); /* Init in case no data base path is */
      100 						/*    use source entry name without entry_name component */
      101 
      102 	if nargs > 1 then do i = 2 to nargs;		/* Set option flags if any */
      103 		call cu_$arg_ptr_rel (i, arg_ptr, arg_len, code, arg_list_ptr);
      104 		if code ^= 0 then call error (code, "parameter " || arg);
      105 
      106 		opt_ok = OFF;
      107 
      108 		if i = 2 then do;			/* See if they supplied a data base path */
      109 			if ^is_ctl_option (arg) then do;
      110 				opt_ok = ON;
      111 				rel_db_path = arg;
      112 			     end;
      113 
      114 
      115 		     end;
      116 
      117 		if arg = "-no_list" | arg = "-nls" then do;
      118 			opt_ok = ON;
      119 			arg_info.list = OFF;
      120 		     end;
      121 		else if arg = "-ls" | arg = "-list" then opt_ok, arg_info.list = ON; /*       -list option */
      122 		else if arg = "-secure" then opt_ok, arg_info.secure = ON; /* set secured bit in model option */
      123 		else if arg = "-no_secure" then do;
      124 			opt_ok = ON;
      125 			arg_info.secure = OFF;
      126 		     end;
      127 		else if arg = "-no_force" | arg = "-nfc" then do;
      128 			opt_ok = ON;
      129 			arg_info.force = OFF;
      130 		     end;
      131 		else if arg = "-force" | arg = "-fc" then do;
      132 			opt_ok = ON;
      133 			arg_info.force = ON;
      134 		     end;
      135 		else if arg = "-td" | arg = "-temp_dir" then do; /* temp directory option */
      136 			arg_info.twd = ON;
      137 			opt_ok = ON;
      138 
      139 			i = i + 1;		/* Position to next arg (should be temp_dir path) */
      140 			if i > nargs then call error (mrds_error_$no_temp_dir, "");
      141 			else call cu_$arg_ptr_rel (i, arg_ptr, arg_len, code, arg_list_ptr);
      142 			if code ^= 0 then call error (code, "Temp_directory");
      143 
      144 			if is_ctl_option (arg) then
      145 			     call error (mrds_error_$no_temp_dir, "");
      146 			call absolute_pathname_ (arg, arg_info.temp_work_dir, code);
      147 			if code ^= 0 then call error (code, arg);
      148 		     end;
      149 		else if arg = "-vfile" | arg = "-vf"
      150 		then do;
      151 			opt_ok = ON;
      152 			arg_info.relation_mode_flags = "0"b;
      153                               dm_file_mode_string = "";
      154 		     end;
      155 		else if arg = "-data_management_file" | arg = "-dmf" 
      156 		     | /* undocumented */ arg = "-dm_file" then do;
      157 			opt_ok = ON;
      158 			arg_info.relation_mode_flags.dm_file_type = "1"b;
      159 			arg_info.relation_mode_flags.protection_on = "1"b;
      160 			arg_info.relation_mode_flags.concurrency_on = "1"b;
      161 			arg_info.relation_mode_flags.rollback_on = "1"b;
      162 			call cu_$arg_ptr_rel ((i + 1), arg_ptr, arg_len,
      163 			     code, arg_list_ptr);
      164 			if (code ^= 0) & (code ^= error_table_$noarg)
      165 			then call error (code, "Argument number "
      166 				|| ltrim (char ((i + 1), 20)));
      167 			if code ^= error_table_$noarg
      168 			then if ^is_ctl_option (arg) then do;
      169 				     if length (arg) > length (dm_file_mode_string)
      170 				     then call error (error_table_$bigarg, "Mode string is too long.");
      171 				     dm_file_mode_string = arg;
      172 				     i = i + 1;
      173 				end;
      174 		     end;
      175 
      176 		if ^opt_ok
      177 		then do;
      178 			if is_ctl_option (arg)
      179 			then call error (error_table_$badopt, arg);
      180 			else call error (error_table_$bad_arg, arg);
      181 		     end;
      182 	     end;					/* END DO I = 2 TO NARGS */
      183 
      184 
      185 /* Take care of the mode string */
      186 
      187 	call set_modes (dm_file_mode_string, arg_info.relation_mode_flags);
      188 
      189 
      190 /* make  absolute path of data base directory */
      191 
      192 	if ^suffix_flag then
      193 	     call absolute_pathname_ (rel_db_path, arg_info.db_dir_path, code);
      194 	else call absolute_pathname_$add_suffix (rel_db_path, db_suffix, arg_info.db_dir_path, code);
      195 
      196 	if code ^= 0 then call error (code, rel_db_path);
      197 
      198 exit:	return;					/* Only return from this procedure */
      199 
      200 /**********
      201**
      202**   This routine is used to parse the mode string needed by the dm_file
      203**   argument and check it for consistency.  It calls mode_string_$parse
      204**   to parse the string and then goes through the mode_string_info
      205**   structure, setting bits in the "mode_bits" parameter to reflect the
      206**   state of the mode string.
      207**
      208***********/
      209 
      210 set_modes:
      211      proc (mode_string, mode_bits);
      212 
      213 /* Parameters */
      214 
      215 	dcl     mode_string		 char (*);	/* The mode string in the command line */
      216 	dcl     1 mode_bits		 like db_relation_modes; /* Structure describing the file characteristics */
      217 
      218 /* Local definitions */
      219 
      220 	dcl     error_table_$bad_mode_value fixed bin (35) ext static;
      221 	dcl     error_table_$undefined_mode fixed bin (35) ext static;
      222 	dcl     error_table_$unimplemented_version fixed bin (35) ext static;
      223 	dcl     mode_string_$parse	 entry (char (*), ptr, ptr, fixed bin (35));
      224 
      225 	dcl     code		 fixed bin (35);	/* Error code */
      226 	dcl     i			 fixed bin;	/* Loop variable */
      227 	dcl     local_area		 area;		/* For call to mode_string_$parse */
      228 	dcl     1 mode_defined,			/* The corresponding bit is set if the mode
      229*						   string contains the mode */
      230 		2 protection	 bit (1),
      231 		2 rollback	 bit (1),
      232 		2 concurrency	 bit (1);
      233 
      234 /* Include file */
      235 
  1     1 /*  BEGIN INCLUDE FILE   mode_string_info.incl.pl1							*/
  1     2 
  1     3 /* Structure for parse_mode_string_ JRDavis 20 October 1980
  1     4*   Last modified 12 January 1981 by J. Spencer Love for version 2, make char_value varying string */
  1     5 
  1     6 declare	mode_value_ptr		ptr,
  1     7 	number_of_modes		fixed bin;
  1     8 
  1     9 declare	1 mode_string_info		aligned based (mode_string_info_ptr),
  1    10 	  2 version		fixed bin,
  1    11 	  2 number		fixed bin,
  1    12 	  2 modes			(number_of_modes refer (mode_string_info.number)) like mode_value;
  1    13 
  1    14 declare	mode_string_info_ptr	ptr;
  1    15 
  1    16 declare	1 mode_value		aligned based (mode_value_ptr),
  1    17 	  2 version		fixed bin,
  1    18 	  2 mode_name		char (32) unaligned,
  1    19 	  2 flags,
  1    20 	    3 boolean_valuep	bit (1) unaligned,
  1    21 	    3 numeric_valuep	bit (1) unaligned,
  1    22 	    3 char_valuep		bit (1) unaligned,
  1    23 	    3 boolean_value		bit (1) unaligned,
  1    24 	    3 pad1		bit (32) unaligned,
  1    25 	  2 numeric_value		fixed bin (35),
  1    26 	  2 char_value		char (32) varying,
  1    27 	  2 code			fixed bin (35),
  1    28 	  2 pad2			bit (36);
  1    29 
  1    30 declare	mode_string_info_version_2	fixed bin static options (constant) initial (2),
  1    31 	mode_value_version_3	fixed bin static options (constant) initial (3);
  1    32 
  1    33 /* END INCLUDE FILE   mode_string_info.incl.pl1								*/
      236 
      237 
      238 
      239 /* Procedure */
      240 
      241 	if mode_string = ""				/* No string given so there's nothing to do */
      242 	then return;
      243 	unspec (mode_defined) = "0"b;
      244 	call mode_string_$parse (mode_string, addr (local_area),
      245 	     mode_string_info_ptr, code);
      246 	if code ^= 0
      247 	then call error (code, "While trying to parse the mode string.");
      248 	if mode_string_info.version ^= mode_string_info_version_2
      249 	then call error (error_table_$unimplemented_version,
      250 		"The mode_string_info structure is not version two.");
      251 	if mode_string_info.modes (1).version ^= mode_value_version_3
      252 	then call error (error_table_$unimplemented_version,
      253 		"The mode_value structure is not version three.");
      254 
      255 /* Now walk through the returned structure and examine the modes */
      256 
      257 	do i = 1 to mode_string_info.number;
      258 	     if mode_string_info.modes (i).mode_name = "protection" then do;
      259 		     if ^mode_string_info.modes (i).flags.boolean_valuep
      260 		     then call error (error_table_$bad_mode_value,
      261 			     "Protect must be a boolean mode value.");
      262 		     mode_defined.protection = "1"b;
      263 		     mode_bits.protection_on =
      264 			mode_string_info.modes (i).flags.boolean_value;
      265 		end;
      266 	     else if mode_string_info.modes (i).mode_name = "rollback" then do;
      267 		     if ^mode_string_info.modes (i).flags.boolean_valuep
      268 		     then call error (error_table_$bad_mode_value,
      269 			     "rollback must be a boolean mode value.");
      270 		     mode_defined.rollback = "1"b;
      271 		     mode_bits.rollback_on
      272 			= mode_string_info.modes (i).flags.boolean_value;
      273 		end;
      274 	     else if mode_string_info.modes (i).mode_name = "concurrency" then do;
      275 		     if ^mode_string_info.modes (i).flags.boolean_valuep
      276 		     then call error (error_table_$bad_mode_value,
      277 			     "Concurrency must be a boolean mode value.");
      278 		     mode_defined.concurrency = "1"b;
      279 		     mode_bits.concurrency_on
      280 			= mode_string_info.modes (i).flags.boolean_value;
      281 		end;
      282 	     else call error (error_table_$undefined_mode,
      283 		     mode_string_info.modes (i).mode_name);
      284 	end;
      285 
      286 /*
      287**
      288** Check the file attributes for consistency.  Neither concurrency or
      289** before journalling can be specified unless the file is protected.
      290** It is valid however, to specify ^protection and not specify either
      291** rollback or concurrency.  In that case, the latter two modes
      292** will default to off.
      293**
      294**/
      295 
      296 	if mode_bits.dm_file_type			/* All bits are zero for vfile */
      297 	then if mode_defined.protection & ^mode_bits.protection_on then do; /* Force undefined bits to off */
      298 		     if ^mode_defined.concurrency
      299 		     then mode_bits.concurrency_on = "0"b;
      300 		     if ^mode_defined.rollback
      301 		     then mode_bits.rollback_on = "0"b;
      302 		end;
      303 	if mode_bits.rollback_on & ^mode_bits.protection_on
      304 	then call error (error_table_$bad_mode_value,
      305 		"Rollback cannot be specified without protection.");
      306 	if mode_bits.concurrency_on & ^mode_bits.protection_on
      307 	then call error (error_table_$bad_mode_value,
      308 		"Concurrency cannot be specified without protection.");
      309 
      310      end set_modes;
      311 
      312 error: proc (cd, msg);
      313 
      314 	dcl     cd		 fixed bin (35);
      315 	dcl     msg		 char (*);	/* Detailed error message (may be null) */
      316 
      317 	if entry_name = "cmdb" then do;
      318 		call com_err_ (cd, entry_name, msg);
      319 		fatal_sw = ON;			/* Indicate that an error occured */
      320 	     end;
      321 	else do;
      322 		sm_err_code = cd;
      323 		sm_err_msg = msg;
      324 	     end;
      325 	goto exit;
      326 
      327      end error;
      328 
      329 is_ctl_option: proc (iarg) returns (bit (1));
      330 
      331 /* This procedure checks the supplied argument to see if it is a control arg */
      332 
      333 	dcl     iarg		 char (*);	/* (INPUT) Input argument */
      334 
      335 	if length (iarg) < 1
      336 	then return ("0"b);
      337 	else return (substr (iarg, 1, 1) = "-");
      338      end is_ctl_option;
      339 
      340 get_source: proc (source, en);
      341 
      342 /* This procedure given a source segment path sets the source directory path and
      343*   entry in arg_info with the proper suffix if not supplied. */
      344 
      345 	dcl     source		 char (*);	/* (INPUT) source segment name */
      346 	dcl     en		 char (*);	/* (INPUT) entry name (rmdb or cmdb) */
      347 
      348 	if is_ctl_option (arg) then /* Did not give a source path */
      349 	     call error (mrds_error_$bad_source_path, arg || "
      350       First argument must be a source pathname.");
      351 
      352 	call expand_pathname_$add_suffix (source, en, arg_info.source_dir, arg_info.source_entry, code);
      353 	if code ^= 0 then call error (code, source);
      354 
      355      end get_source;
      356 
      357 init_arg_info: proc;
      358 
      359 	arg_info.list = OFF;
      360 	arg_info.twd = OFF;
      361 	arg_info.secure = OFF;
      362 	arg_info.force = OFF;
      363 	arg_info.source_dir = BLANK;
      364 	arg_info.source_entry = BLANK;
      365 	arg_info.db_dir_path = BLANK;
      366 	arg_info.temp_work_dir = get_pdir_ (); ;	/* This will be changed if a twd arg is supplied */
      367 	arg_info.relation_mode_flags = default_relation_mode_flags;
      368 
      369      end init_arg_info;
      370 
      371 /**********
      372**
      373**  Entry point for parsing a dm_file mode string.
      374**
      375************/
      376 
      377 parse_mode_string: entry (external_mode_string, external_mode_bits, sm_err_code, sm_err_msg);
      378 
      379 
      380 /* Parameters */
      381 
      382 	dcl     external_mode_string	 char (*) parm;
      383 	dcl     1 external_mode_bits	 like db_relation_modes;
      384 	dcl     sm_err_code		 fixed bin (35);
      385 	dcl     sm_err_msg		 char (*);
      386 
      387 	sm_err_code = 0;
      388 	sm_err_msg = "";
      389 	call set_modes (external_mode_string, external_mode_bits);
      390 	return;
      391 
      392 
      393 /*	PARAMETERS	*/
      394 
      395 	dcl     arg_list_ptr	 ptr;		/* (INPUT) */
      396 
      397 /*      ai_ptr ptr;					/* (INPUT) */
      398 	dcl     1 default_relation_mode_flags /* (INPUT) */
      399 				 like db_relation_modes;
      400 	dcl     fatal_sw		 bit (1);		/* (OUTPUT) */
      401 
      402 /*	OTHERS		*/
      403 
      404 	dcl     arg		 char (arg_len) based (arg_ptr);
      405 	dcl     arg_len		 fixed bin (21);
      406 	dcl     arg_ptr		 ptr;
      407 	dcl     code		 fixed bin (35);
      408 	dcl     dm_file_mode_string	 char (200);
      409 	dcl     entry_name		 char (4);
      410 	dcl     opt_ok		 bit (1);
      411 	dcl     rel_db_path		 char (168);	/* Relative database path */
      412 	dcl     nargs		 fixed bin;
      413 	dcl     i			 fixed bin;
      414 
      415 	dcl     (addr, before, char, empty, length, ltrim,
      416 	        substr, unspec)	 builtin;
      417 
      418 /*	SUBROUTINES	*/
      419 
      420 	dcl     absolute_pathname_	 entry (char (*), char (*), fixed bin (35));
      421 	declare absolute_pathname_$add_suffix entry (char (*), char (*), char (*), fixed bin (35)); /* appends suffix to path */
      422 	declare db_suffix		 char (3) init ("db") int static options (constant); /* MR7.0 database directory pathname suffic */
      423 	declare suffix_flag		 bit (1);		/* on => use ".db" suffix in database path */
      424 	declare error_table_$wrong_no_of_args fixed bin (35) ext; /* incorrect args count */
      425 	dcl     cu_$arg_count_rel	 entry (fixed bin, ptr);
      426 	dcl     cu_$arg_ptr_rel	 entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr);
      427 	dcl     com_err_		 entry options (variable);
      428 	dcl     expand_pathname_$add_suffix entry (char (*), char (*), char (*), char (*), fixed bin (35));
      429 	dcl     get_pdir_		 entry returns (char (168));
      430 
      431 
      432 /*	CONSTANTS		*/
      433 
      434 	dcl     BLANK		 char (1) int static options (constant) init (" ");
      435 	dcl     OFF		 bit (1) int static options (constant) init ("0"b);
      436 	dcl     ON		 bit (1) int static options (constant) init ("1"b);
      437 
      438 /*	ERROR CODES	*/
      439 
      440 	dcl     error_table_$bad_arg	 ext fixed bin (35);
      441 	dcl     error_table_$badopt	 ext fixed bin (35);
      442 	dcl     error_table_$noarg	 fixed bin (35) ext static;
      443 	dcl     error_table_$bigarg	 fixed bin (35) ext static;
      444 	dcl     mrds_error_$bad_source_path ext fixed bin (35);
      445 	dcl     mrds_error_$no_temp_dir ext fixed bin (35);
      446 
  2     1 /*  START OF:	mrds_rst_arg_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 
  2     4 /* This structure contains information describing some of the attributes
  2     5*   of mrds relations.  */
  2     6 
  2     7 dcl  1 db_relation_modes,
  2     8      2 dm_file_type		bit (1),			/* Set if the relation is a dm_file.  Not set if a vfile */
  2     9      2 protection_on	bit (1),			/* Set if protection is enabled for a dm file */
  2    10      2 concurrency_on	bit (1),			/* Set if concurrency is enabled (protected files only \) */
  2    11      2 rollback_on		bit (1);			/* Set if before journals are to be kept (protected files only) */
  2    12 
  2    13 
  2    14 
  2    15 /* This structure contains the information determined about
  2    16*   create_mrds_db control arguments   */
  2    17 
  2    18 dcl 1 arg_info based (ai_ptr),
  2    19     2 list bit (1) unal init ("0"b),			/* ON => Create a listing segment */
  2    20     2 twd bit (1) unal init ("0"b),			/* ON => a temporary working directory path was supplied */
  2    21     2 secure bit (1) unal init ("0"b),			/* on => set secured bit in db_model at creation time */
  2    22     2 force bit (1) unal init ("0"b),			/* on => delete existing dir of same name as new db */
  2    23     2 relation_mode_flags like db_relation_modes,
  2    24     2 unused bit (23) unal init ("0"b),			/* reserved for future use */
  2    25     2 source_dir char (168),				/* Directory pathname of source (INPUT) segment */
  2    26     2 source_entry char (32),				/* Entry name of source segment */
  2    27     2 db_dir_path char (168),				/* Pathname of database directory */
  2    28     2 temp_work_dir char (168);			/* Pathname of temporary working directory */
  2    29 
  2    30 dcl  ai_ptr ptr;					/* Pointer to arg_info structure */
  2    31 
  2    32 /*  END OF:	mrds_rst_arg_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      447 
      448 
      449      end mrds_rst_proc_ctl_args;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/26/88  1247.9  mrds_rst_proc_ctl_args.pl1        >spec>install>1119>mrds_rst_proc_ctl_args.pl1
236          1    03/19/81  1206.8  mode_string_info.incl.pl1         >ldd>include>mode_string_info.incl.pl1
447          2    10/14/83  1609.1  mrds_rst_arg_info.incl.pl1        >ldd>include>mrds_rst_arg_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BLANK                                  constant        char(1)                  initial packed unaligned dcl 434 ref 363 364 365
OFF                                    constant        bit(1)                   initial packed unaligned dcl 435 ref 83 106 119 125
                                                                                  129 359 360 361 362
ON                                     constant        bit(1)                   initial packed unaligned dcl 436 ref 110 118 121 122
                                                                                  124 128 132 133 136 137 151 157 319
absolute_pathname_              000010 constant        entry                    external dcl 420 ref 146 192
absolute_pathname_$add_suffix   000012 constant        entry                    external dcl 421 ref 194
addr                                                   builtin function         dcl 415 ref 244 244
ai_ptr                                 parameter       pointer                  dcl 2-30 ref 23 99 119 121 122 125 129 133 136 146
                                                                                  152 158 159 160 161 187 192 194 352 352 359 360
                                                                                  361 362 363 364 365 366 367
arg                                    based           char                     packed unaligned dcl 404 set ref 97* 104 109* 111
                                                                                  117 117 121 121 122 123 127 127 131 131 135 135
                                                                                  144* 146* 147* 149 149 155 155 155 167* 169 171
                                                                                  178* 178* 180* 348* 348
arg_info                               based           structure                level 1 packed packed unaligned dcl 2-18
arg_len                         000100 automatic       fixed bin(21,0)          dcl 405 set ref 94* 97 97 103* 104 109 109 111 117
                                                                                  117 121 121 122 123 127 127 131 131 135 135 141*
                                                                                  144 144 146 146 147 147 149 149 155 155 155 162*
                                                                                  167 167 169 171 178 178 178 178 180 180 348 348
                                                                                  348
arg_list_ptr                           parameter       pointer                  dcl 395 set ref 23 86* 94* 103* 141* 162*
arg_ptr                         000102 automatic       pointer                  dcl 406 set ref 94* 97 103* 104 109 111 117 117 121
                                                                                  121 122 123 127 127 131 131 135 135 141* 144 146
                                                                                  147 149 149 155 155 155 162* 167 169 171 178 178
                                                                                  180 348 348
before                                                 builtin function         dcl 415 ref 99
boolean_value            13(03)        based           bit(1)                   array level 4 packed packed unaligned dcl 1-9 ref
                                                                                  263 271 279
boolean_valuep           13            based           bit(1)                   array level 4 packed packed unaligned dcl 1-9 ref
                                                                                  259 267 275
cd                                     parameter       fixed bin(35,0)          dcl 314 set ref 312 318* 322
char                                                   builtin function         dcl 415 ref 164
code                            000256 automatic       fixed bin(35,0)          dcl 225 in procedure "set_modes" set ref 244* 246
                                                                                  246*
code                            000104 automatic       fixed bin(35,0)          dcl 407 in procedure "mrds_rst_proc_ctl_args" set
                                                                                  ref 94* 95 95* 103* 104 104* 141* 142 142* 146*
                                                                                  147 147* 162* 164 164 164* 167 192* 194* 196 196*
                                                                                  352* 353 353*
com_err_                        000022 constant        entry                    external dcl 427 ref 318
concurrency               0(02) 002260 automatic       bit(1)                   level 2 packed packed unaligned dcl 228 set ref 278*
                                                                                  298
concurrency_on            0(02)        parameter       bit(1)                   level 2 in structure "mode_bits" packed packed
                                                                                  unaligned dcl 216 in procedure "set_modes" set ref
                                                                                  279* 298* 306
concurrency_on            0(06)        based           bit(1)                   level 3 in structure "arg_info" packed packed
                                                                                  unaligned dcl 2-18 in procedure
                                                                                  "mrds_rst_proc_ctl_args" set ref 160*
cu_$arg_count_rel               000016 constant        entry                    external dcl 425 ref 86
cu_$arg_ptr_rel                 000020 constant        entry                    external dcl 426 ref 94 103 141 162
db_dir_path              63            based           char(168)                level 2 packed packed unaligned dcl 2-18 set ref
                                                                                  192* 194* 365*
db_relation_modes               000245 automatic       structure                level 1 packed packed unaligned dcl 2-7
db_suffix                       000000 constant        char(3)                  initial packed unaligned dcl 422 set ref 194*
default_relation_mode_flags            parameter       structure                level 1 packed packed unaligned dcl 398 ref 23 367
dm_file_mode_string             000105 automatic       char(200)                packed unaligned dcl 408 set ref 89* 153* 169 171*
                                                                                  187*
dm_file_type                           parameter       bit(1)                   level 2 in structure "mode_bits" packed packed
                                                                                  unaligned dcl 216 in procedure "set_modes" ref 296
dm_file_type              0(04)        based           bit(1)                   level 3 in structure "arg_info" packed packed
                                                                                  unaligned dcl 2-18 in procedure
                                                                                  "mrds_rst_proc_ctl_args" set ref 158*
empty                                                  builtin function         dcl 415 ref 227
en                                     parameter       char                     packed unaligned dcl 346 set ref 340 352*
entry_name                      000167 automatic       char(4)                  packed unaligned dcl 409 set ref 88* 97* 99 317 318*
error_table_$bad_arg            000030 external static fixed bin(35,0)          dcl 440 set ref 180*
error_table_$bad_mode_value     000044 external static fixed bin(35,0)          dcl 220 set ref 259* 267* 275* 303* 306*
error_table_$badopt             000032 external static fixed bin(35,0)          dcl 441 set ref 178*
error_table_$bigarg             000036 external static fixed bin(35,0)          dcl 443 set ref 169*
error_table_$noarg              000034 external static fixed bin(35,0)          dcl 442 ref 164 167
error_table_$undefined_mode     000046 external static fixed bin(35,0)          dcl 221 set ref 282*
error_table_$unimplemented_version
                                000050 external static fixed bin(35,0)          dcl 222 set ref 248* 251*
error_table_$wrong_no_of_args   000014 external static fixed bin(35,0)          dcl 424 set ref 90*
expand_pathname_$add_suffix     000024 constant        entry                    external dcl 428 ref 352
external_mode_bits                     parameter       structure                level 1 packed packed unaligned dcl 383 set ref 377
                                                                                  389*
external_mode_string                   parameter       char                     packed unaligned dcl 382 set ref 377 389*
fatal_sw                               parameter       bit(1)                   packed unaligned dcl 400 set ref 23 83* 319*
flags                    13            based           structure                array level 3 dcl 1-9
force                     0(03)        based           bit(1)                   initial level 2 packed packed unaligned dcl 2-18 set
                                                                                  ref 129* 133* 362*
get_pdir_                       000026 constant        entry                    external dcl 429 ref 366
i                               000257 automatic       fixed bin(17,0)          dcl 226 in procedure "set_modes" set ref 257* 258
                                                                                  259 263 266 267 271 274 275 279 282*
i                               000244 automatic       fixed bin(17,0)          dcl 413 in procedure "mrds_rst_proc_ctl_args" set
                                                                                  ref 102* 103* 108 139* 139 140 141* 162 164 172*
                                                                                  172*
iarg                                   parameter       char                     packed unaligned dcl 333 ref 329 335 337
length                                                 builtin function         dcl 415 ref 169 169 335
list                                   based           bit(1)                   initial level 2 packed packed unaligned dcl 2-18 set
                                                                                  ref 119* 121* 359*
local_area                      000260 automatic       area(1024)               dcl 227 set ref 227* 244 244
ltrim                                                  builtin function         dcl 415 ref 164
mode_bits                              parameter       structure                level 1 packed packed unaligned dcl 216 set ref 210
mode_defined                    002260 automatic       structure                level 1 packed packed unaligned dcl 228 set ref 243*
mode_name                 3            based           char(32)                 array level 3 packed packed unaligned dcl 1-9 set
                                                                                  ref 258 266 274 282*
mode_string                            parameter       char                     packed unaligned dcl 215 set ref 210 241 244*
mode_string_$parse              000052 constant        entry                    external dcl 223 ref 244
mode_string_info                       based           structure                level 1 dcl 1-9
mode_string_info_ptr            002262 automatic       pointer                  dcl 1-14 set ref 244* 248 251 257 258 259 263 266
                                                                                  267 271 274 275 279 282
mode_string_info_version_2             constant        fixed bin(17,0)          initial dcl 1-30 ref 248
mode_value                             based           structure                level 1 dcl 1-16
mode_value_version_3                   constant        fixed bin(17,0)          initial dcl 1-30 ref 251
modes                     2            based           structure                array level 2 dcl 1-9
mrds_error_$bad_source_path     000040 external static fixed bin(35,0)          dcl 444 set ref 348*
mrds_error_$no_temp_dir         000042 external static fixed bin(35,0)          dcl 445 set ref 140* 144*
msg                                    parameter       char                     packed unaligned dcl 315 set ref 312 318* 323
nargs                           000243 automatic       fixed bin(17,0)          dcl 412 set ref 86* 90 102 102 140
number                    1            based           fixed bin(17,0)          level 2 dcl 1-9 ref 257
opt_ok                          000170 automatic       bit(1)                   packed unaligned dcl 410 set ref 106* 110* 118* 121*
                                                                                  122* 124* 128* 132* 137* 151* 157* 176
protection                      002260 automatic       bit(1)                   level 2 packed packed unaligned dcl 228 set ref 262*
                                                                                  296
protection_on             0(01)        parameter       bit(1)                   level 2 in structure "mode_bits" packed packed
                                                                                  unaligned dcl 216 in procedure "set_modes" set ref
                                                                                  263* 296 303 306
protection_on             0(05)        based           bit(1)                   level 3 in structure "arg_info" packed packed
                                                                                  unaligned dcl 2-18 in procedure
                                                                                  "mrds_rst_proc_ctl_args" set ref 159*
rel_db_path                     000171 automatic       char(168)                packed unaligned dcl 411 set ref 99* 111* 192* 194*
                                                                                  196*
relation_mode_flags       0(04)        based           structure                level 2 packed packed unaligned dcl 2-18 set ref
                                                                                  152* 187* 367*
rollback                  0(01) 002260 automatic       bit(1)                   level 2 packed packed unaligned dcl 228 set ref 270*
                                                                                  300
rollback_on               0(03)        parameter       bit(1)                   level 2 in structure "mode_bits" packed packed
                                                                                  unaligned dcl 216 in procedure "set_modes" set ref
                                                                                  271* 300* 303
rollback_on               0(07)        based           bit(1)                   level 3 in structure "arg_info" packed packed
                                                                                  unaligned dcl 2-18 in procedure
                                                                                  "mrds_rst_proc_ctl_args" set ref 161*
secure                    0(02)        based           bit(1)                   initial level 2 packed packed unaligned dcl 2-18 set
                                                                                  ref 122* 125* 361*
sm_err_code                            parameter       fixed bin(35,0)          dcl 384 set ref 322* 377 387*
sm_err_msg                             parameter       char                     packed unaligned dcl 385 set ref 323* 377 388*
source                                 parameter       char                     packed unaligned dcl 345 set ref 340 352* 353*
source_dir                1            based           char(168)                level 2 packed packed unaligned dcl 2-18 set ref
                                                                                  352* 363*
source_entry             53            based           char(32)                 level 2 packed packed unaligned dcl 2-18 set ref 99
                                                                                  352* 364*
substr                                                 builtin function         dcl 415 ref 337
suffix_flag                            parameter       bit(1)                   packed unaligned dcl 423 ref 23 192
temp_work_dir           135            based           char(168)                level 2 packed packed unaligned dcl 2-18 set ref
                                                                                  146* 366*
twd                       0(01)        based           bit(1)                   initial level 2 packed packed unaligned dcl 2-18 set
                                                                                  ref 136* 360*
unspec                                                 builtin function         dcl 415 set ref 243*
version                                based           fixed bin(17,0)          level 2 in structure "mode_string_info" dcl 1-9
                                                                                  in procedure "set_modes" ref 248
version                   2            based           fixed bin(17,0)          array level 3 in structure "mode_string_info"
                                                                                  dcl 1-9 in procedure "set_modes" ref 251

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
mode_value_ptr                         automatic       pointer                  dcl 1-6
number_of_modes                        automatic       fixed bin(17,0)          dcl 1-6

NAMES DECLARED BY EXPLICIT CONTEXT.
error                           002465 constant        entry                    internal dcl 312 ref 90 95 104 140 142 144 147 164
                                                                                  169 178 180 196 246 248 251 259 267 275 282 303
                                                                                  306 348 353
exit                            001706 constant        label                    dcl 198 ref 325
get_source                      002610 constant        entry                    internal dcl 340 ref 97
init_arg_info                   002763 constant        entry                    internal dcl 357 ref 84
is_ctl_option                   002553 constant        entry                    internal dcl 329 ref 109 144 167 178 348
mrds_rst_proc_ctl_args          000331 constant        entry                    external dcl 23
parse_mode_string               001714 constant        entry                    external dcl 377
set_modes                       001761 constant        entry                    internal dcl 210 ref 187 389

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3310        3364    3043        3320
Length      3634    3043        54         234     244           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_rst_proc_ctl_args             1353 external procedure  is an external procedure.  
set_modes                               internal procedure  shares stack frame of external procedure mrds_rst_proc_ctl_args.  
error                                80 internal procedure  is called during a stack extension.  
is_ctl_option                           internal procedure  shares stack frame of external procedure mrds_rst_proc_ctl_args.  
get_source                              internal procedure  shares stack frame of external procedure mrds_rst_proc_ctl_args.  
init_arg_info                           internal procedure  shares stack frame of external procedure mrds_rst_proc_ctl_args.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_rst_proc_ctl_args   000100 arg_len                     mrds_rst_proc_ctl_args
                         000102 arg_ptr                     mrds_rst_proc_ctl_args
                         000104 code                        mrds_rst_proc_ctl_args
                         000105 dm_file_mode_string         mrds_rst_proc_ctl_args
                         000167 entry_name                  mrds_rst_proc_ctl_args
                         000170 opt_ok                      mrds_rst_proc_ctl_args
                         000171 rel_db_path                 mrds_rst_proc_ctl_args
                         000243 nargs                       mrds_rst_proc_ctl_args
                         000244 i                           mrds_rst_proc_ctl_args
                         000245 db_relation_modes           mrds_rst_proc_ctl_args
                         000256 code                        set_modes
                         000257 i                           set_modes
                         000260 local_area                  set_modes
                         002260 mode_defined                set_modes
                         002262 mode_string_info_ptr        set_modes

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this_desc  return_mac
tra_ext_1           shorten_stack       ext_entry           ext_entry_desc      int_entry_desc      set_chars_eis
op_empty_           index_before_cs

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            absolute_pathname_$add_suffix com_err_                      cu_$arg_count_rel
cu_$arg_ptr_rel               expand_pathname_$add_suffix   get_pdir_                     mode_string_$parse

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$bad_mode_value   error_table_$badopt           error_table_$bigarg
error_table_$noarg            error_table_$undefined_mode   error_table_$unimplemented_version
error_table_$wrong_no_of_args mrds_error_$bad_source_path   mrds_error_$no_temp_dir




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     23 000324        83 000336        84 000343        86 000344        88 000356        89 000360        90 000363
     94 000407        95 000431        97 000455        99 000474       102 000515       103 000527       104 000547
    106 000603       108 000605       109 000610       110 000632       111 000634       117 000641       118 000653
    119 000655       120 000663       121 000664       122 000706       123 000724       124 000730       125 000732
    126 000740       127 000741       128 000751       129 000753       130 000761       131 000762       132 000772
    133 000774       134 001002       135 001003       136 001013       137 001021       139 001023       140 001024
    141 001045       142 001064       144 001106       146 001145       147 001174       148 001215       149 001216
    151 001226       152 001230       153 001247       154 001252       155 001253       157 001267       158 001271
    159 001277       160 001302       161 001305       162 001310       164 001332       167 001417       169 001446
    171 001474       172 001501       176 001502       178 001504       180 001547       182 001567       187 001571
    192 001611       194 001642       196 001670       198 001706       377 001707       387 001734       388 001736
    389 001743       390 001760       210 001761       227 001772       241 001775       243 002005       244 002007
    246 002036       248 002057       251 002102       257 002126       258 002137       259 002147       262 002173
    263 002175       265 002210       266 002211       267 002215       270 002241       271 002243       273 002256
    274 002257       275 002263       278 002307       279 002311       281 002324       282 002325       284 002346
    296 002350       298 002365       300 002373       303 002401       306 002431       310 002463       312 002464
    317 002500       318 002504       319 002525       320 002533       322 002534       323 002540       325 002550
    329 002553       335 002564       337 002574       340 002610       348 002626       352 002703       353 002742
    355 002762       357 002763       359 002764       360 002772       361 002775       362 003000       363 003003
    364 003006       365 003011       366 003014       367 003023       369 003036


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
