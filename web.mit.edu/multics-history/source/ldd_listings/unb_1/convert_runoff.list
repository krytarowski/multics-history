	COMPILATION LISTING OF SEGMENT convert_runoff
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/23/85  1013.8 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   * Copyright, (C) Honeywell Information Systems Inc., 1980 *
        6*   *                                                         *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 /* Program to convert runoff source files to compose source files. */
       11 
       12 /* format: style2,ind3,ll80,dclind4,idind16,comcol41,linecom */
       13 
       14 convert_runoff:
       15 cv_rf:
       16    proc;
       17 
       18 /* SYNTAX:  convert_runoff X		no * convention */
       19 
       20 /* Written: JAF ?????? */
       21 /* Modified:
       22*01/??/82 - EJW - Rewritten because of various problems.
       23*10/07/82 - EJW - Fixed bug that truncated input pathname.
       24**/
       25 
       26 /* LOCAL STORAGE */
       27 
       28       dcl arg	      char (argl) based (argp);
       29 				/* command line argument */
       30       dcl argl	      fixed bin;
       31       dcl argp	      ptr;
       32       dcl bitct	      fixed bin (24);
       33 				/* segment bitcount */
       34       dcl cect	      fixed bin;	/* .ce line count */
       35       dcl code	      fixed bin (35);
       36 				/* system error code */
       37       dcl CREATE	      bit (1) static options (constant) init ("1"b);
       38       dcl csd	      char (1) init ("%");
       39 				/* current symbol delimiter */
       40       dcl ctd	      char (1);	/* local title delimiter */
       41       dcl db_line	      fixed bin init (-1);
       42 				/* debug ilino */
       43       dcl eqct	      fixed bin;	/* .eq line count */
       44       dcl eqsw	      bit (1) init ("1"b);
       45 				/* first .eq switch */
       46       dcl error_table_$badopt
       47 		      fixed bin (35) ext static;
       48       dcl error_table_$empty_file
       49 		      fixed bin (35) ext static;
       50       dcl ftntglsw	      bit (1);	/* footnote toggle switch */
       51       dcl i	      fixed bin;	/* working index */
       52       dcl ilin	      char (ilinl) based (ilinp);
       53 				/* current input line */
       54       dcl ilinl	      fixed bin (24);
       55 				/* length of input line */
       56       dcl ilino	      fixed bin;	/* input line counter */
       57       dcl ilinp	      ptr;	/* -> input line */
       58       dcl in_chars	      fixed bin (24);
       59 				/* input segment char count */
       60       dcl in_file	      char (200) var;
       61 				/* input file entryname */
       62       dcl indx	      fixed bin (24);
       63 				/* input file position index */
       64       dcl input_ptr	      ptr init (null ());
       65 				/* pointer to input file */
       66       dcl iseg	      char (in_chars) based (input_ptr);
       67 				/* input chars */
       68       dcl lict	      fixed bin;	/* literal count */
       69       dcl ME	      char (14) static options (constant)
       70 		      init ("convert_runoff");
       71       dcl nargs	      fixed bin;	/* number of command line args */
       72       dcl NL	      char (1) static options (constant) init ("
       73 ");
       74       dcl olin	      char (1024) var;
       75 				/* output line */
       76       dcl olino	      fixed bin;	/* output line counter */
       77       dcl olinox	      fixed bin;	/* extra olines used */
       78       dcl ondx	      fixed bin (24);
       79 				/* output file position index */
       80       dcl oseg	      char (out_chars) based (output_ptr);
       81 				/* output chars */
       82       dcl out_chars	      fixed bin (24);
       83 				/* output segment char count */
       84       dcl out_file	      char (200) var;
       85 				/* output file entryname */
       86       dcl output_ptr      ptr init (null ());
       87 				/* pointer to output file */
       88 
       89       dcl (before, convert, divide, hbound, index, reverse, rtrim, search,
       90 	substr)	      builtin;
       91 
       92       dcl (cleanup, conversion)
       93 		      condition;
       94 
       95       dcl com_err_	      entry options (variable);
       96       dcl cu_$arg_count   entry (fixed bin);
       97       dcl cu_$arg_ptr     entry (fixed bin, ptr, fixed bin, fixed bin (35));
       98       dcl ioa_	      entry options (variable);
       99 
      100 /* PROCESS COMMAND LINE */
      101 
      102       call ioa_ ("convert_runoff 1.6");
      103 
      104       call cu_$arg_count (nargs);
      105       if nargs < 1
      106       then
      107          do;
      108 	  call com_err_ (0, ME,
      109 	       "Usage: convert_runoff <runoff-file-pathname>");
      110 	  return;
      111          end;
      112 
      113       call cu_$arg_ptr (1, argp, argl, code);
      114       if code ^= 0
      115       then
      116          do;
      117 	  call com_err_ (code, ME, "Reading pathname of input segment.");
      118 	  return;
      119          end;
      120 
      121       in_file = before (arg, ".runoff") || ".runoff";
      122       call get_seg_ptr ((in_file), ^CREATE, bitct, input_ptr, code);
      123       if code ^= 0
      124       then
      125          do;
      126 in_file_err:
      127 	  call com_err_ (code, ME, "^a", in_file);
      128 	  return;
      129          end;
      130 
      131       on condition (cleanup)
      132          begin;			/* we now have something to clean up */
      133 	  out_chars = 0;
      134 	  call clean;
      135          end;
      136 
      137       if bitct = 0
      138       then
      139          do;
      140 	  call clean;
      141 	  code = error_table_$empty_file;
      142 	  goto in_file_err;
      143          end;
      144 
      145       in_chars = divide (bitct, 9, 24, 0);
      146 				/* if arg is a path, */
      147       i = search (reverse (arg), "<>"); /* take only entryname */
      148       if i = 0
      149       then i = argl + 1;
      150 
      151       out_file = before (substr (arg, argl + 2 - i), ".runoff") || ".compin";
      152       call get_seg_ptr (out_file, CREATE, 0, output_ptr, code);
      153       if code ^= 0
      154       then
      155          do;
      156 	  call com_err_ (code, ME, "^a", out_file);
      157 	  goto finish;
      158          end;
      159 
      160       if input_ptr = output_ptr
      161       then
      162          do;
      163 	  call com_err_ (0, ME,
      164 	       "Attempt to specify same segment as input and output.");
      165 	  goto finish;
      166          end;			/* any more args? */
      167       call cu_$arg_ptr (2, argp, argl, code);
      168       if code = 0
      169       then
      170          do;
      171 	  if arg = "-db"
      172 	  then
      173 	     do;
      174 	        call cu_$arg_ptr (3, argp, argl, code);
      175 
      176 	        on condition (conversion)
      177 		 begin;
      178 		    call com_err_ (0, ME, "Numeric value expected.");
      179 		    db_line = -1;
      180 		    goto revert;
      181 		 end;
      182 
      183 	        if code = 0
      184 	        then db_line = convert (db_line, arg);
      185 	        else db_line = 1;
      186 
      187 revert:
      188 	        revert conversion;
      189 	     end;
      190 
      191 	  else
      192 	     do;
      193 	        call com_err_ (error_table_$badopt, ME, "^a", arg);
      194 	        return;
      195 	     end;
      196          end;
      197 
      198       indx, ondx = 1;		/* initialize */
      199       ilino, olino, olinox, lict, cect, eqct, out_chars = 0;
      200       ftntglsw = "0"b;
      201 
      202 /* SCAN INPUT FILE */
      203 scan_loop:
      204       do while (indx <= in_chars);
      205          ilinl = index (substr (iseg, indx, in_chars - indx + 1), NL) - 1;
      206          if ilinl < 0		/* if no NL, take rest of seg */
      207 				/* MSFs SHOULD BE HANDLED HERE */
      208          then ilinl = in_chars - indx + 1;
      209 
      210          ilinp = addr (substr (iseg, indx));
      211 				/* point to input line */
      212          ilino = ilino + 1;		/* count input lines */
      213          olino = olino + olinox + 1;	/* and output lines */
      214          olinox = 0;		/* reset extra line count */
      215 
      216          if ilino >= db_line & db_line > 0
      217          then call ioa_ ("^6d^-in  = ^a", ilino, ilin);
      218 
      219          if lict > 0		/* if a literal */
      220          then
      221 	  do;
      222 	     olin = ilin;		/* move line to output */
      223 	     lict = lict - 1;	/* count literals */
      224 	  end;
      225 
      226          else
      227 	  do;
      228 	     if substr (ilin, 1, 1) ^= "."
      229 				/* or not a control */
      230 				/* or either comment */
      231 		| substr (ilin, 1, 2) = ".*" | substr (ilin, 1, 2) = ".~"
      232 	     then olin = ilin;	/* move line to output */
      233 
      234 	     else
      235 	        do;
      236 		 olin = "";	/* clear output line */
      237 		 call lookup;	/* check for a runoff control */
      238 
      239 		 if (index (olin, csd) ^= 0)
      240 		 then call builtin;
      241 
      242 		 if (index (olin, BSP) ^= 0)
      243 		 then call relational;
      244 	        end;
      245 
      246 	     cect = cect - 1;	/* count .ce lines */
      247 	     if cect = 0
      248 	     then
      249 	        do;
      250 		 olin = olin || NL || ".tbe";
      251 				/* end title block */
      252 		 olin = olin || NL || ".brb";
      253 				/* make it an orphan */
      254 		 olinox = olinox + 2;
      255 	        end;
      256 
      257 	     eqct = eqct - 1;	/* count .eq lines */
      258 	     if eqct = 0
      259 	     then
      260 	        do;
      261 		 olin = olin || NL || ".bet";
      262 				/* end title block */
      263 		 olinox = olinox + 1;
      264 
      265 		 if ctd ^= "|"
      266 		 then
      267 		    do;
      268 		       olin = olin || NL || ".ctd";
      269 		       olinox = olinox + 1;
      270 		    end;
      271 	        end;
      272 	  end;
      273 
      274          out_chars = out_chars + length (olin) + 1;
      275 				/* grow the output */
      276 				/* MSFs HERE? */
      277          substr (oseg, ondx) = olin || NL;
      278 				/* append line to output */
      279          ondx = out_chars + 1;	/* next output position */
      280          indx = indx + ilinl + 1;	/* advance to next input line */
      281 
      282          if ilino >= db_line & db_line > 0
      283          then call ioa_ ("^8d^-out = ^a", olino, olin);
      284       end scan_loop;
      285 
      286 finish:
      287       call clean;
      288 exit:
      289       return;
      290 
      291 /* CONVERT RUNOFF CONTROLS */
      292 
      293 lookup:
      294    proc;
      295 
      296       dcl ctl_token	      char (4);	/* the runoff control */
      297       dcl varfld	      char (512) var;
      298 				/* variable field for control */
      299 
      300 /* 'tokens' declared at the end of the segment */
      301 
      302 relook:
      303       ctl_token = substr (ilin, 1, min (length (ilin), 4));
      304       if length (ilin) > 4
      305       then varfld = rtrim (substr (ilin, 4));
      306 				/* take SP, too */
      307       else varfld = "";
      308 
      309       do i = 1 to hbound (tokens, 1);	/* go thru token list */
      310 
      311          if substr (tokens (i), 1, 4) = ctl_token
      312 				/* is this the one? */
      313          then
      314 	  do;			/* if a 1-to-1 token replacement */
      315 	     if substr (tokens (i), 5, 1) = " "
      316 		| substr (tokens (i), 5, 1) = "*"
      317 	     then
      318 	        do;
      319 		 olin = olin || substr (tokens (i), 6);
      320 		 olin = olin || varfld;
      321 				/* varfld starts with SP */
      322 		 return;
      323 	        end;
      324 
      325 	     else
      326 	        do;
      327 		 goto rtn (index ("123456789.", substr (tokens (i), 6, 1)));
      328 
      329 rtn (0):
      330 		 call ioa_ ("Line ^i: ^a not handled.", ilino, ctl_token);
      331 		 return;
      332 
      333 rtn (1):				/* .ar */
      334 		 olin = olin || ".ur .brp " || csd || "PageNo" || csd
      335 		      || " ar";
      336 		 return;
      337 
      338 
      339 rtn (2):				/*  .ro */
      340 		 olin = olin || ".ur .brp " || csd || "PageNo" || csd
      341 		      || " rl";
      342 		 return;
      343 
      344 rtn (3):				/* .ce */
      345 		 olin = olin || ".tbb";
      346 				/* start a title block */
      347 		 olin = olin || NL || ".alc";
      348 				/* centered */
      349 		 olin = olin || NL || ".fif";
      350 				/* and unfilled */
      351 		 olinox = olinox + 2;
      352 
      353 		 if varfld = ""	/* default count is 1 */
      354 		 then cect = 2;	/* must be set one too high because */
      355 				/* of the way counting is done in the */
      356 				/* main loop */
      357 		 else
      358 		    do;		/* use given count */
      359 		       on conversion
      360 			begin;
      361 			   call ioa_ ("^a: Numeric value expected in ^a",
      362 			        ME, ilin);
      363 			   cect = 2;
      364 				/* again, 1 too high */
      365 			   goto revert3;
      366 			end;
      367 
      368 		       cect = convert (cect, varfld) + 1;
      369 				/* 1 too high */
      370 
      371 revert3:
      372 		       revert conversion;
      373 		    end;
      374 
      375 		 return;
      376 
      377 rtn (4):				/* .eq  */
      378 		 olin = ".bbt";
      379 
      380 		 if varfld = ""	/* default count is 1 */
      381 		 then eqct = 2;	/* must be set one too high because */
      382 				/* of the way counting is done in the */
      383 				/* main loop */
      384 		 else
      385 		    do;		/* use given count */
      386 		       on conversion
      387 			begin;
      388 			   call ioa_ ("^a: Numeric value expected in ^a",
      389 			        ME, ilin);
      390 			   eqct = 2;
      391 				/* again, 1 too high */
      392 			   goto revert4;
      393 			end;
      394 
      395 		       eqct = convert (eqct, varfld) + 1;
      396 				/* 1 too high */
      397 
      398 revert4:
      399 		       revert conversion;
      400 		    end;		/* need a delimiter change? */
      401 		 ctd =		/* get first char of next line */
      402 		      substr (iseg, indx + ilinl + 1, 1);
      403 		 if ctd ^= "|"
      404 		 then
      405 		    do;
      406 		       olin = olin || NL || ".ctd " || ctd;
      407 		       olinox = olinox + 1;
      408 		    end;
      409 
      410 		 return;
      411 
      412 rtn (5):				/* .fr  */
      413 		 varfld = ltrim (varfld);
      414 
      415 		 if varfld = "t"
      416 		 then olin = ".ftp";
      417 
      418 		 else if varfld = "f"
      419 		 then olin = ".ftr";
      420 
      421 		 else if varfld = "u"
      422 		 then olin = ".ftu";
      423 
      424 		 else olin = ".ftp";
      425 		 return;
      426 
      427 
      428 rtn (6):				/* .ft  */
      429 		 if ftntglsw
      430 		 then olin = ".bef";
      431 		 else olin = ".bbf";
      432 		 ftntglsw = ^ftntglsw;
      433 		 return;
      434 
      435 rtn (7):				/* .li  */
      436 		 if varfld = ""	/* default count is 1 */
      437 		 then varfld = " 1";
      438 
      439 		 on conversion
      440 		    begin;
      441 		       call ioa_ ("^a: Numeric value expected in ^a", ME,
      442 			  ilin);
      443 		       varfld = " 1";
      444 		       goto revert7;
      445 		    end;
      446 
      447 		 lict = convert (lict, varfld);
      448 
      449 revert7:
      450 		 revert conversion;
      451 
      452 		 olin = ".bbl" || varfld;
      453 
      454 		 return;
      455 
      456 rtn (8):				/* .ma  */
      457 		 if varfld = ""	/* default is 1 */
      458 		 then varfld = " 1";
      459 
      460 		 olin = ".vmt" || varfld || NL;
      461 		 olinox = olinox + 1;
      462 		 olin = olin || ".vmb" || varfld;
      463 
      464 		 return;
      465 
      466 rtn (9):				/* .ur  */
      467 		 do while (substr (ilin, 1, 3) = ".ur");
      468 				/* do all .ur's */
      469 		    olin = olin || ".ur ";
      470 				/* place a .ur */
      471 		    j = 2 +	/* step over .ur */
      472 		         verify (substr (ilin, min (ilinl, 4)), " ");
      473 		    indx = indx + j;
      474 		    ilinp = addr (substr (iseg, indx));
      475 				/* move input pointer */
      476 		    ilinl = ilinl - j;
      477 		 end;
      478 
      479 		 if length (olin) > 4
      480 		 then call ioa_ (
      481 			 "Output line ^i: Multiple .ur's. Check for "
      482 			 || "correct symbol delimiter nesting.", olino);
      483 
      484 		 if index (ilin, ".") = 1
      485 				/* is it a control? */
      486 		 then goto relook;
      487 		 else
      488 		    do;
      489 		       olin = olin || ilin;
      490 		       return;
      491 		    end;
      492 
      493 rtn (10):				/* headers/footers */
      494 				/* need a delimiter change? */
      495 		 j = verify (varfld, " 0123456789");
      496 		 ctd = substr (varfld, j, 1);
      497 		 if ctd ^= "|"
      498 		 then
      499 		    do;
      500 		       olin = olin || ".ctd " || ctd || NL;
      501 		       olinox = olinox + 1;
      502 		    end;
      503 
      504 		 olin = olin || substr (tokens (i), 6);
      505 		 olin = olin || varfld;
      506 
      507 		 if ctd = "|"
      508 		 then return;
      509 
      510 		 olin = olin || NL || ".ctd";
      511 		 olinox = olinox + 1;
      512 		 return;
      513 
      514 	        end;
      515 	  end;
      516       end;
      517 
      518 /* table search failed. line isnt a control */
      519       olin = ilin;
      520    end lookup;
      521 
      522 /* CONVERT RUNOFF BUILTINS */
      523 builtin:
      524    proc;
      525 
      526 /* Scan the line for cds, extracting the contained variable names.
      527*   If there is no valid variable name, output a csd||PageNo||csd.
      528*   If there is a valid variable name, then search the builtin list;
      529*   if found, then process according to the list.
      530*   if not, then output it, as-is. */
      531 
      532       dcl bname	      char (32) var;/* extracted variable name */
      533       dcl csdct	      fixed bin;	/* count of opening csd's */
      534       dcl (i, j, k)	      fixed bin;	/* working index */
      535 
      536       i = 1;			/* init line scan index */
      537 
      538       do while (i <= length (olin));
      539          j = index (substr (olin, i), csd);
      540 				/* look for a csd */
      541          if j = 0			/* if none, */
      542          then return;		/* we're done */
      543          else i = i + j - 1;		/* move to csd */
      544 
      545          csdct = verify (substr (olin, i), csd) - 1;
      546 				/* step over csd's */
      547 
      548          if csdct < 0		/* a trailing csd? */
      549          then
      550 	  do;
      551 	     olin = olin || "PageNo" || csd;
      552 	     return;
      553 	  end;
      554 
      555          i = i + csdct;		/* move to first name char */
      556          j = index (substr (olin, i), csd);
      557 				/* look for next csd */
      558 
      559          if j = 0			/* no more in olin? */
      560          then goto Np_ref;
      561          else j = j - 1;
      562 
      563          bname = substr (olin, i, j);	/* extract old name, j holds length */
      564          k = verify (bname,		/* and validate it */
      565 	    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789")
      566 	    ;
      567 
      568          if k ^= 0			/* use %PageNo% for invalid names */
      569          then
      570 	  do;
      571 Np_ref:
      572 	     olin = substr (olin, 1, i - 1) || "PageNo" || csd
      573 		|| substr (olin, i);
      574 	     i = i + 7;
      575 	  end;
      576 
      577          else
      578 	  do;
      579 	     do k = 1 to hbound (builtin_name, 1);
      580 	        if (bname = substr (builtin_name (k), 1, 20))
      581 	        then
      582 		 do;
      583 		    if length (builtin_name (k)) < 21
      584 		    then
      585 		       do;	/* not supported? */
      586 			call ioa_ (
      587 			     "Line ^i: Builtin %^a% is not supported.",
      588 			     ilino, bname);
      589 			goto found;
      590 		       end;
      591 
      592 		    else if substr (builtin_name (k), 21, 1) = "."
      593 		    then
      594 		       do;
      595 			olin = ".ur " || olin;
      596 				/* prepend another .ur */
      597 			i = i + 4;/* bif ref has moved */
      598 			call ioa_ (
      599 			     "Output line ^i: Multiple .ur's. Check for "
      600 			     || "correct symbol delimiter nesting.",
      601 			     olino);
      602 
      603 			goto bif (
      604 			     index ("1234",
      605 			     substr (builtin_name (k), 22, 1)));
      606 
      607 bif (0):				/* error */
      608 			call ioa_ ("Line ^d: Program error processing "
      609 			     || "builtin ^a", ilino, bname);
      610 			goto found;
      611 
      612 bif (1):				/* %(%AlignMode% = ""both"")% */
      613 			bname = csd || "(" || csd || "AlignMode" || csd
      614 			     || "= ""both"")" || csd;
      615 			goto found;
      616 
      617 bif (2):				/* %(%FootReset% = ""paged"")% */
      618 			bname = csd || "(" || csd || "FootReset" || csd
      619 			     || "= ""paged"")" || csd;
      620 			goto found;
      621 
      622 bif (3):				/* %(%FootReset% = ""u"")% */
      623 			bname = csd || "(" || csd || "FootReset" || csd
      624 			     || "= ""u"")" || csd;
      625 			goto found;
      626 
      627 bif (4):				/* %(%Device% = ""printer"")% */
      628 			bname = csd || "(" || csd || "Device" || csd
      629 			     || "= ""Printer"")" || csd;
      630 			goto found;
      631 		       end;
      632 
      633 		    else
      634 		       do;
      635 			bname = substr (builtin_name (k), 21);
      636 				/* get new name */
      637 			goto found;
      638 		       end;
      639 		 end;
      640 	     end;
      641 found:
      642 	     olin = substr (olin, 1, i - 1) || bname || substr (olin, i + j);
      643 	     i = i + length (bname);	/* move to csd */
      644 	     i = i + csdct;		/* step over closing csd's */
      645 	  end;
      646       end;
      647    end builtin;
      648 
      649 relational:
      650    proc;
      651 
      652       dcl (i, k)	      fixed bin;	/* working index */
      653       dcl relop	      char (3);	/* local copy of rel operator */
      654       dcl rels	      (8) char (6) static options (constant)
      655 		      init ("/= ^=", "=/ ^=",
      656 				/* these all doubled so */
      657 		      "<_ <=", "_< <=",
      658 				/* canonical form isnt needed */
      659 		      "=_ ==", "_= ==", ">_ >=", "_> >=");
      660 
      661       i = 1;
      662       do while (i <= length (olin));
      663          k = index (substr (olin, i), BSP);
      664 				/* look for a BSP */
      665          if k = 0 | k = length (olin)	/* if none or trailing BSP, */
      666          then return;		/* we're done */
      667          else i = i + k - 2;		/* move to preceding char */
      668 
      669          relop = substr (olin, i, 3);	/* extract the rel operator */
      670 
      671          do k = 1 to 8;
      672 	  if (relop = substr (rels (k), 1, 3))
      673 	  then
      674 	     do;
      675 	        olin = substr (olin, 1, i - 1) || substr (rels (k), 5)
      676 		   || substr (olin, i + 3);
      677 	     end;
      678          end;
      679          i = i + 3;			/* step over relop */
      680       end;
      681 
      682    end relational;
      683 
      684 get_seg_ptr:
      685    proc (pname, create, bitct, ptr, code);
      686 
      687       dcl pname	      char (200) var;
      688 				/* given pathname */
      689       dcl create	      bit (1);	/* create switch */
      690       dcl bitct	      fixed bin (24);
      691 				/* bitcount */
      692       dcl ptr	      ptr;	/* seg pointer */
      693       dcl code	      fixed bin (35);
      694 				/* error code */
      695 
      696       dcl dname	      char (168);	/* file dirname */
      697       dcl ename	      char (32);	/* file entryname */
      698 
      699       dcl expand_pathname_
      700 		      entry (char (*), char (*), char (*), fixed bin (35));
      701       dcl hcs_$initiate_count
      702 		      entry (char (*), char (*), char (*), fixed bin (24),
      703 		      fixed bin (2), ptr, fixed bin (35));
      704       dcl hcs_$make_seg   entry (char (*), char (*), char (*), fixed bin (5),
      705 		      ptr, fixed bin (35));
      706 
      707       call expand_pathname_ ((pname), dname, ename, code);
      708       if code ^= 0
      709       then return;
      710 
      711       call hcs_$initiate_count (dname, ename, "", bitct, 0, ptr, code);
      712       if ptr ^= null ()
      713       then
      714          do;
      715 	  code = 0;
      716 	  return;
      717          end;
      718 
      719       if create
      720       then call hcs_$make_seg (dname, ename, "", 01010b, ptr, code);
      721 
      722    end get_seg_ptr;
      723 
      724 release_seg_ptr_:
      725    proc (pt, bitct, code);
      726 
      727       dcl pt	      ptr,
      728 	bitct	      fixed bin (24),
      729 	code	      fixed bin (35);
      730 
      731       dcl hcs_$set_bc_seg entry (ptr, fixed bin (24), fixed bin (35));
      732       dcl hcs_$terminate_noname
      733 		      entry (ptr, fixed bin (35));
      734 
      735       code = 0;
      736       if (pt = null ())
      737       then return;
      738       if (bitct > -1)
      739       then call hcs_$set_bc_seg (pt, bitct, code);
      740       if (code = 0)
      741       then call hcs_$terminate_noname (pt, code);
      742 
      743    end;
      744 
      745 
      746 clean:
      747    proc;
      748       if (output_ptr ^= null ())
      749       then call release_seg_ptr_ (output_ptr, out_chars * 9, code);
      750       if (input_ptr ^= null ())
      751       then call release_seg_ptr_ (input_ptr, -1, code);
      752    end;
      753 
      754       dcl BSP	      char (1) int static init ("");
      755       dcl iox_$attach_name
      756 		      entry (char (*), ptr, char (*), ptr, fixed bin (35));
      757       dcl iox_$close      entry (ptr, fixed bin (35));
      758       dcl iox_$detach_iocb
      759 		      entry (ptr, fixed bin (35));
      760       dcl iox_$get_line   entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35))
      761 		      ;
      762       dcl iox_$open	      entry (ptr, fixed bin, bit (1), fixed bin (35));
      763       dcl j	      fixed bin;
      764       dcl recl	      fixed bin;
      765 
      766       dcl (addr, length, mod)
      767 		      builtin;
      768 
      769 /***** CONSTANT ARRAYS */
      770       dcl builtin_name    (58) char (50) var static options (constant)
      771 		      init ("Ad                  .1", "Ce", "CharsTable",
      772 		      "Charsw", "Console             UserInput",
      773 		      "ConvTable", "Date                Date",
      774 		      "Device              Device", "DeviceTable", "Eq",
      775 		      "Eqcnt               Eqcnt",
      776 		      "ExtraMargin         ExtraMargin",
      777 		      "Fi                  FillMode",
      778 		      "Filesw              OutputFileOpt",
      779 		      "Foot                Footcnt", "FootRef", "Fp",
      780 		      "Fr                  .2", "From",
      781 		      "Ft                  FootnoteMode",
      782 		      "Hyphenating         Hyphenating",
      783 		      "In                  Indent",
      784 		      "InputFileName       InputFileName",
      785 		      "InputLines          InputLineno",
      786 		      "LinesLeft           LinesLeft",
      787 		      "Ll                  PageWidth", "Lp",
      788 		      "Ma1                 VMargTop",
      789 		      "Ma2                 VMargHeader",
      790 		      "Ma3                 VMargFooter",
      791 		      "Ma4                 VMargBottom",
      792 		      "Ms                  LineSpace",
      793 		      "MultiplePagecount   PageSpace",
      794 		      "NestingDepth        InsertIndex",
      795 		      "Nl                  PageLine",
      796 		      "NNp                 NextPageNo",
      797 		      "NoFtNo              .3",
      798 		      "NoPaging            Galley",
      799 		      "Np                  PageNo", "PadLeft",
      800 		      "PageNo              PageNo",
      801 				/* compose bif needed for */
      802 				/* correct handling of .ar and .ro */
      803 		      "Parameter           Parameter",
      804 		      "Passes              Pass",
      805 		      "Pi                  PictureCount",
      806 		      "Pl                  PageLength",
      807 		      "Printersw           .4",
      808 		      "PrintLineNumbers    LineNumberOpt", "Roman", "Selsw",
      809 		      "SpecCh              SymbolDelimiter", "Start",
      810 		      "Stopsw              StopOpt", "TextRef", "Time",
      811 		      "To", "TrTable             TrTable",
      812 		      "Un                  Undent",
      813 		      "Waitsw              WaitOpt");
      814 				/* entries in this array are coded */
      815 				/* chars 1,4 - runoff control */
      816 				/* char  5   - action flag */
      817 				/* chars 6,$ - replacement or */
      818 				/*	     function index */
      819 /**** format: off */
      820 dcl tokens	(55) char (12) var static options (constant) init (
      821 		".ad  .alb", ".ar -1",      ".bp  .brp", ".br  .brf",
      822 		".cc  .csd", ".ce -3",      ".ch  .tre", ".ds  .ls 2",
      823 		".ef -.fle", ".eh -.hle",   ".eq -4",    ".ep  .brp e",
      824 ".ex  .exc",
      825 		".fh -.hlf", ".fi  .fin",   ".fo -.fla", ".fr -5",
      826 		".ft -6",    ".gb  .go",    ".gf  .go",  ".he -.hla",
      827 		".if  .ifi", ".in  .inl",   ".la  .la",  ".li -7",
      828 		".ll  .pdw", ".m1  .vmt",   ".m2  .vmh", ".m3  .vmf",
      829 		".m4  .vmb", ".ma -8",      ".mp  .ps",  ".ms  .ls",
      830 		".na  .all", ".ne  .brn",   ".nf  .fif", ".of -.flo",
      831 		".oh -.hlo", ".op  .brp o", ".pa  .brp", ".pi  .bbp",
      832 		".pl  .pdl", ".rd  .rd",    ".ro -2",    ".rt  .rt",
      833 		".sk  .brs", ".sp  .spb",   ".sr  .srv", ".ss  .ls 1",
      834 		".tr  .trn", ".ts  .ts",    ".ty  .ty",  ".un  .unl",
      835 		".ur -9",    ".wt  .wt");
      836 /*** format: on */
      837    end convert_runoff;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/23/85  0911.3  convert_runoff.pl1                >spec>online>comp>convert_runoff.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BSP                                    constant        char(1)                  initial unaligned dcl 754 ref 242 663
CREATE                                 constant        bit(1)                   initial unaligned dcl 37 set ref 122 152*
ME                              002044 constant        char(14)                 initial unaligned dcl 69 set ref 108* 117* 126* 156*
                                                                                  163* 178* 193* 361* 388* 441*
NL                              010020 constant        char(1)                  initial unaligned dcl 72 ref 205 250 252 261 268 277
                                                                                  347 349 406 460 500 510
addr                                                   builtin function         dcl 766 ref 210 474
arg                                    based           char                     unaligned dcl 28 set ref 121 147 151 171 183 193*
argl                            000100 automatic       fixed bin(17,0)          dcl 30 set ref 113* 121 147 148 151 151 167* 171
                                                                                  174* 183 193 193
argp                            000102 automatic       pointer                  dcl 31 set ref 113* 121 147 151 167* 171 174* 183
                                                                                  193
before                                                 builtin function         dcl 89 ref 121 151
bitct                                  parameter       fixed bin(24,0)          dcl 727 in procedure "release_seg_ptr_" set ref 724
                                                                                  738 738*
bitct                                  parameter       fixed bin(24,0)          dcl 690 in procedure "get_seg_ptr" set ref 684 711*
bitct                           000104 automatic       fixed bin(24,0)          dcl 32 in procedure "cv_rf" set ref 122* 137 145
bname                           000732 automatic       varying char(32)         dcl 532 set ref 563* 564 580 586* 607* 612* 617*
                                                                                  622* 627* 635* 641 643
builtin_name                    000370 constant        varying char(50)         initial array dcl 770 ref 579 580 583 592 603 635
cect                            000105 automatic       fixed bin(17,0)          dcl 34 set ref 199* 246* 246 247 353* 363* 368* 368
cleanup                         000706 stack reference condition                dcl 92 ref 131
code                                   parameter       fixed bin(35,0)          dcl 727 in procedure "release_seg_ptr_" set ref 724
                                                                                  735* 738* 740 740*
code                            000106 automatic       fixed bin(35,0)          dcl 35 in procedure "cv_rf" set ref 113* 114 117*
                                                                                  122* 123 126* 141* 152* 153 156* 167* 168 174* 183
                                                                                  748* 750*
code                                   parameter       fixed bin(35,0)          dcl 693 in procedure "get_seg_ptr" set ref 684 707*
                                                                                  708 711* 715* 719*
com_err_                        000014 constant        entry                    external dcl 95 ref 108 117 126 156 163 178 193
conversion                      000714 stack reference condition                dcl 92 ref 176 187 359 371 386 398 439 449
convert                                                builtin function         dcl 89 ref 183 368 395 447
create                                 parameter       bit(1)                   unaligned dcl 689 ref 684 719
csd                             000107 automatic       char(1)                  initial unaligned dcl 38 set ref 38* 239 333 333 339
                                                                                  339 539 545 551 556 571 612 612 612 612 617 617
                                                                                  617 617 622 622 622 622 627 627 627 627
csdct                           000743 automatic       fixed bin(17,0)          dcl 533 set ref 545* 548 555 644
ctd                             000110 automatic       char(1)                  unaligned dcl 40 set ref 265 401* 403 406 496* 497
                                                                                  500 507
ctl_token                       000100 automatic       char(4)                  unaligned dcl 296 set ref 302* 311 329*
cu_$arg_count                   000016 constant        entry                    external dcl 96 ref 104
cu_$arg_ptr                     000020 constant        entry                    external dcl 97 ref 113 167 174
db_line                         000111 automatic       fixed bin(17,0)          initial dcl 41 set ref 41* 179* 183* 183 185* 216
                                                                                  216 282 282
divide                                                 builtin function         dcl 89 ref 145
dname                           000770 automatic       char(168)                unaligned dcl 696 set ref 707* 711* 719*
ename                           001042 automatic       char(32)                 unaligned dcl 697 set ref 707* 711* 719*
eqct                            000112 automatic       fixed bin(17,0)          dcl 43 set ref 199* 257* 257 258 380* 390* 395* 395
eqsw                            000113 automatic       bit(1)                   initial unaligned dcl 44 set ref 44*
error_table_$badopt             000010 external static fixed bin(35,0)          dcl 46 set ref 193*
error_table_$empty_file         000012 external static fixed bin(35,0)          dcl 48 ref 141
expand_pathname_                000024 constant        entry                    external dcl 699 ref 707
ftntglsw                        000114 automatic       bit(1)                   unaligned dcl 50 set ref 200* 428 432* 432
hbound                                                 builtin function         dcl 89 ref 309 579
hcs_$initiate_count             000026 constant        entry                    external dcl 701 ref 711
hcs_$make_seg                   000030 constant        entry                    external dcl 704 ref 719
hcs_$set_bc_seg                 000032 constant        entry                    external dcl 731 ref 738
hcs_$terminate_noname           000034 constant        entry                    external dcl 732 ref 740
i                               000756 automatic       fixed bin(17,0)          dcl 652 in procedure "relational" set ref 661* 662
                                                                                  663 667* 667 669 675 675 679* 679
i                               000744 automatic       fixed bin(17,0)          dcl 534 in procedure "builtin" set ref 536* 538 539
                                                                                  543* 543 545 555* 555 556 563 571 571 574* 574
                                                                                  597* 597 641 641 643* 643 644* 644
i                               000115 automatic       fixed bin(17,0)          dcl 51 in procedure "cv_rf" set ref 147* 148 148*
                                                                                  151 309* 311 315 315 319 327 504*
ilin                                   based           char                     unaligned dcl 52 set ref 216* 222 228 228 228 228
                                                                                  302 302 304 304 361* 388* 441* 466 471 484 489 519
ilinl                           000116 automatic       fixed bin(24,0)          dcl 54 set ref 205* 206 206* 216 216 222 228 228 228
                                                                                  228 280 302 302 304 304 361 361 388 388 401 441
                                                                                  441 466 471 471 476* 476 484 489 519
ilino                           000117 automatic       fixed bin(17,0)          dcl 56 set ref 199* 212* 212 216 216* 282 329* 586*
                                                                                  607*
ilinp                           000120 automatic       pointer                  dcl 57 set ref 210* 216 222 228 228 228 228 302 302
                                                                                  304 304 361 388 441 466 471 474* 484 489 519
in_chars                        000122 automatic       fixed bin(24,0)          dcl 58 set ref 145* 203 205 205 206 210 401 474
in_file                         000123 automatic       varying char(200)        dcl 60 set ref 121* 122 126*
index                                                  builtin function         dcl 89 ref 205 239 242 327 484 539 556 603 663
indx                            000206 automatic       fixed bin(24,0)          dcl 62 set ref 198* 203 205 205 206 210 280* 280 401
                                                                                  473* 473 474
input_ptr                       000210 automatic       pointer                  initial dcl 64 set ref 64* 122* 160 205 210 401 474
                                                                                  750 750*
ioa_                            000022 constant        entry                    external dcl 98 ref 102 216 282 329 361 388 441 479
                                                                                  586 598 607
iseg                                   based           char                     unaligned dcl 66 set ref 205 210 401 474
j                               000745 automatic       fixed bin(17,0)          dcl 534 in procedure "builtin" set ref 539* 541 543
                                                                                  556* 559 561* 561 563 641
j                               000722 automatic       fixed bin(17,0)          dcl 763 in procedure "cv_rf" set ref 471* 473 476
                                                                                  493* 496
k                               000746 automatic       fixed bin(17,0)          dcl 534 in procedure "builtin" set ref 564* 568 579*
                                                                                  580 583 592 603 635*
k                               000757 automatic       fixed bin(17,0)          dcl 652 in procedure "relational" set ref 663* 665
                                                                                  665 667 671* 672 675*
length                                                 builtin function         dcl 766 ref 274 302 304 479 538 583 643 662 665
lict                            000212 automatic       fixed bin(17,0)          dcl 68 set ref 199* 219 223* 223 447* 447
nargs                           000213 automatic       fixed bin(17,0)          dcl 71 set ref 104* 105
olin                            000214 automatic       varying char(1024)       dcl 74 set ref 222* 228* 236* 239 242 250* 250 252*
                                                                                  252 261* 261 268* 268 274 277 282* 319* 319 320*
                                                                                  320 333* 333 339* 339 344* 344 347* 347 349* 349
                                                                                  377* 406* 406 415* 418* 421* 424* 428* 431* 452*
                                                                                  460* 462* 462 469* 469 479 489* 489 500* 500 504*
                                                                                  504 505* 505 510* 510 519* 538 539 545 551* 551
                                                                                  556 563 571* 571 571 595* 595 641* 641 641 662 663
                                                                                  665 669 675* 675 675
olino                           000615 automatic       fixed bin(17,0)          dcl 76 set ref 199* 213* 213 282* 479* 598*
olinox                          000616 automatic       fixed bin(17,0)          dcl 77 set ref 199* 213 214* 254* 254 263* 263 269*
                                                                                  269 351* 351 407* 407 461* 461 501* 501 511* 511
ondx                            000617 automatic       fixed bin(24,0)          dcl 78 set ref 198* 277 279*
oseg                                   based           char                     unaligned dcl 80 set ref 277*
out_chars                       000620 automatic       fixed bin(24,0)          dcl 82 set ref 133* 199* 274* 274 277 279 748
out_file                        000621 automatic       varying char(200)        dcl 84 set ref 151* 152* 156*
output_ptr                      000704 automatic       pointer                  initial dcl 86 set ref 86* 152* 160 277 748 748*
pname                                  parameter       varying char(200)        dcl 687 ref 684 707
pt                                     parameter       pointer                  dcl 727 set ref 724 736 738* 740*
ptr                                    parameter       pointer                  dcl 692 set ref 684 711* 712 719*
relop                           000760 automatic       char(3)                  unaligned dcl 653 set ref 669* 672
rels                            000020 constant        char(6)                  initial array unaligned dcl 654 ref 672 675
reverse                                                builtin function         dcl 89 ref 147
rtrim                                                  builtin function         dcl 89 ref 304
search                                                 builtin function         dcl 89 ref 147
substr                                                 builtin function         dcl 89 set ref 151 205 210 228 228 228 277* 302 304
                                                                                  311 315 315 319 327 401 466 471 474 496 504 539
                                                                                  545 556 563 571 571 580 592 603 635 641 641 663
                                                                                  669 672 675 675 675
tokens                          000034 constant        varying char(12)         initial array dcl 820 ref 309 311 315 315 319 327
                                                                                  504
varfld                          000101 automatic       varying char(512)        dcl 297 set ref 304* 307* 320 353 368 380 395 412*
                                                                                  412 415 418 421 435 435* 443* 447 452 456 456* 460
                                                                                  462 493 496 505

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
iox_$attach_name                000000 constant        entry                    external dcl 755
iox_$close                      000000 constant        entry                    external dcl 757
iox_$detach_iocb                000000 constant        entry                    external dcl 758
iox_$get_line                   000000 constant        entry                    external dcl 760
iox_$open                       000000 constant        entry                    external dcl 762
mod                                                    builtin function         dcl 766
recl                                   automatic       fixed bin(17,0)          dcl 764

NAMES DECLARED BY EXPLICIT CONTEXT.
Np_ref                          005771 constant        label                    dcl 571 ref 559
bif                             000013 constant        label                    array(0:4) dcl 607 ref 603
builtin                         005615 constant        entry                    internal dcl 523 ref 239
clean                           007117 constant        entry                    internal dcl 746 ref 134 140 286
convert_runoff                  002422 constant        entry                    external dcl 14
cv_rf                           002412 constant        entry                    external dcl 14
exit                            003775 constant        label                    dcl 288
finish                          003771 constant        label                    dcl 286 ref 157 165
found                           006464 constant        label                    dcl 641 ref 589 610 615 620 625 630 637
get_seg_ptr                     006666 constant        entry                    internal dcl 684 ref 122 152
in_file_err                     002617 constant        label                    dcl 126 ref 142
lookup                          003777 constant        entry                    internal dcl 293 ref 237
relational                      006541 constant        entry                    internal dcl 649 ref 242
release_seg_ptr_                007052 constant        entry                    internal dcl 724 ref 748 750
relook                          004004 constant        label                    dcl 302 ref 484
revert                          003217 constant        label                    dcl 187 ref 180
revert3                         004544 constant        label                    dcl 371 ref 365
revert4                         004651 constant        label                    dcl 398 ref 392
revert7                         005135 constant        label                    dcl 449 set ref 444
rtn                             000000 constant        label                    array(0:10) dcl 329 ref 327
scan_loop                       003267 constant        label                    dcl 203

NAMES DECLARED BY CONTEXT OR IMPLICATION.
ltrim                                                  builtin function         ref 412
min                                                    builtin function         ref 302 471
null                                                   builtin function         ref 64 86 712 736 748 750
verify                                                 builtin function         ref 471 493 545 564

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10250       10306   10026       10260
Length     10530   10026        36         205     221           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cv_rf                               906 external procedure  is an external procedure.  
on unit on line 131                  64 on unit               
on unit on line 176                  86 on unit               
lookup                              383 internal procedure  enables or reverts conditions.  
on unit on line 359                  88 on unit               
on unit on line 386                  88 on unit               
on unit on line 439                  88 on unit               
builtin                                 internal procedure  shares stack frame of external procedure cv_rf.  
relational                              internal procedure  shares stack frame of external procedure cv_rf.  
get_seg_ptr                             internal procedure  shares stack frame of external procedure cv_rf.  
release_seg_ptr_                        internal procedure  shares stack frame of internal procedure clean.  
clean                                90 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cv_rf                    000100 argl                        cv_rf
                         000102 argp                        cv_rf
                         000104 bitct                       cv_rf
                         000105 cect                        cv_rf
                         000106 code                        cv_rf
                         000107 csd                         cv_rf
                         000110 ctd                         cv_rf
                         000111 db_line                     cv_rf
                         000112 eqct                        cv_rf
                         000113 eqsw                        cv_rf
                         000114 ftntglsw                    cv_rf
                         000115 i                           cv_rf
                         000116 ilinl                       cv_rf
                         000117 ilino                       cv_rf
                         000120 ilinp                       cv_rf
                         000122 in_chars                    cv_rf
                         000123 in_file                     cv_rf
                         000206 indx                        cv_rf
                         000210 input_ptr                   cv_rf
                         000212 lict                        cv_rf
                         000213 nargs                       cv_rf
                         000214 olin                        cv_rf
                         000615 olino                       cv_rf
                         000616 olinox                      cv_rf
                         000617 ondx                        cv_rf
                         000620 out_chars                   cv_rf
                         000621 out_file                    cv_rf
                         000704 output_ptr                  cv_rf
                         000722 j                           cv_rf
                         000732 bname                       builtin
                         000743 csdct                       builtin
                         000744 i                           builtin
                         000745 j                           builtin
                         000746 k                           builtin
                         000756 i                           relational
                         000757 k                           relational
                         000760 relop                       relational
                         000770 dname                       get_seg_ptr
                         001042 ename                       get_seg_ptr
lookup                   000100 ctl_token                   lookup
                         000101 varfld                      lookup

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              tra_ext             enable              shorten_stack       ext_entry           int_entry
set_cs_eis          verify_eis          any_to_any_tr       index_before_cs

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   expand_pathname_
hcs_$initiate_count           hcs_$make_seg                 hcs_$set_bc_seg               hcs_$terminate_noname
ioa_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$empty_file




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     38 002376        41 002400        44 002402        64 002404        86 002406        14 002411       102 002430
    104 002444       105 002453       108 002456       110 002503       113 002504       114 002523       117 002525
    118 002551       121 002552       122 002602       123 002615       126 002617       128 002646       131 002647
    133 002663       134 002665       135 002672       137 002673       140 002675       141 002701       142 002704
    145 002705       147 002707       148 002723       151 002727       152 002773       153 002777       156 003001
    157 003030       160 003031       163 003035       165 003062       167 003063       168 003102       171 003104
    174 003112       176 003131       178 003145       179 003174       180 003177       183 003202       185 003215
    187 003217       189 003220       193 003221       194 003253       198 003254       199 003257       200 003266
    203 003267       205 003273       206 003311       210 003315       212 003321       213 003322       214 003326
    216 003327       219 003366       222 003370       223 003401       224 003403       228 003404       236 003432
    237 003433       239 003437       242 003452       246 003465       247 003467       250 003471       252 003524
    254 003560       257 003563       258 003565       261 003567       263 003622       265 003624       268 003627
    269 003662       274 003664       277 003670       279 003724       280 003730       282 003734       284 003770
    286 003771       288 003775       293 003776       302 004004       304 004015       307 004043       309 004044
    311 004052       315 004057       319 004066       320 004107       322 004121       327 004122       329 004137
    331 004166       333 004167       336 004252       339 004254       342 004337       344 004341       347 004353
    349 004406       351 004442       353 004445       359 004455       361 004471       363 004521       365 004525
    368 004530       371 004544       375 004545       377 004546       380 004552       386 004562       388 004576
    390 004626       392 004632       395 004635       398 004651       401 004652       403 004662       406 004665
    407 004730       410 004732       412 004733       415 004755       418 004767       421 005001       424 005013
    425 005017       428 005020       431 005027       432 005033       433 005036       435 005037       439 005050
    441 005064       443 005114       444 005121       447 005124       449 005135       452 005136       454 005160
    456 005162       460 005173       461 005225       462 005227       464 005263       466 005265       469 005274
    471 005306       473 005332       474 005333       476 005341       477 005343       479 005344       484 005367
    489 005404       490 005416       493 005417       496 005432       497 005436       500 005441       501 005504
    504 005506       505 005526       507 005540       510 005543       511 005576       512 005600       516 005601
    519 005603       520 005614       523 005615       536 005616       538 005620       539 005623       541 005641
    543 005643       545 005646       548 005663       551 005664       552 005717       555 005721       556 005722
    559 005742       561 005743       563 005745       564 005755       568 005770       571 005771       574 006035
    575 006040       579 006041       580 006047       583 006060       586 006064       589 006110       592 006111
    595 006115       597 006136       598 006141       603 006161       607 006176       610 006222       612 006223
    615 006266       617 006270       620 006333       622 006335       625 006400       627 006402       630 006445
    635 006447       637 006461       640 006462       641 006464       643 006532       644 006535       646 006537
    647 006540       649 006541       661 006542       662 006544       663 006547       665 006565       667 006571
    669 006574       671 006600       672 006605       675 006613       677 006657       678 006660       679 006662
    680 006664       682 006665       684 006666       707 006670       708 006727       711 006734       712 006776
    715 007003       716 007004       719 007005       722 007051       724 007052       735 007054       736 007055
    738 007062       740 007101       743 007115       746 007116       748 007124       750 007146       752 007167


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
