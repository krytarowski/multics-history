	COMPILATION LISTING OF SEGMENT lister_expand_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-05-04_1650.27_Thu_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 /* This program converts a Lister file into a Lister ASCII input segment. */
       19 
       20 /* Written by Paul A. Green on September 2, 1974. */
       21 /* Modified 770923 by PG to rename from assist_expand_ to lister_expand_.
       22*   Modified 791128 by PG to requote fields if necessary. (sugg 003)
       23*   Modified 800318 by PG to add output_all_fieldnames control for MJG.
       24**/
       25 
       26 /* format: style3 */
       27 lister_expand_:
       28      procedure (P_in_file_ptr, P_output_ptr, P_output_index, P_width, P_output_all_fieldnames) returns (fixed bin)
       29 	     options (packed_decimal);
       30 
       31 /* parameters */
       32 
       33 declare (
       34          P_in_file_ptr ptr,				/* (input) ptr to ASSIST file */
       35          P_output_ptr ptr,				/* (input) ptr to output segment */
       36          P_output_index fixed bin (21),			/* (in/out) 1-origin character index of next free char. */
       37          P_width fixed bin,				/* (input) line width to use */
       38          P_output_all_fieldnames
       39          bit (1) aligned				/* (input) ON if we should always put out =fieldname */
       40          ) parameter;
       41 
       42 /* automatic */
       43 
       44 declare  atomx fixed bin (21),
       45          fd char (1),
       46          n_chars fixed bin (21),
       47          out_ptr ptr,
       48          output_all_fieldnames
       49          bit (1) aligned,				/* ON if we should always put out =fieldname */
       50          quote bit (1) aligned,			/* ON if atom needs to be quoted */
       51          rd char (1),
       52          sp_fd char (2) aligned,
       53         (fi, line_index, line_length, out)
       54          fixed bin (21),
       55          n_records fixed bin;
       56 
       57 /* based */
       58 
       59 declare  out_string char (1044480) based (out_ptr) unaligned;
       60 
       61 /* builtin */
       62 
       63 declare (hbound, index, lbound, length, null, pointer, substr)
       64          builtin;
       65 
       66 /* internal static */
       67 
       68 declare (
       69          NL char (1) init ("
       70 "),
       71          QUOTE char (1) init (""""),
       72          QUOTE_QUOTE char (2) init (""""""),
       73          NL_HT_SP_VT_NP char (5) init ("
       74 	 "),
       75          SEMI_NL char (2) init (";
       76 ")
       77          ) internal static options (constant);
       78 
       79 /* include files */
       80 
  1     1 /* ====== BEGIN INCLUDE FILE		lister_structures.incl.pl1 ================================ */
  1     2 
  1     3 /*
  1     4*   Modified 800813 by PB to add PUT_UID to listform declarations.
  1     5*   Modified 800825 by PB for version 2 lister file.
  1     6*   Modified 840523 by PB to add SELECT_BEG and SELECT_END.
  1     7**/
  1     8 /* MASTER DECLARATIONS */
  1     9 
  1    10 /* format: style3 */
  1    11 dcl	lister_file_version_2
  1    12 			fixed bin initial (2) internal static options (constant);
  1    13 
  1    14 dcl	1 input_file	based (in_file_ptr) aligned,
  1    15 	  2 (
  1    16 	  field_table_offset,
  1    17 	  record_head,
  1    18 	  record_tail,
  1    19 	  unused		(2)
  1    20 	  )		offset (input_file.area),
  1    21 	  2 next_uid        fixed bin (24) unsigned,
  1    22 	  2 version	fixed bin,
  1    23 	  2 n_records	fixed bin (17),
  1    24 	  2 area		area (261112);
  1    25 
  1    26 dcl	1 update_file	based (up_file_ptr) aligned,
  1    27 	  2 (
  1    28 	  field_table_offset,
  1    29 	  record_head,
  1    30 	  record_tail,
  1    31 	  unused		(2)
  1    32 	  )		offset (update_file.area),
  1    33 	  2 next_uid        fixed bin (24) unsigned,
  1    34 	  2 version	fixed bin,
  1    35 	  2 n_records	fixed bin (17),
  1    36 	  2 area		area (261112);
  1    37 
  1    38 dcl	1 output_file	based (out_file_ptr) aligned,
  1    39 	  2 (
  1    40 	  field_table_offset,
  1    41 	  record_head,
  1    42 	  record_tail,
  1    43 	  unused		(2)
  1    44 	  )		offset (output_file.area),
  1    45 	  2 next_uid        fixed bin (24) unsigned,
  1    46 	  2 version	fixed bin,
  1    47 	  2 n_records	fixed bin (17),
  1    48 	  2 area		area (261112);
  1    49 
  1    50 dcl	1 input_record	based (recordp) aligned,
  1    51 	  2 next		offset (input_file.area),
  1    52 	  2 uid             fixed bin (24) unsigned unaligned,
  1    53 	  2 max_field_index fixed bin (12) unsigned unaligned,
  1    54 	  2 field		dim (0:field_table.max_field_index refer (input_record.max_field_index))
  1    55 			offset (input_file.area);
  1    56 
  1    57 dcl	1 update_record	based aligned,
  1    58 	  2 next		offset (update_file.area),
  1    59 	  2 uid             fixed bin (24) unsigned unaligned,
  1    60 	  2 max_field_index fixed bin (12) unsigned unaligned,
  1    61 	  2 field		dim (0:field_table.max_field_index refer (update_record.max_field_index))
  1    62 			offset (update_file.area);
  1    63 
  1    64 dcl	1 output_record	based aligned,
  1    65 	  2 next		offset (output_file.area),
  1    66 	  2 uid             fixed bin (24) unsigned unaligned,
  1    67 	  2 max_field_index fixed bin (12) unsigned unaligned,
  1    68 	  2 field		dim (0:field_table.max_field_index refer (output_record.max_field_index))
  1    69 			offset (output_file.area);
  1    70 
  1    71 dcl	atom		char (atom_length) based (atomp) varying aligned,
  1    72 	atom_length	fixed bin initial (0),	/* for table option */
  1    73 	atomp		ptr;
  1    74 
  1    75 dcl	(fidp, field_table_ptr, format_table_ptr, in_file_ptr, ltp, recordp, select_ptr, out_file_ptr, up_file_ptr)
  1    76 			ptr,
  1    77 	n		fixed bin;
  1    78 
  1    79 dcl	1 field_table	based (field_table_ptr) aligned,
  1    80 	  2 record_delimiter
  1    81 			unal char (1),
  1    82 	  2 field_delimiter unal char (1),
  1    83 	  2 max_field_index unal fixed bin (17),
  1    84 	  2 hash_field_id_to_index
  1    85 			dimension (0:18) offset,
  1    86 	  2 index_to_field_id
  1    87 			dimension (0:n refer (field_table.max_field_index)) offset;
  1    88 
  1    89 dcl	1 field_identifier	based (fidp) aligned,
  1    90 	  2 next		offset,
  1    91 	  2 field_index	unal fixed bin (17),
  1    92 	  2 size		unal fixed bin (17),
  1    93 	  2 string	unal char (n refer (field_identifier.size));
  1    94 
  1    95 dcl	system_area	area (261120) based (area_ptr);
  1    96 dcl	area_ptr		ptr;
  1    97 
  1    98 /* LISTFORM DECLARATIONS */
  1    99 
  1   100 declare	(
  1   101 	PUT_LITERAL	initial (-1),
  1   102 	PUT_SPACES	initial (-2),
  1   103 	PUT_END		initial (-3),
  1   104 	PUT_DATE		initial (-4),
  1   105 	PUT_TIME		initial (-5),
  1   106 	PUT_RECORD_COUNT	initial (-6),
  1   107 	PUT_ARGUMENT	initial (-7),
  1   108 	PUT_UID             initial (-8)
  1   109 	)		fixed bin internal static;
  1   110 
  1   111 dcl	1 format_table	aligned based (format_table_ptr),
  1   112 	  2 size		fixed bin (17) unal,
  1   113 	  2 before	fixed bin (17) unal,
  1   114 	  2 after		fixed bin (17) unal,
  1   115 	  2 record	fixed bin (17) unal,
  1   116 	  2 literal_table	ptr,
  1   117 	  2 item		dim (n refer (format_table.size)),
  1   118 	    3 action	fixed bin (17) unal,
  1   119 	    3 justification bit (2) unal,
  1   120 	    3 argument_number
  1   121 			fixed bin (15) unal,
  1   122 	    3 width	fixed bin (21);
  1   123 
  1   124 dcl	1 literal_table	aligned based (ltp),
  1   125 	  2 size		fixed bin,		/* number of slots allocated */
  1   126 	  2 n_literals	fixed bin,		/* number of slots in use */
  1   127 	  2 literal	dim (n refer (literal_table.size)) ptr unal;
  1   128 
  1   129 dcl	(
  1   130 	flush_left	initial ("00"b),
  1   131 	center		initial ("01"b),
  1   132 	flush_right	initial ("10"b)
  1   133 	)		bit (2) aligned internal static options (constant);
  1   134 
  1   135 dcl	MIN_FIELD_INDEX	fixed bin initial (0) internal static options (constant);
  1   136 
  1   137 dcl	1 list_node	aligned based,
  1   138 	  2 size		fixed bin,
  1   139 	  2 list		dimension (n refer (list_node.size)) ptr;
  1   140 
  1   141 /* SELECT DECLARATIONS */
  1   142 
  1   143 dcl	1 select_expression based (select_ptr) aligned,
  1   144 	  2 literal_table_ptr
  1   145 			ptr,
  1   146 	  2 size		fixed bin,
  1   147 	  2 last_element	fixed bin,
  1   148 	  2 element	dim (n refer (select_expression.size)),
  1   149 	    3 opcode	unal bit (9),
  1   150 	    3 not		unal bit (1),
  1   151 	    3 top		unal bit (1),
  1   152 	    3 unused	unal bit (7),
  1   153 	    3 field_index	unal fixed bin (8),
  1   154 	    3 literal_index unal fixed bin (8),
  1   155 	1 element		aligned,
  1   156 	  2 opcode	fixed bin,
  1   157 	  2 not		bit (1) aligned,
  1   158 	  2 top		bit (1) aligned,
  1   159 	  2 field_index	fixed bin,
  1   160 	  2 literal_index	fixed bin,
  1   161 	operand1		fixed bin defined (element.field_index),
  1   162 	operand2		fixed bin defined (element.literal_index);
  1   163 
  1   164 dcl	(
  1   165 	SELECT_AND	init ("000000001"b),
  1   166 	SELECT_OR		init ("000000010"b),
  1   167 	SELECT_NOT	init ("000000011"b),
  1   168 	SELECT_FIND	init ("000000100"b),
  1   169 	SELECT_EQ		init ("000000101"b),
  1   170 	SELECT_LT		init ("000000110"b),
  1   171 	SELECT_GT		init ("000000111"b),
  1   172 	SELECT_LE		init ("000001000"b),
  1   173 	SELECT_GE		init ("000001001"b),
  1   174 	SELECT_NEQ	init ("000001010"b),
  1   175 	SELECT_NLT	init ("000001011"b),
  1   176 	SELECT_NGT	init ("000001100"b),
  1   177 	SELECT_NLE	init ("000001101"b),
  1   178 	SELECT_NGE	init ("000001110"b),
  1   179 	SELECT_BEG	init ("000001111"b),
  1   180 	SELECT_END	init ("000010000"b)
  1   181 	)		bit (9) aligned internal static;
  1   182 
  1   183 dcl	(
  1   184 	ANY_FIELD		init (-1),
  1   185 	NULL_FIELD	init (-2),
  1   186 	NUMERIC_FIELD	init (-3),
  1   187 	UID                 init (-4)
  1   188 	)		aligned fixed bin (8) static;
  1   189 
  1   190 dcl	1 numeric_atom	aligned based (atomp),
  1   191 	  2 flag		fixed bin (35),		/* must be -1 */
  1   192 	  2 value		float dec (29) unal;
  1   193 
  1   194 dcl	numeric_flag	fixed bin (35) internal static initial (-1) options (constant);
  1   195 
  1   196 /* SORT DECLARATIONS */
  1   197 
  1   198 declare	n_items_to_sort	fixed bin,
  1   199 	sort_list_ptr	ptr;
  1   200 
  1   201 declare	1 sort_list	aligned based (sort_list_ptr),
  1   202 	  2 n_keys	fixed bin,
  1   203 	  2 key		(n_items_to_sort refer (sort_list.n_keys)),
  1   204 	    3 field_index	fixed bin,
  1   205 	    3 ascending	bit (1) aligned,
  1   206 	    3 numeric	bit (1) aligned;
  1   207 
  1   208 /* MERGE DECLARATIONS */
  1   209 
  1   210 dcl	(
  1   211 	MERGE_ADD		init (0),
  1   212 	MERGE_AND		init (1),
  1   213 	MERGE_OR		init (2),
  1   214 	MERGE_SUBTRACT	init (3)
  1   215 	)		fixed bin internal static options (constant);
  1   216 
  1   217 /* ------ END INCLUDE FILE		lister_structures.incl.pl1 -------------------------------- */
       81 
       82 
       83 /* program */
       84 
       85 	in_file_ptr = P_in_file_ptr;
       86 	out_ptr = P_output_ptr;
       87 	out = P_output_index;
       88 	output_all_fieldnames = P_output_all_fieldnames;
       89 
       90 	field_table_ptr = input_file.field_table_offset;
       91 
       92 	if P_width <= 0
       93 	then line_length = 0;			/* will put one field per line... */
       94 	else line_length = P_width;
       95 
       96 	rd = field_table.record_delimiter;
       97 	fd = field_table.field_delimiter;
       98 	sp_fd = "  ";
       99 	substr (sp_fd, 2, 1) = fd;
      100 
      101 /* initialize some variables */
      102 
      103 	n_records = 0;
      104 	line_index = 0;
      105 
      106 /* Put out the field & record delimiters */
      107 
      108 	call put ("Record_delimiter: ");
      109 	call put (rd);
      110 	call put (SEMI_NL);
      111 
      112 	call put ("Field_delimiter: ");
      113 	call put (fd);
      114 	call put (SEMI_NL);
      115 
      116 /* put out the names of the fields */
      117 
      118 	line_index = 0;
      119 	call put ("Field_names: ");
      120 
      121 	fidp = pointer (field_table.index_to_field_id (0), input_file.area);
      122 	call put (field_identifier.string);
      123 
      124 	do fi = 1 to hbound (field_table.index_to_field_id (*), 1);
      125 	     fidp = pointer (field_table.index_to_field_id (fi), input_file.area);
      126 	     call put (",");
      127 
      128 	     if (line_length = 0 & line_index > 132) | (line_length > 0 & line_index > line_length)
      129 	     then do;
      130 		call put (NL);
      131 		line_index = 0;
      132 	     end;
      133 	     else call put (" ");
      134 
      135 	     call put (field_identifier.string);
      136 	end;
      137 
      138 /* end the list of names with a semi-colon, and put in a blank line. */
      139 
      140 	call put (";
      141 
      142 Records:
      143 ");
      144 
      145 /* now copy each record into the output segment */
      146 
      147 	do recordp = input_file.record_head repeat input_record.next while (recordp ^= null);
      148 
      149 /* we assume that there are no null records */
      150 
      151 	     n_records = n_records + 1;		/* count up number of records */
      152 
      153 	     substr (out_string, out, 1) = rd;
      154 	     out = out + 1;
      155 	     line_index = 1;
      156 
      157 	     do fi = lbound (field_table.index_to_field_id (*), 1) to hbound (field_table.index_to_field_id (*), 1);
      158 		atomp = input_record.field (fi);
      159 
      160 		if atomp ^= null | output_all_fieldnames
      161 		then do;
      162 		     if atomp = null
      163 		     then atom_length = 0;
      164 		     else atom_length = length (atom);
      165 
      166 		     fidp = pointer (field_table.index_to_field_id (fi), input_file.area);
      167 		     n = length (field_identifier.string);
      168 
      169 /* See if length(chars_to_far) + length(fid)+1 + length (atom) + length(sp_fd) + length(two_quotes) > line_length */
      170 
      171 		     if line_index + n + atom_length + 5 > line_length
      172 		     then do;
      173 			substr (out_string, out, 1) = NL;
      174 			out = out + 1;
      175 			line_index = 0;
      176 		     end;
      177 
      178 		     substr (out_string, out, 2) = sp_fd;
      179 		     out = out + 2;
      180 
      181 		     substr (out_string, out, n + 1) = field_identifier.string;
      182 						/* pad with a space */
      183 		     out = out + n + 1;
      184 		end;
      185 
      186 		if atomp ^= null
      187 		then do;
      188 		     n_chars = index (atom, QUOTE) - 1;
      189 		     if n_chars = -1
      190 		     then do;
      191 			n_chars = length (atom);
      192 			quote = "0"b;
      193 		     end;
      194 		     else quote = "1"b;
      195 
      196 		     if ^quote
      197 		     then if index (atom, rd) ^= 0 | index (atom, fd) ^= 0
      198 			then quote = "1"b;
      199 
      200 		     if ^quote
      201 		     then if length (atom) > 0
      202 			then if index (NL_HT_SP_VT_NP, substr (atom, 1, 1)) ^= 0
      203 			     | index (NL_HT_SP_VT_NP, substr (atom, length (atom), 1)) ^= 0
      204 			     then quote = "1"b;
      205 			     else ;
      206 			else quote = "1"b;		/* zero-length token */
      207 
      208 		     if quote
      209 		     then do;
      210 			substr (out_string, out, 1) = QUOTE;
      211 			out = out + 1;
      212 			line_index = line_index + 1;
      213 		     end;
      214 
      215 		     atomx = 1;
      216 		     do while (atomx <= length (atom));
      217 			substr (out_string, out, n_chars) = substr (atom, atomx, n_chars);
      218 			out = out + n_chars;
      219 			atomx = atomx + n_chars;
      220 			line_index = line_index + n_chars;
      221 
      222 			if atomx <= length (atom)
      223 			then do;			/* must have stopped on QUOTE */
      224 			     atomx = atomx + 1;
      225 						/* step over quote */
      226 			     substr (out_string, out, 2) = QUOTE_QUOTE;
      227 			     out = out + 2;
      228 			     line_index = line_index + 2;
      229 			     n_chars = index (substr (atom, atomx), QUOTE) - 1;
      230 			     if n_chars = -1
      231 			     then n_chars = length (substr (atom, atomx));
      232 			end;
      233 		     end;
      234 
      235 		     if quote
      236 		     then do;
      237 			substr (out_string, out, 1) = QUOTE;
      238 			out = out + 1;
      239 			line_index = line_index + 1;
      240 		     end;
      241 		end;
      242 	     end;
      243 
      244 	     substr (out_string, out, 1) = NL;
      245 	     out = out + 1;
      246 	end;
      247 
      248 	P_output_index = out;
      249 	return (n_records);
      250 
      251 put:
      252 	procedure (P_string);
      253 
      254 /* parameters */
      255 
      256 declare  P_string char (*) parameter;
      257 
      258 /* program */
      259 
      260 	     substr (out_string, out, length (P_string)) = P_string;
      261 	     out = out + length (P_string);
      262 	     line_index = line_index + length (P_string);
      263 	     return;
      264 
      265 	end put;
      266 
      267      end						/* lister_expand_ */;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/04/00  1650.2  lister_expand_.pl1                >udd>sm>ds>w>ml>lister_expand_.pl1
81           1    11/06/84  1047.7  lister_structures.incl.pl1        >ldd>incl>lister_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NL                              000004 constant        char(1)                  initial packed unaligned dcl 68 set ref 130* 173 244
NL_HT_SP_VT_NP                  000002 constant        char(5)                  initial packed unaligned dcl 68 ref 200 200
P_in_file_ptr                          parameter       pointer                  dcl 33 ref 27 85
P_output_all_fieldnames                parameter       bit(1)                   dcl 33 ref 27 88
P_output_index                         parameter       fixed bin(21,0)          dcl 33 set ref 27 87 248*
P_output_ptr                           parameter       pointer                  dcl 33 ref 27 86
P_string                               parameter       char                     packed unaligned dcl 256 ref 251 260 260 261 262
P_width                                parameter       fixed bin(17,0)          dcl 33 ref 27 92 94
QUOTE                                  constant        char(1)                  initial packed unaligned dcl 68 ref 188 210 229 237
QUOTE_QUOTE                            constant        char(2)                  initial packed unaligned dcl 68 ref 226
SEMI_NL                         000000 constant        char(2)                  initial packed unaligned dcl 68 set ref 110* 114*
area                     10            based           area(261112)             level 2 dcl 1-14 ref 90 121 125 147 158 166 246
atom                                   based           varying char             dcl 1-71 ref 164 188 191 196 196 200 200 200 200 216
                                                                                  217 222 229 230
atom_length                     000117 automatic       fixed bin(17,0)          initial dcl 1-71 set ref 162* 164* 171 1-71*
atomp                           000120 automatic       pointer                  dcl 1-71 set ref 158* 160 162 164 186 188 191 196
                                                                                  196 200 200 200 200 216 217 222 229 230
atomx                           000100 automatic       fixed bin(21,0)          dcl 44 set ref 215* 216 217 219* 219 222 224* 224
                                                                                  229 230
fd                              000101 automatic       char(1)                  packed unaligned dcl 44 set ref 97* 99 113* 196
fi                              000112 automatic       fixed bin(21,0)          dcl 44 set ref 124* 125* 157* 158 166*
fidp                            000122 automatic       pointer                  dcl 1-75 set ref 121* 122 125* 135 166* 167 181
field                     2            based           offset                   array level 2 dcl 1-50 ref 158
field_delimiter           0(09)        based           char(1)                  level 2 packed packed unaligned dcl 1-79 ref 97
field_identifier                       based           structure                level 1 dcl 1-89
field_table                            based           structure                level 1 dcl 1-79
field_table_offset                     based           offset                   level 2 dcl 1-14 ref 90
field_table_ptr                 000124 automatic       pointer                  dcl 1-75 set ref 90* 96 97 121 124 125 157 157 166
hbound                                                 builtin function         dcl 63 ref 124 157
in_file_ptr                     000126 automatic       pointer                  dcl 1-75 set ref 85* 90 90 121 125 147 147 158 166
                                                                                  246
index                                                  builtin function         dcl 63 ref 188 196 196 200 200 229
index_to_field_id        24            based           offset                   array level 2 dcl 1-79 ref 121 124 125 157 157 166
input_file                             based           structure                level 1 dcl 1-14
input_record                           based           structure                level 1 dcl 1-50
lbound                                                 builtin function         dcl 63 ref 157
length                                                 builtin function         dcl 63 ref 164 167 191 200 200 216 222 230 260 261
                                                                                  262
line_index                      000113 automatic       fixed bin(21,0)          dcl 44 set ref 104* 118* 128 128 131* 155* 171 175*
                                                                                  212* 212 220* 220 228* 228 239* 239 262* 262
line_length                     000114 automatic       fixed bin(21,0)          dcl 44 set ref 92* 94* 128 128 128 171
max_field_index           0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-79 ref 124 157
n                               000132 automatic       fixed bin(17,0)          dcl 1-75 set ref 167* 171 181 183
n_chars                         000102 automatic       fixed bin(21,0)          dcl 44 set ref 188* 189 191* 217 217 218 219 220
                                                                                  229* 230 230*
n_records                       000116 automatic       fixed bin(17,0)          dcl 44 set ref 103* 151* 151 249
next                                   based           offset                   level 2 dcl 1-50 ref 246
null                                                   builtin function         dcl 63 ref 147 160 162 186
out                             000115 automatic       fixed bin(21,0)          dcl 44 set ref 87* 153 154* 154 173 174* 174 178
                                                                                  179* 179 181 183* 183 210 211* 211 217 218* 218
                                                                                  226 227* 227 237 238* 238 244 245* 245 248 260
                                                                                  261* 261
out_ptr                         000104 automatic       pointer                  dcl 44 set ref 86* 153 173 178 181 210 217 226 237
                                                                                  244 260
out_string                             based           char(1044480)            packed unaligned dcl 59 set ref 153* 173* 178* 181*
                                                                                  210* 217* 226* 237* 244* 260*
output_all_fieldnames           000106 automatic       bit(1)                   dcl 44 set ref 88* 160
pointer                                                builtin function         dcl 63 ref 121 125 166
quote                           000107 automatic       bit(1)                   dcl 44 set ref 192* 194* 196 196* 200 200* 206* 208
                                                                                  235
rd                              000110 automatic       char(1)                  packed unaligned dcl 44 set ref 96* 109* 153 196
record_delimiter                       based           char(1)                  level 2 packed packed unaligned dcl 1-79 ref 96
record_head               1            based           offset                   level 2 dcl 1-14 ref 147
recordp                         000130 automatic       pointer                  dcl 1-75 set ref 147* 147* 158* 246
size                      1(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-89 ref 122 122
                                                                                  135 135 167 181
sp_fd                           000111 automatic       char(2)                  dcl 44 set ref 98* 99* 178
string                    2            based           char                     level 2 packed packed unaligned dcl 1-89 set ref
                                                                                  122* 135* 167 181
substr                                                 builtin function         dcl 63 set ref 99* 153* 173* 178* 181* 200 200 210*
                                                                                  217* 217 226* 229 230 237* 244* 260*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANY_FIELD                              internal static fixed bin(8,0)           initial dcl 1-183
MERGE_ADD                              internal static fixed bin(17,0)          initial dcl 1-210
MERGE_AND                              internal static fixed bin(17,0)          initial dcl 1-210
MERGE_OR                               internal static fixed bin(17,0)          initial dcl 1-210
MERGE_SUBTRACT                         internal static fixed bin(17,0)          initial dcl 1-210
MIN_FIELD_INDEX                        internal static fixed bin(17,0)          initial dcl 1-135
NULL_FIELD                             internal static fixed bin(8,0)           initial dcl 1-183
NUMERIC_FIELD                          internal static fixed bin(8,0)           initial dcl 1-183
PUT_ARGUMENT                           internal static fixed bin(17,0)          initial dcl 1-100
PUT_DATE                               internal static fixed bin(17,0)          initial dcl 1-100
PUT_END                                internal static fixed bin(17,0)          initial dcl 1-100
PUT_LITERAL                            internal static fixed bin(17,0)          initial dcl 1-100
PUT_RECORD_COUNT                       internal static fixed bin(17,0)          initial dcl 1-100
PUT_SPACES                             internal static fixed bin(17,0)          initial dcl 1-100
PUT_TIME                               internal static fixed bin(17,0)          initial dcl 1-100
PUT_UID                                internal static fixed bin(17,0)          initial dcl 1-100
SELECT_AND                             internal static bit(9)                   initial dcl 1-164
SELECT_BEG                             internal static bit(9)                   initial dcl 1-164
SELECT_END                             internal static bit(9)                   initial dcl 1-164
SELECT_EQ                              internal static bit(9)                   initial dcl 1-164
SELECT_FIND                            internal static bit(9)                   initial dcl 1-164
SELECT_GE                              internal static bit(9)                   initial dcl 1-164
SELECT_GT                              internal static bit(9)                   initial dcl 1-164
SELECT_LE                              internal static bit(9)                   initial dcl 1-164
SELECT_LT                              internal static bit(9)                   initial dcl 1-164
SELECT_NEQ                             internal static bit(9)                   initial dcl 1-164
SELECT_NGE                             internal static bit(9)                   initial dcl 1-164
SELECT_NGT                             internal static bit(9)                   initial dcl 1-164
SELECT_NLE                             internal static bit(9)                   initial dcl 1-164
SELECT_NLT                             internal static bit(9)                   initial dcl 1-164
SELECT_NOT                             internal static bit(9)                   initial dcl 1-164
SELECT_OR                              internal static bit(9)                   initial dcl 1-164
UID                                    internal static fixed bin(8,0)           initial dcl 1-183
area_ptr                               automatic       pointer                  dcl 1-96
center                                 internal static bit(2)                   initial dcl 1-129
element                                automatic       structure                level 1 dcl 1-143
flush_left                             internal static bit(2)                   initial dcl 1-129
flush_right                            internal static bit(2)                   initial dcl 1-129
format_table                           based           structure                level 1 dcl 1-111
format_table_ptr                       automatic       pointer                  dcl 1-75
list_node                              based           structure                level 1 dcl 1-137
lister_file_version_2                  internal static fixed bin(17,0)          initial dcl 1-11
literal_table                          based           structure                level 1 dcl 1-124
ltp                                    automatic       pointer                  dcl 1-75
n_items_to_sort                        automatic       fixed bin(17,0)          dcl 1-198
numeric_atom                           based           structure                level 1 dcl 1-190
numeric_flag                           internal static fixed bin(35,0)          initial dcl 1-194
operand1                               defined         fixed bin(17,0)          dcl 1-143
operand2                               defined         fixed bin(17,0)          dcl 1-143
out_file_ptr                           automatic       pointer                  dcl 1-75
output_file                            based           structure                level 1 dcl 1-38
output_record                          based           structure                level 1 dcl 1-64
select_expression                      based           structure                level 1 dcl 1-143
select_ptr                             automatic       pointer                  dcl 1-75
sort_list                              based           structure                level 1 dcl 1-201
sort_list_ptr                          automatic       pointer                  dcl 1-198
system_area                            based           area(261120)             dcl 1-95
up_file_ptr                            automatic       pointer                  dcl 1-75
update_file                            based           structure                level 1 dcl 1-26
update_record                          based           structure                level 1 dcl 1-57

NAMES DECLARED BY EXPLICIT CONTEXT.
lister_expand_                  000053 constant        entry                    external dcl 27
put                             000705 constant        entry                    internal dcl 251 ref 108 109 110 112 113 114 119 122
                                                                                  126 130 133 135 140

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1044        1054    1017        1054
Length      1236    1017        10         146      25           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lister_expand_                      117 external procedure  is an external procedure.  
put                                     internal procedure  shares stack frame of external procedure lister_expand_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
lister_expand_           000100 atomx                       lister_expand_
                         000101 fd                          lister_expand_
                         000102 n_chars                     lister_expand_
                         000104 out_ptr                     lister_expand_
                         000106 output_all_fieldnames       lister_expand_
                         000107 quote                       lister_expand_
                         000110 rd                          lister_expand_
                         000111 sp_fd                       lister_expand_
                         000112 fi                          lister_expand_
                         000113 line_index                  lister_expand_
                         000114 line_length                 lister_expand_
                         000115 out                         lister_expand_
                         000116 n_records                   lister_expand_
                         000117 atom_length                 lister_expand_
                         000120 atomp                       lister_expand_
                         000122 fidp                        lister_expand_
                         000124 field_table_ptr             lister_expand_
                         000126 in_file_ptr                 lister_expand_
                         000130 recordp                     lister_expand_
                         000132 n                           lister_expand_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
return_mac          ext_entry           pointer_hard

NO EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     27 000045    1   71 000060        85 000061        86 000065        87 000070        88 000072        90 000075
     92 000101        94 000105        96 000106        97 000111        98 000115        99 000117       103 000122
    104 000123       108 000124       109 000135       110 000140       112 000143       113 000151       114 000154
    118 000157       119 000160       121 000171       122 000177       124 000215       125 000227       126 000235
    128 000242       130 000253       131 000256       132 000257       133 000260       135 000265       136 000304
    140 000306       147 000315       151 000326       153 000327       154 000334       155 000335       157 000337
    158 000347       160 000355       162 000362       164 000370       166 000372       167 000400       171 000404
    173 000412       174 000417       175 000420       178 000421       179 000426       181 000430       183 000437
    186 000443       188 000447       189 000461       191 000463       192 000465       193 000466       194 000467
    196 000471       200 000521       205 000552       206 000553       208 000555       210 000557       211 000564
    212 000565       215 000566       216 000570       217 000573       218 000605       219 000607       220 000610
    222 000611       224 000614       226 000615       227 000621       228 000623       229 000624       230 000642
    233 000647       235 000650       237 000652       238 000657       239 000660       242 000661       244 000663
    245 000670       246 000671       248 000677       249 000702       251 000705       260 000716       261 000725
    262 000726       263 000727


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
