	COMPILATION LISTING OF SEGMENT lsm_sym_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/18/82  1641.5 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 lsm_sym_: proc; return;
       19 
       20 /* This procedure implements symbol table functions for the graphics system's
       21*   structure manipulation package (lsm_). */
       22 /* Modified 07/23/79 by CDT to add implicit location of
       23*   symbol table.  Now only one is allowed per segment. */
       24 /* Last modified 03/25/80 by CDT to replace internal procedure
       25*   hash_pl1 with hash_index_, recently liberated from hardcore */
       26 
       27 /* Arguments */
       28 
       29 dcl (op_code fixed bin,				/* opcode to determine what to do */
       30      key_arg char (*),
       31      symbol_node_arg fixed bin (18),			/* node # of symbol node */
       32      value_node fixed bin (18),			/* node # of symbol value node */
       33      err_code fixed bin (35)) parameter;		/* standard system error code */
       34 
       35 /* Builtins */
       36 
       37 dcl (addr, dim, fixed, length, null, pointer, rtrim, size) builtin;
       38 
       39 /* Automatic */
       40 
       41 dcl (node_no,					/* used to index down a symbol table bucket list */
       42      table_n) fixed bin (18);				/* node # of symbol table */
       43 
       44 dcl  type fixed bin,				/* type of node */
       45      key_node fixed bin (18),
       46      chain_word_ptr pointer,				/* used in symbol bucket list search */
       47      symbol_ptr pointer,
       48      symtab_ptr pointer,				/* pointer to start of bucket list in a symbol table node */
       49      i fixed bin;
       50 
       51 /* Entries */
       52 
       53 dcl  hash_index_ ext entry (pointer, fixed bin, fixed bin, fixed bin (18)) returns (fixed bin);
       54 
       55 /* Based */
       56 
       57 dcl  based_chain_word fixed bin (18) based;
       58 
       59 /* External static */
       60 
       61 dcl (error_table_$unimplemented_version,
       62      graphic_error_table_$lsm_sym_search,
       63      graphic_error_table_$inv_node_type,
       64      graphic_error_table_$lsm_invalid_op) fixed bin (35) external;
       65 
  1     1 /* Begin include file . . . lsm_formats.incl.pl1 */
  1     2 
  1     3 /* CONSTANTS */
  1     4 
  1     5 dcl (LSM_version_7 initial (7),			/* current version, root is always symtab */
  1     6      LSM_version_6 initial (6))			/* root wasn't automatically symtab */
  1     7      fixed bin static options (constant);
  1     8 
  1     9 dcl 1 lsm_constants aligned static options (constant),
  1    10     2 n_types fixed bin initial (9),
  1    11     2 types,
  1    12       3 indirect_type initial (1),
  1    13       3 fixed_type initial (2),
  1    14       3 float_type initial (3),
  1    15       3 bit_type initial (4),
  1    16       3 char_type initial (5),
  1    17       3 symtab_type initial (6),
  1    18       3 symbol_type initial (7),
  1    19       3 list_type initial (8),
  1    20       3 array_type initial (9),
  1    21     2 data_length_factors (9) initial (1, 1, 1, 36, 4, 1, 1, 1, 1),
  1    22     2 max_allocation fixed bin initial (4095),
  1    23     2 initial_component_slots fixed bin initial (8);
  1    24 
  1    25 dcl  lsm_segptr pointer;
  1    26 
  1    27 dcl 1 lsm aligned based (lsm_segptr),			/* declaration of head of lsm_ segment */
  1    28     2 version fixed bin,				/* number of lsm_ version that created this seg */
  1    29     2 free fixed bin (18),				/* word number of first free word in seg */
  1    30     2 root_symtab fixed bin (18),			/* node number of the root symbol table */
  1    31     2 lock bit (36) aligned,
  1    32     2 component_slots fixed bin,
  1    33     2 components fixed bin,
  1    34     2 pad (26) fixed bin (18),
  1    35     2 component_ptrs (lsm_constants.initial_component_slots refer (lsm.component_slots)) pointer unaligned;
  1    36 
  1    37 
  1    38 /* Formats of different node types used by lsm_ */
  1    39 
  1    40 dcl  node_ptr pointer;
  1    41 
  1    42 dcl 1 header aligned based (node_ptr),			/* Used in all formats below */
  1    43     2 type fixed bin (6) unsigned unaligned,		/* type of node */
  1    44     2 allocated_len fixed bin (12) unsigned unaligned,	/* allocated length of data space */
  1    45     2 data_len fixed bin (18) unsigned unaligned;		/* current length of data in block */
  1    46 						/* (in appropriate units) */
  1    47 
  1    48 dcl 1 any_node aligned based (node_ptr),		/* general node description */
  1    49     2 header like header aligned,
  1    50     2 data_space (0 refer (any_node.allocated_len)) bit (36) aligned;
  1    51 
  1    52 dcl 1 indirect_node aligned based (node_ptr),		/* internal to lsm_ */
  1    53     2 header like header,
  1    54     2 new_node fixed bin (18);			/* numberof reallocated node */
  1    55 
  1    56 dcl 1 fixed_node aligned based (node_ptr),		/* array of fixed bin (35) */
  1    57     2 header like header,
  1    58     2 element (0 refer (fixed_node.data_len)) fixed bin (35); /* array of values */
  1    59 
  1    60 dcl 1 float_node aligned based (node_ptr),		/* array of float binary (27) */
  1    61     2 header like header,
  1    62     2 element (0 refer (float_node.data_len)) float bin (27);
  1    63 
  1    64 dcl 1 bit_node aligned based (node_ptr),		/* string of bits */
  1    65     2 header like header,
  1    66     2 string bit (0 refer (bit_node.data_len));		/* bit string of max length */
  1    67 
  1    68 dcl 1 char_node aligned based (node_ptr),		/* string of characters */
  1    69     2 header like header,
  1    70     2 string char (0 refer (char_node.data_len)) unaligned; /* character string of max length */
  1    71 
  1    72 dcl 1 symtab_node aligned based (node_ptr),		/* symbol table node */
  1    73     2 header like header,
  1    74     2 bucket_root (0 : 1 refer (symtab_node.data_len)) fixed bin (18);
  1    75 						/* actually, it is (0 : data_len - 1), but there's no way to do */
  1    76 						/* this with a refer option, and it's invalid not to use refer */
  1    77 
  1    78 dcl 1 symbol_node aligned based (node_ptr),		/* symbol node */
  1    79     2 header like header,
  1    80     2 name_node fixed bin (18),			/* number of character string node containing symbol name */
  1    81     2 value_node fixed bin (18),			/* number of node that is the "value" of this symbol */
  1    82     2 next_node fixed bin (18);			/* number of next symbol node in this bucket chain */
  1    83 						/* =0 if this is last node o chain */
  1    84 
  1    85 dcl 1 list_node aligned based (node_ptr),		/* non-terminal list node */
  1    86     2 header like header,
  1    87     2 node (0 refer (list_node.data_len)) fixed bin (18);	/* numbers of nodes comprising this list */
  1    88 
  1    89 dcl 1 array_node aligned based (node_ptr),		/* non-terminal list with terminal properties */
  1    90     2 header like header,
  1    91     2 node (0 refer (array_node.data_len)) fixed bin (18);	/* numbers of nodes comprising this array */
  1    92 
  1    93 
  1    94 /* End include file . . . lsm_formats.incl.pl1 */
       66 
       67 
  2     1 /* --------------- BEGIN include file lsm_entry_dcls.incl.pl1 --------------- */
  2     2 
  2     3 dcl  lsm_$get_blk entry (ptr, fixed bin (18), fixed bin, fixed bin, ptr, fixed bin (35)),
  2     4      lsm_$make_blk entry (ptr, fixed bin (18), fixed bin, fixed bin, ptr, fixed bin (35)),
  2     5      lsm_$mk_char entry (ptr, char (*), fixed bin (18)),
  2     6      lsm_$replace_blk entry (ptr, fixed bin (18), fixed bin (18), fixed bin (35)),
  2     7      lsm_$replicate entry (ptr, fixed bin (18), fixed bin (18), fixed bin (35)),
  2     8      lsm_$set_blk entry (ptr, fixed bin (18), fixed bin, fixed bin, ptr, fixed bin (35));
  2     9 
  2    10 dcl  lsm_fs_$compact entry (ptr, fixed bin (18), fixed bin (35)),
  2    11      lsm_fs_$free entry (ptr, fixed bin (35)),
  2    12      lsm_fs_$init entry (ptr, fixed bin (35)),
  2    13      lsm_fs_$init_seg entry (ptr, char (*), char (*), fixed bin, fixed bin (35)),
  2    14      lsm_fs_$merge_symbol entry (ptr, ptr, fixed bin (18), bit (1), fixed bin, fixed bin (35)),
  2    15      lsm_fs_$move_struc entry (ptr, ptr, fixed bin (18), fixed bin (18), fixed bin (35)),
  2    16      lsm_fs_$pull entry (ptr, char (*), char (*), fixed bin (35)),
  2    17      lsm_fs_$push entry (ptr, char (*), char (*), fixed bin (35));
  2    18 
  2    19 dcl  lsm_sym_$find_table entry (pointer, fixed bin (18), fixed bin (35)),
  2    20      lsm_sym_$sym_list entry (ptr, (*) fixed bin (18), fixed bin, fixed bin (35)),
  2    21      lsm_sym_$symk entry (ptr, fixed bin, char (*), fixed bin (18), fixed bin (18), fixed bin (35)),
  2    22      lsm_sym_$symn entry (ptr, fixed bin, fixed bin (18), fixed bin (18), fixed bin (18), fixed bin (35));
  2    23 
  2    24 dcl (Find_symbol initial (0),				/* op codes for lsm_sym_$symk and lsm_sym_$symn */
  2    25      Find_or_create_symbol initial (1),
  2    26      Create_symbol initial (2),
  2    27      Delete_symbol initial (3)) fixed bin static options (constant);
  2    28 
  2    29 dcl (Find_seg initial (0),				/* Opcodes for lsm_fs_$init_seg */
  2    30      Create_seg initial (1),
  2    31      Clear_seg initial (2)) fixed bin static options (constant);
  2    32 
  2    33 /* ---------------- END include file lsm_entry_dcls.incl.pl1 ---------------- */
       68 
       69 
       70 symk:	entry (lsm_segptr, op_code, key_arg, symbol_node_arg, value_node, err_code);
       71 
       72 /* key is supplied directly as a character string */
       73 
       74 	symbol_node_arg = 0;			/* Start off not knowing anything */
       75 	err_code = 0;
       76 
       77 	call find_table (lsm_segptr, table_n, err_code);
       78 	if err_code ^= 0 then return;
       79 
       80 	symtab_ptr = pointer (lsm_segptr, table_n);
       81 
       82 	if symtab_ptr -> any_node.type ^= symtab_type then do; /* If node is not a symbol table... */
       83 invalid_type:  err_code = graphic_error_table_$inv_node_type;
       84 	     return;
       85 	end;
       86 
       87 	call hash_find_symbol (lsm_segptr, (symtab_ptr -> symtab_node.data_len), key_arg, symbol_ptr, node_no,
       88 	     chain_word_ptr, op_code, err_code);
       89 	if err_code ^= 0 then return;
       90 
       91 /* If we get here, we know that the existence/nonexistence of the symbol is
       92*   compatible with the operation specified by op_code */
       93 
       94 	if op_code = Delete_symbol then do;
       95 	     chain_word_ptr -> based_chain_word = symbol_ptr -> symbol_node.next_node;
       96 						/* Chain around this node */
       97 	     symbol_ptr -> indirect_node.new_node = symbol_ptr -> symbol_node.value_node;
       98 						/* Make an indirect node so that sym and value will be "EQ" */
       99 	     symbol_ptr -> indirect_node.data_len = 2;
      100 	     symbol_ptr -> indirect_node.type = lsm_constants.indirect_type;
      101 	end;
      102 
      103 	else if symbol_ptr ^= null then do;		/* symbol was found */
      104 	     if op_code = Create_symbol then		/* rewrite value */
      105 		symbol_ptr -> symbol_node.value_node = value_node;
      106 	     else value_node = symbol_ptr -> symbol_node.value_node;
      107 						/* Find or Find_or_create; return value */
      108 	     symbol_node_arg = node_no;
      109 	end;
      110 
      111 	else do;					/* symbol not found, must create it */
      112 	     call lsm_$make_blk (lsm_segptr, key_node, char_type, length (key_arg), node_ptr, err_code);
      113 						/* make node for name */
      114 	     if err_code ^= 0 then return;
      115 
      116 	     node_ptr -> char_node.string = key_arg;
      117 
      118 	     call lsm_$make_blk (lsm_segptr, symbol_node_arg, symbol_type,
      119 		size (symbol_ptr -> symbol_node) - size (null -> header), symbol_ptr, err_code);
      120 	     if err_code ^= 0 then return;
      121 
      122 	     symbol_ptr -> symbol_node.name_node = key_node;
      123 	     symbol_ptr -> symbol_node.value_node = value_node;
      124 	     symbol_ptr -> symbol_node.next_node = 0;
      125 
      126 	     chain_word_ptr -> based_chain_word = symbol_node_arg; /* chain it on */
      127 	end;
      128 
      129 	return;
      130 	










      131 hash_find_symbol: proc (lsm_segptr, symtab_len, key_arg, symbol_ptr, node_no, chain_word_ptr, op_code, err_code);
      132 
      133 dcl (lsm_segptr pointer,
      134      symtab_len fixed bin (18),
      135      key_arg char (*),
      136      symbol_ptr pointer,
      137      node_no fixed bin (18),
      138      chain_word_ptr pointer,
      139      op_code fixed bin,
      140      err_code fixed bin (35)) parameter;
      141 
      142 dcl (first_bucket, last_bucket) fixed bin (18),
      143      i fixed bin (18),
      144      must_be_there bit (1) aligned,
      145      name_node_ptr pointer;
      146 
      147 	     if lsm_segptr -> lsm.version = LSM_version_7 then
      148 		first_bucket, last_bucket = hash_index_ (addr (key_arg), length (rtrim (key_arg)), 0, symtab_len);
      149 
      150 	     else if lsm_segptr -> lsm.version = LSM_version_6 then do;
      151 		first_bucket = 0;
      152 		last_bucket = symtab_len;		/* exhaustive search */
      153 	     end;
      154 
      155 	     else do;
      156 		err_code = error_table_$unimplemented_version;
      157 		return;
      158 	     end;
      159 
      160 	     if (op_code < Find_symbol) | (op_code > Delete_symbol) then do;
      161 		err_code = graphic_error_table_$lsm_invalid_op;
      162 		return;
      163 	     end;
      164 
      165 
      166 	     err_code = 0;
      167 	     must_be_there = (op_code = Delete_symbol) | (op_code = Find_symbol);
      168 
      169 	     do i = first_bucket to last_bucket;
      170 
      171 		chain_word_ptr = addr (symtab_ptr -> symtab_node.bucket_root (i));
      172 		node_no = chain_word_ptr -> based_chain_word;
      173 
      174 		do while (node_no ^= 0);
      175 		     symbol_ptr = pointer (lsm_segptr, node_no);
      176 		     if symbol_ptr -> symbol_node.type ^= lsm_constants.symbol_type then
      177 			goto invalid_type;
      178 
      179 		     name_node_ptr = pointer (lsm_segptr, symbol_ptr -> symbol_node.name_node);
      180 		     if name_node_ptr -> char_node.string = key_arg then /* gotcha */
      181 			return;
      182 
      183 		     chain_word_ptr = addr (symbol_ptr -> symbol_node.next_node);
      184 		     node_no = chain_word_ptr -> based_chain_word;
      185 		end;
      186 	     end;
      187 
      188 /* Not found, sing dirge */
      189 
      190 	     symbol_ptr = null;
      191 	     node_no = 0;
      192 	     if must_be_there then err_code = graphic_error_table_$lsm_sym_search;
      193 	     return;
      194 
      195 	end hash_find_symbol;
      196 
      197 find_table: entry (lsm_segptr, symtab_node_no, err_code);
      198 
      199 dcl  symtab_node_no fixed bin (18) parameter;
      200 
      201 	call find_table (lsm_segptr, symtab_node_no, err_code);
      202 	return;
      203 	










      204 find_table: proc (lsm_segptr, symtab_node_no, err_code);
      205 
      206 dcl (lsm_segptr pointer,
      207      symtab_node_no fixed bin (18),
      208      err_code fixed bin (35)) parameter;
      209 
      210 dcl  root_len fixed bin;
      211 
      212 	     if lsm_segptr -> lsm.version = LSM_version_7 then do; /* current version, easy */
      213 		symtab_node_no = lsm_segptr -> lsm.root_symtab;
      214 		err_code = 0;
      215 		return;
      216 	     end;
      217 
      218 	     else if lsm_segptr -> lsm.version = LSM_version_6 then do;
      219 
      220 /* We have to find the symbol table.  The graphics system used to chain the
      221*   root node to a list, the first element of which was the symbol table node ID
      222*   (the second was always 0). */
      223 
      224 		call lsm_$get_blk (lsm_segptr, lsm_segptr -> lsm.root_symtab, type, root_len, node_ptr, err_code);
      225 		if err_code ^= 0 then return;
      226 
      227 		if (type ^= list_type) | (root_len ^= 2) then do;
      228 		     err_code = graphic_error_table_$inv_node_type;
      229 		     return;
      230 		end;
      231 
      232 		symtab_node_no = node_ptr -> list_node.node (1);
      233 		err_code = 0;
      234 		return;
      235 	     end;
      236 
      237 	     else do;
      238 		err_code = error_table_$unimplemented_version;
      239 		return;
      240 	     end;
      241 
      242 	end find_table;
      243 
      244 sym_list:	entry (lsm_segptr, array, array_len, err_code);
      245 
      246 /* Entry fills "array" with numbers of nodes in symbol table */
      247 /* If array_max is too small, err_code is returned as error_table_$smallarg */
      248 
      249 dcl  array (*) fixed bin (18),			/* Arrayy into which list of symbol node #s will go (output) */
      250      array_max fixed bin,				/* length of array provided by caller */
      251      array_len fixed bin;				/* number of significant elements in array (output) */
      252 
      253 dcl  error_table_$smallarg fixed bin (35) external;
      254 
      255 	err_code = 0;
      256 	array_max = dim (array, 1);			/* Determine dim of array provided by caller */
      257 
      258 	call find_table (lsm_segptr, table_n, err_code);
      259 	if err_code ^= 0 then return;
      260 
      261 	symtab_ptr = pointer (lsm_segptr, table_n);	/* Get pointer to symbol table node */
      262 	if fixed (symtab_ptr -> symbol_node.type, 4) ^= symtab_type /* If not a symbol table node... */
      263 	then go to invalid_type;
      264 
      265 	array_len = 0;
      266 	do i = 0 to fixed (symtab_ptr -> symtab_node.data_len, 17, 0) - 1; /* Iterate over number of buckets */
      267 	     do node_no = symtab_ptr -> symtab_node.bucket_root (i)
      268 		     repeat pointer (lsm_segptr, node_no) -> symbol_node.next_node
      269 		     while (node_no ^= 0);		/* Run down symbol node chain */
      270 		array_len = array_len + 1;		/* One more symbol in array */
      271 
      272 		if err_code ^= 0 then;		/* already know arg is short, just continue */
      273 		else if array_len > array_max
      274 		then err_code = error_table_$smallarg;	/* Array specified is too small to hold entire list */
      275 		else array (array_len) = node_no;	/* Fill in next else array element */
      276 	     end;
      277 	end;
      278 	return;
      279      end lsm_sym_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/18/82  1625.7  lsm_sym_.pl1                      >dumps>old>recomp>lsm_sym_.pl1
66           1    12/17/79  1708.9  lsm_formats.incl.pl1              >ldd>include>lsm_formats.incl.pl1
68           2    03/27/82  0439.3  lsm_entry_dcls.incl.pl1           >ldd>include>lsm_entry_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Create_symbol                          constant        fixed bin(17,0)          initial dcl 2-24 ref 104
Delete_symbol                          constant        fixed bin(17,0)          initial dcl 2-24 ref 94 160 167
Find_symbol                            constant        fixed bin(17,0)          initial dcl 2-24 ref 160 167
LSM_version_6                          constant        fixed bin(17,0)          initial dcl 1-5 ref 150 218
LSM_version_7                          constant        fixed bin(17,0)          initial dcl 1-5 ref 147 212
addr                                                   builtin function         dcl 37 ref 147 147 171 183
any_node                               based           structure                level 1 dcl 1-48
array                                  parameter       fixed bin(18,0)          array dcl 249 set ref 244 256 275*
array_len                              parameter       fixed bin(17,0)          dcl 249 set ref 244 265* 270* 270 273 275
array_max                       000116 automatic       fixed bin(17,0)          dcl 249 set ref 256* 273
based_chain_word                       based           fixed bin(18,0)          dcl 57 set ref 95* 126* 172 184
bucket_root               1            based           fixed bin(18,0)          array level 2 dcl 1-72 set ref 171 267
chain_word_ptr                  000104 automatic       pointer                  dcl 44 in procedure "lsm_sym_" set ref 87* 95 126
chain_word_ptr                         parameter       pointer                  dcl 133 in procedure "hash_find_symbol" set ref 131
                                                                                  171* 172 183* 184
char_node                              based           structure                level 1 dcl 1-68
char_type                 5     000000 constant        fixed bin(17,0)          initial level 3 dcl 1-9 set ref 112*
data_len                  0(18)        based           fixed bin(18,0)          level 3 in structure "indirect_node" packed unsigned
                                                                                  unaligned dcl 1-52 in procedure "lsm_sym_" set ref
                                                                                  99*
data_len                  0(18)        based           fixed bin(18,0)          level 3 in structure "char_node" packed unsigned
                                                                                  unaligned dcl 1-68 in procedure "lsm_sym_" ref 116
                                                                                  180
data_len                  0(18)        based           fixed bin(18,0)          level 3 in structure "symtab_node" packed unsigned
                                                                                  unaligned dcl 1-72 in procedure "lsm_sym_" ref 87
                                                                                  266
dim                                                    builtin function         dcl 37 ref 256
err_code                               parameter       fixed bin(35,0)          dcl 29 in procedure "lsm_sym_" set ref 70 75* 77* 78
                                                                                  83* 87* 89 112* 114 118* 120 197 201* 244 255*
                                                                                  258* 259 272 273*
err_code                               parameter       fixed bin(35,0)          dcl 133 in procedure "hash_find_symbol" set ref 131
                                                                                  156* 161* 166* 192*
err_code                               parameter       fixed bin(35,0)          dcl 206 in procedure "find_table" set ref 204 214*
                                                                                  224* 225 228* 233* 238*
error_table_$smallarg           000026 external static fixed bin(35,0)          dcl 253 ref 273
error_table_$unimplemented_version
                                000012 external static fixed bin(35,0)          dcl 61 ref 156 238
first_bucket                    000132 automatic       fixed bin(18,0)          dcl 142 set ref 147* 151* 169
fixed                                                  builtin function         dcl 37 ref 262 266
graphic_error_table_$inv_node_type
                                000016 external static fixed bin(35,0)          dcl 61 ref 83 228
graphic_error_table_$lsm_invalid_op
                                000020 external static fixed bin(35,0)          dcl 61 ref 161
graphic_error_table_$lsm_sym_search
                                000014 external static fixed bin(35,0)          dcl 61 ref 192
hash_index_                     000010 constant        entry                    external dcl 53 ref 147
header                                 based           structure                level 2 in structure "indirect_node" dcl 1-52
                                                                                  in procedure "lsm_sym_"
header                                 based           structure                level 1 dcl 1-42 in procedure "lsm_sym_" ref 118
header                                 based           structure                level 2 in structure "symtab_node" dcl 1-72
                                                                                  in procedure "lsm_sym_"
header                                 based           structure                level 2 in structure "any_node" dcl 1-48
                                                                                  in procedure "lsm_sym_"
header                                 based           structure                level 2 in structure "symbol_node" dcl 1-78
                                                                                  in procedure "lsm_sym_"
header                                 based           structure                level 2 in structure "char_node" dcl 1-68
                                                                                  in procedure "lsm_sym_"
i                               000112 automatic       fixed bin(17,0)          dcl 44 in procedure "lsm_sym_" set ref 266* 267*
i                               000134 automatic       fixed bin(18,0)          dcl 142 in procedure "hash_find_symbol" set ref 169*
                                                                                  171*
indirect_node                          based           structure                level 1 dcl 1-52
indirect_type             1     000000 constant        fixed bin(17,0)          initial level 3 dcl 1-9 ref 100
key_arg                                parameter       char                     unaligned dcl 133 in procedure "hash_find_symbol"
                                                                                  set ref 131 147 147 147 147 180
key_arg                                parameter       char                     unaligned dcl 29 in procedure "lsm_sym_" set ref 70
                                                                                  87* 112 112 116
key_node                        000103 automatic       fixed bin(18,0)          dcl 44 set ref 112* 122
last_bucket                     000133 automatic       fixed bin(18,0)          dcl 142 set ref 147* 152* 169
length                                                 builtin function         dcl 37 ref 112 112 147 147
list_node                              based           structure                level 1 dcl 1-85
list_type                10     000000 constant        fixed bin(17,0)          initial level 3 dcl 1-9 ref 227
lsm                                    based           structure                level 1 dcl 1-27
lsm_$get_blk                    000022 constant        entry                    external dcl 2-3 ref 224
lsm_$make_blk                   000024 constant        entry                    external dcl 2-3 ref 112 118
lsm_constants                   000000 constant        structure                level 1 dcl 1-9
lsm_segptr                             parameter       pointer                  dcl 206 in procedure "find_table" set ref 204 212
                                                                                  213 218 224* 224
lsm_segptr                             parameter       pointer                  dcl 133 in procedure "hash_find_symbol" ref 131 147
                                                                                  150 175 179
lsm_segptr                             parameter       pointer                  dcl 1-25 in procedure "lsm_sym_" set ref 70 77* 80
                                                                                  87* 112* 118* 197 201* 244 258* 261 276
must_be_there                   000135 automatic       bit(1)                   dcl 142 set ref 167* 192
name_node                 1            based           fixed bin(18,0)          level 2 dcl 1-78 set ref 122* 179
name_node_ptr                   000136 automatic       pointer                  dcl 142 set ref 179* 180
new_node                  1            based           fixed bin(18,0)          level 2 dcl 1-52 set ref 97*
next_node                 3            based           fixed bin(18,0)          level 2 dcl 1-78 set ref 95 124* 183 276
node                      1            based           fixed bin(18,0)          array level 2 dcl 1-85 ref 232
node_no                                parameter       fixed bin(18,0)          dcl 133 in procedure "hash_find_symbol" set ref 131
                                                                                  172* 174 175 184* 191*
node_no                         000100 automatic       fixed bin(18,0)          dcl 41 in procedure "lsm_sym_" set ref 87* 108 267*
                                                                                  267* 275* 276
node_ptr                        000114 automatic       pointer                  dcl 1-40 set ref 112* 116 224* 232
null                                                   builtin function         dcl 37 ref 103 118 190
op_code                                parameter       fixed bin(17,0)          dcl 29 in procedure "lsm_sym_" set ref 70 87* 94 104
op_code                                parameter       fixed bin(17,0)          dcl 133 in procedure "hash_find_symbol" ref 131 160
                                                                                  160 167 167
pointer                                                builtin function         dcl 37 ref 80 175 179 261 276
root_len                        000150 automatic       fixed bin(17,0)          dcl 210 set ref 224* 227
root_symtab               2            based           fixed bin(18,0)          level 2 dcl 1-27 set ref 213 224*
rtrim                                                  builtin function         dcl 37 ref 147 147
size                                                   builtin function         dcl 37 ref 118 118
string                    1            based           char                     level 2 packed unaligned dcl 1-68 set ref 116* 180
symbol_node                            based           structure                level 1 dcl 1-78 set ref 118
symbol_node_arg                        parameter       fixed bin(18,0)          dcl 29 set ref 70 74* 108* 118* 126
symbol_ptr                             parameter       pointer                  dcl 133 in procedure "hash_find_symbol" set ref 131
                                                                                  175* 176 179 183 190*
symbol_ptr                      000106 automatic       pointer                  dcl 44 in procedure "lsm_sym_" set ref 87* 95 97 97
                                                                                  99 100 103 104 106 118 118* 122 123 124
symbol_type               7     000000 constant        fixed bin(17,0)          initial level 3 dcl 1-9 set ref 118* 176
symtab_len                             parameter       fixed bin(18,0)          dcl 133 set ref 131 147* 152
symtab_node                            based           structure                level 1 dcl 1-72
symtab_node_no                         parameter       fixed bin(18,0)          dcl 206 in procedure "find_table" set ref 204 213*
                                                                                  232*
symtab_node_no                         parameter       fixed bin(18,0)          dcl 199 in procedure "lsm_sym_" set ref 197 201*
symtab_ptr                      000110 automatic       pointer                  dcl 44 set ref 80* 82 87 171 261* 262 266 267
symtab_type               6     000000 constant        fixed bin(17,0)          initial level 3 dcl 1-9 ref 82 262
table_n                         000101 automatic       fixed bin(18,0)          dcl 41 set ref 77* 80 258* 261
type                                   based           fixed bin(6,0)           level 3 in structure "indirect_node" packed unsigned
                                                                                  unaligned dcl 1-52 in procedure "lsm_sym_" set ref
                                                                                  100*
type                            000102 automatic       fixed bin(17,0)          dcl 44 in procedure "lsm_sym_" set ref 224* 227
type                                   based           fixed bin(6,0)           level 3 in structure "symbol_node" packed unsigned
                                                                                  unaligned dcl 1-78 in procedure "lsm_sym_" ref 176
                                                                                  262
type                                   based           fixed bin(6,0)           level 3 in structure "any_node" packed unsigned
                                                                                  unaligned dcl 1-48 in procedure "lsm_sym_" ref 82
types                     1     000000 constant        structure                level 2 dcl 1-9
value_node                2            based           fixed bin(18,0)          level 2 in structure "symbol_node" dcl 1-78
                                                                                  in procedure "lsm_sym_" set ref 97 104* 106 123*
value_node                             parameter       fixed bin(18,0)          dcl 29 in procedure "lsm_sym_" set ref 70 104 106*
                                                                                  123
version                                based           fixed bin(17,0)          level 2 dcl 1-27 ref 147 150 212 218

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Clear_seg                              internal static fixed bin(17,0)          initial dcl 2-29
Create_seg                             internal static fixed bin(17,0)          initial dcl 2-29
Find_or_create_symbol                  internal static fixed bin(17,0)          initial dcl 2-24
Find_seg                               internal static fixed bin(17,0)          initial dcl 2-29
array_node                             based           structure                level 1 dcl 1-89
bit_node                               based           structure                level 1 dcl 1-64
fixed_node                             based           structure                level 1 dcl 1-56
float_node                             based           structure                level 1 dcl 1-60
lsm_$mk_char                    000000 constant        entry                    external dcl 2-3
lsm_$replace_blk                000000 constant        entry                    external dcl 2-3
lsm_$replicate                  000000 constant        entry                    external dcl 2-3
lsm_$set_blk                    000000 constant        entry                    external dcl 2-3
lsm_fs_$compact                 000000 constant        entry                    external dcl 2-10
lsm_fs_$free                    000000 constant        entry                    external dcl 2-10
lsm_fs_$init                    000000 constant        entry                    external dcl 2-10
lsm_fs_$init_seg                000000 constant        entry                    external dcl 2-10
lsm_fs_$merge_symbol            000000 constant        entry                    external dcl 2-10
lsm_fs_$move_struc              000000 constant        entry                    external dcl 2-10
lsm_fs_$pull                    000000 constant        entry                    external dcl 2-10
lsm_fs_$push                    000000 constant        entry                    external dcl 2-10
lsm_sym_$find_table             000000 constant        entry                    external dcl 2-19
lsm_sym_$sym_list               000000 constant        entry                    external dcl 2-19
lsm_sym_$symk                   000000 constant        entry                    external dcl 2-19
lsm_sym_$symn                   000000 constant        entry                    external dcl 2-19

NAMES DECLARED BY EXPLICIT CONTEXT.
find_table                      000720 constant        entry                    internal dcl 204 in procedure "lsm_sym_" ref 77 201
                                                                                  258
find_table                      000337 constant        entry                    external dcl 197
hash_find_symbol                000517 constant        entry                    internal dcl 131 ref 87
invalid_type                    000124 constant        label                    dcl 83 ref 176 262
lsm_sym_                        000041 constant        entry                    external dcl 18
sym_list                        000370 constant        entry                    external dcl 244
symk                            000055 constant        entry                    external dcl 70

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1156        1206    1007        1166
Length      1422    1007        30         200     146           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lsm_sym_                            186 external procedure  is an external procedure.  
hash_find_symbol                        internal procedure  shares stack frame of external procedure lsm_sym_.  
find_table                              internal procedure  shares stack frame of external procedure lsm_sym_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
lsm_sym_                 000100 node_no                     lsm_sym_
                         000101 table_n                     lsm_sym_
                         000102 type                        lsm_sym_
                         000103 key_node                    lsm_sym_
                         000104 chain_word_ptr              lsm_sym_
                         000106 symbol_ptr                  lsm_sym_
                         000110 symtab_ptr                  lsm_sym_
                         000112 i                           lsm_sym_
                         000114 node_ptr                    lsm_sym_
                         000116 array_max                   lsm_sym_
                         000132 first_bucket                hash_find_symbol
                         000133 last_bucket                 hash_find_symbol
                         000134 i                           hash_find_symbol
                         000135 must_be_there               hash_find_symbol
                         000136 name_node_ptr               hash_find_symbol
                         000150 root_len                    find_table

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out        return              ext_entry           ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
hash_index_                   lsm_$get_blk                  lsm_$make_blk

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$smallarg         error_table_$unimplemented_version
graphic_error_table_$inv_node_type                          graphic_error_table_$lsm_invalid_op
graphic_error_table_$lsm_sym_search




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     18 000040        18 000046        70 000047        74 000073        75 000075        77 000076        78 000110
     80 000112        82 000120        83 000124        84 000127        87 000130        89 000175        94 000177
     95 000203        97 000206        99 000210       100 000212       101 000215       103 000216       104 000222
    106 000231       108 000234       109 000236       112 000237       114 000262       116 000264       118 000274
    120 000317       122 000321       123 000324       124 000327       126 000330       129 000332       197 000333
    201 000347       202 000362       244 000363       255 000400       256 000401       258 000411       259 000424
    261 000426       262 000434       265 000440       266 000441       267 000451       270 000456       272 000460
    273 000463       275 000472       276 000505       277 000514       278 000516       131 000517       147 000530
    150 000577       151 000601       152 000602       153 000604       156 000605       157 000610       160 000611
    161 000616       162 000621       166 000622       167 000623       169 000632       171 000641       172 000645
    174 000647       175 000652       176 000656       179 000662       180 000667       183 000677       184 000701
    185 000703       186 000704       190 000706       191 000711       192 000712       193 000717       204 000720
    212 000722       213 000726       214 000731       215 000732       218 000733       224 000735       225 000760
    227 000764       228 000772       229 000775       232 000776       233 001001       234 001002       238 001003
    239 001006


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
