	COMPILATION LISTING OF SEGMENT rmdb_create_index
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1348.4 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /****^  HISTORY COMMENTS:
        9*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       10*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       11*     This entry is being made to cover the change made on 85-05-06 by Thanh
       12*     Nguyen. (see mrds #136)
       13*                                                   END HISTORY COMMENTS */
       14 
       15 
       16 rmdb_create_index: proc (rci_rmdb_ctl_ptr, rci_db_abs_path, rci_db_model_ptr, rci_rel_name, rci_attr_name, rci_error_message, rci_code);
       17 
       18 /*
       19*                           BEGIN_DESCRIPTION
       20*   This module will change a non-indexed  attribute  in  a  relation
       21*   into an indexed attribute.
       22*
       23*   This process involves both updating the structures in  the  model
       24*   and writing the new index.
       25*
       26*   An  attempt  has   been   made   to   make   certain   operations
       27*   uninterruptable  by the user. These operations are the updates to
       28*   the data model (including marking the data base as  inconsistent)
       29*   and the addition of  a   new index. To do this any quits signaled
       30*   by the  user  are  delayed  until  the  operations  are  complete.
       31*
       32*
       33*   NOTE:
       34*         Naming convention: because of the number of  internal  routines
       35*         and the need for descriptive names, variables declared  in  all
       36*         routines  (including the main entry) have prefixes that are the
       37*         initials  of  the  routine  name.  Global  variables   can   be
       38*         identified since they have a prefix different from that derived
       39*         from the routine name. Variables with the same name except  for
       40*         the  prefix mean the same thing. Variables without a prefix are
       41*         external to the module,  i.e.  entry  names,  external  static,
       42*         builtins,  conditions, etc. These variables are declared in the
       43*         main routine.
       44*   
       45*         In order to reduce the complexity of this module, none  of  the
       46*         internal  routines  have  an error code parameter. Instead they
       47*         set a global error code declared in the main routine, call  the
       48*         clean_up  routine,  and  perform  a non-local goto to leave the
       49*         module.
       50*                          END_DESCRIPTION
       51*
       52*   Known Bugs:
       53*
       54*   Other Problems:
       55*
       56*                          HISTORY
       57*   82-04-23 Davids: Written
       58*
       59*   82-04-29 Davids: changed   to   use   the  new  calling   sequence  of
       60*                    mu_db_inconsistent also changed the  output  messages
       61*                    and  comments  to  reflect  that amdb will NOT have a
       62*                    -consistent control arg.
       63*    
       64*                    changed cleanup routine so that calls to  iox_$detach
       65*                    and  iox_$destroy are always made even if the call to
       66*                    iox_close fails, this is because the  iocb  could  be
       67*                    attached but not open.
       68*   
       69*   82-04-30 Davids: changed to use the $set entry  in  mu_db_inconsistent
       70*                    which  is  still  the main entry but more discriptive
       71*                    also added the " -brief"  control  arg  on  the  undo
       72*                    request and added the call to iox_$control "start" to
       73*                    the cleanup handler.
       74*
       75*   82-05-07 Davids: added    code    to    signal    quit    after    the
       76*                    exit_rmdb_create_index label so that  if  the  caller
       77*                    hits  quit and then an error occurs the quit does not
       78*                    get  lost  because  the  error  handling  code  calls
       79*                    cleanup   and   then   does   a   non-local  goto  to
       80*                    exit_rmdb_create_index.
       81*
       82*   82-05-25 Davids: added rci_db_model_ptr  parameter  and  removed  code
       83*                    that used toget the pointer.
       84*
       85*   82-06-24 Davids: removed   declared   but   unreferenced    variables,
       86*                    reformated  lines  to  prevent  wrap-around.  changed
       87*                    -force to -brief in the undo request.
       88*
       89*   82-07-01  Roger Lackey : Modified the calls to  mu_db_inconsistent  to
       90*	                  use mdbm_util_$inconsistent_* for binding.
       91*
       92*   82-07-02 R. Harvey : Modified the calls to mu_data_length, mu_data_class$*,
       93*	              mu_encd_key$*, mu_scan_records$* for binding
       94*
       95*   82-07-20 Davids: corrected  the way that the tuple_id was built in the
       96*                    get_a_tuple procedure, it was taking the first 7 bits
       97*                    from the  file_id , it  was supposed to be taking the 
       98*                    last 7. 
       99*
      100*   82-08-20 D. Woodka : deleted references to mdbm_tuple_id  include file
      101*	              for DMS conversion.
      102*
      103*   82-09-15 D. Woodka : Modified for DMS Conversion: removed references
      104*	              to tuples and modified the module to call 
      105*	              rmdb_relmgr_entries.open and
      106*	              rmdb_relmgr_entries.create_index
      107*
      108*   83-01-06 Davids: Modified the internal procedure get_attribute_data to
      109*   no longer calculate the new_index_id and to no longer check the
      110*   rel_info.max_attr_index_id to be sure its < 512 which was needed to be 
      111*   sure that the newly calculated value would fit in the 8-bit field.
      112*   The relation manager will be suppling the new index_id. Also modified
      113*   the internal proc update_model to null the attr_info.index_id and set
      114*   rel_info.max_attr_index_id to 512. The index_id must be nulled so that
      115*   when the vfile relation manager looks at the model it knows that the field
      116*   is not an index yet. The value of max_attr_index_id is set to 512 to keep
      117*   MR10.1 rmdb from working since once MR10.2 rmdb is used the way that
      118*   MR10.1 rmdb calcualted the index id cannot be guarenteeded to produce an
      119*   index_id that MR10.2 rmdb did not already use.
      120*
      121*   Added code to handle transactions.
      122*
      123*   83-01-14 Davids: Modified code to report error in transaction finishing and
      124*   to correctly handle reporting errors in the clean_up procedure.
      125*
      126*   83-02-14 Davids: modified to use the new db_type_flags in the db_model
      127*   structure instead of the old numeric db_type.
      128*
      129*   83-05-24 Davids: Added code to change the version of the saved resultant
      130*   so that it will not be incorrectly used in an opening.
      131**/
      132 
      133 /* PARAMETERS */
      134 
      135 	dcl     rci_db_abs_path	 char (168);	/* (input) path to the data base to be restructured */
      136 	dcl     rci_db_model_ptr	 ptr;		/* (input) pointer to the db_model for the database */
      137 	dcl     rci_rel_name	 char (*);	/* (input) name of relation to be restructured */
      138 	dcl     rci_attr_name	 char (*);	/* (input) name of attribute to be indexed */
      139 	dcl     rci_error_message	 char (500);	/* (output) text of message in the event of an error */
      140 	dcl     rci_code		 fixed bin (35);	/* (output) standard error message */
      141 
      142 /* AUTOMATIC */
      143 
      144 	dcl     rci_attr_defn_order	 fixed bin;
      145 	dcl     rci_attr_desc	 bit (36);	/* standard multics descriptor of the attribute to be indexed */
      146 	dcl     rci_attr_ptr	 ptr;		/* pointer to the attr_info structure */
      147 	dcl     rci_backout_occured	 bit (1);		/* true if restore_significant_data has been called */
      148 	dcl     rci_caller_name	 char (17);	/* for call to get_temp_segment_ */
      149 	dcl     rci_file_id		 bit (36);	/* id of the file as defined in the database model */
      150 	dcl     rci_file_model_ptr	 ptr;		/* pointer to the file model that contains the relation */
      151 	dcl     rci_flag_list	 bit (36) aligned;	/* flag structure for create_index */
      152 	dcl     rci_max_data_length	 fixed bin;	/* maximum number of bits of data a tuple may have, if tuple */
      153 						/* contains varying data the actual number may be less */
      154 	dcl     rci_number_of_attrs	 fixed bin;	/* number of attributes in the relation */
      155 	dcl     rci_number_of_varying_attrs fixed bin;	/* number of varying attributes in the relation */
      156 	dcl     rci_original_rel_info_indexed bit (1);	/* value of the indexed element in rel_info before the model was updated */
      157 	dcl     rci_original_rel_info_max_attr_index_id fixed bin; /* ditto */
      158 	dcl     rci_quit_signaled
      159 				 bit (1);		/* true if a quit was signaled */
      160 	dcl     rci_rel_id		 bit (36);	/* id of the relation as defined in rel_info */
      161 	dcl     rci_rel_opening_id	 bit (36) aligned;	/* opening identifier of the relation */
      162 	dcl     rci_rel_ptr		 ptr;		/* pointer to the rel_info structure */
      163 	dcl     rci_rmdb_ctl_ptr	 ptr;
      164 	dcl     rci_style		 fixed bin (17) init (1);
      165 	dcl     wa		 area;
      166 
      167 
      168 /* BUILTINS */
      169 
      170 	dcl     addr		 builtin;
      171 	dcl     ceil		 builtin;
      172 	dcl     empty		 builtin;
      173 	dcl     fixed		 builtin;
      174 	dcl     length		 builtin;
      175 	dcl     null		 builtin;
      176 	dcl     pointer		 builtin;
      177 	dcl     rel		 builtin;
      178 	dcl     rtrim		 builtin;
      179 
      180 /* BAESED */
      181 
      182 	dcl     rci_based_char8	 char (8) based;	/* overlay on the saved res version */
      183 
      184 /* CONDITIONS */
      185 
      186 	dcl     any_other		 condition;
      187 	dcl     cleanup		 condition;
      188 	dcl     quit		 condition;
      189 
      190 /* ENTRIES */
      191 
      192 	dcl     hcs_$initiate	 entry (char (*), char (*), char (*),
      193 				 fixed bin (1), fixed bin (2), ptr, fixed bin (35));
      194 	dcl     ioa_$rs		 entry () options (variable);
      195 	dcl     mdbm_util_$mu_data_length entry (bit (36)) returns (fixed bin (35));
      196 	dcl     mdbm_util_$inconsistent_set entry (ptr, char (*), char (*), char (*));
      197 	dcl     mdbm_util_$inconsistent_reset entry (ptr);
      198 	dcl     rmdb_add_rmdb_history	 entry (ptr, fixed bin, char (32), fixed bin, char (32), char (500), fixed bin (35));
      199 
      200 /* EXTERNAL STATIC */
      201 
      202 	dcl     error_table_$action_not_performed fixed bin (35) ext static;
      203 	dcl     sys_info$max_seg_size	 fixed bin (35) ext static; /* needed by include files */
      204 
      205 /* INCLUDES */
      206 
  1     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  1     6*     modified to save space occupied by model
  1     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  1     8*     to add mdbm_secured bit in db_model
  1     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  1    10*     collapsed the following into an unused_offset array:
  1    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  1    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  1    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  1    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  1    15*       unused_1
  1    16*     Also changed the name of unused_2 to restructuring_history_offset
  1    17*     and changed the comment on the changer structure to indicate
  1    18*     that it will contain on database creation information.
  1    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  1    20*     used one of the unused_offsets to point to a message which indicates
  1    21*     why the db is inconsistent. The offset will be null when the db is created
  1    22*     and set the first time the message is used. this is so it will be
  1    23*     consistent with existing data bases. Also added the message structure.
  1    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  1    25*     added the undo_request element to the message structure
  1    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  1    27*     changed unused_offset (12) to last_restructruring_history_offset and
  1    28*     changed restructuring_history_offset to first_restructuring_history_offset
  1    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  1    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  1    31*     1 => vfile database and 2 => page_file database. Up to this point all
  1    32*     database types were equal to 1.
  1    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  1    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  1    35*     flags. This will allow information about transactions and dm_file
  1    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  1    37*     change is compatable with all datamodels created by the released version
  1    38*     of mrds.
  1    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  1    40*     added the rollback_on flag to the db_type_flags since it appears that you
  1    41*     can have a dmfile database that requires transactions but does not have any
  1    42*     journalizing. Also switched the order of the transactions_needed and
  1    43*     concurrency_on flags - this makes the change compatable with existing
  1    44*     dmfile databases except when displaying the model since concurrency_on and
  1    45*     rollback_on will be off in the model even though the dmfile relations had
  1    46*     them on during creation.
  1    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  1    48*      Removed ctl_file_path_ptr.
  1    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  1    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  1    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  1    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  1    53*      in the flag word for rmdb copying.
  1    54*                                                   END HISTORY COMMENTS */
  1    55 
  1    56 
  1    57 /* this include file contains the structures that go into the make up
  1    58*   of the "db_model" segment in the model for the database.
  1    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  1    60*
  1    61*   the db_model structure goes at the base of the segment, and contains items unique to
  1    62*   the whole databse. in addition, it has an area of size to fill the
  1    63*   rest of a segment, that holds the lists of files and domains in the database.
  1    64*   these lists are singly forward linked lists. all "pointers" in the database model
  1    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  1    66*   since actual pointers are process dependent on segment number.
  1    67*   the remaining structures are first a path_entry one to save pathnames in,
  1    68*   and the stack_item and constent structures, used to save a boolean
  1    69*   expression in polish form, with the stack represented by a linked list.
  1    70*   the final structure is one for identifying the status of version information */
  1    71 
  1    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  1    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  1    74 	     2 db_type_flags      unal,
  1    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  1    76 	       3 unused	      (13) bit (1) unal,
  1    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  1    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  1    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  1    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  1    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  1    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  1    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  1    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  1    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  1    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  1    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  1    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  1    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  1    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  1    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  1    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  1    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  1    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  1    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  1    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  1    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  1    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  1    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  1   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  1   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  1   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  1   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  1   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  1   105 
  1   106      dcl	   dbm_ptr	      ptr;
  1   107 
  1   108 /* the files in the database each have a file_info containing
  1   109*   their name, the file_model for each file is found by initiating the
  1   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  1   111*   the file_info list is a singly linked list in definition order */
  1   112 
  1   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  1   114 	     2 file_name	      char (30),		/* name of file */
  1   115 	     2 file_id	      bit (36),		/* id number of file */
  1   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  1   117 	     2 unused	      unal bit (18);	/* for future expansion */
  1   118 
  1   119      dcl	   fi_ptr		      ptr;
  1   120 
  1   121 /* each domain used in the database will have a domain info saved in the db_model
  1   122*   segment. it describes the domain of the given name, and it's options.
  1   123*   the domain_info's form a singly linked list in definition order */
  1   124 
  1   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  1   126 	     2 name	      char (32),		/* name of domain */
  1   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  1   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  1   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  1   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  1   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  1   132 	     2 reserved	      bit (31) unal,
  1   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  1   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  1   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  1   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  1   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  1   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  1   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  1   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  1   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  1   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  1   143 	     2 str_err_path_ptr   unal bit (18),
  1   144 	     2 str_after_path_ptr unal bit (18),
  1   145 	     2 get_before_path_ptr unal bit (18),
  1   146 	     2 get_err_path_ptr   unal bit (18),
  1   147 	     2 get_after_path_ptr unal bit (18),
  1   148 	     2 mod_before_path_ptr unal bit (18),
  1   149 	     2 mod_err_path_ptr   unal bit (18),
  1   150 	     2 mod_after_path_ptr unal bit (18),
  1   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  1   152 	     2 unused_2	      unal bit (18),
  1   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  1   154 
  1   155      dcl	   di_ptr		      ptr;
  1   156 
  1   157 /* information necessary for attributes that are not used in any relation */
  1   158 
  1   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  1   160 	     2 name char (32),			/* name of attribute */
  1   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  1   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  1   163 	     2 unused (2) bit (18) unal;
  1   164 
  1   165      dcl     ua_ptr ptr;
  1   166 
  1   167 
  1   168 /* space saving pathname$entryname structure, to be allocated
  1   169*   only when a path$entry has to be saved, else only a bit(18)
  1   170*   offset takes up space in the main model structure */
  1   171 
  1   172      declare 1 path_entry	      based (path_entry_ptr),
  1   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  1   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  1   175 	     2 reserved	      unal bit (36);	/* for future use */
  1   176 
  1   177      declare path_entry_ptr	      ptr;
  1   178 
  1   179 
  1   180 
  1   181 
  1   182 
  1   183 /* declarations for model of postfix stack holding the check option boolean expression
  1   184*   the following encoding values indicate the corresponding type of stack element
  1   185*
  1   186*   1  =
  1   187*   2  ^=
  1   188*   3  >
  1   189*   4  <
  1   190*   5  >=
  1   191*   6  <=
  1   192*
  1   193*   10  and
  1   194*   20  or
  1   195*   30  not
  1   196*
  1   197*   40  - (minus)
  1   198*
  1   199*   50  domain variable(same name as domain)
  1   200*
  1   201*   60  constant(number, bit string, or character string)
  1   202*
  1   203**/
  1   204 
  1   205 
  1   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  1   207 	     2 next	      bit (18),		/* link to next in list */
  1   208 	     2 type	      fixed binary,		/* code for this element type */
  1   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  1   210*						   if this is a constant element type */
  1   211 
  1   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  1   213 
  1   214 
  1   215 
  1   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  1   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  1   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  1   219 
  1   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  1   221 
  1   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  1   223 
  1   224 /* version structure, giving status of source for CMDB/RMDB,
  1   225*   status of model, and status of resultant */
  1   226 
  1   227 /* version number is in form MM.N.Y
  1   228*   where MM is the major version number, N is the minor version alteration,
  1   229*   and Y is the lastest modification to that alteration,
  1   230*   where M and N represent numbers 0-9, and Y is a letter */
  1   231 
  1   232      declare 1 version_status	      unal based (version_status_ptr),
  1   233 	     2 cmdb_rmdb,
  1   234 	       3 major	      fixed bin,
  1   235 	       3 minor	      fixed bin,
  1   236 	       3 modification     char (4),
  1   237 	     2 model,
  1   238 	       3 major	      fixed bin,
  1   239 	       3 minor	      fixed bin,
  1   240 	       3 modification     char (4),
  1   241 	     2 resultant,
  1   242 	       3 major	      fixed bin,
  1   243 	       3 minor	      fixed bin,
  1   244 	       3 modification     char (4);
  1   245 
  1   246      declare version_status_ptr     ptr;
  1   247 
  1   248 
  1   249 /* maintains information only about the db creation */
  1   250 
  1   251      declare 1 changer	      unal based (changer_ptr),
  1   252 	     2 id		      char (32),
  1   253 	     2 time	      fixed bin (71),
  1   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  1   255 
  1   256      declare changer_ptr	      ptr;
  1   257 
  1   258 
  1   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  1   260 	     02 len	      fixed bin,		/* length of the message */
  1   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  1   262 	     02 name	      char (32),		/* name of thing that set the message */
  1   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  1   264*                                                               that caused the database to become inconsistent */
  1   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  1   266 
  1   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  1   268 
  1   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  1   270 
  1   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  1   272 
  1   273 
      207 
      208 
  2     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  2     6*     modified to save space occupied by model
  2     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  2     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  2     9*     the number of secondary indices in the relation - it was always zero.
  2    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  2    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  2    12*     DMS conversion.
  2    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  2    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  2    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  2    16*     for relation manager changes.
  2    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  2    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  2    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  2    20*     <rel> files are good (for rmdb)
  2    21*                                                   END HISTORY COMMENTS */
  2    22 
  2    23 
  2    24 /* each file in the database will have a model segment with the name
  2    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  2    26*   the file_model structure is allocated at the base of the segment for a given file.
  2    27*   it contains an area with which all other structures in this include file are allocated.
  2    28*   these structures contain the information about which relations, foreign keys,
  2    29*   and attributes are members of this file. all lists are singly linked lists in
  2    30*   definition order. pointers to these structures are obtained by using the "pointer"
  2    31*   builtin function with arguments of the segment base pointer, and the
  2    32*   offset (bit (18)) relative to that pointer that is actually stored in
  2    33*   the file model itself. this is because pointer segment numbers are
  2    34*   per process dependent. the major lists pointed to by the file_model structure
  2    35*   are the list of relations in this file(each with a contained attribute list),
  2    36*   and the list of foreign keys whose parent relation resides in this file
  2    37*   (along with a participating attribute sublist, and the child relation list,
  2    38*   if they are also in this file) */
  2    39 
  2    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  2    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  2    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  2    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  2    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  2    45     2 reserved bit (32) unal,				/* reserved for future flags */
  2    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  2    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  2    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  2    49     2 pad_1 fixed bin (35),				/* for future use */
  2    50     2 pad_2 fixed bin (35),
  2    51     2 ratd_len fixed bin (21),			/* length of above */
  2    52     2 mratd_len fixed bin (21),			/* length of above */
  2    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  2    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  2    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  2    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  2    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  2    58     2 block_size unal fixed bin,			/* no. pages in block */
  2    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  2    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  2    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  2    62     2 num_rels unal fixed bin,			/* number of relations in file */
  2    63     2 num_links unal fixed bin,			/* number of links in file */
  2    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  2    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  2    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  2    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  2    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  2    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  2    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  2    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  2    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  2    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  2    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  2    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  2    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  2    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  2    78     2 open_eu_err_path_ptr unal bit (18),
  2    79     2 open_eu_after_path_ptr unal bit (18),
  2    80     2 open_er_before_path_ptr unal bit (18),
  2    81     2 open_er_err_path_ptr unal bit (18),
  2    82     2 open_er_after_path_ptr unal bit (18),
  2    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  2    84     2 open_neu_err_path_ptr unal bit (18),
  2    85     2 open_neu_after_path_ptr unal bit (18),
  2    86     2 open_ner_before_path_ptr unal bit (18),
  2    87     2 open_ner_err_path_ptr unal bit (18),
  2    88     2 open_ner_after_path_ptr unal bit (18),
  2    89     2 open_pu_before_path_ptr unal bit (18),
  2    90     2 open_pu_err_path_ptr unal bit (18),
  2    91     2 open_pu_after_path_ptr unal bit (18),
  2    92     2 open_pr_before_path_ptr unal bit (18),
  2    93     2 open_pr_err_path_ptr unal bit (18),
  2    94     2 open_pr_after_path_ptr unal bit (18),
  2    95     2 open_cu_before_path_ptr unal bit (18),
  2    96     2 open_cu_err_path_ptr unal bit (18),
  2    97     2 open_cu_after_path_ptr unal bit (18),
  2    98     2 open_cr_before_path_ptr unal bit (18),
  2    99     2 open_cr_err_path_ptr unal bit (18),
  2   100     2 open_cr_after_path_ptr unal bit (18),
  2   101     2 close_before_path_ptr unal bit (18),
  2   102     2 close_err_path_ptr unal bit (18),
  2   103     2 close_after_path_ptr unal bit (18),
  2   104     2 unused_1 unal bit (18),				/* for future expansion */
  2   105     2 unused_2 unal bit (18),
  2   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  2   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  2   108 dcl  fm_ptr ptr;
  2   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  2   110 dcl  atd_ptr ptr;
  2   111 dcl  atd_len fixed bin;
  2   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  2   113     2 ncomponents fixed bin,
  2   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  2   115 dcl  cna_ptr ptr;
  2   116 dcl  ncomp_init fixed bin;
  2   117 
  2   118 /* a rel_info structure contains information describing a relation.
  2   119*   a relation may only occur in one file, thus there is one rel_info
  2   120*   per relation per database, each stored in the file_model area for
  2   121*   the file that contains it. the list of rel_info's in this file
  2   122*   form a singly linked list in definition order.
  2   123*   the rel_info itself points to a list of the attributes it contains,
  2   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  2   125 
  2   126 dcl 1 rel_info aligned based (ri_ptr),
  2   127     2 name char (32),				/* relation name */
  2   128     2 id  bit (36) aligned,				/* relation id number */
  2   129     2 hashed bit (1) unal,				/* on if hashed */
  2   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  2   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  2   132     2 system bit (1) unal,				/* on if dont care how stored */
  2   133     2 indexed bit (1) unal,				/* on if secondary index */
  2   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  2   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  2   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  2   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  2   138     2 reserved bit (27) unal,				/* for future flags */
  2   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  2   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  2   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  2   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  2   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  2   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  2   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  2   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  2   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  2   148     2 unused_3 unal fixed bin,			/* element that was never used */
  2   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  2   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  2   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  2   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  2   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  2   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  2   155     2 attr_ptr unal bit (18),				/* to attr. info */
  2   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  2   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  2   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  2   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  2   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  2   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  2   162     2 link_err_path_ptr unal bit (18),
  2   163     2 link_after_path_ptr unal bit (18),
  2   164     2 unlk_before_path_ptr unal bit (18),
  2   165     2 unlk_err_path_ptr unal bit (18),
  2   166     2 unlk_after_path_ptr unal bit (18),
  2   167     2 str_before_path_ptr unal bit (18),
  2   168     2 str_err_path_ptr unal bit (18),
  2   169     2 str_after_path_ptr unal bit (18),
  2   170     2 del_before_path_ptr unal bit (18),
  2   171     2 del_err_path_ptr unal bit (18),
  2   172     2 del_after_path_ptr unal bit (18),
  2   173     2 mod_before_path_ptr unal bit (18),
  2   174     2 mod_err_path_ptr unal bit (18),
  2   175     2 mod_after_path_ptr unal bit (18),
  2   176     2 find_before_path_ptr unal bit (18),
  2   177     2 find_err_path_ptr unal bit (18),
  2   178     2 find_after_path_ptr unal bit (18),
  2   179     2 retr_before_path_ptr unal bit (18),
  2   180     2 retr_err_path_ptr unal bit (18),
  2   181     2 retr_after_path_ptr unal bit (18),
  2   182     2 unused_1 unal bit (18),				/* for future expansion */
  2   183     2 unused_2 unal bit (18),
  2   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  2   185 dcl  ri_ptr ptr;
  2   186 
  2   187 /* a attr_info structure contains information about an attribute in a given relation.
  2   188*   since attributes may appear in more than one relation, each occurence of an attribute
  2   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  2   190*   the list is singly linked in definition order. the attr_info describes
  2   191*   the data it represents, and how that data is used during a database search. */
  2   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  2   193     2 name char (32),				/* name of attribute */
  2   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  2   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  2   196     2 link_attr bit (1) unal,				/* on if participates in link */
  2   197     2 reserved bit (33) unal,
  2   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  2   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  2   200     2 key_order unal fixed bin,			/* relative posit. in key */
  2   201     2 bit_offset fixed bin (35),			/* position in tuple */
  2   202     2 bit_length fixed bin (35),			/* length if fixed */
  2   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  2   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  2   205     2 domain_ptr unal bit (18),			/* to domain info */
  2   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  2   207     2 fwd_thread unal bit (18),			/* to next in list */
  2   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  2   209 dcl  ai_ptr ptr;
  2   210 
  2   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  2   212*   each time a foreign key definition indicates a relation as it's parent,
  2   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  2   214*   a relation can be parent and/or child in any number of foreign keys.
  2   215*   the parent_link_info structure describes the foreign key, and also points
  2   216*   to a list of the attributes that participate in this foreign key.
  2   217*   (this could be from 1 up to all attributes in the relation)
  2   218*   the attr_list structures are in a singly linked list in definition order
  2   219*   for this purpose. also pointed to is a list of child_link_info's
  2   220*   that describe the child relations in this foreign key. since foreign keys
  2   221*   may span files, not all related child_link_info's have to be in this file's
  2   222*   model area. */
  2   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  2   224     2 name char (32),				/* name of link */
  2   225     2 singular bit (1) unal,				/* on if system owned link */
  2   226     2 temp bit (1) unal,				/* on if temp. order */
  2   227     2 first bit (1) unal,				/* insertion indicators */
  2   228     2 last bit (1) unal,
  2   229     2 next bit (1) unal,
  2   230     2 prior bit (1) unal,
  2   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  2   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  2   233     2 dup_first bit (1) unal,				/* duplicates first */
  2   234     2 dup_last bit (1) unal,				/* duplicates last */
  2   235     2 indexed bit (1) unal,				/* locate parent via index */
  2   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  2   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  2   238     2 thread_27 bit (1) unal,
  2   239     2 thread_18 bit (1) unal,
  2   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  2   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  2   242     2 reserved bit (19) unal,				/* reserved for future flags */
  2   243     2 index_id aligned bit (8),			/* id of index if indexed */
  2   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  2   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  2   246     2 n_children unal fixed bin,			/* no. children in link */
  2   247     2 child_fn char (30),				/* file name for first child in list */
  2   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  2   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  2   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  2   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  2   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  2   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  2   254     2 sort_err_path_ptr unal bit (18),
  2   255     2 sort_after_path_ptr unal bit (18),
  2   256     2 srch_before_path_ptr unal bit (18),
  2   257     2 srch_err_path_ptr unal bit (18),
  2   258     2 srch_after_path_ptr unal bit (18),
  2   259     2 link_before_path_ptr unal bit (18),
  2   260     2 link_err_path_ptr unal bit (18),
  2   261     2 link_after_path_ptr unal bit (18),
  2   262     2 unlk_before_path_ptr unal bit (18),
  2   263     2 unlk_err_path_ptr unal bit (18),
  2   264     2 unlk_after_path_ptr unal bit (18),
  2   265     2 unused_1 unal bit (18),				/* for future expansion */
  2   266     2 unused_2 unal bit (18),
  2   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  2   268 dcl  pli_ptr ptr;
  2   269 
  2   270 /* a child_link_info structure is the counter part of a parent_link_info
  2   271*   for foreign key child relations. each time a relation is defined to be
  2   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  2   273*   this list is singly linked in foreign key definition order.
  2   274*   the child_link_info points to a list of participating attributes from the
  2   275*   child relation by means of a singly linked list of attr_list structures
  2   276*   in definition order. the number of attributes in the parent attr_list
  2   277*   and the child attr_list lists are the same with corresponding attr_list
  2   278*   attributes having the same domain. all child_link_infos in this file
  2   279*   are on a seperately linked list. this may not include all
  2   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  2   281*   since foreign keys may span files, and the child_link_info will
  2   282*   reside in the file containing it's associated relation_info. */
  2   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  2   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  2   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  2   286     2 fixed bit (1) unal,				/* on if membership fixed */
  2   287     2 optional bit (1) unal,				/* on if membership optional */
  2   288     2 auto bit (1) unal,				/* on if insertion automatic */
  2   289     2 manual bit (1) unal,				/* on if insertion manual */
  2   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  2   291     2 range_sel bit (1) unal,				/* on if range type selection */
  2   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  2   293     2 key_dup_last bit (1) unal,
  2   294     2 key_null bit (1) unal,				/* on if null allowed */
  2   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  2   296     2 sel_current bit (1) unal,
  2   297     2 sel_key bit (1) unal,
  2   298     2 sel_proc bit (1) unal,
  2   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  2   300     2 reserved bit (21) unal,
  2   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  2   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  2   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  2   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  2   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  2   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  2   307     2 parent_fn char (30),				/* file name for parent info */
  2   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  2   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  2   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  2   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  2   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  2   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  2   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  2   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  2   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  2   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  2   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  2   319     2 link_err_path_ptr unal bit (18),
  2   320     2 link_after_path_ptr unal bit (18),
  2   321     2 unlk_before_path_ptr unal bit (18),
  2   322     2 unlk_err_path_ptr unal bit (18),
  2   323     2 unlk_after_path_ptr unal bit (18),
  2   324     2 srch_before_path_ptr unal bit (18),
  2   325     2 srch_err_path_ptr unal bit (18),
  2   326     2 srch_after_path_ptr unal bit (18),
  2   327     2 unused_1 unal bit (18),				/* for future expansion */
  2   328     2 unused_2 unal bit (18) ;
  2   329 dcl  cli_ptr ptr;
  2   330 
  2   331 /* the attr_list structure is associated with the parent_link_info
  2   332*   and child_link_info structures to represent by means of a singly linked list
  2   333*   the participating attributes from relations in a foreign key.
  2   334*   the parent_link_info has a list for the parent relation,
  2   335*   and the child_link_info has a list for the child relation.
  2   336*   the participating attributes are a subset(not necessary proper) of
  2   337*   those attributes contained in a relation definition.
  2   338*   there are equal numbers of attr_list structures in the parent and
  2   339*   child lists of the same foreign key. the corresponding attributes in these
  2   340*   lists must have the same domain. */
  2   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  2   342     2 attr_fn char (30),				/* file name for attr. */
  2   343     2 attr_ptr unal bit (18),				/* to attr info block */
  2   344     2 fwd_thread unal bit (18);			/* to next in list */
  2   345 dcl  al_ptr ptr;
  2   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  2   347     2 ascend bit (1) unal,				/* ascending order */
  2   348     2 descend bit (1) unal,				/* descending order */
  2   349     2 reserved bit (34) unal,
  2   350     2 attr_ptr unal bit (18),				/* to attr info */
  2   351     2 fwd_thread unal bit (18);			/* to next in list */
  2   352 dcl  sk_ptr ptr;
  2   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  2   354     2 attr_ptr unal bit (18),				/* to attr info */
  2   355     2 fwd_thread unal bit (18);			/* to next in list */
  2   356 dcl  dp_ptr ptr;
  2   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  2   358     2 link_fn char (30),				/* file name for thru link */
  2   359     2 link_ptr unal bit (18),				/* to parent link info */
  2   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  2   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  2   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  2   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  2   364     2 fwd_thread unal bit (18);			/* to next in chain */
  2   365 dcl  sc_ptr ptr;
  2   366 
  2   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  2   368 
  2   369 
      209 
      210 
  3     1 /* BEGIN mdbm_index.incl.pl1 -- jaw, 5/12/78 */
  3     2 
  3     3 dcl 1 index aligned based (ind_ptr),			/* layout of mdbm_index for all file types */
  3     4     2 rel_id bit (12) unal,				/* relation id */
  3     5     2 index_id bit (8) unal,				/* id of index within rel */
  3     6     2 mbz bit (7) unal,				/* pad to char. */
  3     7     2 index_val char (ind_val_len) unal;		/* index value; max 253 chars */
  3     8 
  3     9 dcl  ind_ptr ptr;
  3    10 dcl  ind_val_len fixed bin (35);
  3    11 
  3    12 /* END mdbm_index.incl.pl1 */
  3    13 
      211 
      212 
  4     1 /* BEGIN INCLUDE FILE rmdb_history_entry.incl.pl1 -- nsd, 82-04-09 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(75-01-01,WhoKnows), approve(), audit(), install():
  4     7*     Written.
  4     8*  2) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
  4     9*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  4    10*     Added RMDB_ADD_(ATTR DMN)_OP, RMDB_RN_(ATTR DMN REL)_OP.
  4    11*                                                   END HISTORY COMMENTS */
  4    12 
  4    13 
  4    14 /*
  4    15*   This include file contains the rmdb_history_entry structure which
  4    16*   is  used for maintaining a history of the databases restructuring
  4    17*   events. It also contains a set of constants used in  loading  the
  4    18*   structure.
  4    19*
  4    20*   The restructuring history is applied against the  database  as  a
  4    21*   whole  instead of against each structure in the db_model and file
  4    22*   models which was the approach originally  implemented  but  never
  4    23*   really  used  (except  to  record the database creation). This is
  4    24*   because 1 database restructuring event, i.e. adding a  new  index
  4    25*   to a relation will change several of the structures in the model.
  4    26*
  4    27*   For a detailed explaination of the use of this structure and  the
  4    28*   constants see the rmdb_add_rmdb_event module.
  4    29**/
  4    30 
  4    31 dcl 01 rmdb_history_entry aligned based (rmdb_history_entry_ptr),
  4    32     02 user_id char (32),				/* person_id.project_id.tag */
  4    33     02 date_time_restructured fixed bin (71),
  4    34     02 type_of_object_restructured fixed bin,		/* taken from constants below */
  4    35     02 object_name char (32),
  4    36     02 operation fixed bin,				/* taken from constants below */
  4    37     02 secondary_object_name char (32),			/* i.e. name of attr just indexed in a restructured relation */
  4    38     02 offset_to_next_entry bit (18) unal,
  4    39     02 offset_to_previous_entry bit (18) unal;
  4    40 	
  4    41 
  4    42 dcl  rmdb_history_entry_ptr ptr;
  4    43 
  4    44 
  4    45 dcl  RMDB_DOMAIN_TYPE init (1) fixed bin internal static options (constant);
  4    46 dcl  RMDB_ATTR_TYPE init (2) fixed bin internal static options (constant);
  4    47 dcl  RMDB_REL_TYPE init (3) fixed bin internal static options (constant);
  4    48 
  4    49 
  4    50 dcl  RMDB_ADD_REL_OP init (1) fixed bin internal static options (constant);
  4    51 dcl  RMDB_DEL_REL_OP init (2) fixed bin internal static options (constant);
  4    52 dcl  RMDB_ADD_IDX_OP init (3) fixed bin internal static options (constant);
  4    53 dcl  RMDB_DEL_IDX_OP init (4) fixed bin internal static options (constant);
  4    54 dcl  RMDB_ADD_ATTR_OP init (5) fixed bin int static options (constant);
  4    55 dcl  RMDB_DEL_ATTR_OP init (6) fixed bin int static options (constant);
  4    56 dcl  RMDB_ADD_DMN_OP init (7) fixed bin int static options (constant);
  4    57 dcl  RMDB_DEL_DMN_OP init (8) fixed bin int static options (constant);
  4    58 dcl  RMDB_RN_ATTR_OP init (9) fixed bin int static options (constant);
  4    59 dcl  RMDB_RN_DMN_OP init (10) fixed bin int static options (constant);
  4    60 dcl  RMDB_RN_REL_OP init (11) fixed bin int static options (constant);
  4    61 
  4    62 /* END INCLUDE FILE rmdb_history_entry.incl.pl1 */
      213 
      214 
  5     1 /* BEGIN - mrds_rmdb_ctl.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(82-03-26,Davids), approve(), audit(), install():
  5     7*     created
  5     8*  2) change(82-05-26,Davids), approve(), audit(), install():
  5     9*     added db_model_ptr
  5    10*  3) change(82-06-09,Harvey), approve(), audit(), install():
  5    11*     deleted ssu_ routines ptr storage
  5    12*  4) change(82-08-20,Davids), approve(), audit(), install():
  5    13*     added the relmgr like reference and included the rmdb_relmgr_entries
  5    14*     include file
  5    15*  5) change(83-05-24,Davids), approve(), audit(), install():
  5    16*     added the saved_res_version_ptr element
  5    17*  6) change(84-10-23,Benjamin), approve(), audit(), install():
  5    18*     added flags (just database_readied_by_rmdb for now).
  5    19*  7) change(85-11-08,Spitzer), approve(85-11-08,MCR7311),
  5    20*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  5    21*     added crossref_file_info.
  5    22*                                                   END HISTORY COMMENTS */
  5    23 
  5    24 
  5    25 dcl 01 rmdb_ctl based (rmdb_ctl_ptr),
  5    26     02 version fixed bin,
  5    27     02 rmdb_version char (16) varying,
  5    28     02 absolute_db_path char (168),
  5    29     02 temp_dir_path char (168),
  5    30     02 work_area_ptr ptr,
  5    31     02 db_model_ptr ptr,
  5    32     02 saved_res_version_ptr ptr,
  5    33     02 crossref_file_info,
  5    34        03 iocb_ptr ptr,
  5    35        03 name char (32),
  5    36     02 relmgr_entries like rmdb_relmgr_entries,
  5    37     02 flags,
  5    38        03 database_readied_by_rmdb bit (1) unal,
  5    39        03 unused bit (35) unal;
  5    40     	
  5    41 dcl  RMDB_CTL_VERSION_1 fixed bin init (1) internal static options (constant);
  5    42 
  5    43 dcl  rmdb_ctl_ptr ptr;
  5    44 
  5    45 
  6     1 /*  START OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(82-08-20,Davids), approve(), audit(), install():
  6     6*     written
  6     7*  2) change(86-01-28,Spitzer), approve(86-01-28,MCR7311),
  6     8*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  6     9*     add get_tuples_by_spec, put_tuple, put_tuples, create_cursor entry points.
  6    10*  3) change(86-08-21,Blair), approve(86-08-21,MCR7311),
  6    11*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  6    12*     Back out the entries get_tuples_by_spec and put_tuples since they aren't
  6    13*     sufficiently well tested to be reliable.  Replace with get_tuple_id and
  6    14*     get_tuple_by_id.
  6    15*                                                   END HISTORY COMMENTS */
  6    16 
  6    17 
  6    18 dcl 01 rmdb_relmgr_entries based (rmdb_relmgr_entries_ptr),
  6    19      02 create_relation entry (char (*), char (*), ptr, ptr, bit (36) aligned,
  6    20 	bit (36) aligned, fixed bin (35)),
  6    21      02 delete_relation entry (char (*), char (*), fixed bin (35)),
  6    22      02 open entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  6    23      02 close entry (bit (36) aligned, fixed bin (35)),
  6    24      02 create_index entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17),
  6    25 	bit (36) aligned, fixed bin (35)),
  6    26      02 delete_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35)),
  6    27      02 put_tuple entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  6    28      02 get_tuple_id entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  6    29      02 get_tuple_by_id entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  6    30      02 create_cursor entry (bit (36) aligned, ptr, ptr, fixed bin (35));
  6    31 
  6    32 dcl rmdb_relmgr_entries_ptr ptr;
  6    33 
  6    34 /*  END OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5    46 
  5    47 
  5    48 
  5    49 /* END - mrds_rmdb_ctl.incl.pl1 */
      215 
      216 
  7     1 /* BEGIN INCLUDE FILE - dm_rel_creation_info.incl.pl1 */
  7     2 
  7     3 /* format: style1 */
  7     4      dcl	   1 rel_creation_info    aligned based (rel_creation_info_ptr),
  7     5 	     2 version	      fixed bin (35),
  7     6 	     2 file_create_info_ptr ptr,
  7     7 	     2 esm_info_ptr	      ptr,
  7     8 	     2 cism_info_ptr      ptr;
  7     9 
  7    10      dcl	   rel_creation_info_ptr  ptr;
  7    11      dcl	   REL_CREATION_INFO_VERSION_2 fixed bin (35) init (2);
  7    12 
  7    13 /* END INCLUDE FILE - dm_rel_creation_info.incl.pl1 */
      217 
      218 
  8     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION
  8     4*        The id_list structure is used to identify attributes, fields and
  8     5*   dimensions by various modules of the Data Management System.
  8     6**/
  8     7 
  8     8 /* HISTORY:
  8     9*Written by Matthew Pierret, '82.
  8    10*Modified:
  8    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
  8    12*            (constant)' and to initialize automatic variables.
  8    13**/
  8    14 
  8    15 /* format: style2,ind3 */
  8    16      dcl	   1 id_list	      aligned based (id_list_ptr),
  8    17 	     2 version	      fixed bin (35),
  8    18 	     2 number_of_ids      fixed bin (17),
  8    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
  8    20 
  8    21      dcl	   id_list_ptr	      ptr init (null);
  8    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
  8    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
  8    24 
  8    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
      219 
      220 
  9     1 /*  BEGIN INCLUDE FILE - dm_relation_index_flags.incl.pl1 */
  9     2 
  9     3 /* DESCRIPTION:
  9     4*
  9     5*	This structure is used to control the creation of an index by the 
  9     6*     relation_manager_.
  9     7**/
  9     8 
  9     9 /* HISTORY:
  9    10*
  9    11*Written by Lindsey Spratt, 09/20/83.
  9    12*Modified:
  9    13**/
  9    14 
  9    15 /* format: style2,ind3 */
  9    16      dcl	   1 relation_index_flags based (relation_index_flags_ptr) aligned,
  9    17 	     2 relation_must_be_empty
  9    18 			      bit (1) unal,
  9    19 	     2 index_is_clustering
  9    20 			      bit (1) unal,
  9    21 	     2 index_is_unique    bit (1) unal,
  9    22 	     2 pad	      bit (33) unal;
  9    23 
  9    24      dcl	   relation_index_flags_ptr
  9    25 			      ptr init (null);
  9    26 
  9    27 /*  END INCLUDE FILE - dm_relation_index_flags.incl.pl1 */
      221 
      222 
      223 /*
      224*   Initialize variables which may be referenced before they are  set
      225*   somewhere else
      226**/
      227 	rci_quit_signaled = "0"b;
      228 	rmdb_ctl_ptr = rci_rmdb_ctl_ptr;
      229 	rci_rel_opening_id = "0"b;
      230 	rci_backout_occured = "0"b;
      231 	mstxn_transactions_needed = "0"b;
      232 	mstxn_txn_id = "0"b;
      233 
      234 /* 
      235*   If the database needs transactions and one is already in progress stop right now.
      236**/
      237 	if rci_db_model_ptr -> db_model.db_type_flags.transactions_needed
      238 	then do;
      239 		mstxn_transactions_needed = "1"b;
      240 		call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
      241 		if mstxn_code ^= dm_error_$no_current_transaction
      242 		then do;
      243 			rci_code = error_table_$action_not_performed;
      244 			rci_error_message = "Indexes may not be created while a transaction is in progress, " ||
      245 			     "commit or abort current transaction and try again.";
      246 			goto exit_rmdb_create_index;
      247 		     end;
      248 	     end;
      249 
      250 /*
      251*   Get pointers to the db_model and relation's file  model,  extract
      252*   from  the  models  those values needed to build the index
      253**/
      254 
      255 	call initiate_models (rci_db_abs_path, rci_rel_name, rci_file_model_ptr);
      256 
      257 	call get_relation_data (rci_db_model_ptr, rci_file_model_ptr, rci_rel_name, rci_file_id,
      258 	     rci_rel_ptr, rci_rel_id, rci_number_of_attrs, rci_number_of_varying_attrs, rci_max_data_length);
      259 
      260 	call get_attribute_data (rci_db_model_ptr, rci_file_model_ptr, rci_rel_ptr,
      261 	     rci_rel_name, rci_attr_name, rci_attr_ptr, rci_attr_desc, rci_attr_defn_order);
      262 
      263 
      264 	on cleanup call mstxn_cleanup;
      265 
      266 	on any_other call mstxn_any_other;
      267 
      268 
      269 
      270 	rci_caller_name = "rmdb_create_index";
      271 	ai_ptr = rci_attr_ptr;
      272 	il_number_of_ids = 1;
      273 	allocate id_list in (wa);
      274 	id_list.number_of_ids = 1;
      275 	id_list.version = ID_LIST_VERSION_1;
      276 	id_list.id (1) = rci_attr_ptr -> attr_info.defn_order;
      277 
      278 /* initialize values for create_index */
      279 	rci_style = 1;
      280 	relation_index_flags_ptr = addr (rci_flag_list);
      281 	relation_index_flags.relation_must_be_empty = "0"b;
      282 	relation_index_flags.index_is_clustering = "0"b;
      283 	relation_index_flags.index_is_unique = "0"b;
      284 	relation_index_flags.pad = "0"b;
      285 
 10     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
 10     2 
 10     3 
 10     4 
 10     5 /****^  HISTORY COMMENTS:
 10     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
 10     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
 10     8*     This entry is being made to cover the changes made on 85-05-06 and
 10     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
 10    10*     was removed because not all modules need the dbcb, and the
 10    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
 10    12*     list #136).
 10    13*                                                   END HISTORY COMMENTS */
 10    14 
 10    15 
 10    16 /*
 10    17*                    BEGIN_DESCRIPTION
 10    18*
 10    19*   A generalized routine accessed by all MRDS modules (with the temporary 
 10    20*   (perhaps) exception of restructuring modules) that must start transactions 
 10    21*   if none are present.  The intent is that it be executed as inline code.
 10    22*   The variable mstxn_transactions_needed must be set prior to entering this
 10    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
 10    24*   will suffice.  Included are procedures called mstxn_cleanup and 
 10    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
 10    26*   handlers in the program.  Such handlers should be established just prior to
 10    27*   the inclusion of this code and disabled just following the inclusion of
 10    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
 10    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
 10    30*   include file does the same, because this code might not have been entered 
 10    31*   yet when the handler is invoked.  Directly following this include file the 
 10    32*   contents of mstxn_code should be examined.  If zero, then either the 
 10    33*   transaction was successfully started or no transaction was required.  If the
 10    34*   mrds_finish_transaction code is referenced in general error handling 
 10    35*   situations where the possibility exists that the code in this include file 
 10    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
 10    37*   the beginning of the program.
 10    38*
 10    39*                    END_DESCRIPTION
 10    40*
 10    41*   Written 82-09-28 by Paul W. Benjamin.
 10    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
 10    43*   Modified 83-01-07 by PWB to not reference the dbcb.
 10    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
 10    45*		 any_other handler in situations where the module did
 10    46*		 not start the transaction.
 10    47*   Modified 83-05-05 by PWB to abandon when abort fails.
 10    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
 10    49*		 and abort.
 10    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
 10    51*		 transaction_bj_full conditions.
 10    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
 10    53*		 and to handle transaction_lock_timeout_.
 10    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
 10    55*                     dbcb.user_started_transaction flag.
 10    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
 10    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
 10    58*                     directory >ldd>include and >exl>mrd>i
 10    59**/
 10    60 
 10    61 dcl continue_to_signal_ entry (fixed bin(35));
 10    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
 10    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
 10    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
 10    65 dcl mstxn_code fixed bin (35);
 10    66 dcl mstxn_retries fixed;
 10    67 dcl mstxn_temp_code fixed bin (35);
 10    68 dcl mstxn_transactions_needed bit (1) aligned;
 10    69 dcl user_started_transaction bit (1) aligned;
 10    70 dcl mstxn_txn_id bit (36) aligned;
 10    71 dcl user_transaction_id bit (36) aligned;
 10    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
 10    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
 10    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
 10    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
 10    76 dcl transaction_manager_$handle_conditions entry ();
 10    77 dcl 1 mstxn_condition_info like condition_info;
 10    78 
 11     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 11     2 
 11     3 /* HISTORY:
 11     4*
 11     5*Designed by Matthew C. Pierret, 01/26/82.
 11     6*Coded by Jeffrey D. Ives, 04/30/82.
 11     7*Modified:
 11     8*10/18/82 by Steve Herbst: Names changed.
 11     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
 11    10**/
 11    11 
 11    12 dcl (LOWEST_MODE init (1),
 11    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
 11    14 
 11    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
 11    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
 11    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
 11    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
 11    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
 11    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
 11    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
 11    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
 11    23 
 11    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 10    79 

 10    80 
 12     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
 12     2 
 12     3 /* Structure for find_condition_info_.
 12     4*
 12     5*   Written 1-Mar-79 by M. N. Davidoff.
 12     6**/
 12     7 
 12     8 /* automatic */
 12     9 
 12    10      declare condition_info_ptr     pointer;
 12    11 
 12    12 /* based */
 12    13 
 12    14      declare 1 condition_info	      aligned based (condition_info_ptr),
 12    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
 12    16 	     2 version	      fixed binary,		/* Must be 1 */
 12    17 	     2 condition_name     char (32) varying,	/* name of condition */
 12    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
 12    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
 12    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
 12    21 	     2 flags	      unaligned,
 12    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
 12    23 	       3 pad1	      bit (35),
 12    24 	     2 pad2	      bit (36),
 12    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
 12    26 	     2 pad3	      (4) bit (36);
 12    27 
 12    28 /* internal static */
 12    29 
 12    30      declare condition_info_version_1
 12    31 			      fixed binary internal static options (constant) initial (1);
 12    32 
 12    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
 10    81 
 10    82 
 10    83 	mstxn_code = 0;
 10    84 	mstxn_txn_id = "0"b;
 10    85 	
 10    86 	if ^mstxn_transactions_needed			/* only need transactions */
 10    87 	     then goto mstxn_exit;			/* for protected page files */
 10    88 	mstxn_retries = 0;
 10    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
 10    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
 10    91 	     then do;				
 10    92 	     user_started_transaction = "1"b;
 10    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
 10    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
 10    95 	     goto mstxn_exit;	
 10    96 	end;
 10    97 
 10    98 	user_started_transaction = "0"b;
 10    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
 10   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
 10   101 
 10   102 mstxn_cleanup:
 10   103 proc;
 10   104 
 10   105 /*  This procedure MUST be called by a cleanup handler. */
 10   106 
 10   107           if mstxn_txn_id ^= "0"b
 10   108           then do;
 10   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
 10   110 	     if mstxn_temp_code ^= 0
 10   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
 10   112 	end;
 10   113 	
 10   114      end mstxn_cleanup;
 10   115 
 10   116 mstxn_any_other:
 10   117 proc;
 10   118 
 10   119 /*  This procedure MUST be called by an any_other handler. */
 10   120 
 10   121           if mstxn_txn_id ^= "0"b
 10   122           then do;
 10   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
 10   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
 10   125 		then do;
 10   126 		mftxn_code = dm_error_$lock_deadlock;
 10   127 		goto mftxn_check_code;
 10   128 	     end;
 10   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
 10   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
 10   131 		then do;
 10   132 		mftxn_code = dm_error_$bj_journal_full;
 10   133 		goto mftxn_check_code;
 10   134 	     end;
 10   135 	     else call transaction_manager_$handle_conditions;
 10   136 	end;
 10   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
 10   138      end mstxn_any_other;
 10   139      
 10   140 mstxn_exit:
 10   141      
 10   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
      286 
      287 
      288 	if mstxn_code ^= 0
      289 	then do;
      290 		rci_error_message = "Could not start a transaction";
      291 		goto exit_rmdb_create_index;
      292 	     end;
      293 
      294 	rci_backout_occured = "0"b;
      295 
      296 /*
      297*   Update the model. This operation consists  of  marking  the  data
      298*   base  as  inconsistent  and  updating  the relation and attribute
      299*   models. The version of the saved resultant is also changed so that
      300*   it will not be used for opening the database. In addition a history
      301*   entry is added  to  the  data  base model.  This  update is done
      302*   before any of the data is changed so that there is enough information
      303*   avaiable so that the delete_index request can work.
      304*
      305*   If a quit is signaled during this time, the fact is recorded, but
      306*   the  quit  is  not processed. After the model has been completely
      307*   updated the quit is signaled.
      308**/
      309 
      310 	on quit rci_quit_signaled = "1"b;
      311 	rmdb_ctl_ptr -> rmdb_ctl.saved_res_version_ptr -> rci_based_char8 = "RESTRUCT";
      312 	call mdbm_util_$inconsistent_set (rci_db_model_ptr, "create_index", "Indexing attribute " ||
      313 	     rtrim (rci_attr_name) || " in relation " || rtrim (rci_rel_name),
      314 	     "delete_index " || rtrim (rci_rel_name) || " " || rtrim (rci_attr_name) || " -brief");
      315 	call update_model (rci_db_model_ptr, rci_rel_ptr, rci_attr_ptr);
      316 	revert quit;
      317 	if rci_quit_signaled
      318 	then do;
      319 		rci_quit_signaled = "0"b;
      320 		signal quit;
      321 	     end;
      322 
      323 	on cleanup begin;
      324 		call mstxn_cleanup;
      325 		call clean_up ("0"b, "1"b);
      326 	     end;
      327 
      328 	call rmdb_ctl.relmgr_entries.open (rci_db_abs_path, rci_rel_name,
      329 	     rci_rel_opening_id, rci_code);
      330 	if rci_code ^= 0
      331 	then do;
      332 		rci_error_message = "Could not open the relation to create the index.";
      333 		call restore_significant_data;
      334 		goto mftxn_exit;			/* need to reset the inconsistency of db */
      335 	     end;
      336 
      337 	call rmdb_ctl.relmgr_entries.create_index (rci_rel_opening_id,
      338 	     id_list_ptr, rci_flag_list, rci_style,
      339 	     attr_info.index_id, rci_code);
      340 
      341 	mftxn_code = rci_code;
      342 
 13     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
 13     2 
 13     3 
 13     4 
 13     5 /****^  HISTORY COMMENTS:
 13     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
 13     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
 13     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
 13     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
 13    10*                                                   END HISTORY COMMENTS */
 13    11 
 13    12 
 13    13 /*
 13    14*                    BEGIN_DESCRIPTION
 13    15*
 13    16*   A generalized routine accessed by all MRDS modules that begin and commit 
 13    17*   transactions.  The intent is that it be executed as inline code. It is 
 13    18*   assumed that mrds_start_transaction was executed previously in the 
 13    19*   procedure.  Prior to this include file the program should assign the value 
 13    20*   of its local error code to mftxn_code.  The program utilizing this
 13    21*   include file must supply a function labeled should_rollback that returns
 13    22*   bit (1).  This routine should examine the error code mftxn_code and whether
 13    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
 13    24*   means rollback.  This procedure may choose to simply return "0"b as it 
 13    25*   appears that MRDS will generally NOT rollback transactions.  This routine
 13    26*   does rollback and restart if the before journal is full but only attempts it
 13    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
 13    28*   where any data that was saved prior to the transaction is restored.  A 
 13    29*   procedure consisting solely of a return statement can be supplied if 
 13    30*   necessary.  After execution of this include file, mftxn_code must be
 13    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
 13    32*   then the commit has failed.  Otherwise it will be unchanged.
 13    33*
 13    34*                    END_DESCRIPTION
 13    35*
 13    36*   Written 82-09-30 by Paul W. Benjamin.
 13    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
 13    38*                     error code only when the transaction is in an error state.
 13    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
 13    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
 13    41*		 fails, and to abort rather than rollback when bj is full.
 13    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
 13    43*		 and rollback.
 13    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
 13    45*		 to by the mstxn_any_other procedure.
 13    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
 13    47*                     the user already started his own transaction.
 13    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
 13    49*                     the directory >ldd>include and >exl>mrd>i.
 13    50**/
 13    51 
 13    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
 13    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
 13    54 dcl mftxn_code fixed bin (35);
 13    55 dcl mftxn_temp_code fixed bin (35);
 13    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
 13    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
 13    58 	
 13    59 
 13    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
 13    61 	     then do;
 13    62 	     mftxn_code = 0;
 13    63 	     goto mftxn_exit;
 13    64 	end;
 13    65 mftxn_check_code:
 13    66 	if mftxn_code = 0
 13    67 	     then do;
 13    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
 13    69 	     if mftxn_code ^= 0
 13    70 		then do;
 13    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
 13    72 		if mftxn_temp_code ^= 0
 13    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
 13    74 	     end;
 13    75 	end;
 13    76 	else do;
 13    77 	     call restore_significant_data;
 13    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
 13    79 		& mstxn_retries < 1		
 13    80 		then do;
 13    81 		     mstxn_retries = mstxn_retries + 1;
 13    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
 13    83 		     if mftxn_temp_code ^= 0
 13    84 			then do;
 13    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
 13    86 			if mftxn_temp_code ^= 0
 13    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
 13    88 		     end;
 13    89 		     else do;
 13    90 			mstxn_code = 0;
 13    91 			goto mstxn_exit;		/* go back and try again */
 13    92 		     end;
 13    93 		end;
 13    94 	     else if should_rollback ()		/* let the program decide */
 13    95 		then do;
 13    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
 13    97 		if mftxn_temp_code ^= 0
 13    98 		     then do;
 13    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
 13   100 		     if mftxn_temp_code ^= 0
 13   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
 13   102 		end;
 13   103 		else do;
 13   104 		     mstxn_code = 0;
 13   105 		     goto mstxn_exit;		/* go back and try again */
 13   106 		end;
 13   107 	     end;
 13   108 	     else do;
 13   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
 13   110 		if mftxn_temp_code ^= 0
 13   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
 13   112 	     end;
 13   113 	end;
 13   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
 13   115 mftxn_exit:
 13   116      
 13   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
      343 
      344 
      345 	if mftxn_code ^= 0
      346 	then do;
      347 		rci_error_message = "Cound not finish the transaction.";
      348 		call clean_up ("0"b, "1"b);
      349 		goto exit_rmdb_create_index;
      350 	     end;
      351 
      352 	if ^rci_backout_occured & rci_code ^= 0		/* if error occured during creation process */
      353 	then do;
      354 		rci_error_message = "Could not add an index";
      355 		call clean_up ("0"b, "1"b);
      356 		goto exit_rmdb_create_index;
      357 	     end;
      358 
      359 /*
      360*   Mark the data  base  as  consistent  again  don't  let  the  user
      361*   interrupt.  Also  cleanup  attachments  in  this  case  the  "1"b
      362*   indicates that any non-zero error code produced  in  the  cleanup
      363*   handler should be returned to the user, since the database is not
      364*   marked inconsistent the value of the second switch is "0"b.
      365**/
      366 
      367 	on quit rci_quit_signaled = "1"b;
      368 	call mdbm_util_$inconsistent_reset (rci_db_model_ptr);
      369 	revert quit;
      370 	if rci_quit_signaled
      371 	then do;
      372 		rci_quit_signaled = "0"b;
      373 		signal quit;
      374 	     end;
      375 
      376 	call clean_up ("1"b, "0"b);
      377 
      378 exit_rmdb_create_index:
      379 	if rci_quit_signaled
      380 	then do;
      381 		revert quit;
      382 		rci_quit_signaled = "0"b;
      383 		signal quit;
      384 	     end;
      385 	return;
      386 
      387 should_rollback: proc () returns (bit (1));
      388 	return ("0"b);
      389      end should_rollback;
      390 
      391 
      392 
      393 
      394 
      395 
      396 restore_significant_data: proc;
      397 
      398 	dcl     rsd_code		 fixed bin (35);
      399 	dcl     rsd_error_message	 char (500);
      400 
      401 
      402 	rci_rel_ptr -> rel_info.indexed = rci_original_rel_info_indexed;
      403 	rci_rel_ptr -> rel_info.max_attr_index_id =
      404 	     rci_original_rel_info_max_attr_index_id;
      405 	rci_attr_ptr -> attr_info.index_attr = "0"b;
      406 
      407 	call rmdb_add_rmdb_history (rci_db_model_ptr, RMDB_REL_TYPE, (rci_rel_ptr -> rel_info.name),
      408 	     RMDB_DEL_IDX_OP, (rci_attr_ptr -> attr_info.name), rsd_error_message, rsd_code);
      409 
      410 	rci_error_message = rtrim (rci_error_message) || " Backout has occured.";
      411 
      412 	if rci_rel_opening_id ^= "0"b then
      413 	     call rmdb_ctl.relmgr_entries.close (rci_rel_opening_id, rsd_code);
      414 	rci_rel_opening_id = "0"b;
      415 
      416 	rci_backout_occured = "1"b;
      417 
      418 	return;
      419      end restore_significant_data;
      420 
      421 initiate_models: proc (im_db_abs_path, im_rel_name, im_file_model_ptr);
      422 
      423 /*
      424*   This routine initiates a pointer to the  file_model segment that
      425*   contains the relation model. If the file model cannot be found
      426*   it indicates that  the  data  base does not contain the relation.
      427**/
      428 
      429 /* PARAMETERS */
      430 
      431 	dcl     im_db_abs_path	 char (168);	/* (input) path to the data base to be restructured */
      432 	dcl     im_rel_name		 char (*);	/* (input) name of relation to be restructured */
      433 	dcl     im_file_model_ptr	 ptr;		/* (output) pointer to the file model
      434*						   .        that contains the relation */
      435 
      436 
      437 	call hcs_$initiate (im_db_abs_path, rtrim (im_rel_name) || ".m", "", 0, 0, im_file_model_ptr, rci_code);
      438 	if im_file_model_ptr = null ()
      439 	then do;
      440 		call ioa_$rs ("^/The relation ^a does not exist in the data base.",
      441 		     rci_error_message, length (rci_error_message), im_rel_name);
      442 		goto exit_rmdb_create_index;
      443 	     end;
      444 	else rci_code = 0;
      445 
      446 	return;
      447 
      448      end initiate_models;
      449 
      450 get_relation_data: proc (grd_db_model_ptr, grd_file_model_ptr, grd_rel_name, grd_file_id, grd_rel_ptr, grd_rel_id,
      451 	grd_number_of_attrs, grd_number_of_varying_attrs, grd_max_data_length);
      452 
      453 /*
      454*   This routine extracts information from the rel_info and file_info
      455*   structures for the relation to be restructured, i.e. the relation
      456*   with an attribute being indexed.
      457**/
      458 
      459 /* PARAMETERS */
      460 
      461 	dcl     grd_db_model_ptr	 ptr;		/* (input) pointer to the database model */
      462 	dcl     grd_file_model_ptr	 ptr;		/* (input) pointer to the file model that contains the relation */
      463 	dcl     grd_rel_name	 char (*);	/* (input) name of relation to be restructured */
      464 	dcl     grd_file_id		 bit (36);	/* (output) id of the file as defined in the database model */
      465 	dcl     grd_rel_ptr		 ptr;		/* (output) pointer to the rel_info structure */
      466 	dcl     grd_rel_id		 bit (36);	/* (output) id of the relation as defined in rel_info */
      467 	dcl     grd_number_of_attrs	 fixed bin;	/* (output) number of attributes in the relation */
      468 	dcl     grd_number_of_varying_attrs fixed bin;	/* (output) number of varying attributes in the relation */
      469 	dcl     grd_max_data_length	 fixed bin;	/* (output) maximum number of bits of data a tuple
      470*						   .          may have, if tuple contains varying
      471*						   .          data the actual number may be less */
      472 
      473 
      474 	grd_file_id = pointer (grd_db_model_ptr, grd_file_model_ptr -> file_model.fi_ptr) -> file_info.file_id;
      475 
      476 	grd_rel_ptr = pointer (grd_file_model_ptr, grd_file_model_ptr -> rel_ptr);
      477 
      478 	if grd_rel_ptr -> rel_info.name ^= grd_rel_name
      479 	then do;
      480 		rci_code = error_table_$action_not_performed;
      481 		call ioa_$rs ("Data model inconsistant - file ^a contains a relation named ^a",
      482 		     rci_error_message, length (rci_error_message), grd_rel_name, grd_rel_ptr -> rel_info.name);
      483 		goto exit_rmdb_create_index;
      484 	     end;
      485 	else do;
      486 		grd_rel_id = grd_rel_ptr -> rel_info.id;
      487 		grd_number_of_attrs = grd_rel_ptr -> rel_info.num_attr;
      488 		grd_number_of_varying_attrs = grd_rel_ptr -> rel_info.nvar_atts;
      489 		grd_max_data_length = ceil (grd_rel_ptr -> rel_info.max_data_len / 9);
      490 	     end;
      491 
      492 	return;
      493 
      494      end get_relation_data;
      495 
      496 get_attribute_data: proc (gad_db_model_ptr, gad_file_model_ptr, gad_rel_ptr, gad_rel_name, gad_attr_name,
      497 	gad_attr_ptr, gad_attr_desc, gad_attr_defn_order);
      498 
      499 /*
      500*   This  routine  extracts  information  out  of   the   attribute's
      501*   attr_info  and  rel_info structures that have to do with the attr
      502*   being indexed. It also checks various attributes of the attribute
      503*   and reports errors if
      504*   .   1) attribute is already indexed
      505*   .   2) attribute is the first attribute of the  primary  key  and
      506*   .      hence does not need to be indexed
      507*   .   3) attribute's domain will  allow  values  >  253  characters
      508*   .      which is the maximum length of an index
      509*   .   4) relation does not contain the indicated attribute
      510**/
      511 
      512 /* PARAMETERS */
      513 
      514 	dcl     gad_db_model_ptr	 ptr;		/* (input) pointer to the database model */
      515 	dcl     gad_file_model_ptr	 ptr;		/* (input) pointer to the file model that contains the relation */
      516 	dcl     gad_rel_ptr		 ptr;		/* (input) pointer to the rel_info structure */
      517 	dcl     gad_rel_name	 char (*);	/* (input) name of relation to be restructured */
      518 	dcl     gad_attr_name	 char (*);	/* (input) name of attribute to be indexed */
      519 	dcl     gad_attr_ptr	 ptr;		/* (output) pointer to the attr_info structure */
      520 	dcl     gad_attr_desc	 bit (36);	/* (output) standard multics descriptor
      521*						   .        of the attribute to be indexed */
      522 	dcl     gad_attr_defn_order	 fixed bin;
      523 
      524 /* AUTOMATIC */
      525 
      526 	dcl     gad_domain_ptr	 ptr;		/* pointer to attribute's domain info */
      527 	dcl     gad_found		 bit (1);		/* true if the attribute exists in the relation */
      528 	dcl     gad_i		 fixed bin;	/* loop index */
      529 
      530 	gad_attr_ptr = pointer (gad_file_model_ptr, gad_rel_ptr -> rel_info.attr_ptr);
      531 	gad_found = "0"b;
      532 	do gad_i = 1 to gad_rel_ptr -> rel_info.num_attr while (^gad_found);
      533 	     if gad_attr_ptr -> attr_info.name = gad_attr_name
      534 	     then do;
      535 		     gad_found = "1"b;
      536 		     if gad_attr_ptr -> attr_info.index_attr
      537 		     then do;
      538 			     rci_code = error_table_$action_not_performed;
      539 			     call ioa_$rs ("^/Attribute ^a in relation ^a is already indexed",
      540 				rci_error_message, length (rci_error_message), gad_attr_name, gad_rel_name);
      541 			     goto exit_rmdb_create_index;
      542 			end;
      543 		     if gad_attr_ptr -> attr_info.key_attr & gad_attr_ptr -> attr_info.key_order = 1
      544 		     then do;
      545 			     rci_code = error_table_$action_not_performed;
      546 			     call ioa_$rs ("^/Attribute ^a in relation ^a is the first attribute of the^/" ||
      547 				"relation's primary key and can already be used as an index",
      548 				rci_error_message, length (rci_error_message), gad_attr_name, gad_rel_name);
      549 			     goto exit_rmdb_create_index;
      550 			end;
      551 		     gad_attr_defn_order = gad_attr_ptr -> attr_info.defn_order;
      552 		     gad_domain_ptr = pointer (gad_db_model_ptr, gad_attr_ptr -> attr_info.domain_ptr);
      553 		     gad_attr_desc = gad_domain_ptr -> domain_info.db_desc;
      554 		     if mdbm_util_$mu_data_length (gad_attr_desc) > 2277 /* 253 * 9 */
      555 		     then do;
      556 			     rci_code = error_table_$action_not_performed;
      557 			     call ioa_$rs (
      558 				"^/Attribute ^a has a domain that allows values with lengths " ||
      559 				"^/longer than 253 characters - the maximum allowable index length.",
      560 				rci_error_message, length (rci_error_message), gad_attr_name);
      561 			     goto exit_rmdb_create_index;
      562 			end;
      563 		end;
      564 	     else gad_attr_ptr = pointer (gad_file_model_ptr, gad_attr_ptr -> attr_info.fwd_thread);
      565 	end;
      566 	if ^gad_found
      567 	then do;
      568 		rci_code = error_table_$action_not_performed;
      569 		call ioa_$rs ("^/Relation ^a does not contain an attribute named ^a",
      570 		     rci_error_message, length (rci_error_message), gad_rel_name, gad_attr_name);
      571 		goto exit_rmdb_create_index;
      572 	     end;
      573 
      574 	return;
      575 
      576      end get_attribute_data;
      577 
      578 update_model: proc (um_db_model_ptr, um_rel_ptr, um_attr_ptr);
      579 
      580 /*
      581*   This procedure updates the model to indicate the new index and to
      582*   record that restructuring has taken place. The index_id will be set
      583*   by the relation_manager when it creates the index but the rel_mgr
      584*   expects the id to be "0"b until it actually sets it. It also sets the
      585*   max_attr_index_id to 512 so that MR10.1 rmdb will die. This is needed
      586*   because the max_attr_index_id which is used by MR10.1 rmdb to calculate
      587*   the new index_id can no longer be guarenteeded to be the maximum index
      588*   id once MR10.2 rmdb has been used. MR10.1 rmdb had a check that refused
      589*   to allow the index_id to go above 511 because it was only 8 bits long,
      590*   setting max_attr_index_id (which is fixed bin) will therefore stop
      591*   MR10.1 rmdb.
      592**/
      593 
      594 /* PARAMETERS */
      595 
      596 	dcl     um_db_model_ptr	 ptr;		/* (input) pointer to the database model */
      597 	dcl     um_rel_ptr		 ptr;		/* (input) pointer to the rel_info structure */
      598 	dcl     um_attr_ptr		 ptr;		/* (input) pointer to the attr_info structure */
      599 
      600 	rci_original_rel_info_indexed = um_rel_ptr -> rel_info.indexed;
      601 	um_rel_ptr -> rel_info.indexed = "1"b;
      602 
      603 	rci_original_rel_info_max_attr_index_id = um_rel_ptr -> rel_info.max_attr_index_id;
      604 	um_rel_ptr -> rel_info.max_attr_index_id = 512;
      605 
      606 	um_attr_ptr -> attr_info.index_attr = "1"b;
      607 	um_attr_ptr -> attr_info.index_id = "0"b;
      608 
      609 	call rmdb_add_rmdb_history (um_db_model_ptr, RMDB_REL_TYPE, (um_rel_ptr -> rel_info.name),
      610 	     RMDB_ADD_IDX_OP, (um_attr_ptr -> attr_info.name), rci_error_message, rci_code);
      611 	if rci_code ^= 0
      612 	then do;
      613 		call clean_up ("0"b, "1"b);
      614 		goto exit_rmdb_create_index;
      615 	     end;
      616 
      617 	return;
      618 
      619      end update_model;
      620 
      621 clean_up: proc (cu_set_code, cu_leave_db_inconsistent);
      622 
      623 /*
      624*   This procedure is called both during normal and error termination
      625*   and in the event that the cleanup condition is signaled.
      626*
      627*   In the event that this procedure is called due  to  an  error  we
      628*   want  to  be sure that the error code reported to the user is the
      629*   one that caused the error. There is therefore a local error  code
      630*   in  this procedure which is set to the global error code (the one
      631*   returned  to   the   user)   only   during   normal   (non-error,
      632*   non-cleanup_condition) termination and if an error occurs in this
      633*   procedure (this could occur  during  io  attachment  cleanup).  A
      634*   record  of  the  error is concatinated onto the end of the global
      635*   error_message so that the caller has some indication of what went
      636*   wrong.
      637**/
      638 
      639 
      640 
      641 
      642 
      643 
      644 /* PARAMETERS */
      645 
      646 	dcl     cu_set_code		 bit (1);		/* (input) true ==> if error occurs during cleanup, global error
      647*						   .       code will be set to error */
      648 	dcl     cu_leave_db_inconsistent bit (1);	/* (input) true ==> the dba will not be queried if indexing is
      649*						   .       to continue and the message giving directions for
      650*						   .       how to make the db consistent will be concatinated
      651*						   .       to the returned error message */
      652 
      653 /* AUTOMATIC */
      654 
      655 	dcl     cu_code		 fixed bin (35);	/* local error code */
      656 
      657 
      658 
      659 
      660 	if cu_leave_db_inconsistent
      661 	then rci_error_message = rtrim (rci_error_message) ||
      662 		"^/The data base is being left in an inconsistant state," ||
      663 		"^/to make the database consistent use the delete_index request" ||
      664 		"^/to delete the partially created index.";
      665 
      666 
      667 	if rci_rel_opening_id ^= "0"b then
      668 	     call rmdb_ctl.relmgr_entries.close (rci_rel_opening_id, cu_code);
      669 	if cu_set_code
      670 	then do;					/* set global error code, if error in cleanup occured */
      671 		if cu_code ^= 0			/* if error didn't occur don't change anything */
      672 		then do;
      673 			rci_code = cu_code;
      674 			if rci_code = 0		/* keep old message if there was another error */
      675 			then rci_error_message = "^/The relation could not be closed.";
      676 			else rci_error_message = rtrim (rci_error_message) ||
      677 				"^/The relation could not be closed.";
      678 		     end;
      679 	     end;
      680 	else do;
      681 		if cu_code ^= 0			/* even if code is not reset, let user know error occured */
      682 		then rci_error_message = rtrim (rci_error_message) ||
      683 			"^/The relation could not be close.";
      684 	     end;
      685 
      686 	return;
      687 
      688      end clean_up;
      689 
      690 
      691      end rmdb_create_index;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1143.2  rmdb_create_index.pl1             >special_ldd>install>MR12.0-1187>rmdb_create_index.pl1
207          1    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
209          2    10/16/86  1139.9  mdbm_file_model.incl.pl1          >special_ldd>install>MR12.0-1187>mdbm_file_model.incl.pl1
211          3    10/14/83  1608.3  mdbm_index.incl.pl1               >ldd>include>mdbm_index.incl.pl1
213          4    10/16/86  1139.6  rmdb_history_entry.incl.pl1       >special_ldd>install>MR12.0-1187>rmdb_history_entry.incl.pl1
215          5    10/16/86  1139.6  mrds_rmdb_ctl.incl.pl1            >special_ldd>install>MR12.0-1187>mrds_rmdb_ctl.incl.pl1
5-46         6    10/16/86  1140.2  rmdb_relmgr_entries.incl.pl1      >special_ldd>install>MR12.0-1187>rmdb_relmgr_entries.incl.pl1
217          7    10/14/83  1609.1  dm_rel_creation_info.incl.pl1     >ldd>include>dm_rel_creation_info.incl.pl1
219          8    10/14/83  1609.1  dm_id_list.incl.pl1               >ldd>include>dm_id_list.incl.pl1
221          9    10/14/83  1609.1  dm_relation_index_flags.incl.pl1  >ldd>include>dm_relation_index_flags.incl.pl1
286         10    02/05/86  1416.4  mrds_start_transaction.incl.pl1   >ldd>include>mrds_start_transaction.incl.pl1
10-79       11    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
10-81       12    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
343         13    02/05/86  1416.4  mrds_finish_transaction.incl.pl1  >ldd>include>mrds_finish_transaction.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ID_LIST_VERSION_1                      constant        fixed bin(17,0)          initial dcl 8-23 ref 275
REL_CREATION_INFO_VERSION_2     002162 automatic       fixed bin(35,0)          initial dcl 7-11 set ref 7-11*
RMDB_ADD_IDX_OP                 000026 constant        fixed bin(17,0)          initial dcl 4-52 set ref 609*
RMDB_DEL_IDX_OP                 000025 constant        fixed bin(17,0)          initial dcl 4-53 set ref 407*
RMDB_REL_TYPE                   000026 constant        fixed bin(17,0)          initial dcl 4-47 set ref 407* 609*
TM_NORMAL_MODE                  000021 constant        fixed bin(17,0)          initial dcl 11-15 set ref 10-99*
addr                                                   builtin function         dcl 170 ref 280 10-123 10-123
ai_ptr                          002156 automatic       pointer                  dcl 2-209 set ref 271* 337
any_other                       002134 stack reference condition                dcl 186 ref 266
attr_info                              based           structure                level 1 dcl 2-192
attr_ptr                 24(18)        based           bit(18)                  level 2 packed unaligned dcl 2-126 ref 530
ceil                                                   builtin function         dcl 171 ref 489
cleanup                         002142 stack reference condition                dcl 187 ref 264 323
close                   166            based           entry variable           level 3 dcl 5-25 ref 412 667
condition_info                         based           structure                level 1 dcl 12-14
condition_name            3     002202 automatic       varying char(32)         level 2 dcl 10-77 set ref 10-124 10-129 10-129
continue_to_signal_             000026 constant        entry                    external dcl 10-61 ref 10-137
create_index            172            based           entry variable           level 3 dcl 5-25 ref 337
cu_code                         000100 automatic       fixed bin(35,0)          dcl 655 set ref 667* 671 673 681
cu_leave_db_inconsistent               parameter       bit(1)                   unaligned dcl 648 ref 621 660
cu_set_code                            parameter       bit(1)                   unaligned dcl 646 ref 621 669
db_desc                  11            based           bit(36)                  level 2 dcl 1-125 ref 553
db_model                               based           structure                level 1 dcl 1-72
db_type_flags             0(18)        based           structure                level 2 packed unaligned dcl 1-72
defn_order               12            based           fixed bin(17,0)          level 2 packed unaligned dcl 2-192 ref 276 551
dm_error_$bj_journal_full       000046 external static fixed bin(35,0)          dcl 13-52 ref 10-132
dm_error_$lock_deadlock         000050 external static fixed bin(35,0)          dcl 13-53 ref 13-78 10-126
dm_error_$no_current_transaction
                                000030 external static fixed bin(35,0)          dcl 10-62 ref 241 10-90
domain_info                            based           structure                level 1 dcl 1-125
domain_ptr               17            based           bit(18)                  level 2 packed unaligned dcl 2-192 ref 552
empty                                                  builtin function         dcl 172 ref 165
error_table_$action_not_performed
                                000024 external static fixed bin(35,0)          dcl 202 ref 243 480 538 545 556 568
fi_ptr                   22(27)        based           bit(18)                  level 2 packed unaligned dcl 2-40 ref 474
file_id                  10            based           bit(36)                  level 2 dcl 1-113 ref 474
file_info                              based           structure                level 1 dcl 1-113
file_model                             based           structure                level 1 dcl 2-40
find_condition_info_            000032 constant        entry                    external dcl 10-64 ref 10-123
fwd_thread               20            based           bit(18)                  level 2 packed unaligned dcl 2-192 ref 564
gad_attr_defn_order                    parameter       fixed bin(17,0)          dcl 522 set ref 496 551*
gad_attr_desc                          parameter       bit(36)                  unaligned dcl 520 set ref 496 553* 554*
gad_attr_name                          parameter       char                     unaligned dcl 518 set ref 496 533 539* 546* 557*
                                                                                  569*
gad_attr_ptr                           parameter       pointer                  dcl 519 set ref 496 530* 533 536 543 543 551 552
                                                                                  564* 564
gad_db_model_ptr                       parameter       pointer                  dcl 514 ref 496 552
gad_domain_ptr                  002472 automatic       pointer                  dcl 526 set ref 552* 553
gad_file_model_ptr                     parameter       pointer                  dcl 515 ref 496 530 564
gad_found                       002474 automatic       bit(1)                   unaligned dcl 527 set ref 531* 532 535* 566
gad_i                           002475 automatic       fixed bin(17,0)          dcl 528 set ref 532*
gad_rel_name                           parameter       char                     unaligned dcl 517 set ref 496 539* 546* 569*
gad_rel_ptr                            parameter       pointer                  dcl 516 ref 496 530 532
grd_db_model_ptr                       parameter       pointer                  dcl 461 ref 450 474
grd_file_id                            parameter       bit(36)                  unaligned dcl 464 set ref 450 474*
grd_file_model_ptr                     parameter       pointer                  dcl 462 ref 450 474 476 476
grd_max_data_length                    parameter       fixed bin(17,0)          dcl 469 set ref 450 489*
grd_number_of_attrs                    parameter       fixed bin(17,0)          dcl 467 set ref 450 487*
grd_number_of_varying_attrs            parameter       fixed bin(17,0)          dcl 468 set ref 450 488*
grd_rel_id                             parameter       bit(36)                  unaligned dcl 466 set ref 450 486*
grd_rel_name                           parameter       char                     unaligned dcl 463 set ref 450 478 481*
grd_rel_ptr                            parameter       pointer                  dcl 465 set ref 450 476* 478 481 486 487 488 489
hcs_$initiate                   000010 constant        entry                    external dcl 192 ref 437
id                        2            based           fixed bin(17,0)          array level 2 in structure "id_list" dcl 8-16
                                                                                  in procedure "rmdb_create_index" set ref 276*
id                       10            based           bit(36)                  level 2 in structure "rel_info" dcl 2-126
                                                                                  in procedure "rmdb_create_index" ref 486
id_list                                based           structure                level 1 dcl 8-16 set ref 273
id_list_ptr                     002164 automatic       pointer                  initial dcl 8-21 set ref 273* 274 275 276 337* 8-21*
il_number_of_ids                002166 automatic       fixed bin(17,0)          initial dcl 8-22 set ref 272* 273 273 8-22*
im_db_abs_path                         parameter       char(168)                unaligned dcl 431 set ref 421 437*
im_file_model_ptr                      parameter       pointer                  dcl 433 set ref 421 437* 438
im_rel_name                            parameter       char                     unaligned dcl 432 set ref 421 437 440*
index_attr               10(01)        based           bit(1)                   level 2 packed unaligned dcl 2-192 set ref 405* 536
                                                                                  606*
index_id                 11            based           bit(36)                  level 2 dcl 2-192 set ref 337* 607*
index_is_clustering       0(01)        based           bit(1)                   level 2 packed unaligned dcl 9-16 set ref 282*
index_is_unique           0(02)        based           bit(1)                   level 2 packed unaligned dcl 9-16 set ref 283*
indexed                  11(04)        based           bit(1)                   level 2 packed unaligned dcl 2-126 set ref 402* 600
                                                                                  601*
ioa_$rs                         000012 constant        entry                    external dcl 194 ref 440 481 539 546 557 569
key_attr                 10            based           bit(1)                   level 2 packed unaligned dcl 2-192 ref 543
key_order                12(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-192 ref 543
length                                                 builtin function         dcl 174 ref 440 440 481 481 539 539 546 546 557 557
                                                                                  569 569
max_attr_index_id        13(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-126 set ref 403* 603
                                                                                  604*
max_data_len             17            based           fixed bin(35,0)          level 2 dcl 2-126 ref 489
mdbm_util_$inconsistent_reset   000020 constant        entry                    external dcl 197 ref 368
mdbm_util_$inconsistent_set     000016 constant        entry                    external dcl 196 ref 312
mdbm_util_$mu_data_length       000014 constant        entry                    external dcl 195 ref 554
mftxn_code                      002234 automatic       fixed bin(35,0)          dcl 13-54 set ref 341* 13-62* 13-65 13-68* 13-69
                                                                                  13-78 13-115 10-126* 10-132*
mftxn_temp_code                 002235 automatic       fixed bin(35,0)          dcl 13-55 set ref 13-71* 13-72 13-72* 13-82* 13-83
                                                                                  13-85* 13-86 13-86* 13-96* 13-97 13-99* 13-100
                                                                                  13-100* 13-109* 13-110 13-110*
mstxn_code                      002172 automatic       fixed bin(35,0)          dcl 10-65 set ref 240* 241 10-83* 10-89* 10-90
                                                                                  10-99* 10-140 13-90* 13-104* 10-137*
mstxn_condition_info            002202 automatic       structure                level 1 unaligned dcl 10-77 set ref 10-123 10-123
mstxn_retries                   002173 automatic       fixed bin(17,0)          dcl 10-66 set ref 10-88* 13-78 13-81* 13-81
mstxn_temp_code                 002174 automatic       fixed bin(35,0)          dcl 10-67 set ref 10-109* 10-110 10-110* 10-123*
mstxn_transactions_needed       002175 automatic       bit(1)                   dcl 10-68 set ref 231* 239* 10-86
mstxn_txn_id                    002177 automatic       bit(36)                  dcl 10-70 set ref 232* 240* 10-84* 10-89* 10-93
                                                                                  10-94* 10-99* 10-100 13-60 13-68* 13-71* 13-72*
                                                                                  13-82* 13-85* 13-86* 13-96* 13-99* 13-100* 13-109*
                                                                                  13-110* 13-114* 10-107 10-109* 10-110* 10-121
name                                   based           char(32)                 level 2 in structure "attr_info" dcl 2-192
                                                                                  in procedure "rmdb_create_index" ref 407 533 609
name                                   based           char(32)                 level 2 in structure "rel_info" dcl 2-126
                                                                                  in procedure "rmdb_create_index" set ref 407 478
                                                                                  481* 609
null                                                   builtin function         dcl 175 ref 8-21 9-24 10-123 10-123 438
num_attr                 12            based           fixed bin(17,0)          level 2 packed unaligned dcl 2-126 ref 487 532
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 8-16 set ref 273* 274*
nvar_atts                14(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-126 ref 488
open                    162            based           entry variable           level 3 dcl 5-25 ref 328
pad                       0(03)        based           bit(33)                  level 2 packed unaligned dcl 9-16 set ref 284*
pointer                                                builtin function         dcl 176 ref 474 476 530 552 564
quit                            002150 stack reference condition                dcl 188 ref 310 316 320 367 369 373 381 383
rci_attr_defn_order             000100 automatic       fixed bin(17,0)          dcl 144 set ref 260*
rci_attr_desc                   000101 automatic       bit(36)                  unaligned dcl 145 set ref 260*
rci_attr_name                          parameter       char                     unaligned dcl 138 set ref 16 260* 312 312
rci_attr_ptr                    000102 automatic       pointer                  dcl 146 set ref 260* 271 276 315* 405 407
rci_backout_occured             000104 automatic       bit(1)                   unaligned dcl 147 set ref 230* 294* 352 416*
rci_based_char8                        based           char(8)                  unaligned dcl 182 set ref 311*
rci_caller_name                 000105 automatic       char(17)                 unaligned dcl 148 set ref 270*
rci_code                               parameter       fixed bin(35,0)          dcl 140 set ref 16 243* 328* 330 337* 341 352 437*
                                                                                  444* 480* 538* 545* 556* 568* 609* 611 673* 674
rci_db_abs_path                        parameter       char(168)                unaligned dcl 135 set ref 16 255* 328*
rci_db_model_ptr                       parameter       pointer                  dcl 136 set ref 16 237 257* 260* 312* 315* 368* 407*
rci_error_message                      parameter       char(500)                unaligned dcl 139 set ref 16 244* 290* 332* 347*
                                                                                  354* 410* 410 440* 440 440 481* 481 481 539* 539
                                                                                  539 546* 546 546 557* 557 557 569* 569 569 609*
                                                                                  660* 660 674* 676* 676 681* 681
rci_file_id                     000112 automatic       bit(36)                  unaligned dcl 149 set ref 257*
rci_file_model_ptr              000114 automatic       pointer                  dcl 150 set ref 255* 257* 260*
rci_flag_list                   000116 automatic       bit(36)                  dcl 151 set ref 280 337*
rci_max_data_length             000117 automatic       fixed bin(17,0)          dcl 152 set ref 257*
rci_number_of_attrs             000120 automatic       fixed bin(17,0)          dcl 154 set ref 257*
rci_number_of_varying_attrs     000121 automatic       fixed bin(17,0)          dcl 155 set ref 257*
rci_original_rel_info_indexed   000122 automatic       bit(1)                   unaligned dcl 156 set ref 402 600*
rci_original_rel_info_max_attr_index_id
                                000123 automatic       fixed bin(17,0)          dcl 157 set ref 403 603*
rci_quit_signaled               000124 automatic       bit(1)                   unaligned dcl 158 set ref 227* 310* 317 319* 367*
                                                                                  370 372* 378 382*
rci_rel_id                      000125 automatic       bit(36)                  unaligned dcl 160 set ref 257*
rci_rel_name                           parameter       char                     unaligned dcl 137 set ref 16 255* 257* 260* 312 312
                                                                                  328*
rci_rel_opening_id              000126 automatic       bit(36)                  dcl 161 set ref 229* 328* 337* 412 412* 414* 667
                                                                                  667*
rci_rel_ptr                     000130 automatic       pointer                  dcl 162 set ref 257* 260* 315* 402 403 407
rci_rmdb_ctl_ptr                       parameter       pointer                  dcl 163 ref 16 228
rci_style                       000132 automatic       fixed bin(17,0)          initial dcl 164 set ref 164* 279* 337*
rel_info                               based           structure                level 1 dcl 2-126
rel_ptr                  20(27)        based           bit(18)                  level 2 packed unaligned dcl 2-40 ref 476
relation_index_flags                   based           structure                level 1 dcl 9-16
relation_index_flags_ptr        002170 automatic       pointer                  initial dcl 9-24 set ref 280* 281 282 283 284 9-24*
relation_must_be_empty                 based           bit(1)                   level 2 packed unaligned dcl 9-16 set ref 281*
relmgr_entries          152            based           structure                level 2 unaligned dcl 5-25
rmdb_add_rmdb_history           000022 constant        entry                    external dcl 198 ref 407 609
rmdb_ctl                               based           structure                level 1 unaligned dcl 5-25
rmdb_ctl_ptr                    002160 automatic       pointer                  dcl 5-43 set ref 228* 311 328 337 412 667
rmdb_relmgr_entries                    based           structure                level 1 unaligned dcl 6-18
rsd_code                        002252 automatic       fixed bin(35,0)          dcl 398 set ref 407* 412*
rsd_error_message               002253 automatic       char(500)                unaligned dcl 399 set ref 407*
rtrim                                                  builtin function         dcl 178 ref 312 312 312 312 410 437 660 676 681
saved_res_version_ptr
                        136            based           pointer                  level 2 dcl 5-25 ref 311
transaction_manager_$abandon_txn
                                000034 constant        entry                    external dcl 10-72 ref 13-72 13-86 13-100 13-110
                                                                                  10-110
transaction_manager_$abort_txn  000036 constant        entry                    external dcl 10-73 ref 13-71 13-85 13-99 13-109
                                                                                  10-109
transaction_manager_$begin_txn  000040 constant        entry                    external dcl 10-74 ref 10-99
transaction_manager_$commit_txn 000052 constant        entry                    external dcl 13-56 ref 13-68
transaction_manager_$get_current_txn_id
                                000042 constant        entry                    external dcl 10-75 ref 240 10-89
transaction_manager_$handle_conditions
                                000044 constant        entry                    external dcl 10-76 ref 10-135
transaction_manager_$rollback_txn
                                000054 constant        entry                    external dcl 13-57 ref 13-82 13-96
transactions_needed       0(34)        based           bit(1)                   level 3 packed unaligned dcl 1-72 ref 237
um_attr_ptr                            parameter       pointer                  dcl 598 ref 578 606 607 609
um_db_model_ptr                        parameter       pointer                  dcl 596 set ref 578 609*
um_rel_ptr                             parameter       pointer                  dcl 597 ref 578 600 601 603 604 609
user_started_transaction        002176 automatic       bit(1)                   dcl 10-69 set ref 10-92* 10-98* 13-60
user_transaction_id             002200 automatic       bit(36)                  dcl 10-71 set ref 10-93* 10-100*
version                                based           fixed bin(35,0)          level 2 dcl 8-16 set ref 275*
wa                              000134 automatic       area(1024)               dcl 165 set ref 165* 273

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 11-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 11-12
RMDB_ADD_ATTR_OP                       internal static fixed bin(17,0)          initial dcl 4-54
RMDB_ADD_DMN_OP                        internal static fixed bin(17,0)          initial dcl 4-56
RMDB_ADD_REL_OP                        internal static fixed bin(17,0)          initial dcl 4-50
RMDB_ATTR_TYPE                         internal static fixed bin(17,0)          initial dcl 4-46
RMDB_CTL_VERSION_1                     internal static fixed bin(17,0)          initial dcl 5-41
RMDB_DEL_ATTR_OP                       internal static fixed bin(17,0)          initial dcl 4-55
RMDB_DEL_DMN_OP                        internal static fixed bin(17,0)          initial dcl 4-57
RMDB_DEL_REL_OP                        internal static fixed bin(17,0)          initial dcl 4-51
RMDB_DOMAIN_TYPE                       internal static fixed bin(17,0)          initial dcl 4-45
RMDB_RN_ATTR_OP                        internal static fixed bin(17,0)          initial dcl 4-58
RMDB_RN_DMN_OP                         internal static fixed bin(17,0)          initial dcl 4-59
RMDB_RN_REL_OP                         internal static fixed bin(17,0)          initial dcl 4-60
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 11-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 11-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 11-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 11-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 11-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 11-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 11-20
al_ptr                                 automatic       pointer                  dcl 2-345
alloc_length                           internal static fixed bin(35,0)          dcl 1-222
atd                                    based           char                     unaligned dcl 2-109
atd_len                                automatic       fixed bin(17,0)          dcl 2-111
atd_ptr                                automatic       pointer                  dcl 2-110
attr_list                              based           structure                level 1 dcl 2-341
changer                                based           structure                level 1 packed unaligned dcl 1-251
changer_ptr                            automatic       pointer                  dcl 1-256
child_link_info                        based           structure                level 1 dcl 2-283
cli_ptr                                automatic       pointer                  dcl 2-329
cna_ptr                                automatic       pointer                  dcl 2-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 2-112
condition_info_ptr                     automatic       pointer                  dcl 12-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 12-30
constant                               based           structure                level 1 unaligned dcl 1-216
constant_ptr                           automatic       pointer                  dcl 1-220
dbm_ptr                                automatic       pointer                  dcl 1-106
di_ptr                                 automatic       pointer                  dcl 1-155
dp_ptr                                 automatic       pointer                  dcl 2-356
dup_prev                               based           structure                level 1 dcl 2-353
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 10-63
fi_ptr                                 automatic       pointer                  dcl 1-119
fixed                                                  builtin function         dcl 173
fm_ptr                                 automatic       pointer                  dcl 2-108
ind_ptr                                automatic       pointer                  dcl 3-9
ind_val_len                            automatic       fixed bin(35,0)          dcl 3-10
index                                  based           structure                level 1 dcl 3-3
message_str                            based           structure                level 1 packed unaligned dcl 1-259
message_str_len                        automatic       fixed bin(17,0)          dcl 1-269
message_str_ptr                        automatic       pointer                  dcl 1-267
ncomp_init                             automatic       fixed bin(17,0)          dcl 2-116
parent_link_info                       based           structure                level 1 dcl 2-223
path_entry                             based           structure                level 1 packed unaligned dcl 1-172
path_entry_ptr                         automatic       pointer                  dcl 1-177
pli_ptr                                automatic       pointer                  dcl 2-268
rel                                                    builtin function         dcl 177
rel_creation_info                      based           structure                level 1 dcl 7-4
rel_creation_info_ptr                  automatic       pointer                  dcl 7-10
ri_ptr                                 automatic       pointer                  dcl 2-185
rmdb_history_entry                     based           structure                level 1 dcl 4-31
rmdb_history_entry_ptr                 automatic       pointer                  dcl 4-42
rmdb_relmgr_entries_ptr                automatic       pointer                  dcl 6-32
sc_ptr                                 automatic       pointer                  dcl 2-365
select_chain                           based           structure                level 1 dcl 2-357
sk_ptr                                 automatic       pointer                  dcl 2-352
sort_key                               based           structure                level 1 dcl 2-346
stack_item                             based           structure                level 1 unaligned dcl 1-206
stack_item_ptr                         automatic       pointer                  dcl 1-212
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 203
ua_ptr                                 automatic       pointer                  dcl 1-165
unreferenced_attribute                 based           structure                level 1 dcl 1-159
version_status                         based           structure                level 1 packed unaligned dcl 1-232
version_status_ptr                     automatic       pointer                  dcl 1-246

NAMES DECLARED BY EXPLICIT CONTEXT.
clean_up                        003355 constant        entry                    internal dcl 621 ref 325 348 355 376 613
exit_rmdb_create_index          002106 constant        label                    dcl 378 ref 246 291 349 356 442 483 541 549 561 571
                                                                                  614
get_attribute_data              002703 constant        entry                    internal dcl 496 ref 260
get_relation_data               002551 constant        entry                    internal dcl 450 ref 257
initiate_models                 002376 constant        entry                    internal dcl 421 ref 255
mftxn_check_code                001541 constant        label                    dcl 13-65 ref 10-127 10-133
mftxn_exit                      001761 constant        label                    dcl 13-115 ref 334 13-63
mstxn_any_other                 002154 constant        entry                    internal dcl 10-116 ref 266
mstxn_cleanup                   002117 constant        entry                    internal dcl 10-102 ref 264 324
mstxn_exit                      001114 constant        label                    dcl 10-140 ref 10-86 10-95 13-91 13-105
restore_significant_data        002260 constant        entry                    internal dcl 396 ref 333 13-77
rmdb_create_index               000506 constant        entry                    external dcl 16
should_rollback                 002251 constant        entry                    internal dcl 387 ref 13-94
update_model                    003254 constant        entry                    internal dcl 578 ref 315

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4136        4214    3600        4146
Length      4764    3600        56         534     335           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rmdb_create_index                  1712 external procedure  is an external procedure.  
on unit on line 264                  64 on unit               
on unit on line 266                  82 on unit               
mstxn_cleanup                        70 internal procedure  is called by several nonquick procedures.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 266.  
on unit on line 310                  64 on unit               
on unit on line 323                  74 on unit               
on unit on line 367                  64 on unit               
should_rollback                         internal procedure  shares stack frame of external procedure rmdb_create_index.  
restore_significant_data                internal procedure  shares stack frame of external procedure rmdb_create_index.  
initiate_models                         internal procedure  shares stack frame of external procedure rmdb_create_index.  
get_relation_data                       internal procedure  shares stack frame of external procedure rmdb_create_index.  
get_attribute_data                      internal procedure  shares stack frame of external procedure rmdb_create_index.  
update_model                            internal procedure  shares stack frame of external procedure rmdb_create_index.  
clean_up                             76 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
clean_up                 000100 cu_code                     clean_up
rmdb_create_index        000100 rci_attr_defn_order         rmdb_create_index
                         000101 rci_attr_desc               rmdb_create_index
                         000102 rci_attr_ptr                rmdb_create_index
                         000104 rci_backout_occured         rmdb_create_index
                         000105 rci_caller_name             rmdb_create_index
                         000112 rci_file_id                 rmdb_create_index
                         000114 rci_file_model_ptr          rmdb_create_index
                         000116 rci_flag_list               rmdb_create_index
                         000117 rci_max_data_length         rmdb_create_index
                         000120 rci_number_of_attrs         rmdb_create_index
                         000121 rci_number_of_varying_attrs rmdb_create_index
                         000122 rci_original_rel_info_indexed
                                                            rmdb_create_index
                         000123 rci_original_rel_info_max_attr_index_id
                                                            rmdb_create_index
                         000124 rci_quit_signaled           rmdb_create_index
                         000125 rci_rel_id                  rmdb_create_index
                         000126 rci_rel_opening_id          rmdb_create_index
                         000130 rci_rel_ptr                 rmdb_create_index
                         000132 rci_style                   rmdb_create_index
                         000134 wa                          rmdb_create_index
                         002156 ai_ptr                      rmdb_create_index
                         002160 rmdb_ctl_ptr                rmdb_create_index
                         002162 REL_CREATION_INFO_VERSION_2 rmdb_create_index
                         002164 id_list_ptr                 rmdb_create_index
                         002166 il_number_of_ids            rmdb_create_index
                         002170 relation_index_flags_ptr    rmdb_create_index
                         002172 mstxn_code                  rmdb_create_index
                         002173 mstxn_retries               rmdb_create_index
                         002174 mstxn_temp_code             rmdb_create_index
                         002175 mstxn_transactions_needed   rmdb_create_index
                         002176 user_started_transaction    rmdb_create_index
                         002177 mstxn_txn_id                rmdb_create_index
                         002200 user_transaction_id         rmdb_create_index
                         002202 mstxn_condition_info        rmdb_create_index
                         002234 mftxn_code                  rmdb_create_index
                         002235 mftxn_temp_code             rmdb_create_index
                         002252 rsd_code                    restore_significant_data
                         002253 rsd_error_message           restore_significant_data
                         002472 gad_domain_ptr              get_attribute_data
                         002474 gad_found                   get_attribute_data
                         002475 gad_i                       get_attribute_data

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ent_var        call_ext_out_desc   call_ext_out
call_int_this       call_int_other      return_mac          tra_ext_1           signal_op           enable_op
shorten_stack       ext_entry_desc      int_entry           ceil_fx2            divide_fx1          op_alloc_
op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           find_condition_info_          hcs_$initiate                 ioa_$rs
mdbm_util_$inconsistent_reset mdbm_util_$inconsistent_set   mdbm_util_$mu_data_length     rmdb_add_rmdb_history
transaction_manager_$abandon_txn                            transaction_manager_$abort_txn
transaction_manager_$begin_txn                              transaction_manager_$commit_txn
transaction_manager_$get_current_txn_id                     transaction_manager_$handle_conditions
transaction_manager_$rollback_txn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$lock_deadlock       dm_error_$no_current_transaction
error_table_$action_not_performed




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     16 000500       164 000526       165 000530    7   11 000533    8   21 000535    8   22 000537    9   24 000541
    227 000543       228 000544       229 000550       230 000551       231 000552       232 000553       237 000554
    239 000560       240 000562       241 000573       243 000577       244 000602       246 000606       255 000607
    257 000631       260 000676       264 000741       266 000763       270 001001       271 001004       272 001006
    273 001010       274 001020       275 001022       276 001024       279 001030       280 001032       281 001034
    282 001036       283 001040       284 001042   10   83 001044   10   84 001045   10   86 001046   10   88 001050
10   89 001051   10   90 001062   10   92 001066   10   93 001070   10   94 001072   10   95 001073   10   98 001074
10   99 001075   10  100 001112   10  140 001114       290 001116       291 001123       294 001124       310 001125
    311 001145       312 001152       315 001363       316 001377       317 001400       319 001402       320 001403
    323 001406       324 001422       325 001427       326 001444       328 001445       330 001474       332 001477
    333 001503       334 001504       337 001505       341 001527   13   60 001532   13   62 001537   13   63 001540
13   65 001541   13   68 001543   13   69 001554   13   71 001556   13   72 001567   13   75 001602   13   77 001603
13   78 001604   13   81 001613   13   82 001614   13   83 001627   13   85 001631   13   86 001642   13   88 001655
13   90 001656   13   91 001657   13   93 001660   13   94 001661   13   96 001666   13   97 001702   13   99 001704
13  100 001715   13  102 001730   13  104 001731   13  105 001732   13  107 001733   13  109 001734   13  110 001745
13  114 001760   13  115 001761       347 001763       348 001770       349 002004       352 002005       354 002012
    355 002016       356 002032       367 002033       368 002053       369 002063       370 002064       372 002066
    373 002067       376 002072       378 002106       381 002110       382 002111       383 002112       385 002115
10  102 002116   10  107 002124   10  109 002127   10  110 002137   10  114 002153   10  116 002154   10  121 002155
10  123 002160   10  124 002177   10  126 002205   10  127 002210   10  129 002213   10  132 002225   10  133 002230
10  135 002233   10  136 002240   10  137 002241   10  138 002250       387 002251       388 002253       396 002260
    402 002261       403 002267       405 002271       407 002274       410 002326       412 002356       414 002372
    416 002373       418 002375       421 002376       437 002407       438 002503       440 002511       442 002545
    444 002546       446 002550       450 002551       474 002562       476 002600       478 002606       480 002614
    481 002620       483 002656       486 002657       487 002663       488 002666       489 002672       492 002702
    496 002703       530 002721       531 002732       532 002733       533 002747       535 002760       536 002762
    538 002765       539 002771       541 003027       543 003030       545 003040       546 003044       549 003102
    551 003103       552 003106       553 003114       554 003120       556 003134       557 003140       561 003173
    563 003174       564 003175       565 003203       566 003205       568 003207       569 003213       571 003252
    574 003253       578 003254       600 003256       601 003264       603 003266       604 003272       606 003274
    607 003300       609 003301       611 003333       613 003336       614 003352       617 003353       621 003354
    660 003362       667 003442       669 003457       671 003465       673 003467       674 003472       676 003500
    678 003527       679 003530       681 003531       684 003564       686 003565


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
