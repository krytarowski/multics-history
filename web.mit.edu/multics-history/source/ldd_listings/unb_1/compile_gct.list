	COMPILATION LISTING OF SEGMENT compile_gct
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/18/82  1633.6 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 compile_gct: proc;
       12 
       13 /* This routine will compile a graphic character table. */
       14 /* Hacked out of compile_gdt on 01/19/78 by C. D. Tavares */
       15 
       16 dcl  cu_$arg_ptr ext entry (fixed bin, pointer, fixed bin, fixed bin (35)),
       17      cu_$arg_count ext entry returns (fixed bin (35)),
       18      ap pointer,
       19      al fixed bin,
       20      arg based (ap) char (al),
       21      com_err_ ext entry options (variable),
       22      code fixed bin (35);
       23 
       24 dcl  error_table_$translation_failed ext fixed bin (35),
       25      error_table_$inconsistent ext fixed bin (35),
       26      error_table_$badopt ext fixed bin (35);
       27 
       28 dcl  expand_pathname_$add_suffix ext entry (char (*), char (*), char (*), char (*), fixed bin (35)),
       29      suffixed_name_$new_suffix ext entry (char (*), char (*), char (*), char (*), fixed bin (35)),
       30      get_wdir_ ext entry returns (char (168)),
       31      dirname char (168),
       32      ename char (33) initial (""),
       33      object_ename char (32);
       34 
       35 dcl  tssi_$get_segment entry (char (*), char (*), pointer, pointer, fixed bin (35)),
       36      tssi_$finish_segment ext entry (pointer, fixed bin, bit (36) aligned, pointer, fixed bin (35)),
       37      tssi_$clean_up_segment ext entry (pointer),
       38      cleanup condition;
       39 
       40 dcl  parse_file_$parse_file_init_name ext entry (char (*), char (*), pointer, fixed bin (35)),
       41      parse_file_$parse_file_cur_line ext entry (fixed bin, fixed bin),
       42      parse_file_$parse_file_unset_break ext entry (char (*));
       43 
       44 dcl  acl_ptr pointer initial (null),
       45     (null, hbound, substr, length, before, collate, divide, max, index) builtin;
       46 
       47 dcl  outdx fixed bin,
       48      segp pointer,
       49     (i, j, k) fixed bin,
       50      char_number fixed bin,
       51      char_name char (8) varying,
       52      found bit (1) aligned,
       53      vec_sw bit (1) aligned,
       54      metric_char char (1),
       55      metric_dimensions (3) fixed bin,
       56      margin (2) fixed bin,
       57      coords (2) fixed bin;
       58 
  1     1 dcl  gct_charnames (128) char (8) varying static options (constant) initial
  1     2     ("nul",      "soh",      "stx",      "etx",      "eot",      "enq",      "ack",      "bel",
  1     3      "bs",       "ht",       "nl",       "vt",       "ff",       "cr",       "rrs",      "brs",
  1     4      "dle",      "dc1",      "dc2",      "dc3",      "dc4",      "nak",      "syn",      "etb",
  1     5      "can",      "em",       "sub",      "esc",      "fs",       "gs",       "rs",       "us",
  1     6      "space",    "excl_pt",  "dbl_quot", "sharp",    "dollar",   "percent",  "amprsnd",  "r_quote",
  1     7      "l_paren",  "r_paren",  "star",     "plus",     "comma",    "minus",    "dot",      "slash",
  1     8      "zero",     "one",      "two",      "three",    "four",     "five",     "six",      "seven",
  1     9      "eight",    "nine",     "colon",    "semi",     "lessthan", "equal",    "grthan",   "ques_mrk",
  1    10      "atsign",   "A",        "B",        "C",        "D",        "E",        "F",        "G",
  1    11      "H",        "I",        "J",        "K",        "L",        "M",        "N",        "O",
  1    12      "P",        "Q",        "R",        "S",        "T",        "U",        "V",        "W",
  1    13      "X",        "Y",        "Z",        "l_brack",  "backslsh", "r_brack",  "cirflex",  "underbar",
  1    14      "l_quote",  "a",        "b",        "c",        "d",        "e",        "f",        "g",
  1    15      "h",        "i",        "j",        "k",        "l",        "m",        "n",        "o",
  1    16      "p",        "q",        "r",        "s",        "t",        "u",        "v",        "w",
  1    17      "x",        "y",        "z",        "l_brace",  "vert_bar", "r_brace",  "tilde",    "del");
       59 
       60 
       61 dcl (cur_x, cur_y) fixed bin;
       62 
       63 dcl 1 invis_struc aligned,
       64     2 (min_x, max_x, min_y, max_y) fixed bin;
       65 
       66 dcl 1 vis_struc like invis_struc aligned;
       67 
       68 dcl (character_name, character_type, main_proc) char (32) aligned varying initial (""),
       69      token char (32) aligned varying,
       70      explanation char (80) varying aligned initial (""),
       71      default_flags char (168) aligned varying initial (""),
       72      temp_string char (400) varying;
       73 
       74 dcl  title_string char (100) aligned varying initial
       75     (""" Created by:  compile_gct, Version of 17 February 1978.
       76 ") static options (constant),
       77 
       78      header_string char (200) aligned varying initial
       79     ("	name	^a^/
       80 	segdef	char_ptr
       81 	segdef	character_sizes^/
       82 	use	char_structures^/
       83 character_sizes:
       84 ^3(	dec	^d
       85 ^)") static options (constant),
       86 
       87      finishing_string char (40) static options (constant) varying initial ("
       88 	include	gct_trap_proc
       89 
       90 	end
       91 ");
       92 
       93 
       94 dcl (SPACE initial (" "),
       95      TAB initial ("	"),
       96      UNDERSCORE initial ("_"),
       97      COLON initial (":"),
       98      CR initial (""),
       99      BS initial (""),
      100      NL initial ("
      101 ")) char (1) static options (constant);
      102 
      103 dcl  sys_info$max_seg_size ext fixed bin (35),
      104      max_string_size fixed bin (21) initial (sys_info$max_seg_size * 4);
      105 
      106 dcl 1 based_char_description aligned based (cp),
      107     2 next_p pointer,
      108     2 char_number fixed bin,
      109     2 header aligned,
      110       3 (n_elements,
      111      width,
      112      left_margin,
      113      right_margin) fixed bin (8) unaligned,
      114     2 word_align aligned,
      115       3 move_type bit (nelem refer (based_char_description.n_elements)) unaligned,
      116     2 coord_pairs (nelem refer (based_char_description.n_elements)) unaligned,
      117       3 (x,
      118      y) fixed bin (8) unaligned;
      119 
      120 dcl (cp, tp, last_p, start_p) pointer;
      121 
      122 dcl (gct_charbits, tempbits, desirable_chars) bit (128) aligned,
      123      special_bits bit (128) aligned internal static options (constant) initial
      124     ("000000001110010000000000000000001000000000000000000000000000000000000000000000000000000000000001"b);
      125 
      126 dcl  movetype bit (144) aligned,
      127      nelem fixed bin,
      128     (x, y) fixed bin dimension (144);
      129 
      130 dcl (ioa_$ioa_stream, ioa_$rsnp, ioa_, ioa_$rsnpnnl) ext entry options (variable),
      131      pf_ptr pointer initial (null),
      132      pf_string char (max_string_size) aligned based (pf_ptr);
      133 
      134 dcl  delete_$path ext entry (char (*), char (*), bit (6), char (*), fixed bin (35)),
      135     (list_switch, no_assembly) bit (1) aligned,
      136      alm ext entry options (variable);
      137 
      138 
      139 
      140 	start_p = null;
      141 
      142 	call ioa_ ("COMPILE_GCT");			/* crow */
      143 	call cu_$arg_ptr (1, ap, al, code);		/* get name of input file */
      144 	if code ^= 0 then do;			/* not there */
      145 	     call com_err_ (code, "compile_gct",	/* give advice */
      146 		"Usage is 'compile_gct segname' where segname.gct is a graphic character table.");
      147 returner:
      148 	     call clean_up;				/* close out output file */
      149 	     return;
      150 	end;
      151 
      152 	call expand_pathname_$add_suffix (arg, "gct", dirname, ename, code);
      153 	if code ^= 0 then call error ((arg), ""b);	/* couldn't */
      154 
      155 	list_switch, no_assembly = ""b;
      156 
      157 	do i = 2 to cu_$arg_count ();
      158 	     call cu_$arg_ptr (i, ap, al, code);
      159 	     if substr (arg, 1, 1) ^= "-" then goto badopt;
      160 	     if arg = "-check" | arg = "-ck" then no_assembly = "1"b;
      161 	     else if arg = "-list" | arg = "-ls" then list_switch = "1"b;
      162 	     else do;
      163 badopt:		call com_err_ (error_table_$badopt, "compile_gct", "");
      164 		goto returner;
      165 	     end;
      166 	end;
      167 
      168 	if list_switch & no_assembly then do;
      169 	     call com_err_ (error_table_$inconsistent, "compile_gct", "-check, -list");
      170 	     goto returner;
      171 	end;
      172 
      173 	call suffixed_name_$new_suffix (ename, "gct", "alm", object_ename, code); /* make new name */
      174 	if code ^= 0 then call error ((object_ename), ""b);
      175 
      176 	on cleanup call clean_up;
      177 
      178 	call parse_file_$parse_file_init_name (dirname, ename, pf_ptr, code); /* initiate parsing program */
      179 	if code ^= 0 then call error ((ename), ""b);
      180 
      181 	call tssi_$get_segment (get_wdir_ (), (object_ename), segp, acl_ptr, code); /* create output segment */
      182 	if code ^= 0 then call error ((object_ename), ""b);
      183 
      184 	call parse_file_$parse_file_unset_break ("_-.");	/* we want "_-." to be valid in a token */
      185 
      186 	gct_charbits = special_bits;
      187 
      188 	metric_char = "O";				/* good default */
      189 	metric_dimensions (*) = -1;
      190 
      191 	outdx = 1;				/* output string index */
      192 	call get_token;
      193 
      194 	if token = "metric" then do;
      195 	     call get_token;
      196 	     metric_char = token;
      197 
      198 	     do char_number = 1 to hbound (gct_charnames, 1) while (gct_charnames (char_number) ^= token);
      199 	     end;
      200 
      201 	     if char_number > hbound (gct_charnames, 1) then call error ("Unrecognized character: " || token, "1"b);
      202 
      203 	     call get_token;
      204 	end;
      205 
      206 	do while (token ^= " EOF ");
      207 
      208 	     do char_number = 1 to hbound (gct_charnames, 1) while (gct_charnames (char_number) ^= token);
      209 	     end;
      210 
      211 	     if char_number > hbound (gct_charnames, 1) then call error ("Unrecognized character: " || token, "1"b);
      212 
      213 	     if substr (gct_charbits, char_number, 1) then call error ("Character already defined: " || token, "1"b);
      214 
      215 	     substr (gct_charbits, char_number, 1) = "1"b; /* mark character as defined */
      216 
      217 	     call get_break (COLON, crump);
      218 
      219 	     char_name = token;
      220 	     margin = -1;
      221 	     nelem = 0;
      222 	     movetype = ""b;
      223 
      224 	     call get_token;
      225 
      226 	     cur_x, cur_y, vis_struc, invis_struc = 0;
      227 
      228 	     do i = 1 by 1 while (token ^= "end");
      229 		if token = "shift" then vec_sw = "0"b;
      230 		else if token = "vector" then do;
      231 		     substr (movetype, i, 1) = "1"b;
      232 		     vec_sw = "1"b;
      233 		     call maxmin (vis_struc);
      234 		end;
      235 		else call error ("Neither shift nor vector:  " || token, "1"b);
      236 		coords = getvals ();
      237 		cur_x = cur_x + coords (1);
      238 		cur_y = cur_y + coords (2);
      239 		call maxmin (invis_struc);
      240 		if vec_sw then call maxmin (vis_struc);
      241 		if substr (movetype, 1, i) = "0"b then do; /* shifts so far, nothing visible yet */
      242 		     vis_struc.min_x, vis_struc.max_x = cur_x;
      243 		     vis_struc.min_y, vis_struc.max_y = cur_y;
      244 		end;
      245 		nelem = nelem + 1;
      246 		x (nelem) = coords (1);
      247 		y (nelem) = coords (2);
      248 
      249 		call get_token;
      250 	     end;
      251 
      252 maxmin:	     proc (struc);
      253 
      254 dcl 1 struc like invis_struc aligned parameter;
      255 
      256 		if cur_x < struc.min_x then struc.min_x = cur_x;
      257 		if cur_x > struc.max_x then struc.max_x = cur_x;
      258 		if cur_y < struc.min_y then struc.min_y = cur_y;
      259 		if cur_y > struc.max_y then struc.max_y = cur_y;
      260 		return;
      261 	     end maxmin;
      262 
      263 	     invis_struc.min_x = max (invis_struc.min_x, 0); /* fix boundary conditions for */
      264 	     invis_struc.max_x = min (invis_struc.max_x, cur_x); /* chars with "negative margins" */
      265 
      266 	     if char_name = metric_char then do;
      267 		metric_dimensions (1) = vis_struc.max_y - vis_struc.min_y;
      268 		metric_dimensions (2) = invis_struc.max_x - invis_struc.min_x;
      269 		metric_dimensions (3) = invis_struc.min_x - vis_struc.min_x + vis_struc.max_x - invis_struc.max_x;
      270 						/* this is the negative of the sum of the margins */
      271 	     end;
      272 
      273 	     if cur_x < 0 then call ioa_ ("WARNING: Character ""^a"" has net X offset of ^d.", char_name, cur_x);
      274 	     if cur_y ^= 0 then call ioa_ ("WARNING: Character ""^a"" has net Y offset of ^d.", char_name, cur_y);
      275 
      276 	     allocate based_char_description;
      277 	     based_char_description.char_number = char_number;
      278 	     based_char_description.width = invis_struc.max_x - invis_struc.min_x;
      279 	     based_char_description.left_margin = vis_struc.min_x - invis_struc.min_x;
      280 	     based_char_description.right_margin = invis_struc.max_x - vis_struc.max_x;
      281 	     based_char_description.move_type = movetype;
      282 
      283 	     do i = 1 to nelem;
      284 		based_char_description.x (i) = x (i);
      285 		based_char_description.y (i) = y (i);
      286 	     end;
      287 
      288 	     last_p = null;
      289 	     found = ""b;
      290 
      291 	     do tp = start_p repeat (tp -> based_char_description.next_p)
      292 		     while (tp ^= null & ^found);
      293 		if tp -> based_char_description.char_number < char_number then last_p = tp;
      294 		else found = "1"b;
      295 	     end;
      296 
      297 	     if last_p = null then do;
      298 		cp -> based_char_description.next_p = start_p;
      299 		start_p = cp;
      300 	     end;
      301 	     else do;
      302 		cp -> based_char_description.next_p = last_p -> based_char_description.next_p;
      303 		last_p -> based_char_description.next_p = cp;
      304 	     end;
      305 
      306 
      307 	     call get_token;
      308 	end;
      309 
      310 	if metric_dimensions (1) = -1 then call error ("Metric character not found: " || metric_char, ""b);
      311 
      312 	desirable_chars = ""b;
      313 	substr (desirable_chars, 33, 126 - 33 + 1) = copy ("1"b, 128);
      314 	tempbits = ^gct_charbits & desirable_chars;
      315 	if tempbits then do;
      316 	     temp_string = "";
      317 	     do while (tempbits);
      318 		i = index (tempbits, "1"b);
      319 		if length (temp_string) ^= 0 then temp_string = temp_string || ", ";
      320 		temp_string = temp_string || gct_charnames (i);
      321 		substr (tempbits, i, 1) = "0"b;
      322 	     end;
      323 
      324 	     call ioa_ ("Warning:  Definitions were not found for the following characters:");
      325 	     call ioa_ (temp_string);
      326 	end;
      327 
      328 	call put_out (title_string);
      329 
      330 	call ioa_$rsnpnnl (header_string, temp_string, 0, before (ename, ".gct"), metric_dimensions (*));
      331 	call put_out (temp_string);
      332 
      333 	do cp = start_p repeat (cp -> based_char_description.next_p) while (cp ^= null);
      334 
      335 	     call ioa_$rsnp ("^/^a:", temp_string, 0, gct_charnames (cp -> based_char_description.char_number));
      336 	     call put_out (temp_string);
      337 
      338 	     call ioa_$rsnp ("^-vfd^-9/^d,9/^d,9/^d,9/^d", temp_string, 0,
      339 		cp -> based_char_description.n_elements,
      340 		cp -> based_char_description.width,
      341 		cp -> based_char_description.left_margin,
      342 		cp -> based_char_description.right_margin);
      343 
      344 	     call put_out (temp_string);
      345 
      346 	     do i = 1 to cp -> based_char_description.n_elements by 36;
      347 		call ioa_$rsnp ("^-oct^-^.3b", temp_string, 0, substr (cp -> based_char_description.move_type, i, 36));
      348 		call put_out (temp_string);
      349 	     end;
      350 
      351 	     do i = 1 to cp -> based_char_description.n_elements by 2;
      352 		j = i + 1;
      353 		call ioa_$rsnpnnl ("^-vfd^-9/^d,9/^d", temp_string, 0,
      354 		     cp -> based_char_description.x (i),
      355 		     cp -> based_char_description.y (i));
      356 		if j ^> cp -> based_char_description.n_elements then
      357 		     call ioa_$rsnpnnl ("^a,9/^d,9/^d", temp_string, 0, (temp_string),
      358 		     cp -> based_char_description.x (j),
      359 		     cp -> based_char_description.y (j));
      360 
      361 		k = max (divide (34 - length (temp_string), 10, 17, 0) + 1, 0);
      362 
      363 		call ioa_$rsnpnnl ("^a^v-"" ^[vector^;shift ^] ^3d ^3d", temp_string, 0, (temp_string), k,
      364 		     substr (cp -> based_char_description.move_type, i, 1),
      365 		     cp -> based_char_description.x (i),
      366 		     cp -> based_char_description.y (i));
      367 		if j ^> cp -> based_char_description.n_elements then
      368 		     call ioa_$rsnpnnl ("^a, ^[vector^;shift ^] ^3d ^3d", temp_string, 0, (temp_string),
      369 		     substr (cp -> based_char_description.move_type, j, 1),
      370 		     cp -> based_char_description.x (j),
      371 		     cp -> based_char_description.y (j));
      372 
      373 		temp_string = temp_string || NL;
      374 		call put_out (temp_string);
      375 	     end;
      376 
      377 	     call put_out ((NL));
      378 	end;
      379 
      380 	do j = 0 to -1 by -1;
      381 	     if j = 0 then tempbits = ^gct_charbits;
      382 	     else tempbits = special_bits;
      383 
      384 	     if tempbits then do;
      385 		do while (tempbits);
      386 		     i = index (tempbits, "1"b);
      387 		     call ioa_$rsnp ("^a:^-null", temp_string, 0, gct_charnames (i));
      388 		     call put_out (temp_string);
      389 		     substr (tempbits, i, 1) = "0"b;
      390 		end;
      391 
      392 		call ioa_$rsnp ("^-vfd^-9/^d,9/0,9/0,9/0^/", temp_string, 0, j);
      393 		call put_out (temp_string);
      394 	     end;
      395 	end;
      396 
      397 	call put_out (finishing_string);
      398 
      399 	call tssi_$finish_segment (segp, outdx * 9 - 9, "1011"b, acl_ptr, code); /* shine it up */
      400 	acl_ptr = null;
      401 	revert cleanup;
      402 	if code ^= 0 then call error ((ename), ""b);	/* too bad. after all that. */
      403 
      404 	if no_assembly then goto returner;
      405 
      406 	if list_switch then call alm (object_ename, "-list");
      407 	else call alm (object_ename);
      408 
      409 	call delete_$path (get_wdir_ (), object_ename, "100111"b, "compile_gct", code);
      410 	if code ^= 0 then call error ("Cannot delete " || object_ename, ""b);
      411 
      412 	call clean_up;
      413 	return;
      414 
      415 crump:						/* here is where errors go */
      416 	call error (explanation, "1"b);		/* confess */
      417 
      418 
      419 clean_up:	proc;
      420 
      421 	     if acl_ptr ^= null then call tssi_$clean_up_segment (acl_ptr);
      422 
      423 	     do cp = start_p repeat (tp) while (cp ^= null);
      424 		tp = cp -> based_char_description.next_p;
      425 		free cp -> based_char_description;
      426 	     end;
      427 
      428 	end;
      429 
      430 
      431 error:	proc (explanation, print_line);		/* the snitcher */
      432 
      433 dcl  explanation char (*) varying aligned parameter,
      434      print_line bit (1) aligned parameter;
      435 
      436 dcl (ci, cc) fixed bin;
      437 
      438 	     call com_err_ (code, "compile_gct", explanation); /* report the error */
      439 
      440 	     if print_line then do;			/* print out the source line of input file */
      441 		call parse_file_$parse_file_cur_line (ci, cc);
      442 		call ioa_$ioa_stream ("error_output", "^-SOURCE: ^a", substr (pf_string, ci, cc));
      443 	     end;
      444 	     call com_err_ (error_table_$translation_failed, "compile_gct", ""); /* one chance is all we give */
      445 	     goto returner;
      446 	end;
      447 
      448 
      449 get_token: proc;					/* gets tokens from input file */
      450 
      451 dcl  parse_file_$parse_file_ptr ext entry (pointer, fixed bin, fixed bin, fixed bin),
      452      tokenp pointer,
      453      b_token char (count) based (tokenp),
      454      count fixed bin,
      455      break fixed bin,
      456      eof fixed bin;
      457 
      458 loop:
      459 	     call parse_file_$parse_file_ptr (tokenp, count, break, eof); /* get a token */
      460 
      461 	     if eof > 0 then token = " EOF ";
      462 
      463 	     else do;
      464 		token = b_token;
      465 		if break > 0 then if token = SPACE then goto loop; /* harmless */
      466 		     else if token = TAB then goto loop; /* harmless */
      467 		     else if token = NL then goto loop; /* harmless */
      468 		     else call error ("Illegal character " || token || " encountered", "1"b); /* yell */
      469 	     end;
      470 
      471 	     return;
      472 
      473 get_break:     entry (char, errlab);			/* gets break tokens, goes to errlab if fails */
      474 
      475 dcl  char char (1),
      476      errlab label;
      477 
      478 bloop:
      479 	     call parse_file_$parse_file_ptr (tokenp, count, break, eof); /* get a token */
      480 
      481 	     if eof > 0 then call error ("Unexpected end of file encountered", ""b); /* oops */
      482 
      483 	     if break > 0 then if b_token = SPACE then goto bloop; /* harmless */
      484 		else if b_token = TAB then goto bloop;	/* harmless */
      485 		else if b_token = NL then goto bloop;	/* harmless */
      486 		else if b_token = char then return;	/* it's the one we wanted */
      487 		else do;				/* it's not */
      488 bad_break:
      489 		     explanation = "Illegal token " || b_token || " found instead of expected token " || char;
      490 		     goto errlab;			/* we don't call error, because */
      491 						/* it may not be an error condition. */
      492 		end;
      493 
      494 	     else goto bad_break;			/* wasn't a break token */
      495 	     return;
      496 
      497 
      498 	end get_token;
      499 
      500 getvals:	proc returns (fixed bin dimension (2));
      501 
      502 dcl  temp (2) fixed bin,
      503      i fixed bin,
      504      cv_dec_check_ ext entry (char (*), fixed bin (35)) returns (fixed bin);
      505 
      506 	     do i = 1 to 2;
      507 		call get_token;
      508 		temp (i) = cv_dec_check_ ((token), code);
      509 		if code ^= 0 then call error ("Non numeric token in numeric position:  " || token, "1"b);
      510 	     end;
      511 
      512 	     return (temp);
      513 	end getvals;
      514 
      515 put_out:	proc (string);				/* writes string into output file */
      516 
      517 dcl  string char (*) varying;
      518 
      519 dcl  outstring char (65536) based (segp);
      520 
      521 	     substr (outstring, outdx, length (string)) = string; /* copy into output file */
      522 	     outdx = outdx + length (string);
      523 
      524 	     return;
      525 	end;
      526 
      527      end compile_gct;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/18/82  1627.7  compile_gct.pl1                   >dumps>old>recomp>compile_gct.pl1
59           1    03/27/82  0439.2  gct_char_names.incl.pl1           >ldd>include>gct_char_names.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
COLON                           000004 constant        char(1)                  initial unaligned dcl 94 set ref 217*
NL                              005736 constant        char(1)                  initial unaligned dcl 94 ref 373 377 467 485
SPACE                           005740 constant        char(1)                  initial unaligned dcl 94 ref 465 483
TAB                             005737 constant        char(1)                  initial unaligned dcl 94 ref 466 484
acl_ptr                         000206 automatic       pointer                  initial dcl 44 set ref 44* 181* 399* 400* 421 421*
al                              000102 automatic       fixed bin(17,0)          dcl 16 set ref 143* 152 152 153 158* 159 160 160 161
                                                                                  161
alm                             000062 constant        entry                    external dcl 134 ref 406 407
ap                              000100 automatic       pointer                  dcl 16 set ref 143* 152 153 158* 159 160 160 161 161
arg                                    based           char                     unaligned dcl 16 set ref 152* 153 159 160 160 161
                                                                                  161
b_token                                based           char                     unaligned dcl 451 ref 464 483 484 485 486 488
based_char_description                 based           structure                level 1 dcl 106 set ref 276 425
before                                                 builtin function         dcl 44 ref 330 330
break                           001323 automatic       fixed bin(17,0)          dcl 451 set ref 458* 465 478* 483
cc                              000101 automatic       fixed bin(17,0)          dcl 436 set ref 441* 442 442
char                                   parameter       char(1)                  unaligned dcl 475 ref 473 486 488
char_name                       000220 automatic       varying char(8)          dcl 47 set ref 219* 266 273* 274*
char_number                     000217 automatic       fixed bin(17,0)          dcl 47 in procedure "compile_gct" set ref 198* 198*
                                                                                  201 208* 208* 211 213 215 277 293
char_number               2            based           fixed bin(17,0)          level 2 in structure "based_char_description"
                                                                                  dcl 106 in procedure "compile_gct" set ref 277*
                                                                                  293 335
character_name                  000250 automatic       varying char(32)         initial dcl 68 set ref 68*
character_type                  000261 automatic       varying char(32)         initial dcl 68 set ref 68*
ci                              000100 automatic       fixed bin(17,0)          dcl 436 set ref 441* 442 442
cleanup                         000200 stack reference condition                dcl 35 ref 176 401
code                            000103 automatic       fixed bin(35,0)          dcl 16 set ref 143* 144 145* 152* 153 158* 173* 174
                                                                                  178* 179 181* 182 399* 402 409* 410 438* 508* 509
com_err_                        000014 constant        entry                    external dcl 16 ref 145 163 169 438 444
coord_pairs                            based           structure                array level 2 packed unaligned dcl 106
coords                          000234 automatic       fixed bin(17,0)          array dcl 47 set ref 236* 237 238 246 247
count                           001322 automatic       fixed bin(17,0)          dcl 451 set ref 458* 464 478* 483 484 485 486 488
cp                              000562 automatic       pointer                  dcl 120 set ref 276* 277 278 279 280 281 284 285 298
                                                                                  299 302 303 333* 333* 335 338 338 338 338 346 347
                                                                                  347 351 353 353 356 356 356 363 363 363 363 367
                                                                                  367 367 367 367* 378 423* 423* 424 425*
cu_$arg_count                   000012 constant        entry                    external dcl 16 ref 157
cu_$arg_ptr                     000010 constant        entry                    external dcl 16 ref 143 158
cur_x                           000236 automatic       fixed bin(17,0)          dcl 61 set ref 226* 237* 237 242 256 256 257 257 264
                                                                                  273 273*
cur_y                           000237 automatic       fixed bin(17,0)          dcl 61 set ref 226* 238* 238 243 258 258 259 259 274
                                                                                  274*
cv_dec_check_                   000066 constant        entry                    external dcl 502 ref 508
default_flags                   000341 automatic       varying char(168)        initial dcl 68 set ref 68*
delete_$path                    000060 constant        entry                    external dcl 134 ref 409
desirable_chars                 000602 automatic       bit(128)                 dcl 122 set ref 312* 313* 314
dirname                         000104 automatic       char(168)                unaligned dcl 28 set ref 152* 178*
divide                                                 builtin function         dcl 44 ref 361
ename                           000156 automatic       char(33)                 initial unaligned dcl 28 set ref 28* 152* 173* 178*
                                                                                  179 330 330 402
eof                             001324 automatic       fixed bin(17,0)          dcl 451 set ref 458* 461 478* 481
errlab                                 parameter       label variable           dcl 475 ref 473 490
error_table_$badopt             000022 external static fixed bin(35,0)          dcl 24 set ref 163*
error_table_$inconsistent       000020 external static fixed bin(35,0)          dcl 24 set ref 169*
error_table_$translation_failed 000016 external static fixed bin(35,0)          dcl 24 set ref 444*
expand_pathname_$add_suffix     000024 constant        entry                    external dcl 28 ref 152
explanation                     000314 automatic       varying char(80)         initial dcl 68 in procedure "compile_gct" set ref
                                                                                  68* 415* 488*
explanation                            parameter       varying char             dcl 433 in procedure "error" set ref 431 438*
finishing_string                000005 constant        varying char(40)         initial dcl 74 set ref 397*
found                           000223 automatic       bit(1)                   dcl 47 set ref 289* 291 294*
gct_charbits                    000572 automatic       bit(128)                 dcl 122 set ref 186* 213 215* 314 381
gct_charnames                   000135 constant        varying char(8)          initial array dcl 1-1 set ref 198 198 201 208 208
                                                                                  211 320 335* 387*
get_wdir_                       000030 constant        entry                    external dcl 28 ref 181 181 409 409
hbound                                                 builtin function         dcl 44 ref 198 201 208 211
header                    3            based           structure                level 2 dcl 106
header_string                   000020 constant        varying char(200)        initial dcl 74 set ref 330*
i                               001336 automatic       fixed bin(17,0)          dcl 502 in procedure "getvals" set ref 506* 508*
i                               000214 automatic       fixed bin(17,0)          dcl 47 in procedure "compile_gct" set ref 157* 158*
                                                                                  228* 231 241* 283* 284 284 285 285* 318* 320 321
                                                                                  346* 347 347* 351* 352 353 353 363 363 363 363*
                                                                                  386* 387 389
index                                                  builtin function         dcl 44 ref 318 386
invis_struc                     000240 automatic       structure                level 1 dcl 63 set ref 226* 239*
ioa_                            000054 constant        entry                    external dcl 130 ref 142 273 274 324 325
ioa_$ioa_stream                 000050 constant        entry                    external dcl 130 ref 442
ioa_$rsnp                       000052 constant        entry                    external dcl 130 ref 335 338 347 387 392
ioa_$rsnpnnl                    000056 constant        entry                    external dcl 130 ref 330 353 356 363 367
j                               000215 automatic       fixed bin(17,0)          dcl 47 set ref 352* 356 356 356 367 367 367 367 367
                                                                                  380* 381 392*
k                               000216 automatic       fixed bin(17,0)          dcl 47 set ref 361* 363*
last_p                          000566 automatic       pointer                  dcl 120 set ref 288* 293* 297 302 303
left_margin               3(18)        based           fixed bin(8,0)           level 3 packed unaligned dcl 106 set ref 279* 338*
length                                                 builtin function         dcl 44 ref 319 361 521 522
list_switch                     001256 automatic       bit(1)                   dcl 134 set ref 155* 161* 168 406
main_proc                       000272 automatic       varying char(32)         initial dcl 68 set ref 68*
margin                          000232 automatic       fixed bin(17,0)          array dcl 47 set ref 220*
max                                                    builtin function         dcl 44 ref 263 361
max_string_size                 000561 automatic       fixed bin(21,0)          initial dcl 103 set ref 103* 442 442
max_x                     1     000240 automatic       fixed bin(17,0)          level 2 in structure "invis_struc" dcl 63
                                                                                  in procedure "compile_gct" set ref 264* 264 268
                                                                                  269 278 280
max_x                     1            parameter       fixed bin(17,0)          level 2 in structure "struc" dcl 254 in procedure
                                                                                  "maxmin" set ref 257 257*
max_x                     1     000244 automatic       fixed bin(17,0)          level 2 in structure "vis_struc" dcl 66 in procedure
                                                                                  "compile_gct" set ref 242* 269 280
max_y                     3     000244 automatic       fixed bin(17,0)          level 2 in structure "vis_struc" dcl 66 in procedure
                                                                                  "compile_gct" set ref 243* 267
max_y                     3            parameter       fixed bin(17,0)          level 2 in structure "struc" dcl 254 in procedure
                                                                                  "maxmin" set ref 259 259*
metric_char                     000225 automatic       char(1)                  unaligned dcl 47 set ref 188* 196* 266 310
metric_dimensions               000226 automatic       fixed bin(17,0)          array dcl 47 set ref 189* 267* 268* 269* 310 330*
min_x                           000244 automatic       fixed bin(17,0)          level 2 in structure "vis_struc" dcl 66 in procedure
                                                                                  "compile_gct" set ref 242* 269 279
min_x                                  parameter       fixed bin(17,0)          level 2 in structure "struc" dcl 254 in procedure
                                                                                  "maxmin" set ref 256 256*
min_x                           000240 automatic       fixed bin(17,0)          level 2 in structure "invis_struc" dcl 63
                                                                                  in procedure "compile_gct" set ref 263* 263 268
                                                                                  269 278 279
min_y                     2     000244 automatic       fixed bin(17,0)          level 2 in structure "vis_struc" dcl 66 in procedure
                                                                                  "compile_gct" set ref 243* 267
min_y                     2            parameter       fixed bin(17,0)          level 2 in structure "struc" dcl 254 in procedure
                                                                                  "maxmin" set ref 258 258*
move_type                 4            based           bit                      level 3 packed unaligned dcl 106 set ref 281* 347
                                                                                  347 363 363 367 367
movetype                        000606 automatic       bit(144)                 dcl 126 set ref 222* 231* 241 281
n_elements                3            based           fixed bin(8,0)           level 3 packed unaligned dcl 106 set ref 276* 281
                                                                                  284 285 338* 346 347 347 351 353 353 356 356 356
                                                                                  363 363 363 363 367 367 367 367 367 425 425
nelem                           000612 automatic       fixed bin(17,0)          dcl 126 set ref 221* 245* 245 246 247 276 276 276
                                                                                  283
next_p                                 based           pointer                  level 2 dcl 106 set ref 295 298* 302* 302 303* 378
                                                                                  424
no_assembly                     001257 automatic       bit(1)                   dcl 134 set ref 155* 160* 168 404
null                                                   builtin function         dcl 44 ref 44 130 140 288 291 297 333 400 421 423
object_ename                    000167 automatic       char(32)                 unaligned dcl 28 set ref 173* 174 181 182 406* 407*
                                                                                  409* 410
outdx                           000210 automatic       fixed bin(17,0)          dcl 47 set ref 191* 399 521 522* 522
outstring                              based           char(65536)              unaligned dcl 519 set ref 521*
parse_file_$parse_file_cur_line 000042 constant        entry                    external dcl 40 ref 441
parse_file_$parse_file_init_name
                                000040 constant        entry                    external dcl 40 ref 178
parse_file_$parse_file_ptr      000064 constant        entry                    external dcl 451 ref 458 478
parse_file_$parse_file_unset_break
                                000044 constant        entry                    external dcl 40 ref 184
pf_ptr                          001254 automatic       pointer                  initial dcl 130 set ref 130* 178* 442 442
pf_string                              based           char                     dcl 130 ref 442 442
print_line                             parameter       bit(1)                   dcl 433 ref 431 440
right_margin              3(27)        based           fixed bin(8,0)           level 3 packed unaligned dcl 106 set ref 280* 338*
segp                            000212 automatic       pointer                  dcl 47 set ref 181* 399* 521
special_bits                    000000 constant        bit(128)                 initial dcl 122 ref 186 382
start_p                         000570 automatic       pointer                  dcl 120 set ref 140* 291 298 299* 333 423
string                                 parameter       varying char             dcl 517 ref 515 521 521 522
struc                                  parameter       structure                level 1 dcl 254 set ref 252
substr                                                 builtin function         dcl 44 set ref 159 213 215* 231* 241 313* 321* 347
                                                                                  347 363 363 367 367 389* 442 442 521*
suffixed_name_$new_suffix       000026 constant        entry                    external dcl 28 ref 173
sys_info$max_seg_size           000046 external static fixed bin(35,0)          dcl 103 ref 103
temp                            001334 automatic       fixed bin(17,0)          array dcl 502 set ref 508* 512
temp_string                     000414 automatic       varying char(400)        dcl 68 set ref 316* 319 319* 319 320* 320 325* 330*
                                                                                  331* 335* 336* 338* 344* 347* 348* 353* 356* 356
                                                                                  361 363* 363 367* 367 373* 373 374* 387* 388* 392*
                                                                                  393*
tempbits                        000576 automatic       bit(128)                 dcl 122 set ref 314* 315 317 318 321* 381* 382* 384
                                                                                  385 386 389*
title_string                    000103 constant        varying char(100)        initial dcl 74 set ref 328*
token                           000303 automatic       varying char(32)         dcl 68 set ref 194 196 198 201 206 208 211 213 219
                                                                                  228 229 230 235 461* 464* 465 466 467 468 508 509
tokenp                          001320 automatic       pointer                  dcl 451 set ref 458* 464 478* 483 484 485 486 488
tp                              000564 automatic       pointer                  dcl 120 set ref 291* 291* 293 293* 295 424* 426
tssi_$clean_up_segment          000036 constant        entry                    external dcl 35 ref 421
tssi_$finish_segment            000034 constant        entry                    external dcl 35 ref 399
tssi_$get_segment               000032 constant        entry                    external dcl 35 ref 181
vec_sw                          000224 automatic       bit(1)                   dcl 47 set ref 229* 232* 240
vis_struc                       000244 automatic       structure                level 1 dcl 66 set ref 226* 233* 240*
width                     3(09)        based           fixed bin(8,0)           level 3 packed unaligned dcl 106 set ref 278* 338*
word_align                4            based           structure                level 2 dcl 106
x                                      based           fixed bin(8,0)           array level 3 in structure "based_char_description"
                                                                                  packed unaligned dcl 106 in procedure
                                                                                  "compile_gct" set ref 284* 353* 356* 363* 367*
x                               000613 automatic       fixed bin(17,0)          array dcl 126 in procedure "compile_gct" set ref
                                                                                  246* 284
y                                      based           fixed bin(8,0)           array level 3 in structure "based_char_description"
                                                                                  packed unaligned dcl 106 in procedure
                                                                                  "compile_gct" set ref 285* 353* 356* 363* 367*
y                               001033 automatic       fixed bin(17,0)          array dcl 126 in procedure "compile_gct" set ref
                                                                                  247* 285

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BS                                     internal static char(1)                  initial unaligned dcl 94
CR                                     internal static char(1)                  initial unaligned dcl 94
UNDERSCORE                             internal static char(1)                  initial unaligned dcl 94
collate                                                builtin function         dcl 44

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_break                       005451 constant        label                    dcl 488 ref 483
badopt                          001654 constant        label                    dcl 163 ref 159
bloop                           005360 constant        label                    dcl 478 ref 483 484 485
clean_up                        004772 constant        entry                    internal dcl 419 ref 147 176 412
compile_gct                     001356 constant        entry                    external dcl 11
crump                           004726 constant        label                    dcl 415 ref 217 217
error                           005055 constant        entry                    internal dcl 431 ref 153 174 179 182 201 211 213 235
                                                                                  310 402 410 415 468 481 509
get_break                       005356 constant        entry                    internal dcl 473 ref 217
get_token                       005227 constant        entry                    internal dcl 449 ref 192 195 203 224 249 307 507
getvals                         005521 constant        entry                    internal dcl 500 ref 236
loop                            005230 constant        label                    dcl 458 ref 465 466 467
maxmin                          004745 constant        entry                    internal dcl 252 ref 233 239 240
put_out                         005636 constant        entry                    internal dcl 515 ref 328 331 336 344 348 374 377 388
                                                                                  393 397
returner                        001471 constant        label                    dcl 147 ref 164 170 404 445

NAMES DECLARED BY CONTEXT OR IMPLICATION.
copy                                                   builtin function         ref 313
min                                                    builtin function         ref 264

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6272        6362    5744        6302
Length      6632    5744        70         233     326           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
compile_gct                         928 external procedure  is an external procedure.  
on unit on line 176                  64 on unit               
maxmin                                  internal procedure  shares stack frame of external procedure compile_gct.  
clean_up                             70 internal procedure  is called by several nonquick procedures.  
error                               102 internal procedure  is called during a stack extension.  
get_token                               internal procedure  shares stack frame of external procedure compile_gct.  
getvals                                 internal procedure  shares stack frame of external procedure compile_gct.  
put_out                                 internal procedure  shares stack frame of external procedure compile_gct.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
compile_gct              000100 ap                          compile_gct
                         000102 al                          compile_gct
                         000103 code                        compile_gct
                         000104 dirname                     compile_gct
                         000156 ename                       compile_gct
                         000167 object_ename                compile_gct
                         000206 acl_ptr                     compile_gct
                         000210 outdx                       compile_gct
                         000212 segp                        compile_gct
                         000214 i                           compile_gct
                         000215 j                           compile_gct
                         000216 k                           compile_gct
                         000217 char_number                 compile_gct
                         000220 char_name                   compile_gct
                         000223 found                       compile_gct
                         000224 vec_sw                      compile_gct
                         000225 metric_char                 compile_gct
                         000226 metric_dimensions           compile_gct
                         000232 margin                      compile_gct
                         000234 coords                      compile_gct
                         000236 cur_x                       compile_gct
                         000237 cur_y                       compile_gct
                         000240 invis_struc                 compile_gct
                         000244 vis_struc                   compile_gct
                         000250 character_name              compile_gct
                         000261 character_type              compile_gct
                         000272 main_proc                   compile_gct
                         000303 token                       compile_gct
                         000314 explanation                 compile_gct
                         000341 default_flags               compile_gct
                         000414 temp_string                 compile_gct
                         000561 max_string_size             compile_gct
                         000562 cp                          compile_gct
                         000564 tp                          compile_gct
                         000566 last_p                      compile_gct
                         000570 start_p                     compile_gct
                         000572 gct_charbits                compile_gct
                         000576 tempbits                    compile_gct
                         000602 desirable_chars             compile_gct
                         000606 movetype                    compile_gct
                         000612 nelem                       compile_gct
                         000613 x                           compile_gct
                         001033 y                           compile_gct
                         001254 pf_ptr                      compile_gct
                         001256 list_switch                 compile_gct
                         001257 no_assembly                 compile_gct
                         001320 tokenp                      get_token
                         001322 count                       get_token
                         001323 break                       get_token
                         001324 eof                         get_token
                         001334 temp                        getvals
                         001336 i                           getvals
error                    000100 ci                          error
                         000101 cc                          error

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            alloc_bs            realloc_cs          cat_realloc_cs      call_ext_out_desc   call_ext_out
call_int_this_desc  call_int_this       call_int_other      return              tra_ext             tra_label_var
enable              shorten_stack       ext_entry           int_entry           int_entry_desc      set_cs_eis
index_bs_1_eis      alloc_based_storage free_based          index_before_cs

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
alm                           com_err_                      cu_$arg_count                 cu_$arg_ptr
cv_dec_check_                 delete_$path                  expand_pathname_$add_suffix   get_wdir_
ioa_                          ioa_$ioa_stream               ioa_$rsnp                     ioa_$rsnpnnl
parse_file_$parse_file_cur_line                             parse_file_$parse_file_init_name
parse_file_$parse_file_ptr    parse_file_$parse_file_unset_break                          suffixed_name_$new_suffix
tssi_$clean_up_segment        tssi_$finish_segment          tssi_$get_segment

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$inconsistent     error_table_$translation_failed
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 001355        28 001363        44 001366        68 001370       103 001375       130 001400       140 001402
    142 001403       143 001420       144 001437       145 001441       147 001471       149 001475       152 001476
    153 001534       155 001564       157 001567       158 001603       159 001620       160 001625       161 001641
    163 001654       164 001701       166 001702       168 001704       169 001710       170 001741       173 001742
    174 001776       176 002023       178 002045       179 002072       181 002117       182 002161       184 002206
    186 002221       188 002225       189 002227       191 002240       192 002242       194 002243       195 002250
    196 002251       198 002256       199 002273       201 002275       203 002335       206 002337       208 002344
    209 002361       211 002363       213 002423       215 002466       217 002473       219 002500       220 002510
    221 002521       222 002522       224 002525       226 002526       228 002540       229 002547       230 002556
    231 002563       232 002567       233 002571       234 002573       235 002574       236 002631       237 002636
    238 002640       239 002642       240 002644       241 002650       242 002655       243 002660       245 002663
    246 002664       247 002667       249 002671       250 002672       263 002674       264 002701       266 002706
    267 002713       268 002716       269 002721       273 002726       274 002754       276 003002       277 003023
    278 003025       279 003031       280 003035       281 003040       283 003045       284 003054       285 003077
    286 003117       288 003121       289 003123       291 003124       293 003134       294 003142       295 003144
    297 003147       298 003153       299 003155       300 003157       302 003160       303 003163       307 003165
    308 003166       310 003167       312 003224       313 003230       314 003240       315 003247       316 003253
    317 003254       318 003260       319 003265       320 003301       321 003317       322 003323       324 003324
    325 003340       328 003351       330 003354       331 003423       333 003427       335 003435       336 003470
    338 003473       344 003544       346 003547       347 003560       348 003620       349 003623       351 003626
    352 003637       353 003641       356 003732       361 004041       363 004052       367 004171       373 004311
    374 004321       375 004324       377 004327       378 004336       380 004342       381 004346       382 004354
    384 004360       385 004364       386 004370       387 004375       388 004432       389 004435       390 004441
    392 004442       393 004473       395 004476       397 004501       399 004504       400 004531       401 004533
    402 004534       404 004561       406 004563       407 004605       409 004616       410 004664       412 004720
    413 004725       415 004726       527 004744       252 004745       256 004747       257 004753       258 004760
    259 004764       260 004770       419 004771       421 004777       423 005012       424 005023       425 005026
    426 005046       428 005053       431 005054       438 005070       440 005116       441 005122       442 005133
    443 005176       444 005177       445 005224       449 005227       458 005230       461 005245       464 005254
    465 005265       466 005274       467 005301       468 005306       469 005354       471 005355       473 005356
    478 005360       481 005375       483 005422       484 005432       485 005436       486 005442       488 005451
    490 005516       500 005521       506 005523       507 005530       508 005531       509 005563       510 005623
    512 005626       515 005636       521 005647       522 005660       524 005662


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
