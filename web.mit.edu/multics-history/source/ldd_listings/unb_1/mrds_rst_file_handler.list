	COMPILATION LISTING OF SEGMENT mrds_rst_file_handler
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1346.7 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 
       19 /* HISTORY:
       20*
       21*   originally written by jim gray - - october 1978
       22*   modified by Jim Gray - - July 1979 to add pl1 version of data alignment in tuple
       23*   Modified by Jim Gray - - Dec. 1979, to  add consideration of packed decimal
       24*   data types to pad_to_alignment_boundary routine.
       25*   Modified by Jim Gray - - Dec. 1979, to make pad_to_alignment_boundary external
       26*   procedure mdbm_util_$align_data_item, so other routines could use it.
       27*   Modified by Jim Gray - - Jan. 1980, to disallow file statement, only default files are now allowed.
       28*   Modified by Jim Gray - - April 1980, to remove abs. path in attach desc, so databsaes can be copied.
       29*   Modified by Jim Gray - - Sept. 1980, to capture the use of reserved segment names
       30*   "dbc" and "db_model" for this new architecture.
       31*
       32*   81-04-30 Jim Gray : changed max number of relations creatable
       33*   tobe dependent on mrds_data_$max_relations, rather than on a file_id_len
       34*   that is constrained by the mdbm_tuple_id include file structure.
       35*
       36*   81-05-01 Jim Gray : changed db_model.file_id_len to be taken from mrds_data_$max_relations
       37*
       38*   81-05-18 Jim Gray : added check for max attrs per relation
       39*
       40*   81-09-16 Davids: added the rtrim so that the code would compile with
       41*   .        the prefix option stringsize.
       42*
       43*   81-11-25 Davids: changed rel_info.id to  be  "000000000001"b  and
       44*   file_info.file_id  to be "000000000000000000000000000000000001"b,
       45*   For all relations and files. This was to prepare the way for easy
       46*   restructuring,  i.e.  adding  and  deleteing relations and making
       47*   temp_rels permanent.
       48*
       49*   82-05-19 Davids: changed rel_info.nsec_inds to  rel_info.unused_3
       50*   because  it  really wasn't the number of secondary indices in the
       51*   relation it was always zero - it is still 0 but now it has a more
       52*   descriptive name.
       53*
       54*   82-06-25  R.  Harvey: changed to use mdbm_file_model_init.incl to
       55*   speed up creation of databases.
       56*
       57*   82-07-02 Roger Lackey: deleted
       58*   file_model.num_rels = file_model.num_rels + 1;
       59*   because it is now initialized in structured and only one relation per file
       60*   is allowed now.
       61*
       62*   83-02-17 Davids: explicitly declared variables that were declared by
       63*   context or implication and deleted declarations to variables that were
       64*   not referenced.
       65**/
       66 
       67 
       68 mrds_rst_file_handler:
       69      procedure (rsc_ptr, list_ptr);
       70 
       71 /*
       72*   .                       BEGIN_DESCRIPTION:
       73*   this routine builds/alters the mrds database model file information
       74*   and the global entity lists maintained by RMDB/CMDB,
       75*   based upon the file data and directive that is active when
       76*   called by the RMDB/CMDB parser.
       77*   the directive may be undefine, define, redefine, or cmdb and the data is
       78*   either a file name to be deleted, or a linked list of linked list of
       79*   structures holding the file information and it's relation list
       80*   .                       END_DESCRIPTION
       81**/
       82 
       83 /* PARAMETERS:
       84*
       85*   rsc_ptr - - (input) pointer to the common control segment
       86*
       87*   list_ptr - - (input) pointer to the single file name to be deleted(undefine only) or to the
       88*   file structure headed list of relation structures
       89*
       90*   database model - - (output) updated model with altered file information
       91*
       92*   global lists - - (output) the list of database entities, updated
       93*   according to directive and data
       94*
       95*   error_output - - (output) via mrds_rst_error calls, of error messages
       96**/
       97 
       98 /* REMAINING ERRORS:
       99*
      100*
      101*   undefine:
      102*
      103*   the file name may be the <error_symbol>(this may be ignored)
      104*   the file may not be defined in the database
      105*
      106*   define, cmdb:
      107*
      108*   the file name may be the <error_symbol>(this may be ignored)
      109*   one of the relation names may be the <error_symbol>(this may be ignored)
      110*   the file may already be defined in the database
      111*   a relation may not be defined in the database
      112*   a relation may reside in a file already
      113*   the file/relation max_tuples may not be set
      114*   the file type may conflict with the max_tuples option values given
      115*
      116*   redefine:
      117*
      118*   same as define, except file name may not be defined in the database
      119*   or the relation(s) may reside in other than the given file
      120*
      121*   note: "(this may be ignored)" means a previous error will prevent
      122*   a database model with erroneous information from being built
      123*
      124**/
      125 
      126 /* set semantic structure pointers */
      127 
      128 	stmt_ptr = rsc_ptr -> rsc.stmt_ptr;
      129 	directive_ptr = rsc_ptr -> rsc.directive_ptr;
      130 
      131 	if directive.type = UNDEFINE then do;		/* input structure depends on direcitve */
      132 		delete_name_ptr = list_ptr;
      133 		file_name = rtrim (delete_name.overlay);/* CHANGE 81-09-16 */
      134 	     end;
      135 	else do;
      136 		file_ptr = list_ptr;
      137 		file_name = file.name;
      138 	     end;
      139 
      140 /* call trace if metering is on */
      141 
      142 	if ^rsc.trace_sw then
      143 	     ;
      144 	else call
      145 		mrds_rst_meter (rsc_ptr, "mrds_rst_file_handler", IN, file_name);
      146 
      147 /* check on which directive called us */
      148 
      149 	if directive.type = UNDEFINE | directive.type = REDEFINE then do;
      150 		if stmt (directive.type).file.number > 0 then
      151 		     ;				/* not first time */
      152 		else do;				/* first time only, issue error */
      153 			call
      154 			     ioa_$rs ("^a ^a", message, message_length,
      155 			     "The file handler will not implement ""undefine"" or ""redefine"""
      156 			     , "directives until a later release.");
      157 			call
      158 			     mrds_rst_error (rsc_ptr, 2 /* severity */,
      159 			     mrds_error_$rst_undone_option, (message));
      160 		     end;
      161 	     end;
      162 	else do;
      163 
      164 /* define or cmdb directive was caller, process newly defined file */
      165 
      166 		if file.default then
      167 		     ;				/* called from file cleanup to give default file for rels */
      168 		else if rsc.allow_blocked_files then
      169 		     ;
      170 		else if rsc.blocked_file_seen then
      171 		     ;
      172 		else do;
      173 			rsc.blocked_file_seen = ON;
      174 			call
      175 			     ioa_$rs ("^a", message, message_length,
      176 			     "The file statment will not be implemented until a later release."
      177 			     );
      178 			call
      179 			     mrds_rst_error (rsc_ptr, 2 /* severity */,
      180 			     mrds_error_$rst_undone_option, (message));
      181 		     end;
      182 
      183 
      184 		call define_file ();
      185 
      186 	     end;
      187 
      188 /* call the trace routine if metering is turned on */
      189 
      190 	if ^rsc.trace_sw then
      191 	     ;
      192 	else call
      193 		mrds_rst_meter (rsc_ptr, "mrds_rst_file_handler", OUT, file_name);
      194 
      195 define_file:
      196      procedure ();
      197 
      198 /* routine to build the model for this file according to it's definition */
      199 
      200 	error_mode = OFF;
      201 
      202 /* check that files defined in the source do not use relation names */
      203 
      204 	if file.default then
      205 	     ;					/* file from cleanup handler */
      206 	else do;					/* from source */
      207 
      208 		call
      209 		     mrds_rst_tree_search ((file.name), rsc.h_grel_ptr, node_ptr,
      210 		     parent_ptr, success);
      211 
      212 		if ^success then
      213 		     ;				/* not a relation name */
      214 		else do;				/* bad name, do a fixup */
      215 			error_mode = ON;		/* set special provisions for detecting all errors */
      216 			call
      217 			     ioa_$rs ("^a^a^a ^d ^a", message, message_length, "The file """,
      218 			     file.name, """ on line", file.line_num,
      219 			     "has the same name as a relation, only default files may have relation names!!"
      220 			     );
      221 			call
      222 			     mrds_rst_error (rsc_ptr, 2 /* severity */,
      223 			     mrds_error_$rst_dup_file, (message));
      224 			call mrds_rst_rsc_alloc (rsc_ptr, GL, gl_ptr); /* get dummy version not in list */
      225 		     end;
      226 	     end;
      227 
      228 /* make sure the file is not already in the database or previously defined(if above error did'nt occur) */
      229 
      230 	if error_mode then
      231 	     error_code = 0;
      232 	else call
      233 		mrds_rst_list_element$add ((file.name), MAIN_LIST, rsc_ptr,
      234 		rsc.h_gfile_ptr, gl_ptr, error_code);
      235 
      236 	if error_code = 0 then
      237 	     ;					/* normal processing of good file */
      238 	else do;
      239 		error_mode = ON;			/* make special provisions so all errors are detected */
      240 		call
      241 		     ioa_$rs ("^a^a^a ^d ^a", message, message_length, "The file """,
      242 		     file.name, """ on line", file.line_num,
      243 		     "is already defined in the database, duplicate names are not allowed!!"
      244 		     );
      245 		call
      246 		     mrds_rst_error (rsc_ptr, 2 /* severity */, mrds_error_$rst_dup_file,
      247 		     (message));
      248 		call mrds_rst_rsc_alloc (rsc_ptr, GL, gl_ptr); /* make dummy version not in list */
      249 	     end;
      250 
      251 /* check for reserved segment names (due to db architecture) being used for file name */
      252 
      253 	if file.name ^= "dbc" & file.name ^= "db_model" then
      254 	     ;
      255 	else do;
      256 		error_mode = ON;			/* use unique name instead of reserved name */
      257 		if file.default then
      258 		     call
      259 			ioa_$rs ("^a^a^a", message, message_length,
      260 			"The relation name """, file.name,
      261 			""" is a reserved name in this database architecture.");
      262 		else call
      263 			ioa_$rs ("^a^a^a ^d ^a", message, message_length,
      264 			"The file name """, file.name, """ given on line",
      265 			file.line_num,
      266 			"is a reserved name in this database architecture.");
      267 		call
      268 		     mrds_rst_error (rsc_ptr, 2 /* severity */,
      269 		     mrds_error_$rst_reserved_name, (message));
      270 	     end;
      271 
      272 /* file was not found in list so it was added,
      273*   link list element to list head and fill in the blanks */
      274 
      275 	gl.type = MAIN_LIST;
      276 	gl.name = file.name;
      277 	gl.item_info_ptr = null ();			/* no file_info yet */
      278 	gl.parse_info_ptr = file_ptr;
      279 	gl.other_info_ptr = gl_ptr;
      280 	gl.item_sub_list_ptr = null ();		/* no relations yet */
      281 	gl.file_info_ptr = null ();			/* no file model defined to hold file yet */
      282 	gl.file_model_ptr = null ();
      283 	gl.affected = ON;
      284 	gl.undefine = OFF;
      285 	gl.redefine = OFF;
      286 	if directive.type = DEFINE then do;
      287 		gl.define = ON;
      288 		gl.cmdb = OFF;
      289 	     end;
      290 	else do;					/* CMDB directive */
      291 		gl.define = OFF;
      292 		gl.cmdb = ON;
      293 	     end;
      294 	gl.superior_assigned = OFF;			/* no file model for this file yet */
      295 	gl.inferior_assigned = OFF;			/* no relations for this file yet */
      296 	gl.complete = OFF;				/* file is not formatted yet */
      297 	gl.consistant = ON;				/* assume innocent until proven guilty */
      298 	gl.reserved = OFF;
      299 
      300 /* build the file model and file_info for this file */
      301 
      302 	call load_file_model ();
      303 
      304 /* process the list of relations for this file */
      305 
      306 	if ^gl.superior_assigned then
      307 	     ;
      308 	else do;
      309 
      310 		call file_relation_handler ();
      311 
      312 /* compute parameters for blocked files, now that max_tuples and tuple sizes are known */
      313 
      314 		if ^gl.inferior_assigned then
      315 		     gl.consistant = OFF;
      316 
      317 /* check for too many files or too many tuples */
      318 
      319 		call check_file_size_and_number ();
      320 
      321 	     end;
      322 
      323      end;
      324 
      325 file_relation_handler:
      326      procedure ();
      327 
      328 /* check each relation in the list for this file */
      329 
      330 	max_tuples = 0;
      331 	item_ptr = file.i_ptr;			/* get first on list of this file's relations */
      332 	do while (item_ptr ^= null ());
      333 
      334 /* make sure that the given relation is defined in the database */
      335 
      336 	     call
      337 		mrds_rst_tree_search (item.name, rsc.h_grel_ptr, node_ptr,
      338 		parent_ptr, success);
      339 
      340 	     if ^success then do;			/* not found */
      341 		     call
      342 			ioa_$rs ("^a^a^a ^d ^a^a^a", message, message_length,
      343 			"The relation """, item.name, """ on line", item.line_num,
      344 			"given for file """, file.name,
      345 			""" has not been defined in the database.");
      346 		     call
      347 			mrds_rst_error (rsc_ptr, 2 /* severity */,
      348 			mrds_error_$rst_undef_rel, (message));
      349 		end;
      350 	     else do;
      351 		     rel_gl_ptr = node_ptr -> node.data;/* get relation global element pointer */
      352 		     relation_ptr = rel_gl_ptr -> gl.parse_info_ptr; /* get relation declaration */
      353 
      354 /* check that this relation is not already in some file */
      355 
      356 		     if ^rel_gl_ptr -> gl.superior_assigned then
      357 			;
      358 		     else do;
      359 			     call
      360 				ioa_$rs ("^a^a^a ^d ^a^a^a^a^a", message, message_length,
      361 				"The relation """, relation.name, """ on line",
      362 				relation.line_num, "given in file """, file.name,
      363 				""" is already defined as belonging to file """,
      364 				rel_gl_ptr -> gl.other_info_ptr -> gl.name,
      365 				""",  moving relations is not allowed!!");
      366 			     call
      367 				mrds_rst_error (rsc_ptr, 2 /* severity */,
      368 				mrds_error_$rst_rel_has_file, (message));
      369 			end;
      370 		     rel_gl_ptr -> gl.superior_assigned = ON; /* file present for this relation */
      371 		     rel_gl_ptr -> gl.file_info_ptr = fi_ptr; /* set file info/model in relation global element */
      372 		     rel_gl_ptr -> gl.file_model_ptr = fm_ptr;
      373 		     rel_gl_ptr -> gl.other_info_ptr = gl_ptr; /* file global list element for relation */
      374 
      375 /* add this relation to the file's relation sublist */
      376 
      377 		     call
      378 			mrds_rst_list_element$add (relation.name, SUB_LIST, rsc_ptr,
      379 			gl.item_sub_list_ptr, sl_ptr, error_code);
      380 
      381 		     if error_code ^= 0 then do;
      382 			     call
      383 				ioa_$rs ("^a^a^a^a", message, message_length,
      384 				"LOGIC ERROR in  mrds_rst_file_handler, a duplicate relation """
      385 				, relation.name, """ was found in sublist of file """,
      386 				file.name, """.");
      387 			     call
      388 				mrds_rst_error (rsc_ptr, 4 /* severity */, error_code,
      389 				(message));
      390 			     num_dims = 0;		/* unused variable */
      391 			end;
      392 		     else do;
      393 
      394 /* fill in the sublist element */
      395 
      396 			     sl.type = SUB_LIST;
      397 			     sl.name = relation.name;
      398 			     sl.item_info_ptr = null (); /* no relation info yet */
      399 			     sl.parse_info_ptr = relation_ptr; /* relation parse structure */
      400 			     sl.old_other_info_ptr = null ();
      401 			     sl.new_other_info_ptr = gl_ptr;
      402 			     sl.global_list_ptr = rel_gl_ptr;
      403 			     sl.reserved = OFF;
      404 
      405 /* build the relation info for this "good" relation in this file */
      406 
      407 			     call load_rel_info ();
      408 			     gl.inferior_assigned = ON; /* relation present for file */
      409 
      410 /* build all the attribute infos contained in this relation, if attributes present, and rel_info obtained */
      411 
      412 			     if ^rel_gl_ptr -> gl.inferior_assigned
      413 				| ^rel_gl_ptr -> gl.complete then
      414 				;
      415 			     else do;
      416 
      417 				     call load_attr_infos ();
      418 
      419 				     call check_relation_key_length ();
      420 
      421 				     call align_varying_tuple_data ();
      422 				end;
      423 			end;
      424 		end;
      425 
      426 /* go to next relation in list */
      427 
      428 	     item_ptr = item.next;
      429 	end;
      430 
      431      end;
      432 
      433 load_file_model:
      434      procedure ();
      435 
      436 /* routine to initialize and fill in the file model/info */
      437 
      438 	db_model_path = rtrim (rsc.temp_dir) || ">db_model";
      439 
      440 /* update the db_model file statistics */
      441 
      442 	dbm_ptr = rsc.n_dm_ptr;
      443 	db_model.num_unblk_files = db_model.num_unblk_files + 1;
      444 	db_model.unblk_file_id_len =
      445 	     max (db_model.unblk_file_id_len,
      446 	     fixed (ceil (log2 (db_model.num_unblk_files)), 17));
      447 	bit_36_temp = db_model.num_unblk_files;
      448 
      449 /* add a file_info to the db_model for this file */
      450 
      451 	call mrds_rst_model_alloc (rsc_ptr, db_model_path, FILE_INFO, fi_ptr);
      452 
      453 	if fi_ptr ^= null () then
      454 	     ;
      455 	else if rsc.model_overflow then
      456 	     ;					/* reported first time only */
      457 	else do;
      458 		rsc.model_overflow = ON;
      459 		call
      460 		     ioa_$rs ("^a^a^a^a ^a", message, message_length, "File """,
      461 		     file.name, """", line_number (),
      462 		     "caused an overflow of the db_model while processing the file_info.")
      463 		     ;
      464 		call
      465 		     mrds_rst_error (rsc_ptr, 2 /* severity */,
      466 		     mrds_error_$rst_model_limit, (message));
      467 	     end;
      468 
      469 	gl.file_info_ptr = fi_ptr;
      470 	gl.item_info_ptr = fi_ptr;
      471 
      472 	if error_mode then
      473 	     name_of_file = unique_chars_ ("0"b);	/* use dummy name if previous error */
      474 	else name_of_file = rtrim (file.name);
      475 	file_model_path = rtrim (rsc.temp_dir) || ">" || name_of_file || ".m";
      476 
      477 	if fi_ptr = null () then
      478 	     ;					/* due to model overflow */
      479 	else do;
      480 
      481 		file_info.file_name = name_of_file;
      482 		file_info.file_id = "000000000000000000000000000000000001"b;
      483 
      484 /* link into file_info list in order */
      485 
      486 		file_info.fwd_ptr, file_info.unused = NULL_OFFSET;
      487 
      488 		if db_model.file_ptr = NULL_OFFSET then
      489 		     db_model.file_ptr = rel (fi_ptr);
      490 		else do;
      491 			if stmt (directive.type).file.number > 0 then
      492 			     ;			/* not first time */
      493 			else do;			/* first time, get list end */
      494 				last_fi_ptr = pointer (dbm_ptr, db_model.file_ptr);
      495 				do while (last_fi_ptr -> file_info.fwd_ptr ^= NULL_OFFSET);
      496 				     last_fi_ptr =
      497 					pointer (dbm_ptr, last_fi_ptr -> file_info.fwd_ptr);
      498 				end;
      499 			     end;
      500 			last_fi_ptr -> file_info.fwd_ptr = rel (fi_ptr); /* set list end as new file_info */
      501 		     end;
      502 		last_fi_ptr = fi_ptr;
      503 
      504 	     end;
      505 
      506 /* get a segment for a file_model for this file */
      507 
      508 	call
      509 	     mrds_rst_get_seg_ptr (rsc_ptr,
      510 	     rsc.h_n_seg_info_ls_ptr /* put in new model list */,
      511 	     name_of_file || ".m" /* file_model name */, ON /* create seg */,
      512 	     fm_ptr, error_code);
      513 
      514 	if error_code ^= 0 then do;
      515 		call
      516 		     ioa_$rs ("^a^a^a", message, message_length,
      517 		     "Unable to make segment for file model of file """, name_of_file,
      518 		     """.");
      519 		call mrds_rst_error (rsc_ptr, 4 /* severity */, error_code, (message));
      520 	     end;
      521 	else do;
      522 
      523 /* initialize the file model */
      524 
      525 		call file_model_init ();
      526 		gl.superior_assigned = ON;		/* file model for file present */
      527 		gl.file_model_ptr = fm_ptr;
      528 
      529 	     end;
      530 
      531      end;
      532 
      533 file_model_init:
      534      procedure ();
      535 						/* fill in file parameters with initial values */
      536 
      537 	like_file_model = init_file_model;		/* init model */
      538 	file_model.fi_ptr = rel (fi_ptr);		/* offset in db_model of file_info */
      539 	file_model.changer_ptr = db_model.changer_ptr;	/* get person.project and system time */
      540 	file_model.fm_area = empty ();		/* initailize file_model area */
      541 
      542      end;
      543 
      544 load_rel_info:
      545      procedure ();
      546 
      547 /* routine to allocate and initialize the rel_info structure for
      548*   the current relation in this file, using the file model area,
      549*   and updating the file_model and global file element as necessary */
      550 
      551 	call mrds_rst_model_alloc (rsc_ptr, file_model_path, REL_INFO, ri_ptr);
      552 
      553 	if ri_ptr ^= null then
      554 	     rel_gl_ptr -> gl.complete = ON;		/* rel_info present now */
      555 	else if rsc.model_overflow then
      556 	     ;					/* reported only first time */
      557 	else do;
      558 		rsc.model_overflow = ON;
      559 		call
      560 		     ioa_$rs ("^a^a^a^a ^a^a^a", message, message_length, "File """,
      561 		     file.name, """", line_number (),
      562 		     "caused an overflow of the file_model while processing the relation """
      563 		     , relation.name, """.");
      564 		call
      565 		     mrds_rst_error (rsc_ptr, 2 /* severity */,
      566 		     mrds_error_$rst_model_limit, (message));
      567 	     end;
      568 
      569 	rel_gl_ptr -> gl.item_info_ptr = ri_ptr;	/* set rel_info in rel global element */
      570 	sl.item_info_ptr = ri_ptr;			/* set rel_info in file's rel sublist element */
      571 
      572 /* update the relation count */
      573 
      574 	if ri_ptr = null () then
      575 	     ;
      576 	else do;
      577 
      578 		db_model.num_rels = db_model.num_rels + 1;
      579 
      580 /* initialize relation detailed information */
      581 
      582 		rel_info = init_rel_info;		/* copy template */
      583 		rel_info.name = relation.name;
      584 		rel_info.changer_ptr = file_model.changer_ptr;
      585 		bit_36_temp = db_model.num_rels;
      586 
      587 		file_model.rel_ptr = rel (ri_ptr);
      588 
      589 	     end;
      590 
      591      end;
      592 
      593 load_attr_infos:
      594      procedure ();
      595 
      596 /* routine to allocate and initialize the attr_info structures for
      597*   the attributes in the current relation, using the file model area,
      598*   updating the file_model and rel_info and global list elements as necessary to reflect the additions */
      599 
      600 	root_ptr = rel_gl_ptr -> gl.item_sub_list_ptr;	/* start of attr list for this relation */
      601 	all_attributes_used = OFF;			/* not all attrs added to rel yet */
      602 	current_definition_order = 1;
      603 
      604 /* run through all attributes in this relation */
      605 
      606 	do while (^all_attributes_used);
      607 
      608 	     if ^definition_order_found () then
      609 		all_attributes_used = ON;
      610 	     else do;
      611 
      612 /* get needed pointers */
      613 
      614 		     di_ptr = attr_gl_ptr -> gl.other_info_ptr; /* get attribute's domain info pointer */
      615 		     dom_sl_ptr = attr_gl_ptr -> gl.item_info_ptr; /* corres domain sublist for attr */
      616 
      617 /* now get space for a new attr_info for this attribute for this relation */
      618 
      619 		     call
      620 			mrds_rst_model_alloc (rsc_ptr, file_model_path, ATTR_INFO,
      621 			ai_ptr);
      622 		     if ai_ptr ^= null then
      623 			attr_gl_ptr -> gl.complete = ON; /* attr_info present */
      624 		     else if ^rsc.model_overflow then do;
      625 			     rsc.model_overflow = ON; /* so only first overflow reported */
      626 			     call
      627 				ioa_$rs ("^a^a^a^a ^a^a^a^a^a", message, message_length,
      628 				"File """, file.name, """", line_number (),
      629 				"caused an overflow of the file_model while processing attribute """
      630 				, attr_gl_ptr -> gl.name, """ in relation """,
      631 				rel_gl_ptr -> gl.name, """.");
      632 			     call
      633 				mrds_rst_error (rsc_ptr, 2 /* severity */,
      634 				mrds_error_$rst_model_limit, (message));
      635 			end;
      636 
      637 /* update global list entries */
      638 
      639 		     rel_sl_ptr -> sl.item_info_ptr = ai_ptr; /* set attr_info in rel's attr sublist element
      640*						   this can be used now to get the fm_ptr via pointer(ai_ptr,0)
      641*						   and the fi_ptr via pointer(fm_ptr, file_model.fi_ptr) */
      642 		     if attr_sl_ptr ^= null () then do;
      643 			     attr_sl_ptr -> sl.item_info_ptr = ri_ptr; /* set rel_info in attr's rel sublist element */
      644 			     attr_sl_ptr -> sl.old_other_info_ptr = ai_ptr;
      645 						/* set attr_info ptr for this rel */
      646 			end;
      647 		     if dom_sl_ptr = null () then
      648 			;
      649 		     else dom_sl_ptr -> sl.item_info_ptr = ai_ptr; /* set attr_info in domain's attr sublist */
      650 
      651 /* fill in the attr_info structure for this attribute */
      652 
      653 		     call set_attr_info ();
      654 
      655 		end;
      656 
      657 /* go to the next attribute in user defined order */
      658 
      659 	     current_definition_order = current_definition_order + 1;
      660 	end;
      661      end;
      662 
      663 set_attr_info:
      664      procedure ();
      665 
      666 /* routine to fill in the attr_info structure details */
      667 
      668 /* count up number of attributes */
      669 
      670 	if ai_ptr = null () then
      671 	     ;
      672 	else do;
      673 		rel_info.num_attr = rel_info.num_attr + 1;
      674 		if ^attribute.pr_key then
      675 		     ;
      676 		else rel_info.num_key_attrs = rel_info.num_key_attrs + 1;
      677 
      678 		if rel_info.num_attr > mrds_data_$max_attributes & ^rsc.max_attrs
      679 		then do;
      680 			rsc.max_attrs = ON;
      681 			call
      682 			     ioa_$rs ("^a^a^a^a^a ^d^a", message, message_length,
      683 			     "Attribute """, attr_gl_ptr -> gl.name, """ in relation """,
      684 			     rel_gl_ptr -> gl.name,
      685 			     """ exceeded the maxmimum number of attributes allowed per relation of"
      686 			     , mrds_data_$max_attributes, ".");
      687 			call
      688 			     mrds_rst_error (rsc_ptr, 2 /* severity */,
      689 			     mrds_error_$max_attributes, (message));
      690 		     end;
      691 
      692 
      693 
      694 /* initialize attr_info structure */
      695 
      696 		attr_info.name = attribute.name;
      697 		attr_info.changer_ptr = file_model.changer_ptr;
      698 		attr_info.key_attr = attribute.pr_key;	/* ON => primary key */
      699 		attr_info.index_attr = OFF;		/* not involved in indexes or links yet */
      700 		attr_info.link_attr = OFF;
      701 		attr_info.reserved = OFF;
      702 		attr_info.index_id = OFF;
      703 		attr_info.defn_order = attribute.defn_order;
      704 		attr_info.key_order = attribute.key_order;
      705 		attr_info.link_par_cnt, attr_info.link_child_cnt = 0;
      706 		attr_info.rslt_ptr = NULL_OFFSET;	/* off for  mrds */
      707 
      708 /* compute attribute bit offset and length, update rel_info max data length,
      709*   and number/offset of varying attributes, and the average tuple size,
      710*   also set the attribute and global list domain info pointers */
      711 
      712 		call compute_bit_offset_and_length ();	/* sets average_tuple_length */
      713 
      714 /* link the attr_info into the list in definition order */
      715 
      716 		current_ai_ptr = pointer (fm_ptr, rel_info.attr_ptr);
      717 		last_ai_ptr = null ();
      718 		place_not_found = ON;
      719 
      720 /* find the right list position according to definition order */
      721 
      722 		do while (place_not_found);
      723 		     if rel (current_ai_ptr) = NULL_OFFSET then
      724 			place_not_found = OFF;
      725 		     else if current_ai_ptr -> attr_info.defn_order
      726 			     >= attr_info.defn_order then
      727 			place_not_found = OFF;
      728 		     else do;
      729 			     last_ai_ptr = current_ai_ptr;
      730 			     current_ai_ptr =
      731 				pointer (fm_ptr, current_ai_ptr -> attr_info.fwd_thread);
      732 			end;
      733 		end;
      734 
      735 /* set this attr_info's forward pointer */
      736 
      737 		if current_ai_ptr = null () then
      738 		     attr_info.fwd_thread = NULL_OFFSET;
      739 		else attr_info.fwd_thread = rel (current_ai_ptr);
      740 
      741 /* set previous pointer to this attr_info */
      742 
      743 		if last_ai_ptr = null () then
      744 		     rel_info.attr_ptr = rel (ai_ptr);
      745 		else last_ai_ptr -> attr_info.fwd_thread = rel (ai_ptr);
      746 	     end;
      747 
      748      end;
      749 
      750 definition_order_found:
      751      procedure () returns (bit (1));
      752 
      753 /* this routine determines if the current definition order
      754*   correspondes to any in the sublist of attrs for this relation */
      755 
      756 	node_ptr = root_ptr;			/* convention for first on list */
      757 	found = OFF;
      758 	required_order_found = OFF;
      759 	do while (^found);
      760 
      761 	     call get_definition_order (order_was_obtained, order_obtained);
      762 	     if ^order_was_obtained then do;
      763 		     found = ON;
      764 		     required_order_found = OFF;
      765 		end;
      766 	     else if current_definition_order ^= order_obtained then
      767 		;
      768 	     else do;
      769 		     found = ON;
      770 		     required_order_found = ON;
      771 		end;
      772 
      773 	end;
      774 
      775 	return (required_order_found);
      776 
      777 
      778 	declare required_order_found	 bit (1);		/* on => current order is in list */
      779 	declare found		 bit (1);		/* on => exit loop, else keep looking */
      780 	declare order_was_obtained	 bit (1);		/* on => given order was in list */
      781 	declare order_obtained	 fixed bin;	/* order found during get next order */
      782 
      783      end;
      784 
      785 get_definition_order:
      786      procedure (found, order_found);
      787 
      788 /* get the definition order of the next attribute in the relation's attr sublist */
      789 
      790 	call
      791 	     mrds_rst_tree_successor (root_ptr, node_ptr, successor_ptr,
      792 	     successor_parent_ptr, found);
      793 	if ^found then
      794 	     order_found = 0;
      795 	else do;
      796 
      797 		node_ptr = successor_ptr;		/* make it the current one */
      798 		rel_sl_ptr = node_ptr -> node.data;	/* get rel sublist pointer */
      799 		attr_gl_ptr = rel_sl_ptr -> sl.global_list_ptr; /* get global attr pointer */
      800 		call
      801 		     list_search (relation.name, attr_gl_ptr -> gl.item_sub_list_ptr,
      802 		     attr_sl_ptr, ATTR_SL);
      803 		attribute_ptr = rel_sl_ptr -> sl.parse_info_ptr; /* get parse information */
      804 		order_found = attribute.defn_order;
      805 
      806 	     end;
      807 
      808 
      809 	declare order_found		 fixed bin;	/* definition order of next attribute */
      810 	declare found		 bit (1);		/* on => attr found, else none left */
      811 
      812      end;
      813 
      814 list_search:
      815      procedure (key, root_ptr, data_ptr, success);
      816 
      817 /* routine to get an element pointer from the global lists */
      818 
      819 	call mrds_rst_tree_search (key, root_ptr, node_ptr, parent_ptr, success);
      820 
      821 	if success then
      822 	     data_ptr = node_ptr -> node.data;
      823 	else do;
      824 		call
      825 		     ioa_$rs ("^a^a^a", message, message_length,
      826 		     "LOGIC ERROR in mrds_rst_file_handler, the name """, key,
      827 		     """ was found in a global list, but not in the corresponding sublist"
      828 		     );
      829 		call
      830 		     mrds_rst_error (rsc_ptr, 4 /* severity */,
      831 		     mrds_error_$rst_logic_error, (message));
      832 		data_ptr = null ();
      833 	     end;
      834 
      835 	declare key		 char (32) aligned; /* name to look for in list */
      836 	declare root_ptr		 ptr;		/* head of desired list */
      837 	declare node_ptr		 ptr;		/* pointer to head portion of list element */
      838 	declare parent_ptr		 ptr;		/* pointer to tree parent of found node */
      839 	declare data_ptr		 ptr;		/* pointer to data portion of list element */
      840 	declare success		 bit (1);		/* ON => element found */
      841 
      842      end;
      843 
      844 compute_bit_offset_and_length:
      845      procedure ();
      846 
      847 /* routine to convert the attribute's domain descriptor into
      848*   the required tuple offset and space required and update the
      849*   corresponding statistics for the relation information
      850*   NOTE: the padding routines were introduced to make the data stored
      851*   in the tuple(via bit offset/length) relect the pl1 definition
      852*   of storage locations needed for unaligned and aligned data types */
      853 
      854 	attr_info.bit_length = get_domain_bit_size ();	/* also sets domain_info ptr in attr_info */
      855 
      856 /* fixed length attribute/domain handling */
      857 
      858 	if ^varying_string then do;			/* fixed attributes */
      859 		padding =
      860 		     mdbm_util_$align_data_item (desc_ptr, rel_info.var_offset - 1);
      861 		attr_info.bit_offset = rel_info.var_offset + padding;
      862 						/* set to end of fixed data */
      863 		rel_info.var_offset =
      864 		     rel_info.var_offset + attr_info.bit_length + padding;
      865 						/* set new fixed data end */
      866 		rel_info.avg_data_len =
      867 		     rel_info.avg_data_len + attr_info.bit_length + padding;
      868 						/* average = max for fixed */
      869 	     end;
      870 
      871 /* varying string handling */
      872 
      873 	else do;					/* varying strings */
      874 		rel_info.nvar_atts = rel_info.nvar_atts + 1; /* count up varying attributes */
      875 		attr_info.bit_offset = rel_info.nvar_atts; /* varying array index, not offset */
      876 		rel_info.avg_data_len =
      877 		     rel_info.avg_data_len + average_varying_length
      878 		     + pad (WORD, average_varying_length); /* use average for varying */
      879 		padding = pad (WORD, attr_info.bit_length); /* varying must start/stop on word boundary */
      880 	     end;
      881 
      882 /* set the maximum tuple and key bit lengths */
      883 
      884 	rel_info.max_data_len =
      885 	     rel_info.max_data_len + attr_info.bit_length + padding;
      886 	if ^attribute.pr_key then
      887 	     ;
      888 	else rel_info.max_key_len = rel_info.max_key_len + attr_info.bit_length;
      889 
      890 
      891      end;
      892 
      893 get_domain_bit_size:
      894      procedure () returns (fixed binary (35));
      895 
      896 /* calculate the amount of storage that needs to be allocated(in bits)
      897*   to hold a converted value that has the same type as the domain */
      898 
      899 	varying_string = OFF;
      900 
      901 /* set attributes domain info pointer */
      902 
      903 	if di_ptr = null () then do;
      904 		attr_info.domain_ptr = NULL_OFFSET;
      905 		domain_bit_length = 1;		/* set dummy domain size */
      906 		attr_gl_ptr -> gl.consistant = OFF;	/* no domain info present for attribute */
      907 		desc_ptr = null ();
      908 	     end;
      909 	else do;					/* good domain present */
      910 
      911 		attr_info.domain_ptr = rel (di_ptr);
      912 		attr_gl_ptr -> gl.other_info_ptr = di_ptr; /* set domain_info in attr global element */
      913 		rel_sl_ptr -> sl.new_other_info_ptr = di_ptr; /* set domain_info in rel sublist for attr */
      914 		desc_ptr = addr (domain_info.db_desc);	/* get descriptor for this attribute */
      915 
      916 /* set bit length according to this domain's data type, and average length of varying strings */
      917 
      918 		domain_bit_length =
      919 		     mdbm_util_$get_data_bit_length (desc_ptr -> descriptor_bit_36_ovrly)
      920 		     ;
      921 
      922 /* set varying strings average bit length */
      923 
      924 		if descriptor.type = 20 then do;	/* bit varying */
      925 			varying_string = ON;
      926 			average_varying_length = domain_info.ave_len + 36;
      927 		     end;
      928 		else if descriptor.type = 22 then do;	/* char varying */
      929 			varying_string = ON;
      930 			average_varying_length = (domain_info.ave_len * 9) + 36;
      931 		     end;
      932 		else ;				/* not varying string */
      933 
      934 	     end;
      935 
      936 	return (domain_bit_length);
      937 
      938 
      939 	declare domain_bit_length	 fixed binary (35); /* required bit length to store domain's data */
      940 
      941      end;
      942 
      943 pad:
      944      procedure (pad_size, pad_base) returns (fixed bin);
      945 
      946 /* routine to return the number of bits necessary to pad a bit count
      947*   out to an alignment boundary of 9(byte), 36(word), or 72(double word) bits
      948*   as determined by the pad size input */
      949 
      950 	if mod (pad_base, pad_size) = 0 then
      951 	     number_of_bits = 0;
      952 	else do;
      953 
      954 		number_of_bits = pad_size - mod (pad_base, pad_size);
      955 
      956 	     end;
      957 
      958 	return (number_of_bits);
      959 
      960 
      961 	declare pad_size		 fixed bin;	/* either 9 or 36 or 72 */
      962 	declare pad_base		 fixed bin (35);	/* current bit length to be padded */
      963 	declare number_of_bits	 fixed bin;	/* what has to be added to get to the desired boundary */
      964 
      965      end;
      966 
      967 align_varying_tuple_data:
      968      procedure ();
      969 
      970 /* varying attributes in the tuple must start on a word boundary,
      971*   this routine makes sure that the end of the fixed data portion of the
      972*   tuple, which is where the varying attributes start, is on that boundary */
      973 
      974 	if rel_info.nvar_atts = 0 then
      975 	     ;
      976 	else do;
      977 
      978 		amount_to_pad = pad (WORD, rel_info.var_offset - 1);
      979 		rel_info.var_offset = rel_info.var_offset + amount_to_pad;
      980 		rel_info.max_data_len = rel_info.max_data_len + amount_to_pad;
      981 		rel_info.avg_data_len = rel_info.avg_data_len + amount_to_pad;
      982 
      983 	     end;
      984 
      985 
      986 	declare amount_to_pad	 fixed bin;	/* bits needed for word alignment */
      987 
      988      end;
      989 
      990 check_file_size_and_number:
      991      procedure ();
      992 
      993 /* routine to check that the number of files and/or
      994*   the maximum number of file tuples don't
      995*   exceed implementation limits based on the mdbm_tuple_id.incl.pl1 constants */
      996 
      997 	file_id_space = db_model.unblk_file_id_len;	/* already set to max(file_id_len, ceil(log2(num_files))) */
      998 	db_model.max_max_tuples = max (db_model.max_max_tuples, max_tuples);
      999 						/* get max across all files so far */
     1000 	if db_model.max_max_tuples = 0 then
     1001 	     tuple_id_space = 0;
     1002 	else tuple_id_space = ceil (log2 (db_model.max_max_tuples));
     1003 	vfile_component_space = ceil (log2 (max_vfile_components));
     1004 
     1005 /* try to pad the file_id_space out to mrds_data_$file_id_len_pad
     1006*   to make room for restructuring to add files wihtout causing the
     1007*   reformatting of all files in the database due to an overflow of the
     1008*   existing db_model.file_id_len space allotted */
     1009 
     1010 /*	     if file_type = BLOCKED then
     1011*   blocked_check = ON ;
     1012*   else blocked_check = OFF ;
     1013*   first_time = ON ;
     1014*   space_left_to_pad = ON ;
     1015*   do while (space_left_to_pad) ;
     1016*
     1017*   if (blocked_check & (file_id_space + tuple_id_space <= 34)) |
     1018*   (^blocked_check & (file_id_space + vfile_component_space <= 17)) then do ;
     1019*
     1020*   /* last space usage within limits, try to get another
     1021*   bit for the file_id_space to occupy * /
     1022*
     1023*   if file_id_space < mrds_data_$file_id_len_pad then
     1024*   file_id_space = file_id_space + 1 ; /* can add bit since within needed space guess * /
     1025*   else space_left_to_pad = OFF ;
     1026*   end ;
     1027*
     1028*   else if ^first_time then do ;
     1029*
     1030*   /* we padded too much, back off one bit and use that * /
     1031*
     1032*   file_id_space = file_id_space - 1 ;
     1033*   space_left_to_pad = OFF ;
     1034*   end ;
     1035*
     1036*   else do ;
     1037*
     1038*   /* not enough space on the first try with minimrdsm sizes * /
     1039*
     1040*   space_left_to_pad = OFF ; */
     1041 
     1042 	file_id_space = ceil (log2 (mrds_data_$max_relations)) + 1;
     1043 
     1044 	if db_model.num_blk_files + db_model.num_unblk_files
     1045 	     > mrds_data_$max_relations then do;
     1046 
     1047 
     1048 		if rsc.max_files then
     1049 		     ;				/* only give error first time */
     1050 		else do;
     1051 			rsc.max_files = ON;
     1052 			call
     1053 			     ioa_$rs ("^a^a^a^a ^a ^d ^a", message, message_length,
     1054 			     "The file """, file.name, """", line_number (),
     1055 			     "was unblocked file number", db_model.num_unblk_files,
     1056 			     "and exceeded the maximum number of unblocked files allowed."
     1057 			     );
     1058 			call
     1059 			     mrds_rst_error (rsc_ptr, 2 /* severity */,
     1060 			     mrds_error_$rst_option_limit, (message));
     1061 		     end;
     1062 	     end;
     1063 
     1064 
     1065 /* save the possibly bigger file_id_space calculated */
     1066 
     1067 	db_model.unblk_file_id_len = file_id_space;
     1068 
     1069 
     1070 
     1071 	declare file_id_space	 fixed binary;	/* bit length of file id */
     1072 	declare tuple_id_space	 fixed binary;	/* bit length of tuple maximum */
     1073 	declare vfile_component_space	 fixed binary;	/* bit length of max vfile components */
     1074 	declare max_vfile_components	 fixed binary init (900); /* max no of comps */
     1075 
     1076      end;
     1077 
     1078 check_relation_key_length:
     1079      procedure ();
     1080 
     1081 /* make sure that the data length of the attributes
     1082*   that make up the primary key for this relation do not
     1083*   exceed the implementation restriction maximum */
     1084 
     1085 	key_length_in_chars = ceil (rel_info.max_key_len / 9);
     1086 
     1087 	if key_length_in_chars <= mrds_data_$max_key_len then
     1088 	     ;
     1089 	else do;
     1090 
     1091 		call
     1092 		     ioa_$rs ("^a^a^a ^d ^a^a^a ^d ^a ^d ^a", message, message_length,
     1093 		     "The relation """, relation.name, """ on line", relation.line_num,
     1094 		     "given in file """, file.name,
     1095 		     """ has a primary key data length of", key_length_in_chars,
     1096 		     "characters, which is greater than the allowed maximum length of",
     1097 		     mrds_data_$max_key_len, "characters.");
     1098 		call
     1099 		     mrds_rst_error (rsc_ptr, 2 /* severity */, mrds_error_$long_key,
     1100 		     (message));
     1101 
     1102 	     end;
     1103 
     1104 
     1105      end;
     1106 
     1107 line_number:
     1108      procedure () returns (char (20) varying);
     1109 
     1110 /* return null string for default files,
     1111*   or the line occurence for files from the source */
     1112 
     1113 	if file.default then
     1114 	     returned_line = "";
     1115 	else returned_line = ", on line " || ltrim (char (file.line_num)) || ",";
     1116 
     1117 	return (returned_line);
     1118 
     1119 
     1120 	declare returned_line	 char (20) varying;
     1121 
     1122      end;
     1123 
     1124 	declare name_of_file	 char (30) varying; /* name to add .m to for model seg */
     1125 	declare db_model_path	 char (168);	/* path name to db_model */
     1126 	declare file_model_path	 char (200);	/* path name down to file_model */
     1127 	declare mrds_rst_rsc_alloc	 entry (ptr, fixed bin, ptr); /* work area manager */
     1128 	declare mrds_rst_model_alloc	 entry (ptr, char (*), fixed bin, ptr);
     1129 						/* model allocation routine */
     1130 
     1131 	declare unique_chars_	 entry (bit (*)) returns (char (15)); /* unique character generator */
     1132 	declare error_mode		 bit (1);		/* ON => duplicate file name processing fixup */
     1133 	declare mrds_rst_tree_successor entry (ptr, ptr, ptr, ptr, bit (1));
     1134 						/* get next routine */
     1135 	declare attr_gl_ptr		 ptr;		/* pointer to attribute global element */
     1136 	declare dom_sl_ptr		 ptr;		/* pointer to corres attribute domain sublist element */
     1137 	declare rel_sl_ptr		 ptr;		/* pointer to relation sublist element */
     1138 	declare attr_sl_ptr		 ptr;		/* pointer to attribute sublist element */
     1139 	declare ATTR_SL		 bit (1);		/* ON => pointer found for attr_sl_ptr */
     1140 						/* init path/entry value */
     1141 	declare file_name		 char (30);	/* file name for this call */
     1142 	declare (addr, ceil, char, log2, empty, fixed, ltrim, max, mod, null, pointer, rel, rtrim)
     1143 				 builtin;		/* functions known to pl1 */
     1144 	declare ON		 bit (1) internal static options (constant) init ("1"b);
     1145 						/* true value */
     1146 	declare OFF		 bit (1) internal static options (constant) init ("0"b);
     1147 						/* false value */
     1148 	declare NULL_OFFSET		 bit (18) internal static options (constant)
     1149 				 init ((18)"1"b);	/* db version of null offset */
     1150 	declare sys_info$max_seg_size	 fixed bin (35) external; /* system constant */
     1151 	declare mrds_rst_get_seg_ptr
     1152 				 entry (ptr, ptr, char (32) aligned, bit (1), ptr, fixed bin (35));
     1153 						/* ON => get new segment */
     1154 	declare error_code		 fixed binary (35); /* mrds_error_ table index */
     1155 	declare message		 char (320) varying;/* specifics of error message */
     1156 	declare message_length	 fixed bin (21);	/* length of specifics message */
     1157 	declare last_fi_ptr		 ptr internal static; /* saved file_info pointer */
     1158 	declare last_ai_ptr		 ptr;		/* saved attr_info pointer */
     1159 	declare current_ai_ptr	 ptr;		/* pointer to present attr_info in list */
     1160 	declare place_not_found	 bit (1);		/* definition order insertion place flag */
     1161 	declare mrds_error_$rst_model_limit fixed bin (35) external;
     1162 						/* model capacity exceeded */
     1163 	declare mrds_error_$long_key	 fixed bin (35) external; /* max key length exceeded */
     1164 	declare mrds_error_$rst_option_limit fixed bin (35) external;
     1165 						/* exceeded allowable for option */
     1166 	declare mrds_error_$rst_undone_option fixed bin (35) external;
     1167 						/* option not coded yet */
     1168 	declare mrds_error_$rst_undef_rel fixed bin (35) external; /* item not in database */
     1169 	declare mrds_error_$rst_dup_file fixed bin (35) external; /* duplicate attr definition */
     1170 	declare mrds_error_$rst_rel_has_file fixed bin (35) external;
     1171 						/* file assigned to relation */
     1172 	declare mrds_error_$rst_logic_error fixed bin (35) ext; /* program failure */
     1173 	declare max_tuples		 fixed binary (71); /* file's accumulated max tuples */
     1174 	declare mrds_data_$max_key_len fixed bin (35) ext;/* implementation restriction on key size */
     1175 	declare key_length_in_chars	 fixed bin (35);	/* computed character length of relation key */
     1176 	declare mrds_rst_tree_search	 entry (char (32) aligned, ptr, ptr, ptr, bit (1));
     1177 						/* list searcher */
     1178 	declare mrds_rst_error	 entry (ptr, fixed bin, fixed bin (35), char (*));
     1179 						/* general error handler */
     1180 	declare ioa_$rs		 entry options (variable); /* string manipulator */
     1181 	declare mrds_rst_list_element$add
     1182 				 entry (char (32) aligned, fixed binary, ptr, ptr, ptr,
     1183 				 fixed bin (35));
     1184 	declare list_ptr		 ptr;		/* pointer to parse info list */
     1185 	declare IN		 bit (1) internal static options (constant) init ("1"b);
     1186 						/* input meter flag */
     1187 	declare OUT		 bit (1) internal static options (constant) init ("0"b);
     1188 						/* output meter flag */
     1189 	declare mrds_rst_meter	 entry (ptr, char (*), bit (1), char (*));
     1190 						/* metering/tracing routine */
     1191 	declare rel_gl_ptr		 ptr;		/* temp storage for relation global element pointer */
     1192 	declare average_varying_length fixed bin (35);	/* average varying string bit length */
     1193 	declare varying_string	 bit (1);		/* ON => varying string type attribute */
     1194 	declare bit_36_temp		 fixed bin (35) aligned; /* 36 bit word to overlay */
     1195 	declare BYTE		 fixed bin init (9);/* byte boundary = 9 bits */
     1196 	declare WORD		 fixed bin init (36); /* word boundary = 36 bits */
     1197 	declare DOUBLE_WORD		 fixed bin init (72); /* double word boundary = 72 bits */
     1198 	declare padding		 fixed bin;	/* amount needed to pad to a given boundary */
     1199 	declare current_definition_order fixed bin;	/* definition order for current attr */
     1200 	declare all_attributes_used	 bit (1);		/* on => all rel attrs processed */
     1201 	declare mdbm_util_$get_data_bit_length entry (bit (36))
     1202 				 returns (fixed bin (35)); /* gets storage bits from descriptor */
     1203 	declare descriptor_bit_36_ovrly bit (36) based;	/* overlay for descriptor */
     1204 	declare mdbm_util_$align_data_item entry (ptr, fixed bin (35))
     1205 				 returns (fixed bin); /* aligns to data type boundary,
     1206*						   given current offset */
     1207 	declare mrds_error_$rst_reserved_name fixed bin (35) ext; /* reserved name used */
     1208 	declare mrds_data_$max_relations fixed bin (35) ext; /* most relations can create */
     1209 	declare mrds_data_$max_attributes fixed bin (35) ext; /* max attrs allowed per rel */
     1210 	declare mrds_error_$max_attributes fixed bin (35) ext; /* > mrds_data_$max_attrs seen */
     1211 
  1     1 /* BEGIN INCLUDE FILE mrds_rst_struct_types.incl.pl1 - - Jim Gray 2/20/79 */
  1     2 
  1     3 /* these constants are used to identify structures to be allocated
  1     4*   to the general purpose allocation routines */
  1     5 
  1     6 /*  HISTORY:
  1     7*    82-06-28 Roger Lackey : Removed struct types 52, 53, 54, 55, 56, 57, 58
  1     8*    Type 25 is no longer used and is handled with special code so bounds of 
  1     9*    array could continue to work */
  1    10 
  1    11 /* PARSE INFO STRUCTURES */
  1    12 
  1    13 declare  DOMAIN fixed bin internal static options (constant) init (1) ;
  1    14 declare  ATTRIBUTE_DOMAIN fixed bin internal static options (constant) init (2) ;
  1    15 declare  RELATION fixed bin internal static options (constant) init (3) ;
  1    16 declare  ATTRIBUTE fixed bin internal static options (constant) init (4) ;
  1    17 declare  FILE fixed bin internal static options (constant) init (5) ;
  1    18 declare  ITEM fixed bin internal static options (constant) init (6) ;
  1    19 declare  LINK fixed bin internal static options (constant) init (7) ;
  1    20 declare  FOREIGN_KEY fixed bin internal static options (constant) init (8) ;
  1    21 declare  CHILDREN fixed bin internal static options (constant) init (9) ;
  1    22 declare  INDEX fixed bin internal static options (constant) init (10) ;
  1    23 declare  DELETE_NAME fixed bin internal static options (constant) init (11) ;
  1    24 declare  DOM_LIST fixed bin internal static options (constant) init (12) ; /* in link handler */
  1    25 
  1    26 /* SEMANTIC STRUCTURES */
  1    27 
  1    28 declare  DIRECTIVE fixed bin internal static options (constant) init (13) ;
  1    29 declare  STMT fixed bin internal static options (constant) init (14) ;
  1    30 
  1    31 
  1    32 /* PARSING STRUCTURES */
  1    33 
  1    34 declare  LEX_STACK fixed bin internal static options (constant) init (15) ;
  1    35 declare  P_STRUCT fixed bin internal static options (constant) init (16) ;
  1    36 declare  CUR_LEX_TOP fixed bin internal static options (constant) init (17) ;
  1    37 declare  FIXUP_TOKEN fixed bin internal static options (constant) init (50) ; /* scanner */
  1    38 declare  STRING_SOURCE fixed bin internal static options (constant) init (51) ; /* semantics */
  1    39 declare  TOKEN fixed bin internal static options (constant) init (18) ;
  1    40 declare  OUTPUT_TEXT fixed bin internal static options (constant) init (19) ;
  1    41 
  1    42 
  1    43 /* DB_MODEL STRUCTURES */
  1    44 
  1    45 declare  DB_MODEL fixed bin internal static options (constant) init (0) ;
  1    46 declare  FILE_INFO fixed bin internal static options (constant) init (1) ;
  1    47 declare  DOMAIN_INFO fixed bin internal static options (constant) init (2) ;
  1    48 declare  PATH_ENTRY fixed bin internal static options (constant) init (3) ;
  1    49 declare  STACK_ITEM fixed bin internal static options (constant) init (4) ;
  1    50 declare  CONSTANT fixed bin internal static options (constant) init (30) ;
  1    51 declare  VERSION_STATUS fixed bin internal static options (constant) init (5) ;
  1    52 declare  CHANGER fixed bin internal static options (constant) init (6) ;
  1    53 
  1    54 
  1    55 /* FILE_MODEL STRUCTURES */
  1    56 
  1    57 declare  FILE_MODEL fixed bin internal static options (constant) init (7) ;
  1    58 declare  REL_INFO fixed bin internal static options (constant) init (8) ;
  1    59 declare  ATTR_INFO fixed bin internal static options (constant) init (9) ;
  1    60 declare  PARENT_LINK_INFO fixed bin internal static options (constant) init (10) ;
  1    61 declare  CHILD_LINK_INFO fixed bin internal static options (constant) init (11) ;
  1    62 declare  ATTR_LIST fixed bin internal static options (constant) init (12) ;
  1    63 declare  ATD fixed bin internal static options (constant) init (31) ;
  1    64 declare  COMP_NO_ARRAY fixed bin internal static options (constant) init (32) ;
  1    65 declare  SORT_KEY fixed bin internal static options (constant) init (13) ;
  1    66 declare  DUP_PREV fixed bin internal static options (constant) init (14) ;
  1    67 declare  SELECT_CHAIN fixed bin internal static options (constant) init (15) ;
  1    68 
  1    69 
  1    70 /* GLOBAL LIST STRUCTURES */
  1    71 
  1    72 declare  GL fixed bin internal static options (constant) init (20) ;
  1    73 declare  SL fixed bin internal static options (constant) init (21) ;
  1    74 declare  SEGINFO fixed bin internal static options (constant) init (22) ;
  1    75 declare  LIST_OVRLY fixed bin internal static options (constant) init (26) ;
  1    76 declare  SAVED_CHILD_COUNT fixed bin internal static options (constant) init (24) ; /* in global list build */
  1    77 declare  NODE fixed bin internal static options (constant) init (23) ;
  1    78 
  1    79 
  1    80 /* DISPLAY STRUCTURES */
  1    81 
  1    82 declare  DISPLAY_INFO fixed bin internal static options (constant) init (25) ;
  1    83 
  1    84 /*   Remove because nolonger used 82-06-28        
  1    85*  NAME_LIST fixed bin internal static options (constant) init (52) ;
  1    86*  PAI_ARRAY fixed bin internal static options (constant) init (53) ;
  1    87*  PAR_LK_ATTR_INFO fixed bin internal static options (constant) init (54) ;
  1    88*  CAI_ARRAY fixed bin internal static options (constant) init (55) ;
  1    89*  CHILD_LK_ATTR_INFO fixed bin internal static options (constant) init (56) ;
  1    90*  NAME_TABLE fixed bin internal static options (constant) init (57) ;
  1    91*  ATTR_TABLE fixed bin internal static options (constant) init (58) ;
  1    92**/
  1    93 
  1    94 /* END INCULDE FILE mrds_rst_struct_types */
  1    95 
     1212 
  2     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
  2     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
  2     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
  2     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
  2     5 
  2     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
  2     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
  2     8     2 type unsigned fixed bin (6) unal,			/* data type */
  2     9     2 packed bit (1) unal,				/* on if data item is packed */
  2    10     2 number_dims bit (4) unal,			/* dimensions */
  2    11     2 size,					/* size for string data */
  2    12       3 scale bit (12) unal,				/* scale for num. data */
  2    13       3 precision bit (12) unal,			/* prec. for num. data */
  2    14     2 array_info (num_dims),
  2    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
  2    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
  2    17       3 multiplier fixed bin (35);			/*  element separation */
  2    18 
  2    19 dcl  desc_ptr ptr;
  2    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
  2    21 
  2    22 /* END mdbm_descriptor.incl.pl1 */
  2    23 
  2    24 
     1213 
  3     1 /* BEGIN INCLUDE FILE mrds_rst_rsc.incl.pl1		RDL  7/7/78	*/
  3     2 
  3     3 /* Modified 8/21/78 by RDL */
  3     4 
  3     5 /* Modified 9/11/78 	by RDL to add directive and stmt pointers */
  3     6 
  3     7 /* Modified 11/4/78		by RDL to add debug,trace,meter switches
  3     8*
  3     9*   Modified 3/29/79 by RDL to change s_seg_info_ptr to source_seg_ptr
  3    10*
  3    11*   Modified by Jim Gray - - Jan. 1980, to add flags to disallow blocked files, forieng keys, and restructuring.
  3    12*
  3    13*   Modified by Jim Gray - - Feb. 1980, to add command level flag for cmdb subroutine interface.
  3    14*
  3    15*   Modified by Jim Gray - - 80-11-06, to add bit for cmdb -secure option.
  3    16*
  3    17*   81-05-18 Jim Gray : added bit for max_attributes error message, so that
  3    18*   it would only be issued on first occurence.
  3    19*
  3    20*   82-08-19 Davids: added the db_type field.
  3    21*
  3    22*   83-02-18 Mike Kubicar : Removed the db_type field and added the 
  3    23*   db_relation_mode_flags substructure to define the modes applicable
  3    24*   to the database's relations.  Also removed assorted unsed fields
  3    25*   (names that included the word unused).
  3    26*
  3    27**/
  3    28 
  3    29 dcl 1 rsc based (rsc_ptr),				/* Restructuring control info */
  3    30     2 rsc_dir char (200),				/* pathname of directory containing rsc segment */
  3    31     2 dbp char (168),				/* Database absolute path */
  3    32     2 temp_dir char (168),				/* Path name of temp restrucuring directory */
  3    33     2 temp_dir_sw bit (1) unal,			/* On => temp dir has been created */
  3    34     2 db_quiesced_sw bit (1) unal,			/* On => database has been quiesced */
  3    35     2 o_db_open_sw bit (1) unal,			/* On => old database has been opened */
  3    36     2 n_db_open_sw bit (1) unal,			/* On => temp database is open */
  3    37     2 listing_seg_sw bit (1) unal,			/* On => listing segment has been created */
  3    38     2 skip_scanner_conversion bit (1) unal,		/* Skip conversion in scanner */
  3    39     2 cmdb_option bit (1) unal,			/* ON => this is a cmdb source, not restructuring */
  3    40     2 trace_sw bit (1) unal,				/* On -> trace mode in affect */
  3    41     2 debug_sw bit (1) unal,				/* On = debug mode (NOT IMPLEMENTED) */
  3    42     2 meter_sw bit (1) unal,				/* On = procedures call metering procedure */
  3    43     2 delete_db_sw bit (1) unal,			/* On = delete data base in cleanup */
  3    44     2 model_consistent_sw bit (1) unal,			/* On => Model is consistent */
  3    45     2 physical_started_sw bit (1) unal,			/* On => Physical restructuring started */
  3    46     2 physical_complete_sw bit (1) unal,		/* On => Physical restructuring completed */
  3    47     2 model_overflow bit (1) unal,			/* ON => model segment area condition occurred */
  3    48     2 max_files bit (1) unal,				/* ON => maximum number of files reached */
  3    49     2 allow_foreign_keys bit (1) unal,			/* on => allow foreign key statment */
  3    50     2 foreign_key_seen bit (1) unal,			/* on => foreign key definition in source */
  3    51     2 allow_blocked_files bit (1) unal,			/* on => allow file statement with blocked option */
  3    52     2 blocked_file_seen bit (1) unal,			/* on => blocked file definition in source */
  3    53     2 allow_restructuring bit (1) unal,			/* on => allow RMDB entry point */
  3    54     2 command_level bit (1) unal,			/* on => called from command unal, not subroutine level */
  3    55     2 secure bit (1) unal,				/* on => -secure option given for cmdb */
  3    56     2 max_attrs bit (1) unal,				/* on => max attrs/rel or max indexes/rel exceeded */
  3    57     2 db_relation_mode_flags,
  3    58       3 dm_file_type bit (1) unal,			/* on => relations are dm files */
  3    59       3 protection_on bit (1) unal,			/* on => relations need transactions */
  3    60       3 concurrency_on bit (1) unal,			/* on => concurrency control enabled */
  3    61       3 rollback_on bit (1) unal,			/* on => before journalling is enabled */
  3    62     2 severity_high fixed bin,			/* Highest severity level error encountered */
  3    63     2 phase fixed bin,				/* 000 = init
  3    64*						   100 = global list init
  3    65*						   200 = parse
  3    66*						   300 = physical init
  3    67*						   400 = physical */
  3    68     2 h_o_seg_info_ls_ptr ptr,			/* Pointer to head of old db seg_info list */
  3    69     2 h_n_seg_info_ls_ptr ptr,			/* Pointer to head of new db seg_info list */
  3    70     2 h_gfile_ptr ptr,				/* Pointer to head of global file list */
  3    71     2 h_gdom_ptr ptr,				/* Pointer to head of global domain list */
  3    72     2 h_gattr_ptr ptr,				/* Pointer to head of global attribute list */
  3    73     2 h_grel_ptr ptr,				/* Pointer to head of global relation list */
  3    74     2 h_glink_ptr ptr,				/* Pointer to head of global link list */
  3    75     2 o_dm_ptr ptr,					/* Pointer to old data model seg  (dm_model ) */
  3    76     2 n_dm_ptr ptr,					/* Pointer to temp data model seg */
  3    77     2 o_fn_hdr_ptr ptr,				/* Pointer to head of original file list (fn structure) */
  3    78     2 source_seg_ptr ptr,				/* Pointer to source_seg */
  3    79     2 listing_iocb_ptr ptr,				/* Pointer to listing segment iocb */
  3    80     2 directive_ptr ptr,				/* Pointer to directive type str in mrds_rst_semactics.incl.pl1 */
  3    81     2 stmt_ptr ptr,					/* Pointer to statement str in mrds_rst_sematics.incl.pl1 */
  3    82     2 trace_metering_iocb_ptr ptr,			/* Pointer to seg used by trace and metering */
  3    83     2 tree_node_area_ptr ptr,				/* pointer to working storage for tree nodes */
  3    84     2 tree_data,
  3    85       3 seg_info_area_ptr ptr,			/* seg info working storage area */
  3    86       3 gl_area_ptr ptr,				/* global list data work storage area */
  3    87       3 sl_area_ptr ptr,				/* sublist data work storage area */
  3    88     2 parse_info_area_ptr ptr,			/* parse interface work area storage */
  3    89     2 static_info_area_ptr ptr,			/* directive, stmt and other static work storage area */
  3    90     2 variable_length_area_ptr ptr,			/* varibale allocates work storage area */
  3    91     2 other_area_ptr ptr,				/* unspecified work area storage */
  3    92     2 wa area (sys_info$max_seg_size - fixed (rel (addr (rsc.wa))) + 1); /* Work area */
  3    93 
  3    94 dcl  rsc_ptr ptr;					/* Pointer to base of rsc segment */
  3    95 
  3    96 
  3    97 
  3    98 /* END INCLUDE FILE mrds_rst_rsc.incl.pl1				*/
  3    99 
     1214 
  4     1 /* BEGIN INCLUDE FILE mrds_rst_semantics.incl.pl1 jeg 8/31/78 */
  4     2 
  4     3 /* structure to remember what directives have been seen and are active */
  4     4 
  4     5 declare 1 directive based (directive_ptr),
  4     6         2 type fixed binary,				/* stmt structure index for given directive */
  4     7         2 undefine,
  4     8 	3 active bit (1) unal,
  4     9 	3 seen bit (1) unal,
  4    10 	3 pad bit (34) unal,
  4    11         2 define,
  4    12 	3 active bit (1) unal,
  4    13 	3 seen bit (1) unal,
  4    14 	3 pad bit (34) unal,
  4    15         2 redefine,
  4    16 	3 active bit (1) unal,
  4    17 	3 seen bit (1) unal,
  4    18 	3 pad bit (34) unal,
  4    19         2 cmdb,
  4    20 	3 active bit (1) unal,
  4    21 	3 seen bit (1) unal,
  4    22 	3 pad bit (34) unal ;
  4    23 
  4    24 declare  directive_ptr ptr internal static ;
  4    25 
  4    26 /* encoding for directive types */
  4    27 
  4    28 declare  UNDEFINE fixed bin internal static options (constant) init (1) ;
  4    29 declare  DEFINE fixed bin internal static options (constant) init (2) ;
  4    30 declare  REDEFINE fixed bin internal static options (constant) init (3) ;
  4    31 declare  CMDB fixed binary internal static options (constant) init (4) ;
  4    32 
  4    33 
  4    34 /* structure to remember what statements have been seen, are active,
  4    35*   and how many items are in the statement, and how big the list for the last item was */
  4    36 
  4    37 declare 1 stmt (4) based (stmt_ptr),
  4    38         2 domain,
  4    39 	3 active bit (1) unal,
  4    40 	3 pad bit (35) unal,
  4    41 	3 number fixed binary,
  4    42         2 attribute,
  4    43 	3 active bit (1) unal,
  4    44 	3 pad bit (35) unal,
  4    45 	3 number fixed binary,
  4    46         2 relation,
  4    47 	3 active bit (1) unal,
  4    48 	3 pad bit (35) unal,
  4    49 	3 number fixed binary,
  4    50         2 file,
  4    51 	3 active bit (1) unal,
  4    52 	3 pad bit (35) unal,
  4    53 	3 number fixed binary,
  4    54         2 foreign_key,
  4    55 	3 active bit (1) unal,
  4    56 	3 pad bit (35) unal,
  4    57 	3 number fixed binary,
  4    58         2 index,
  4    59 	3 active bit (1) unal,
  4    60 	3 pad bit (35) unal,
  4    61 	3 number fixed binary ;
  4    62 
  4    63 /* NOTE:
  4    64*   active ON => this stmt/directive is currently being processed
  4    65*   seen ON => this stmt/directive was or is being processed
  4    66**/
  4    67 
  4    68 declare  stmt_ptr ptr internal static ;
  4    69 
  4    70 /* END INCLUDE FILE mrds_rst_semantics.incl.pl1 */
  4    71 
     1215 
  5     1 /* BEGIN INCLUDE FILE mrds_rst_parse_info.incl.pl1 -- oris, 6/30/78 */
  5     2 /* modified 9/6/78 -- jeg, for lrk parser - cmdb interface */
  5     3 /* modified 12/20/78 - - jeg, to add line number info for handlers */
  5     4 /* modified 3/15/79 - - jeg, to add scanner, semantic, and link handler variables to be allocated in rsc */
  5     5 /* Modified by Jim Gray - - 23-June-80, to separate max_string_size,
  5     6*   and max_line_size mrds_data_ items. */
  5     7 
  5     8 
  5     9 
  5    10 
  5    11 declare 1 domain aligned based (domain_ptr),
  5    12         2 name char (32),				/* name of this domain */
  5    13         2 descriptor bit (36),			/* Multics pl1 descriptor for domain type */
  5    14         2 varying_avg_length fixed bin (24),		/* average length of varying strings */
  5    15         2 options bit (1) unal,			/* ON => some option is present */
  5    16         2 pad bit (35) unal,
  5    17         2 check,
  5    18 	3 flag bit (1) unal,			/* ON => check option present */
  5    19 	3 pad bit (35) unal,
  5    20 	3 stack_ptr ptr,				/* pointer to postfix stack
  5    21*						   holding boolean expression */
  5    22 	3 stack_size fixed binary,			/* number of stack elements */
  5    23         2 check_proc,
  5    24 	3 flag bit (1) unal,			/* ON => check_proc option is present */
  5    25 	3 pad bit (35) unal,
  5    26 	3 path char (168),				/* check procedure pathname */
  5    27 	3 entry char (32),				/* check procedure entryname */
  5    28         2 encode_proc,
  5    29 	3 flag bit (1) unal,			/* ON => encode_proc option is present */
  5    30 	3 pad bit (35) unal,
  5    31 	3 path char (168),				/* encode procedure pathname */
  5    32 	3 entry char (32),				/* encode procedure entryname */
  5    33         2 decode_proc,
  5    34 	3 flag bit (1) unal,			/* ON => decode_proc option is present */
  5    35 	3 pad bit (35) unal,
  5    36 	3 path char (168),				/* decode procedure pathname */
  5    37 	3 entry char (32),				/* decode procedure entryname */
  5    38         2 decode_dcl,
  5    39 	3 flag bit (1) unal,			/* ON => decode declaration is present */
  5    40 	3 pad bit (35) unal,
  5    41 	3 descriptor bit (36),			/* decode declaration pl1 descriptor */
  5    42         2 line_num fixed bin (24) ;			/* line of domain name in source */
  5    43 
  5    44 
  5    45 declare  domain_ptr ptr ;
  5    46 
  5    47 
  5    48 
  5    49 
  5    50 
  5    51 dcl 1 relation aligned based (relation_ptr),
  5    52     2 a_ptr ptr,					/* ptr to attribute list for this relation */
  5    53     2 name char (32),				/* relation name */
  5    54     2 max_tup fixed bin,				/* maximum tuples for this relation if a blocked file */
  5    55     2 num_items fixed bin,				/* number of attributes in this relation */
  5    56     2 unused bit (36) unal,				/* future flags */
  5    57     2 line_num fixed bin (24) ;			/* line of relation name in source */
  5    58 
  5    59 
  5    60 dcl  relation_ptr ptr;
  5    61 
  5    62 
  5    63 dcl 1 attribute aligned based (attribute_ptr),
  5    64     2 next ptr,					/* ptr to next in list */
  5    65     2 name char (32),				/* name of attribute */
  5    66     2 pr_key bit (1) unal,				/* ON => part of primary key */
  5    67     2 pad bit (35) unal,
  5    68     2 defn_order fixed bin,				/* position within the relation */
  5    69     2 key_order fixed bin,				/* position within the primary key, if a key */
  5    70     2 line_num fixed bin (24) ;			/* line of attribute name in source */
  5    71 
  5    72 
  5    73 dcl  attribute_ptr ptr;
  5    74 
  5    75 
  5    76 
  5    77 dcl 1 attribute_domain aligned based (attdom_ptr),
  5    78     2 attr char (32),				/* attribute name */
  5    79     2 dom char (32),				/* domain name */
  5    80     2 default bit (1) unal,				/* on => defined as default attr, not by source */
  5    81     2 unused bit (35) unal,				/* future flags */
  5    82     2 line_num fixed bin (24) ;			/* line of attribute name in source */
  5    83 
  5    84 dcl  attdom_ptr ptr;				/* ptr to attribute_domain structure */
  5    85 
  5    86 
  5    87 
  5    88 
  5    89 dcl 1 file aligned based (file_ptr),
  5    90     2 i_ptr ptr,					/* ptr to item containing relation name */
  5    91     2 name char (30),				/* file name */
  5    92     2 type fixed bin,				/* blocked or unblocked */
  5    93 						/* type = 1 => unblocked,
  5    94*						   type = 2 => blocked */
  5    95     2 ppb fixed bin,				/* pages per block, if blocked */
  5    96     2 hbh fixed bin,				/* hash bucket headers per block */
  5    97     2 block fixed bin,				/* blocks per hash bucket headers */
  5    98     2 num_items fixed bin,				/* nbr. items -- relations -- in file */
  5    99     2 default bit (1) unal,				/* on => defined as default file, not by source */
  5   100     2 unused bit (35) unal,				/* future flags */
  5   101     2 line_num fixed bin (24) ;			/* line of file name in source */
  5   102 
  5   103 
  5   104 dcl  file_ptr ptr;					/* ptr to file structure */
  5   105 
  5   106 
  5   107 dcl 1 rel_index aligned based (index_ptr),
  5   108     2 i_ptr ptr,					/* ptr. to item containing index attr. name */
  5   109     2 rel_name char (32),				/* name of relation being indexed */
  5   110     2 num_items fixed bin,				/* nbr. items -- attributes -- indexed for a relation */
  5   111     2 unused bit (36) unal,				/* future flags */
  5   112     2 line_num fixed bin (24) ;			/* line of relation name in source */
  5   113 
  5   114 
  5   115 dcl  index_ptr ptr;					/* ptr to index structure */
  5   116 
  5   117 
  5   118 dcl 1 link aligned based (link_ptr),
  5   119     2 parent_ptr ptr,				/* ptr to foreign_key structure cont. parent rel. name */
  5   120     2 children_ptr ptr,				/* ptr. to list of children names for this link */
  5   121     2 clust_fl bit (1) unal,				/* ON => link is clustered in one file */
  5   122     2 pad bit (35) unal,
  5   123     2 name char (32),				/* name of this link */
  5   124     2 num_children fixed bin,				/* number of children for this link's parent */
  5   125     2 line_num fixed bin (24) ;			/* line of link name occurence in source */
  5   126 
  5   127 
  5   128 dcl  link_ptr ptr;					/* ptr to link structure */
  5   129 
  5   130 
  5   131 dcl 1 children aligned based (children_ptr),
  5   132     2 next ptr,					/* ptr to next in list */
  5   133     2 child_ptr ptr;				/* ptr. to foreign_key struct. containing child rel. name */
  5   134 
  5   135 
  5   136 dcl  children_ptr ptr;				/* ptr to children structure */
  5   137 
  5   138 
  5   139 dcl 1 foreign_key aligned based (forkey_ptr),
  5   140     2 i_ptr ptr,					/* ptr to item list containing foreign key attributes */
  5   141     2 rel_name char (32),				/* name of parent/child relation */
  5   142     2 num_items fixed bin,				/* nbr of attributes defining this foreign key */
  5   143     2 unused bit (36) unal,				/* future flags */
  5   144     2 line_num fixed bin (24) ;			/* line of relation occurence in source */
  5   145 
  5   146 
  5   147 dcl  forkey_ptr ptr;				/* ptr to foreign_key structure */
  5   148 
  5   149 
  5   150 dcl 1 item aligned based (item_ptr),
  5   151     2 next ptr,					/* ptr to next item in the list */
  5   152     2 name char (32),				/* name of item -- relation name or attribute name */
  5   153     2 unused bit (36) unal,				/* future flags */
  5   154     2 line_num fixed bin (24) ;			/* line of item occurence in source */
  5   155 
  5   156 
  5   157 dcl  item_ptr ptr;					/* ptr to item structure */
  5   158 
  5   159 
  5   160 declare 1 delete_name aligned based (delete_name_ptr),	/* overlay for  undefine parse information */
  5   161         2 overlay char (32),				/* name portion */
  5   162         2 unused bit (36) unal,			/* future flags */
  5   163         2 line_num fixed bin (24) ;			/* line number of name occurence in source */
  5   164 
  5   165 declare  delete_name_ptr ptr ;
  5   166 
  5   167 /* scanner variables */
  5   168 
  5   169 declare  token char (mrds_data_$max_string_size) varying
  5   170          based (accum_token_ptr) ;			/* temp store for accumulating the token */
  5   171 declare  accum_token_ptr ptr internal static ;		/* pointer to allocated accumulator store */
  5   172 declare  mrds_data_$max_string_size fixed bin (35) external ; /* max token  size in chars */
  5   173 declare  mrds_data_$max_line_size fixed bin (35) ext ;	/* max output listing line size */
  5   174 declare  token_length fixed binary (24) ;		/* current length of token */
  5   175 declare  output_text char (mrds_data_$max_line_size) varying
  5   176          based (output_text_ptr) ;			/* body of text for this line in output listing */
  5   177 declare  output_text_ptr ptr internal static ;		/* pointer to allocated output line storage */
  5   178 declare  fixup_token char (token_length) based ;		/* saved fixed up version of token */
  5   179 
  5   180 /* semantic variables */
  5   181 
  5   182 declare  source_size fixed bin (35) ;			/* length of source char string for any_to_any */
  5   183 declare  string_source_ptr ptr ;			/* pointer to source for any_to_any conversion */
  5   184 declare  string_source char (source_size) based (string_source_ptr) ; /* storage for expanded string constant */
  5   185 
  5   186 /* link handler variable */
  5   187 
  5   188 declare  dom_list_ptr ptr ;				/* pointer to domain list element */
  5   189 declare 1 dom_list based (dom_list_ptr),		/* element of parent attr domain ptr list */
  5   190         2 next ptr,					/* pointer to next in order on list */
  5   191         2 attr_name char (32) aligned,			/* parent attr's name */
  5   192         2 dom_info_ptr ptr ;				/* parent attr's domain ptr */
  5   193 
  5   194 /* END INCLUDE FILE mrds_rst_parse_info.incl.pl1 */
  5   195 
     1216 
  6     1 /* BEGIN INCLUDE FILE mrds_rst_tree.incl.pl1   jeg 7/19/78 */
  6     2 
  6     3 /* common declarations for threaded binary tree routines
  6     4*
  6     5*   The tree maintains an inorder list of it's keys.
  6     6*   this means that for a given node, any key in it's left subtree
  6     7*   is "less" than the given node's key and that any key in it's
  6     8*   right subtree is "greater" than the given node's key.
  6     9*
  6    10*   Threads are maintained to allow fast and easy traversal of the tree.
  6    11*   threads occupy the position of null pointers of an straight binary tree,
  6    12*   thus they only occur in leaf nodes.
  6    13*   left threads point to that nodes inorder predecessor.
  6    14*   right threads point to that nodes inorder successor.
  6    15*
  6    16*   note: root_ptr must be passed by reference
  6    17*   ( not by value ) so it can be changed .
  6    18*   Also, each parameter must be a different
  6    19*   variable. The same variable used for two
  6    20*   or more arguments when any of the tree
  6    21*   routines are called will produce errors */
  6    22 
  6    23 
  6    24 declare  key char (32) aligned ;			/* data key directing search */
  6    25 
  6    26 declare  root_ptr ptr ;				/* pointer to head of desired list */
  6    27 declare  node_ptr ptr ;				/* pointer to key node, when success */
  6    28 declare  parent_ptr ptr ;				/* pointer to direct parent of current node */
  6    29 declare  data_ptr ptr ;				/* pointer from tree node to data structure headed by node */
  6    30 declare  successor_ptr ptr ;				/* pointer to inorder successor of current node in tree */
  6    31 declare  successor_parent_ptr ptr ;			/* pointer to immediate tree parent of inorder successor node */
  6    32 declare  predecessor_ptr ptr ;			/* pointer to inorder predecessor of current node */
  6    33 declare  predecessor_parent_ptr ptr ;			/* pointer to direct parent of predecessor */
  6    34 declare  area_ptr ptr ;				/* pointer to based area for node allocation/freeing */
  6    35 
  6    36 declare  work_area area based (area_ptr) ;		/* area of storage for tree */
  6    37 
  6    38 declare  success bit (1) ;				/* on if operation successful */
  6    39 declare  thread bit (1) aligned ;			/* current thread indicator, on = thread, off = pointer */
  6    40 
  6    41 declare 1 node based (node_ptr) aligned,		/* tree element */
  6    42         2 data ptr,					/* data field link */
  6    43         2 key char (32),				/* data key */
  6    44         2 right,					/* right branch link */
  6    45 	3 thread bit (1),				/* indicates whether link is thread or pointer */
  6    46 	3 link ptr,				/* pointer to right descendent or thread to successor */
  6    47         2 left,					/* left branch link */
  6    48 	3 thread bit (1),				/* indicates whether link is thread or pointer */
  6    49 	3 link ptr,				/* pointer to left descendent or thread to predecessor */
  6    50         2 pad bit (34) ;				/* reserved for future flags */
  6    51 
  6    52 /* END INCLUDE FILE mrds_rst_tree.incl.pl1  */
  6    53 
  6    54 
  6    55 
  6    56 
     1217 
  7     1 /* BEGIN INCLUDE FILE mrds_rst_global_lists.incl.pl1	jeg	7/17/78	*/
  7     2 
  7     3 /* note: mrds_rst_list_element$add and delete entries
  7     4*   makes use of the following structure type correspondence
  7     5*
  7     6*   structure_type = 1  refers to gl (global list element)
  7     7*
  7     8*   structure_type = 2 refers to sl (global sublist element)
  7     9*
  7    10*   structure_type = 3  refers to seg_info(segment information element)
  7    11*
  7    12**/
  7    13 
  7    14 
  7    15 dcl 1 gl aligned based (gl_ptr),			/* Template for global list entry */
  7    16     2 type fixed bin,				/* structure_type, usefull when overlay used */
  7    17     2 name char (32),				/* Item name */
  7    18     2 item_info_ptr ptr,				/* Pointer to info structure for this item */
  7    19     2 parse_info_ptr ptr,				/* Pointer to info obtained by parsing source */
  7    20     2 other_info_ptr ptr,				/* Pointer to additional info str if needed */
  7    21     2 item_sub_list_ptr ptr,				/* Pointer to sub list of items if neccessary for this his item */
  7    22     2 file_info_ptr ptr,				/* Pointer to file info for this entry */
  7    23     2 file_model_ptr ptr,				/* Pointer to file model for this entry */
  7    24     2 affected bit (1) unal,				/* ON => affected by some directive */
  7    25     2 cmdb bit (1) unal,				/* ON => affected by cmdb directive */
  7    26     2 undefine bit (1) unal,				/* ON => affected by undefine directive */
  7    27     2 define bit (1) unal,				/* ON => affected by define directive */
  7    28     2 redefine bit (1) unal,				/* ON => affected by redefine directive */
  7    29     2 superior_assigned bit (1) unal,			/* ON => has parent */
  7    30     2 inferior_assigned bit (1) unal,			/* ON => child present */
  7    31     2 complete bit (1) unal,				/* ON => all things present */
  7    32     2 consistant bit (1) unal,			/* ON => correct model */
  7    33     2 reserved bit (26) unal,				/* for future use */
  7    34     2 child_defined bit (1) unal ;			/* ON => global element entered by child */
  7    35 
  7    36 dcl  gl_ptr ptr;					/* Pointer to gl structure */
  7    37 
  7    38 
  7    39 
  7    40 dcl 1 sl aligned based (sl_ptr),			/* Template of sub list entry for global list */
  7    41     2 type fixed bin,				/* structure_type, usefull when overlay used */
  7    42     2 name char (32),				/* Name of item */
  7    43     2 item_info_ptr ptr,				/* Pointer to info structure for this entry */
  7    44     2 parse_info_ptr ptr,				/* Pointer to info obtained by parsing source */
  7    45     2 old_other_info_ptr ptr,				/* Pointer to old version of other info */
  7    46     2 new_other_info_ptr ptr,				/* Pointer to new version of other info */
  7    47     2 global_list_ptr ptr,				/* pointer to corresponding global list element */
  7    48     2 reserved bit (36) unal;				/* Reserved for future use */
  7    49 
  7    50 dcl  sl_ptr ptr;					/* Pointer to sub list structure */
  7    51 
  7    52 
  7    53 dcl 1 seg_info based (seg_info_ptr),			/* Info about segment initiated */
  7    54     2 name char (32),				/* Segment name */
  7    55     2 dir char (168),				/* Absolute path of containing directory */
  7    56     2 seg_ptr ptr,					/* Pointer to base of segment */
  7    57     2 bcnt fixed bin (24);				/* Bit count of segment */
  7    58 
  7    59 dcl  seg_info_ptr ptr;				/* Pointer to seg_info str */
  7    60 
  7    61 
  7    62 
  7    63 dcl  MAIN_LIST fixed bin internal static options (constant) init (1);
  7    64 dcl  SUB_LIST fixed bin internal static options (constant) init (2);
  7    65 dcl  SEG_INFO fixed bin internal static options (constant) init (3);
  7    66 
  7    67 declare 1 list_ovrly aligned based (list_ovrly_ptr),	/* overlay for top part of gl and sl list elements */
  7    68         2 type fixed bin,				/* structure_type, 1 => gl, 2 => sl */
  7    69         2 name char (32),				/* Name of item */
  7    70         2 item_info_ptr ptr,				/* pointer to info structure for this entry */
  7    71         2 parse_info_ptr ptr,				/* pointer to info obtained by parsing source */
  7    72         2 other_info_ptr ptr ;			/* pointer to additional info structure if needed */
  7    73 
  7    74 declare  list_ovrly_ptr ptr ;				/* pointer to overlay structure */
  7    75 
  7    76 
  7    77 declare  saved_child_count fixed bin based (saved_child_count_ptr) ; /* parent link structure child count */
  7    78 declare  saved_child_count_ptr ptr ;			/* pointer to remembered number of children */
  7    79 
  7    80 
  7    81 /* USES AND MEANING OF LIST ELEMENT ENTRIES
  7    82*
  7    83*   DOMAIN GLOBAL LIST --------------------------
  7    84*
  7    85*   gl.type - - MAIN_LIST
  7    86*   gl.name - - 32 char domain name
  7    87*   gl.item_info_ptr - - pointer to domain_info for this domain
  7    88*   gl.parse_info_ptr - - pointer to parse info structure
  7    89*   gl.other_info_ptr - - dbm_ptr, pointer to mdbm_db_model
  7    90*   gl.item_sub_list_ptr - - pointer to sublist of attributes using this domain
  7    91*   gl.file_info_ptr - - null ()
  7    92*   gl.file_model_ptr - - null ()
  7    93*   gl.superior_assigned - - ON => domain referenced by some relation
  7    94*   gl.inferior_assigned - - ON => referencing attribute present
  7    95*   gl.complete - - ON => domain_info present
  7    96*   gl.consistant - - always ON
  7    97*
  7    98*   DOMAIN GLOBAL LIST "REFERENCING ATTRIBUTES" SUBLIST ----------------
  7    99*
  7   100*   sl.type - - SUB_LIST
  7   101*   sl.name - - 32 char attribute name
  7   102*   sl.item_info_ptr - - pointer to this attribute's attribute_info
  7   103*   sl.parse_info_ptr - - pointer to parse info structure
  7   104*   sl.old_other_info_ptr - - null ()
  7   105*   sl.new_other_info_ptr - - pointer to this domain's global list element
  7   106*   sl.global_list_ptr - - pointer to attribute's global list element
  7   107*
  7   108*   ATTRIBUTE GLOBAL LIST -----------------
  7   109*
  7   110*   gl.type - - MAIN_LIST
  7   111*   gl.name - - 32 char attribute name
  7   112*   gl.item_info_ptr - - pointer to corresponding domain sublist element for this attribute
  7   113*   gl.parse_info_ptr - - pointer to parse info structure
  7   114*   gl.other_info_ptr - - domain_info of domain for this attribute
  7   115*   gl.item_sub_list_ptr - - pointer to sublist of relations that use this attribute
  7   116*   gl.file_info_ptr - - null (), use pointer(fm_ptr,file_model.fi_ptr)
  7   117*   gl.file_model_ptr - - null (), use pointer(ai_ptr,0), ai_ptr from corres. rel's attr sublist
  7   118*   gl.superior_assigned - - ON => relation contains this attribute
  7   119*   gl.inferior_assigned - - ON => attribute references known domain
  7   120*   gl.complete - - ON => attr_info present for this attribute
  7   121*   gl.consistant - - OFF => no domain for this attribute
  7   122*
  7   123*   ATTRIBUTE GLOBAL LIST "USED IN RELATION" SUBLIST ------------------
  7   124*
  7   125*   sl.type - - SUB_LIST
  7   126*   sl.name - - 32 char relation name
  7   127*   sl.item_info_ptr - - pointer to this relation's rel_info
  7   128*   sl.parse_info_ptr - - pointer to parse info structure
  7   129*   sl.old_other_info_ptr - - pointer to attribute's attr_info in this relation
  7   130*   sl.new_other_info_ptr - - pointer to this attribute's global list element
  7   131*   sl.global_list_ptr - - pointer to relation's global list element
  7   132*
  7   133*   RELATION GLOBAL LIST -------------------
  7   134*
  7   135*   gl.type - - MAIN_LIST
  7   136*   gl.name - - 32 char relation name
  7   137*   gl.item_info_ptr - - pointer to rel_info for this relation
  7   138*   gl.parse_info_ptr - - pointer to parse info structure
  7   139*   gl.other_info_ptr - - pointer to global list element of file containing this relation
  7   140*   gl.item_sub_list_ptr - - pointer to sublist of attributes in this relation
  7   141*   gl.file_info_ptr - - pointer to file_info of this relation's file
  7   142*   gl.file_model_ptr - - pointer to file_model of this relation's file
  7   143*   gl.superior_assigned - - ON => file present to hold this relation
  7   144*   gl.inferior_assigned - - ON => attribute's present in this relation
  7   145*   gl.complete - - ON => rel_info assigned to this relation
  7   146*   gl.consistant - - OFF => no attributes for this relation
  7   147*
  7   148*   RELATION GLOBAL LIST "CONTAINED ATTRIBUTE" SUBLIST ----------------
  7   149*
  7   150*   sl.type - - SUB_LIST
  7   151*   sl.name - - 32 char attribute name
  7   152*   sl.item_info_ptr - - pointer to this attribute's attribute_info
  7   153*   sl.parse_info_ptr - - pointer to parse info structure
  7   154*   sl.old_other_info_ptr - - pointer to domain_info for this attribute in old model
  7   155*   sl.new_other_info_ptr - - pointer to domain_info for this attribute in new model
  7   156*   sl.global_list_ptr - - pointer to attribute's global list element
  7   157*
  7   158*   FILE GLOBAL LIST -----------------------
  7   159*
  7   160*   gl.type - - MAIN_LIST
  7   161*   gl.name - - 30 char file name plus 2 trailing blanks
  7   162*   gl.item_info_ptr - - pointer to file_info for this file
  7   163*   gl.parse_info_ptr - - pointer to parse info structure
  7   164*   gl.other_info_ptr - - null ()
  7   165*   gl.item_sub_list_ptr - - pointer to sublist of relations contained in this file
  7   166*   gl.file_info_ptr - - pointer to file_info for this file
  7   167*   gl.file_model_ptr - - pointer to file_model for this file
  7   168*   gl.superior_assigned - - ON => file_model present for this file
  7   169*   gl.inferior_assigned - - ON => relation present for this file
  7   170*   gl.complete - - OFF => not formatted yet
  7   171*   gl.consistant - - ON => no relations present
  7   172*
  7   173*   FILE GLOBAL LIST "CONTAINED RELATION" SUBLIST ----------------
  7   174*
  7   175*   sl.type - - SUB_LIST
  7   176*   sl.name - - 32 char relation name
  7   177*   sl.item_info_ptr - - relation's rel_info pointer
  7   178*   sl.parse_info_ptr - - pointer to parse info structure
  7   179*   sl.old_other_info_ptr - - null ()
  7   180*   sl.new_other_info_ptr - - pointer to file global list element
  7   181*   sl.global_list_ptr - - pointer to relation's global list element
  7   182*
  7   183*   FOREIGN KEY GLOBAL LIST --------------------
  7   184*
  7   185*   gl.type - - MAIN_LIST
  7   186*   gl.name - - 32 char link(foreign key) name, parent_link_info.name
  7   187*   gl.item_info_ptr - - pointer to parent_link_info for this foreign key
  7   188*   gl.parse_info_ptr - - pointer to parse info structure
  7   189*   gl.other_info_ptr - - pointer to parent relation global list element
  7   190*   gl.item_sub_list_ptr - - pointer to sublist of child relations for this parent
  7   191*   gl.file_info_ptr - - pointer to file_info for parent relation's file
  7   192*   gl.file_model_ptr - - pointer to file_model for parent relation's file
  7   193*   gl.superior_assigned - - ON => parent present
  7   194*   gl.inferior_assigned - - ON => child present
  7   195*   gl.complete - - ON => pli_info and cli_info present
  7   196*   gl.consistant - - ON => rels/attrs found and corres domains match
  7   197*   gl.child_defined - - ON => not defined by parent, but by one of it's children
  7   198*
  7   199*   FOREIGN KEY GLOBAL LIST CHILDREN SUBLIST
  7   200*
  7   201*   sl.type - - SUB_LIST
  7   202*   sl.name - - 32 char name of relation representing this child
  7   203*   sl.item_info_ptr - - pointer to child_link_info for this child
  7   204*   sl.parse_info_ptr - - pointer to parse info structure
  7   205*   sl.old_other_info_ptr - - pointer to file_model holding this child relation
  7   206*   sl.new_other_info_ptr - - pointer to rel_info for this child
  7   207*   sl.global_list_ptr - - pointer to child relation global list element
  7   208*
  7   209*   NOTE: all pointers are to the new model unless otherwise indicated
  7   210*
  7   211**/
  7   212 
  7   213 /* END INCLUDE FILE mrds_rst_global_lists.incl.pl1	*/
  7   214 
     1218 
  8     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  8     6*     modified to save space occupied by model
  8     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  8     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  8     9*     the number of secondary indices in the relation - it was always zero.
  8    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  8    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  8    12*     DMS conversion.
  8    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  8    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  8    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  8    16*     for relation manager changes.
  8    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  8    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  8    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  8    20*     <rel> files are good (for rmdb)
  8    21*                                                   END HISTORY COMMENTS */
  8    22 
  8    23 
  8    24 /* each file in the database will have a model segment with the name
  8    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  8    26*   the file_model structure is allocated at the base of the segment for a given file.
  8    27*   it contains an area with which all other structures in this include file are allocated.
  8    28*   these structures contain the information about which relations, foreign keys,
  8    29*   and attributes are members of this file. all lists are singly linked lists in
  8    30*   definition order. pointers to these structures are obtained by using the "pointer"
  8    31*   builtin function with arguments of the segment base pointer, and the
  8    32*   offset (bit (18)) relative to that pointer that is actually stored in
  8    33*   the file model itself. this is because pointer segment numbers are
  8    34*   per process dependent. the major lists pointed to by the file_model structure
  8    35*   are the list of relations in this file(each with a contained attribute list),
  8    36*   and the list of foreign keys whose parent relation resides in this file
  8    37*   (along with a participating attribute sublist, and the child relation list,
  8    38*   if they are also in this file) */
  8    39 
  8    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  8    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  8    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  8    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  8    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  8    45     2 reserved bit (32) unal,				/* reserved for future flags */
  8    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  8    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  8    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  8    49     2 pad_1 fixed bin (35),				/* for future use */
  8    50     2 pad_2 fixed bin (35),
  8    51     2 ratd_len fixed bin (21),			/* length of above */
  8    52     2 mratd_len fixed bin (21),			/* length of above */
  8    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  8    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  8    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  8    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  8    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  8    58     2 block_size unal fixed bin,			/* no. pages in block */
  8    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  8    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  8    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  8    62     2 num_rels unal fixed bin,			/* number of relations in file */
  8    63     2 num_links unal fixed bin,			/* number of links in file */
  8    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  8    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  8    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  8    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  8    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  8    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  8    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  8    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  8    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  8    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  8    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  8    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  8    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  8    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  8    78     2 open_eu_err_path_ptr unal bit (18),
  8    79     2 open_eu_after_path_ptr unal bit (18),
  8    80     2 open_er_before_path_ptr unal bit (18),
  8    81     2 open_er_err_path_ptr unal bit (18),
  8    82     2 open_er_after_path_ptr unal bit (18),
  8    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  8    84     2 open_neu_err_path_ptr unal bit (18),
  8    85     2 open_neu_after_path_ptr unal bit (18),
  8    86     2 open_ner_before_path_ptr unal bit (18),
  8    87     2 open_ner_err_path_ptr unal bit (18),
  8    88     2 open_ner_after_path_ptr unal bit (18),
  8    89     2 open_pu_before_path_ptr unal bit (18),
  8    90     2 open_pu_err_path_ptr unal bit (18),
  8    91     2 open_pu_after_path_ptr unal bit (18),
  8    92     2 open_pr_before_path_ptr unal bit (18),
  8    93     2 open_pr_err_path_ptr unal bit (18),
  8    94     2 open_pr_after_path_ptr unal bit (18),
  8    95     2 open_cu_before_path_ptr unal bit (18),
  8    96     2 open_cu_err_path_ptr unal bit (18),
  8    97     2 open_cu_after_path_ptr unal bit (18),
  8    98     2 open_cr_before_path_ptr unal bit (18),
  8    99     2 open_cr_err_path_ptr unal bit (18),
  8   100     2 open_cr_after_path_ptr unal bit (18),
  8   101     2 close_before_path_ptr unal bit (18),
  8   102     2 close_err_path_ptr unal bit (18),
  8   103     2 close_after_path_ptr unal bit (18),
  8   104     2 unused_1 unal bit (18),				/* for future expansion */
  8   105     2 unused_2 unal bit (18),
  8   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  8   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  8   108 dcl  fm_ptr ptr;
  8   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  8   110 dcl  atd_ptr ptr;
  8   111 dcl  atd_len fixed bin;
  8   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  8   113     2 ncomponents fixed bin,
  8   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  8   115 dcl  cna_ptr ptr;
  8   116 dcl  ncomp_init fixed bin;
  8   117 
  8   118 /* a rel_info structure contains information describing a relation.
  8   119*   a relation may only occur in one file, thus there is one rel_info
  8   120*   per relation per database, each stored in the file_model area for
  8   121*   the file that contains it. the list of rel_info's in this file
  8   122*   form a singly linked list in definition order.
  8   123*   the rel_info itself points to a list of the attributes it contains,
  8   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  8   125 
  8   126 dcl 1 rel_info aligned based (ri_ptr),
  8   127     2 name char (32),				/* relation name */
  8   128     2 id  bit (36) aligned,				/* relation id number */
  8   129     2 hashed bit (1) unal,				/* on if hashed */
  8   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  8   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  8   132     2 system bit (1) unal,				/* on if dont care how stored */
  8   133     2 indexed bit (1) unal,				/* on if secondary index */
  8   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  8   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  8   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  8   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  8   138     2 reserved bit (27) unal,				/* for future flags */
  8   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  8   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  8   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  8   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  8   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  8   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  8   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  8   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  8   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  8   148     2 unused_3 unal fixed bin,			/* element that was never used */
  8   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  8   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  8   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  8   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  8   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  8   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  8   155     2 attr_ptr unal bit (18),				/* to attr. info */
  8   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  8   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  8   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  8   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  8   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  8   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  8   162     2 link_err_path_ptr unal bit (18),
  8   163     2 link_after_path_ptr unal bit (18),
  8   164     2 unlk_before_path_ptr unal bit (18),
  8   165     2 unlk_err_path_ptr unal bit (18),
  8   166     2 unlk_after_path_ptr unal bit (18),
  8   167     2 str_before_path_ptr unal bit (18),
  8   168     2 str_err_path_ptr unal bit (18),
  8   169     2 str_after_path_ptr unal bit (18),
  8   170     2 del_before_path_ptr unal bit (18),
  8   171     2 del_err_path_ptr unal bit (18),
  8   172     2 del_after_path_ptr unal bit (18),
  8   173     2 mod_before_path_ptr unal bit (18),
  8   174     2 mod_err_path_ptr unal bit (18),
  8   175     2 mod_after_path_ptr unal bit (18),
  8   176     2 find_before_path_ptr unal bit (18),
  8   177     2 find_err_path_ptr unal bit (18),
  8   178     2 find_after_path_ptr unal bit (18),
  8   179     2 retr_before_path_ptr unal bit (18),
  8   180     2 retr_err_path_ptr unal bit (18),
  8   181     2 retr_after_path_ptr unal bit (18),
  8   182     2 unused_1 unal bit (18),				/* for future expansion */
  8   183     2 unused_2 unal bit (18),
  8   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  8   185 dcl  ri_ptr ptr;
  8   186 
  8   187 /* a attr_info structure contains information about an attribute in a given relation.
  8   188*   since attributes may appear in more than one relation, each occurence of an attribute
  8   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  8   190*   the list is singly linked in definition order. the attr_info describes
  8   191*   the data it represents, and how that data is used during a database search. */
  8   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  8   193     2 name char (32),				/* name of attribute */
  8   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  8   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  8   196     2 link_attr bit (1) unal,				/* on if participates in link */
  8   197     2 reserved bit (33) unal,
  8   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  8   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  8   200     2 key_order unal fixed bin,			/* relative posit. in key */
  8   201     2 bit_offset fixed bin (35),			/* position in tuple */
  8   202     2 bit_length fixed bin (35),			/* length if fixed */
  8   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  8   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  8   205     2 domain_ptr unal bit (18),			/* to domain info */
  8   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  8   207     2 fwd_thread unal bit (18),			/* to next in list */
  8   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  8   209 dcl  ai_ptr ptr;
  8   210 
  8   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  8   212*   each time a foreign key definition indicates a relation as it's parent,
  8   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  8   214*   a relation can be parent and/or child in any number of foreign keys.
  8   215*   the parent_link_info structure describes the foreign key, and also points
  8   216*   to a list of the attributes that participate in this foreign key.
  8   217*   (this could be from 1 up to all attributes in the relation)
  8   218*   the attr_list structures are in a singly linked list in definition order
  8   219*   for this purpose. also pointed to is a list of child_link_info's
  8   220*   that describe the child relations in this foreign key. since foreign keys
  8   221*   may span files, not all related child_link_info's have to be in this file's
  8   222*   model area. */
  8   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  8   224     2 name char (32),				/* name of link */
  8   225     2 singular bit (1) unal,				/* on if system owned link */
  8   226     2 temp bit (1) unal,				/* on if temp. order */
  8   227     2 first bit (1) unal,				/* insertion indicators */
  8   228     2 last bit (1) unal,
  8   229     2 next bit (1) unal,
  8   230     2 prior bit (1) unal,
  8   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  8   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  8   233     2 dup_first bit (1) unal,				/* duplicates first */
  8   234     2 dup_last bit (1) unal,				/* duplicates last */
  8   235     2 indexed bit (1) unal,				/* locate parent via index */
  8   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  8   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  8   238     2 thread_27 bit (1) unal,
  8   239     2 thread_18 bit (1) unal,
  8   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  8   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  8   242     2 reserved bit (19) unal,				/* reserved for future flags */
  8   243     2 index_id aligned bit (8),			/* id of index if indexed */
  8   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  8   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  8   246     2 n_children unal fixed bin,			/* no. children in link */
  8   247     2 child_fn char (30),				/* file name for first child in list */
  8   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  8   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  8   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  8   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  8   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  8   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  8   254     2 sort_err_path_ptr unal bit (18),
  8   255     2 sort_after_path_ptr unal bit (18),
  8   256     2 srch_before_path_ptr unal bit (18),
  8   257     2 srch_err_path_ptr unal bit (18),
  8   258     2 srch_after_path_ptr unal bit (18),
  8   259     2 link_before_path_ptr unal bit (18),
  8   260     2 link_err_path_ptr unal bit (18),
  8   261     2 link_after_path_ptr unal bit (18),
  8   262     2 unlk_before_path_ptr unal bit (18),
  8   263     2 unlk_err_path_ptr unal bit (18),
  8   264     2 unlk_after_path_ptr unal bit (18),
  8   265     2 unused_1 unal bit (18),				/* for future expansion */
  8   266     2 unused_2 unal bit (18),
  8   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  8   268 dcl  pli_ptr ptr;
  8   269 
  8   270 /* a child_link_info structure is the counter part of a parent_link_info
  8   271*   for foreign key child relations. each time a relation is defined to be
  8   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  8   273*   this list is singly linked in foreign key definition order.
  8   274*   the child_link_info points to a list of participating attributes from the
  8   275*   child relation by means of a singly linked list of attr_list structures
  8   276*   in definition order. the number of attributes in the parent attr_list
  8   277*   and the child attr_list lists are the same with corresponding attr_list
  8   278*   attributes having the same domain. all child_link_infos in this file
  8   279*   are on a seperately linked list. this may not include all
  8   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  8   281*   since foreign keys may span files, and the child_link_info will
  8   282*   reside in the file containing it's associated relation_info. */
  8   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  8   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  8   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  8   286     2 fixed bit (1) unal,				/* on if membership fixed */
  8   287     2 optional bit (1) unal,				/* on if membership optional */
  8   288     2 auto bit (1) unal,				/* on if insertion automatic */
  8   289     2 manual bit (1) unal,				/* on if insertion manual */
  8   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  8   291     2 range_sel bit (1) unal,				/* on if range type selection */
  8   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  8   293     2 key_dup_last bit (1) unal,
  8   294     2 key_null bit (1) unal,				/* on if null allowed */
  8   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  8   296     2 sel_current bit (1) unal,
  8   297     2 sel_key bit (1) unal,
  8   298     2 sel_proc bit (1) unal,
  8   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  8   300     2 reserved bit (21) unal,
  8   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  8   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  8   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  8   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  8   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  8   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  8   307     2 parent_fn char (30),				/* file name for parent info */
  8   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  8   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  8   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  8   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  8   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  8   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  8   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  8   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  8   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  8   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  8   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  8   319     2 link_err_path_ptr unal bit (18),
  8   320     2 link_after_path_ptr unal bit (18),
  8   321     2 unlk_before_path_ptr unal bit (18),
  8   322     2 unlk_err_path_ptr unal bit (18),
  8   323     2 unlk_after_path_ptr unal bit (18),
  8   324     2 srch_before_path_ptr unal bit (18),
  8   325     2 srch_err_path_ptr unal bit (18),
  8   326     2 srch_after_path_ptr unal bit (18),
  8   327     2 unused_1 unal bit (18),				/* for future expansion */
  8   328     2 unused_2 unal bit (18) ;
  8   329 dcl  cli_ptr ptr;
  8   330 
  8   331 /* the attr_list structure is associated with the parent_link_info
  8   332*   and child_link_info structures to represent by means of a singly linked list
  8   333*   the participating attributes from relations in a foreign key.
  8   334*   the parent_link_info has a list for the parent relation,
  8   335*   and the child_link_info has a list for the child relation.
  8   336*   the participating attributes are a subset(not necessary proper) of
  8   337*   those attributes contained in a relation definition.
  8   338*   there are equal numbers of attr_list structures in the parent and
  8   339*   child lists of the same foreign key. the corresponding attributes in these
  8   340*   lists must have the same domain. */
  8   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  8   342     2 attr_fn char (30),				/* file name for attr. */
  8   343     2 attr_ptr unal bit (18),				/* to attr info block */
  8   344     2 fwd_thread unal bit (18);			/* to next in list */
  8   345 dcl  al_ptr ptr;
  8   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  8   347     2 ascend bit (1) unal,				/* ascending order */
  8   348     2 descend bit (1) unal,				/* descending order */
  8   349     2 reserved bit (34) unal,
  8   350     2 attr_ptr unal bit (18),				/* to attr info */
  8   351     2 fwd_thread unal bit (18);			/* to next in list */
  8   352 dcl  sk_ptr ptr;
  8   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  8   354     2 attr_ptr unal bit (18),				/* to attr info */
  8   355     2 fwd_thread unal bit (18);			/* to next in list */
  8   356 dcl  dp_ptr ptr;
  8   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  8   358     2 link_fn char (30),				/* file name for thru link */
  8   359     2 link_ptr unal bit (18),				/* to parent link info */
  8   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  8   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  8   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  8   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  8   364     2 fwd_thread unal bit (18);			/* to next in chain */
  8   365 dcl  sc_ptr ptr;
  8   366 
  8   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  8   368 
  8   369 
     1219 
  9     1 /* BEGIN INCLUDE FILE mdbm_file_model_init.incl.pl1 -- rbh 6/22/82 */
  9     2 
  9     3 
  9     4 
  9     5 /****^  HISTORY COMMENTS:
  9     6*  1) change(82-10-12,DWoodka), approve(), audit(), install():
  9     7*     Modified for DMS conversion - added primary_key_index_id to init_rel_info,
  9     8*     and changed init_rel_info.id to be bit (36) instead of bit (12). Deleted
  9     9*     child_link_ptr and parent_link_ptr, no longer needed.
  9    10*  2) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
  9    11*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  9    12*     added (file_model relation)_copy_good fields for rmdb.
  9    13*                                                   END HISTORY COMMENTS */
  9    14 
  9    15 
  9    16 /* From mdbm_file_model.incl.pl1 */
  9    17 
  9    18 dcl 1 init_file_model aligned internal static options (constant), /* base of segment */
  9    19     2 temporary bit (1) unal init ("0"b),	/* on if file not part of db. */
  9    20     2 procedures_present bit (1) unal init ("0"b), /* on => ids procedures present */
  9    21     2 file_model_copy_good bit (1) unaligned init ("0"b),	/* on => <rel>.m file is the good copy */
  9    22     2 relation_copy_good bit (1) unaligned init ("0"b),	/* on => <rel> file is the good copy */
  9    23     2 reserved bit (32) unal init ("0"b),	/* reserved for future flags */
  9    24     2 max_tuples fixed bin (35) init (0),		/* not used */
  9    25     2 num_blocks fixed bin (35) init (0),		/* not used */
  9    26     2 num_buckets fixed bin (35) init (0),		/* not used */
  9    27     2 pad_1 fixed bin (35) init (0),			/* for future use */
  9    28     2 pad_2 fixed bin (35) init (0),
  9    29 
  9    30     2 ratd_len fixed bin (21) init (0),			/* useless garbage */
  9    31     2 mratd_len fixed bin (21) init (0),		/* useless garbage */
  9    32     2 uatd_len fixed bin (21) init (0),			/* useless garbage */
  9    33     2 latd_len fixed bin (21) init (0),			/* useless garbage */
  9    34     2 sratd_len fixed bin (21) init (0),		/* useless garbage */
  9    35     2 suatd_len fixed bin (21) init (0),		/* useless garbage */
  9    36     2 file_type unal fixed bin init (1),		/* 1 */
  9    37     2 block_size unal fixed bin init (0),		/* not used */
  9    38     2 block_factor unal fixed bin init (0),		/* not used */
  9    39     2 bucket_density unal fixed bin init (0),		/* not used */
  9    40     2 tuple_id_len unal fixed bin init (36),		/* always 36? */
  9    41     2 num_rels unal fixed bin init (1),			/* always 1 */
  9    42     2 num_links unal fixed bin init (0),		/* not used */
  9    43     2 num_children unal fixed bin init (0),		/* not used */
  9    44     2 default_rbs (3) unal fixed bin (8) init (4,4,4),	/* file ring brackets when not MDBM-secured */
  9    45     2 rel_ptr unal bit (18) init ((18)"1"b),	/* to first of list of rel_infos */
  9    46     2 link_ptr unal bit (18) init ((18)"1"b), /* always null */
  9    47     2 children_ptr unal bit (18) init ((18)"1"b),  /* always null */
  9    48     2 cno_array_ptr unal bit (18) init ((18)"1"b), /* always null */
  9    49     2 fi_ptr unal bit (18) init ((18)"1"b),	/* offset to file_info in db_model */
  9    50     2 suatd_ptr unal bit (18) init ((18)"1"b),		/* garbage */
  9    51     2 sratd_ptr unal bit (18) init ((18)"1"b),		/* garbage */
  9    52     2 latd_ptr unal bit (18) init ((18)"1"b),		/* garbage */
  9    53     2 uatd_ptr unal bit (18) init ((18)"1"b),		/* garbage */
  9    54     2 mratd_ptr unal bit (18) init ((18)"1"b),		/* garbage */
  9    55     2 ratd_ptr unal bit (18) init ((18)"1"b),		/* garbage */
  9    56     2 ptr_pad unal bit (9) init ((9)"1"b),		/* align to half-word value */
  9    57     2 unused_ptr_space unal bit (18) dimension (28) init ((28)(18)"1"b),   /* free ptr space */
  9    58     2 ptr_pad2 unal bit (9) init ((9)"1"b),		/* align to byte */
  9    59     2 changer_ptr unal bit (18) init ((18)"1"b);		/* pointer to changer_id, changer_time structure */
  9    60 
  9    61 
  9    62 dcl 1 like_file_model aligned based (fm_ptr) like init_file_model;	/* base of segment */
  9    63 
  9    64 
  9    65 dcl 1 init_rel_info aligned internal static options (constant),
  9    66     2 name char (32) init (""),			/* relation name */
  9    67     2 id aligned bit (36) init ("000000000000000000000000000000000001"b),		/* relation id number */
  9    68     2 hashed bit (1) unal init ("0"b),		/* on if hashed */
  9    69     2 duplicates bit (1) unal init ("0"b),	/* on if allow dup. hash fields */
  9    70     2 via_link bit (1) unal init ("0"b),	/* on if to be stored by parent */
  9    71     2 system bit (1) unal init ("0"b),		/* on if dont care how stored */
  9    72     2 indexed bit (1) unal init ("0"b),		/* on if secondary index */
  9    73     2 mrds_update bit (1) unal init ("1"b),	/* on if updateable by MRDS */
  9    74     2 mrds_retrieve bit (1) unal init ("1"b),	/* on if retrievable by MRDS */
  9    75     2 virtual bit (1) unal init ("0"b),		/* if virtual relation, mapped on IDS records */
  9    76     2 procedures_present bit (1) unal init ("0"b),/* on => ids type procedures present */
  9    77     2 reserved bit (27) unal init ("0"b),	/* for future flags */
  9    78     2 num_attr unal fixed bin init (0),			/* number of attributes (all levels) defined */
  9    79     2 num_links_child unal fixed bin init (0),		/* no. links in which child */
  9    80     2 num_links_par unal fixed bin init (0),		/* no. links_in which parent */
  9    81     2 max_attr_index_id unal fixed bin init (0),		/* max index id used by attr in this rel or PLI */
  9    82     2 num_key_attrs unal fixed bin init (0),		/* number of attributes in primary key for this rel */
  9    83     2 nvar_atts unal fixed bin init (0),		/* no. varying len. attributes */
  9    84     2 n36_thds unal fixed bin init (0),			/* no. of 36-bit threads */
  9    85     2 n27_thds unal fixed bin init (0),			/* no of 27-bit threads */
  9    86     2 n18_thds unal fixed bin init (0),			/* no of 18-bit threads */
  9    87     2 unused_3 unal fixed bin init (0),			/* element that was never used */
  9    88     2 max_data_len fixed bin (35) init (0),		/* max length of data portion of tuple */
  9    89     2 avg_data_len fixed bin (35) init (0),		/* average length of tuple data portion */
  9    90     2 max_key_len fixed bin (35) init (0),		/* max key length if not hashed */
  9    91     2 var_offset fixed bin (35) init (1),		/* position of first varying attr. */
  9    92     2 max_tuples fixed bin (35) init (0),		/* max no. tuples if blocked file */
  9    93     2 fwd_thread unal bit (18) init ((18)"1"b),    /* offset to next rel. in file */
  9    94     2 attr_ptr unal bit (18) init ((18)"1"b), /* to attr. info */
  9    95     2 primary_key_index_id bit (36) aligned init ("000000000000000000000000000000000001"b), 
  9    96     2 clink_ptr unal bit (18) init ((18)"1"b),/* offset to child info of link determining location */
  9    97     2 map_ptr unal bit (18) init ((18)"1"b),	/* pointer to mapping info if virtual rel. */
  9    98     2 sec_ind_ptr unal bit (18) init ((18)"1"b),   /* ptr to list of sec. ind. infos, init. not used */
  9    99     2 locator_proc_path_ptr unal bit (18) init ((18)"1"b),   /* proc to determ. location */
  9   100     2 link_before_path_ptr unal bit (18) init ((18)"1"b),    /* op. proc. paths and entries */
  9   101     2 link_err_path_ptr unal bit (18) init ((18)"1"b),
  9   102     2 link_after_path_ptr unal bit (18) init ((18)"1"b),
  9   103     2 unlk_before_path_ptr unal bit (18) init ((18)"1"b),
  9   104     2 unlk_err_path_ptr unal bit (18) init ((18)"1"b),
  9   105     2 unlk_after_path_ptr unal bit (18) init ((18)"1"b),
  9   106     2 str_before_path_ptr unal bit (18) init ((18)"1"b),
  9   107     2 str_err_path_ptr unal bit (18) init ((18)"1"b),
  9   108     2 str_after_path_ptr unal bit (18) init ((18)"1"b),
  9   109     2 del_before_path_ptr unal bit (18) init ((18)"1"b),
  9   110     2 del_err_path_ptr unal bit (18) init ((18)"1"b),
  9   111     2 del_after_path_ptr unal bit (18) init ((18)"1"b),
  9   112     2 mod_before_path_ptr unal bit (18) init ((18)"1"b),
  9   113     2 mod_err_path_ptr unal bit (18) init ((18)"1"b),
  9   114     2 mod_after_path_ptr unal bit (18) init ((18)"1"b),
  9   115     2 find_before_path_ptr unal bit (18) init ((18)"1"b),
  9   116     2 find_err_path_ptr unal bit (18) init ((18)"1"b),
  9   117     2 find_after_path_ptr unal bit (18) init ((18)"1"b),
  9   118     2 retr_before_path_ptr unal bit (18) init ((18)"1"b),
  9   119     2 retr_err_path_ptr unal bit (18) init ((18)"1"b),
  9   120     2 retr_after_path_ptr unal bit (18) init ((18)"1"b),
  9   121     2 unused_1 unal bit (18) init ((18)"1"b), /* for future expansion */
  9   122     2 unused_2 unal bit (18) init ((18)"1"b),
  9   123     2 changer_ptr unal bit (18) init ((18)"1"b);   /* pointer to changer_id, changer_time structure */
  9   124 
  9   125 
  9   126 /* END INCLUDE FILE mdbm_file_model_init.incl.pl1 */
  9   127 
  9   128 
     1220 
 10     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
 10     2 
 10     3 
 10     4 /****^  HISTORY COMMENTS:
 10     5*  1) change(79-02-01,Gray), approve(), audit(), install():
 10     6*     modified to save space occupied by model
 10     7*  2) change(80-11-03,Gray), approve(), audit(), install():
 10     8*     to add mdbm_secured bit in db_model
 10     9*  3) change(82-04-09,Davids), approve(), audit(), install():
 10    10*     collapsed the following into an unused_offset array:
 10    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
 10    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
 10    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
 10    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
 10    15*       unused_1
 10    16*     Also changed the name of unused_2 to restructuring_history_offset
 10    17*     and changed the comment on the changer structure to indicate
 10    18*     that it will contain on database creation information.
 10    19*  4) change(82-04-14,Davids), approve(), audit(), install():
 10    20*     used one of the unused_offsets to point to a message which indicates
 10    21*     why the db is inconsistent. The offset will be null when the db is created
 10    22*     and set the first time the message is used. this is so it will be
 10    23*     consistent with existing data bases. Also added the message structure.
 10    24*  5) change(82-04-28,Davids), approve(), audit(), install():
 10    25*     added the undo_request element to the message structure
 10    26*  6) change(82-05-04,Davids), approve(), audit(), install():
 10    27*     changed unused_offset (12) to last_restructruring_history_offset and
 10    28*     changed restructuring_history_offset to first_restructuring_history_offset
 10    29*  7) change(82-08-19,Davids), approve(), audit(), install():
 10    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
 10    31*     1 => vfile database and 2 => page_file database. Up to this point all
 10    32*     database types were equal to 1.
 10    33*  8) change(83-02-14,Davids), approve(), audit(), install():
 10    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
 10    35*     flags. This will allow information about transactions and dm_file
 10    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
 10    37*     change is compatable with all datamodels created by the released version
 10    38*     of mrds.
 10    39*  9) change(83-02-15,Davids), approve(), audit(), install():
 10    40*     added the rollback_on flag to the db_type_flags since it appears that you
 10    41*     can have a dmfile database that requires transactions but does not have any
 10    42*     journalizing. Also switched the order of the transactions_needed and
 10    43*     concurrency_on flags - this makes the change compatable with existing
 10    44*     dmfile databases except when displaying the model since concurrency_on and
 10    45*     rollback_on will be off in the model even though the dmfile relations had
 10    46*     them on during creation.
 10    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
 10    48*      Removed ctl_file_path_ptr.
 10    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
 10    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 10    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
 10    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
 10    53*      in the flag word for rmdb copying.
 10    54*                                                   END HISTORY COMMENTS */
 10    55 
 10    56 
 10    57 /* this include file contains the structures that go into the make up
 10    58*   of the "db_model" segment in the model for the database.
 10    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
 10    60*
 10    61*   the db_model structure goes at the base of the segment, and contains items unique to
 10    62*   the whole databse. in addition, it has an area of size to fill the
 10    63*   rest of a segment, that holds the lists of files and domains in the database.
 10    64*   these lists are singly forward linked lists. all "pointers" in the database model
 10    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
 10    66*   since actual pointers are process dependent on segment number.
 10    67*   the remaining structures are first a path_entry one to save pathnames in,
 10    68*   and the stack_item and constent structures, used to save a boolean
 10    69*   expression in polish form, with the stack represented by a linked list.
 10    70*   the final structure is one for identifying the status of version information */
 10    71 
 10    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
 10    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
 10    74 	     2 db_type_flags      unal,
 10    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
 10    76 	       3 unused	      (13) bit (1) unal,
 10    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
 10    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
 10    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
 10    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
 10    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
 10    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
 10    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
 10    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
 10    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
 10    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
 10    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
 10    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
 10    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
 10    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
 10    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
 10    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
 10    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
 10    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
 10    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
 10    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
 10    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
 10    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
 10    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
 10   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
 10   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
 10   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
 10   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
 10   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
 10   105 
 10   106      dcl	   dbm_ptr	      ptr;
 10   107 
 10   108 /* the files in the database each have a file_info containing
 10   109*   their name, the file_model for each file is found by initiating the
 10   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
 10   111*   the file_info list is a singly linked list in definition order */
 10   112 
 10   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
 10   114 	     2 file_name	      char (30),		/* name of file */
 10   115 	     2 file_id	      bit (36),		/* id number of file */
 10   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
 10   117 	     2 unused	      unal bit (18);	/* for future expansion */
 10   118 
 10   119      dcl	   fi_ptr		      ptr;
 10   120 
 10   121 /* each domain used in the database will have a domain info saved in the db_model
 10   122*   segment. it describes the domain of the given name, and it's options.
 10   123*   the domain_info's form a singly linked list in definition order */
 10   124 
 10   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
 10   126 	     2 name	      char (32),		/* name of domain */
 10   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
 10   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
 10   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
 10   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
 10   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
 10   132 	     2 reserved	      bit (31) unal,
 10   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
 10   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
 10   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
 10   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
 10   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
 10   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
 10   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
 10   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
 10   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
 10   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
 10   143 	     2 str_err_path_ptr   unal bit (18),
 10   144 	     2 str_after_path_ptr unal bit (18),
 10   145 	     2 get_before_path_ptr unal bit (18),
 10   146 	     2 get_err_path_ptr   unal bit (18),
 10   147 	     2 get_after_path_ptr unal bit (18),
 10   148 	     2 mod_before_path_ptr unal bit (18),
 10   149 	     2 mod_err_path_ptr   unal bit (18),
 10   150 	     2 mod_after_path_ptr unal bit (18),
 10   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
 10   152 	     2 unused_2	      unal bit (18),
 10   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
 10   154 
 10   155      dcl	   di_ptr		      ptr;
 10   156 
 10   157 /* information necessary for attributes that are not used in any relation */
 10   158 
 10   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
 10   160 	     2 name char (32),			/* name of attribute */
 10   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
 10   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
 10   163 	     2 unused (2) bit (18) unal;
 10   164 
 10   165      dcl     ua_ptr ptr;
 10   166 
 10   167 
 10   168 /* space saving pathname$entryname structure, to be allocated
 10   169*   only when a path$entry has to be saved, else only a bit(18)
 10   170*   offset takes up space in the main model structure */
 10   171 
 10   172      declare 1 path_entry	      based (path_entry_ptr),
 10   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
 10   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
 10   175 	     2 reserved	      unal bit (36);	/* for future use */
 10   176 
 10   177      declare path_entry_ptr	      ptr;
 10   178 
 10   179 
 10   180 
 10   181 
 10   182 
 10   183 /* declarations for model of postfix stack holding the check option boolean expression
 10   184*   the following encoding values indicate the corresponding type of stack element
 10   185*
 10   186*   1  =
 10   187*   2  ^=
 10   188*   3  >
 10   189*   4  <
 10   190*   5  >=
 10   191*   6  <=
 10   192*
 10   193*   10  and
 10   194*   20  or
 10   195*   30  not
 10   196*
 10   197*   40  - (minus)
 10   198*
 10   199*   50  domain variable(same name as domain)
 10   200*
 10   201*   60  constant(number, bit string, or character string)
 10   202*
 10   203**/
 10   204 
 10   205 
 10   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
 10   207 	     2 next	      bit (18),		/* link to next in list */
 10   208 	     2 type	      fixed binary,		/* code for this element type */
 10   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
 10   210*						   if this is a constant element type */
 10   211 
 10   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
 10   213 
 10   214 
 10   215 
 10   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
 10   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
 10   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
 10   219 
 10   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
 10   221 
 10   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
 10   223 
 10   224 /* version structure, giving status of source for CMDB/RMDB,
 10   225*   status of model, and status of resultant */
 10   226 
 10   227 /* version number is in form MM.N.Y
 10   228*   where MM is the major version number, N is the minor version alteration,
 10   229*   and Y is the lastest modification to that alteration,
 10   230*   where M and N represent numbers 0-9, and Y is a letter */
 10   231 
 10   232      declare 1 version_status	      unal based (version_status_ptr),
 10   233 	     2 cmdb_rmdb,
 10   234 	       3 major	      fixed bin,
 10   235 	       3 minor	      fixed bin,
 10   236 	       3 modification     char (4),
 10   237 	     2 model,
 10   238 	       3 major	      fixed bin,
 10   239 	       3 minor	      fixed bin,
 10   240 	       3 modification     char (4),
 10   241 	     2 resultant,
 10   242 	       3 major	      fixed bin,
 10   243 	       3 minor	      fixed bin,
 10   244 	       3 modification     char (4);
 10   245 
 10   246      declare version_status_ptr     ptr;
 10   247 
 10   248 
 10   249 /* maintains information only about the db creation */
 10   250 
 10   251      declare 1 changer	      unal based (changer_ptr),
 10   252 	     2 id		      char (32),
 10   253 	     2 time	      fixed bin (71),
 10   254 	     2 next	      bit (18);		/* to next in the singly linked list */
 10   255 
 10   256      declare changer_ptr	      ptr;
 10   257 
 10   258 
 10   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
 10   260 	     02 len	      fixed bin,		/* length of the message */
 10   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
 10   262 	     02 name	      char (32),		/* name of thing that set the message */
 10   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
 10   264*                                                               that caused the database to become inconsistent */
 10   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
 10   266 
 10   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
 10   268 
 10   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
 10   270 
 10   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
 10   272 
 10   273 
     1221 
     1222 
     1223      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1143.7  mrds_rst_file_handler.pl1         >special_ldd>install>MR12.0-1187>mrds_rst_file_handler.pl1
1212         1    10/14/83  1609.0  mrds_rst_struct_types.incl.pl1    >ldd>include>mrds_rst_struct_types.incl.pl1
1213         2    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
1214         3    10/14/83  1609.1  mrds_rst_rsc.incl.pl1             >ldd>include>mrds_rst_rsc.incl.pl1
1215         4    10/14/83  1608.4  mrds_rst_semantics.incl.pl1       >ldd>include>mrds_rst_semantics.incl.pl1
1216         5    10/14/83  1608.6  mrds_rst_parse_info.incl.pl1      >ldd>include>mrds_rst_parse_info.incl.pl1
1217         6    10/14/83  1608.6  mrds_rst_tree.incl.pl1            >ldd>include>mrds_rst_tree.incl.pl1
1218         7    10/14/83  1608.4  mrds_rst_global_lists.incl.pl1    >ldd>include>mrds_rst_global_lists.incl.pl1
1219         8    10/16/86  1139.9  mdbm_file_model.incl.pl1          >special_ldd>install>MR12.0-1187>mdbm_file_model.incl.pl1
1220         9    10/16/86  1140.0  mdbm_file_model_init.incl.pl1     >special_ldd>install>MR12.0-1187>mdbm_file_model_init.incl.pl1
1221        10    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTR_INFO                       000204 constant        fixed bin(17,0)          initial dcl 1-59 set ref 619*
ATTR_SL                         000256 automatic       bit(1)                   unaligned dcl 1139 set ref 800*
BYTE                            000431 automatic       fixed bin(17,0)          initial dcl 1195 set ref 1195*
DEFINE                                 constant        fixed bin(17,0)          initial dcl 4-29 ref 286
DOUBLE_WORD                     000433 automatic       fixed bin(17,0)          initial dcl 1197 set ref 1197*
FILE_INFO                       000200 constant        fixed bin(17,0)          initial dcl 1-46 set ref 451*
GL                              000123 constant        fixed bin(17,0)          initial dcl 1-72 set ref 224* 248*
IN                              000113 constant        bit(1)                   initial unaligned dcl 1185 set ref 144*
MAIN_LIST                       000200 constant        fixed bin(17,0)          initial dcl 7-63 set ref 232* 275
NULL_OFFSET                            constant        bit(18)                  initial unaligned dcl 1148 ref 486 488 495 706 723
                                                                                  737 904
OFF                                    constant        bit(1)                   initial unaligned dcl 1146 ref 200 284 285 288 291
                                                                                  294 295 296 298 314 403 601 699 700 701 702 723
                                                                                  725 757 758 764 899 906
ON                              000113 constant        bit(1)                   initial unaligned dcl 1144 set ref 173 215 239 256
                                                                                  283 287 292 297 370 408 458 508* 526 553 558 608
                                                                                  622 625 680 718 763 769 770 925 929 1051
OUT                             000175 constant        bit(1)                   initial unaligned dcl 1187 set ref 192*
REDEFINE                               constant        fixed bin(17,0)          initial dcl 4-30 ref 149
REL_INFO                        000112 constant        fixed bin(17,0)          initial dcl 1-58 set ref 551*
SUB_LIST                        000201 constant        fixed bin(17,0)          initial dcl 7-64 set ref 377* 396
UNDEFINE                               constant        fixed bin(17,0)          initial dcl 4-28 ref 131 149
WORD                            000432 automatic       fixed bin(17,0)          initial dcl 1196 set ref 876* 879* 978* 1196*
addr                                                   builtin function         dcl 1142 ref 540 914
affected                 26            based           bit(1)                   level 2 packed unaligned dcl 7-15 set ref 283*
ai_ptr                          000502 automatic       pointer                  dcl 8-209 set ref 619* 622 639 644 649 670 696 697
                                                                                  698 699 700 701 702 703 704 705 705 706 725 737
                                                                                  739 743 745 854 861 863 866 875 879 884 888 904
                                                                                  911
all_attributes_used             000436 automatic       bit(1)                   unaligned dcl 1200 set ref 601* 606 608*
allow_blocked_files     206(18)        based           bit(1)                   level 2 packed unaligned dcl 3-29 ref 168
amount_to_pad                   000652 automatic       fixed bin(17,0)          dcl 986 set ref 978* 979 980 981
attr_gl_ptr                     000246 automatic       pointer                  dcl 1135 set ref 614 615 622 626 681 799* 800 906
                                                                                  912
attr_info                              based           structure                level 1 dcl 8-192
attr_ptr                 24(18)        based           bit(18)                  level 2 packed unaligned dcl 8-126 set ref 716 743*
attr_sl_ptr                     000254 automatic       pointer                  dcl 1138 set ref 642 643 644 800*
attribute                              based           structure                level 1 dcl 5-63
attribute_ptr                   000446 automatic       pointer                  dcl 5-73 set ref 674 696 698 703 704 803* 804 886
ave_len                  13            based           fixed bin(35,0)          level 2 dcl 10-125 ref 926 930
average_varying_length          000426 automatic       fixed bin(35,0)          dcl 1192 set ref 876 876* 926* 930*
avg_data_len             20            based           fixed bin(35,0)          level 2 dcl 8-126 set ref 866* 866 876* 876 981* 981
bit_36_temp                     000430 automatic       fixed bin(35,0)          dcl 1194 set ref 447* 585*
bit_length               14            based           fixed bin(35,0)          level 2 dcl 8-192 set ref 854* 863 866 879* 884 888
bit_offset               13            based           fixed bin(35,0)          level 2 dcl 8-192 set ref 861* 875*
blocked_file_seen       206(19)        based           bit(1)                   level 2 packed unaligned dcl 3-29 set ref 170 173*
ceil                                                   builtin function         dcl 1142 ref 444 1002 1003 1042 1085
changer_ptr              32(18)        based           bit(18)                  level 2 in structure "db_model" packed unaligned
                                                                                  dcl 10-72 in procedure "mrds_rst_file_handler" ref
                                                                                  539
changer_ptr              20(18)        based           bit(18)                  level 2 in structure "attr_info" packed unaligned
                                                                                  dcl 8-192 in procedure "mrds_rst_file_handler" set
                                                                                  ref 697*
changer_ptr              44(27)        based           bit(18)                  level 2 in structure "file_model" packed unaligned
                                                                                  dcl 8-40 in procedure "mrds_rst_file_handler" set
                                                                                  ref 539* 584 697
changer_ptr              43(18)        based           bit(18)                  level 2 in structure "rel_info" packed unaligned
                                                                                  dcl 8-126 in procedure "mrds_rst_file_handler" set
                                                                                  ref 584*
char                                                   builtin function         dcl 1142 ref 1115
cmdb                     26(01)        based           bit(1)                   level 2 packed unaligned dcl 7-15 set ref 288* 292*
complete                 26(07)        based           bit(1)                   level 2 packed unaligned dcl 7-15 set ref 296* 412
                                                                                  553* 622*
consistant               26(08)        based           bit(1)                   level 2 packed unaligned dcl 7-15 set ref 297* 314*
                                                                                  906*
current_ai_ptr                  000414 automatic       pointer                  dcl 1159 set ref 716* 723 725 729 730* 730 737 739
current_definition_order        000435 automatic       fixed bin(17,0)          dcl 1199 set ref 602* 659* 659 766
data                                   based           pointer                  level 2 dcl 6-41 ref 351 798 821
data_ptr                               parameter       pointer                  dcl 839 set ref 814 821* 832*
db_desc                  11            based           bit(36)                  level 2 dcl 10-125 set ref 914
db_model                               based           structure                level 1 dcl 10-72
db_model_path                   000111 automatic       char(168)                unaligned dcl 1125 set ref 438* 451*
dbm_ptr                         000504 automatic       pointer                  dcl 10-106 set ref 442* 443 443 444 444 444 447 488
                                                                                  488 494 494 496 539 578 578 585 997 998 998 1000
                                                                                  1002 1044 1044 1052 1067
default                  17            based           bit(1)                   level 2 packed unaligned dcl 5-89 ref 166 204 257
                                                                                  1113
define                   26(03)        based           bit(1)                   level 2 packed unaligned dcl 7-15 set ref 287* 291*
defn_order               12            based           fixed bin(17,0)          level 2 in structure "attr_info" packed unaligned
                                                                                  dcl 8-192 in procedure "mrds_rst_file_handler" set
                                                                                  ref 703* 725 725
defn_order               13            based           fixed bin(17,0)          level 2 in structure "attribute" dcl 5-63
                                                                                  in procedure "mrds_rst_file_handler" ref 703 804
delete_name                            based           structure                level 1 dcl 5-160
delete_name_ptr                 000454 automatic       pointer                  dcl 5-165 set ref 132* 133
desc_ptr                        000440 automatic       pointer                  dcl 2-19 set ref 859* 907* 914* 918 924 928
descriptor                             based           structure                level 1 unaligned dcl 2-6
descriptor_bit_36_ovrly                based           bit(36)                  unaligned dcl 1203 set ref 918*
di_ptr                          000510 automatic       pointer                  dcl 10-155 set ref 614* 903 911 912 913 914 926 930
directive                              based           structure                level 1 unaligned dcl 4-5
directive_ptr                   000012 internal static pointer                  dcl 4-24 in procedure "mrds_rst_file_handler" set
                                                                                  ref 129* 131 149 149 150 286 491
directive_ptr           242            based           pointer                  level 2 in structure "rsc" dcl 3-29 in procedure
                                                                                  "mrds_rst_file_handler" ref 129
dom_sl_ptr                      000250 automatic       pointer                  dcl 1136 set ref 615* 647 649
domain_bit_length               000632 automatic       fixed bin(35,0)          dcl 939 set ref 905* 918* 936
domain_info                            based           structure                level 1 dcl 10-125
domain_ptr               17            based           bit(18)                  level 2 packed unaligned dcl 8-192 set ref 904* 911*
empty                                                  builtin function         dcl 1142 ref 540
error_code                      000267 automatic       fixed bin(35,0)          dcl 1154 set ref 230* 232* 236 377* 381 387* 508*
                                                                                  514 519*
error_mode                      000245 automatic       bit(1)                   unaligned dcl 1132 set ref 200* 215* 230 239* 256*
                                                                                  472
fi_ptr                          000506 automatic       pointer                  dcl 10-119 in procedure "mrds_rst_file_handler" set
                                                                                  ref 371 451* 453 469 470 477 481 482 486 486 488
                                                                                  500 502 538
fi_ptr                   22(27)        based           bit(18)                  level 2 in structure "file_model" packed unaligned
                                                                                  dcl 8-40 in procedure "mrds_rst_file_handler" set
                                                                                  ref 538*
file                                   based           structure                level 1 dcl 5-89 in procedure
                                                                                  "mrds_rst_file_handler"
file                      6            based           structure                array level 2 in structure "stmt" unaligned dcl 4-37
                                                                                  in procedure "mrds_rst_file_handler"
file_id                  10            based           bit(36)                  level 2 dcl 10-113 set ref 482*
file_id_space                   000662 automatic       fixed bin(17,0)          dcl 1071 set ref 997* 1042* 1067
file_info                              based           structure                level 1 dcl 10-113
file_info_ptr            22            based           pointer                  level 2 dcl 7-15 set ref 281* 371* 469*
file_model                             based           structure                level 1 dcl 8-40
file_model_path                 000163 automatic       char(200)                unaligned dcl 1126 set ref 475* 551* 619*
file_model_ptr           24            based           pointer                  level 2 dcl 7-15 set ref 282* 372* 527*
file_name                       000257 automatic       char(30)                 unaligned dcl 1141 in procedure
                                                                                  "mrds_rst_file_handler" set ref 133* 137* 144*
                                                                                  192*
file_name                              based           char(30)                 level 2 in structure "file_info" dcl 10-113
                                                                                  in procedure "mrds_rst_file_handler" set ref 481*
file_ptr                        000450 automatic       pointer                  dcl 5-104 in procedure "mrds_rst_file_handler" set
                                                                                  ref 136* 137 166 204 208 216 216 232 240 240 253
                                                                                  253 257 257 262 262 276 278 331 341 359 382 459
                                                                                  474 559 626 1052 1091 1113 1115
file_ptr                 22            based           bit(18)                  level 2 in structure "db_model" packed unaligned
                                                                                  dcl 10-72 in procedure "mrds_rst_file_handler" set
                                                                                  ref 488 488* 494
fixed                                                  builtin function         dcl 1142 ref 444 540
fm_area                  46            based           area                     level 2 dcl 8-40 set ref 540* 540
fm_ptr                          000476 automatic       pointer                  dcl 8-108 set ref 372 508* 527 537 538 539 540 540
                                                                                  584 587 697 716 730
found                           000573 automatic       bit(1)                   unaligned dcl 779 in procedure
                                                                                  "definition_order_found" set ref 757* 759 763*
                                                                                  769*
found                                  parameter       bit(1)                   unaligned dcl 810 in procedure
                                                                                  "get_definition_order" set ref 785 790* 793
fwd_ptr                  11            based           bit(18)                  level 2 packed unaligned dcl 10-113 set ref 486* 495
                                                                                  496 500*
fwd_thread               20            based           bit(18)                  level 2 packed unaligned dcl 8-192 set ref 730 737*
                                                                                  739* 745*
gl                                     based           structure                level 1 dcl 7-15
gl_ptr                          000472 automatic       pointer                  dcl 7-36 set ref 224* 232* 248* 275 276 277 278 279
                                                                                  279 280 281 282 283 284 285 287 288 291 292 294
                                                                                  295 296 297 298 306 314 314 373 377 401 408 469
                                                                                  470 526 527
global_list_ptr          22            based           pointer                  level 2 dcl 7-40 set ref 402* 799
h_gfile_ptr             216            based           pointer                  level 2 dcl 3-29 set ref 232*
h_grel_ptr              224            based           pointer                  level 2 dcl 3-29 set ref 208* 336*
h_n_seg_info_ls_ptr     214            based           pointer                  level 2 dcl 3-29 set ref 508*
i_ptr                                  based           pointer                  level 2 dcl 5-89 ref 331
index_attr               10(01)        based           bit(1)                   level 2 packed unaligned dcl 8-192 set ref 699*
index_id                 11            based           bit(36)                  level 2 dcl 8-192 set ref 702*
inferior_assigned        26(06)        based           bit(1)                   level 2 packed unaligned dcl 7-15 set ref 295* 314
                                                                                  408* 412
init_file_model                 000000 constant        structure                level 1 dcl 9-18 ref 537
init_rel_info                   000046 constant        structure                level 1 dcl 9-65 ref 582
ioa_$rs                         000060 constant        entry                    external dcl 1180 ref 153 174 216 240 257 262 341
                                                                                  359 382 459 515 559 626 681 824 1052 1091
item                                   based           structure                level 1 dcl 5-150
item_info_ptr            12            based           pointer                  level 2 in structure "sl" dcl 7-40 in procedure
                                                                                  "mrds_rst_file_handler" set ref 398* 570* 639*
                                                                                  643* 649*
item_info_ptr            12            based           pointer                  level 2 in structure "gl" dcl 7-15 in procedure
                                                                                  "mrds_rst_file_handler" set ref 277* 470* 569* 615
item_ptr                        000452 automatic       pointer                  dcl 5-157 set ref 331* 332 336 341 341 428* 428
item_sub_list_ptr        20            based           pointer                  level 2 dcl 7-15 set ref 280* 377* 600 800*
key                                    parameter       char(32)                 dcl 835 set ref 814 819* 824*
key_attr                 10            based           bit(1)                   level 2 packed unaligned dcl 8-192 set ref 698*
key_length_in_chars             000422 automatic       fixed bin(35,0)          dcl 1175 set ref 1085* 1087 1091*
key_order                14            based           fixed bin(17,0)          level 2 in structure "attribute" dcl 5-63
                                                                                  in procedure "mrds_rst_file_handler" ref 704
key_order                12(18)        based           fixed bin(17,0)          level 2 in structure "attr_info" packed unaligned
                                                                                  dcl 8-192 in procedure "mrds_rst_file_handler" set
                                                                                  ref 704*
last_ai_ptr                     000412 automatic       pointer                  dcl 1158 set ref 717* 729* 743 745
last_fi_ptr                     000010 internal static pointer                  dcl 1157 set ref 494* 495 496* 496 500 502*
like_file_model                        based           structure                level 1 dcl 9-62 set ref 537*
line_num                 13            based           fixed bin(24,0)          level 2 in structure "item" dcl 5-150 in procedure
                                                                                  "mrds_rst_file_handler" set ref 341*
line_num                 15            based           fixed bin(24,0)          level 2 in structure "relation" dcl 5-51
                                                                                  in procedure "mrds_rst_file_handler" set ref 359*
                                                                                  1091*
line_num                 20            based           fixed bin(24,0)          level 2 in structure "file" dcl 5-89 in procedure
                                                                                  "mrds_rst_file_handler" set ref 216* 240* 262*
                                                                                  1115
link_attr                10(02)        based           bit(1)                   level 2 packed unaligned dcl 8-192 set ref 700*
link_child_cnt           15            based           fixed bin(17,0)          level 2 dcl 8-192 set ref 705*
link_par_cnt             16            based           fixed bin(17,0)          level 2 dcl 8-192 set ref 705*
list_ptr                               parameter       pointer                  dcl 1184 ref 68 132 136
log2                                                   builtin function         dcl 1142 ref 444 1002 1003 1042
ltrim                                                  builtin function         dcl 1142 ref 1115
max                                                    builtin function         dcl 1142 ref 444 998
max_attrs               206(23)        based           bit(1)                   level 2 packed unaligned dcl 3-29 set ref 678 680*
max_data_len             17            based           fixed bin(35,0)          level 2 dcl 8-126 set ref 884* 884 980* 980
max_files               206(15)        based           bit(1)                   level 2 packed unaligned dcl 3-29 set ref 1048 1051*
max_key_len              21            based           fixed bin(35,0)          level 2 dcl 8-126 set ref 888* 888 1085
max_max_tuples           15(18)        based           fixed bin(35,0)          level 2 packed unaligned dcl 10-72 set ref 998* 998
                                                                                  1000 1002
max_tuples                      000420 automatic       fixed bin(71,0)          dcl 1173 set ref 330* 998
max_vfile_components            000665 automatic       fixed bin(17,0)          initial dcl 1074 set ref 1003 1074*
mdbm_util_$align_data_item      000070 constant        entry                    external dcl 1204 ref 859
mdbm_util_$get_data_bit_length  000066 constant        entry                    external dcl 1201 ref 918
message                         000270 automatic       varying char(320)        dcl 1155 set ref 153* 157 174* 178 216* 221 240* 245
                                                                                  257* 262* 267 341* 346 359* 366 382* 387 459* 464
                                                                                  515* 519 559* 564 626* 632 681* 687 824* 829 1052*
                                                                                  1058 1091* 1098
message_length                  000411 automatic       fixed bin(21,0)          dcl 1156 set ref 153* 174* 216* 240* 257* 262* 341*
                                                                                  359* 382* 459* 515* 559* 626* 681* 824* 1052*
                                                                                  1091*
mod                                                    builtin function         dcl 1142 ref 950 954
model_overflow          206(14)        based           bit(1)                   level 2 packed unaligned dcl 3-29 set ref 455 458*
                                                                                  555 558* 624 625*
mrds_data_$max_attributes       000076 external static fixed bin(35,0)          dcl 1209 set ref 678 681*
mrds_data_$max_key_len          000052 external static fixed bin(35,0)          dcl 1174 set ref 1087 1091*
mrds_data_$max_relations        000074 external static fixed bin(35,0)          dcl 1208 ref 1042 1044
mrds_error_$long_key            000034 external static fixed bin(35,0)          dcl 1163 set ref 1098*
mrds_error_$max_attributes      000100 external static fixed bin(35,0)          dcl 1210 set ref 687*
mrds_error_$rst_dup_file        000044 external static fixed bin(35,0)          dcl 1169 set ref 221* 245*
mrds_error_$rst_logic_error     000050 external static fixed bin(35,0)          dcl 1172 set ref 829*
mrds_error_$rst_model_limit     000032 external static fixed bin(35,0)          dcl 1161 set ref 464* 564* 632*
mrds_error_$rst_option_limit    000036 external static fixed bin(35,0)          dcl 1164 set ref 1058*
mrds_error_$rst_rel_has_file    000046 external static fixed bin(35,0)          dcl 1170 set ref 366*
mrds_error_$rst_reserved_name   000072 external static fixed bin(35,0)          dcl 1207 set ref 267*
mrds_error_$rst_undef_rel       000042 external static fixed bin(35,0)          dcl 1168 set ref 346*
mrds_error_$rst_undone_option   000040 external static fixed bin(35,0)          dcl 1166 set ref 157* 178*
mrds_rst_error                  000056 constant        entry                    external dcl 1178 ref 157 178 221 245 267 346 366
                                                                                  387 464 519 564 632 687 829 1058 1098
mrds_rst_get_seg_ptr            000030 constant        entry                    external dcl 1151 ref 508
mrds_rst_list_element$add       000062 constant        entry                    external dcl 1181 ref 232 377
mrds_rst_meter                  000064 constant        entry                    external dcl 1189 ref 144 192
mrds_rst_model_alloc            000020 constant        entry                    external dcl 1128 ref 451 551 619
mrds_rst_rsc_alloc              000016 constant        entry                    external dcl 1127 ref 224 248
mrds_rst_tree_search            000054 constant        entry                    external dcl 1176 ref 208 336 819
mrds_rst_tree_successor         000024 constant        entry                    external dcl 1133 ref 790
n_dm_ptr                232            based           pointer                  level 2 dcl 3-29 ref 442
name                                   based           char(32)                 level 2 in structure "rel_info" dcl 8-126
                                                                                  in procedure "mrds_rst_file_handler" set ref 583*
name                      2            based           char(32)                 level 2 in structure "relation" dcl 5-51
                                                                                  in procedure "mrds_rst_file_handler" set ref 359*
                                                                                  377* 382* 397 559* 583 800* 1091*
name                      2            based           char(32)                 level 2 in structure "item" dcl 5-150 in procedure
                                                                                  "mrds_rst_file_handler" set ref 336* 341*
name                      2            based           char(30)                 level 2 in structure "file" dcl 5-89 in procedure
                                                                                  "mrds_rst_file_handler" set ref 137 208 216* 232
                                                                                  240* 253 253 257* 262* 276 341* 359* 382* 459* 474
                                                                                  559* 626* 1052* 1091*
name                      1            based           char(32)                 level 2 in structure "sl" dcl 7-40 in procedure
                                                                                  "mrds_rst_file_handler" set ref 397*
name                                   based           char(32)                 level 2 in structure "attr_info" dcl 8-192
                                                                                  in procedure "mrds_rst_file_handler" set ref 696*
name                      1            based           char(32)                 level 2 in structure "gl" dcl 7-15 in procedure
                                                                                  "mrds_rst_file_handler" set ref 276* 359* 626*
                                                                                  626* 681* 681*
name                      2            based           char(32)                 level 2 in structure "attribute" dcl 5-63
                                                                                  in procedure "mrds_rst_file_handler" ref 696
name_of_file                    000100 automatic       varying char(30)         dcl 1124 set ref 472* 474* 475 481 508 515*
new_other_info_ptr       20            based           pointer                  level 2 dcl 7-40 set ref 401* 913*
next                                   based           pointer                  level 2 dcl 5-150 ref 428
node                                   based           structure                level 1 dcl 6-41
node_ptr                        000460 automatic       pointer                  dcl 6-27 in procedure "mrds_rst_file_handler" set
                                                                                  ref 208* 336* 351 756* 790* 797* 798
node_ptr                        000612 automatic       pointer                  dcl 837 in procedure "list_search" set ref 819* 821
null                                                   builtin function         dcl 1142 ref 277 280 281 282 332 398 400 453 477 553
                                                                                  574 622 642 647 670 717 737 743 832 903 907
num_attr                 12            based           fixed bin(17,0)          level 2 packed unaligned dcl 8-126 set ref 673* 673
                                                                                  678
num_blk_files            13            based           fixed bin(17,0)          level 2 packed unaligned dcl 10-72 ref 1044
num_dims                        000442 automatic       fixed bin(17,0)          initial dcl 2-20 set ref 2-20* 390*
num_key_attrs            14            based           fixed bin(17,0)          level 2 packed unaligned dcl 8-126 set ref 676* 676
num_rels                 14            based           fixed bin(17,0)          level 2 packed unaligned dcl 10-72 set ref 578* 578
                                                                                  585
num_unblk_files          13(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 10-72 set ref 443* 443
                                                                                  444 447 1044 1052*
number                    7            based           fixed bin(17,0)          array level 3 dcl 4-37 ref 150 491
number_of_bits                  000642 automatic       fixed bin(17,0)          dcl 963 set ref 950* 954* 958
nvar_atts                14(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 8-126 set ref 874* 874
                                                                                  875 974
old_other_info_ptr       16            based           pointer                  level 2 dcl 7-40 set ref 400* 644*
order_found                            parameter       fixed bin(17,0)          dcl 809 set ref 785 793* 804*
order_obtained                  000575 automatic       fixed bin(17,0)          dcl 781 set ref 761* 766
order_was_obtained              000574 automatic       bit(1)                   unaligned dcl 780 set ref 761* 762
other_info_ptr           16            based           pointer                  level 2 dcl 7-15 set ref 279* 359 373* 614 912*
overlay                                based           char(32)                 level 2 dcl 5-160 ref 133
pad_base                               parameter       fixed bin(35,0)          dcl 962 ref 943 950 954
pad_size                               parameter       fixed bin(17,0)          dcl 961 ref 943 950 954 954
padding                         000434 automatic       fixed bin(17,0)          dcl 1198 set ref 859* 861 863 866 879* 884
parent_ptr                      000614 automatic       pointer                  dcl 838 in procedure "list_search" set ref 819*
parent_ptr                      000462 automatic       pointer                  dcl 6-28 in procedure "mrds_rst_file_handler" set
                                                                                  ref 208* 336*
parse_info_ptr           14            based           pointer                  level 2 in structure "gl" dcl 7-15 in procedure
                                                                                  "mrds_rst_file_handler" set ref 278* 352
parse_info_ptr           14            based           pointer                  level 2 in structure "sl" dcl 7-40 in procedure
                                                                                  "mrds_rst_file_handler" set ref 399* 803
place_not_found                 000416 automatic       bit(1)                   unaligned dcl 1160 set ref 718* 722 723* 725*
pointer                                                builtin function         dcl 1142 ref 494 496 716 730
pr_key                   12            based           bit(1)                   level 2 packed unaligned dcl 5-63 ref 674 698 886
redefine                 26(04)        based           bit(1)                   level 2 packed unaligned dcl 7-15 set ref 285*
rel                                                    builtin function         dcl 1142 ref 488 500 538 540 587 723 739 743 745 911
rel_gl_ptr                      000424 automatic       pointer                  dcl 1191 set ref 351* 352 356 359 370 371 372 373
                                                                                  402 412 412 553 569 600 626 681
rel_info                               based           structure                level 1 dcl 8-126 set ref 582*
rel_ptr                  20(27)        based           bit(18)                  level 2 packed unaligned dcl 8-40 set ref 587*
rel_sl_ptr                      000252 automatic       pointer                  dcl 1137 set ref 639 798* 799 803 913
relation                               based           structure                level 1 dcl 5-51
relation_ptr                    000444 automatic       pointer                  dcl 5-60 set ref 352* 359 359 377 382 397 399 559
                                                                                  583 800 1091 1091
required_order_found            000572 automatic       bit(1)                   unaligned dcl 778 set ref 758* 764* 770* 775
reserved                 10(03)        based           bit(33)                  level 2 in structure "attr_info" packed unaligned
                                                                                  dcl 8-192 in procedure "mrds_rst_file_handler" set
                                                                                  ref 701*
reserved                 26(09)        based           bit(26)                  level 2 in structure "gl" packed unaligned dcl 7-15
                                                                                  in procedure "mrds_rst_file_handler" set ref 298*
reserved                 24            based           bit(36)                  level 2 in structure "sl" packed unaligned dcl 7-40
                                                                                  in procedure "mrds_rst_file_handler" set ref 403*
returned_line                   000702 automatic       varying char(20)         dcl 1120 set ref 1113* 1115* 1117
ri_ptr                          000500 automatic       pointer                  dcl 8-185 set ref 551* 553 569 570 574 582 583 584
                                                                                  587 643 673 673 676 676 678 716 743 859 861 863
                                                                                  863 866 866 874 874 875 876 876 884 884 888 888
                                                                                  974 978 979 979 980 980 981 981 1085
root_ptr                               parameter       pointer                  dcl 836 in procedure "list_search" set ref 814 819*
root_ptr                        000456 automatic       pointer                  dcl 6-26 in procedure "mrds_rst_file_handler" set
                                                                                  ref 600* 756 790*
rsc                                    based           structure                level 1 unaligned dcl 3-29
rsc_ptr                                parameter       pointer                  dcl 3-94 set ref 68 128 129 142 144* 157* 168 170
                                                                                  173 178* 190 192* 208 221* 224* 232* 232 245* 248*
                                                                                  267* 336 346* 366* 377* 387* 438 442 451* 455 458
                                                                                  464* 475 508* 508 519* 551* 555 558 564* 619* 624
                                                                                  625 632* 678 680 687* 829* 1048 1051 1058* 1098*
rslt_ptr                 17(18)        based           bit(18)                  level 2 packed unaligned dcl 8-192 set ref 706*
rtrim                                                  builtin function         dcl 1142 ref 133 438 474 475
sl                                     based           structure                level 1 dcl 7-40
sl_ptr                          000474 automatic       pointer                  dcl 7-50 set ref 377* 396 397 398 399 400 401 402
                                                                                  403 570
stmt                                   based           structure                array level 1 unaligned dcl 4-37
stmt_ptr                        000014 internal static pointer                  dcl 4-68 in procedure "mrds_rst_file_handler" set
                                                                                  ref 128* 150 491
stmt_ptr                244            based           pointer                  level 2 in structure "rsc" dcl 3-29 in procedure
                                                                                  "mrds_rst_file_handler" ref 128
success                         000470 automatic       bit(1)                   unaligned dcl 6-38 in procedure
                                                                                  "mrds_rst_file_handler" set ref 208* 212 336* 340
success                                parameter       bit(1)                   unaligned dcl 840 in procedure "list_search" set ref
                                                                                  814 819* 821
successor_parent_ptr            000466 automatic       pointer                  dcl 6-31 set ref 790*
successor_ptr                   000464 automatic       pointer                  dcl 6-30 set ref 790* 797
superior_assigned        26(05)        based           bit(1)                   level 2 packed unaligned dcl 7-15 set ref 294* 306
                                                                                  356 370* 526*
sys_info$max_seg_size           000026 external static fixed bin(35,0)          dcl 1150 ref 540
temp_dir                134            based           char(168)                level 2 packed unaligned dcl 3-29 ref 438 475
trace_sw                206(07)        based           bit(1)                   level 2 packed unaligned dcl 3-29 ref 142 190
tuple_id_space                  000663 automatic       fixed bin(17,0)          dcl 1072 set ref 1000* 1002*
type                                   based           fixed bin(17,0)          level 2 in structure "gl" dcl 7-15 in procedure
                                                                                  "mrds_rst_file_handler" set ref 275*
type                                   based           fixed bin(17,0)          level 2 in structure "directive" dcl 4-5
                                                                                  in procedure "mrds_rst_file_handler" ref 131 149
                                                                                  149 150 286 491
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "descriptor" packed unsigned
                                                                                  unaligned dcl 2-6 in procedure
                                                                                  "mrds_rst_file_handler" ref 924 928
type                                   based           fixed bin(17,0)          level 2 in structure "sl" dcl 7-40 in procedure
                                                                                  "mrds_rst_file_handler" set ref 396*
unblk_file_id_len        12(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 10-72 set ref 444* 444
                                                                                  997 1067*
undefine                 26(02)        based           bit(1)                   level 2 packed unaligned dcl 7-15 set ref 284*
unique_chars_                   000022 constant        entry                    external dcl 1131 ref 472
unused                   11(18)        based           bit(18)                  level 2 packed unaligned dcl 10-113 set ref 486*
var_offset               22            based           fixed bin(35,0)          level 2 dcl 8-126 set ref 859 861 863* 863 978 979*
                                                                                  979
varying_string                  000427 automatic       bit(1)                   unaligned dcl 1193 set ref 858 899* 925* 929*
vfile_component_space           000664 automatic       fixed bin(17,0)          dcl 1073 set ref 1003*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ATD                                    internal static fixed bin(17,0)          initial dcl 1-63
ATTRIBUTE                              internal static fixed bin(17,0)          initial dcl 1-16
ATTRIBUTE_DOMAIN                       internal static fixed bin(17,0)          initial dcl 1-14
ATTR_LIST                              internal static fixed bin(17,0)          initial dcl 1-62
CHANGER                                internal static fixed bin(17,0)          initial dcl 1-52
CHILDREN                               internal static fixed bin(17,0)          initial dcl 1-21
CHILD_LINK_INFO                        internal static fixed bin(17,0)          initial dcl 1-61
CMDB                                   internal static fixed bin(17,0)          initial dcl 4-31
COMP_NO_ARRAY                          internal static fixed bin(17,0)          initial dcl 1-64
CONSTANT                               internal static fixed bin(17,0)          initial dcl 1-50
CUR_LEX_TOP                            internal static fixed bin(17,0)          initial dcl 1-36
DB_MODEL                               internal static fixed bin(17,0)          initial dcl 1-45
DELETE_NAME                            internal static fixed bin(17,0)          initial dcl 1-23
DIRECTIVE                              internal static fixed bin(17,0)          initial dcl 1-28
DISPLAY_INFO                           internal static fixed bin(17,0)          initial dcl 1-82
DOMAIN                                 internal static fixed bin(17,0)          initial dcl 1-13
DOMAIN_INFO                            internal static fixed bin(17,0)          initial dcl 1-47
DOM_LIST                               internal static fixed bin(17,0)          initial dcl 1-24
DUP_PREV                               internal static fixed bin(17,0)          initial dcl 1-66
FILE                                   internal static fixed bin(17,0)          initial dcl 1-17
FILE_MODEL                             internal static fixed bin(17,0)          initial dcl 1-57
FIXUP_TOKEN                            internal static fixed bin(17,0)          initial dcl 1-37
FOREIGN_KEY                            internal static fixed bin(17,0)          initial dcl 1-20
INDEX                                  internal static fixed bin(17,0)          initial dcl 1-22
ITEM                                   internal static fixed bin(17,0)          initial dcl 1-18
LEX_STACK                              internal static fixed bin(17,0)          initial dcl 1-34
LINK                                   internal static fixed bin(17,0)          initial dcl 1-19
LIST_OVRLY                             internal static fixed bin(17,0)          initial dcl 1-75
NODE                                   internal static fixed bin(17,0)          initial dcl 1-77
OUTPUT_TEXT                            internal static fixed bin(17,0)          initial dcl 1-40
PARENT_LINK_INFO                       internal static fixed bin(17,0)          initial dcl 1-60
PATH_ENTRY                             internal static fixed bin(17,0)          initial dcl 1-48
P_STRUCT                               internal static fixed bin(17,0)          initial dcl 1-35
RELATION                               internal static fixed bin(17,0)          initial dcl 1-15
SAVED_CHILD_COUNT                      internal static fixed bin(17,0)          initial dcl 1-76
SEGINFO                                internal static fixed bin(17,0)          initial dcl 1-74
SEG_INFO                               internal static fixed bin(17,0)          initial dcl 7-65
SELECT_CHAIN                           internal static fixed bin(17,0)          initial dcl 1-67
SL                                     internal static fixed bin(17,0)          initial dcl 1-73
SORT_KEY                               internal static fixed bin(17,0)          initial dcl 1-65
STACK_ITEM                             internal static fixed bin(17,0)          initial dcl 1-49
STMT                                   internal static fixed bin(17,0)          initial dcl 1-29
STRING_SOURCE                          internal static fixed bin(17,0)          initial dcl 1-38
TOKEN                                  internal static fixed bin(17,0)          initial dcl 1-39
VERSION_STATUS                         internal static fixed bin(17,0)          initial dcl 1-51
accum_token_ptr                        internal static pointer                  dcl 5-171
al_ptr                                 automatic       pointer                  dcl 8-345
alloc_length                           internal static fixed bin(35,0)          dcl 10-222
area_ptr                               automatic       pointer                  dcl 6-34
atd                                    based           char                     unaligned dcl 8-109
atd_len                                automatic       fixed bin(17,0)          dcl 8-111
atd_ptr                                automatic       pointer                  dcl 8-110
attdom_ptr                             automatic       pointer                  dcl 5-84
attr_list                              based           structure                level 1 dcl 8-341
attribute_domain                       based           structure                level 1 dcl 5-77
changer                                based           structure                level 1 packed unaligned dcl 10-251
changer_ptr                            automatic       pointer                  dcl 10-256
child_link_info                        based           structure                level 1 dcl 8-283
children                               based           structure                level 1 dcl 5-131
children_ptr                           automatic       pointer                  dcl 5-136
cli_ptr                                automatic       pointer                  dcl 8-329
cna_ptr                                automatic       pointer                  dcl 8-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 8-112
constant                               based           structure                level 1 unaligned dcl 10-216
constant_ptr                           automatic       pointer                  dcl 10-220
data_ptr                               automatic       pointer                  dcl 6-29
dom_list                               based           structure                level 1 unaligned dcl 5-189
dom_list_ptr                           automatic       pointer                  dcl 5-188
domain                                 based           structure                level 1 dcl 5-11
domain_ptr                             automatic       pointer                  dcl 5-45
dp_ptr                                 automatic       pointer                  dcl 8-356
dup_prev                               based           structure                level 1 dcl 8-353
fixup_token                            based           char                     unaligned dcl 5-178
foreign_key                            based           structure                level 1 dcl 5-139
forkey_ptr                             automatic       pointer                  dcl 5-147
index_ptr                              automatic       pointer                  dcl 5-115
key                                    automatic       char(32)                 dcl 6-24
link                                   based           structure                level 1 dcl 5-118
link_ptr                               automatic       pointer                  dcl 5-128
list_ovrly                             based           structure                level 1 dcl 7-67
list_ovrly_ptr                         automatic       pointer                  dcl 7-74
message_str                            based           structure                level 1 packed unaligned dcl 10-259
message_str_len                        automatic       fixed bin(17,0)          dcl 10-269
message_str_ptr                        automatic       pointer                  dcl 10-267
mrds_data_$max_line_size               external static fixed bin(35,0)          dcl 5-173
mrds_data_$max_string_size             external static fixed bin(35,0)          dcl 5-172
ncomp_init                             automatic       fixed bin(17,0)          dcl 8-116
output_text                            based           varying char             dcl 5-175
output_text_ptr                        internal static pointer                  dcl 5-177
parent_link_info                       based           structure                level 1 dcl 8-223
path_entry                             based           structure                level 1 packed unaligned dcl 10-172
path_entry_ptr                         automatic       pointer                  dcl 10-177
pli_ptr                                automatic       pointer                  dcl 8-268
predecessor_parent_ptr                 automatic       pointer                  dcl 6-33
predecessor_ptr                        automatic       pointer                  dcl 6-32
rel_index                              based           structure                level 1 dcl 5-107
saved_child_count                      based           fixed bin(17,0)          dcl 7-77
saved_child_count_ptr                  automatic       pointer                  dcl 7-78
sc_ptr                                 automatic       pointer                  dcl 8-365
seg_info                               based           structure                level 1 unaligned dcl 7-53
seg_info_ptr                           automatic       pointer                  dcl 7-59
select_chain                           based           structure                level 1 dcl 8-357
sk_ptr                                 automatic       pointer                  dcl 8-352
sort_key                               based           structure                level 1 dcl 8-346
source_size                            automatic       fixed bin(35,0)          dcl 5-182
stack_item                             based           structure                level 1 unaligned dcl 10-206
stack_item_ptr                         automatic       pointer                  dcl 10-212
string_source                          based           char                     unaligned dcl 5-184
string_source_ptr                      automatic       pointer                  dcl 5-183
thread                                 automatic       bit(1)                   dcl 6-39
token                                  based           varying char             dcl 5-169
token_length                           automatic       fixed bin(24,0)          dcl 5-174
ua_ptr                                 automatic       pointer                  dcl 10-165
unreferenced_attribute                 based           structure                level 1 dcl 10-159
version_status                         based           structure                level 1 packed unaligned dcl 10-232
version_status_ptr                     automatic       pointer                  dcl 10-246
work_area                              based           area(1024)               dcl 6-36

NAMES DECLARED BY EXPLICIT CONTEXT.
align_varying_tuple_data        006031 constant        entry                    internal dcl 967 ref 421
check_file_size_and_number      006066 constant        entry                    internal dcl 990 ref 319
check_relation_key_length       006346 constant        entry                    internal dcl 1078 ref 419
compute_bit_offset_and_length   005560 constant        entry                    internal dcl 844 ref 712
define_file                     001473 constant        entry                    internal dcl 195 ref 184
definition_order_found          005265 constant        entry                    internal dcl 750 ref 608
file_model_init                 004123 constant        entry                    internal dcl 533 ref 525
file_relation_handler           002420 constant        entry                    internal dcl 325 ref 310
get_definition_order            005325 constant        entry                    internal dcl 785 ref 761
get_domain_bit_size             005711 constant        entry                    internal dcl 893 ref 854
line_number                     006556 constant        entry                    internal dcl 1107 ref 459 559 626 1052
list_search                     005412 constant        entry                    internal dcl 814 ref 800
load_attr_infos                 004432 constant        entry                    internal dcl 593 ref 417
load_file_model                 003246 constant        entry                    internal dcl 433 ref 302
load_rel_info                   004156 constant        entry                    internal dcl 544 ref 407
mrds_rst_file_handler           001064 constant        entry                    external dcl 68
pad                             006011 constant        entry                    internal dcl 943 ref 876 879 978
set_attr_info                   004732 constant        entry                    internal dcl 663 ref 653

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7310        7412    6744        7320
Length     10126    6744       102         500     343           6

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_rst_file_handler              1421 external procedure  is an external procedure.  
define_file                             internal procedure  shares stack frame of external procedure mrds_rst_file_handler.  
file_relation_handler                   internal procedure  shares stack frame of external procedure mrds_rst_file_handler.  
load_file_model                         internal procedure  shares stack frame of external procedure mrds_rst_file_handler.  
file_model_init                         internal procedure  shares stack frame of external procedure mrds_rst_file_handler.  
load_rel_info                           internal procedure  shares stack frame of external procedure mrds_rst_file_handler.  
load_attr_infos                         internal procedure  shares stack frame of external procedure mrds_rst_file_handler.  
set_attr_info                           internal procedure  shares stack frame of external procedure mrds_rst_file_handler.  
definition_order_found                  internal procedure  shares stack frame of external procedure mrds_rst_file_handler.  
get_definition_order                    internal procedure  shares stack frame of external procedure mrds_rst_file_handler.  
list_search                             internal procedure  shares stack frame of external procedure mrds_rst_file_handler.  
compute_bit_offset_and_length           internal procedure  shares stack frame of external procedure mrds_rst_file_handler.  
get_domain_bit_size                     internal procedure  shares stack frame of external procedure mrds_rst_file_handler.  
pad                                     internal procedure  shares stack frame of external procedure mrds_rst_file_handler.  
align_varying_tuple_data                internal procedure  shares stack frame of external procedure mrds_rst_file_handler.  
check_file_size_and_number              internal procedure  shares stack frame of external procedure mrds_rst_file_handler.  
check_relation_key_length               internal procedure  shares stack frame of external procedure mrds_rst_file_handler.  
line_number                             internal procedure  shares stack frame of external procedure mrds_rst_file_handler.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 last_fi_ptr                 mrds_rst_file_handler
000012 directive_ptr               mrds_rst_file_handler
000014 stmt_ptr                    mrds_rst_file_handler

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_rst_file_handler    000100 name_of_file                mrds_rst_file_handler
                         000111 db_model_path               mrds_rst_file_handler
                         000163 file_model_path             mrds_rst_file_handler
                         000245 error_mode                  mrds_rst_file_handler
                         000246 attr_gl_ptr                 mrds_rst_file_handler
                         000250 dom_sl_ptr                  mrds_rst_file_handler
                         000252 rel_sl_ptr                  mrds_rst_file_handler
                         000254 attr_sl_ptr                 mrds_rst_file_handler
                         000256 ATTR_SL                     mrds_rst_file_handler
                         000257 file_name                   mrds_rst_file_handler
                         000267 error_code                  mrds_rst_file_handler
                         000270 message                     mrds_rst_file_handler
                         000411 message_length              mrds_rst_file_handler
                         000412 last_ai_ptr                 mrds_rst_file_handler
                         000414 current_ai_ptr              mrds_rst_file_handler
                         000416 place_not_found             mrds_rst_file_handler
                         000420 max_tuples                  mrds_rst_file_handler
                         000422 key_length_in_chars         mrds_rst_file_handler
                         000424 rel_gl_ptr                  mrds_rst_file_handler
                         000426 average_varying_length      mrds_rst_file_handler
                         000427 varying_string              mrds_rst_file_handler
                         000430 bit_36_temp                 mrds_rst_file_handler
                         000431 BYTE                        mrds_rst_file_handler
                         000432 WORD                        mrds_rst_file_handler
                         000433 DOUBLE_WORD                 mrds_rst_file_handler
                         000434 padding                     mrds_rst_file_handler
                         000435 current_definition_order    mrds_rst_file_handler
                         000436 all_attributes_used         mrds_rst_file_handler
                         000440 desc_ptr                    mrds_rst_file_handler
                         000442 num_dims                    mrds_rst_file_handler
                         000444 relation_ptr                mrds_rst_file_handler
                         000446 attribute_ptr               mrds_rst_file_handler
                         000450 file_ptr                    mrds_rst_file_handler
                         000452 item_ptr                    mrds_rst_file_handler
                         000454 delete_name_ptr             mrds_rst_file_handler
                         000456 root_ptr                    mrds_rst_file_handler
                         000460 node_ptr                    mrds_rst_file_handler
                         000462 parent_ptr                  mrds_rst_file_handler
                         000464 successor_ptr               mrds_rst_file_handler
                         000466 successor_parent_ptr        mrds_rst_file_handler
                         000470 success                     mrds_rst_file_handler
                         000472 gl_ptr                      mrds_rst_file_handler
                         000474 sl_ptr                      mrds_rst_file_handler
                         000476 fm_ptr                      mrds_rst_file_handler
                         000500 ri_ptr                      mrds_rst_file_handler
                         000502 ai_ptr                      mrds_rst_file_handler
                         000504 dbm_ptr                     mrds_rst_file_handler
                         000506 fi_ptr                      mrds_rst_file_handler
                         000510 di_ptr                      mrds_rst_file_handler
                         000572 required_order_found        definition_order_found
                         000573 found                       definition_order_found
                         000574 order_was_obtained          definition_order_found
                         000575 order_obtained              definition_order_found
                         000612 node_ptr                    list_search
                         000614 parent_ptr                  list_search
                         000632 domain_bit_length           get_domain_bit_size
                         000642 number_of_bits              pad
                         000652 amount_to_pad               align_varying_tuple_data
                         000662 file_id_space               check_file_size_and_number
                         000663 tuple_id_space              check_file_size_and_number
                         000664 vfile_component_space       check_file_size_and_number
                         000665 max_vfile_components        check_file_size_and_number
                         000702 returned_line               line_number

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        return_mac
fl2_to_fx1          mdfx1               shorten_stack       ext_entry           ceil_fx2            ceil_fl
divide_fx1          log_base_2_         double_log_base_2_  op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_$rs                       mdbm_util_$align_data_item    mdbm_util_$get_data_bit_length
mrds_rst_error                mrds_rst_get_seg_ptr          mrds_rst_list_element$add     mrds_rst_meter
mrds_rst_model_alloc          mrds_rst_rsc_alloc            mrds_rst_tree_search          mrds_rst_tree_successor
unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mrds_data_$max_attributes     mrds_data_$max_key_len        mrds_data_$max_relations      mrds_error_$long_key
mrds_error_$max_attributes    mrds_error_$rst_dup_file      mrds_error_$rst_logic_error   mrds_error_$rst_model_limit
mrds_error_$rst_option_limit  mrds_error_$rst_rel_has_file  mrds_error_$rst_reserved_name mrds_error_$rst_undef_rel
mrds_error_$rst_undone_option sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     68 001060      1195 001071      1196 001073      1197 001075    2   20 001077       128 001100       129 001105
    131 001107       132 001112       133 001115       134 001131       136 001132       137 001135       142 001140
    144 001144       149 001176       150 001204       153 001211       157 001251       160 001311       161 001312
    166 001313       168 001320       170 001327       173 001333       174 001335       178 001366       181 001426
    184 001427       190 001430       192 001437      1223 001472       195 001473       200 001474       204 001475
    208 001502       212 001527       215 001533       216 001535       221 001624       224 001664       230 001701
    232 001705       236 001735       239 001740       240 001742       245 002031       248 002071       253 002106
    256 002120       257 002122       262 002173       267 002257       270 002317       275 002320       276 002322
    277 002327       278 002331       279 002333       280 002335       281 002337       282 002341       283 002343
    284 002346       285 002350       286 002352       287 002356       288 002360       289 002362       291 002363
    292 002365       294 002367       295 002371       296 002373       297 002375       298 002377       302 002401
    306 002402       310 002407       314 002410       319 002416       323 002417       325 002420       330 002421
    331 002423       332 002426       336 002432       340 002455       341 002460       346 002562       349 002622
    351 002624       352 002627       356 002631       359 002635       366 002754       369 003014       370 003015
    371 003020       372 003022       373 003024       377 003026       381 003052       382 003054       387 003134
    390 003174       391 003176       396 003177       397 003201       398 003206       399 003210       400 003212
    401 003214       402 003217       403 003222       407 003224       408 003225       412 003230       417 003236
    419 003237       421 003240       428 003241       429 003244       431 003245       433 003246       438 003247
    442 003300       443 003303       444 003310       447 003326       451 003332       453 003357       455 003364
    458 003373       459 003375       464 003461       467 003521       469 003522       470 003525       472 003530
    474 003557       475 003600       477 003653       481 003661       482 003666       486 003670       488 003674
    491 003705       494 003714       495 003720       496 003727       498 003732       500 003733       502 003736
    508 003741       514 004003       515 004006       519 004052       520 004112       525 004114       526 004115
    527 004120       531 004122       533 004123       537 004124       538 004130       539 004134       540 004141
    542 004155       544 004156       551 004157       553 004204       555 004214       558 004223       559 004225
    564 004323       567 004363       569 004364       570 004367       574 004372       578 004377       582 004405
    583 004411       584 004415       585 004422       587 004425       591 004431       593 004432       600 004433
    601 004436       602 004437       606 004441       608 004444       614 004454       615 004457       619 004462
    622 004507       624 004517       625 004525       626 004527       632 004640       635 004700       639 004701
    642 004704       643 004710       644 004713       647 004716       649 004723       653 004726       659 004727
    660 004730       661 004731       663 004732       670 004733       673 004740       674 004746       676 004753
    678 004760       680 004773       681 004775       687 005072       690 005132       696 005133       697 005140
    698 005145       699 005151       700 005153       701 005155       702 005157       703 005160       704 005163
    705 005165       706 005167       712 005171       716 005172       717 005200       718 005202       722 005204
    723 005206       725 005213       729 005226       730 005227       733 005234       737 005235       739 005245
    743 005250       745 005261       748 005264       750 005265       756 005267       757 005271       758 005272
    759 005273       761 005276       762 005300       763 005303       764 005305       765 005306       766 005307
    769 005313       770 005315       773 005316       775 005317       785 005325       790 005327       793 005347
    797 005357       798 005361       799 005364       800 005366       803 005403       804 005406       812 005411
    814 005412       819 005414       821 005434       824 005446       829 005513       832 005553       842 005557
    844 005560       854 005561       858 005570       859 005572       861 005614       863 005622       866 005627
    869 005634       874 005635       875 005643       876 005645       879 005655       884 005670       886 005677
    888 005704       891 005710       893 005711       899 005713       903 005714       904 005720       905 005723
    906 005725       907 005730       908 005732       911 005733       912 005736       913 005741       914 005743
    918 005745       924 005756       925 005764       926 005766       927 005773       928 005774       929 005776
    930 006000       936 006005       943 006011       950 006013       954 006022       958 006025       967 006031
    974 006032       978 006040       979 006050       980 006055       981 006061       988 006065       990 006066
   1074 006067       997 006071       998 006076      1000 006112      1002 006122      1003 006130      1042 006137
   1044 006150      1048 006163      1051 006172      1052 006174      1058 006301      1061 006341      1067 006342
   1076 006345      1078 006346      1085 006347      1087 006360      1091 006364      1098 006514      1102 006554
   1105 006555      1107 006556      1113 006560      1115 006566      1117 006642


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
