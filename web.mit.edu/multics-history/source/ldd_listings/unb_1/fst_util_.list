	COMPILATION LISTING OF SEGMENT fst_util_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 01/19/88  1502.7 mst Tue
	    Options: optimize map

        1 /****^  ******************************************************
        2*        *                                                    *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987           *
        4*        *                                                    *
        5*        * Copyright (c) 1972 by Massachusetts Institute of   *
        6*        * Technology and Honeywell Information Systems, Inc. *
        7*        *                                                    *
        8*        ****************************************************** */
        9 
       10 
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(87-12-03,TLNguyen), approve(87-12-03,MCR7806),
       14*     audit(87-12-10,Lippard), install(88-01-19,MR12.2-1015):
       15*      - Fixed subscript range condition occured in the fst_util_$merge entry.
       16*      - Fixed substring range condition occured in the fst_util_$change entry.
       17*      - Replace the num_lines subscript of the t array field in the
       18*        basic_rsq_table based record with basic_rsq_table.num_lines as
       19*        coding standards.
       20*                                                   END HISTORY COMMENTS */
       21 
       22 
       23 fst_util_: proc;
       24 
       25 /*  This procedure implements the merge_text, move_text, change, input, and renumber commands.
       26*
       27*   Written 3/76 by S.E. Barr
       28*   Modified 11/76 by S.E. Barr to prevent change request from operationg on the entire text
       29*   Bug fixed in merging of non-basic text 06/24/81 S. Herbst
       30*   Modified 10/31/83 by C Spitzer. add cleanup handlers.
       31**/
       32 /*   parameters */
       33 
       34 dcl  arg_increment fixed bin;				/* increment for resequencing */
       35 dcl  code fixed bin (35);				/* fast error code */
       36 dcl  edit_ptr ptr;					/* ptr to structure with edit information */
       37 dcl  next_number fixed bin;				/* numbers generated for input must be less than this */
       38 dcl  new_string char (*) var;				/* replacement string for change entry */
       39 dcl  num_chars fixed bin (21);			/* number of characters in block to be moved */
       40 dcl  old_string char (*) var;				/* old string for change entry */
       41 dcl  seg char (*);					/* contents of segment to be inserted */
       42 dcl  seq_number fixed bin;				/* first vaule for renumbering */
       43 dcl  start fixed bin (21);				/* index in text of block to be moved */
       44 dcl  table_ptr ptr;					/* ptr to basic_rsq_table */
       45 dcl  table_1_ptr ptr;				/* ptr to 1st table for MERGE */
       46 dcl  table_2_ptr ptr;				/* ptr to  2nd table for MERGE */
       47 dcl  target fixed bin (21);				/* index in text before the new location of block */
       48 dcl  temp_length fixed bin (21);			/* number of characters in modified version of text */
       49 
       50 /* automatic */
       51 
       52 dcl  change_ok bit (1) unal;				/* ON if change is allowed */
       53 dcl  check bit (1) unal;				/* ON to prevent substitution of line numbers */
       54 dcl  check_null bit (1) unal;				/* ON to prevent forming a line number with a null string  */
       55 dcl  done bit (1) unal;
       56 dcl  i fixed bin (21);
       57 dcl  increment fixed bin;
       58 dcl  j fixed bin (21);
       59 dcl  len_new_string fixed bin;			/* number of characters in newstring */
       60 dcl  len_old_string fixed bin;			/* number  of characters in old_string */
       61 dcl  last_index fixed bin (21);			/* index in text of last character copied into temp */
       62 dcl  number_pic pic "99999";
       63 dcl  number_pic_blank pic "99999vb";
       64 dcl  temp_ptr ptr;
       65 
       66 /* based */
       67 
       68 dcl 1 basic_rsq_table aligned based (table_ptr),
       69     2 num_lines fixed bin,
       70     2 t (basic_rsq_table.num_lines) aligned,
       71       3 old_number fixed bin (17) unal,
       72       3 new_number fixed bin (17) unal;
       73 dcl 1 f aligned based (edit_ptr) like fst_edit_info;
       74 dcl  ptr_array (1) ptr based;
       75 dcl  text char (f.text_length) based (f.text_ptr);
       76 dcl  temp char (f.max_seg_size) based (temp_ptr);
       77 
       78 /* constants */
       79 
       80 dcl  check_line_number bit (1) unal int static options (constant) init ("1"b); /* ON if line numbers should be checked.
       81*						   OFF if only line references are checked */
       82 dcl  conditional bit (1) unal int static options (constant) init ("1"b); /* ON if renumber to prevent overlap.
       83*						   OFF must renumber */
       84 dcl  DIGIT char (10) int static init ("0123456789");
       85 dcl  NEW_LINE char int static init ("
       86 ");
       87 dcl  max_line_num fixed bin int static options (constant) init (99999);
       88 
       89 dcl (addr, addrel, index, substr, verify, length, mod, null, reverse) builtin;
       90 dcl  cleanup condition;
       91 
       92 /* external */
       93 
       94 dcl  dfast_basic_resequence_ entry (fixed bin (21), ptr, char (*), bit (1) unal, ptr, fixed bin (21), fixed bin (35));
       95 dcl  fst_cv_line_num_ entry (char (*), fixed bin, fixed bin (35)) returns (bit (1));
       96 dcl  ioa_ entry options (variable);
       97 dcl  iox_$get_line entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
       98 dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
       99 dcl  iox_$user_input ptr ext;
      100 dcl  iox_$user_output ptr ext;
      101 dcl  get_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
      102 dcl  release_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
      103 
      104 /*  */
  1     1 /* BEGIN INCLUDE FILE ... fst_edit_info.incl.pl1 */
  1     2 
  1     3 dcl 1 fst_edit_info aligned based (edit_ptr),
  1     4     2 pathname char (168) var,			/* path last used with new, old, save command */
  1     5     2 text_ptr ptr,					/* ptr to text being edited */
  1     6     2 alt_ptr ptr,					/* ptr to text additions not  yet included */
  1     7     2 text_length fixed bin (21),			/* number of characters in text */
  1     8     2 alt_length fixed bin (21),			/* number of characters in pending changes */
  1     9     2 max_seg_size fixed bin (21),			/* max. number of characters per segment */
  1    10     2 working_dir char (168) var,			/* path of the working directory */
  1    11     2 end_line_number fixed bin,			/* value of line number of the last line */
  1    12     2 flags aligned,
  1    13       3 subsystem bit (1) unal,			/* ON if entered as subsystem,  OFF if command */
  1    14       3 text_modified bit (1) unal,			/* ON if changes since last save */
  1    15       3 basic_source bit (1) unal,			/* ON if name ends with .basic */
  1    16       3 prompt bit (1) unal,				/* ON if should prompt after commands */
  1    17       3 pad bit (32) unal;
  1    18 
  1    19 /* END INCLUDE FILE ... fst_edit_info.incl.pl1 */
      105 
  2     1 /*  BEGIN INCLUDE ... dfast_error_codes.incl.pl1  */
  2     2 
  2     3 dcl  error_alt_empty fixed bin (35) int static init (1)options (constant);
  2     4 dcl  error_max_size fixed bin (35) int static init (2)options (constant);
  2     5 dcl  error_cur_empty fixed bin (35) int static init (3)options (constant);
  2     6 dcl  error_not_saved fixed bin (35) int static init (4)options (constant);
  2     7 dcl  error_name_dup fixed bin (35) int static init (5)options (constant);
  2     8 dcl  error_long_rec fixed bin (35) int static init (6)options (constant);
  2     9 dcl  error_unknown_arg fixed bin (35) int static init (7)options (constant);
  2    10 dcl  error_no_expl fixed bin (35) int static init (8)options (constant);
  2    11 dcl  error_bad_name fixed bin (35) int static init (9)options (constant);
  2    12 dcl  error_bad_req fixed bin (35) int static init (10)options (constant);
  2    13 dcl  error_syntax_string fixed bin (35) int static init (11)options (constant);
  2    14 dcl  error_name_miss fixed bin (35) int static init (12)options (constant);
  2    15 dcl  error_no_comp fixed bin (35) int static init (13)options (constant);
  2    16 dcl  error_no_main fixed bin (35) int static init (14)options (constant);
  2    17 dcl  error_block_spec fixed bin (35) int static init (15)options (constant);
  2    18 dcl  error_obj_nop fixed bin (35) int static init (16)options (constant);
  2    19 dcl  error_sav_cur fixed bin (35) int static init (17)options (constant);
  2    20 dcl  error_bad_type fixed bin (35) int static init (18)options (constant);
  2    21 dcl  error_unkn_sys fixed bin (35) int static init (19)options (constant);
  2    22 dcl  error_no_suffix fixed bin (35) int static init (20)options (constant);
  2    23 dcl  error_no_nl fixed bin (35) int static init (21)options (constant);
  2    24 dcl  error_bad_sort fixed bin (35) int static init (22)options (constant);
  2    25 dcl  error_no_num fixed bin (35) int static init (23)options (constant);
  2    26 dcl  error_line_miss fixed bin (35) int static init (24)options (constant);
  2    27 dcl  error_request_miss fixed bin (35) int static init (25)options (constant);
  2    28 dcl  error_bad_line fixed bin (35) int static init (26)options (constant);
  2    29 dcl  error_no_string fixed bin (35) int static init (27)options (constant);
  2    30 dcl  error_line_order fixed bin (35) int static init (28)options (constant);
  2    31 dcl  error_max_lines fixed bin (35) int static init (29)options (constant);
  2    32 dcl  error_bad_pathname fixed bin (35) int static init (30)options (constant);
  2    33 dcl  error_access_mode fixed bin (35) int static init (31)options (constant);
  2    34 dcl  error_delimiter_miss fixed bin (35) int static init (32)options (constant);
  2    35 dcl  error_size_fixed_record fixed bin (35) int static init (33)options (constant);
  2    36 dcl  error_bad_rec_len fixed bin (35) int static init (34)options (constant);
  2    37 dcl  error_string_size fixed bin (35) int static init (35)options (constant);
  2    38 dcl  error_max_line_number  fixed bin (35) int static init (36)options (constant);
  2    39 dcl  error_max_args fixed bin (35) int static init (37)options (constant);
  2    40 dcl  error_name_sys fixed bin (35) int static init (38)options (constant);
  2    41 dcl  error_dprint_map fixed bin (35) int static init (39)options (constant);
  2    42 dcl  error_max_num fixed bin (35) int static options (constant) init (40);
  2    43 dcl  error_edit_max_num fixed bin (35) int static options (constant) init (41);
  2    44 dcl  error_un_num_text fixed bin (35) int static options (constant) init (42);
  2    45 dcl  error_no_new_line fixed bin (35) int static options (constant) init (43);
  2    46 
  2    47 /* END INCLUDE ... dfast_error_codes.incl.pl1 */
      106 
      107 /*  */
      108 /*  This entry resequences the temporary text.
      109**/
      110 resequence: entry (edit_ptr, seq_number, arg_increment, temp_length, code);
      111 
      112 	temp_length = 0;
      113 	increment = arg_increment;
      114 	temp_ptr = f.alt_ptr;
      115 	if f.basic_source then do;
      116 	     table_ptr = null;
      117 
      118 	     on cleanup begin;
      119 		if table_ptr ^= null then call release_temp_segments_ ("fst_util_", addr (table_ptr) -> ptr_array, code);
      120 		end;
      121 
      122 	     call get_temp_segments_ ("fst_util_", addr (table_ptr) -> ptr_array, code);
      123 	     if code = 0 then do;
      124 		basic_rsq_table.num_lines = 0;
      125 		call fill_basic_table (^conditional, text);
      126 		if code = 0 then call dfast_basic_resequence_ (f.max_seg_size, table_ptr, text,
      127 		     "1"b, temp_ptr, temp_length, code);
      128 	     end;
      129 
      130 	     if table_ptr ^= null then call release_temp_segments_ ("fst_util_", addr (table_ptr) -> ptr_array, (0));
      131 	end;
      132 
      133 	else call renumber (^conditional, text);
      134 
      135 	return;
      136 
      137 /*   */
      138 /*  This entry inserts the segment "seg" into the temporary text after location start -1.  The segment to be
      139*   inserted is resequenced beginning with seq_number and incrementing by 10 to derive subsequent numbers.  If
      140*   the segment is inserted before the end of the temporary text, the text following seg will be resequenced, if
      141*   necessary, to prevent overlap.
      142**/
      143 merge:	entry (edit_ptr, seg, start, seq_number, temp_length, code);
      144 
      145 	temp_ptr = f.alt_ptr;
      146 	temp_length = 0;
      147 	increment = 10;
      148 	seq_number = seq_number + increment - mod (seq_number, increment);
      149 	if f.basic_source then do;
      150 	     table_ptr = null;
      151 
      152 	     on cleanup begin;
      153 		if table_ptr ^= null then call release_temp_segments_ ("fst_util_", addr (table_ptr) -> ptr_array, code);
      154 		end;
      155 
      156 	     call get_temp_segments_ ("fst_util_", addr (table_ptr) -> ptr_array, code);
      157 	     if code = 0 then do;
      158 		basic_rsq_table.num_lines = 0;
      159 
      160 /* There is no temporary text or the new segment is put at the end so the temporary text doesn't need to be changed. */
      161 
      162 		if f.text_length = 0 | start > f.text_length then do;
      163 		     if f.text_length > 0 then call copy (text);
      164 		     call fill_basic_table (^conditional, seg);
      165 		     call copy_rsq (check_line_number, seg);
      166 		end;
      167 
      168 /* segment is inserted at the beginning. */
      169 
      170 		else if start = 1 then do;
      171 		     call fill_basic_table (^conditional, seg);
      172 		     if code = 0 then do;
      173 			call copy_rsq (check_line_number, seg);
      174 			if code = 0 then do;
      175 			     basic_rsq_table.num_lines = 0;
      176 			     call fill_basic_table (conditional, text);
      177 			     if code = 0 then call copy_rsq (check_line_number, text);
      178 			end;
      179 		     end;
      180 		end;
      181 
      182 /* segment is inserted in the middle. */
      183 
      184 		else do;
      185 		     table_1_ptr = table_ptr;
      186 		     call fill_basic_table (^conditional, seg);
      187 		     if code = 0 then do;
      188 			table_2_ptr, table_ptr = addrel (addr (basic_rsq_table.t (basic_rsq_table.num_lines).old_number), 1);
      189 			call fill_basic_table (conditional, substr (text, start, f.text_length - start + 1));
      190 
      191 /* If the text didn't have to resequenced, it can be copied. */
      192 
      193 			if table_2_ptr -> basic_rsq_table.num_lines = 0 then do;
      194 			     call copy (substr (text, 1, start -1));
      195 			     table_ptr = table_1_ptr;
      196 			     call copy_rsq (check_line_number, seg);
      197 			     call copy (substr (text, start, f.text_length - start + 1));
      198 			end;
      199 
      200 /* text has to edited for line number reference changes. */
      201 
      202 			else do;
      203 			     call copy_rsq (^check_line_number, substr (text, 1, start-1));
      204 			     table_ptr = table_1_ptr;
      205 			     call copy_rsq (check_line_number, seg);
      206 			     table_ptr = table_2_ptr;
      207 			     call copy_rsq (check_line_number, substr (text, start, f.text_length - start + 1));
      208 			end;
      209 		     end;
      210 		end;
      211 	     end;
      212 	     if table_ptr ^= null then call release_temp_segments_ ("fst_util_", addr (table_ptr) -> ptr_array, (0));
      213 	end;
      214 	else do;
      215 	     if start > 1 then call copy (substr (text, 1, start -1));
      216 	     call renumber (^conditional, seg);
      217 	     if code = 0 then do;
      218 		if start <= f.text_length then call renumber (conditional, substr (text, start,
      219 		     f.text_length - start + 1));
      220 	     end;
      221 	end;
      222 	return;
      223 
      224 /*  */
      225 /* This entry moves a block of lines to a new location (target + 1) in the temporary text.  The block of lines
      226*   that are moved are resequenced beginning with seq_number and incrementing by 10.  Lines following the new location
      227*   of the moved lines will be resequenced, if necessary to prevent overlap
      228*   The block is not empty and there is no overlap of the target and the block.
      229*   *
      230*   *
      231*   *			___________			___________
      232*   *		1	|	|		1	|	|
      233*   *			|	|			|	|
      234*   *			___________			___________
      235*   *		target	|	|		start	|/////////|
      236*   *			|	|			|/////////|
      237*   *			___________			___________
      238*   *		start	|/////////|	start+num_chars	|	|
      239*   *			|/////////|			|	|
      240*   *			___________			___________
      241*   *	  start+num_chars	|	|		target	|	|
      242*   *			|	|			|	|
      243*   *			___________			___________
      244*   *	  f.text_length			f.text_length
      245**/
      246 move:	entry (edit_ptr, start, num_chars, target, seq_number, temp_length, code);
      247 
      248 	temp_ptr = f.alt_ptr;
      249 	temp_length = 0;
      250 	increment = 10;
      251 	seq_number = seq_number + increment - mod (seq_number, increment);
      252 	if f.basic_source then do;
      253 	     table_ptr = null;
      254 
      255 	     on cleanup begin;
      256 		if table_ptr ^= null then call release_temp_segments_ ("fst_util_", addr (table_ptr) -> ptr_array, code);
      257 		end;
      258 
      259 	     call get_temp_segments_ ("fst_util_", addr (table_ptr) -> ptr_array, code);
      260 	     if code = 0 then do;
      261 		call fill_basic_table (^conditional, substr (text, start, num_chars));
      262 		if target < start then do;
      263 		     if start - target - 1 > 0 then call fill_basic_table (conditional, substr (text, target+1,
      264 			start - target - 1));
      265 		     i = start + num_chars;
      266 		     if i <= f.text_length then call fill_basic_table (conditional, substr (text, i,
      267 			f.text_length - i + 1));
      268 
      269 		     if target > 0 then call copy_rsq (^check_line_number, substr (text, 1, target));
      270 		     call copy_rsq (check_line_number, substr (text, start, num_chars));
      271 		     if start - target -1 > 0 then call copy_rsq (check_line_number, substr (text, target+1,
      272 			start - target - 1));
      273 		     if i <= f.text_length then call copy_rsq (check_line_number, substr (text, i, f.text_length - i + 1));
      274 		end;
      275 		else do;
      276 		     if target < f.text_length then
      277 			call fill_basic_table (conditional, substr (text, target+1, f.text_length - target));
      278 
      279 		     if start > 1 then call copy_rsq (^check_line_number, substr (text, 1, start -1));
      280 		     i = start + num_chars;
      281 		     if i <= target then call copy_rsq (^check_line_number, substr (text, i, target - i + 1));
      282 		     call copy_rsq (check_line_number, substr (text, start, num_chars));
      283 		     if target < f.text_length then call copy_rsq (check_line_number, substr (text, target + 1,
      284 			f.text_length - target));
      285 		end;
      286 
      287 		if table_ptr ^= null then call release_temp_segments_ ("fst_util_", addr (table_ptr) -> ptr_array,
      288 		     (0));
      289 	     end;
      290 	end;
      291 
      292 	else do;
      293 	     if target < start then do;
      294 		if target > 0 then call copy (substr (text, 1, target));
      295 		call renumber (^conditional, substr (text, start, num_chars));
      296 		if start - target - 1 > 0 then call renumber (conditional, substr (text, target +1, start - target - 1));
      297 		i = start + num_chars;
      298 		if i <= f.text_length then call renumber (conditional, substr (text, i, f.text_length - i + 1));
      299 	     end;
      300 	     else do;
      301 		if start > 1 then call copy (substr (text, 1, start - 1));
      302 		i = start + num_chars;
      303 		if i <= target then call copy (substr (text, i, target - i +1));
      304 		call renumber (^conditional, substr (text, start, num_chars));
      305 		if target < f.text_length then call renumber (conditional, substr (text, target+1, f.text_length - target));
      306 	     end;
      307 	end;
      308 
      309 	return;
      310 
      311 /*  */
      312 /* * This entry replaces old_string with new_string within a block of lines.  A check to prevent changing line
      313*   * number is made if:
      314*   *
      315*   *	1.  old_string begins with a digit:
      316*   *		c/20/y/
      317*   *		20 x = 20 	->	20 x = y
      318*   *
      319*   *	2.  new_string begins with a digit:
      320*   *		c/ x/0/
      321*   *		20 x = x		->	20 x =0
      322*   *
      323*   *	3.  new_string is null:
      324*   *		c/  //
      325*   *		20  40  50	->	20  4050
      326**/
      327 change:	entry (edit_ptr, start, num_chars, old_string, new_string, temp_length, code);
      328 
      329 	len_new_string = length (new_string);
      330 	len_old_string = length (old_string);
      331 	temp_ptr = f.alt_ptr;
      332 
      333 /* set up checks if old_string or new_string begins with a digit or new_string is null. */
      334 
      335 	change_ok = "1"b;
      336 	
      337 	if len_new_string = 0 then do;
      338 	     if len_old_string = 0 then check = "0"b;
      339 	     else  check = (verify (substr (old_string, 1, 1), DIGIT) = 0);
      340 	end;
      341           else if len_old_string ^= 0 then check = (verify (substr (old_string, 1, 1), DIGIT) = 0) | (verify (substr (new_string, 1, 1), DIGIT) = 0);
      342 	else check = (verify (substr (new_string, 1, 1), DIGIT) = 0);
      343 
      344 	check_null = (len_new_string = 0);
      345 
      346 
      347 	last_index = 0;
      348 	do while (num_chars > 0);
      349 	     i = index (substr (text, start, num_chars), old_string) -1;
      350 	     if i > -1 then do;
      351 
      352 /* The check verifies back for the first non-digit.  If this is a new_line character or the start of the text,
      353*   the change is not allowed.  In the following case replacement is not allowed.
      354*   *
      355*   *	c /25/30/		abcdefgh(nl)1025 abc	(nl) = new line  character
      356*   *			|
      357*   *			start		(i = 12, j = 4)
      358**/
      359 		if check | check_null then do;
      360 		     j = verify (reverse (substr (text, 1, start+ i -1)), DIGIT);
      361 		     if j > 0 then do;
      362 			change_ok = (substr (text, start + i - j, 1) ^= NEW_LINE);
      363 		     end;
      364 		     else change_ok = "0"b;		/* all characters were digits (1st line) */
      365 
      366 /* This check overrides the previous one, if: 1) the second string was null, 2) the first string did not begin
      367*   with a digit and 3) the concationation will not form a line number.
      368*   *
      369*   *	c /ab//	 for "20abc"	-> "20c"		overrides
      370*   *		 for "20ab7"	-> "20ab7"	doesn't override previous check
      371**/
      372 		     if check_null & ^check then do;
      373 			if verify (substr (text, start + i + len_old_string, 1), DIGIT) > 0 then change_ok = "1"b;
      374 		     end;
      375 		end;
      376 
      377 		if change_ok then do;
      378 		     num_chars = num_chars - i - len_old_string;
      379 		     i = start + i -1;
      380 		     if i > last_index then call copy (substr (text, last_index + 1, i - last_index));
      381 		     if temp_length + len_new_string <= f.max_seg_size then do;
      382 			substr (temp, temp_length + 1, len_new_string) = new_string;
      383 			temp_length = temp_length + len_new_string;
      384 			last_index = i + len_old_string;
      385 			start = last_index + 1;
      386 		     end;
      387 		     else code = error_max_size;
      388 		end;
      389 		else do;
      390 		     change_ok = "1"b;
      391 		     start = start + i + 1;
      392 		     num_chars = num_chars - i - 1;
      393 		end;
      394 	     end;
      395 
      396 	     else num_chars = 0;
      397 	end;
      398 
      399 	if last_index = 0 then code = error_no_string;
      400 	else if last_index < f.text_length then call copy (substr (text, last_index+1, f.text_length - last_index));
      401 
      402 	return;
      403 
      404 /*   */
      405 /* * This entry implements input mode:  a line number is printed and the user completes the line.
      406*   * This mode is terminated when:
      407*   *
      408*   *	1.  The user types a line with only the new_line character.
      409*   *	2.  The next input line number would be equal or exceed next_number.
      410**/
      411 input:	entry (edit_ptr, start, seq_number, arg_increment, next_number, temp_length, code);
      412 
      413 	temp_ptr = f.alt_ptr;
      414 	increment = arg_increment;
      415 	seq_number = seq_number + increment - mod (seq_number, increment);
      416 
      417 
      418 	if start > 1 then call copy (substr (text, 1, start -1));
      419 
      420 	done = "0"b;
      421 	do while (seq_number < next_number & ^done);
      422 	     number_pic_blank = seq_number;
      423 	     call iox_$put_chars (iox_$user_output, addr (number_pic_blank), length (number_pic_blank), code);
      424 	     call copy ((number_pic_blank));
      425 	     call iox_$get_line (iox_$user_input, addr (substr (temp, temp_length + 1, 1)), 150, i, code);
      426 	     if code = 0 then do;
      427 		if i = 1 then do;
      428 		     temp_length = temp_length - 6;	/* remove last number and blank */
      429 		     seq_number = seq_number - increment;
      430 		     done = "1"b;
      431 		end;
      432 		else temp_length = temp_length + i;
      433 	     end;
      434 	     else done = "0"b;
      435 	     seq_number = seq_number + increment;
      436 	end;
      437 
      438 	if code = 0 then do;
      439 	     if start <= f.text_length then call copy (substr (text, start, f.text_length - start + 1));
      440 	     else f.end_line_number = seq_number - increment;
      441 	     if ^done then call ioa_ ("end of input mode.  Next line number is  ^d", next_number);
      442 	end;
      443 
      444 	return;
      445 
      446 
      447 /*  */
      448 /*  This procedure copies text from seg into the temporary buffer temp.  It renumbers the lines.
      449*
      450*   1.  If the line begins with a number, the number is replaced.
      451*   2.  If the line does not begin with a number, a number is added.
      452**/
      453 
      454 renumber:	proc (conditional, seg);
      455 
      456 
      457 dcl  conditional bit (1) unal;			/* ON if renumber only if necessary */
      458 dcl  seg char (*);
      459 
      460 
      461 dcl  line_start fixed bin (21);			/* index of line to be copied */
      462 dcl  num_chars fixed bin (21);			/* length of line without number */
      463 dcl  i fixed bin (21);
      464 dcl  len fixed bin (21);
      465 dcl  num fixed bin;
      466 
      467 
      468 	     len = length (seg);
      469 	     line_start = 1;
      470 
      471 	     do while (line_start <= len & code = 0);
      472 		i = verify (substr (seg, line_start), DIGIT) - 1;
      473 		if i = -1 then line_start = len + 1;
      474 		else do;
      475 		     if conditional & i > 0 then do;
      476 			if fst_cv_line_num_ (substr (seg, line_start, i), num, code) then do;
      477 			     if num > seq_number then do;
      478 				call copy (substr (seg, line_start, len - line_start + 1));
      479 				return;
      480 			     end;
      481 			end;
      482 		     end;
      483 		     line_start = line_start + i;
      484 		     num_chars = index (substr (seg, line_start), NEW_LINE);
      485 		     if num_chars = 0 then num_chars = len - line_start + 1;
      486 		     if seq_number <= max_line_num then do;
      487 			number_pic = seq_number;
      488 			call copy ((number_pic));
      489 			call copy (substr (seg, line_start, num_chars));
      490 			line_start = line_start + num_chars;
      491 			seq_number = seq_number + increment;
      492 		     end;
      493 		     else code = error_edit_max_num;
      494 		end;
      495 	     end;
      496 
      497 	     return;
      498 	end renumber;
      499 
      500 
      501 
      502 /*  */
      503 /* This procedure copies the segment into the temporary buffer.
      504**/
      505 copy:	proc (seg);
      506 
      507 dcl  seg char (*);
      508 
      509 dcl  i fixed bin (21);
      510 
      511 	     i = length (seg);
      512 	     if i > 0 then do;
      513 		if temp_length + i <= f.max_seg_size then do;
      514 		     substr (temp, temp_length + 1, i) = seg;
      515 		     temp_length = temp_length + i;
      516 		end;
      517 		else code = error_max_size;
      518 	     end;
      519 
      520 	     return;
      521 
      522 	end copy;
      523 
      524 
      525 
      526 /* *  This procedure calls dfast_basic_resequence_ which edits seg to use the new line numbers in the table.
      527*   *  The output is is stored in temp.
      528*   *
      529*   *	check_line_numbers	= "1"b	ON if line numbers should be edited also.
      530*   *			= "0"b	OFF if only line number references are changed.
      531**/
      532 copy_rsq:	proc (check_line_numbers, seg);
      533 
      534 dcl  check_line_numbers bit (1) unal;
      535 dcl  seg char (*);
      536 
      537 	     call dfast_basic_resequence_ (f.max_seg_size, table_ptr, seg, check_line_numbers, temp_ptr, temp_length,
      538 		code);
      539 
      540 	     return;
      541 
      542 	end copy_rsq;
      543 
      544 /*  */
      545 /* * This procedure adds to a table to be used to resequence a basic source segment.  It uses these global variables:
      546*   *
      547*   *	table_ptr		ptr to table
      548*   *	num_lines		number of lines in table
      549*   *	seq_number	new_number
      550*   *	increment		value to derive subsequent numbers
      551*   *
      552*   * If conditional is set, it puts the number in the table only if it is less than the seq_number.
      553**/
      554 fill_basic_table: proc (conditional, seg);
      555 
      556 dcl  conditional bit (1) unal;
      557 dcl  seg char (*);
      558 
      559 /* automatic */
      560 
      561 dcl  start fixed bin (21);
      562 dcl  i fixed bin (21);
      563 dcl  old_num fixed bin;
      564 
      565 	     start = 1;
      566 	     do while (start <= length (seg) & code = 0);
      567 		i = verify (substr (seg, start), DIGIT) - 1;
      568 		if i > 0 then do;
      569 		     if fst_cv_line_num_ (substr (seg, start, i), old_num, code) then do;
      570 
      571 /* conditional test.  If the next number is greater or equal to the sequence number, no more lines need to be added to
      572*   the table.
      573**/
      574 			if conditional then if old_num >= seq_number then return;
      575 
      576 			basic_rsq_table.num_lines = basic_rsq_table.num_lines + 1;
      577 
      578 			basic_rsq_table.t (basic_rsq_table.num_lines).old_number = old_num;
      579 			basic_rsq_table.t (basic_rsq_table.num_lines).new_number = seq_number;
      580 			seq_number = seq_number + increment;
      581 			start = start + i;
      582 			i = index (substr (seg, start), NEW_LINE);
      583 			if i = 0 then i = length (seg) - start + 1;
      584 			start = start + i;
      585 		     end;
      586 		end;
      587 		else code = error_un_num_text;
      588 	     end;
      589 
      590 	     return;
      591 
      592 	end fill_basic_table;
      593 
      594      end fst_util_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/19/88  1500.1  fst_util_.pl1                     >spec>install>MR12.2-1015>fst_util_.pl1
105          1    12/03/76  1658.6  fst_edit_info.incl.pl1            >ldd>include>fst_edit_info.incl.pl1
106          2    03/27/82  0439.4  dfast_error_codes.incl.pl1        >ldd>include>dfast_error_codes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DIGIT                           000000 constant        char(10)                 initial unaligned dcl 84 ref 339 341 341 342 360 373
                                                                                  472 567
NEW_LINE                        004641 constant        char(1)                  initial unaligned dcl 85 ref 362 484 582
addr                                                   builtin function         dcl 89 ref 119 122 130 153 156 188 212 256 259 287
                                                                                  423 423 425 425
addrel                                                 builtin function         dcl 89 ref 188
alt_ptr                  56            based           pointer                  level 2 dcl 73 ref 114 145 248 331 413
arg_increment                          parameter       fixed bin(17,0)          dcl 34 ref 110 113 411 414
basic_rsq_table                        based           structure                level 1 dcl 68
basic_source            137(02)        based           bit(1)                   level 3 packed unaligned dcl 73 ref 115 149 252
change_ok                       000106 automatic       bit(1)                   unaligned dcl 52 set ref 335* 362* 364* 373* 377
                                                                                  390*
check                           000107 automatic       bit(1)                   unaligned dcl 53 set ref 338* 339* 341* 342* 359 372
check_line_number               000007 constant        bit(1)                   initial unaligned dcl 80 set ref 165* 173* 177* 196*
                                                                                  203 205* 207* 269 270* 271* 273* 279 281 282* 283*
check_line_numbers                     parameter       bit(1)                   unaligned dcl 534 set ref 532 537*
check_null                      000110 automatic       bit(1)                   unaligned dcl 54 set ref 344* 359 372
cleanup                         000126 stack reference condition                dcl 90 ref 118 152 255
code                                   parameter       fixed bin(35,0)          dcl 35 set ref 110 119* 122* 123 126 126* 143 153*
                                                                                  156* 157 172 174 177 187 217 246 256* 259* 260 327
                                                                                  387* 399* 411 423* 425* 426 438 471 476* 493* 517*
                                                                                  537* 566 569* 587*
conditional                            parameter       bit(1)                   unaligned dcl 556 in procedure "fill_basic_table"
                                                                                  ref 554 574
conditional                     000007 constant        bit(1)                   initial unaligned dcl 82 in procedure "fst_util_"
                                                                                  set ref 125 133 164 171 176* 186 189* 216 218* 261
                                                                                  263* 266* 276* 295 296* 298* 304 305*
conditional                            parameter       bit(1)                   unaligned dcl 457 in procedure "renumber" ref 454
                                                                                  475
dfast_basic_resequence_         000010 constant        entry                    external dcl 94 ref 126 537
done                            000111 automatic       bit(1)                   unaligned dcl 55 set ref 420* 421 430* 434* 441
edit_ptr                               parameter       pointer                  dcl 36 ref 110 114 115 125 125 125 126 126 126 126
                                                                                  133 133 133 143 145 149 162 162 163 163 163 163
                                                                                  176 176 176 177 177 177 189 189 189 189 189 189
                                                                                  194 194 194 194 197 197 197 197 197 197 203 203
                                                                                  203 203 207 207 207 207 207 207 215 215 215 215
                                                                                  218 218 218 218 218 218 218 246 248 252 261 261
                                                                                  261 261 263 263 263 263 266 266 266 266 266 266
                                                                                  266 269 269 269 269 270 270 270 270 271 271 271
                                                                                  271 273 273 273 273 273 273 273 276 276 276 276
                                                                                  276 276 276 279 279 279 279 281 281 281 281 282
                                                                                  282 282 282 283 283 283 283 283 283 283 294 294
                                                                                  294 294 295 295 295 295 296 296 296 296 298 298
                                                                                  298 298 298 298 298 301 301 301 301 303 303 303
                                                                                  303 304 304 304 304 305 305 305 305 305 305 305
                                                                                  327 331 349 349 360 360 362 362 373 373 380 380
                                                                                  380 380 381 382 400 400 400 400 400 400 400 411
                                                                                  413 418 418 418 418 425 425 439 439 439 439 439
                                                                                  439 439 440 513 514 537
end_line_number         136            based           fixed bin(17,0)          level 2 dcl 73 set ref 440*
error_edit_max_num                     constant        fixed bin(35,0)          initial dcl 2-43 ref 493
error_max_size                         constant        fixed bin(35,0)          initial dcl 2-4 ref 387 517
error_no_string                        constant        fixed bin(35,0)          initial dcl 2-29 ref 399
error_un_num_text                      constant        fixed bin(35,0)          initial dcl 2-44 ref 587
f                                      based           structure                level 1 dcl 73
flags                   137            based           structure                level 2 dcl 73
fst_cv_line_num_                000012 constant        entry                    external dcl 95 ref 476 569
fst_edit_info                          based           structure                level 1 dcl 1-3
get_temp_segments_              000026 constant        entry                    external dcl 101 ref 122 156 259
i                               000112 automatic       fixed bin(21,0)          dcl 56 in procedure "fst_util_" set ref 265* 266 266
                                                                                  266 266 266 273 273 273 273 273 280* 281 281 281
                                                                                  281 281 297* 298 298 298 298 298 302* 303 303 303
                                                                                  303 303 349* 350 360 362 373 378 379* 379 380 380
                                                                                  380 384 391 392 425* 427 432
i                               000102 automatic       fixed bin(21,0)          dcl 463 in procedure "renumber" set ref 472* 473 475
                                                                                  476 476 483
i                               000101 automatic       fixed bin(21,0)          dcl 562 in procedure "fill_basic_table" set ref 567*
                                                                                  568 569 569 581 582* 583 583* 584
i                               000100 automatic       fixed bin(21,0)          dcl 509 in procedure "copy" set ref 511* 512 513 514
                                                                                  515
increment                       000113 automatic       fixed bin(17,0)          dcl 57 set ref 113* 147* 148 148 250* 251 251 414*
                                                                                  415 415 429 435 440 491 580
index                                                  builtin function         dcl 89 ref 349 484 582
ioa_                            000014 constant        entry                    external dcl 96 ref 441
iox_$get_line                   000016 constant        entry                    external dcl 97 ref 425
iox_$put_chars                  000020 constant        entry                    external dcl 98 ref 423
iox_$user_input                 000022 external static pointer                  dcl 99 set ref 425*
iox_$user_output                000024 external static pointer                  dcl 100 set ref 423*
j                               000114 automatic       fixed bin(21,0)          dcl 58 set ref 360* 361 362
last_index                      000117 automatic       fixed bin(21,0)          dcl 61 set ref 347* 380 380 380 380 380 384* 385 399
                                                                                  400 400 400 400 400
len                             000103 automatic       fixed bin(21,0)          dcl 464 set ref 468* 471 473 478 478 485
len_new_string                  000115 automatic       fixed bin(17,0)          dcl 59 set ref 329* 337 344 381 382 383
len_old_string                  000116 automatic       fixed bin(17,0)          dcl 60 set ref 330* 338 341 373 378 384
length                                                 builtin function         dcl 89 ref 329 330 423 423 468 511 566 583
line_start                      000100 automatic       fixed bin(21,0)          dcl 461 set ref 469* 471 472 473* 476 476 478 478
                                                                                  478 478 483* 483 484 485 489 489 490* 490
max_line_num                           constant        fixed bin(17,0)          initial dcl 87 ref 486
max_seg_size             62            based           fixed bin(21,0)          level 2 dcl 73 set ref 126* 381 382 425 425 513 514
                                                                                  537*
mod                                                    builtin function         dcl 89 ref 148 251 415
new_number                1(18)        based           fixed bin(17,0)          array level 3 packed unaligned dcl 68 set ref 579*
new_string                             parameter       varying char             dcl 38 ref 327 329 341 342 382
next_number                            parameter       fixed bin(17,0)          dcl 37 set ref 411 421 441*
null                                                   builtin function         dcl 89 ref 116 119 130 150 153 212 253 256 287
num                             000104 automatic       fixed bin(17,0)          dcl 465 set ref 476* 477
num_chars                              parameter       fixed bin(21,0)          dcl 39 in procedure "fst_util_" set ref 246 261 261
                                                                                  265 270 270 280 282 282 295 295 297 302 304 304
                                                                                  327 348 349 378* 378 392* 392 396*
num_chars                       000101 automatic       fixed bin(21,0)          dcl 462 in procedure "renumber" set ref 484* 485
                                                                                  485* 489 489 490
num_lines                              based           fixed bin(17,0)          level 2 dcl 68 set ref 124* 158* 175* 188 193 576*
                                                                                  576 578 579
number_pic                      000120 automatic       picture(5)               unaligned dcl 62 set ref 487* 488
number_pic_blank                000122 automatic       picture(6)               unaligned dcl 63 set ref 422* 423 423 423 423 424
old_num                         000102 automatic       fixed bin(17,0)          dcl 563 set ref 569* 574 578
old_number                1            based           fixed bin(17,0)          array level 3 packed unaligned dcl 68 set ref 188
                                                                                  578*
old_string                             parameter       varying char             dcl 40 ref 327 330 339 341 349
ptr_array                              based           pointer                  array dcl 74 set ref 119* 122* 130* 153* 156* 212*
                                                                                  256* 259* 287*
release_temp_segments_          000030 constant        entry                    external dcl 102 ref 119 130 153 212 256 287
reverse                                                builtin function         dcl 89 ref 360
seg                                    parameter       char                     unaligned dcl 41 in procedure "fst_util_" set ref
                                                                                  143 164* 165* 171* 173* 186* 196* 205* 216*
seg                                    parameter       char                     unaligned dcl 458 in procedure "renumber" ref 454
                                                                                  468 472 476 476 478 478 484 489 489
seg                                    parameter       char                     unaligned dcl 557 in procedure "fill_basic_table"
                                                                                  ref 554 566 567 569 569 582 583
seg                                    parameter       char                     unaligned dcl 507 in procedure "copy" ref 505 511
                                                                                  514
seg                                    parameter       char                     unaligned dcl 535 in procedure "copy_rsq" set ref
                                                                                  532 537*
seq_number                             parameter       fixed bin(17,0)          dcl 42 set ref 110 143 148* 148 148 246 251* 251 251
                                                                                  411 415* 415 415 421 422 429* 429 435* 435 440 477
                                                                                  486 487 491* 491 574 579 580* 580
start                           000100 automatic       fixed bin(21,0)          dcl 561 in procedure "fill_basic_table" set ref 565*
                                                                                  566 567 569 569 581* 581 582 583 584* 584
start                                  parameter       fixed bin(21,0)          dcl 43 in procedure "fst_util_" set ref 143 162 170
                                                                                  189 189 189 189 194 194 197 197 197 197 203 203
                                                                                  207 207 207 207 215 215 215 218 218 218 218 218
                                                                                  246 261 261 262 263 263 263 265 270 270 271 271
                                                                                  271 279 279 279 280 282 282 293 295 295 296 296
                                                                                  296 297 301 301 301 302 304 304 327 349 360 362
                                                                                  373 379 385* 391* 391 411 418 418 418 439 439 439
                                                                                  439 439
substr                                                 builtin function         dcl 89 set ref 189 189 194 194 197 197 203 203 207
                                                                                  207 215 215 218 218 261 261 263 263 266 266 269
                                                                                  269 270 270 271 271 273 273 276 276 279 279 281
                                                                                  281 282 282 283 283 294 294 295 295 296 296 298
                                                                                  298 301 301 303 303 304 304 305 305 339 341 341
                                                                                  342 349 360 362 373 380 380 382* 400 400 418 418
                                                                                  425 425 439 439 472 476 476 478 478 484 489 489
                                                                                  514* 567 569 569 582
t                         1            based           structure                array level 2 dcl 68
table_1_ptr                     000102 automatic       pointer                  dcl 45 set ref 185* 195 204
table_2_ptr                     000104 automatic       pointer                  dcl 46 set ref 188* 193 206
table_ptr                       000100 automatic       pointer                  dcl 44 set ref 116* 119 119 122 124 126* 130 130
                                                                                  150* 153 153 156 158 175 185 188 188 188* 195*
                                                                                  204* 206* 212 212 253* 256 256 259 287 287 537*
                                                                                  576 576 578 578 579 579
target                                 parameter       fixed bin(21,0)          dcl 47 ref 246 262 263 263 263 263 263 269 269 269
                                                                                  271 271 271 271 271 276 276 276 276 276 281 281
                                                                                  281 283 283 283 283 283 293 294 294 294 296 296
                                                                                  296 296 296 303 303 303 305 305 305 305 305
temp                                   based           char                     unaligned dcl 76 set ref 382* 425 425 514*
temp_length                            parameter       fixed bin(21,0)          dcl 48 set ref 110 112* 126* 143 146* 246 249* 327
                                                                                  381 382 383* 383 411 425 425 428* 428 432* 432 513
                                                                                  514 515* 515 537*
temp_ptr                        000124 automatic       pointer                  dcl 64 set ref 114* 126* 145* 248* 331* 382 413* 425
                                                                                  425 514 537*
text                                   based           char                     unaligned dcl 75 set ref 125* 126* 133* 163* 176*
                                                                                  177* 189 189 194 194 197 197 203 203 207 207 215
                                                                                  215 218 218 261 261 263 263 266 266 269 269 270
                                                                                  270 271 271 273 273 276 276 279 279 281 281 282
                                                                                  282 283 283 294 294 295 295 296 296 298 298 301
                                                                                  301 303 303 304 304 305 305 349 360 362 373 380
                                                                                  380 400 400 418 418 439 439
text_length              60            based           fixed bin(21,0)          level 2 dcl 73 ref 125 125 126 126 133 133 162 162
                                                                                  163 163 163 176 176 177 177 189 189 189 189 194
                                                                                  194 197 197 197 197 203 203 207 207 207 207 215
                                                                                  215 218 218 218 218 218 261 261 263 263 266 266
                                                                                  266 266 266 269 269 270 270 271 271 273 273 273
                                                                                  273 273 276 276 276 276 276 279 279 281 281 282
                                                                                  282 283 283 283 283 283 294 294 295 295 296 296
                                                                                  298 298 298 298 298 301 301 303 303 304 304 305
                                                                                  305 305 305 305 349 360 362 373 380 380 400 400
                                                                                  400 400 400 418 418 439 439 439 439 439
text_ptr                 54            based           pointer                  level 2 dcl 73 ref 125 126 133 163 176 177 189 189
                                                                                  194 194 197 197 203 203 207 207 215 215 218 218
                                                                                  261 261 263 263 266 266 269 269 270 270 271 271
                                                                                  273 273 276 276 279 279 281 281 282 282 283 283
                                                                                  294 294 295 295 296 296 298 298 301 301 303 303
                                                                                  304 304 305 305 349 360 362 373 380 380 400 400
                                                                                  418 418 439 439
verify                                                 builtin function         dcl 89 ref 339 341 341 342 360 373 472 567

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
error_access_mode                      internal static fixed bin(35,0)          initial dcl 2-33
error_alt_empty                        internal static fixed bin(35,0)          initial dcl 2-3
error_bad_line                         internal static fixed bin(35,0)          initial dcl 2-28
error_bad_name                         internal static fixed bin(35,0)          initial dcl 2-11
error_bad_pathname                     internal static fixed bin(35,0)          initial dcl 2-32
error_bad_rec_len                      internal static fixed bin(35,0)          initial dcl 2-36
error_bad_req                          internal static fixed bin(35,0)          initial dcl 2-12
error_bad_sort                         internal static fixed bin(35,0)          initial dcl 2-24
error_bad_type                         internal static fixed bin(35,0)          initial dcl 2-20
error_block_spec                       internal static fixed bin(35,0)          initial dcl 2-17
error_cur_empty                        internal static fixed bin(35,0)          initial dcl 2-5
error_delimiter_miss                   internal static fixed bin(35,0)          initial dcl 2-34
error_dprint_map                       internal static fixed bin(35,0)          initial dcl 2-41
error_line_miss                        internal static fixed bin(35,0)          initial dcl 2-26
error_line_order                       internal static fixed bin(35,0)          initial dcl 2-30
error_long_rec                         internal static fixed bin(35,0)          initial dcl 2-8
error_max_args                         internal static fixed bin(35,0)          initial dcl 2-39
error_max_line_number                  internal static fixed bin(35,0)          initial dcl 2-38
error_max_lines                        internal static fixed bin(35,0)          initial dcl 2-31
error_max_num                          internal static fixed bin(35,0)          initial dcl 2-42
error_name_dup                         internal static fixed bin(35,0)          initial dcl 2-7
error_name_miss                        internal static fixed bin(35,0)          initial dcl 2-14
error_name_sys                         internal static fixed bin(35,0)          initial dcl 2-40
error_no_comp                          internal static fixed bin(35,0)          initial dcl 2-15
error_no_expl                          internal static fixed bin(35,0)          initial dcl 2-10
error_no_main                          internal static fixed bin(35,0)          initial dcl 2-16
error_no_new_line                      internal static fixed bin(35,0)          initial dcl 2-45
error_no_nl                            internal static fixed bin(35,0)          initial dcl 2-23
error_no_num                           internal static fixed bin(35,0)          initial dcl 2-25
error_no_suffix                        internal static fixed bin(35,0)          initial dcl 2-22
error_not_saved                        internal static fixed bin(35,0)          initial dcl 2-6
error_obj_nop                          internal static fixed bin(35,0)          initial dcl 2-18
error_request_miss                     internal static fixed bin(35,0)          initial dcl 2-27
error_sav_cur                          internal static fixed bin(35,0)          initial dcl 2-19
error_size_fixed_record                internal static fixed bin(35,0)          initial dcl 2-35
error_string_size                      internal static fixed bin(35,0)          initial dcl 2-37
error_syntax_string                    internal static fixed bin(35,0)          initial dcl 2-13
error_unkn_sys                         internal static fixed bin(35,0)          initial dcl 2-21
error_unknown_arg                      internal static fixed bin(35,0)          initial dcl 2-9

NAMES DECLARED BY EXPLICIT CONTEXT.
change                          002726 constant        entry                    external dcl 327
copy                            004121 constant        entry                    internal dcl 505 ref 163 194 197 215 294 301 303 380
                                                                                  400 418 424 439 478 488 489
copy_rsq                        004166 constant        entry                    internal dcl 532 ref 165 173 177 196 203 205 207 269
                                                                                  270 271 273 279 281 282 283
fill_basic_table                004246 constant        entry                    internal dcl 554 ref 125 164 171 176 186 189 261 263
                                                                                  266 276
fst_util_                       000051 constant        entry                    external dcl 23
input                           003330 constant        entry                    external dcl 411
merge                           000377 constant        entry                    external dcl 143
move                            001423 constant        entry                    external dcl 246
renumber                        003624 constant        entry                    internal dcl 454 ref 133 216 218 295 296 298 304 305
resequence                      000064 constant        entry                    external dcl 110

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5076        5130    4643        5106
Length      5374    4643        32         230     232           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
fst_util_                           160 external procedure  is an external procedure.  
on unit on line 118                  82 on unit               
on unit on line 152                  82 on unit               
on unit on line 255                  82 on unit               
renumber                             92 internal procedure  is called during a stack extension.  
copy                                 66 internal procedure  is called during a stack extension.  
copy_rsq                             96 internal procedure  is called during a stack extension.  
fill_basic_table                     90 internal procedure  is called during a stack extension.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
copy                     000100 i                           copy
fill_basic_table         000100 start                       fill_basic_table
                         000101 i                           fill_basic_table
                         000102 old_num                     fill_basic_table
fst_util_                000100 table_ptr                   fst_util_
                         000102 table_1_ptr                 fst_util_
                         000104 table_2_ptr                 fst_util_
                         000106 change_ok                   fst_util_
                         000107 check                       fst_util_
                         000110 check_null                  fst_util_
                         000111 done                        fst_util_
                         000112 i                           fst_util_
                         000113 increment                   fst_util_
                         000114 j                           fst_util_
                         000115 len_new_string              fst_util_
                         000116 len_old_string              fst_util_
                         000117 last_index                  fst_util_
                         000120 number_pic                  fst_util_
                         000122 number_pic_blank            fst_util_
                         000124 temp_ptr                    fst_util_
renumber                 000100 line_start                  renumber
                         000101 num_chars                   renumber
                         000102 i                           renumber
                         000103 len                         renumber
                         000104 num                         renumber

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_other_desc return_mac          mdfx1               enable_op           shorten_stack       ext_entry
ext_entry_desc      int_entry           int_entry_desc      set_chars_eis       index_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
dfast_basic_resequence_       fst_cv_line_num_              get_temp_segments_            ioa_
iox_$get_line                 iox_$put_chars                release_temp_segments_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
iox_$user_input               iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     23 000050       110 000056       112 000102       113 000103       114 000105       115 000112       116 000115
    118 000117       119 000133       120 000164       122 000165       123 000212       124 000214       125 000215
    126 000242       130 000313       131 000345       133 000346       135 000370       143 000371       145 000423
    146 000430       147 000431       148 000433       149 000443       150 000446       152 000450       153 000464
    154 000515       156 000516       157 000543       158 000545       162 000546       163 000555       164 000571
    165 000612       166 000630       170 000631       171 000634       172 000654       173 000656       174 000674
    175 000676       176 000677       177 000721       180 000745       185 000746       186 000750       187 000770
    188 000772       189 001001       193 001035       194 001040       195 001065       196 001070       197 001106
    198 001135       203 001137       204 001173       205 001176       206 001214       207 001216       208 001251
    212 001252       213 001304       215 001305       216 001331       217 001353       218 001355       220 001413
    222 001414       246 001415       248 001441       249 001446       250 001447       251 001451       252 001461
    253 001464       255 001466       256 001502       257 001533       259 001534       260 001561       261 001563
    262 001616       263 001623       265 001656       266 001663       269 001717       270 001753       271 002004
    273 002041       274 002100       276 002102       279 002135       280 002174       281 002201       282 002240
    283 002271       285 002327       287 002330       290 002362       293 002363       294 002366       295 002407
    296 002443       297 002500       298 002505       299 002541       301 002543       302 002567       303 002574
    304 002624       305 002660       306 002716       309 002717       327 002720       329 002755       330 002761
    331 002764       335 002770       337 002772       338 002774       339 003000       340 003011       341 003012
    342 003041       344 003053       347 003056       348 003057       349 003063       350 003101       359 003103
    360 003107       361 003125       362 003126       363 003135       364 003136       372 003137       373 003143
    377 003157       378 003161       379 003165       380 003171       381 003214       382 003224       383 003234
    384 003236       385 003241       386 003243       387 003244       388 003246       390 003247       391 003251
    392 003255       394 003261       396 003262       397 003263       399 003264       400 003271       402 003320
    411 003322       413 003350       414 003355       415 003357       418 003367       420 003413       421 003415
    422 003424       423 003435       424 003456       425 003470       426 003515       427 003517       428 003522
    429 003524       430 003526       431 003530       432 003531       433 003532       434 003533       435 003534
    436 003536       438 003537       439 003541       440 003573       441 003577       444 003622       454 003623
    468 003637       469 003640       471 003642       472 003650       473 003671       475 003677       476 003706
    477 003745       478 003752       479 004000       483 004002       484 004004       485 004025       486 004032
    487 004036       488 004047       489 004062       490 004105       491 004110       492 004113       493 004114
    495 004116       497 004117       505 004120       511 004134       512 004135       513 004137       514 004146
    515 004160       516 004161       517 004162       520 004164       532 004165       537 004201       540 004244
    554 004245       565 004261       566 004263       567 004272       568 004313       569 004314       574 004353
    576 004366       578 004370       579 004375       580 004400       581 004402       582 004404       583 004424
    584 004431       586 004432       587 004433       588 004435       590 004436


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
