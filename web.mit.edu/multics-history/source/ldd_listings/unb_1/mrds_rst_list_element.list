	COMPILATION LISTING OF SEGMENT mrds_rst_list_element
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/18/85  1101.8 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 mrds_rst_list_element: procedure (key, structure_type, rsc_ptr, root_ptr, structure_ptr, error_code);
       19 
       20 
       21 /* HISTORY:
       22*
       23*   originally written by jim gray - - july 1978
       24*   modified by Jim Gray 2/19/79, to allocate structures in areas according to type,
       25*   this changed the area_ptr input to an rsc_ptr input parameter
       26*
       27**/
       28 
       29 /* DESCRIPTION:
       30*
       31*   add or delete global list header and data space
       32*   the global restructuring lists are made up of elements
       33*   that have two parts.  the head portion is a node
       34*   in a binary tree with a link to a data portion that
       35*   may be one of several pl1 structures.
       36*
       37*   there are two entries:
       38*   entry add - inserts the head portion into the
       39*   tree and links it newly allocated data space.
       40*   entry delete - deletes the head portion and
       41*   frees the allocated data space.     */
       42 
       43 
       44 /* PARAMETERS:
       45*
       46*   key - - (input) data key used for location of head portion in search tree
       47*
       48*   structure_type - - (input) the type of pl1 structure in the include file
       49*   that is to be allocated or freed (see include file)
       50*
       51*   rsc_ptr - - (input) pointer to the common rsc segment, that contains pointers to the areas where
       52*   the different structure types are to be allocated, or freed from
       53*
       54*   root_ptr - - (input/output) pointer to desired list to be manipulated,
       55*   additions to empty lists, or deletions of root nodes change it
       56*
       57*   error_code - - (output) value indicating either failure reason or success
       58*
       59*   structure_ptr - - (output) when adding, the resultant pointer to the
       60*   newly allocated structure(or to the existing structure when duplicate add attempted)
       61*
       62**/
       63 
       64 
       65 add: entry (key, structure_type, rsc_ptr, root_ptr, structure_ptr, error_code);
       66 
       67 /* entry to add element to global list
       68*   first, get head portion for list element into
       69*   it's proper place in the list */
       70 
       71 	call mrds_rst_tree_insert (key, rsc_ptr, root_ptr, node_ptr, success);
       72 
       73 /* no success means attempt to add duplicate to list,
       74*   return error code and pointer to existing structure */
       75 
       76 	if ^success then do;
       77 		error_code = mrds_error_$rst_list_duplicate;
       78 		structure_ptr = node_ptr -> node.data;
       79 	     end;
       80 
       81 	else do;
       82 
       83 /* get new data portion for list element using
       84*   the given area and structure parameters */
       85 
       86 		if structure_type = MAIN_LIST then do;
       87 			error_code = 0;
       88 			call mrds_rst_rsc_alloc (rsc_ptr, GL, structure_ptr);
       89 		     end;
       90 		else if structure_type = SUB_LIST then do;
       91 			error_code = 0;
       92 			call mrds_rst_rsc_alloc (rsc_ptr, SL, structure_ptr);
       93 		     end;
       94 		else if structure_type = SEG_INFO then do;
       95 			error_code = 0;
       96 			call mrds_rst_rsc_alloc (rsc_ptr, SEGINFO, structure_ptr);
       97 		     end;
       98 		else do;
       99 			error_code = mrds_error_$rst_invalid_structure_type;
      100 			structure_ptr = null ();
      101 		     end;
      102 
      103 /* link data portion of element to it's head part
      104*   that is in the global list */
      105 
      106 		node_ptr -> node.data = structure_ptr;
      107 
      108 	     end;
      109 
      110 	return;
      111 
      112 
      113 
      114 
      115 
      116 delete: entry (key, structure_type, rsc_ptr, root_ptr, error_code);
      117 
      118 /* entry to delete global element
      119*   first delete the head portion from list,
      120*   saving pointer to the data portion */
      121 
      122 	call mrds_rst_tree_delete (key, rsc_ptr, root_ptr, structure_ptr, success);
      123 
      124 /* no success means key node was not found */
      125 
      126 	if ^success then
      127 	     error_code = mrds_error_$rst_list_delete_fail;
      128 
      129 	else
      130 
      131 /* free the data portion space with size according to structure type */
      132 
      133 	     if structure_type = MAIN_LIST then do;
      134 		error_code = 0;
      135 		call mrds_rst_rsc_alloc$free (rsc_ptr, GL, structure_ptr);
      136 	     end;
      137 	else if structure_type = SUB_LIST then do;
      138 		error_code = 0;
      139 		call mrds_rst_rsc_alloc$free (rsc_ptr, SL, structure_ptr);
      140 	     end;
      141 	else if structure_type = SEG_INFO then do;
      142 		error_code = 0;
      143 		call mrds_rst_rsc_alloc$free (rsc_ptr, SEGINFO, structure_ptr);
      144 	     end;
      145 	else error_code = mrds_error_$rst_invalid_structure_type;
      146 
      147 
      148 
      149 	dcl     null		 builtin;
      150 	dcl     mrds_rst_rsc_alloc	 entry (ptr, fixed bin, ptr); /* work area manager */
      151 	dcl     mrds_rst_rsc_alloc$free entry (ptr, fixed bin, ptr); /* freeing entry in work area manager */
      152 	dcl     mrds_rst_tree_delete	 entry (char (32) aligned, ptr, ptr, ptr, bit (1)); /* tree node delete routine */
      153 	dcl     mrds_rst_tree_insert	 entry (char (32) aligned, ptr, ptr, ptr, bit (1)); /* tree node insertion routine */
      154 
      155 	dcl     structure_ptr	 ptr;		/* pointer to data space just added or to be deleted */
      156 
      157 	dcl     structure_type	 fixed binary;	/* number 0f structure desired, see include file */
      158 	dcl     error_code		 fixed binary (35); /* zero or failure reason code */
      159 
      160 	dcl     mrds_error_$rst_list_duplicate fixed binary (35) external; /* attempt to add duplicate error */
      161 	dcl     mrds_error_$rst_invalid_structure_type fixed binary (35) external; /* undefined structure type error */
      162 	dcl     mrds_error_$rst_list_delete_fail fixed binary (35) external; /* attempt to delete missing key */
      163 
  1     1 /* BEGIN INCLUDE FILE mrds_rst_tree.incl.pl1   jeg 7/19/78 */
  1     2 
  1     3 /* common declarations for threaded binary tree routines
  1     4*
  1     5*   The tree maintains an inorder list of it's keys.
  1     6*   this means that for a given node, any key in it's left subtree
  1     7*   is "less" than the given node's key and that any key in it's
  1     8*   right subtree is "greater" than the given node's key.
  1     9*
  1    10*   Threads are maintained to allow fast and easy traversal of the tree.
  1    11*   threads occupy the position of null pointers of an straight binary tree,
  1    12*   thus they only occur in leaf nodes.
  1    13*   left threads point to that nodes inorder predecessor.
  1    14*   right threads point to that nodes inorder successor.
  1    15*
  1    16*   note: root_ptr must be passed by reference
  1    17*   ( not by value ) so it can be changed .
  1    18*   Also, each parameter must be a different
  1    19*   variable. The same variable used for two
  1    20*   or more arguments when any of the tree
  1    21*   routines are called will produce errors */
  1    22 
  1    23 
  1    24 declare  key char (32) aligned ;			/* data key directing search */
  1    25 
  1    26 declare  root_ptr ptr ;				/* pointer to head of desired list */
  1    27 declare  node_ptr ptr ;				/* pointer to key node, when success */
  1    28 declare  parent_ptr ptr ;				/* pointer to direct parent of current node */
  1    29 declare  data_ptr ptr ;				/* pointer from tree node to data structure headed by node */
  1    30 declare  successor_ptr ptr ;				/* pointer to inorder successor of current node in tree */
  1    31 declare  successor_parent_ptr ptr ;			/* pointer to immediate tree parent of inorder successor node */
  1    32 declare  predecessor_ptr ptr ;			/* pointer to inorder predecessor of current node */
  1    33 declare  predecessor_parent_ptr ptr ;			/* pointer to direct parent of predecessor */
  1    34 declare  area_ptr ptr ;				/* pointer to based area for node allocation/freeing */
  1    35 
  1    36 declare  work_area area based (area_ptr) ;		/* area of storage for tree */
  1    37 
  1    38 declare  success bit (1) ;				/* on if operation successful */
  1    39 declare  thread bit (1) aligned ;			/* current thread indicator, on = thread, off = pointer */
  1    40 
  1    41 declare 1 node based (node_ptr) aligned,		/* tree element */
  1    42         2 data ptr,					/* data field link */
  1    43         2 key char (32),				/* data key */
  1    44         2 right,					/* right branch link */
  1    45 	3 thread bit (1),				/* indicates whether link is thread or pointer */
  1    46 	3 link ptr,				/* pointer to right descendent or thread to successor */
  1    47         2 left,					/* left branch link */
  1    48 	3 thread bit (1),				/* indicates whether link is thread or pointer */
  1    49 	3 link ptr,				/* pointer to left descendent or thread to predecessor */
  1    50         2 pad bit (34) ;				/* reserved for future flags */
  1    51 
  1    52 /* END INCLUDE FILE mrds_rst_tree.incl.pl1  */
  1    53 
  1    54 
  1    55 
  1    56 
      164 
      165 
  2     1 /* BEGIN INCLUDE FILE mrds_rst_struct_types.incl.pl1 - - Jim Gray 2/20/79 */
  2     2 
  2     3 /* these constants are used to identify structures to be allocated
  2     4*   to the general purpose allocation routines */
  2     5 
  2     6 /*  HISTORY:
  2     7*    82-06-28 Roger Lackey : Removed struct types 52, 53, 54, 55, 56, 57, 58
  2     8*    Type 25 is no longer used and is handled with special code so bounds of 
  2     9*    array could continue to work */
  2    10 
  2    11 /* PARSE INFO STRUCTURES */
  2    12 
  2    13 declare  DOMAIN fixed bin internal static options (constant) init (1) ;
  2    14 declare  ATTRIBUTE_DOMAIN fixed bin internal static options (constant) init (2) ;
  2    15 declare  RELATION fixed bin internal static options (constant) init (3) ;
  2    16 declare  ATTRIBUTE fixed bin internal static options (constant) init (4) ;
  2    17 declare  FILE fixed bin internal static options (constant) init (5) ;
  2    18 declare  ITEM fixed bin internal static options (constant) init (6) ;
  2    19 declare  LINK fixed bin internal static options (constant) init (7) ;
  2    20 declare  FOREIGN_KEY fixed bin internal static options (constant) init (8) ;
  2    21 declare  CHILDREN fixed bin internal static options (constant) init (9) ;
  2    22 declare  INDEX fixed bin internal static options (constant) init (10) ;
  2    23 declare  DELETE_NAME fixed bin internal static options (constant) init (11) ;
  2    24 declare  DOM_LIST fixed bin internal static options (constant) init (12) ; /* in link handler */
  2    25 
  2    26 /* SEMANTIC STRUCTURES */
  2    27 
  2    28 declare  DIRECTIVE fixed bin internal static options (constant) init (13) ;
  2    29 declare  STMT fixed bin internal static options (constant) init (14) ;
  2    30 
  2    31 
  2    32 /* PARSING STRUCTURES */
  2    33 
  2    34 declare  LEX_STACK fixed bin internal static options (constant) init (15) ;
  2    35 declare  P_STRUCT fixed bin internal static options (constant) init (16) ;
  2    36 declare  CUR_LEX_TOP fixed bin internal static options (constant) init (17) ;
  2    37 declare  FIXUP_TOKEN fixed bin internal static options (constant) init (50) ; /* scanner */
  2    38 declare  STRING_SOURCE fixed bin internal static options (constant) init (51) ; /* semantics */
  2    39 declare  TOKEN fixed bin internal static options (constant) init (18) ;
  2    40 declare  OUTPUT_TEXT fixed bin internal static options (constant) init (19) ;
  2    41 
  2    42 
  2    43 /* DB_MODEL STRUCTURES */
  2    44 
  2    45 declare  DB_MODEL fixed bin internal static options (constant) init (0) ;
  2    46 declare  FILE_INFO fixed bin internal static options (constant) init (1) ;
  2    47 declare  DOMAIN_INFO fixed bin internal static options (constant) init (2) ;
  2    48 declare  PATH_ENTRY fixed bin internal static options (constant) init (3) ;
  2    49 declare  STACK_ITEM fixed bin internal static options (constant) init (4) ;
  2    50 declare  CONSTANT fixed bin internal static options (constant) init (30) ;
  2    51 declare  VERSION_STATUS fixed bin internal static options (constant) init (5) ;
  2    52 declare  CHANGER fixed bin internal static options (constant) init (6) ;
  2    53 
  2    54 
  2    55 /* FILE_MODEL STRUCTURES */
  2    56 
  2    57 declare  FILE_MODEL fixed bin internal static options (constant) init (7) ;
  2    58 declare  REL_INFO fixed bin internal static options (constant) init (8) ;
  2    59 declare  ATTR_INFO fixed bin internal static options (constant) init (9) ;
  2    60 declare  PARENT_LINK_INFO fixed bin internal static options (constant) init (10) ;
  2    61 declare  CHILD_LINK_INFO fixed bin internal static options (constant) init (11) ;
  2    62 declare  ATTR_LIST fixed bin internal static options (constant) init (12) ;
  2    63 declare  ATD fixed bin internal static options (constant) init (31) ;
  2    64 declare  COMP_NO_ARRAY fixed bin internal static options (constant) init (32) ;
  2    65 declare  SORT_KEY fixed bin internal static options (constant) init (13) ;
  2    66 declare  DUP_PREV fixed bin internal static options (constant) init (14) ;
  2    67 declare  SELECT_CHAIN fixed bin internal static options (constant) init (15) ;
  2    68 
  2    69 
  2    70 /* GLOBAL LIST STRUCTURES */
  2    71 
  2    72 declare  GL fixed bin internal static options (constant) init (20) ;
  2    73 declare  SL fixed bin internal static options (constant) init (21) ;
  2    74 declare  SEGINFO fixed bin internal static options (constant) init (22) ;
  2    75 declare  LIST_OVRLY fixed bin internal static options (constant) init (26) ;
  2    76 declare  SAVED_CHILD_COUNT fixed bin internal static options (constant) init (24) ; /* in global list build */
  2    77 declare  NODE fixed bin internal static options (constant) init (23) ;
  2    78 
  2    79 
  2    80 /* DISPLAY STRUCTURES */
  2    81 
  2    82 declare  DISPLAY_INFO fixed bin internal static options (constant) init (25) ;
  2    83 
  2    84 /*   Remove because nolonger used 82-06-28        
  2    85*  NAME_LIST fixed bin internal static options (constant) init (52) ;
  2    86*  PAI_ARRAY fixed bin internal static options (constant) init (53) ;
  2    87*  PAR_LK_ATTR_INFO fixed bin internal static options (constant) init (54) ;
  2    88*  CAI_ARRAY fixed bin internal static options (constant) init (55) ;
  2    89*  CHILD_LK_ATTR_INFO fixed bin internal static options (constant) init (56) ;
  2    90*  NAME_TABLE fixed bin internal static options (constant) init (57) ;
  2    91*  ATTR_TABLE fixed bin internal static options (constant) init (58) ;
  2    92**/
  2    93 
  2    94 /* END INCULDE FILE mrds_rst_struct_types */
  2    95 
      166 
      167 
  3     1 /* BEGIN INCLUDE FILE mrds_rst_rsc.incl.pl1		RDL  7/7/78	*/
  3     2 
  3     3 /* Modified 8/21/78 by RDL */
  3     4 
  3     5 /* Modified 9/11/78 	by RDL to add directive and stmt pointers */
  3     6 
  3     7 /* Modified 11/4/78		by RDL to add debug,trace,meter switches
  3     8*
  3     9*   Modified 3/29/79 by RDL to change s_seg_info_ptr to source_seg_ptr
  3    10*
  3    11*   Modified by Jim Gray - - Jan. 1980, to add flags to disallow blocked files, forieng keys, and restructuring.
  3    12*
  3    13*   Modified by Jim Gray - - Feb. 1980, to add command level flag for cmdb subroutine interface.
  3    14*
  3    15*   Modified by Jim Gray - - 80-11-06, to add bit for cmdb -secure option.
  3    16*
  3    17*   81-05-18 Jim Gray : added bit for max_attributes error message, so that
  3    18*   it would only be issued on first occurence.
  3    19*
  3    20*   82-08-19 Davids: added the db_type field.
  3    21*
  3    22*   83-02-18 Mike Kubicar : Removed the db_type field and added the 
  3    23*   db_relation_mode_flags substructure to define the modes applicable
  3    24*   to the database's relations.  Also removed assorted unsed fields
  3    25*   (names that included the word unused).
  3    26*
  3    27**/
  3    28 
  3    29 dcl 1 rsc based (rsc_ptr),				/* Restructuring control info */
  3    30     2 rsc_dir char (200),				/* pathname of directory containing rsc segment */
  3    31     2 dbp char (168),				/* Database absolute path */
  3    32     2 temp_dir char (168),				/* Path name of temp restrucuring directory */
  3    33     2 temp_dir_sw bit (1) unal,			/* On => temp dir has been created */
  3    34     2 db_quiesced_sw bit (1) unal,			/* On => database has been quiesced */
  3    35     2 o_db_open_sw bit (1) unal,			/* On => old database has been opened */
  3    36     2 n_db_open_sw bit (1) unal,			/* On => temp database is open */
  3    37     2 listing_seg_sw bit (1) unal,			/* On => listing segment has been created */
  3    38     2 skip_scanner_conversion bit (1) unal,		/* Skip conversion in scanner */
  3    39     2 cmdb_option bit (1) unal,			/* ON => this is a cmdb source, not restructuring */
  3    40     2 trace_sw bit (1) unal,				/* On -> trace mode in affect */
  3    41     2 debug_sw bit (1) unal,				/* On = debug mode (NOT IMPLEMENTED) */
  3    42     2 meter_sw bit (1) unal,				/* On = procedures call metering procedure */
  3    43     2 delete_db_sw bit (1) unal,			/* On = delete data base in cleanup */
  3    44     2 model_consistent_sw bit (1) unal,			/* On => Model is consistent */
  3    45     2 physical_started_sw bit (1) unal,			/* On => Physical restructuring started */
  3    46     2 physical_complete_sw bit (1) unal,		/* On => Physical restructuring completed */
  3    47     2 model_overflow bit (1) unal,			/* ON => model segment area condition occurred */
  3    48     2 max_files bit (1) unal,				/* ON => maximum number of files reached */
  3    49     2 allow_foreign_keys bit (1) unal,			/* on => allow foreign key statment */
  3    50     2 foreign_key_seen bit (1) unal,			/* on => foreign key definition in source */
  3    51     2 allow_blocked_files bit (1) unal,			/* on => allow file statement with blocked option */
  3    52     2 blocked_file_seen bit (1) unal,			/* on => blocked file definition in source */
  3    53     2 allow_restructuring bit (1) unal,			/* on => allow RMDB entry point */
  3    54     2 command_level bit (1) unal,			/* on => called from command unal, not subroutine level */
  3    55     2 secure bit (1) unal,				/* on => -secure option given for cmdb */
  3    56     2 max_attrs bit (1) unal,				/* on => max attrs/rel or max indexes/rel exceeded */
  3    57     2 db_relation_mode_flags,
  3    58       3 dm_file_type bit (1) unal,			/* on => relations are dm files */
  3    59       3 protection_on bit (1) unal,			/* on => relations need transactions */
  3    60       3 concurrency_on bit (1) unal,			/* on => concurrency control enabled */
  3    61       3 rollback_on bit (1) unal,			/* on => before journalling is enabled */
  3    62     2 severity_high fixed bin,			/* Highest severity level error encountered */
  3    63     2 phase fixed bin,				/* 000 = init
  3    64*						   100 = global list init
  3    65*						   200 = parse
  3    66*						   300 = physical init
  3    67*						   400 = physical */
  3    68     2 h_o_seg_info_ls_ptr ptr,			/* Pointer to head of old db seg_info list */
  3    69     2 h_n_seg_info_ls_ptr ptr,			/* Pointer to head of new db seg_info list */
  3    70     2 h_gfile_ptr ptr,				/* Pointer to head of global file list */
  3    71     2 h_gdom_ptr ptr,				/* Pointer to head of global domain list */
  3    72     2 h_gattr_ptr ptr,				/* Pointer to head of global attribute list */
  3    73     2 h_grel_ptr ptr,				/* Pointer to head of global relation list */
  3    74     2 h_glink_ptr ptr,				/* Pointer to head of global link list */
  3    75     2 o_dm_ptr ptr,					/* Pointer to old data model seg  (dm_model ) */
  3    76     2 n_dm_ptr ptr,					/* Pointer to temp data model seg */
  3    77     2 o_fn_hdr_ptr ptr,				/* Pointer to head of original file list (fn structure) */
  3    78     2 source_seg_ptr ptr,				/* Pointer to source_seg */
  3    79     2 listing_iocb_ptr ptr,				/* Pointer to listing segment iocb */
  3    80     2 directive_ptr ptr,				/* Pointer to directive type str in mrds_rst_semactics.incl.pl1 */
  3    81     2 stmt_ptr ptr,					/* Pointer to statement str in mrds_rst_sematics.incl.pl1 */
  3    82     2 trace_metering_iocb_ptr ptr,			/* Pointer to seg used by trace and metering */
  3    83     2 tree_node_area_ptr ptr,				/* pointer to working storage for tree nodes */
  3    84     2 tree_data,
  3    85       3 seg_info_area_ptr ptr,			/* seg info working storage area */
  3    86       3 gl_area_ptr ptr,				/* global list data work storage area */
  3    87       3 sl_area_ptr ptr,				/* sublist data work storage area */
  3    88     2 parse_info_area_ptr ptr,			/* parse interface work area storage */
  3    89     2 static_info_area_ptr ptr,			/* directive, stmt and other static work storage area */
  3    90     2 variable_length_area_ptr ptr,			/* varibale allocates work storage area */
  3    91     2 other_area_ptr ptr,				/* unspecified work area storage */
  3    92     2 wa area (sys_info$max_seg_size - fixed (rel (addr (rsc.wa))) + 1); /* Work area */
  3    93 
  3    94 dcl  rsc_ptr ptr;					/* Pointer to base of rsc segment */
  3    95 
  3    96 
  3    97 
  3    98 /* END INCLUDE FILE mrds_rst_rsc.incl.pl1				*/
  3    99 
      168 
      169 
  4     1 /* BEGIN INCLUDE FILE mdbm_seg_area.incl.pl1 - - Jim Gray 2/19/79 */
  4     2 
  4     3 /* these structures provide a standard for
  4     4*   1) using an entire segment as an area, managed by the area manager
  4     5*   2) a constant header, that has an offset to the major common structure in the area
  4     6*   the pointer to that structure is obtained via pointer(model_seg_ptr, model_seg.offset)
  4     7*   the model_area_ptr is obtained via pointer(model_seg_ptr, size(model_seg)) */
  4     8 
  4     9 declare 1 model_seg aligned based (model_seg_ptr),	/* segment header, not to be changed */
  4    10         2 struct_offset bit (18),			/* offset to major structure allocated in area */
  4    11         2 padding (3) fixed bin ;			/* to set up four word boundary */
  4    12 
  4    13 declare  model_seg_ptr ptr int automatic init (null ());
  4    14 
  4    15 
  4    16 declare  model_area area (sys_info$max_seg_size - size (model_seg)) based (model_area_ptr) ; /* segment area */
  4    17 
  4    18 declare  model_area_ptr ptr int automatic init (null ());
  4    19 
  4    20 dcl size builtin;
  4    21 
  4    22 /* END INCLUDE FILE mdbm_seg_area.incl.pl1 */
  4    23 
      170 
      171 
  5     1 /* BEGIN INCLUDE FILE mrds_rst_global_lists.incl.pl1	jeg	7/17/78	*/
  5     2 
  5     3 /* note: mrds_rst_list_element$add and delete entries
  5     4*   makes use of the following structure type correspondence
  5     5*
  5     6*   structure_type = 1  refers to gl (global list element)
  5     7*
  5     8*   structure_type = 2 refers to sl (global sublist element)
  5     9*
  5    10*   structure_type = 3  refers to seg_info(segment information element)
  5    11*
  5    12**/
  5    13 
  5    14 
  5    15 dcl 1 gl aligned based (gl_ptr),			/* Template for global list entry */
  5    16     2 type fixed bin,				/* structure_type, usefull when overlay used */
  5    17     2 name char (32),				/* Item name */
  5    18     2 item_info_ptr ptr,				/* Pointer to info structure for this item */
  5    19     2 parse_info_ptr ptr,				/* Pointer to info obtained by parsing source */
  5    20     2 other_info_ptr ptr,				/* Pointer to additional info str if needed */
  5    21     2 item_sub_list_ptr ptr,				/* Pointer to sub list of items if neccessary for this his item */
  5    22     2 file_info_ptr ptr,				/* Pointer to file info for this entry */
  5    23     2 file_model_ptr ptr,				/* Pointer to file model for this entry */
  5    24     2 affected bit (1) unal,				/* ON => affected by some directive */
  5    25     2 cmdb bit (1) unal,				/* ON => affected by cmdb directive */
  5    26     2 undefine bit (1) unal,				/* ON => affected by undefine directive */
  5    27     2 define bit (1) unal,				/* ON => affected by define directive */
  5    28     2 redefine bit (1) unal,				/* ON => affected by redefine directive */
  5    29     2 superior_assigned bit (1) unal,			/* ON => has parent */
  5    30     2 inferior_assigned bit (1) unal,			/* ON => child present */
  5    31     2 complete bit (1) unal,				/* ON => all things present */
  5    32     2 consistant bit (1) unal,			/* ON => correct model */
  5    33     2 reserved bit (26) unal,				/* for future use */
  5    34     2 child_defined bit (1) unal ;			/* ON => global element entered by child */
  5    35 
  5    36 dcl  gl_ptr ptr;					/* Pointer to gl structure */
  5    37 
  5    38 
  5    39 
  5    40 dcl 1 sl aligned based (sl_ptr),			/* Template of sub list entry for global list */
  5    41     2 type fixed bin,				/* structure_type, usefull when overlay used */
  5    42     2 name char (32),				/* Name of item */
  5    43     2 item_info_ptr ptr,				/* Pointer to info structure for this entry */
  5    44     2 parse_info_ptr ptr,				/* Pointer to info obtained by parsing source */
  5    45     2 old_other_info_ptr ptr,				/* Pointer to old version of other info */
  5    46     2 new_other_info_ptr ptr,				/* Pointer to new version of other info */
  5    47     2 global_list_ptr ptr,				/* pointer to corresponding global list element */
  5    48     2 reserved bit (36) unal;				/* Reserved for future use */
  5    49 
  5    50 dcl  sl_ptr ptr;					/* Pointer to sub list structure */
  5    51 
  5    52 
  5    53 dcl 1 seg_info based (seg_info_ptr),			/* Info about segment initiated */
  5    54     2 name char (32),				/* Segment name */
  5    55     2 dir char (168),				/* Absolute path of containing directory */
  5    56     2 seg_ptr ptr,					/* Pointer to base of segment */
  5    57     2 bcnt fixed bin (24);				/* Bit count of segment */
  5    58 
  5    59 dcl  seg_info_ptr ptr;				/* Pointer to seg_info str */
  5    60 
  5    61 
  5    62 
  5    63 dcl  MAIN_LIST fixed bin internal static options (constant) init (1);
  5    64 dcl  SUB_LIST fixed bin internal static options (constant) init (2);
  5    65 dcl  SEG_INFO fixed bin internal static options (constant) init (3);
  5    66 
  5    67 declare 1 list_ovrly aligned based (list_ovrly_ptr),	/* overlay for top part of gl and sl list elements */
  5    68         2 type fixed bin,				/* structure_type, 1 => gl, 2 => sl */
  5    69         2 name char (32),				/* Name of item */
  5    70         2 item_info_ptr ptr,				/* pointer to info structure for this entry */
  5    71         2 parse_info_ptr ptr,				/* pointer to info obtained by parsing source */
  5    72         2 other_info_ptr ptr ;			/* pointer to additional info structure if needed */
  5    73 
  5    74 declare  list_ovrly_ptr ptr ;				/* pointer to overlay structure */
  5    75 
  5    76 
  5    77 declare  saved_child_count fixed bin based (saved_child_count_ptr) ; /* parent link structure child count */
  5    78 declare  saved_child_count_ptr ptr ;			/* pointer to remembered number of children */
  5    79 
  5    80 
  5    81 /* USES AND MEANING OF LIST ELEMENT ENTRIES
  5    82*
  5    83*   DOMAIN GLOBAL LIST --------------------------
  5    84*
  5    85*   gl.type - - MAIN_LIST
  5    86*   gl.name - - 32 char domain name
  5    87*   gl.item_info_ptr - - pointer to domain_info for this domain
  5    88*   gl.parse_info_ptr - - pointer to parse info structure
  5    89*   gl.other_info_ptr - - dbm_ptr, pointer to mdbm_db_model
  5    90*   gl.item_sub_list_ptr - - pointer to sublist of attributes using this domain
  5    91*   gl.file_info_ptr - - null ()
  5    92*   gl.file_model_ptr - - null ()
  5    93*   gl.superior_assigned - - ON => domain referenced by some relation
  5    94*   gl.inferior_assigned - - ON => referencing attribute present
  5    95*   gl.complete - - ON => domain_info present
  5    96*   gl.consistant - - always ON
  5    97*
  5    98*   DOMAIN GLOBAL LIST "REFERENCING ATTRIBUTES" SUBLIST ----------------
  5    99*
  5   100*   sl.type - - SUB_LIST
  5   101*   sl.name - - 32 char attribute name
  5   102*   sl.item_info_ptr - - pointer to this attribute's attribute_info
  5   103*   sl.parse_info_ptr - - pointer to parse info structure
  5   104*   sl.old_other_info_ptr - - null ()
  5   105*   sl.new_other_info_ptr - - pointer to this domain's global list element
  5   106*   sl.global_list_ptr - - pointer to attribute's global list element
  5   107*
  5   108*   ATTRIBUTE GLOBAL LIST -----------------
  5   109*
  5   110*   gl.type - - MAIN_LIST
  5   111*   gl.name - - 32 char attribute name
  5   112*   gl.item_info_ptr - - pointer to corresponding domain sublist element for this attribute
  5   113*   gl.parse_info_ptr - - pointer to parse info structure
  5   114*   gl.other_info_ptr - - domain_info of domain for this attribute
  5   115*   gl.item_sub_list_ptr - - pointer to sublist of relations that use this attribute
  5   116*   gl.file_info_ptr - - null (), use pointer(fm_ptr,file_model.fi_ptr)
  5   117*   gl.file_model_ptr - - null (), use pointer(ai_ptr,0), ai_ptr from corres. rel's attr sublist
  5   118*   gl.superior_assigned - - ON => relation contains this attribute
  5   119*   gl.inferior_assigned - - ON => attribute references known domain
  5   120*   gl.complete - - ON => attr_info present for this attribute
  5   121*   gl.consistant - - OFF => no domain for this attribute
  5   122*
  5   123*   ATTRIBUTE GLOBAL LIST "USED IN RELATION" SUBLIST ------------------
  5   124*
  5   125*   sl.type - - SUB_LIST
  5   126*   sl.name - - 32 char relation name
  5   127*   sl.item_info_ptr - - pointer to this relation's rel_info
  5   128*   sl.parse_info_ptr - - pointer to parse info structure
  5   129*   sl.old_other_info_ptr - - pointer to attribute's attr_info in this relation
  5   130*   sl.new_other_info_ptr - - pointer to this attribute's global list element
  5   131*   sl.global_list_ptr - - pointer to relation's global list element
  5   132*
  5   133*   RELATION GLOBAL LIST -------------------
  5   134*
  5   135*   gl.type - - MAIN_LIST
  5   136*   gl.name - - 32 char relation name
  5   137*   gl.item_info_ptr - - pointer to rel_info for this relation
  5   138*   gl.parse_info_ptr - - pointer to parse info structure
  5   139*   gl.other_info_ptr - - pointer to global list element of file containing this relation
  5   140*   gl.item_sub_list_ptr - - pointer to sublist of attributes in this relation
  5   141*   gl.file_info_ptr - - pointer to file_info of this relation's file
  5   142*   gl.file_model_ptr - - pointer to file_model of this relation's file
  5   143*   gl.superior_assigned - - ON => file present to hold this relation
  5   144*   gl.inferior_assigned - - ON => attribute's present in this relation
  5   145*   gl.complete - - ON => rel_info assigned to this relation
  5   146*   gl.consistant - - OFF => no attributes for this relation
  5   147*
  5   148*   RELATION GLOBAL LIST "CONTAINED ATTRIBUTE" SUBLIST ----------------
  5   149*
  5   150*   sl.type - - SUB_LIST
  5   151*   sl.name - - 32 char attribute name
  5   152*   sl.item_info_ptr - - pointer to this attribute's attribute_info
  5   153*   sl.parse_info_ptr - - pointer to parse info structure
  5   154*   sl.old_other_info_ptr - - pointer to domain_info for this attribute in old model
  5   155*   sl.new_other_info_ptr - - pointer to domain_info for this attribute in new model
  5   156*   sl.global_list_ptr - - pointer to attribute's global list element
  5   157*
  5   158*   FILE GLOBAL LIST -----------------------
  5   159*
  5   160*   gl.type - - MAIN_LIST
  5   161*   gl.name - - 30 char file name plus 2 trailing blanks
  5   162*   gl.item_info_ptr - - pointer to file_info for this file
  5   163*   gl.parse_info_ptr - - pointer to parse info structure
  5   164*   gl.other_info_ptr - - null ()
  5   165*   gl.item_sub_list_ptr - - pointer to sublist of relations contained in this file
  5   166*   gl.file_info_ptr - - pointer to file_info for this file
  5   167*   gl.file_model_ptr - - pointer to file_model for this file
  5   168*   gl.superior_assigned - - ON => file_model present for this file
  5   169*   gl.inferior_assigned - - ON => relation present for this file
  5   170*   gl.complete - - OFF => not formatted yet
  5   171*   gl.consistant - - ON => no relations present
  5   172*
  5   173*   FILE GLOBAL LIST "CONTAINED RELATION" SUBLIST ----------------
  5   174*
  5   175*   sl.type - - SUB_LIST
  5   176*   sl.name - - 32 char relation name
  5   177*   sl.item_info_ptr - - relation's rel_info pointer
  5   178*   sl.parse_info_ptr - - pointer to parse info structure
  5   179*   sl.old_other_info_ptr - - null ()
  5   180*   sl.new_other_info_ptr - - pointer to file global list element
  5   181*   sl.global_list_ptr - - pointer to relation's global list element
  5   182*
  5   183*   FOREIGN KEY GLOBAL LIST --------------------
  5   184*
  5   185*   gl.type - - MAIN_LIST
  5   186*   gl.name - - 32 char link(foreign key) name, parent_link_info.name
  5   187*   gl.item_info_ptr - - pointer to parent_link_info for this foreign key
  5   188*   gl.parse_info_ptr - - pointer to parse info structure
  5   189*   gl.other_info_ptr - - pointer to parent relation global list element
  5   190*   gl.item_sub_list_ptr - - pointer to sublist of child relations for this parent
  5   191*   gl.file_info_ptr - - pointer to file_info for parent relation's file
  5   192*   gl.file_model_ptr - - pointer to file_model for parent relation's file
  5   193*   gl.superior_assigned - - ON => parent present
  5   194*   gl.inferior_assigned - - ON => child present
  5   195*   gl.complete - - ON => pli_info and cli_info present
  5   196*   gl.consistant - - ON => rels/attrs found and corres domains match
  5   197*   gl.child_defined - - ON => not defined by parent, but by one of it's children
  5   198*
  5   199*   FOREIGN KEY GLOBAL LIST CHILDREN SUBLIST
  5   200*
  5   201*   sl.type - - SUB_LIST
  5   202*   sl.name - - 32 char name of relation representing this child
  5   203*   sl.item_info_ptr - - pointer to child_link_info for this child
  5   204*   sl.parse_info_ptr - - pointer to parse info structure
  5   205*   sl.old_other_info_ptr - - pointer to file_model holding this child relation
  5   206*   sl.new_other_info_ptr - - pointer to rel_info for this child
  5   207*   sl.global_list_ptr - - pointer to child relation global list element
  5   208*
  5   209*   NOTE: all pointers are to the new model unless otherwise indicated
  5   210*
  5   211**/
  5   212 
  5   213 /* END INCLUDE FILE mrds_rst_global_lists.incl.pl1	*/
  5   214 
      172 
      173 
      174 
      175      end;
      176 
      177 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/85  0909.2  mrds_rst_list_element.pl1         >special_ldd>online>mrds.pbf-04/18/85>mrds_rst_list_element.pl1
164          1    10/14/83  1608.6  mrds_rst_tree.incl.pl1            >ldd>include>mrds_rst_tree.incl.pl1
166          2    10/14/83  1609.0  mrds_rst_struct_types.incl.pl1    >ldd>include>mrds_rst_struct_types.incl.pl1
168          3    10/14/83  1609.1  mrds_rst_rsc.incl.pl1             >ldd>include>mrds_rst_rsc.incl.pl1
170          4    10/14/83  1608.6  mdbm_seg_area.incl.pl1            >ldd>include>mdbm_seg_area.incl.pl1
172          5    10/14/83  1608.4  mrds_rst_global_lists.incl.pl1    >ldd>include>mrds_rst_global_lists.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
GL                              000002 constant        fixed bin(17,0)          initial dcl 2-72 set ref 88* 135*
MAIN_LIST                              constant        fixed bin(17,0)          initial dcl 5-63 ref 86 129
SEGINFO                         000000 constant        fixed bin(17,0)          initial dcl 2-74 set ref 96* 143*
SEG_INFO                               constant        fixed bin(17,0)          initial dcl 5-65 ref 94 141
SL                              000001 constant        fixed bin(17,0)          initial dcl 2-73 set ref 92* 139*
SUB_LIST                               constant        fixed bin(17,0)          initial dcl 5-64 ref 90 137
data                                   based           pointer                  level 2 dcl 1-41 set ref 78 106*
error_code                             parameter       fixed bin(35,0)          dcl 158 set ref 18 65 77* 87* 91* 95* 99* 116 126*
                                                                                  134* 138* 142* 145*
key                                    parameter       char(32)                 dcl 1-24 set ref 18 65 71* 116 122*
model_area_ptr                  000106 automatic       pointer                  initial dcl 4-18 set ref 4-18*
model_seg_ptr                   000104 automatic       pointer                  initial dcl 4-13 set ref 4-13*
mrds_error_$rst_invalid_structure_type
                                000022 external static fixed bin(35,0)          dcl 161 ref 99 145
mrds_error_$rst_list_delete_fail
                                000024 external static fixed bin(35,0)          dcl 162 ref 126
mrds_error_$rst_list_duplicate  000020 external static fixed bin(35,0)          dcl 160 ref 77
mrds_rst_rsc_alloc              000010 constant        entry                    external dcl 150 ref 88 92 96
mrds_rst_rsc_alloc$free         000012 constant        entry                    external dcl 151 ref 135 139 143
mrds_rst_tree_delete            000014 constant        entry                    external dcl 152 ref 122
mrds_rst_tree_insert            000016 constant        entry                    external dcl 153 ref 71
node                                   based           structure                level 1 dcl 1-41
node_ptr                        000100 automatic       pointer                  dcl 1-27 set ref 71* 78 106
null                                                   builtin function         dcl 149 ref 100 4-13 4-18
root_ptr                               parameter       pointer                  dcl 1-26 set ref 18 65 71* 116 122*
rsc_ptr                                parameter       pointer                  dcl 3-94 set ref 18 65 71* 88* 92* 96* 116 122* 135*
                                                                                  139* 143*
structure_ptr                          parameter       pointer                  dcl 155 set ref 18 65 78* 88* 92* 96* 100* 106 122*
                                                                                  135* 139* 143*
structure_type                         parameter       fixed bin(17,0)          dcl 157 ref 18 65 86 90 94 116 129 137 141
success                         000102 automatic       bit(1)                   unaligned dcl 1-38 set ref 71* 76 122* 126

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ATD                                    internal static fixed bin(17,0)          initial dcl 2-63
ATTRIBUTE                              internal static fixed bin(17,0)          initial dcl 2-16
ATTRIBUTE_DOMAIN                       internal static fixed bin(17,0)          initial dcl 2-14
ATTR_INFO                              internal static fixed bin(17,0)          initial dcl 2-59
ATTR_LIST                              internal static fixed bin(17,0)          initial dcl 2-62
CHANGER                                internal static fixed bin(17,0)          initial dcl 2-52
CHILDREN                               internal static fixed bin(17,0)          initial dcl 2-21
CHILD_LINK_INFO                        internal static fixed bin(17,0)          initial dcl 2-61
COMP_NO_ARRAY                          internal static fixed bin(17,0)          initial dcl 2-64
CONSTANT                               internal static fixed bin(17,0)          initial dcl 2-50
CUR_LEX_TOP                            internal static fixed bin(17,0)          initial dcl 2-36
DB_MODEL                               internal static fixed bin(17,0)          initial dcl 2-45
DELETE_NAME                            internal static fixed bin(17,0)          initial dcl 2-23
DIRECTIVE                              internal static fixed bin(17,0)          initial dcl 2-28
DISPLAY_INFO                           internal static fixed bin(17,0)          initial dcl 2-82
DOMAIN                                 internal static fixed bin(17,0)          initial dcl 2-13
DOMAIN_INFO                            internal static fixed bin(17,0)          initial dcl 2-47
DOM_LIST                               internal static fixed bin(17,0)          initial dcl 2-24
DUP_PREV                               internal static fixed bin(17,0)          initial dcl 2-66
FILE                                   internal static fixed bin(17,0)          initial dcl 2-17
FILE_INFO                              internal static fixed bin(17,0)          initial dcl 2-46
FILE_MODEL                             internal static fixed bin(17,0)          initial dcl 2-57
FIXUP_TOKEN                            internal static fixed bin(17,0)          initial dcl 2-37
FOREIGN_KEY                            internal static fixed bin(17,0)          initial dcl 2-20
INDEX                                  internal static fixed bin(17,0)          initial dcl 2-22
ITEM                                   internal static fixed bin(17,0)          initial dcl 2-18
LEX_STACK                              internal static fixed bin(17,0)          initial dcl 2-34
LINK                                   internal static fixed bin(17,0)          initial dcl 2-19
LIST_OVRLY                             internal static fixed bin(17,0)          initial dcl 2-75
NODE                                   internal static fixed bin(17,0)          initial dcl 2-77
OUTPUT_TEXT                            internal static fixed bin(17,0)          initial dcl 2-40
PARENT_LINK_INFO                       internal static fixed bin(17,0)          initial dcl 2-60
PATH_ENTRY                             internal static fixed bin(17,0)          initial dcl 2-48
P_STRUCT                               internal static fixed bin(17,0)          initial dcl 2-35
RELATION                               internal static fixed bin(17,0)          initial dcl 2-15
REL_INFO                               internal static fixed bin(17,0)          initial dcl 2-58
SAVED_CHILD_COUNT                      internal static fixed bin(17,0)          initial dcl 2-76
SELECT_CHAIN                           internal static fixed bin(17,0)          initial dcl 2-67
SORT_KEY                               internal static fixed bin(17,0)          initial dcl 2-65
STACK_ITEM                             internal static fixed bin(17,0)          initial dcl 2-49
STMT                                   internal static fixed bin(17,0)          initial dcl 2-29
STRING_SOURCE                          internal static fixed bin(17,0)          initial dcl 2-38
TOKEN                                  internal static fixed bin(17,0)          initial dcl 2-39
VERSION_STATUS                         internal static fixed bin(17,0)          initial dcl 2-51
area_ptr                               automatic       pointer                  dcl 1-34
data_ptr                               automatic       pointer                  dcl 1-29
gl                                     based           structure                level 1 dcl 5-15
gl_ptr                                 automatic       pointer                  dcl 5-36
list_ovrly                             based           structure                level 1 dcl 5-67
list_ovrly_ptr                         automatic       pointer                  dcl 5-74
model_area                             based           area                     dcl 4-16
model_seg                              based           structure                level 1 dcl 4-9
parent_ptr                             automatic       pointer                  dcl 1-28
predecessor_parent_ptr                 automatic       pointer                  dcl 1-33
predecessor_ptr                        automatic       pointer                  dcl 1-32
rsc                                    based           structure                level 1 unaligned dcl 3-29
saved_child_count                      based           fixed bin(17,0)          dcl 5-77
saved_child_count_ptr                  automatic       pointer                  dcl 5-78
seg_info                               based           structure                level 1 unaligned dcl 5-53
seg_info_ptr                           automatic       pointer                  dcl 5-59
size                                                   builtin function         dcl 4-20
sl                                     based           structure                level 1 dcl 5-40
sl_ptr                                 automatic       pointer                  dcl 5-50
successor_parent_ptr                   automatic       pointer                  dcl 1-31
successor_ptr                          automatic       pointer                  dcl 1-30
thread                                 automatic       bit(1)                   dcl 1-39
work_area                              based           area(1024)               dcl 1-36

NAMES DECLARED BY EXPLICIT CONTEXT.
add                             000042 constant        entry                    external dcl 65
delete                          000204 constant        entry                    external dcl 116
mrds_rst_list_element           000026 constant        entry                    external dcl 18

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       464         512     327         474
Length      1012     327        26         264     135           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_rst_list_element                88 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_rst_list_element    000100 node_ptr                    mrds_rst_list_element
                         000102 success                     mrds_rst_list_element
                         000104 model_seg_ptr               mrds_rst_list_element
                         000106 model_area_ptr              mrds_rst_list_element

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
mrds_rst_rsc_alloc            mrds_rst_rsc_alloc$free       mrds_rst_tree_delete          mrds_rst_tree_insert

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mrds_error_$rst_invalid_structure_type                      mrds_error_$rst_list_delete_fail
mrds_error_$rst_list_duplicate




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 4   13 000013    4   18 000015        18 000020        65 000037        71 000053        76 000073        77 000076
     78 000101        79 000105        86 000106        87 000112        88 000113        89 000126        90 000127
     91 000131        92 000132        93 000145        94 000146        95 000150        96 000151        97 000164
     99 000165       100 000170       106 000172       110 000176       116 000177       122 000215       126 000235
    129 000244       134 000250       135 000251       136 000264       137 000265       138 000267       139 000270
    140 000303       141 000304       142 000306       143 000307       144 000322       145 000323       175 000326


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
