	COMPILATION LISTING OF SEGMENT trim_wordlist
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 02/16/88  1421.0 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(85-09-13,Spitzer), approve(85-09-13,MCR6618),
       12*     audit(85-10-30,Blair), install(85-12-16,MR12.0-1001):
       13*     Allow to read/write
       14*     MSFs.
       15*  2) change(88-01-01,Gilcrease), approve(88-02-05,MCR7834),
       16*     audit(88-02-05,Blair), install(88-02-16,MR12.2-1023):
       17*               Fix trim error when first letter cap, and contains '.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 trim_wordlist: twl: proc;
       21 
       22 /* The trim_wordlist command removes from a specified wordlist all
       23*   words found in a specified sequence of dictionaries.  The dictionaries
       24*   are consulted in order.  If the "notrim" attribute is enabled
       25*   for a word found in a dictionary,  the word is not deleted and
       26*   subsequent dictionaries in the sequence, if any, are not consulted
       27*   for that word.
       28**/
       29 
       30 /* Coded 9/28/77 by J. Stern */
       31 /* Modified 7/7/81 by P. Benjamin to fix bug where bad dict in search list stops processing */
       32 
       33 /* Automatic */
       34 
       35 dcl  msf bit (1) aligned;
       36 dcl (nargs, argno) fixed bin;
       37 dcl  ap ptr;
       38 dcl  al fixed bin;
       39 dcl  code fixed bin (35);
       40 dcl  system_area_ptr ptr;
       41 dcl  ndict fixed bin;
       42 dcl  temp_ndict fixed bin;
       43 dcl (brief, exact_match, have_wl_path) bit (1) aligned;
       44 dcl  (temp_dir, dname) char (168);
       45 dcl  (temp_name, ename) char (32);
       46 dcl  temp_ptr ptr;
       47 dcl  type fixed bin (2);
       48 dcl  bc fixed bin (24);
       49 dcl  wl_ptr ptr;
       50 dcl (wl_len, wl_ix) fixed bin (21);
       51 dcl  switch char (32);
       52 dcl  atd char (256) varying;
       53 dcl  dictx fixed bin;
       54 dcl (nwords, saved_nwords, original_nwords) fixed bin (21);
       55 dcl  eof bit (1) aligned;
       56 dcl  wordx fixed bin (21);
       57 dcl  word_ptr ptr;
       58 dcl  word_len fixed bin (21);
       59 dcl  notrim bit (1) aligned;
       60 dcl  new_wl_len fixed bin (21);
       61 dcl  dip ptr;
       62 
       63 dcl 1 get_key_info,
       64     2 flags like gk_header.flags,
       65     2 descriptor,
       66       3 hpoints bit (32) unal,
       67       3 notrim bit (1) unal,
       68       3 pad bit (3) unal,
       69     2 key_len fixed bin,
       70     2 key char (256);
       71 
       72 
       73 /* Based */
       74 
       75 dcl  arg char (al) based (ap);
       76 dcl  system_area area based (system_area_ptr);
       77 dcl  dict_iocbps (ndict) ptr based (dip);
       78 dcl  wl_cs char (wl_len) based (wl_ptr);
       79 dcl  wl_vec (wl_len) char (1) unal based (wl_ptr);
       80 dcl  word char (word_len) based (word_ptr);
       81 
       82 dcl  1 trim_data (nwords) aligned based (temp_ptr),
       83      2 wordp ptr unal,
       84      2 notrim bit (1) unal,
       85      2 pad bit (10) unal,
       86      2 wordl fixed bin (24) unal;
       87 
       88 /* Static */
       89 
       90 dcl  error_table_$dirseg fixed bin(35) ext static;
       91 dcl  error_table_$short_record fixed bin(35) ext static;
       92 dcl  error_table_$end_of_info fixed bin(35) ext static;
       93 dcl  error_table_$fatal_error fixed bin (35) ext;
       94 dcl  error_table_$noarg fixed bin (35) ext;
       95 dcl  error_table_$zero_length_seg fixed bin (35) ext;
       96 dcl  error_table_$badopt fixed bin (35) ext;
       97 dcl  error_table_$no_record fixed bin (35) ext;
       98 dcl  error_table_$no_key fixed bin (35) ext;
       99 
      100 dcl  whoami char (13) int static options (constant) init ("trim_wordlist");
      101 dcl  capital_letters char (26) int static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
      102 dcl  small_letters char (26) int static options (constant) init ("abcdefghijklmnopqrstuvwxyz");
      103 dcl  NL char (1) int static options (constant) init ("
      104 ");
      105 
      106 
      107 /* Conditions */
      108 
      109 dcl  cleanup condition;
      110 
      111 
      112 /* Builtins */
      113 
      114 dcl (substr, divide, null, rtrim, index, addr, verify, translate, search, mod, length, unspec) builtin;
      115 
      116 
      117 /* Entries */
      118 
      119 dcl  cu_$arg_count entry (fixed bin);
      120 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
      121 dcl  com_err_ entry options (variable);
      122 dcl  get_system_free_area_ entry (ptr);
      123 dcl  get_pdir_ entry() returns(char(168));
      124 dcl  expand_pathname_$add_suffix entry (char (*), char (*), char (*), char (*), fixed bin (35));
      125 dcl  absolute_pathname_ entry (char(*), char(*), fixed bin(35));
      126 dcl  absolute_pathname_$add_suffix entry (char (*), char (*), char (*), fixed bin (35));
      127 dcl  initiate_file_ entry (char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35));
      128 dcl  (get_temp_segment_, release_temp_segment_) entry (char (*), ptr, fixed bin (35));
      129 dcl  hcs_$status_minf entry (char(*), char(*), fixed bin(1), fixed bin(2), fixed bin(24), fixed bin(35));
      130 dcl  unique_chars_ entry (bit (*)) returns (char (15));
      131 dcl  pathname_ entry (char(*), char(*)) returns(char(168));
      132 dcl  iox_$attach_name entry (char(*), ptr, char(*), ptr, fixed bin(35));
      133 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
      134 dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
      135 dcl  iox_$close entry (ptr, fixed bin (35));
      136 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
      137 dcl  iox_$destroy_iocb entry (ptr, fixed bin(35));
      138 dcl  iox_$put_chars entry (ptr, ptr, fixed bin(21), fixed bin(35));
      139 dcl  iox_$get_line entry (ptr, ptr, fixed bin(21), fixed bin(21), fixed bin(35));
      140 dcl  delete_$path entry (char(*), char(*), bit(36) aligned, char(*), fixed bin(35));
      141 dcl  ioa_ entry options (variable);
      142 dcl  terminate_file_ entry (ptr, fixed bin(24), bit(*), fixed bin(35));
      143 dcl  search_paths_$get entry (char (*), bit (36), char (*), ptr, ptr, fixed bin, ptr, fixed bin (35));
      144 dcl  copy_ entry (ptr);
      145 
      146 	wl_ptr, temp_ptr, dip, sl_info_p = null;	/* initialize ptrs */
      147 
      148 /* find out how many args we have */
      149 
      150 	call cu_$arg_count (nargs);
      151 	if nargs < 1
      152 	then do;
      153 noarg:	     call com_err_ (error_table_$noarg, whoami, "^/Usage:  trim_wordlist wl_path {dict_paths} {-brief} {-exact_match}");
      154 	     go to finish;
      155 	end;
      156 
      157 	on cleanup call cleaner;
      158 
      159 /* allocate space for dictionary pathnames */
      160 
      161 	sl_info_num_paths = nargs - 1;			/* upper limit on number of dict paths */
      162 	call get_system_free_area_ (system_area_ptr);
      163 	allocate sl_info in (system_area);
      164 
      165 /* examine arguments */
      166 
      167 	ndict = 0;
      168 	brief, exact_match, have_wl_path = "0"b;
      169 	temp_dir = get_pdir_ ();
      170 
      171 	do argno = 1 to nargs;
      172 	     call cu_$arg_ptr (argno, ap, al, code);
      173 	     if index (arg, "-") ^= 1			/* not a control arg */
      174 	     then if ^have_wl_path			/* don't have wordlist pathname yet */
      175 		then do;
      176 		     call expand_pathname_$add_suffix (arg, "wl", dname, ename, code);
      177 		     if code ^= 0
      178 		     then do;
      179 			call com_err_ (code, whoami, arg);
      180 			go to finish;
      181 		     end;
      182 		     have_wl_path = "1"b;		/* remember we have the wordlist pathname */
      183 		end;
      184 		else do;				/* must be a dictionary pathname */
      185 		     ndict = ndict + 1;
      186 		     call absolute_pathname_$add_suffix (arg, "dict", sl_info.pathname (ndict), code);
      187 		     if code ^= 0
      188 		     then do;
      189 			call com_err_ (code, whoami, arg);
      190 			go to finish;
      191 		     end;
      192 		end;
      193 
      194 	     else if arg = "-td" | arg = "-temp_dir"
      195 		then do;
      196 		     call cu_$arg_ptr (argno+1, ap, al, code);
      197 		     if code ^= 0 then do;
      198 			call com_err_ (code, whoami, "After -temp_dir");
      199 			return;
      200 			end;
      201 		     call absolute_pathname_ (arg, temp_dir, code);
      202 		     if code ^= 0 then do;
      203 			call com_err_ (code, whoami, "^a", arg);
      204 			return;
      205 			end;
      206 		     argno = argno + 1;
      207 		     end;
      208 
      209 	     else if arg = "-bf" | arg = "-brief"
      210 	     then brief = "1"b;
      211 
      212 	     else if arg = "-exm" | arg = "-exact_match"
      213 	     then exact_match = "1"b;
      214 
      215 	     else do;
      216 		call com_err_ (error_table_$badopt, whoami, arg);
      217 		go to finish;
      218 	     end;
      219 	end;
      220 
      221 	if ^have_wl_path
      222 	then go to noarg;
      223 
      224 /* if no dictionaries specified, get search list */
      225 
      226 	if ndict = 0
      227 	then do;
      228 	     free sl_info in (system_area);
      229 	     sl_info_p = null;
      230 
      231 	     call search_paths_$get ("dict", "111111"b, "", null, system_area_ptr, sl_info_version_1, sl_info_p, code);
      232 	     if code ^= 0
      233 	     then do;
      234 		call com_err_ (code, whoami, "Cannot get ""dict"" search list.");
      235 		go to finish;
      236 	     end;
      237 
      238 	     ndict = sl_info.num_paths;
      239 	end;
      240 
      241 	call hcs_$status_minf (dname, ename, 1, type, bc, code);
      242 	if code ^= 0 then goto bad_seg;
      243 
      244 	if type = 2
      245 	then if bc = 0
      246 	     then do;
      247 		code = error_table_$dirseg;
      248 		goto bad_seg;
      249 		end;
      250 	     else msf = "1"b;
      251 	else msf = "0"b;
      252 
      253 	if msf
      254 	then do;
      255 /* open original word list */
      256 	     switch = unique_chars_ ("0"b) || "." || whoami;
      257 	     atd = "vfile_ " || rtrim (dname);
      258 	     atd = atd || ">";
      259 	     atd = atd || ename;
      260 
      261 	     call iox_$attach_name (switch, wl_ptr, (atd), null, code);
      262 	     if code ^= 0 then goto bad_seg;
      263 	     
      264 	     call iox_$open (wl_ptr, Stream_input, "0"b, code);
      265 	     if code ^= 0 then goto bad_seg;
      266 
      267 /* open temp file in [pd] to hold trimmed list */
      268 
      269 	     temp_name, switch = unique_chars_ ("0"b) || "." || whoami;
      270 	     atd = "vfile_ " || rtrim (temp_dir);
      271 	     atd = atd || ">";
      272 	     atd = atd || temp_name;
      273 
      274 	     call iox_$attach_name (switch, temp_ptr, (atd), null, code);
      275 	     if code ^= 0 then do;
      276 		call com_err_ (code, whoami, "Attempting to attach temp file in [pd].");
      277 		goto finish;
      278 		end;
      279 
      280 	     call iox_$open (temp_ptr, Stream_output, "0"b, code);
      281 	     if code ^= 0 then do;
      282 		call com_err_ (code, whoami, "Attempting to open a temp file in [pd].");
      283 		goto finish;
      284 		end;
      285 	     end;
      286 	else do;					/* get ptr to and length of the wordlist */
      287 	     call initiate_file_ (dname, ename, RW_ACCESS, wl_ptr, bc, code);
      288 	     if wl_ptr = null
      289 	     then do;
      290 bad_seg:		call com_err_ (code, whoami, "^a", pathname_ (dname, ename));
      291 		go to finish;
      292 		end;
      293 
      294 	     wl_len = divide (bc, 9, 24, 0);		/* convert bit count to char count */
      295 	     if wl_len = 0
      296 	     then do;
      297 		code = error_table_$zero_length_seg;
      298 		go to bad_seg;
      299 		end;
      300 	     end;
      301 
      302 /* if more than 1 dictionary, create temporary workspace */
      303 
      304 	if ndict > 1 & ^msf
      305 	then do;
      306 	     call get_temp_segment_ (whoami, temp_ptr, code);
      307 	     if code ^= 0
      308 	     then do;
      309 		call com_err_ (code, whoami, "Cannot get temp segment.");
      310 		go to finish;
      311 	     end;
      312 	end;
      313 
      314 /* open all of the dictionaries */
      315 
      316 	allocate dict_iocbps in (system_area);
      317 	dict_iocbps (*) = null;
      318 
      319 	temp_ndict = 1;
      320 	do dictx = 1 to ndict;
      321 	     switch = unique_chars_ (""b) || "." || whoami;    /* use unique name for I/O switch */
      322 	     atd = "vfile_ " || rtrim (sl_info.pathname (dictx));
      323 	     atd = atd || " -share"; /* build attach description */
      324 	     call iox_$attach_name (switch, dict_iocbps (temp_ndict), (atd), null, code);
      325 	     if code ^= 0
      326 		then call com_err_ (code, whoami, "Cannot attach switch.  ^a", switch);
      327 
      328 	     else do;
      329 		call iox_$open (dict_iocbps (temp_ndict), Keyed_sequential_input, "0"b, code);
      330 		if code ^= 0
      331 		     then do;
      332 		     call com_err_ (code, whoami, "Cannot open file.  ^a", sl_info.pathname (dictx));
      333 		     call iox_$detach_iocb (dict_iocbps (temp_ndict), code);
      334 		end;
      335 		else temp_ndict = temp_ndict + 1;
      336 	     end;
      337 	end;
      338 	if temp_ndict = 1				/* No usable dicts */
      339 	     then do;
      340 	     call com_err_ (error_table_$fatal_error, whoami);
      341 	     goto finish;
      342 	end;
      343 	ndict = temp_ndict - 1;			/* Now ndict is the number of usable dicts */
      344 	
      345 	get_key_info.flags.input_key = "1"b;
      346 	get_key_info.input_desc = "0"b;
      347 	get_key_info.desc_code = 0;
      348 	get_key_info.rel_type = 0;
      349 	get_key_info.head_size = 256;
      350 	get_key_info.reset_pos = "0"b;
      351 	get_key_info.flags.pad = ""b;
      352 	get_key_info.version = gk_info_version_0;
      353 
      354 /* now do the real work */
      355 
      356 	if msf then call process_msf;
      357 	else call process_non_msf;
      358 
      359 /* report results if brief option not specified */
      360 
      361 	if ^brief
      362 	then call ioa_ ("number of words trimmed = ^d^/number of words remaining = ^d", original_nwords-nwords, nwords);
      363 
      364 /* clean up and go home */
      365 
      366 	if ^msf then do;
      367 	    if new_wl_len + 1 <= wl_len then	         /* set to NUL */
      368   	       substr (wl_cs, new_wl_len + 1, 4 - mod (new_wl_len, 4)) = "   ";
      369 	     call terminate_file_ (wl_ptr, 9 * new_wl_len, TERM_FILE_TRUNC_BC_TERM, code);
      370 	     if code ^= 0
      371 	     then call com_err_ (code, whoami, "^a", pathname_ (dname, ename));
      372 	     end;
      373 
      374 finish:	call cleaner;
      375 	return;
      376 
      377 cleaner:	proc;					/* cleanup procedure */
      378 
      379 	     if dip ^= null
      380 	     then do dictx = 1 to ndict;
      381 		if dict_iocbps (dictx) ^= null
      382 		then call close_file (dict_iocbps (dictx));
      383 	     end;
      384 
      385 	     if msf
      386 	     then do;
      387 		if wl_ptr ^= null then call close_file (wl_ptr);
      388 		if temp_ptr ^= null then call close_file (temp_ptr);
      389 		call delete_$path (temp_dir, temp_name, "101111"b, whoami, (0));
      390 		wl_ptr, temp_ptr = null;
      391 		end;
      392 	     else do;
      393 		if temp_ptr ^= null
      394 		then call release_temp_segment_ (whoami, temp_ptr, (0));
      395 		if wl_ptr ^= null
      396 		then call terminate_file_ (wl_ptr, 0, TERM_FILE_TERM, (0));
      397 		end;
      398 
      399 	     if dip ^= null
      400 	     then free dict_iocbps in (system_area);
      401 
      402 	     if sl_info_p ^= null
      403 	     then free sl_info in (system_area);
      404 
      405 	end cleaner;
      406 
      407 close_file:
      408      proc (iocbp);
      409 
      410 dcl  iocbp ptr parameter;
      411 
      412 	call iox_$close (iocbp, (0));
      413 	call iox_$detach_iocb (iocbp, (0));
      414 	call iox_$destroy_iocb (iocbp, (0));
      415 	iocbp = null;
      416 
      417 	return;
      418 	end close_file;
      419 
      420 process_non_msf:
      421      proc;
      422 
      423 /* consult the dictionaries one at a time (in order) */
      424 /* for each dictionary, look up all wordlist words */
      425 /* for each word, either trim or retain as appropriate */
      426 /* for the first dictionary, parse the wordlist as we go */
      427 /* for the last dictionary, build the new trimmed wordlist as we go */
      428 
      429 	wl_ix = 1;
      430 	new_wl_len = 0;
      431 	saved_nwords = wl_len;			/* upper limit on number of words in wordlist */
      432 
      433 	do dictx = 1 to ndict;
      434 	     eof = "0"b;
      435 	     nwords = 0;
      436 
      437 	     do wordx = 1 to saved_nwords while (^eof);
      438 
      439 		if dictx = 1			/* first dictionary */
      440 		then do;				/* find next word in wordlist */
      441 		     word_len = index (substr (wl_cs, wl_ix), NL) -1;
      442 		     if word_len = 0		/* a blank line, not legal but we'll tolerate it */
      443 		     then go to advance_index;
      444 		     if word_len = -1		/* wordlist does not end in NL, be kind */
      445 		     then word_len = wl_len -wl_ix + 1; /* last word is rest of segment */
      446 		     word_ptr = addr (wl_vec (wl_ix));
      447 		     if word_len > 256		/* cannot be in dictionary */
      448 		     then notrim = "1"b;		/* so don't bother looking */
      449 		     else notrim = "0"b;
      450 advance_index:	     wl_ix = wl_ix + word_len + 1;
      451 		     if wl_ix > wl_len
      452 		     then eof = "1"b;		/* end of wordlist reached */
      453 		     if word_len = 0
      454 		     then do;
      455 			wordx = wordx - 1;		/* don't count this word */
      456 			go to next_word;
      457 		     end;
      458 		end;
      459 
      460 		else do;				/* get saved word description */
      461 		     word_ptr = trim_data (wordx).wordp;
      462 		     word_len = trim_data (wordx).wordl;
      463 		     notrim = trim_data (wordx).notrim;
      464 		end;
      465 
      466 		if ^trim_word ()			/* retain this word */
      467 		then do;
      468 		     nwords = nwords + 1;
      469 		     if dictx < ndict		/* not last dictionary */
      470 		     then do;			/* save word description */
      471 			trim_data (nwords).wordp = word_ptr;
      472 			trim_data (nwords).wordl = word_len;
      473 			trim_data (nwords).notrim = notrim;
      474 		     end;
      475 		     else do;			/* last dictionary, put word in new wordlist */
      476 			substr (wl_cs, new_wl_len + 1, word_len) = word;
      477 			new_wl_len = new_wl_len + word_len;
      478 			substr (wl_cs, new_wl_len + 1, 1) = NL;
      479 			new_wl_len = new_wl_len + 1;
      480 		     end;
      481 		end;
      482 next_word:
      483 	     end;
      484 
      485 	     if dictx = 1
      486 	     then original_nwords = wordx - 1;
      487 	     saved_nwords = nwords;
      488 	end;
      489 
      490           return;
      491 	end process_non_msf;
      492 
      493 process_msf:
      494      proc;
      495 
      496 /* For each word, consult the dictionaries. If it is not to be trimmed, write
      497*   the word out to the output temp file in [pd]. When done and if there has
      498*   been at least one word changed, copy_ the temp file over the original. */
      499 
      500 dcl  buffer char (256);
      501 dcl  word_max_len fixed bin (21);
      502 dcl  1 co like copy_options;
      503 
      504           word_ptr = addr (buffer);
      505 	word_max_len = length (buffer);
      506 	notrim = "0"b;
      507 	nwords, original_nwords = 0;
      508 
      509 	call iox_$get_line (wl_ptr, word_ptr, word_max_len, word_len, code);
      510 	do while (code ^= error_table_$end_of_info);
      511 	     if code ^= 0
      512 	     then if code ^= error_table_$short_record
      513 		then goto bad_seg;
      514 	          else ;
      515 	     else word_len = word_len - 1;
      516 
      517 	     if word_len = 0 then goto skip_word;
      518 	     original_nwords = original_nwords + 1;
      519 
      520 	     do dictx = 1 to ndict;
      521 		if trim_word ()
      522 		then goto skip_word;
      523 		end;
      524 
      525 	     call iox_$put_chars (temp_ptr, word_ptr, word_len, code);
      526 	     if code = 0 then do;
      527 		call iox_$put_chars (temp_ptr, addr (NL), length (NL), code);
      528 		nwords = nwords + 1;
      529 		end;
      530 	     if code ^= 0 then call com_err_ (code, whoami, "Writing word ""^a"" to temp file.", word);
      531 	     
      532 skip_word:
      533 	     call iox_$get_line (wl_ptr, word_ptr, word_max_len, word_len, code);
      534 	     end;
      535 
      536 	if original_nwords = 0 then do;
      537 	     code = error_table_$zero_length_seg;
      538 	     goto bad_seg;
      539 	     end;
      540 
      541 	call close_file (temp_ptr);
      542 	call close_file (wl_ptr);
      543 
      544 	if nwords ^= original_nwords then do;		/* some got trimmed */
      545 	     co.version = COPY_OPTIONS_VERSION_1;
      546 	     co.caller_name = whoami;
      547 	     co.source_dir = temp_dir;
      548 	     co.source_name = temp_name;
      549 	     co.target_dir = dname;
      550 	     co.target_name = ename;
      551 	     unspec (co.flags) = "0"b;
      552 	     co.flags.delete = "1"b;			/* delete source when done */
      553 	     co.flags.force = "1"b;			/* try to force access if needed */
      554 
      555 	     unspec (co.copy_items) = "0"b;
      556 	     co.copy_items.update = "1"b;
      557 
      558 	     call copy_ (addr(co));			/* copy work file to input file */
      559 	     if co.target_err_switch
      560 	     then goto finish;			/* errors reported by sub_err_ */
      561 	     end;
      562 
      563 	return;
      564 	end process_msf;
      565 
      566 /* This procedure determines whether or not the current word should be trimmed.
      567*   It first looks for the current word in the current dictionary.  If found,
      568*   the word is trimmed unless it has the notrim attribute.  If the word is
      569*   not found and the exact_match option was not specified, the word is checked
      570*   for standard capitalization.  If the current word has only its first letter
      571*   capitalized, it can be trimmed by the equivalent de-capitalized word if
      572*   found in the dictionary.  If the current word has all letters capitalized,
      573*   it can be trimmed by either a "first-cap" or "no-cap" equivalent
      574*   word if found in the dictionary.
      575**/
      576 
      577 trim_word: proc returns (bit (1) aligned);
      578 
      579 
      580 	     if notrim
      581 	     then return ("0"b);
      582 
      583 	     get_key_info.key = word;
      584 	     if known_word ()
      585 	     then return ("1"b);
      586 
      587 	     if exact_match
      588 	     then return ("0"b);
      589 
      590 	     if verify (word, capital_letters) = 0
      591 	     then do;
      592 		if word_len > 1
      593 		then do;
      594 		     substr (get_key_info.key, 2) = translate (substr (word, 2), small_letters, capital_letters);
      595 		     if known_word ()
      596 		     then return ("1"b);
      597 		end;
      598 check_no_cap:
      599 		get_key_info.key = translate (word, small_letters, capital_letters);
      600 		if known_word ()
      601 		then return ("1"b);
      602 	     end;
      603 	     else if word_len > 1
      604 	     then if search (substr (word, 1, 1), capital_letters) = 1
      605 		& verify (substr (word, 2), small_letters) = 0
      606 		then go to check_no_cap;
      607 	     else if index (word, "'") ^= 0 then go to check_no_cap;
      608 
      609 skip_word:     return ("0"b);
      610 
      611 /* This procedure determines whether or not a specified word is "known",
      612*   i.e., whether or not the word is defined in the current dictionary.
      613*   Each dictionary is an indexed file.  A dictionary contains a word
      614*   if the word is a key for the file.  A record descriptor is associated
      615*   with each key.  The notrim flag (as well as other data) is kept in the
      616*   record descriptor.
      617**/
      618 
      619 known_word:    proc returns (bit (1) aligned);
      620 
      621 
      622 		get_key_info.key_len = 256;
      623 		call iox_$control (dict_iocbps (dictx), "get_key", addr (get_key_info), code);
      624 		if code ^= 0
      625 		then if code = error_table_$no_record | code = error_table_$no_key
      626 		     then return ("0"b);
      627 		     else do;
      628 			call com_err_ (code, whoami, "Referencing dictionary ^a.  Word not trimmed.  ^a",
      629 			     sl_info.pathname (dictx), word);
      630 			go to dont_trim;
      631 		     end;
      632 
      633 		if get_key_info.notrim
      634 		then do;
      635 dont_trim:	     notrim = "1"b;
      636 		     go to skip_word;
      637 		end;
      638 
      639 		return ("1"b);
      640 
      641 	     end known_word;
      642 
      643 
      644 	end trim_word;
      645 
      646 /* include files */
      647 
  1     1 /* ak_info -- include file for info structures used by the following vfile_
  1     2*   control orders: "add_key", "delete_key", "get_key", and "reassign_key".
  1     3*   Created by M. Asherman 3/23/76
  1     4*   Modified 5/13/77 to add separate gk_info structure */
  1     5 
  1     6      dcl	   1 ak_info	      based (ak_info_ptr),
  1     7 	     2 header	      like ak_header,
  1     8 	     2 key	      char (ak_key_len refer (ak_info.header.key_len));
  1     9 
  1    10      dcl	   1 ak_header	      based (ak_info_ptr),
  1    11 	     2 flags	      aligned,
  1    12 	       3 input_key	      bit (1) unal,		/* set if key is input arg */
  1    13 	       3 input_desc	      bit (1) unal,		/* set if descriptor is an input arg */
  1    14 	       3 mbz	      bit (34) unal,	/* not used for the present */
  1    15 	     2 descrip	      fixed (35),		/* record designator */
  1    16 	     2 key_len	      fixed;
  1    17 
  1    18      dcl	   ak_info_ptr	      ptr;
  1    19      dcl	   ak_key_len	      fixed;
  1    20 
  1    21 
  1    22      dcl	   1 rk_info	      based (rk_info_ptr),
  1    23 	     2 header	      like rk_header,
  1    24 	     2 key	      char (rk_key_len refer (rk_info.header.key_len));
  1    25 
  1    26      dcl	   1 rk_header	      based (rk_info_ptr),
  1    27 	     2 flags	      aligned,
  1    28 	       3 input_key	      bit (1) unal,		/* same as above */
  1    29 	       3 input_old_desc   bit (1) unal,		/* set if specified entry has initial descrip
  1    30*						   given by old_descrip */
  1    31 	       3 input_new_desc   bit (1) unal,		/* set if new val for descrip is input in this struc */
  1    32 	       3 mbz	      bit (33) unal,
  1    33 	     2 old_descrip	      fixed (35),		/* used if first flag is set */
  1    34 	     2 new_descrip	      fixed (35),		/* used only if second flag is set */
  1    35 	     2 key_len	      fixed;
  1    36 
  1    37      dcl	   rk_info_ptr	      ptr;
  1    38      dcl	   rk_key_len	      fixed;
  1    39 
  1    40 
  1    41      dcl	   1 gk_info	      based (gk_info_ptr),	/* structure for get_key order */
  1    42 	     2 header	      like gk_header,
  1    43 	     2 key	      char (gk_key_len refer (gk_info.header.key_len));
  1    44 						/* may be Input as well as Output */
  1    45 
  1    46      dcl	   1 gk_header	      based (gk_info_ptr),
  1    47 	     2 flags	      aligned,
  1    48 	       3 input_key	      bit (1) unal,		/* if set, use key in this structure */
  1    49 	       3 input_desc	      bit (1) unal,		/* if set, descriptor given in this structure */
  1    50 	       3 desc_code	      fixed (2) unal,	/* 0=any, 1=current -- applies when input_desc="0"b */
  1    51 	       3 position_specification
  1    52 			      unal,
  1    53 	         4 current	      bit (1) unal,		/* otherwise next */
  1    54 	         4 rel_type	      fixed (2) unal,	/* as in seek_head, if input_key = "1"b */
  1    55 	         4 head_size      fixed bin (9) unsigned unaligned,
  1    56 						/* size of head for initial seek */
  1    57 	       3 reset_pos	      bit (1) unal,		/* if set, final position unchanged by this operation */
  1    58 	       3 pad	      bit (8) unal,
  1    59 	       3 version	      fixed (8) unal,
  1    60 	     2 descrip	      fixed (35),		/* Output, except when input_desc="1"b */
  1    61 	     2 key_len	      fixed;		/* Input when input_key="1"b, also Output in all cases */
  1    62 
  1    63      dcl	   gk_info_ptr	      ptr;
  1    64      dcl	   gk_key_len	      fixed;
  1    65 
  1    66      dcl	   gk_info_version_0      internal static fixed options (constant) init (0);
  1    67 
  1    68 /* end ak_info.incl.pl1 */
      648 
  2     1 /* BEGIN INCLUDE FILE . . . sl_info.incl.pl1 */
  2     2 
  2     3      
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(87-11-16,Lippard), approve(87-12-21,MCR7822),
  2     7*     audit(88-02-09,Blair), install(88-02-16,MR12.2-1023):
  2     8*     Modified to add INITIATED_SEGS type.
  2     9*  2) change(87-11-19,Lippard), approve(87-12-21,MCR7822),
  2    10*     audit(88-02-09,Blair), install(88-02-16,MR12.2-1023):
  2    11*     Added uid to sl_info structure.
  2    12*                                                   END HISTORY COMMENTS */
  2    13 
  2    14 
  2    15 declare 1 sl_info	      aligned based (sl_info_p),
  2    16 	     2 version	      fixed binary,		/* Must be 1 */
  2    17 	     2 num_paths	      fixed binary,		/* Number of search paths */
  2    18 	     2 change_index_p     pointer,		/* Pointer to search list's update count */
  2    19 	     2 change_index	      fixed binary (71),	/* This search list's update count */
  2    20 	     2 pad1	      (6) bit (36),		/* Must be zero */
  2    21 	     2 paths	      (sl_info_num_paths refer (sl_info.num_paths)),
  2    22 	       3 type	      fixed binary,		/* Type of search path */
  2    23 	       3 code	      fixed binary (35),	/* Standard status code of search path */
  2    24 	       3 uid	      bit (36),		/* Unique ID */
  2    25 	       3 pathname	      char (168) unaligned;	/* Search pathname */
  2    26 
  2    27      declare sl_info_num_paths      fixed binary;
  2    28      declare sl_info_p	      pointer;
  2    29      declare sl_info_version_1      fixed binary internal static options (constant) initial (1);
  2    30 
  2    31 /* Keyword Types */
  2    32 
  2    33      declare ABSOLUTE_PATH	      fixed binary internal static options (constant) initial (0);
  2    34      declare UNEXPANDED_PATH	      fixed binary internal static options (constant) initial (1);
  2    35      declare REFERENCING_DIR	      fixed binary internal static options (constant) initial (3);
  2    36      declare WORKING_DIR	      fixed binary internal static options (constant) initial (4);
  2    37      declare PROCESS_DIR	      fixed binary internal static options (constant) initial (5);
  2    38      declare HOME_DIR	      fixed binary internal static options (constant) initial (6);
  2    39      declare INITIATED_SEGS	      fixed binary internal static options (constant) initial (7);
  2    40 
  2    41 /* END INCLUDE FILE . . . sl_info.incl.pl1 */
      649 
  3     1 /* BEGIN INCLUDE FILE: copy_options.incl.pl1 */
  3     2 
  3     3 /* This structure declares the input structure used by the copy_ subroutine.
  3     4*
  3     5*   NOTE: This include file depends on declarations in the include file
  3     6*   copy_flags.incl.pl1.
  3     7*
  3     8*   Jay Pattin 6/1/83 */
  3     9 
  3    10 declare   copy_options_ptr              ptr;
  3    11 
  3    12 declare   1 copy_options                aligned based (copy_options_ptr),
  3    13           2 version                     char (8),           /* currently COPY_OPTIONS_VERSION_1 */
  3    14           2 caller_name                 char (32) unal,     /* Used in nd_handler_ call */
  3    15           2 source_dir                  char (168) unal,
  3    16           2 source_name                 char (32) unal,
  3    17           2 target_dir                  char (168) unal,
  3    18           2 target_name                 char (32) unal,
  3    19           2 flags,
  3    20             3 no_name_dup               bit (1) unaligned,  /* ON = don't call nd_handler_ */
  3    21             3 raw                       bit (1) unaligned,  /* ON = don't call object_type_, use hcs_ */
  3    22             3 force                     bit (1) unaligned,  /* ON = delete or force access to target */
  3    23             3 delete                    bit (1) unaligned,  /* ON = delete original after copy (for move) */
  3    24             3 target_err_switch         bit (1) unaligned,
  3    25             3 mbz                       bit (31) unaligned,
  3    26           2 copy_items                  like copy_flags;    /* see copy_flags.incl.pl1 */
  3    27 
  3    28 declare   COPY_OPTIONS_VERSION_1        char (8) static options (constant) init ("CPOPT001");
  3    29 
  3    30 /* END INCLUDE FILE: copy_options.incl.pl1 */
      650 
  4     1 /* BEGIN INCLUDE FILE:  copy_flags.incl.pl1 */
  4     2 
  4     3 /* Flags for attributes that should/may be copied by the copy_ subroutine. This include file is
  4     4*   required by suffix_info.incl.pl1 and copy_options.incl.pl1
  4     5*
  4     6*   Jay Pattin 6/23/83 */
  4     7 
  4     8 declare   1 copy_flags                  aligned based,      /* ON means that this attribute may be copied by copy_ */
  4     9           2 names                       bit (1) unaligned,
  4    10           2 acl                         bit (1) unaligned,
  4    11           2 ring_brackets               bit (1) unaligned,
  4    12           2 max_length                  bit (1) unaligned,
  4    13           2 copy_switch                 bit (1) unaligned,
  4    14           2 safety_switch               bit (1) unaligned,
  4    15           2 dumper_switches             bit (1) unaligned,
  4    16           2 entry_bound                 bit (1) unaligned,  /* only for vanilla object segments */
  4    17           2 extend                      bit (1) unaligned,  /* copy_ may append to end of existing object */
  4    18           2 update                      bit (1) unaligned,  /* copy_ may replace contents of existing object */
  4    19           2 mbz                         bit (26) unaligned;
  4    20 
  4    21 /* END INCLUDE FILE:  copy_flags.incl.pl1 */
      651 
  5     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  5     2*
  5     3*   Values for the "access mode" argument so often used in hardcore
  5     4*   James R. Davis 26 Jan 81  MCR 4844
  5     5*   Added constants for SM access 4/28/82 Jay Pattin
  5     6*   Added text strings 03/19/85 Chris Jones
  5     7**/
  5     8 
  5     9 
  5    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  5    11 dcl	(
  5    12 	N_ACCESS		   init ("000"b),
  5    13 	R_ACCESS		   init ("100"b),
  5    14 	E_ACCESS		   init ("010"b),
  5    15 	W_ACCESS		   init ("001"b),
  5    16 	RE_ACCESS		   init ("110"b),
  5    17 	REW_ACCESS	   init ("111"b),
  5    18 	RW_ACCESS		   init ("101"b),
  5    19 	S_ACCESS		   init ("100"b),
  5    20 	M_ACCESS		   init ("010"b),
  5    21 	A_ACCESS		   init ("001"b),
  5    22 	SA_ACCESS		   init ("101"b),
  5    23 	SM_ACCESS		   init ("110"b),
  5    24 	SMA_ACCESS	   init ("111"b)
  5    25 	)		   bit (3) internal static options (constant);
  5    26 
  5    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  5    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  5    29 
  5    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  5    31 			   static options (constant);
  5    32 
  5    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  5    34 			   static options (constant);
  5    35 
  5    36 dcl	(
  5    37 	N_ACCESS_BIN	   init (00000b),
  5    38 	R_ACCESS_BIN	   init (01000b),
  5    39 	E_ACCESS_BIN	   init (00100b),
  5    40 	W_ACCESS_BIN	   init (00010b),
  5    41 	RW_ACCESS_BIN	   init (01010b),
  5    42 	RE_ACCESS_BIN	   init (01100b),
  5    43 	REW_ACCESS_BIN	   init (01110b),
  5    44 	S_ACCESS_BIN	   init (01000b),
  5    45 	M_ACCESS_BIN	   init (00010b),
  5    46 	A_ACCESS_BIN	   init (00001b),
  5    47 	SA_ACCESS_BIN	   init (01001b),
  5    48 	SM_ACCESS_BIN	   init (01010b),
  5    49 	SMA_ACCESS_BIN	   init (01011b)
  5    50 	)		   fixed bin (5) internal static options (constant);
  5    51 
  5    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      652 
  6     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  6     2 /* format: style2,^inddcls,idind32 */
  6     3 
  6     4 declare 1 terminate_file_switches	based,
  6     5 	2 truncate		bit (1) unaligned,
  6     6 	2 set_bc			bit (1) unaligned,
  6     7 	2 terminate		bit (1) unaligned,
  6     8 	2 force_write		bit (1) unaligned,
  6     9 	2 delete			bit (1) unaligned;
  6    10 
  6    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  6    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  6    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  6    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  6    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  6    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  6    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  6    18 
  6    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      653 
  7     1 /* Begin include file ..... iox_modes.incl.pl1 */
  7     2 
  7     3 /* Written by C. D. Tavares, 03/17/75 */
  7     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  7     5 
  7     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  7     7     ("stream_input", "stream_output", "stream_input_output",
  7     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  7     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  7    10      "direct_input", "direct_output", "direct_update");
  7    11 
  7    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  7    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  7    14 
  7    15 dcl (Stream_input initial (1),
  7    16      Stream_output initial (2),
  7    17      Stream_input_output initial (3),
  7    18      Sequential_input initial (4),
  7    19      Sequential_output initial (5),
  7    20      Sequential_input_output initial (6),
  7    21      Sequential_update initial (7),
  7    22      Keyed_sequential_input initial (8),
  7    23      Keyed_sequential_output initial (9),
  7    24      Keyed_sequential_update initial (10),
  7    25      Direct_input initial (11),
  7    26      Direct_output initial (12),
  7    27      Direct_update initial (13)) fixed bin int static options (constant);
  7    28 
  7    29 /* End include file ..... iox_modes.incl.pl1 */
      654 
      655 
      656      end trim_wordlist;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/16/88  1406.4  trim_wordlist.pl1                 >spec>install>MR12.2-1023>trim_wordlist.pl1
648          1    07/19/79  1547.0  ak_info.incl.pl1                  >ldd>include>ak_info.incl.pl1
649          2    02/16/88  1407.4  sl_info.incl.pl1                  >spec>install>MR12.2-1023>sl_info.incl.pl1
650          3    10/14/83  1606.7  copy_options.incl.pl1             >ldd>include>copy_options.incl.pl1
651          4    10/14/83  1606.7  copy_flags.incl.pl1               >ldd>include>copy_flags.incl.pl1
652          5    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
653          6    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
654          7    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
COPY_OPTIONS_VERSION_1          000004 constant        char(8)                  initial unaligned dcl 3-28 ref 545
Keyed_sequential_input          000000 constant        fixed bin(17,0)          initial dcl 7-15 set ref 329*
NL                              000006 constant        char(1)                  initial unaligned dcl 103 set ref 441 478 527 527
                                                                                  527 527
RW_ACCESS                       000003 constant        bit(3)                   initial unaligned dcl 5-11 set ref 287*
Stream_input                    000075 constant        fixed bin(17,0)          initial dcl 7-15 set ref 264*
Stream_output                   000076 constant        fixed bin(17,0)          initial dcl 7-15 set ref 280*
TERM_FILE_TERM                  000002 constant        bit(3)                   initial unaligned dcl 6-14 set ref 395*
TERM_FILE_TRUNC_BC_TERM         000001 constant        bit(3)                   initial unaligned dcl 6-15 set ref 369*
absolute_pathname_              000046 constant        entry                    external dcl 125 ref 201
absolute_pathname_$add_suffix   000050 constant        entry                    external dcl 126 ref 186
addr                                                   builtin function         dcl 114 ref 446 504 527 527 558 558 623 623
ak_header                              based           structure                level 1 unaligned dcl 1-10
al                              000106 automatic       fixed bin(17,0)          dcl 38 set ref 172* 173 176 176 179 179 186 186 189
                                                                                  189 194 194 196* 201 201 203 203 209 209 212 212
                                                                                  216 216
ap                              000104 automatic       pointer                  dcl 37 set ref 172* 173 176 179 186 189 194 194 196*
                                                                                  201 203 209 209 212 212 216
arg                                    based           char                     unaligned dcl 75 set ref 173 176* 179* 186* 189* 194
                                                                                  194 201* 203* 209 209 212 212 216*
argno                           000102 automatic       fixed bin(17,0)          dcl 36 set ref 171* 172* 196 206* 206*
atd                             000304 automatic       varying char(256)        dcl 52 set ref 257* 258* 258 259* 259 261 270* 271*
                                                                                  271 272* 272 274 322* 323* 323 324
bc                              000267 automatic       fixed bin(24,0)          dcl 48 set ref 241* 244 287* 294
brief                           000114 automatic       bit(1)                   dcl 43 set ref 168* 209* 361
buffer                          000564 automatic       char(256)                unaligned dcl 500 set ref 504 505
caller_name               2     000665 automatic       char(32)                 level 2 packed unaligned dcl 502 set ref 546*
capital_letters                 000016 constant        char(26)                 initial unaligned dcl 101 ref 590 594 598 603
cleanup                         000530 stack reference condition                dcl 109 ref 157
co                              000665 automatic       structure                level 1 packed unaligned dcl 502 set ref 558 558
code                            000107 automatic       fixed bin(35,0)          dcl 39 set ref 172* 176* 177 179* 186* 187 189* 196*
                                                                                  197 198* 201* 202 203* 231* 232 234* 241* 242 247*
                                                                                  261* 262 264* 265 274* 275 276* 280* 281 282* 287*
                                                                                  290* 297* 306* 307 309* 324* 325 325* 329* 330
                                                                                  332* 333* 369* 370 370* 509* 510 511 511 525* 526
                                                                                  527* 530 530* 532* 537* 623* 624 624 624 628*
com_err_                        000036 constant        entry                    external dcl 121 ref 153 179 189 198 203 216 234 276
                                                                                  282 290 309 325 332 340 370 530 628
copy_                           000116 constant        entry                    external dcl 144 ref 558
copy_flags                             based           structure                level 1 dcl 4-8
copy_items              157     000665 automatic       structure                level 2 packed unaligned dcl 502 set ref 555*
copy_options                           based           structure                level 1 dcl 3-12
cu_$arg_count                   000032 constant        entry                    external dcl 119 ref 150
cu_$arg_ptr                     000034 constant        entry                    external dcl 120 ref 172 196
delete                  156(03) 000665 automatic       bit(1)                   level 3 packed unaligned dcl 502 set ref 552*
delete_$path                    000106 constant        entry                    external dcl 140 ref 389
desc_code                 0(02) 000424 automatic       fixed bin(2,0)           level 3 packed unaligned dcl 63 set ref 347*
descriptor                1     000424 automatic       structure                level 2 packed unaligned dcl 63
dict_iocbps                            based           pointer                  array dcl 77 set ref 316 317* 324* 329* 333* 381
                                                                                  381* 399 623*
dictx                           000405 automatic       fixed bin(17,0)          dcl 53 set ref 320* 322 332* 379* 381 381* 433* 439
                                                                                  469 485* 520* 623 628
dip                             000422 automatic       pointer                  dcl 61 set ref 146* 316* 317 324 329 333 379 381 381
                                                                                  399 399 623
divide                                                 builtin function         dcl 114 ref 294
dname                           000171 automatic       char(168)                unaligned dcl 44 set ref 176* 241* 257 287* 290*
                                                                                  290* 370* 370* 549
ename                           000253 automatic       char(32)                 unaligned dcl 45 set ref 176* 241* 259 287* 290*
                                                                                  290* 370* 370* 550
eof                             000411 automatic       bit(1)                   dcl 55 set ref 434* 437 451*
error_table_$badopt             000024 external static fixed bin(35,0)          dcl 96 set ref 216*
error_table_$dirseg             000010 external static fixed bin(35,0)          dcl 90 ref 247
error_table_$end_of_info        000014 external static fixed bin(35,0)          dcl 92 ref 510
error_table_$fatal_error        000016 external static fixed bin(35,0)          dcl 93 set ref 340*
error_table_$no_key             000030 external static fixed bin(35,0)          dcl 98 ref 624
error_table_$no_record          000026 external static fixed bin(35,0)          dcl 97 ref 624
error_table_$noarg              000020 external static fixed bin(35,0)          dcl 94 set ref 153*
error_table_$short_record       000012 external static fixed bin(35,0)          dcl 91 ref 511
error_table_$zero_length_seg    000022 external static fixed bin(35,0)          dcl 95 ref 297 537
exact_match                     000115 automatic       bit(1)                   dcl 43 set ref 168* 212* 587
expand_pathname_$add_suffix     000044 constant        entry                    external dcl 124 ref 176
flags                   156     000665 automatic       structure                level 2 in structure "co" packed unaligned dcl 502
                                                                                  in procedure "process_msf" set ref 551*
flags                           000424 automatic       structure                level 2 in structure "get_key_info" packed unaligned
                                                                                  dcl 63 in procedure "twl"
flags                                  based           structure                level 2 in structure "gk_header" dcl 1-46
                                                                                  in procedure "twl"
flags                                  based           structure                level 3 in structure "gk_info" dcl 1-41 in procedure
                                                                                  "twl"
force                   156(02) 000665 automatic       bit(1)                   level 3 packed unaligned dcl 502 set ref 553*
get_key_info                    000424 automatic       structure                level 1 unaligned dcl 63 set ref 623 623
get_pdir_                       000042 constant        entry                    external dcl 123 ref 169
get_system_free_area_           000040 constant        entry                    external dcl 122 ref 162
get_temp_segment_               000054 constant        entry                    external dcl 128 ref 306
gk_header                              based           structure                level 1 unaligned dcl 1-46
gk_info_version_0                      constant        fixed bin(17,0)          initial dcl 1-66 ref 352
have_wl_path                    000116 automatic       bit(1)                   dcl 43 set ref 168* 173 182* 221
hcs_$status_minf                000060 constant        entry                    external dcl 129 ref 241
head_size                 0(09) 000424 automatic       fixed bin(9,0)           level 4 packed unsigned unaligned dcl 63 set ref
                                                                                  349*
index                                                  builtin function         dcl 114 ref 173 441 607
initiate_file_                  000052 constant        entry                    external dcl 127 ref 287
input_desc                0(01) 000424 automatic       bit(1)                   level 3 packed unaligned dcl 63 set ref 346*
input_key                       000424 automatic       bit(1)                   level 3 packed unaligned dcl 63 set ref 345*
ioa_                            000110 constant        entry                    external dcl 141 ref 361
iocbp                                  parameter       pointer                  dcl 410 set ref 407 412* 413* 414* 415*
iox_$attach_name                000066 constant        entry                    external dcl 132 ref 261 274 324
iox_$close                      000074 constant        entry                    external dcl 135 ref 412
iox_$control                    000072 constant        entry                    external dcl 134 ref 623
iox_$destroy_iocb               000100 constant        entry                    external dcl 137 ref 414
iox_$detach_iocb                000076 constant        entry                    external dcl 136 ref 333 413
iox_$get_line                   000104 constant        entry                    external dcl 139 ref 509 532
iox_$open                       000070 constant        entry                    external dcl 133 ref 264 280 329
iox_$put_chars                  000102 constant        entry                    external dcl 138 ref 525 527
key                       3     000424 automatic       char(256)                level 2 packed unaligned dcl 63 set ref 583* 594*
                                                                                  598*
key_len                   2     000424 automatic       fixed bin(17,0)          level 2 dcl 63 set ref 622*
length                                                 builtin function         dcl 114 ref 505 527 527
mod                                                    builtin function         dcl 114 ref 367
msf                             000100 automatic       bit(1)                   dcl 35 set ref 250* 251* 253 304 356 366 385
nargs                           000101 automatic       fixed bin(17,0)          dcl 36 set ref 150* 151 161 171
ndict                           000112 automatic       fixed bin(17,0)          dcl 41 set ref 167* 185* 185 186 226 238* 304 316
                                                                                  317 320 343* 379 399 433 469 520
new_wl_len                      000420 automatic       fixed bin(21,0)          dcl 60 set ref 367 367 367 369 430* 476 477* 477 478
                                                                                  479* 479
notrim                          000417 automatic       bit(1)                   dcl 59 in procedure "twl" set ref 447* 449* 463* 473
                                                                                  506* 580 635*
notrim                    1(32) 000424 automatic       bit(1)                   level 3 in structure "get_key_info" packed unaligned
                                                                                  dcl 63 in procedure "twl" set ref 633
notrim                    1            based           bit(1)                   array level 2 in structure "trim_data" packed
                                                                                  unaligned dcl 82 in procedure "twl" set ref 463
                                                                                  473*
null                                                   builtin function         dcl 114 ref 146 229 231 231 261 261 274 274 288 317
                                                                                  324 324 379 381 387 388 390 393 395 399 402 415
num_paths                 1            based           fixed bin(17,0)          level 2 dcl 2-15 set ref 163* 228 238 402
nwords                          000406 automatic       fixed bin(21,0)          dcl 54 set ref 361 361* 435* 468* 468 471 472 473
                                                                                  487 507* 528* 528 544
original_nwords                 000410 automatic       fixed bin(21,0)          dcl 54 set ref 361 485* 507* 518* 518 536 544
pad                       0(19) 000424 automatic       bit(8)                   level 3 packed unaligned dcl 63 set ref 351*
pathname                 17            based           char(168)                array level 3 packed unaligned dcl 2-15 set ref 186*
                                                                                  322 332* 628*
pathname_                       000064 constant        entry                    external dcl 131 ref 290 290 370 370
paths                    14            based           structure                array level 2 dcl 2-15
position_specification
                          0(05) 000424 automatic       structure                level 3 packed unaligned dcl 63
rel_type                  0(06) 000424 automatic       fixed bin(2,0)           level 4 packed unaligned dcl 63 set ref 348*
release_temp_segment_           000056 constant        entry                    external dcl 128 ref 393
reset_pos                 0(18) 000424 automatic       bit(1)                   level 3 packed unaligned dcl 63 set ref 350*
rk_header                              based           structure                level 1 unaligned dcl 1-26
rtrim                                                  builtin function         dcl 114 ref 257 270 322
saved_nwords                    000407 automatic       fixed bin(21,0)          dcl 54 set ref 431* 437 487*
search                                                 builtin function         dcl 114 ref 603
search_paths_$get               000114 constant        entry                    external dcl 143 ref 231
sl_info                                based           structure                level 1 dcl 2-15 set ref 163 228 402
sl_info_num_paths               000536 automatic       fixed bin(17,0)          dcl 2-27 set ref 161* 163 163
sl_info_p                       000540 automatic       pointer                  dcl 2-28 set ref 146* 163* 186 228 229* 231* 238 322
                                                                                  332 402 402 628
sl_info_version_1               000075 constant        fixed bin(17,0)          initial dcl 2-29 set ref 231*
small_letters                   000007 constant        char(26)                 initial unaligned dcl 102 ref 594 598 603
source_dir               12     000665 automatic       char(168)                level 2 packed unaligned dcl 502 set ref 547*
source_name              64     000665 automatic       char(32)                 level 2 packed unaligned dcl 502 set ref 548*
substr                                                 builtin function         dcl 114 set ref 367* 441 476* 478* 594* 594 603 603
switch                          000274 automatic       char(32)                 unaligned dcl 51 set ref 256* 261* 269* 274* 321*
                                                                                  324* 325*
system_area                            based           area(1024)               dcl 76 ref 163 228 316 399 402
system_area_ptr                 000110 automatic       pointer                  dcl 40 set ref 162* 163 228 231* 316 399 402
target_dir               74     000665 automatic       char(168)                level 2 packed unaligned dcl 502 set ref 549*
target_err_switch       156(04) 000665 automatic       bit(1)                   level 3 packed unaligned dcl 502 set ref 559
target_name             146     000665 automatic       char(32)                 level 2 packed unaligned dcl 502 set ref 550*
temp_dir                        000117 automatic       char(168)                unaligned dcl 44 set ref 169* 201* 270 389* 547
temp_name                       000243 automatic       char(32)                 unaligned dcl 45 set ref 269* 272 389* 548
temp_ndict                      000113 automatic       fixed bin(17,0)          dcl 42 set ref 319* 324 329 333 335* 335 338 343
temp_ptr                        000264 automatic       pointer                  dcl 46 set ref 146* 274* 280* 306* 388 388* 390* 393
                                                                                  393* 461 462 463 471 472 473 525* 527* 541*
terminate_file_                 000112 constant        entry                    external dcl 142 ref 369 395
translate                                              builtin function         dcl 114 ref 594 598
trim_data                              based           structure                array level 1 dcl 82
type                            000266 automatic       fixed bin(2,0)           dcl 47 set ref 241* 244
unique_chars_                   000062 constant        entry                    external dcl 130 ref 256 269 321
unspec                                                 builtin function         dcl 114 set ref 551* 555*
update                  157(09) 000665 automatic       bit(1)                   level 3 packed unaligned dcl 502 set ref 556*
verify                                                 builtin function         dcl 114 ref 590 603
version                   0(27) 000424 automatic       fixed bin(8,0)           level 3 in structure "get_key_info" packed unaligned
                                                                                  dcl 63 in procedure "twl" set ref 352*
version                         000665 automatic       char(8)                  level 2 in structure "co" packed unaligned dcl 502
                                                                                  in procedure "process_msf" set ref 545*
whoami                          000025 constant        char(13)                 initial unaligned dcl 100 set ref 153* 179* 189*
                                                                                  198* 203* 216* 234* 256 269 276* 282* 290* 306*
                                                                                  309* 321 325* 332* 340* 370* 389* 393* 530* 546
                                                                                  628*
wl_cs                                  based           char                     unaligned dcl 78 set ref 367* 441 476* 478*
wl_ix                           000273 automatic       fixed bin(21,0)          dcl 50 set ref 429* 441 444 446 450* 450 451
wl_len                          000272 automatic       fixed bin(21,0)          dcl 50 set ref 294* 295 367 367 431 441 444 451 476
                                                                                  478
wl_ptr                          000270 automatic       pointer                  dcl 49 set ref 146* 261* 264* 287* 288 367 369* 387
                                                                                  387* 390* 395 395* 441 446 476 478 509* 532* 542*
wl_vec                                 based           char(1)                  array unaligned dcl 79 set ref 446
word                                   based           char                     unaligned dcl 80 set ref 476 530* 583 590 594 598
                                                                                  603 603 607 628*
word_len                        000416 automatic       fixed bin(21,0)          dcl 58 set ref 441* 442 444 444* 447 450 453 462*
                                                                                  472 476 476 477 509* 515* 515 517 525* 530 530
                                                                                  532* 583 590 592 594 598 603 603 603 607 628 628
word_max_len                    000664 automatic       fixed bin(21,0)          dcl 501 set ref 505* 509* 532*
word_ptr                        000414 automatic       pointer                  dcl 57 set ref 446* 461* 471 476 504* 509* 525* 530
                                                                                  532* 583 590 594 598 603 603 607 628
wordl                     1(11)        based           fixed bin(24,0)          array level 2 packed unaligned dcl 82 set ref 462
                                                                                  472*
wordp                                  based           pointer                  array level 2 packed unaligned dcl 82 set ref 461
                                                                                  471*
wordx                           000412 automatic       fixed bin(21,0)          dcl 56 set ref 437* 455* 455 461 462 463* 485

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_PATH                          internal static fixed bin(17,0)          initial dcl 2-33
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-33
Direct_input                           internal static fixed bin(17,0)          initial dcl 7-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 7-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 7-15
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
HOME_DIR                               internal static fixed bin(17,0)          initial dcl 2-38
INITIATED_SEGS                         internal static fixed bin(17,0)          initial dcl 2-39
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 7-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 7-15
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
PROCESS_DIR                            internal static fixed bin(17,0)          initial dcl 2-37
REFERENCING_DIR                        internal static fixed bin(17,0)          initial dcl 2-35
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
R_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
Sequential_input                       internal static fixed bin(17,0)          initial dcl 7-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 7-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 7-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 7-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 7-15
TERM_FILE_BC                           internal static bit(2)                   initial unaligned dcl 6-12
TERM_FILE_DELETE                       internal static bit(5)                   initial unaligned dcl 6-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 6-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial unaligned dcl 6-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial unaligned dcl 6-13
UNEXPANDED_PATH                        internal static fixed bin(17,0)          initial dcl 2-34
WORKING_DIR                            internal static fixed bin(17,0)          initial dcl 2-36
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
ak_info                                based           structure                level 1 unaligned dcl 1-6
ak_info_ptr                            automatic       pointer                  dcl 1-18
ak_key_len                             automatic       fixed bin(17,0)          dcl 1-19
copy_options_ptr                       automatic       pointer                  dcl 3-10
gk_info                                based           structure                level 1 unaligned dcl 1-41
gk_info_ptr                            automatic       pointer                  dcl 1-63
gk_key_len                             automatic       fixed bin(17,0)          dcl 1-64
iox_modes                              internal static char(24)                 initial array dcl 7-6
rk_info                                based           structure                level 1 unaligned dcl 1-22
rk_info_ptr                            automatic       pointer                  dcl 1-37
rk_key_len                             automatic       fixed bin(17,0)          dcl 1-38
short_iox_modes                        internal static char(4)                  initial array dcl 7-12
terminate_file_switches                based           structure                level 1 packed unaligned dcl 6-4

NAMES DECLARED BY EXPLICIT CONTEXT.
advance_index                   003416 constant        label                    dcl 450 ref 442
bad_seg                         002017 constant        label                    dcl 290 ref 242 248 262 265 298 511 538
check_no_cap                    004122 constant        label                    dcl 598 ref 603 607
cleaner                         003002 constant        entry                    internal dcl 377 ref 157 374
close_file                      003251 constant        entry                    internal dcl 407 ref 381 387 388 541 542
dont_trim                       004340 constant        label                    dcl 635 ref 630
finish                          002774 constant        label                    dcl 374 ref 154 180 190 217 235 277 283 291 310 341
                                                                                  559
known_word                      004214 constant        entry                    internal dcl 619 ref 584 595 600
next_word                       003516 constant        label                    dcl 482 ref 456
noarg                           000325 constant        label                    dcl 153 set ref 221
process_msf                     003533 constant        entry                    internal dcl 493 ref 356
process_non_msf                 003322 constant        entry                    internal dcl 420 ref 357
skip_word                       004211 constant        label                    dcl 609 in procedure "trim_word" ref 636
skip_word                       003714 constant        label                    dcl 532 in procedure "process_msf" ref 517 521
trim_word                       004027 constant        entry                    internal dcl 577 ref 466 521
trim_wordlist                   000302 constant        entry                    external dcl 20
twl                             000273 constant        entry                    external dcl 20

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5624        5744    5176        5634
Length      6360    5176       120         377     426           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
twl                                 784 external procedure  is an external procedure.  
on unit on line 157                  64 on unit               
cleaner                              98 internal procedure  is called by several nonquick procedures.  
close_file                           72 internal procedure  is called by several nonquick procedures.  
process_non_msf                         internal procedure  shares stack frame of external procedure twl.  
process_msf                             internal procedure  shares stack frame of external procedure twl.  
trim_word                               internal procedure  shares stack frame of external procedure twl.  
known_word                              internal procedure  shares stack frame of external procedure twl.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
twl                      000100 msf                         twl
                         000101 nargs                       twl
                         000102 argno                       twl
                         000104 ap                          twl
                         000106 al                          twl
                         000107 code                        twl
                         000110 system_area_ptr             twl
                         000112 ndict                       twl
                         000113 temp_ndict                  twl
                         000114 brief                       twl
                         000115 exact_match                 twl
                         000116 have_wl_path                twl
                         000117 temp_dir                    twl
                         000171 dname                       twl
                         000243 temp_name                   twl
                         000253 ename                       twl
                         000264 temp_ptr                    twl
                         000266 type                        twl
                         000267 bc                          twl
                         000270 wl_ptr                      twl
                         000272 wl_len                      twl
                         000273 wl_ix                       twl
                         000274 switch                      twl
                         000304 atd                         twl
                         000405 dictx                       twl
                         000406 nwords                      twl
                         000407 saved_nwords                twl
                         000410 original_nwords             twl
                         000411 eof                         twl
                         000412 wordx                       twl
                         000414 word_ptr                    twl
                         000416 word_len                    twl
                         000417 notrim                      twl
                         000420 new_wl_len                  twl
                         000422 dip                         twl
                         000424 get_key_info                twl
                         000536 sl_info_num_paths           twl
                         000540 sl_info_p                   twl
                         000564 buffer                      process_msf
                         000664 word_max_len                process_msf
                         000665 co                          process_msf

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          mdfx1               enable_op           shorten_stack       ext_entry           int_entry
op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            absolute_pathname_$add_suffix com_err_                      copy_
cu_$arg_count                 cu_$arg_ptr                   delete_$path                  expand_pathname_$add_suffix
get_pdir_                     get_system_free_area_         get_temp_segment_             hcs_$status_minf
initiate_file_                ioa_                          iox_$attach_name              iox_$close
iox_$control                  iox_$destroy_iocb             iox_$detach_iocb              iox_$get_line
iox_$open                     iox_$put_chars                pathname_                     release_temp_segment_
search_paths_$get             terminate_file_               unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$dirseg           error_table_$end_of_info      error_table_$fatal_error
error_table_$no_key           error_table_$no_record        error_table_$noarg            error_table_$short_record
error_table_$zero_length_seg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     20 000272       146 000307       150 000314       151 000322       153 000325       154 000351       157 000352
    161 000374       162 000377       163 000406       167 000417       168 000420       169 000423       171 000432
    172 000441       173 000456       176 000474       177 000532       179 000534       180 000560       182 000561
    183 000563       185 000564       186 000565       187 000624       189 000626       190 000652       192 000653
    194 000654       196 000664       197 000704       198 000706       199 000733       201 000734       202 000760
    203 000762       204 001014       206 001015       207 001016       209 001017       212 001032       216 001045
    217 001071       219 001072       221 001074       226 001076       228 001100       229 001106       231 001110
    232 001161       234 001163       235 001207       238 001210       241 001213       242 001252       244 001254
    247 001261       248 001264       250 001265       251 001270       253 001271       256 001273       257 001332
    258 001365       259 001375       261 001407       262 001451       264 001454       265 001473       269 001475
    270 001540       271 001573       272 001603       274 001615       275 001657       276 001662       277 001706
    280 001707       281 001726       282 001730       283 001754       285 001755       287 001756       288 002013
    290 002017       291 002066       294 002067       295 002072       297 002073       298 002076       304 002077
    306 002104       307 002125       309 002127       310 002156       316 002157       317 002165       319 002202
    320 002204       321 002213       322 002250       323 002320       324 002333       325 002405       329 002441
    330 002463       332 002465       333 002525       334 002541       335 002542       337 002543       338 002545
    340 002550       341 002565       343 002566       345 002570       346 002572       347 002574       348 002600
    349 002604       350 002606       351 002610       352 002612       356 002614       357 002620       361 002621
    366 002652       367 002654       369 002673       370 002723       374 002774       375 003000       377 003001
    379 003007       381 003024       383 003043       385 003046       387 003050       388 003063       389 003077
    390 003134       391 003140       393 003141       395 003167       399 003223       402 003234       405 003247
    407 003250       412 003256       413 003270       414 003303       415 003316       417 003321       420 003322
    429 003323       430 003325       431 003326       433 003330       434 003337       435 003340       437 003341
    439 003353       441 003356       442 003375       444 003376       446 003404       447 003410       449 003415
    450 003416       451 003421       453 003425       455 003427       456 003431       458 003432       461 003433
    462 003440       463 003446       466 003451       468 003456       469 003457       471 003462       472 003467
    473 003474       474 003500       476 003501       477 003510       478 003511       479 003515       482 003516
    485 003520       487 003526       488 003530       490 003532       493 003533       504 003534       505 003536
    506 003540       507 003541       509 003543       510 003562       511 003566       514 003572       515 003573
    517 003575       518 003577       520 003600       521 003607       523 003614       525 003616       526 003633
    527 003635       528 003656       530 003657       532 003714       534 003733       536 003734       537 003736
    538 003740       541 003741       542 003747       544 003755       545 003760       546 003763       547 003766
    548 003771       549 003774       550 003777       551 004002       552 004003       553 004005       555 004007
    556 004010       558 004012       559 004023       563 004026       577 004027       580 004031       583 004035
    584 004042       587 004053       590 004060       592 004074       594 004077       595 004110       598 004122
    600 004134       602 004146       603 004147       607 004177       609 004211       619 004214       622 004216
    623 004220       624 004257       628 004271       630 004334       633 004335       635 004340       636 004342
    639 004343


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
