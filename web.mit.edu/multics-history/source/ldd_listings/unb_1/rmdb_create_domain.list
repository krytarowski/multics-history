	COMPILATION LISTING OF SEGMENT rmdb_create_domain
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1336.6 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /* format: ^inddcls,^indattr,indnoniterend,^indnoniterdo,indend,tree,^case,insnl,comcol61,dclind5,declareind5,delnl */
        8 
        9 /*DESCRIPTION
       10*  This routine creates unreferenced domains in the db_model segment. The
       11*  specified domains must not already exist. The crossreference is updated with
       12*  the created domains.
       13*/*
       14*
       15*/****^  HISTORY COMMENTS:
       16*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
       17*     audit(86-09-24,Blair), install(86-10-16,MR12.0-1187):
       18*     written
       19*                                                   END HISTORY COMMENTS */
       20 
       21 rmdb_create_domain:
       22      proc (Irmdb_ctl_ptr, Icreate_domain_info_ptr, Oerror_message, Ocode);
       23 
       24 	rmdb_ctl_ptr = Irmdb_ctl_ptr;
       25 	if rmdb_ctl.version ^= RMDB_CTL_VERSION_1
       26 	then call error (error_table_$unimplemented_version,
       27 		"Version " || ltrim (char (rmdb_ctl.version)) || " of rmdb_ctl structure.");
       28 
       29 	create_domain_info_ptr = Icreate_domain_info_ptr;
       30 
       31 	if create_domain_info.version ^= create_domain_info_version_1
       32 	then call error (error_table_$unimplemented_version,
       33 		"Version " || create_domain_info.version || " of create_domain_info structure.");
       34 
       35 	if create_domain_info.count < 1
       36 	then call error (error_table_$action_not_performed, "No domains to create.");
       37 
       38 	dbm_ptr = rmdb_ctl.db_model_ptr;
       39 	if rmdb_ctl.crossref_file_info.iocb_ptr = null
       40 	then do;
       41 	     call mdbm_util_$xref_build (rmdb_ctl.temp_dir_path, rmdb_ctl.absolute_db_path, dbm_ptr,
       42 		rmdb_ctl.crossref_file_info.name, rmdb_ctl.crossref_file_info.iocb_ptr, error_message, code);
       43 	     if code ^= 0
       44 	     then call error (code, error_message);
       45 	     end;
       46 	local_iocb = rmdb_ctl.crossref_file_info.iocb_ptr;
       47 
       48 /* Loop through all domains to be created to see if they already exist. */
       49 	do loop = 1 to create_domain_info.count;
       50 	     call mdbm_util_$xref_find_record (local_iocb, DOMAIN_KEY_HEAD, create_domain_info.name (loop), null, 0,
       51 		error_message, code);
       52 	     if code = 0
       53 	     then call error (mrds_error_$domain_already_defined, create_domain_info.name (loop));
       54 	     else if code ^= error_table_$no_record
       55 		then call error (code, error_message);
       56 	     end;					/* do loop */
       57 
       58 /* Find the pointer to the last domain_info structure so we can add on the end
       59*   of the linked list. */
       60 	last_di_ptr = null;
       61 	do di_ptr = ptr (dbm_ptr, db_model.domain_ptr) repeat ptr (dbm_ptr, domain_info.fwd_thread)
       62 	     while (rel (di_ptr) ^= NULL_OFFSET);
       63 	     last_di_ptr = di_ptr;
       64 	     end;					/* do di_ptr */
       65 
       66 /* Trap areas so we can return a intelligable error message. */
       67 	on area call error (error_table_$area_too_small, "Creating domain_info in the db_model segment.");
       68 
       69 /* Now go through and create each domain. */
       70 	do loop = 1 to create_domain_info.count;
       71 	     call create_a_domain (loop);
       72 	     end;					/* do loop */
       73 
       74 	call error (0, "");
       75 
       76 RETURN_TO_CALLER:
       77 	return;
       78 
       79 error:
       80      proc (cd, msg);
       81 
       82 dcl  cd fixed bin (35) parameter;
       83 dcl  msg char (*) parameter;
       84 
       85 	Ocode = cd;
       86 	if cd = 0
       87 	then Oerror_message = "";
       88 	else Oerror_message = error_message;
       89 	goto RETURN_TO_CALLER;
       90      end error;
       91 
       92 create_a_domain:
       93      proc (idx);
       94 
       95 dcl  idx fixed bin parameter;
       96 dcl  new_changer_ptr ptr;
       97 dcl  new_di_ptr ptr;
       98 dcl  new_path_ptr (3) ptr;
       99 dcl  quit_occured bit (1) aligned;
      100 
      101 	quit_occured = "0"b;
      102 
      103 	new_di_ptr, new_path_ptr (*), new_changer_ptr = null;
      104 	on cleanup call cleaner;
      105 
      106 	on quit quit_occured = "1"b;			/* BEGIN CRITICAL CODE */
      107 
      108 	call mdbm_util_$inconsistent_set (dbm_ptr, "create_attribute",
      109 	     "Creating attribute " || create_domain_info.name (idx),
      110 	     "delete_domain -force -inhibit_error " || create_domain_info.name (idx));
      111 
      112 /* Create the new domain_info structure and populate it */
      113 	allocate domain_info in (db_model.dbm_area) set (new_di_ptr);
      114 	unspec (new_di_ptr -> domain_info) = "0"b;
      115 	new_di_ptr -> domain_info.name = create_domain_info.name (idx);
      116 	new_di_ptr -> domain_info.unreferenced = "1"b;
      117 
      118 	new_di_ptr -> domain_info.db_desc = create_domain_info.descriptor (idx);
      119 	new_di_ptr -> domain_info.user_desc = create_domain_info.decode_declare_data_descriptor (idx);
      120 	if new_di_ptr -> domain_info.user_desc = "0"b
      121 	then new_di_ptr -> domain_info.user_desc = new_di_ptr -> domain_info.db_desc;
      122 
      123 	new_di_ptr -> domain_info.fwd_thread = NULL_OFFSET;
      124 
      125 	call set_path (new_di_ptr -> domain_info.check_path_ptr, create_domain_info.check_proc_path (idx), 1);
      126 	call set_path (new_di_ptr -> domain_info.encd_path_ptr, create_domain_info.encode_proc_path (idx), 2);
      127 	call set_path (new_di_ptr -> domain_info.decd_path_ptr, create_domain_info.decode_proc_path (idx), 3);
      128 
      129 	new_di_ptr -> domain_info.ck_stack_ptr = NULL_OFFSET;
      130 	new_di_ptr -> domain_info.str_before_path_ptr = NULL_OFFSET;
      131 	new_di_ptr -> domain_info.str_err_path_ptr = NULL_OFFSET;
      132 	new_di_ptr -> domain_info.str_after_path_ptr = NULL_OFFSET;
      133 	new_di_ptr -> domain_info.get_before_path_ptr = NULL_OFFSET;
      134 	new_di_ptr -> domain_info.get_err_path_ptr = NULL_OFFSET;
      135 	new_di_ptr -> domain_info.get_after_path_ptr = NULL_OFFSET;
      136 	new_di_ptr -> domain_info.mod_before_path_ptr = NULL_OFFSET;
      137 	new_di_ptr -> domain_info.mod_err_path_ptr = NULL_OFFSET;
      138 	new_di_ptr -> domain_info.mod_after_path_ptr = NULL_OFFSET;
      139 	new_di_ptr -> domain_info.unused_1 = NULL_OFFSET;
      140 	new_di_ptr -> domain_info.unused_2 = NULL_OFFSET;
      141 
      142 /* Create the changer structure and populate it. */
      143 	allocate changer in (db_model.dbm_area) set (new_changer_ptr);
      144 	new_changer_ptr -> changer.id = get_group_id_ ();
      145 	new_changer_ptr -> changer.time = clock ();
      146 	new_changer_ptr -> changer.next = NULL_OFFSET;
      147 
      148 	new_di_ptr -> domain_info.changer_ptr = rel (new_changer_ptr);
      149 
      150 /* Add the new domain to the crossreference file */
      151 	call mdbm_util_$xref_create_record (local_iocb, DOMAIN_KEY_HEAD, create_domain_info.name (idx),
      152 	     rel (new_di_ptr), error_message, code);
      153 	if code ^= 0
      154 	then do;
      155 	     call cleaner;
      156 	     call error (code, error_message);
      157 	     end;
      158 
      159 /* Add a new attribute record to the crossreference file, as all domains have
      160*   an attribute with the same name be default. */
      161 	call mdbm_util_$xref_create_record (local_iocb, ATTRIBUTE_KEY_HEAD, create_domain_info.name (idx),
      162 	     rel (new_di_ptr), error_message, code);
      163 	if code ^= 0
      164 	then do;
      165 	     call cleaner;
      166 	     call error (code, error_message);
      167 	     end;
      168 
      169 /* Now we mark the created domain record as referenced by the attribute with
      170*   the same name */
      171 	call mdbm_util_$xref_reference (local_iocb, DOMAIN_KEY_HEAD, create_domain_info.name (idx),
      172 	     create_domain_info.name (idx), null, (0), error_message, code);
      173 	if code ^= 0
      174 	then do;
      175 	     call cleaner;
      176 	     call error (code, error_message);
      177 	     end;
      178 
      179 /* Add the new domain_info to the end of the linked list. */
      180 	if last_di_ptr = null
      181 	then db_model.domain_ptr = rel (new_di_ptr);
      182 	else last_di_ptr -> domain_info.fwd_thread = rel (new_di_ptr);
      183 	last_di_ptr = new_di_ptr;
      184 
      185 	db_model.num_domains = db_model.num_domains + 1;
      186 
      187 	call rmdb_add_rmdb_history (dbm_ptr, RMDB_DOMAIN_TYPE, create_domain_info.name (idx), RMDB_ADD_DMN_OP, "",
      188 	     error_message, code);
      189 	if code ^= 0
      190 	then call error (code, error_message);
      191 
      192 	call mdbm_util_$inconsistent_reset (dbm_ptr);
      193 
      194 	revert quit;				/* END CRITICAL CODE */
      195 	if quit_occured
      196 	then signal quit;
      197 
      198 	return;
      199 
      200 cleaner:
      201      proc;
      202 
      203 dcl  based_item fixed bin (35) based;
      204 dcl  p ptr;
      205 
      206 /* Free all the created structures in db_model segment */
      207 	do p = new_changer_ptr, new_di_ptr, new_path_ptr (1), new_path_ptr (2), new_path_ptr (3);
      208 	     if p ^= null
      209 	     then free p -> based_item;
      210 	     end;
      211 
      212 	call mdbm_util_$xref_destroy (rmdb_ctl.crossref_file_info.iocb_ptr, rmdb_ctl.temp_dir_path,
      213 	     rmdb_ctl.crossref_file_info.name, (""), (0));
      214 
      215 	call mdbm_util_$inconsistent_reset (dbm_ptr);
      216 
      217 	return;
      218      end cleaner;
      219 
      220 set_path:
      221      proc (sp_offset, sp_path, sp_idx);
      222 
      223 dcl  sp_dir char (168);
      224 dcl  sp_dollar_index fixed bin;
      225 dcl  sp_entry char (32);
      226 dcl  sp_idx fixed bin parameter;
      227 dcl  sp_name char (32);
      228 dcl  sp_offset bit (18) unaligned parameter;
      229 dcl  sp_path char (*) parameter;
      230 
      231 	if sp_path = ""
      232 	then do;
      233 	     sp_offset = NULL_OFFSET;
      234 	     new_path_ptr (idx) = null;
      235 	     end;
      236 	else do;
      237 	     sp_dollar_index = index (sp_path, "$");
      238 	     if sp_dollar_index ^= 0
      239 	     then do;
      240 		sp_entry = substr (sp_path, sp_dollar_index + 1);
      241 		substr (sp_path, sp_dollar_index) = "";
      242 		end;
      243 	     else sp_entry = "";
      244 	     call expand_pathname_ (sp_path, sp_dir, sp_name, code);
      245 	     if code ^= 0
      246 	     then call error (code, sp_path);
      247 
      248 	     allocate path_entry in (db_model.dbm_area) set (new_path_ptr (idx));
      249 	     new_path_ptr (idx) -> path_entry.path = pathname_ (sp_dir, sp_name);
      250 	     if sp_entry = ""
      251 	     then new_path_ptr (idx) -> path_entry.entry = sp_name;
      252 	     else new_path_ptr (idx) -> path_entry.entry = sp_entry;
      253 
      254 	     new_path_ptr (idx) -> path_entry.reserved = "0"b;
      255 	     sp_offset = rel (new_path_ptr (idx));
      256 	     end;
      257 
      258 	return;
      259      end set_path;
      260 
      261      end create_a_domain;
      262 
  1     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  1     6*     modified to save space occupied by model
  1     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  1     8*     to add mdbm_secured bit in db_model
  1     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  1    10*     collapsed the following into an unused_offset array:
  1    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  1    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  1    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  1    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  1    15*       unused_1
  1    16*     Also changed the name of unused_2 to restructuring_history_offset
  1    17*     and changed the comment on the changer structure to indicate
  1    18*     that it will contain on database creation information.
  1    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  1    20*     used one of the unused_offsets to point to a message which indicates
  1    21*     why the db is inconsistent. The offset will be null when the db is created
  1    22*     and set the first time the message is used. this is so it will be
  1    23*     consistent with existing data bases. Also added the message structure.
  1    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  1    25*     added the undo_request element to the message structure
  1    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  1    27*     changed unused_offset (12) to last_restructruring_history_offset and
  1    28*     changed restructuring_history_offset to first_restructuring_history_offset
  1    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  1    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  1    31*     1 => vfile database and 2 => page_file database. Up to this point all
  1    32*     database types were equal to 1.
  1    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  1    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  1    35*     flags. This will allow information about transactions and dm_file
  1    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  1    37*     change is compatable with all datamodels created by the released version
  1    38*     of mrds.
  1    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  1    40*     added the rollback_on flag to the db_type_flags since it appears that you
  1    41*     can have a dmfile database that requires transactions but does not have any
  1    42*     journalizing. Also switched the order of the transactions_needed and
  1    43*     concurrency_on flags - this makes the change compatable with existing
  1    44*     dmfile databases except when displaying the model since concurrency_on and
  1    45*     rollback_on will be off in the model even though the dmfile relations had
  1    46*     them on during creation.
  1    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  1    48*      Removed ctl_file_path_ptr.
  1    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  1    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  1    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  1    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  1    53*      in the flag word for rmdb copying.
  1    54*                                                   END HISTORY COMMENTS */
  1    55 
  1    56 
  1    57 /* this include file contains the structures that go into the make up
  1    58*   of the "db_model" segment in the model for the database.
  1    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  1    60*
  1    61*   the db_model structure goes at the base of the segment, and contains items unique to
  1    62*   the whole databse. in addition, it has an area of size to fill the
  1    63*   rest of a segment, that holds the lists of files and domains in the database.
  1    64*   these lists are singly forward linked lists. all "pointers" in the database model
  1    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  1    66*   since actual pointers are process dependent on segment number.
  1    67*   the remaining structures are first a path_entry one to save pathnames in,
  1    68*   and the stack_item and constent structures, used to save a boolean
  1    69*   expression in polish form, with the stack represented by a linked list.
  1    70*   the final structure is one for identifying the status of version information */
  1    71 
  1    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  1    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  1    74 	     2 db_type_flags      unal,
  1    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  1    76 	       3 unused	      (13) bit (1) unal,
  1    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  1    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  1    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  1    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  1    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  1    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  1    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  1    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  1    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  1    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  1    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  1    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  1    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  1    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  1    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  1    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  1    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  1    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  1    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  1    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  1    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  1    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  1    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  1   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  1   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  1   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  1   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  1   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  1   105 
  1   106      dcl	   dbm_ptr	      ptr;
  1   107 
  1   108 /* the files in the database each have a file_info containing
  1   109*   their name, the file_model for each file is found by initiating the
  1   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  1   111*   the file_info list is a singly linked list in definition order */
  1   112 
  1   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  1   114 	     2 file_name	      char (30),		/* name of file */
  1   115 	     2 file_id	      bit (36),		/* id number of file */
  1   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  1   117 	     2 unused	      unal bit (18);	/* for future expansion */
  1   118 
  1   119      dcl	   fi_ptr		      ptr;
  1   120 
  1   121 /* each domain used in the database will have a domain info saved in the db_model
  1   122*   segment. it describes the domain of the given name, and it's options.
  1   123*   the domain_info's form a singly linked list in definition order */
  1   124 
  1   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  1   126 	     2 name	      char (32),		/* name of domain */
  1   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  1   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  1   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  1   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  1   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  1   132 	     2 reserved	      bit (31) unal,
  1   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  1   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  1   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  1   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  1   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  1   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  1   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  1   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  1   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  1   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  1   143 	     2 str_err_path_ptr   unal bit (18),
  1   144 	     2 str_after_path_ptr unal bit (18),
  1   145 	     2 get_before_path_ptr unal bit (18),
  1   146 	     2 get_err_path_ptr   unal bit (18),
  1   147 	     2 get_after_path_ptr unal bit (18),
  1   148 	     2 mod_before_path_ptr unal bit (18),
  1   149 	     2 mod_err_path_ptr   unal bit (18),
  1   150 	     2 mod_after_path_ptr unal bit (18),
  1   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  1   152 	     2 unused_2	      unal bit (18),
  1   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  1   154 
  1   155      dcl	   di_ptr		      ptr;
  1   156 
  1   157 /* information necessary for attributes that are not used in any relation */
  1   158 
  1   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  1   160 	     2 name char (32),			/* name of attribute */
  1   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  1   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  1   163 	     2 unused (2) bit (18) unal;
  1   164 
  1   165      dcl     ua_ptr ptr;
  1   166 
  1   167 
  1   168 /* space saving pathname$entryname structure, to be allocated
  1   169*   only when a path$entry has to be saved, else only a bit(18)
  1   170*   offset takes up space in the main model structure */
  1   171 
  1   172      declare 1 path_entry	      based (path_entry_ptr),
  1   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  1   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  1   175 	     2 reserved	      unal bit (36);	/* for future use */
  1   176 
  1   177      declare path_entry_ptr	      ptr;
  1   178 
  1   179 
  1   180 
  1   181 
  1   182 
  1   183 /* declarations for model of postfix stack holding the check option boolean expression
  1   184*   the following encoding values indicate the corresponding type of stack element
  1   185*
  1   186*   1  =
  1   187*   2  ^=
  1   188*   3  >
  1   189*   4  <
  1   190*   5  >=
  1   191*   6  <=
  1   192*
  1   193*   10  and
  1   194*   20  or
  1   195*   30  not
  1   196*
  1   197*   40  - (minus)
  1   198*
  1   199*   50  domain variable(same name as domain)
  1   200*
  1   201*   60  constant(number, bit string, or character string)
  1   202*
  1   203**/
  1   204 
  1   205 
  1   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  1   207 	     2 next	      bit (18),		/* link to next in list */
  1   208 	     2 type	      fixed binary,		/* code for this element type */
  1   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  1   210*						   if this is a constant element type */
  1   211 
  1   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  1   213 
  1   214 
  1   215 
  1   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  1   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  1   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  1   219 
  1   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  1   221 
  1   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  1   223 
  1   224 /* version structure, giving status of source for CMDB/RMDB,
  1   225*   status of model, and status of resultant */
  1   226 
  1   227 /* version number is in form MM.N.Y
  1   228*   where MM is the major version number, N is the minor version alteration,
  1   229*   and Y is the lastest modification to that alteration,
  1   230*   where M and N represent numbers 0-9, and Y is a letter */
  1   231 
  1   232      declare 1 version_status	      unal based (version_status_ptr),
  1   233 	     2 cmdb_rmdb,
  1   234 	       3 major	      fixed bin,
  1   235 	       3 minor	      fixed bin,
  1   236 	       3 modification     char (4),
  1   237 	     2 model,
  1   238 	       3 major	      fixed bin,
  1   239 	       3 minor	      fixed bin,
  1   240 	       3 modification     char (4),
  1   241 	     2 resultant,
  1   242 	       3 major	      fixed bin,
  1   243 	       3 minor	      fixed bin,
  1   244 	       3 modification     char (4);
  1   245 
  1   246      declare version_status_ptr     ptr;
  1   247 
  1   248 
  1   249 /* maintains information only about the db creation */
  1   250 
  1   251      declare 1 changer	      unal based (changer_ptr),
  1   252 	     2 id		      char (32),
  1   253 	     2 time	      fixed bin (71),
  1   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  1   255 
  1   256      declare changer_ptr	      ptr;
  1   257 
  1   258 
  1   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  1   260 	     02 len	      fixed bin,		/* length of the message */
  1   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  1   262 	     02 name	      char (32),		/* name of thing that set the message */
  1   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  1   264*                                                               that caused the database to become inconsistent */
  1   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  1   266 
  1   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  1   268 
  1   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  1   270 
  1   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  1   272 
  1   273 
      263 
      264 
  2     1 /*  START OF:	rmdb_create_domain_info.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
  2     6*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  2     7*     Contains the list of domains to be created.
  2     8*                                                   END HISTORY COMMENTS */
  2     9 
  2    10 dcl create_domain_info_count fixed bin (17);
  2    11 dcl create_domain_info_ptr ptr;
  2    12 dcl create_domain_info_version_1 char (8) int static options (constant) init ("cdi 1.0");
  2    13 
  2    14 dcl 1 create_domain_info based (create_domain_info_ptr),
  2    15      2 version char (8),
  2    16      2 count fixed bin (17),
  2    17      2 domain (create_domain_info_count refer (create_domain_info.count)),
  2    18       3 name char (32),
  2    19       3 descriptor bit (36),
  2    20       3 decode_declare_data_descriptor bit (36),
  2    21       3 check_proc_path char (168),
  2    22       3 decode_proc_path char (168),
  2    23       3 encode_proc_path char (168);
  2    24 
  2    25 /*  END OF:	rmdb_create_domain_info.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      265 
  3     1 /*  START OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 /****^  HISTORY COMMENTS:
  3     4*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
  3     5*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  3     6*     written.
  3     7*                                                   END HISTORY COMMENTS */
  3     8 
  3     9 /*DESCRIPTION
  3    10*  The following structures are the definition of the records with the keyed
  3    11*  vfile that is built during restructuring. This file serves as a crossreference
  3    12*  of unique attributes and domains used within the specified MRDS database. Each
  3    13*  object is a char (33); the first byte is set to an unprintable character so we
  3    14*  can use the index builtin to find a specific object.
  3    15**/
  3    16 
  3    17 dcl crossref_info_record_ptr ptr;
  3    18 dcl crossref_info_record_count fixed bin (21);
  3    19 dcl 1 crossref_info_record based (crossref_info_record_ptr),
  3    20      2 offset bit (18) unal,
  3    21      2 pad bit (18) unal,
  3    22      2 count fixed bin (21),
  3    23      2 entry (crossref_info_record_count refer (crossref_info_record.count)) unaligned,
  3    24       3 object_head char (1),
  3    25       3 object char (32);
  3    26 
  3    27 dcl crossref_info_record_objects char (33*crossref_info_record.count)
  3    28 			   based (addr (crossref_info_record.entry(1)));
  3    29 dcl OBJECT_HEAD char (1) int static options (constant) init (" ");
  3    30 
  3    31 dcl ATTRIBUTE_KEY_HEAD char (10) int static options (constant) init ("attribute:");
  3    32 dcl DOMAIN_KEY_HEAD char (7) int static options (constant) init ("domain:");
  3    33 dcl RELATION_KEY_HEAD char (9) int static options (constant) init ("relation:");
  3    34 
  3    35 /*DESCRIPTION
  3    36*  The following structures are used to contain sufficient crossreference
  3    37*  information for the delete_attribute and delete_domain requests. These
  3    38*  requests require a more complete view of a crossreference tree, associating
  3    39*  domains, attributes and relations in 2 directions.
  3    40**/
  3    41 
  3    42 dcl domain_list_ptr ptr;
  3    43 dcl domain_list_count fixed bin;
  3    44 dcl domain_list_names char (33*domain_list.count) based (addr (domain_list.name(1)));
  3    45 dcl 1 domain_list based (domain_list_ptr),
  3    46      2 count fixed bin,				/* number of domains in the list */
  3    47      2 name (domain_list_count refer (domain_list.count))
  3    48 	  char (33) unaligned,			/* name of this domain */
  3    49      2 attribute_list_ptr (domain_list_count refer (domain_list.count))
  3    50 		      ptr;			/* -> attribute_list structure */
  3    51 
  3    52 dcl attribute_list_ptr ptr;
  3    53 dcl attribute_list_count fixed bin;
  3    54 dcl attribute_list_names char (33*attribute_list.count) based (addr (attribute_list.name(1)));
  3    55 dcl 1 attribute_list based (attribute_list_ptr),
  3    56      2 count fixed bin,				/* number of attributes in the list */
  3    57      2 name (attribute_list_count refer (attribute_list.count))
  3    58 	  char (33) unaligned,			/* name of this attribute */
  3    59      2 domain_info_ptr (attribute_list_count refer (attribute_list.count))
  3    60 		   bit (18) unal,			/* offset in db_model of the domain_info structure for this attribute */
  3    61      2 attribute_ptr (attribute_list_count refer (attribute_list.count))
  3    62 		 ptr;				/* -> attribute structure */
  3    63 
  3    64 dcl relation_list_ptr ptr;
  3    65 dcl relation_list_count fixed bin;
  3    66 dcl relation_list_names char (33*relation_list.count) based (addr (relation_list.name (1)));
  3    67 dcl 1 relation_list based (relation_list_ptr),
  3    68      2 count fixed bin,				/* number of relations that are to be touched in this operation */
  3    69      2 name (relation_list_count refer (relation_list.count))
  3    70 	  char (33) unaligned,			/* name of this relation */
  3    71      2 relation_ptr (relation_list_count refer (relation_list.count))
  3    72 		ptr;				/* -> relation structure */
  3    73 
  3    74 dcl relation_ptr ptr;
  3    75 dcl relation_attribute_count fixed bin;
  3    76 dcl relation_attribute_names char (33*relation.attribute_count) based (addr (relation.attribute_names (1)));
  3    77 dcl 1 relation based (relation_ptr),
  3    78      2 name char (32),				/* name of the relation */
  3    79      2 file_model_ptr ptr,				/* -> relation.m segment */
  3    80      2 copy_file_model_ptr ptr,
  3    81      2 attribute_count fixed bin,			/* number of attributes defined for this relation */
  3    82      2 mbz fixed bin (35),
  3    83      2 attribute (relation_attribute_count refer (relation.attribute_count)),
  3    84       3 flags aligned,
  3    85         4 delete bit (1) unaligned,			/* ON: delete this attribute */
  3    86         4 new bit (1) unaligned,			/* ON: this attribute is added to the relation */
  3    87         4 part_of_key bit (1) unaligned,                    /* ON: this attribute is part of the primary key */
  3    88         4 to_be_deleted bit (1) unaligned,
  3    89         4 pad bit (32) unaligned,
  3    90       3 domain_info_ptr bit (18) aligned,		/* -> db_model domain_info structure */
  3    91       3 attribute_info_ptr ptr,			/* -> file_model attribute_info structure */
  3    92       3 value_ptr ptr,				/* if flags.new, this -> the value of the column to be stored */
  3    93 						/*   it must be of the correct data type as specified by the domain */
  3    94      2 attribute_names (relation_attribute_count refer (relation.attribute_count))
  3    95 		   char (33) unaligned;
  3    96 
  3    97 dcl attribute_ptr ptr;
  3    98 dcl attribute_count fixed bin;
  3    99 dcl 1 attribute based (attribute_ptr),
  3   100      2 count fixed bin,				/* number of relations this attribute is used in */
  3   101      2 relation_idx (attribute_count refer (attribute.count))
  3   102 		fixed bin;			/* index into list of relation names */
  3   103 
  3   104 /*  END OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      266 
  4     1 /* BEGIN INCLUDE FILE rmdb_history_entry.incl.pl1 -- nsd, 82-04-09 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(75-01-01,WhoKnows), approve(), audit(), install():
  4     7*     Written.
  4     8*  2) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
  4     9*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  4    10*     Added RMDB_ADD_(ATTR DMN)_OP, RMDB_RN_(ATTR DMN REL)_OP.
  4    11*                                                   END HISTORY COMMENTS */
  4    12 
  4    13 
  4    14 /*
  4    15*   This include file contains the rmdb_history_entry structure which
  4    16*   is  used for maintaining a history of the databases restructuring
  4    17*   events. It also contains a set of constants used in  loading  the
  4    18*   structure.
  4    19*
  4    20*   The restructuring history is applied against the  database  as  a
  4    21*   whole  instead of against each structure in the db_model and file
  4    22*   models which was the approach originally  implemented  but  never
  4    23*   really  used  (except  to  record the database creation). This is
  4    24*   because 1 database restructuring event, i.e. adding a  new  index
  4    25*   to a relation will change several of the structures in the model.
  4    26*
  4    27*   For a detailed explaination of the use of this structure and  the
  4    28*   constants see the rmdb_add_rmdb_event module.
  4    29**/
  4    30 
  4    31 dcl 01 rmdb_history_entry aligned based (rmdb_history_entry_ptr),
  4    32     02 user_id char (32),				/* person_id.project_id.tag */
  4    33     02 date_time_restructured fixed bin (71),
  4    34     02 type_of_object_restructured fixed bin,		/* taken from constants below */
  4    35     02 object_name char (32),
  4    36     02 operation fixed bin,				/* taken from constants below */
  4    37     02 secondary_object_name char (32),			/* i.e. name of attr just indexed in a restructured relation */
  4    38     02 offset_to_next_entry bit (18) unal,
  4    39     02 offset_to_previous_entry bit (18) unal;
  4    40 	
  4    41 
  4    42 dcl  rmdb_history_entry_ptr ptr;
  4    43 
  4    44 
  4    45 dcl  RMDB_DOMAIN_TYPE init (1) fixed bin internal static options (constant);
  4    46 dcl  RMDB_ATTR_TYPE init (2) fixed bin internal static options (constant);
  4    47 dcl  RMDB_REL_TYPE init (3) fixed bin internal static options (constant);
  4    48 
  4    49 
  4    50 dcl  RMDB_ADD_REL_OP init (1) fixed bin internal static options (constant);
  4    51 dcl  RMDB_DEL_REL_OP init (2) fixed bin internal static options (constant);
  4    52 dcl  RMDB_ADD_IDX_OP init (3) fixed bin internal static options (constant);
  4    53 dcl  RMDB_DEL_IDX_OP init (4) fixed bin internal static options (constant);
  4    54 dcl  RMDB_ADD_ATTR_OP init (5) fixed bin int static options (constant);
  4    55 dcl  RMDB_DEL_ATTR_OP init (6) fixed bin int static options (constant);
  4    56 dcl  RMDB_ADD_DMN_OP init (7) fixed bin int static options (constant);
  4    57 dcl  RMDB_DEL_DMN_OP init (8) fixed bin int static options (constant);
  4    58 dcl  RMDB_RN_ATTR_OP init (9) fixed bin int static options (constant);
  4    59 dcl  RMDB_RN_DMN_OP init (10) fixed bin int static options (constant);
  4    60 dcl  RMDB_RN_REL_OP init (11) fixed bin int static options (constant);
  4    61 
  4    62 /* END INCLUDE FILE rmdb_history_entry.incl.pl1 */
      267 
  5     1 /* BEGIN - mrds_rmdb_ctl.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(82-03-26,Davids), approve(), audit(), install():
  5     7*     created
  5     8*  2) change(82-05-26,Davids), approve(), audit(), install():
  5     9*     added db_model_ptr
  5    10*  3) change(82-06-09,Harvey), approve(), audit(), install():
  5    11*     deleted ssu_ routines ptr storage
  5    12*  4) change(82-08-20,Davids), approve(), audit(), install():
  5    13*     added the relmgr like reference and included the rmdb_relmgr_entries
  5    14*     include file
  5    15*  5) change(83-05-24,Davids), approve(), audit(), install():
  5    16*     added the saved_res_version_ptr element
  5    17*  6) change(84-10-23,Benjamin), approve(), audit(), install():
  5    18*     added flags (just database_readied_by_rmdb for now).
  5    19*  7) change(85-11-08,Spitzer), approve(85-11-08,MCR7311),
  5    20*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  5    21*     added crossref_file_info.
  5    22*                                                   END HISTORY COMMENTS */
  5    23 
  5    24 
  5    25 dcl 01 rmdb_ctl based (rmdb_ctl_ptr),
  5    26     02 version fixed bin,
  5    27     02 rmdb_version char (16) varying,
  5    28     02 absolute_db_path char (168),
  5    29     02 temp_dir_path char (168),
  5    30     02 work_area_ptr ptr,
  5    31     02 db_model_ptr ptr,
  5    32     02 saved_res_version_ptr ptr,
  5    33     02 crossref_file_info,
  5    34        03 iocb_ptr ptr,
  5    35        03 name char (32),
  5    36     02 relmgr_entries like rmdb_relmgr_entries,
  5    37     02 flags,
  5    38        03 database_readied_by_rmdb bit (1) unal,
  5    39        03 unused bit (35) unal;
  5    40     	
  5    41 dcl  RMDB_CTL_VERSION_1 fixed bin init (1) internal static options (constant);
  5    42 
  5    43 dcl  rmdb_ctl_ptr ptr;
  5    44 
  5    45 
  6     1 /*  START OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(82-08-20,Davids), approve(), audit(), install():
  6     6*     written
  6     7*  2) change(86-01-28,Spitzer), approve(86-01-28,MCR7311),
  6     8*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  6     9*     add get_tuples_by_spec, put_tuple, put_tuples, create_cursor entry points.
  6    10*  3) change(86-08-21,Blair), approve(86-08-21,MCR7311),
  6    11*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  6    12*     Back out the entries get_tuples_by_spec and put_tuples since they aren't
  6    13*     sufficiently well tested to be reliable.  Replace with get_tuple_id and
  6    14*     get_tuple_by_id.
  6    15*                                                   END HISTORY COMMENTS */
  6    16 
  6    17 
  6    18 dcl 01 rmdb_relmgr_entries based (rmdb_relmgr_entries_ptr),
  6    19      02 create_relation entry (char (*), char (*), ptr, ptr, bit (36) aligned,
  6    20 	bit (36) aligned, fixed bin (35)),
  6    21      02 delete_relation entry (char (*), char (*), fixed bin (35)),
  6    22      02 open entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  6    23      02 close entry (bit (36) aligned, fixed bin (35)),
  6    24      02 create_index entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17),
  6    25 	bit (36) aligned, fixed bin (35)),
  6    26      02 delete_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35)),
  6    27      02 put_tuple entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  6    28      02 get_tuple_id entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  6    29      02 get_tuple_by_id entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  6    30      02 create_cursor entry (bit (36) aligned, ptr, ptr, fixed bin (35));
  6    31 
  6    32 dcl rmdb_relmgr_entries_ptr ptr;
  6    33 
  6    34 /*  END OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5    46 
  5    47 
  5    48 
  5    49 /* END - mrds_rmdb_ctl.incl.pl1 */
      268 
      269 
      270 dcl  addr builtin;
      271 dcl  area condition;
      272 dcl  char builtin;
      273 dcl  cleanup condition;
      274 dcl  clock builtin;
      275 dcl  code fixed bin (35);
      276 dcl  error_message char (500);
      277 dcl  error_table_$action_not_performed fixed bin (35) ext static;
      278 dcl  error_table_$area_too_small fixed bin (35) ext static;
      279 dcl  error_table_$no_record fixed bin (35) ext static;
      280 dcl  error_table_$unimplemented_version fixed bin (35) ext static;
      281 dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
      282 dcl  fixed builtin;
      283 dcl  get_group_id_ entry () returns (char (32));
      284 dcl  Icreate_domain_info_ptr ptr parameter;
      285 dcl  index builtin;
      286 dcl  Irmdb_ctl_ptr ptr parameter;
      287 dcl  last_di_ptr ptr;
      288 dcl  local_iocb ptr;
      289 dcl  loop fixed bin (17);
      290 dcl  ltrim builtin;
      291 dcl  mdbm_util_$inconsistent_reset entry (ptr);
      292 dcl  mdbm_util_$inconsistent_set entry (ptr, char (*), char (*), char (*));
      293 dcl  mdbm_util_$xref_build entry (char (*), char (*), ptr, char (*), ptr, char (*), fixed bin (35));
      294 dcl  mdbm_util_$xref_create_record entry (ptr, char (*), char (*), bit (18), char (*), fixed bin (35));
      295 dcl  mdbm_util_$xref_destroy entry (ptr, char (*), char (*), char (*), fixed bin (35));
      296 dcl  mdbm_util_$xref_find_record entry (ptr, char (*), char (*), ptr, fixed bin (21), char (*), fixed bin (35));
      297 dcl  mdbm_util_$xref_reference entry (ptr, char (*), char (*), char (*), ptr, fixed bin (21), char (*), fixed bin (35));
      298 dcl  mrds_error_$domain_already_defined fixed bin (35) ext static;
      299 dcl  null builtin;
      300 dcl  NULL_OFFSET bit (18) unaligned int static options (constant) init ((18)"1"b);
      301 dcl  Ocode fixed bin (35) parameter;
      302 dcl  Oerror_message char (*) parameter;
      303 dcl  pathname_ entry (char (*), char (*)) returns (char (168));
      304 dcl  ptr builtin;
      305 dcl  quit condition;
      306 dcl  rel builtin;
      307 dcl  rmdb_add_rmdb_history entry (ptr, fixed bin, char (32), fixed bin, char (32), char (500), fixed bin (35));
      308 dcl  substr builtin;
      309 dcl  sys_info$max_seg_size fixed bin (35) ext static;
      310 dcl  unspec builtin;
      311 
      312      end rmdb_create_domain;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1143.5  rmdb_create_domain.pl1            >special_ldd>install>MR12.0-1187>rmdb_create_domain.pl1
263          1    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
265          2    10/16/86  1139.5  rmdb_create_domain_info.incl.pl1  >special_ldd>install>MR12.0-1187>rmdb_create_domain_info.incl.pl1
266          3    10/16/86  1140.3  rmdb_crossref_info.incl.pl1       >special_ldd>install>MR12.0-1187>rmdb_crossref_info.incl.pl1
267          4    10/16/86  1139.6  rmdb_history_entry.incl.pl1       >special_ldd>install>MR12.0-1187>rmdb_history_entry.incl.pl1
268          5    10/16/86  1139.6  mrds_rmdb_ctl.incl.pl1            >special_ldd>install>MR12.0-1187>mrds_rmdb_ctl.incl.pl1
5-46         6    10/16/86  1140.2  rmdb_relmgr_entries.incl.pl1      >special_ldd>install>MR12.0-1187>rmdb_relmgr_entries.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTRIBUTE_KEY_HEAD              000004 constant        char(10)                 initial unaligned dcl 3-31 set ref 161*
DOMAIN_KEY_HEAD                 000002 constant        char(7)                  initial unaligned dcl 3-32 set ref 50* 151* 171*
Icreate_domain_info_ptr                parameter       pointer                  dcl 284 ref 21 29
Irmdb_ctl_ptr                          parameter       pointer                  dcl 286 ref 21 24
NULL_OFFSET                            constant        bit(18)                  initial unaligned dcl 300 ref 61 123 129 130 131 132
                                                                                  133 134 135 136 137 138 139 140 146 233
Ocode                                  parameter       fixed bin(35,0)          dcl 301 set ref 21 85*
Oerror_message                         parameter       char                     unaligned dcl 302 set ref 21 86* 88*
RMDB_ADD_DMN_OP                 000000 constant        fixed bin(17,0)          initial dcl 4-56 set ref 187*
RMDB_CTL_VERSION_1                     constant        fixed bin(17,0)          initial dcl 5-41 ref 25
RMDB_DOMAIN_TYPE                000037 constant        fixed bin(17,0)          initial dcl 4-45 set ref 187*
absolute_db_path          6            based           char(168)                level 2 packed unaligned dcl 5-25 set ref 41*
area                            000110 stack reference condition                dcl 271 ref 67
based_item                             based           fixed bin(35,0)          dcl 203 ref 208
cd                                     parameter       fixed bin(35,0)          dcl 82 ref 79 85 86
changer                                based           structure                level 1 packed unaligned dcl 1-251 set ref 143
changer_ptr              24(18)        based           bit(18)                  level 2 packed unaligned dcl 1-125 set ref 148*
char                                                   builtin function         dcl 272 ref 25
check_path_ptr           15            based           bit(18)                  level 2 packed unaligned dcl 1-125 set ref 125*
check_proc_path          15            based           char(168)                array level 3 packed unaligned dcl 2-14 set ref 125*
ck_stack_ptr             15(18)        based           bit(18)                  level 2 packed unaligned dcl 1-125 set ref 129*
cleanup                         000000 stack reference condition                dcl 273 ref 104
clock                                                  builtin function         dcl 274 ref 145
code                            000116 automatic       fixed bin(35,0)          dcl 275 set ref 41* 43 43* 50* 52 54 54* 151* 153
                                                                                  156* 161* 163 166* 171* 173 176* 187* 189 189*
                                                                                  244* 245 245*
count                     2            based           fixed bin(17,0)          level 2 dcl 2-14 ref 35 49 70
create_domain_info                     based           structure                level 1 unaligned dcl 2-14
create_domain_info_ptr          000104 automatic       pointer                  dcl 2-11 set ref 29* 31 31 35 49 50 52 70 108 108
                                                                                  115 118 119 125 126 127 151 161 171 171 187
create_domain_info_version_1    000010 constant        char(8)                  initial unaligned dcl 2-12 ref 31
crossref_file_info      140            based           structure                level 2 unaligned dcl 5-25
db_desc                  11            based           bit(36)                  level 2 dcl 1-125 set ref 118* 120
db_model                               based           structure                level 1 dcl 1-72
db_model_ptr            134            based           pointer                  level 2 dcl 5-25 ref 38
dbm_area                 34            based           area                     level 2 dcl 1-72 ref 113 143 248
dbm_ptr                         000100 automatic       pointer                  dcl 1-106 set ref 38* 41* 61 61 64 108* 113 143 180
                                                                                  185 185 187* 192* 215* 248
decd_path_ptr            16(18)        based           bit(18)                  level 2 packed unaligned dcl 1-125 set ref 127*
decode_declare_data_descriptor
                         14            based           bit(36)                  array level 3 packed unaligned dcl 2-14 ref 119
decode_proc_path         67            based           char(168)                array level 3 packed unaligned dcl 2-14 set ref 127*
descriptor               13            based           bit(36)                  array level 3 packed unaligned dcl 2-14 ref 118
di_ptr                          000102 automatic       pointer                  dcl 1-155 set ref 61* 61* 63* 64
domain                    3            based           structure                array level 2 packed unaligned dcl 2-14
domain_info                            based           structure                level 1 dcl 1-125 set ref 113 114*
domain_ptr               22(18)        based           bit(18)                  level 2 packed unaligned dcl 1-72 set ref 61 180*
encd_path_ptr            16            based           bit(18)                  level 2 packed unaligned dcl 1-125 set ref 126*
encode_proc_path        141            based           char(168)                array level 3 packed unaligned dcl 2-14 set ref 126*
entry                    52            based           char(32)                 level 2 packed unaligned dcl 1-172 set ref 250* 252*
error_message                   000117 automatic       char(500)                unaligned dcl 276 set ref 41* 43* 50* 54* 88 151*
                                                                                  156* 161* 166* 171* 176* 187* 189*
error_table_$action_not_performed
                                000010 external static fixed bin(35,0)          dcl 277 set ref 35*
error_table_$area_too_small     000012 external static fixed bin(35,0)          dcl 278 set ref 67*
error_table_$no_record          000014 external static fixed bin(35,0)          dcl 279 ref 54
error_table_$unimplemented_version
                                000016 external static fixed bin(35,0)          dcl 280 set ref 25* 31*
expand_pathname_                000020 constant        entry                    external dcl 281 ref 244
fwd_thread               14(18)        based           bit(18)                  level 2 packed unaligned dcl 1-125 set ref 64 123*
                                                                                  182*
get_after_path_ptr       21(18)        based           bit(18)                  level 2 packed unaligned dcl 1-125 set ref 135*
get_before_path_ptr      20(18)        based           bit(18)                  level 2 packed unaligned dcl 1-125 set ref 133*
get_err_path_ptr         21            based           bit(18)                  level 2 packed unaligned dcl 1-125 set ref 134*
get_group_id_                   000022 constant        entry                    external dcl 283 ref 144
id                                     based           char(32)                 level 2 packed unaligned dcl 1-251 set ref 144*
idx                                    parameter       fixed bin(17,0)          dcl 95 ref 92 108 108 115 118 119 125 126 127 151
                                                                                  161 171 171 187 234 248 249 250 252 254 255
index                                                  builtin function         dcl 285 ref 237
iocb_ptr                140            based           pointer                  level 3 dcl 5-25 set ref 39 41* 46 212*
last_di_ptr                     000314 automatic       pointer                  dcl 287 set ref 60* 63* 180 182 183*
local_iocb                      000316 automatic       pointer                  dcl 288 set ref 46* 50* 151* 161* 171*
loop                            000320 automatic       fixed bin(17,0)          dcl 289 set ref 49* 50 52* 70* 71*
ltrim                                                  builtin function         dcl 290 ref 25
mdbm_util_$inconsistent_reset   000024 constant        entry                    external dcl 291 ref 192 215
mdbm_util_$inconsistent_set     000026 constant        entry                    external dcl 292 ref 108
mdbm_util_$xref_build           000030 constant        entry                    external dcl 293 ref 41
mdbm_util_$xref_create_record   000032 constant        entry                    external dcl 294 ref 151 161
mdbm_util_$xref_destroy         000034 constant        entry                    external dcl 295 ref 212
mdbm_util_$xref_find_record     000036 constant        entry                    external dcl 296 ref 50
mdbm_util_$xref_reference       000040 constant        entry                    external dcl 297 ref 171
mod_after_path_ptr       23            based           bit(18)                  level 2 packed unaligned dcl 1-125 set ref 138*
mod_before_path_ptr      22            based           bit(18)                  level 2 packed unaligned dcl 1-125 set ref 136*
mod_err_path_ptr         22(18)        based           bit(18)                  level 2 packed unaligned dcl 1-125 set ref 137*
mrds_error_$domain_already_defined
                                000042 external static fixed bin(35,0)          dcl 298 set ref 52*
msg                                    parameter       char                     unaligned dcl 83 ref 79
name                                   based           char(32)                 level 2 in structure "domain_info" dcl 1-125
                                                                                  in procedure "rmdb_create_domain" set ref 115*
name                    142            based           char(32)                 level 3 in structure "rmdb_ctl" packed unaligned
                                                                                  dcl 5-25 in procedure "rmdb_create_domain" set ref
                                                                                  41* 212*
name                      3            based           char(32)                 array level 3 in structure "create_domain_info"
                                                                                  packed unaligned dcl 2-14 in procedure
                                                                                  "rmdb_create_domain" set ref 50* 52* 108 108 115
                                                                                  151* 161* 171* 171* 187*
new_changer_ptr                 000100 automatic       pointer                  dcl 96 set ref 103* 143* 144 145 146 148 207
new_di_ptr                      000102 automatic       pointer                  dcl 97 set ref 103* 113* 114 115 116 118 119 120 120
                                                                                  120 123 125 126 127 129 130 131 132 133 134 135
                                                                                  136 137 138 139 140 148 151 151 161 161 180 182
                                                                                  183 207
new_path_ptr                    000104 automatic       pointer                  array dcl 98 set ref 103* 207 207 207 234* 248* 249
                                                                                  250 252 254 255
next                     12            based           bit(18)                  level 2 packed unaligned dcl 1-251 set ref 146*
null                                                   builtin function         dcl 299 ref 39 50 50 60 103 171 171 180 208 234
num_domains              14(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-72 set ref 185* 185
p                               000100 automatic       pointer                  dcl 204 set ref 207* 208 208*
path                                   based           char(168)                level 2 packed unaligned dcl 1-172 set ref 249*
path_entry                             based           structure                level 1 packed unaligned dcl 1-172 set ref 248
pathname_                       000044 constant        entry                    external dcl 303 ref 249
ptr                                                    builtin function         dcl 304 ref 61 64
quit                            000000 stack reference condition                dcl 305 ref 106 194 195
quit_occured                    000112 automatic       bit(1)                   dcl 99 set ref 101* 106* 195
rel                                                    builtin function         dcl 306 ref 61 148 151 151 161 161 180 182 255
reserved                 62            based           bit(36)                  level 2 packed unaligned dcl 1-172 set ref 254*
rmdb_add_rmdb_history           000046 constant        entry                    external dcl 307 ref 187
rmdb_ctl                               based           structure                level 1 unaligned dcl 5-25
rmdb_ctl_ptr                    000106 automatic       pointer                  dcl 5-43 set ref 24* 25 25 38 39 41 41 41 41 46 212
                                                                                  212 212
rmdb_relmgr_entries                    based           structure                level 1 unaligned dcl 6-18
sp_dir                          000140 automatic       char(168)                unaligned dcl 223 set ref 244* 249*
sp_dollar_index                 000212 automatic       fixed bin(17,0)          dcl 224 set ref 237* 238 240 241
sp_entry                        000213 automatic       char(32)                 unaligned dcl 225 set ref 240* 243* 250 252
sp_idx                                 parameter       fixed bin(17,0)          dcl 226 ref 220
sp_name                         000223 automatic       char(32)                 unaligned dcl 227 set ref 244* 249* 250
sp_offset                              parameter       bit(18)                  unaligned dcl 228 set ref 220 233* 255*
sp_path                                parameter       char                     unaligned dcl 229 set ref 220 231 237 240 241* 244*
                                                                                  245*
str_after_path_ptr       20            based           bit(18)                  level 2 packed unaligned dcl 1-125 set ref 132*
str_before_path_ptr      17            based           bit(18)                  level 2 packed unaligned dcl 1-125 set ref 130*
str_err_path_ptr         17(18)        based           bit(18)                  level 2 packed unaligned dcl 1-125 set ref 131*
substr                                                 builtin function         dcl 308 set ref 240 241*
temp_dir_path            60            based           char(168)                level 2 packed unaligned dcl 5-25 set ref 41* 212*
time                     10            based           fixed bin(71,0)          level 2 packed unaligned dcl 1-251 set ref 145*
unreferenced             10(04)        based           bit(1)                   level 2 packed unaligned dcl 1-125 set ref 116*
unspec                                                 builtin function         dcl 310 set ref 114*
unused_1                 23(18)        based           bit(18)                  level 2 packed unaligned dcl 1-125 set ref 139*
unused_2                 24            based           bit(18)                  level 2 packed unaligned dcl 1-125 set ref 140*
user_desc                12            based           bit(36)                  level 2 dcl 1-125 set ref 119* 120 120*
version                                based           char(8)                  level 2 in structure "create_domain_info" packed
                                                                                  unaligned dcl 2-14 in procedure
                                                                                  "rmdb_create_domain" ref 31 31
version                                based           fixed bin(17,0)          level 2 in structure "rmdb_ctl" dcl 5-25
                                                                                  in procedure "rmdb_create_domain" ref 25 25

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
OBJECT_HEAD                            internal static char(1)                  initial unaligned dcl 3-29
RELATION_KEY_HEAD                      internal static char(9)                  initial unaligned dcl 3-33
RMDB_ADD_ATTR_OP                       internal static fixed bin(17,0)          initial dcl 4-54
RMDB_ADD_IDX_OP                        internal static fixed bin(17,0)          initial dcl 4-52
RMDB_ADD_REL_OP                        internal static fixed bin(17,0)          initial dcl 4-50
RMDB_ATTR_TYPE                         internal static fixed bin(17,0)          initial dcl 4-46
RMDB_DEL_ATTR_OP                       internal static fixed bin(17,0)          initial dcl 4-55
RMDB_DEL_DMN_OP                        internal static fixed bin(17,0)          initial dcl 4-57
RMDB_DEL_IDX_OP                        internal static fixed bin(17,0)          initial dcl 4-53
RMDB_DEL_REL_OP                        internal static fixed bin(17,0)          initial dcl 4-51
RMDB_REL_TYPE                          internal static fixed bin(17,0)          initial dcl 4-47
RMDB_RN_ATTR_OP                        internal static fixed bin(17,0)          initial dcl 4-58
RMDB_RN_DMN_OP                         internal static fixed bin(17,0)          initial dcl 4-59
RMDB_RN_REL_OP                         internal static fixed bin(17,0)          initial dcl 4-60
addr                                                   builtin function         dcl 270
alloc_length                           internal static fixed bin(35,0)          dcl 1-222
attribute                              based           structure                level 1 unaligned dcl 3-99
attribute_count                        automatic       fixed bin(17,0)          dcl 3-98
attribute_list                         based           structure                level 1 unaligned dcl 3-55
attribute_list_count                   automatic       fixed bin(17,0)          dcl 3-53
attribute_list_names                   based           char                     unaligned dcl 3-54
attribute_list_ptr                     automatic       pointer                  dcl 3-52
attribute_ptr                          automatic       pointer                  dcl 3-97
changer_ptr                            automatic       pointer                  dcl 1-256
constant                               based           structure                level 1 unaligned dcl 1-216
constant_ptr                           automatic       pointer                  dcl 1-220
create_domain_info_count               automatic       fixed bin(17,0)          dcl 2-10
crossref_info_record                   based           structure                level 1 unaligned dcl 3-19
crossref_info_record_count             automatic       fixed bin(21,0)          dcl 3-18
crossref_info_record_objects           based           char                     unaligned dcl 3-27
crossref_info_record_ptr               automatic       pointer                  dcl 3-17
domain_list                            based           structure                level 1 unaligned dcl 3-45
domain_list_count                      automatic       fixed bin(17,0)          dcl 3-43
domain_list_names                      based           char                     unaligned dcl 3-44
domain_list_ptr                        automatic       pointer                  dcl 3-42
fi_ptr                                 automatic       pointer                  dcl 1-119
file_info                              based           structure                level 1 dcl 1-113
fixed                                                  builtin function         dcl 282
message_str                            based           structure                level 1 packed unaligned dcl 1-259
message_str_len                        automatic       fixed bin(17,0)          dcl 1-269
message_str_ptr                        automatic       pointer                  dcl 1-267
path_entry_ptr                         automatic       pointer                  dcl 1-177
relation                               based           structure                level 1 unaligned dcl 3-77
relation_attribute_count               automatic       fixed bin(17,0)          dcl 3-75
relation_attribute_names               based           char                     unaligned dcl 3-76
relation_list                          based           structure                level 1 unaligned dcl 3-67
relation_list_count                    automatic       fixed bin(17,0)          dcl 3-65
relation_list_names                    based           char                     unaligned dcl 3-66
relation_list_ptr                      automatic       pointer                  dcl 3-64
relation_ptr                           automatic       pointer                  dcl 3-74
rmdb_history_entry                     based           structure                level 1 dcl 4-31
rmdb_history_entry_ptr                 automatic       pointer                  dcl 4-42
rmdb_relmgr_entries_ptr                automatic       pointer                  dcl 6-32
stack_item                             based           structure                level 1 unaligned dcl 1-206
stack_item_ptr                         automatic       pointer                  dcl 1-212
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 309
ua_ptr                                 automatic       pointer                  dcl 1-165
unreferenced_attribute                 based           structure                level 1 dcl 1-159
version_status                         based           structure                level 1 packed unaligned dcl 1-232
version_status_ptr                     automatic       pointer                  dcl 1-246

NAMES DECLARED BY EXPLICIT CONTEXT.
RETURN_TO_CALLER                000670 constant        label                    dcl 76 ref 89
cleaner                         001746 constant        entry                    internal dcl 200 ref 104 155 165 175
create_a_domain                 000733 constant        entry                    internal dcl 92 ref 71
error                           000672 constant        entry                    internal dcl 79 ref 25 31 35 43 52 54 67 74 156 166
                                                                                  176 189 245
rmdb_create_domain              000136 constant        entry                    external dcl 21
set_path                        002066 constant        entry                    internal dcl 220 ref 125 126 127

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2616        2666    2322        2626
Length      3262    2322        50         360     273           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rmdb_create_domain                  278 external procedure  is an external procedure.  
on unit on line 67                   88 on unit               
error                                65 internal procedure  is called during a stack extension.  
create_a_domain                     294 internal procedure  enables or reverts conditions.  
on unit on line 104                  64 on unit               
on unit on line 106                  64 on unit               
cleaner                              92 internal procedure  is called by several nonquick procedures.  
set_path                                internal procedure  shares stack frame of internal procedure create_a_domain.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cleaner                  000100 p                           cleaner
create_a_domain          000100 new_changer_ptr             create_a_domain
                         000102 new_di_ptr                  create_a_domain
                         000104 new_path_ptr                create_a_domain
                         000112 quit_occured                create_a_domain
                         000140 sp_dir                      set_path
                         000212 sp_dollar_index             set_path
                         000213 sp_entry                    set_path
                         000223 sp_name                     set_path
rmdb_create_domain       000100 dbm_ptr                     rmdb_create_domain
                         000102 di_ptr                      rmdb_create_domain
                         000104 create_domain_info_ptr      rmdb_create_domain
                         000106 rmdb_ctl_ptr                rmdb_create_domain
                         000116 code                        rmdb_create_domain
                         000117 error_message               rmdb_create_domain
                         000314 last_di_ptr                 rmdb_create_domain
                         000316 local_iocb                  rmdb_create_domain
                         000320 loop                        rmdb_create_domain

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other_desc call_int_other      return_mac          tra_ext_1           signal_op           enable_op
shorten_stack       ext_entry_desc      int_entry           int_entry_desc      op_alloc_           op_freen_
clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
expand_pathname_              get_group_id_                 mdbm_util_$inconsistent_reset mdbm_util_$inconsistent_set
mdbm_util_$xref_build         mdbm_util_$xref_create_record mdbm_util_$xref_destroy       mdbm_util_$xref_find_record
mdbm_util_$xref_reference     pathname_                     rmdb_add_rmdb_history

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$area_too_small   error_table_$no_record
error_table_$unimplemented_version                          mrds_error_$domain_already_defined




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     21 000131        24 000151        25 000155        29 000242        31 000247        35 000306        38 000333
     39 000336        41 000343        43 000402        46 000420        49 000423        50 000433        52 000503
     54 000530        56 000547        60 000551        61 000553        63 000565        64 000567        67 000575
     70 000632        71 000643        72 000651        74 000653        76 000670        79 000671        85 000705
     86 000712        88 000722        89 000727        92 000732       101 000740       103 000741       104 000757
    106 001001       108 001021       113 001075       114 001104       115 001107       116 001120       118 001122
    119 001124       120 001126       123 001132       125 001134       126 001161       127 001214       129 001251
    130 001254       131 001256       132 001260       133 001262       134 001264       135 001266       136 001270
    137 001272       138 001274       139 001276       140 001300       143 001302       144 001311       145 001317
    146 001325       148 001330       151 001334       153 001402       155 001405       156 001411       161 001427
    163 001475       165 001500       166 001504       171 001522       173 001601       175 001604       176 001610
    180 001626       182 001640       183 001644       185 001646       187 001654       189 001706       192 001726
    194 001736       195 001737       198 001744       200 001745       207 001753       208 001760       210 001766
    212 002017       215 002054       217 002065       220 002066       231 002077       233 002105       234 002111
    235 002117       237 002120       238 002131       240 002132       241 002140       242 002150       243 002151
    244 002154       245 002203       248 002225       249 002241       250 002265       252 002277       254 002304
    255 002307       258 002316


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
