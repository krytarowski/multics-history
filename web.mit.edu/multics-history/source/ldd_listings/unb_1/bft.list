	COMPILATION LISTING OF SEGMENT bft
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 02/24/88  0846.8 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1987 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: style4,indattr,ifthen,^indcomtxt,thendo,^indproc,^indblkcom,^indprocbody,initcol1,declareind8,dclind4,struclvlind3,comcol55 */
       10 
       11 bft:
       12 background_file_transfer:
       13      proc options (main);
       14 
       15 /* PROGRAM FUNCTION
       16*
       17*This is the routine that accepts command line arguments and then calls the
       18*appropriate entrypoint in bft_.  This procedure checks the number of arguments
       19*to the command and then if that is satisfactory then calls the appropriate
       20*subroutine to check the arguments themselves.  This is done by checking the
       21*first argument.  If it is valid, then a subroutine to handle that particular
       22*command is called.
       23**/
       24 
       25 /* NOTES
       26**/
       27 
       28 /****^  HISTORY COMMENTS:
       29*  1) change(86-06-06,Eichele), approve(87-07-15,MCR7580),
       30*     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
       31*     Created.
       32*  2) change(87-10-23,Flegel), approve(87-10-23,MCR7787),
       33*     audit(88-01-27,RWaters), install(88-02-24,MR12.2-1028):
       34*     Added multiple entry queues, control args, and queue display.
       35*  3) change(87-12-12,Flegel), approve(87-12-12,MCR7819),
       36*     audit(88-01-27,RWaters), install(88-02-24,MR12.2-1028):
       37*     Added control arguments for a wider scope of request capabilities.
       38*                                                   END HISTORY COMMENTS */
       39 
       40 /* PARAMETERS */
       41 
       42 /* MISC VARIABLES */
       43 dcl key_procedure	       entry variable;	    /* Actual request handler */
       44 dcl reason	       char (256) var;	    /* Error reason */
       45 dcl code		       fixed bin (35);
       46 
       47 /* GLOBAL */
       48 dcl display_sw	       bit (1);		    /* List request */
       49 dcl unload_sw	       bit (1);		    /* unload request */
       50 dcl store_sw	       bit (1);		    /* store request */
       51 dcl recover_sw	       bit (1);		    /* recover request */
       52 dcl load_sw	       bit (1);		    /* load request */
       53 dcl fetch_sw	       bit (1);		    /* fetch request */
       54 dcl cancel_sw	       bit (1);		    /* cancel request */
       55 dcl priority	       fixed bin;		    /* Queue number */
       56 dcl long_sw	       bit (1);		    /* If queue display is long */
       57 dcl main_arg_ptr	       ptr;		    /* Command arguments */
       58 dcl arg_pos	       fixed bin;		    /* Argument being looked at */
       59 dcl arg_count	       fixed bin;		    /* Number of arguments */
       60 dcl arg_len	       fixed bin (21);	    /* Argument length */
       61 dcl arg_ptr	       ptr;		    /* Argument */
       62 dcl arg		       char (arg_len) based (arg_ptr);
       63 dcl 01 modes	       like bft_queue_flags auto aligned; /* Transfer modes */
       64 
       65 /* STRUCTURES */
       66 
       67 /* SYSTEM CALLS */
       68 dcl cu_$arg_list_ptr        entry (ptr);
       69 dcl ioa_		       entry () options (variable);
       70 dcl absolute_pathname_     entry (char (*), char (*), fixed bin (35));
       71 dcl cu_$arg_ptr_rel	       entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr);
       72 dcl cu_$arg_count	       entry (fixed bin, fixed bin (35));
       73 dcl com_err_	       entry () options (variable);
       74 
       75 /* SYSTEM CALL SUPPORT */
       76 dcl error_table_$nodescr    fixed bin(35) ext static;
       77 dcl error_table_$inconsistent fixed bin (35) ext static;
       78 dcl error_table_$noarg     fixed bin (35) ext static;
       79 dcl error_table_$bad_arg   fixed bin (35) ext static;
       80 dcl error_table_$wrong_no_of_args fixed bin (35) ext static;
       81 
       82 /* EXTERNAL CALLS */
       83 dcl bft_$cancel	       entry (fixed bin, char (*), fixed bin (35));
       84 dcl bft_queue_$display_element entry (ptr, bit (1), fixed bin, bit (1), bit (1));
       85 dcl bft_queue_$initiate    entry (ptr, fixed bin (35));
       86 dcl bft_$fetch	       entry (char (*) var, char (*) var, bit (36) aligned, fixed bin, fixed bin (35));
       87 dcl bft_$load	       entry (fixed bin (35));
       88 dcl bft_$recover_fetch     entry (fixed bin (35));
       89 dcl bft_$recover_store     entry (fixed bin (35));
       90 dcl bft_$store	       entry (char (*) var, char (*) var, bit (36) aligned, fixed bin, fixed bin (35));
       91 dcl bft_$unload	       entry (fixed bin (35));
       92 
       93 /* EXTERNAL CALL SUPPORT */
       94 dcl bft_error_table_$invalid_file_type 	fixed bin(35) ext static;
       95 dcl bft_error_table_$invalid_keyword fixed bin (35) ext static;
       96 dcl bft_error_table_$invalid_priority fixed bin (35) ext static;
       97 dcl bft_error_table_$bft_not_loaded fixed bin (35) ext static;
       98 dcl ws_error_$invalid_capability_name fixed bin (35) ext static;
       99 
      100 /* BUILTINS */
      101 dcl null		       builtin;
      102 dcl unspec	       builtin;
      103 dcl substr	       builtin;
      104 dcl rank		       builtin;
      105 dcl addr		       builtin;
      106 dcl rtrim		       builtin;
      107 
      108 /* CONDITIONS */
      109 
      110 /* CONSTANTS */
      111 dcl NAME		       char (3) int static options (constant) init ("bft");
      112 dcl USAGE_CANCEL	       char (128) var int static options (constant) init ("^3tUsage:  bft cancel request_identifier {request_identifier ...}");
      113 dcl USAGE_UNLOAD	       char (128) var int static options (constant) init ("^3tUsage:  bft unload");
      114 dcl USAGE_RECOVER	       char (128) var int static options (constant) init ("^3tUsage:  bft recover");
      115 dcl USAGE_LOAD	       char (128) var int static options (constant) init ("^3tUsage:  bft load");
      116 dcl USAGE_BFT	       char (128) var int static options (constant) init ("^3tUsage:  bft KEY {name1 {name2...name1N name2N}} {-control_args}");
      117 dcl USAGE_KEYS	       char (128) var int static options (constant) init ("^6t(s)tore, (f)etch, (c)ancel, (ls) list, (l)oad, (u)nload, (r)ecover");
      118 
      119 /**/
      120 
      121 /* INITIALIZATION */
      122 
      123 /* Set default transfer modes */
      124 
      125      priority = 3;				    /* Queue 3 */
      126      unspec (modes) = ""b;			    /* "0" are default values */
      127      long_sw = "0"b;			    /* Long queue display */
      128 
      129 /* Set request type switches */
      130 
      131      cancel_sw = "0"b;
      132      fetch_sw = "0"b;
      133      load_sw = "0"b;
      134      recover_sw = "0"b;
      135      store_sw = "0"b;
      136      unload_sw = "0"b;
      137      display_sw = "0"b;
      138 
      139 /* MAIN */
      140 
      141 /* Get MAIN's arg_ptr */
      142 
      143      call cu_$arg_list_ptr (main_arg_ptr);
      144      if main_arg_ptr = null then do;
      145 	call com_err_ (error_table_$nodescr, NAME,
      146 	     "Getting argument pointer.");
      147 	return;
      148      end;
      149 
      150 /* How many args are there ? */
      151 
      152      call cu_$arg_count (arg_count, code);
      153      if code ^= 0 then do;
      154 	call com_err_ (code, NAME, "Getting argument count.");
      155 	return;
      156      end;
      157 
      158 /* None, then this is a request for usage */
      159 
      160      if arg_count <= 0 then do;
      161 	call com_err_ (error_table_$wrong_no_of_args, NAME);
      162 	call ioa_ (USAGE_BFT);
      163 	return;
      164      end;
      165 
      166 /* Extract the keyword */
      167 
      168      arg_pos = 0;
      169      call get_arg ("0"b, code);
      170      if code ^= 0 then do;
      171 	call com_err_ (code, NAME);
      172 	call ioa_ (USAGE_BFT);
      173 	return;
      174      end;
      175 
      176 /* This argument MUST be a keyword, otherwise - what are we to do? */
      177 
      178      if (arg = "cancel" | arg = "c") then do;
      179 	key_procedure = bft_cancel;
      180 	cancel_sw = "1"b;
      181      end;
      182      else if (arg = "fetch" | arg = "f") then do;
      183 	key_procedure = bft_fetch;
      184 	fetch_sw = "1"b;
      185      end;
      186      else if (arg = "load" | arg = "l" | arg = "ld") then do;
      187 	key_procedure = bft_load;
      188 	load_sw = "1"b;
      189      end;
      190      else if (arg = "list" | arg = "ls") then do;
      191 	key_procedure = bft_display;
      192 	display_sw = "1"b;
      193      end;
      194      else if (arg = "recover" | arg = "r") then do;
      195 	key_procedure = bft_recover;
      196 	recover_sw = "1"b;
      197      end;
      198      else if (arg = "store" | arg = "s") then do;
      199 	key_procedure = bft_store;
      200 	store_sw = "1"b;
      201      end;
      202      else if (arg = "unload" | arg = "u" | arg = "uld") then do;
      203 	key_procedure = bft_unload;
      204 	unload_sw = "1"b;
      205      end;
      206      else do;
      207 	call com_err_ (bft_error_table_$invalid_keyword, NAME, arg);
      208 	call ioa_ (USAGE_KEYS);
      209 	return;
      210      end;
      211 
      212 /* Parse through control arguments */
      213 
      214      call parse_control_args (code, reason);
      215      if code ^= 0 then do;
      216 	call com_err_ (code, NAME, reason);
      217 	return;
      218      end;
      219 
      220 /* We made it to here, so call the handler, skip the first "real" argument
      221*   as it is the keyword */
      222 
      223      arg_pos = 0;
      224      call get_arg ("0"b, (0));
      225      call key_procedure ();
      226 
      227      return;
      228 
      229 /**/
      230 
      231 /* INTERNAL ENTRIES */
      232 
      233 /**/
      234 
      235 /* INTERNAL PROCEDURES */
      236 
      237 
      238 /* *** Procedure: cancel - Internal proc for bft  *** */
      239 
      240 bft_cancel:
      241      proc ();
      242 
      243 
      244 /* PROCEDURE FUNCTION
      245*
      246*Cancel an element from the queue, ONLY if it is not currenlty in transfer.
      247**/
      248 
      249 /* NOTES
      250**/
      251 
      252 /* PARAMETERS */
      253 
      254 /* MISC VARIABLES */
      255 dcl request_type	       char (32) var;	    /* Cancellation request type */
      256 dcl code		       fixed bin (35);	    /* Error code */
      257 dcl passed	       fixed bin;		    /* Number of requests cancelled */
      258 
      259 /* STRUCTURES */
      260 
      261 /* INITIALIZATION */
      262      passed = 0;
      263 
      264 /* MAIN */
      265 
      266 /* Parse through each arg in the command line */
      267 
      268      do while (arg_pos < arg_count);
      269 	call get_arg ("1"b, code);
      270 	if code ^= 0 then do;
      271 	     if passed = 0 then
      272 		call com_err_ (code, NAME, arg);
      273 	     else
      274 		call com_err_ (code, NAME);
      275 	     goto CANCEL_RETURN;
      276 	end;
      277 
      278 /* Determine which entry type we have, and cancel accordingly */
      279 
      280 	if substr (arg, 1, 1) ^= "-" then
      281 	     call bft_$cancel (BFT_PATH_ID, arg, code);
      282 	else do;
      283 	     request_type = arg;
      284 	     call get_arg ("0"b, code);
      285 	     if code ^= 0 then do;
      286 		call com_err_ (code, NAME);
      287 		return;
      288 	     end;
      289 
      290 	     if request_type = "-id" then
      291 		call bft_$cancel (BFT_TIME_ID, arg, code);
      292 	     else if request_type = "-entry" | request_type = "-et" then
      293 		call bft_$cancel (BFT_ENTRY_ID, arg, code);
      294 	end;
      295 
      296 /* Is there an error ? */
      297 
      298 	if code ^= 0 then do;
      299 	     call com_err_ (code, NAME, "Cancelling ^a.", arg);
      300 	     goto CANCEL_RETURN;
      301 	end;
      302 
      303 /* Increment the cancellation count */
      304 
      305 	passed = passed + 1;
      306      end;
      307 
      308 CANCEL_RETURN:
      309 
      310      if passed > 0 then
      311 	call ioa_ ("^a: ^d request^[s^] submitted for cancellation.",
      312 	     NAME, passed, (passed > 1));
      313 
      314      end bft_cancel;
      315 
      316 /**/
      317 
      318 /* *** Procedure: bft_display - Internal proc for bft  *** */
      319 
      320 bft_display:
      321      proc ();
      322 
      323 
      324 /* PROCEDURE FUNCTION
      325*
      326*Display the current entries in the queues.
      327**/
      328 
      329 /* NOTES
      330**/
      331 
      332 /* PARAMETERS */
      333 
      334 /* MISC VARIABLES */
      335 dcl running_count	       fixed bin;
      336 dcl code		       fixed bin (35);
      337 dcl running	       bit (1);		    /* Running element displayed */
      338 dcl i		       fixed bin;
      339 dcl empty_sw	       bit (1);		    /* Queues are empty? */
      340 dcl slot		       fixed bin (35);	    /* Queue traversal index */
      341 dcl count		       fixed bin (21);	    /* Elements in queue */
      342 
      343 /* STRUCTURES */
      344 
      345 /* INITIALIZATION */
      346      empty_sw = "1"b;
      347 
      348 /* MAIN */
      349 
      350      call bft_queue_$initiate (queue_ptr, code);
      351      if code ^= 0 then do;
      352 	call com_err_ (code, NAME, "Initiating queue.");
      353 	return;
      354      end;
      355 
      356 /* Display the store queue */
      357 
      358      running = "0"b;
      359      running_count = 1;
      360      do i = BFT_MIN_PRIORITY to BFT_MAX_PRIORITY;
      361 
      362 /* Count how many requests are pending */
      363 
      364 	count = 0;
      365 	slot = queue.header.store_queue (i).first;
      366 	do while (slot ^= 0);
      367 	     count = count + 1;
      368 	     slot = queue.array (slot).next;
      369 	end;
      370 
      371 /* Tell user how many requests in store queue */
      372 
      373 	if count > 0 then do;
      374 	     empty_sw = "1"b;		    /* To tell display_element to print a header */
      375 	     call ioa_ ("^/BFT Store Queue ^d:^20t^d request^[s^].^/",
      376 		i, running_count + count, (running_count + count > 1));
      377 	     running_count = 0;
      378 
      379 /* Display the running element */
      380 
      381 	     if queue.header.storing.flags.initiated & ^running then do;
      382 		call bft_queue_$display_element (addr (queue.header.storing),
      383 		     long_sw, BFT_MULTICS_to_PC, "1"b, "1"b);
      384 		if long_sw then
      385 		     call ioa_ ();
      386 		empty_sw = "0"b;
      387 		running = "1"b;
      388 	     end;
      389 
      390 /* Display the remainder of the queue */
      391 
      392 	     slot = queue.header.store_queue (i).first;
      393 	     do while (slot ^= 0);
      394 		call bft_queue_$display_element (addr (queue.array (slot)),
      395 		     long_sw, BFT_MULTICS_to_PC, "0"b, empty_sw);
      396 		empty_sw = "0"b;
      397 		slot = queue.array (slot).next;
      398 		if long_sw & slot ^= 0 then
      399 		     call ioa_ ();
      400 	     end;
      401 	end;
      402      end;
      403 
      404 /* Display the running element if there are no pending elements */
      405 
      406      if queue.header.storing.flags.initiated & ^running then do;
      407 	call ioa_ ("^/BFT Store Queue:^/");
      408 	call bft_queue_$display_element (addr (queue.header.storing),
      409 	     long_sw, BFT_MULTICS_to_PC, "1"b, "1"b);
      410 	empty_sw = "0"b;
      411 	running = "1"b;
      412      end;
      413 
      414 /* Display the fetch queue */
      415 
      416      running = "0"b;
      417      running_count = 1;
      418      do i = BFT_MIN_PRIORITY to BFT_MAX_PRIORITY;
      419 	count = 0;
      420 	slot = queue.header.fetch_queue (i).first;
      421 	do while (slot ^= 0);
      422 	     count = count + 1;
      423 	     slot = queue.array (slot).next;
      424 	end;
      425 
      426 	if count > 0 then do;
      427 	     empty_sw = "1"b;		    /* To tell display_element to print a header */
      428 	     call ioa_ ("^/BFT Fetch Queue ^d:^20t^d request^[s^].^/",
      429 		i, running_count + count, (running_count + count > 1));
      430 	     running_count = 0;
      431 
      432 	     if queue.header.fetching.flags.initiated & ^running then do;
      433 		call bft_queue_$display_element (addr (queue.header.fetching),
      434 		     long_sw, BFT_PC_to_MULTICS, "1"b, "1"b);
      435 		if long_sw then
      436 		     call ioa_ ();
      437 		empty_sw = "0"b;
      438 		running = "1"b;
      439 	     end;
      440 
      441 	     slot = queue.header.fetch_queue (i).first;
      442 	     do while (slot ^= 0);
      443 		call bft_queue_$display_element (addr (queue.array (slot)),
      444 		     long_sw, BFT_PC_to_MULTICS, "0"b, empty_sw);
      445 		empty_sw = "0"b;
      446 		slot = queue.array (slot).next;
      447 		if long_sw & slot ^= 0 then
      448 		     call ioa_ ();
      449 	     end;
      450 	end;
      451      end;
      452      if queue.header.fetching.flags.initiated & ^running then do;
      453 	call ioa_ ("^/BFT Fetch Queue:^/");
      454 	call bft_queue_$display_element (addr (queue.header.fetching),
      455 	     long_sw, BFT_PC_to_MULTICS, "1"b, "1"b);
      456 	empty_sw = "0"b;
      457 	running = "1"b;
      458      end;
      459 
      460 /* If there were no transfers, say so */
      461 
      462      if empty_sw then
      463 	call ioa_ ("There are no requests in any BFT queue.");
      464      else
      465 	call ioa_ ();
      466 
      467      end bft_display;
      468 
      469 /**/
      470 
      471 /* *** Procedure: bft_fetch - Internal proc for bft *** */
      472 
      473 bft_fetch:
      474      proc ();
      475 
      476 /* PROCEDURE FUNCTION
      477*
      478*This routine is called if the first argument specified a fetch.  If two
      479*filenames are given, both are accepted.  If only one is given, then the
      480*destination will default to being the same as the supplied source name.
      481**/
      482 
      483 /* NOTES
      484**/
      485 
      486 /* PARAMETERS */
      487 
      488 /* MISC VARIABLES */
      489 dcl code		       fixed bin (35);	    /* Error code */
      490 dcl passed	       fixed bin;		    /* Requests submitted */
      491 dcl temp_file	       char (168);
      492 dcl mu_path	       char (168);
      493 dcl pc_path	       char (66);
      494 
      495 /* STRUCTURES */
      496 
      497 /* INITIALIZATION */
      498      passed = 0;
      499 
      500 /* MAIN */
      501 
      502 /* Repeat until there are no more requests in the command line */
      503 
      504      do while (arg_pos < arg_count);
      505 
      506 /* Get the pc_path */
      507 
      508 	call get_arg ("0"b, code);
      509 	if code ^= 0 then do;
      510 	     if passed = 0 then
      511 		call com_err_ (code, NAME, arg);
      512 
      513 	     goto FETCH_RETURN;
      514 	end;
      515 
      516 	pc_path = arg;
      517 	mu_path = "===";
      518 
      519 /* Look for the Multics path, if it is not specified, default to pc_path */
      520 
      521 	call get_arg ("0"b, code);
      522 	if code ^= 0 & code ^= error_table_$noarg then do;
      523 	     call com_err_ (code, NAME, arg);
      524 	     goto FETCH_RETURN;
      525 	end;
      526 	else if code = 0 then
      527 	     mu_path = arg;
      528 
      529 /* Obtain the full pathname of the specified destination */
      530 
      531 	temp_file = mu_path;
      532 	call absolute_pathname_ (temp_file, mu_path, code);
      533 	if code ^= 0 then do;
      534 	     call com_err_ (code, NAME, "Expanding Multics pathname.");
      535 	     goto FETCH_RETURN;
      536 	end;
      537 
      538 /* Call the bft_$fetch entrypoint with the valid parms */
      539 
      540 	call bft_$fetch (rtrim (pc_path), rtrim (mu_path), unspec (modes),
      541 	     priority, code);
      542 	if code ^= 0 then do;
      543 	     if code = ws_error_$invalid_capability_name then
      544 		code = bft_error_table_$bft_not_loaded;
      545 	     call com_err_ (code, NAME, "Issuing fetch request.");
      546 
      547 	     goto FETCH_RETURN;
      548 	end;
      549 
      550 /* Increment the cancellation count */
      551 
      552 	passed = passed + 1;
      553      end;
      554 
      555 FETCH_RETURN:
      556 
      557      if passed > 0 then
      558 	call ioa_ ("^a: ^d request^[s^] submitted for fetching.", NAME,
      559 	     passed, (passed > 1));
      560 
      561      end bft_fetch;
      562 
      563 /**/
      564 
      565 /* *** Procedure: bft_load - Internal proc for bft *** */
      566 
      567 bft_load:
      568      proc ();
      569 
      570 /* PROCEDURE FUNCTION                                                             
      571*
      572*This calls the proper entrypoint to get BFT loaded into the CAT.  No arguments
      573*are required.
      574**/
      575 
      576 /* NOTES
      577**/
      578 
      579 /* PARAMETERS */
      580 
      581 /* MISC VARIABLES */
      582 dcl code		       fixed bin (35);	    /* Error code */
      583 
      584 /* STRUCTURES */
      585 
      586 /* INITIALIZATION */
      587 
      588 /* MAIN */
      589 
      590 /* Print a usage message if there is an invalid number  of args */
      591 
      592      if arg_count ^= 1 then do;
      593 	call com_err_ (error_table_$wrong_no_of_args, NAME);
      594 	call ioa_ (USAGE_LOAD);
      595 	return;
      596      end;
      597 
      598 /* Make call to proper entrypoint */
      599 
      600      call bft_$load (code);
      601      if (code ^= 0) then do;
      602 	if code = ws_error_$invalid_capability_name then
      603 	     code = bft_error_table_$bft_not_loaded;
      604 	call com_err_ (code, NAME, "While attempting to load BFT.");
      605 	return;
      606      end;
      607 
      608      end bft_load;
      609 
      610 /**/
      611 
      612 /* *** Procedure: bft_recover - Internal proc for bft *** */
      613 
      614 bft_recover:
      615      proc ();
      616 
      617 /* PROCEDURE FUNCTION                                                    
      618*
      619*This is the routine called if the argument was fetch_recover.  The purpose of
      620*this routine is to transmit the portion of a file that was previously
      621*interrupted.
      622**/
      623 
      624 /* NOTES
      625**/
      626 
      627 /* PARAMETERS */
      628 
      629 /* MISC VARIABLES */
      630 dcl code		       fixed bin (35);	    /* Error code */
      631 
      632 /* STRUCTURES */
      633 
      634 /* INITIALIZATION */
      635 
      636 /* MAIN */
      637 
      638 /* Print a usage message if there is an invalid number  of args */
      639 
      640      if arg_count ^= 1 then do;
      641 	call com_err_ (error_table_$wrong_no_of_args, NAME);
      642 	call ioa_ (USAGE_RECOVER);
      643 	return;
      644      end;
      645 
      646 /* Recover fetch operations */
      647 
      648      call bft_$recover_fetch (code);
      649      if (code ^= 0) then do;
      650 	if code = ws_error_$invalid_capability_name then
      651 	     code = bft_error_table_$bft_not_loaded;
      652 	call com_err_ (code, NAME, "Attempting to recover fetch.");
      653      end;
      654 
      655 /* Recover store operations */
      656 
      657      call bft_$recover_store (code);
      658      if (code ^= 0) then do;
      659 	if code = ws_error_$invalid_capability_name then
      660 	     code = bft_error_table_$bft_not_loaded;
      661 	call com_err_ (code, NAME, "Attempting to recover store.");
      662      end;
      663 
      664      end bft_recover;
      665 
      666 /**/
      667 
      668 /* *** Procedure: bft_store - Internal proc for bft *** */
      669 
      670 bft_store:
      671      proc ();
      672 
      673 /* PROCEDURE FUNCTION                                                            
      674*
      675*This routine is identical in function to the bft_fetch, except for the fact
      676*that it calls bft_$store.
      677**/
      678 
      679 /* NOTES
      680**/
      681 
      682 /* PARAMETERS */
      683 
      684 /* MISC VARIABLES */
      685 dcl code		       fixed bin (35);	    /* Error code */
      686 dcl passed	       fixed bin;		    /* Previous request submitted */
      687 dcl pc_path	       char (66);
      688 dcl mu_path	       char (168);
      689 
      690 /* STRUCTURES */
      691 
      692 /* INITIALIZATION */
      693      passed = 0;
      694 
      695 /* MAIN */
      696 
      697 /* Repeat until there are no more requests in the command line */
      698 
      699      do while (arg_pos < arg_count);
      700 
      701 /* Get the mu_path */
      702 
      703 	call get_arg ("0"b, code);
      704 	if code ^= 0 then do;
      705 	     if passed = 0 then
      706 		call com_err_ (code, NAME, arg);
      707 
      708 	     goto STORE_RETURN;
      709 	end;
      710 
      711 	mu_path = arg;
      712 	pc_path = "===";
      713 
      714 /* Look for the PC path, if not specified then assume mu_patjh */
      715 
      716 	call get_arg ("0"b, code);
      717 	if code ^= 0 & code ^= error_table_$noarg then do;
      718 	     call com_err_ (code, NAME, arg);
      719 	     goto STORE_RETURN;
      720 	end;
      721 	else if code = 0 then
      722 	     pc_path = arg;
      723 
      724 /* Call the bft_$store entrypoint with the valid parms */
      725 
      726 	call bft_$store (rtrim (mu_path), rtrim (pc_path), unspec (modes),
      727 	     priority, code);
      728 	if code ^= 0 then do;
      729 	     if code = ws_error_$invalid_capability_name then
      730 		code = bft_error_table_$bft_not_loaded;
      731 	     call com_err_ (code, NAME, "Issuing store request.");
      732 	     goto STORE_RETURN;
      733 	end;
      734 
      735 	passed = passed + 1;
      736      end;
      737 
      738 STORE_RETURN:
      739 
      740      if passed > 0 then
      741 	call ioa_ ("^a: ^d request^[s^] submitted for storing.", NAME,
      742 	     passed, (passed > 1));
      743 
      744      end bft_store;
      745 
      746 /**/
      747 
      748 /* *** Procedure: bft_unload - Internal proc for bft *** */
      749 
      750 bft_unload:
      751      proc ();
      752 
      753 /* PROCEDURE FUNCTION                                                           
      754*
      755*If the first argument was unload then this is the routine that is called.  This
      756*calls the necessary enttrypoint to have BFT deleted from the CAT.
      757**/
      758 
      759 /* NOTES
      760**/
      761 
      762 /* PARAMETERS */
      763 
      764 /* MISC VARIABLES */
      765 dcl code		       fixed bin (35);	    /* Error code */
      766 
      767 /* STRUCTURES */
      768 
      769 /* INITIALIZATION */
      770 
      771 /* MAIN */
      772 
      773 /* Print a usage message if there is an invalid number  of args */
      774 
      775      if arg_count ^= 1 then do;
      776 	call com_err_ (error_table_$wrong_no_of_args, NAME);
      777 	call ioa_ (USAGE_UNLOAD);
      778 	return;
      779      end;
      780 
      781 /* Call the proper entrypoint with the valid parameters */
      782 
      783      call bft_$unload (code);
      784      if (code ^= 0) then do;
      785 	if code = ws_error_$invalid_capability_name then
      786 	     code = bft_error_table_$bft_not_loaded;
      787 	call com_err_ (code, NAME, "While attempting to unload BFT.");
      788 	return;
      789      end;
      790 
      791      end bft_unload;
      792 
      793 /**/
      794 
      795 /* *** Procedure: get_arg - Internal proc for bft  *** */
      796 
      797 get_arg:
      798      proc (p_special, p_code);
      799 
      800 
      801 /* PROCEDURE FUNCTION
      802*
      803*Extract the next real argument from the argument list.
      804*If the p_special parameter is True, then accept the "-control_arg STR" as a
      805*"non-control" argument.
      806**/
      807 
      808 /* NOTES
      809**/
      810 
      811 /* PARAMETERS */
      812 dcl p_special	       bit(1) parameter;	    /* Accept "-ca STR " */
      813 dcl p_code	       fixed bin (35) parameter;  /* Error code */
      814 
      815 /* MISC VARIABLES */
      816 
      817 /* STRUCTURES */
      818 
      819 /* INITIALIZATION */
      820 
      821 /* MAIN */
      822      p_code = 0;
      823 
      824 /* Skip all control_args until a NON-control_arg is found */
      825 
      826      do while ("1"b);
      827 	arg_pos = arg_pos + 1;
      828 
      829 	if arg_pos > arg_count then do;
      830 	     p_code = error_table_$noarg;
      831 	     return;
      832 	end;
      833 
      834 	call cu_$arg_ptr_rel (arg_pos, arg_ptr, arg_len, p_code, main_arg_ptr);
      835 	if p_code ^= 0 then
      836 	     return;
      837 
      838 	if substr (arg, 1, 1) = "-" then do;
      839 	     if arg = "-entry" | arg = "-et"	    /* These are special */
      840 		| arg = "-id"
      841 	     then do;
      842 		if p_special then		    /* Caller wants this */
      843 		     return;
      844 		else			    /* Skip the param */
      845 		     arg_pos = arg_pos + 1;
      846 	     end;
      847 	     else if arg = "-queue" | arg = "-q"    /* Skip the param */
      848 		| arg = "-file_type" | arg = "-ft"
      849 	     then
      850 		arg_pos = arg_pos + 1;
      851 	     else				    /* No params */
      852 		;
      853 	end;
      854 	else
      855 	     return;
      856      end;
      857 
      858      end get_arg;
      859 
      860 /**/
      861 
      862 /* *** Procedure: parse_control_args - Internal proc for bft  *** */
      863 
      864 parse_control_args:
      865      proc (p_code, p_reason);
      866 
      867 
      868 /* PROCEDURE FUNCTION
      869*
      870*Skip through the command line arguments and extract control arguments.
      871*
      872*Control arguments extracted are:
      873*
      874*	-brief,		-bf
      875*	-notify,		-nt
      876*	-no_notify,	-nnt
      877*	-file_type TYPE,	-ft TYPE
      878*	-queue N,		-q N
      879*
      880*Control arguments "skipped" (as they are really a "single" argument):
      881*
      882*	-entry NAME,	-et NAME
      883*	-id ID
      884**/
      885 
      886 /* NOTES
      887**/
      888 
      889 /* PARAMETERS */
      890 dcl p_reason	       char (*) var parameter;    /* Error reason */
      891 dcl p_code	       fixed bin (35) parameter;  /* Error code */
      892 
      893 /* MISC VARIABLES */
      894 dcl temp_queue	       fixed bin;		    /* local queue value */
      895 
      896 /* STRUCTURES */
      897 
      898 /* INITIALIZATION */
      899      p_code = 0;
      900      p_reason = "";
      901 
      902 /* MAIN */
      903 
      904      do arg_pos = 1 to arg_count;
      905 	call cu_$arg_ptr_rel (arg_pos, arg_ptr, arg_len, p_code, main_arg_ptr);
      906 	if p_code ^= 0 then
      907 	     return;
      908 
      909 	if arg = "-file_type" | arg = "-ft" then do;
      910 	     if ^(store_sw | fetch_sw) then do;
      911 		p_code = error_table_$inconsistent;
      912 		return;
      913 	     end;
      914 
      915 	     arg_pos = arg_pos + 1;
      916 	     call cu_$arg_ptr_rel (arg_pos, arg_ptr, arg_len, p_code, main_arg_ptr);
      917 	     if p_code ^= 0 then
      918 		return;
      919 
      920 	     if arg = "binary" then
      921 		modes.binary_sw = "1"b;
      922 	     else if arg = "ascii" then
      923 		modes.binary_sw = "0"b;
      924 	     else do;
      925 		p_reason = arg;
      926 		p_code = bft_error_table_$invalid_file_type;
      927 		return;
      928 	     end;
      929 	end;
      930 
      931 	else if arg = "-long" | arg = "-lg" then do;
      932 	     if ^display_sw then do;
      933 		p_code = error_table_$inconsistent;
      934 		return;
      935 	     end;
      936 
      937 	     long_sw = "1"b;
      938 	end;
      939 
      940 	else if arg = "-brief" | arg = "-bf" then do;
      941 	     if ^display_sw then do;
      942 		p_code = error_table_$inconsistent;
      943 		return;
      944 	     end;
      945 
      946 	     long_sw = "0"b;
      947 	end;
      948 
      949 	else if arg = "-id" then do;
      950 	     if ^cancel_sw then do;
      951 		p_code = error_table_$inconsistent;
      952 		return;
      953 	     end;
      954 	end;
      955 
      956 	else if arg = "-entry" | arg = "-et" then do;
      957 	     if  ^cancel_sw then do;
      958 		p_code = error_table_$inconsistent;
      959 		return;
      960 	     end;
      961 	end;
      962 
      963 	else if arg = "-notify" | arg = "-nt" then do;
      964 	     if ^(fetch_sw | store_sw) then do;
      965 		p_code = error_table_$inconsistent;
      966 		return;
      967 	     end;
      968 
      969 	     modes.notify_sw = "1"b;
      970 	end;
      971 
      972 	else if arg = "-no_notify" | arg = "-nnt" then do;
      973 	     if ^(fetch_sw | store_sw) then do;
      974 		p_code = error_table_$inconsistent;
      975 		return;
      976 	     end;
      977 
      978 	     modes.notify_sw = "0"b;
      979 	end;
      980 
      981 	else if arg = "-queue" | arg = "-q" then do;
      982 	     if ^(store_sw | fetch_sw) then do;
      983 		p_code = error_table_$inconsistent;
      984 		return;
      985 	     end;
      986 
      987 	     arg_pos = arg_pos + 1;
      988 	     call cu_$arg_ptr_rel (arg_pos, arg_ptr, arg_len, p_code, main_arg_ptr);
      989 	     if p_code ^= 0 then
      990 		return;
      991 
      992 	     if arg_len ^= 1 then do;
      993 		p_reason = arg;
      994 		p_code = bft_error_table_$invalid_priority;
      995 		return;
      996 	     end;
      997 
      998 	     temp_queue = rank (substr (arg, 1, 1)) - rank ("0");
      999 	     if temp_queue < BFT_MIN_PRIORITY
     1000 		| temp_queue > BFT_MAX_PRIORITY
     1001 	     then do;
     1002 		p_reason = arg;
     1003 		p_code = bft_error_table_$invalid_priority;
     1004 		return;
     1005 	     end;
     1006 
     1007 	     priority = temp_queue;
     1008 	end;
     1009 
     1010 	else if substr (arg, 1, 1) = "-" then do;
     1011 	     p_code = error_table_$bad_arg;
     1012 	     reason = arg;
     1013 	     return;
     1014 	end;
     1015      end;
     1016 
     1017      end parse_control_args;
     1018 
     1019 /**/
     1020 
     1021 /* INCLUDE FILES */
  1     1 /*  BEGIN INCLUDE FILE: bft_queue.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(87-10-06,Flegel), approve(87-10-23,MCR7787),
  1     5*     audit(88-01-27,RWaters), install(88-02-24,MR12.2-1028):
  1     6*     Created.
  1     7*                                                   END HISTORY COMMENTS */
  1     8 
  1     9 
  1    10 /* format: style4,indattr,ifthen,^indcomtxt,thendo,^indproc,^indblkcom,^indprocbody,initcol1,declareind8,dclind4,struclvlind3,comcol55 */
  1    11 
  1    12 dcl BFT_QUEUE_VERSION_1    char (8) internal static options (constant)
  1    13 		       init ("VERSION1");
  1    14 dcl BFT_QUEUE_PRIORITIES   fixed bin internal static options (constant)
  1    15 		       init (4);
  1    16 dcl BFT_QUEUE_WAIT_TIME    fixed bin internal static options (constant)
  1    17 		       init (30);
  1    18 
  1    19 /* Queue */
  1    20 
  1    21 dcl queue_ptr	       ptr;
  1    22 dcl 01 queue	      based (queue_ptr) aligned,
  1    23        02 header	      like queue_header,
  1    24        02 array	      (queue.header.segment_size) like queue_element;
  1    25 
  1    26 /* Queue header */
  1    27 
  1    28 dcl 01 queue_header	       based,
  1    29        02 version	       char (8),		    /* Segment ID */
  1    30        02 lockword	       bit (36) aligned,	    /* Segment lock */
  1    31        02 store_queue      (4),		    /* Multics -> PC */
  1    32 	03 last	       fixed bin (35),	    /* Last element */
  1    33 	03 first	       fixed bin (35),	    /* Entry transferring */
  1    34 	03 flags,
  1    35 	   04 pad	       bit (36) unal,
  1    36        02 fetch_queue      (4),		    /* PC -> Multics */
  1    37 	03 last	       fixed bin (35),	    /* Last element */
  1    38 	03 first	       fixed bin (35),	    /* Entry transferring */
  1    39 	03 flags,
  1    40 	   04 pad	       bit (36) unal,
  1    41        02 storing	       like queue_element,	    /* Current store */
  1    42        02 store_file_pos   fixed bin (21),	    /* Position is send */
  1    43        02 fetching	       like queue_element,	    /* Current fetch */
  1    44        02 fetch_file_pos   fixed bin (21),	    /* Positin in fetch */
  1    45        02 free_list	       fixed bin (35),	    /* Free entries in Q */
  1    46        02 segment_size     fixed bin (35);	    /* Records in segment */
  1    47 
  1    48 /* Queue element definition */
  1    49 
  1    50 dcl 01 queue_element       based,
  1    51        02 next	       fixed bin (35),	    /* Next in Q */
  1    52        02 multics_path     char (168),		    /* Path on Multics */
  1    53        02 pc_path	       char (66),		    /* Drive:Path on PC */
  1    54        02 time_id	       fixed bin (71),	    /* Time stamp id */
  1    55        02 flags	       like bft_queue_flags,	    /* Entry switches */
  1    56        02 mbz	       bit (18);		    /* Word boundary size */
  1    57 
  1    58 /* We need the definitions for the queue flags */
  1    59 
  2     1 /*  BEGIN INCLUDE FILE: bft.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(87-11-16,Flegel), approve(87-11-16,MCR7787),
  2     6*     audit(88-01-27,RWaters), install(88-02-24,MR12.2-1028):
  2     7*     Created to provide access to flags structure for programs which call the
  2     8*     bft_$(fetch store) entrypoints.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 dcl BFT_MIN_PRIORITY      fixed bin int static options (constant) init (1);
  2    12 dcl BFT_MAX_PRIORITY      fixed bin int static options (constant) init (4);
  2    13 dcl BFT_PATH_ID	      fixed bin int static options (constant) init (32);
  2    14 dcl BFT_TIME_ID	      fixed bin int static options (constant) init (33);
  2    15 dcl BFT_ENTRY_ID	      fixed bin int static options (constant) init (34);
  2    16 
  2    17 /* BFT queue flags / switches;
  2    18*   NOTE that the pad and mbz are first, this is because a conversion routine
  2    19*   to convert significant bits to a respective character string assumes that
  2    20*   the bit string is RIGHT JUSTIFIED (this is to allow the accepting of
  2    21*   numerical values - eg. fixed bin */
  2    22 
  2    23 dcl 01 bft_queue_flags  based,
  2    24        02 mbz	    bit (4) unal,		    /* System word adjust */
  2    25        02 pad	    bit (28) unal,		    /* Future expansion */
  2    26        02 allocated     bit (1) unal,		    /* Is this an entry? */
  2    27        02 initiated     bit (1) unal,		    /* Transfer in progress */
  2    28        02 binary_sw     bit (1) unal,		    /* Binary file_type */
  2    29        02 notify_sw     bit (1) unal;		    /* If a notify is to be done */
  2    30 
  2    31 /*  END INCLUDE FILE: bft.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
  1    60 
  1    61 
  1    62 /*  END INCLUDE FILE: bft_queue.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1022 
  3     1 /*  BEGIN INCLUDE FILE: bft_values.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(87-07-15,Flegel), approve(87-07-15,MCR7580),
  3     6*     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
  3     7*     Created.
  3     8*  2) change(87-10-23,Flegel), approve(87-10-23,MCR7787),
  3     9*     audit(88-01-27,RWaters), install(88-02-24,MR12.2-1028):
  3    10*     Converted to use with new queueing strategy;  added data_block structure;
  3    11*                                                   END HISTORY COMMENTS */
  3    12 
  3    13 /* format: style4,indattr,ifthen,^indcomtxt,thendo,^indproc,^indblkcom,initcol1,declareind8,dclind4,struclvlind3,comcol55 */
  3    14 
  3    15 dcl bft_minor_$add_to_fetch_queue fixed bin int static options (constant) init (64);
  3    16 dcl bft_minor_$add_to_store_queue fixed bin int static options (constant) init (65);
  3    17 dcl bft_minor_$check_file_length fixed bin int static options (constant) init (66);
  3    18 dcl bft_minor_$initiate_fetch fixed bin int static options (constant) init (67);
  3    19 dcl bft_minor_$bft_shut_down fixed bin int static options (constant) init (68);
  3    20 dcl bft_minor_$position_file_pointer fixed bin int static options (constant) init (69);
  3    21 dcl bft_minor_$receive_data fixed bin int static options (constant) init (70);
  3    22 dcl bft_minor_$receive_eof fixed bin int static options (constant) init (71);
  3    23 dcl bft_minor_$recover_fetch fixed bin int static options (constant) init (72);
  3    24 dcl bft_minor_$recover_store fixed bin int static options (constant) init (73);
  3    25 dcl bft_minor_$read_error fixed bin int static options (constant) init (74);
  3    26 dcl bft_minor_$initiate_store fixed bin int static options (constant) init (75);
  3    27 dcl bft_minor_$write_error fixed bin int static options (constant) init (76);
  3    28 dcl bft_minor_$send_data   fixed bin int static options (constant) init (77);
  3    29 dcl bft_minor_$cancel_request fixed bin int static options (constant) init (78);
  3    30 dcl bft_minor_$expand_pc_path fixed bin int static options (constant) init (80);
  3    31 dcl bft_minor_$full_pc_path fixed bin int static options (constant) init (81);
  3    32 
  3    33 
  3    34 dcl BFT_MINOR_CAPS	       fixed bin int static options (constant) init (13);
  3    35 dcl BFT_INBUFFER_SIZE      fixed bin int static options (constant) init (128);
  3    36 dcl BFT_OUTBUFFER_SIZE     fixed bin int static options (constant) init (128);
  3    37 dcl BFT_BLOCK_SIZE	       fixed bin (21) int static options (constant) init (110);
  3    38 dcl BFT_FIRST	       char (1) int static options (constant) init (" ");
  3    39 dcl BFT_NEXT	       char (1) int static options (constant) init ("!");
  3    40 dcl DELIM_CHAR	       char (1) based (addr (DEL));
  3    41 dcl DEL		       bit (9) unaligned internal static
  3    42 		       options (constant) init ("011111111"b);
  3    43 
  3    44 dcl 01 bft_values_struct,
  3    45        02 destination_filename char (164),
  3    46        02 source_filename  char (164);
  3    47 
  3    48 /* New declarations for queueing */
  3    49 
  3    50 dcl BFT_PC_to_MULTICS     fixed bin internal static options (constant)
  3    51 		      init (32);
  3    52 dcl BFT_MULTICS_to_PC     fixed bin internal static options (constant)
  3    53 		      init (33);
  3    54 dcl BFT_DATA_BLOCK_VERSION_1 char (8) internal static options (constant)
  3    55 		      init ("VERSION1");
  3    56 dcl BFT_INBUFF_LENGTH     fixed bin internal static options (constant)
  3    57 		      init (128);
  3    58 dcl BFT_OUTBUFF_LENGTH    fixed bin internal static options (constant)
  3    59 		      init (128);
  3    60 
  3    61 dcl data_block_ptr	      ptr;		    /* Data to be kept around */
  3    62 dcl 01 data_block	      based (data_block_ptr),
  3    63        02 version	      char (8),		    /* Version ID */
  3    64        02 pc_bft_num      fixed bin,		    /* Major of PC:BFT */
  3    65        02 inbuff_len      fixed bin,		    /* Input buffer length */
  3    66        02 outbuff_len     fixed bin,		    /* Output buffer length */
  3    67        02 receive_iocb_ptr ptr,		    /* IOCB of receiving file */
  3    68        02 send_iocb_ptr   ptr,		    /* IOCB of sending file */
  3    69        02 system_free_area_ptr ptr,		    /* Pointer to sys free */
  3    70        02 fetch_pending   ptr,		    /* Fetch waiting for PC path */
  3    71        02 store_pending   ptr,		    /* Store waiting for PC path */
  3    72        02 queue_ptr	      ptr,		    /* BFT queue segment */
  3    73        02 flags,
  3    74 	03 shut_down_sw bit (1) unal,		    /* BFT is shutting down */
  3    75 	03 pad	      bit (35) unal;
  3    76 
  3    77 /* Structure to contain transfer requests awaiting a PC path expansion */
  3    78 
  3    79 dcl 01 pending	      based,
  3    80        02 multics_path    char (168),		    /* Multics path */
  3    81        02 pc_path	      char (66),		    /* PC path */
  3    82        02 flags	      bit(36),		    /* Transfer modes */
  3    83        02 switches,
  3    84 	03 processing_sw bit (1) unal,	    /* Waiting for PC answer */
  3    85 	03 first_sw     bit (1) unal,		    /* First match requested */
  3    86 	03 pad	      bit (34) unal,
  3    87        02 priority	      fixed bin,		    /* Priority */
  3    88        02 id	      fixed bin,		    /* Request ID */
  3    89        02 next	      ptr;		    /* Next in chain */
  3    90 
  3    91 /*  END INCLUDE FILE: bft_values.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1023 
     1024 
     1025      end bft;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/24/88  0843.5  bft.pl1                           >special_ldd>install>MR12.2-1028>bft.pl1
1022         1    02/24/88  0843.7  bft_queue.incl.pl1                >special_ldd>install>MR12.2-1028>bft_queue.incl.pl1
1-60         2    02/24/88  0843.9  bft.incl.pl1                      >special_ldd>install>MR12.2-1028>bft.incl.pl1
1023         3    02/24/88  0846.4  bft_values.incl.pl1               >special_ldd>install>MR12.2-1028>bft_values.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BFT_ENTRY_ID                    000000 constant        fixed bin(17,0)          initial dcl 2-15 set ref 292*
BFT_MAX_PRIORITY                       constant        fixed bin(17,0)          initial dcl 2-12 ref 360 418 999
BFT_MIN_PRIORITY                       constant        fixed bin(17,0)          initial dcl 2-11 ref 360 418 999
BFT_MULTICS_to_PC               000001 constant        fixed bin(17,0)          initial dcl 3-52 set ref 382* 394* 408*
BFT_PATH_ID                     000002 constant        fixed bin(17,0)          initial dcl 2-13 set ref 280*
BFT_PC_to_MULTICS               000002 constant        fixed bin(17,0)          initial dcl 3-50 set ref 433* 443* 454*
BFT_TIME_ID                     000001 constant        fixed bin(17,0)          initial dcl 2-14 set ref 290*
NAME                            000250 constant        char(3)                  initial packed unaligned dcl 111 set ref 145* 154*
                                                                                  161* 171* 207* 216* 271* 273* 286* 299* 308* 352*
                                                                                  510* 523* 534* 545* 555* 593* 604* 641* 652* 661*
                                                                                  705* 718* 731* 738* 776* 787*
USAGE_BFT                       000044 constant        varying char(128)        initial dcl 116 set ref 162* 172*
USAGE_KEYS                      000003 constant        varying char(128)        initial dcl 117 set ref 208*
USAGE_LOAD                      000105 constant        varying char(128)        initial dcl 115 set ref 594*
USAGE_RECOVER                   000146 constant        varying char(128)        initial dcl 114 set ref 642*
USAGE_UNLOAD                    000207 constant        varying char(128)        initial dcl 113 set ref 777*
absolute_pathname_              000014 constant        entry                    external dcl 70 ref 532
addr                                                   builtin function         dcl 105 ref 382 382 394 394 408 408 433 433 443 443
                                                                                  454 454
arg                                    based           char                     packed unaligned dcl 62 set ref 178 178 182 182 186
                                                                                  186 186 190 190 194 194 198 198 202 202 202 207*
                                                                                  271* 280 280* 283 290* 292* 299* 510* 516 523* 526
                                                                                  705* 711 718* 721 838 839 839 839 847 847 847 847
                                                                                  909 909 920 922 925 931 931 940 940 949 956 956
                                                                                  963 963 972 972 981 981 993 998 1002 1010 1012
arg_count                       000223 automatic       fixed bin(17,0)          dcl 59 set ref 152* 160 268 504 592 640 699 775 829
                                                                                  904
arg_len                         000224 automatic       fixed bin(21,0)          dcl 60 set ref 178 178 182 182 186 186 186 190 190
                                                                                  194 194 198 198 202 202 202 207 207 271 271 280
                                                                                  280 280 283 290 290 292 292 299 299 510 510 516
                                                                                  523 523 526 705 705 711 718 718 721 834* 838 839
                                                                                  839 839 847 847 847 847 905* 909 909 916* 920 922
                                                                                  925 931 931 940 940 949 956 956 963 963 972 972
                                                                                  981 981 988* 992 993 998 1002 1010 1012
arg_pos                         000222 automatic       fixed bin(17,0)          dcl 58 set ref 168* 223* 268 504 699 827* 827 829
                                                                                  834* 844* 844 847* 847 904* 905* 915* 915 916*
                                                                                  987* 987 988*
arg_ptr                         000226 automatic       pointer                  dcl 61 set ref 178 178 182 182 186 186 186 190 190
                                                                                  194 194 198 198 202 202 202 207 271 280 280 283
                                                                                  290 292 299 510 516 523 526 705 711 718 721 834*
                                                                                  838 839 839 839 847 847 847 847 905* 909 909 916*
                                                                                  920 922 925 931 931 940 940 949 956 956 963 963
                                                                                  972 972 981 981 988* 993 998 1002 1010 1012
array                   242            based           structure                array level 2 dcl 1-22 set ref 394 394 443 443
bft_$cancel                     000036 constant        entry                    external dcl 83 ref 280 290 292
bft_$fetch                      000044 constant        entry                    external dcl 86 ref 540
bft_$load                       000046 constant        entry                    external dcl 87 ref 600
bft_$recover_fetch              000050 constant        entry                    external dcl 88 ref 648
bft_$recover_store              000052 constant        entry                    external dcl 89 ref 657
bft_$store                      000054 constant        entry                    external dcl 90 ref 726
bft_$unload                     000056 constant        entry                    external dcl 91 ref 783
bft_error_table_$bft_not_loaded 000066 external static fixed bin(35,0)          dcl 97 ref 543 602 650 659 729 785
bft_error_table_$invalid_file_type
                                000060 external static fixed bin(35,0)          dcl 94 ref 926
bft_error_table_$invalid_keyword
                                000062 external static fixed bin(35,0)          dcl 95 set ref 207*
bft_error_table_$invalid_priority
                                000064 external static fixed bin(35,0)          dcl 96 ref 994 1003
bft_queue_$display_element      000040 constant        entry                    external dcl 84 ref 382 394 408 433 443 454
bft_queue_$initiate             000042 constant        entry                    external dcl 85 ref 350
bft_queue_flags                        based           structure                level 1 packed packed unaligned dcl 2-23
binary_sw                 0(34) 000230 automatic       bit(1)                   level 2 packed packed unaligned dcl 63 set ref 920*
                                                                                  922*
cancel_sw                       000214 automatic       bit(1)                   packed unaligned dcl 54 set ref 131* 180* 950 957
code                            000100 automatic       fixed bin(35,0)          dcl 685 in procedure "bft_store" set ref 703* 704
                                                                                  705* 716* 717 717 718* 721 726* 728 729 729* 731*
code                            000100 automatic       fixed bin(35,0)          dcl 489 in procedure "bft_fetch" set ref 508* 509
                                                                                  510* 521* 522 522 523* 526 532* 533 534* 540* 542
                                                                                  543 543* 545*
code                            000101 automatic       fixed bin(35,0)          dcl 336 in procedure "bft_display" set ref 350* 351
                                                                                  352*
code                            000100 automatic       fixed bin(35,0)          dcl 765 in procedure "bft_unload" set ref 783* 784
                                                                                  785 785* 787*
code                            000205 automatic       fixed bin(35,0)          dcl 45 in procedure "background_file_transfer" set
                                                                                  ref 152* 153 154* 169* 170 171* 214* 215 216*
code                            000100 automatic       fixed bin(35,0)          dcl 582 in procedure "bft_load" set ref 600* 601 602
                                                                                  602* 604*
code                            000100 automatic       fixed bin(35,0)          dcl 630 in procedure "bft_recover" set ref 648* 649
                                                                                  650 650* 652* 657* 658 659 659* 661*
code                            000111 automatic       fixed bin(35,0)          dcl 256 in procedure "bft_cancel" set ref 269* 270
                                                                                  271* 273* 280* 284* 285 286* 290* 292* 298 299*
com_err_                        000022 constant        entry                    external dcl 73 ref 145 154 161 171 207 216 271 273
                                                                                  286 299 352 510 523 534 545 593 604 641 652 661
                                                                                  705 718 731 776 787
count                           000106 automatic       fixed bin(21,0)          dcl 341 set ref 364* 367* 367 373 375 375 419* 422*
                                                                                  422 426 428 428
cu_$arg_count                   000020 constant        entry                    external dcl 72 ref 152
cu_$arg_list_ptr                000010 constant        entry                    external dcl 68 ref 143
cu_$arg_ptr_rel                 000016 constant        entry                    external dcl 71 ref 834 905 916 988
display_sw                      000206 automatic       bit(1)                   packed unaligned dcl 48 set ref 137* 192* 932 941
empty_sw                        000104 automatic       bit(1)                   packed unaligned dcl 339 set ref 346* 374* 386* 394*
                                                                                  396* 410* 427* 437* 443* 445* 456* 462
error_table_$bad_arg            000032 external static fixed bin(35,0)          dcl 79 ref 1011
error_table_$inconsistent       000026 external static fixed bin(35,0)          dcl 77 ref 911 933 942 951 958 965 974 983
error_table_$noarg              000030 external static fixed bin(35,0)          dcl 78 ref 522 717 830
error_table_$nodescr            000024 external static fixed bin(35,0)          dcl 76 set ref 145*
error_table_$wrong_no_of_args   000034 external static fixed bin(35,0)          dcl 80 set ref 161* 593* 641* 776*
fetch_queue              17            based           structure                array level 3 dcl 1-22
fetch_sw                        000213 automatic       bit(1)                   packed unaligned dcl 53 set ref 132* 184* 910 964
                                                                                  973 982
fetching                136            based           structure                level 3 dcl 1-22 set ref 433 433 454 454
first                    20            based           fixed bin(35,0)          array level 4 in structure "queue" dcl 1-22
                                                                                  in procedure "background_file_transfer" ref 420
                                                                                  441
first                     4            based           fixed bin(35,0)          array level 4 in structure "queue" dcl 1-22
                                                                                  in procedure "background_file_transfer" ref 365
                                                                                  392
flags                   234            based           structure                level 4 in structure "queue" dcl 1-22 in procedure
                                                                                  "background_file_transfer"
flags                   132            based           structure                level 4 in structure "queue" dcl 1-22 in procedure
                                                                                  "background_file_transfer"
header                                 based           structure                level 2 dcl 1-22
i                               000103 automatic       fixed bin(17,0)          dcl 338 set ref 360* 365 375* 392* 418* 420 428*
                                                                                  441*
initiated               132(33)        based           bit(1)                   level 5 in structure "queue" packed packed unaligned
                                                                                  dcl 1-22 in procedure "background_file_transfer"
                                                                                  set ref 381 406
initiated               234(33)        based           bit(1)                   level 5 in structure "queue" packed packed unaligned
                                                                                  dcl 1-22 in procedure "background_file_transfer"
                                                                                  set ref 432 452
ioa_                            000012 constant        entry                    external dcl 69 ref 162 172 208 308 375 384 398 407
                                                                                  428 435 447 453 462 464 555 594 642 738 777
key_procedure                   000100 automatic       entry variable           dcl 43 set ref 179* 183* 187* 191* 195* 199* 203*
                                                                                  225
load_sw                         000212 automatic       bit(1)                   packed unaligned dcl 52 set ref 133* 188*
long_sw                         000216 automatic       bit(1)                   packed unaligned dcl 56 set ref 127* 382* 384 394*
                                                                                  398 408* 433* 435 443* 447 454* 937* 946*
main_arg_ptr                    000220 automatic       pointer                  dcl 57 set ref 143* 144 834* 905* 916* 988*
modes                           000230 automatic       structure                level 1 dcl 63 set ref 126* 540 540 726 726
mu_path                         000154 automatic       char(168)                packed unaligned dcl 492 in procedure "bft_fetch"
                                                                                  set ref 517* 526* 531 532* 540 540
mu_path                         000123 automatic       char(168)                packed unaligned dcl 688 in procedure "bft_store"
                                                                                  set ref 711* 726 726
next                    242            based           fixed bin(35,0)          array level 3 dcl 1-22 set ref 368 397 423 446
notify_sw                 0(35) 000230 automatic       bit(1)                   level 2 packed packed unaligned dcl 63 set ref 969*
                                                                                  978*
null                                                   builtin function         dcl 101 ref 144
p_code                                 parameter       fixed bin(35,0)          dcl 891 in procedure "parse_control_args" set ref
                                                                                  864 899* 905* 906 911* 916* 917 926* 933* 942*
                                                                                  951* 958* 965* 974* 983* 988* 989 994* 1003* 1011*
p_code                                 parameter       fixed bin(35,0)          dcl 813 in procedure "get_arg" set ref 797 822* 830*
                                                                                  834* 835
p_reason                               parameter       varying char             dcl 890 set ref 864 900* 925* 993* 1002*
p_special                              parameter       bit(1)                   packed unaligned dcl 812 ref 797 842
passed                          000101 automatic       fixed bin(17,0)          dcl 686 in procedure "bft_store" set ref 693* 705
                                                                                  735* 735 738 738* 738
passed                          000101 automatic       fixed bin(17,0)          dcl 490 in procedure "bft_fetch" set ref 498* 510
                                                                                  552* 552 555 555* 555
passed                          000112 automatic       fixed bin(17,0)          dcl 257 in procedure "bft_cancel" set ref 262* 271
                                                                                  305* 305 308 308* 308
pc_path                         000226 automatic       char(66)                 packed unaligned dcl 493 in procedure "bft_fetch"
                                                                                  set ref 516* 540 540
pc_path                         000102 automatic       char(66)                 packed unaligned dcl 687 in procedure "bft_store"
                                                                                  set ref 712* 721* 726 726
priority                        000215 automatic       fixed bin(17,0)          dcl 55 set ref 125* 540* 726* 1007*
queue                                  based           structure                level 1 dcl 1-22
queue_element                          based           structure                level 1 unaligned dcl 1-50
queue_header                           based           structure                level 1 unaligned dcl 1-28
queue_ptr                       000232 automatic       pointer                  dcl 1-21 set ref 350* 365 368 381 382 382 392 394
                                                                                  394 397 406 408 408 420 423 432 433 433 441 443
                                                                                  443 446 452 454 454
rank                                                   builtin function         dcl 104 ref 998 998
reason                          000104 automatic       varying char(256)        dcl 44 set ref 214* 216* 1012*
recover_sw                      000211 automatic       bit(1)                   packed unaligned dcl 51 set ref 134* 196*
request_type                    000100 automatic       varying char(32)         dcl 255 set ref 283* 290 292 292
rtrim                                                  builtin function         dcl 106 ref 540 540 540 540 726 726 726 726
running                         000102 automatic       bit(1)                   packed unaligned dcl 337 set ref 358* 381 387* 406
                                                                                  411* 416* 432 438* 452 457*
running_count                   000100 automatic       fixed bin(17,0)          dcl 335 set ref 359* 375 375 377* 417* 428 428 430*
slot                            000105 automatic       fixed bin(35,0)          dcl 340 set ref 365* 366 368* 368 392* 393 394 394
                                                                                  397* 397 398 420* 421 423* 423 441* 442 443 443
                                                                                  446* 446 447
store_queue               3            based           structure                array level 3 dcl 1-22
store_sw                        000210 automatic       bit(1)                   packed unaligned dcl 50 set ref 135* 200* 910 964
                                                                                  973 982
storing                  34            based           structure                level 3 dcl 1-22 set ref 382 382 408 408
substr                                                 builtin function         dcl 103 ref 280 838 998 1010
temp_file                       000102 automatic       char(168)                packed unaligned dcl 491 set ref 531* 532*
temp_queue                      000242 automatic       fixed bin(17,0)          dcl 894 set ref 998* 999 999 1007
unload_sw                       000207 automatic       bit(1)                   packed unaligned dcl 49 set ref 136* 204*
unspec                                                 builtin function         dcl 102 set ref 126* 540 540 726 726
ws_error_$invalid_capability_name
                                000070 external static fixed bin(35,0)          dcl 98 ref 543 602 650 659 729 785

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BFT_BLOCK_SIZE                         internal static fixed bin(21,0)          initial dcl 3-37
BFT_DATA_BLOCK_VERSION_1               internal static char(8)                  initial packed unaligned dcl 3-54
BFT_FIRST                              internal static char(1)                  initial packed unaligned dcl 3-38
BFT_INBUFFER_SIZE                      internal static fixed bin(17,0)          initial dcl 3-35
BFT_INBUFF_LENGTH                      internal static fixed bin(17,0)          initial dcl 3-56
BFT_MINOR_CAPS                         internal static fixed bin(17,0)          initial dcl 3-34
BFT_NEXT                               internal static char(1)                  initial packed unaligned dcl 3-39
BFT_OUTBUFFER_SIZE                     internal static fixed bin(17,0)          initial dcl 3-36
BFT_OUTBUFF_LENGTH                     internal static fixed bin(17,0)          initial dcl 3-58
BFT_QUEUE_PRIORITIES                   internal static fixed bin(17,0)          initial dcl 1-14
BFT_QUEUE_VERSION_1                    internal static char(8)                  initial packed unaligned dcl 1-12
BFT_QUEUE_WAIT_TIME                    internal static fixed bin(17,0)          initial dcl 1-16
DEL                                    internal static bit(9)                   initial packed unaligned dcl 3-41
DELIM_CHAR                             based           char(1)                  packed unaligned dcl 3-40
USAGE_CANCEL                           internal static varying char(128)        initial dcl 112
bft_minor_$add_to_fetch_queue          internal static fixed bin(17,0)          initial dcl 3-15
bft_minor_$add_to_store_queue          internal static fixed bin(17,0)          initial dcl 3-16
bft_minor_$bft_shut_down               internal static fixed bin(17,0)          initial dcl 3-19
bft_minor_$cancel_request              internal static fixed bin(17,0)          initial dcl 3-29
bft_minor_$check_file_length           internal static fixed bin(17,0)          initial dcl 3-17
bft_minor_$expand_pc_path              internal static fixed bin(17,0)          initial dcl 3-30
bft_minor_$full_pc_path                internal static fixed bin(17,0)          initial dcl 3-31
bft_minor_$initiate_fetch              internal static fixed bin(17,0)          initial dcl 3-18
bft_minor_$initiate_store              internal static fixed bin(17,0)          initial dcl 3-26
bft_minor_$position_file_pointer       internal static fixed bin(17,0)          initial dcl 3-20
bft_minor_$read_error                  internal static fixed bin(17,0)          initial dcl 3-25
bft_minor_$receive_data                internal static fixed bin(17,0)          initial dcl 3-21
bft_minor_$receive_eof                 internal static fixed bin(17,0)          initial dcl 3-22
bft_minor_$recover_fetch               internal static fixed bin(17,0)          initial dcl 3-23
bft_minor_$recover_store               internal static fixed bin(17,0)          initial dcl 3-24
bft_minor_$send_data                   internal static fixed bin(17,0)          initial dcl 3-28
bft_minor_$write_error                 internal static fixed bin(17,0)          initial dcl 3-27
bft_values_struct                      automatic       structure                level 1 packed packed unaligned dcl 3-44
data_block                             based           structure                level 1 unaligned dcl 3-62
data_block_ptr                         automatic       pointer                  dcl 3-61
pending                                based           structure                level 1 unaligned dcl 3-79

NAMES DECLARED BY EXPLICIT CONTEXT.
CANCEL_RETURN                   001643 constant        label                    dcl 308 ref 275 300
FETCH_RETURN                    003203 constant        label                    dcl 555 ref 513 524 535 547
STORE_RETURN                    004005 constant        label                    dcl 738 ref 708 719 732
background_file_transfer        000604 constant        entry                    external dcl 11
bft                             000614 constant        entry                    external dcl 11
bft_cancel                      001313 constant        entry                    internal dcl 240 ref 179
bft_display                     001702 constant        entry                    internal dcl 320 ref 191
bft_fetch                       002632 constant        entry                    internal dcl 473 ref 183
bft_load                        003242 constant        entry                    internal dcl 567 ref 187
bft_recover                     003344 constant        entry                    internal dcl 614 ref 195
bft_store                       003506 constant        entry                    internal dcl 670 ref 199
bft_unload                      004044 constant        entry                    internal dcl 750 ref 203
get_arg                         004146 constant        entry                    internal dcl 797 ref 169 224 269 284 508 521 703 716
parse_control_args              004272 constant        entry                    internal dcl 864 ref 214

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5400        5472    5004        5410
Length      6044    5004        72         336     374           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
background_file_transfer            205 external procedure  is an external procedure.  
bft_cancel                          116 internal procedure  is assigned to an entry variable.  
bft_display                         116 internal procedure  is assigned to an entry variable.  
bft_fetch                           220 internal procedure  is assigned to an entry variable.  
bft_load                             90 internal procedure  is assigned to an entry variable.  
bft_recover                          90 internal procedure  is assigned to an entry variable.  
bft_store                           178 internal procedure  is assigned to an entry variable.  
bft_unload                           90 internal procedure  is assigned to an entry variable.  
get_arg                              76 internal procedure  is called by several nonquick procedures.  
parse_control_args                      internal procedure  shares stack frame of external procedure background_file_transfer.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
background_file_transfer 000100 key_procedure               background_file_transfer
                         000104 reason                      background_file_transfer
                         000205 code                        background_file_transfer
                         000206 display_sw                  background_file_transfer
                         000207 unload_sw                   background_file_transfer
                         000210 store_sw                    background_file_transfer
                         000211 recover_sw                  background_file_transfer
                         000212 load_sw                     background_file_transfer
                         000213 fetch_sw                    background_file_transfer
                         000214 cancel_sw                   background_file_transfer
                         000215 priority                    background_file_transfer
                         000216 long_sw                     background_file_transfer
                         000220 main_arg_ptr                background_file_transfer
                         000222 arg_pos                     background_file_transfer
                         000223 arg_count                   background_file_transfer
                         000224 arg_len                     background_file_transfer
                         000226 arg_ptr                     background_file_transfer
                         000230 modes                       background_file_transfer
                         000232 queue_ptr                   background_file_transfer
                         000242 temp_queue                  parse_control_args
bft_cancel               000100 request_type                bft_cancel
                         000111 code                        bft_cancel
                         000112 passed                      bft_cancel
bft_display              000100 running_count               bft_display
                         000101 code                        bft_display
                         000102 running                     bft_display
                         000103 i                           bft_display
                         000104 empty_sw                    bft_display
                         000105 slot                        bft_display
                         000106 count                       bft_display
bft_fetch                000100 code                        bft_fetch
                         000101 passed                      bft_fetch
                         000102 temp_file                   bft_fetch
                         000154 mu_path                     bft_fetch
                         000226 pc_path                     bft_fetch
bft_load                 000100 code                        bft_load
bft_recover              000100 code                        bft_recover
bft_store                000100 code                        bft_store
                         000101 passed                      bft_store
                         000102 pc_path                     bft_store
                         000123 mu_path                     bft_store
bft_unload               000100 code                        bft_unload

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               alloc_char_temp     call_ent_var        call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return_mac          shorten_stack       ext_entry           int_entry           return_main
set_main_flag

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            bft_$cancel                   bft_$fetch                    bft_$load
bft_$recover_fetch            bft_$recover_store            bft_$store                    bft_$unload
bft_queue_$display_element    bft_queue_$initiate           com_err_                      cu_$arg_count
cu_$arg_list_ptr              cu_$arg_ptr_rel               ioa_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bft_error_table_$bft_not_loaded                             bft_error_table_$invalid_file_type
bft_error_table_$invalid_keyword                            bft_error_table_$invalid_priority
error_table_$bad_arg          error_table_$inconsistent     error_table_$noarg            error_table_$nodescr
error_table_$wrong_no_of_args ws_error_$invalid_capability_name




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000603       125 000621       126 000623       127 000624       131 000625       132 000626       133 000627
    134 000630       135 000631       136 000632       137 000633       143 000634       144 000642       145 000646
    147 000672       152 000673       153 000704       154 000706       155 000732       160 000733       161 000735
    162 000752       163 000763       168 000764       169 000765       170 000777       171 001001       172 001016
    173 001027       178 001030       179 001042       180 001045       181 001047       182 001050       183 001060
    184 001063       185 001065       186 001066       187 001102       188 001105       189 001107       190 001110
    191 001120       192 001123       193 001125       194 001126       195 001136       196 001141       197 001143
    198 001144       199 001154       200 001157       201 001161       202 001162       203 001176       204 001201
    205 001203       207 001204       208 001230       209 001241       214 001242       215 001245       216 001247
    217 001270       223 001271       224 001272       225 001305       227 001311       240 001312       262 001320
    268 001321       269 001326       270 001341       271 001343       273 001373       275 001410       280 001411
    283 001444       284 001454       285 001467       286 001471       287 001506       290 001507       292 001542
    298 001601       299 001603       300 001640       305 001641       306 001642       308 001643       314 001700
    320 001701       346 001707       350 001711       351 001722       352 001724       353 001753       358 001754
    359 001755       360 001757       364 001767       365 001770       366 001775       367 002000       368 002001
    369 002006       373 002007       374 002011       375 002013       377 002052       381 002053       382 002062
    384 002106       386 002117       387 002121       392 002123       393 002131       394 002134       396 002164
    397 002166       398 002173       400 002205       402 002206       406 002210       407 002217       408 002233
    410 002262       411 002264       416 002266       417 002267       418 002271       419 002301       420 002302
    421 002307       422 002312       423 002313       424 002320       426 002321       427 002323       428 002325
    430 002364       432 002365       433 002374       435 002420       437 002431       438 002433       441 002435
    442 002443       443 002446       445 002476       446 002500       447 002505       449 002517       451 002520
    452 002522       453 002531       454 002550       456 002577       457 002601       462 002603       464 002623
    467 002630       473 002631       498 002637       504 002640       508 002644       509 002657       510 002661
    513 002710       516 002711       517 002717       521 002722       522 002735       523 002742       524 002766
    526 002767       531 002777       532 003002       533 003022       534 003024       535 003050       540 003051
    542 003145       543 003150       545 003155       547 003200       552 003201       553 003202       555 003203
    561 003240       567 003241       592 003247       593 003253       594 003267       595 003300       600 003301
    601 003307       602 003311       604 003316       605 003341       608 003342       614 003343       640 003351
    641 003355       642 003371       643 003402       648 003403       649 003411       650 003413       652 003420
    657 003443       658 003452       659 003454       661 003461       664 003504       670 003505       693 003513
    699 003514       703 003520       704 003533       705 003535       708 003564       711 003565       712 003573
    716 003576       717 003611       718 003616       719 003642       721 003643       726 003653       728 003747
    729 003752       731 003757       732 004002       735 004003       736 004004       738 004005       744 004042
    750 004043       775 004051       776 004055       777 004071       778 004102       783 004103       784 004111
    785 004113       787 004120       788 004143       791 004144       797 004145       822 004153       826 004155
    827 004156       829 004160       830 004163       831 004167       834 004170       835 004210       838 004213
    839 004221       842 004236       844 004243       846 004244       847 004245       853 004266       854 004267
    856 004270       858 004271       864 004272       899 004303       900 004305       904 004307       905 004317
    906 004337       909 004343       910 004355       911 004361       912 004364       915 004365       916 004366
    917 004405       920 004411       922 004422       925 004431       926 004442       927 004445       929 004446
    931 004447       932 004457       933 004461       934 004464       937 004465       938 004467       940 004470
    941 004500       942 004502       943 004505       946 004506       947 004510       949 004511       950 004515
    951 004517       952 004522       954 004523       956 004524       957 004534       958 004536       959 004541
    961 004542       963 004543       964 004553       965 004557       966 004562       969 004563       970 004565
    972 004566       973 004576       974 004602       975 004605       978 004606       979 004610       981 004611
    982 004621       983 004625       984 004630       987 004631       988 004632       989 004651       992 004655
    993 004660       994 004671       995 004674       998 004675       999 004707      1002 004713      1003 004724
   1004 004727      1007 004730      1008 004731      1010 004732      1011 004736      1012 004741      1013 004751
   1015 004752      1017 004754


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
