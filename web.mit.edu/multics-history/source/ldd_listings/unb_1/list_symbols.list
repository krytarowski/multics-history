	COMPILATION LISTING OF SEGMENT list_symbols
	Compiled by: Multics PL/I Compiler, Release 26a, of September 3, 1980
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 01/06/81  1247.4 mst Tue
	    Options: optimize map

        1 /* ******************************************************
        2*   *                                                    *
        3*   *                                                    *
        4*   *    Copyright, (C) Honeywell Information Systems    *
        5*   *    Inc., 1980.                                     *
        6*   *                                                    *
        7*   *                                                    *
        8*   ****************************************************** */
        9 
       10 list_symbols: lsb: procedure;
       11 
       12 /*	This procedure implements the list_symbols and find_symbols commands.
       13*   *	Created on 10/13/75 by Bill Silver as list_notescript.
       14*   *	Changed on 06/07/77 by Bill Silver to list_symbols.
       15*   *	Changed on 08/16/78 by R.J.C. Kissel to handle more than 253 symbols.
       16*   *      Changed on 10/28/80 by Paul Benjamin for special suffixing.
       17*   *
       18*   *	The list_symbols/find_symbols commands will list one or several or all
       19*   *	or the symbols/expansions in the currently defined Speedtype symbol dictionary.
       20*   *	Their calling sequences are:
       21*   *
       22*   *	list_symbols, lsb  {symbols} {-control_args}
       23*   *	find_symbols, fsb  {expansions}  {-control_args}
       24*   *
       25*   *	where:
       26*   *
       27*   *	     -lg, -long	Print suffix expansions.
       28*   *	     -op, -option	Print option info.
       29*   *	     -tt, -total	Print total number of defined symbols.
       30**/
       31 
       32 dcl  sb_buf char (8);				/* Symbol buffer. */
       33 dcl  exp_buf char (56);				/* Expansion buffer. */
       34 
       35 /* Note above that 56 is really length(exp.expansion). */
       36 
       37 
       38 dcl  arg_len fixed bin;				/* Length of symbol argument. */
       39 dcl  arg_ptr ptr;					/* Pointer to symbol argument. */
       40 dcl  argx fixed bin;				/* Index of current argument. */
       41 dcl  dir_name char (168) aligned;			/* Directory name of symbol dictionary. */
       42 dcl  ecode fixed bin (35);				/* Error table code. */
       43 dcl  ent_name char (32) aligned;			/* Entry name of symbol dictionary. */
       44 dcl  exp_buf_len fixed bin;				/* Length of expansion buffer. */
       45 dcl  exp_buf_ptr ptr;				/* Pointer to expansion buffer. */
       46 dcl  exp_len fixed bin;				/* Length of expansion. */
       47 dcl  found_flag bit (1);				/* ON => expansion found. */
       48 dcl  i fixed bin;
       49 dcl  item_len fixed bin;				/* Length of current item. */
       50 dcl  item_ptr ptr;					/* Pointer to current item. */
       51 dcl  itemx fixed bin;				/* Index of current item. */
       52 dcl  list_flag bit (1);				/* ON => symbol,  OFF => expansion. */
       53 dcl  listx fixed bin;				/* Type of listing index. */
       54 dcl  long_flag bit (1);				/* ON => list suffixes. */
       55 dcl  sb_buf_ptr ptr;				/* Pointer to symbol buffer. */
       56 dcl  sb_len fixed bin;				/* Length of symbol. */
       57 dcl  sbx fixed bin;					/* Table index of symbol. */
       58 dcl  num_args fixed bin;				/* Number of command arguments. */
       59 dcl  num_items fixed bin;				/* Number of items specified. */
       60 dcl  num_sb fixed bin;				/* Number of possible symbol entries. */
       61 dcl  option_flag bit (1);				/* ON => list options. */
       62 dcl  optx fixed bin;				/* Index of control arg option. */
       63 dcl  string_len fixed bin;				/* Length of sorting strings. */
       64 dcl  suffix_char char (1);				/* Suffix character. */
       65 dcl  temp_code fixed bin (35);			/* Used when already have non-zero ecode. */
       66 dcl  total_flag bit (1);				/* ON => list totals. */
       67 dcl  items (16) char (56);				/* Temporary storage for items. */
       68 
       69 /* Note above that 56 is really length(exp.expansion). */
       70 
       71 dcl  item_lens (16) fixed bin;			/* Length of each item. */
       72 
       73 
       74 /*		BASED DATA		*/
       75 
       76 dcl  argument char (arg_len) based (arg_ptr);		/* Command argument. */
       77 
       78 dcl  expansion char (exp_len) based (exp_buf_ptr);	/* Used to print expanded symbol. */
       79 
       80 dcl  item char (item_len) based (item_ptr);		/* Used to reference first argument. */
       81 
       82 
       83 /*		INTERNAL STATIC DATA	*/
       84 
       85 dcl  brief_options (4) char (4)
       86      internal static init ("-lg", "-op", "-tt", "");
       87 
       88 dcl  long_options (4) char (8)
       89      internal static init ("-long", "-option", "-total", "");
       90 
       91 dcl  suffix_names (5) char (8)			/* List of knwon suffix names. */
       92      internal static init ("plural", "ed", "ing", "er", "ly");
       93 
       94 dcl  escape_names (5) char (8)			/* List of known escape names. */
       95      internal static init ("pad", "perm", "temp", "trans", "space");
       96 
       97 dcl  prefix_names (2) char (8)
       98      internal static init ("under", "upper");
       99 
      100 
      101 /*		EXTERNAL DATA		*/
      102 
      103 dcl (addr, hbound, index, length, substr) builtin;
      104 
      105 dcl  error_table_$badopt fixed bin (35) external;
      106 dcl  error_table_$no_w_permission fixed bin(35) ext static;
      107 
      108 dcl  com_err_ entry options (variable);
      109 dcl  cu_$arg_count entry (fixed bin);
      110 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
      111 dcl  ioa_ entry options (variable);
      112 dcl  speedtype_expand_ entry (ptr, fixed bin, ptr, fixed bin, fixed bin, fixed bin (35));
      113 dcl  speedtype_info_$name entry (char (168) aligned, char (32) aligned, fixed bin (35));
      114 dcl  speedtype_info_$pointer entry (ptr, fixed bin (35));
      115 dcl  speedtype_index_ entry (char (*), ptr, fixed bin, fixed bin (35));
      116 dcl  speedtype_sort_ entry (ptr, fixed bin, fixed bin);
      117 						/* 	*/
  1     1 /*	Begin include file ... speedtype_symbols.incl.pl1
  1     2**	Created on 09/06/76 by Bill Silver.
  1     3**         Modified   06/03/80 by Paul Benjamin to allow special suffixing.
  1     4**
  1     5**	This include file defines the format of a Speedtype Symbol Dictionary.
  1     6**	The default Speedtype options are:
  1     7**
  1     8**	     ESCAPES:
  1     9**		temp "~"  pad (Octal 177)  perm "`"  trans ":"  space ";"
  1    10**	     PREFIXES:
  1    11**		under "_"  upper "+"
  1    12**	     SUFFIXES:
  1    13**		plural "+"  ed "-"  ing "*"  er "="  ly "|"
  1    14**	     DELIMITERS:
  1    15**		,"()?!<>[]{}
  1    16**/
  1    17 dcl	ssd_ptr		ptr;		/* Pointer to the base of a Speedtype Symbol Dictionary. */
  1    18 dcl	exp_ptr		ptr;		/* Pointer to an expansion entry. */
  1    19 dcl	sb_ptr		ptr;		/* Pointer to a symbol entry. */
  1    20 dcl       spc_ptr             ptr;                /* Pointer to a special entry. */
  1    21 dcl	delim_ptr		ptr;		/* Pointer to delimiter characters. */
  1    22 
  1    23 dcl	ssd_version_2	fixed bin		/* Version of this include file. */
  1    24 	internal static	init (2);
  1    25 
  1    26 dcl    1	ssd  based(ssd_ptr) aligned,		/* Format of a Speedtype Symbol Dictionary. */
  1    27 	2  version	fixed bin,	/* Version number.  Currently = 2. */
  1    28 	2  identifier	char(12),		/* "Seedtype_SD" => this is a Speedtype Symbol Dictionary. */
  1    29 	2  flags		bit(36),		/* Not used, all zero. */
  1    30 	2  delimiters	char(24),		/* Blank, New Line, Tab, Escapes, Others. */
  1    31 	2  escapes	char(5), 		/* Pad, Perm, Temp, Trans, Space */
  1    32 	2  prefixes	char(2),		/* Under, Upper. */
  1    33 	2  suffixes	char(5),		/* Plural, ed, ing, er, ly. */
  1    34 	2  num_symbols	fixed bin,	/* Number of defined symbols. */
  1    35 	2  table_size       fixed bin,          /* Size of the 3 tables to follow. */
  1    36 	2  pad(14)	bit(36),		/* Round out header to 32 words. */
  1    37 	2  spec_tab(table_size) like  spc,      /* Special entries. */
  1    38 	2  exp_tab(table_size) like  exp,	/* Expansion entries. */
  1    39 	2  sb_tab(table_size) like  sb;         /* Symbol entries. */
  1    40 
  1    41 dcl    1	delim_chars  based(delim_ptr)  aligned,	/* Overlay of ssd.delimiters. */
  1    42         (	2  blank		char(1),
  1    43 	2  new_line	char(1),
  1    44 	2  tab		char(1),
  1    45 	2  escapes	char(5),
  1    46 	2  others		char(16)) unaligned;
  1    47 
  1    48 dcl    1	sb  based(sb_ptr)   aligned,		/* Symbol entry. */
  1    49         (	2  new_line	char(1),		/* Needed to make index functions work. */
  1    50 	2  symbol		char(7)) unal;	/* Actual symbol string. */
  1    51 
  1    52 dcl    1	exp  based(exp_ptr) aligned,		/* Expansion entry. */
  1    53         (	2  actionx(5)	fixed bin(8),	/* Action index for each suffix. */
  1    54 	2  pad		fixed bin(17),	/* Reserved for additional suffixes, flags, etc.. */
  1    55 	2  len		fixed bin(8),	/* Actual length of expansion. */
  1    56 	2  expansion	char(56)) unal;	/* Expansion of string (56 => size(exp) = 16 words). */
  1    57 dcl    1  spc  based(spc_ptr) aligned,            /* Special entry. */
  1    58 	2  special (5)      char(56) unal;      /* One for each possible suffix. */
  1    59 
  1    60 /*	End include file ... speedtype_symbols.incl.pl1	*/
      118 
      119 /* 	*/
      120 /*	Entry for list_symbols, lsb
      121**/
      122 	list_flag = "1"b;
      123 	goto COMMON;
      124 
      125 /*	Entry for find_symbols, fsb
      126**/
      127 find_symbols: fsb: entry;
      128 
      129 	list_flag = "0"b;
      130 
      131 
      132 COMMON:
      133 	listx,
      134 	     num_items = 0;				/* Initialize control variables. */
      135 	long_flag,
      136 	     option_flag,
      137 	     total_flag = "0"b;
      138 
      139 	sb_buf_ptr = addr (sb_buf);			/* Set up pointers and lengths for suffix listing. */
      140 	exp_buf_ptr = addr (exp_buf);
      141 	exp_buf_len = length (exp_buf);
      142 
      143 	call cu_$arg_count (num_args);		/* Get number of arguments. */
      144 
      145 	if num_args = 0				/* Are there any arguments? */
      146 	then listx = 1;				/* No, sort and list all. */
      147 	else do argx = 1 to num_args;			/* Process all the arguments. */
      148 	     call PROCESS_ARGUMENT;			/* Process one argument. */
      149 	     if ecode ^= 0 then return;
      150 	end;
      151 
      152 	call speedtype_info_$pointer (ssd_ptr, ecode);
      153 	if ecode ^= 0				/* Is there a valid Speedtype symbol dictionary? */
      154 	then do;
      155 	     if ecode = error_table_$no_w_permission
      156 		then do;
      157 		call speedtype_info_$name (dir_name, ent_name, temp_code);
      158 		call com_err_ (ecode, "Speedtype", "Attempting to convert ^a>^a to new version.", dir_name, ent_name);
      159 	     end;
      160 	     return;
      161 	end;
      162 
      163 	if option_flag then call LIST_OPTION;		/* If told to, list the options. */
      164 
      165 	num_sb = ssd.num_symbols;			/* Make sure there are defined symbols. */
      166 	if num_sb = 0
      167 	then do;
      168 	     call ioa_ ("No symbols defined");
      169 	     return;
      170 	end;
      171 
      172 	if total_flag				/* If told to, print total. */
      173 	then if num_sb = 1
      174 	     then call ioa_ ("Total:  1 symbol");
      175 	     else call ioa_ ("Total:  ^d symbols", num_sb);
      176 
      177 	goto LISTX (listx);				/* Go do selected type of listing. */
      178 
      179 LISTX (0):					/* List only the total or options. */
      180 	return;
      181 
      182 LISTX (1):					/* List all symbols or expansions. */
      183 	call speedtype_info_$name (dir_name, ent_name, ecode);
      184 	if ecode = 0
      185 	then call ioa_ ("Speedtype symbol dictionary:  ^a>^a", dir_name, ent_name);
      186 	if ^total_flag				/* List total if not already done. */
      187 	then if num_sb = 1
      188 	     then call ioa_ ("Total:  1 symbol");
      189 	     else call ioa_ ("Total:  ^d symbols", num_sb);
      190 	call LIST_SORT;				/* List in sorted order. */
      191 	return;
      192 
      193 LISTX (2):
      194 	do itemx = 1 to num_items;			/* List all items specified. */
      195 	     item_ptr = addr (items (itemx));		/* Set up reference to item string. */
      196 	     item_len = item_lens (itemx);
      197 	     if list_flag				/* List item. */
      198 	     then call LIST_SYMBOL;			/* Item is a symbol. */
      199 	     else call LIST_EXPANSION;		/* Item is a expansion. */
      200 	end;
      201 	return;
      202 						/* 	*/
      203 LIST_SORT: procedure;
      204 
      205 /*	This procedure will list all symbol entries defined in the
      206*   *	symbol dictionary currently in use.  They will be listed
      207*   *	in ASCII collating sequence.
      208**/
      209 dcl  vex fixed bin;					/* Local index. */
      210 dcl  tseg_ptr (1) ptr;
      211 dcl  vector_ptr ptr;
      212 
      213 dcl 1 vector (num_sb) based (vector_ptr),		/* Structure for sorting. */
      214     2 string_ptr ptr,
      215     2 isbx fixed bin;				/* Rename to get around name-scope problem. */
      216 
      217 dcl  get_temp_segments_ entry (char (*), (*)ptr, fixed bin (35));
      218 dcl  release_temp_segments_ entry (char (*), (*)ptr, fixed bin (35));
      219 
      220 dcl  cleanup condition;
      221 
      222 	     call get_temp_segments_ ("list_symbols", tseg_ptr, ecode);
      223 	     if ecode ^= 0
      224 	     then do;
      225 		call com_err_ (ecode, "Speedtype");
      226 		return;
      227 	     end;
      228 
      229 	     on cleanup
      230 		begin;
      231 		if tseg_ptr (1) ^= null ()
      232 		then call release_temp_segments_ ("list_symbols", tseg_ptr, ecode);
      233 	     end;
      234 
      235 	     vector_ptr = tseg_ptr (1);
      236 
      237 	     do vex = 1 to num_sb;			/* Put each entry in the sorting list. */
      238 		vector (vex).isbx = vex;		/* Save symbol index. */
      239 		if list_flag			/* List => sort symbols, Find => expansions. */
      240 		then vector (vex).string_ptr = addr (ssd.sb_tab (vex));
      241 		else vector (vex).string_ptr = addr (ssd.exp_tab (vex).expansion);
      242 	     end;
      243 
      244 	     if list_flag				/* Now sort list of symbols or expansions. */
      245 	     then string_len = 8;			/* Symbol length. */
      246 	     else string_len = length (exp.expansion);	/* Expansion length. */
      247 
      248 	     call speedtype_sort_ (vector_ptr, num_sb, string_len);
      249 
      250 	     do vex = 1 to num_sb;			/* List each symbol in sorted order. */
      251 		sbx = vector (vex).isbx;		/* Get symbol index. */
      252 		call DISPLAY_SYMBOL;		/* List information about this symbol. */
      253 	     end;
      254 
      255 	     call release_temp_segments_ ("list_symbols", tseg_ptr, ecode);
      256 
      257 	end LIST_SORT;
      258 						/* 	*/
      259 LIST_SYMBOL: procedure;
      260 
      261 /*	This procedure is called to list just one symbol.
      262**/
      263 
      264 	     call speedtype_index_ (item, ssd_ptr, sbx, ecode);
      265 	     if ecode ^= 0				/* Is this a valid symbol? */
      266 	     then return;				/* No. */
      267 
      268 	     if sbx > 0				/* Is this symbol defined? */
      269 	     then call DISPLAY_SYMBOL;		/* Yes, list it. */
      270 	     else call com_err_ (0, "Speedtype", "Symbol ""^a"" not defined", item);
      271 
      272 	end LIST_SYMBOL;
      273 
      274 
      275 
      276 
      277 
      278 
      279 
      280 
      281 LIST_EXPANSION: procedure;
      282 
      283 /*	This procedure will look for and list a specified expansion.
      284*   *	If it finds it it will display information about the symbol that
      285*   *	represents this expansion.  All symbols representing this expansion
      286*   *	will be listed.
      287**/
      288 
      289 	     found_flag = "0"b;			/* Assume expansion not found. */
      290 
      291 	     do sbx = 1 to num_sb;			/* Search expansion table. */
      292 		exp_ptr = addr (ssd.exp_tab (sbx));	/* Get pointer to expansion entry. */
      293 		if exp.expansion = item		/* Is this the one we are looking for. */
      294 		then do;				/* Yes, expansion matches. */
      295 		     call DISPLAY_SYMBOL;		/* List this symbol. */
      296 		     found_flag = "1"b;		/* Note that expansion found. */
      297 		end;
      298 	     end;
      299 
      300 	     if ^found_flag				/* Tell user if expansion not found. */
      301 	     then call com_err_ (0, "Speedtype", "Expansion ""^a"" not defined", item);
      302 
      303 	end LIST_EXPANSION;
      304 						/* 	*/
      305 DISPLAY_SYMBOL: procedure;
      306 
      307 /*	This procedure is called to display information about one symbol.
      308**/
      309 
      310 	     sb_ptr = addr (ssd.sb_tab (sbx));		/* Get pointer to symbol entry. */
      311 	     exp_ptr = addr (ssd.exp_tab (sbx));	/* Get pointer to expansion entry. */
      312 
      313 	     if list_flag				/* List => symbol first. */
      314 	     then call ioa_ ("^a^-^a", sb.symbol, exp.expansion);
      315 	     else call ioa_ ("^a  -  ^a", exp.expansion, sb.symbol);
      316 
      317 	     if ^long_flag				/* If no long flag then all done. */
      318 	     then return;
      319 
      320 	     sb_buf = sb.symbol;			/* Copy symbol into work buffer. */
      321 	     sb_len = index (sb_buf, " ");		/* Get length of symbol. */
      322 	     if sb_len = 0 then sb_len = length (sb_buf);
      323 
      324 	     do i = 1 to hbound (exp.actionx, 1);	/* Generate expansion with each suffix. */
      325 		if exp.actionx (i) ^= 0		/* Is this suffix defined? */
      326 		then do;				/* Yes, add suffix and expand. */
      327 		     suffix_char,			/* Save suffix character. */
      328 			substr (sb_buf, sb_len, 1) = substr (ssd.suffixes, i, 1);
      329 		     call speedtype_expand_ (sb_buf_ptr, sb_len, exp_buf_ptr, exp_buf_len, exp_len, ecode);
      330 		     if ecode ^= 0
      331 		     then do;
      332 			call com_err_ (ecode, "Speedtype", "Error expanding ^a", sb_buf);
      333 			return;
      334 		     end;				/* Next line lists suffix and expansion. */
      335 		     call ioa_ ("^6x(^a) ^a", suffix_char, expansion);
      336 		end;
      337 	     end;
      338 	     call ioa_ (" ");			/* Skip a line. */
      339 
      340 	end DISPLAY_SYMBOL;
      341 						/* 	*/
      342 LIST_OPTION: procedure;
      343 
      344 /*	This procedure is called to list the options found in the
      345*   *	header of the current Speedtype symbol dictionary.
      346**/
      347 	     call speedtype_info_$name (dir_name, ent_name, ecode);
      348 	     if ecode = 0
      349 	     then call ioa_ ("^/Options for Speedtype symbol dictionary:  ^a>^a", dir_name, ent_name);
      350 
      351 	     call ioa_ ("Speedtype Version (^d)", ssd.version);
      352 
      353 	     call ioa_ ("Suffixes:");
      354 	     do i = 1 to hbound (suffix_names, 1);	/* List each suffix character. */
      355 		call ioa_ ("^5x^10a""^a""", suffix_names (i), substr (ssd.suffixes, i, 1));
      356 	     end;
      357 
      358 	     call ioa_ ("Prefixes:");
      359 	     do i = 1 to hbound (prefix_names, 1);	/* List each prefix character. */
      360 		call ioa_ ("^5x^10a""^a""", prefix_names (i), substr (ssd.prefixes, i, 1));
      361 	     end;
      362 
      363 	     call ioa_ ("Escapes:");
      364 	     do i = 1 to hbound (escape_names, 1);	/* List each escape character. */
      365 		call ioa_ ("^5x^10a""^a""", escape_names (i), substr (ssd.escapes, i, 1));
      366 	     end;
      367 
      368 	     delim_ptr = addr (ssd.delimiters);
      369 	     call ioa_ ("Delimiters:  ""^a""", delim_chars.others);
      370 
      371 	end LIST_OPTION;
      372 						/* 	*/
      373 PROCESS_ARGUMENT: procedure;
      374 
      375 /*	This procedure is called to process one argument.
      376**/
      377 	     call cu_$arg_ptr (argx, arg_ptr, arg_len, ecode);
      378 	     if ecode ^= 0
      379 	     then do;
      380 		call com_err_ (ecode, "Speedtype", "Error getting argument ^d", argx);
      381 		return;
      382 	     end;
      383 
      384 	     if substr (argument, 1, 1) ^= "-"		/* If argument is not a control argument. */
      385 	     then do;				/* It is a symbol or an expansion item. */
      386 		listx = 2;			/* List items. */
      387 		if num_items = hbound (items, 1)	/* Too many items? */
      388 		then do;				/* Yes, reject this item. */
      389 		     call com_err_ (0, "Speedtype", "Cannot list more than ^d symbols.", num_items);
      390 		     return;
      391 		end;
      392 		num_items = num_items + 1;		/* Another item in the list. */
      393 		items (num_items) = argument;		/* Add item to list. */
      394 		item_lens (num_items) = arg_len;	/* Save length of item. */
      395 		return;
      396 	     end;
      397 
      398 	     do optx = 1 to hbound (long_options, 1);	/* See if this a valid control argument. */
      399 		if (argument = brief_options (optx)) |
      400 		(argument = long_options (optx))
      401 		then goto OPTION (optx);		/* Found it, go process it. */
      402 	     end;
      403 
      404 	     ecode = error_table_$badopt;
      405 	     call com_err_ (ecode, "Speedtype", "Argument ^a unknown", argument);
      406 	     return;
      407 
      408 OPTION (1):					/* "-lg" or "-long" */
      409 	     long_flag = "1"b;
      410 	     if listx = 0 then listx = 1;		/* "-long" => list all by default. */
      411 	     return;
      412 
      413 OPTION (2):					/* "-op" or "-option" */
      414 	     option_flag = "1"b;
      415 	     return;
      416 
      417 OPTION (3):					/* "-tt" or "-total" */
      418 	     total_flag = "1"b;
      419 	     return;
      420 
      421 	end PROCESS_ARGUMENT;
      422 
      423      end list_symbols;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/06/81  1247.5  list_symbols.pl1                  >spec>on>speed>list_symbols.pl1
118          1    11/14/80  1152.8  speedtype_symbols.incl.pl1        >ldd>include_1>speedtype_symbols.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
actionx                                based           fixed bin(8,0)           array level 2 packed unaligned dcl 1-52 ref 324 325
addr                                                   builtin function         dcl 103 ref 139 140 195 239 241 292 310 311 368
arg_len                         000120 automatic       fixed bin(17,0)          dcl 38 set ref 377* 384 393 394 399 399 405 405
arg_ptr                         000122 automatic       pointer                  dcl 39 set ref 377* 384 393 399 399 405
argument                               based           char                     unaligned dcl 76 set ref 384 393 399 399 405*
argx                            000124 automatic       fixed bin(17,0)          dcl 40 set ref 147* 377* 380*
brief_options                   000016 constant        char(4)                  initial array unaligned dcl 85 ref 399
cleanup                         000106 stack reference condition                dcl 220 ref 229
com_err_                        000044 constant        entry                    external dcl 108 ref 158 225 270 300 332 380 389 405
cu_$arg_count                   000046 constant        entry                    external dcl 109 ref 143
cu_$arg_ptr                     000050 constant        entry                    external dcl 110 ref 377
delim_chars                            based           structure                level 1 dcl 1-41
delim_ptr                       000632 automatic       pointer                  dcl 1-21 set ref 368* 369
delimiters                5            based           char(24)                 level 2 dcl 1-26 set ref 368
dir_name                        000125 automatic       char(168)                dcl 41 set ref 157* 158* 182* 184* 347* 348*
ecode                           000177 automatic       fixed bin(35,0)          dcl 42 set ref 149 152* 153 155 158* 182* 184 222*
                                                                                  223 225* 231* 255* 264* 265 329* 330 332* 347* 348
                                                                                  377* 378 380* 404* 405*
ent_name                        000200 automatic       char(32)                 dcl 43 set ref 157* 158* 182* 184* 347* 348*
error_table_$badopt             000040 external static fixed bin(35,0)          dcl 105 ref 404
error_table_$no_w_permission    000042 external static fixed bin(35,0)          dcl 106 ref 155
escape_names                    000022 internal static char(8)                  initial array unaligned dcl 94 set ref 364 365*
escapes                  13            based           char(5)                  level 2 dcl 1-26 ref 365 365
exp                                    based           structure                level 1 dcl 1-52
exp_buf                         000102 automatic       char(56)                 unaligned dcl 33 set ref 140 141
exp_buf_len                     000210 automatic       fixed bin(17,0)          dcl 44 set ref 141* 329*
exp_buf_ptr                     000212 automatic       pointer                  dcl 45 set ref 140* 329* 335
exp_len                         000214 automatic       fixed bin(17,0)          dcl 46 set ref 329* 335 335
exp_ptr                         000626 automatic       pointer                  dcl 1-18 set ref 246 292* 293 311* 313 315 324 325
exp_tab                                based           structure                array level 2 dcl 1-26 set ref 292 311
expansion                              based           char                     unaligned dcl 78 in procedure "lsb" set ref 335*
expansion                              based           char(56)                 array level 3 in structure "ssd" packed unaligned
                                                                                  dcl 1-26 in procedure "lsb" set ref 241
expansion                 2            based           char(56)                 level 2 in structure "exp" packed unaligned dcl 1-52
                                                                                  in procedure "lsb" set ref 246 293 313* 315*
found_flag                      000215 automatic       bit(1)                   unaligned dcl 47 set ref 289* 296* 300
get_temp_segments_              000066 constant        entry                    external dcl 217 ref 222
hbound                                                 builtin function         dcl 103 ref 324 354 359 364 387 398
i                               000216 automatic       fixed bin(17,0)          dcl 48 set ref 324* 325 327* 354* 355 355 355* 359*
                                                                                  360 360 360* 364* 365 365 365*
index                                                  builtin function         dcl 103 ref 321
ioa_                            000052 constant        entry                    external dcl 111 ref 168 172 175 184 186 189 313 315
                                                                                  335 338 348 351 353 355 358 360 363 365 369
isbx                      2            based           fixed bin(17,0)          array level 2 dcl 213 set ref 238* 251
item                                   based           char                     unaligned dcl 80 set ref 264* 270* 293 300*
item_len                        000217 automatic       fixed bin(17,0)          dcl 49 set ref 196* 264 264 270 270 293 300 300
item_lens                       000603 automatic       fixed bin(17,0)          array dcl 71 set ref 196 394*
item_ptr                        000220 automatic       pointer                  dcl 50 set ref 195* 264 270 293 300
items                           000243 automatic       char(56)                 array unaligned dcl 67 set ref 195 387 393*
itemx                           000222 automatic       fixed bin(17,0)          dcl 51 set ref 193* 195 196*
length                                                 builtin function         dcl 103 ref 141 246 322
list_flag                       000223 automatic       bit(1)                   unaligned dcl 52 set ref 122* 129* 197 239 244 313
listx                           000224 automatic       fixed bin(17,0)          dcl 53 set ref 132* 145* 177 386* 410 410*
long_flag                       000225 automatic       bit(1)                   unaligned dcl 54 set ref 135* 317 408*
long_options                    000006 constant        char(8)                  initial array unaligned dcl 88 ref 398 399
num_args                        000232 automatic       fixed bin(17,0)          dcl 58 set ref 143* 145 147
num_items                       000233 automatic       fixed bin(17,0)          dcl 59 set ref 132* 193 387 389* 392* 392 393 394
num_sb                          000234 automatic       fixed bin(17,0)          dcl 60 set ref 165* 166 172 175* 186 189* 237 248*
                                                                                  250 291
num_symbols              20            based           fixed bin(17,0)          level 2 dcl 1-26 ref 165
option_flag                     000235 automatic       bit(1)                   unaligned dcl 61 set ref 135* 163 413*
optx                            000236 automatic       fixed bin(17,0)          dcl 62 set ref 398* 399 399 399*
others                    2            based           char(16)                 level 2 packed unaligned dcl 1-41 set ref 369*
prefix_names                    000034 internal static char(8)                  initial array unaligned dcl 97 set ref 359 360*
prefixes                 15            based           char(2)                  level 2 dcl 1-26 ref 360 360
release_temp_segments_          000070 constant        entry                    external dcl 218 ref 231 255
sb                                     based           structure                level 1 dcl 1-48
sb_buf                          000100 automatic       char(8)                  unaligned dcl 32 set ref 139 320* 321 322 327* 332*
sb_buf_ptr                      000226 automatic       pointer                  dcl 55 set ref 139* 329*
sb_len                          000230 automatic       fixed bin(17,0)          dcl 56 set ref 321* 322 322* 327 329*
sb_ptr                          000630 automatic       pointer                  dcl 1-19 set ref 310* 313 315 320
sb_tab                                 based           structure                array level 2 dcl 1-26 set ref 239 310
sbx                             000231 automatic       fixed bin(17,0)          dcl 57 set ref 251* 264* 268 291* 292* 310 311
spc                                    based           structure                level 1 dcl 1-57
speedtype_expand_               000054 constant        entry                    external dcl 112 ref 329
speedtype_index_                000062 constant        entry                    external dcl 115 ref 264
speedtype_info_$name            000056 constant        entry                    external dcl 113 ref 157 182 347
speedtype_info_$pointer         000060 constant        entry                    external dcl 114 ref 152
speedtype_sort_                 000064 constant        entry                    external dcl 116 ref 248
ssd                                    based           structure                level 1 dcl 1-26
ssd_ptr                         000624 automatic       pointer                  dcl 1-17 set ref 152* 165 239 239 239 241 241 264*
                                                                                  292 292 310 310 310 311 311 327 351 355 355 360
                                                                                  360 365 365 368
string_len                      000237 automatic       fixed bin(17,0)          dcl 63 set ref 244* 246* 248*
string_ptr                             based           pointer                  array level 2 dcl 213 set ref 239* 241*
substr                                                 builtin function         dcl 103 set ref 327 327* 355 355 360 360 365 365 384
suffix_char                     000240 automatic       char(1)                  unaligned dcl 64 set ref 327* 335*
suffix_names                    000010 internal static char(8)                  initial array unaligned dcl 91 set ref 354 355*
suffixes                 16            based           char(5)                  level 2 dcl 1-26 ref 327 355 355
symbol                    0(09)        based           char(7)                  level 2 packed unaligned dcl 1-48 set ref 313* 315*
                                                                                  320
table_size               21            based           fixed bin(17,0)          level 2 dcl 1-26 ref 239 239 241 292 310 310 311
temp_code                       000241 automatic       fixed bin(35,0)          dcl 65 set ref 157*
total_flag                      000242 automatic       bit(1)                   unaligned dcl 66 set ref 135* 172 186 417*
tseg_ptr                        000102 automatic       pointer                  array dcl 210 set ref 222* 231 231* 235 255*
vector                                 based           structure                array level 1 unaligned dcl 213
vector_ptr                      000104 automatic       pointer                  dcl 211 set ref 235* 238 239 241 248* 251
version                                based           fixed bin(17,0)          level 2 dcl 1-26 set ref 351*
vex                             000100 automatic       fixed bin(17,0)          dcl 209 set ref 237* 238 238 239 239 241 241* 250*
                                                                                  251*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
spc_ptr                                automatic       pointer                  dcl 1-20
ssd_version_2                          internal static fixed bin(17,0)          initial dcl 1-23

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          000322 constant        label                    dcl 132 ref 123
DISPLAY_SYMBOL                  001435 constant        entry                    internal dcl 305 ref 252 268 295
LISTX                           000000 constant        label                    array(0:2) dcl 179 ref 177
LIST_EXPANSION                  001331 constant        entry                    internal dcl 281 ref 199
LIST_OPTION                     001754 constant        entry                    internal dcl 342 ref 163
LIST_SORT                       000717 constant        entry                    internal dcl 203 ref 190
LIST_SYMBOL                     001222 constant        entry                    internal dcl 259 ref 197
OPTION                          000003 constant        label                    array(3) dcl 408 ref 399
PROCESS_ARGUMENT                002315 constant        entry                    internal dcl 373 ref 148
find_symbols                    000314 constant        entry                    external dcl 127
fsb                             000305 constant        entry                    external dcl 127
list_symbols                    000274 constant        entry                    external dcl 10
lsb                             000265 constant        entry                    external dcl 10

NAME DECLARED BY CONTEXT OR IMPLICATION.
null                                                   builtin function         ref 231

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3010        3102    2564        3020
Length      3336    2564        72         220     224          30

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lsb                                 642 external procedure  is an external procedure.  
LIST_SORT                            98 internal procedure  enables or reverts conditions.  
on unit on line 229                  82 on unit               
LIST_SYMBOL                             internal procedure  shares stack frame of external procedure lsb.  
LIST_EXPANSION                          internal procedure  shares stack frame of external procedure lsb.  
DISPLAY_SYMBOL                      116 internal procedure  is called by several nonquick procedures.  
LIST_OPTION                             internal procedure  shares stack frame of external procedure lsb.  
PROCESS_ARGUMENT                        internal procedure  shares stack frame of external procedure lsb.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 suffix_names                lsb
000022 escape_names                lsb
000034 prefix_names                lsb

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
LIST_SORT                000100 vex                         LIST_SORT
                         000102 tseg_ptr                    LIST_SORT
                         000104 vector_ptr                  LIST_SORT
lsb                      000100 sb_buf                      lsb
                         000102 exp_buf                     lsb
                         000120 arg_len                     lsb
                         000122 arg_ptr                     lsb
                         000124 argx                        lsb
                         000125 dir_name                    lsb
                         000177 ecode                       lsb
                         000200 ent_name                    lsb
                         000210 exp_buf_len                 lsb
                         000212 exp_buf_ptr                 lsb
                         000214 exp_len                     lsb
                         000215 found_flag                  lsb
                         000216 i                           lsb
                         000217 item_len                    lsb
                         000220 item_ptr                    lsb
                         000222 itemx                       lsb
                         000223 list_flag                   lsb
                         000224 listx                       lsb
                         000225 long_flag                   lsb
                         000226 sb_buf_ptr                  lsb
                         000230 sb_len                      lsb
                         000231 sbx                         lsb
                         000232 num_args                    lsb
                         000233 num_items                   lsb
                         000234 num_sb                      lsb
                         000235 option_flag                 lsb
                         000236 optx                        lsb
                         000237 string_len                  lsb
                         000240 suffix_char                 lsb
                         000241 temp_code                   lsb
                         000242 total_flag                  lsb
                         000243 items                       lsb
                         000603 item_lens                   lsb
                         000624 ssd_ptr                     lsb
                         000626 exp_ptr                     lsb
                         000630 sb_ptr                      lsb
                         000632 delim_ptr                   lsb

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return              enable
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   get_temp_segments_
ioa_                          release_temp_segments_        speedtype_expand_             speedtype_index_
speedtype_info_$name          speedtype_info_$pointer       speedtype_sort_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$no_w_permission




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     10 000264       122 000301       123 000303       127 000304       129 000321       132 000322       135 000324
    139 000327       140 000331       141 000333       143 000335       145 000344       147 000351       148 000357
    149 000360       150 000362       152 000364       153 000375       155 000377       157 000402       158 000414
    160 000454       163 000455       165 000460       166 000463       168 000464       169 000500       172 000501
    175 000525       177 000550       179 000552       182 000553       184 000566       186 000614       189 000641
    190 000664       191 000670       193 000671       195 000700       196 000703       197 000706       199 000712
    200 000713       201 000715       203 000716       222 000724       223 000752       225 000755       226 000776
    229 000777       231 001013       233 001046       235 001047       237 001051       238 001061       239 001066
    241 001110       242 001121       244 001123       246 001131       248 001133       250 001146       251 001156
    252 001163       253 001170       255 001172       257 001221       259 001222       264 001223       265 001253
    268 001256       270 001265       272 001330       281 001331       289 001332       291 001333       292 001342
    293 001353       295 001361       296 001365       298 001367       300 001371       303 001433       305 001434
    310 001442       311 001462       313 001467       315 001516       317 001544       320 001547       321 001555
    322 001566       324 001571       325 001577       327 001607       329 001623       330 001644       332 001647
    333 001703       335 001704       337 001735       338 001740       340 001753       342 001754       347 001755
    348 001770       351 002016       353 002041       354 002056       355 002063       356 002121       358 002123
    359 002140       360 002145       361 002203       363 002205       364 002220       365 002225       366 002263
    368 002265       369 002270       371 002314       373 002315       377 002316       378 002333       380 002335
    381 002371       384 002372       386 002377       387 002401       389 002404       390 002441       392 002442
    393 002443       394 002452       395 002455       398 002456       399 002463       402 002502       404 002504
    405 002507       406 002545       408 002546       410 002550       411 002554       413 002555       415 002557
    417 002560       419 002562


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
