	COMPILATION LISTING OF SEGMENT rmdb_delete_all
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 12/07/87  1320.2 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: ^inddcls,^indattr,indnoniterend,^indnoniterdo,indend,tree,^case,insnl,comcol61,dclind5,declareind5,delnl */
       10 
       11 /*DESCRIPTION
       12*  This set of entry points deletes either all the 1) domains, 2) attribute, or
       13*  3) relations, depending on which entry point it is entered at. */
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
       17*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
       18*     written
       19*  2) change(87-11-03,Blair), approve(87-11-03,MCR7792), audit(87-11-30,Dupuis),
       20*     install(87-12-07,MR12.2-1008):
       21*     Initialize mstxn_txn_id to 0 before establishing the cleanup handler so
       22*     that we don't get caught trying to abort a txn based on some bogus value.
       23*                                                   END HISTORY COMMENTS */
       24 
       25 rmdb_delete_all:
       26      proc;
       27 
       28 	return;					/* not an entry point */
       29 
       30 /*DESCRIPTION
       31*  This entry point deletes all defined domains. This implies all existing
       32*  attributes and relations must be deleted. For speed, we don't update the
       33*  crossreference file (if it even exists) as we are doing the task, but delete
       34*  it as everything in it becomes invalid. */
       35 
       36 rmdb_delete_all$domains:
       37      entry (Irmdb_ctl_ptr, Oerror_message, Ocode);
       38 
       39 	entry_point = DOMAINS;
       40 	goto COMMON;
       41 
       42 rmdb_delete_all$attributes:
       43      entry (Irmdb_ctl_ptr, Oerror_message, Ocode);
       44 
       45 	entry_point = ATTRIBUTES;
       46 	goto COMMON;
       47 
       48 rmdb_delete_all$relations:
       49      entry (Irmdb_ctl_ptr, Oerror_message, Ocode);
       50 
       51 	entry_point = RELATIONS;
       52 	goto COMMON;
       53 
       54 COMMON:
       55 	rmdb_ctl_ptr = Irmdb_ctl_ptr;
       56 	dbm_ptr = rmdb_ctl.db_model_ptr;
       57 
       58 	call transaction_in_progress;
       59 	mstxn_txn_id = "0"b;
       60 
       61 	quit_occurred = "0"b;			/* BEGIN CRITICAL CODE */
       62 
       63 	on quit quit_occurred = "1"b;
       64 
       65 /* Invalidate the resultant. */
       66 	rmdb_ctl.saved_res_version_ptr -> based_char8 = "RESTRUCT";
       67 
       68 	call mdbm_util_$xref_destroy (rmdb_ctl.crossref_file_info.iocb_ptr, rmdb_ctl.temp_dir_path,
       69 	     rmdb_ctl.crossref_file_info.name, (""), (0));
       70 
       71 	temp_ptr = null;
       72 	on cleanup
       73 	     begin;
       74 		call mstxn_cleanup;
       75 		call cleaner;
       76 	     end;
       77 	on any_other call mstxn_any_other;
       78 
       79 	if mstxn_transactions_needed
       80 	then do;
  1     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the changes made on 85-05-06 and
  1     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
  1    10*     was removed because not all modules need the dbcb, and the
  1    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
  1    12*     list #136).
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 /*
  1    17*                    BEGIN_DESCRIPTION
  1    18*
  1    19*   A generalized routine accessed by all MRDS modules (with the temporary 
  1    20*   (perhaps) exception of restructuring modules) that must start transactions 
  1    21*   if none are present.  The intent is that it be executed as inline code.
  1    22*   The variable mstxn_transactions_needed must be set prior to entering this
  1    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
  1    24*   will suffice.  Included are procedures called mstxn_cleanup and 
  1    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
  1    26*   handlers in the program.  Such handlers should be established just prior to
  1    27*   the inclusion of this code and disabled just following the inclusion of
  1    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
  1    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
  1    30*   include file does the same, because this code might not have been entered 
  1    31*   yet when the handler is invoked.  Directly following this include file the 
  1    32*   contents of mstxn_code should be examined.  If zero, then either the 
  1    33*   transaction was successfully started or no transaction was required.  If the
  1    34*   mrds_finish_transaction code is referenced in general error handling 
  1    35*   situations where the possibility exists that the code in this include file 
  1    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
  1    37*   the beginning of the program.
  1    38*
  1    39*                    END_DESCRIPTION
  1    40*
  1    41*   Written 82-09-28 by Paul W. Benjamin.
  1    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
  1    43*   Modified 83-01-07 by PWB to not reference the dbcb.
  1    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
  1    45*		 any_other handler in situations where the module did
  1    46*		 not start the transaction.
  1    47*   Modified 83-05-05 by PWB to abandon when abort fails.
  1    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
  1    49*		 and abort.
  1    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
  1    51*		 transaction_bj_full conditions.
  1    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
  1    53*		 and to handle transaction_lock_timeout_.
  1    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
  1    55*                     dbcb.user_started_transaction flag.
  1    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
  1    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
  1    58*                     directory >ldd>include and >exl>mrd>i
  1    59**/
  1    60 
  1    61 dcl continue_to_signal_ entry (fixed bin(35));
  1    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
  1    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
  1    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
  1    65 dcl mstxn_code fixed bin (35);
  1    66 dcl mstxn_retries fixed;
  1    67 dcl mstxn_temp_code fixed bin (35);
  1    68 dcl mstxn_transactions_needed bit (1) aligned;
  1    69 dcl user_started_transaction bit (1) aligned;
  1    70 dcl mstxn_txn_id bit (36) aligned;
  1    71 dcl user_transaction_id bit (36) aligned;
  1    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
  1    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
  1    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
  1    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
  1    76 dcl transaction_manager_$handle_conditions entry ();
  1    77 dcl 1 mstxn_condition_info like condition_info;
  1    78 
  2     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*Designed by Matthew C. Pierret, 01/26/82.
  2     6*Coded by Jeffrey D. Ives, 04/30/82.
  2     7*Modified:
  2     8*10/18/82 by Steve Herbst: Names changed.
  2     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  2    10**/
  2    11 
  2    12 dcl (LOWEST_MODE init (1),
  2    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  2    14 
  2    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  2    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  2    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  2    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  2    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  2    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  2    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  2    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  2    23 
  2    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    79 

  1    80 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
  1    81 
  1    82 
  1    83 	mstxn_code = 0;
  1    84 	mstxn_txn_id = "0"b;
  1    85 	
  1    86 	if ^mstxn_transactions_needed			/* only need transactions */
  1    87 	     then goto mstxn_exit;			/* for protected page files */
  1    88 	mstxn_retries = 0;
  1    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
  1    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
  1    91 	     then do;				
  1    92 	     user_started_transaction = "1"b;
  1    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
  1    95 	     goto mstxn_exit;	
  1    96 	end;
  1    97 
  1    98 	user_started_transaction = "0"b;
  1    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
  1   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1   101 
  1   102 mstxn_cleanup:
  1   103 proc;
  1   104 
  1   105 /*  This procedure MUST be called by a cleanup handler. */
  1   106 
  1   107           if mstxn_txn_id ^= "0"b
  1   108           then do;
  1   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
  1   110 	     if mstxn_temp_code ^= 0
  1   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
  1   112 	end;
  1   113 	
  1   114      end mstxn_cleanup;
  1   115 
  1   116 mstxn_any_other:
  1   117 proc;
  1   118 
  1   119 /*  This procedure MUST be called by an any_other handler. */
  1   120 
  1   121           if mstxn_txn_id ^= "0"b
  1   122           then do;
  1   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
  1   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
  1   125 		then do;
  1   126 		mftxn_code = dm_error_$lock_deadlock;
  1   127 		goto mftxn_check_code;
  1   128 	     end;
  1   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
  1   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
  1   131 		then do;
  1   132 		mftxn_code = dm_error_$bj_journal_full;
  1   133 		goto mftxn_check_code;
  1   134 	     end;
  1   135 	     else call transaction_manager_$handle_conditions;
  1   136 	end;
  1   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
  1   138      end mstxn_any_other;
  1   139      
  1   140 mstxn_exit:
  1   141      
  1   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
       81 
       82 	     if mstxn_code ^= 0
       83 	     then call error (mstxn_code, "Could not start a transaction.");
       84 	     end;
       85 
       86 	if entry_point = DOMAINS
       87 	then call delete_domains;
       88 
       89 /* Note that we don't have to expressly delete all the attributes if we entered
       90*   through the $attributes entry point. This is because all mention of
       91*   referenced attributes is in the model files, and we will later delete the
       92*   unreferenced attributes. */
       93 	call delete_relations;
       94 
       95 	if mstxn_transactions_needed
       96 	then do;
       97 	     mftxn_code = 0;
  4     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
  4     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*                    BEGIN_DESCRIPTION
  4    15*
  4    16*   A generalized routine accessed by all MRDS modules that begin and commit 
  4    17*   transactions.  The intent is that it be executed as inline code. It is 
  4    18*   assumed that mrds_start_transaction was executed previously in the 
  4    19*   procedure.  Prior to this include file the program should assign the value 
  4    20*   of its local error code to mftxn_code.  The program utilizing this
  4    21*   include file must supply a function labeled should_rollback that returns
  4    22*   bit (1).  This routine should examine the error code mftxn_code and whether
  4    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
  4    24*   means rollback.  This procedure may choose to simply return "0"b as it 
  4    25*   appears that MRDS will generally NOT rollback transactions.  This routine
  4    26*   does rollback and restart if the before journal is full but only attempts it
  4    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
  4    28*   where any data that was saved prior to the transaction is restored.  A 
  4    29*   procedure consisting solely of a return statement can be supplied if 
  4    30*   necessary.  After execution of this include file, mftxn_code must be
  4    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
  4    32*   then the commit has failed.  Otherwise it will be unchanged.
  4    33*
  4    34*                    END_DESCRIPTION
  4    35*
  4    36*   Written 82-09-30 by Paul W. Benjamin.
  4    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
  4    38*                     error code only when the transaction is in an error state.
  4    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
  4    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
  4    41*		 fails, and to abort rather than rollback when bj is full.
  4    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
  4    43*		 and rollback.
  4    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
  4    45*		 to by the mstxn_any_other procedure.
  4    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
  4    47*                     the user already started his own transaction.
  4    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
  4    49*                     the directory >ldd>include and >exl>mrd>i.
  4    50**/
  4    51 
  4    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
  4    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
  4    54 dcl mftxn_code fixed bin (35);
  4    55 dcl mftxn_temp_code fixed bin (35);
  4    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
  4    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
  4    58 	
  4    59 
  4    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
  4    61 	     then do;
  4    62 	     mftxn_code = 0;
  4    63 	     goto mftxn_exit;
  4    64 	end;
  4    65 mftxn_check_code:
  4    66 	if mftxn_code = 0
  4    67 	     then do;
  4    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
  4    69 	     if mftxn_code ^= 0
  4    70 		then do;
  4    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    72 		if mftxn_temp_code ^= 0
  4    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    74 	     end;
  4    75 	end;
  4    76 	else do;
  4    77 	     call restore_significant_data;
  4    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
  4    79 		& mstxn_retries < 1		
  4    80 		then do;
  4    81 		     mstxn_retries = mstxn_retries + 1;
  4    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    83 		     if mftxn_temp_code ^= 0
  4    84 			then do;
  4    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    86 			if mftxn_temp_code ^= 0
  4    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    88 		     end;
  4    89 		     else do;
  4    90 			mstxn_code = 0;
  4    91 			goto mstxn_exit;		/* go back and try again */
  4    92 		     end;
  4    93 		end;
  4    94 	     else if should_rollback ()		/* let the program decide */
  4    95 		then do;
  4    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    97 		if mftxn_temp_code ^= 0
  4    98 		     then do;
  4    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   100 		     if mftxn_temp_code ^= 0
  4   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   102 		end;
  4   103 		else do;
  4   104 		     mstxn_code = 0;
  4   105 		     goto mstxn_exit;		/* go back and try again */
  4   106 		end;
  4   107 	     end;
  4   108 	     else do;
  4   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   110 		if mftxn_temp_code ^= 0
  4   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   112 	     end;
  4   113 	end;
  4   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
  4   115 mftxn_exit:
  4   116      
  4   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
       98 
       99 	     end;
      100 
      101 	if (entry_point = DOMAINS) | (entry_point = ATTRIBUTES)
      102 	then call delete_unreferenced_attributes;
      103 
      104 	if entry_point = DOMAINS
      105 	then call rmdb_add_rmdb_history (dbm_ptr, RMDB_DOMAIN_TYPE,
      106 	          "-all", RMDB_DEL_DMN_OP, "", error_message, (0));
      107 	else if entry_point = ATTRIBUTES
      108 	     then call rmdb_add_rmdb_history (dbm_ptr, RMDB_ATTR_TYPE,
      109 		     "-all", RMDB_DEL_ATTR_OP, "", error_message, (0));
      110 	     else call rmdb_add_rmdb_history (dbm_ptr, RMDB_REL_TYPE,
      111 		     "-all", RMDB_DEL_REL_OP, "", error_message, (0));
      112 
      113 	call mdbm_util_$inconsistent_reset (dbm_ptr);
      114 
      115 	revert quit;				/* END CRITICAL CODE */
      116 	if quit_occurred
      117 	then signal quit;
      118 
      119 	call error (0, "");
      120 
      121 delete_relations:
      122      proc;
      123 
      124 dcl  last_unreferenced_attribute_ptr ptr;
      125 dcl  model_name char (32);
      126 dcl  relation_name char (32);
      127 
      128 	local_iocb = rmdb_ctl.crossref_file_info.iocb_ptr;
      129 
      130 	if entry_point = RELATIONS
      131 	then do;
      132 	     call mdbm_util_$get_temp_segment_path (rmdb_ctl.temp_dir_path, myname, temp_ptr, code);
      133 	     if code ^= 0
      134 	     then call error (code, "Unable to get a temp segment.");
      135 
      136 	     attribute_list_ptr = temp_ptr;
      137 	     attribute_list.count = 0;
      138 
      139 /* Find the last unreferenced_attribute structure so we can add on the end. */
      140 	     last_unreferenced_attribute_ptr = null;
      141 	     do ua_ptr = ptr (dbm_ptr, db_model.unreferenced_attribute_ptr)
      142 		repeat ptr (dbm_ptr, unreferenced_attribute.fwd_thread) while (rel (ua_ptr) ^= NULL_OFFSET);
      143 
      144 		last_unreferenced_attribute_ptr = ua_ptr;
      145 		end;				/* do ua_ptr */
      146 
      147 	     end;
      148 
      149 /* Process all the relations. */
      150 	do fi_ptr = ptr (dbm_ptr, db_model.file_ptr) repeat ptr (dbm_ptr, db_model.file_ptr)
      151 	     while (rel (fi_ptr) ^= NULL_OFFSET);
      152 
      153 	     relation_name = file_info.file_name;
      154 	     model_name = rtrim (relation_name) || ".m";
      155 
      156 /* If we are deleting all the relations, we must make all attributes be
      157*   unreferenced. */
      158 	     if entry_point = RELATIONS
      159 	     then do;
      160 
      161 /* Initiate the file_model segment so we can get to the list of attributes used
      162*   within this relation. We don't need to terminate the file_model as
      163*   we are shortly going to delete it. */
      164 		call initiate_file_ (rmdb_ctl.absolute_db_path, model_name, R_ACCESS, fm_ptr, (0), code);
      165 		if fm_ptr ^= null
      166 		then do;
      167 
      168 /* Process all the attributes in this relation. */
      169 		     ri_ptr = ptr (dbm_ptr, rel_ptr);
      170 		     do ai_ptr = ptr (fm_ptr, rel_info.attr_ptr) repeat ptr (fm_ptr, attr_info.fwd_thread)
      171 			while (rel (ai_ptr) ^= NULL_OFFSET);
      172 
      173 			call make_attribute_unreferenced;
      174 			end;			/* do ai_ptr */
      175 		     end;				/* initiated the file_model */
      176 		end;
      177 
      178 /* Delete the file_model segment and the relation file. */
      179 	     call delete_$path (rmdb_ctl.absolute_db_path, model_name, "101111"b, myname, (0));
      180 	     call rmdb_ctl.relmgr_entries.delete_relation (rmdb_ctl.absolute_db_path, relation_name, (0));
      181 
      182 	     db_model.file_ptr = file_info.fwd_ptr;
      183 	     call free (dbm_ptr, rel (fi_ptr));
      184 
      185 	     end;					/* do fi_ptr */
      186 
      187 /* If we are deleting all the attributes, we must make all domains be unreferenced. */
      188 	if entry_point = ATTRIBUTES
      189 	then do di_ptr = ptr (dbm_ptr, db_model.domain_ptr) repeat ptr (dbm_ptr, domain_info.fwd_thread)
      190 		while (rel (di_ptr) ^= NULL_OFFSET);
      191 
      192 		domain_info.unreferenced = "1"b;
      193 		end;				/* do di_ptr */
      194 
      195 /* Mark in the db_model that there aren't any type of files or relations left. */
      196 	db_model.num_blk_files, db_model.num_unblk_files, db_model.num_rels = 0;
      197 	return;
      198 
      199 make_attribute_unreferenced:
      200      proc;
      201 
      202 dcl  position fixed bin;
      203 dcl  search_name char (33);
      204 
      205 	search_name = OBJECT_HEAD || attr_info.name;
      206 	position = index (attribute_list_names, search_name);
      207 	if position = 0
      208 	then do;					/* not in list yet */
      209 	     attribute_list.count = attribute_list.count + 1;
      210 	     attribute_list.name (attribute_list.count) = search_name;
      211 
      212 	     allocate unreferenced_attribute in (dbm_area) set (ua_ptr);
      213 	     unreferenced_attribute.name = attr_info.name;
      214 	     unreferenced_attribute.domain_ptr = attr_info.domain_ptr;
      215 	     unreferenced_attribute.fwd_thread = NULL_OFFSET;
      216 	     unreferenced_attribute.unused (*) = NULL_OFFSET;
      217 
      218 	     if last_unreferenced_attribute_ptr = null
      219 	     then db_model.unreferenced_attribute_ptr = rel (ua_ptr);
      220 	     else last_unreferenced_attribute_ptr -> unreferenced_attribute.fwd_thread = rel (ua_ptr);
      221 	     last_unreferenced_attribute_ptr = ua_ptr;
      222 
      223 	     end;
      224 
      225 	return;
      226      end make_attribute_unreferenced;
      227 
      228      end delete_relations;
      229 
      230 delete_domains:
      231      proc;
      232 
      233 	do di_ptr = ptr (dbm_ptr, db_model.domain_ptr) repeat ptr (dbm_ptr, db_model.domain_ptr)
      234 	     while (rel (di_ptr) ^= NULL_OFFSET);
      235 
      236 	     db_model.domain_ptr = domain_info.fwd_thread;
      237 
      238 	     call free (dbm_ptr, domain_info.check_path_ptr);
      239 	     call free (dbm_ptr, domain_info.ck_stack_ptr);
      240 	     call free (dbm_ptr, domain_info.encd_path_ptr);
      241 	     call free (dbm_ptr, domain_info.decd_path_ptr);
      242 	     call free (dbm_ptr, domain_info.str_before_path_ptr);
      243 	     call free (dbm_ptr, domain_info.str_err_path_ptr);
      244 	     call free (dbm_ptr, domain_info.str_after_path_ptr);
      245 	     call free (dbm_ptr, domain_info.get_before_path_ptr);
      246 	     call free (dbm_ptr, domain_info.get_err_path_ptr);
      247 	     call free (dbm_ptr, domain_info.get_after_path_ptr);
      248 	     call free (dbm_ptr, domain_info.mod_before_path_ptr);
      249 	     call free (dbm_ptr, domain_info.mod_err_path_ptr);
      250 	     call free (dbm_ptr, domain_info.mod_after_path_ptr);
      251 	     call free (dbm_ptr, rel (di_ptr));
      252 	     end;					/* do while */
      253 
      254 	db_model.num_domains = 0;
      255 
      256 	return;
      257      end delete_domains;
      258 
      259 delete_unreferenced_attributes:
      260      proc;
      261 
      262 	do ua_ptr = ptr (dbm_ptr, db_model.unreferenced_attribute_ptr)
      263 	     repeat ptr (dbm_ptr, db_model.unreferenced_attribute_ptr) while (rel (ua_ptr) ^= NULL_OFFSET);
      264 
      265 	     db_model.unreferenced_attribute_ptr = unreferenced_attribute.fwd_thread;
      266 	     call free (dbm_ptr, rel (ua_ptr));
      267 	     end;					/* do while */
      268 
      269 	return;
      270      end delete_unreferenced_attributes;
      271 
      272 transaction_in_progress:
      273      proc;
      274 
      275 	if db_model.db_type_flags.transactions_needed
      276 	then do;
      277 	     mstxn_transactions_needed = "1"b;
      278 	     call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
      279 	     if mstxn_code = 0
      280 	     then do;
      281 		mstxn_txn_id = "0"b;
      282 		call error (error_table_$action_not_performed,
      283 		     rtrim (ENTRY_POINT_NAMES (entry_point)) ||
      284 		     " may not be deleted while a transaction is in progress. Commit or abort the transaction and try again.");
      285 		end;
      286 	     end;
      287 	else mstxn_transactions_needed = "0"b;
      288 
      289 	if entry_point = DOMAINS
      290 	then call mdbm_util_$inconsistent_set (dbm_ptr, "delete_domain", "Deleting all domains.",
      291 		"delete_domain -all -brief");
      292 	else if entry_point = ATTRIBUTES
      293 	     then call mdbm_util_$inconsistent_set (dbm_ptr, "delete_attribute", "Deleting all attributes.",
      294 		     "delete_attribute -all -brief");
      295 	     else call mdbm_util_$inconsistent_set (dbm_ptr, "delete_relation", "Deleting all relations.",
      296 		     "delete_relation -all -brief");
      297 
      298 	return;
      299      end transaction_in_progress;
      300 
      301 free:
      302      proc (base_ptr, offset);
      303 
      304 dcl  base_ptr ptr parameter;				/* base of segment */
      305 dcl  based_variable fixed bin (35) based;		/* used just to free structures */
      306 dcl  freeing_ptr ptr;				/* -> structure to free */
      307 dcl  offset bit (18) unaligned parameter;		/* offset to base_ptr of structure */
      308 
      309 	if offset ^= NULL_OFFSET
      310 	then do;
      311 	     freeing_ptr = ptr (base_ptr, offset);
      312 	     free freeing_ptr -> based_variable;
      313 	     offset = NULL_OFFSET;
      314 	     end;
      315 	return;
      316      end free;
      317 
      318 /*DESCRIPTION
      319*  Error handler and cleanup handler. This is the only way to exit these
      320*  subroutines.
      321**/
      322 
      323 error:
      324      proc (code, msg);
      325 
      326 dcl  code fixed bin (35) parameter;
      327 dcl  msg char (*) parameter;
      328 
      329 	Ocode = code;
      330 	Oerror_message = msg;
      331 	goto RETURN_TO_CALLER;
      332      end error;
      333 
      334 RETURN_TO_CALLER:
      335 	call cleaner;
      336 	return;
      337 
      338 cleaner:
      339      proc;
      340 
      341 	if temp_ptr ^= null
      342 	then call mdbm_util_$free_temp_segment (myname, temp_ptr, (0));
      343 
      344 	return;
      345      end cleaner;
      346 
      347 restore_significant_data:
      348      proc;
      349 	return;
      350      end restore_significant_data;
      351 
      352 should_rollback:
      353      proc returns (bit (1) aligned);
      354 	return ("0"b);
      355      end should_rollback;
      356 
  5     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  5     2*
  5     3*   Values for the "access mode" argument so often used in hardcore
  5     4*   James R. Davis 26 Jan 81  MCR 4844
  5     5*   Added constants for SM access 4/28/82 Jay Pattin
  5     6*   Added text strings 03/19/85 Chris Jones
  5     7**/
  5     8 
  5     9 
  5    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  5    11 dcl	(
  5    12 	N_ACCESS		   init ("000"b),
  5    13 	R_ACCESS		   init ("100"b),
  5    14 	E_ACCESS		   init ("010"b),
  5    15 	W_ACCESS		   init ("001"b),
  5    16 	RE_ACCESS		   init ("110"b),
  5    17 	REW_ACCESS	   init ("111"b),
  5    18 	RW_ACCESS		   init ("101"b),
  5    19 	S_ACCESS		   init ("100"b),
  5    20 	M_ACCESS		   init ("010"b),
  5    21 	A_ACCESS		   init ("001"b),
  5    22 	SA_ACCESS		   init ("101"b),
  5    23 	SM_ACCESS		   init ("110"b),
  5    24 	SMA_ACCESS	   init ("111"b)
  5    25 	)		   bit (3) internal static options (constant);
  5    26 
  5    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  5    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  5    29 
  5    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  5    31 			   static options (constant);
  5    32 
  5    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  5    34 			   static options (constant);
  5    35 
  5    36 dcl	(
  5    37 	N_ACCESS_BIN	   init (00000b),
  5    38 	R_ACCESS_BIN	   init (01000b),
  5    39 	E_ACCESS_BIN	   init (00100b),
  5    40 	W_ACCESS_BIN	   init (00010b),
  5    41 	RW_ACCESS_BIN	   init (01010b),
  5    42 	RE_ACCESS_BIN	   init (01100b),
  5    43 	REW_ACCESS_BIN	   init (01110b),
  5    44 	S_ACCESS_BIN	   init (01000b),
  5    45 	M_ACCESS_BIN	   init (00010b),
  5    46 	A_ACCESS_BIN	   init (00001b),
  5    47 	SA_ACCESS_BIN	   init (01001b),
  5    48 	SM_ACCESS_BIN	   init (01010b),
  5    49 	SMA_ACCESS_BIN	   init (01011b)
  5    50 	)		   fixed bin (5) internal static options (constant);
  5    51 
  5    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      357 
  6     1 /* BEGIN - mrds_rmdb_ctl.incl.pl1 */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(82-03-26,Davids), approve(), audit(), install():
  6     7*     created
  6     8*  2) change(82-05-26,Davids), approve(), audit(), install():
  6     9*     added db_model_ptr
  6    10*  3) change(82-06-09,Harvey), approve(), audit(), install():
  6    11*     deleted ssu_ routines ptr storage
  6    12*  4) change(82-08-20,Davids), approve(), audit(), install():
  6    13*     added the relmgr like reference and included the rmdb_relmgr_entries
  6    14*     include file
  6    15*  5) change(83-05-24,Davids), approve(), audit(), install():
  6    16*     added the saved_res_version_ptr element
  6    17*  6) change(84-10-23,Benjamin), approve(), audit(), install():
  6    18*     added flags (just database_readied_by_rmdb for now).
  6    19*  7) change(85-11-08,Spitzer), approve(85-11-08,MCR7311),
  6    20*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  6    21*     added crossref_file_info.
  6    22*                                                   END HISTORY COMMENTS */
  6    23 
  6    24 
  6    25 dcl 01 rmdb_ctl based (rmdb_ctl_ptr),
  6    26     02 version fixed bin,
  6    27     02 rmdb_version char (16) varying,
  6    28     02 absolute_db_path char (168),
  6    29     02 temp_dir_path char (168),
  6    30     02 work_area_ptr ptr,
  6    31     02 db_model_ptr ptr,
  6    32     02 saved_res_version_ptr ptr,
  6    33     02 crossref_file_info,
  6    34        03 iocb_ptr ptr,
  6    35        03 name char (32),
  6    36     02 relmgr_entries like rmdb_relmgr_entries,
  6    37     02 flags,
  6    38        03 database_readied_by_rmdb bit (1) unal,
  6    39        03 unused bit (35) unal;
  6    40     	
  6    41 dcl  RMDB_CTL_VERSION_1 fixed bin init (1) internal static options (constant);
  6    42 
  6    43 dcl  rmdb_ctl_ptr ptr;
  6    44 
  6    45 
  7     1 /*  START OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 
  7     4 /****^  HISTORY COMMENTS:
  7     5*  1) change(82-08-20,Davids), approve(), audit(), install():
  7     6*     written
  7     7*  2) change(86-01-28,Spitzer), approve(86-01-28,MCR7311),
  7     8*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  7     9*     add get_tuples_by_spec, put_tuple, put_tuples, create_cursor entry points.
  7    10*  3) change(86-08-21,Blair), approve(86-08-21,MCR7311),
  7    11*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  7    12*     Back out the entries get_tuples_by_spec and put_tuples since they aren't
  7    13*     sufficiently well tested to be reliable.  Replace with get_tuple_id and
  7    14*     get_tuple_by_id.
  7    15*                                                   END HISTORY COMMENTS */
  7    16 
  7    17 
  7    18 dcl 01 rmdb_relmgr_entries based (rmdb_relmgr_entries_ptr),
  7    19      02 create_relation entry (char (*), char (*), ptr, ptr, bit (36) aligned,
  7    20 	bit (36) aligned, fixed bin (35)),
  7    21      02 delete_relation entry (char (*), char (*), fixed bin (35)),
  7    22      02 open entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  7    23      02 close entry (bit (36) aligned, fixed bin (35)),
  7    24      02 create_index entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17),
  7    25 	bit (36) aligned, fixed bin (35)),
  7    26      02 delete_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35)),
  7    27      02 put_tuple entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  7    28      02 get_tuple_id entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  7    29      02 get_tuple_by_id entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  7    30      02 create_cursor entry (bit (36) aligned, ptr, ptr, fixed bin (35));
  7    31 
  7    32 dcl rmdb_relmgr_entries_ptr ptr;
  7    33 
  7    34 /*  END OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6    46 
  6    47 
  6    48 
  6    49 /* END - mrds_rmdb_ctl.incl.pl1 */
      358 
  8     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  8     6*     modified to save space occupied by model
  8     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  8     8*     to add mdbm_secured bit in db_model
  8     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  8    10*     collapsed the following into an unused_offset array:
  8    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  8    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  8    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  8    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  8    15*       unused_1
  8    16*     Also changed the name of unused_2 to restructuring_history_offset
  8    17*     and changed the comment on the changer structure to indicate
  8    18*     that it will contain on database creation information.
  8    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  8    20*     used one of the unused_offsets to point to a message which indicates
  8    21*     why the db is inconsistent. The offset will be null when the db is created
  8    22*     and set the first time the message is used. this is so it will be
  8    23*     consistent with existing data bases. Also added the message structure.
  8    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  8    25*     added the undo_request element to the message structure
  8    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  8    27*     changed unused_offset (12) to last_restructruring_history_offset and
  8    28*     changed restructuring_history_offset to first_restructuring_history_offset
  8    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  8    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  8    31*     1 => vfile database and 2 => page_file database. Up to this point all
  8    32*     database types were equal to 1.
  8    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  8    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  8    35*     flags. This will allow information about transactions and dm_file
  8    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  8    37*     change is compatable with all datamodels created by the released version
  8    38*     of mrds.
  8    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  8    40*     added the rollback_on flag to the db_type_flags since it appears that you
  8    41*     can have a dmfile database that requires transactions but does not have any
  8    42*     journalizing. Also switched the order of the transactions_needed and
  8    43*     concurrency_on flags - this makes the change compatable with existing
  8    44*     dmfile databases except when displaying the model since concurrency_on and
  8    45*     rollback_on will be off in the model even though the dmfile relations had
  8    46*     them on during creation.
  8    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  8    48*      Removed ctl_file_path_ptr.
  8    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  8    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  8    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  8    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  8    53*      in the flag word for rmdb copying.
  8    54*                                                   END HISTORY COMMENTS */
  8    55 
  8    56 
  8    57 /* this include file contains the structures that go into the make up
  8    58*   of the "db_model" segment in the model for the database.
  8    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  8    60*
  8    61*   the db_model structure goes at the base of the segment, and contains items unique to
  8    62*   the whole databse. in addition, it has an area of size to fill the
  8    63*   rest of a segment, that holds the lists of files and domains in the database.
  8    64*   these lists are singly forward linked lists. all "pointers" in the database model
  8    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  8    66*   since actual pointers are process dependent on segment number.
  8    67*   the remaining structures are first a path_entry one to save pathnames in,
  8    68*   and the stack_item and constent structures, used to save a boolean
  8    69*   expression in polish form, with the stack represented by a linked list.
  8    70*   the final structure is one for identifying the status of version information */
  8    71 
  8    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  8    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  8    74 	     2 db_type_flags      unal,
  8    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  8    76 	       3 unused	      (13) bit (1) unal,
  8    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  8    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  8    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  8    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  8    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  8    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  8    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  8    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  8    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  8    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  8    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  8    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  8    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  8    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  8    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  8    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  8    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  8    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  8    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  8    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  8    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  8    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  8    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  8   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  8   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  8   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  8   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  8   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  8   105 
  8   106      dcl	   dbm_ptr	      ptr;
  8   107 
  8   108 /* the files in the database each have a file_info containing
  8   109*   their name, the file_model for each file is found by initiating the
  8   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  8   111*   the file_info list is a singly linked list in definition order */
  8   112 
  8   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  8   114 	     2 file_name	      char (30),		/* name of file */
  8   115 	     2 file_id	      bit (36),		/* id number of file */
  8   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  8   117 	     2 unused	      unal bit (18);	/* for future expansion */
  8   118 
  8   119      dcl	   fi_ptr		      ptr;
  8   120 
  8   121 /* each domain used in the database will have a domain info saved in the db_model
  8   122*   segment. it describes the domain of the given name, and it's options.
  8   123*   the domain_info's form a singly linked list in definition order */
  8   124 
  8   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  8   126 	     2 name	      char (32),		/* name of domain */
  8   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  8   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  8   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  8   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  8   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  8   132 	     2 reserved	      bit (31) unal,
  8   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  8   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  8   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  8   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  8   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  8   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  8   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  8   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  8   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  8   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  8   143 	     2 str_err_path_ptr   unal bit (18),
  8   144 	     2 str_after_path_ptr unal bit (18),
  8   145 	     2 get_before_path_ptr unal bit (18),
  8   146 	     2 get_err_path_ptr   unal bit (18),
  8   147 	     2 get_after_path_ptr unal bit (18),
  8   148 	     2 mod_before_path_ptr unal bit (18),
  8   149 	     2 mod_err_path_ptr   unal bit (18),
  8   150 	     2 mod_after_path_ptr unal bit (18),
  8   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  8   152 	     2 unused_2	      unal bit (18),
  8   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  8   154 
  8   155      dcl	   di_ptr		      ptr;
  8   156 
  8   157 /* information necessary for attributes that are not used in any relation */
  8   158 
  8   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  8   160 	     2 name char (32),			/* name of attribute */
  8   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  8   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  8   163 	     2 unused (2) bit (18) unal;
  8   164 
  8   165      dcl     ua_ptr ptr;
  8   166 
  8   167 
  8   168 /* space saving pathname$entryname structure, to be allocated
  8   169*   only when a path$entry has to be saved, else only a bit(18)
  8   170*   offset takes up space in the main model structure */
  8   171 
  8   172      declare 1 path_entry	      based (path_entry_ptr),
  8   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  8   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  8   175 	     2 reserved	      unal bit (36);	/* for future use */
  8   176 
  8   177      declare path_entry_ptr	      ptr;
  8   178 
  8   179 
  8   180 
  8   181 
  8   182 
  8   183 /* declarations for model of postfix stack holding the check option boolean expression
  8   184*   the following encoding values indicate the corresponding type of stack element
  8   185*
  8   186*   1  =
  8   187*   2  ^=
  8   188*   3  >
  8   189*   4  <
  8   190*   5  >=
  8   191*   6  <=
  8   192*
  8   193*   10  and
  8   194*   20  or
  8   195*   30  not
  8   196*
  8   197*   40  - (minus)
  8   198*
  8   199*   50  domain variable(same name as domain)
  8   200*
  8   201*   60  constant(number, bit string, or character string)
  8   202*
  8   203**/
  8   204 
  8   205 
  8   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  8   207 	     2 next	      bit (18),		/* link to next in list */
  8   208 	     2 type	      fixed binary,		/* code for this element type */
  8   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  8   210*						   if this is a constant element type */
  8   211 
  8   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  8   213 
  8   214 
  8   215 
  8   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  8   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  8   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  8   219 
  8   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  8   221 
  8   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  8   223 
  8   224 /* version structure, giving status of source for CMDB/RMDB,
  8   225*   status of model, and status of resultant */
  8   226 
  8   227 /* version number is in form MM.N.Y
  8   228*   where MM is the major version number, N is the minor version alteration,
  8   229*   and Y is the lastest modification to that alteration,
  8   230*   where M and N represent numbers 0-9, and Y is a letter */
  8   231 
  8   232      declare 1 version_status	      unal based (version_status_ptr),
  8   233 	     2 cmdb_rmdb,
  8   234 	       3 major	      fixed bin,
  8   235 	       3 minor	      fixed bin,
  8   236 	       3 modification     char (4),
  8   237 	     2 model,
  8   238 	       3 major	      fixed bin,
  8   239 	       3 minor	      fixed bin,
  8   240 	       3 modification     char (4),
  8   241 	     2 resultant,
  8   242 	       3 major	      fixed bin,
  8   243 	       3 minor	      fixed bin,
  8   244 	       3 modification     char (4);
  8   245 
  8   246      declare version_status_ptr     ptr;
  8   247 
  8   248 
  8   249 /* maintains information only about the db creation */
  8   250 
  8   251      declare 1 changer	      unal based (changer_ptr),
  8   252 	     2 id		      char (32),
  8   253 	     2 time	      fixed bin (71),
  8   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  8   255 
  8   256      declare changer_ptr	      ptr;
  8   257 
  8   258 
  8   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  8   260 	     02 len	      fixed bin,		/* length of the message */
  8   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  8   262 	     02 name	      char (32),		/* name of thing that set the message */
  8   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  8   264*                                                               that caused the database to become inconsistent */
  8   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  8   266 
  8   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  8   268 
  8   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  8   270 
  8   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  8   272 
  8   273 
      359 
  9     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  9     2 
  9     3 
  9     4 /****^  HISTORY COMMENTS:
  9     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  9     6*     modified to save space occupied by model
  9     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  9     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  9     9*     the number of secondary indices in the relation - it was always zero.
  9    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  9    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  9    12*     DMS conversion.
  9    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  9    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  9    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  9    16*     for relation manager changes.
  9    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  9    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  9    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  9    20*     <rel> files are good (for rmdb)
  9    21*                                                   END HISTORY COMMENTS */
  9    22 
  9    23 
  9    24 /* each file in the database will have a model segment with the name
  9    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  9    26*   the file_model structure is allocated at the base of the segment for a given file.
  9    27*   it contains an area with which all other structures in this include file are allocated.
  9    28*   these structures contain the information about which relations, foreign keys,
  9    29*   and attributes are members of this file. all lists are singly linked lists in
  9    30*   definition order. pointers to these structures are obtained by using the "pointer"
  9    31*   builtin function with arguments of the segment base pointer, and the
  9    32*   offset (bit (18)) relative to that pointer that is actually stored in
  9    33*   the file model itself. this is because pointer segment numbers are
  9    34*   per process dependent. the major lists pointed to by the file_model structure
  9    35*   are the list of relations in this file(each with a contained attribute list),
  9    36*   and the list of foreign keys whose parent relation resides in this file
  9    37*   (along with a participating attribute sublist, and the child relation list,
  9    38*   if they are also in this file) */
  9    39 
  9    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  9    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  9    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  9    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  9    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  9    45     2 reserved bit (32) unal,				/* reserved for future flags */
  9    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  9    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  9    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  9    49     2 pad_1 fixed bin (35),				/* for future use */
  9    50     2 pad_2 fixed bin (35),
  9    51     2 ratd_len fixed bin (21),			/* length of above */
  9    52     2 mratd_len fixed bin (21),			/* length of above */
  9    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  9    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  9    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  9    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  9    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  9    58     2 block_size unal fixed bin,			/* no. pages in block */
  9    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  9    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  9    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  9    62     2 num_rels unal fixed bin,			/* number of relations in file */
  9    63     2 num_links unal fixed bin,			/* number of links in file */
  9    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  9    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  9    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  9    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  9    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  9    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  9    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  9    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  9    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  9    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  9    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  9    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  9    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  9    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  9    78     2 open_eu_err_path_ptr unal bit (18),
  9    79     2 open_eu_after_path_ptr unal bit (18),
  9    80     2 open_er_before_path_ptr unal bit (18),
  9    81     2 open_er_err_path_ptr unal bit (18),
  9    82     2 open_er_after_path_ptr unal bit (18),
  9    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  9    84     2 open_neu_err_path_ptr unal bit (18),
  9    85     2 open_neu_after_path_ptr unal bit (18),
  9    86     2 open_ner_before_path_ptr unal bit (18),
  9    87     2 open_ner_err_path_ptr unal bit (18),
  9    88     2 open_ner_after_path_ptr unal bit (18),
  9    89     2 open_pu_before_path_ptr unal bit (18),
  9    90     2 open_pu_err_path_ptr unal bit (18),
  9    91     2 open_pu_after_path_ptr unal bit (18),
  9    92     2 open_pr_before_path_ptr unal bit (18),
  9    93     2 open_pr_err_path_ptr unal bit (18),
  9    94     2 open_pr_after_path_ptr unal bit (18),
  9    95     2 open_cu_before_path_ptr unal bit (18),
  9    96     2 open_cu_err_path_ptr unal bit (18),
  9    97     2 open_cu_after_path_ptr unal bit (18),
  9    98     2 open_cr_before_path_ptr unal bit (18),
  9    99     2 open_cr_err_path_ptr unal bit (18),
  9   100     2 open_cr_after_path_ptr unal bit (18),
  9   101     2 close_before_path_ptr unal bit (18),
  9   102     2 close_err_path_ptr unal bit (18),
  9   103     2 close_after_path_ptr unal bit (18),
  9   104     2 unused_1 unal bit (18),				/* for future expansion */
  9   105     2 unused_2 unal bit (18),
  9   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  9   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  9   108 dcl  fm_ptr ptr;
  9   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  9   110 dcl  atd_ptr ptr;
  9   111 dcl  atd_len fixed bin;
  9   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  9   113     2 ncomponents fixed bin,
  9   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  9   115 dcl  cna_ptr ptr;
  9   116 dcl  ncomp_init fixed bin;
  9   117 
  9   118 /* a rel_info structure contains information describing a relation.
  9   119*   a relation may only occur in one file, thus there is one rel_info
  9   120*   per relation per database, each stored in the file_model area for
  9   121*   the file that contains it. the list of rel_info's in this file
  9   122*   form a singly linked list in definition order.
  9   123*   the rel_info itself points to a list of the attributes it contains,
  9   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  9   125 
  9   126 dcl 1 rel_info aligned based (ri_ptr),
  9   127     2 name char (32),				/* relation name */
  9   128     2 id  bit (36) aligned,				/* relation id number */
  9   129     2 hashed bit (1) unal,				/* on if hashed */
  9   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  9   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  9   132     2 system bit (1) unal,				/* on if dont care how stored */
  9   133     2 indexed bit (1) unal,				/* on if secondary index */
  9   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  9   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  9   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  9   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  9   138     2 reserved bit (27) unal,				/* for future flags */
  9   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  9   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  9   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  9   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  9   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  9   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  9   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  9   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  9   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  9   148     2 unused_3 unal fixed bin,			/* element that was never used */
  9   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  9   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  9   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  9   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  9   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  9   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  9   155     2 attr_ptr unal bit (18),				/* to attr. info */
  9   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  9   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  9   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  9   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  9   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  9   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  9   162     2 link_err_path_ptr unal bit (18),
  9   163     2 link_after_path_ptr unal bit (18),
  9   164     2 unlk_before_path_ptr unal bit (18),
  9   165     2 unlk_err_path_ptr unal bit (18),
  9   166     2 unlk_after_path_ptr unal bit (18),
  9   167     2 str_before_path_ptr unal bit (18),
  9   168     2 str_err_path_ptr unal bit (18),
  9   169     2 str_after_path_ptr unal bit (18),
  9   170     2 del_before_path_ptr unal bit (18),
  9   171     2 del_err_path_ptr unal bit (18),
  9   172     2 del_after_path_ptr unal bit (18),
  9   173     2 mod_before_path_ptr unal bit (18),
  9   174     2 mod_err_path_ptr unal bit (18),
  9   175     2 mod_after_path_ptr unal bit (18),
  9   176     2 find_before_path_ptr unal bit (18),
  9   177     2 find_err_path_ptr unal bit (18),
  9   178     2 find_after_path_ptr unal bit (18),
  9   179     2 retr_before_path_ptr unal bit (18),
  9   180     2 retr_err_path_ptr unal bit (18),
  9   181     2 retr_after_path_ptr unal bit (18),
  9   182     2 unused_1 unal bit (18),				/* for future expansion */
  9   183     2 unused_2 unal bit (18),
  9   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  9   185 dcl  ri_ptr ptr;
  9   186 
  9   187 /* a attr_info structure contains information about an attribute in a given relation.
  9   188*   since attributes may appear in more than one relation, each occurence of an attribute
  9   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  9   190*   the list is singly linked in definition order. the attr_info describes
  9   191*   the data it represents, and how that data is used during a database search. */
  9   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  9   193     2 name char (32),				/* name of attribute */
  9   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  9   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  9   196     2 link_attr bit (1) unal,				/* on if participates in link */
  9   197     2 reserved bit (33) unal,
  9   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  9   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  9   200     2 key_order unal fixed bin,			/* relative posit. in key */
  9   201     2 bit_offset fixed bin (35),			/* position in tuple */
  9   202     2 bit_length fixed bin (35),			/* length if fixed */
  9   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  9   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  9   205     2 domain_ptr unal bit (18),			/* to domain info */
  9   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  9   207     2 fwd_thread unal bit (18),			/* to next in list */
  9   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  9   209 dcl  ai_ptr ptr;
  9   210 
  9   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  9   212*   each time a foreign key definition indicates a relation as it's parent,
  9   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  9   214*   a relation can be parent and/or child in any number of foreign keys.
  9   215*   the parent_link_info structure describes the foreign key, and also points
  9   216*   to a list of the attributes that participate in this foreign key.
  9   217*   (this could be from 1 up to all attributes in the relation)
  9   218*   the attr_list structures are in a singly linked list in definition order
  9   219*   for this purpose. also pointed to is a list of child_link_info's
  9   220*   that describe the child relations in this foreign key. since foreign keys
  9   221*   may span files, not all related child_link_info's have to be in this file's
  9   222*   model area. */
  9   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  9   224     2 name char (32),				/* name of link */
  9   225     2 singular bit (1) unal,				/* on if system owned link */
  9   226     2 temp bit (1) unal,				/* on if temp. order */
  9   227     2 first bit (1) unal,				/* insertion indicators */
  9   228     2 last bit (1) unal,
  9   229     2 next bit (1) unal,
  9   230     2 prior bit (1) unal,
  9   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  9   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  9   233     2 dup_first bit (1) unal,				/* duplicates first */
  9   234     2 dup_last bit (1) unal,				/* duplicates last */
  9   235     2 indexed bit (1) unal,				/* locate parent via index */
  9   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  9   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  9   238     2 thread_27 bit (1) unal,
  9   239     2 thread_18 bit (1) unal,
  9   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  9   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  9   242     2 reserved bit (19) unal,				/* reserved for future flags */
  9   243     2 index_id aligned bit (8),			/* id of index if indexed */
  9   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  9   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  9   246     2 n_children unal fixed bin,			/* no. children in link */
  9   247     2 child_fn char (30),				/* file name for first child in list */
  9   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  9   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  9   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  9   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  9   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  9   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  9   254     2 sort_err_path_ptr unal bit (18),
  9   255     2 sort_after_path_ptr unal bit (18),
  9   256     2 srch_before_path_ptr unal bit (18),
  9   257     2 srch_err_path_ptr unal bit (18),
  9   258     2 srch_after_path_ptr unal bit (18),
  9   259     2 link_before_path_ptr unal bit (18),
  9   260     2 link_err_path_ptr unal bit (18),
  9   261     2 link_after_path_ptr unal bit (18),
  9   262     2 unlk_before_path_ptr unal bit (18),
  9   263     2 unlk_err_path_ptr unal bit (18),
  9   264     2 unlk_after_path_ptr unal bit (18),
  9   265     2 unused_1 unal bit (18),				/* for future expansion */
  9   266     2 unused_2 unal bit (18),
  9   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  9   268 dcl  pli_ptr ptr;
  9   269 
  9   270 /* a child_link_info structure is the counter part of a parent_link_info
  9   271*   for foreign key child relations. each time a relation is defined to be
  9   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  9   273*   this list is singly linked in foreign key definition order.
  9   274*   the child_link_info points to a list of participating attributes from the
  9   275*   child relation by means of a singly linked list of attr_list structures
  9   276*   in definition order. the number of attributes in the parent attr_list
  9   277*   and the child attr_list lists are the same with corresponding attr_list
  9   278*   attributes having the same domain. all child_link_infos in this file
  9   279*   are on a seperately linked list. this may not include all
  9   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  9   281*   since foreign keys may span files, and the child_link_info will
  9   282*   reside in the file containing it's associated relation_info. */
  9   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  9   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  9   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  9   286     2 fixed bit (1) unal,				/* on if membership fixed */
  9   287     2 optional bit (1) unal,				/* on if membership optional */
  9   288     2 auto bit (1) unal,				/* on if insertion automatic */
  9   289     2 manual bit (1) unal,				/* on if insertion manual */
  9   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  9   291     2 range_sel bit (1) unal,				/* on if range type selection */
  9   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  9   293     2 key_dup_last bit (1) unal,
  9   294     2 key_null bit (1) unal,				/* on if null allowed */
  9   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  9   296     2 sel_current bit (1) unal,
  9   297     2 sel_key bit (1) unal,
  9   298     2 sel_proc bit (1) unal,
  9   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  9   300     2 reserved bit (21) unal,
  9   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  9   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  9   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  9   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  9   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  9   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  9   307     2 parent_fn char (30),				/* file name for parent info */
  9   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  9   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  9   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  9   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  9   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  9   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  9   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  9   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  9   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  9   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  9   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  9   319     2 link_err_path_ptr unal bit (18),
  9   320     2 link_after_path_ptr unal bit (18),
  9   321     2 unlk_before_path_ptr unal bit (18),
  9   322     2 unlk_err_path_ptr unal bit (18),
  9   323     2 unlk_after_path_ptr unal bit (18),
  9   324     2 srch_before_path_ptr unal bit (18),
  9   325     2 srch_err_path_ptr unal bit (18),
  9   326     2 srch_after_path_ptr unal bit (18),
  9   327     2 unused_1 unal bit (18),				/* for future expansion */
  9   328     2 unused_2 unal bit (18) ;
  9   329 dcl  cli_ptr ptr;
  9   330 
  9   331 /* the attr_list structure is associated with the parent_link_info
  9   332*   and child_link_info structures to represent by means of a singly linked list
  9   333*   the participating attributes from relations in a foreign key.
  9   334*   the parent_link_info has a list for the parent relation,
  9   335*   and the child_link_info has a list for the child relation.
  9   336*   the participating attributes are a subset(not necessary proper) of
  9   337*   those attributes contained in a relation definition.
  9   338*   there are equal numbers of attr_list structures in the parent and
  9   339*   child lists of the same foreign key. the corresponding attributes in these
  9   340*   lists must have the same domain. */
  9   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  9   342     2 attr_fn char (30),				/* file name for attr. */
  9   343     2 attr_ptr unal bit (18),				/* to attr info block */
  9   344     2 fwd_thread unal bit (18);			/* to next in list */
  9   345 dcl  al_ptr ptr;
  9   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  9   347     2 ascend bit (1) unal,				/* ascending order */
  9   348     2 descend bit (1) unal,				/* descending order */
  9   349     2 reserved bit (34) unal,
  9   350     2 attr_ptr unal bit (18),				/* to attr info */
  9   351     2 fwd_thread unal bit (18);			/* to next in list */
  9   352 dcl  sk_ptr ptr;
  9   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  9   354     2 attr_ptr unal bit (18),				/* to attr info */
  9   355     2 fwd_thread unal bit (18);			/* to next in list */
  9   356 dcl  dp_ptr ptr;
  9   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  9   358     2 link_fn char (30),				/* file name for thru link */
  9   359     2 link_ptr unal bit (18),				/* to parent link info */
  9   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  9   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  9   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  9   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  9   364     2 fwd_thread unal bit (18);			/* to next in chain */
  9   365 dcl  sc_ptr ptr;
  9   366 
  9   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  9   368 
  9   369 
      360 
 10     1 /*  START OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 10     2 
 10     3 /****^  HISTORY COMMENTS:
 10     4*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
 10     5*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
 10     6*     written.
 10     7*                                                   END HISTORY COMMENTS */
 10     8 
 10     9 /*DESCRIPTION
 10    10*  The following structures are the definition of the records with the keyed
 10    11*  vfile that is built during restructuring. This file serves as a crossreference
 10    12*  of unique attributes and domains used within the specified MRDS database. Each
 10    13*  object is a char (33); the first byte is set to an unprintable character so we
 10    14*  can use the index builtin to find a specific object.
 10    15**/
 10    16 
 10    17 dcl crossref_info_record_ptr ptr;
 10    18 dcl crossref_info_record_count fixed bin (21);
 10    19 dcl 1 crossref_info_record based (crossref_info_record_ptr),
 10    20      2 offset bit (18) unal,
 10    21      2 pad bit (18) unal,
 10    22      2 count fixed bin (21),
 10    23      2 entry (crossref_info_record_count refer (crossref_info_record.count)) unaligned,
 10    24       3 object_head char (1),
 10    25       3 object char (32);
 10    26 
 10    27 dcl crossref_info_record_objects char (33*crossref_info_record.count)
 10    28 			   based (addr (crossref_info_record.entry(1)));
 10    29 dcl OBJECT_HEAD char (1) int static options (constant) init (" ");
 10    30 
 10    31 dcl ATTRIBUTE_KEY_HEAD char (10) int static options (constant) init ("attribute:");
 10    32 dcl DOMAIN_KEY_HEAD char (7) int static options (constant) init ("domain:");
 10    33 dcl RELATION_KEY_HEAD char (9) int static options (constant) init ("relation:");
 10    34 
 10    35 /*DESCRIPTION
 10    36*  The following structures are used to contain sufficient crossreference
 10    37*  information for the delete_attribute and delete_domain requests. These
 10    38*  requests require a more complete view of a crossreference tree, associating
 10    39*  domains, attributes and relations in 2 directions.
 10    40**/
 10    41 
 10    42 dcl domain_list_ptr ptr;
 10    43 dcl domain_list_count fixed bin;
 10    44 dcl domain_list_names char (33*domain_list.count) based (addr (domain_list.name(1)));
 10    45 dcl 1 domain_list based (domain_list_ptr),
 10    46      2 count fixed bin,				/* number of domains in the list */
 10    47      2 name (domain_list_count refer (domain_list.count))
 10    48 	  char (33) unaligned,			/* name of this domain */
 10    49      2 attribute_list_ptr (domain_list_count refer (domain_list.count))
 10    50 		      ptr;			/* -> attribute_list structure */
 10    51 
 10    52 dcl attribute_list_ptr ptr;
 10    53 dcl attribute_list_count fixed bin;
 10    54 dcl attribute_list_names char (33*attribute_list.count) based (addr (attribute_list.name(1)));
 10    55 dcl 1 attribute_list based (attribute_list_ptr),
 10    56      2 count fixed bin,				/* number of attributes in the list */
 10    57      2 name (attribute_list_count refer (attribute_list.count))
 10    58 	  char (33) unaligned,			/* name of this attribute */
 10    59      2 domain_info_ptr (attribute_list_count refer (attribute_list.count))
 10    60 		   bit (18) unal,			/* offset in db_model of the domain_info structure for this attribute */
 10    61      2 attribute_ptr (attribute_list_count refer (attribute_list.count))
 10    62 		 ptr;				/* -> attribute structure */
 10    63 
 10    64 dcl relation_list_ptr ptr;
 10    65 dcl relation_list_count fixed bin;
 10    66 dcl relation_list_names char (33*relation_list.count) based (addr (relation_list.name (1)));
 10    67 dcl 1 relation_list based (relation_list_ptr),
 10    68      2 count fixed bin,				/* number of relations that are to be touched in this operation */
 10    69      2 name (relation_list_count refer (relation_list.count))
 10    70 	  char (33) unaligned,			/* name of this relation */
 10    71      2 relation_ptr (relation_list_count refer (relation_list.count))
 10    72 		ptr;				/* -> relation structure */
 10    73 
 10    74 dcl relation_ptr ptr;
 10    75 dcl relation_attribute_count fixed bin;
 10    76 dcl relation_attribute_names char (33*relation.attribute_count) based (addr (relation.attribute_names (1)));
 10    77 dcl 1 relation based (relation_ptr),
 10    78      2 name char (32),				/* name of the relation */
 10    79      2 file_model_ptr ptr,				/* -> relation.m segment */
 10    80      2 copy_file_model_ptr ptr,
 10    81      2 attribute_count fixed bin,			/* number of attributes defined for this relation */
 10    82      2 mbz fixed bin (35),
 10    83      2 attribute (relation_attribute_count refer (relation.attribute_count)),
 10    84       3 flags aligned,
 10    85         4 delete bit (1) unaligned,			/* ON: delete this attribute */
 10    86         4 new bit (1) unaligned,			/* ON: this attribute is added to the relation */
 10    87         4 part_of_key bit (1) unaligned,                    /* ON: this attribute is part of the primary key */
 10    88         4 to_be_deleted bit (1) unaligned,
 10    89         4 pad bit (32) unaligned,
 10    90       3 domain_info_ptr bit (18) aligned,		/* -> db_model domain_info structure */
 10    91       3 attribute_info_ptr ptr,			/* -> file_model attribute_info structure */
 10    92       3 value_ptr ptr,				/* if flags.new, this -> the value of the column to be stored */
 10    93 						/*   it must be of the correct data type as specified by the domain */
 10    94      2 attribute_names (relation_attribute_count refer (relation.attribute_count))
 10    95 		   char (33) unaligned;
 10    96 
 10    97 dcl attribute_ptr ptr;
 10    98 dcl attribute_count fixed bin;
 10    99 dcl 1 attribute based (attribute_ptr),
 10   100      2 count fixed bin,				/* number of relations this attribute is used in */
 10   101      2 relation_idx (attribute_count refer (attribute.count))
 10   102 		fixed bin;			/* index into list of relation names */
 10   103 
 10   104 /*  END OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      361 
 11     1 /* BEGIN INCLUDE FILE rmdb_history_entry.incl.pl1 -- nsd, 82-04-09 */
 11     2 
 11     3 
 11     4 
 11     5 /****^  HISTORY COMMENTS:
 11     6*  1) change(75-01-01,WhoKnows), approve(), audit(), install():
 11     7*     Written.
 11     8*  2) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
 11     9*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 11    10*     Added RMDB_ADD_(ATTR DMN)_OP, RMDB_RN_(ATTR DMN REL)_OP.
 11    11*                                                   END HISTORY COMMENTS */
 11    12 
 11    13 
 11    14 /*
 11    15*   This include file contains the rmdb_history_entry structure which
 11    16*   is  used for maintaining a history of the databases restructuring
 11    17*   events. It also contains a set of constants used in  loading  the
 11    18*   structure.
 11    19*
 11    20*   The restructuring history is applied against the  database  as  a
 11    21*   whole  instead of against each structure in the db_model and file
 11    22*   models which was the approach originally  implemented  but  never
 11    23*   really  used  (except  to  record the database creation). This is
 11    24*   because 1 database restructuring event, i.e. adding a  new  index
 11    25*   to a relation will change several of the structures in the model.
 11    26*
 11    27*   For a detailed explaination of the use of this structure and  the
 11    28*   constants see the rmdb_add_rmdb_event module.
 11    29**/
 11    30 
 11    31 dcl 01 rmdb_history_entry aligned based (rmdb_history_entry_ptr),
 11    32     02 user_id char (32),				/* person_id.project_id.tag */
 11    33     02 date_time_restructured fixed bin (71),
 11    34     02 type_of_object_restructured fixed bin,		/* taken from constants below */
 11    35     02 object_name char (32),
 11    36     02 operation fixed bin,				/* taken from constants below */
 11    37     02 secondary_object_name char (32),			/* i.e. name of attr just indexed in a restructured relation */
 11    38     02 offset_to_next_entry bit (18) unal,
 11    39     02 offset_to_previous_entry bit (18) unal;
 11    40 	
 11    41 
 11    42 dcl  rmdb_history_entry_ptr ptr;
 11    43 
 11    44 
 11    45 dcl  RMDB_DOMAIN_TYPE init (1) fixed bin internal static options (constant);
 11    46 dcl  RMDB_ATTR_TYPE init (2) fixed bin internal static options (constant);
 11    47 dcl  RMDB_REL_TYPE init (3) fixed bin internal static options (constant);
 11    48 
 11    49 
 11    50 dcl  RMDB_ADD_REL_OP init (1) fixed bin internal static options (constant);
 11    51 dcl  RMDB_DEL_REL_OP init (2) fixed bin internal static options (constant);
 11    52 dcl  RMDB_ADD_IDX_OP init (3) fixed bin internal static options (constant);
 11    53 dcl  RMDB_DEL_IDX_OP init (4) fixed bin internal static options (constant);
 11    54 dcl  RMDB_ADD_ATTR_OP init (5) fixed bin int static options (constant);
 11    55 dcl  RMDB_DEL_ATTR_OP init (6) fixed bin int static options (constant);
 11    56 dcl  RMDB_ADD_DMN_OP init (7) fixed bin int static options (constant);
 11    57 dcl  RMDB_DEL_DMN_OP init (8) fixed bin int static options (constant);
 11    58 dcl  RMDB_RN_ATTR_OP init (9) fixed bin int static options (constant);
 11    59 dcl  RMDB_RN_DMN_OP init (10) fixed bin int static options (constant);
 11    60 dcl  RMDB_RN_REL_OP init (11) fixed bin int static options (constant);
 11    61 
 11    62 /* END INCLUDE FILE rmdb_history_entry.incl.pl1 */
      362 
      363 
      364 dcl  addr builtin;
      365 dcl  any_other condition;
      366 dcl  ATTRIBUTES fixed bin int static options (constant) init (2);
      367 dcl  based_char8 char (8) based;
      368 dcl  cleanup condition;
      369 dcl  code fixed bin (35);
      370 dcl  delete_$path entry (char (*), char (*), bit (36) aligned, char (*), fixed bin (35));
      371 dcl  DOMAINS fixed bin int static options (constant) init (1);
      372 dcl  entry_point fixed bin;
      373 dcl  ENTRY_POINT_NAMES (3) char (32) int static options (constant) init ("Domains", "Attributes", "Relations");
      374 dcl  error_message char (500);
      375 dcl  error_table_$action_not_performed fixed bin (35) ext static;
      376 dcl  fixed builtin;
      377 dcl  index builtin;
      378 dcl  initiate_file_ entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
      379 dcl  Irmdb_ctl_ptr ptr parameter;
      380 dcl  local_iocb ptr;
      381 dcl  mdbm_util_$free_temp_segment entry (char (*), ptr, fixed bin (35));
      382 dcl  mdbm_util_$get_temp_segment_path entry (char (*), char (*), ptr, fixed bin (35));
      383 dcl  mdbm_util_$inconsistent_reset entry (ptr);
      384 dcl  mdbm_util_$inconsistent_set entry (ptr, char (*), char (*), char (*));
      385 dcl  mdbm_util_$xref_destroy entry (ptr, char(*), char(*), char(*), fixed bin(35));
      386 dcl  myname char (32) int static options (constant) init ("rmdb_delete_all");
      387 dcl  null builtin;
      388 dcl  NULL_OFFSET bit (18) unaligned int static options (constant) init ((18)"1"b);
      389 dcl  Ocode fixed bin (35) parameter;
      390 dcl  Oerror_message char (*) parameter;
      391 dcl  ptr builtin;
      392 dcl  quit condition;
      393 dcl  quit_occurred bit (1) aligned;
      394 dcl  rel builtin;
      395 dcl  RELATIONS fixed bin int static options (constant) init (3);
      396 dcl  rmdb_add_rmdb_history entry (ptr, fixed bin, char(32), fixed bin, char(32), char(500), fixed bin(35));
      397 dcl  rtrim builtin;
      398 dcl  sys_info$max_seg_size fixed bin (35) ext static;
      399 dcl  temp_ptr ptr;
      400 
      401      end rmdb_delete_all;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/07/87  1320.2  rmdb_delete_all.pl1               >spec>install>MR12.2-1008>rmdb_delete_all.pl1
81           1    02/05/86  1416.4  mrds_start_transaction.incl.pl1   >ldd>include>mrds_start_transaction.incl.pl1
1-79         2    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
1-81         3    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
98           4    02/05/86  1416.4  mrds_finish_transaction.incl.pl1  >ldd>include>mrds_finish_transaction.incl.pl1
357          5    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
358          6    10/17/86  1404.4  mrds_rmdb_ctl.incl.pl1            >ldd>include>mrds_rmdb_ctl.incl.pl1
6-46         7    10/17/86  1404.6  rmdb_relmgr_entries.incl.pl1      >ldd>include>rmdb_relmgr_entries.incl.pl1
359          8    10/17/86  1404.3  mdbm_db_model.incl.pl1            >ldd>include>mdbm_db_model.incl.pl1
360          9    10/17/86  1404.5  mdbm_file_model.incl.pl1          >ldd>include>mdbm_file_model.incl.pl1
361         10    10/17/86  1404.6  rmdb_crossref_info.incl.pl1       >ldd>include>rmdb_crossref_info.incl.pl1
362         11    10/17/86  1404.4  rmdb_history_entry.incl.pl1       >ldd>include>rmdb_history_entry.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTRIBUTES                             constant        fixed bin(17,0)          initial dcl 366 ref 45 101 107 188 292
DOMAINS                                constant        fixed bin(17,0)          initial dcl 371 ref 39 86 101 104 289
ENTRY_POINT_NAMES               000010 constant        char(32)                 initial array unaligned dcl 373 ref 282
Irmdb_ctl_ptr                          parameter       pointer                  dcl 379 ref 36 42 48 54
NULL_OFFSET                     003024 constant        bit(18)                  initial unaligned dcl 388 ref 141 150 170 188 215
                                                                                  216 233 262 309 313
OBJECT_HEAD                     003025 constant        char(1)                  initial unaligned dcl 10-29 ref 205
Ocode                                  parameter       fixed bin(35,0)          dcl 389 set ref 36 42 48 329*
Oerror_message                         parameter       char                     unaligned dcl 390 set ref 36 42 48 330*
RELATIONS                              constant        fixed bin(17,0)          initial dcl 395 ref 51 130 158
RMDB_ATTR_TYPE                  000073 constant        fixed bin(17,0)          initial dcl 11-46 set ref 107*
RMDB_DEL_ATTR_OP                000071 constant        fixed bin(17,0)          initial dcl 11-55 set ref 107*
RMDB_DEL_DMN_OP                 000072 constant        fixed bin(17,0)          initial dcl 11-57 set ref 104*
RMDB_DEL_REL_OP                 000073 constant        fixed bin(17,0)          initial dcl 11-51 set ref 110*
RMDB_DOMAIN_TYPE                000075 constant        fixed bin(17,0)          initial dcl 11-45 set ref 104*
RMDB_REL_TYPE                   000066 constant        fixed bin(17,0)          initial dcl 11-47 set ref 110*
R_ACCESS                        000060 constant        bit(3)                   initial unaligned dcl 5-11 set ref 164*
TM_NORMAL_MODE                  000075 constant        fixed bin(17,0)          initial dcl 2-15 set ref 1-99*
absolute_db_path          6            based           char(168)                level 2 packed unaligned dcl 6-25 set ref 164* 179*
                                                                                  180*
addr                                                   builtin function         dcl 364 ref 1-123 1-123 206
ai_ptr                          000162 automatic       pointer                  dcl 9-209 set ref 170* 170* 174 205 213 214
any_other                       000166 stack reference condition                dcl 365 ref 77
attr_info                              based           structure                level 1 dcl 9-192
attr_ptr                 24(18)        based           bit(18)                  level 2 packed unaligned dcl 9-126 ref 170
attribute_list                         based           structure                level 1 unaligned dcl 10-55
attribute_list_names                   based           char                     unaligned dcl 10-54 ref 206
attribute_list_ptr              000164 automatic       pointer                  dcl 10-52 set ref 136* 137 206 206 209 209 210 210
base_ptr                               parameter       pointer                  dcl 304 ref 301 311
based_char8                            based           char(8)                  unaligned dcl 367 set ref 66*
based_variable                         based           fixed bin(35,0)          dcl 305 ref 312
check_path_ptr           15            based           bit(18)                  level 2 packed unaligned dcl 8-125 set ref 238*
ck_stack_ptr             15(18)        based           bit(18)                  level 2 packed unaligned dcl 8-125 set ref 239*
cleanup                         000174 stack reference condition                dcl 368 ref 72
code                                   parameter       fixed bin(35,0)          dcl 326 in procedure "error" ref 323 329
code                            000202 automatic       fixed bin(35,0)          dcl 369 in procedure "rmdb_delete_all" set ref 132*
                                                                                  133 133* 164*
condition_info                         based           structure                level 1 dcl 3-14
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 1-77 set ref 1-124 1-129 1-129
continue_to_signal_             000010 constant        entry                    external dcl 1-61 ref 1-137
count                                  based           fixed bin(17,0)          level 2 dcl 10-55 set ref 137* 206 209* 209 210
crossref_file_info      140            based           structure                level 2 unaligned dcl 6-25
db_model                               based           structure                level 1 dcl 8-72
db_model_ptr            134            based           pointer                  level 2 dcl 6-25 ref 56
db_type_flags             0(18)        based           structure                level 2 packed unaligned dcl 8-72
dbm_area                 34            based           area                     level 2 dcl 8-72 ref 212
dbm_ptr                         000146 automatic       pointer                  dcl 8-106 set ref 56* 104* 107* 110* 113* 141 141
                                                                                  145 150 150 169 182 183* 185 185 188 188 193 196
                                                                                  196 196 212 218 233 233 236 238* 239* 240* 241*
                                                                                  242* 243* 244* 245* 246* 247* 248* 249* 250* 251*
                                                                                  252 252 254 262 262 265 266* 267 267 275 289* 292*
                                                                                  295*
decd_path_ptr            16(18)        based           bit(18)                  level 2 packed unaligned dcl 8-125 set ref 241*
delete_$path                    000040 constant        entry                    external dcl 370 ref 179
delete_relation         156            based           entry variable           level 3 dcl 6-25 ref 180
di_ptr                          000152 automatic       pointer                  dcl 8-155 set ref 188* 188* 192* 193 233* 233* 236
                                                                                  238 239 240 241 242 243 244 245 246 247 248 249
                                                                                  250 251 251*
dm_error_$bj_journal_full       000030 external static fixed bin(35,0)          dcl 4-52 ref 1-132
dm_error_$lock_deadlock         000032 external static fixed bin(35,0)          dcl 4-53 ref 4-78 1-126
dm_error_$no_current_transaction
                                000012 external static fixed bin(35,0)          dcl 1-62 ref 1-90
domain_info                            based           structure                level 1 dcl 8-125
domain_ptr               10            based           bit(18)                  level 2 in structure "unreferenced_attribute" packed
                                                                                  unaligned dcl 8-159 in procedure "rmdb_delete_all"
                                                                                  set ref 214*
domain_ptr               17            based           bit(18)                  level 2 in structure "attr_info" packed unaligned
                                                                                  dcl 9-192 in procedure "rmdb_delete_all" ref 214
domain_ptr               22(18)        based           bit(18)                  level 2 in structure "db_model" packed unaligned
                                                                                  dcl 8-72 in procedure "rmdb_delete_all" set ref
                                                                                  188 233 236* 252
encd_path_ptr            16            based           bit(18)                  level 2 packed unaligned dcl 8-125 set ref 240*
entry_point                     000203 automatic       fixed bin(17,0)          dcl 372 set ref 39* 45* 51* 86 101 101 104 107 130
                                                                                  158 188 282 289 292
error_message                   000204 automatic       char(500)                unaligned dcl 374 set ref 104* 107* 110*
error_table_$action_not_performed
                                000042 external static fixed bin(35,0)          dcl 375 set ref 282*
fi_ptr                          000150 automatic       pointer                  dcl 8-119 set ref 150* 150* 153 182 183 183*
file_info                              based           structure                level 1 dcl 8-113
file_model                             based           structure                level 1 dcl 9-40
file_name                              based           char(30)                 level 2 dcl 8-113 ref 153
file_ptr                 22            based           bit(18)                  level 2 packed unaligned dcl 8-72 set ref 150 182*
                                                                                  185
find_condition_info_            000014 constant        entry                    external dcl 1-64 ref 1-123
fm_ptr                          000156 automatic       pointer                  dcl 9-108 set ref 164* 165 169 170 174
freeing_ptr                     000520 automatic       pointer                  dcl 306 set ref 311* 312
fwd_ptr                  11            based           bit(18)                  level 2 packed unaligned dcl 8-113 ref 182
fwd_thread               10(18)        based           bit(18)                  level 2 in structure "unreferenced_attribute" packed
                                                                                  unaligned dcl 8-159 in procedure "rmdb_delete_all"
                                                                                  set ref 145 215* 220* 265
fwd_thread               20            based           bit(18)                  level 2 in structure "attr_info" packed unaligned
                                                                                  dcl 9-192 in procedure "rmdb_delete_all" ref 174
fwd_thread               14(18)        based           bit(18)                  level 2 in structure "domain_info" packed unaligned
                                                                                  dcl 8-125 in procedure "rmdb_delete_all" ref 193
                                                                                  236
get_after_path_ptr       21(18)        based           bit(18)                  level 2 packed unaligned dcl 8-125 set ref 247*
get_before_path_ptr      20(18)        based           bit(18)                  level 2 packed unaligned dcl 8-125 set ref 245*
get_err_path_ptr         21            based           bit(18)                  level 2 packed unaligned dcl 8-125 set ref 246*
index                                                  builtin function         dcl 377 ref 206
initiate_file_                  000044 constant        entry                    external dcl 378 ref 164
iocb_ptr                140            based           pointer                  level 3 dcl 6-25 set ref 68* 128
last_unreferenced_attribute_ptr 000424 automatic       pointer                  dcl 124 set ref 140* 144* 218 220 221*
local_iocb                      000402 automatic       pointer                  dcl 380 set ref 128*
mdbm_util_$free_temp_segment    000046 constant        entry                    external dcl 381 ref 341
mdbm_util_$get_temp_segment_path
                                000050 constant        entry                    external dcl 382 ref 132
mdbm_util_$inconsistent_reset   000052 constant        entry                    external dcl 383 ref 113
mdbm_util_$inconsistent_set     000054 constant        entry                    external dcl 384 ref 289 292 295
mdbm_util_$xref_destroy         000056 constant        entry                    external dcl 385 ref 68
mftxn_code                      000142 automatic       fixed bin(35,0)          dcl 4-54 set ref 97* 4-62* 4-65 4-68* 4-69 4-78
                                                                                  1-126* 1-132*
mftxn_temp_code                 000143 automatic       fixed bin(35,0)          dcl 4-55 set ref 4-71* 4-72 4-72* 4-82* 4-83 4-85*
                                                                                  4-86 4-86* 4-96* 4-97 4-99* 4-100 4-100* 4-109*
                                                                                  4-110 4-110*
mod_after_path_ptr       23            based           bit(18)                  level 2 packed unaligned dcl 8-125 set ref 250*
mod_before_path_ptr      22            based           bit(18)                  level 2 packed unaligned dcl 8-125 set ref 248*
mod_err_path_ptr         22(18)        based           bit(18)                  level 2 packed unaligned dcl 8-125 set ref 249*
model_name                      000426 automatic       char(32)                 unaligned dcl 125 set ref 154* 164* 179*
msg                                    parameter       char                     unaligned dcl 327 ref 323 330
mstxn_code                      000100 automatic       fixed bin(35,0)          dcl 1-65 set ref 1-83* 1-89* 1-90 1-99* 1-140 1-140*
                                                                                  4-90* 4-104* 1-137* 278* 279
mstxn_condition_info            000110 automatic       structure                level 1 unaligned dcl 1-77 set ref 1-123 1-123
mstxn_retries                   000101 automatic       fixed bin(17,0)          dcl 1-66 set ref 1-88* 4-78 4-81* 4-81
mstxn_temp_code                 000102 automatic       fixed bin(35,0)          dcl 1-67 set ref 1-109* 1-110 1-110* 1-123*
mstxn_transactions_needed       000103 automatic       bit(1)                   dcl 1-68 set ref 79 1-86 95 277* 287*
mstxn_txn_id                    000105 automatic       bit(36)                  dcl 1-70 set ref 59* 1-84* 1-89* 1-93 1-94* 1-99*
                                                                                  1-100 4-60 4-68* 4-71* 4-72* 4-82* 4-85* 4-86*
                                                                                  4-96* 4-99* 4-100* 4-109* 4-110* 4-114* 1-107
                                                                                  1-109* 1-110* 1-121 278* 281*
myname                          000000 constant        char(32)                 initial unaligned dcl 386 set ref 132* 179* 341*
name                    142            based           char(32)                 level 3 in structure "rmdb_ctl" packed unaligned
                                                                                  dcl 6-25 in procedure "rmdb_delete_all" set ref
                                                                                  68*
name                                   based           char(32)                 level 2 in structure "unreferenced_attribute"
                                                                                  dcl 8-159 in procedure "rmdb_delete_all" set ref
                                                                                  213*
name                      1            based           char(33)                 array level 2 in structure "attribute_list" packed
                                                                                  unaligned dcl 10-55 in procedure "rmdb_delete_all"
                                                                                  set ref 206 210*
name                                   based           char(32)                 level 2 in structure "attr_info" dcl 9-192
                                                                                  in procedure "rmdb_delete_all" ref 205 213
null                                                   builtin function         dcl 387 ref 71 1-123 1-123 140 165 218 341
num_blk_files            13            based           fixed bin(17,0)          level 2 packed unaligned dcl 8-72 set ref 196*
num_domains              14(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 8-72 set ref 254*
num_rels                 14            based           fixed bin(17,0)          level 2 packed unaligned dcl 8-72 set ref 196*
num_unblk_files          13(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 8-72 set ref 196*
offset                                 parameter       bit(18)                  unaligned dcl 307 set ref 301 309 311 313*
position                        000454 automatic       fixed bin(17,0)          dcl 202 set ref 206* 207
ptr                                                    builtin function         dcl 391 ref 141 145 150 169 170 174 185 188 193 233
                                                                                  252 262 267 311
quit                            000404 stack reference condition                dcl 392 ref 63 115 116
quit_occurred                   000412 automatic       bit(1)                   dcl 393 set ref 61* 63* 116
rel                                                    builtin function         dcl 394 ref 141 150 170 183 183 188 218 220 233 251
                                                                                  251 262 266 266
rel_info                               based           structure                level 1 dcl 9-126
rel_ptr                  20(27)        based           bit(18)                  level 2 packed unaligned dcl 9-40 ref 169
relation_name                   000436 automatic       char(32)                 unaligned dcl 126 set ref 153* 154 180*
relmgr_entries          152            based           structure                level 2 unaligned dcl 6-25
ri_ptr                          000160 automatic       pointer                  dcl 9-185 set ref 169* 170
rmdb_add_rmdb_history           000060 constant        entry                    external dcl 396 ref 104 107 110
rmdb_ctl                               based           structure                level 1 unaligned dcl 6-25
rmdb_ctl_ptr                    000144 automatic       pointer                  dcl 6-43 set ref 54* 56 66 68 68 68 128 132 164 179
                                                                                  180 180
rmdb_relmgr_entries                    based           structure                level 1 unaligned dcl 7-18
rtrim                                                  builtin function         dcl 397 ref 154 282
saved_res_version_ptr
                        136            based           pointer                  level 2 dcl 6-25 ref 66
search_name                     000455 automatic       char(33)                 unaligned dcl 203 set ref 205* 206 210
str_after_path_ptr       20            based           bit(18)                  level 2 packed unaligned dcl 8-125 set ref 244*
str_before_path_ptr      17            based           bit(18)                  level 2 packed unaligned dcl 8-125 set ref 242*
str_err_path_ptr         17(18)        based           bit(18)                  level 2 packed unaligned dcl 8-125 set ref 243*
temp_dir_path            60            based           char(168)                level 2 packed unaligned dcl 6-25 set ref 68* 132*
temp_ptr                        000414 automatic       pointer                  dcl 399 set ref 71* 132* 136 341 341*
transaction_manager_$abandon_txn
                                000016 constant        entry                    external dcl 1-72 ref 4-72 4-86 4-100 4-110 1-110
transaction_manager_$abort_txn  000020 constant        entry                    external dcl 1-73 ref 4-71 4-85 4-99 4-109 1-109
transaction_manager_$begin_txn  000022 constant        entry                    external dcl 1-74 ref 1-99
transaction_manager_$commit_txn 000034 constant        entry                    external dcl 4-56 ref 4-68
transaction_manager_$get_current_txn_id
                                000024 constant        entry                    external dcl 1-75 ref 1-89 278
transaction_manager_$handle_conditions
                                000026 constant        entry                    external dcl 1-76 ref 1-135
transaction_manager_$rollback_txn
                                000036 constant        entry                    external dcl 4-57 ref 4-82 4-96
transactions_needed       0(34)        based           bit(1)                   level 3 packed unaligned dcl 8-72 ref 275
ua_ptr                          000154 automatic       pointer                  dcl 8-165 set ref 141* 141* 144* 145 212* 213 214
                                                                                  215 216 218 220 221 262* 262* 265 266 266*
unreferenced             10(04)        based           bit(1)                   level 2 packed unaligned dcl 8-125 set ref 192*
unreferenced_attribute                 based           structure                level 1 dcl 8-159 set ref 212
unreferenced_attribute_ptr
                         23            based           bit(18)                  level 2 packed unaligned dcl 8-72 set ref 141 218*
                                                                                  262 265* 267
unused                   11            based           bit(18)                  array level 2 packed unaligned dcl 8-159 set ref
                                                                                  216*
user_started_transaction        000104 automatic       bit(1)                   dcl 1-69 set ref 1-92* 1-98* 4-60
user_transaction_id             000106 automatic       bit(36)                  dcl 1-71 set ref 1-93* 1-100*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ATTRIBUTE_KEY_HEAD                     internal static char(10)                 initial unaligned dcl 10-31
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-33
DOMAIN_KEY_HEAD                        internal static char(7)                  initial unaligned dcl 10-32
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 2-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 2-12
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
RELATION_KEY_HEAD                      internal static char(9)                  initial unaligned dcl 10-33
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
RMDB_ADD_ATTR_OP                       internal static fixed bin(17,0)          initial dcl 11-54
RMDB_ADD_DMN_OP                        internal static fixed bin(17,0)          initial dcl 11-56
RMDB_ADD_IDX_OP                        internal static fixed bin(17,0)          initial dcl 11-52
RMDB_ADD_REL_OP                        internal static fixed bin(17,0)          initial dcl 11-50
RMDB_CTL_VERSION_1                     internal static fixed bin(17,0)          initial dcl 6-41
RMDB_DEL_IDX_OP                        internal static fixed bin(17,0)          initial dcl 11-53
RMDB_RN_ATTR_OP                        internal static fixed bin(17,0)          initial dcl 11-58
RMDB_RN_DMN_OP                         internal static fixed bin(17,0)          initial dcl 11-59
RMDB_RN_REL_OP                         internal static fixed bin(17,0)          initial dcl 11-60
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 2-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 2-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 2-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 2-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 2-20
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
al_ptr                                 automatic       pointer                  dcl 9-345
alloc_length                           internal static fixed bin(35,0)          dcl 8-222
atd                                    based           char                     unaligned dcl 9-109
atd_len                                automatic       fixed bin(17,0)          dcl 9-111
atd_ptr                                automatic       pointer                  dcl 9-110
attr_list                              based           structure                level 1 dcl 9-341
attribute                              based           structure                level 1 unaligned dcl 10-99
attribute_count                        automatic       fixed bin(17,0)          dcl 10-98
attribute_list_count                   automatic       fixed bin(17,0)          dcl 10-53
attribute_ptr                          automatic       pointer                  dcl 10-97
changer                                based           structure                level 1 packed unaligned dcl 8-251
changer_ptr                            automatic       pointer                  dcl 8-256
child_link_info                        based           structure                level 1 dcl 9-283
cli_ptr                                automatic       pointer                  dcl 9-329
cna_ptr                                automatic       pointer                  dcl 9-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 9-112
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
constant                               based           structure                level 1 unaligned dcl 8-216
constant_ptr                           automatic       pointer                  dcl 8-220
crossref_info_record                   based           structure                level 1 unaligned dcl 10-19
crossref_info_record_count             automatic       fixed bin(21,0)          dcl 10-18
crossref_info_record_objects           based           char                     unaligned dcl 10-27
crossref_info_record_ptr               automatic       pointer                  dcl 10-17
domain_list                            based           structure                level 1 unaligned dcl 10-45
domain_list_count                      automatic       fixed bin(17,0)          dcl 10-43
domain_list_names                      based           char                     unaligned dcl 10-44
domain_list_ptr                        automatic       pointer                  dcl 10-42
dp_ptr                                 automatic       pointer                  dcl 9-356
dup_prev                               based           structure                level 1 dcl 9-353
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 1-63
fixed                                                  builtin function         dcl 376
message_str                            based           structure                level 1 packed unaligned dcl 8-259
message_str_len                        automatic       fixed bin(17,0)          dcl 8-269
message_str_ptr                        automatic       pointer                  dcl 8-267
ncomp_init                             automatic       fixed bin(17,0)          dcl 9-116
parent_link_info                       based           structure                level 1 dcl 9-223
path_entry                             based           structure                level 1 packed unaligned dcl 8-172
path_entry_ptr                         automatic       pointer                  dcl 8-177
pli_ptr                                automatic       pointer                  dcl 9-268
relation                               based           structure                level 1 unaligned dcl 10-77
relation_attribute_count               automatic       fixed bin(17,0)          dcl 10-75
relation_attribute_names               based           char                     unaligned dcl 10-76
relation_list                          based           structure                level 1 unaligned dcl 10-67
relation_list_count                    automatic       fixed bin(17,0)          dcl 10-65
relation_list_names                    based           char                     unaligned dcl 10-66
relation_list_ptr                      automatic       pointer                  dcl 10-64
relation_ptr                           automatic       pointer                  dcl 10-74
rmdb_history_entry                     based           structure                level 1 dcl 11-31
rmdb_history_entry_ptr                 automatic       pointer                  dcl 11-42
rmdb_relmgr_entries_ptr                automatic       pointer                  dcl 7-32
sc_ptr                                 automatic       pointer                  dcl 9-365
select_chain                           based           structure                level 1 dcl 9-357
sk_ptr                                 automatic       pointer                  dcl 9-352
sort_key                               based           structure                level 1 dcl 9-346
stack_item                             based           structure                level 1 unaligned dcl 8-206
stack_item_ptr                         automatic       pointer                  dcl 8-212
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 398
version_status                         based           structure                level 1 packed unaligned dcl 8-232
version_status_ptr                     automatic       pointer                  dcl 8-246

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          000357 constant        label                    dcl 54 set ref 40 46 52
RETURN_TO_CALLER                001230 constant        label                    dcl 334 ref 331
cleaner                         002733 constant        entry                    internal dcl 338 ref 75 334
delete_domains                  002072 constant        entry                    internal dcl 230 ref 86
delete_relations                001364 constant        entry                    internal dcl 121 ref 93
delete_unreferenced_attributes  002330 constant        entry                    internal dcl 259 ref 101
error                           002677 constant        entry                    internal dcl 323 ref 1-140 119 133 282
free                            002647 constant        entry                    internal dcl 301 ref 183 238 239 240 241 242 243 244
                                                                                  245 246 247 248 249 250 251 266
make_attribute_unreferenced     001770 constant        entry                    internal dcl 199 ref 173
mftxn_check_code                000623 constant        label                    dcl 4-65 ref 1-127 1-133
mftxn_exit                      001043 constant        label                    dcl 4-115 ref 4-63
mstxn_any_other                 001267 constant        entry                    internal dcl 1-116 ref 77
mstxn_cleanup                   001235 constant        entry                    internal dcl 1-102 ref 74
mstxn_exit                      000563 constant        label                    dcl 1-140 ref 1-86 1-95 4-91 4-105
restore_significant_data        002767 constant        entry                    internal dcl 347 ref 4-77
rmdb_delete_all                 000267 constant        entry                    external dcl 25
rmdb_delete_all$attributes      000321 constant        entry                    external dcl 42
rmdb_delete_all$domains         000301 constant        entry                    external dcl 36
rmdb_delete_all$relations       000341 constant        entry                    external dcl 48
should_rollback                 002771 constant        entry                    internal dcl 352 ref 4-94
transaction_in_progress         002364 constant        entry                    internal dcl 272 ref 58

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3444        3526    3027        3454
Length      4216    3027        62         454     415           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rmdb_delete_all                     524 external procedure  is an external procedure.  
on unit on line 63                   64 on unit               
on unit on line 72                   76 on unit               
on unit on line 77                   82 on unit               
mstxn_cleanup                           internal procedure  shares stack frame of on unit on line 72.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 77.  
delete_relations                        internal procedure  shares stack frame of external procedure rmdb_delete_all.  
make_attribute_unreferenced             internal procedure  shares stack frame of external procedure rmdb_delete_all.  
delete_domains                          internal procedure  shares stack frame of external procedure rmdb_delete_all.  
delete_unreferenced_attributes
                                        internal procedure  shares stack frame of external procedure rmdb_delete_all.  
transaction_in_progress                 internal procedure  shares stack frame of external procedure rmdb_delete_all.  
free                                    internal procedure  shares stack frame of external procedure rmdb_delete_all.  
error                                65 internal procedure  is called during a stack extension.  
cleaner                              80 internal procedure  is called by several nonquick procedures.  
restore_significant_data                internal procedure  shares stack frame of external procedure rmdb_delete_all.  
should_rollback                         internal procedure  shares stack frame of external procedure rmdb_delete_all.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rmdb_delete_all          000100 mstxn_code                  rmdb_delete_all
                         000101 mstxn_retries               rmdb_delete_all
                         000102 mstxn_temp_code             rmdb_delete_all
                         000103 mstxn_transactions_needed   rmdb_delete_all
                         000104 user_started_transaction    rmdb_delete_all
                         000105 mstxn_txn_id                rmdb_delete_all
                         000106 user_transaction_id         rmdb_delete_all
                         000110 mstxn_condition_info        rmdb_delete_all
                         000142 mftxn_code                  rmdb_delete_all
                         000143 mftxn_temp_code             rmdb_delete_all
                         000144 rmdb_ctl_ptr                rmdb_delete_all
                         000146 dbm_ptr                     rmdb_delete_all
                         000150 fi_ptr                      rmdb_delete_all
                         000152 di_ptr                      rmdb_delete_all
                         000154 ua_ptr                      rmdb_delete_all
                         000156 fm_ptr                      rmdb_delete_all
                         000160 ri_ptr                      rmdb_delete_all
                         000162 ai_ptr                      rmdb_delete_all
                         000164 attribute_list_ptr          rmdb_delete_all
                         000202 code                        rmdb_delete_all
                         000203 entry_point                 rmdb_delete_all
                         000204 error_message               rmdb_delete_all
                         000402 local_iocb                  rmdb_delete_all
                         000412 quit_occurred               rmdb_delete_all
                         000414 temp_ptr                    rmdb_delete_all
                         000424 last_unreferenced_attribute_ptr
                                                            delete_relations
                         000426 model_name                  delete_relations
                         000436 relation_name               delete_relations
                         000454 position                    make_attribute_unreferenced
                         000455 search_name                 make_attribute_unreferenced
                         000520 freeing_ptr                 free

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ent_var_desc   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other      return_mac          tra_ext_1           signal_op           enable_op           shorten_stack
ext_entry           ext_entry_desc      int_entry           int_entry_desc      set_chars_eis       index_chars_eis
op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           delete_$path                  find_condition_info_          initiate_file_
mdbm_util_$free_temp_segment  mdbm_util_$get_temp_segment_path                            mdbm_util_$inconsistent_reset
mdbm_util_$inconsistent_set   mdbm_util_$xref_destroy       rmdb_add_rmdb_history
transaction_manager_$abandon_txn                            transaction_manager_$abort_txn
transaction_manager_$begin_txn                              transaction_manager_$commit_txn
transaction_manager_$get_current_txn_id                     transaction_manager_$handle_conditions
transaction_manager_$rollback_txn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$lock_deadlock       dm_error_$no_current_transaction
error_table_$action_not_performed




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     25 000266        28 000274        36 000275        39 000314        40 000316        42 000317        45 000334
     46 000336        48 000337        51 000354        52 000356        54 000357        56 000363        58 000365
     59 000366        61 000367        63 000370        66 000410        68 000415        71 000447        72 000451
     74 000465        75 000466        76 000473        77 000474        79 000512    1   83 000514    1   84 000515
 1   86 000516    1   88 000517    1   89 000520    1   90 000531    1   92 000535    1   93 000537    1   94 000541
 1   95 000542    1   98 000543    1   99 000544    1  100 000561    1  140 000563        86 000604        93 000610
     95 000611        97 000613    4   60 000614    4   62 000621    4   63 000622    4   65 000623    4   68 000625
 4   69 000636    4   71 000640    4   72 000651    4   75 000664    4   77 000665    4   78 000666    4   81 000675
 4   82 000676    4   83 000711    4   85 000713    4   86 000724    4   88 000737    4   90 000740    4   91 000741
 4   93 000742    4   94 000743    4   96 000750    4   97 000764    4   99 000766    4  100 000777    4  102 001012
 4  104 001013    4  105 001014    4  107 001015    4  109 001016    4  110 001027    4  114 001042       101 001043
    104 001051       107 001107       110 001144       113 001176       115 001205       116 001206       119 001213
    334 001230       336 001234    1  102 001235    1  107 001236    1  109 001241    1  110 001252    1  114 001266
 1  116 001267    1  121 001270    1  123 001273    1  124 001312    1  126 001320    1  127 001323    1  129 001326
 1  132 001340    1  133 001343    1  135 001346    1  136 001353    1  137 001354    1  138 001363       121 001364
    128 001365       130 001370       132 001373       133 001421       136 001442       137 001444       140 001445
    141 001447       144 001461       145 001463       150 001471       153 001503       154 001507       158 001535
    164 001541       165 001600       169 001604       170 001614       173 001625       174 001626       179 001635
    180 001671       182 001713       183 001717       185 001723       188 001732       192 001747       193 001752
    196 001760       197 001767       199 001770       205 001771       206 002000       207 002011       209 002012
    210 002013       212 002020       213 002026       214 002032       215 002034       216 002036       218 002054
    220 002064       221 002070       225 002071       230 002072       233 002073       236 002105       238 002111
    239 002121       240 002134       241 002145       242 002160       243 002171       244 002204       245 002215
    246 002230       247 002241       248 002254       249 002265       250 002300       251 002311       252 002315
    254 002324       256 002327       259 002330       262 002331       265 002343       266 002350       267 002354
    269 002363       272 002364       275 002365       277 002370       278 002372       279 002403       281 002405
    282 002406       285 002460       286 002461       287 002462       289 002463       292 002533       295 002602
    298 002646       301 002647       309 002651       311 002656       312 002666       313 002670       315 002675
    323 002676       329 002712       330 002717       331 002727       338 002732       341 002740       344 002766
    347 002767       349 002770       352 002771       354 002773


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
