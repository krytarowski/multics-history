	COMPILATION LISTING OF SEGMENT mrds_rst_parse
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/18/85  1102.5 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 
       19 
       20 /* HISTORY:
       21*
       22*   originally written by jim gray - - july 1978
       23*
       24**/
       25 
       26 mrds_rst_parse: procedure (rsc_ptr, source_seg_ptr, source_length);
       27 
       28 /*
       29*   .                        BEGIN_DESCRIPTION
       30*   table driven lrk parsing algorithm
       31*   method is that of a no backtrack bottom up shift reduce parser
       32*   the tables are built using the automated lrk tool of d. ward
       33*   (see the Multics lrk MTB)
       34*
       35*   an additional entry - debug_set - may be call without parameters to set
       36*   a debug switch for debug output
       37*   .                        END_DESCRIPTION
       38**/
       39 
       40 /* PARAMETERS:
       41*
       42*   rsc_ptr - - (input) pointer to restructure control segment
       43*
       44*   source_seg_ptr - - (input) pointer to restructuring source segment
       45*
       46*   source_length - - (input) character length of source segment
       47*
       48*   (output) will come from the semantic action routines that the parser calls
       49*   as well as from the scanner listing segment output which includes error messages
       50*   ( the listing is in source_seg.list )
       51*
       52**/
       53 
       54 /* normal entry */
       55 
       56 	goto PARSE;
       57 
       58 
       59 
       60 
       61 
       62 
       63 
       64 
       65 
       66 
       67 
       68 /* debug switch set entry */
       69 
       70 debug_set: entry ();
       71 
       72 /* switch state of debug switch to regulate
       73*   debug output from parser */
       74 
       75 	debug_sw = ^debug_sw;
       76 	return;
       77 
       78 
       79 
       80 
       81 
       82 
       83 
       84 
       85 
       86 
       87 
       88 
       89 PARSE:
       90 
       91 /* if trace is on, call metering */
       92 
       93 	if ^rsc.trace_sw then ;
       94 	else call mrds_rst_meter (rsc_ptr, "mrds_rst_parse", "1"b /* in */, "");
       95 
       96 
       97 /* initialize the lexical analyzer, and semantic routines */
       98 
       99 	call mrds_rst_scanner$init (rsc_ptr, source_seg_ptr, source_length);
      100 	call mrds_rst_semantics$init (rsc_ptr);
      101 
      102 
      103 
      104 
      105 /* go forth and parse the source */
      106 
      107 /*
      108*
      109*   ________________________________________________________________________________
      110*
      111*   _____________________________________________________________
      112*   | initialize                                                  |
      113*   | do while (^EOI);                                            |
      114*   |      if READ_state then do;                                 |
      115*   |           enter state number into parse stack               |
      116*   |           if look-ahead stack empty                         |
      117*   |           then call scanner; /* puts to look-ahead stack * /|
      118*   |           look in read-table for 1st look-ahead symbol      |
      119*   |           if not found then ERROR                           |
      120*   |           set next state from read-table                    |
      121*   |           if look-ahead transition                          |
      122*   |           then delete 1 state from parse stack              |
      123*   |           else move symbol from look-ahead stack            |
      124*   |                            to lex stack                     |
      125*   |      end;                                                   |
      126*   |      else if LOOK_state then do; /* look ahead n * /        |
      127*   |           do until n symbols in look-ahead stack;           |
      128*   |                call scanner; /* put to look-ahead stack * / |
      129*   |           end;                                              |
      130*   |           look in look-table for n'th look-ahead symbol     |
      131*   |           if not found then ERROR                           |
      132*   |           set next state from look-table                    |
      133*   |      end;                                                   |
      134*   |      else if APPLY_state then do;                           |
      135*   |           call semantics                                    |
      136*   |           delete necessary symbols from lex stack           |
      137*   |           delete necessary states from parse stack          |
      138*   |           look in apply-table for top stacked state         |
      139*   |           set next state from apply-table                   |
      140*   |      end;                                                   |
      141*   | end;                                                        |
      142*   |_____________________________________________________________|
      143*   Generalized parse procedure.
      144*
      145**/
      146 
      147 /* get space for lexical stack */
      148 
      149 	call mrds_rst_rsc_alloc (rsc_ptr, LEX_STACK, lex_stack_ptr);
      150 	call mrds_rst_rsc_alloc (rsc_ptr, P_STRUCT, p_struct_ptr);
      151 	call mrds_rst_rsc_alloc (rsc_ptr, CUR_LEX_TOP, cur_lex_top_ptr);
      152 
      153 
      154 /* Parser for tables created by LRK. */
      155 
      156 
      157 	current_state = 1;
      158 	nil_sym = -1;				/* set nil_sym non-existant */
      159 	nil_flag = "0"b;				/* Initially not in skip error recovery */
      160 	ls_top, ps_top = 0;
      161 	la_put, la_get = 1;
      162 	la_ct = 0;
      163 	token_cnt = 0;
      164 	error_mark = -1;
      165 
      166 /* The parsing loop. */
      167 NEXT:
      168 	if (current_state = 0) then goto done_parse;
      169 	current_table = current_state;
      170 	string (db_data) = "";
      171 	db_data.state = current_state;
      172 	goto CASE (DPDA.v1 (current_table));
      173 
      174 CASE (3):						/* Shared look */
      175 	current_table = DPDA.v2 (current_table);
      176 CASE (1):						/* Look. */
      177 	la_use = mod (la_get + la_need - 1, -lbound (lex_stack, 1)) + 1;
      178 	if (la_need >= -lbound (lex_stack, 1) - 1) then call too_many (-lbound (lex_stack, 1), "lookahead");
      179 	la_need = la_need + 1;
      180 	goto read_look;
      181 
      182 CASE (10):					/* Shared read */
      183 	current_table = DPDA.v2 (current_table);
      184 
      185 CASE (9):						/* Read. */
      186 	db_data.type = "READ";
      187 	la_need = 1;
      188 	la_use = la_get;
      189 	goto read_look;
      190 
      191 CASE (2):						/* Stack and Shared read */
      192 	current_table = DPDA.v2 (current_table);
      193 
      194 CASE (0):						/* Stack and Read. */
      195 	db_data.type = "READ";
      196 	db_data.flag = "*";
      197 	la_need = 1;
      198 	la_use = la_get;
      199 	if (ps_top >= hbound (parse_stack, 1)) then call too_many (hbound (parse_stack, 1), "parse");
      200 	ps_top = ps_top + 1;			/* Top of  parsing stack. */
      201 	parse_stack (ps_top) = current_state;		/* Stack the current state. */
      202 	cur_lex_top (ps_top) = ls_top;		/* save current lex top (for recovery) */
      203 read_look:
      204 	do while (la_ct < la_need);			/* make sure enough symbols are available */
      205 	     call mrds_rst_scanner (addr (lex_stack), -la_put);
      206 	     la_put = mod (la_put, -lbound (lex_stack, 1)) + 1;
      207 	     la_ct = la_ct + 1;
      208 	end;
      209 	test_symbol = lex_stack.symbol (-la_use);
      210 	m = 0;
      211 	nil = 0;
      212 						/*	Look current symbol up in read list. */
      213 	do i = current_table + 1 to current_table + DPDA.v2 (current_table);
      214 	     n = DPDA.v1 (i);
      215 	     dcl	   an		      fixed bin (24);
      216 	     if n < 0 then an = -n;
      217 	     else an = +n;
      218 	     if (an = test_symbol) then do;
      219 		     next_state = DPDA.v2 (i);
      220 		     goto got_symbol;
      221 		end;
      222 	     if (an > test_symbol) then do;
      223 		     do i = i to current_table + DPDA.v2 (current_table);
      224 			if abs (DPDA.v1 (i)) = nil_sym then nil = i;
      225 		     end;
      226 		     go to not_found;
      227 		end;
      228 	     if n < 0 then m = i;			/* Record a default transition. */
      229 	     else if n = nil_sym then nil = i;		/* Record a nil symbol transition
      230*						   (for skip error recovery) */
      231 	end;
      232 not_found:
      233 	if (m > 0) then do;				/* if marked symbol was in table, use it */
      234 		next_state = DPDA.v2 (m);
      235 		goto got_symbol;
      236 	     end;
      237 
      238 	if nil_flag & nil > 0 then do;		/* If skip recovery has just occurred
      239*						   and there is a nil symbol
      240*						   transition take the transition
      241*						   and back up to the nil
      242*						   symbol in the lookahead
      243*						   stack. */
      244 		next_state = DPDA.v2 (nil);
      245 		la_get = mod (la_get - 2, -lbound (lex_stack, 1)) + 1;
      246 		la_ct = la_ct + 1;
      247 		test_symbol = nil_sym;
      248 		go to got_symbol;
      249 	     end;
      250 	line_number = lex_stack (-la_use).line;
      251 	if token_cnt > error_mark then
      252 	     if local_recovered () then goto read_look;
      253 
      254 	if skip_recovered () then do;
      255 		call mrds_rst_error (rsc_ptr, 3 /* severity */, mrds_error_$rst_parse_err_recover, (recov_msg));
      256 		goto NEXT;
      257 	     end;
      258 	if debug_sw then call ioa_$ioa_switch_nnl (iox_$user_output, " ^4i  ", current_state);
      259 	call ioa_$rs ("^a ^d ^a ^a", message, message_length,
      260 	     "Line", lex_stack (-la_get).line, "symbol", getermc (test_symbol, la_get));
      261 	call mrds_rst_error (rsc_ptr, 2 /* severity */, mrds_error_$rst_parse_err_no_recover, (message));
      262 	goto done_parse;
      263 
      264 got_symbol:
      265 	nil_flag = "0"b;				/* If skip error recovery was
      266*						   in progress, it is now
      267*						   complete. */
      268 	if debug_sw then do;
      269 		if (next_state < 0) then do;		/* is this a look-ahead state? */
      270 			db_data.type = "LK01";
      271 			db_look = la_need;
      272 			db_data.data = geterm (test_symbol, 0); /* display only terminal "name" on look-ahead */
      273 			db_data.flag = " ";
      274 		     end;
      275 		else do;
      276 			db_data.data = getermc (test_symbol, la_get); /* display terminal "name" and data, if available */
      277 		     end;
      278 		call ioa_$ioa_switch_nnl (iox_$user_output, "^a^/", string (db_data));
      279 	     end;
      280 	current_state = next_state;
      281 	if (current_state < 0) then do;		/* Transition is a look-ahead state. */
      282 		current_state = -current_state;
      283 	     end;
      284 	else do;
      285 		if (ls_top >= hbound (lex_stack, 1)) then call too_many (hbound (lex_stack, 1), "lexical");
      286 		ls_top = ls_top + 1;
      287 		lex_stack (ls_top) = lex_stack (-la_get);
      288 		la_get = mod (la_get, -lbound (lex_stack, 1)) + 1;
      289 		la_ct = la_ct - 1;
      290 		token_cnt = token_cnt + 1;
      291 	     end;
      292 	goto NEXT;
      293 
      294 CASE (6):						/* Apply Shared */
      295 	current_table = DPDA.v2 (current_state + 3);
      296 CASE (4):						/* Apply state. */
      297 CASE (5):						/* Apply single */
      298 	la_need = 1;
      299 	rulen = DPDA.v1 (current_state + 2);
      300 	altn = DPDA.v2 (current_state + 2);
      301 	if debug_sw then do;
      302 		db_data.type = "APLY";
      303 		db_data.data = "(";
      304 		call ioa_$ioa_switch_nnl (iox_$user_output, "^a^i ^i)", string (db_data), rulen, altn);
      305 	     end;
      306 	if (rulen > 0) then do;
      307 		if rsc_ptr -> rsc.severity_high >= 3 then ; /* forget semantics if skip recovery has occured */
      308 		else call mrds_rst_semantics (rulen, altn, lex_stack_ptr, ls_top);
      309 	     end;
      310 	if debug_sw then do;
      311 		call ioa_$ioa_switch_nnl (iox_$user_output, "^-pd=^i ld=^i("
      312 		     , DPDA.v1 (current_state + 1), DPDA.v2 (current_state + 1));
      313 		do t = ps_top to ps_top - DPDA.v1 (current_state + 1) + 1 by -1;
      314 		     call ioa_$ioa_switch_nnl (iox_$user_output, " ^d", parse_stack (t));
      315 		end;
      316 		call ioa_$ioa_switch_nnl (iox_$user_output, ")^/");
      317 	     end;
      318 						/* *	Check for an apply of an empty production.
      319*						   In this case the apply state number must be
      320*						   pushed on the parse stack. (Reference
      321*						   LaLonde, W. R.:  An Efficient LALR Parser Generator.
      322*						   Tech. Report CSRG-2, 1971, pp. 34-35.)  * */
      323 	if DPDA.v1 (current_state + 1) = -1 then do;
      324 		if (ps_top >= hbound (parse_stack, 1)) then call too_many (hbound (parse_stack, 1), "parse");
      325 		parse_stack (ps_top + 1) = current_state;
      326 	     end;
      327 	ps_top = ps_top - DPDA.v1 (current_state + 1);	/* Delete parse stack states. */
      328 	ls_top = ls_top - DPDA.v2 (current_state + 1);	/* delete lex stack states */
      329 	if ps_top <= 0 then do;
      330 		call ioa_$rs ("^a", message, message_length, "Parse stack empty");
      331 		call mrds_rst_error (rsc_ptr, 4 /* severity */, mrds_error_$rst_parse_fail, (message));
      332 		goto done_parse;
      333 	     end;
      334 	do i = current_table + 4 to current_table + DPDA.v2 (current_table);
      335 	     if (DPDA.v1 (i) = parse_stack (ps_top)) then do;
      336 		     current_state = DPDA.v2 (i);
      337 		     goto NEXT;
      338 		end;
      339 	end;
      340 	current_state = DPDA.v2 (current_table + 3);
      341 	goto NEXT;
      342 done_parse:
      343 	if rsc.trace_sw then call mrds_rst_meter (rsc_ptr, "mrds_rst_parse", "0"b /* out */, "");
      344 	return;
      345 						/* %page; */
      346 skip_recovered: proc returns (bit (1));
      347 
      348 /* *
      349*   Skip recovery requires that the user difine one or more  recovery
      350*   terminal symbols by means of the
      351*
      352*   -recover <nil> st1 st2 ...
      353*
      354*   control  included  in  the  lrk  source.   st1  st2 etc. are skip
      355*   terminals.  They are terminals which can  end  statements.   They
      356*   cause  a  table  to  be built for skip recovery.  This table is a
      357*   list of read or lookahead states which can follow the reading  of
      358*   a skip terminal. These states correspond to the beginnings of new
      359*   statements.
      360*
      361*   Skip  recovery  is  done  when  an  error  has occurred and local
      362*   recovery (if used) was not successful.  Basically what it does is
      363*   to skip forward in the source by calling  the  scanner  until  it
      364*   encounters  one  of  the skip terminals.  It then tries to find a
      365*   state which followed a previous occurrence of the found terminal.
      366*   If one is found it adjusts the lexical and parse stacks and  then
      367*   procedes.
      368*
      369*   Effectively  a  bad "statement" has been discarded.  In this case
      370*   "statement" means an input string bounded by two  identical  skip
      371*   terminals  (such  as  ";"  for  example)  including  the boundary
      372*   terminal on  the  right.   If  the  language  is  such  that  the
      373*   discarded  statement  is optional (syntactically) the rest of the
      374*   input can be checked for syntax errors.
      375*
      376*   When a bad "statement" is discarded the parser  is  restarted  in
      377*   the  state  in  which it began to process that statement.  If the
      378*   next input symbol encountered is not acceptable  to  this  state,
      379*   the  parser  makes  a last attempt at error recovery by replacing
      380*   the bad "statement" with the <nil> symbol defined by the -recover
      381*   control if used.
      382*
      383*   The <nil> symbol is one which the scanner must NEvER  return.  It
      384*   is  needed  because some languages do not allow all statements to
      385*   occur at every point.  This means that when you back  up  to  the
      386*   last  statement  beginning  point, you may not be allowed to have
      387*   the statement you find next.  As an example, take  this  grammar:
      388*   <g>  ::= <i> | <g> <i> !
      389*   <i>  ::= <a> | <b> !
      390*   <a>  ::= a ; <rd> !
      391*   <rd> ::= r ; | <rd> r ; !
      392*   <b>  ::= b ; <sd> !
      393*   <sd> ::= s ; | <sd> s ; !
      394*   %page;
      395*   Then  suppose  that  you  intended to have an input like line (1)
      396*   below, but instead you got (2):
      397*
      398*   (1)  a ; r ; r ; b ; s ; s ; s ; a ; r ; r ; r ;
      399*   (2)  a ; r ; r ; b ; s ; s ; s   a ; r ; r ; r ;
      400*
      401*   Suppose that the grammar had specified
      402*   -recover <nil> ;
      403*   and local recovery  is  not  used.   When  the  "s"  "a"  ";"  is
      404*   encountered,  skip  recovery  will discard it as a bad statement.
      405*   But this then means that it will miss the fact that it should  be
      406*   entering  the  <a>  rule.   It  will  then get to the "r" but the
      407*   parser will have restarted in a state which can  read  either  an
      408*   "a",  "b",  or  "s".   So  it  will  have to skip again.  In this
      409*   example, skipping will occur, one statement at a time, until  EOI
      410*   is reached.  This means that no syntax checking is done in all of
      411*   the "r" s which are skipped.  This is not highly desireable.
      412*
      413*   However, if you add a rule like this:
      414*
      415*   <a>  ::= <nil> <rd> !
      416*   then  the  generated <nil> from skip recovery will allow the <rd>
      417*   to be correctly parsed, reducing  the  number  of  useless  error
      418*   messages by quite a bit, usually.
      419*
      420*   These <nil> rules can help parse thru misplaced statements during
      421*   error  recovery,  but  will  never  accept these statements under
      422*   normal circumstances.  The semantics on these <nil> rules  should then report an error.
      423*   */
      424 
      425 
      426 	dcl     (i, ii)		 fixed bin (24);
      427 	dcl     (j, jj)		 fixed bin (24);
      428 	dcl     c			 fixed bin (24);
      429 	dcl     dec4		 pic "zzz9";
      430 
      431 /* * %page; */
      432 
      433 
      434 	if (hbound (skip_v1, 1) <= 0) then return ("0"b); /* no skip table */
      435 	error_mark = 0;
      436 	current_table = 1;
      437 	recov_msg = "Unuseable ";
      438 	recov_msg = recov_msg || geterm (test_symbol, la_get);
      439 	recov_msg = recov_msg || " on line ";
      440 	dec4 = lex_stack (-la_get).line;
      441 	recov_msg = recov_msg || ltrim (dec4);
      442 	recov_msg = recov_msg || ",  Skipped to ";
      443 
      444 	nil_sym = skip_v1 (2);			/* SKIP table */
      445 	c = 1;
      446 	do while (c ^= 0);
      447 	     if (la_ct < 1) then do;			/* if look-ahead stack is empty, get a symbol */
      448 		     call mrds_rst_scanner (addr (lex_stack), -la_put);
      449 		     la_put = mod (la_put, -lbound (lex_stack, 1)) + 1;
      450 		     la_ct = 1;
      451 		end;
      452 	     c = lex_stack.symbol (-la_get);
      453 	     do i = current_table + 2 to current_table + skip_v2 (current_table); /* SKIP table */
      454 		if (skip_v1 (i) = c) then do;		/* SKIP table */
      455 			jj = skip_v2 (i);		/* SKIP table */
      456 			do j = ps_top to 1 by -1;
      457 			     do ii = jj + 1 to jj + skip_v2 (jj); /* SKIP table */
      458 				if (skip_v1 (ii) = parse_stack (j)) then do; /* SKIP table */
      459 					ps_top = j - 1;
      460 					ls_top = cur_lex_top (j);
      461 					current_state = skip_v2 (ii); /* SKIP table */
      462 					recov_msg = recov_msg || geterm (c, 0);
      463 					recov_msg = recov_msg || " on line ";
      464 					dec4 = lex_stack (-la_get).line;
      465 					recov_msg = recov_msg || ltrim (dec4)
      466 					     || " " || copy ("!*!", 26);
      467 					lex_stack (-la_get).symlen = 0;
      468 						/* generate a nil symbol into the look-ahead stack */
      469 					lex_stack (-la_get).symbol = nil_sym;
      470 					la_get = mod (la_get, -lbound (lex_stack, 1)) + 1;
      471 						/* Advance past nil symbol.
      472*						   It will not be used unless
      473*						   the next symbol cannot be read. */
      474 					la_ct = la_ct - 1;
      475 					nil_flag = "1"b;
      476 					return ("1"b);
      477 				     end;
      478 			     end;
      479 			end;
      480 		     end;
      481 	     end;
      482 	     la_get = mod (la_get, -lbound (lex_stack, 1)) + 1;
      483 	     la_ct = la_ct - 1;
      484 	end;
      485 	recov_msg = recov_msg || end_of_input_msg || copy ("!*!", 26);
      486 	current_state = 0;
      487 	return ("1"b);
      488      end;
      489 
      490 	dcl     (addr, mod, fixed)	 builtin;
      491 	dcl     db_look		 pic "99" defined (db_data.type) pos (3);
      492 	dcl     1 db_data,
      493 		2 flag		 char (1),	/* * means stacked */
      494 		2 state		 pic "zzz9",
      495 		2 fil1		 char (2),
      496 		2 type		 char (6),
      497 		2 data		 char (100);
      498 	dcl     DDop		 (-1:2) char (4) int static init ("LOOK", "FINI", "READ", "ERR");
      499 	dcl     ioa_$ioa_switch_nnl	 entry options (variable);
      500 	dcl     iox_$user_output	 ptr ext static;
      501 
      502 
      503 	;
      504 	dcl     ls_top		 fixed bin (24);	/* location of top of lexical stack */
      505 	dcl     altn		 fixed bin (24);	/* APPLY alternative number */
      506 	dcl     current_state	 fixed bin (24);	/* number of current state */
      507 	dcl     test_symbol		 fixed bin (24);	/* encoding of current symbol */
      508 	dcl     current_table	 fixed bin (24);	/* number of current table */
      509 	dcl     i			 fixed bin (24);	/* temp */
      510 	dcl     la_ct		 fixed bin (24);	/* number of terminals in look-ahead stack */
      511 	dcl     la_get		 fixed bin (24);	/* location in look_ahead stack to get next symbol */
      512 	dcl     la_need		 fixed bin (24);	/* number of look-ahead symbols needed */
      513 	dcl     la_put		 fixed bin (24);	/* location in look_ahead stack to put next symbol */
      514 	dcl     la_use		 fixed bin (24);	/* location in look-ahead stack to test with */
      515 	dcl     (m, n)		 fixed bin (24);
      516 	dcl     next_state		 fixed bin (24);	/* number of next state */
      517 	dcl     nil_sym		 fixed bin (24);
      518 	dcl     nil		 fixed bin (24);
      519 	dcl     nil_flag		 bit (1);
      520 	dcl     ps_top		 fixed bin (24);	/* location of top of parse stack */
      521 	dcl     recov_msg		 char (150) var;
      522 	dcl     rulen		 fixed bin (24);	/* APPLY rule number */
      523 	dcl     t			 fixed bin (24);
      524 	dcl     sys_info$max_seg_size	 fixed binary (35) external; /* largest segment size */
      525 	dcl     token_cnt		 fixed binary (24); /* number of tokens used */
      526 	dcl     error_mark		 fixed binary (24); /* point to get past before another local correction allowed */
      527 	dcl     line_number		 fixed binary (24); /* line where error detected */
      528 						/* %page; */
      529 geterm: proc (idx, ids) returns (char (100) var);
      530 
      531 	dcl     (idx, ids)		 fixed bin (24);
      532 	dcl     temp		 char (100) var;
      533 	dcl     c_str		 char (20000) based;
      534 
      535 	temp = "";
      536 get_rest:
      537 	if (ids > 0) then
      538 	     if (lex_stack (-ids).symlen > 0) then do;
      539 		     temp = temp || """";
      540 		     temp = temp || substr (lex_stack (-ids).symptr -> c_str, 1, min (50, lex_stack (-ids).symlen));
      541 		     temp = temp || """";
      542 		     return (temp);
      543 		end;
      544 	if (idx = 0) then temp = end_of_input_msg;
      545 	else temp = substr (string (TC), TL.fc (idx), TL.ln (idx));
      546 	return (temp);
      547 getermc: entry (idx, ids) returns (char (100) var);
      548 
      549 	if (idx = 0) then temp = end_of_input_msg;
      550 	else temp = substr (string (TC), TL.fc (idx), TL.ln (idx));
      551 	temp = temp || " ";
      552 	goto get_rest;
      553      end;
      554 
      555 local_recovered: proc returns (bit (1));
      556 
      557 /*
      558*   "    this procedure implements the LRK local error recovery (using
      559*   "    the  DPDA  table).  This  is  done by using the current (bad)
      560*   "    symbol and the next input symbol. All  possible  parses  from
      561*   "    this state are examined. These trial parses proceed until the
      562*   "    next read or lookahead state is encountered. The trial parses
      563*   "    are true simulations of what  can  happen,  apply  states are
      564*   "    chosen according to the simulated top of parse stack.
      565*
      566*   "    Given:
      567*   "         B is the current symbol (bad)
      568*   "         N is the next input symbol
      569*   "         C is the current state
      570*   "         R is a "next" read state
      571*   "    These are the conditions which can exist.
      572*   "         C( N )    R( B N )    -kind-
      573*   "            0         1 0    symbol leading to R is missing
      574*   "            0         0 1    B is a wrong symbol
      575*   "            1         1 0    B and N reversed in input
      576*   "            1         0 x    B is an extra symbol in the input
      577*   "            0         0 0    recovery fails
      578*
      579*   "    The recovery tries to find  a  useable  combination.  If  one
      580*   "    exists,  the  search  does  not  stop.  If  a  second  one is
      581*   "    encountered, the search stops, a message is  generated  which
      582*   "    says the choice is not unique, and then the first combination
      583*   "    is used.
      584*
      585*   "    The local recovery shcheme was altered in  Sept  1977  by  Al
      586*   "    Kepner  to  allow  local  recovery from errors encountered by
      587*   "    look-ahead states.  Preveously  only  errors  encountered  by
      588*   "    read states could be handled.  The error correction scheme is
      589*   "    still the same heuristic described above.
      590*   "
      591*   "    Some  complexity has been added to procedure next_term.  Note
      592*   "    the new variables la_get2 and la_use2.  These  are  necessary
      593*   "    to  handle  the  case  where  an  error  is  encountered by a
      594*   "    look-ahead state and the next state found is not a look-ahead
      595*   "    state.  In this case the next  read  state  encountered  will
      596*   "    correspond  to the "bad" symbol or a symbol to the left of it
      597*   "    (depending on how many look-ahead states preceded the error).
      598*   "    The goal is to  find  the  read  or  look-ahead  state  which
      599*   "    corresponds  to  the  input  symbol to the right of the "bad"
      600*   "    symbol.  The goal is recognized by the condition  "la_use2  =
      601*   "    la_next".   Until  this  goal  is reached look-ahead and read
      602*   "    states are simply passed through using the  look-ahead  stack
      603*   "    to find the appropriate next state.
      604*   */
      605 
      606 
      607 
      608 
      609 
      610 
      611 
      612 
      613 	if (test_symbol < 0) then do;
      614 		call ioa_$rs ("^a ^d ^a", message, message_length,
      615 		     "Line", lex_stack (-la_get).line, "Negative terminal; cannot recover");
      616 		call mrds_rst_error (rsc_ptr, 2 /* severity */, mrds_error_$rst_parse_err_no_correct, (message));
      617 		return ("0"b);
      618 	     end;
      619 	error_mark = token_cnt + la_need;
      620 	do while (la_ct < la_need + 1);
      621 	     call mrds_rst_scanner (addr (lex_stack), -la_put);
      622 	     la_put = mod (la_put, -lbound (lex_stack, 1)) + 1;
      623 	     la_ct = la_ct + 1;
      624 	end;
      625 	if hbound (skip_v1, 1) > 0 then nil_sym = skip_v1 (2); /* SKIP table */
      626 	else nil_sym = -1;
      627 	la_next = mod (la_use, -lbound (lex_stack, 1)) + 1;
      628 	next_symbol = lex_stack (-la_next).symbol;
      629 	dcl     string		 builtin;
      630 	string (sws) = "0"b;
      631 	transit = -1;
      632 	combinations = 0;
      633 	depth = 0;
      634 	if debug_sw then call dump_la;
      635 	do i = current_table + 1 to current_table + DPDA.v2 (current_table) while (combinations < 2);
      636 	     alt_symbol = abs (DPDA.v1 (i));
      637 	     if alt_symbol = nil_sym then go to try_again;
      638 	     if debug_sw then call ioa_$ioa_switch_nnl (iox_$user_output, "#^4i ^4a ^i ^a^/",
      639 		     current_state, DDop (sign (DPDA.v2 (i))), alt_symbol, geterm (alt_symbol, 0));
      640 	     string (cycle) = "0"b;
      641 	     if combinations < 2 then
      642 		call next_term ((ps_top), (DPDA.v2 (i)));
      643 try_again:
      644 	end;
      645 	recov_msg = "";
      646 	if (transit = -1) then return ("0"b);
      647 	goto case (fixed (string (sws)));
      648 
      649 case (0):						/* can't resolve it */
      650 	return ("0"b);
      651 
      652 case (3):
      653 case (7):						/* cannot occur */
      654 	signal condition (logic_error);
      655 	dcl     logic_error		 condition;
      656 
      657 case (1):						/* B is wrong symbol */
      658 	recov_msg = recov_msg || geterm (transit, 0);
      659 	recov_msg = recov_msg || " used in place of erroneous ";
      660 	recov_msg = recov_msg || geterm (test_symbol, la_get);
      661 	goto set_symbol;
      662 
      663 case (2):						/* symbol leading to R is missing */
      664 	recov_msg = recov_msg || "Missing ";
      665 	recov_msg = recov_msg || geterm (transit, 0);
      666 	recov_msg = recov_msg || " is assumed before ";
      667 	recov_msg = recov_msg || geterm (test_symbol, la_get);
      668 	la_ct = la_ct + 1;
      669 	lex_stack (-la_put) = lex_stack (-la_next);
      670 	lex_stack (-la_next) = lex_stack (-la_use);
      671 	la_put = mod (la_put, -lbound (lex_stack, 1)) + 1;
      672 set_symbol:
      673 	lex_stack (-la_use).token_num = 0;		/* flag as phoney token for semantics */
      674 	la_next = la_use;
      675 	lex_stack (-la_next).symptr = addr (default_symbol);
      676 	lex_stack (-la_next).symlen = length (default_symbol);
      677 	lex_stack (-la_next).line = lex_stack (-(mod (la_put - 2, -lbound (lex_stack, 1)) + 1)).line;
      678 	lex_stack (-la_next).symbol = transit;
      679 	goto done;
      680 
      681 case (4):
      682 case (5):						/* B is an extra symbol */
      683 	recov_msg = recov_msg || "Extraneous ";
      684 	recov_msg = recov_msg || geterm (test_symbol, la_use);
      685 	recov_msg = recov_msg || " ignored before ";
      686 	recov_msg = recov_msg || geterm (next_symbol, la_next);
      687 	la_ct = la_ct - 1;
      688 	la_put = mod (la_put - 2, -lbound (lex_stack, 1)) + 1; /* Back up one in look-ahead stack. */
      689 	lex_stack (-la_use) = lex_stack (-la_next);
      690 	goto done;
      691 
      692 case (6):						/* B and N reversed */
      693 	recov_msg = recov_msg || geterm (test_symbol, la_use);
      694 	recov_msg = recov_msg || " and ";
      695 	recov_msg = recov_msg || geterm (next_symbol, la_next);
      696 	recov_msg = recov_msg || " are reversed.";
      697 	lex_stack (ls_top + 1) = lex_stack (-la_use);
      698 	lex_stack (-la_use) = lex_stack (-la_next);
      699 	lex_stack (-la_next) = lex_stack (ls_top + 1);
      700 done:
      701 	if combinations <= 1 then ;
      702 	else recov_msg = recov_msg || copy (" ", 30) || "(choose first of many possibilities)";
      703 	call ioa_$rs ("^a ^d ^a", message, message_length,
      704 	     "Line", line_number, recov_msg);
      705 	call mrds_rst_error (rsc_ptr, 1 /* severity */, mrds_error_$rst_parse_err_correct, (message));
      706 	if debug_sw then call dump_la;
      707 	return ("1"b);				/* recovery completed */
      708 
      709 	dcl     1 sws,
      710 		2 CNf		 bit (1) unal,	/* current state contains next symbol */
      711 		2 RBNf		 bit (2) unal;	/* next read matches bad or next symbol */
      712 	dcl     combinations	 fixed bin (24);	/* useable combinations found so far */
      713 	dcl     transit		 fixed bin (24);	/* found alternate symbol to use from current state */
      714 	dcl     la_next		 fixed bin (24);	/* temporary "next" look-ahead position */
      715 	dcl     alt_symbol		 fixed bin (24);	/* current alternate symbol */
      716 	dcl     cycle		 (4000) bit (1) unal;
      717 	dcl     default_symbol	 char (13) int static init ("ERROR_SYMBOL_");
      718 	dcl     next_symbol		 fixed bin (24);
      719 	dcl     depth		 fixed bin (24);
      720 						/* %page; */
      721 
      722 dump_la: proc;
      723 
      724 	dcl     ii		 fixed bin (24);
      725 	if debug_sw then do;
      726 		ii = la_get;
      727 		do while (ii ^= la_put);
      728 		     call ioa_$ioa_switch_nnl (iox_$user_output, "#la(-^i) ^3i""^a""^/",
      729 			ii,
      730 			lex_stack (-ii).symbol,
      731 			geterm (lex_stack (-ii).symbol, 0));
      732 		     ii = mod (ii, -lbound (lex_stack, 1)) + 1;
      733 		end;
      734 	     end;
      735      end dump_la;
      736 						/* %page; */
      737 next_term: proc (top, ns);
      738 
      739 	look_ahead = (ns < 0);
      740 	if look_ahead then do;
      741 		la_use2 = la_use;
      742 		la_get2 = la_get;
      743 	     end;
      744 	else la_use2, la_get2 = mod (la_get, -lbound (lex_stack, 1)) + 1;
      745 	depth = depth + 5;
      746 	do i = 1 to ps_top;
      747 	     parse_stack2 (i) = parse_stack (i);
      748 	end;
      749 NEXT:
      750 	if (ns = 0) then do;
      751 		transit = 0;
      752 		depth = depth - 5;
      753 		go to done;
      754 	     end;
      755 	ns = abs (ns);
      756 	cur_st = ns;
      757 	if DPDA.v1 (cur_st) = 0 | DPDA.v1 (cur_st) = 2 then do; /* Stack state? */
      758 		if top >= hbound (parse_stack, 1) then call too_many (hbound (parse_stack, 1), "parse");
      759 		top = top + 1;
      760 		parse_stack (top) = cur_st;
      761 	     end;
      762 	goto CASE (DPDA.v1 (cur_st));
      763 CASE (2):						/* Stack and Shared read */
      764 CASE (3):						/* Shared look */
      765 CASE (10):					/* Shared read */
      766 	cur_st = DPDA.v2 (cur_st);
      767 CASE (0):						/* Stack and Read. */
      768 CASE (1):						/* Look. */
      769 CASE (9):						/* Read. */
      770 	if DPDA.v1 (cur_st) = 1 then
      771 	     la_use2 = mod (la_use2, -lbound (lex_stack, 1)) + 1;
      772 	else la_use2 = la_get2;
      773 	if la_use2 = la_next then do;
      774 		if debug_sw then call ioa_$ioa_switch_nnl (iox_$user_output, "#^vx^4i READ^/", depth, ns);
      775 		rep = 0;
      776 		do s = test_symbol, next_symbol while (next_symbol ^= alt_symbol);
      777 		     rep = rep + 1;
      778 		     do i = cur_st + 1 to cur_st + DPDA.v2 (cur_st) while (combinations < 2);
      779 			if ((DPDA.v1 (i) < 0) & (-DPDA.v1 (i) <= s))
      780 			     | (DPDA.v1 (i) = s) then do;
      781 				if debug_sw then
      782 				     call ioa_$ioa_switch_nnl (iox_$user_output, "#^vx(^i)^i^/", depth, rep, s);
      783 				if (combinations = 0) then do;
      784 					combinations = 1;
      785 					transit = alt_symbol;
      786 					if (rep = 1) then RBNf = "10"b;
      787 					else RBNf = "01"b;
      788 				     end;
      789 				else combinations = 2;
      790 			     end;
      791 		     end;
      792 		end;
      793 		if (next_symbol = alt_symbol) then do;
      794 			if (combinations = 0) then do;
      795 				CNf = "1"b;
      796 				do i = cur_st + 1 to cur_st + DPDA.v2 (cur_st);
      797 				     if ((DPDA.v1 (i) < 0) & (-DPDA.v1 (i) <= test_symbol))
      798 					| DPDA.v1 (i) = test_symbol then
      799 					RBNf = "10"b;
      800 				end;
      801 				transit = alt_symbol;
      802 				combinations = 1;
      803 			     end;
      804 			else combinations = 2;
      805 		     end;
      806 done:
      807 		depth = depth - 5;
      808 		do i = 1 to ps_top;
      809 		     parse_stack (i) = parse_stack2 (i);
      810 		end;
      811 		return;
      812 	     end;
      813 	else do;
      814 		if la_use2 = la_use			/* la_use points to the bad input symbol. */
      815 		then s = alt_symbol;		/* We are considering an alternate symbol. */
      816 		else
      817 		     s = lex_stack (-la_use2).symbol;
      818 		marked = 0;
      819 		do i = cur_st + 1 to cur_st + DPDA.v2 (cur_st)
      820 		     while (abs (DPDA.v1 (i)) <= s);
      821 		     if abs (DPDA.v1 (i)) = s then
      822 			go to found;
      823 		     else if DPDA.v1 (i) < 0 then
      824 			marked = i;
      825 		end;
      826 		if marked ^= 0 then
      827 		     i = marked;
      828 		else go to done;
      829 found:
      830 		ns = DPDA.v2 (i);
      831 		if ns >= 0 then
      832 		     la_get2 = mod (la_get2, -lbound (lex_stack, 1)) + 1;
      833 		go to NEXT;
      834 	     end;
      835 CASE (4):						/* Apply state. */
      836 CASE (5):						/* Apply single */
      837 CASE (6):						/* Apply Shared */
      838 	if debug_sw then call ioa_$ioa_switch_nnl (iox_$user_output, "#^vx^4i APLY^/", depth, ns);
      839 	if DPDA.v1 (cur_st + 1) = -1 then do;
      840 		if (top >= hbound (parse_stack, 1)) then call too_many (hbound (parse_stack, 1), "parse");
      841 		parse_stack (top + 1) = cur_st;
      842 	     end;
      843 	top = top - DPDA.v1 (cur_st + 1);
      844 	if (DPDA.v1 (cur_st) = 6) then
      845 	     cur_st = DPDA.v2 (cur_st + 3);
      846 	if top > 0 then
      847 	     do i = cur_st + 4 to cur_st + DPDA.v2 (cur_st);
      848 		if (DPDA.v1 (i) = parse_stack (top)) then do;
      849 			ns = DPDA.v2 (i);
      850 			goto NEXT;
      851 		     end;
      852 	     end;
      853 	else return;
      854 	ns = DPDA.v2 (cur_st + 3);
      855 	goto NEXT;
      856 
      857 
      858 
      859 
      860 
      861 	dcl     top		 fixed bin (24),	/* top of parse stack for this invocation */
      862 	        ns		 fixed bin (24);	/* branch to follow */
      863 
      864 	dcl     cur_st		 fixed bin (24);	/* current state for this recursion */
      865 	dcl     rep		 fixed bin (24);
      866 	dcl     s			 fixed bin (24);
      867 	dcl     look_ahead		 bit (1);
      868 	dcl     i			 fixed bin (24);
      869 	dcl     la_get2		 fixed bin (24);
      870 	dcl     la_use2		 fixed bin (24);
      871 	dcl     marked		 fixed bin (24);
      872      end next_term;
      873      end local_recovered;
      874 
      875 /* * %page; */
      876 
      877 too_many: proc (x, t);
      878 	p6 = x;
      879 	call ioa_$rs ("^a", message, message_length,
      880 	     "Exceeded " || p6 || " entries of lrk " || t || " stack.");
      881 	call mrds_rst_error (rsc_ptr, 4 /* severity */, mrds_error_$rst_parse_fail, (message));
      882 	go to stop;
      883 
      884 /* *	variables for too_many:	*/
      885 	dcl     p6		 pic "zzzzz9";
      886 	dcl     t			 char (*) parm;
      887 	dcl     x			 fixed bin (24) parm;
      888      end too_many;
      889 stop:
      890 	;
      891 
      892 
      893 
      894 	dcl     (abs, copy, hbound, lbound, length, ltrim,
      895 	        min, rel, sign, string, substr) builtin;
      896 	dcl     source_seg_ptr	 ptr;		/* restructuring directives source segment pointer */
      897 	dcl     source_length	 fixed binary (24); /* character length of source segment */
      898 	dcl     mrds_rst_rsc_alloc	 entry (ptr, fixed bin, ptr); /* working area allocate routine */
      899 	dcl     mrds_rst_scanner$init	 entry (ptr, ptr, fixed binary (24)); /* scanner initialization entry */
      900 	dcl     mrds_rst_scanner	 entry (ptr, fixed bin (24)); /* lexical analyzer routine */
      901 	dcl     mrds_rst_semantics	 entry (fixed bin (24), fixed bin (24), ptr, fixed bin (24)); /* semantic action routines */
      902 	dcl     mrds_rst_semantics$init entry (ptr);	/* semantic initialization entry */
      903 	dcl     mrds_rst_error	 entry (ptr, fixed bin, fixed bin (35), char (*)); /* error handling routine */
      904 	dcl     ioa_$rs		 entry options (variable); /* routine to return string */
      905 	dcl     message		 char (128) varying;/* message with details of error */
      906 	dcl     message_length	 fixed binary;	/* length of returned error message */
      907 	dcl     mrds_rst_meter	 entry (ptr, char (*), bit (1), char (*)); /* metering routine */
      908 	dcl     mrds_error_$rst_parse_err_recover fixed bin (35) external; /* skip recovery error */
      909 	dcl     mrds_error_$rst_parse_err_no_recover fixed bin (35) external; /* unable to skip recover  */
      910 	dcl     mrds_error_$rst_parse_err_correct fixed bin (35) external; /* local correction error */
      911 	dcl     mrds_error_$rst_parse_err_no_correct fixed bin (35) external; /* unable to correct locally */
      912 	dcl     mrds_error_$rst_parse_fail fixed bin (35) external; /* parsing cannot proceed error */
      913 	dcl     end_of_input_msg	 char (18) init (" --END_OF_INPUT-- "); /* EOI message */
      914 
      915 
      916 
      917 
      918 
      919 
      920 
      921 
      922 
      923 
      924 
      925 
  1     1 /* BEGIN INCLUDE FILE mrds_rst_parse_stack.incl.pl1  jeg 8/8/78 */
  1     2 
  1     3 declare 1 lex_stack (-5:50) based (lex_stack_ptr),
  1     4         2 symptr ptr,				/* pointer to terminal symbol in source input */
  1     5         2 symlen fixed binary (24),			/* length of terminal symbol in input */
  1     6         2 line fixed binary (24),			/* line number in source for this symbol */
  1     7         2 symbol fixed binary (24),			/* parser's encoding value for the terminal symbol */
  1     8         2 val fixed binary (71),			/* conversion value for numbers */
  1     9         2 float float binary (63),			/* conversion value if floating point number */
  1    10         2 line_strt ptr,				/* pointer to start of current line */
  1    11         2 line_size fixed binary (24),			/* current length of line */
  1    12         2 token_num fixed binary (24) ;			/* number of this token in current line,
  1    13*						   0 if <error_symbol> for missing or wrong symbol */
  1    14 
  1    15 declare  lex_stack_ptr ptr ;				/* pointer to lexical stack */
  1    16 
  1    17 declare  debug_sw bit (1) static init ("0"b) ;		/* on => output debug messages */
  1    18 
  1    19 dcl 1 p_struct (50) aligned based (p_struct_ptr),
  1    20     2 parse_stack fixed bin (24),			/* * parse stack */
  1    21     2 parse_stack2 fixed bin (24);			/* * copy of parse stack used
  1    22*						   with local error recovery */
  1    23 
  1    24 dcl  p_struct_ptr ptr ;
  1    25 
  1    26 
  1    27 dcl  cur_lex_top (50) fixed bin (24) aligned based (cur_lex_top_ptr) ; /* current lex top stack (with parse_stack) */
  1    28 
  1    29 declare  cur_lex_top_ptr ptr ;
  1    30 
  1    31 
  1    32 /* END INCLUDE FILE mrds_rst_parse_stack.incl.pl1 */
  1    33 
      926 
      927 
  2     1 /* BEGIN INCLUDE FILE mrds_rst_parse_table.incl.pl1   (Davids Multics)  10/15/81 1622.8 mst Thu */
  2     2 
  2     3 dcl  1 mrds_rst_parse_table$DPDA	ext static,
  2     4 	  2 DPDAsize	fixed bin,
  2     5 	  2 DPDA(705),
  2     6 	    3(v1,v2)	fixed bin(17)unal;
  2     7 dcl  DPDAp	ptr;
  2     8 
  2     9 /*   END INCLUDE FILE mrds_rst_parse_table.incl.pl1 */
      928 
      929 
  3     1 /* BEGIN INCLUDE FILE mrds_rst_skip_table.incl.pl1   (Davids Multics)  10/15/81 1622.9 mst Thu */
  3     2 
  3     3 /* lrk_pl1_dpda   10/15/81  1622.5 mst Thu
  3     4*   Input:  >udd>Multics>Davids>tr>11714>mrds_rst_parse                  
  3     5*   Output: >udd>Multics>Davids>tr>11714>mrds_rst_skip_table.incl.pl1
  3     6**/
  3     7 dcl	skip_v1		(12)fixed bin(24) static int options(constant) init(
  3     8 7,34,4,8,11,47,510,580,596,602,623,644
  3     9 );
  3    10 dcl	skip_v2		(12)fixed bin(24) static int options(constant) init(
  3    11 2,0,4,8,(8)3
  3    12 );
  3    13 
  3    14 /*   END INCLUDE FILE mrds_rst_skip_table.incl.pl1 */
      930 
      931 
  4     1 /* BEGIN INCLUDE FILE mrds_rst_terminals.incl.pl1   (Davids Multics)  10/15/81 1622.7 mst Thu */
  4     2 dcl	1 mrds_rst_terminals		static internal,
  4     3 	  2 TC		( 339) char(1) init(
  4     4 "<","l","e","f","t","_","p","a","r","e","n","t","h","e",
  4     5 "s","i","s",">","<","r","i","g","h","t","_","p","a","r",
  4     6 "e","n","t","h","e","s","i","s",">","<","c","o","m","m",
  4     7 "a",">","<","s","e","m","i","c","o","l","o","n",">","<",
  4     8 "c","o","l","o","n",">","<","h","y","p","h","e","n",">",
  4     9 "<","a","s","t","e","r","i","s","k",">","<","p","l","u",
  4    10 "s",">","<","p","a","t","h","_","n","a","m","e",">","<",
  4    11 "e","n","t","r","y","_","n","a","m","e",">","<","p","o",
  4    12 "s","i","t","i","v","e","_","i","n","t","e","g","e","r",
  4    13 ">","<","i","d","e","n","t","i","f","i","e","r",">","<",
  4    14 "d","o","m","a","i","n",">","<","a","t","t","r","i","b",
  4    15 "u","t","e",">","<","r","e","l","a","t","i","o","n",">",
  4    16 "<","i","n","d","e","x",">","<","r","e","a","l",">","<",
  4    17 "c","o","m","p","l","e","x",">","<","f","i","x","e","d",
  4    18 ">","<","f","l","o","a","t",">","<","b","i","n","a","r",
  4    19 "y",">","<","d","e","c","i","m","a","l",">","<","p","r",
  4    20 "e","c","i","s","i","o","n",">","<","c","h","a","r",">",
  4    21 "<","b","i","t",">","<","v","a","r","y","i","n","g",">",
  4    22 "<","n","o","n","v","a","r","y","i","n","g",">","<","a",
  4    23 "l","i","g","n","e","d",">","<","u","n","a","l","i","g",
  4    24 "n","e","d",">","<","c","h","e","c","k","_","p","r","o",
  4    25 "c",">","<","e","n","c","o","d","e","_","p","r","o","c",
  4    26 ">","<","d","e","c","o","d","e","_","p","r","o","c",">",
  4    27 "<","d","e","c","o","d","e","_","d","c","l",">","<","n",
  4    28 "i","l",">"),
  4    29 	  2 TL		( 34),
  4    30 	    3 lk		fixed bin(24) init(
  4    31 ( 7) 0, 3,( 3) 0, 6, 5, 0,
  4    32  0, 0, 2, 0, 0, 12, 8, 1, 14,( 4) 0, 23,
  4    33  28, 17, 4, 31, 32, 25),
  4    34 	    3 fc		fixed bin(24) init(
  4    35  1, 19, 38, 45, 56, 63, 71, 81, 87, 98, 110, 128, 140, 148,
  4    36  159, 169, 176, 182, 191, 198, 205, 213, 222, 233, 239, 244, 253, 265,
  4    37  274, 285, 297, 310, 323, 335),
  4    38 	    3 ln		fixed bin(24) init(
  4    39  18, 19, 7, 11, 7, 8, 10, 6, 11, 12, 18, 12, 8, 11,
  4    40  10, 7, 6, 9, 7, 7, 8, 9, 11, 6, 5, 9, 12, 9,
  4    41  11, 12, 13, 13, 12, 5),
  4    42 	  2 THL		(0: 36) fixed bin(24) init(
  4    43 ( 6) 0, 24, 20, 0, 0, 27, 7, 0, 18,
  4    44  10, 0, 9, 0, 22, 21, 0, 0, 11, 0, 30, 13, 0, 19,
  4    45  0, 33, 29, 34, 0, 26, 0, 15, 16);
  4    46 
  4    47 /*   END INCLUDE FILE mrds_rst_terminals.incl.pl1 */
      932 
      933 
  5     1 /* BEGIN INCLUDE FILE mrds_rst_rsc.incl.pl1		RDL  7/7/78	*/
  5     2 
  5     3 /* Modified 8/21/78 by RDL */
  5     4 
  5     5 /* Modified 9/11/78 	by RDL to add directive and stmt pointers */
  5     6 
  5     7 /* Modified 11/4/78		by RDL to add debug,trace,meter switches
  5     8*
  5     9*   Modified 3/29/79 by RDL to change s_seg_info_ptr to source_seg_ptr
  5    10*
  5    11*   Modified by Jim Gray - - Jan. 1980, to add flags to disallow blocked files, forieng keys, and restructuring.
  5    12*
  5    13*   Modified by Jim Gray - - Feb. 1980, to add command level flag for cmdb subroutine interface.
  5    14*
  5    15*   Modified by Jim Gray - - 80-11-06, to add bit for cmdb -secure option.
  5    16*
  5    17*   81-05-18 Jim Gray : added bit for max_attributes error message, so that
  5    18*   it would only be issued on first occurence.
  5    19*
  5    20*   82-08-19 Davids: added the db_type field.
  5    21*
  5    22*   83-02-18 Mike Kubicar : Removed the db_type field and added the 
  5    23*   db_relation_mode_flags substructure to define the modes applicable
  5    24*   to the database's relations.  Also removed assorted unsed fields
  5    25*   (names that included the word unused).
  5    26*
  5    27**/
  5    28 
  5    29 dcl 1 rsc based (rsc_ptr),				/* Restructuring control info */
  5    30     2 rsc_dir char (200),				/* pathname of directory containing rsc segment */
  5    31     2 dbp char (168),				/* Database absolute path */
  5    32     2 temp_dir char (168),				/* Path name of temp restrucuring directory */
  5    33     2 temp_dir_sw bit (1) unal,			/* On => temp dir has been created */
  5    34     2 db_quiesced_sw bit (1) unal,			/* On => database has been quiesced */
  5    35     2 o_db_open_sw bit (1) unal,			/* On => old database has been opened */
  5    36     2 n_db_open_sw bit (1) unal,			/* On => temp database is open */
  5    37     2 listing_seg_sw bit (1) unal,			/* On => listing segment has been created */
  5    38     2 skip_scanner_conversion bit (1) unal,		/* Skip conversion in scanner */
  5    39     2 cmdb_option bit (1) unal,			/* ON => this is a cmdb source, not restructuring */
  5    40     2 trace_sw bit (1) unal,				/* On -> trace mode in affect */
  5    41     2 debug_sw bit (1) unal,				/* On = debug mode (NOT IMPLEMENTED) */
  5    42     2 meter_sw bit (1) unal,				/* On = procedures call metering procedure */
  5    43     2 delete_db_sw bit (1) unal,			/* On = delete data base in cleanup */
  5    44     2 model_consistent_sw bit (1) unal,			/* On => Model is consistent */
  5    45     2 physical_started_sw bit (1) unal,			/* On => Physical restructuring started */
  5    46     2 physical_complete_sw bit (1) unal,		/* On => Physical restructuring completed */
  5    47     2 model_overflow bit (1) unal,			/* ON => model segment area condition occurred */
  5    48     2 max_files bit (1) unal,				/* ON => maximum number of files reached */
  5    49     2 allow_foreign_keys bit (1) unal,			/* on => allow foreign key statment */
  5    50     2 foreign_key_seen bit (1) unal,			/* on => foreign key definition in source */
  5    51     2 allow_blocked_files bit (1) unal,			/* on => allow file statement with blocked option */
  5    52     2 blocked_file_seen bit (1) unal,			/* on => blocked file definition in source */
  5    53     2 allow_restructuring bit (1) unal,			/* on => allow RMDB entry point */
  5    54     2 command_level bit (1) unal,			/* on => called from command unal, not subroutine level */
  5    55     2 secure bit (1) unal,				/* on => -secure option given for cmdb */
  5    56     2 max_attrs bit (1) unal,				/* on => max attrs/rel or max indexes/rel exceeded */
  5    57     2 db_relation_mode_flags,
  5    58       3 dm_file_type bit (1) unal,			/* on => relations are dm files */
  5    59       3 protection_on bit (1) unal,			/* on => relations need transactions */
  5    60       3 concurrency_on bit (1) unal,			/* on => concurrency control enabled */
  5    61       3 rollback_on bit (1) unal,			/* on => before journalling is enabled */
  5    62     2 severity_high fixed bin,			/* Highest severity level error encountered */
  5    63     2 phase fixed bin,				/* 000 = init
  5    64*						   100 = global list init
  5    65*						   200 = parse
  5    66*						   300 = physical init
  5    67*						   400 = physical */
  5    68     2 h_o_seg_info_ls_ptr ptr,			/* Pointer to head of old db seg_info list */
  5    69     2 h_n_seg_info_ls_ptr ptr,			/* Pointer to head of new db seg_info list */
  5    70     2 h_gfile_ptr ptr,				/* Pointer to head of global file list */
  5    71     2 h_gdom_ptr ptr,				/* Pointer to head of global domain list */
  5    72     2 h_gattr_ptr ptr,				/* Pointer to head of global attribute list */
  5    73     2 h_grel_ptr ptr,				/* Pointer to head of global relation list */
  5    74     2 h_glink_ptr ptr,				/* Pointer to head of global link list */
  5    75     2 o_dm_ptr ptr,					/* Pointer to old data model seg  (dm_model ) */
  5    76     2 n_dm_ptr ptr,					/* Pointer to temp data model seg */
  5    77     2 o_fn_hdr_ptr ptr,				/* Pointer to head of original file list (fn structure) */
  5    78     2 source_seg_ptr ptr,				/* Pointer to source_seg */
  5    79     2 listing_iocb_ptr ptr,				/* Pointer to listing segment iocb */
  5    80     2 directive_ptr ptr,				/* Pointer to directive type str in mrds_rst_semactics.incl.pl1 */
  5    81     2 stmt_ptr ptr,					/* Pointer to statement str in mrds_rst_sematics.incl.pl1 */
  5    82     2 trace_metering_iocb_ptr ptr,			/* Pointer to seg used by trace and metering */
  5    83     2 tree_node_area_ptr ptr,				/* pointer to working storage for tree nodes */
  5    84     2 tree_data,
  5    85       3 seg_info_area_ptr ptr,			/* seg info working storage area */
  5    86       3 gl_area_ptr ptr,				/* global list data work storage area */
  5    87       3 sl_area_ptr ptr,				/* sublist data work storage area */
  5    88     2 parse_info_area_ptr ptr,			/* parse interface work area storage */
  5    89     2 static_info_area_ptr ptr,			/* directive, stmt and other static work storage area */
  5    90     2 variable_length_area_ptr ptr,			/* varibale allocates work storage area */
  5    91     2 other_area_ptr ptr,				/* unspecified work area storage */
  5    92     2 wa area (sys_info$max_seg_size - fixed (rel (addr (rsc.wa))) + 1); /* Work area */
  5    93 
  5    94 dcl  rsc_ptr ptr;					/* Pointer to base of rsc segment */
  5    95 
  5    96 
  5    97 
  5    98 /* END INCLUDE FILE mrds_rst_rsc.incl.pl1				*/
  5    99 
      934 
      935 
  6     1 /* BEGIN INCLUDE FILE mrds_rst_struct_types.incl.pl1 - - Jim Gray 2/20/79 */
  6     2 
  6     3 /* these constants are used to identify structures to be allocated
  6     4*   to the general purpose allocation routines */
  6     5 
  6     6 /*  HISTORY:
  6     7*    82-06-28 Roger Lackey : Removed struct types 52, 53, 54, 55, 56, 57, 58
  6     8*    Type 25 is no longer used and is handled with special code so bounds of 
  6     9*    array could continue to work */
  6    10 
  6    11 /* PARSE INFO STRUCTURES */
  6    12 
  6    13 declare  DOMAIN fixed bin internal static options (constant) init (1) ;
  6    14 declare  ATTRIBUTE_DOMAIN fixed bin internal static options (constant) init (2) ;
  6    15 declare  RELATION fixed bin internal static options (constant) init (3) ;
  6    16 declare  ATTRIBUTE fixed bin internal static options (constant) init (4) ;
  6    17 declare  FILE fixed bin internal static options (constant) init (5) ;
  6    18 declare  ITEM fixed bin internal static options (constant) init (6) ;
  6    19 declare  LINK fixed bin internal static options (constant) init (7) ;
  6    20 declare  FOREIGN_KEY fixed bin internal static options (constant) init (8) ;
  6    21 declare  CHILDREN fixed bin internal static options (constant) init (9) ;
  6    22 declare  INDEX fixed bin internal static options (constant) init (10) ;
  6    23 declare  DELETE_NAME fixed bin internal static options (constant) init (11) ;
  6    24 declare  DOM_LIST fixed bin internal static options (constant) init (12) ; /* in link handler */
  6    25 
  6    26 /* SEMANTIC STRUCTURES */
  6    27 
  6    28 declare  DIRECTIVE fixed bin internal static options (constant) init (13) ;
  6    29 declare  STMT fixed bin internal static options (constant) init (14) ;
  6    30 
  6    31 
  6    32 /* PARSING STRUCTURES */
  6    33 
  6    34 declare  LEX_STACK fixed bin internal static options (constant) init (15) ;
  6    35 declare  P_STRUCT fixed bin internal static options (constant) init (16) ;
  6    36 declare  CUR_LEX_TOP fixed bin internal static options (constant) init (17) ;
  6    37 declare  FIXUP_TOKEN fixed bin internal static options (constant) init (50) ; /* scanner */
  6    38 declare  STRING_SOURCE fixed bin internal static options (constant) init (51) ; /* semantics */
  6    39 declare  TOKEN fixed bin internal static options (constant) init (18) ;
  6    40 declare  OUTPUT_TEXT fixed bin internal static options (constant) init (19) ;
  6    41 
  6    42 
  6    43 /* DB_MODEL STRUCTURES */
  6    44 
  6    45 declare  DB_MODEL fixed bin internal static options (constant) init (0) ;
  6    46 declare  FILE_INFO fixed bin internal static options (constant) init (1) ;
  6    47 declare  DOMAIN_INFO fixed bin internal static options (constant) init (2) ;
  6    48 declare  PATH_ENTRY fixed bin internal static options (constant) init (3) ;
  6    49 declare  STACK_ITEM fixed bin internal static options (constant) init (4) ;
  6    50 declare  CONSTANT fixed bin internal static options (constant) init (30) ;
  6    51 declare  VERSION_STATUS fixed bin internal static options (constant) init (5) ;
  6    52 declare  CHANGER fixed bin internal static options (constant) init (6) ;
  6    53 
  6    54 
  6    55 /* FILE_MODEL STRUCTURES */
  6    56 
  6    57 declare  FILE_MODEL fixed bin internal static options (constant) init (7) ;
  6    58 declare  REL_INFO fixed bin internal static options (constant) init (8) ;
  6    59 declare  ATTR_INFO fixed bin internal static options (constant) init (9) ;
  6    60 declare  PARENT_LINK_INFO fixed bin internal static options (constant) init (10) ;
  6    61 declare  CHILD_LINK_INFO fixed bin internal static options (constant) init (11) ;
  6    62 declare  ATTR_LIST fixed bin internal static options (constant) init (12) ;
  6    63 declare  ATD fixed bin internal static options (constant) init (31) ;
  6    64 declare  COMP_NO_ARRAY fixed bin internal static options (constant) init (32) ;
  6    65 declare  SORT_KEY fixed bin internal static options (constant) init (13) ;
  6    66 declare  DUP_PREV fixed bin internal static options (constant) init (14) ;
  6    67 declare  SELECT_CHAIN fixed bin internal static options (constant) init (15) ;
  6    68 
  6    69 
  6    70 /* GLOBAL LIST STRUCTURES */
  6    71 
  6    72 declare  GL fixed bin internal static options (constant) init (20) ;
  6    73 declare  SL fixed bin internal static options (constant) init (21) ;
  6    74 declare  SEGINFO fixed bin internal static options (constant) init (22) ;
  6    75 declare  LIST_OVRLY fixed bin internal static options (constant) init (26) ;
  6    76 declare  SAVED_CHILD_COUNT fixed bin internal static options (constant) init (24) ; /* in global list build */
  6    77 declare  NODE fixed bin internal static options (constant) init (23) ;
  6    78 
  6    79 
  6    80 /* DISPLAY STRUCTURES */
  6    81 
  6    82 declare  DISPLAY_INFO fixed bin internal static options (constant) init (25) ;
  6    83 
  6    84 /*   Remove because nolonger used 82-06-28        
  6    85*  NAME_LIST fixed bin internal static options (constant) init (52) ;
  6    86*  PAI_ARRAY fixed bin internal static options (constant) init (53) ;
  6    87*  PAR_LK_ATTR_INFO fixed bin internal static options (constant) init (54) ;
  6    88*  CAI_ARRAY fixed bin internal static options (constant) init (55) ;
  6    89*  CHILD_LK_ATTR_INFO fixed bin internal static options (constant) init (56) ;
  6    90*  NAME_TABLE fixed bin internal static options (constant) init (57) ;
  6    91*  ATTR_TABLE fixed bin internal static options (constant) init (58) ;
  6    92**/
  6    93 
  6    94 /* END INCULDE FILE mrds_rst_struct_types */
  6    95 
      936 
      937 
      938      end;
      939 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/85  0909.2  mrds_rst_parse.pl1                >special_ldd>online>mrds.pbf-04/18/85>mrds_rst_parse.pl1
926          1    10/14/83  1608.4  mrds_rst_parse_stack.incl.pl1     >ldd>include>mrds_rst_parse_stack.incl.pl1
928          2    10/14/83  1609.0  mrds_rst_parse_table.incl.pl1     >ldd>include>mrds_rst_parse_table.incl.pl1
930          3    10/14/83  1609.0  mrds_rst_skip_table.incl.pl1      >ldd>include>mrds_rst_skip_table.incl.pl1
932          4    10/14/83  1609.0  mrds_rst_terminals.incl.pl1       >ldd>include>mrds_rst_terminals.incl.pl1
934          5    10/14/83  1609.1  mrds_rst_rsc.incl.pl1             >ldd>include>mrds_rst_rsc.incl.pl1
936          6    10/14/83  1609.0  mrds_rst_struct_types.incl.pl1    >ldd>include>mrds_rst_struct_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CNf                             000410 automatic       bit(1)                   level 2 packed unaligned dcl 709 set ref 795*
CUR_LEX_TOP                     000376 constant        fixed bin(17,0)          initial dcl 6-36 set ref 151*
DDop                            000010 internal static char(4)                  initial array unaligned dcl 498 set ref 638*
DPDA                      1     000060 external static structure                array level 2 packed unaligned dcl 2-3
LEX_STACK                       000377 constant        fixed bin(17,0)          initial dcl 6-34 set ref 149*
P_STRUCT                        000434 constant        fixed bin(17,0)          initial dcl 6-35 set ref 150*
RBNf                      0(01) 000410 automatic       bit(2)                   level 2 packed unaligned dcl 709 set ref 786* 787*
                                                                                  797*
TC                              000013 constant        char(1)                  initial array level 2 packed unaligned dcl 4-2 ref
                                                                                  545 550
TL                      125     000013 constant        structure                array level 2 unaligned dcl 4-2
abs                                                    builtin function         dcl 894 ref 224 636 755 819 821
addr                                                   builtin function         dcl 490 ref 205 205 448 448 621 621 675
alt_symbol                      000414 automatic       fixed bin(24,0)          dcl 715 set ref 636* 637 638* 638* 785 792 793 801
                                                                                  814
altn                            000137 automatic       fixed bin(24,0)          dcl 505 set ref 300* 304* 308*
an                              000100 automatic       fixed bin(24,0)          dcl 215 set ref 216* 217* 218 222
c                               000330 automatic       fixed bin(24,0)          dcl 428 set ref 445* 446 452* 454 462*
c_str                                  based           char(20000)              unaligned dcl 533 ref 540
combinations                    000411 automatic       fixed bin(24,0)          dcl 712 set ref 632* 635 641 700 778 783 784* 789*
                                                                                  794 802* 804*
copy                                                   builtin function         dcl 894 ref 465 485 702
cur_lex_top                            based           fixed bin(24,0)          array dcl 1-27 set ref 202* 460
cur_lex_top_ptr                 000310 automatic       pointer                  dcl 1-29 set ref 151* 202 460
cur_st                          000616 automatic       fixed bin(24,0)          dcl 864 set ref 756* 757 757 760 762 763* 763 767
                                                                                  778 778 778 796 796 796 819 819 819 839 841 843
                                                                                  844 844* 844 846 846 846 854
current_state                   000140 automatic       fixed bin(24,0)          dcl 506 set ref 157* 167 169 171 201 258* 280* 281
                                                                                  282* 282 294 299 300 311 311 313 323 325 327 328
                                                                                  336* 340* 461* 486* 638*
current_table                   000142 automatic       fixed bin(24,0)          dcl 508 set ref 169* 172 174* 174 182* 182 191* 191
                                                                                  213 213 213 223 223 294* 334 334 334 340 436* 453
                                                                                  453 453 635 635 635
cycle                           000415 automatic       bit(1)                   array unaligned dcl 716 set ref 640*
data                      3(09) 000101 automatic       char(100)                level 2 packed unaligned dcl 492 set ref 272* 276*
                                                                                  303*
db_data                         000101 automatic       structure                level 1 packed unaligned dcl 492 set ref 170* 278
                                                                                  278 304 304
db_look                                defined         picture(2)               unaligned dcl 491 set ref 271*
debug_sw                        000014 internal static bit(1)                   initial unaligned dcl 1-17 set ref 75* 75 258 268
                                                                                  301 310 634 638 706 725 774 781 835
dec4                            000331 automatic       picture(4)               unaligned dcl 429 set ref 440* 441 464* 465
default_symbol                  000015 internal static char(13)                 initial unaligned dcl 717 set ref 675 676
depth                           000576 automatic       fixed bin(24,0)          dcl 719 set ref 633* 745* 745 752* 752 774* 781*
                                                                                  806* 806 835*
end_of_input_msg                000276 automatic       char(18)                 initial unaligned dcl 913 set ref 485 544 549 913*
error_mark                      000232 automatic       fixed bin(24,0)          dcl 526 set ref 164* 251 435* 619*
fc                      126     000013 constant        fixed bin(24,0)          initial array level 3 dcl 4-2 ref 545 550
fixed                                                  builtin function         dcl 490 ref 647
flag                            000101 automatic       char(1)                  level 2 packed unaligned dcl 492 set ref 196* 273*
hbound                                                 builtin function         dcl 894 ref 199 199 199 285 285 285 324 324 324 434
                                                                                  625 758 758 758 840 840 840
i                               000622 automatic       fixed bin(24,0)          dcl 868 in procedure "next_term" set ref 746* 747
                                                                                  747* 778* 779 779 779* 796* 797 797 797* 808* 809
                                                                                  809* 819* 819* 821 823 823* 826* 829 846* 848 849*
i                               000143 automatic       fixed bin(24,0)          dcl 509 in procedure "mrds_rst_parse" set ref 213*
                                                                                  214 219 223* 223* 224 224* 228 229* 334* 335 336*
                                                                                  635* 636 638 641*
i                               000324 automatic       fixed bin(24,0)          dcl 426 in procedure "skip_recovered" set ref 453*
                                                                                  454 455*
ids                                    parameter       fixed bin(24,0)          dcl 531 ref 529 536 536 540 540 547
idx                                    parameter       fixed bin(24,0)          dcl 531 ref 529 544 545 545 547 549 550 550
ii                              000325 automatic       fixed bin(24,0)          dcl 426 in procedure "skip_recovered" set ref 457*
                                                                                  458 461*
ii                              000606 automatic       fixed bin(24,0)          dcl 724 in procedure "dump_la" set ref 726* 727 728*
                                                                                  728 728 732* 732
ioa_$ioa_switch_nnl             000022 constant        entry                    external dcl 499 ref 258 278 304 311 314 316 638 728
                                                                                  774 781 835
ioa_$rs                         000042 constant        entry                    external dcl 904 ref 259 330 614 703 879
iox_$user_output                000024 external static pointer                  dcl 500 set ref 258* 278* 304* 311* 314* 316* 638*
                                                                                  728* 774* 781* 835*
j                               000326 automatic       fixed bin(24,0)          dcl 427 set ref 456* 458 459 460*
jj                              000327 automatic       fixed bin(24,0)          dcl 427 set ref 455* 457 457 457
la_ct                           000144 automatic       fixed bin(24,0)          dcl 510 set ref 162* 203 207* 207 246* 246 289* 289
                                                                                  447 450* 474* 474 483* 483 620 623* 623 668* 668
                                                                                  687* 687
la_get                          000145 automatic       fixed bin(24,0)          dcl 511 set ref 161* 176 188 198 245* 245 259 259*
                                                                                  276* 287 288* 288 438* 440 452 464 467 469 470*
                                                                                  470 482* 482 614 660* 667* 726 742 744
la_get2                         000623 automatic       fixed bin(24,0)          dcl 869 set ref 742* 744* 772 831* 831
la_need                         000146 automatic       fixed bin(24,0)          dcl 512 set ref 176 178 179* 179 187* 197* 203 271
                                                                                  296* 619 620
la_next                         000413 automatic       fixed bin(24,0)          dcl 714 set ref 627* 628 669 670 674* 675 676 677
                                                                                  678 686* 689 695* 698 699 773
la_put                          000147 automatic       fixed bin(24,0)          dcl 513 set ref 161* 205 206* 206 448 449* 449 621
                                                                                  622* 622 669 671* 671 677 688* 688 727
la_use                          000150 automatic       fixed bin(24,0)          dcl 514 set ref 176* 188* 198* 209 250 627 670 672
                                                                                  674 684* 689 692* 697 698 741 814
la_use2                         000624 automatic       fixed bin(24,0)          dcl 870 set ref 741* 744* 767* 767 772* 773 814 816
lbound                                                 builtin function         dcl 894 ref 176 178 178 206 245 288 449 470 482 622
                                                                                  627 671 677 688 732 744 767 831
length                                                 builtin function         dcl 894 ref 676
lex_stack                              based           structure                array level 1 unaligned dcl 1-3 set ref 176 178 178
                                                                                  205 205 206 245 285 285 285 287* 287 288 448 448
                                                                                  449 470 482 621 621 622 627 669* 669 670* 670 671
                                                                                  677 688 689* 689 697* 697 698* 698 699* 699 732
                                                                                  744 767 831
lex_stack_ptr                   000304 automatic       pointer                  dcl 1-15 set ref 149* 176 178 178 205 205 206 209
                                                                                  245 250 259 285 285 285 287 287 288 308* 440 448
                                                                                  448 449 452 464 467 469 470 482 536 540 540 614
                                                                                  621 621 622 627 628 669 669 670 670 671 672 675
                                                                                  676 677 677 677 678 688 689 689 697 697 698 698
                                                                                  699 699 728 728 732 744 767 816 831
line                      3            based           fixed bin(24,0)          array level 2 dcl 1-3 set ref 250 259* 440 464 614*
                                                                                  677* 677
line_number                     000233 automatic       fixed bin(24,0)          dcl 527 set ref 250* 703*
ln                      127     000013 constant        fixed bin(24,0)          initial array level 3 dcl 4-2 ref 545 550
logic_error                     000402 stack reference condition                dcl 655 ref 652
look_ahead                      000621 automatic       bit(1)                   unaligned dcl 867 set ref 739* 740
ls_top                          000136 automatic       fixed bin(24,0)          dcl 504 set ref 160* 202 285 286* 286 287 308* 328*
                                                                                  328 460* 697 699
ltrim                                                  builtin function         dcl 894 ref 441 465
m                               000151 automatic       fixed bin(24,0)          dcl 515 set ref 210* 228* 232 234
marked                          000625 automatic       fixed bin(24,0)          dcl 871 set ref 818* 823* 826 826
message                         000234 automatic       varying char(128)        dcl 905 set ref 259* 261 330* 331 614* 616 703* 705
                                                                                  879* 881
message_length                  000275 automatic       fixed bin(17,0)          dcl 906 set ref 259* 330* 614* 703* 879*
min                                                    builtin function         dcl 894 ref 540
mod                                                    builtin function         dcl 490 ref 176 206 245 288 449 470 482 622 627 671
                                                                                  677 688 732 744 767 831
mrds_error_$rst_parse_err_correct
                                000052 external static fixed bin(35,0)          dcl 910 set ref 705*
mrds_error_$rst_parse_err_no_correct
                                000054 external static fixed bin(35,0)          dcl 911 set ref 616*
mrds_error_$rst_parse_err_no_recover
                                000050 external static fixed bin(35,0)          dcl 909 set ref 261*
mrds_error_$rst_parse_err_recover
                                000046 external static fixed bin(35,0)          dcl 908 set ref 255*
mrds_error_$rst_parse_fail      000056 external static fixed bin(35,0)          dcl 912 set ref 331* 881*
mrds_rst_error                  000040 constant        entry                    external dcl 903 ref 255 261 331 616 705 881
mrds_rst_meter                  000044 constant        entry                    external dcl 907 ref 94 342
mrds_rst_parse_table$DPDA       000060 external static structure                level 1 unaligned dcl 2-3
mrds_rst_rsc_alloc              000026 constant        entry                    external dcl 898 ref 149 150 151
mrds_rst_scanner                000032 constant        entry                    external dcl 900 ref 205 448 621
mrds_rst_scanner$init           000030 constant        entry                    external dcl 899 ref 99
mrds_rst_semantics              000034 constant        entry                    external dcl 901 ref 308
mrds_rst_semantics$init         000036 constant        entry                    external dcl 902 ref 100
mrds_rst_terminals              000013 constant        structure                level 1 unaligned dcl 4-2
n                               000152 automatic       fixed bin(24,0)          dcl 515 set ref 214* 216 216 217 228 229
next_state                      000153 automatic       fixed bin(24,0)          dcl 516 set ref 219* 234* 244* 269 280
next_symbol                     000575 automatic       fixed bin(24,0)          dcl 718 set ref 628* 686* 695* 776 792 793
nil                             000155 automatic       fixed bin(24,0)          dcl 518 set ref 211* 224* 229* 238 244
nil_flag                        000156 automatic       bit(1)                   unaligned dcl 519 set ref 159* 238 264* 475*
nil_sym                         000154 automatic       fixed bin(24,0)          dcl 517 set ref 158* 224 229 247 444* 469 625* 626*
                                                                                  637
ns                                     parameter       fixed bin(24,0)          dcl 861 set ref 737 739 749 755* 755 756 774* 829*
                                                                                  831 835* 849* 854*
p6                              000646 automatic       picture(6)               unaligned dcl 885 set ref 878* 879
p_struct                               based           structure                array level 1 dcl 1-19
p_struct_ptr                    000306 automatic       pointer                  dcl 1-24 set ref 150* 199 199 199 201 314 324 324
                                                                                  324 325 335 458 747 747 758 758 758 760 809 809
                                                                                  840 840 840 841 848
parse_stack                            based           fixed bin(24,0)          array level 2 dcl 1-19 set ref 199 199 199 201* 314*
                                                                                  324 324 324 325* 335 458 747 758 758 758 760* 809*
                                                                                  840 840 840 841* 848
parse_stack2              1            based           fixed bin(24,0)          array level 2 dcl 1-19 set ref 747* 809
ps_top                          000157 automatic       fixed bin(24,0)          dcl 520 set ref 160* 199 200* 200 201 202 313 313
                                                                                  324 325 327* 327 329 335 456 459* 641 746 808
recov_msg                       000160 automatic       varying char(150)        dcl 521 set ref 255 437* 438* 438 439* 439 441* 441
                                                                                  442* 442 462* 462 463* 463 465* 465 485* 485 645*
                                                                                  657* 657 659* 659 660* 660 663* 663 665* 665 666*
                                                                                  666 667* 667 681* 681 684* 684 685* 685 686* 686
                                                                                  692* 692 694* 694 695* 695 696* 696 702* 702 703*
rep                             000617 automatic       fixed bin(24,0)          dcl 865 set ref 775* 777* 777 781* 786
rsc                                    based           structure                level 1 unaligned dcl 5-29
rsc_ptr                                parameter       pointer                  dcl 5-94 set ref 26 89 94* 99* 100* 149* 150* 151*
                                                                                  255* 261* 307 331* 342 342* 616* 705* 881*
rulen                           000227 automatic       fixed bin(24,0)          dcl 522 set ref 299* 304* 306 308*
s                               000620 automatic       fixed bin(24,0)          dcl 866 set ref 776* 779 779 781* 814* 816* 819 821
severity_high           207            based           fixed bin(17,0)          level 2 dcl 5-29 ref 307
sign                                                   builtin function         dcl 894 ref 638
skip_v1                         000414 constant        fixed bin(24,0)          initial array dcl 3-7 ref 434 444 454 458 625 625
skip_v2                         000400 constant        fixed bin(24,0)          initial array dcl 3-10 ref 453 455 457 461
source_length                          parameter       fixed bin(24,0)          dcl 897 set ref 26 99*
source_seg_ptr                         parameter       pointer                  dcl 896 set ref 26 99*
state                     0(09) 000101 automatic       picture(4)               level 2 packed unaligned dcl 492 set ref 171*
string                                                 builtin function         dcl 629 in procedure "local_recovered" set ref 630*
                                                                                  640* 647
string                                                 builtin function         dcl 894 in procedure "mrds_rst_parse" set ref 170*
                                                                                  278 278 304 304 545 550
substr                                                 builtin function         dcl 894 ref 540 545 550
sws                             000410 automatic       structure                level 1 packed unaligned dcl 709 set ref 630* 647
symbol                    4            based           fixed bin(24,0)          array level 2 dcl 1-3 set ref 209 452 469* 628 678*
                                                                                  728* 728* 816
symlen                    2            based           fixed bin(24,0)          array level 2 dcl 1-3 set ref 467* 536 540 676*
symptr                                 based           pointer                  array level 2 dcl 1-3 set ref 540 675*
t                                      parameter       char                     unaligned dcl 886 in procedure "too_many" ref 877
                                                                                  879
t                               000230 automatic       fixed bin(24,0)          dcl 523 in procedure "mrds_rst_parse" set ref 313*
                                                                                  314*
temp                            000342 automatic       varying char(100)        dcl 532 set ref 535* 539* 539 540* 540 541* 541 542
                                                                                  544* 545* 546 549* 550* 551* 551
test_symbol                     000141 automatic       fixed bin(24,0)          dcl 507 set ref 209* 218 222 247* 259* 272* 276*
                                                                                  438* 613 660* 667* 684* 692* 776 797 797
token_cnt                       000231 automatic       fixed bin(24,0)          dcl 525 set ref 163* 251 290* 290 619
token_num                15            based           fixed bin(24,0)          array level 2 dcl 1-3 set ref 672*
top                                    parameter       fixed bin(24,0)          dcl 861 set ref 737 758 759* 759 760 840 841 843*
                                                                                  843 846 848
trace_sw                206(07)        based           bit(1)                   level 2 packed unaligned dcl 5-29 ref 89 342
transit                         000412 automatic       fixed bin(24,0)          dcl 713 set ref 631* 646 657* 665* 678 751* 785*
                                                                                  801*
type                      1(27) 000101 automatic       char(6)                  level 2 packed unaligned dcl 492 set ref 185* 194*
                                                                                  270* 271* 271 302*
v1                        1     000060 external static fixed bin(17,0)          array level 3 packed unaligned dcl 2-3 set ref 172
                                                                                  214 224 299 311* 313 323 327 335 636 757 757 762
                                                                                  767 779 779 779 797 797 797 819 821 823 839 843
                                                                                  844 848
v2                        1(18) 000060 external static fixed bin(17,0)          array level 3 packed unaligned dcl 2-3 set ref 174
                                                                                  182 191 213 219 223 234 244 294 300 311* 328 334
                                                                                  336 340 635 638 641 763 778 796 819 829 844 846
                                                                                  849 854
x                                      parameter       fixed bin(24,0)          dcl 887 ref 877 878

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ATD                                    internal static fixed bin(17,0)          initial dcl 6-63
ATTRIBUTE                              internal static fixed bin(17,0)          initial dcl 6-16
ATTRIBUTE_DOMAIN                       internal static fixed bin(17,0)          initial dcl 6-14
ATTR_INFO                              internal static fixed bin(17,0)          initial dcl 6-59
ATTR_LIST                              internal static fixed bin(17,0)          initial dcl 6-62
CHANGER                                internal static fixed bin(17,0)          initial dcl 6-52
CHILDREN                               internal static fixed bin(17,0)          initial dcl 6-21
CHILD_LINK_INFO                        internal static fixed bin(17,0)          initial dcl 6-61
COMP_NO_ARRAY                          internal static fixed bin(17,0)          initial dcl 6-64
CONSTANT                               internal static fixed bin(17,0)          initial dcl 6-50
DB_MODEL                               internal static fixed bin(17,0)          initial dcl 6-45
DELETE_NAME                            internal static fixed bin(17,0)          initial dcl 6-23
DIRECTIVE                              internal static fixed bin(17,0)          initial dcl 6-28
DISPLAY_INFO                           internal static fixed bin(17,0)          initial dcl 6-82
DOMAIN                                 internal static fixed bin(17,0)          initial dcl 6-13
DOMAIN_INFO                            internal static fixed bin(17,0)          initial dcl 6-47
DOM_LIST                               internal static fixed bin(17,0)          initial dcl 6-24
DPDAp                                  automatic       pointer                  dcl 2-7
DUP_PREV                               internal static fixed bin(17,0)          initial dcl 6-66
FILE                                   internal static fixed bin(17,0)          initial dcl 6-17
FILE_INFO                              internal static fixed bin(17,0)          initial dcl 6-46
FILE_MODEL                             internal static fixed bin(17,0)          initial dcl 6-57
FIXUP_TOKEN                            internal static fixed bin(17,0)          initial dcl 6-37
FOREIGN_KEY                            internal static fixed bin(17,0)          initial dcl 6-20
GL                                     internal static fixed bin(17,0)          initial dcl 6-72
INDEX                                  internal static fixed bin(17,0)          initial dcl 6-22
ITEM                                   internal static fixed bin(17,0)          initial dcl 6-18
LINK                                   internal static fixed bin(17,0)          initial dcl 6-19
LIST_OVRLY                             internal static fixed bin(17,0)          initial dcl 6-75
NODE                                   internal static fixed bin(17,0)          initial dcl 6-77
OUTPUT_TEXT                            internal static fixed bin(17,0)          initial dcl 6-40
PARENT_LINK_INFO                       internal static fixed bin(17,0)          initial dcl 6-60
PATH_ENTRY                             internal static fixed bin(17,0)          initial dcl 6-48
RELATION                               internal static fixed bin(17,0)          initial dcl 6-15
REL_INFO                               internal static fixed bin(17,0)          initial dcl 6-58
SAVED_CHILD_COUNT                      internal static fixed bin(17,0)          initial dcl 6-76
SEGINFO                                internal static fixed bin(17,0)          initial dcl 6-74
SELECT_CHAIN                           internal static fixed bin(17,0)          initial dcl 6-67
SL                                     internal static fixed bin(17,0)          initial dcl 6-73
SORT_KEY                               internal static fixed bin(17,0)          initial dcl 6-65
STACK_ITEM                             internal static fixed bin(17,0)          initial dcl 6-49
STMT                                   internal static fixed bin(17,0)          initial dcl 6-29
STRING_SOURCE                          internal static fixed bin(17,0)          initial dcl 6-38
TOKEN                                  internal static fixed bin(17,0)          initial dcl 6-39
VERSION_STATUS                         internal static fixed bin(17,0)          initial dcl 6-51
rel                                                    builtin function         dcl 894
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 524

NAMES DECLARED BY EXPLICIT CONTEXT.
CASE                            000363 constant        label                    array(0:10) dcl 763 in procedure "next_term" ref 762
CASE                            000000 constant        label                    array(0:10) dcl 174 in procedure "mrds_rst_parse"
                                                                                  set ref 172
NEXT                            005010 constant        label                    dcl 749 in procedure "next_term" ref 833 850 855
NEXT                            001103 constant        label                    dcl 167 in procedure "mrds_rst_parse" ref 256 292
                                                                                  337 341
PARSE                           000733 constant        label                    dcl 89 ref 56
case                            000353 constant        label                    array(0:7) dcl 649 set ref 647
debug_set                       000720 constant        entry                    external dcl 70
done                            004465 constant        label                    dcl 700 in procedure "local_recovered" ref 679 690
done                            005353 constant        label                    dcl 806 in procedure "next_term" ref 753 826
done_parse                      002500 constant        label                    dcl 342 ref 167 262 332
dump_la                         004644 constant        entry                    internal dcl 722 ref 634 706
found                           005446 constant        label                    dcl 829 ref 821
get_rest                        003273 constant        label                    dcl 536 ref 552
geterm                          003270 constant        entry                    internal dcl 529 ref 272 438 462 638 657 660 665 667
                                                                                  684 686 692 695 728
getermc                         003404 constant        entry                    internal dcl 547 ref 259 276
got_symbol                      001671 constant        label                    dcl 264 ref 220 235 248
local_recovered                 003442 constant        entry                    internal dcl 555 ref 251
mrds_rst_parse                  000710 constant        entry                    external dcl 26
next_term                       004745 constant        entry                    internal dcl 737 ref 641
not_found                       001401 constant        label                    dcl 232 ref 226
read_look                       001236 constant        label                    dcl 203 ref 180 189 251
set_symbol                      004214 constant        label                    dcl 672 ref 661
skip_recovered                  002544 constant        entry                    internal dcl 346 ref 254
stop                            002542 constant        label                    dcl 889 ref 882
too_many                        005646 constant        entry                    internal dcl 877 ref 178 199 285 324 758 840
try_again                       004005 constant        label                    dcl 643 ref 637

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6460        6542    6227        6470
Length      7164    6227        62         405     231          12

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_rst_parse                      750 external procedure  is an external procedure.  
skip_recovered                          internal procedure  shares stack frame of external procedure mrds_rst_parse.  
geterm                                  internal procedure  shares stack frame of external procedure mrds_rst_parse.  
local_recovered                         internal procedure  shares stack frame of external procedure mrds_rst_parse.  
dump_la                                 internal procedure  shares stack frame of external procedure mrds_rst_parse.  
next_term                               internal procedure  shares stack frame of external procedure mrds_rst_parse.  
too_many                                internal procedure  shares stack frame of external procedure mrds_rst_parse.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 DDop                        mrds_rst_parse
000014 debug_sw                    mrds_rst_parse
000015 default_symbol              local_recovered

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_rst_parse           000100 an                          mrds_rst_parse
                         000101 db_data                     mrds_rst_parse
                         000136 ls_top                      mrds_rst_parse
                         000137 altn                        mrds_rst_parse
                         000140 current_state               mrds_rst_parse
                         000141 test_symbol                 mrds_rst_parse
                         000142 current_table               mrds_rst_parse
                         000143 i                           mrds_rst_parse
                         000144 la_ct                       mrds_rst_parse
                         000145 la_get                      mrds_rst_parse
                         000146 la_need                     mrds_rst_parse
                         000147 la_put                      mrds_rst_parse
                         000150 la_use                      mrds_rst_parse
                         000151 m                           mrds_rst_parse
                         000152 n                           mrds_rst_parse
                         000153 next_state                  mrds_rst_parse
                         000154 nil_sym                     mrds_rst_parse
                         000155 nil                         mrds_rst_parse
                         000156 nil_flag                    mrds_rst_parse
                         000157 ps_top                      mrds_rst_parse
                         000160 recov_msg                   mrds_rst_parse
                         000227 rulen                       mrds_rst_parse
                         000230 t                           mrds_rst_parse
                         000231 token_cnt                   mrds_rst_parse
                         000232 error_mark                  mrds_rst_parse
                         000233 line_number                 mrds_rst_parse
                         000234 message                     mrds_rst_parse
                         000275 message_length              mrds_rst_parse
                         000276 end_of_input_msg            mrds_rst_parse
                         000304 lex_stack_ptr               mrds_rst_parse
                         000306 p_struct_ptr                mrds_rst_parse
                         000310 cur_lex_top_ptr             mrds_rst_parse
                         000324 i                           skip_recovered
                         000325 ii                          skip_recovered
                         000326 j                           skip_recovered
                         000327 jj                          skip_recovered
                         000330 c                           skip_recovered
                         000331 dec4                        skip_recovered
                         000342 temp                        geterm
                         000410 sws                         local_recovered
                         000411 combinations                local_recovered
                         000412 transit                     local_recovered
                         000413 la_next                     local_recovered
                         000414 alt_symbol                  local_recovered
                         000415 cycle                       local_recovered
                         000575 next_symbol                 local_recovered
                         000576 depth                       local_recovered
                         000606 ii                          dump_la
                         000616 cur_st                      next_term
                         000617 rep                         next_term
                         000620 s                           next_term
                         000621 look_ahead                  next_term
                         000622 i                           next_term
                         000623 la_get2                     next_term
                         000624 la_use2                     next_term
                         000625 marked                      next_term
                         000646 p6                          too_many

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        return
sign                mod_fx1             signal              shorten_stack       ext_entry           repeat
set_cs_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_$ioa_switch_nnl           ioa_$rs                       mrds_rst_error                mrds_rst_meter
mrds_rst_rsc_alloc            mrds_rst_scanner              mrds_rst_scanner$init         mrds_rst_semantics
mrds_rst_semantics$init

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
iox_$user_output              mrds_error_$rst_parse_err_correct
mrds_error_$rst_parse_err_no_correct                        mrds_error_$rst_parse_err_no_recover
mrds_error_$rst_parse_err_recover                           mrds_error_$rst_parse_fail    mrds_rst_parse_table$DPDA




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    913 000674        26 000704        56 000716        70 000717        75 000726        76 000732        89 000733
     94 000742        99 000775       100 001011       149 001021       150 001035       151 001051       157 001065
    158 001067       159 001071       160 001072       161 001074       162 001077       163 001100       164 001101
    167 001103       169 001105       170 001106       171 001111       172 001120       174 001123       176 001127
    178 001140       179 001156       180 001157       182 001160       185 001164       187 001167       188 001171
    189 001173       191 001174       194 001200       196 001203       197 001205       198 001207       199 001211
    200 001223       201 001224       202 001232       203 001236       205 001241       206 001256       207 001265
    208 001266       209 001267       210 001274       211 001275       213 001276       214 001313       216 001317
    217 001323       218 001324       219 001326       220 001333       222 001334       223 001335       224 001351
    225 001363       226 001365       228 001366       229 001373       231 001377       232 001401       234 001403
    235 001410       238 001411       244 001415       245 001422       246 001432       247 001433       248 001435
    250 001436       251 001443       254 001453       255 001460       256 001520       258 001522       259 001547
    261 001627       262 001667       264 001671       268 001672       269 001674       270 001676       271 001701
    272 001710       273 001717       274 001721       276 001722       278 001730       280 001756       281 001760
    282 001761       283 001763       285 001764       286 001776       287 001777       288 002013       289 002022
    290 002024       292 002025       294 002026       296 002033       299 002035       300 002042       301 002050
    302 002052       303 002055       304 002060       306 002114       307 002116       308 002125       310 002142
    311 002145       313 002202       314 002221       315 002246       316 002251       323 002270       324 002277
    325 002311       327 002316       328 002326       329 002336       330 002340       331 002371       332 002431
    334 002433       335 002447       336 002461       337 002465       339 002466       340 002470       341 002477
    342 002500       344 002541       889 002542       938 002543       346 002544       434 002546       435 002555
    436 002556       437 002560       438 002565       439 002601       440 002613       441 002626       442 002653
    444 002665       445 002667       446 002671       447 002674       448 002677       449 002714       450 002723
    452 002725       453 002732       454 002743       455 002746       456 002751       457 002757       458 002771
    459 003001       460 003004       461 003010       462 003012       463 003027       464 003041       465 003054
    467 003143       469 003147       470 003154       474 003163       475 003165       476 003167       478 003175
    479 003177       481 003202       482 003204       483 003213       484 003215       485 003216       486 003260
    487 003262       529 003270       535 003272       536 003273       539 003304       540 003313       541 003334
    542 003343       544 003352       545 003362       546 003375       547 003404       549 003406       550 003417
    551 003432       552 003441       555 003442       613 003444       614 003446       616 003515       617 003555
    619 003564       620 003567       621 003574       622 003611       623 003620       624 003621       625 003622
    626 003627       627 003631       628 003640       630 003645       631 003647       632 003651       633 003652
    634 003653       635 003657       636 003700       637 003710       638 003712       640 003765       641 003770
    643 004005       645 004007       646 004010       647 004021       649 004024       652 004032       657 004035
    659 004052       660 004064       661 004100       663 004101       665 004113       666 004130       667 004142
    668 004156       669 004157       670 004173       671 004205       672 004214       674 004220       675 004222
    676 004227       677 004233       678 004247       679 004251       681 004252       684 004264       685 004300
    686 004312       687 004326       688 004330       689 004340       690 004354       692 004355       694 004371
    695 004403       696 004417       697 004431       698 004445       699 004457       700 004465       702 004471
    703 004527       705 004571       706 004631       707 004636       722 004644       725 004645       726 004650
    727 004652       728 004655       732 004734       733 004743       735 004744       737 004745       739 004747
    740 004752       741 004753       742 004755       743 004757       744 004760       745 004770       746 004772
    747 005001       748 005006       749 005010       751 005013       752 005014       753 005016       755 005017
    756 005023       757 005024       758 005033       759 005045       760 005047       762 005055       763 005061
    767 005066       772 005103       773 005105       774 005107       775 005140       776 005141       777 005145
    778 005146       779 005166       781 005202       783 005237       784 005241       785 005243       786 005245
    787 005255       788 005261       789 005262       791 005264       792 005266       793 005276       794 005301
    795 005303       796 005305       797 005323       800 005342       801 005344       802 005346       803 005350
    804 005351       806 005353       808 005355       809 005365       810 005372       811 005374       814 005375
    816 005402       818 005407       819 005410       821 005434       823 005435       825 005441       826 005443
    829 005446       831 005455       833 005465       835 005466       839 005517       840 005526       841 005541
    843 005547       844 005560       846 005572       848 005611       849 005624       850 005630       852 005631
    853 005634       854 005635       855 005645       877 005646       878 005657       879 005671       881 005757
    882 006020


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
