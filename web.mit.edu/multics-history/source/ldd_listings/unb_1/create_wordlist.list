	COMPILATION LISTING OF SEGMENT create_wordlist
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 01/23/89  1229.7 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1989                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(85-09-13,Spitzer), approve(85-09-13,MCR6618),
       12*     audit(85-10-30,Blair), install(85-12-16,MR12.0-1001):
       13*     Allow to read/write
       14*     MSFs.
       15*  2) change(88-10-05,Lee), approve(88-11-14,MCR8018), audit(88-11-28,Flegel),
       16*     install(89-01-23,MR12.3-1010):
       17*     phx20562 (Commands 478) - fixed bug in locate_words when -lines
       18*     control arg is specified.
       19*                                                   END HISTORY COMMENTS */
       20 
       21 create_wordlist: cwl: proc;
       22 
       23 /* converted 7/12/77 by J. Stern from word_list to create_wordlist 
       24*   modified 05/28/80 by P. Benjamin to fix missing -li shortname for -lines
       25*		 and fix bug where -li has no arg and should default to 0
       26*   modified 05/29/80 by P. Benjamin to fix -lg bug where all lines not printed.
       27**/
       28 
       29 
       30 /* Automatic */
       31 
       32 dcl  temp_dir char (168);
       33 dcl  (uid_in, uid_out) bit (36) aligned;		/* File UIDs */
       34 dcl  current_record fixed bin (24);
       35 dcl  max_line_len fixed bin (21);			/* size of read input buffer */
       36 dcl  changed_lines bit (1) aligned;			/* =1b, changed input line */
       37 dcl  output_record_number fixed bin (35);		/* record number in temp file */
       38 dcl  (inputp, outputp, sortp) ptr init (null);		/* IOCB pointers */
       39 dcl  type fixed bin (2);				/* 1=segment, 2=directory */
       40 dcl  msf bit (1) aligned;
       41 dcl (nmp, mpp, mlp, rlp, rpp, system_area_ptr) ptr init (null);
       42 dcl  ap ptr;
       43 dcl  al fixed bin;
       44 dcl (ldpp, ldcp) ptr init (null);
       45 dcl  old_ptr ptr;
       46 dcl  old_count fixed bin;
       47 dcl  plip ptr init (null);
       48 dcl  prevx fixed bin;
       49 dcl  lines fixed bin (24) init (-1);
       50 dcl (argno, n_args, n_words, wordx) fixed bin;
       51 dcl  no_sort_opt bit (1) aligned init ("0"b);
       52 dcl (brief_opt, long_opt) bit (1) aligned init ("0"b);
       53 dcl  header_opt bit (1) aligned init ("0"b);
       54 dcl  no_exclude_opt bit (1) aligned init ("0"b);
       55 dcl  count_opt bit (1) aligned init ("0"b);
       56 dcl  no_control_opt bit (1) aligned init ("0"b);
       57 dcl (cwl_cmd, lw_cmd, rw_cmd) bit (1) aligned init ("0"b);
       58 dcl  got_pname bit (1) aligned init ("0"b);
       59 dcl  invalid_sw bit (1) aligned;
       60 dcl  ul_sw bit (1) aligned;
       61 dcl  whoami char (16);
       62 dcl  (ename, input_ename, sort_name) char (32);
       63 dcl  (dname, input_dname, sort_dir) char (168);
       64 dcl  arg_syntax char (120);
       65 dcl  code fixed bin (35);
       66 dcl  bc fixed bin (24);
       67 dcl  temp_ptr_array (3) ptr init ((3) null);
       68 dcl (input_ptr, temp_ptr, output_ptr, sort_data_ptr) ptr init (null);
       69 dcl (input_len, output_len, temp_len) fixed bin (21);
       70 dcl  line_ptr ptr;
       71 dcl  strip_ptr ptr;
       72 dcl (to_line, from_line) fixed bin (24) init (0);
       73 dcl (delim_ix, delim_len, line_ix, line_len, ul_spaces) fixed bin (21);
       74 dcl (token_ix, token_len, strip_ix, strip_len, word_ix, word_len, ul_ix, ul_len) fixed bin (24);
       75 dcl (rev_line_ix, rev_line_len) fixed bin (24);
       76 dcl (i, j, n, line_diff, last, line, output_words) fixed bin (24);
       77 dcl  ul_ptr ptr;
       78 dcl  max_sort_entries fixed bin (24);
       79 
       80 
       81 /* Based */
       82 
       83 dcl  system_area area (65536) based (system_area_ptr);
       84 dcl  arg char (al) based (ap);
       85 dcl  match_word char (match_len (wordx)) based (match_ptr (wordx));
       86 dcl  match_len (n_words) based (mlp) fixed bin;
       87 dcl  match_ptr (n_words) based (mpp) ptr;
       88 dcl  rev_word char (rev_len (wordx)) based (rev_ptr (wordx));
       89 dcl  rev_len (n_words) based (rlp) fixed bin;
       90 dcl  rev_ptr (n_words) based (rpp) ptr;
       91 dcl  num_matches (n_words) based (nmp) fixed bin;
       92 dcl  line_data_ptr (n_words) ptr based (ldpp);
       93 dcl  line_data_count (n_words) fixed bin based (ldcp);
       94 dcl 1 line_data (line_data_count (wordx)) aligned based (line_data_ptr (wordx)),
       95     2 line_num fixed bin,
       96     2 line_index fixed bin (24);
       97 dcl  line_data_kludge (2 * line_data_count (wordx)) fixed bin based (line_data_ptr (wordx));
       98 dcl  line_data_mover (old_count) fixed bin (71) based (old_ptr);
       99 dcl  prev_line_ix (0 : lines-1) fixed bin (24) based (plip);
      100 dcl  input_cs char (input_len) based (input_ptr);
      101 dcl  input_vec (input_len) char (1) unal based (input_ptr);
      102 dcl  input_line char (line_len) based (line_ptr);
      103 dcl  output_cs char (output_len) based (output_ptr);
      104 dcl  temp_cs char (temp_len) based (temp_ptr);
      105 dcl  temp_vec (temp_len) char (1) unal based (temp_ptr);
      106 dcl  strip_cs char (1048576) based (strip_ptr);
      107 dcl  strip_vec (1048576) char (1) based (strip_ptr);
      108 dcl  ul_cs char (ul_len) based (ul_ptr);
      109 dcl  ul_vec (ul_len) char (1) based (ul_ptr);
      110 dcl 1 sort_data (max_sort_entries) aligned based (sort_data_ptr),
      111     2 wordp ptr unal,
      112     2 wordl fixed bin (24);
      113 
      114 
      115 /* Static */
      116 
      117 dcl  line_data_incr fixed bin int static init (50);
      118 dcl  delims char (5) aligned int static init (" 	
      119 ");						/* SPACE, HT, VT, FF, NL */
      120 dcl  NL char (1) aligned int static init ("
      121 ");
      122 dcl  letters char (52) int static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
      123 
      124 dcl (error_table_$noarg,
      125      error_table_$dirseg,
      126      error_table_$key_duplication,
      127      error_table_$no_key,
      128      error_table_$no_record,
      129      error_table_$short_record,
      130      error_table_$end_of_info,
      131      error_table_$noentry,
      132      error_table_$wrong_no_of_args,
      133      error_table_$badopt,
      134      error_table_$inconsistent,
      135      error_table_$zero_length_seg,
      136      error_table_$entlong) fixed bin (35) ext;
      137 
      138 dcl  sys_info$max_seg_size fixed bin (24) ext static;
      139 
      140 
      141 /* Conditions */
      142 
      143 dcl  cleanup condition;
      144 
      145 
      146 /* Builtins */
      147 
      148 dcl (addr, divide, index, hbound, length, max, min, mod, null, reverse, rtrim, search, substr, unspec, verify) builtin;
      149 
      150 
      151 /* Entries */
      152 
      153 dcl  absolute_pathname_ entry (char(*), char(*), fixed bin(35));
      154 dcl  cu_$arg_count entry (fixed bin);
      155 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
      156 dcl  expand_pathname_ ext entry (char (*), char (*), char (*), fixed bin (35));
      157 dcl  get_system_free_area_ entry (ptr);
      158 dcl  delete_$path entry (char(*), char(*), bit(36) aligned, char(*), fixed bin(35));
      159 dcl  initiate_file_ entry (char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35));
      160 dcl  terminate_file_ entry (ptr, fixed bin(24), bit(*), fixed bin(35));
      161 dcl  com_err_ ext entry options (variable);
      162 dcl  ioa_ ext entry options (variable);
      163 dcl  get_wdir_ ext entry returns (char (168));
      164 dcl  hcs_$get_uid_file entry (char (*), char (*), bit (36) aligned, fixed bin (35));
      165 dcl  hcs_$make_seg ext entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
      166 dcl  hcs_$status_minf entry (char(*), char(*), fixed bin(1), fixed bin(2), fixed bin(24), fixed bin(35));
      167 dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (24));
      168 dcl  alphabetize_strings_ entry (ptr, fixed bin (24));
      169 dcl  (get_temp_segments_, release_temp_segments_) entry (char (*), (*) ptr, fixed bin (35));
      170 dcl  unique_chars_ entry (bit(*)) returns(char(15));
      171 dcl  get_pdir_ entry() returns(char(168));
      172 dcl  pathname_ entry (char(*), char(*)) returns(char(168));
      173 dcl  iox_$attach_name entry (char(*), ptr, char(*), ptr, fixed bin(35));
      174 dcl  iox_$open entry (ptr, fixed bin, bit(1) aligned, fixed bin(35));
      175 dcl  iox_$close entry (ptr, fixed bin(35));
      176 dcl  iox_$detach_iocb entry (ptr, fixed bin(35));
      177 dcl  iox_$destroy_iocb entry (ptr, fixed bin(35));	  
      178 dcl  iox_$get_line entry (ptr, ptr, fixed bin(21), fixed bin(21), fixed bin(35));		  
      179 dcl  iox_$put_chars entry (ptr, ptr, fixed bin(21), fixed bin(35));
      180 dcl  iox_$position entry (ptr, fixed bin, fixed bin(21), fixed bin(35));
      181 dcl  iox_$control entry (ptr, char(*), ptr, fixed bin(35));
      182 
      183 	cwl_cmd = "1"b;				/* remember we came in via the create_wordlist entry */
      184 	whoami = "create_wordlist";
      185 	arg_syntax = "path {-brief} {-from N} {-to N} {-header} {-no_sort} {-no_exclude} {-no_control_lines}";
      186 	goto join;
      187 
      188 locate_words: lw: entry;
      189 
      190 	lw_cmd = "1"b;				/* remember we came in via the locate_words entry */
      191 	whoami = "locate_words";
      192 	arg_syntax = "path words {-from N} {-to N} {-header} {-lines N | -long | -count} {-word word}";
      193 	goto join;
      194 
      195 revise_words: rw: entry;
      196 
      197 	rw_cmd = "1"b;				/* remember we came in via the revise_words entry */
      198 	whoami = "revise_words";
      199 	arg_syntax = "path word1 rev1 ... wordN revN {-from N} {-to N} {-header} {-lines N | -long | -brief} {-word word rev}";
      200 join:	call cu_$arg_count (n_args);			/* get number of arguments */
      201 	if cwl_cmd & n_args < 1
      202 	then do;
      203 noarg:	     code = error_table_$noarg;
      204 usage:	     call com_err_ (code, whoami, "^/Usage:  ^a ^a", whoami, arg_syntax);
      205 	     return;
      206 	end;
      207 	if lw_cmd & n_args < 2
      208 	then goto noarg;
      209 	if rw_cmd & n_args < 3
      210 	then goto noarg;
      211 
      212 	if ^cwl_cmd
      213 	then do;
      214 	     if lw_cmd
      215 	     then n_words = n_args;			/* upper bound on number of words */
      216 	     else n_words = divide (n_args, 2, 17, 0);
      217 	     on cleanup call cleaner;
      218 	     call get_system_free_area_ (system_area_ptr);
      219 	     allocate match_len in (system_area);
      220 	     allocate match_ptr in (system_area);
      221 	     if rw_cmd
      222 	     then do;
      223 		allocate rev_len in (system_area);
      224 		allocate rev_ptr in (system_area);
      225 	     end;
      226 	end;
      227 
      228 	temp_dir = get_pdir_ ();
      229 	n_words = 0;
      230 	do argno = 1 by 1 to n_args;
      231 	     call cu_$arg_ptr (argno, ap, al, code);
      232 	     if index (arg, "-") ^= 1 then do;		/* not an option */
      233 		if ^got_pname then do;		/* this should be a pathname */
      234 		     call expand_pathname_ (arg, dname, ename, code);
      235 		     if code ^= 0 then do;
      236 			call com_err_ (code, whoami, arg);
      237 			return;
      238 		     end;
      239 		     got_pname = "1"b;
      240 		end;
      241 		else if cwl_cmd then do;
      242 		     code = error_table_$wrong_no_of_args;
      243 		     goto usage;
      244 		end;
      245 		else do;				/* this should be a match word */
      246 insert_word:	     do wordx = 1 to n_words while (match_word < arg); /* find place to insert arg. */
      247 		     end;
      248 
      249 		     do j = n_words to wordx by -1;	/* make room for insertion. */
      250 			match_ptr (j + 1) = match_ptr (j);
      251 			match_len (j + 1) = match_len (j);
      252 			if rw_cmd then do;
      253 			     rev_ptr (j + 1) = rev_ptr (j);
      254 			     rev_len (j + 1) = rev_len (j);
      255 			end;
      256 		     end;
      257 		     match_ptr (wordx) = ap;		/* save ptr to current word */
      258 		     match_len (wordx) = al;		/* save length of current word */
      259 		     n_words = n_words + 1;
      260 		     if rw_cmd then do;
      261 			call next_arg;
      262 			rev_ptr (wordx) = ap;
      263 			rev_len (wordx) = al;
      264 		     end;
      265 		end;
      266 	     end;
      267 	     else if arg = "-word" then do;
      268 		call next_arg;
      269 		goto insert_word;
      270 	     end;
      271 	     else if cwl_cmd & (arg = "-no_sort" | arg = "-ns") then no_sort_opt = "1"b;
      272 	     else if ^lw_cmd & (arg = "-bf" | arg = "-brief") then brief_opt = "1"b;
      273 	     else if arg = "-he" | arg = "-header" then header_opt = "1"b;
      274 	     else if ^cwl_cmd & (arg = "-lg" | arg = "-long") then long_opt = "1"b;
      275 	     else if cwl_cmd & (arg = "-ne" | arg = "-no_exclude") then no_exclude_opt = "1"b;
      276 	     else if lw_cmd & (arg = "-ct" | arg = "-count") then count_opt = "1"b;
      277 	     else if ^lw_cmd & (arg = "-temp_dir" | arg = "-td") then do;
      278 		     call next_arg;
      279 		     call absolute_pathname_ (arg, temp_dir, code);
      280 		     if code ^= 0 then do;
      281 			call com_err_ (code, whoami, "^a", arg);
      282 			return;
      283 			end;
      284 		     end;
      285 	     else if arg = "-ncl" | arg = "-no_control_lines"
      286 	     then no_control_opt = "1"b;
      287 	     else if arg = "-fm" | arg = "-from"
      288 	     then do;
      289 		call next_arg_num (from_line);
      290 		if code ^= 0 | from_line < 1
      291 		then do;
      292 bad_line:		     call com_err_ (0, whoami, "Invalid line number.  ^a", arg);
      293 		     return;
      294 		end;
      295 	     end;
      296 	     else if arg = "-to"
      297 	     then do;
      298 		call next_arg_num (to_line);
      299 		if code ^= 0 | to_line < 1
      300 		then goto bad_line;
      301 	     end;
      302 	     else if ^cwl_cmd & (arg = "-lines" | arg = "-li")
      303 	     then do;
      304 		if argno + 1 > n_args then lines = 0;
      305 		else do;
      306 		     argno = argno + 1;
      307 		     call cu_$arg_ptr (argno, ap, al, code);
      308 		     lines = cv_dec_check_ (arg, code);
      309 		     if code ^= 0 then do;
      310 			lines = 0;
      311 			code = 0;
      312 			argno = argno - 1;
      313 		     end;
      314 		end;
      315 		if lines < 0
      316 		then do;
      317 		     call com_err_ (0, whoami, "Invalid line count.  ^a", arg);
      318 		     return;
      319 		end;
      320 	     end;
      321 	     else do;
      322 		call com_err_ (error_table_$badopt, whoami, "^a", arg);
      323 		return;
      324 	     end;
      325 	end;
      326 
      327 	if ^got_pname				/* pathname missing */
      328 	| (^cwl_cmd & n_words = 0)			/* match word(s) missing */
      329 	then goto noarg;
      330 
      331 	if (long_opt | lines ^= -1) & (count_opt | brief_opt)
      332 	then do;
      333 	     call com_err_ (error_table_$inconsistent, whoami, "^[-count^;-brief^] and ^[-long^;-lines^] are mutually exclusive.", count_opt, long_opt);
      334 	     return;
      335 	end;
      336 	if lines > -1
      337 	then long_opt = "1"b;
      338 	else lines = 0;
      339 
      340 	if ^cwl_cmd then do;			/* check validity of word arguments */
      341 	     invalid_sw = "0"b;			/* assume all word arguments are valid */
      342 	     do wordx = 1 to n_words;
      343 		call validate_word (match_word);
      344 	     end;
      345 	     if invalid_sw then return;
      346 
      347 	     allocate num_matches in (system_area);
      348 	     num_matches (*) = 0;
      349 	     if ^count_opt
      350 	     then do;
      351 		allocate line_data_ptr in (system_area);
      352 		allocate line_data_count in (system_area);
      353 		line_data_count (*) = 0;
      354 	     end;
      355 	     if lines > 0
      356 	     then do;
      357 		allocate prev_line_ix in (system_area);
      358 		prev_line_ix (*) = 1;
      359 	     end;
      360 	end;
      361 	else on cleanup call cleaner;
      362 
      363 	input_ename = ename;			/* save for later */
      364 	input_dname = dname;
      365 
      366 	call hcs_$status_minf (dname, ename, 1, type, bc, code);
      367 	if code ^= 0 then call err_exit;
      368 
      369 	if type = 2
      370 	then if bc = 0				/* directory */
      371 	     then do;
      372 		code = error_table_$dirseg;		/* can't do anything with it */
      373 		call err_exit;
      374 		end;
      375 	     else msf = "1"b;			/* directory with bit count = MSF */
      376 	else msf = "0"b;
      377 
      378 /* If the input is an MSF, then we have to use vfile_ rather thanpointer I/O
      379*   to read it. There is also a possibility that if we are doing a revise_words
      380*   on a non-MSF, the changes could involve growing the input segment to an
      381*   MSF. That is handled later. */
      382 
      383 	if msf then call open_file (dname, ename, inputp, Stream_input);
      384 	else do;					/* initiate input seg */
      385 	     call initiate_file_ (dname, ename, R_ACCESS, input_ptr, bc, code);
      386 	     if input_ptr = null then call err_exit;
      387 	     input_len = divide (bc, 9, 21, 0);		/* get character count */
      388 	     if input_len = 0 then do;
      389 		code = error_table_$zero_length_seg;
      390 		call err_exit;
      391 		end;
      392 	     end;
      393 
      394 	if cwl_cmd then do;				/* if create_wordlist entry */
      395 	     call hcs_$get_uid_file (input_dname, input_ename, uid_in, code);
      396 	     if code ^= 0 then call err_exit;
      397 
      398 	     i = length (rtrim (ename));
      399 	     if i > 29 then do;			/* make sure we can add ".wl" suffix to entry name */
      400 		call com_err_ (error_table_$entlong, whoami, "^a.wl", ename);
      401 		goto finish;
      402 	     end;
      403 	     substr (ename, i+1, 3) = ".wl";
      404 
      405 	     dname = get_wdir_ ();
      406 
      407 	     call hcs_$get_uid_file (dname, ename, uid_out, code);
      408 	     if code ^= 0
      409 	     then if code ^= error_table_$noentry
      410 		then call err_exit;
      411 
      412 	     if uid_in = uid_out then do;
      413 		call com_err_ (0, whoami, "Input and output files are the same. ^a and ^a.",
      414 		     pathname_ (input_dname, input_ename), pathname_ (dname, ename));
      415 		goto finish;
      416 		end;
      417 
      418 	     if msf then do;
      419 		call open_file (dname, ename, outputp, Stream_output);
      420 		if ^no_sort_opt then do;
      421 		     call open_file ("", "", sortp, Keyed_sequential_update);
      422 		     sort_dir = dname;
      423 		     sort_name = ename;
      424 		     end;
      425 		end;
      426 	     else do;
      427 		call hcs_$make_seg (dname, ename, "", 01010b, output_ptr, code); /* create output seg in working dir */
      428 		if output_ptr = null then call err_exit;
      429 		end;
      430 	end;
      431 	else if rw_cmd & msf then do;			/* revise_words needs to change the source file */
      432 		call open_file ("", "", outputp, Stream_output);
      433 		sort_dir = dname;			/* save path for deletion */
      434 		sort_name = ename;
      435 		end;
      436 
      437 	call get_temp_segments_ (whoami, temp_ptr_array, code);
      438 	if code ^= 0
      439 	then do;
      440 	     call com_err_ (code, whoami, "Cannot get temporary segments.");
      441 	     goto finish;
      442 	end;
      443 
      444 	ul_ptr = temp_ptr_array (1);			/* place to assemble de-underlined words */
      445 	if msf
      446 	then input_ptr, line_ptr = temp_ptr_array (2);	/* place to read vfile_ input */
      447 	else do;
      448 	     sort_data_ptr = temp_ptr_array (2);	/* used for sorting */
      449 	     max_sort_entries = divide (sys_info$max_seg_size, 2, 24, 0);
      450 	     end;
      451 	if rw_cmd then temp_ptr = temp_ptr_array (3);
      452 
      453 	if header_opt
      454 	then call ioa_ ("^/^-^a^/", pathname_ (input_dname, input_ename));
      455 
      456 
      457 	prevx = lines -1;
      458 	line_ix = 1;
      459 	rev_line_ix = 1;
      460 	line_diff = 0;
      461 	output_words = 0;				/* init word counter */
      462 	output_len = 0;
      463 	temp_len = 0;				/* init length of temp seg */
      464 	last = 0;					/* init index of last input seg char moved to temp seg */
      465 
      466 	changed_lines = "0"b;			/* didnt change anything yet for revise_words */
      467 	output_record_number = 0;
      468 
      469 	if msf then do;
      470 	     max_line_len = sys_info$max_seg_size * 4;
      471 	     call iox_$get_line (inputp, line_ptr, max_line_len, input_len, code);
      472 	     end;
      473 
      474 	do line = 1 by 1;				/* scan input one line at a time */
      475 	     if msf
      476 	     then if code ^= 0
      477 		then if code = error_table_$end_of_info
      478 		     then goto end_of_data;
      479 		     else if code = error_table_$short_record
      480 			then goto msf_read;		/* no trailing NL */
      481 			else call err_exit;
      482 		else do;
      483 msf_read:		     line_ix = 1;			/* fake indices so that later code works */
      484 		     rev_line_ix = 1;		/*   for both cases */
      485 		     output_len = 0;
      486 		     temp_len = 0;
      487 		     last = 0;
      488 		     end;
      489 	     else if line_ix > input_len
      490 		then goto end_of_data;
      491 
      492 	     line_len = index (substr (input_cs, line_ix), NL) -1;
      493 	     if line_len = -1			/* input does not end with NL */
      494 	     then line_len = input_len - line_ix + 1;	/* do it anyway */
      495 
      496 	     if line < from_line
      497 	     then goto next_line;
      498 	     if to_line ^= 0 & line > to_line
      499 	     then goto end_of_data;
      500 
      501 	     if line_len = 0
      502 	     then goto next_line;
      503 
      504 	     line_ptr = addr (input_vec (line_ix));
      505 
      506 	     if no_control_opt
      507 	     then if substr (input_line, 1, 1) = "."
      508 		then goto next_line;
      509 
      510 	     strip_ptr = line_ptr;
      511 	     delim_ix = 1;				/* prepare to look at first char of line */
      512 
      513 	     do while (delim_ix <= line_len);		/* scan until line exhausted */
      514 		delim_len = verify (substr (input_line, delim_ix), delims) -1; /* skip delimiters */
      515 		if delim_len = -1
      516 		then delim_len = line_len -delim_ix +1;
      517 
      518 		token_ix = delim_ix + delim_len;	/* advance index past delimiters */
      519 		if token_ix > line_len
      520 		then goto next_line;
      521 		else if token_ix = line_len
      522 		then token_len = 1;
      523 		else do;
      524 		     token_len = search (substr (input_line, token_ix+1), delims); /* find end-of-token delimiter */
      525 		     if token_len = 0 then		/* no delimiter */
      526 			token_len = line_len + 1 - token_ix; /* use end of line as delimiter */
      527 		end;
      528 
      529 		strip_ix = token_ix;
      530 		strip_len = token_len;
      531 		call strip_punc;			/* strip surrounding punctuation from token */
      532 		call check_ul;			/* check for underlining */
      533 
      534 		if ul_sw then do;			/* the word was underlined */
      535 		     ul_ix = word_ix;
      536 		     ul_spaces = 0;
      537 		     strip_ptr = ul_ptr;		/* prepare to strip words in ul_cs */
      538 		     i = 1;
      539 		     do while (i <= ul_len);		/* rescan token to pick out words */
      540 			n = verify (substr (ul_cs, i), " "); /* skip spaces */
      541 			if n = 0 then goto end_of_ul;
      542 			i = i + n -1;		/* advance index past spaces */
      543 			ul_spaces = ul_spaces + n -1; /* remember number of spaces seen */
      544 			n = index (substr (ul_cs, i), " ") -1; /* find next space */
      545 			if n = -1 then		/* no more spaces */
      546 			     n = ul_len +1 -i;	/* use end of token as delimiter */
      547 			strip_ix = i;
      548 			strip_len = n;
      549 			call strip_punc;
      550 			if cwl_cmd then call output_word;
      551 			else call test_word;
      552 			i = i + n;
      553 		     end;
      554 end_of_ul:	     if cwl_cmd
      555 		     then ul_ptr = addr (ul_vec (ul_len + 1)); /* move buffer ahead for next de-underlined word */
      556 		     strip_ptr = line_ptr;
      557 		end;
      558 
      559 		else				/* no underlining to worry about */
      560 		if cwl_cmd then call output_word;
      561 		else call test_word;
      562 
      563 next_token:	delim_ix = token_ix + token_len;	/* advance index past current token */
      564 	     end;
      565 next_line:
      566 	     if lines > 0				/* must remember previous line indices */
      567 	     then do;				/* use prev_line_ix array as circular buffer */
      568 		prevx = mod (prevx + 1, lines);	/* advance circular buffer index */
      569 		if msf & rw_cmd
      570 		then do;
      571 		     prev_line_ix (prevx) = output_record_number;
      572 		     output_record_number = output_record_number + 1;
      573 		     end;
      574 		else do;				/* fixed for phx20562, use rev_line_ix */
      575 						/* only if revise_word command */
      576 		     if ^rw_cmd then prev_line_ix (prevx) = line_ix;
      577 		     else prev_line_ix (prevx) = rev_line_ix;
      578 		     end;
      579 	     end;
      580 
      581 	     if msf
      582 	     then do;
      583 		if rw_cmd then do;
      584 		     if temp_len ^= 0 then do;	/* write out line to temp work file */
      585 			call iox_$put_chars (outputp, temp_ptr, temp_len, code);
      586 			if code ^= 0 then call err_exit;
      587 			if last < input_len		/* copy end of input line */
      588 			then call iox_$put_chars (outputp, addr (input_vec (last+1)), input_len-last, code);
      589 			end;
      590 		     else call iox_$put_chars (outputp, line_ptr, input_len, code);
      591 		     if code ^= 0 then call err_exit;
      592 		     end;
      593 
      594 		call iox_$get_line (inputp, line_ptr, max_line_len, input_len, code);
      595 		end;
      596 	     else do;
      597 		line_ix = line_ix + line_len + 1;
      598 
      599 		if rw_cmd & long_opt
      600 		then do;
      601 		     rev_line_len = line_len + line_diff;    /* compute length of revised line */
      602 		     rev_line_ix = rev_line_ix + rev_line_len +1; /* compute index of next revised line */
      603 		     line_diff = 0;
      604 		     end;
      605 		end;
      606 	end;
      607 
      608 end_of_data:
      609 
      610 /* For revise_words, if there are any chars left after the last
      611*   revision, move them to the temp seg.  Then copy the whole
      612*   temp seg into the original input seg (which becomes the output seg). */
      613 
      614 	if rw_cmd then do;
      615 	     if msf then do;
      616 		if changed_lines
      617 		then do;
      618 		     code = 0;
      619 		     do while (code = 0);		/* copy rest of input file */
      620 			call iox_$get_line (inputp, line_ptr, max_line_len, input_len, code);
      621 			if code = 0 | code = error_table_$short_record
      622 			then call iox_$put_chars (outputp, line_ptr, input_len, code);
      623 			end;
      624 		     if code ^= error_table_$end_of_info then call err_exit;
      625 
      626 		     call iox_$close (inputp, code);	/* close input file */
      627 		     call close_file (outputp);
      628 		     outputp = null;
      629 
      630 		     call copy_temp_file (dname, ename, get_wdir_ (), input_ename);
      631 
      632 		     call iox_$open (inputp, 1, "0"b, code); /* open input file for reading */
      633 		     if code ^= 0 then call err_exit;
      634 		     end;
      635 		else call close_file (outputp);	/* don't need temp work file anymore */
      636 		end;
      637 	     else if last > 0 then do;
      638 		     n = input_len - last;
      639 		     if n > 0 then do;
      640 			substr (temp_cs, temp_len+1, n) = substr (input_cs, last+1, n);
      641 			temp_len = temp_len + n;
      642 			end;
      643 		     output_ptr = input_ptr;
      644 		     substr (output_ptr -> temp_cs, 1, temp_len) = substr (temp_cs, 1, temp_len);
      645 		     input_len, output_len = temp_len;
      646 		     end;
      647 	end;
      648 
      649 	if cwl_cmd then do;				/* if create_wordlist entry */
      650 	     if ^brief_opt then
      651 		call ioa_ ("total number of words = ^d", output_words); /* print word count */
      652 	     if ^no_sort_opt then do;			/* if nosort option not requested */
      653 		if msf then call copy_keyed_file;
      654 		else do;
      655 		     call alphabetize_strings_ (sort_data_ptr, output_words); /* alphabetize the words */
      656 		     call copy_sorted_words;		/* copy sorted words to output seg */
      657 		     end;
      658 		if ^brief_opt then
      659 		     call ioa_ ("number of unique words = ^d", output_words); /* print unique word count */
      660 	     end;
      661 	end;
      662 
      663 	else do;
      664 	     if msf then do;
      665 		current_record = 1;
      666 		call iox_$position (inputp, -1, 0, code);    /* BOF */
      667 		end;
      668 
      669 	     do wordx = 1 to n_words;			/* print results for locate_words or revise_words */
      670 		if count_opt
      671 		then call ioa_ ("^d match^[es^] for ^a", num_matches (wordx), (num_matches (wordx) ^= 1), match_word);
      672 		else if rw_cmd & ^long_opt
      673 		then do;
      674 		     if num_matches (wordx) = 0
      675 		     then call ioa_ ("No revisions for ^a", match_word);
      676 		     else if ^brief_opt
      677 		     then call ioa_ ("^d revision^[s^] for ^a", num_matches (wordx), (num_matches (wordx) ^= 1), match_word);
      678 		end;
      679 		else if lw_cmd & ^long_opt
      680 		then do;
      681 		     if num_matches (wordx) = 0
      682 		     then call ioa_ ("^20a NONE", match_word);
      683 		     else do;
      684 			line_data_count (wordx) = num_matches (wordx);
      685 			do i = 1 by 20 to 2*num_matches (wordx);
      686 			     call ioa_ ("^[^20a^;^20x^s^]^vs^10(^d^x^s^)", i = 1, match_word, i-1, line_data_kludge);
      687 			end;
      688 		     end;
      689 		end;
      690 		else call print_long;		/* print lines of text */
      691 		end;
      692 	end;
      693 
      694 
      695 	if (cwl_cmd | (rw_cmd & last > 0)) & ^msf then do;
      696 	     substr (output_cs, output_len+1, 4 - mod (output_len, 4)) = "   "; /* set to NUL */
      697 	     call terminate_file_ (output_ptr, 9*output_len, TERM_FILE_TRUNC_BC, code); /* truncate output seg */
      698 	     if code ^= 0 then call err_exit;
      699 	end;
      700 
      701 finish:	call cleaner;
      702 exit:	return;
      703 
      704 err_exit:						/* moan and return */
      705      proc;
      706 
      707 	call com_err_ (code, whoami, "^a", pathname_ (input_dname, input_ename));
      708 	goto finish;
      709 	end err_exit;
      710 
      711 next_arg:	proc;					/* fetches next command arg */
      712 
      713 	     argno = argno + 1;
      714 	     if argno > n_args
      715 	     then goto noarg;
      716 
      717 	     call cu_$arg_ptr (argno, ap, al, code);
      718 
      719 	end next_arg;
      720 
      721 next_arg_num: proc (num);				/* fetches next arg, converts to fixed bin */
      722 
      723 dcl  num fixed bin (24);
      724 
      725 
      726 	     call next_arg;
      727 	     num = cv_dec_check_ (arg, code);
      728 
      729 	end next_arg_num;
      730 
      731 validate_word: proc (word);
      732 
      733 dcl  word char (*);
      734 
      735 /* checks validity of words supplied as arguments to commands
      736*   a word must not contain delimiters or surrounding punctuation and must not be underlined
      737**/
      738 
      739 	     if search (word, delims) ^= 0		/* word contains delimiters */
      740 	     then do;
      741 bad_word:		call com_err_ (0, whoami, """^a"" is not a word.", word);
      742 		invalid_sw = "1"b;			/* the word is invalid */
      743 		return;
      744 	     end;
      745 	     strip_ptr = addr (word);
      746 	     strip_ix = 1;
      747 	     strip_len = length (word);
      748 	     call strip_punc;			/* strip surrounding punctuation from argument word */
      749 	     if word_ix > 1 | word_len < strip_len	/* some punctuation was removed */
      750 	     then goto bad_word;
      751 	     call check_ul;				/* check word for underlining */
      752 	     if ul_sw then goto bad_word;
      753 
      754 	end validate_word;
      755 
      756 strip_punc: proc;
      757 
      758 /* removes surrounding punctuation from a string
      759*   the input string is given by substr(strip_cs, strip_ix, strip_len)
      760*   the output string is given by substr(strip_cs, word_ix, word_len)
      761**/
      762 
      763 dcl  n fixed bin (24);
      764 
      765 	     n = verify (substr (strip_cs, strip_ix, strip_len), "([{""") -1; /* check for leading punctuation including PAD (177) */
      766 	     if n = -1 then goto no_strip;		/* if all punctuation, do not strip */
      767 	     word_ix = strip_ix + n;
      768 	     word_len = strip_len - n;
      769 	     n = verify (reverse (substr (strip_cs, word_ix, word_len)), ")]}""!,.:;?")-1; /* check for trailing punctuation */
      770 	     if n = -1 then do;			/* if all punctuation, do not strip */
      771 no_strip:		word_ix = strip_ix;
      772 		word_len = strip_len;
      773 		return;
      774 	     end;
      775 	     word_len = word_len - n;
      776 	     if word_len >= 2 then do;		/* enough room for underlining */
      777 		if strip_ix < word_ix then
      778 		     if substr (strip_cs, word_ix, 2) = "_"
      779 		     then do;			/* do not strip underlined leading punctuation */
      780 			word_ix = word_ix -1;
      781 			word_len = word_len + 1;
      782 		     end;
      783 		if word_ix + word_len < strip_ix + strip_len then
      784 		     if substr (strip_cs, word_ix + word_len -2, 2) = "_"
      785 		     then word_len = word_len +1;	/* do not strip underlined trailing punctuation */
      786 	     end;
      787 
      788 	end strip_punc;
      789 
      790 check_ul:	proc;
      791 
      792 /* checks word for continuous underlining
      793*   de-underlined string is assembled in ul_cs
      794*   underline without adjacent backspace -> space
      795*   the input word is given by substr(strip_cs, word_ix, word_len)
      796**/
      797 
      798 dcl (i, j) fixed bin;
      799 dcl  end_word_ix fixed bin;
      800 
      801 	     ul_sw = "0"b;				/* assume word is not underlined */
      802 	     if index (substr (strip_cs, word_ix, word_len), "") ^= 0
      803 	     then do;				/* word contains backspaces, check for underlining */
      804 		i = word_ix;
      805 		end_word_ix = word_ix + word_len - 1;
      806 		do j = 1 by 1 while (i <= end_word_ix); /* scan token */
      807 		     if i+2 > end_word_ix then goto check_single_ul;
      808 		     if substr (strip_cs, i, 2) = "_"
      809 		     then do;
      810 			substr (ul_cs, j, 1) = substr (strip_cs, i+2, 1);
      811 			i = i + 3;
      812 		     end;
      813 		     else if substr (strip_cs, i+1, 2) = "_"
      814 		     then do;
      815 			substr (ul_cs, j, 1) = substr (strip_cs, i, 1);
      816 			i = i +3;
      817 		     end;
      818 		     else
      819 check_single_ul:	     if substr (strip_cs, i, 1) = "_"
      820 		     then do;
      821 			substr (ul_cs, j, 1) = " ";
      822 			i = i + 1;
      823 		     end;
      824 		     else return;			/* not standard underlined string */
      825 		end;
      826 		ul_sw = "1"b;			/* yup, that was an underlined string */
      827 		ul_len = j - 1;			/* remember length of de-underlined string */
      828 	     end;
      829 
      830 	end check_ul;
      831 
      832 output_word: proc;
      833 
      834 /* Move the word specified to an output file. If MSF input, then if sorting the
      835*   word goes to a keyed vfile_, else put in stream output file. If ^MSF,
      836*   then if sorting, word ptr and length goes to sort_data array, else put in
      837*   output seg with NL appended. Since we're eliminating white space from the
      838*   input file and words are delimited by at least 1 white space character,
      839*   if the input is not an MSF, the output cannot be. Words containing no
      840*   letters are excluded from the wordlist unless -no_exclude specified.
      841**/
      842 
      843 dcl  1 aki,
      844        2 flags aligned,
      845          3 input_key bit (1) unaligned init ("1"b),
      846          3 input_desc bit (1) unaligned init ("1"b),
      847          3 mbz bit (34) unaligned init ("0"b),
      848        2 descrip fixed bin (35) init (0),
      849        2 key_len fixed bin,
      850        2 key char (256);
      851 
      852 	     if ^no_exclude_opt
      853 	     then if search (substr (strip_cs, word_ix, word_len), letters) = 0
      854 		then return;
      855 
      856 	     output_words = output_words + 1;
      857 	     if msf
      858 	     then if no_sort_opt
      859 		then do;
      860 		     call iox_$put_chars (outputp, addr (strip_vec (word_ix)), (word_len), code);
      861 		     if code ^= 0 then call err_exit;
      862 		     call iox_$put_chars (outputp, addr (NL), length (NL), code);
      863 		     if code ^= 0 then call err_exit;
      864 		     end;
      865 		else do;
      866 		     aki.key_len = min (256, word_len);
      867 		     aki.key = substr (strip_cs, word_ix, word_len);
      868 		     call iox_$control (sortp, "add_key", addr (aki), code);
      869 		     if code ^= 0
      870 		     then if code = error_table_$key_duplication
      871 			then ;			/* allowable */
      872 			else call err_exit;
      873 		end;
      874 	     else if no_sort_opt
      875 		then do;
      876 		     substr (output_cs, output_len + 1, word_len) = substr (strip_cs, word_ix, word_len);
      877 		     output_len = output_len + word_len;
      878 		     substr (output_cs, output_len + 1, 1) = NL;
      879 		     output_len = output_len + 1;
      880 		     end;
      881 		else do;
      882 		     if output_words > hbound (sort_data, 1)
      883 		     then do;
      884 			call com_err_ (0, whoami, "Number of words exceeds sorting limit of ^d.", hbound (sort_data, 1));
      885 			goto finish;
      886 		     end;
      887 
      888 		     sort_data (output_words).wordp = addr (strip_vec (word_ix));
      889 		     sort_data (output_words).wordl = word_len;
      890 		     end;
      891 
      892 	return;
      893 	end output_word;
      894 
      895 test_word: proc;
      896 
      897 /* tests if current word matches any of the match words
      898*   if a match is found, the action taken depends on whether locate_words or revise_words was called
      899*   for locate_words, the line number and line index of the current word is saved
      900*   for revise_words, the uncopied portion of the input string preceding the current word is copied to the temp seg
      901*   if "-long" was specified, the line number and line index of the revised word is saved
      902**/
      903 
      904 dcl  cc fixed bin (24);
      905 dcl  i fixed bin;
      906 
      907 /* Since the match_word array is sorted, we only have to
      908*   search until we find the first word in the array that is greater than or equal to the
      909*   current word. */
      910 
      911 	     do wordx = 1 to n_words while (match_word < substr (strip_cs, word_ix, word_len));
      912 	     end;
      913 
      914 	     if wordx <= n_words
      915 	     then if match_word = substr (strip_cs, word_ix, word_len)
      916 		then do;
      917 		     num_matches (wordx) = num_matches (wordx) + 1; /* we found a match, increment match count */
      918 		     if count_opt
      919 		     then return;
      920 		     if rw_cmd then do;		/* move chars before current word to temp seg and revise word */
      921 			if ul_sw then do;		/* word was de-underlined */
      922 			     word_ix = ul_ix + ul_spaces + 3* (word_ix-1-ul_spaces); /* get index of original word */
      923 			     word_len = 3 * word_len; /* get length of original word */
      924 			end;
      925 			word_ix = word_ix + line_ix -1;
      926 			cc = word_ix -last -1;	/* compute number of unmoved chars before word_ix */
      927 			substr (temp_cs, temp_len+1, cc) = substr (input_cs, last+1, cc); /* move 'em */
      928 			last = last + cc + word_len;	/* recompute last char moved */
      929 			temp_len = temp_len + cc;	/* number of chars in temp seg */
      930 			changed_lines = "1"b;
      931 			if ^ul_sw then do;
      932 			     substr (temp_cs, temp_len+1, length (rev_word)) = rev_word; /* drop in the revision */
      933 			     temp_len = temp_len + length (rev_word);
      934 			end;
      935 			else do i = 1 to length (rev_word); /* underline the revision canonically */
      936 			     if substr (rev_word, i, 1) < "_" then do;
      937 				substr (temp_cs, temp_len +1, 1) = substr (rev_word, i, 1);
      938 				temp_len = temp_len +1;
      939 				substr (temp_cs, temp_len+1, 2) = "_";
      940 				temp_len = temp_len + 2;
      941 			     end;
      942 			     else do;
      943 				substr (temp_cs, temp_len +1, 2) = "_";
      944 				temp_len = temp_len +2;
      945 				substr (temp_cs, temp_len +1, 1) = substr (rev_word, i, 1);
      946 				temp_len = temp_len +1;
      947 			     end;
      948 			end;
      949 			if long_opt
      950 			then do;			/* compute difference between original and revised line lengths */
      951 			     line_diff = line_diff + length (rev_word) - word_len;
      952 			     goto save_line_number;
      953 			end;
      954 		     end;
      955 		     else do;
      956 save_line_number:
      957 			if mod (num_matches (wordx), line_data_incr) = 1
      958 			then do;			/* allocate more space for line data */
      959 			     old_count = line_data_count (wordx);
      960 			     if old_count > 0
      961 			     then old_ptr = line_data_ptr (wordx);
      962 			     line_data_count (wordx) = old_count + line_data_incr;
      963 			     allocate line_data in (system_area);
      964 			     if old_count > 0
      965 			     then do;
      966 				line_data_ptr (wordx) -> line_data_mover = line_data_mover;
      967 				free line_data_mover in (system_area);
      968 			     end;
      969 			end;
      970 			line_num (num_matches (wordx)) = line; /* remember line number */
      971 			if long_opt
      972 			then if msf		/* don't need line_index for MSFs */
      973 			     then line_index (num_matches (wordx)) = 0;
      974 			     else do;		/* remember line index */
      975 				if lines = 0
      976 				then if lw_cmd
      977 				     then i = line_ix;
      978 				     else i = rev_line_ix;
      979 				else i = prev_line_ix (mod (prevx + 1, lines)); /* use oldest line in circular buffer */
      980 				line_index (num_matches (wordx)) = i;
      981 				end;
      982 		     end;
      983 		end;
      984 
      985 	end test_word;
      986 
      987 print_long: proc;					/* prints output for -long option */
      988 
      989 dcl (i, j, k) fixed bin (21);
      990 dcl  last_line_printed fixed bin (21);
      991 dcl  j_contains_match bit(1);
      992 dcl  NL_index fixed bin (21);
      993   
      994 	     if n_words ^= 1
      995 	     then if lw_cmd
      996 		then call ioa_ ("^2/^a^/", match_word);
      997 		else call ioa_ ("^2/^a^/", rev_word);
      998 
      999 	     if num_matches (wordx) = 0
     1000 	     then do;
     1001 		call ioa_ ("^-NONE");
     1002 		return;
     1003 	     end;
     1004 
     1005 	     last_line_printed = 0;
     1006 	     do i = 1 to num_matches (wordx);		/* print line containing each match */
     1007 		if i > 1
     1008 		then if line_num (i) = line_num (i-1)
     1009 		     then goto next_line_num;	/* don't print same line twice */
     1010 		line = line_num (i);
     1011 		line_ix = line_index (i);
     1012 		do j = max (line - lines, 1) to line + lines;	/* print surrounding lines */
     1013 		     if ^msf
     1014 		     then if line_ix > input_len
     1015 			then goto next_line_num;
     1016 
     1017 		     if i < num_matches (wordx)
     1018 		     then if (j = line_num (i+1)) & (j ^= line)
     1019 			then goto next_line_num;	/* don't print line for next match yet */
     1020 
     1021 		     if msf then do;
     1022 			if j ^= current_record
     1023 			then do;			/* find record with relative positioning */
     1024 			     call iox_$position (inputp, 0, j - current_record, code);
     1025 			     if code ^= 0 & code ^= error_table_$short_record then call err_exit;
     1026 			     end;
     1027 			call iox_$get_line (inputp, line_ptr, max_line_len, line_len, code);
     1028 			if code ^= 0
     1029 			then if code = error_table_$end_of_info
     1030 			     then goto next_line_num;
     1031 			     else call err_exit;
     1032 
     1033 			current_record = j + 1;	/* reading advanced by 1 record */
     1034 		          NL_index = index (input_line, NL); /* look for NL */
     1035 			if NL_index ^= 0
     1036 			then line_len = NL_index - 1; /* we have one, bump back 1 char so ioa_ doesn't print 2 NLs */
     1037 			end;
     1038 		     else do;
     1039 			line_ptr = addr (input_vec (line_ix));
     1040 			line_len = index (substr (input_cs, line_ix), NL) -1;
     1041 			if line_len = -1
     1042 			then line_len = input_len - line_ix + 1;
     1043 			end;
     1044 		     if j > last_line_printed
     1045 		     then do;
     1046 			do k = i to num_matches (wordx);
     1047 			     if line_num (k) = j 
     1048 			     then do;
     1049 				j_contains_match = "1"b;
     1050 				k = num_matches (wordx);
     1051 			     end;
     1052 			     else j_contains_match = "0"b;
     1053 			end;
     1054 			call ioa_ ("^6d ^[*^; ^]  ^a", j, ((lines > 0) & ((j = line) | (j_contains_match = "1"b))), input_line);
     1055 			last_line_printed = j;
     1056 		     end;
     1057 		     line_ix = line_ix + line_len + 1;
     1058 		end;
     1059 next_line_num:
     1060 	     end;
     1061 
     1062 	end print_long;
     1063 
     1064 copy_keyed_file:
     1065      proc;
     1066 
     1067 dcl  1 gki,
     1068        2 flags aligned like gk_header.flags,
     1069        2 descrip fixed bin (35) aligned,
     1070        2 key_len fixed bin,
     1071        2 key char (256);
     1072 
     1073 	unspec (gki) = "0"b;
     1074 
     1075 	dname = sort_dir;
     1076 	ename = sort_name;
     1077 	call iox_$position (sortp, -1, 0, code);	/* to BOF */
     1078 	if code ^= 0 then call err_exit;
     1079 
     1080 	code, output_words = 0;
     1081 	do while (code = 0);
     1082 	     call iox_$control (sortp, "get_key", addr (gki), code);
     1083 	     if code = 0 then do;
     1084 		output_words = output_words + 1;
     1085 		call iox_$put_chars (outputp, addr (gki.key), (gki.key_len), code);
     1086 		if code ^= 0 then call err_exit;
     1087 		call iox_$put_chars (outputp, addr (NL), length (NL), code);
     1088 		if code ^= 0 then call err_exit;
     1089 
     1090 		call iox_$position (sortp, 0, 1, code);
     1091 		if code = 0 then call iox_$control (sortp, "get_key", addr (gki), code);
     1092 		end;
     1093 	     end;
     1094 	if code = error_table_$end_of_info | code = error_table_$no_key | code = error_table_$no_record
     1095 	then ;					/* allowable errors */
     1096 	else call err_exit;
     1097 
     1098 	return;
     1099 	end copy_keyed_file;
     1100 
     1101 copy_sorted_words: proc;
     1102 
     1103 /* copies sorted words from temp seg to output seg
     1104*   eliminates duplications
     1105**/
     1106 
     1107 dcl  i fixed bin (24);
     1108 dcl  unique_words fixed bin (24);
     1109 dcl (wordp, last_wordp) ptr;
     1110 dcl (wordl, last_wordl) fixed bin (24);
     1111 dcl  sort_string char (wordl) based (wordp);
     1112 dcl  last_sort_string char (last_wordl) based (last_wordp);
     1113 
     1114 
     1115 	     unique_words = 0;
     1116 	     last_wordl = 0;
     1117 
     1118 	     do i = 1 to output_words;
     1119 		wordp = sort_data (i).wordp;
     1120 		wordl = sort_data (i).wordl;
     1121 
     1122 		if wordl = last_wordl
     1123 		then if sort_string = last_sort_string
     1124 		     then goto next_word;
     1125 		unique_words = unique_words + 1;
     1126 
     1127 		last_wordl = wordl;
     1128 		last_wordp = wordp;
     1129 
     1130 		substr (output_cs, output_len + 1, wordl) = sort_string;
     1131 		output_len = output_len + wordl;
     1132 		substr (output_cs, output_len + 1, 1) = NL;
     1133 		output_len = output_len + 1;
     1134 
     1135 next_word:
     1136 	     end;
     1137 
     1138 	     output_words = unique_words;
     1139 
     1140 	end copy_sorted_words;
     1141 
     1142 cleaner:	proc;					/* cleanup handler */
     1143 
     1144 	     if plip ^= null then do;
     1145 		free prev_line_ix in (system_area);
     1146 		plip = null;
     1147 	     end;
     1148 
     1149 	     if ldpp ^= null then do;
     1150 		do wordx = 1 to n_words;
     1151 		     if line_data_count (wordx) > 0
     1152 		     then free line_data in (system_area);
     1153 		end;
     1154 		free line_data_ptr in (system_area);
     1155 		free line_data_count in (system_area);
     1156 		ldpp, ldcp = null;
     1157 	     end;
     1158 	     if nmp ^= null then do;
     1159 		free num_matches in (system_area);
     1160 		nmp = null;
     1161 	     end;
     1162 	     if mpp ^= null then do;
     1163 		free match_ptr in (system_area);
     1164 		mpp = null;
     1165 	     end;
     1166 	     if mlp ^= null then do;
     1167 		free match_len in (system_area);
     1168 		mlp = null;
     1169 	     end;
     1170 	     if rpp ^= null then do;
     1171 		free rev_ptr in (system_area);
     1172 		rpp = null;
     1173 	     end;
     1174 	     if rlp ^= null then do;
     1175 		free rev_len in (system_area);
     1176 		rlp = null;
     1177 	     end;
     1178 
     1179 	     if temp_ptr_array (1) ^= null
     1180 	     then call release_temp_segments_ (whoami, temp_ptr_array, code);
     1181 
     1182 	     if msf then do;
     1183 		call close_file (inputp);
     1184 		call close_file (outputp);
     1185 		if ^no_sort_opt & cwl_cmd then do;
     1186 		     call close_file (sortp);
     1187 		     call delete_$path (sort_dir, sort_name, "101111"b, whoami, code);
     1188 		     if code ^= 0 then call com_err_ (code, whoami, "Deleting ^a.", pathname_ (sort_dir, sort_name));
     1189 		     end;
     1190 		end;
     1191 	     else do;				/* terminate input  output segs */
     1192 		if input_ptr = output_ptr
     1193 		then input_ptr = null;
     1194 		do input_ptr = input_ptr, output_ptr;
     1195 		     if input_ptr ^= null then call terminate_file_ (input_ptr, 0, TERM_FILE_TERM, (0));
     1196 		     end;
     1197 		end;
     1198 
     1199 	return;
     1200 	end cleaner;
     1201 
     1202 copy_temp_file:
     1203      proc (input_dir, input_name, output_dir, output_name);
     1204 
     1205 /* Copy the contents of the input file to the output file. This is only used
     1206*   in MSF mode. */
     1207 
     1208 dcl  (input_dir, output_dir) char (*) parameter;
     1209 dcl  (input_name, output_name) char (*) parameter;
     1210 dcl  buffer char (1024);
     1211 
     1212 dcl 1 co like copy_options;
     1213 
     1214 dcl  copy_ entry (ptr);
     1215 
     1216 	co.version = COPY_OPTIONS_VERSION_1;
     1217 	co.caller_name = whoami;
     1218 	co.source_dir = input_dir;
     1219 	co.source_name = input_name;
     1220 	co.target_dir = output_dir;
     1221 	co.target_name = output_name;
     1222 	unspec (co.flags) = "0"b;
     1223 	co.flags.delete = "1"b;			/* delete source when done */
     1224 	co.flags.force = "1"b;			/* try to force access if needed */
     1225 
     1226 	unspec (co.copy_items) = "0"b;
     1227 	co.copy_items.update = "1"b;
     1228 
     1229 	call copy_ (addr(co));			/* copy work file to input file */
     1230 	if co.target_err_switch
     1231 	then call err_exit;				/* errors reported by sub_err_ */
     1232 
     1233 	return;
     1234 	end copy_temp_file;
     1235 
     1236 open_file:
     1237      proc (dir, ent, iocbp, mode);
     1238 
     1239 dcl  (dir, ent) char (*) parameter;
     1240 dcl  iocbp ptr parameter;
     1241 dcl  mode fixed bin parameter;
     1242 dcl  atd char (256) varying;
     1243 dcl  switchname char (32) varying;
     1244 
     1245 	dname = dir;
     1246 	if dname = "" then dname = temp_dir;
     1247 	ename = ent;
     1248 	if ename = "" then ename = unique_chars_ ("0"b) || "." || whoami;
     1249 
     1250 	atd = "vfile_ " || rtrim (dname);
     1251 	atd = atd || ">";
     1252 	atd = atd || rtrim (ename);
     1253 
     1254 	switchname = unique_chars_ (""b) || ".";
     1255 	switchname = switchname || whoami;
     1256 
     1257 	call iox_$attach_name ((switchname), iocbp, (atd), null, code);
     1258 	if code ^= 0 then call err_exit;
     1259 
     1260 	call iox_$open (iocbp, mode, "0"b, code);
     1261 	if code ^= 0 then call err_exit;
     1262 
     1263 	return;
     1264 	end open_file;
     1265 
     1266 close_file:
     1267      proc (iocbp);
     1268 
     1269 dcl  iocbp ptr parameter;
     1270 
     1271 	if iocbp ^= null then do;
     1272 	     call iox_$close (iocbp, (0));
     1273 	     call iox_$detach_iocb (iocbp, (0));
     1274 	     call iox_$destroy_iocb (iocbp, (0));
     1275 	     end;
     1276 
     1277 	return;
     1278 	end close_file;
     1279 
  1     1 /* BEGIN INCLUDE FILE: copy_options.incl.pl1 */
  1     2 
  1     3 /* This structure declares the input structure used by the copy_ subroutine.
  1     4*
  1     5*   NOTE: This include file depends on declarations in the include file
  1     6*   copy_flags.incl.pl1.
  1     7*
  1     8*   Jay Pattin 6/1/83 */
  1     9 
  1    10 declare   copy_options_ptr              ptr;
  1    11 
  1    12 declare   1 copy_options                aligned based (copy_options_ptr),
  1    13           2 version                     char (8),           /* currently COPY_OPTIONS_VERSION_1 */
  1    14           2 caller_name                 char (32) unal,     /* Used in nd_handler_ call */
  1    15           2 source_dir                  char (168) unal,
  1    16           2 source_name                 char (32) unal,
  1    17           2 target_dir                  char (168) unal,
  1    18           2 target_name                 char (32) unal,
  1    19           2 flags,
  1    20             3 no_name_dup               bit (1) unaligned,  /* ON = don't call nd_handler_ */
  1    21             3 raw                       bit (1) unaligned,  /* ON = don't call object_type_, use hcs_ */
  1    22             3 force                     bit (1) unaligned,  /* ON = delete or force access to target */
  1    23             3 delete                    bit (1) unaligned,  /* ON = delete original after copy (for move) */
  1    24             3 target_err_switch         bit (1) unaligned,
  1    25             3 mbz                       bit (31) unaligned,
  1    26           2 copy_items                  like copy_flags;    /* see copy_flags.incl.pl1 */
  1    27 
  1    28 declare   COPY_OPTIONS_VERSION_1        char (8) static options (constant) init ("CPOPT001");
  1    29 
  1    30 /* END INCLUDE FILE: copy_options.incl.pl1 */
     1280 
  2     1 /* BEGIN INCLUDE FILE:  copy_flags.incl.pl1 */
  2     2 
  2     3 /* Flags for attributes that should/may be copied by the copy_ subroutine. This include file is
  2     4*   required by suffix_info.incl.pl1 and copy_options.incl.pl1
  2     5*
  2     6*   Jay Pattin 6/23/83 */
  2     7 
  2     8 declare   1 copy_flags                  aligned based,      /* ON means that this attribute may be copied by copy_ */
  2     9           2 names                       bit (1) unaligned,
  2    10           2 acl                         bit (1) unaligned,
  2    11           2 ring_brackets               bit (1) unaligned,
  2    12           2 max_length                  bit (1) unaligned,
  2    13           2 copy_switch                 bit (1) unaligned,
  2    14           2 safety_switch               bit (1) unaligned,
  2    15           2 dumper_switches             bit (1) unaligned,
  2    16           2 entry_bound                 bit (1) unaligned,  /* only for vanilla object segments */
  2    17           2 extend                      bit (1) unaligned,  /* copy_ may append to end of existing object */
  2    18           2 update                      bit (1) unaligned,  /* copy_ may replace contents of existing object */
  2    19           2 mbz                         bit (26) unaligned;
  2    20 
  2    21 /* END INCLUDE FILE:  copy_flags.incl.pl1 */
     1281 
  3     1 /* ak_info -- include file for info structures used by the following vfile_
  3     2*   control orders: "add_key", "delete_key", "get_key", and "reassign_key".
  3     3*   Created by M. Asherman 3/23/76
  3     4*   Modified 5/13/77 to add separate gk_info structure */
  3     5 
  3     6      dcl	   1 ak_info	      based (ak_info_ptr),
  3     7 	     2 header	      like ak_header,
  3     8 	     2 key	      char (ak_key_len refer (ak_info.header.key_len));
  3     9 
  3    10      dcl	   1 ak_header	      based (ak_info_ptr),
  3    11 	     2 flags	      aligned,
  3    12 	       3 input_key	      bit (1) unal,		/* set if key is input arg */
  3    13 	       3 input_desc	      bit (1) unal,		/* set if descriptor is an input arg */
  3    14 	       3 mbz	      bit (34) unal,	/* not used for the present */
  3    15 	     2 descrip	      fixed (35),		/* record designator */
  3    16 	     2 key_len	      fixed;
  3    17 
  3    18      dcl	   ak_info_ptr	      ptr;
  3    19      dcl	   ak_key_len	      fixed;
  3    20 
  3    21 
  3    22      dcl	   1 rk_info	      based (rk_info_ptr),
  3    23 	     2 header	      like rk_header,
  3    24 	     2 key	      char (rk_key_len refer (rk_info.header.key_len));
  3    25 
  3    26      dcl	   1 rk_header	      based (rk_info_ptr),
  3    27 	     2 flags	      aligned,
  3    28 	       3 input_key	      bit (1) unal,		/* same as above */
  3    29 	       3 input_old_desc   bit (1) unal,		/* set if specified entry has initial descrip
  3    30*						   given by old_descrip */
  3    31 	       3 input_new_desc   bit (1) unal,		/* set if new val for descrip is input in this struc */
  3    32 	       3 mbz	      bit (33) unal,
  3    33 	     2 old_descrip	      fixed (35),		/* used if first flag is set */
  3    34 	     2 new_descrip	      fixed (35),		/* used only if second flag is set */
  3    35 	     2 key_len	      fixed;
  3    36 
  3    37      dcl	   rk_info_ptr	      ptr;
  3    38      dcl	   rk_key_len	      fixed;
  3    39 
  3    40 
  3    41      dcl	   1 gk_info	      based (gk_info_ptr),	/* structure for get_key order */
  3    42 	     2 header	      like gk_header,
  3    43 	     2 key	      char (gk_key_len refer (gk_info.header.key_len));
  3    44 						/* may be Input as well as Output */
  3    45 
  3    46      dcl	   1 gk_header	      based (gk_info_ptr),
  3    47 	     2 flags	      aligned,
  3    48 	       3 input_key	      bit (1) unal,		/* if set, use key in this structure */
  3    49 	       3 input_desc	      bit (1) unal,		/* if set, descriptor given in this structure */
  3    50 	       3 desc_code	      fixed (2) unal,	/* 0=any, 1=current -- applies when input_desc="0"b */
  3    51 	       3 position_specification
  3    52 			      unal,
  3    53 	         4 current	      bit (1) unal,		/* otherwise next */
  3    54 	         4 rel_type	      fixed (2) unal,	/* as in seek_head, if input_key = "1"b */
  3    55 	         4 head_size      fixed bin (9) unsigned unaligned,
  3    56 						/* size of head for initial seek */
  3    57 	       3 reset_pos	      bit (1) unal,		/* if set, final position unchanged by this operation */
  3    58 	       3 pad	      bit (8) unal,
  3    59 	       3 version	      fixed (8) unal,
  3    60 	     2 descrip	      fixed (35),		/* Output, except when input_desc="1"b */
  3    61 	     2 key_len	      fixed;		/* Input when input_key="1"b, also Output in all cases */
  3    62 
  3    63      dcl	   gk_info_ptr	      ptr;
  3    64      dcl	   gk_key_len	      fixed;
  3    65 
  3    66      dcl	   gk_info_version_0      internal static fixed options (constant) init (0);
  3    67 
  3    68 /* end ak_info.incl.pl1 */
     1282 
  4     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  4     2*
  4     3*   Values for the "access mode" argument so often used in hardcore
  4     4*   James R. Davis 26 Jan 81  MCR 4844
  4     5*   Added constants for SM access 4/28/82 Jay Pattin
  4     6*   Added text strings 03/19/85 Chris Jones
  4     7**/
  4     8 
  4     9 
  4    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  4    11 dcl	(
  4    12 	N_ACCESS		   init ("000"b),
  4    13 	R_ACCESS		   init ("100"b),
  4    14 	E_ACCESS		   init ("010"b),
  4    15 	W_ACCESS		   init ("001"b),
  4    16 	RE_ACCESS		   init ("110"b),
  4    17 	REW_ACCESS	   init ("111"b),
  4    18 	RW_ACCESS		   init ("101"b),
  4    19 	S_ACCESS		   init ("100"b),
  4    20 	M_ACCESS		   init ("010"b),
  4    21 	A_ACCESS		   init ("001"b),
  4    22 	SA_ACCESS		   init ("101"b),
  4    23 	SM_ACCESS		   init ("110"b),
  4    24 	SMA_ACCESS	   init ("111"b)
  4    25 	)		   bit (3) internal static options (constant);
  4    26 
  4    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  4    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  4    29 
  4    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  4    31 			   static options (constant);
  4    32 
  4    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  4    34 			   static options (constant);
  4    35 
  4    36 dcl	(
  4    37 	N_ACCESS_BIN	   init (00000b),
  4    38 	R_ACCESS_BIN	   init (01000b),
  4    39 	E_ACCESS_BIN	   init (00100b),
  4    40 	W_ACCESS_BIN	   init (00010b),
  4    41 	RW_ACCESS_BIN	   init (01010b),
  4    42 	RE_ACCESS_BIN	   init (01100b),
  4    43 	REW_ACCESS_BIN	   init (01110b),
  4    44 	S_ACCESS_BIN	   init (01000b),
  4    45 	M_ACCESS_BIN	   init (00010b),
  4    46 	A_ACCESS_BIN	   init (00001b),
  4    47 	SA_ACCESS_BIN	   init (01001b),
  4    48 	SM_ACCESS_BIN	   init (01010b),
  4    49 	SMA_ACCESS_BIN	   init (01011b)
  4    50 	)		   fixed bin (5) internal static options (constant);
  4    51 
  4    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
     1283 
  5     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  5     2 /* format: style2,^inddcls,idind32 */
  5     3 
  5     4 declare 1 terminate_file_switches	based,
  5     5 	2 truncate		bit (1) unaligned,
  5     6 	2 set_bc			bit (1) unaligned,
  5     7 	2 terminate		bit (1) unaligned,
  5     8 	2 force_write		bit (1) unaligned,
  5     9 	2 delete			bit (1) unaligned;
  5    10 
  5    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  5    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  5    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  5    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  5    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  5    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  5    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  5    18 
  5    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
     1284 
  6     1 /* Begin include file ..... iox_modes.incl.pl1 */
  6     2 
  6     3 /* Written by C. D. Tavares, 03/17/75 */
  6     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  6     5 
  6     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  6     7     ("stream_input", "stream_output", "stream_input_output",
  6     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  6     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  6    10      "direct_input", "direct_output", "direct_update");
  6    11 
  6    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  6    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  6    14 
  6    15 dcl (Stream_input initial (1),
  6    16      Stream_output initial (2),
  6    17      Stream_input_output initial (3),
  6    18      Sequential_input initial (4),
  6    19      Sequential_output initial (5),
  6    20      Sequential_input_output initial (6),
  6    21      Sequential_update initial (7),
  6    22      Keyed_sequential_input initial (8),
  6    23      Keyed_sequential_output initial (9),
  6    24      Keyed_sequential_update initial (10),
  6    25      Direct_input initial (11),
  6    26      Direct_output initial (12),
  6    27      Direct_update initial (13)) fixed bin int static options (constant);
  6    28 
  6    29 /* End include file ..... iox_modes.incl.pl1 */
     1285 
     1286 
     1287      end create_wordlist;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/23/89  1229.7  create_wordlist.pl1               >spec>install>1010>create_wordlist.pl1
1280         1    10/14/83  1606.7  copy_options.incl.pl1             >ldd>include>copy_options.incl.pl1
1281         2    10/14/83  1606.7  copy_flags.incl.pl1               >ldd>include>copy_flags.incl.pl1
1282         3    07/19/79  1547.0  ak_info.incl.pl1                  >ldd>include>ak_info.incl.pl1
1283         4    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
1284         5    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
1285         6    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
COPY_OPTIONS_VERSION_1          000002 constant        char(8)                  initial packed unaligned dcl 1-28 ref 1216
Keyed_sequential_update                constant        fixed bin(17,0)          initial dcl 6-15 set ref 421*
NL                              000010 internal static char(1)                  initial dcl 120 set ref 492 862 862 862 862 878 1034
                                                                                  1040 1087 1087 1087 1087 1132
NL_index                        001051 automatic       fixed bin(21,0)          dcl 992 set ref 1034* 1035 1035
R_ACCESS                        000112 constant        bit(3)                   initial packed unaligned dcl 4-11 set ref 385*
Stream_input                           constant        fixed bin(17,0)          initial dcl 6-15 set ref 383*
Stream_output                          constant        fixed bin(17,0)          initial dcl 6-15 set ref 419* 432*
TERM_FILE_TERM                  000000 constant        bit(3)                   initial packed unaligned dcl 5-14 set ref 1195*
TERM_FILE_TRUNC_BC              000001 constant        bit(2)                   initial packed unaligned dcl 5-13 set ref 697*
absolute_pathname_              000046 constant        entry                    external dcl 153 ref 279
addr                                                   builtin function         dcl 148 ref 504 554 587 587 745 860 860 862 862 868
                                                                                  868 888 1039 1082 1082 1085 1085 1087 1087 1091
                                                                                  1091 1229 1229
ak_header                              based           structure                level 1 unaligned dcl 3-10
aki                             000720 automatic       structure                level 1 unaligned dcl 843 set ref 868 868
al                              000206 automatic       fixed bin(17,0)          dcl 43 set ref 231* 232 234 234 236 236 246 258 263
                                                                                  267 271 271 272 272 273 273 274 274 275 275 276
                                                                                  276 277 277 279 279 281 281 285 285 287 287 292
                                                                                  292 296 302 302 307* 308 308 317 317 322 322 717*
                                                                                  727 727
alphabetize_strings_            000104 constant        entry                    external dcl 168 ref 655
ap                              000204 automatic       pointer                  dcl 42 set ref 231* 232 234 236 246 257 262 267 271
                                                                                  271 272 272 273 273 274 274 275 275 276 276 277
                                                                                  277 279 281 285 285 287 287 292 296 302 302 307*
                                                                                  308 317 322 717* 727
arg                                    based           char                     packed unaligned dcl 84 set ref 232 234* 236* 246
                                                                                  267 271 271 272 272 273 273 274 274 275 275 276
                                                                                  276 277 277 279* 281* 285 285 287 287 292* 296 302
                                                                                  302 308* 317* 322* 727*
arg_syntax                      000477 automatic       char(120)                packed unaligned dcl 64 set ref 185* 192* 199* 204*
argno                           000224 automatic       fixed bin(17,0)          dcl 50 set ref 230* 231* 304 306* 306 307* 312* 312*
                                                                                  713* 713 714 717*
atd                             001404 automatic       varying char(256)        dcl 1242 set ref 1250* 1251* 1251 1252* 1252 1257
bc                              000536 automatic       fixed bin(24,0)          dcl 66 set ref 366* 369 385* 387
brief_opt                       000231 automatic       bit(1)                   initial dcl 52 set ref 52* 272* 331 650 658 676
caller_name               2     001216 automatic       char(32)                 level 2 packed packed unaligned dcl 1212 set ref
                                                                                  1217*
cc                              001032 automatic       fixed bin(24,0)          dcl 904 set ref 926* 927 927 928 929
changed_lines                   000156 automatic       bit(1)                   dcl 36 set ref 466* 616 930*
cleanup                         000622 stack reference condition                dcl 143 ref 217 361
co                              001216 automatic       structure                level 1 packed packed unaligned dcl 1212 set ref
                                                                                  1229 1229
code                            000535 automatic       fixed bin(35,0)          dcl 65 set ref 203* 204* 231* 234* 235 236* 242*
                                                                                  279* 280 281* 290 299 307* 308* 309 311* 366* 367
                                                                                  372* 385* 389* 395* 396 407* 408 408 427* 437* 438
                                                                                  440* 471* 475 475 479 585* 586 587* 590* 591 594*
                                                                                  618* 619 620* 621 621 621* 624 626* 632* 633 666*
                                                                                  697* 698 707* 717* 727* 860* 861 862* 863 868* 869
                                                                                  869 1024* 1025 1025 1027* 1028 1028 1077* 1078
                                                                                  1080* 1081 1082* 1083 1085* 1086 1087* 1088 1090*
                                                                                  1091 1091* 1094 1094 1094 1179* 1187* 1188 1188*
                                                                                  1257* 1258 1260* 1261
com_err_                        000066 constant        entry                    external dcl 161 ref 204 236 281 292 317 322 333 400
                                                                                  413 440 707 741 884 1188
copy_                           000142 constant        entry                    external dcl 1214 ref 1229
copy_flags                             based           structure                level 1 dcl 2-8
copy_items              157     001216 automatic       structure                level 2 packed packed unaligned dcl 1212 set ref
                                                                                  1226*
copy_options                           based           structure                level 1 dcl 1-12
count_opt                       000235 automatic       bit(1)                   initial dcl 55 set ref 55* 276* 331 333* 349 670 918
cu_$arg_count                   000050 constant        entry                    external dcl 154 ref 200
cu_$arg_ptr                     000052 constant        entry                    external dcl 155 ref 231 307 717
current_record                  000154 automatic       fixed bin(24,0)          dcl 34 set ref 665* 1022 1024 1033*
cv_dec_check_                   000102 constant        entry                    external dcl 167 ref 308 727
cwl_cmd                         000237 automatic       bit(1)                   initial dcl 57 set ref 57* 183* 201 212 241 271 274
                                                                                  275 302 327 340 394 550 554 559 649 695 1185
delete                  156(03) 001216 automatic       bit(1)                   level 3 packed packed unaligned dcl 1212 set ref
                                                                                  1223*
delete_$path                    000060 constant        entry                    external dcl 158 ref 1187
delim_ix                        000570 automatic       fixed bin(21,0)          dcl 73 set ref 511* 513 514 515 518 563*
delim_len                       000571 automatic       fixed bin(21,0)          dcl 73 set ref 514* 515 515* 518
delims                          000022 constant        char(5)                  initial dcl 118 ref 514 524 739
descrip                   1     000720 automatic       fixed bin(35,0)          initial level 2 dcl 843 set ref 843*
dir                                    parameter       char                     packed unaligned dcl 1239 ref 1236 1245
divide                                                 builtin function         dcl 148 ref 216 387 449
dname                           000301 automatic       char(168)                packed unaligned dcl 63 set ref 234* 364 366* 383*
                                                                                  385* 405* 407* 413* 413* 419* 422 427* 433 630*
                                                                                  1075* 1245* 1246 1246* 1250
ename                           000251 automatic       char(32)                 packed unaligned dcl 62 set ref 234* 363 366* 383*
                                                                                  385* 398 400* 403* 407* 413* 413* 419* 423 427*
                                                                                  434 630* 1076* 1247* 1248 1248* 1252
end_word_ix                     000710 automatic       fixed bin(17,0)          dcl 799 set ref 805* 806 807
ent                                    parameter       char                     packed unaligned dcl 1239 ref 1236 1247
error_table_$badopt             000034 external static fixed bin(35,0)          dcl 124 set ref 322*
error_table_$dirseg             000014 external static fixed bin(35,0)          dcl 124 ref 372
error_table_$end_of_info        000026 external static fixed bin(35,0)          dcl 124 ref 475 624 1028 1094
error_table_$entlong            000042 external static fixed bin(35,0)          dcl 124 set ref 400*
error_table_$inconsistent       000036 external static fixed bin(35,0)          dcl 124 set ref 333*
error_table_$key_duplication    000016 external static fixed bin(35,0)          dcl 124 ref 869
error_table_$no_key             000020 external static fixed bin(35,0)          dcl 124 ref 1094
error_table_$no_record          000022 external static fixed bin(35,0)          dcl 124 ref 1094
error_table_$noarg              000012 external static fixed bin(35,0)          dcl 124 ref 203
error_table_$noentry            000030 external static fixed bin(35,0)          dcl 124 ref 408
error_table_$short_record       000024 external static fixed bin(35,0)          dcl 124 ref 479 621 1025
error_table_$wrong_no_of_args   000032 external static fixed bin(35,0)          dcl 124 ref 242
error_table_$zero_length_seg    000040 external static fixed bin(35,0)          dcl 124 ref 389
expand_pathname_                000054 constant        entry                    external dcl 156 ref 234
flags                                  based           structure                level 2 in structure "gk_header" dcl 3-46
                                                                                  in procedure "cwl"
flags                                  based           structure                level 3 in structure "gk_info" dcl 3-41 in procedure
                                                                                  "cwl"
flags                   156     001216 automatic       structure                level 2 in structure "co" packed packed unaligned
                                                                                  dcl 1212 in procedure "copy_temp_file" set ref
                                                                                  1222*
flags                           000720 automatic       structure                level 2 in structure "aki" dcl 843 in procedure
                                                                                  "output_word"
force                   156(02) 001216 automatic       bit(1)                   level 3 packed packed unaligned dcl 1212 set ref
                                                                                  1224*
from_line                       000567 automatic       fixed bin(24,0)          initial dcl 72 set ref 72* 289* 290 496
get_pdir_                       000114 constant        entry                    external dcl 171 ref 228
get_system_free_area_           000056 constant        entry                    external dcl 157 ref 218
get_temp_segments_              000106 constant        entry                    external dcl 169 ref 437
get_wdir_                       000072 constant        entry                    external dcl 163 ref 405 630 630
gk_header                              based           structure                level 1 unaligned dcl 3-46
gki                             001064 automatic       structure                level 1 unaligned dcl 1067 set ref 1073* 1082 1082
                                                                                  1091 1091
got_pname                       000242 automatic       bit(1)                   initial dcl 58 set ref 58* 233 239* 327
hbound                                                 builtin function         dcl 148 ref 882 884 884
hcs_$get_uid_file               000074 constant        entry                    external dcl 164 ref 395 407
hcs_$make_seg                   000076 constant        entry                    external dcl 165 ref 427
hcs_$status_minf                000100 constant        entry                    external dcl 166 ref 366
header_opt                      000233 automatic       bit(1)                   initial dcl 53 set ref 53* 273* 453
i                               000607 automatic       fixed bin(24,0)          dcl 76 in procedure "cwl" set ref 398* 399 403 538*
                                                                                  539 540 542* 542 544 545 547 552* 552 685* 686
                                                                                  686*
i                               001044 automatic       fixed bin(21,0)          dcl 989 in procedure "print_long" set ref 1006* 1007
                                                                                  1007 1007 1010 1011 1017 1017 1046*
i                               001176 automatic       fixed bin(24,0)          dcl 1107 in procedure "copy_sorted_words" set ref
                                                                                  1118* 1119 1120*
i                               000706 automatic       fixed bin(17,0)          dcl 798 in procedure "check_ul" set ref 804* 806 807
                                                                                  808 810 811* 811 813 815 816* 816 818 822* 822
i                               001033 automatic       fixed bin(17,0)          dcl 905 in procedure "test_word" set ref 935* 936
                                                                                  937 945* 975* 978* 979* 980
index                                                  builtin function         dcl 148 ref 232 492 544 802 1034 1040
initiate_file_                  000062 constant        entry                    external dcl 159 ref 385
input_cs                               based           char                     packed unaligned dcl 100 ref 492 640 927 1040
input_desc                0(01) 000720 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 843 set
                                                                                  ref 843*
input_dir                              parameter       char                     packed unaligned dcl 1208 ref 1202 1218
input_dname                     000353 automatic       char(168)                packed unaligned dcl 63 set ref 364* 395* 413* 413*
                                                                                  453* 453* 707* 707*
input_ename                     000261 automatic       char(32)                 packed unaligned dcl 62 set ref 363* 395* 413* 413*
                                                                                  453* 453* 630* 707* 707*
input_key                       000720 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 843 set
                                                                                  ref 843*
input_len                       000556 automatic       fixed bin(21,0)          dcl 69 set ref 387* 388 471* 489 492 493 587 587
                                                                                  590* 594* 620* 621* 638 640 645* 927 1013 1040
                                                                                  1041
input_line                             based           char                     packed unaligned dcl 102 set ref 506 514 524 1034
                                                                                  1054*
input_name                             parameter       char                     packed unaligned dcl 1209 ref 1202 1219
input_ptr                       000546 automatic       pointer                  initial dcl 68 set ref 68* 385* 386 445* 492 504 587
                                                                                  587 640 643 927 1039 1040 1192 1192* 1194* 1194*
                                                                                  1195 1195*
input_vec                              based           char(1)                  array packed unaligned dcl 101 set ref 504 587 587
                                                                                  1039
inputp                          000160 automatic       pointer                  initial dcl 38 set ref 38* 383* 471* 594* 620* 626*
                                                                                  632* 666* 1024* 1027* 1183*
invalid_sw                      000243 automatic       bit(1)                   dcl 59 set ref 341* 345 742*
ioa_                            000070 constant        entry                    external dcl 162 ref 453 650 658 670 674 676 681 686
                                                                                  994 997 1001 1054
iocbp                                  parameter       pointer                  dcl 1269 in procedure "close_file" set ref 1266 1271
                                                                                  1272* 1273* 1274*
iocbp                                  parameter       pointer                  dcl 1240 in procedure "open_file" set ref 1236 1257*
                                                                                  1260*
iox_$attach_name                000120 constant        entry                    external dcl 173 ref 1257
iox_$close                      000124 constant        entry                    external dcl 175 ref 626 1272
iox_$control                    000140 constant        entry                    external dcl 181 ref 868 1082 1091
iox_$destroy_iocb               000130 constant        entry                    external dcl 177 ref 1274
iox_$detach_iocb                000126 constant        entry                    external dcl 176 ref 1273
iox_$get_line                   000132 constant        entry                    external dcl 178 ref 471 594 620 1027
iox_$open                       000122 constant        entry                    external dcl 174 ref 632 1260
iox_$position                   000136 constant        entry                    external dcl 180 ref 666 1024 1077 1090
iox_$put_chars                  000134 constant        entry                    external dcl 179 ref 585 587 590 621 860 862 1085
                                                                                  1087
j                               000707 automatic       fixed bin(17,0)          dcl 798 in procedure "check_ul" set ref 806* 810 815
                                                                                  821* 827
j                               001045 automatic       fixed bin(21,0)          dcl 989 in procedure "print_long" set ref 1012* 1017
                                                                                  1017 1022 1024 1033 1044 1047 1054* 1054 1055*
j                               000610 automatic       fixed bin(24,0)          dcl 76 in procedure "cwl" set ref 249* 250 250 251
                                                                                  251 253 253 254 254*
j_contains_match                001050 automatic       bit(1)                   packed unaligned dcl 991 set ref 1049* 1052* 1054
k                               001046 automatic       fixed bin(21,0)          dcl 989 set ref 1046* 1047 1050*
key                       3     000720 automatic       char(256)                level 2 in structure "aki" packed packed unaligned
                                                                                  dcl 843 in procedure "output_word" set ref 867*
key                       3     001064 automatic       char(256)                level 2 in structure "gki" packed packed unaligned
                                                                                  dcl 1067 in procedure "copy_keyed_file" set ref
                                                                                  1085 1085
key_len                   2     000720 automatic       fixed bin(17,0)          level 2 in structure "aki" dcl 843 in procedure
                                                                                  "output_word" set ref 866*
key_len                   2     001064 automatic       fixed bin(17,0)          level 2 in structure "gki" dcl 1067 in procedure
                                                                                  "copy_keyed_file" set ref 1085
last                            000613 automatic       fixed bin(24,0)          dcl 76 set ref 464* 487* 587 587 587 587 637 638 640
                                                                                  695 926 927 928* 928
last_line_printed               001047 automatic       fixed bin(21,0)          dcl 990 set ref 1005* 1044 1055*
last_sort_string                       based           char                     packed unaligned dcl 1112 ref 1122
last_wordl                      001205 automatic       fixed bin(24,0)          dcl 1110 set ref 1116* 1122 1122 1127*
last_wordp                      001202 automatic       pointer                  dcl 1109 set ref 1122 1128*
ldcp                            000212 automatic       pointer                  initial dcl 44 set ref 44* 352* 353 684 686 959 962
                                                                                  963 1151 1151 1155 1156*
ldpp                            000210 automatic       pointer                  initial dcl 44 set ref 44* 351* 686 960 963 966 970
                                                                                  971 980 1007 1007 1010 1011 1017 1047 1149 1151
                                                                                  1154 1156*
length                                                 builtin function         dcl 148 ref 398 747 862 862 932 933 935 951 1087
                                                                                  1087
letters                         000004 constant        char(52)                 initial packed unaligned dcl 122 ref 852
line                            000614 automatic       fixed bin(24,0)          dcl 76 set ref 474* 496 498* 970 1010* 1012 1012
                                                                                  1017 1054
line_data                              based           structure                array level 1 dcl 94 set ref 963 1151
line_data_count                        based           fixed bin(17,0)          array dcl 93 set ref 352 353* 684* 686 959 962* 963
                                                                                  1151 1151 1155
line_data_incr                  012016 constant        fixed bin(17,0)          initial dcl 117 ref 956 962
line_data_kludge                       based           fixed bin(17,0)          array dcl 97 set ref 686*
line_data_mover                        based           fixed bin(71,0)          array dcl 98 set ref 966* 966 967
line_data_ptr                          based           pointer                  array dcl 92 set ref 351 686 960 963* 966 970 971
                                                                                  980 1007 1007 1010 1011 1017 1047 1151 1154
line_diff                       000612 automatic       fixed bin(24,0)          dcl 76 set ref 460* 601 603* 951* 951
line_index                1            based           fixed bin(24,0)          array level 2 dcl 94 set ref 971* 980* 1011
line_ix                         000572 automatic       fixed bin(21,0)          dcl 73 set ref 458* 483* 489 492 493 504 576 597*
                                                                                  597 925 975 1011* 1013 1039 1040 1041 1057* 1057
line_len                        000573 automatic       fixed bin(21,0)          dcl 73 set ref 492* 493 493* 501 506 513 514 515 519
                                                                                  521 524 525 597 601 1027* 1034 1035* 1040* 1041
                                                                                  1041* 1054 1054 1057
line_num                               based           fixed bin(17,0)          array level 2 dcl 94 set ref 970* 1007 1007 1010
                                                                                  1017 1047
line_ptr                        000562 automatic       pointer                  dcl 70 set ref 445* 471* 504* 506 510 514 524 556
                                                                                  590* 594* 620* 621* 1027* 1034 1039* 1054
lines                           000223 automatic       fixed bin(24,0)          initial dcl 49 set ref 49* 304* 308* 310* 315 331
                                                                                  336 338* 355 357 358 457 565 568 975 979 1012 1012
                                                                                  1054 1145
long_opt                        000232 automatic       bit(1)                   initial dcl 52 set ref 52* 274* 331 333* 336* 599
                                                                                  672 679 949 971
lw_cmd                          000240 automatic       bit(1)                   initial dcl 57 set ref 57* 190* 207 214 272 276 277
                                                                                  679 975 994
match_len                              based           fixed bin(17,0)          array dcl 86 set ref 219 246 251* 251 258* 343 343
                                                                                  670 670 674 674 676 676 681 681 686 686 911 914
                                                                                  994 994 1167
match_ptr                              based           pointer                  array dcl 87 set ref 220 246 250* 250 257* 343 670
                                                                                  674 676 681 686 911 914 994 1163
match_word                             based           char                     packed unaligned dcl 85 set ref 246 343* 670* 674*
                                                                                  676* 681* 686* 911 914 994*
max                                                    builtin function         dcl 148 ref 1012
max_line_len                    000155 automatic       fixed bin(21,0)          dcl 35 set ref 470* 471* 594* 620* 1027*
max_sort_entries                000620 automatic       fixed bin(24,0)          dcl 78 set ref 449* 882 884 884
mbz                       0(02) 000720 automatic       bit(34)                  initial level 3 packed packed unaligned dcl 843 set
                                                                                  ref 843*
min                                                    builtin function         dcl 148 ref 866
mlp                             000174 automatic       pointer                  initial dcl 41 set ref 41* 219* 246 251 251 258 343
                                                                                  343 670 670 674 674 676 676 681 681 686 686 911
                                                                                  914 994 994 1166 1167 1168*
mod                                                    builtin function         dcl 148 ref 568 696 956 979
mode                                   parameter       fixed bin(17,0)          dcl 1241 set ref 1236 1260*
mpp                             000172 automatic       pointer                  initial dcl 41 set ref 41* 220* 246 250 250 257 343
                                                                                  670 674 676 681 686 911 914 994 1162 1163 1164*
msf                             000167 automatic       bit(1)                   dcl 40 set ref 375* 376* 383 418 431 445 469 475 569
                                                                                  581 615 653 664 695 857 971 1013 1021 1182
n                               000676 automatic       fixed bin(24,0)          dcl 763 in procedure "strip_punc" set ref 765* 766
                                                                                  767 768 769* 770 775
n                               000611 automatic       fixed bin(24,0)          dcl 76 in procedure "cwl" set ref 540* 541 542 543
                                                                                  544* 545 545* 548 552 638* 639 640 640 641
n_args                          000225 automatic       fixed bin(17,0)          dcl 50 set ref 200* 201 207 209 214 216 230 304 714
n_words                         000226 automatic       fixed bin(17,0)          dcl 50 set ref 214* 216* 219 220 223 224 229* 246
                                                                                  249 259* 259 327 342 347 348 351 352 353 669 911
                                                                                  914 994 1150 1154 1155 1159 1163 1167 1171 1175
nmp                             000170 automatic       pointer                  initial dcl 41 set ref 41* 347* 348 670 670 674 676
                                                                                  676 681 684 685 917 917 956 970 971 980 999 1006
                                                                                  1017 1046 1050 1158 1159 1160*
no_control_opt                  000236 automatic       bit(1)                   initial dcl 56 set ref 56* 285* 506
no_exclude_opt                  000234 automatic       bit(1)                   initial dcl 54 set ref 54* 275* 852
no_sort_opt                     000230 automatic       bit(1)                   initial dcl 51 set ref 51* 271* 420 652 857 874 1185
null                                                   builtin function         dcl 148 ref 38 38 38 41 41 41 41 41 41 44 44 47 67
                                                                                  67 67 68 68 68 68 386 428 628 1144 1146 1149 1156
                                                                                  1158 1160 1162 1164 1166 1168 1170 1172 1174 1176
                                                                                  1179 1192 1195 1257 1257 1271
num                                    parameter       fixed bin(24,0)          dcl 723 set ref 721 727*
num_matches                            based           fixed bin(17,0)          array dcl 91 set ref 347 348* 670* 670 674 676* 676
                                                                                  681 684 685 917* 917 956 970 971 980 999 1006 1017
                                                                                  1046 1050 1159
old_count                       000216 automatic       fixed bin(17,0)          dcl 46 set ref 959* 960 962 964 966 967
old_ptr                         000214 automatic       pointer                  dcl 45 set ref 960* 966 967
output_cs                              based           char                     packed unaligned dcl 103 set ref 696* 876* 878*
                                                                                  1130* 1132*
output_dir                             parameter       char                     packed unaligned dcl 1208 ref 1202 1220
output_len                      000557 automatic       fixed bin(21,0)          dcl 69 set ref 462* 485* 645* 696 696 696 697 876
                                                                                  876 877* 877 878 878 879* 879 1130 1130 1131* 1131
                                                                                  1132 1132 1133* 1133
output_name                            parameter       char                     packed unaligned dcl 1209 ref 1202 1221
output_ptr                      000552 automatic       pointer                  initial dcl 68 set ref 68* 427* 428 643* 644 696
                                                                                  697* 876 878 1130 1132 1192 1194
output_record_number            000157 automatic       fixed bin(35,0)          dcl 37 set ref 467* 571 572* 572
output_words                    000615 automatic       fixed bin(24,0)          dcl 76 set ref 461* 650* 655* 658* 856* 856 882 888
                                                                                  889 1080* 1084* 1084 1118 1138*
outputp                         000162 automatic       pointer                  initial dcl 38 set ref 38* 419* 432* 585* 587* 590*
                                                                                  621* 627* 628* 635* 860* 862* 1085* 1087* 1184*
pathname_                       000116 constant        entry                    external dcl 172 ref 413 413 413 413 453 453 707 707
                                                                                  1188 1188
plip                            000220 automatic       pointer                  initial dcl 47 set ref 47* 357* 358 571 576 577 979
                                                                                  1144 1145 1146*
prev_line_ix                           based           fixed bin(24,0)          array dcl 99 set ref 357 358* 571* 576* 577* 979
                                                                                  1145
prevx                           000222 automatic       fixed bin(17,0)          dcl 48 set ref 457* 568* 568 571 576 577 979
release_temp_segments_          000110 constant        entry                    external dcl 169 ref 1179
rev_len                                based           fixed bin(17,0)          array dcl 89 set ref 223 254* 254 263* 932 932 933
                                                                                  935 936 937 945 951 997 997 1175
rev_line_ix                     000605 automatic       fixed bin(24,0)          dcl 75 set ref 459* 484* 577 602* 602 978
rev_line_len                    000606 automatic       fixed bin(24,0)          dcl 75 set ref 601* 602
rev_ptr                                based           pointer                  array dcl 90 set ref 224 253* 253 262* 932 932 933
                                                                                  935 936 937 945 951 997 1171
rev_word                               based           char                     packed unaligned dcl 88 set ref 932 932 933 935 936
                                                                                  937 945 951 997*
reverse                                                builtin function         dcl 148 ref 769
rk_header                              based           structure                level 1 unaligned dcl 3-26
rlp                             000176 automatic       pointer                  initial dcl 41 set ref 41* 223* 254 254 263 932 932
                                                                                  933 935 936 937 945 951 997 997 1174 1175 1176*
rpp                             000200 automatic       pointer                  initial dcl 41 set ref 41* 224* 253 253 262 932 932
                                                                                  933 935 936 937 945 951 997 1170 1171 1172*
rtrim                                                  builtin function         dcl 148 ref 398 1250 1252
rw_cmd                          000241 automatic       bit(1)                   initial dcl 57 set ref 57* 197* 209 221 252 260 431
                                                                                  451 569 576 583 599 608 672 695 920
search                                                 builtin function         dcl 148 ref 524 739 852
sort_data                              based           structure                array level 1 dcl 110 set ref 882 884 884
sort_data_ptr                   000554 automatic       pointer                  initial dcl 68 set ref 68* 448* 655* 882 884 884 888
                                                                                  889 1119 1120
sort_dir                        000425 automatic       char(168)                packed unaligned dcl 63 set ref 422* 433* 1075 1187*
                                                                                  1188* 1188*
sort_name                       000271 automatic       char(32)                 packed unaligned dcl 62 set ref 423* 434* 1076 1187*
                                                                                  1188* 1188*
sort_string                            based           char                     packed unaligned dcl 1111 ref 1122 1130
sortp                           000164 automatic       pointer                  initial dcl 38 set ref 38* 421* 868* 1077* 1082*
                                                                                  1090* 1091* 1186*
source_dir               12     001216 automatic       char(168)                level 2 packed packed unaligned dcl 1212 set ref
                                                                                  1218*
source_name              64     001216 automatic       char(32)                 level 2 packed packed unaligned dcl 1212 set ref
                                                                                  1219*
strip_cs                               based           char(1048576)            packed unaligned dcl 106 ref 765 769 777 783 802 808
                                                                                  810 813 815 818 852 867 876 911 914
strip_ix                        000577 automatic       fixed bin(24,0)          dcl 74 set ref 529* 547* 746* 765 767 771 777 783
strip_len                       000600 automatic       fixed bin(24,0)          dcl 74 set ref 530* 548* 747* 749 765 768 772 783
strip_ptr                       000564 automatic       pointer                  dcl 71 set ref 510* 537* 556* 745* 765 769 777 783
                                                                                  802 808 810 813 815 818 852 860 860 867 876 888
                                                                                  911 914
strip_vec                              based           char(1)                  array packed unaligned dcl 107 set ref 860 860 888
substr                                                 builtin function         dcl 148 set ref 403* 492 506 514 524 540 544 640*
                                                                                  640 644* 644 696* 765 769 777 783 802 808 810* 810
                                                                                  813 815* 815 818 821* 852 867 876* 876 878* 911
                                                                                  914 927* 927 932* 936 937* 937 939* 943* 945* 945
                                                                                  1040 1130* 1132*
switchname                      001505 automatic       varying char(32)         dcl 1243 set ref 1254* 1255* 1255 1257
sys_info$max_seg_size           000044 external static fixed bin(24,0)          dcl 138 ref 449 470
system_area                            based           area(65536)              dcl 83 ref 219 220 223 224 347 351 352 357 963 967
                                                                                  1145 1151 1154 1155 1159 1163 1167 1171 1175
system_area_ptr                 000202 automatic       pointer                  initial dcl 41 set ref 41* 218* 219 220 223 224 347
                                                                                  351 352 357 963 967 1145 1151 1154 1155 1159 1163
                                                                                  1167 1171 1175
target_dir               74     001216 automatic       char(168)                level 2 packed packed unaligned dcl 1212 set ref
                                                                                  1220*
target_err_switch       156(04) 001216 automatic       bit(1)                   level 3 packed packed unaligned dcl 1212 set ref
                                                                                  1230
target_name             146     001216 automatic       char(32)                 level 2 packed packed unaligned dcl 1212 set ref
                                                                                  1221*
temp_cs                                based           char                     packed unaligned dcl 104 set ref 640* 644* 644 927*
                                                                                  932* 937* 939* 943* 945*
temp_dir                        000100 automatic       char(168)                packed unaligned dcl 32 set ref 228* 279* 1246
temp_len                        000560 automatic       fixed bin(21,0)          dcl 69 set ref 463* 486* 584 585* 640 640 641* 641
                                                                                  644 644 644 644 645 927 927 929* 929 932 932 933*
                                                                                  933 937 937 938* 938 939 939 940* 940 943 943 944*
                                                                                  944 945 945 946* 946
temp_ptr                        000550 automatic       pointer                  initial dcl 68 set ref 68* 451* 585* 640 644 927 932
                                                                                  937 939 943 945
temp_ptr_array                  000540 automatic       pointer                  initial array dcl 67 set ref 67* 67* 67* 437* 444
                                                                                  445 448 451 1179 1179*
terminate_file_                 000064 constant        entry                    external dcl 160 ref 697 1195
to_line                         000566 automatic       fixed bin(24,0)          initial dcl 72 set ref 72* 298* 299 498 498
token_ix                        000575 automatic       fixed bin(24,0)          dcl 74 set ref 518* 519 521 524 525 529 563
token_len                       000576 automatic       fixed bin(24,0)          dcl 74 set ref 521* 524* 525 525* 530 563
type                            000166 automatic       fixed bin(2,0)           dcl 39 set ref 366* 369
uid_in                          000152 automatic       bit(36)                  dcl 33 set ref 395* 412
uid_out                         000153 automatic       bit(36)                  dcl 33 set ref 407* 412
ul_cs                                  based           char                     packed unaligned dcl 108 set ref 540 544 810* 815*
                                                                                  821*
ul_ix                           000603 automatic       fixed bin(24,0)          dcl 74 set ref 535* 922
ul_len                          000604 automatic       fixed bin(24,0)          dcl 74 set ref 539 540 544 545 554 810 815 821 827*
ul_ptr                          000616 automatic       pointer                  dcl 77 set ref 444* 537 540 544 554* 554 810 815 821
ul_spaces                       000574 automatic       fixed bin(21,0)          dcl 73 set ref 536* 543* 543 922 922
ul_sw                           000244 automatic       bit(1)                   dcl 60 set ref 534 752 801* 826* 921 931
ul_vec                                 based           char(1)                  array packed unaligned dcl 109 set ref 554
unique_chars_                   000112 constant        entry                    external dcl 170 ref 1248 1254
unique_words                    001177 automatic       fixed bin(24,0)          dcl 1108 set ref 1115* 1125* 1125 1138
unspec                                                 builtin function         dcl 148 set ref 1073* 1222* 1226*
update                  157(09) 001216 automatic       bit(1)                   level 3 packed packed unaligned dcl 1212 set ref
                                                                                  1227*
verify                                                 builtin function         dcl 148 ref 514 540 765 769
version                         001216 automatic       char(8)                  level 2 packed packed unaligned dcl 1212 set ref
                                                                                  1216*
whoami                          000245 automatic       char(16)                 packed unaligned dcl 61 set ref 184* 191* 198* 204*
                                                                                  204* 236* 281* 292* 317* 322* 333* 400* 413* 437*
                                                                                  440* 707* 741* 884* 1179* 1187* 1188* 1217 1248
                                                                                  1255
word                                   parameter       char                     packed unaligned dcl 733 set ref 731 739 741* 745
                                                                                  747
word_ix                         000601 automatic       fixed bin(24,0)          dcl 74 set ref 535 749 767* 769 771* 777 777 780*
                                                                                  780 783 783 802 804 805 852 860 860 867 876 888
                                                                                  911 914 922* 922 925* 925 926
word_len                        000602 automatic       fixed bin(24,0)          dcl 74 set ref 749 768* 769 772* 775* 775 776 781*
                                                                                  781 783 783 783* 783 802 805 852 860 866 867 876
                                                                                  876 877 889 911 914 923* 923 928 951
wordl                           001204 automatic       fixed bin(24,0)          dcl 1110 in procedure "copy_sorted_words" set ref
                                                                                  1120* 1122 1122 1127 1130 1130 1131
wordl                     1            based           fixed bin(24,0)          array level 2 in structure "sort_data" dcl 110
                                                                                  in procedure "cwl" set ref 889* 1120
wordp                                  based           pointer                  array level 2 in structure "sort_data" packed packed
                                                                                  unaligned dcl 110 in procedure "cwl" set ref 888*
                                                                                  1119
wordp                           001200 automatic       pointer                  dcl 1109 in procedure "copy_sorted_words" set ref
                                                                                  1119* 1122 1128 1130
wordx                           000227 automatic       fixed bin(17,0)          dcl 50 set ref 246* 246 246* 249 257 258 262 263
                                                                                  342* 343 343 343* 669* 670 670 670 670 670 674 674
                                                                                  674 674 676 676 676 676 676 681 681 681 681 684
                                                                                  684 685 686 686 686 686 686* 911* 911 911* 914 914
                                                                                  914 917 917 932 932 932 932 933 933 935 935 936
                                                                                  936 937 937 945 945 951 951 956 959 960 962 963
                                                                                  963 966 970 970 971 971 980 980 994 994 994 997
                                                                                  997 997 999 1006 1007 1007 1010 1011 1017 1017
                                                                                  1046 1047 1050 1150* 1151 1151 1151*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 4-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 4-33
Direct_input                           internal static fixed bin(17,0)          initial dcl 6-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 6-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 6-15
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 4-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 6-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 6-15
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 4-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 4-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 4-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 4-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 4-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 4-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 4-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 4-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 4-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 4-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 4-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 4-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 4-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 4-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 4-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 4-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
Sequential_input                       internal static fixed bin(17,0)          initial dcl 6-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 6-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 6-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 6-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 6-15
TERM_FILE_BC                           internal static bit(2)                   initial packed unaligned dcl 5-12
TERM_FILE_DELETE                       internal static bit(5)                   initial packed unaligned dcl 5-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial packed unaligned dcl 5-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial packed unaligned dcl 5-11
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial packed unaligned dcl 5-15
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 4-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
ak_info                                based           structure                level 1 unaligned dcl 3-6
ak_info_ptr                            automatic       pointer                  dcl 3-18
ak_key_len                             automatic       fixed bin(17,0)          dcl 3-19
buffer                                 automatic       char(1024)               packed unaligned dcl 1210
copy_options_ptr                       automatic       pointer                  dcl 1-10
gk_info                                based           structure                level 1 unaligned dcl 3-41
gk_info_ptr                            automatic       pointer                  dcl 3-63
gk_info_version_0                      internal static fixed bin(17,0)          initial dcl 3-66
gk_key_len                             automatic       fixed bin(17,0)          dcl 3-64
iox_modes                              internal static char(24)                 initial array dcl 6-6
rk_info                                based           structure                level 1 unaligned dcl 3-22
rk_info_ptr                            automatic       pointer                  dcl 3-37
rk_key_len                             automatic       fixed bin(17,0)          dcl 3-38
short_iox_modes                        internal static char(4)                  initial array dcl 6-12
temp_vec                               based           char(1)                  array packed unaligned dcl 105
terminate_file_switches                based           structure                level 1 packed packed unaligned dcl 5-4

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_line                        001622 constant        label                    dcl 292 ref 299
bad_word                        005113 constant        label                    dcl 741 ref 749 752
check_single_ul                 005365 constant        label                    dcl 818 ref 807
check_ul                        005277 constant        entry                    internal dcl 790 ref 532 751
cleaner                         007305 constant        entry                    internal dcl 1142 ref 217 361 701
close_file                      010401 constant        entry                    internal dcl 1266 ref 627 635 1183 1184 1186
copy_keyed_file                 006775 constant        entry                    internal dcl 1064 ref 653
copy_sorted_words               007226 constant        entry                    internal dcl 1101 ref 656
copy_temp_file                  007730 constant        entry                    internal dcl 1202 ref 630
create_wordlist                 000610 constant        entry                    external dcl 21
cwl                             000600 constant        entry                    external dcl 21
end_of_data                     003761 constant        label                    dcl 608 ref 475 489 498
end_of_ul                       003544 constant        label                    dcl 554 ref 541
err_exit                        004741 constant        entry                    internal dcl 704 ref 367 373 386 390 396 408 428 481
                                                                                  586 591 624 633 698 861 863 872 1025 1031 1078
                                                                                  1086 1088 1096 1230 1258 1261
exit                            004740 constant        label                    dcl 702
finish                          004734 constant        label                    dcl 701 ref 401 415 441 708 885
insert_word                     001234 constant        label                    dcl 246 ref 269
join                            000706 constant        label                    dcl 200 ref 186 193
locate_words                    000640 constant        entry                    external dcl 188
lw                              000630 constant        entry                    external dcl 188
msf_read                        003257 constant        label                    dcl 483 ref 479
next_arg                        005012 constant        entry                    internal dcl 711 ref 261 268 278 726
next_arg_num                    005035 constant        entry                    internal dcl 721 ref 289 298
next_line                       003566 constant        label                    dcl 565 ref 496 501 506 519
next_line_num                   006772 constant        label                    dcl 1059 ref 1007 1013 1017 1028
next_token                      003562 constant        label                    dcl 563
next_word                       007277 constant        label                    dcl 1135 ref 1122
no_strip                        005236 constant        label                    dcl 771 ref 766
noarg                           000722 constant        label                    dcl 203 ref 207 209 327 714
open_file                       010040 constant        entry                    internal dcl 1236 ref 383 419 421 432
output_word                     005413 constant        entry                    internal dcl 832 ref 550 559
print_long                      006277 constant        entry                    internal dcl 987 ref 690
revise_words                    000670 constant        entry                    external dcl 195
rw                              000660 constant        entry                    external dcl 195
save_line_number                006143 constant        label                    dcl 956 ref 952
strip_punc                      005176 constant        entry                    internal dcl 756 ref 531 549 748
test_word                       005702 constant        entry                    internal dcl 895 ref 551 561
usage                           000725 constant        label                    dcl 204 ref 243
validate_word                   005066 constant        entry                    internal dcl 731 ref 343

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     12610       12754   12027       12620
Length     13426   12027       144         436     561           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cwl                                1324 external procedure  is an external procedure.  
on unit on line 217                  64 on unit               
on unit on line 361                  64 on unit               
err_exit                                internal procedure  shares stack frame of external procedure cwl.  
next_arg                                internal procedure  shares stack frame of external procedure cwl.  
next_arg_num                            internal procedure  shares stack frame of external procedure cwl.  
validate_word                           internal procedure  shares stack frame of external procedure cwl.  
strip_punc                              internal procedure  shares stack frame of external procedure cwl.  
check_ul                                internal procedure  shares stack frame of external procedure cwl.  
output_word                             internal procedure  shares stack frame of external procedure cwl.  
test_word                               internal procedure  shares stack frame of external procedure cwl.  
print_long                              internal procedure  shares stack frame of external procedure cwl.  
copy_keyed_file                         internal procedure  shares stack frame of external procedure cwl.  
copy_sorted_words                       internal procedure  shares stack frame of external procedure cwl.  
cleaner                             150 internal procedure  is called by several nonquick procedures.  
copy_temp_file                          internal procedure  shares stack frame of external procedure cwl.  
open_file                               internal procedure  shares stack frame of external procedure cwl.  
close_file                           72 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 NL                          cwl

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cwl                      000100 temp_dir                    cwl
                         000152 uid_in                      cwl
                         000153 uid_out                     cwl
                         000154 current_record              cwl
                         000155 max_line_len                cwl
                         000156 changed_lines               cwl
                         000157 output_record_number        cwl
                         000160 inputp                      cwl
                         000162 outputp                     cwl
                         000164 sortp                       cwl
                         000166 type                        cwl
                         000167 msf                         cwl
                         000170 nmp                         cwl
                         000172 mpp                         cwl
                         000174 mlp                         cwl
                         000176 rlp                         cwl
                         000200 rpp                         cwl
                         000202 system_area_ptr             cwl
                         000204 ap                          cwl
                         000206 al                          cwl
                         000210 ldpp                        cwl
                         000212 ldcp                        cwl
                         000214 old_ptr                     cwl
                         000216 old_count                   cwl
                         000220 plip                        cwl
                         000222 prevx                       cwl
                         000223 lines                       cwl
                         000224 argno                       cwl
                         000225 n_args                      cwl
                         000226 n_words                     cwl
                         000227 wordx                       cwl
                         000230 no_sort_opt                 cwl
                         000231 brief_opt                   cwl
                         000232 long_opt                    cwl
                         000233 header_opt                  cwl
                         000234 no_exclude_opt              cwl
                         000235 count_opt                   cwl
                         000236 no_control_opt              cwl
                         000237 cwl_cmd                     cwl
                         000240 lw_cmd                      cwl
                         000241 rw_cmd                      cwl
                         000242 got_pname                   cwl
                         000243 invalid_sw                  cwl
                         000244 ul_sw                       cwl
                         000245 whoami                      cwl
                         000251 ename                       cwl
                         000261 input_ename                 cwl
                         000271 sort_name                   cwl
                         000301 dname                       cwl
                         000353 input_dname                 cwl
                         000425 sort_dir                    cwl
                         000477 arg_syntax                  cwl
                         000535 code                        cwl
                         000536 bc                          cwl
                         000540 temp_ptr_array              cwl
                         000546 input_ptr                   cwl
                         000550 temp_ptr                    cwl
                         000552 output_ptr                  cwl
                         000554 sort_data_ptr               cwl
                         000556 input_len                   cwl
                         000557 output_len                  cwl
                         000560 temp_len                    cwl
                         000562 line_ptr                    cwl
                         000564 strip_ptr                   cwl
                         000566 to_line                     cwl
                         000567 from_line                   cwl
                         000570 delim_ix                    cwl
                         000571 delim_len                   cwl
                         000572 line_ix                     cwl
                         000573 line_len                    cwl
                         000574 ul_spaces                   cwl
                         000575 token_ix                    cwl
                         000576 token_len                   cwl
                         000577 strip_ix                    cwl
                         000600 strip_len                   cwl
                         000601 word_ix                     cwl
                         000602 word_len                    cwl
                         000603 ul_ix                       cwl
                         000604 ul_len                      cwl
                         000605 rev_line_ix                 cwl
                         000606 rev_line_len                cwl
                         000607 i                           cwl
                         000610 j                           cwl
                         000611 n                           cwl
                         000612 line_diff                   cwl
                         000613 last                        cwl
                         000614 line                        cwl
                         000615 output_words                cwl
                         000616 ul_ptr                      cwl
                         000620 max_sort_entries            cwl
                         000676 n                           strip_punc
                         000706 i                           check_ul
                         000707 j                           check_ul
                         000710 end_word_ix                 check_ul
                         000720 aki                         output_word
                         001032 cc                          test_word
                         001033 i                           test_word
                         001044 i                           print_long
                         001045 j                           print_long
                         001046 k                           print_long
                         001047 last_line_printed           print_long
                         001050 j_contains_match            print_long
                         001051 NL_index                    print_long
                         001064 gki                         copy_keyed_file
                         001176 i                           copy_sorted_words
                         001177 unique_words                copy_sorted_words
                         001200 wordp                       copy_sorted_words
                         001202 last_wordp                  copy_sorted_words
                         001204 wordl                       copy_sorted_words
                         001205 last_wordl                  copy_sorted_words
                         001216 co                          copy_temp_file
                         001404 atd                         open_file
                         001505 switchname                  open_file

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars   call_ext_out_desc
call_ext_out        call_int_this       call_int_other      return_mac          mdfx1               enable_op
shorten_stack       ext_entry           int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            alphabetize_strings_          com_err_                      copy_
cu_$arg_count                 cu_$arg_ptr                   cv_dec_check_                 delete_$path
expand_pathname_              get_pdir_                     get_system_free_area_         get_temp_segments_
get_wdir_                     hcs_$get_uid_file             hcs_$make_seg                 hcs_$status_minf
initiate_file_                ioa_                          iox_$attach_name              iox_$close
iox_$control                  iox_$destroy_iocb             iox_$detach_iocb              iox_$get_line
iox_$open                     iox_$position                 iox_$put_chars                pathname_
release_temp_segments_        terminate_file_               unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$dirseg           error_table_$end_of_info      error_table_$entlong
error_table_$inconsistent     error_table_$key_duplication  error_table_$no_key           error_table_$no_record
error_table_$noarg            error_table_$noentry          error_table_$short_record     error_table_$wrong_no_of_args
error_table_$zero_length_seg  sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     38 000512        41 000516        44 000524        47 000526        49 000527        51 000531        52 000532
     53 000534        54 000535        55 000536        56 000537        57 000540        58 000543        67 000544
     68 000567        72 000573        21 000577       183 000616       184 000620       185 000623       186 000626
    188 000627       190 000646       191 000650       192 000653       193 000656       195 000657       197 000676
    198 000700       199 000703       200 000706       201 000715       203 000722       204 000725       205 000763
    207 000764       209 000771       212 000776       214 001000       216 001005       217 001010       218 001032
    219 001041       220 001046       221 001054       223 001056       224 001063       228 001071       229 001100
    230 001101       231 001111       232 001126       233 001142       234 001144       235 001174       236 001176
    237 001222       239 001223       240 001225       241 001226       242 001230       243 001233       246 001234
    247 001257       249 001261       250 001271       251 001275       252 001302       253 001304       254 001310
    256 001313       257 001316       258 001323       259 001327       260 001330       261 001332       262 001333
    263 001340       266 001344       267 001345       268 001351       269 001352       271 001353       272 001370
    273 001407       274 001422       275 001441       276 001456       277 001473       278 001505       279 001506
    280 001532       281 001534       282 001566       284 001567       285 001570       287 001603       289 001613
    290 001615       292 001622       293 001661       295 001662       296 001663       298 001667       299 001671
    301 001676       302 001677       304 001711       306 001717       307 001720       308 001735       309 001761
    310 001763       311 001764       312 001765       315 001767       317 001771       318 002030       320 002031
    322 002032       323 002064       325 002065       327 002067       331 002100       333 002113       334 002146
    336 002147       338 002155       340 002156       341 002160       342 002161       343 002171       344 002210
    345 002212       347 002214       348 002221       349 002233       351 002236       352 002244       353 002251
    355 002263       357 002265       358 002272       360 002306       361 002307       363 002331       364 002334
    366 002337       367 002376       369 002401       372 002406       373 002411       374 002412       375 002413
    376 002416       383 002417       385 002425       386 002462       387 002467       388 002472       389 002473
    390 002476       394 002477       395 002501       396 002526       398 002531       399 002543       400 002545
    401 002574       403 002575       405 002600       407 002607       408 002634       412 002642       413 002645
    415 002741       418 002742       419 002744       420 002747       421 002751       422 002754       423 002757
    425 002762       427 002763       428 003022       430 003027       431 003030       432 003034       433 003037
    434 003042       437 003045       438 003066       440 003070       441 003114       444 003115       445 003117
    448 003125       449 003127       451 003133       453 003137       457 003200       458 003203       459 003205
    460 003207       461 003210       462 003211       463 003212       464 003213       466 003214       467 003215
    469 003216       470 003220       471 003224       474 003242       475 003244       479 003253       481 003255
    483 003257       484 003261       485 003263       486 003264       487 003265       488 003266       489 003267
    492 003272       493 003312       496 003320       498 003323       501 003327       504 003331       506 003335
    510 003343       511 003344       513 003346       514 003351       515 003370       518 003376       519 003400
    521 003402       524 003406       525 003423       529 003430       530 003432       531 003434       532 003435
    534 003436       535 003440       536 003442       537 003443       538 003445       539 003447       540 003453
    541 003473       542 003474       543 003477       544 003503       545 003521       547 003527       548 003531
    549 003533       550 003534       551 003540       552 003541       553 003543       554 003544       556 003552
    557 003554       559 003555       561 003561       563 003562       564 003565       565 003566       568 003570
    569 003575       571 003601       572 003604       573 003610       576 003611       577 003617       581 003622
    583 003624       584 003626       585 003630       586 003645       587 003650       589 003676       590 003677
    591 003714       594 003717       595 003736       597 003737       599 003743       601 003750       602 003753
    603 003756       606 003757       608 003761       615 003763       616 003765       618 003767       619 003770
    620 003772       621 004011       623 004033       624 004034       626 004040       627 004051       628 004057
    630 004061       632 004073       633 004114       634 004117       635 004120       636 004126       637 004127
    638 004131       639 004134       640 004135       641 004147       643 004151       644 004153       645 004161
    649 004164       650 004166       652 004210       653 004212       655 004216       656 004227       658 004230
    661 004252       664 004253       665 004255       666 004257       669 004277       670 004307       672 004365
    674 004374       676 004433       678 004505       679 004506       681 004512       684 004547       685 004551
    686 004561       687 004647       689 004652       690 004653       691 004654       695 004656       696 004666
    697 004701       698 004731       701 004734       702 004740       704 004741       707 004742       708 005011
    711 005012       713 005013       714 005014       717 005017       719 005034       721 005035       726 005037
    727 005040       729 005065       731 005066       739 005077       741 005113       742 005146       743 005150
    745 005151       746 005153       747 005155       748 005163       749 005164       751 005172       752 005173
    754 005175       756 005176       765 005177       766 005213       767 005215       768 005217       769 005222
    770 005234       771 005236       772 005240       773 005242       775 005243       776 005245       777 005250
    780 005257       781 005261       783 005262       788 005276       790 005277       801 005300       802 005301
    804 005315       805 005317       806 005322       807 005327       808 005332       810 005340       811 005346
    812 005350       813 005351       815 005355       816 005362       817 005364       818 005365       821 005373
    822 005400       823 005401       824 005402       825 005403       826 005405       827 005407       830 005412
    832 005413       843 005414       852 005423       856 005443       857 005444       860 005450       861 005475
    862 005500       863 005521       864 005524       866 005525       867 005532       868 005540       869 005570
    872 005576       873 005577       874 005600       876 005602       877 005615       878 005617       879 005624
    880 005625       882 005626       884 005631       885 005663       888 005664       889 005675       890 005700
    892 005701       895 005702       911 005703       912 005730       914 005732       917 005753       918 005756
    920 005762       921 005764       922 005766       923 005777       925 006002       926 006006       927 006011
    928 006023       929 006026       930 006030       931 006032       932 006034       933 006045       934 006047
    935 006050       936 006061       937 006075       938 006102       939 006103       940 006107       941 006111
    943 006112       944 006117       945 006121       946 006125       948 006126       949 006130       951 006133
    952 006141       954 006142       956 006143       959 006152       960 006155       962 006163       963 006166
    964 006203       966 006205       967 006221       970 006223       971 006237       975 006251       978 006260
    979 006263       980 006271       985 006276       987 006277       994 006300       997 006335       999 006364
   1001 006370      1002 006403      1005 006404      1006 006405      1007 006413      1010 006430      1011 006442
   1012 006444      1013 006461      1017 006466      1021 006510      1022 006512      1024 006515      1025 006535
   1027 006543      1028 006562      1031 006567      1033 006570      1034 006573      1035 006607      1037 006612
   1039 006613      1040 006621      1041 006641      1044 006647      1046 006652      1047 006663      1049 006675
   1050 006677      1051 006703      1052 006704      1053 006705      1054 006707      1055 006762      1057 006764
   1058 006770      1059 006772      1062 006774      1064 006775      1073 006776      1075 007001      1076 007004
   1077 007007      1078 007027      1080 007032      1081 007034      1082 007036      1083 007066      1084 007070
   1085 007071      1086 007112      1087 007115      1088 007136      1090 007141      1091 007161      1093 007213
   1094 007214      1096 007224      1098 007225      1101 007226      1115 007227      1116 007230      1118 007231
   1119 007241      1120 007245      1122 007250      1125 007260      1127 007261      1128 007262      1130 007263
   1131 007270      1132 007271      1133 007276      1135 007277      1138 007301      1140 007303      1142 007304
   1144 007312      1145 007317      1146 007322      1149 007325      1150 007331      1151 007342      1153 007354
   1154 007357      1155 007363      1156 007366      1158 007372      1159 007377      1160 007401      1162 007404
   1163 007410      1164 007414      1166 007417      1167 007423      1168 007425      1170 007430      1171 007434
   1172 007440      1174 007443      1175 007447      1176 007451      1179 007454      1182 007501      1183 007504
   1184 007513      1185 007523      1186 007530      1187 007537      1188 007573      1190 007650      1192 007651
   1194 007657      1195 007663      1196 007717      1199 007727      1202 007730      1216 007760      1217 007762
   1218 007765      1219 007773      1220 010000      1221 010005      1222 010012      1223 010013      1224 010015
   1226 010017      1227 010020      1229 010022      1230 010033      1233 010037      1236 010040      1245 010056
   1246 010064      1247 010073      1248 010077      1250 010142      1251 010175      1252 010205      1254 010231
   1255 010262      1257 010275      1258 010350      1260 010354      1261 010374      1263 010377      1266 010400
   1271 010406      1272 010413      1273 010424      1274 010437      1277 010452


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
