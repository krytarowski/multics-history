	COMPILATION LISTING OF SEGMENT hasp_workstation_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/17/88  1038.0 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: off */
       13 
       14 /* I/O Module for communications with a HASP workstation: This I/O module is designed for use by the I/O daemon's RJE
       15*   software (remote_driver_).  It communicates with the HASP workstation through a TTY channel controlled by the ring-0
       16*   HASP demultiplexer.
       17*
       18*   As each TTY channel connected through the HASP demultiplexer communicates with only a single device of the physical
       19*   HASP workstation, this I/O module will ensure that all I/O switches attached to a given channel have the same device
       20*   type.  (Multiple I/O switches are allowed to support multiple request types being attached to the same channel.) */
       21 
       22 /* Created:  January 1980 by G. Palter */
       23 /* Modified: 1 September 1980 by G. Palter to remove stream mode support */
       24 /* Modified: 2 December 1980 by G. Palter to properly set return code for io_call control order */
       25 /* Modified: 18 December 1980 by G. Palter to support -terminal_type for input/output translations */
       26 /* Modified: 13 January 1981 by G. Palter to pass the representation of a space in the transmission medium's character
       27*      code to hasp_util_ */
       28 /* Modified: 22 July 1981 by G. Palter to convert to version 2 dial_manager_ and invoke release_channel when done with a
       29*      particular channel */
       30 /* Modified: 25 December 1981 by G. Palter to support set_forms control order */
       31 /* Modified: 26 July 1982 by G. Palter to add get_channel_info control order */
       32 /* Modified: October 1982 by G. Palter to drastically improve write_record performance by changing the order of calls to
       33*      hcs_$tty_order, hcs_$tty_write, and ipc_$block and to use mvt_ rather than the PL/I translate builtin where
       34*      appropriate */
       35 /* Modified: 14 December 1982 by G. Palter to support "s0" as a valid carriage control sequence (HASP #008), to fix bugs
       36*      in the read_record entrypoint's handling of partial or very long input records (HASP #001 and HASP #002), and to
       37*      insure proper behavior of the read_record entrypoint when the input record will not fit in the caller's buffer */
       38 /* Modified: 12 February 1985 by Jim Homan to support HASP operator consoles as message coordinator consoles:
       39*      add read_record_timeout, write_record_timeout, set_event_channel and set_term_type control orders;
       40*      add -suppress_dial_manager control arg.
       41*      Also removed calls to convert_ipc_code_, changed substraddr to addcharno,
       42*      created timer_manager_constants include file. */
       43 
       44 /****^  HISTORY COMMENTS:
       45*  1) change(87-03-17,LJAdams), approve(87-04-03,MCR7646),
       46*     audit(87-05-05,Gilcrease), install(87-05-14,MR12.1-1030):
       47*     Changed ttd_version to ttd_version_3.
       48*  2) change(87-04-03,Beattie), approve(87-04-06,MCR7656),
       49*     audit(87-07-30,Parisek), install(87-08-03,MR12.1-1055):
       50*     Add support for control orders necessary to use operator subchannel on
       51*     HASP workstation multiplexer as login channels.
       52*                                                   END HISTORY COMMENTS */
       53 
       54 /* format: on,style4,delnl,insnl,ifthenstmt,ifthen */
       55 
       56 
       57 hasp_workstation_:
       58      procedure ();
       59 
       60 	return;					/* not an entry */
       61 
       62 
       63 /* Parameters */
       64 
       65 dcl  P_iocb_ptr pointer parameter;			/* *: -> I/O switch being operated upon */
       66 dcl  P_code fixed binary (35) parameter;
       67 
       68 dcl  P_attach_options (*) character (*) varying parameter;	/* attach: attachment arguments */
       69 dcl  P_loud_sw bit (1) parameter;			/* attach: ON => attachment errors should call com_err_ */
       70 
       71 dcl  P_open_mode fixed binary parameter;		/* open: opening mode */
       72 dcl  P_open_sw bit (1) parameter;			/* open: obsolete parameter */
       73 
       74 dcl  P_record_lth fixed binary (21) parameter;		/* read_record: set to size of terminal_io_record read into
       75*						   buffer in characters;
       76*						   get_chars: set to # of characters read into buffer;
       77*						   write_record, put_chars: size of terminal_io_record to be
       78*						   written in characters */
       79 
       80 dcl  P_buffer_ptr pointer parameter;			/* read_record, get_chars: -> area to place result of read */
       81 dcl  P_buffer_lth fixed binary (21) parameter;		/* read_record, get_chars: size of area in characters */
       82 
       83 dcl  P_record_ptr pointer parameter;			/* write_record, put_chars: -> terminal_io_record
       84*						   to be written */
       85 
       86 dcl  P_order character (*) parameter;			/* control: name of control order to be performed */
       87 dcl  P_info_ptr pointer parameter;			/* control: -> additional information required to execute the
       88*						   control order */
       89 
       90 dcl  P_new_modes character (*) parameter;		/* modes: new modes to be set */
       91 dcl  P_old_modes character (*) parameter;		/* modes: set to modes in effect before change */
       92 dcl  P_timeout fixed bin (71) parameter;		/* read_record_timed: */
       93 dcl  P_chars_sent fixed bin (21) parameter;		/* write_record_timed: */
       94 
       95 /* Local copies of parameters */
       96 
       97 dcl  iocb_ptr pointer;
       98 dcl  code fixed binary (35);
       99 
      100 dcl  temp_state fixed bin;
      101 dcl  based_state fixed bin based;
      102 
      103 dcl  argument character (argument_lth) based (argument_ptr);/* based on attach options */
      104 dcl  argument_lth fixed binary (21);
      105 dcl  argument_ptr pointer;
      106 
      107 dcl  loud_sw bit (1) aligned;
      108 
      109 dcl  open_mode fixed binary;
      110 
      111 dcl  order character (32);
      112 dcl  info_ptr pointer;
      113 
      114 
      115 /* Remaining declarations */
      116 
      117 dcl  event_channel fixed bin (71) based;
      118 
      119 dcl  system_area area aligned based (system_area_ptr);
      120 dcl  system_area_ptr pointer;
      121 
      122 dcl  argument_idx fixed binary;			/* # of attach option being processed */
      123 
      124 dcl  (tty_channel, device_name) character (32);		/* required components of attach description */
      125 dcl  have_comm bit (1) aligned;			/* ON => -comm option given (required) */
      126 dcl  terminal_type character (32);			/* terminal type specifying translations (optional) */
      127 dcl  block_on_io_sw bit (1) aligned;			/* OFF => -no_block given */
      128 dcl  suppress_dial_manager_sw bit (1) aligned;		/* ON => -suppress_dial_manager given */
      129 dcl  other_attach_options character (256) varying;	/* optional portions supplied by caller */
      130 dcl  timeout fixed bin (71);
      131 dcl  stop_time fixed bin (71);
      132 
      133 dcl  device_type fixed binary;			/* local copy used for argument processing */
      134 dcl  idx fixed binary;
      135 
      136 dcl  character_value character (32);			/* unused values from argument processing */
      137 dcl  numeric_value fixed binary (35);
      138 
      139 dcl  1 ttd aligned like terminal_type_data;		/* used to call ttt_info_$terminal_data */
      140 
      141 dcl  1 dma aligned like dial_manager_arg;		/* used to attach the channel */
      142 
      143 dcl  1 local_event_wait_info aligned like event_wait_info;	/* for calls to ipc_$block */
      144 
      145 dcl  dialup_msg_channel character (32);			/* arguments to convert_dial_message_ */
      146 dcl  1 dialup_msg_flags aligned,
      147        2 dialed_up bit (1) unaligned,
      148        2 hungup bit (1) unaligned,
      149        2 control bit (1) unaligned,
      150        2 pad bit (33) unaligned;
      151 
      152 dcl  state fixed binary;				/* MCS channel state value */
      153 
      154 dcl  multiplexer_device_type fixed binary;		/* for "get_device_type" control order */
      155 
      156 dcl  1 tty_modes aligned,				/* used to change MCS modes */
      157        2 modes_lth fixed binary,
      158        2 modes character (256);
      159 
      160 dcl  1 read_status aligned,				/* for "read_status" control order */
      161        2 event_channel fixed binary (71),		/* channel to block on waiting for input to arrive */
      162        2 input_available bit (1);			/* ON => data in ring-0 waiting to be read */
      163 
      164 dcl  1 write_status aligned,				/* for "write_status" control order */
      165        2 event_channel fixed binary (71),		/* channel to block on waiting for write to complete */
      166        2 output_pending bit (1);			/* ON => data in ring-0 waiting to be sent */
      167 
      168 dcl  ips_mask bit (36);				/* IPS mask */
      169 
      170 dcl  cv_string_buffer character (cv_string_buffer_lth) based (cv_string_buffer_ptr);
      171 dcl  cv_string_buffer_used character (cv_string_buffer_used_lth) based (cv_string_buffer_ptr);
      172 dcl  (cv_string_buffer_lth, cv_string_buffer_used_lth) fixed binary (21);
      173 dcl  (cv_string_buffer_ptr, new_cv_string_buffer_ptr) pointer;
      174 
      175 dcl  io_buffer character (io_buffer_lth) unaligned based (io_buffer_ptr);
      176 dcl  (io_buffer_lth, io_buffer_used, io_buffer_read) fixed binary (21);
      177 dcl  io_buffer_ptr pointer;				/* buffer for I/O to/from the channel */
      178 
      179 dcl  cv_string_buffer_space character (384);		/* local space large enough for most conversions */
      180 dcl  io_buffer_space character (256) unaligned;		/* local space large enough for most I/O */
      181 
      182 dcl  (compress_code, expand_code) fixed binary (35);	/* code from hasp_util_$compress_text/expand_text */
      183 
      184 dcl  terminal_io_record_header_lth fixed binary (21);
      185 
      186 dcl  previous_data character (64) varying;		/* large enough for an SCB and associated data */
      187 
      188 dcl  (have_srcb, more_data_needed) bit (1) aligned;
      189 
      190 dcl  srcb_read character (1);				/* SRCB read from the device */
      191 
      192 dcl  n_extra_records fixed binary;			/* used to calculate output I/O buffer size */
      193 
      194 dcl  srcb character (1) unaligned based (srcb_ptr);	/* SRCB character being constructed/interpreted */
      195 dcl  srcb_ptr pointer;
      196 
      197 dcl  1 hasp_printer_srcb unaligned based (srcb_ptr) like hasp_printer_srcb_byte;
      198 
      199 dcl  more_srcbs_needed bit (1) aligned;			/* local state used to perform output slewing */
      200 dcl  (n_last_opcode, local_slew_count) fixed binary;
      201 
      202 dcl  pid bit (36) aligned based (info_ptr);		/* data used by "assign_to_user_process" control order */
      203 dcl  detachflag fixed bin aligned based (info_ptr);	/* data used by "detach_user_process" control order */
      204 dcl  line_type fixed bin based (info_ptr);		/* data used by "set_line_type" control order */
      205 
      206 dcl  1 read_status_info aligned like read_status based (info_ptr);
      207 						/* data used by "read_status" control order */
      208 
      209 dcl  1 hangup_proc_info aligned based (info_ptr),		/* data used by "hangup_proc" control order */
      210        2 procedure entry variable,			/* procedure to invoke when line is hungup */
      211        2 data_ptr pointer,				/* user's data to be supplied to said procedure */
      212        2 priority fixed binary;			/* priority of this event call channel */
      213 
      214 dcl  1 get_channel_info aligned based (info_ptr) like tty_get_channel_info;
      215 
      216 dcl  NAME character (32) static options (constant) initial ("hasp_workstation_");
      217 
      218 /* format: off */
      219 dcl (NUL		initial (" "),
      220      ASCII_SPACE	initial (" "),
      221      EBCDIC_SPACE	initial ("@"))
      222 	character (1) static options (constant);
      223 
      224 dcl (UPPERCASE	initial ("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
      225      LOWERCASE	initial ("abcdefghijklmnopqrstuvwxyz"))
      226 	character (26) static options (constant);
      227 
      228 dcl  ascii_to_ebcdic_$ae_table character (128) external;
      229 dcl  ebcdic_to_ascii_$ea_table character (256) external;
      230 
      231 dcl  error_table_$timeout fixed bin(35) ext static;
      232 dcl  error_table_$invalid_device fixed bin(35) ext static;
      233 dcl (error_table_$action_not_performed, error_table_$bad_conversion, error_table_$bad_mode, error_table_$badopt,
      234      error_table_$bigarg, error_table_$device_type_unknown, error_table_$eof_record, error_table_$improper_data_format,
      235      error_table_$inconsistent, error_table_$incorrect_device_type, error_table_$invalid_read, error_table_$invalid_write,
      236      error_table_$io_no_permission, error_table_$long_record, error_table_$noalloc, error_table_$noarg,
      237      error_table_$not_attached, error_table_$not_closed, error_table_$not_detached, error_table_$not_open,
      238      error_table_$null_info_ptr, error_table_$short_record, error_table_$smallarg, error_table_$unable_to_do_io,
      239      error_table_$undefined_order_request, error_table_$unimplemented_version, error_table_$wrong_no_of_args)
      240 	fixed binary (35) external;
      241 /* format: on */
      242 
      243 dcl  com_err_ entry () options (variable);
      244 dcl  continue_to_signal_ entry (fixed binary (35));
      245 dcl  convert_dial_message_
      246 	entry (bit (72) aligned, character (*), character (*), fixed binary, 1 aligned like dialup_msg_flags,
      247 	fixed binary (35));
      248 dcl  cu_$arg_list_ptr entry () returns (pointer);
      249 dcl  cu_$arg_ptr entry (fixed binary, pointer, fixed binary (21), fixed binary (35));
      250 dcl  cv_dec_check_ entry (character (*), fixed binary (35)) returns (fixed binary (35));
      251 dcl  dial_manager_$privileged_attach entry (pointer, fixed binary (35));
      252 dcl  dial_manager_$release_channel entry (pointer, fixed binary (35));
      253 dcl  get_group_id_ entry () returns (char (32));
      254 dcl  get_system_free_area_ entry () returns (pointer);
      255 dcl  hasp_util_$compress_text
      256 	entry (pointer, fixed binary (21), fixed binary (21), pointer, fixed binary (21), fixed binary (21),
      257 	character (1) aligned, fixed binary (35));
      258 dcl  hasp_util_$expand_text
      259 	entry (pointer, fixed binary (21), fixed binary (21), pointer, fixed binary (21), fixed binary (21),
      260 	character (1) aligned, fixed binary (35));
      261 dcl  hcs_$assign_channel entry (fixed binary (71), fixed binary (35));
      262 dcl  hcs_$delete_channel entry (fixed binary (71), fixed binary (35));
      263 dcl  hcs_$reset_ips_mask entry (bit (36), bit (36));
      264 dcl  hcs_$set_ips_mask entry (bit (36), bit (36));
      265 dcl  hcs_$tty_detach_new_proc entry (fixed bin, bit (36) aligned, fixed bin, fixed bin (35));
      266 dcl  hcs_$tty_event entry (fixed bin, fixed bin (71), fixed bin, fixed bin (35));
      267 dcl  hcs_$tty_abort entry (fixed binary, fixed binary, fixed binary, fixed binary (35));
      268 dcl  hcs_$tty_attach entry (character (*), fixed binary (71), fixed binary, fixed binary, fixed binary (35));
      269 dcl  hcs_$tty_detach entry (fixed binary, fixed binary, fixed binary, fixed binary (35));
      270 dcl  hcs_$tty_order entry (fixed binary, character (*), pointer, fixed binary, fixed binary (35));
      271 dcl  hcs_$tty_state entry (fixed bin, fixed bin, fixed bin (35));
      272 dcl  hcs_$tty_read
      273 	entry (fixed binary, pointer, fixed binary (21), fixed binary (21), fixed binary (21), fixed binary,
      274 	fixed binary (35));
      275 dcl  hcs_$tty_write
      276 	entry (fixed binary, pointer, fixed binary (21), fixed binary (21), fixed binary (21), fixed binary,
      277 	fixed binary (35));
      278 dcl  ioa_$general_rs entry (pointer, fixed binary, fixed binary, character (*), fixed binary (21), bit (1), bit (1));
      279 dcl  iox_$err_no_operation entry ();
      280 dcl  iox_$propagate entry (pointer);
      281 dcl  ipc_$block entry (pointer, pointer, fixed binary (35));
      282 dcl  ipc_$create_ev_chn entry (fixed binary (71), fixed binary (35));
      283 dcl  ipc_$decl_ev_call_chn entry (fixed binary (71), entry, pointer, fixed binary, fixed binary (35));
      284 dcl  ipc_$decl_ev_wait_chn entry (fixed binary (71), fixed binary (35));
      285 dcl  ipc_$delete_ev_chn entry (fixed binary (71), fixed binary (35));
      286 dcl  mvt_ entry (pointer, pointer, fixed binary (21), character (512) aligned);
      287 dcl  requote_string_ entry (character (*)) returns (character (*));
      288 dcl  terminate_process_ entry (char (*), ptr);
      289 dcl  timer_manager_$alarm_wakeup entry (fixed binary (71), bit (2), fixed binary (71));
      290 dcl  timer_manager_$reset_alarm_wakeup entry (fixed bin (71));
      291 dcl  ttt_info_$terminal_data entry (character (*), fixed binary, fixed binary, pointer, fixed binary (35));
      292 
      293 dcl  (any_other, area, cleanup) condition;
      294 
      295 dcl  (addcharno, addr, binary, clock, copy, currentsize, divide, dimension, hbound, index, lbound, length, ltrim, max,
      296      maxlength, min, mod, null, rel, rtrim, string, substr, translate, unspec) builtin;
      297 
      298 
      299 /* Data describing a single switch attached through this I/O module */
      300 
      301 dcl  1 had aligned based (had_ptr),
      302        2 attach_description character (256) varying,	/* attach description for this I/O switch */
      303        2 open_description character (24) varying,		/* open description (mode) */
      304        2 channel_info_ptr pointer,			/* -> description of the channel */
      305        2 top_of_page_sequence_ptr pointer,		/* -> description of slewing operations to reach next page */
      306        2 inside_page_sequence_ptr pointer,		/* -> ... next inside page (head sheet) */
      307        2 outside_page_sequence_ptr pointer,		/* -> ... next outside page (tail sheet) */
      308        2 default_forms character (32) varying,		/* default type of forms used on this switch (from -forms) */
      309        2 current_forms character (32) varying,		/* type of forms currently in use (set_forms control order) */
      310        2 translations,
      311          3 input character (512),			/* received data -> ASCII translate table */
      312          3 output character (512),			/* ASCII -> transmittable data translate table */
      313          3 space character (1),			/* an ASCII space in remote device's character code */
      314        2 chain,					/* chain of I/O switches attached to this channel */
      315          3 next pointer,
      316          3 previous pointer;
      317 
      318 dcl  had_ptr pointer;
      319 
      320 
      321 /* Data describing a single TTY channel attached through this I/O module */
      322 
      323 dcl  1 channel_info aligned based (channel_info_ptr),
      324        2 name character (32),				/* name of channel described by this entry */
      325        2 device_type fixed binary,			/* type of device attached on this channel */
      326        2 devx fixed binary,				/* MCS identifier of this channel */
      327        2 event_channel fixed binary (71),		/* MCS signals events via this ipc_ channel */
      328        2 attach_event_channel fixed binary (71),		/* used to obtain the channel from the Answering Service */
      329        2 hads,					/* chain of I/O switches attached to this channel */
      330          3 first pointer,
      331          3 last pointer,
      332        2 held_input_ptr pointer,			/* -> input from this channel waiting for processing */
      333        2 forms character (32) varying,			/* type of forms last written to this device */
      334        2 chain,					/* chain of channels attached via this I/O module */
      335          3 previous pointer,
      336          3 next pointer,
      337        2 flags,
      338          3 attached bit (1) unaligned,			/* ON => channel has been attached from answering service */
      339          3 attach_channel_is_call bit (1) unaligned,	/* ON => attach channel has been converted to call channel */
      340          3 event_channel_assigned bit (1) unaligned,
      341          3 event_channel_created bit (1) unaligned,
      342          3 output_interrupted bit (1) unaligned,		/* ON => a write_record timed out and a resetwrite
      343*						   must be done before further output */
      344          3 suppress_dial_manager bit (1) unaligned,
      345          3 block_on_io bit (1) unaligned,		/* ON => block on read and write IO operations */
      346          3 pad bit (29) unaligned;
      347 
      348 dcl  channel_info_ptr pointer;
      349 
      350 dcl  first_channel_info_ptr pointer internal static initial (null ());
      351 dcl  last_channel_info_ptr pointer internal static initial (null ());
      352 
      353 
      354 /* Slew sequence description:  the types of slewing performed by the I/O daemon (top-of-page/inside-psage/outside-page)
      355*   must be translated into a sequence of operations intepretable by the HASP workstation.  These operations are either
      356*   (1) skip N lines or (2) skip to channel N.  The sequences are specified in the attach description */
      357 
      358 dcl  1 slew_sequence aligned based (slew_sequence_ptr),
      359        2 n_ops fixed binary,				/* # of operations required to do this type of slewing */
      360        2 ops (slew_sequence_n_ops refer (slew_sequence.n_ops)),
      361          3 count_or_channel fixed binary,		/* # of lines to skip or channel # */
      362          3 skip_to_channel bit (1);			/* ON => above value is channel #; OFF => it's a line count */
      363 
      364 dcl  slew_sequence_ptr pointer;
      365 dcl  slew_sequence_n_ops fixed binary;			/* used by attach entry to allocate this structure */
      366 
      367 
      368 /* Held input:  The read_record operation may read more data from ring-0 than necessary; this data is held in this
      369*   structure for later processing */
      370 
      371 dcl  1 held_input aligned based (held_input_ptr),
      372        2 n_elements_used fixed binary (21),		/* # of characters still being held */
      373        2 n_elements_allocated fixed binary (21),		/* # of characters initially held */
      374        2 data character (held_input_n_elements_allocated refer (held_input.n_elements_allocated));
      375 
      376 dcl  held_input_ptr pointer;
      377 dcl  held_input_n_elements_allocated fixed binary (21);
      378 
      379 /* Attach an I/O switch to a device of a HASP workstation */
      380 
      381 hasp_workstation_attach:
      382      entry (P_iocb_ptr, P_attach_options, P_loud_sw, P_code);
      383 
      384 	iocb_ptr = P_iocb_ptr;
      385 	loud_sw = P_loud_sw;
      386 	code = 0;					/* assume no errors yet */
      387 
      388 	had_ptr = null ();				/* avoid freeing garbage if I/O switch already attached */
      389 
      390 	if iocb_ptr -> iocb.attach_descrip_ptr ^= null () then do;
      391 	     P_code = error_table_$not_detached;	/* special case this error */
      392 	     if loud_sw then call com_err_ (P_code, NAME, "For switch ^a.", iocb_ptr -> iocb.name);
      393 	     return;
      394 	end;
      395 
      396 	system_area_ptr = get_system_free_area_ ();
      397 
      398 	on condition (cleanup) call cleanup_attachment ((0));
      399 
      400 
      401 /* Process attachment options */
      402 
      403 	if hbound (P_attach_options, 1) < 1 then
      404 	     call abort_attachment (error_table_$noarg,
      405 		"At least ""-comm"", ""-tty"", and  ""-device"" must be supplied.");
      406 
      407 	allocate had in (system_area) set (had_ptr);
      408 
      409 	have_comm = "0"b;				/* haven't seen -comm yet */
      410 	tty_channel = "";				/* haven't seen -tty yet */
      411 	device_name = "";				/* haven't seen -device yet */
      412 	terminal_type = "";				/* haven't seen -terminal_type yet */
      413 
      414 	block_on_io_sw = "1"b;			/* set the default values */
      415 	suppress_dial_manager_sw = "0"b;
      416 
      417 	other_attach_options = "";			/* optional stuff goes here */
      418 
      419 	had.open_description = "";
      420 	had.top_of_page_sequence_ptr,			/* haven't seen slew control information yet */
      421 	     had.inside_page_sequence_ptr, had.outside_page_sequence_ptr = null ();
      422 	had.default_forms, had.current_forms = "";	/* haven't seen -forms yet */
      423 	call set_translation (had.translations.input,	/* assume input is EBCDIC */
      424 	     addr (ebcdic_to_ascii_$ea_table), length (ebcdic_to_ascii_$ea_table));
      425 	call set_translation (had.translations.output, addr (ascii_to_ebcdic_$ae_table),
      426 	     length (ascii_to_ebcdic_$ae_table));
      427 	had.translations.space = EBCDIC_SPACE;		/* default translations */
      428 	had.channel_info_ptr = null ();		/* prevents abort from prematurely detaching channel */
      429 
      430 
      431 	do argument_idx = lbound (P_attach_options, 1) to hbound (P_attach_options, 1);
      432 
      433 	     argument_ptr = addcharno (addr (P_attach_options (argument_idx)), 4);
      434 	     argument_lth = length (P_attach_options (argument_idx));
      435 
      436 	     if substr (argument, 1, 1) ^= "-" then	/* do not allow non-control arguments */
      437 		call abort_attachment (error_table_$wrong_no_of_args, "All options must be control arguments.");
      438 
      439 	     if (argument = "-comm") then do;		/* communications module: must be "hasp" */
      440 		character_value = get_string_argument ();
      441 		if (argument ^= "hasp") then call abort_attachment (0, "Communications module must be ""hasp"".");
      442 		have_comm = "1"b;			/* got the right value */
      443 	     end;
      444 
      445 	     else if (argument = "-tty") then		/* specification of TTY channel */
      446 		tty_channel = get_string_argument ();
      447 
      448 	     else if (argument = "-device") then do;	/* type of device on other end of channel */
      449 		device_name = get_string_argument ();
      450 		device_type = -1;
      451 		do idx = lbound (HASP_DEVICE_NAMES, 1) to hbound (HASP_DEVICE_NAMES, 1) while (device_type = -1);
      452 		     if HASP_DEVICE_NAMES (idx) = device_name then device_type = idx;
      453 		end;
      454 		if device_type = -1 then		/* unknown type */
      455 		     call abort_attachment (error_table_$device_type_unknown,
      456 			"Device type must be one of ^v(""^a"", ^)or ""^a""; not ""^a"".",
      457 			(dimension (HASP_DEVICE_NAMES, 1) - 1), HASP_DEVICE_NAMES, device_name);
      458 	     end;
      459 
      460 	     else if (argument = "-terminal_type") | (argument = "-ttp") then do;
      461 						/* terminal type: specifies input/output translations */
      462 		terminal_type = get_string_argument ();
      463 		terminal_type = translate (terminal_type, UPPERCASE, LOWERCASE);
      464 		ttd.version = ttd_version_3;		/* try to get input/output translations */
      465 		call ttt_info_$terminal_data (terminal_type, -1, 0, addr (ttd), code);
      466 		if code ^= 0 then call abort_attachment (code, "-terminal_type ^a", terminal_type);
      467 		if (ttd.tables.input_tr_ptr = null ()) | (ttd.tables.output_tr_ptr = null ()) then
      468 		     call abort_attachment (0, "Terminal type ""^a"" does not specify input and output translations.",
      469 			terminal_type);
      470 		call set_translation (had.translations.input,
      471 		     addr (ttd.tables.input_tr_ptr -> cv_trans_struc.cv_trans.value),
      472 		     dimension (ttd.tables.input_tr_ptr -> cv_trans_struc.cv_trans.value, 1));
      473 		call set_translation (had.translations.output,
      474 		     addr (ttd.tables.output_tr_ptr -> cv_trans_struc.cv_trans.value),
      475 		     dimension (ttd.tables.output_tr_ptr -> cv_trans_struc.cv_trans.value, 1));
      476 		had.translations.space = translate (ASCII_SPACE, had.translations.output);
      477 	     end;
      478 
      479 	     else if (argument = "-physical_line_length") | (argument = "-pll") then do;
      480 						/* supplied by calling I/O module:  ignored here */
      481 		numeric_value = get_numeric_argument ();
      482 		other_attach_options = other_attach_options || " -physical_line_length ";
      483 		other_attach_options = other_attach_options || argument;
      484 	     end;
      485 
      486 	     else if (argument = "-ebcdic") then	/* supplied by calling I/O module:  ignored here */
      487 		other_attach_options = other_attach_options || " -ebcdic";
      488 
      489 	     else if (argument = "-ascii") then		/* hasp_workstation_ doesn't support ASCII data */
      490 		call abort_attachment (0, "ASCII is not supported by this I/O module.");
      491 
      492 	     else if (argument = "-horizontal_tab") | (argument = "-htab") then
      493 		call abort_attachment (0, "Horizontal tabs are not supported by this I/O module.");
      494 
      495 	     else if (argument = "-top_of_page") then do; /* specifies how to get to top of any page */
      496 		call parse_slew_sequence (had.top_of_page_sequence_ptr);
      497 		other_attach_options = other_attach_options || " -top_of_page ";
      498 		other_attach_options = other_attach_options || argument;
      499 	     end;
      500 
      501 	     else if (argument = "-inside_page") then do; /* specifies how to get to top of inside page */
      502 		call parse_slew_sequence (had.inside_page_sequence_ptr);
      503 		other_attach_options = other_attach_options || " -inside_page ";
      504 		other_attach_options = other_attach_options || argument;
      505 	     end;
      506 
      507 	     else if (argument = "-outside_page") then do;/* specifies how to get to top of outside page */
      508 		call parse_slew_sequence (had.outside_page_sequence_ptr);
      509 		other_attach_options = other_attach_options || " -outside_page ";
      510 		other_attach_options = other_attach_options || argument;
      511 	     end;
      512 
      513 	     else if (argument = "-forms") then do;	/* specifies forms to be used for this switch */
      514 		character_value = get_string_argument ();
      515 		if argument_lth > maxlength (had.default_forms) then
      516 		     call abort_attachment (error_table_$bigarg, "Forms name must be ^d characters or less.",
      517 			maxlength (had.default_forms));
      518 		character_value = translate (character_value, UPPERCASE, LOWERCASE);
      519 		other_attach_options = other_attach_options || " -forms ";
      520 		other_attach_options =
      521 		     other_attach_options || requote_string_ (substr (character_value, 1, argument_lth));
      522 		had.default_forms = substr (character_value, 1, argument_lth);
      523 	     end;					/* will translate to proper code later */
      524 
      525 	     else if (argument = "-suppress_dial_manager") then do;
      526 		suppress_dial_manager_sw = "1"b;
      527 		other_attach_options = other_attach_options || " -suppress_dial_manager";
      528 	     end;
      529 
      530 	     else if (argument = "-no_block") then do;
      531 		block_on_io_sw = "0"b;
      532 		other_attach_options = other_attach_options || " -no_block";
      533 	     end;
      534 
      535 	     else call abort_attachment (error_table_$badopt, """^a""", argument);
      536 	end;					/* of argument processing loop */
      537 
      538 
      539 /* Validate that all required information has been supplied and apply any needed defaults */
      540 
      541 	if ^have_comm then				/* must specify -comm */
      542 	     call abort_attachment (error_table_$noarg, """-comm""");
      543 
      544 	if (tty_channel = "") then			/* must specify -tty */
      545 	     call abort_attachment (error_table_$noarg, """-tty""");
      546 
      547 	if (device_name = "") then			/* must specify -device */
      548 	     call abort_attachment (error_table_$noarg, """-device""");
      549 
      550 	if (device_type = HASP_PRINTER) then		/* only printers need slewing sequences */
      551 	     if ((had.top_of_page_sequence_ptr = null ()) | (had.inside_page_sequence_ptr = null ())
      552 		| (had.outside_page_sequence_ptr = null ())) then do;
      553 						/* not all sequences supplied: default to skip to channel 1 */
      554 		slew_sequence_n_ops = 1;
      555 		allocate slew_sequence in (system_area) set (slew_sequence_ptr);
      556 		slew_sequence.ops (1).count_or_channel = 1;
      557 		slew_sequence.ops (1).skip_to_channel = "1"b;
      558 		if (had.top_of_page_sequence_ptr = null ()) then had.top_of_page_sequence_ptr = slew_sequence_ptr;
      559 		if (had.inside_page_sequence_ptr = null ()) then had.inside_page_sequence_ptr = slew_sequence_ptr;
      560 		if (had.outside_page_sequence_ptr = null ()) then had.outside_page_sequence_ptr = slew_sequence_ptr;
      561 	     end;
      562 	     else ;				/* all sequences were specified */
      563 
      564 	else					/* not printer: reject any slewing controls */
      565 	     if ((had.top_of_page_sequence_ptr ^= null ()) | (had.inside_page_sequence_ptr ^= null ())
      566 	     | (had.outside_page_sequence_ptr ^= null ())) then do;
      567 	     if (had.outside_page_sequence_ptr ^= null ()) then idx = 3;
      568 	     if (had.inside_page_sequence_ptr ^= null ()) then idx = 2;
      569 	     if (had.top_of_page_sequence_ptr ^= null ()) then idx = 1;
      570 	     call abort_attachment (error_table_$inconsistent,
      571 		"""-^[top_of_page^;inside_page^;outside_page^]"" may not be specified for the ^a device.", idx,
      572 		device_name);
      573 	end;
      574 
      575 	if (device_type ^= HASP_PRINTER) then		/* do not allow forms if not a printer */
      576 	     if (had.default_forms ^= "") then
      577 		call abort_attachment (error_table_$inconsistent,
      578 		     """-forms"" may not be specified for the ^a device.", device_name);
      579 
      580 	if (had.default_forms ^= "") then do;		/* translate to code used by foreign device */
      581 	     had.default_forms = translate (had.default_forms, had.translations.output);
      582 	     had.current_forms = had.default_forms;	/* start out by using this forms specification */
      583 	end;
      584 
      585 
      586 /* Build the attach description */
      587 
      588 	had.attach_description = rtrim (NAME);
      589 	had.attach_description = had.attach_description || " -comm hasp -tty ";
      590 	had.attach_description = had.attach_description || rtrim (tty_channel);
      591 	had.attach_description = had.attach_description || " -device ";
      592 	had.attach_description = had.attach_description || rtrim (device_name);
      593 	if (terminal_type ^= "") then do;		/* optional -terminal_type was given */
      594 	     had.attach_description = had.attach_description || " -terminal_type ";
      595 	     had.attach_description = had.attach_description || rtrim (terminal_type);
      596 	end;
      597 	had.attach_description = had.attach_description || other_attach_options;
      598 
      599 
      600 /* Find the description of this channel:  Validate that all I/O switches attached to this channel are of for the same type
      601*   of I/O daemon device (printer, reader, etc.) */
      602 
      603 	do channel_info_ptr = first_channel_info_ptr repeat (channel_info.chain.next)
      604 	     while (channel_info_ptr ^= null ());
      605 	     if channel_info.name = tty_channel then go to FOUND_CHANNEL;
      606 	end;
      607 
      608 FOUND_CHANNEL:
      609 	if (channel_info_ptr = null ()) then do;	/* first use of the channel */
      610 	     allocate channel_info in (system_area) set (channel_info_ptr);
      611 	     channel_info.name = tty_channel;
      612 	     channel_info.device_type = device_type;
      613 	     channel_info.devx, channel_info.event_channel, channel_info.attach_event_channel = -1;
      614 	     channel_info.hads = null ();		/* no switches connected yet */
      615 	     channel_info.held_input_ptr = null ();	/* no read ahead yet */
      616 	     channel_info.forms = "";			/* no forms used yet */
      617 	     string (channel_info.flags) = ""b;		/* not attached yet */
      618 	     if first_channel_info_ptr = null () then
      619 		first_channel_info_ptr = channel_info_ptr;
      620 	     else last_channel_info_ptr -> channel_info.chain.next = channel_info_ptr;
      621 	     channel_info.chain.previous = last_channel_info_ptr;
      622 	     channel_info.chain.next = null ();
      623 	     last_channel_info_ptr = channel_info_ptr;
      624 	end;
      625 
      626 	else					/* channel in use: insure that device type is correct */
      627 	     if channel_info.device_type ^= device_type then
      628 	     call abort_attachment (error_table_$incorrect_device_type, "Device type of ^a is ""^a""; not ""^a"".",
      629 		tty_channel, HASP_DEVICE_NAMES (channel_info.device_type), HASP_DEVICE_NAMES (device_type));
      630 
      631 	if channel_info.hads.first = null () then
      632 	     channel_info.hads.first = had_ptr;		/* first switch for this channel */
      633 	else channel_info.hads.last -> had.chain.next = had_ptr;
      634 	had.chain.previous = channel_info.hads.last;
      635 	had.chain.next = null ();
      636 	channel_info.hads.last = had_ptr;
      637 
      638 	had.channel_info_ptr = channel_info_ptr;
      639 
      640 
      641 /* Acquire and attach the channel if necessary */
      642 
      643 	if channel_info.devx = -1 then do;
      644 
      645 	     channel_info.block_on_io = block_on_io_sw;
      646 	     channel_info.suppress_dial_manager = suppress_dial_manager_sw;
      647 	     if suppress_dial_manager_sw then goto ASSUME_ATTACHED;
      648 
      649 /* Request the TTY channel from the Answering Service */
      650 
      651 	     call ipc_$create_ev_chn (channel_info.attach_event_channel, code);
      652 	     if code ^= 0 then call abort_attachment (code, "Creating ipc_ channel.");
      653 
      654 	     dma.version = dial_manager_arg_version_2;
      655 	     dma.dial_channel = channel_info.attach_event_channel;
      656 	     dma.channel_name = tty_channel;
      657 	     dma.dial_qualifier, dma.dial_out_destination, dma.reservation_string = "";
      658 
      659 	     call dial_manager_$privileged_attach (addr (dma), code);
      660 	     if code = error_table_$action_not_performed then go to ASSUME_ATTACHED;
      661 	     if code ^= 0 then call abort_attachment (code, "Attempting to attach ^a.", tty_channel);
      662 
      663 	     event_wait_channel.n_channels = 1;
      664 	     event_wait_channel.channel_id (1) = channel_info.attach_event_channel;
      665 
      666 WAIT_FOR_ANSWERING_SERVICE:
      667 	     call ipc_$block (addr (event_wait_channel), addr (local_event_wait_info), code);
      668 						/* wait for answering service to give it to us */
      669 	     if code ^= 0 then call abort_attachment (code, "Waiting for attachment to ^a.", tty_channel);
      670 
      671 	     call convert_dial_message_ (unspec (local_event_wait_info.message), dialup_msg_channel, ((32)" "), (0),
      672 		dialup_msg_flags, code);
      673 	     if code ^= 0 then call abort_attachment (code, "Interpreting attachment to ^a.", tty_channel);
      674 
      675 	     if ^dialup_msg_flags.dialed_up then do;	/* seems to be a wakeup for some other channel */
      676 		call com_err_ (0, NAME,
      677 		     "For switch ^a: Unexpected signal from answering service - ^[hangup^;control^] for channel ^a.",
      678 		     iocb_ptr -> iocb.name, dialup_msg_flags.hungup, dialup_msg_channel);
      679 		go to WAIT_FOR_ANSWERING_SERVICE;
      680 	     end;
      681 
      682 
      683 /* Create the event channel for ring-0:  try using a special channel first */
      684 
      685 ASSUME_ATTACHED:
      686 	     channel_info.attached = "1"b;		/* we have the channel from the answering service now */
      687 
      688 	     call hcs_$assign_channel (channel_info.event_channel, code);
      689 
      690 	     if code = 0 then
      691 		channel_info.event_channel_assigned = "1"b;
      692 	     else do;				/* couldn't get fast channel: try standard one */
      693 		call ipc_$create_ev_chn (channel_info.event_channel, code);
      694 		if code ^= 0 then call abort_attachment (code, "Creating ipc_ channel.");
      695 		channel_info.event_channel_created = "0"b;
      696 	     end;
      697 
      698 
      699 /* Attach the channel through the ring-0 HASP multiplexer in MCS, validate
      700*   the supplied device type, and set its modes to "rawi,rawo" */
      701 
      702 	     call hcs_$tty_attach (tty_channel, channel_info.event_channel, channel_info.devx, state, code);
      703 	     if ^suppress_dial_manager_sw then
      704 		if state ^= 5 then code = error_table_$io_no_permission;
      705 	     if suppress_dial_manager_sw then
      706 		if code = error_table_$action_not_performed then
      707 						/* This means the mpx is down */
      708 		     call abort_attachment (error_table_$invalid_device,
      709 						/* But the message coordinator likes this error code
      710*						   to mean mpx down. */
      711 			"The parent multiplexer has not been loaded.");
      712 	     if code ^= 0 then call abort_attachment (code, "Unable to attach to ^a.", tty_channel);
      713 
      714 	     call hcs_$tty_order (channel_info.devx, "get_device_type", addr (multiplexer_device_type), state, code);
      715 	     if ^suppress_dial_manager_sw then
      716 		if state ^= 5 then code = error_table_$io_no_permission;
      717 	     if (code = 0) then
      718 		if (channel_info.device_type = multiplexer_device_type) then
      719 		     ;				/* proper device type for this channel */
      720 		else call abort_attachment (error_table_$incorrect_device_type,
      721 			"Device type of ^a is ""^a""; not ""^a"".", tty_channel,
      722 			HASP_DEVICE_NAMES (multiplexer_device_type), HASP_DEVICE_NAMES (channel_info.device_type));
      723 	     else if (code = error_table_$undefined_order_request) then
      724 		call abort_attachment (0, "^a is not connected to a HASP multiplexer.", tty_channel);
      725 	     else call abort_attachment (code, "Unable to determine device type of ^a.", tty_channel);
      726 
      727 	     tty_modes.modes = "rawi,rawo";
      728 	     tty_modes.modes_lth = length (tty_modes.modes);
      729 	     call hcs_$tty_order (channel_info.devx, "modes", addr (tty_modes), state, code);
      730 	     if ^suppress_dial_manager_sw then
      731 		if state ^= 5 then code = error_table_$io_no_permission;
      732 	     if code ^= 0 then call abort_attachment (code, "Unable to set initial modes for ^a.", tty_channel);
      733 	end;
      734 
      735 
      736 /* Mask and complete construction of the IOCB */
      737 
      738 	ips_mask = ""b;
      739 
      740 	on condition (any_other) call any_other_handler ();
      741 
      742 	call hcs_$set_ips_mask (((36)"0"b), ips_mask);
      743 
      744 	iocb_ptr -> iocb.attach_descrip_ptr = addr (had.attach_description);
      745 	iocb_ptr -> iocb.attach_data_ptr = had_ptr;
      746 	iocb_ptr -> iocb.open = hasp_workstation_open;
      747 	iocb_ptr -> iocb.control = hasp_workstation_control_before_open;
      748 	iocb_ptr -> iocb.detach_iocb = hasp_workstation_detach;
      749 
      750 	call iox_$propagate (iocb_ptr);
      751 
      752 	call hcs_$reset_ips_mask (ips_mask, ips_mask);
      753 
      754 RETURN_FROM_ATTACH:
      755 	P_code = code;
      756 	return;
      757 
      758 /* Open an I/O switch connected to a HASP workstation:  only record oriented openings are supported */
      759 
      760 hasp_workstation_open:
      761      entry (P_iocb_ptr, P_open_mode, P_open_sw, P_code);
      762 
      763 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
      764 
      765 	if iocb_ptr -> iocb.open_descrip_ptr ^= null () then do;
      766 	     P_code = error_table_$not_closed;
      767 	     return;
      768 	end;
      769 
      770 	open_mode = P_open_mode;
      771 
      772 	if ^((open_mode = Sequential_input) | (open_mode = Sequential_output) | (open_mode = Sequential_input_output))
      773 	then do;
      774 	     P_code = error_table_$bad_mode;
      775 	     return;
      776 	end;
      777 
      778 	had_ptr = iocb_ptr -> iocb.attach_data_ptr;
      779 	channel_info_ptr = had.channel_info_ptr;
      780 
      781 	if (channel_info.device_type = HASP_READER) then
      782 	     if (open_mode = Sequential_output) then do;	/* reader opened for output only */
      783 		P_code = error_table_$bad_mode;
      784 		return;
      785 	     end;
      786 
      787 	if (channel_info.device_type = HASP_PRINTER) | (channel_info.device_type = HASP_PUNCH) then
      788 	     if (open_mode = Sequential_input) then do;	/* printer/punch opened for input only */
      789 		P_code = error_table_$bad_mode;
      790 		return;
      791 	     end;
      792 
      793 	had.open_description = rtrim (iox_modes (open_mode));
      794 
      795 	ips_mask = ""b;
      796 
      797 	on condition (any_other) call any_other_handler ();
      798 
      799 	call hcs_$set_ips_mask (((36)"0"b), ips_mask);
      800 
      801 	if ((open_mode = Sequential_input) | (open_mode = Sequential_input_output)) then
      802 	     iocb_ptr -> iocb.read_record = hasp_workstation_read_record;
      803 
      804 	if ((open_mode = Sequential_output) | (open_mode = Sequential_input_output)) then
      805 	     iocb_ptr -> iocb.write_record = hasp_workstation_write_record;
      806 
      807 	iocb_ptr -> iocb.control = hasp_workstation_control;
      808 	iocb_ptr -> iocb.modes = hasp_workstation_modes;
      809 
      810 	iocb_ptr -> iocb.close = hasp_workstation_close;
      811 
      812 	iocb_ptr -> iocb.detach_iocb = hasp_workstation_detach;
      813 
      814 	iocb_ptr -> iocb.open_descrip_ptr = addr (had.open_description);
      815 						/* it's now open */
      816 
      817 	call iox_$propagate (iocb_ptr);
      818 
      819 	call hcs_$reset_ips_mask (ips_mask, ips_mask);
      820 
      821 	P_code = 0;
      822 	return;
      823 
      824 /* Close an I/O switch connected to a HASP workstation */
      825 
      826 hasp_workstation_close:
      827      entry (P_iocb_ptr, P_code);
      828 
      829 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
      830 
      831 	if iocb_ptr -> iocb.open_descrip_ptr = null () then do;
      832 	     P_code = error_table_$not_open;
      833 	     return;
      834 	end;
      835 
      836 	ips_mask = ""b;
      837 
      838 	on condition (cleanup) call any_other_handler ();
      839 
      840 	call hcs_$set_ips_mask (((36)"0"b), ips_mask);
      841 
      842 	iocb_ptr -> iocb.open_descrip_ptr = null ();
      843 
      844 	iocb_ptr -> iocb.open = hasp_workstation_open;
      845 	iocb_ptr -> iocb.detach_iocb = hasp_workstation_detach;
      846 	iocb_ptr -> iocb.control = hasp_workstation_control_before_open;
      847 
      848 	iocb_ptr -> iocb.modes, iocb_ptr -> iocb.read_record, iocb_ptr -> iocb.write_record = iox_$err_no_operation;
      849 
      850 	call iox_$propagate (iocb_ptr);
      851 
      852 	call hcs_$reset_ips_mask (ips_mask, ips_mask);
      853 
      854 	P_code = 0;
      855 
      856 	return;
      857 
      858 /* Detach an I/O switch from a device of a HASP workstation */
      859 
      860 hasp_workstation_detach:
      861      entry (P_iocb_ptr, P_code);
      862 
      863 	iocb_ptr = P_iocb_ptr;
      864 
      865 	if iocb_ptr -> iocb.attach_descrip_ptr = null () then do;
      866 	     P_code = error_table_$not_attached;
      867 	     return;
      868 	end;
      869 
      870 	if iocb_ptr -> iocb.open_descrip_ptr ^= null () then do;
      871 	     P_code = error_table_$not_closed;
      872 	     return;
      873 	end;
      874 
      875 	system_area_ptr = get_system_free_area_ ();
      876 
      877 	had_ptr = iocb_ptr -> iocb.attach_data_ptr;
      878 	channel_info_ptr = had.channel_info_ptr;
      879 
      880 	call cleanup_attachment (code);		/* remove this switch and the channel if necessary */
      881 
      882 	ips_mask = ""b;
      883 
      884 	on condition (any_other) call any_other_handler ();
      885 
      886 	call hcs_$set_ips_mask (((36)"0"b), ips_mask);
      887 
      888 	iocb_ptr -> iocb.attach_descrip_ptr = null ();	/* it's detached */
      889 
      890 	call iox_$propagate (iocb_ptr);
      891 
      892 	call hcs_$reset_ips_mask (ips_mask, ips_mask);
      893 
      894 	P_code = code;				/* in case trouble freeing the channel */
      895 	return;
      896 
      897 /* Read a record:  read a single record from the device, returning a "standard" terminal_io_record structure */
      898 
      899 hasp_workstation_read_record:
      900      entry (P_iocb_ptr, P_buffer_ptr, P_buffer_lth, P_record_lth, P_code);
      901 
      902 	call init_read ();
      903 
      904 	if ^channel_info.block_on_io then
      905 	     timeout = 0;
      906 	else timeout = -1;
      907 	goto READ_JOIN;
      908 
      909 hasp_workstation_read_record_timed:			/* For read_record_timeout control order */
      910      entry (P_iocb_ptr, P_buffer_ptr, P_buffer_lth, P_record_lth, P_code, P_timeout);
      911 
      912 	call init_read ();
      913 
      914 	if ^channel_info.block_on_io then do;
      915 	     P_code = error_table_$inconsistent;
      916 	     return;
      917 	end;
      918 
      919 	timeout = P_timeout;
      920 
      921 READ_JOIN:
      922 	stop_time = clock () + timeout;
      923 	code = 0;
      924 
      925 	if (channel_info.device_type = HASP_PRINTER) | (channel_info.device_type = HASP_PUNCH) then do;
      926 	     P_code = error_table_$invalid_read;	/* can't read from printer or punch */
      927 	     return;
      928 	end;
      929 
      930 	system_area_ptr = get_system_free_area_ ();
      931 	cv_string_buffer_ptr = null ();		/* for cleanup handler */
      932 
      933 	on condition (cleanup)
      934 	     begin;
      935 	     if cv_string_buffer_ptr ^= null () then
      936 		if cv_string_buffer_ptr ^= addr (cv_string_buffer_space) then free cv_string_buffer in (system_area);
      937 	end;
      938 
      939 
      940 /* Validate that there is room in the buffer to hold some actual data in addition to a terminal_io_record header */
      941 
      942 	terminal_io_record_ptr = P_buffer_ptr;
      943 
      944 	terminal_io_record_header_lth =		/* # of characters of buffer occupied by record's header */
      945 	     4 * (binary (rel (addr (terminal_io_record.data)), 18, 0) - binary (rel (terminal_io_record_ptr), 18, 0));
      946 
      947 	if terminal_io_record_header_lth >= P_buffer_lth then do;
      948 	     code = error_table_$smallarg;		/* supplied buffer is just TOO small */
      949 	     return;
      950 	end;
      951 
      952 	terminal_io_record_n_elements = P_buffer_lth - terminal_io_record_header_lth;
      953 						/* # of actual characters that will fit into the buffer */
      954 
      955 
      956 /* Obtain and unpack a record:  a record is constructed from any data obtained in prior calls to read_record in addition
      957*   to whatever data must be read from ring-0 in this call to complete the record.  Unpacking is performed on the data in
      958*   256 character sections until hasp_util_$expand_text detects the end-of-record sequence in the stream */
      959 
      960 	cv_string_buffer_ptr = addr (cv_string_buffer_space);
      961 	cv_string_buffer_lth = length (cv_string_buffer_space);
      962 	cv_string_buffer_used_lth = 0;		/* start putting data into automatic */
      963 
      964 	previous_data = "";				/* piece left from previous read */
      965 
      966 	srcb_ptr = addr (srcb_read);			/* a place to put the SRCB ... */
      967 	have_srcb = "0"b;				/* ... which hasn't been found yet */
      968 
      969 	more_data_needed = "1"b;
      970 
      971 
      972 	do while (more_data_needed);
      973 
      974 /* Select source of data for this time around:  if necessary, data will be read from ring-0 */
      975 
      976 	     if channel_info.held_input_ptr ^= null () then do;
      977 						/* read ahead: process as much of the block as can be used */
      978 		io_buffer_ptr = addr (channel_info.held_input_ptr -> held_input.data);
      979 		io_buffer_lth = channel_info.held_input_ptr -> held_input.n_elements_allocated;
      980 		io_buffer_read = channel_info.held_input_ptr -> held_input.n_elements_used;
      981 	     end;
      982 
      983 	     else do;				/* no more read ahead: obtain more data from ring-0 */
      984 		io_buffer_ptr = addr (io_buffer_space);
      985 		io_buffer_lth = length (io_buffer_space);
      986 		call read_io_buffer ();		/* sets io_buffer_read */
      987 		if code ^= 0 then go to RETURN_FROM_READ_RECORD;
      988 		if io_buffer_read = 0 then do;
      989 		     terminal_io_record.n_elements = 0;
      990 		     P_record_lth = 0;
      991 		     P_code = 0;
      992 		     return;
      993 		end;
      994 	     end;
      995 
      996 	     if length (previous_data) > 0 then do;	/* some data left over from previous junk: merge them */
      997 		held_input_n_elements_allocated = length (previous_data) + io_buffer_read;
      998 		allocate held_input in (system_area) set (held_input_ptr);
      999 		held_input.n_elements_used = held_input.n_elements_allocated;
     1000 		substr (held_input.data, 1, length (previous_data)) = previous_data;
     1001 		substr (held_input.data, (length (previous_data) + 1), io_buffer_read) =
     1002 		     substr (io_buffer, 1, io_buffer_read);
     1003 		if io_buffer_ptr ^= addr (io_buffer_space) then
     1004 		     free channel_info.held_input_ptr -> held_input in (system_area);
     1005 		channel_info.held_input_ptr = held_input_ptr;
     1006 		io_buffer_ptr = addr (held_input.data);
     1007 		io_buffer_lth, io_buffer_read = held_input.n_elements_used;
     1008 		previous_data = "";
     1009 	     end;
     1010 
     1011 
     1012 /* Unpack the data:  stop when an end-of-record indicator is found */
     1013 
     1014 	     if have_srcb then
     1015 		io_buffer_used = 0;			/* in middle of record: first character in buffer is SCB */
     1016 	     else do;				/* first part of record: first character is SRCB */
     1017 		srcb = substr (io_buffer, 1, 1);
     1018 		io_buffer_used = 1;
     1019 		have_srcb = "1"b;
     1020 	     end;
     1021 
     1022 	     do while (more_data_needed & (io_buffer_used < io_buffer_read));
     1023 
     1024 		call hasp_util_$expand_text (addr (io_buffer), io_buffer_read, io_buffer_used,
     1025 		     addr (cv_string_buffer), cv_string_buffer_lth, cv_string_buffer_used_lth, had.translations.space,
     1026 		     expand_code);
     1027 
     1028 		if expand_code = 0 then more_data_needed = "0"b;
     1029 						/* found end of record indicator */
     1030 
     1031 		else if expand_code = error_table_$short_record then ;
     1032 						/* took entire buffer but need more */
     1033 
     1034 		else if expand_code = error_table_$long_record then do;
     1035 						/* overflowed the output buffer: grow it and continue */
     1036 		     cv_string_buffer_lth = 2 * cv_string_buffer_lth;
     1037 		     on condition (area)
     1038 			begin;			/* can't get enough room: record is not readable */
     1039 			code = error_table_$noalloc;
     1040 			go to RETURN_FROM_READ_RECORD;
     1041 		     end;
     1042 		     allocate cv_string_buffer in (system_area) set (new_cv_string_buffer_ptr);
     1043 		     revert condition (area);
     1044 		     new_cv_string_buffer_ptr -> cv_string_buffer_used = cv_string_buffer_used;
     1045 		     if cv_string_buffer_ptr ^= addr (cv_string_buffer_space) then
     1046 			free cv_string_buffer in (system_area);
     1047 		     cv_string_buffer_ptr = new_cv_string_buffer_ptr;
     1048 		end;
     1049 
     1050 		else if (io_buffer_read - io_buffer_used) <= (HASP_MAX_NOT_COMPRESSED_TEXT_LTH + 1) then do;
     1051 						/* possibly need to read more data from ring-0 */
     1052 		     previous_data = substr (io_buffer, (io_buffer_used + 1), (io_buffer_read - io_buffer_used));
     1053 		     io_buffer_used = io_buffer_read;	/* force to read some more data */
     1054 		end;
     1055 
     1056 		else do;				/* data is definitely improperly formatted */
     1057 		     code = error_table_$improper_data_format;
     1058 		     go to RETURN_FROM_READ_RECORD;
     1059 		end;
     1060 	     end;
     1061 
     1062 	     if io_buffer_used = io_buffer_read then	/* have exhausted this buffer ... */
     1063 		if io_buffer_ptr ^= addr (io_buffer_space) then do;
     1064 		     free channel_info.held_input_ptr -> held_input in (system_area);
     1065 		     channel_info.held_input_ptr = null ();
     1066 		end;				/* ... so get rid of it so we can read some more */
     1067 	end;
     1068 
     1069 	if io_buffer_used < io_buffer_read then do;	/* some data left over: save it */
     1070 	     held_input_n_elements_allocated = io_buffer_read - io_buffer_used;
     1071 	     allocate held_input in (system_area) set (held_input_ptr);
     1072 	     held_input.n_elements_used = held_input.n_elements_allocated;
     1073 	     held_input.data = substr (io_buffer, (io_buffer_used + 1), (io_buffer_read - io_buffer_used));
     1074 	     if io_buffer_ptr ^= addr (io_buffer_space) then free channel_info.held_input_ptr -> held_input;
     1075 	     channel_info.held_input_ptr = held_input_ptr;
     1076 	end;
     1077 
     1078 
     1079 /* Check for end of file:  An EOF record is a zero length record.  If an EOF record is found, return
     1080*   error_table_$eof_record, otherwise, convert the data in the record to ASCII */
     1081 
     1082 	if (cv_string_buffer_used_lth = 0) then do;
     1083 	     code = error_table_$eof_record;
     1084 	     go to RETURN_FROM_READ_RECORD;
     1085 	end;
     1086 
     1087 	else do;					/* data seems OK: convert it */
     1088 	     terminal_io_record.n_elements = min (terminal_io_record_n_elements, cv_string_buffer_used_lth);
     1089 	     if cv_string_buffer_used_lth > 0 then
     1090 		call mvt_ (addr (cv_string_buffer_used), addr (terminal_io_record_data_chars),
     1091 		     (terminal_io_record.n_elements), had.translations.input);
     1092 	     if cv_string_buffer_used_lth > terminal_io_record_n_elements then code = error_table_$long_record;
     1093 	end;					/* ... return as much as will fit */
     1094 
     1095 
     1096 /* Control reaches here iff the record is read/converted successfully:  complete the terminal_io_record structure */
     1097 
     1098 	terminal_io_record.version = terminal_io_record_version_1;
     1099 
     1100 	if (channel_info.device_type = HASP_CONSOLE) then terminal_io_record.device_type = TELEPRINTER_DEVICE;
     1101 	else if (channel_info.device_type = HASP_READER) then terminal_io_record.device_type = READER_DEVICE;
     1102 
     1103 	terminal_io_record.slew_type = SLEW_BY_COUNT;	/* for console/reader, this is fixed */
     1104 	terminal_io_record.slew_count = 1;
     1105 
     1106 	string (terminal_io_record.flags) = ""b;
     1107 
     1108 	terminal_io_record.element_size = 9;
     1109 
     1110 	P_record_lth = terminal_io_record_header_lth + terminal_io_record.n_elements;
     1111 
     1112 
     1113 /* Cleanup */
     1114 
     1115 RETURN_FROM_READ_RECORD:
     1116 	if cv_string_buffer_ptr ^= null () then
     1117 	     if cv_string_buffer_ptr ^= addr (cv_string_buffer_space) then free cv_string_buffer in (system_area);
     1118 
     1119 	P_code = code;
     1120 	return;
     1121 
     1122 /* Write a record:  write a single record to the device.  This record represents part or all of a single line and should
     1123*   be the output of the prt_conv_ module using the remote_conv_ conversion routine */
     1124 
     1125 hasp_workstation_write_record:
     1126      entry (P_iocb_ptr, P_record_ptr, P_record_lth, P_code);
     1127 
     1128 	timeout = -1;
     1129 	goto WRITE_JOIN;
     1130 
     1131 hasp_workstation_write_record_timed:			/* for write_record_timout control order */
     1132      entry (P_iocb_ptr, P_record_ptr, P_record_lth, P_code, P_timeout, P_chars_sent);
     1133 
     1134 	timeout = P_timeout;
     1135 	if timeout < 0 then timeout = 0;		/* Make sure that timeout = -1 means non-timeout call */
     1136 
     1137 WRITE_JOIN:
     1138 	if timeout >= 0 then stop_time = clock () + timeout;
     1139 
     1140 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
     1141 	had_ptr = iocb_ptr -> iocb.attach_data_ptr;
     1142 	channel_info_ptr = had.channel_info_ptr;
     1143 	code = 0;
     1144 
     1145 	if channel_info.device_type = HASP_READER then do;/* can't write the card reader */
     1146 	     P_code = error_table_$invalid_write;
     1147 	     return;
     1148 	end;
     1149 
     1150 	system_area_ptr = get_system_free_area_ ();
     1151 	io_buffer_ptr = null ();			/* for cleanup handler */
     1152 
     1153 	on condition (cleanup)
     1154 	     begin;				/* free any temporary buffers */
     1155 	     if io_buffer_ptr ^= null () then
     1156 		if io_buffer_ptr ^= addr (io_buffer_space) then free io_buffer in (system_area);
     1157 	end;
     1158 
     1159 
     1160 /* Validate input:  insure that the caller has supplied a complete terminal I/O record; insure that the terminal input
     1161*   record contains character as opposed to binary data */
     1162 
     1163 	terminal_io_record_ptr = P_record_ptr;
     1164 
     1165 	if terminal_io_record.version ^= terminal_io_record_version_1 then do;
     1166 	     P_code = error_table_$unimplemented_version;
     1167 	     return;
     1168 	end;
     1169 
     1170 	if mod (P_record_lth, 4) = 0 then		/* X+4-mod(X,4) fails when X is already a multiple of 4 */
     1171 	     if (4 * currentsize (terminal_io_record)) = P_record_lth then
     1172 		;				/* user supplied length agrees with computed length */
     1173 	     else do;
     1174 		P_code = error_table_$improper_data_format;
     1175 		return;
     1176 	     end;
     1177 	else					/* supplied length not multiple of 4:  must round it up */
     1178 	     if (4 * currentsize (terminal_io_record)) ^= (P_record_lth + 4 - mod (P_record_lth, 4)) then do;
     1179 	     P_code = error_table_$improper_data_format;
     1180 	     return;
     1181 	end;
     1182 
     1183 	if terminal_io_record.binary | terminal_io_record.preslew | (terminal_io_record.element_size ^= 9) then do;
     1184 	     P_code = error_table_$improper_data_format;
     1185 	     return;
     1186 	end;
     1187 
     1188 
     1189 /* Convert the data to the character code used by the remote system (in place) */
     1190 
     1191 	call mvt_ (addr (terminal_io_record_data_chars), addr (terminal_io_record_data_chars),
     1192 	     (terminal_io_record.n_elements), had.translations.output);
     1193 
     1194 
     1195 /* Compute size of I/O buffer required assuming no compression can be performed on the record.  If this size is not too
     1196*   large, the automatic buffer will be used; otherwise, a buffer will be allocated */
     1197 
     1198 	io_buffer_lth =
     1199 	     max (terminal_io_record.n_elements, 1)
     1200 	     +
     1201 	     divide ((terminal_io_record.n_elements + HASP_MAX_NOT_COMPRESSED_TEXT_LTH - 1),
     1202 	     HASP_MAX_NOT_COMPRESSED_TEXT_LTH, 17, 0) +	/* SCBs for the text */
     1203 	     2;					/* SRCB and end-of-record SCB */
     1204 
     1205 	if (channel_info.device_type = HASP_PRINTER) then do;
     1206 						/* line printer: must count extra records for SRCBs and
     1207*						   forms change (if necessary) */
     1208 	     if (had.current_forms ^= channel_info.forms) then
     1209 		io_buffer_lth = io_buffer_lth + 3 + max (length (had.current_forms), 1);
     1210 						/* SRCB, SCB, forms-name, EOR-SCB */
     1211 	     if (terminal_io_record.slew_type = SLEW_BY_COUNT) then
     1212 		n_extra_records = divide (terminal_io_record.slew_count, HASP_MAX_SLEW_COUNT, 17, 0);
     1213 	     else if (terminal_io_record.slew_type = SLEW_TO_TOP_OF_PAGE) then
     1214 		n_extra_records = had.top_of_page_sequence_ptr -> slew_sequence.n_ops - 1;
     1215 	     else if (terminal_io_record.slew_type = SLEW_TO_INSIDE_PAGE) then
     1216 		n_extra_records = had.inside_page_sequence_ptr -> slew_sequence.n_ops - 1;
     1217 	     else if (terminal_io_record.slew_type = SLEW_TO_OUTSIDE_PAGE) then
     1218 		n_extra_records = had.outside_page_sequence_ptr -> slew_sequence.n_ops - 1;
     1219 	     else if (terminal_io_record.slew_type = SLEW_TO_CHANNEL) then n_extra_records = 0;
     1220 						/* can be specified in the first SRCB */
     1221 	     io_buffer_lth = io_buffer_lth + 4 * n_extra_records;
     1222 						/* SRCB, SCB, blank, EOR-SCB */
     1223 	end;
     1224 
     1225 	if io_buffer_lth <= length (io_buffer_space) then do;
     1226 						/* space needed available in automatic */
     1227 	     io_buffer_ptr = addr (io_buffer_space);
     1228 	     io_buffer_lth = length (io_buffer_space);
     1229 	end;
     1230 	else do;					/* space required larger than automatic buffer */
     1231 	     on condition (area)
     1232 		begin;
     1233 		code = error_table_$noalloc;		/* just TOO much */
     1234 		go to RETURN_FROM_WRITE_RECORD;
     1235 	     end;
     1236 	     allocate io_buffer in (system_area) set (io_buffer_ptr);
     1237 	end;
     1238 
     1239 	io_buffer_used = 0;				/* nothing in the output yet */
     1240 
     1241 
     1242 /* Forms processing:  for a line printer, issue a HASP forms change record if the forms required for this I/O switch
     1243*   differs from the last forms used on the channel */
     1244 
     1245 	if (channel_info.device_type = HASP_PRINTER) then
     1246 	     if (had.current_forms ^= channel_info.forms) then do;
     1247 		call add_character_to_io_buffer ((HASP_FORMS_CHANGE_SRCB));
     1248 		if length (had.current_forms) = 0 then
     1249 		     call hasp_util_$compress_text (addr (had.translations.space), 1, (0), addr (io_buffer),
     1250 			length (io_buffer), io_buffer_used, had.translations.space, compress_code);
     1251 		else call hasp_util_$compress_text (addr (had.current_forms), length (had.current_forms), (0),
     1252 			addr (io_buffer), length (io_buffer), io_buffer_used, had.translations.space, compress_code)
     1253 			;
     1254 		if compress_code ^= 0 then go to WRITE_RECORD_BAD_DATA;
     1255 		call add_character_to_io_buffer ((HASP_EOR_SCB));
     1256 	     end;
     1257 
     1258 
     1259 /* Create the record:  construct the SRCB for the record, compress the record (insuring that some data is present in the
     1260*   record), and add the terminating end-of-record SCB */
     1261 
     1262 	call generate_record_srcb ();			/* does the dirty work */
     1263 
     1264 	if terminal_io_record.n_elements = 0 then	/* no data:  supply some to avoid lossage with RSCS */
     1265 	     call hasp_util_$compress_text (addr (had.translations.space), 1, (0), addr (io_buffer), length (io_buffer),
     1266 		io_buffer_used, had.translations.space, compress_code);
     1267 
     1268 	else call hasp_util_$compress_text (addr (terminal_io_record.data), (terminal_io_record.n_elements), (0),
     1269 		addr (io_buffer), length (io_buffer), io_buffer_used, had.translations.space, compress_code);
     1270 
     1271 	if compress_code ^= 0 then do;		/* failed. yet above code insured there'd be enough room */
     1272 WRITE_RECORD_BAD_DATA:
     1273 	     code = error_table_$improper_data_format;
     1274 	     go to RETURN_FROM_WRITE_RECORD;
     1275 	end;
     1276 
     1277 	call add_character_to_io_buffer ((HASP_EOR_SCB));
     1278 
     1279 
     1280 /* Complete the data block:  for the line printer, the slew control operation requested in the data record may not be
     1281*   representable as a single SRCB character.  The call to generate_record_srcb above sets local state to indicate if more
     1282*   SRCBs are needed.  In this case, empty records are created containing just the SRCB and a blank */
     1283 
     1284 	do while (more_srcbs_needed);
     1285 
     1286 	     call generate_next_srcb ();		/* create the next SRCB */
     1287 
     1288 	     call hasp_util_$compress_text (addr (had.translations.space), 1, (0), addr (io_buffer), length (io_buffer),
     1289 		io_buffer_used, had.translations.space, compress_code);
     1290 	     if compress_code ^= 0 then go to WRITE_RECORD_BAD_DATA;
     1291 
     1292 	     call add_character_to_io_buffer ((HASP_EOR_SCB));
     1293 	end;
     1294 
     1295 
     1296 /* Transmit the I/O block and return to the caller */
     1297 
     1298 	if timeout = -1 then
     1299 	     call write_io_buffer ((0));
     1300 	else call write_io_buffer (P_chars_sent);
     1301 
     1302 	if code = 0 then				/* if write was successfull ... */
     1303 	     if (channel_info.device_type = HASP_PRINTER) then
     1304 						/* ... forms have changed */
     1305 		channel_info.forms = had.current_forms;
     1306 
     1307 RETURN_FROM_WRITE_RECORD:
     1308 	if io_buffer_ptr ^= null () then
     1309 	     if io_buffer_ptr ^= addr (io_buffer_space) then free io_buffer in (system_area);
     1310 
     1311 	P_code = code;
     1312 	return;
     1313 
     1314 /* Perform control operations on an I/O switch connected to a HASP workstation */
     1315 
     1316 hasp_workstation_control_before_open:
     1317      entry (P_iocb_ptr, P_order, P_info_ptr, P_code);
     1318 
     1319 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
     1320 	had_ptr = iocb_ptr -> iocb.attach_data_ptr;
     1321 	channel_info_ptr = had.channel_info_ptr;
     1322 
     1323 	order = P_order;
     1324 	info_ptr = P_info_ptr;
     1325 	code = 0;
     1326 	if (order = "set_event" | order = "set_event_channel") then
     1327 	     call hasp_workstation_control (P_iocb_ptr, P_order, P_info_ptr, P_code);
     1328 	else do;
     1329 	     call hcs_$tty_order (channel_info.devx, order, info_ptr, state, code);
     1330 	     P_code = code;
     1331 	end;
     1332 
     1333 	return;
     1334 
     1335 hasp_workstation_control:
     1336      entry (P_iocb_ptr, P_order, P_info_ptr, P_code);
     1337 
     1338 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
     1339 	had_ptr = iocb_ptr -> iocb.attach_data_ptr;
     1340 	channel_info_ptr = had.channel_info_ptr;
     1341 
     1342 	order = P_order;
     1343 	info_ptr = P_info_ptr;
     1344 	code = 0;
     1345 
     1346 
     1347 	if (order = "io_call") then do;
     1348 
     1349 /* io_call command interface:  translate the supplied info into an ordinary control order */
     1350 
     1351 	     if info_ptr = null () then do;		/* need the order name */
     1352 		P_code = error_table_$undefined_order_request;
     1353 		return;
     1354 	     end;
     1355 
     1356 	     order = info_ptr -> io_call_info.order_name;
     1357 	     info_ptr = null ();
     1358 	end;
     1359 
     1360 
     1361 	if (order = "runout") then do;
     1362 
     1363 /* Wait for all output to leave the FNP:  for HASP channels, we only wait for the output to leave the TTY channel and
     1364*   enter the multiplexer */
     1365 
     1366 	     write_status.output_pending = "1"b;	/* need do until */
     1367 
     1368 	     do while (write_status.output_pending);
     1369 
     1370 		call hcs_$tty_order (channel_info.devx, "write_status", addr (write_status), state, code);
     1371 		if state ^= 5 then code = error_table_$io_no_permission;
     1372 		if code ^= 0 then go to RETURN_FROM_CONTROL;
     1373 
     1374 		if write_status.output_pending then do;
     1375 		     event_wait_channel.n_channels = 1;
     1376 		     event_wait_channel.channel_id (1) = channel_info.event_channel;
     1377 		     call ipc_$block (addr (event_wait_channel), addr (local_event_wait_info), code);
     1378 		     if code ^= 0 then go to RETURN_FROM_CONTROL;
     1379 		end;
     1380 	     end;
     1381 	end;
     1382 
     1383 
     1384 	else if (order = "end_write_mode") then do;
     1385 
     1386 /* End a write operation: waits for all output to enter the multiplexer, then for a line printer or card punch, writes an
     1387*   EOF record, and, for a line printer, reset the forms to the default forms given in the attach description */
     1388 
     1389 	     if (channel_info.device_type = HASP_READER) then do;
     1390 		code = error_table_$invalid_write;
     1391 		go to RETURN_FROM_CONTROL;
     1392 	     end;
     1393 
     1394 	     if (channel_info.device_type = HASP_CONSOLE) then
     1395 		;				/* don't write an EOF record */
     1396 
     1397 	     else do;
     1398 		io_buffer_ptr = addr (TEMPLATE_HASP_EOF_RECORD);
     1399 		io_buffer_lth, io_buffer_used = length (TEMPLATE_HASP_EOF_RECORD);
     1400 		call write_io_buffer ((0));		/* send it */
     1401 		if code ^= 0 then go to RETURN_FROM_CONTROL;
     1402 		if channel_info.device_type = HASP_PRINTER then
     1403 						/* reset the switch to its default */
     1404 		     had.current_forms = had.default_forms;
     1405 		channel_info.forms = "";		/* reset to default forms */
     1406 	     end;
     1407 
     1408 	     call hasp_workstation_control (iocb_ptr, "runout", (null ()), code);
     1409 	end;
     1410 
     1411 
     1412 	else if (order = "set_forms") then do;
     1413 
     1414 /* Change the forms used for output on this switch until the next "end_write_mode" control order */
     1415 
     1416 	     if (info_ptr = null ()) then
     1417 		code = error_table_$null_info_ptr;
     1418 
     1419 	     else do;
     1420 		sti_ptr = info_ptr;
     1421 
     1422 		if set_forms_info.version ^= SET_FORMS_INFO_VERSION_1 then
     1423 		     code = error_table_$unimplemented_version;
     1424 
     1425 		else do;
     1426 		     had.current_forms = rtrim (set_forms_info.forms);
     1427 						/* strip trailing whitespace */
     1428 		     had.current_forms = translate (had.current_forms, UPPERCASE, LOWERCASE);
     1429 		     had.current_forms = translate (had.current_forms, had.translations.output);
     1430 		end;				/* convert to uppercase and proper character set */
     1431 	     end;
     1432 	end;
     1433 
     1434 
     1435 	else if (order = "read_status") then do;
     1436 
     1437 /* Indicate if input is available:  check local buffers before checking with ring-0 */
     1438 
     1439 	     if (info_ptr = null ()) then
     1440 		code = error_table_$null_info_ptr;
     1441 
     1442 	     else do;
     1443 		read_status_info.event_channel = channel_info.event_channel;
     1444 
     1445 		if (channel_info.held_input_ptr ^= null ()) then
     1446 		     read_status_info.input_available = "1"b;
     1447 						/* got some here */
     1448 
     1449 		else do;
     1450 		     call hcs_$tty_order (channel_info.devx, "read_status", info_ptr, state, code);
     1451 		     if state ^= 5 then code = error_table_$io_no_permission;
     1452 		end;
     1453 	     end;
     1454 	end;
     1455 
     1456 
     1457 	else if (order = "resetread") then do;
     1458 
     1459 /* Flush pending input:  throw out any input being held locally and then perform an appropriate "abort" control on the
     1460*   channel */
     1461 
     1462 	     if channel_info.held_input_ptr ^= null () then
     1463 		free channel_info.held_input_ptr -> held_input in (system_area);
     1464 	     channel_info.held_input_ptr = null ();
     1465 
     1466 	     call hcs_$tty_abort (channel_info.devx, (1), state, code);
     1467 	     if state ^= 5 then code = error_table_$io_no_permission;
     1468 	end;
     1469 
     1470 
     1471 	else if (order = "resetwrite") then do;
     1472 
     1473 /* Flush pending output:  perform the appropriate "abort" control order on the channel */
     1474 
     1475 	     call hcs_$tty_abort (channel_info.devx, (2), state, code);
     1476 	     if state ^= 5 then code = error_table_$io_no_permission;
     1477 	end;
     1478 
     1479 
     1480 	else if (order = "hangup_proc") then do;
     1481 
     1482 /* Caller supplies a procedure to be invoked when the channel used by this switch is hungup */
     1483 
     1484 	     if (info_ptr = null ()) then
     1485 		code = error_table_$null_info_ptr;
     1486 
     1487 	     else do;
     1488 		call ipc_$decl_ev_call_chn (channel_info.attach_event_channel, hangup_proc_info.procedure,
     1489 		     hangup_proc_info.data_ptr, hangup_proc_info.priority, code);
     1490 		if code = 0 then channel_info.attach_channel_is_call = "1"b;
     1491 	     end;
     1492 	end;
     1493 
     1494 
     1495 	else if (order = "get_channel_info") then do;
     1496 
     1497 /* Return the name and MCS device index of the channel attached via this switch */
     1498 
     1499 	     if (info_ptr = null ()) then code = error_table_$null_info_ptr;
     1500 
     1501 	     else if get_channel_info.version ^= tty_get_channel_info_version then
     1502 		code = error_table_$unimplemented_version;
     1503 
     1504 	     else do;
     1505 		get_channel_info.devx = channel_info.devx;
     1506 		get_channel_info.channel_name = channel_info.name;
     1507 	     end;
     1508 	end;
     1509 
     1510 
     1511 	else if (order = "select_device") then ;	/* select a specific output device: ignored */
     1512 
     1513 	else if (order = "reset") then ;		/* reset the switch to a well-known state: ignored */
     1514 
     1515 	else if (order = "set_event" | order = "set_event_channel") then do;
     1516 	     if channel_info.event_channel_assigned then call hcs_$delete_channel (channel_info.event_channel, code);
     1517 	     else if channel_info.event_channel_created then call ipc_$delete_ev_chn (channel_info.event_channel, code);
     1518 	     channel_info.event_channel = info_ptr -> event_channel;
     1519 	     call hcs_$tty_event (channel_info.devx, channel_info.event_channel, state, code);
     1520 	     if code ^= 0 then goto RETURN_FROM_CONTROL;
     1521 	     channel_info.event_channel_assigned = "0"b;
     1522 	     channel_info.event_channel_created = "0"b;
     1523 	end;
     1524 
     1525 	else if (order = "set_term_type") then do;
     1526 	     sttip = info_ptr;
     1527 	     if set_term_type_info.version ^= stti_version_1 then do;
     1528 		code = error_table_$unimplemented_version;
     1529 		goto RETURN_FROM_CONTROL;
     1530 	     end;
     1531 
     1532 	     ttd.version = ttd_version_3;
     1533 	     call ttt_info_$terminal_data (set_term_type_info.name, -1, 0, addr (ttd), code);
     1534 	     if code ^= 0 then goto RETURN_FROM_CONTROL;
     1535 	     if (ttd.tables.input_tr_ptr ^= null ()) then /* If no translation table, don't change */
     1536 		call set_translation (had.translations.input,
     1537 		     addr (ttd.tables.input_tr_ptr -> cv_trans_struc.cv_trans.value),
     1538 		     dimension (ttd.tables.input_tr_ptr -> cv_trans_struc.cv_trans.value, 1));
     1539 	     if (ttd.tables.output_tr_ptr ^= null ()) then do;
     1540 		call set_translation (had.translations.output,
     1541 		     addr (ttd.tables.output_tr_ptr -> cv_trans_struc.cv_trans.value),
     1542 		     dimension (ttd.tables.output_tr_ptr -> cv_trans_struc.cv_trans.value, 1));
     1543 		had.translations.space = translate (ASCII_SPACE, had.translations.output);
     1544 	     end;					/* This should not affect operation of channel.  Its only */
     1545 						/* effect should be to set up the tcb with terminal type so */
     1546 						/* stty can see it. */
     1547 	     call hcs_$tty_order (channel_info.devx, "set_terminal_data", addr (ttd), state, code);
     1548 	     if state ^= 5 then code = error_table_$io_no_permission;
     1549 	end;
     1550 
     1551 	else if (order = "set_line_type") then do;
     1552 
     1553 	     if (info_ptr = null ()) then code = error_table_$null_info_ptr;
     1554 
     1555 	     else if line_type ^= LINE_HASP_OPR | channel_info.device_type ^= HASP_CONSOLE then
     1556 		code = error_table_$incorrect_device_type;
     1557 	     else code = 0;				/* basically a nop */
     1558 	end;
     1559 
     1560 	else if (order = "read_record_timeout") then do;
     1561 	     timeout_info_ptr = info_ptr;
     1562 	     input_timeout_info.characters_read = 0;
     1563 	     call hasp_workstation_read_record_timed (P_iocb_ptr, input_timeout_info.buffer_pointer,
     1564 		input_timeout_info.buffer_length, input_timeout_info.characters_read, code,
     1565 		input_timeout_info.timeout);
     1566 	end;
     1567 
     1568 	else if (order = "write_record_timeout") then do;
     1569 	     timeout_info_ptr = info_ptr;
     1570 	     call hasp_workstation_write_record_timed (P_iocb_ptr, output_timeout_info.buffer_pointer,
     1571 		output_timeout_info.buffer_length, code, output_timeout_info.timeout,
     1572 		output_timeout_info.characters_written);
     1573 	end;					/* wouldn't do any good to send password mask */
     1574 
     1575 	else if (order = "assign_to_user_process") then do;
     1576 	     if info_ptr = null () then
     1577 		code = error_table_$null_info_ptr;
     1578 	     else do;
     1579 		call hcs_$tty_detach_new_proc (channel_info.devx, pid, state, code);
     1580 		if state ^= 5 then code = error_table_$io_no_permission;
     1581 	     end;
     1582 	end;
     1583 
     1584 	else if (order = "printer_off") then code = 0;
     1585 	else if (order = "printer_on") then code = 0;
     1586 
     1587 	else if (order = "state") then do;
     1588 	     call hcs_$tty_state (channel_info.devx, temp_state, (0));
     1589 	     info_ptr -> based_state = temp_state;
     1590 	     code = 0;
     1591 	end;
     1592 
     1593 	else if (order = "detach_user_process") then do;
     1594 	     call hcs_$tty_detach (channel_info.devx, detachflag, temp_state, code);
     1595 	     if temp_state ^= 5 then code = error_table_$io_no_permission;
     1596 	end;
     1597 
     1598 	else do;
     1599 
     1600 /* Unrecognized control order:  pass it on to MCS */
     1601 
     1602 	     call hcs_$tty_order (channel_info.devx, order, info_ptr, state, code);
     1603 	     if order ^= "listen" then
     1604 		if state ^= 5 then code = error_table_$io_no_permission;
     1605 	end;
     1606 
     1607 RETURN_FROM_CONTROL:
     1608 	P_code = code;
     1609 	return;
     1610 
     1611 /* Change modes:  modes operation a noop */
     1612 
     1613 hasp_workstation_modes:
     1614      entry (P_iocb_ptr, P_new_modes, P_old_modes, P_code);
     1615 
     1616 	P_old_modes = "";				/* no modes are reflected to caller */
     1617 	P_code = 0;
     1618 	return;
     1619 
     1620 /* Remove an I/O switch which might be attached to the channel:  if this switch is the only one attached to the channel,
     1621*   the channel itself is detached */
     1622 
     1623 cleanup_attachment:
     1624      procedure (P_code);
     1625 
     1626 dcl  P_code fixed binary (35) parameter;		/* a parameter to allow callers to ignore it */
     1627 
     1628 	P_code = 0;
     1629 
     1630 	if had_ptr ^= null () then do;		/* there is an I/O switch */
     1631 
     1632 	     if had.channel_info_ptr ^= null () then do;	/* there is knowledge of the channel */
     1633 
     1634 		channel_info_ptr = had.channel_info_ptr;
     1635 
     1636 		if (had.chain.previous = null ()) then
     1637 		     channel_info.hads.first = had.chain.next;
     1638 		else had.chain.previous -> had.chain.next = had.chain.next;
     1639 
     1640 		if (had.chain.next = null ()) then
     1641 		     channel_info.hads.last = had.chain.previous;
     1642 		else had.chain.next -> had.chain.previous = had.chain.previous;
     1643 
     1644 		if (channel_info.hads.first = null ()) then call release_channel ();
     1645 						/* last switch connected to the channel */
     1646 	     end;
     1647 
     1648 	     if had.top_of_page_sequence_ptr ^= null () then
     1649 		free had.top_of_page_sequence_ptr -> slew_sequence in (system_area);
     1650 
     1651 	     if had.inside_page_sequence_ptr ^= null () then
     1652 		free had.inside_page_sequence_ptr -> slew_sequence in (system_area);
     1653 
     1654 	     if had.outside_page_sequence_ptr ^= null () then
     1655 		free had.outside_page_sequence_ptr -> slew_sequence in (system_area);
     1656 
     1657 	     free had in (system_area);
     1658 	     had_ptr = null ();			/* just to be sure */
     1659 	end;
     1660 
     1661 	return;
     1662 
     1663 
     1664 
     1665 /* Internal to cleanup_attachment:  release the knowledge associated with a TTY channel */
     1666 
     1667 release_channel:
     1668 	procedure ();
     1669 
     1670 	     if channel_info.devx ^= -1 then call hcs_$tty_detach (channel_info.devx, (0), (0), P_code);
     1671 
     1672 	     if channel_info.event_channel ^= -1 then
     1673 		if channel_info.event_channel_assigned then
     1674 		     call hcs_$delete_channel (channel_info.event_channel, (0));
     1675 		else if channel_info.event_channel_created then
     1676 		     call ipc_$delete_ev_chn (channel_info.event_channel, (0));
     1677 
     1678 	     if channel_info.attached then do;		/* give the channel back to the answering service */
     1679 		if channel_info.attach_channel_is_call then
     1680 		     call ipc_$decl_ev_wait_chn (channel_info.attach_event_channel, (0));
     1681 		if ^channel_info.suppress_dial_manager then do;
     1682 		     dma.version = dial_manager_arg_version_2;
     1683 		     dma.dial_channel = channel_info.attach_event_channel;
     1684 		     dma.channel_name = channel_info.name;
     1685 		     dma.dial_qualifier, dma.dial_out_destination, dma.reservation_string = "";
     1686 		     call dial_manager_$release_channel (addr (dma), (0));
     1687 		end;
     1688 		channel_info.attached = "0"b;		/* assume success */
     1689 	     end;
     1690 
     1691 	     if channel_info.attach_event_channel ^= -1 then
     1692 		call ipc_$delete_ev_chn (channel_info.attach_event_channel, (0));
     1693 
     1694 	     if (channel_info.chain.previous = null ()) then
     1695 		first_channel_info_ptr = channel_info.chain.next;
     1696 	     else channel_info.chain.previous -> channel_info.chain.next = channel_info.chain.next;
     1697 
     1698 	     if (channel_info.chain.next = null ()) then
     1699 		last_channel_info_ptr = channel_info.chain.previous;
     1700 	     else channel_info.chain.next -> channel_info.chain.previous = channel_info.chain.previous;
     1701 
     1702 	     free channel_info in (system_area);
     1703 	     channel_info_ptr = null ();
     1704 
     1705 	     return;
     1706 
     1707 	end release_channel;
     1708 
     1709      end cleanup_attachment;
     1710 
     1711 /* Wrapper to protect against errors while IPS interrupts are masked */
     1712 
     1713 any_other_handler:
     1714      procedure () options (non_quick);
     1715 
     1716 dcl  1 fatal_error_info aligned,
     1717        2 version fixed bin,
     1718        2 status_code fixed bin (35);
     1719 
     1720 	if get_group_id_ () = "Initializer.SysDaemon.z" then do;
     1721 
     1722 	     if ips_mask then call hcs_$reset_ips_mask (ips_mask, ips_mask);
     1723 	     ips_mask = ""b;
     1724 
     1725 	     call continue_to_signal_ ((0));		/* hope to get an asdump */
     1726 	end;
     1727 	else do;
     1728 	     fatal_error_info.version = 0;
     1729 	     fatal_error_info.status_code = error_table_$unable_to_do_io;
     1730 
     1731 	     call terminate_process_ ("fatal_error", addr (fatal_error_info));
     1732 	end;
     1733 
     1734 	return;
     1735 
     1736      end any_other_handler;
     1737 
     1738 
     1739 
     1740 /* Abort a call to the attach entry:  print an error message if requested */
     1741 
     1742 abort_attachment:
     1743      procedure () options (variable, non_quick);
     1744 
     1745 dcl  the_code fixed binary (35) based (the_code_ptr);
     1746 dcl  the_code_ptr pointer;
     1747 
     1748 dcl  caller_message character (256);
     1749 
     1750 	call cu_$arg_ptr (1, the_code_ptr, (0), (0));
     1751 
     1752 	if loud_sw then do;				/* an error message is requested */
     1753 	     call ioa_$general_rs (cu_$arg_list_ptr (), 2, 3, caller_message, (0), "1"b, "0"b);
     1754 	     call com_err_ (the_code, NAME, "For switch ^a: ^a", iocb_ptr -> iocb.name, caller_message);
     1755 	end;
     1756 
     1757 	call cleanup_attachment ((0));		/* get rid of anything that was accomplished */
     1758 
     1759 	if the_code = 0 then
     1760 	     code = error_table_$action_not_performed;
     1761 	else code = the_code;			/* save the error code */
     1762 
     1763 	go to RETURN_FROM_ATTACH;
     1764 
     1765      end abort_attachment;
     1766 
     1767 /* Fetch the next argument from the attach options and validate that it is a non-null character string */
     1768 
     1769 get_string_argument:
     1770      procedure () returns (character (*));
     1771 
     1772 dcl  option_name character (32);
     1773 
     1774 	option_name = argument;			/* about to move on to the next one */
     1775 
     1776 	if (argument_idx = hbound (P_attach_options, 1)) then
     1777 	     call abort_attachment (error_table_$noarg, "Character string following ""^a"".", option_name);
     1778 
     1779 	argument_idx = argument_idx + 1;
     1780 
     1781 	argument_ptr = addcharno (addr (P_attach_options (argument_idx)), 4);
     1782 	argument_lth = length (P_attach_options (argument_idx));
     1783 
     1784 	if (argument = "") then
     1785 	     call abort_attachment (0, "Character string following ""^a"" must be non-null.", option_name);
     1786 
     1787 	return (argument);
     1788 
     1789      end get_string_argument;
     1790 
     1791 
     1792 
     1793 /* Fetch the next argument from the attach options and verify that it is a number */
     1794 
     1795 get_numeric_argument:
     1796      procedure () returns (fixed binary (35));
     1797 
     1798 dcl  option_name character (32);
     1799 dcl  the_value fixed binary (35);
     1800 
     1801 	option_name = argument;			/* about to move on to the next one */
     1802 
     1803 	if (argument_idx = hbound (P_attach_options, 1)) then
     1804 	     call abort_attachment (error_table_$noarg, "Number following ""^a"".", option_name);
     1805 
     1806 	argument_idx = argument_idx + 1;
     1807 
     1808 	argument_ptr = addcharno (addr (P_attach_options (argument_idx)), 4);
     1809 	argument_lth = length (P_attach_options (argument_idx));
     1810 
     1811 	the_value = cv_dec_check_ (argument, code);
     1812 
     1813 	if code ^= 0 then
     1814 	     call abort_attachment (error_table_$bad_conversion, """^a"" must be followed by a number; not ""^a"".",
     1815 		option_name, argument);
     1816 
     1817 	return (the_value);
     1818 
     1819      end get_numeric_argument;
     1820 
     1821 init_read:
     1822      procedure;
     1823 
     1824 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
     1825 	had_ptr = iocb_ptr -> iocb.attach_data_ptr;
     1826 	channel_info_ptr = had.channel_info_ptr;
     1827 	return;
     1828 
     1829      end init_read;
     1830 
     1831 
     1832 
     1833 
     1834 /* Set input/output translation to the given string:  If the string supplied is less than 512 characters, the out of range
     1835*   characters are translated to NULs */
     1836 
     1837 set_translation:
     1838      procedure (P_translate_table, P_translate_string_ptr, P_translate_string_lth);
     1839 
     1840 dcl  P_translate_table character (512) aligned parameter;	/* translate table */
     1841 dcl  P_translate_string_ptr pointer parameter;		/* -> translation string */
     1842 dcl  P_translate_string_lth fixed binary (21) parameter;	/* length of translation string */
     1843 
     1844 dcl  translate_string character (P_translate_string_lth) based (P_translate_string_ptr);
     1845 
     1846 	P_translate_table = translate_string;
     1847 
     1848 	if length (translate_string) < length (P_translate_table) then
     1849 	     substr (P_translate_table, (length (translate_string) + 1)) =
     1850 		copy (NUL, (length (P_translate_table) - length (translate_string)));
     1851 
     1852 	return;
     1853 
     1854      end set_translation;
     1855 
     1856 /* Parse a slew control sequence specification:  the specification is of the form
     1857*   Tn:Tn:Tn:Tn:...
     1858*   where "n" is the numeric value and T represents the type of operation to perform.  T may be either "c" for skip to
     1859*   channel "n", or "s" for space "n" lines */
     1860 
     1861 parse_slew_sequence:
     1862      procedure (P_slew_sequence_ptr);
     1863 
     1864 dcl  P_slew_sequence_ptr pointer;			/* set -> slew_sequence constructed */
     1865 
     1866 dcl  (option_name, operation) character (32);
     1867 dcl  (start, next_colon) fixed binary (21);
     1868 dcl  the_number fixed binary (35);
     1869 dcl  next_op fixed binary;
     1870 
     1871 
     1872 	option_name = argument;			/* remember it for error messages */
     1873 
     1874 	character_value = get_string_argument ();	/* insure specification is present */
     1875 
     1876 	start = 1;
     1877 	slew_sequence_n_ops = 0;			/* haven't found any yet */
     1878 
     1879 
     1880 /* Count and verify syntax of each operation */
     1881 
     1882 	do while (start <= length (argument));
     1883 
     1884 	     next_colon = index (substr (argument, start), ":");
     1885 	     if next_colon = 0 then			/* rest of argument is this sequence */
     1886 		next_colon = length (argument) - start + 2;
     1887 
     1888 	     operation = ltrim (rtrim (substr (argument, start, (next_colon - 1))));
     1889 
     1890 	     if (operation = "") then
     1891 		call abort_attachment (0, "All slewing operations must be non-null: ""^a"" for ""^a"".", argument,
     1892 		     option_name);
     1893 
     1894 	     if (substr (operation, 1, 1) ^= "c") & (substr (operation, 1, 1) ^= "s") then
     1895 		call abort_attachment (0, "Invalid slewing operation ""^a"" specified in ""^a"" for ""^a"".",
     1896 		     substr (operation, 1, 1), argument, option_name);
     1897 
     1898 	     the_number = cv_dec_check_ (substr (operation, 2), code);
     1899 	     if code ^= 0 then
     1900 		call abort_attachment (error_table_$bad_conversion, """^a"" in ""^a"" for ""^a"".",
     1901 		     substr (operation, 2), argument, option_name);
     1902 
     1903 	     if ((substr (operation, 1, 1) = "c") & ((the_number < 1) | (the_number > 12)))
     1904 		| ((substr (operation, 1, 1) = "s") & ((the_number > 15) | (the_number < 0))) then
     1905 		call abort_attachment (0, "Invalid value for slewing operation ""^a"" in ""^a"" for ""^a"".",
     1906 		     operation, argument, option_name);
     1907 
     1908 	     slew_sequence_n_ops = slew_sequence_n_ops + 1;
     1909 						/* it's OK */
     1910 	     start = start + next_colon;
     1911 	end;
     1912 
     1913 
     1914 /* Specification is valid:  allocate the structure and fill it in */
     1915 
     1916 	on condition (area)
     1917 	     call abort_attachment (error_table_$noalloc, "Interpreting ""^a"" for ""^a"".", argument, option_name);
     1918 
     1919 	allocate slew_sequence in (system_area) set (slew_sequence_ptr);
     1920 
     1921 	start = 1;
     1922 	next_op = 0;
     1923 
     1924 	do while (start <= length (argument));
     1925 
     1926 	     next_colon = index (substr (argument, start), ":");
     1927 	     if next_colon = 0 then			/* rest of argument is this sequence */
     1928 		next_colon = length (argument) - start + 2;
     1929 
     1930 	     operation = ltrim (rtrim (substr (argument, start, (next_colon - 1))));
     1931 	     next_op = next_op + 1;
     1932 
     1933 	     if (substr (operation, 1, 1) = "c") then
     1934 		slew_sequence.ops (next_op).skip_to_channel = "1"b;
     1935 	     else slew_sequence.ops (next_op).skip_to_channel = "0"b;
     1936 
     1937 	     the_number = cv_dec_check_ (substr (operation, 2), (0));
     1938 	     slew_sequence.ops (next_op).count_or_channel = the_number;
     1939 
     1940 	     start = start + next_colon;
     1941 	end;
     1942 
     1943 	P_slew_sequence_ptr = slew_sequence_ptr;	/* return results to caller */
     1944 
     1945 	return;
     1946 
     1947      end parse_slew_sequence;
     1948 
     1949 /* Read an I/O buffer:  block until some data arrives and perform a single read from ring-0 */
     1950 
     1951 read_io_buffer:
     1952      procedure ();
     1953 
     1954 	io_buffer_read = 0;				/* need do until here */
     1955 
     1956 	do while (io_buffer_read = 0);
     1957 
     1958 	     read_status.input_available = "0"b;	/* again, no do until */
     1959 
     1960 	     if timeout ^= 0 then			/* timeout of zero means no blocking */
     1961 		do while (^read_status.input_available);
     1962 
     1963 		call hcs_$tty_order (channel_info.devx, "read_status", addr (read_status), state, code);
     1964 		if state ^= 5 then code = error_table_$io_no_permission;
     1965 		if code ^= 0 then return;		/* punt! */
     1966 
     1967 		if ^read_status.input_available then do;/* need to wait for some input */
     1968 		     event_wait_channel.n_channels = 1;
     1969 		     event_wait_channel.channel_id (1) = channel_info.event_channel;
     1970 		     if timeout > 0 then
     1971 			call timer_manager_$alarm_wakeup (stop_time, ABSOLUTE_MICROSECONDS,
     1972 			     channel_info.event_channel);
     1973 		     call ipc_$block (addr (event_wait_channel), addr (local_event_wait_info), code);
     1974 		     if timeout > 0 then call timer_manager_$reset_alarm_wakeup (channel_info.event_channel);
     1975 		     if code ^= 0 then return;
     1976 		     if timeout > 0 then
     1977 			if clock () > stop_time then read_status.input_available = "1"b;
     1978 						/* Force drop out of loop */
     1979 		end;
     1980 	     end;
     1981 
     1982 	     call hcs_$tty_read (channel_info.devx, addr (io_buffer), (0), io_buffer_lth, io_buffer_read, state, code);
     1983 	     if state ^= 5 then code = error_table_$io_no_permission;
     1984 	     if code ^= 0 then return;
     1985 	     if io_buffer_read = 0 then
     1986 		if timeout >= 0 then do;
     1987 		     if (clock () > stop_time) & channel_info.block_on_io then code = error_table_$timeout;
     1988 		     return;
     1989 		end;
     1990 	end;
     1991 
     1992 	return;
     1993 
     1994      end read_io_buffer;
     1995 
     1996 /* Generate the SRCB for this record:  for the console or a punch, the contents of the record's SRCB is fixed; for a line
     1997*   printer, the contents of the SRCB are determined from the slew_control field of the terminal_io_record.  For the
     1998*   printer, the type of slewing requested might not be able to be satisfied by one SRCB; if this occurs, state information
     1999*   is saved to allow generation of as many null records with appropriate SRCBs as necessary */
     2000 
     2001 generate_record_srcb:
     2002      procedure ();
     2003 
     2004 
     2005 	more_srcbs_needed = "0"b;			/* assume that only one SRCB needed for this slew */
     2006 
     2007 
     2008 	if (channel_info.device_type = HASP_PRINTER) then do;
     2009 
     2010 /* Line printer:  start interpretation of slew_control */
     2011 
     2012 	     if (terminal_io_record.slew_type = SLEW_BY_COUNT) then local_slew_count = terminal_io_record.slew_count;
     2013 
     2014 	     else if (terminal_io_record.slew_type = SLEW_TO_CHANNEL) then ;
     2015 						/* given channel stop: only need one SRCB for this type */
     2016 
     2017 	     else do;				/* skip to top of some type of page */
     2018 		n_last_opcode = 0;			/* haven't done anything yet */
     2019 		if (terminal_io_record.slew_type = SLEW_TO_TOP_OF_PAGE) then
     2020 		     slew_sequence_ptr = had.top_of_page_sequence_ptr;
     2021 		else if (terminal_io_record.slew_type = SLEW_TO_INSIDE_PAGE) then
     2022 		     slew_sequence_ptr = had.inside_page_sequence_ptr;
     2023 		else if (terminal_io_record.slew_type = SLEW_TO_OUTSIDE_PAGE) then
     2024 		     slew_sequence_ptr = had.outside_page_sequence_ptr;
     2025 	     end;
     2026 
     2027 	     call generate_next_srcb ();		/* actually generate the SRCB */
     2028 	end;
     2029 
     2030 
     2031 	else do;
     2032 
     2033 /* The console or a punch:  generate a fixed SRCB */
     2034 
     2035 	     call add_character_to_io_buffer (NUL);
     2036 	     srcb_ptr = addcharno (addr (io_buffer), io_buffer_used - 1);
     2037 
     2038 	     if (channel_info.device_type = HASP_CONSOLE) then srcb = HASP_CONSOLE_SRCB;
     2039 	     else if (channel_info.device_type = HASP_PUNCH) then srcb = TEMPLATE_HASP_CARD_SRCB;
     2040 	end;
     2041 
     2042 	return;
     2043 
     2044      end generate_record_srcb;
     2045 
     2046 /* Generate next SRCB:  given the current local state, construct the next SRCB character required to perform the request
     2047*   slewing operation; update the local state for the next call (if any) */
     2048 
     2049 generate_next_srcb:
     2050      procedure ();
     2051 
     2052 	call add_character_to_io_buffer (NUL);		/* make the SRCB and initialize it to all zeroes */
     2053 	srcb_ptr = addcharno (addr (io_buffer), io_buffer_used - 1);
     2054 
     2055 	hasp_printer_srcb.mbo1 = "1"b;		/* SRCB now specifies space zero lines */
     2056 
     2057 	if (terminal_io_record.slew_type = SLEW_BY_COUNT) then do;
     2058 	     hasp_printer_srcb.number = min (local_slew_count, HASP_MAX_SLEW_COUNT);
     2059 	     local_slew_count = local_slew_count - hasp_printer_srcb.number;
     2060 	     more_srcbs_needed = (local_slew_count > 0);
     2061 	end;
     2062 
     2063 	else if (terminal_io_record.slew_type = SLEW_TO_CHANNEL) then do;
     2064 						/* skip to specified channel stop */
     2065 	     hasp_printer_srcb.skip_to_channel = "1"b;
     2066 	     hasp_printer_srcb.number = terminal_io_record.slew_count;
     2067 	     more_srcbs_needed = "0"b;		/* only need one SRCB to do the job */
     2068 	end;
     2069 
     2070 	else do;					/* special slewing requested: interpret attach description */
     2071 	     n_last_opcode = n_last_opcode + 1;
     2072 	     hasp_printer_srcb.skip_to_channel = slew_sequence.ops (n_last_opcode).skip_to_channel;
     2073 	     hasp_printer_srcb.number = slew_sequence.ops (n_last_opcode).count_or_channel;
     2074 	     more_srcbs_needed = (slew_sequence.n_ops > n_last_opcode);
     2075 	end;
     2076 
     2077 	return;
     2078 
     2079      end generate_next_srcb;
     2080 
     2081 
     2082 
     2083 /* Add the specified character to the I/O buffer for later output */
     2084 
     2085 add_character_to_io_buffer:
     2086      procedure (P_character);
     2087 
     2088 dcl  P_character character (1) parameter;
     2089 
     2090 	if io_buffer_used = length (io_buffer) then	/* no room in buffer */
     2091 	     go to WRITE_RECORD_BAD_DATA;
     2092 
     2093 	io_buffer_used = io_buffer_used + 1;
     2094 
     2095 	substr (io_buffer, io_buffer_used, 1) = P_character;
     2096 
     2097 	return;
     2098 
     2099      end add_character_to_io_buffer;
     2100 
     2101 /* Write an I/O buffer:  blocks until the entire buffer has been taken by ring-0 MCS */
     2102 
     2103 write_io_buffer:
     2104      procedure (transmitted);
     2105 
     2106 dcl  (transmitted, sent_on_call) fixed binary (21);
     2107 
     2108 /* First see if any output from an interrupted timed write_record
     2109*   is sitting in ring 0 and must be flushed.  The flushing is done at the last
     2110*   possible moment (now) to lessen the chance of flushing output that was ahead
     2111*   of the interrupted record, but still in ring 0. */
     2112 
     2113 	transmitted = 0;
     2114 
     2115 	if channel_info.output_interrupted then do;
     2116 	     call hcs_$tty_abort (channel_info.devx, 2, state, code);
     2117 	     if state ^= 5 then code = error_table_$io_no_permission;
     2118 	     if code ^= 0 then return;
     2119 	     channel_info.output_interrupted = "0"b;
     2120 	end;
     2121 
     2122 	do while (transmitted < io_buffer_used);
     2123 
     2124 	     call hcs_$tty_write (channel_info.devx, addcharno (addr (io_buffer), transmitted), (0),
     2125 		(io_buffer_used - transmitted), sent_on_call, state, code);
     2126 	     if state ^= 5 then code = error_table_$io_no_permission;
     2127 	     if code ^= 0 then return;		/* punt! */
     2128 
     2129 	     transmitted = transmitted + sent_on_call;	/* got some more through */
     2130 
     2131 	     if transmitted < io_buffer_used then do;	/* not done yet: wait 'till we should try again */
     2132 		call hcs_$tty_order (channel_info.devx, "write_status", addr (write_status), state, code);
     2133 		if state ^= 5 then code = error_table_$io_no_permission;
     2134 		if code ^= 0 then return;		/* punt! */
     2135 
     2136 		if write_status.output_pending then do; /* must really and truly wait */
     2137 		     if timeout = 0			/* Zero timeout means never block */
     2138 			| (timeout > 0 & clock () > stop_time) then do;
     2139 						/* Really timed out */
     2140 			if transmitted > 0 then channel_info.output_interrupted = "1"b;
     2141 			if channel_info.block_on_io then code = error_table_$timeout;
     2142 						/* non-block code is not interested in timeouts */
     2143 			return;
     2144 		     end;
     2145 		     event_wait_channel.n_channels = 1;
     2146 		     event_wait_channel.channel_id (1) = channel_info.event_channel;
     2147 		     call timer_manager_$alarm_wakeup (1, RELATIVE_SECONDS, event_wait_channel.channel_id (1));
     2148 		     if timeout > 0 then
     2149 			call timer_manager_$alarm_wakeup (stop_time, ABSOLUTE_MICROSECONDS,
     2150 			     channel_info.event_channel);
     2151 		     call ipc_$block (addr (event_wait_channel), addr (local_event_wait_info), code);
     2152 		     call timer_manager_$reset_alarm_wakeup (channel_info.event_channel);
     2153 		     if code ^= 0 then return;	/* punt! */
     2154 		end;
     2155 	     end;
     2156 	end;
     2157 
     2158 	return;					/* this return taken only on success */
     2159 
     2160      end write_io_buffer;
     2161 
  1     1 /* BEGIN INCLUDE FILE ... terminal_io_record.incl.pl1 */
  1     2 /* Created:  November 1979 by G. Palter */
  1     3 /* Modified: 26 March 1982 by G. Palter to make the structure more compatible with use of the like attribute */
  1     4 
  1     5 
  1     6 /* Record format used by I/O modules designed for communcation with remote I/O daemon stations */
  1     7 
  1     8 dcl 1 terminal_io_record aligned based (terminal_io_record_ptr),
  1     9       2 header,
  1    10         3 version fixed binary,
  1    11         3 device_type fixed binary,			/* type of device sending/receiving this record --
  1    12*						   reader/printer/punch/teleprinter */
  1    13         3 slew_control,				/* slew control data: used for printer and teleprinter only */
  1    14 	4 slew_type fixed binary (18) unaligned unsigned,	/* type of slewing operation before/after this line --
  1    15*						   by-count/top-of-form/inside-page/outside-page/to-channel */
  1    16 	4 slew_count fixed binary (18) unaligned unsigned,/* # of lines if by count; channel # if to channel */
  1    17         3 flags,
  1    18 	4 binary bit (1) unaligned,			/* ON => data in record should be written in binary mode */
  1    19 	4 preslew bit (1) unaligned,			/* ON => perform above slew before printing data;
  1    20*						   OFF => perform above slew after printing data */
  1    21 	4 pad bit (34) unaligned,
  1    22         3 element_size fixed binary,			/* # of bits in a data element */
  1    23         3 n_elements fixed binary (24),			/* # of elements in the record */
  1    24       2 data,					/* force word alignment */
  1    25         3 bits (terminal_io_record_n_elements refer (terminal_io_record.n_elements))
  1    26 	  bit (terminal_io_record_element_size refer (terminal_io_record.element_size)) unaligned;
  1    27 
  1    28 dcl  terminal_io_record_ptr pointer;
  1    29 
  1    30 dcl  terminal_io_record_element_size fixed binary;	/* used for allocating terminal_io_record structures */
  1    31 dcl  terminal_io_record_n_elements fixed binary (24);
  1    32 
  1    33 
  1    34 /* Manifest constants */
  1    35 
  1    36 dcl  terminal_io_record_version_1 fixed binary static options (constant) initial (1);
  1    37 
  1    38 dcl (TELEPRINTER_DEVICE	initial (1),
  1    39      READER_DEVICE		initial (2),
  1    40      PRINTER_DEVICE		initial (3),
  1    41      PUNCH_DEVICE		initial (4))
  1    42 	fixed binary static options (constant);
  1    43 
  1    44 dcl (SLEW_BY_COUNT		initial (1),
  1    45      SLEW_TO_TOP_OF_PAGE	initial (2),
  1    46      SLEW_TO_INSIDE_PAGE	initial (3),		/* skip to top of next inside page (head sheet) */
  1    47      SLEW_TO_OUTSIDE_PAGE	initial (4),		/* skip to top of next outside page (tail sheet) */
  1    48      SLEW_TO_CHANNEL	initial (5))		/* skip to specified channel stop */
  1    49 	fixed binary static options (constant);
  1    50 
  1    51 
  1    52 /* Data in record as a character string (terminal_io_record.element_size = 9) */
  1    53 
  1    54 dcl  terminal_io_record_data_chars character (terminal_io_record.n_elements) unaligned
  1    55 	based (addr (terminal_io_record.bits));
  1    56 
  1    57 dcl  terminal_io_record_data_chars_varying_max_len fixed binary (21);  /* Set this before using the varying string. */
  1    58 dcl  terminal_io_record_data_chars_varying character (terminal_io_record_data_chars_varying_max_len) varying
  1    59 	based (addr (terminal_io_record.n_elements));	/* varying string consists of length and data */
  1    60 
  1    61 
  1    62 /* Data in record as a bit string (terminal_io_record.element_size = 1) */
  1    63 
  1    64 dcl terminal_io_record_data_bits bit (terminal_io_record.n_elements) unaligned based (addr (terminal_io_record.bits));
  1    65 
  1    66 /* END INCLUDE FILE ... terminal_io_record.incl.pl1 */
     2162 
     2163 
  2     1 /* BEGIN INCLUDE FILE ... hasp_device_data.incl.pl1 */
  2     2 /* Created:  November 1979 by G. Palter */
  2     3 
  2     4 /* HASP device types */
  2     5 
  2     6 dcl (HASP_CONSOLE		initial (1),		/* operator's console */
  2     7      HASP_READER		initial (2),
  2     8      HASP_PRINTER		initial (3),
  2     9      HASP_PUNCH		initial (4))
  2    10 	fixed binary static options (constant);
  2    11 
  2    12 
  2    13 /* Name of each type of device as used by the remote I/O daemon software */
  2    14 
  2    15 dcl  HASP_DEVICE_NAMES (4) character (32) static options (constant) initial ("teleprinter", "reader", "printer", "punch");
  2    16 
  2    17 
  2    18 /* Maximum record length for each type of device */
  2    19 
  2    20 dcl  HASP_MAX_DEVICE_RECORD_LTHS (4) fixed binary (21) static options (constant) initial (80, 80, 132, 80);
  2    21 
  2    22 /* END INCLUDE FILE ... hasp_device_data.incl.pl1 */
     2164 
     2165 
  3     1 /* BEGIN INCLUDE FILE ... hasp_srcb_scb_bytes.incl.pl1 */
  3     2 /* Created:  October 1979 by G. Palter */
  3     3 
  3     4 /* HASP End-Of-File record */
  3     5 
  3     6 dcl 1 TEMPLATE_HASP_EOF_RECORD_BITS aligned static options (constant),
  3     7     2 srcb bit (9) unaligned initial ("200"b3),		/* SRCB -- 200-bit is always ON */
  3     8     2 eor_scb bit (9) unaligned initial ("000"b3);	/* SCB -- end of record */
  3     9 
  3    10 dcl TEMPLATE_HASP_EOF_RECORD character (2) aligned based (addr (TEMPLATE_HASP_EOF_RECORD_BITS));
  3    11 
  3    12 
  3    13 /* HASP Sub-Record Control Byte (SRCB) -- operator's console */
  3    14 
  3    15 dcl  HASP_CONSOLE_SRCB_BITS bit (9) aligned static options (constant) initial ("200"b3);
  3    16 dcl  HASP_CONSOLE_SRCB character (1) aligned based (addr (HASP_CONSOLE_SRCB_BITS));
  3    17 
  3    18 
  3    19 /* HASP Sub-Record Control Byte (SRCB) -- reader/punch */
  3    20 
  3    21 dcl 1 hasp_card_srcb_byte unaligned based (hasp_card_srcb_byte_ptr),
  3    22     2 pad1 bit (1) unaligned,				/* supplied by MCS */
  3    23     2 mbo1 bit (1) unaligned,				/* always ON */
  3    24     2 count_units fixed binary (2) unaligned unsigned,	/* SCB count units: 0 => 1; 1 => 2; 2 => 4 */
  3    25     2 binary bit (1) unaligned,			/* ON => binary data record */
  3    26     2 mbz1 bit (4) unaligned;				/* always OFF */
  3    27 
  3    28 dcl  hasp_card_srcb_byte_ptr pointer;
  3    29 
  3    30 dcl 1 TEMPLATE_HASP_CARD_SRCB_BITS aligned static options (constant),
  3    31     2 pad1 bit (1) unaligned initial ("0"b),
  3    32     2 mbo1 bit (1) unaligned initial ("1"b),
  3    33     2 count_units fixed binary (2) unaligned unsigned initial (0),	/* SCB counts single characters */
  3    34     2 binary bit (1) unaligned initial ("0"b),		/* not binary card */
  3    35     2 mbz1 bit (4) unaligned initial ("0000"b);
  3    36 
  3    37 dcl  TEMPLATE_HASP_CARD_SRCB character (1) aligned based (addr (TEMPLATE_HASP_CARD_SRCB_BITS));
  3    38 
  3    39 
  3    40 /* HASP Sub-Record Control Byte (SRCB) -- printer */
  3    41 
  3    42 dcl 1 hasp_printer_srcb_byte unaligned based (hasp_printer_srcb_byte_ptr),
  3    43     2 pad1 bit (1) unaligned,				/* supplied by MCS */
  3    44     2 mbo1 bit (1) unaligned,				/* always ON */
  3    45     2 mbz1 bit (1) unaligned,				/* always OFF */
  3    46     2 prespace bit (1) unaligned,			/* ON => pre-spacing; OFF => post-spacing */
  3    47     2 skip_to_channel bit (1) unaligned,		/* ON => skip to given channel; OFF => skip # lines */
  3    48     2 number fixed binary (4) unaligned unsigned;		/* channel # or # or lines to skip */
  3    49 
  3    50 dcl  hasp_printer_srcb_byte_ptr pointer;
  3    51 
  3    52 dcl 1 TEMPLATE_HASP_PRINTER_SRCB_BITS aligned static options (constant),
  3    53     2 pad1 bit (1) unaligned initial ("0"b),
  3    54     2 mbo1 bit (1) unaligned initial ("1"b),
  3    55     2 mbz1 bit (1) unaligned initial ("0"b),
  3    56     2 prespace bit (1) unaligned initial ("0"b),		/* post-spacing */
  3    57     2 skip_to_channel bit (1) unaligned initial ("0"b),	/* # of lines */
  3    58     2 number fixed binary (4) unaligned unsigned initial (1);
  3    59 
  3    60 dcl  TEMPLATE_HASP_PRINTER_SRCB character (1) aligned based (addr (TEMPLATE_HASP_PRINTER_SRCB_BITS));
  3    61 
  3    62 dcl  HASP_MAX_SLEW_COUNT fixed binary static options (constant) initial (3);
  3    63 						/* max slew of 3 insures proper operation with 370's */
  3    64 
  3    65 dcl 1 HASP_FORMS_CHANGE_SRCB_BITS aligned static options (constant),
  3    66     2 pad1 bit (1) unaligned initial ("0"b),
  3    67     2 mbo1 bit (1) unaligned initial ("1"b),
  3    68     2 mbz1 bit (1) unaligned initial ("0"b),
  3    69     2 change bit (6) unaligned initial ("16"b3);		/* change forms record */
  3    70 
  3    71 dcl  HASP_FORMS_CHANGE_SRCB character (1) aligned based (addr (HASP_FORMS_CHANGE_SRCB_BITS));
  3    72 
  3    73 
  3    74 /* HASP String Control Byte (SCB) */
  3    75 
  3    76 dcl 1 hasp_scb_byte unaligned based (hasp_scb_byte_ptr),
  3    77     2 pad1 bit (1) unaligned,				/* supplied by MCS */
  3    78     2 not_eor bit (1) unaligned,			/* ON => not an end of record indicator */
  3    79     2 not_compressed bit (1) unaligned,			/* ON => this SCB refers to a non-compressed string */
  3    80     2 variant bit (6) unaligned;			/* dependent on setting of hasp_scb_byte.not_compressed */
  3    81 
  3    82 dcl 1 hasp_not_compressed_scb_byte unaligned based (hasp_scb_byte_ptr),
  3    83     2 pad1 bit (1) unaligned,
  3    84     2 not_eor bit (1) unaligned,
  3    85     2 not_compressed bit (1) unaligned,			/* ON */
  3    86     2 count fixed binary (6) unaligned unsigned;		/* # of characters in string following the SCB */
  3    87 
  3    88 dcl 1 hasp_compressed_scb_byte unaligned based (hasp_scb_byte_ptr),
  3    89     2 pad1 bit (1) unaligned,
  3    90     2 not_eor bit (1) unaligned,
  3    91     2 not_compressed bit (1) unaligned,			/* OFF */
  3    92     2 not_blank bit (1) unaligned,			/* ON => repeated character isn't a blank and follows SCB */
  3    93     2 count fixed binary (5) unaligned unsigned;		/* # of occurrences of the character */
  3    94 
  3    95 dcl  hasp_scb_byte_ptr pointer;
  3    96 
  3    97 dcl  HASP_EOR_SCB_BITS bit (9) aligned static options (constant) initial ("000"b3);
  3    98 dcl  HASP_EOR_SCB character (1) aligned based (addr (HASP_EOR_SCB_BITS));
  3    99 
  3   100 dcl (HASP_MAX_NOT_COMPRESSED_TEXT_LTH	initial (62),	/* # of characters representable by a single SCB */
  3   101      HASP_MAX_COMPRESSED_TEXT_LTH	initial (31))	/* # of occurences of a character representable by
  3   102*						     a single SCB */
  3   103 	fixed binary static options (constant);
  3   104 
  3   105 /* END INCLUDE FILE ... hasp_srcb_scb_bytes.incl.pl1 */
     2166 
     2167 
  4     1 /* BEGIN INCLUDE FILE ... hasp_set_forms_info.incl.pl1 */
  4     2 /* Created:  25 December 1981 by G. Palter */
  4     3 
  4     4 /* Data structure required by the hasp_workstation_ set_forms control order */
  4     5 
  4     6 dcl 1 set_forms_info aligned based (sti_ptr),
  4     7       2 version fixed binary,
  4     8       2 forms character (32);				/* the forms to use untill the next end_write_mode order */
  4     9 
  4    10 dcl  sti_ptr pointer;
  4    11 
  4    12 dcl  SET_FORMS_INFO_VERSION_1 fixed binary static options (constant) initial (1);
  4    13 
  4    14 /* END INCLUDE FILE ... hasp_set_forms_info.incl.pl1 */
     2168 
     2169 
  5     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  5     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  5     3*      version number to IOX2. */
  5     4 /* format: style2 */
  5     5 
  5     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  5     7 	     2 version	      character (4) aligned,	/* IOX2 */
  5     8 	     2 name	      char (32),		/* I/O name of this block. */
  5     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  5    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  5    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  5    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  5    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  5    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  5    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  5    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  5    17 						/* open(p,mode,not_used,s) */
  5    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  5    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  5    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  5    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  5    24 						/* put_chars(p,bufptr,buflen,s) */
  5    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  5    26 						/* modes(p,newmode,oldmode,s) */
  5    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  5    28 						/* position(p,u1,u2,s) */
  5    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  5    30 						/* control(p,order,infptr,s) */
  5    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  5    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  5    34 						/* write_record(p,bufptr,buflen,s) */
  5    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  5    36 						/* rewrite_record(p,bufptr,buflen,s) */
  5    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  5    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  5    39 						/* seek_key(p,key,len,s) */
  5    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  5    41 						/* read_key(p,key,len,s) */
  5    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  5    43 						/* read_length(p,len,s) */
  5    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  5    45 						/* open_file(p,mode,desc,not_used,s) */
  5    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  5    47 						/* close_file(p,desc,s) */
  5    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  5    49 						/* detach(p,desc,s) */
  5    50 
  5    51      declare iox_$iocb_version_sentinel
  5    52 			      character (4) aligned external static;
  5    53 
  5    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
     2170 
     2171 
  6     1 /* Begin include file ..... iox_modes.incl.pl1 */
  6     2 
  6     3 /* Written by C. D. Tavares, 03/17/75 */
  6     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  6     5 
  6     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  6     7     ("stream_input", "stream_output", "stream_input_output",
  6     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  6     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  6    10      "direct_input", "direct_output", "direct_update");
  6    11 
  6    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  6    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  6    14 
  6    15 dcl (Stream_input initial (1),
  6    16      Stream_output initial (2),
  6    17      Stream_input_output initial (3),
  6    18      Sequential_input initial (4),
  6    19      Sequential_output initial (5),
  6    20      Sequential_input_output initial (6),
  6    21      Sequential_update initial (7),
  6    22      Keyed_sequential_input initial (8),
  6    23      Keyed_sequential_output initial (9),
  6    24      Keyed_sequential_update initial (10),
  6    25      Direct_input initial (11),
  6    26      Direct_output initial (12),
  6    27      Direct_update initial (13)) fixed bin int static options (constant);
  6    28 
  6    29 /* End include file ..... iox_modes.incl.pl1 */
     2172 
     2173 
  7     1 /* Begin include file ..... io_call_info.incl.pl1 */
  7     2 
  7     3 /* This include file defines the info_structure used by an I/O module to perform an "io_call" order
  7     4*   on behalf of the io_call command. */
  7     5 /* Coded April 1976 by Larry Johnson */
  7     6 /* Changed June 1977 by Larry Johnson for "io_call_af" order */
  7     7 
  7     8      dcl	   io_call_infop	      ptr;
  7     9 
  7    10      dcl	   1 io_call_info	      aligned based (io_call_infop),
  7    11 	     2 version	      fixed bin,
  7    12 	     2 caller_name	      char (32),		/* Caller name for error messages */
  7    13 	     2 order_name	      char (32),		/* Actual name of the order to be performed */
  7    14 	     2 report	      entry variable options (variable),
  7    15 						/* Entry to ioa_ like procedure to report results */
  7    16 	     2 error	      entry variable options (variable),
  7    17 						/* Entry to com_err_ like procedure to report results */
  7    18 	     2 af_returnp	      ptr,		/* Pointer to return string if "io_call_af"  order */
  7    19 	     2 af_returnl	      fixed bin,		/* Length of string */
  7    20 	     2 fill	      (5) bit (36) aligned,
  7    21 	     2 nargs	      fixed bin,		/* Number of additional command arguments provided */
  7    22 	     2 max_arglen	      fixed bin,		/* Length of longest argument (used to define array) */
  7    23 	     2 args	      (0 refer (io_call_info.nargs)) char (0 refer (io_call_info.max_arglen)) varying;
  7    24 
  7    25      dcl	   io_call_af_ret	      char (io_call_info.af_returnl) based (io_call_info.af_returnp) varying;
  7    26 						/* Return string for active function */
  7    27 
  7    28 /* End include file ..... io_call_info.incl.pl1 */
     2174 
     2175 
  8     1 /* BEGIN INCLUDE FILE ... dial_manager_arg.incl.pl1 */
  8     2 
  8     3 /* Modified by E. N. Kittlitz 11/80 to add reservation string, move dial-out
  8     4*   destination from dial_qualifier, add dial_message.
  8     5*   Modified by Robert Coren 4/83 to add required access class stuff.
  8     6*   Modified 1984-08-27 BIM for V4, privileged_operation.
  8     7**/
  8     8 
  8     9 
  8    10 dcl  dial_manager_arg_version_2 fixed bin internal static initial (2) options (constant);
  8    11 dcl  dial_manager_arg_version_3 fixed bin internal static initial (3) options (constant);
  8    12 dcl  dial_manager_arg_version_4 fixed bin internal static initial (4) options (constant);
  8    13 
  8    14 dcl 1 dial_manager_arg based aligned,
  8    15     2 version fixed bin,				/* = 4 */
  8    16     2 dial_qualifier char (22),			/* identify different processes with same process group id */
  8    17     2 dial_channel fixed bin (71),			/* event wait channel */
  8    18     2 channel_name char (32),				/* channel name for privileged attach */
  8    19 						/* limit of version 1 structure */
  8    20     2 dial_out_destination char (32),			/* dial-out destination (e.g. phone_no) */
  8    21     2 reservation_string char (256),			/* reservation string */
  8    22     2 dial_message fixed bin (71),			/* OUTPUT: A.S. message received by dial_manager_ */
  8    23 						/* limit of version 2 structure */
  8    24     2 access_class bit (72),				/* access class to be associated with the attachment */
  8    25     2 flags aligned,
  8    26      3 access_class_required bit (1) unaligned,		/* indicates whether to enforce access_class */
  8    27      3 privileged_operation bit (1) unaligned,		/* for accept_dials, accepts dials from */
  8    28 						/* system_low:access_class */
  8    29 						/* no effect on other operations yet. */
  8    30      3 mbz bit (34) unaligned;			/* must be zero */
  8    31 
  8    32 /* END INCLUDE FILE ... dial_manager_arg.incl.pl1 */
     2176 
     2177 
  9     1 /* BEGIN INCLUDE FILE ... event_wait_channel.incl.pl1 */
  9     2 
  9     3 /* ipc_$block wait list with one channel
  9     4*
  9     5*   Written 9-May-79 by M. N. Davidoff.
  9     6**/
  9     7 
  9     8      declare 1 event_wait_channel   aligned,
  9     9 	     2 n_channels	      fixed bin initial (1),	/* number of channels */
  9    10 	     2 pad	      bit (36),
  9    11 	     2 channel_id	      (1) fixed bin (71);	/* event channel to wait on */
  9    12 
  9    13 /* END INCLUDE FILE ... event_wait_channel.incl.pl1 */
     2178 
     2179 
 10     1 /* BEGIN INCLUDE FILE event_wait_info.incl.pl1 */
 10     2 
 10     3 /* T. Casey, May 1978 */
 10     4 
 10     5 dcl  event_wait_info_ptr ptr;
 10     6 
 10     7 dcl 1 event_wait_info aligned based (event_wait_info_ptr),	/* argument structure filled in on return from ipc_$block */
 10     8     2 channel_id fixed bin (71),			/* event channel on which wakeup occurred */
 10     9     2 message fixed bin (71),				/* 72 bits of information passed by sender of wakeup */
 10    10     2 sender bit (36),				/* process id of sender */
 10    11     2 origin,
 10    12       3 dev_signal bit (18) unaligned,			/* "1"b if device signal */
 10    13       3 ring fixed bin (17) unaligned,			/* ring from which sent */
 10    14     2 channel_index fixed bin;			/* index of this channel in the event wait list */
 10    15 
 10    16 /* END INCLUDE FILE event_wait_info.incl.pl1 */
     2180 
     2181 
 11     1 /* BEGIN INCLUDE FILE ... line_types.incl.pl1  */
 11     2 
 11     3 /* Written  November 10 1975 by Paul Green */
 11     4 /* Modified October 1978 by Larry Johnson to include line_type_names */
 11     5 /* Modified 12/19/78 by J. Stern to add POLLED_VIP line type */
 11     6 /* Modified 9/27/79 by J. Stern to add X25LAP line type */
 11     7 /* Modified Spring 1981 by Charles Hornig to add HDLC line type */
 11     8 /* Modified May 1981 by Robert Coren to add COLTS line type */
 11     9 /* Modified September 1984 by Robert Coren to correctly count VIP as a synchronous line type */
 11    10 
 11    11 
 11    12 /****^  HISTORY COMMENTS:
 11    13*  1) change(86-02-25,Negaret), approve(87-07-13,MCR7679),
 11    14*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 11    15*     Add a DSA line type.
 11    16*  2) change(87-03-17,Beattie), approve(87-07-13,MCR7656),
 11    17*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 11    18*     Add HASP_OPR to identify HASP workstation consoles with login service.
 11    19*                                                   END HISTORY COMMENTS */
 11    20 
 11    21 
 11    22 declare   (LINE_MC            initial (-2),
 11    23        	 LINE_TELNET	initial (-1),
 11    24            LINE_UNKNOWN       initial (0),
 11    25 	 LINE_ASCII	initial (1),
 11    26 	 LINE_1050	initial (2),
 11    27 	 LINE_2741	initial (3),
 11    28 	 LINE_ARDS	initial (4),
 11    29 	 LINE_SYNCH	initial (5),
 11    30 	 LINE_G115	initial (6),
 11    31 	 LINE_BSC		initial (7),
 11    32 	 LINE_ETX		initial (8),
 11    33 	 LINE_VIP		initial (9),
 11    34 	 LINE_ASYNC1	initial (10),
 11    35 	 LINE_ASYNC2	initial (11),
 11    36 	 LINE_ASYNC3	initial (12),
 11    37 	 LINE_SYNC1	initial (13),
 11    38 	 LINE_SYNC2	initial (14),
 11    39 	 LINE_SYNC3	initial (15),
 11    40 	 LINE_POLLED_VIP	initial (16),
 11    41 	 LINE_X25LAP	initial (17),
 11    42 	 LINE_HDLC	initial (18),
 11    43 	 LINE_COLTS	initial (19),
 11    44 	 LINE_DSA           initial (20),
 11    45 	 LINE_HASP_OPR	initial (21)
 11    46 	) fixed bin internal static options (constant);
 11    47 
 11    48 dcl  max_line_type fixed bin int static options (constant) init (21);
 11    49 
 11    50 declare  n_sync_line_types fixed bin int static options (constant) init (10);
 11    51 
 11    52 declare  sync_line_type (10) fixed bin int static options (constant) init (5, 6, 7, 9, 13, 14, 15, 16, 17, 18);
 11    53 
 11    54 dcl  line_types (-2:21) char (16) int static options (constant) init (
 11    55      "MC",                                                  /* -2 */
 11    56      "TELNET",					/* -1 */
 11    57      "none",					/* 0 */
 11    58      "ASCII",					/* 1 */
 11    59      "1050",					/* 2 */
 11    60      "2741",					/* 3 */
 11    61      "ARDS",					/* 4 */
 11    62      "Sync",					/* 5 */
 11    63      "G115",					/* 6 */
 11    64      "BSC",					/* 7 */
 11    65      "202ETX",					/* 8 */
 11    66      "VIP",					/* 9 */
 11    67      "ASYNC1",					/* 10 */
 11    68      "ASYNC2",					/* 11 */
 11    69      "ASYNC3",					/* 12 */
 11    70      "SYNC1",					/* 13 */
 11    71      "SYNC2",					/* 14 */
 11    72      "SYNC3",					/* 15 */
 11    73      "POLLED_VIP",					/* 16 */
 11    74      "X25LAP",					/* 17 */
 11    75      "HDLC",					/* 18 */
 11    76      "COLTS",					/* 19 */
 11    77      "DSA",					/* 20 */
 11    78      "HASP_OPR");					/* 21 */
 11    79 
 11    80 /* END INCLUDE FILE ... line_types.incl.pl1  */
     2182 
     2183 
 12     1 /* BEGIN INCLUDE FiLE ... terminal_type_data.incl.pl1 */
 12     2 
 12     3 
 12     4 /****^  HISTORY COMMENTS:
 12     5*  1) change(77-05-19,JStern), approve(), audit(), install():
 12     6*     Created
 12     7*     Modified 8/14/79 by Robert Coren to convert to version 2 by adding
 12     8*        flow control parameters
 12     9*  2) change(87-03-09,LJAdams), approve(87-04-03,MCR7646),
 12    10*     audit(87-05-05,Gilcrease), install(87-08-04,MR12.1-1056):
 12    11*     Change the ttd_version to ttd_version_3.  Add the protocol field.
 12    12*                                                   END HISTORY COMMENTS */
 12    13 
 12    14 
 12    15 dcl 1 terminal_type_data aligned based (ttdp),		/* info structure for set_terminal_data order */
 12    16       2 version fixed bin,				/* structure version */
 12    17       2 old_type fixed bin,				/* old terminal type number, -1 => none */
 12    18       2 name char (32) unaligned,			/* terminal type name */
 12    19       2 tables,
 12    20         3 input_tr_ptr ptr,				/* input translation table ptr */
 12    21         3 output_tr_ptr ptr,				/* output translation table ptr */
 12    22         3 input_cv_ptr ptr,				/* input conversion table ptr */
 12    23         3 output_cv_ptr ptr,				/* output conversion table ptr */
 12    24         3 special_ptr ptr,				/* special chars table ptr */
 12    25         3 delay_ptr ptr,				/* delay table ptr */
 12    26       2 editing_chars unaligned,
 12    27         3 erase char (1) unaligned,
 12    28         3 kill char (1) unaligned,
 12    29       2 framing_chars unaligned,
 12    30         3 frame_begin char (1) unaligned,
 12    31         3 frame_end char (1) unaligned,
 12    32       2 flags unal,
 12    33         3 keyboard_locking bit (1),			/* ON to request keyboard locking and unlocking */
 12    34         3 input_timeout bit (1),
 12    35         3 output_block_acknowledge bit (1),
 12    36         3 mbz bit (15),
 12    37       2 line_delimiter char (1) unal,
 12    38       2 mbz bit (9) unal,
 12    39 
 12    40       /* the remainder of this structure is only present if version is 2 or more */
 12    41 
 12    42       2 flow_control_chars unal,
 12    43         3 input_suspend char (1),
 12    44         3 input_resume char (1),
 12    45         3 output_suspend_etb char (1),
 12    46         3 output_resume_ack char (1),
 12    47       2 output_buffer_size fixed bin,
 12    48 
 12    49       /* the remainder of this structure is only present if version is 3 or more */
 12    50       2 protocol fixed bin; /* 0=NONE; 1=MOWSE */
 12    51 
 12    52 
 12    53 dcl  ttdp ptr;					/* ptr to terminal_type_data structure */
 12    54 dcl  ttd_version_3 fixed bin int static options (constant) init (3);
 12    55 						/* current version of structure */
 12    56 
 12    57 
 12    58 /* END INCLUDE FILE ... terminal_type_data.incl.pl1 */
     2184 
     2185 
 13     1 /*	BEGIN INCLUDE FILE ... tty_convert.incl.pl1	*/
 13     2 
 13     3 /* tty_ conversion tables */
 13     4 /* Created 11/3/75 by Robert S. Coren */
 13     5 /* Info structures added 5/19/77 by Robert S. Coren */
 13     6 /* Length of cv_trans changed from 128 to 256 05/03/78 by Robert Coren */
 13     7 /* conversion table mnemonics added JRDavis 21 Aug 80 */
 13     8 /* fix special_chars_struc to have good refers Fri 13 Feb 81 JRDavis */
 13     9 
 13    10 
 13    11 /****^  HISTORY COMMENTS:
 13    12*  1) change(85-12-01,Negaret), approve(87-07-23,MCR7742),
 13    13*     audit(87-07-23,GDixon), install(87-08-04,MR12.1-1056):
 13    14*      Added INPUT_CONVERT_DSA_CR_PROCESSING constant.
 13    15*  2) change(88-01-22,Brunelle), approve(88-01-22,MCR7813),
 13    16*     audit(88-10-05,Blair), install(88-10-17,MR12.2-1171):
 13    17*     Expand c_chars definition from 3 chars to 15.  Change SPECIAL_VERSION
 13    18*     from 1 to 2.  Add version variable to get_special_info_struc and define
 13    19*     SPECIAL_INFO_STRUCT_VERSION_1.
 13    20*                                                   END HISTORY COMMENTS */
 13    21 
 13    22 
 13    23 /* format: style2,linecom,^indnoniterdo,indcomtxt,^inditerdo,dclind5,idind25 */
 13    24 
 13    25 
 13    26      dcl	1 special_chars	     aligned based,		/* table of special character sequences */
 13    27 	  2 nl_seq	     aligned like c_chars,	/* new-line sequence */
 13    28 	  2 cr_seq	     aligned like c_chars,	/* carriage-return sequence */
 13    29 	  2 bs_seq	     aligned like c_chars,	/* backspace sequence */
 13    30 	  2 tab_seq	     aligned like c_chars,	/* horizontal tab sequence */
 13    31 	  2 vt_seq	     aligned like c_chars,	/* vertical tab sequence */
 13    32 	  2 ff_seq	     aligned like c_chars,	/* form-feed sequence */
 13    33 	  2 printer_on	     aligned like c_chars,	/* printer-on sequence */
 13    34 	  2 printer_off	     aligned like c_chars,	/* printer_off sequence */
 13    35 	  2 red_ribbon_shift     aligned like c_chars,	/* red ribbon shift sequence */
 13    36 	  2 black_ribbon_shift   aligned like c_chars,	/* black ribbon shift sequence */
 13    37 	  2 end_of_page	     aligned like c_chars,	/* end-of-page warning sequence */
 13    38 	  2 escape_length	     fixed bin,		/* number of escape sequences */
 13    39 	  2 not_edited_escapes   (sc_escape_len refer (special_chars.escape_length)) like c_chars,
 13    40 						/* use in ^edited mode */
 13    41 	  2 edited_escapes	     (sc_escape_len refer (special_chars.escape_length)) like c_chars,
 13    42 						/* use in edited mode */
 13    43 	  2 input_escapes	     aligned,
 13    44 	    3 len		     fixed bin (8) unaligned, /* length of string */
 13    45 	    3 str		     char (sc_input_escape_len refer (special_chars.input_escapes.len)) unaligned,
 13    46 						/* escape sequence characters */
 13    47 	  2 input_results	     aligned,
 13    48 	    3 pad		     bit (9) unaligned,	/* so that strings will look the same */
 13    49 	    3 str		     char (sc_input_escape_len refer (special_chars.input_escapes.len)) unaligned;
 13    50 						/* results of escape sequences */
 13    51 
 13    52 
 13    53      dcl	c_chars_ptr	     ptr;
 13    54      dcl	1 c_chars		     based (c_chars_ptr) aligned,
 13    55 	  2 count		     fixed bin (8) unaligned,
 13    56 	  2 chars		     (15) char (1) unaligned;
 13    57 
 13    58      dcl	sc_escape_len	     fixed bin;		/* count of output escapes to allocate in special_chars  */
 13    59      dcl	sc_input_escape_len	     fixed bin;		/* count of input escapes to allocate in special_chars  */
 13    60 
 13    61 
 13    62      dcl	1 cv_trans	     based aligned,		/* conversion/translation table format */
 13    63 	  2 value		     (0:255) fixed bin (8) unal;
 13    64 
 13    65 
 13    66      dcl	1 delay		     based aligned,		/* delay counts for output */
 13    67 	  2 vert_nl	     fixed bin,
 13    68 	  2 horz_nl	     float bin,
 13    69 	  2 const_tab	     fixed bin,
 13    70 	  2 var_tab	     float bin,
 13    71 	  2 backspace	     fixed bin,
 13    72 	  2 vt_ff		     fixed bin;
 13    73 
 13    74 /* info structures used with orders */
 13    75 
 13    76      dcl	1 special_chars_struc    aligned based,
 13    77 	  2 version	     fixed bin,
 13    78 	  2 default	     fixed bin,		/* non-zero indicates use default */
 13    79 	  2 special_chars,				/* same as level-1 above */
 13    80 						/* has to be spelled out instead of using like */
 13    81 						/* because of refer options */
 13    82 	    3 nl_seq	     aligned like c_chars,	/* new-line sequence */
 13    83 	    3 cr_seq	     aligned like c_chars,	/* carriage-return sequence */
 13    84 	    3 bs_seq	     aligned like c_chars,	/* backspace sequence */
 13    85 	    3 tab_seq	     aligned like c_chars,	/* horizontal tab sequence */
 13    86 	    3 vt_seq	     aligned like c_chars,	/* vertical tab sequence */
 13    87 	    3 ff_seq	     aligned like c_chars,	/* form-feed sequence */
 13    88 	    3 printer_on	     aligned like c_chars,	/* printer-on sequence */
 13    89 	    3 printer_off	     aligned like c_chars,	/* printer_off sequence */
 13    90 	    3 red_ribbon_shift   aligned like c_chars,	/* red ribbon shift sequence */
 13    91 	    3 black_ribbon_shift aligned like c_chars,	/* black ribbon shift sequence */
 13    92 	    3 end_of_page	     aligned like c_chars,	/* end-of-page warning sequence */
 13    93 	    3 escape_length	     fixed bin,		/* number of escape sequences */
 13    94 	    3 not_edited_escapes (sc_escape_len refer (special_chars_struc.escape_length)) like c_chars,
 13    95 						/* use in ^edited mode */
 13    96 	    3 edited_escapes     (sc_escape_len refer (special_chars_struc.escape_length)) like c_chars,
 13    97 						/* use in edited mode */
 13    98 	    3 input_escapes	     aligned,
 13    99 	      4 len	     fixed bin (8) unaligned, /* length of string */
 13   100 	      4 str	     char (sc_input_escape_len refer (special_chars_struc.input_escapes.len)) unaligned,
 13   101 						/* escape sequence characters */
 13   102 	    3 input_results	     aligned,
 13   103 	      4 pad	     bit (9) unaligned,	/* so that strings will look the same */
 13   104 	      4 str	     char (sc_input_escape_len refer (special_chars_struc.input_escapes.len)) unaligned;
 13   105 						/* results of escape sequences */
 13   106 
 13   107      dcl	1 cv_trans_struc	     aligned based,		/* all conversion/translation tables */
 13   108 	  2 version	     fixed bin,
 13   109 	  2 default	     fixed bin,		/* as above */
 13   110 	  2 cv_trans	     like cv_trans;
 13   111 
 13   112      dcl	1 delay_struc	     aligned based,
 13   113 	  2 version	     fixed bin,
 13   114 	  2 default	     fixed bin,		/* as above */
 13   115 	  2 delay		     like delay;
 13   116 
 13   117      dcl	1 get_special_info_struc based aligned,		/* get_special order */
 13   118 	  2 version	     char (8),
 13   119 	  2 area_ptr	     pointer,
 13   120 	  2 table_ptr	     pointer;
 13   121 
 13   122      dcl	SPECIAL_INFO_STRUCT_VERSION_1
 13   123 			     char (8) int static options (constant) init ("sisv1000");
 13   124      dcl	SPECIAL_VERSION	     fixed bin int static options (constant) init (1);
 13   125      dcl	SPECIAL_VERSION_2	     fixed bin int static options (constant) init (2);
 13   126      dcl	DELAY_VERSION	     fixed bin int static options (constant) init (1);
 13   127      dcl	CV_TRANS_VERSION	     fixed bin int static options (constant) init (2);
 13   128 
 13   129      dcl	CV_TRANS_SIZE	     (2) fixed bin int static options (constant) init (127, 255);
 13   130 						/* indexed by version number */
 13   131 
 13   132 
 13   133 /* values for input and output conversion tables */
 13   134 
 13   135      dcl	(
 13   136 	INPUT_CONVERT_ORDINARY   init (0),
 13   137 	INPUT_CONVERT_BREAK	     init (1),
 13   138 	INPUT_CONVERT_ESCAPE     init (2),
 13   139 	INPUT_CONVERT_DISCARD    init (3),
 13   140 	INPUT_CONVERT_FORMFEED   init (4),
 13   141 	INPUT_CONVERT_PRECEDENCE_DISCARD
 13   142 			     init (5),
 13   143 	INPUT_CONVERT_DSA_CR_PROCESSING
 13   144 			     init (6)
 13   145 	)		     fixed bin (8) unaligned internal static options (constant);
 13   146 
 13   147      dcl	(
 13   148 	OUTPUT_CONVERT_ORDINARY  init (0),
 13   149 	OUTPUT_CONVERT_NEWLINE   init (1),
 13   150 	OUTPUT_CONVERT_CR	     init (2),
 13   151 	OUTPUT_CONVERT_HT	     init (3),
 13   152 	OUTPUT_CONVERT_BS	     init (4),
 13   153 	OUTPUT_CONVERT_VT	     init (5),
 13   154 	OUTPUT_CONVERT_FF	     init (6),
 13   155 	OUTPUT_CONVERT_OCTAL     init (7),
 13   156 	OUTPUT_CONVERT_RRS	     init (8),
 13   157 	OUTPUT_CONVERT_BRS	     init (9),
 13   158 	OUTPUT_CONVERT_NO_MOTION init (10),
 13   159 	OUTPUT_CONVERT_PRECEDENCE_NO_MOTION
 13   160 			     init (11),
 13   161 	OUTPUT_CONVERT_DONT_SEND init (12),
 13   162 	OUTPUT_CONVERT_NOT_USED_13
 13   163 			     init (13),
 13   164 	OUTPUT_CONVERT_NOT_USED_14
 13   165 			     init (14),
 13   166 	OUTPUT_CONVERT_NOT_USED_15
 13   167 			     init (15),
 13   168 	OUTPUT_CONVERT_NOT_USED_16
 13   169 			     init (16),
 13   170 	OUTPUT_CONVERT_FIRST_SPECIAL
 13   171 			     init (17)
 13   172 	)		     fixed bin (8) unaligned internal static options (constant);
 13   173 
 13   174 /*	END INCLUDE FILE ... tty_convert.incl.pl1 */
     2186 
     2187 
 14     1 /* BEGIN INCLUDE FILE ... tty_get_channel_info.incl.pl1 */
 14     2 
 14     3 /* for get_channel_info order to tty_ */
 14     4 
 14     5      dcl	   1 tty_get_channel_info aligned based,
 14     6 	     2 version	      fixed bin init (tty_get_channel_info_version),
 14     7 	     2 devx	      fixed bin,
 14     8 	     2 channel_name	      char (32);
 14     9 
 14    10      dcl	   tty_get_channel_info_version fixed bin init (1) internal static options (constant);
 14    11 
 14    12 /* END INCLUDE FILE ... tty_get_channel_info.incl.pl1 */
     2188 
     2189 
 15     1 /*	BEGIN INCLUDE FILE io_timeout_info.incl.pl1			*/
 15     2 /* Initial version 1982.09.08 by Richard Lamson				*/
 15     3 
 15     4 declare 1 input_timeout_info	  based (timeout_info_ptr) aligned,
 15     5 	2 timeout		  fixed binary (71),
 15     6 	2 buffer_pointer	  pointer,
 15     7 	2 buffer_length	  fixed binary (21),
 15     8 	2 characters_read	  fixed binary (21);
 15     9 
 15    10 declare 1 output_timeout_info   based (timeout_info_ptr) aligned,
 15    11 	2 timeout		  fixed binary (71),
 15    12 	2 buffer_pointer	  pointer,
 15    13 	2 buffer_length	  fixed binary (21),
 15    14 	2 characters_written  fixed binary (21);
 15    15 
 15    16 declare	timeout_info_ptr pointer;
 15    17 
 15    18 /*	end include file io_timeout_info.incl.pl1			*/
     2190 
     2191 
 16     1 /* BEGIN INCLUDE FILE ... set_term_type_info.incl.pl1 */
 16     2 /* Created 7/18/77 by Robert Coren */
 16     3 /* Defines info structure for set_term_type order */
 16     4 
 16     5 dcl  stti_version_1 fixed bin int static options (constant) init (1);
 16     6 dcl  sttip ptr;
 16     7 
 16     8 dcl 1 set_term_type_info aligned based (sttip),
 16     9     2 version fixed bin,
 16    10     2 name char (32) unal,
 16    11     2 flags unal,
 16    12       3 send_initial_string bit (1),
 16    13       3 set_modes bit (1),
 16    14       3 ignore_line_type bit (1),
 16    15       3 mbz bit (33);
 16    16 
 16    17 /* END INCLUDE FILE ... set_term_type_info.incl.pl1 */
     2192 
     2193 
 17     1 /* BEGIN INCLUDE FILE timer_manager_constants.incl.pl1 */
 17     2 
 17     3 /****^  HISTORY COMMENTS:
 17     4*  1) change(85-03-05,Sibert), approve(87-05-25,MCR7678),
 17     5*     audit(87-04-02,GDixon), install(87-08-04,MR12.1-1056):
 17     6*     Initially written.
 17     7*                                                   END HISTORY COMMENTS */
 17     8 
 17     9 /* Values for the flags arguments in timer_manager_ calls */
 17    10 
 17    11 dcl ABSOLUTE_MICROSECONDS bit (2) int static options (constant) init ("00"b);
 17    12 dcl ABSOLUTE_SECONDS bit (2) int static options (constant) init ("01"b);
 17    13 dcl RELATIVE_MICROSECONDS bit (2) int static options (constant) init ("10"b);
 17    14 dcl RELATIVE_SECONDS bit (2) int static options (constant) init ("11"b);
 17    15 
 17    16 /* END INCLUDE FILE timer_manager_constants.incl.pl1 */
     2194 
     2195 
     2196      end hasp_workstation_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/17/88  1034.1  hasp_workstation_.pl1             >spec>install>MR12.2-1171>hasp_workstation_.pl1
2162         1    11/12/82  1624.8  terminal_io_record.incl.pl1       >ldd>include>terminal_io_record.incl.pl1
2164         2    03/27/82  0436.6  hasp_device_data.incl.pl1         >ldd>include>hasp_device_data.incl.pl1
2166         3    03/27/82  0436.6  hasp_srcb_scb_bytes.incl.pl1      >ldd>include>hasp_srcb_scb_bytes.incl.pl1
2168         4    02/08/82  2101.5  hasp_set_forms_info.incl.pl1      >ldd>include>hasp_set_forms_info.incl.pl1
2170         5    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
2172         6    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
2174         7    07/19/79  1547.1  io_call_info.incl.pl1             >ldd>include>io_call_info.incl.pl1
2176         8    09/13/84  0921.5  dial_manager_arg.incl.pl1         >ldd>include>dial_manager_arg.incl.pl1
2178         9    06/29/79  1728.0  event_wait_channel.incl.pl1       >ldd>include>event_wait_channel.incl.pl1
2180        10    06/29/79  1727.8  event_wait_info.incl.pl1          >ldd>include>event_wait_info.incl.pl1
2182        11    08/06/87  0913.4  line_types.incl.pl1               >ldd>include>line_types.incl.pl1
2184        12    08/06/87  0913.5  terminal_type_data.incl.pl1       >ldd>include>terminal_type_data.incl.pl1
2186        13    10/17/88  1024.1  tty_convert.incl.pl1              >spec>install>MR12.2-1171>tty_convert.incl.pl1
2188        14    01/28/81  0923.4  tty_get_channel_info.incl.pl1     >ldd>include>tty_get_channel_info.incl.pl1
2190        15    10/19/82  2111.7  io_timeout_info.incl.pl1          >ldd>include>io_timeout_info.incl.pl1
2192        16    09/01/77  1359.3  set_term_type_info.incl.pl1       >ldd>include>set_term_type_info.incl.pl1
2194        17    08/06/87  0913.5  timer_manager_constants.incl.pl1  >ldd>include>timer_manager_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABSOLUTE_MICROSECONDS           000274 constant        bit(2)                   initial packed unaligned dcl 17-11 set ref 1970*
                                                                                  2148*
ASCII_SPACE                     015304 constant        char(1)                  initial packed unaligned dcl 219 ref 476 1543
EBCDIC_SPACE                           constant        char(1)                  initial packed unaligned dcl 219 ref 427
HASP_CONSOLE                           constant        fixed bin(17,0)          initial dcl 2-6 ref 1100 1394 1555 2038
HASP_CONSOLE_SRCB                      based           char(1)                  dcl 3-16 ref 2038
HASP_CONSOLE_SRCB_BITS          000122 constant        bit(9)                   initial dcl 3-15 set ref 2038
HASP_DEVICE_NAMES               000123 constant        char(32)                 initial array packed unaligned dcl 2-15 set ref 451
                                                                                  451 452 454 454* 626* 626* 720* 720*
HASP_EOR_SCB                           based           char(1)                  dcl 3-98 ref 1255 1277 1292
HASP_EOR_SCB_BITS                      constant        bit(9)                   initial dcl 3-97 set ref 1255 1277 1292
HASP_FORMS_CHANGE_SRCB                 based           char(1)                  dcl 3-71 ref 1247
HASP_FORMS_CHANGE_SRCB_BITS     000002 constant        structure                level 1 dcl 3-65 set ref 1247
HASP_MAX_NOT_COMPRESSED_TEXT_LTH       constant        fixed bin(17,0)          initial dcl 3-100 ref 1050 1198 1198
HASP_MAX_SLEW_COUNT                    constant        fixed bin(17,0)          initial dcl 3-62 ref 1211 2058
HASP_PRINTER                           constant        fixed bin(17,0)          initial dcl 2-6 ref 550 575 787 925 1205 1245 1302
                                                                                  1402 2008
HASP_PUNCH                             constant        fixed bin(17,0)          initial dcl 2-6 ref 787 925 2039
HASP_READER                            constant        fixed bin(17,0)          initial dcl 2-6 ref 781 1101 1145 1389
LINE_HASP_OPR                          constant        fixed bin(17,0)          initial dcl 11-22 ref 1555
LOWERCASE                       000163 constant        char(26)                 initial packed unaligned dcl 224 ref 463 518 1428
NAME                            000201 constant        char(32)                 initial packed unaligned dcl 216 set ref 392* 588
                                                                                  676* 1754*
NUL                                    constant        char(1)                  initial packed unaligned dcl 219 set ref 1848 2035*
                                                                                  2052*
P_attach_options                       parameter       varying char             array dcl 68 set ref 381 403 431 431 433 434 1776
                                                                                  1781 1782 1803 1808 1809
P_buffer_lth                           parameter       fixed bin(21,0)          dcl 81 ref 899 909 947 952
P_buffer_ptr                           parameter       pointer                  dcl 80 ref 899 909 942
P_character                            parameter       char(1)                  packed unaligned dcl 2088 ref 2085 2095
P_chars_sent                           parameter       fixed bin(21,0)          dcl 93 set ref 1131 1300*
P_code                                 parameter       fixed bin(35,0)          dcl 66 in procedure "hasp_workstation_" set ref 381
                                                                                  391* 392* 754* 760 766* 774* 783* 789* 821* 826
                                                                                  832* 854* 860 866* 871* 894* 899 909 915* 926*
                                                                                  991* 1119* 1125 1131 1146* 1166* 1174* 1179* 1184*
                                                                                  1311* 1316 1326* 1330* 1335 1352* 1607* 1613 1617*
P_code                                 parameter       fixed bin(35,0)          dcl 1626 in procedure "cleanup_attachment" set ref
                                                                                  1623 1628* 1670*
P_info_ptr                             parameter       pointer                  dcl 87 set ref 1316 1324 1326* 1335 1343
P_iocb_ptr                             parameter       pointer                  dcl 65 set ref 381 384 760 763 826 829 860 863 899
                                                                                  909 1125 1131 1140 1316 1319 1326* 1335 1338 1563*
                                                                                  1570* 1613 1824
P_loud_sw                              parameter       bit(1)                   packed unaligned dcl 69 ref 381 385
P_new_modes                            parameter       char                     packed unaligned dcl 90 ref 1613
P_old_modes                            parameter       char                     packed unaligned dcl 91 set ref 1613 1616*
P_open_mode                            parameter       fixed bin(17,0)          dcl 71 ref 760 770
P_open_sw                              parameter       bit(1)                   packed unaligned dcl 72 ref 760
P_order                                parameter       char                     packed unaligned dcl 86 set ref 1316 1323 1326* 1335
                                                                                  1342
P_record_lth                           parameter       fixed bin(21,0)          dcl 74 set ref 899 909 990* 1110* 1125 1131 1170
                                                                                  1170 1177 1177
P_record_ptr                           parameter       pointer                  dcl 83 ref 1125 1131 1163
P_slew_sequence_ptr                    parameter       pointer                  dcl 1864 set ref 1861 1943*
P_timeout                              parameter       fixed bin(71,0)          dcl 92 ref 909 919 1131 1134
P_translate_string_lth                 parameter       fixed bin(21,0)          dcl 1842 ref 1837 1846 1848 1848 1848
P_translate_string_ptr                 parameter       pointer                  dcl 1841 ref 1837 1846 1848 1848 1848
P_translate_table                      parameter       char(512)                dcl 1840 set ref 1837 1846* 1848 1848* 1848
READER_DEVICE                          constant        fixed bin(17,0)          initial dcl 1-38 ref 1101
RELATIVE_SECONDS                000003 constant        bit(2)                   initial packed unaligned dcl 17-14 set ref 2147*
SET_FORMS_INFO_VERSION_1               constant        fixed bin(17,0)          initial dcl 4-12 ref 1422
SLEW_BY_COUNT                          constant        fixed bin(17,0)          initial dcl 1-44 ref 1103 1211 2012 2057
SLEW_TO_CHANNEL                        constant        fixed bin(17,0)          initial dcl 1-44 ref 1219 2014 2063
SLEW_TO_INSIDE_PAGE                    constant        fixed bin(17,0)          initial dcl 1-44 ref 1215 2021
SLEW_TO_OUTSIDE_PAGE                   constant        fixed bin(17,0)          initial dcl 1-44 ref 1217 2023
SLEW_TO_TOP_OF_PAGE                    constant        fixed bin(17,0)          initial dcl 1-44 ref 1213 2019
Sequential_input                       constant        fixed bin(17,0)          initial dcl 6-15 ref 772 787 801
Sequential_input_output                constant        fixed bin(17,0)          initial dcl 6-15 ref 772 801 804
Sequential_output                      constant        fixed bin(17,0)          initial dcl 6-15 ref 772 781 804
TELEPRINTER_DEVICE                     constant        fixed bin(17,0)          initial dcl 1-38 ref 1100
TEMPLATE_HASP_CARD_SRCB                based           char(1)                  dcl 3-37 ref 2039
TEMPLATE_HASP_CARD_SRCB_BITS    000001 constant        structure                level 1 dcl 3-30 set ref 2039
TEMPLATE_HASP_EOF_RECORD               based           char(2)                  dcl 3-10 set ref 1398 1399
TEMPLATE_HASP_EOF_RECORD_BITS   000000 constant        structure                level 1 dcl 3-6 set ref 1398 1399
UPPERCASE                       000172 constant        char(26)                 initial packed unaligned dcl 224 ref 463 518 1428
actual_iocb_ptr          12            based           pointer                  level 2 dcl 5-6 ref 763 829 1140 1319 1338 1824
addcharno                                              builtin function         dcl 295 ref 433 1781 1808 2036 2053 2124 2124
addr                                                   builtin function         dcl 295 ref 423 423 425 425 433 465 465 470 470 473
                                                                                  473 659 659 666 666 666 666 714 714 729 729 744
                                                                                  814 935 944 960 966 978 984 1003 1006 1024 1024
                                                                                  1024 1024 1045 1062 1074 1089 1089 1089 1089 1089
                                                                                  1089 1115 1155 1191 1191 1191 1191 1191 1191 1191
                                                                                  1191 1227 1247 1248 1248 1248 1248 1251 1251 1251
                                                                                  1251 1255 1264 1264 1264 1264 1268 1268 1268 1268
                                                                                  1277 1288 1288 1288 1288 1292 1307 1370 1370 1377
                                                                                  1377 1377 1377 1398 1398 1399 1533 1533 1535 1535
                                                                                  1540 1540 1547 1547 1686 1686 1731 1731 1781 1808
                                                                                  1963 1963 1973 1973 1973 1973 1982 1982 2036 2038
                                                                                  2039 2053 2124 2124 2132 2132 2151 2151 2151 2151
any_other                       001146 stack reference condition                dcl 293 ref 740 797 884
area                            001154 stack reference condition                dcl 293 ref 1037 1043 1231 1916
argument                               based           char                     packed unaligned dcl 103 set ref 436 439 441 445 448
                                                                                  460 460 479 479 483 486 489 492 492 495 498 501
                                                                                  504 507 510 513 525 530 535* 1774 1784 1787 1801
                                                                                  1811* 1813* 1872 1882 1884 1885 1888 1890* 1894*
                                                                                  1899* 1903* 1916* 1924 1926 1927 1930
argument_idx                    000126 automatic       fixed bin(17,0)          dcl 122 set ref 431* 433 434* 1776 1779* 1779 1781
                                                                                  1782 1803 1806* 1806 1808 1809
argument_lth                    000104 automatic       fixed bin(21,0)          dcl 104 set ref 434* 436 439 441 445 448 460 460 479
                                                                                  479 483 486 489 492 492 495 498 501 504 507 510
                                                                                  513 515 520 520 522 525 530 535 535 1774 1782*
                                                                                  1784 1787 1801 1809* 1811 1811 1813 1813 1872 1882
                                                                                  1884 1885 1888 1890 1890 1894 1894 1899 1899 1903
                                                                                  1903 1916 1916 1924 1926 1927 1930
argument_ptr                    000106 automatic       pointer                  dcl 105 set ref 433* 436 439 441 445 448 460 460 479
                                                                                  479 483 486 489 492 492 495 498 501 504 507 510
                                                                                  513 525 530 535 1774 1781* 1784 1787 1801 1808*
                                                                                  1811 1813 1872 1882 1884 1885 1888 1890 1894 1899
                                                                                  1903 1916 1924 1926 1927 1930
ascii_to_ebcdic_$ae_table       000014 external static char(128)                packed unaligned dcl 228 set ref 425 425 425 425
attach_channel_is_call
                         42(01)        based           bit(1)                   level 3 packed packed unaligned dcl 323 set ref
                                                                                  1490* 1679
attach_data_ptr          16            based           pointer                  level 2 dcl 5-6 set ref 745* 778 877 1141 1320 1339
                                                                                  1825
attach_descrip_ptr       14            based           pointer                  level 2 dcl 5-6 set ref 390 744* 865 888*
attach_description                     based           varying char(256)        level 2 dcl 301 set ref 588* 589* 589 590* 590 591*
                                                                                  591 592* 592 594* 594 595* 595 597* 597 744
attach_event_channel     14            based           fixed bin(71,0)          level 2 dcl 323 set ref 613* 651* 655 664 1488*
                                                                                  1679* 1683 1691 1691*
attached                 42            based           bit(1)                   level 3 packed packed unaligned dcl 323 set ref 685*
                                                                                  1678 1688*
based_state                            based           fixed bin(17,0)          dcl 101 set ref 1589*
binary                    3            based           bit(1)                   level 4 in structure "terminal_io_record" packed
                                                                                  packed unaligned dcl 1-8 in procedure
                                                                                  "hasp_workstation_" set ref 1183
binary                                                 builtin function         dcl 295 in procedure "hasp_workstation_" ref 944 944
bits                      6            based           bit                      array level 3 packed packed unaligned dcl 1-8 set
                                                                                  ref 1089 1089 1191 1191 1191 1191
block_on_io              42(06)        based           bit(1)                   level 3 packed packed unaligned dcl 323 set ref 645*
                                                                                  904 914 1987 2141
block_on_io_sw                  000160 automatic       bit(1)                   dcl 127 set ref 414* 531* 645
buffer_length             4            based           fixed bin(21,0)          level 2 in structure "output_timeout_info" dcl 15-10
                                                                                  in procedure "hasp_workstation_" set ref 1570*
buffer_length             4            based           fixed bin(21,0)          level 2 in structure "input_timeout_info" dcl 15-4
                                                                                  in procedure "hasp_workstation_" set ref 1563*
buffer_pointer            2            based           pointer                  level 2 in structure "output_timeout_info" dcl 15-10
                                                                                  in procedure "hasp_workstation_" set ref 1570*
buffer_pointer            2            based           pointer                  level 2 in structure "input_timeout_info" dcl 15-4
                                                                                  in procedure "hasp_workstation_" set ref 1563*
c_chars                                based           structure                level 1 dcl 13-54
caller_message                  000102 automatic       char(256)                packed unaligned dcl 1748 set ref 1753* 1754*
chain                   544            based           structure                level 2 in structure "had" dcl 301 in procedure
                                                                                  "hasp_workstation_"
chain                    36            based           structure                level 2 in structure "channel_info" dcl 323
                                                                                  in procedure "hasp_workstation_"
channel_id                2     001212 automatic       fixed bin(71,0)          array level 2 dcl 9-8 set ref 664* 1376* 1969* 2146*
                                                                                  2147*
channel_info                           based           structure                level 1 dcl 323 set ref 610 1702
channel_info_ptr                001172 automatic       pointer                  dcl 348 in procedure "hasp_workstation_" set ref
                                                                                  603* 603* 605* 606 608 610* 611 612 613 613 613
                                                                                  614 615 616 617 618 620 621 622 623 626 626 631
                                                                                  631 633 634 636 638 643 645 646 651 655 664 685
                                                                                  688 690 693 695 702 702 714 717 720 729 779* 781
                                                                                  787 787 878* 904 914 925 925 976 978 979 980 1003
                                                                                  1005 1064 1065 1074 1075 1100 1101 1142* 1145 1205
                                                                                  1208 1245 1245 1302 1302 1321* 1329 1340* 1370
                                                                                  1376 1389 1394 1402 1405 1443 1445 1450 1462 1462
                                                                                  1464 1466 1475 1488 1490 1505 1506 1516 1516 1517
                                                                                  1517 1518 1519 1519 1521 1522 1547 1555 1579 1588
                                                                                  1594 1602 1634* 1636 1640 1644 1670 1670 1672 1672
                                                                                  1672 1675 1675 1678 1679 1679 1681 1683 1684 1688
                                                                                  1691 1691 1694 1694 1696 1696 1698 1698 1700 1700
                                                                                  1702 1703* 1826* 1963 1969 1970 1974 1982 1987
                                                                                  2008 2038 2039 2115 2116 2119 2124 2132 2140 2141
                                                                                  2146 2148 2152
channel_info_ptr        110            based           pointer                  level 2 in structure "had" dcl 301 in procedure
                                                                                  "hasp_workstation_" set ref 428* 638* 779 878 1142
                                                                                  1321 1340 1632 1634 1826
channel_name             12     000340 automatic       char(32)                 level 2 in structure "dma" dcl 141 in procedure
                                                                                  "hasp_workstation_" set ref 656* 1684*
channel_name              2            based           char(32)                 level 2 in structure "get_channel_info" dcl 214
                                                                                  in procedure "hasp_workstation_" set ref 1506*
character_value                 000272 automatic       char(32)                 packed unaligned dcl 136 set ref 440* 514* 518* 518
                                                                                  520 520 522 1874*
characters_read           5            based           fixed bin(21,0)          level 2 dcl 15-4 set ref 1562* 1563*
characters_written        5            based           fixed bin(21,0)          level 2 dcl 15-10 set ref 1570*
cleanup                         001162 stack reference condition                dcl 293 ref 398 838 933 1153
clock                                                  builtin function         dcl 295 ref 921 1137 1976 1987 2137
close                    36            based           entry variable           level 2 dcl 5-6 set ref 810*
code                            000102 automatic       fixed bin(35,0)          dcl 98 set ref 386* 465* 466 466* 651* 652 652* 659*
                                                                                  660 661 661* 666* 669 669* 671* 673 673* 688* 690
                                                                                  693* 694 694* 702* 703* 705 712 712* 714* 715* 717
                                                                                  723 725* 729* 730* 732 732* 754 880* 894 923* 948*
                                                                                  987 1039* 1057* 1083* 1092* 1119 1143* 1233* 1272*
                                                                                  1302 1311 1325* 1329* 1330 1344* 1370* 1371* 1372
                                                                                  1377* 1378 1390* 1401 1408* 1416* 1422* 1439*
                                                                                  1450* 1451* 1466* 1467* 1475* 1476* 1484* 1488*
                                                                                  1490 1499* 1501* 1516* 1517* 1519* 1520 1528*
                                                                                  1533* 1534 1547* 1548* 1553* 1555* 1557* 1563*
                                                                                  1570* 1576* 1579* 1580* 1584* 1585* 1590* 1594*
                                                                                  1595* 1602* 1603* 1607 1759* 1761* 1811* 1813
                                                                                  1898* 1899 1963* 1964* 1965 1973* 1975 1982* 1983*
                                                                                  1984 1987* 2116* 2117* 2118 2124* 2126* 2127 2132*
                                                                                  2133* 2134 2141* 2151* 2153
com_err_                        000112 constant        entry                    external dcl 243 ref 392 676 1754
compress_code                   001110 automatic       fixed bin(35,0)          dcl 182 set ref 1248* 1251* 1254 1264* 1268* 1271
                                                                                  1288* 1290
continue_to_signal_             000114 constant        entry                    external dcl 244 ref 1725
control                  66            based           entry variable           level 2 dcl 5-6 set ref 747* 807* 846*
convert_dial_message_           000116 constant        entry                    external dcl 245 ref 671
copy                                                   builtin function         dcl 295 ref 1848
count_or_channel          1            based           fixed bin(17,0)          array level 3 dcl 358 set ref 556* 1938* 2073
cu_$arg_list_ptr                000120 constant        entry                    external dcl 248 ref 1753 1753
cu_$arg_ptr                     000122 constant        entry                    external dcl 249 ref 1750
current_forms           131            based           varying char(32)         level 2 dcl 301 set ref 422* 582* 1208 1208 1245
                                                                                  1248 1251 1251 1251 1251 1302 1402* 1426* 1428*
                                                                                  1428 1429* 1429
currentsize                                            builtin function         dcl 295 ref 1170 1177
cv_dec_check_                   000124 constant        entry                    external dcl 250 ref 1811 1898 1937
cv_string_buffer                       based           char                     packed unaligned dcl 170 set ref 935 1024 1024 1042
                                                                                  1045 1115
cv_string_buffer_lth            000634 automatic       fixed bin(21,0)          dcl 172 set ref 935 935 961* 1024 1024 1024* 1036*
                                                                                  1036 1042 1042 1045 1045 1115 1115
cv_string_buffer_ptr            000636 automatic       pointer                  dcl 173 set ref 931* 935 935 935 960* 1024 1024 1044
                                                                                  1045 1045 1047* 1089 1089 1115 1115 1115
cv_string_buffer_space          000650 automatic       char(384)                packed unaligned dcl 179 set ref 935 960 961 1045
                                                                                  1115
cv_string_buffer_used                  based           char                     packed unaligned dcl 171 set ref 1044* 1044 1089
                                                                                  1089
cv_string_buffer_used_lth       000635 automatic       fixed bin(21,0)          dcl 172 set ref 962* 1024* 1044 1044 1082 1088 1089
                                                                                  1089 1089 1092
cv_trans                  2            based           structure                level 2 in structure "cv_trans_struc" dcl 13-107
                                                                                  in procedure "hasp_workstation_"
cv_trans                               based           structure                level 1 dcl 13-62 in procedure "hasp_workstation_"
cv_trans_struc                         based           structure                level 1 dcl 13-107
data                      6            based           structure                level 2 in structure "terminal_io_record" dcl 1-8
                                                                                  in procedure "hasp_workstation_" set ref 944 1268
                                                                                  1268
data                      2            based           char                     level 2 in structure "held_input" dcl 371
                                                                                  in procedure "hasp_workstation_" set ref 978 1000*
                                                                                  1001* 1006 1073*
data_ptr                  4            based           pointer                  level 2 dcl 209 set ref 1488*
default_forms           120            based           varying char(32)         level 2 dcl 301 set ref 422* 515 515 515 522* 575
                                                                                  580 581* 581 582 1402
delay                                  based           structure                level 1 dcl 13-66
detach_iocb              26            based           entry variable           level 2 dcl 5-6 set ref 748* 812* 845*
detachflag                             based           fixed bin(17,0)          dcl 203 set ref 1594*
device_name                     000137 automatic       char(32)                 packed unaligned dcl 124 set ref 411* 449* 452 454*
                                                                                  547 570* 575* 592
device_type               1            based           fixed bin(17,0)          level 3 in structure "terminal_io_record" dcl 1-8
                                                                                  in procedure "hasp_workstation_" set ref 1100*
                                                                                  1101*
device_type                     000270 automatic       fixed bin(17,0)          dcl 133 in procedure "hasp_workstation_" set ref
                                                                                  450* 451 452* 454 550 575 612 626 626
device_type              10            based           fixed bin(17,0)          level 2 in structure "channel_info" dcl 323
                                                                                  in procedure "hasp_workstation_" set ref 612* 626
                                                                                  626 717 720 781 787 787 925 925 1100 1101 1145
                                                                                  1205 1245 1302 1389 1394 1402 1555 2008 2038 2039
devx                      1            based           fixed bin(17,0)          level 2 in structure "get_channel_info" dcl 214
                                                                                  in procedure "hasp_workstation_" set ref 1505*
devx                     11            based           fixed bin(17,0)          level 2 in structure "channel_info" dcl 323
                                                                                  in procedure "hasp_workstation_" set ref 613* 643
                                                                                  702* 714* 729* 1329* 1370* 1450* 1466* 1475* 1505
                                                                                  1519* 1547* 1579* 1588* 1594* 1602* 1670 1670*
                                                                                  1963* 1982* 2116* 2124* 2132*
dial_channel             10     000340 automatic       fixed bin(71,0)          level 2 dcl 141 set ref 655* 1683*
dial_manager_$privileged_attach 000126 constant        entry                    external dcl 251 ref 659
dial_manager_$release_channel   000130 constant        entry                    external dcl 252 ref 1686
dial_manager_arg                       based           structure                level 1 dcl 8-14
dial_manager_arg_version_2             constant        fixed bin(17,0)          initial dcl 8-10 ref 654 1682
dial_out_destination     22     000340 automatic       char(32)                 level 2 dcl 141 set ref 657* 1685*
dial_qualifier            1     000340 automatic       char(22)                 level 2 dcl 141 set ref 657* 1685*
dialed_up                       000517 automatic       bit(1)                   level 2 packed packed unaligned dcl 146 set ref 675
dialup_msg_channel              000507 automatic       char(32)                 packed unaligned dcl 145 set ref 671* 676*
dialup_msg_flags                000517 automatic       structure                level 1 dcl 146 set ref 671*
dimension                                              builtin function         dcl 295 ref 454 470 470 473 473 1535 1535 1540 1540
divide                                                 builtin function         dcl 295 ref 1198 1211
dma                             000340 automatic       structure                level 1 dcl 141 set ref 659 659 1686 1686
ebcdic_to_ascii_$ea_table       000016 external static char(256)                packed unaligned dcl 229 set ref 423 423 423 423
element_size              4            based           fixed bin(17,0)          level 3 dcl 1-8 set ref 1089 1089 1108* 1170 1177
                                                                                  1183 1191 1191 1191 1191
error_table_$action_not_performed
                                000024 external static fixed bin(35,0)          dcl 233 ref 660 705 1759
error_table_$bad_conversion     000026 external static fixed bin(35,0)          dcl 233 set ref 1813* 1899*
error_table_$bad_mode           000030 external static fixed bin(35,0)          dcl 233 ref 774 783 789
error_table_$badopt             000032 external static fixed bin(35,0)          dcl 233 set ref 535*
error_table_$bigarg             000034 external static fixed bin(35,0)          dcl 233 set ref 515*
error_table_$device_type_unknown
                                000036 external static fixed bin(35,0)          dcl 233 set ref 454*
error_table_$eof_record         000040 external static fixed bin(35,0)          dcl 233 ref 1083
error_table_$improper_data_format
                                000042 external static fixed bin(35,0)          dcl 233 ref 1057 1174 1179 1184 1272
error_table_$inconsistent       000044 external static fixed bin(35,0)          dcl 233 set ref 570* 575* 915
error_table_$incorrect_device_type
                                000046 external static fixed bin(35,0)          dcl 233 set ref 626* 720* 1555
error_table_$invalid_device     000022 external static fixed bin(35,0)          dcl 232 set ref 705*
error_table_$invalid_read       000050 external static fixed bin(35,0)          dcl 233 ref 926
error_table_$invalid_write      000052 external static fixed bin(35,0)          dcl 233 ref 1146 1390
error_table_$io_no_permission   000054 external static fixed bin(35,0)          dcl 233 ref 703 715 730 1371 1451 1467 1476 1548
                                                                                  1580 1595 1603 1964 1983 2117 2126 2133
error_table_$long_record        000056 external static fixed bin(35,0)          dcl 233 ref 1034 1092
error_table_$noalloc            000060 external static fixed bin(35,0)          dcl 233 set ref 1039 1233 1916*
error_table_$noarg              000062 external static fixed bin(35,0)          dcl 233 set ref 403* 541* 544* 547* 1776* 1803*
error_table_$not_attached       000064 external static fixed bin(35,0)          dcl 233 ref 866
error_table_$not_closed         000066 external static fixed bin(35,0)          dcl 233 ref 766 871
error_table_$not_detached       000070 external static fixed bin(35,0)          dcl 233 ref 391
error_table_$not_open           000072 external static fixed bin(35,0)          dcl 233 ref 832
error_table_$null_info_ptr      000074 external static fixed bin(35,0)          dcl 233 ref 1416 1439 1484 1499 1553 1576
error_table_$short_record       000076 external static fixed bin(35,0)          dcl 233 ref 1031
error_table_$smallarg           000100 external static fixed bin(35,0)          dcl 233 ref 948
error_table_$timeout            000020 external static fixed bin(35,0)          dcl 231 ref 1987 2141
error_table_$unable_to_do_io    000102 external static fixed bin(35,0)          dcl 233 ref 1729
error_table_$undefined_order_request
                                000104 external static fixed bin(35,0)          dcl 233 ref 723 1352
error_table_$unimplemented_version
                                000106 external static fixed bin(35,0)          dcl 233 ref 1166 1422 1501 1528
error_table_$wrong_no_of_args   000110 external static fixed bin(35,0)          dcl 233 set ref 436*
event_channel                          based           fixed bin(71,0)          level 2 in structure "read_status_info" dcl 206
                                                                                  in procedure "hasp_workstation_" set ref 1443*
event_channel                          based           fixed bin(71,0)          dcl 117 in procedure "hasp_workstation_" ref 1518
event_channel            12            based           fixed bin(71,0)          level 2 in structure "channel_info" dcl 323
                                                                                  in procedure "hasp_workstation_" set ref 613* 688*
                                                                                  693* 702* 1376 1443 1516* 1517* 1518* 1519* 1672
                                                                                  1672* 1675* 1969 1970* 1974* 2146 2148* 2152*
event_channel_assigned
                         42(02)        based           bit(1)                   level 3 packed packed unaligned dcl 323 set ref 690*
                                                                                  1516 1521* 1672
event_channel_created
                         42(03)        based           bit(1)                   level 3 packed packed unaligned dcl 323 set ref 695*
                                                                                  1517 1522* 1675
event_wait_channel              001212 automatic       structure                level 1 dcl 9-8 set ref 666 666 1377 1377 1973 1973
                                                                                  2151 2151
event_wait_info                        based           structure                level 1 dcl 10-7
expand_code                     001111 automatic       fixed bin(35,0)          dcl 182 set ref 1024* 1028 1031 1034
fatal_error_info                000100 automatic       structure                level 1 dcl 1716 set ref 1731 1731
first                    16            based           pointer                  level 3 dcl 323 set ref 631 631* 1636* 1644
first_channel_info_ptr          000010 internal static pointer                  initial dcl 350 set ref 603 618 618* 1694*
flags                     3            based           structure                level 3 in structure "terminal_io_record" dcl 1-8
                                                                                  in procedure "hasp_workstation_" set ref 1106*
flags                    42            based           structure                level 2 in structure "channel_info" dcl 323
                                                                                  in procedure "hasp_workstation_" set ref 617*
forms                    24            based           varying char(32)         level 2 in structure "channel_info" dcl 323
                                                                                  in procedure "hasp_workstation_" set ref 616* 1208
                                                                                  1245 1302* 1405*
forms                     1            based           char(32)                 level 2 in structure "set_forms_info" dcl 4-6
                                                                                  in procedure "hasp_workstation_" ref 1426
get_channel_info                       based           structure                level 1 dcl 214
get_group_id_                   000132 constant        entry                    external dcl 253 ref 1720
get_system_free_area_           000134 constant        entry                    external dcl 254 ref 396 875 930 1150
had                                    based           structure                level 1 dcl 301 set ref 407 1657
had_ptr                         001170 automatic       pointer                  dcl 318 set ref 388* 407* 419 420 420 420 422 422
                                                                                  423 425 427 428 470 473 476 476 496 502 508 515
                                                                                  515 515 522 550 550 550 558 558 559 559 560 560
                                                                                  564 564 564 567 568 569 575 580 581 581 581 582
                                                                                  582 588 589 589 590 590 591 591 592 592 594 594
                                                                                  595 595 597 597 631 633 634 635 636 638 744 745
                                                                                  778* 779 793 814 877* 878 1024 1089 1141* 1142
                                                                                  1191 1208 1208 1213 1215 1217 1245 1248 1248 1248
                                                                                  1248 1251 1251 1251 1251 1251 1264 1264 1264 1268
                                                                                  1288 1288 1288 1302 1320* 1321 1339* 1340 1402
                                                                                  1402 1426 1428 1428 1429 1429 1429 1535 1540 1543
                                                                                  1543 1630 1632 1634 1636 1636 1638 1638 1640 1640
                                                                                  1642 1642 1648 1648 1651 1651 1654 1654 1657 1658*
                                                                                  1825* 1826 2019 2021 2023
hads                     16            based           structure                level 2 dcl 323 set ref 614*
hangup_proc_info                       based           structure                level 1 dcl 209
hasp_printer_srcb                      based           structure                level 1 packed packed unaligned dcl 197
hasp_printer_srcb_byte                 based           structure                level 1 packed packed unaligned dcl 3-42
hasp_util_$compress_text        000136 constant        entry                    external dcl 255 ref 1248 1251 1264 1268 1288
hasp_util_$expand_text          000140 constant        entry                    external dcl 258 ref 1024
have_comm                       000147 automatic       bit(1)                   dcl 125 set ref 409* 442* 541
have_srcb                       001134 automatic       bit(1)                   dcl 188 set ref 967* 1014 1019*
hbound                                                 builtin function         dcl 295 ref 403 431 451 1776 1803
hcs_$assign_channel             000142 constant        entry                    external dcl 261 ref 688
hcs_$delete_channel             000144 constant        entry                    external dcl 262 ref 1516 1672
hcs_$reset_ips_mask             000146 constant        entry                    external dcl 263 ref 752 819 852 892 1722
hcs_$set_ips_mask               000150 constant        entry                    external dcl 264 ref 742 799 840 886
hcs_$tty_abort                  000156 constant        entry                    external dcl 267 ref 1466 1475 2116
hcs_$tty_attach                 000160 constant        entry                    external dcl 268 ref 702
hcs_$tty_detach                 000162 constant        entry                    external dcl 269 ref 1594 1670
hcs_$tty_detach_new_proc        000152 constant        entry                    external dcl 265 ref 1579
hcs_$tty_event                  000154 constant        entry                    external dcl 266 ref 1519
hcs_$tty_order                  000164 constant        entry                    external dcl 270 ref 714 729 1329 1370 1450 1547
                                                                                  1602 1963 2132
hcs_$tty_read                   000170 constant        entry                    external dcl 272 ref 1982
hcs_$tty_state                  000166 constant        entry                    external dcl 271 ref 1588
hcs_$tty_write                  000172 constant        entry                    external dcl 275 ref 2124
header                                 based           structure                level 2 dcl 1-8
held_input                             based           structure                level 1 dcl 371 set ref 998 1003 1064 1071 1074 1462
held_input_n_elements_allocated 001202 automatic       fixed bin(21,0)          dcl 377 set ref 997* 998 998 1070* 1071 1071
held_input_ptr                  001200 automatic       pointer                  dcl 376 in procedure "hasp_workstation_" set ref
                                                                                  998* 999 999 1000 1001 1005 1006 1007 1071* 1072
                                                                                  1072 1073 1075
held_input_ptr           22            based           pointer                  level 2 in structure "channel_info" dcl 323
                                                                                  in procedure "hasp_workstation_" set ref 615* 976
                                                                                  978 979 980 1003 1005* 1064 1065* 1074 1075* 1445
                                                                                  1462 1462 1464*
hungup                    0(01) 000517 automatic       bit(1)                   level 2 packed packed unaligned dcl 146 set ref 676*
idx                             000271 automatic       fixed bin(17,0)          dcl 134 set ref 451* 452 452* 567* 568* 569* 570*
index                                                  builtin function         dcl 295 ref 1884 1926
info_ptr                        000122 automatic       pointer                  dcl 112 set ref 1324* 1329* 1343* 1351 1356 1357*
                                                                                  1416 1420 1439 1443 1445 1450* 1484 1488 1488 1488
                                                                                  1499 1501 1505 1506 1518 1526 1553 1555 1561 1569
                                                                                  1576 1579 1589 1594 1602*
input                   142            based           char(512)                level 3 dcl 301 set ref 423* 470* 1089* 1535*
input_available           2     000624 automatic       bit(1)                   level 2 in structure "read_status" dcl 160
                                                                                  in procedure "hasp_workstation_" set ref 1958*
                                                                                  1960 1967 1976*
input_available           2            based           bit(1)                   level 2 in structure "read_status_info" dcl 206
                                                                                  in procedure "hasp_workstation_" set ref 1445*
input_timeout_info                     based           structure                level 1 dcl 15-4
input_tr_ptr             12     000304 automatic       pointer                  level 3 dcl 139 set ref 467 470 470 470 470 1535
                                                                                  1535 1535 1535 1535
inside_page_sequence_ptr
                        114            based           pointer                  level 2 dcl 301 set ref 420* 502* 550 559 559* 564
                                                                                  568 1215 1651 1651 2021
io_buffer                              based           char                     packed unaligned dcl 175 set ref 1001 1017 1024 1024
                                                                                  1052 1073 1155 1236 1248 1248 1248 1248 1251 1251
                                                                                  1251 1251 1264 1264 1264 1264 1268 1268 1268 1268
                                                                                  1288 1288 1288 1288 1307 1982 1982 2036 2053 2090
                                                                                  2095* 2124 2124
io_buffer_lth                   000642 automatic       fixed bin(21,0)          dcl 176 set ref 979* 985* 1001 1007* 1017 1024 1024
                                                                                  1052 1073 1155 1155 1198* 1208* 1208 1221* 1221
                                                                                  1225 1228* 1236 1236 1248 1248 1248 1248 1251 1251
                                                                                  1251 1251 1264 1264 1264 1264 1268 1268 1268 1268
                                                                                  1288 1288 1288 1288 1307 1307 1399* 1982 1982
                                                                                  1982* 2036 2053 2090 2095 2124 2124
io_buffer_ptr                   000646 automatic       pointer                  dcl 177 set ref 978* 984* 1001 1003 1006* 1017 1024
                                                                                  1024 1052 1062 1073 1074 1151* 1155 1155 1155
                                                                                  1227* 1236* 1248 1248 1248 1248 1251 1251 1251
                                                                                  1251 1264 1264 1264 1264 1268 1268 1268 1268 1288
                                                                                  1288 1288 1288 1307 1307 1307 1398* 1982 1982 2036
                                                                                  2053 2090 2095 2124 2124
io_buffer_read                  000644 automatic       fixed bin(21,0)          dcl 176 set ref 980* 988 997 1001 1001 1007* 1022
                                                                                  1024* 1050 1052 1053 1062 1069 1070 1073 1954*
                                                                                  1956 1982* 1985
io_buffer_space                 001010 automatic       char(256)                packed unaligned dcl 180 set ref 984 985 1003 1062
                                                                                  1074 1155 1225 1227 1228 1307
io_buffer_used                  000643 automatic       fixed bin(21,0)          dcl 176 set ref 1014* 1018* 1022 1024* 1050 1052
                                                                                  1052 1053* 1062 1069 1070 1073 1073 1239* 1248*
                                                                                  1251* 1264* 1268* 1288* 1399* 2036 2053 2090 2093*
                                                                                  2093 2095 2122 2124 2131
io_call_info                           based           structure                level 1 dcl 7-10
ioa_$general_rs                 000174 constant        entry                    external dcl 278 ref 1753
iocb                                   based           structure                level 1 dcl 5-6
iocb_ptr                        000100 automatic       pointer                  dcl 97 set ref 384* 390 392 676 744 745 746 747 748
                                                                                  750* 763* 765 778 801 804 807 808 810 812 814 817*
                                                                                  829* 831 842 844 845 846 848 848 848 850* 863* 865
                                                                                  870 877 888 890* 1140* 1141 1319* 1320 1338* 1339
                                                                                  1408* 1754 1824* 1825
iox_$err_no_operation           000176 constant        entry                    external dcl 279 ref 848
iox_$propagate                  000200 constant        entry                    external dcl 280 ref 750 817 850 890
iox_modes                       000004 constant        char(24)                 initial array dcl 6-6 ref 793
ipc_$block                      000202 constant        entry                    external dcl 281 ref 666 1377 1973 2151
ipc_$create_ev_chn              000204 constant        entry                    external dcl 282 ref 651 693
ipc_$decl_ev_call_chn           000206 constant        entry                    external dcl 283 ref 1488
ipc_$decl_ev_wait_chn           000210 constant        entry                    external dcl 284 ref 1679
ipc_$delete_ev_chn              000212 constant        entry                    external dcl 285 ref 1517 1675 1691
ips_mask                        000633 automatic       bit(36)                  packed unaligned dcl 168 set ref 738* 742* 752* 752*
                                                                                  795* 799* 819* 819* 836* 840* 852* 852* 882* 886*
                                                                                  892* 892* 1722 1722* 1722* 1723*
last                     20            based           pointer                  level 3 dcl 323 set ref 633 634 636* 1640*
last_channel_info_ptr           000012 internal static pointer                  initial dcl 351 set ref 620 621 623* 1698*
lbound                                                 builtin function         dcl 295 ref 431 451
length                                                 builtin function         dcl 295 ref 423 423 425 425 434 728 961 985 996 997
                                                                                  1000 1001 1208 1225 1228 1248 1248 1248 1251 1251
                                                                                  1251 1251 1264 1264 1268 1268 1288 1288 1399 1782
                                                                                  1809 1848 1848 1848 1848 1848 1882 1885 1924 1927
                                                                                  2090
line_type                              based           fixed bin(17,0)          dcl 204 ref 1555
local_event_wait_info           000500 automatic       structure                level 1 dcl 143 set ref 666 666 1377 1377 1973 1973
                                                                                  2151 2151
local_slew_count                001144 automatic       fixed bin(17,0)          dcl 200 set ref 2012* 2058 2059* 2059 2060
loud_sw                         000110 automatic       bit(1)                   dcl 107 set ref 385* 392 1752
ltrim                                                  builtin function         dcl 295 ref 1888 1930
max                                                    builtin function         dcl 295 ref 1198 1208
maxlength                                              builtin function         dcl 295 ref 515 515 515
mbo1                      0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 197 set ref
                                                                                  2055*
message                   2     000500 automatic       fixed bin(71,0)          level 2 dcl 143 set ref 671 671
min                                                    builtin function         dcl 295 ref 1088 2058
mod                                                    builtin function         dcl 295 ref 1170 1177
modes                    56            based           entry variable           level 2 in structure "iocb" dcl 5-6 in procedure
                                                                                  "hasp_workstation_" set ref 808* 848*
modes                     1     000522 automatic       char(256)                level 2 in structure "tty_modes" dcl 156
                                                                                  in procedure "hasp_workstation_" set ref 727* 728
modes_lth                       000522 automatic       fixed bin(17,0)          level 2 dcl 156 set ref 728*
more_data_needed                001135 automatic       bit(1)                   dcl 188 set ref 969* 972 1022 1028*
more_srcbs_needed               001142 automatic       bit(1)                   dcl 199 set ref 1284 2005* 2060* 2067* 2074*
multiplexer_device_type         000521 automatic       fixed bin(17,0)          dcl 154 set ref 714 714 717 720
mvt_                            000214 constant        entry                    external dcl 286 ref 1089 1191
n_channels                      001212 automatic       fixed bin(17,0)          initial level 2 dcl 9-8 set ref 663* 1375* 9-8*
                                                                                  1968* 2145*
n_elements                5            based           fixed bin(24,0)          level 3 dcl 1-8 set ref 989* 1088* 1089 1089 1089
                                                                                  1110 1170 1177 1191 1191 1191 1191 1191 1198 1198
                                                                                  1264 1268
n_elements_allocated      1            based           fixed bin(21,0)          level 2 dcl 371 set ref 978 979 998* 999 1000 1001
                                                                                  1003 1006 1064 1071* 1072 1073 1074 1462
n_elements_used                        based           fixed bin(21,0)          level 2 dcl 371 set ref 980 999* 1007 1072*
n_extra_records                 001137 automatic       fixed bin(17,0)          dcl 192 set ref 1211* 1213* 1215* 1217* 1219* 1221
n_last_opcode                   001143 automatic       fixed bin(17,0)          dcl 200 set ref 2018* 2071* 2071 2072 2073 2074
n_ops                                  based           fixed bin(17,0)          level 2 dcl 358 set ref 555* 1213 1215 1217 1648
                                                                                  1651 1654 1919* 2074
name                                   based           char(32)                 level 2 in structure "channel_info" dcl 323
                                                                                  in procedure "hasp_workstation_" set ref 605 611*
                                                                                  1506 1684
name                      1            based           char(32)                 level 2 in structure "set_term_type_info" packed
                                                                                  packed unaligned dcl 16-8 in procedure
                                                                                  "hasp_workstation_" set ref 1533*
name                      1            based           char(32)                 level 2 in structure "iocb" dcl 5-6 in procedure
                                                                                  "hasp_workstation_" set ref 392* 676* 1754*
new_cv_string_buffer_ptr        000640 automatic       pointer                  dcl 173 set ref 1042* 1044 1047
next                    544            based           pointer                  level 3 in structure "had" dcl 301 in procedure
                                                                                  "hasp_workstation_" set ref 633* 635* 1636 1638*
                                                                                  1638 1640 1642
next                     40            based           pointer                  level 3 in structure "channel_info" dcl 323
                                                                                  in procedure "hasp_workstation_" set ref 606 620*
                                                                                  622* 1694 1696* 1696 1698 1700
next_colon                      000121 automatic       fixed bin(21,0)          dcl 1867 set ref 1884* 1885 1885* 1888 1910 1926*
                                                                                  1927 1927* 1930 1940
next_op                         000123 automatic       fixed bin(17,0)          dcl 1869 set ref 1922* 1931* 1931 1933 1935 1938
null                                                   builtin function         dcl 295 ref 388 390 420 428 467 467 550 550 550 558
                                                                                  559 560 564 564 564 567 568 569 603 608 614 615
                                                                                  618 622 631 635 765 831 842 865 870 888 931 935
                                                                                  976 1065 1115 1151 1155 1307 1351 1357 1408 1416
                                                                                  1439 1445 1462 1464 1484 1499 1535 1539 1553 1576
                                                                                  1630 1632 1636 1640 1644 1648 1651 1654 1658 1694
                                                                                  1698 1703
number                    0(05)        based           fixed bin(4,0)           level 2 packed packed unsigned unaligned dcl 197 set
                                                                                  ref 2058* 2059 2066* 2073*
numeric_value                   000302 automatic       fixed bin(35,0)          dcl 137 set ref 481*
open                     32            based           entry variable           level 2 dcl 5-6 set ref 746* 844*
open_descrip_ptr         20            based           pointer                  level 2 dcl 5-6 set ref 765 814* 831 842* 870
open_description        101            based           varying char(24)         level 2 dcl 301 set ref 419* 793* 814
open_mode                       000111 automatic       fixed bin(17,0)          dcl 109 set ref 770* 772 772 772 781 787 793 801 801
                                                                                  804 804
operation                       000110 automatic       char(32)                 packed unaligned dcl 1866 set ref 1888* 1890 1894
                                                                                  1894 1894 1894 1898 1898 1899 1899 1903 1903 1903*
                                                                                  1930* 1933 1937 1937
ops                       1            based           structure                array level 2 dcl 358
option_name                     000100 automatic       char(32)                 packed unaligned dcl 1772 in procedure
                                                                                  "get_string_argument" set ref 1774* 1776* 1784*
option_name                     001240 automatic       char(32)                 packed unaligned dcl 1798 in procedure
                                                                                  "get_numeric_argument" set ref 1801* 1803* 1813*
option_name                     000100 automatic       char(32)                 packed unaligned dcl 1866 in procedure
                                                                                  "parse_slew_sequence" set ref 1872* 1890* 1894*
                                                                                  1899* 1903* 1916*
order                           000112 automatic       char(32)                 packed unaligned dcl 111 set ref 1323* 1326 1326
                                                                                  1329* 1342* 1347 1356* 1361 1384 1412 1435 1457
                                                                                  1471 1480 1495 1511 1513 1515 1515 1525 1551 1560
                                                                                  1568 1575 1584 1585 1587 1593 1602* 1603
order_name               11            based           char(32)                 level 2 dcl 7-10 ref 1356
other_attach_options            000162 automatic       varying char(256)        dcl 129 set ref 417* 482* 482 483* 483 486* 486 497*
                                                                                  497 498* 498 503* 503 504* 504 509* 509 510* 510
                                                                                  519* 519 520* 520 527* 527 532* 532 597
output                  342            based           char(512)                level 3 dcl 301 set ref 425* 473* 476 581 1191* 1429
                                                                                  1540* 1543
output_interrupted       42(04)        based           bit(1)                   level 3 packed packed unaligned dcl 323 set ref 2115
                                                                                  2119* 2140*
output_pending            2     000630 automatic       bit(1)                   level 2 dcl 164 set ref 1366* 1368 1374 2136
output_timeout_info                    based           structure                level 1 dcl 15-10
output_tr_ptr            14     000304 automatic       pointer                  level 3 dcl 139 set ref 467 473 473 473 473 1539
                                                                                  1540 1540 1540 1540
outside_page_sequence_ptr
                        116            based           pointer                  level 2 dcl 301 set ref 420* 508* 550 560 560* 564
                                                                                  567 1217 1654 1654 2023
pid                                    based           bit(36)                  dcl 202 set ref 1579*
preslew                   3(01)        based           bit(1)                   level 4 packed packed unaligned dcl 1-8 set ref 1183
previous                 36            based           pointer                  level 3 in structure "channel_info" dcl 323
                                                                                  in procedure "hasp_workstation_" set ref 621* 1694
                                                                                  1696 1698 1700* 1700
previous                546            based           pointer                  level 3 in structure "had" dcl 301 in procedure
                                                                                  "hasp_workstation_" set ref 634* 1636 1638 1640
                                                                                  1642* 1642
previous_data                   001113 automatic       varying char(64)         dcl 186 set ref 964* 996 997 1000 1000 1001 1008*
                                                                                  1052*
priority                  6            based           fixed bin(17,0)          level 2 dcl 209 set ref 1488*
procedure                              based           entry variable           level 2 dcl 209 set ref 1488*
read_record              72            based           entry variable           level 2 dcl 5-6 set ref 801* 848*
read_status                     000624 automatic       structure                level 1 dcl 160 set ref 1963 1963
read_status_info                       based           structure                level 1 dcl 206
rel                                                    builtin function         dcl 295 ref 944 944
requote_string_                 000216 constant        entry                    external dcl 287 ref 520
reservation_string       32     000340 automatic       char(256)                level 2 dcl 141 set ref 657* 1685*
rtrim                                                  builtin function         dcl 295 ref 588 590 592 595 793 1426 1888 1930
sent_on_call                    001324 automatic       fixed bin(21,0)          dcl 2106 set ref 2124* 2129
set_forms_info                         based           structure                level 1 dcl 4-6
set_term_type_info                     based           structure                level 1 dcl 16-8
skip_to_channel           0(04)        based           bit(1)                   level 2 in structure "hasp_printer_srcb" packed
                                                                                  packed unaligned dcl 197 in procedure
                                                                                  "hasp_workstation_" set ref 2065* 2072*
skip_to_channel           2            based           bit(1)                   array level 3 in structure "slew_sequence" dcl 358
                                                                                  in procedure "hasp_workstation_" set ref 557*
                                                                                  1933* 1935* 2072
slew_control              2            based           structure                level 3 dcl 1-8
slew_count                2(18)        based           fixed bin(18,0)          level 4 packed packed unsigned unaligned dcl 1-8 set
                                                                                  ref 1104* 1211 2012 2066
slew_sequence                          based           structure                level 1 dcl 358 set ref 555 1648 1651 1654 1919
slew_sequence_n_ops             001176 automatic       fixed bin(17,0)          dcl 365 set ref 554* 555 555 1877* 1908* 1908 1919
                                                                                  1919
slew_sequence_ptr               001174 automatic       pointer                  dcl 364 set ref 555* 556 557 558 559 560 1919* 1933
                                                                                  1935 1938 1943 2019* 2021* 2023* 2072 2073 2074
slew_type                 2            based           fixed bin(18,0)          level 4 packed packed unsigned unaligned dcl 1-8 set
                                                                                  ref 1103* 1211 1213 1215 1217 1219 2012 2014 2019
                                                                                  2021 2023 2057 2063
space                   542            based           char(1)                  level 3 dcl 301 set ref 427* 476* 1024* 1248 1248
                                                                                  1248* 1251* 1264 1264 1264* 1268* 1288 1288 1288*
                                                                                  1543*
srcb                                   based           char(1)                  packed unaligned dcl 194 set ref 1017* 2038* 2039*
srcb_ptr                        001140 automatic       pointer                  dcl 195 set ref 966* 1017 2036* 2038 2039 2053* 2055
                                                                                  2058 2059 2065 2066 2072 2073
srcb_read                       001136 automatic       char(1)                  packed unaligned dcl 190 set ref 966
start                           000120 automatic       fixed bin(21,0)          dcl 1867 set ref 1876* 1882 1884 1885 1888 1910*
                                                                                  1910 1921* 1924 1926 1927 1930 1940* 1940
state                           000520 automatic       fixed bin(17,0)          dcl 152 set ref 702* 703 714* 715 729* 730 1329*
                                                                                  1370* 1371 1450* 1451 1466* 1467 1475* 1476 1519*
                                                                                  1547* 1548 1579* 1580 1602* 1603 1963* 1964 1982*
                                                                                  1983 2116* 2117 2124* 2126 2132* 2133
status_code               1     000100 automatic       fixed bin(35,0)          level 2 dcl 1716 set ref 1729*
sti_ptr                         001210 automatic       pointer                  dcl 4-10 set ref 1420* 1422 1426
stop_time                       000266 automatic       fixed bin(71,0)          dcl 131 set ref 921* 1137* 1970* 1976 1987 2137
                                                                                  2148*
string                                                 builtin function         dcl 295 set ref 617* 1106*
stti_version_1                         constant        fixed bin(17,0)          initial dcl 16-5 ref 1527
sttip                           001220 automatic       pointer                  dcl 16-6 set ref 1526* 1527 1533
substr                                                 builtin function         dcl 295 set ref 436 520 520 522 1000* 1001* 1001
                                                                                  1017 1052 1073 1848* 1884 1888 1894 1894 1894 1894
                                                                                  1898 1898 1899 1899 1903 1903 1926 1930 1933 1937
                                                                                  1937 2095*
suppress_dial_manager
                         42(05)        based           bit(1)                   level 3 packed packed unaligned dcl 323 set ref 646*
                                                                                  1681
suppress_dial_manager_sw        000161 automatic       bit(1)                   dcl 128 set ref 415* 526* 646 647 703 705 715 730
system_area                            based           area(1024)               dcl 119 ref 407 555 610 935 998 1003 1042 1045 1064
                                                                                  1071 1115 1155 1236 1307 1462 1648 1651 1654 1657
                                                                                  1702 1919
system_area_ptr                 000124 automatic       pointer                  dcl 120 set ref 396* 407 555 610 875* 930* 935 998
                                                                                  1003 1042 1045 1064 1071 1115 1150* 1155 1236 1307
                                                                                  1462 1648 1651 1654 1657 1702 1919
tables                   12     000304 automatic       structure                level 2 dcl 139
temp_state                      000103 automatic       fixed bin(17,0)          dcl 100 set ref 1588* 1589 1594* 1595
terminal_io_record                     based           structure                level 1 dcl 1-8 set ref 1170 1177
terminal_io_record_data_chars          based           char                     packed unaligned dcl 1-54 set ref 1089 1089 1191
                                                                                  1191 1191 1191
terminal_io_record_header_lth   001112 automatic       fixed bin(21,0)          dcl 184 set ref 944* 947 952 1110
terminal_io_record_n_elements   001206 automatic       fixed bin(24,0)          dcl 1-31 set ref 952* 1088 1092
terminal_io_record_ptr          001204 automatic       pointer                  dcl 1-28 set ref 942* 944 944 989 1088 1089 1089
                                                                                  1089 1089 1089 1098 1100 1101 1103 1104 1106 1108
                                                                                  1110 1163* 1165 1170 1177 1183 1183 1183 1191 1191
                                                                                  1191 1191 1191 1191 1191 1191 1191 1198 1198 1211
                                                                                  1211 1213 1215 1217 1219 1264 1268 1268 1268 2012
                                                                                  2012 2014 2019 2021 2023 2057 2063 2066
terminal_io_record_version_1           constant        fixed bin(17,0)          initial dcl 1-36 ref 1098 1165
terminal_type                   000150 automatic       char(32)                 packed unaligned dcl 126 set ref 412* 462* 463* 463
                                                                                  465* 466* 467* 593 595
terminal_type_data                     based           structure                level 1 dcl 12-15
terminate_process_              000220 constant        entry                    external dcl 288 ref 1731
the_code                               based           fixed bin(35,0)          dcl 1745 set ref 1754* 1759 1761
the_code_ptr                    000100 automatic       pointer                  dcl 1746 set ref 1750* 1754 1759 1761
the_number                      000122 automatic       fixed bin(35,0)          dcl 1868 set ref 1898* 1903 1903 1903 1903 1937*
                                                                                  1938
the_value                       001250 automatic       fixed bin(35,0)          dcl 1799 set ref 1811* 1817
timeout                                based           fixed bin(71,0)          level 2 in structure "input_timeout_info" dcl 15-4
                                                                                  in procedure "hasp_workstation_" set ref 1563*
timeout                                based           fixed bin(71,0)          level 2 in structure "output_timeout_info" dcl 15-10
                                                                                  in procedure "hasp_workstation_" set ref 1570*
timeout                         000264 automatic       fixed bin(71,0)          dcl 130 in procedure "hasp_workstation_" set ref
                                                                                  904* 906* 919* 921 1128* 1134* 1135 1135* 1137
                                                                                  1137 1298 1960 1970 1974 1976 1985 2137 2137 2148
timeout_info_ptr                001216 automatic       pointer                  dcl 15-16 set ref 1561* 1562 1563 1563 1563 1563
                                                                                  1569* 1570 1570 1570 1570
timer_manager_$alarm_wakeup     000222 constant        entry                    external dcl 289 ref 1970 2147 2148
timer_manager_$reset_alarm_wakeup
                                000224 constant        entry                    external dcl 290 ref 1974 2152
top_of_page_sequence_ptr
                        112            based           pointer                  level 2 dcl 301 set ref 420* 496* 550 558 558* 564
                                                                                  569 1213 1648 1648 2019
translate                                              builtin function         dcl 295 ref 463 476 518 581 1428 1429 1543
translate_string                       based           char                     packed unaligned dcl 1844 ref 1846 1848 1848 1848
translations            142            based           structure                level 2 dcl 301
transmitted                            parameter       fixed bin(21,0)          dcl 2106 set ref 2103 2113* 2122 2124 2124 2124
                                                                                  2129* 2129 2131 2140
ttd                             000304 automatic       structure                level 1 dcl 139 set ref 465 465 1533 1533 1547 1547
ttd_version_3                          constant        fixed bin(17,0)          initial dcl 12-54 ref 464 1532
ttt_info_$terminal_data         000226 constant        entry                    external dcl 291 ref 465 1533
tty_channel                     000127 automatic       char(32)                 packed unaligned dcl 124 set ref 410* 445* 544 590
                                                                                  605 611 626* 656 661* 669* 673* 702* 712* 720*
                                                                                  723* 725* 732*
tty_get_channel_info                   based           structure                level 1 dcl 14-5
tty_get_channel_info_version           constant        fixed bin(17,0)          initial dcl 14-10 ref 1501
tty_modes                       000522 automatic       structure                level 1 dcl 156 set ref 729 729
unspec                                                 builtin function         dcl 295 ref 671 671
value                     2            based           fixed bin(8,0)           array level 3 packed packed unaligned dcl 13-107 set
                                                                                  ref 470 470 470 470 473 473 473 473 1535 1535 1535
                                                                                  1535 1540 1540 1540 1540
version                         000340 automatic       fixed bin(17,0)          level 2 in structure "dma" dcl 141 in procedure
                                                                                  "hasp_workstation_" set ref 654* 1682*
version                                based           fixed bin(17,0)          level 3 in structure "terminal_io_record" dcl 1-8
                                                                                  in procedure "hasp_workstation_" set ref 1098*
                                                                                  1165
version                                based           fixed bin(17,0)          level 2 in structure "set_forms_info" dcl 4-6
                                                                                  in procedure "hasp_workstation_" ref 1422
version                         000304 automatic       fixed bin(17,0)          level 2 in structure "ttd" dcl 139 in procedure
                                                                                  "hasp_workstation_" set ref 464* 1532*
version                                based           fixed bin(17,0)          initial level 2 in structure "get_channel_info"
                                                                                  dcl 214 in procedure "hasp_workstation_" ref 1501
version                                based           fixed bin(17,0)          level 2 in structure "set_term_type_info" dcl 16-8
                                                                                  in procedure "hasp_workstation_" ref 1527
version                         000100 automatic       fixed bin(17,0)          level 2 in structure "fatal_error_info" dcl 1716
                                                                                  in procedure "any_other_handler" set ref 1728*
write_record             76            based           entry variable           level 2 dcl 5-6 set ref 804* 848*
write_status                    000630 automatic       structure                level 1 dcl 164 set ref 1370 1370 2132 2132

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_SECONDS                       internal static bit(2)                   initial packed unaligned dcl 17-12
CV_TRANS_SIZE                          internal static fixed bin(17,0)          initial array dcl 13-129
CV_TRANS_VERSION                       internal static fixed bin(17,0)          initial dcl 13-127
DELAY_VERSION                          internal static fixed bin(17,0)          initial dcl 13-126
Direct_input                           internal static fixed bin(17,0)          initial dcl 6-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 6-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 6-15
HASP_MAX_COMPRESSED_TEXT_LTH           internal static fixed bin(17,0)          initial dcl 3-100
HASP_MAX_DEVICE_RECORD_LTHS            internal static fixed bin(21,0)          initial array dcl 2-20
INPUT_CONVERT_BREAK                    internal static fixed bin(8,0)           initial packed unaligned dcl 13-135
INPUT_CONVERT_DISCARD                  internal static fixed bin(8,0)           initial packed unaligned dcl 13-135
INPUT_CONVERT_DSA_CR_PROCESSING        internal static fixed bin(8,0)           initial packed unaligned dcl 13-135
INPUT_CONVERT_ESCAPE                   internal static fixed bin(8,0)           initial packed unaligned dcl 13-135
INPUT_CONVERT_FORMFEED                 internal static fixed bin(8,0)           initial packed unaligned dcl 13-135
INPUT_CONVERT_ORDINARY                 internal static fixed bin(8,0)           initial packed unaligned dcl 13-135
INPUT_CONVERT_PRECEDENCE_DISCARD       internal static fixed bin(8,0)           initial packed unaligned dcl 13-135
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 6-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 6-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 6-15
LINE_1050                              internal static fixed bin(17,0)          initial dcl 11-22
LINE_2741                              internal static fixed bin(17,0)          initial dcl 11-22
LINE_ARDS                              internal static fixed bin(17,0)          initial dcl 11-22
LINE_ASCII                             internal static fixed bin(17,0)          initial dcl 11-22
LINE_ASYNC1                            internal static fixed bin(17,0)          initial dcl 11-22
LINE_ASYNC2                            internal static fixed bin(17,0)          initial dcl 11-22
LINE_ASYNC3                            internal static fixed bin(17,0)          initial dcl 11-22
LINE_BSC                               internal static fixed bin(17,0)          initial dcl 11-22
LINE_COLTS                             internal static fixed bin(17,0)          initial dcl 11-22
LINE_DSA                               internal static fixed bin(17,0)          initial dcl 11-22
LINE_ETX                               internal static fixed bin(17,0)          initial dcl 11-22
LINE_G115                              internal static fixed bin(17,0)          initial dcl 11-22
LINE_HDLC                              internal static fixed bin(17,0)          initial dcl 11-22
LINE_MC                                internal static fixed bin(17,0)          initial dcl 11-22
LINE_POLLED_VIP                        internal static fixed bin(17,0)          initial dcl 11-22
LINE_SYNC1                             internal static fixed bin(17,0)          initial dcl 11-22
LINE_SYNC2                             internal static fixed bin(17,0)          initial dcl 11-22
LINE_SYNC3                             internal static fixed bin(17,0)          initial dcl 11-22
LINE_SYNCH                             internal static fixed bin(17,0)          initial dcl 11-22
LINE_TELNET                            internal static fixed bin(17,0)          initial dcl 11-22
LINE_UNKNOWN                           internal static fixed bin(17,0)          initial dcl 11-22
LINE_VIP                               internal static fixed bin(17,0)          initial dcl 11-22
LINE_X25LAP                            internal static fixed bin(17,0)          initial dcl 11-22
OUTPUT_CONVERT_BRS                     internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
OUTPUT_CONVERT_BS                      internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
OUTPUT_CONVERT_CR                      internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
OUTPUT_CONVERT_DONT_SEND               internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
OUTPUT_CONVERT_FF                      internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
OUTPUT_CONVERT_FIRST_SPECIAL           internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
OUTPUT_CONVERT_HT                      internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
OUTPUT_CONVERT_NEWLINE                 internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
OUTPUT_CONVERT_NOT_USED_13             internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
OUTPUT_CONVERT_NOT_USED_14             internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
OUTPUT_CONVERT_NOT_USED_15             internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
OUTPUT_CONVERT_NOT_USED_16             internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
OUTPUT_CONVERT_NO_MOTION               internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
OUTPUT_CONVERT_OCTAL                   internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
OUTPUT_CONVERT_ORDINARY                internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
OUTPUT_CONVERT_PRECEDENCE_NO_MOTION    internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
OUTPUT_CONVERT_RRS                     internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
OUTPUT_CONVERT_VT                      internal static fixed bin(8,0)           initial packed unaligned dcl 13-147
PRINTER_DEVICE                         internal static fixed bin(17,0)          initial dcl 1-38
PUNCH_DEVICE                           internal static fixed bin(17,0)          initial dcl 1-38
RELATIVE_MICROSECONDS                  internal static bit(2)                   initial packed unaligned dcl 17-13
SPECIAL_INFO_STRUCT_VERSION_1          internal static char(8)                  initial packed unaligned dcl 13-122
SPECIAL_VERSION                        internal static fixed bin(17,0)          initial dcl 13-124
SPECIAL_VERSION_2                      internal static fixed bin(17,0)          initial dcl 13-125
Sequential_update                      internal static fixed bin(17,0)          initial dcl 6-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 6-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 6-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 6-15
TEMPLATE_HASP_PRINTER_SRCB             based           char(1)                  dcl 3-60
TEMPLATE_HASP_PRINTER_SRCB_BITS        internal static structure                level 1 dcl 3-52
c_chars_ptr                            automatic       pointer                  dcl 13-53
delay_struc                            based           structure                level 1 dcl 13-112
dial_manager_arg_version_3             internal static fixed bin(17,0)          initial dcl 8-11
dial_manager_arg_version_4             internal static fixed bin(17,0)          initial dcl 8-12
event_wait_info_ptr                    automatic       pointer                  dcl 10-5
get_special_info_struc                 based           structure                level 1 dcl 13-117
hasp_card_srcb_byte                    based           structure                level 1 packed packed unaligned dcl 3-21
hasp_card_srcb_byte_ptr                automatic       pointer                  dcl 3-28
hasp_compressed_scb_byte               based           structure                level 1 packed packed unaligned dcl 3-88
hasp_not_compressed_scb_byte           based           structure                level 1 packed packed unaligned dcl 3-82
hasp_printer_srcb_byte_ptr             automatic       pointer                  dcl 3-50
hasp_scb_byte                          based           structure                level 1 packed packed unaligned dcl 3-76
hasp_scb_byte_ptr                      automatic       pointer                  dcl 3-95
io_call_af_ret                         based           varying char             dcl 7-25
io_call_infop                          automatic       pointer                  dcl 7-8
iox_$iocb_version_sentinel             external static char(4)                  dcl 5-51
line_types                             internal static char(16)                 initial array packed unaligned dcl 11-54
max_line_type                          internal static fixed bin(17,0)          initial dcl 11-48
n_sync_line_types                      internal static fixed bin(17,0)          initial dcl 11-50
sc_escape_len                          automatic       fixed bin(17,0)          dcl 13-58
sc_input_escape_len                    automatic       fixed bin(17,0)          dcl 13-59
short_iox_modes                        internal static char(4)                  initial array dcl 6-12
special_chars                          based           structure                level 1 dcl 13-26
special_chars_struc                    based           structure                level 1 dcl 13-76
sync_line_type                         internal static fixed bin(17,0)          initial array dcl 11-52
terminal_io_record_data_bits           based           bit                      packed unaligned dcl 1-64
terminal_io_record_data_chars_varying  based           varying char             dcl 1-58
terminal_io_record_data_chars_varying_max_len
                                       automatic       fixed bin(21,0)          dcl 1-57
terminal_io_record_element_size        automatic       fixed bin(17,0)          dcl 1-30
ttdp                                   automatic       pointer                  dcl 12-53

NAMES DECLARED BY EXPLICIT CONTEXT.
ASSUME_ATTACHED                 004465 constant        label                    dcl 685 ref 647 660
FOUND_CHANNEL                   003764 constant        label                    dcl 608 ref 605
READ_JOIN                       006131 constant        label                    dcl 921 ref 907
RETURN_FROM_ATTACH              005244 constant        label                    dcl 754 ref 1763
RETURN_FROM_CONTROL             011703 constant        label                    dcl 1607 ref 1372 1378 1391 1401 1520 1529 1534
RETURN_FROM_READ_RECORD         006776 constant        label                    dcl 1115 ref 987 1040 1058 1084
RETURN_FROM_WRITE_RECORD        010016 constant        label                    dcl 1307 ref 1234 1274
WAIT_FOR_ANSWERING_SERVICE      004262 constant        label                    dcl 666 set ref 679
WRITE_JOIN                      007073 constant        label                    dcl 1137 ref 1129
WRITE_RECORD_BAD_DATA           007700 constant        label                    dcl 1272 ref 1254 1290 2090
abort_attachment                012432 constant        entry                    internal dcl 1742 ref 403 436 441 454 466 467 489
                                                                                  492 515 535 541 544 547 570 575 626 652 661 669
                                                                                  673 694 705 712 720 723 725 732 1776 1784 1803
                                                                                  1813 1890 1894 1899 1903 1916
add_character_to_io_buffer      014514 constant        entry                    internal dcl 2085 ref 1247 1255 1277 1292 2035 2052
any_other_handler               012335 constant        entry                    internal dcl 1713 ref 740 797 838 884
cleanup_attachment              011750 constant        entry                    internal dcl 1623 ref 398 880 1757
generate_next_srcb              014404 constant        entry                    internal dcl 2049 ref 1286 2027
generate_record_srcb            014306 constant        entry                    internal dcl 2001 ref 1262
get_numeric_argument            012760 constant        entry                    internal dcl 1795 ref 481
get_string_argument             012627 constant        entry                    internal dcl 1769 ref 440 445 449 462 514 1874
hasp_workstation_               001420 constant        entry                    external dcl 57
hasp_workstation_attach         001434 constant        entry                    external dcl 381
hasp_workstation_close          005533 constant        entry                    external dcl 826 ref 810
hasp_workstation_control        010200 constant        entry                    external dcl 1335 ref 807 1326 1408
hasp_workstation_control_before_open
                                010045 constant        entry                    external dcl 1316 ref 747 846
hasp_workstation_detach         005676 constant        entry                    external dcl 860 ref 748 812 845
hasp_workstation_modes          011713 constant        entry                    external dcl 1613 ref 808
hasp_workstation_open           005254 constant        entry                    external dcl 760 ref 746 844
hasp_workstation_read_record    006045 constant        entry                    external dcl 899 ref 801
hasp_workstation_read_record_timed
                                006101 constant        entry                    external dcl 909 ref 1563
hasp_workstation_write_record   007025 constant        entry                    external dcl 1125 ref 804
hasp_workstation_write_record_timed
                                007051 constant        entry                    external dcl 1131 ref 1570
init_read                       013125 constant        entry                    internal dcl 1821 ref 902 912
parse_slew_sequence             013175 constant        entry                    internal dcl 1861 ref 496 502 508
read_io_buffer                  014047 constant        entry                    internal dcl 1951 ref 986
release_channel                 012100 constant        entry                    internal dcl 1667 ref 1644
set_translation                 013140 constant        entry                    internal dcl 1837 ref 423 425 470 473 1535 1540
write_io_buffer                 014531 constant        entry                    internal dcl 2103 ref 1298 1300 1400

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     16666       17116   15310       16676
Length     20166   15310       230        1034    1355           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
hasp_workstation_                   992 external procedure  is an external procedure.  
on unit on line 398                  72 on unit               
on unit on line 740                  64 on unit               
on unit on line 797                  64 on unit               
on unit on line 838                  64 on unit               
on unit on line 884                  64 on unit               
on unit on line 933                  66 on unit               
on unit on line 1037                 64 on unit               
on unit on line 1153                 66 on unit               
on unit on line 1231                 64 on unit               
cleanup_attachment                   84 internal procedure  is called by several nonquick procedures.  
release_channel                         internal procedure  shares stack frame of internal procedure cleanup_attachment.  
any_other_handler                    92 internal procedure  is declared options(non_quick).  
abort_attachment                    178 internal procedure  is declared options(non_quick), and is declared options(variable).  
get_string_argument                 114 internal procedure  uses returns(char(*)) or returns(bit(*)).  
get_numeric_argument                    internal procedure  shares stack frame of external procedure hasp_workstation_.  
init_read                               internal procedure  shares stack frame of external procedure hasp_workstation_.  
set_translation                         internal procedure  shares stack frame of external procedure hasp_workstation_.  
parse_slew_sequence                 162 internal procedure  enables or reverts conditions.  
on unit on line 1916                 94 on unit               
read_io_buffer                          internal procedure  shares stack frame of external procedure hasp_workstation_.  
generate_record_srcb                    internal procedure  shares stack frame of external procedure hasp_workstation_.  
generate_next_srcb                      internal procedure  shares stack frame of external procedure hasp_workstation_.  
add_character_to_io_buffer              internal procedure  shares stack frame of external procedure hasp_workstation_.  
write_io_buffer                         internal procedure  shares stack frame of external procedure hasp_workstation_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 first_channel_info_ptr      hasp_workstation_
000012 last_channel_info_ptr       hasp_workstation_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
abort_attachment         000100 the_code_ptr                abort_attachment
                         000102 caller_message              abort_attachment
any_other_handler        000100 fatal_error_info            any_other_handler
get_string_argument      000100 option_name                 get_string_argument
hasp_workstation_        000100 iocb_ptr                    hasp_workstation_
                         000102 code                        hasp_workstation_
                         000103 temp_state                  hasp_workstation_
                         000104 argument_lth                hasp_workstation_
                         000106 argument_ptr                hasp_workstation_
                         000110 loud_sw                     hasp_workstation_
                         000111 open_mode                   hasp_workstation_
                         000112 order                       hasp_workstation_
                         000122 info_ptr                    hasp_workstation_
                         000124 system_area_ptr             hasp_workstation_
                         000126 argument_idx                hasp_workstation_
                         000127 tty_channel                 hasp_workstation_
                         000137 device_name                 hasp_workstation_
                         000147 have_comm                   hasp_workstation_
                         000150 terminal_type               hasp_workstation_
                         000160 block_on_io_sw              hasp_workstation_
                         000161 suppress_dial_manager_sw    hasp_workstation_
                         000162 other_attach_options        hasp_workstation_
                         000264 timeout                     hasp_workstation_
                         000266 stop_time                   hasp_workstation_
                         000270 device_type                 hasp_workstation_
                         000271 idx                         hasp_workstation_
                         000272 character_value             hasp_workstation_
                         000302 numeric_value               hasp_workstation_
                         000304 ttd                         hasp_workstation_
                         000340 dma                         hasp_workstation_
                         000500 local_event_wait_info       hasp_workstation_
                         000507 dialup_msg_channel          hasp_workstation_
                         000517 dialup_msg_flags            hasp_workstation_
                         000520 state                       hasp_workstation_
                         000521 multiplexer_device_type     hasp_workstation_
                         000522 tty_modes                   hasp_workstation_
                         000624 read_status                 hasp_workstation_
                         000630 write_status                hasp_workstation_
                         000633 ips_mask                    hasp_workstation_
                         000634 cv_string_buffer_lth        hasp_workstation_
                         000635 cv_string_buffer_used_lth   hasp_workstation_
                         000636 cv_string_buffer_ptr        hasp_workstation_
                         000640 new_cv_string_buffer_ptr    hasp_workstation_
                         000642 io_buffer_lth               hasp_workstation_
                         000643 io_buffer_used              hasp_workstation_
                         000644 io_buffer_read              hasp_workstation_
                         000646 io_buffer_ptr               hasp_workstation_
                         000650 cv_string_buffer_space      hasp_workstation_
                         001010 io_buffer_space             hasp_workstation_
                         001110 compress_code               hasp_workstation_
                         001111 expand_code                 hasp_workstation_
                         001112 terminal_io_record_header_lth
                                                            hasp_workstation_
                         001113 previous_data               hasp_workstation_
                         001134 have_srcb                   hasp_workstation_
                         001135 more_data_needed            hasp_workstation_
                         001136 srcb_read                   hasp_workstation_
                         001137 n_extra_records             hasp_workstation_
                         001140 srcb_ptr                    hasp_workstation_
                         001142 more_srcbs_needed           hasp_workstation_
                         001143 n_last_opcode               hasp_workstation_
                         001144 local_slew_count            hasp_workstation_
                         001170 had_ptr                     hasp_workstation_
                         001172 channel_info_ptr            hasp_workstation_
                         001174 slew_sequence_ptr           hasp_workstation_
                         001176 slew_sequence_n_ops         hasp_workstation_
                         001200 held_input_ptr              hasp_workstation_
                         001202 held_input_n_elements_allocated
                                                            hasp_workstation_
                         001204 terminal_io_record_ptr      hasp_workstation_
                         001206 terminal_io_record_n_elements
                                                            hasp_workstation_
                         001210 sti_ptr                     hasp_workstation_
                         001212 event_wait_channel          hasp_workstation_
                         001216 timeout_info_ptr            hasp_workstation_
                         001220 sttip                       hasp_workstation_
                         001240 option_name                 get_numeric_argument
                         001250 the_value                   get_numeric_argument
                         001324 sent_on_call                write_io_buffer
parse_slew_sequence      000100 option_name                 parse_slew_sequence
                         000110 operation                   parse_slew_sequence
                         000120 start                       parse_slew_sequence
                         000121 next_colon                  parse_slew_sequence
                         000122 the_number                  parse_slew_sequence
                         000123 next_op                     parse_slew_sequence

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              alloc_char_temp     call_ext_in_desc    call_ext_in         call_ext_out_desc
call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc call_int_other      return_mac
tra_ext_1           mdfx1               enable_op           shorten_stack       ext_entry           ext_entry_desc
int_entry           int_entry_desc      set_chars_eis       return_chars_eis    translate_2         fetch_chars_eis
op_alloc_           op_freen_           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      continue_to_signal_           convert_dial_message_         cu_$arg_list_ptr
cu_$arg_ptr                   cv_dec_check_                 dial_manager_$privileged_attach
dial_manager_$release_channel get_group_id_                 get_system_free_area_         hasp_util_$compress_text
hasp_util_$expand_text        hcs_$assign_channel           hcs_$delete_channel           hcs_$reset_ips_mask
hcs_$set_ips_mask             hcs_$tty_abort                hcs_$tty_attach               hcs_$tty_detach
hcs_$tty_detach_new_proc      hcs_$tty_event                hcs_$tty_order                hcs_$tty_read
hcs_$tty_state                hcs_$tty_write                ioa_$general_rs               iox_$err_no_operation
iox_$propagate                ipc_$block                    ipc_$create_ev_chn            ipc_$decl_ev_call_chn
ipc_$decl_ev_wait_chn         ipc_$delete_ev_chn            mvt_                          requote_string_
terminate_process_            timer_manager_$alarm_wakeup   timer_manager_$reset_alarm_wakeup
ttt_info_$terminal_data

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
ascii_to_ebcdic_$ae_table     ebcdic_to_ascii_$ea_table     error_table_$action_not_performed
error_table_$bad_conversion   error_table_$bad_mode         error_table_$badopt           error_table_$bigarg
error_table_$device_type_unknown                            error_table_$eof_record
error_table_$improper_data_format                           error_table_$inconsistent
error_table_$incorrect_device_type                          error_table_$invalid_device   error_table_$invalid_read
error_table_$invalid_write    error_table_$io_no_permission error_table_$long_record      error_table_$noalloc
error_table_$noarg            error_table_$not_attached     error_table_$not_closed       error_table_$not_detached
error_table_$not_open         error_table_$null_info_ptr    error_table_$short_record     error_table_$smallarg
error_table_$timeout          error_table_$unable_to_do_io  error_table_$undefined_order_request
error_table_$unimplemented_version                          error_table_$wrong_no_of_args




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 9    8 001413        57 001417        60 001426       381 001427       384 001453       385 001457       386 001464
    388 001465       390 001467       391 001472       392 001475       393 001527       396 001530       398 001537
    403 001564       407 001611       409 001616       410 001617       411 001622       412 001625       414 001630
    415 001632       417 001633       419 001634       420 001635       422 001641       423 001643       425 001662
    427 001702       428 001705       431 001707       433 001721       434 001740       436 001742       439 001766
    440 001774       441 002014       442 002043       443 002045       445 002046       448 002073       449 002100
    450 002120       451 002123       452 002134       453 002145       454 002147       458 002210       460 002211
    462 002221       463 002241       464 002253       465 002256       466 002313       467 002343       470 002377
    473 002417       476 002437       477 002450       479 002452       481 002462       482 002464       483 002476
    484 002511       486 002512       489 002531       492 002556       495 002607       496 002613       497 002622
    498 002634       499 002647       501 002650       502 002654       503 002663       504 002675       505 002710
    507 002711       508 002715       509 002724       510 002736       511 002751       513 002752       514 002756
    515 002776       518 003030       519 003041       520 003054       522 003120       523 003132       525 003133
    526 003137       527 003141       528 003153       530 003154       531 003160       532 003161       533 003173
    535 003174       536 003222       541 003224       544 003245       547 003270       550 003315       554 003335
    555 003337       556 003350       557 003352       558 003354       559 003362       560 003367       562 003374
    564 003375       567 003412       568 003420       569 003426       570 003434       575 003464       580 003521
    581 003527       582 003546       588 003554       589 003574       590 003606       591 003632       592 003644
    593 003670       594 003674       595 003706       597 003732       603 003744       605 003754       606 003761
    608 003764       610 003770       611 003775       612 004000       613 004002       614 004007       615 004012
    616 004013       617 004014       618 004015       620 004023       621 004025       622 004027       623 004031
    624 004032       626 004033       631 004076       633 004106       634 004111       635 004113       636 004115
    638 004116       643 004117       645 004122       646 004127       647 004134       651 004136       652 004147
    654 004170       655 004172       656 004175       657 004200       659 004211       660 004224       661 004230
    663 004255       664 004257       666 004262       669 004301       671 004326       673 004371       675 004416
    676 004421       679 004464       685 004465       688 004470       690 004501       693 004507       694 004521
    695 004542       702 004545       703 004575       705 004605       712 004632       714 004657       715 004716
    717 004726       720 004735       723 004776       725 005026       727 005051       728 005054       729 005056
    730 005113       732 005123       738 005150       740 005151       742 005173       744 005206       745 005211
    746 005213       747 005217       748 005222       750 005225       752 005234       754 005244       756 005246
    760 005247       763 005265       765 005272       766 005276       767 005301       770 005302       772 005304
    774 005312       775 005315       778 005316       779 005320       781 005322       783 005330       784 005333
    787 005334       789 005344       790 005347       793 005350       795 005401       797 005402       799 005424
    801 005437       804 005453       807 005465       808 005472       810 005475       812 005500       814 005503
    817 005506       819 005515       821 005525       822 005526       826 005527       829 005544       831 005551
    832 005555       833 005560       836 005561       838 005562       840 005604       842 005617       844 005622
    845 005626       846 005631       848 005634       850 005654       852 005662       854 005672       856 005673
    860 005674       863 005707       865 005713       866 005717       867 005722       870 005723       871 005727
    872 005732       875 005733       877 005742       878 005745       880 005747       882 005755       884 005756
    886 006000       888 006013       890 006016       892 006025       894 006035       895 006037       899 006040
    902 006060       904 006061       906 006070       907 006072       909 006073       912 006116       914 006117
    915 006123       916 006126       919 006127       921 006131       923 006134       925 006135       926 006143
    927 006146       930 006147       931 006156       933 006160       935 006174       937 006214       942 006215
    944 006221       947 006232       948 006235       949 006240       952 006241       960 006244       961 006246
    962 006250       964 006251       966 006252       967 006254       969 006255       972 006257       976 006262
    978 006267       979 006272       980 006274       981 006276       984 006277       985 006301       986 006303
    987 006304       988 006306       989 006310       990 006312       991 006313       992 006314       996 006315
    997 006317       998 006321       999 006333      1000 006334      1001 006341      1003 006346      1005 006364
   1006 006367      1007 006371      1008 006374      1014 006375      1017 006401      1018 006406      1019 006410
   1022 006412      1024 006417      1028 006451      1031 006455      1034 006461      1036 006463      1037 006466
   1039 006502      1040 006505      1042 006510      1043 006517      1044 006520      1045 006525      1047 006540
   1048 006542      1050 006543      1052 006552      1053 006563      1054 006565      1057 006566      1058 006570
   1060 006571      1062 006572      1064 006603      1065 006613      1067 006616      1069 006617      1070 006622
   1071 006625      1072 006637      1073 006640      1074 006654      1075 006672      1082 006675      1083 006677
   1084 006702      1088 006703      1089 006710      1092 006736      1098 006744      1100 006746      1101 006756
   1103 006763      1104 006766      1106 006770      1108 006771      1110 006773      1115 006776      1119 007015
   1120 007017      1125 007020      1128 007040      1129 007042      1131 007043      1134 007066      1135 007070
   1137 007073      1140 007077      1141 007104      1142 007106      1143 007110      1145 007111      1146 007114
   1147 007117      1150 007120      1151 007127      1153 007131      1155 007145      1157 007165      1163 007166
   1165 007172      1166 007175      1167 007200      1170 007201      1174 007217      1175 007222      1176 007223
   1177 007224      1179 007240      1180 007243      1183 007244      1184 007253      1185 007256      1191 007257
   1198 007303      1205 007317      1208 007323      1211 007343      1213 007355      1215 007363      1217 007371
   1219 007377      1221 007402      1225 007405      1227 007410      1228 007412      1229 007414      1231 007415
   1233 007431      1234 007434      1236 007437      1239 007446      1245 007447      1247 007462      1248 007466
   1251 007530      1254 007565      1255 007567      1262 007573      1264 007574      1268 007640      1271 007676
   1272 007700      1274 007703      1277 007704      1284 007710      1286 007712      1288 007713      1290 007753
   1292 007755      1293 007761      1298 007762      1300 007773      1302 010002      1307 010016      1311 010035
   1312 010037      1316 010040      1319 010064      1320 010071      1321 010073      1323 010075      1324 010102
   1325 010105      1326 010106      1329 010143      1330 010173      1333 010175      1335 010176      1338 010217
   1339 010224      1340 010226      1342 010230      1343 010235      1344 010240      1347 010241      1351 010245
   1352 010251      1353 010254      1356 010255      1357 010260      1361 010262      1366 010266      1368 010270
   1370 010272      1371 010331      1372 010337      1374 010341      1375 010343      1376 010345      1377 010350
   1378 010367      1380 010371      1381 010372      1384 010373      1389 010377      1390 010402      1391 010405
   1394 010406      1398 010411      1399 010413      1400 010416      1401 010421      1402 010423      1405 010435
   1408 010436      1409 010465      1412 010466      1416 010472      1420 010502      1422 010504      1426 010513
   1428 010535      1429 010553      1430 010573      1432 010574      1435 010575      1439 010601      1443 010611
   1445 010613      1450 010623      1451 010657      1454 010665      1457 010666      1462 010672      1464 010705
   1466 010710      1467 010727      1468 010735      1471 010736      1475 010742      1476 010761      1477 010767
   1480 010770      1484 010774      1488 011004      1490 011024      1492 011031      1495 011032      1499 011036
   1501 011046      1505 011055      1506 011060      1508 011063      1511 011064      1513 011071      1515 011076
   1516 011106      1517 011123      1518 011137      1519 011142      1520 011157      1521 011161      1522 011164
   1523 011166      1525 011167      1526 011173      1527 011175      1528 011200      1529 011203      1532 011204
   1533 011206      1534 011244      1535 011246      1539 011272      1540 011276      1543 011316      1544 011327
   1547 011330      1548 011371      1549 011377      1551 011400      1553 011404      1555 011414      1557 011426
   1558 011427      1560 011430      1561 011434      1562 011436      1563 011440      1566 011460      1568 011461
   1569 011465      1570 011467      1573 011510      1575 011511      1576 011515      1579 011525      1580 011542
   1582 011550      1584 011551      1585 011557      1587 011565      1588 011571      1589 011605      1590 011607
   1591 011610      1593 011611      1594 011615      1595 011632      1596 011640      1602 011641      1603 011671
   1607 011703      1609 011705      1613 011706      1616 011737      1617 011745      1618 011746      1623 011747
   1628 011755      1630 011757      1632 011764      1634 011771      1636 011773      1638 012003      1640 012006
   1642 012017      1644 012022      1648 012030      1651 012043      1654 012056      1657 012071      1658 012074
   1661 012077      1667 012100      1670 012101      1672 012126      1675 012153      1678 012170      1679 012175
   1681 012212      1682 012217      1683 012221      1684 012223      1685 012226      1686 012237      1688 012253
   1691 012257      1694 012276      1696 012310      1698 012313      1700 012323      1702 012326      1703 012330
   1705 012333      1713 012334      1720 012342      1722 012354      1723 012367      1725 012371      1726 012401
   1728 012402      1729 012403      1731 012406      1734 012430      1742 012431      1750 012437      1752 012457
   1753 012462      1754 012541      1757 012602      1759 012612      1761 012621      1763 012623      1769 012626
   1774 012634      1776 012642      1779 012673      1781 012675      1782 012714      1784 012716      1787 012747
   1795 012760      1801 012762      1803 012767      1806 013020      1808 013021      1809 013040      1811 013042
   1813 013064      1817 013121      1821 013125      1824 013126      1825 013133      1826 013135      1827 013137
   1837 013140      1846 013142      1848 013151      1852 013172      1861 013174      1872 013202      1874 013210
   1876 013232      1877 013235      1882 013236      1884 013242      1885 013261      1888 013266      1890 013322
   1894 013362      1898 013432      1899 013456      1903 013524      1908 013606      1910 013610      1911 013612
   1916 013613      1919 013666      1921 013701      1922 013703      1924 013704      1926 013710      1927 013727
   1930 013734      1931 013770      1933 013771      1935 014002      1937 014005      1938 014031      1940 014040
   1941 014042      1943 014043      1945 014046      1951 014047      1954 014050      1956 014051      1958 014054
   1960 014055      1963 014062      1964 014121      1965 014127      1967 014132      1968 014134      1969 014136
   1970 014141      1973 014156      1974 014175      1975 014207      1976 014212      1980 014221      1982 014222
   1983 014251      1984 014257      1985 014262      1987 014266      1988 014303      1990 014304      1992 014305
   2001 014306      2005 014307      2008 014310      2012 014314      2014 014326      2018 014331      2019 014332
   2021 014340      2023 014346      2027 014353      2028 014354      2035 014355      2036 014357      2038 014365
   2039 014376      2042 014403      2049 014404      2052 014405      2053 014407      2055 014415      2057 014420
   2058 014427      2059 014440      2060 014450      2061 014453      2063 014454      2065 014456      2066 014461
   2067 014467      2068 014470      2071 014471      2072 014472      2073 014500      2074 014507      2077 014513
   2085 014514      2090 014516      2093 014521      2095 014522      2097 014530      2103 014531      2113 014533
   2115 014534      2116 014540      2117 014557      2118 014565      2119 014570      2122 014573      2124 014600
   2126 014635      2127 014643      2129 014646      2131 014651      2132 014654      2133 014713      2134 014721
   2136 014724      2137 014726      2140 014742      2141 014750      2143 014757      2145 014760      2146 014762
   2147 014765      2148 015002      2151 015020      2152 015037      2153 015047      2156 015052      2158 015053


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
