	COMPILATION LISTING OF SEGMENT basic_matrix_double_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 09/11/84  1244.6 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 /* format: style2 */
       11 
       12 basic_matrix_double_:
       13      proc (bo_stack_pt);
       14 
       15 	dcl     (bo_stack_pt, bo_pt, sink_pt, source_pt, p1, p2, p3)
       16 				 ptr,
       17 	        copy		 bit (1) aligned,
       18 	        t			 float bin (63),
       19 	        accuracy		 float bin (63) static,
       20 	        (i, j, k, m, n, p, row_max, col_max)
       21 				 fixed bin;
       22 
       23 	dcl     (abs, addr, hbound, max, min)
       24 				 builtin;
       25 
       26 	dcl     string_area		 area (65536) based (string_segment);
       27 
       28 	dcl     C			 (0:row_max, 0:col_max) float bin (63) based,
       29 	        C_transpose		 (0:col_max, 0:row_max) float bin (63) based;
       30 
       31 	dcl     vector_m		 (0:m) float bin (63) based,
       32 	        vector_n		 (0:n) float bin (63) based,
       33 	        vector_p		 (0:p) float bin (63) based,
       34 	        matrix_mn		 (0:m, 0:n) float bin (63) based,
       35 	        matrix_mp		 (0:m, 0:p) float bin (63) based,
       36 	        matrix_pn		 (0:p, 0:n) float bin (63) based;
       37 
  1     1 dcl	1 basic_operators_frame	aligned based(bo_pt),
  1     2 	2 pr(0:7)			ptr,
  1     3 	2 prev_sp			ptr,
  1     4 	2 next_sp			ptr,
  1     5 	2 return_ptr		ptr,
  1     6 	2 entry_ptr		ptr,
  1     7 	2 operator_and_lp_ptr	ptr,
  1     8 	2 arglist_ptr		ptr,
  1     9 	2 reserved		bit(72),
  1    10 	2 on_unit_relp(2)		bit(18) unaligned,
  1    11 	2 translator_id		bit(18) unaligned,
  1    12 	2 operator_return_offset	bit(18) unaligned,
  1    13 	2 regs,
  1    14 	  3 xr(0:7)		bit(18) unaligned,
  1    15 	  3 (a_reg,q_reg)		fixed bin(35),
  1    16 	  3 rest_of_regs(2)		bit(36) aligned,
  1    17 	2 print_using_pt		ptr,		/* N.B. this holds return loc, pos in struc must be the same
  1    18*						   as for ep basic as debuggers depend on this */
  1    19 	2 abort_label		label,
  1    20 	2 conversion_label		label,
  1    21 	2 size_label		label,
  1    22 	2 on_units(2),
  1    23 	  3 name			ptr,
  1    24 	  3 body			ptr,
  1    25 	  3 size			fixed bin,
  1    26 	  3 next			fixed bin,
  1    27 	2 program_header		ptr,
  1    28 	2 text_base_ptr		ptr,
  1    29 	2 string_segment		ptr,
  1    30 	2 fcb_pt			ptr,
  1    31 	2 arglist1(2)		ptr,
  1    32 	2 runtime_arglist(2)	ptr,
  1    33 	2 cpu_start		fixed bin(71),
  1    34 	2 determinant		float bin(63),
  1    35 	2 fcb(0:16)		ptr unaligned,
  1    36 	2 precision_lng 		fixed bin(17) unaligned,
  1    37 	2 file_number		fixed bin(17) unaligned,
  1    38 	2 (error_number,pdl)	fixed bin,
  1    39 	2 program_header_offset	bit(18) aligned,
  1    40 	2 numeric_data		unaligned,
  1    41 	  3 (finish,start)		fixed bin(17),
  1    42 	2 string_data		unaligned,
  1    43 	  3 (finish,start)		fixed bin(17),
  1    44 	2 random			fixed bin,
  1    45 	2 first_frame		bit(18),
  1    46 	2 last_frame		bit(18),
  1    47 	2 next_frame		bit(18),
  1    48 	2 number_read		fixed bin,
  1    49 	2 (pu_pos,pu_length)	fixed bin,
  1    50 	2 definitions		ptr unal,
  1    51 	2 fn_temp1		fixed bin,
  1    52 	2 fn_temp2		fixed bin,
  1    53 	2 entryname		ptr unal,
  1    54 	2 flags			unaligned,
  1    55 	  3 non_basic_caller	bit(1),
  1    56 	  3 main_program		bit(1),
  1    57 	  3 quits_disabled		bit(1),
  1    58 	  3 had_quit		bit(1),
  1    59 	  3 ignore_handler		bit(1),
  1    60 	  3 filler		bit(13),
  1    61 	2 number_length		fixed bin(17) unaligned,
  1    62 	2 string_value		bit(36),
  1    63 	2 temporaries(3)		aligned,
  1    64 	  3 temp			float bin,
  1    65 	  3 tpad			bit(36),
  1    66 	2 arg(1)			ptr;
  1    67 
  1    68 dcl	1 d_basic_operators_frame	aligned based(bo_pt),
  1    69 	2 x_pr(0:7)			ptr,
  1    70 	2 x_prev_sp			ptr,
  1    71 	2 x_next_sp			ptr,
  1    72 	2 x_return_ptr		ptr,
  1    73 	2 x_entry_ptr		ptr,
  1    74 	2 x_operator_and_lp_ptr	ptr,
  1    75 	2 x_arglist_ptr		ptr,
  1    76 	2 x_reserved		bit(72),
  1    77 	2 x_on_unit_relp(2)		bit(18) unaligned,
  1    78 	2 x_translator_id		bit(18) unaligned,
  1    79 	2 x_operator_return_offset	bit(18) unaligned,
  1    80 	2 x_regs,
  1    81 	  3 x_xr(0:7)		bit(18) unaligned,
  1    82 	  3 (x_a_reg,x_q_reg)	fixed bin,
  1    83 	  3 x_rest_of_regs(2)		bit(36) aligned,
  1    84 	2 x_print_using_pt		ptr,
  1    85 	2 x_abort_label		label,
  1    86 	2 x_conversion_label		label,
  1    87 	2 x_size_label		label,
  1    88 	2 x_on_units(2),
  1    89 	  3 x_name			ptr,
  1    90 	  3 x_body			ptr,
  1    91 	  3 x_size			fixed bin,
  1    92 	  3 x_next			fixed bin,
  1    93 	2 x_program_header		ptr,
  1    94 	2 x_text_base_ptr		ptr,
  1    95 	2 x_string_segment		ptr,
  1    96 	2 x_fcb_pt			ptr,
  1    97 	2 x_arglist1(2)		ptr,
  1    98 	2 x_runtime_arglist(2)	ptr,
  1    99 	2 x_cpu_start		fixed bin(71),
  1   100 	2 x_determinant		float bin(63),
  1   101 	2 x_fcb(0:16)		ptr unaligned,
  1   102 	2 x_precision_lng 		fixed bin(17) unaligned,
  1   103 	2 x_file_number		fixed bin(17) unaligned,
  1   104 	2 x_error_number		fixed bin,
  1   105 	2 x_pdl			fixed bin,
  1   106 	2 x_program_header_offset	bit(18) aligned,
  1   107 	2 x_numeric_data		unaligned,
  1   108 	  3 (x_finish,x_start)	fixed bin(17),
  1   109 	2 x_string_data		unaligned,
  1   110 	  3 (x_finish,x_start)	fixed bin(17),
  1   111 	2 x_random			fixed bin,
  1   112 	2 x_first_frame		bit(18),
  1   113 	2 x_last_frame		bit(18),
  1   114 	2 x_next_frame		bit(18),
  1   115 	2 x_number_read		fixed bin,
  1   116 	2 (x_pu_pos,x_pu_length)	fixed bin,
  1   117 	2 x_definitions		ptr unal,
  1   118 	2 x_fn_temp1		fixed bin,
  1   119 	2 x_fn_temp2		fixed bin,
  1   120 	2 x_entryname		ptr unal,
  1   121 	2 x_flags			unaligned,
  1   122 	  3 x_non_basic_caller	bit(1),
  1   123 	  3 x_main_program		bit(1),
  1   124 	  3 x_quits_disabled		bit(1),
  1   125 	  3 x_had_quit		bit(1),
  1   126 	  3 x_filler		bit(14),
  1   127 	2 x_number_length		fixed bin(17) unaligned,
  1   128 	2 x_string_value		bit(36),
  1   129 	2 d_temp(3)		float bin(63),
  1   130 	2 x_arg(1)			ptr;
       38 
  2     1 dcl	1 array_dope		aligned based,
  2     2 	2 data			ptr,
  2     3 	2 original_bounds(2)	fixed bin,
  2     4 	2 current_bounds(2)		fixed bin;
  2     5 
  2     6 dcl	1 scalar_symbol		aligned based,
  2     7 	2 name			char(2) unaligned,
  2     8 	2 parameter		bit(1) unaligned,
  2     9 	2 location		bit(17) unaligned;
  2    10 
  2    11 dcl	1 array_symbol		aligned based,
  2    12 	2 name			char(1) unaligned,
  2    13 	2 skip			bit(9) unaligned,
  2    14 	2 parameter		bit(1) unaligned,
  2    15 	2 location		bit(17) unaligned,
  2    16 	2 offset			fixed bin,
  2    17 	2 bounds(2)		fixed bin(17) unaligned;
       39 
       40 
       41 	bo_pt = bo_stack_pt;
       42 	goto switch (q_reg);
       43 
       44 /* inverse */
       45 
       46 switch (1):
       47 	row_max = pr (2) -> current_bounds (1) - 1;
       48 	if row_max <= 0
       49 	then goto array_error;
       50 
       51 	begin;
       52 
       53 	     dcl	   space		      (row_max * row_max * 2),
       54 		   LU		      (row_max, row_max) float bin (63) aligned based (addr (space));
       55 
       56 	     dcl	   P		      (100) fixed bin,
       57 		   (B, X, R, DX, scales)  dim (100) float bin (63),
       58 		   (i, j, e, k, pividx)   fixed bin,
       59 		   (ajj, norm_row, biggest, size, multiplier, pivot)
       60 				      float bin (63);
       61 
       62 	     dcl	   (
       63 		   scale_factor	      init (1.0e6),
       64 		   maxval		      init (1.0e6),
       65 		   minval		      init (1.0e-6)
       66 		   )		      float bin (63) static;
       67 
       68 	     dcl	   (ap, ainvp)	      ptr;
       69 
       70 	     dcl	   A		      (0:row_max, 0:row_max) float bin (63) based (ap),
       71 		   A_inverse	      (0:row_max, 0:row_max) float bin (63) based (ainvp);
       72 
       73 	     if row_max > hbound (P, 1)
       74 	     then goto array_error;
       75 
       76 	     ap = pr (1) -> array_dope.data;
       77 
       78 	     if pr (1) ^= pr (2)
       79 	     then ainvp = pr (2) -> array_dope.data;
       80 	     else allocate A_inverse in (string_area);
       81 
       82 /* Initialize LU decomposition */
       83 
       84 	     do i = 1 to row_max;
       85 		P (i) = i;
       86 		norm_row = 0.0e0;
       87 
       88 		do j = 1 to row_max;
       89 		     LU (i, j) = A (i, j);
       90 		     norm_row = max (norm_row, abs (LU (i, j)));
       91 		end;
       92 
       93 		if norm_row = 0.0e0
       94 		then goto singular;
       95 
       96 		scales (i) = 1.0 / norm_row;
       97 	     end;
       98 
       99 /* Perform Gaussian elimination with partial pivoting and scaling */
      100 
      101 	     determinant = 1.0e0;
      102 
      103 	     do k = 1 to row_max - 1;
      104 		biggest = 0.0e0;
      105 
      106 		do i = k to row_max;
      107 		     size = abs (LU (P (i), k)) * scales (P (i));
      108 
      109 		     if size > biggest
      110 		     then do;
      111 			     biggest = size;
      112 			     pividx = i;
      113 			end;
      114 		end;
      115 
      116 		if biggest = 0.0e0
      117 		then goto singular;
      118 
      119 		if pividx ^= k
      120 		then do;
      121 
      122 /* Change sign of determinant and interchange
      123*		        permutation elements */
      124 
      125 			determinant = -determinant;
      126 
      127 			j = P (k);
      128 			P (k) = P (pividx);
      129 			P (pividx) = j;
      130 		     end;
      131 
      132 		pivot = LU (P (k), k);
      133 
      134 		do i = k + 1 to row_max;
      135 		     LU (P (i), k), multiplier = LU (P (i), k) / pivot;
      136 
      137 		     if multiplier ^= 0.0e0
      138 		     then do j = k + 1 to row_max;
      139 			     LU (P (i), j) = LU (P (i), j) - multiplier * LU (P (k), j);
      140 			end;
      141 		end;
      142 
      143 	     end;
      144 
      145 	     if LU (P (row_max), row_max) = 0
      146 	     then goto singular;
      147 
      148 /* Determine inverse and compute determinant */
      149 
      150 	     e = 0;
      151 	     do j = 1 to row_max;
      152 
      153 		do i = 1 to row_max;
      154 		     B (i) = 0;
      155 		end;
      156 
      157 		B (j) = 1.0e0;
      158 
      159 /* Solve AX = B for X */
      160 
      161 		call solve (X, B);
      162 
      163 /* Improve the solution */
      164 
      165 		call improve;
      166 
      167 /* Solution is column j of inverse */
      168 
      169 		do i = 1 to row_max;
      170 		     A_inverse (i, j) = X (i);
      171 		end;
      172 
      173 		ajj = LU (P (j), j);
      174 
      175 		if abs (determinant) > maxval / max (ajj, 1.0e0)
      176 		then do;
      177 			e = e + 1;
      178 			determinant = determinant / scale_factor;
      179 		     end;
      180 
      181 		if abs (determinant) < minval / min (ajj, 1.0e0)
      182 		then do;
      183 			e = e - 1;
      184 			determinant = determinant * scale_factor;
      185 		     end;
      186 
      187 		determinant = determinant * ajj;
      188 	     end;
      189 
      190 /* Correct exponent of determinant */
      191 
      192 	     do i = 1 to e by +1;
      193 		determinant = determinant * scale_factor;
      194 	     end;
      195 
      196 	     do i = -1 to e by -1;
      197 		determinant = determinant / scale_factor;
      198 	     end;
      199 
      200 /* ALL THRU */
      201 
      202 	     goto inverse_done;
      203 
      204 solve:
      205      proc (X, B);
      206 
      207 	dcl     (B, X)		 dim (100) float bin (63),
      208 	        dot		 float bin (63),
      209 	        (i, j)		 fixed bin;
      210 
      211 	do i = 1 to row_max;
      212 	     dot = 0.0e0;
      213 
      214 	     do j = 1 to i - 1;
      215 		dot = dot + LU (P (i), j) * X (j);
      216 	     end;
      217 
      218 	     X (i) = B (P (i)) - dot;
      219 	end;
      220 
      221 	do i = row_max by -1 to 1;
      222 	     dot = 0.0e0;
      223 
      224 	     do j = i + 1 to row_max;
      225 		dot = dot + LU (P (i), j) * X (j);
      226 	     end;
      227 
      228 	     X (i) = (X (i) - dot) / LU (P (i), i);
      229 	end;
      230 
      231      end;
      232 
      233 improve:
      234      proc;
      235 
      236 	dcl     (i, j, iterations)	 fixed binary,
      237 	        (norm_x, norm_dx, t)	 float bin (63),
      238 	        dot		 float bin (63);	/* MUST BE DOUBLE PRECISION */
      239 
      240 	dcl     max_iterations	 float bin static init (16),
      241 						/* about 2*log10(epsilon) */
      242 	        epsilon		 float bin static init (1e-8);
      243 
      244 	norm_x = 0.0e0;
      245 
      246 	do i = 1 to row_max;
      247 	     norm_x = max (norm_x, abs (X (i)));
      248 	end;
      249 
      250 	if norm_x = 0.0e0
      251 	then do;
      252 		accuracy = epsilon;
      253 		return;
      254 	     end;
      255 
      256 	do iterations = 1 to max_iterations;
      257 	     do i = 1 to row_max;
      258 
      259 		dot = 0.0e0;
      260 
      261 		do j = 1 to row_max;
      262 		     dot = dot + A (i, j) * X (j);
      263 		end;
      264 
      265 		R (i) = B (i) - dot;
      266 	     end;
      267 
      268 	     call solve (DX, R);
      269 
      270 	     norm_dx = 0.0e0;
      271 
      272 	     do i = 1 to row_max;
      273 		t = X (i);
      274 		X (i) = X (i) + DX (i);
      275 		norm_dx = max (norm_dx, abs (X (i) - t));
      276 	     end;
      277 
      278 	     if iterations = 1
      279 	     then accuracy = max (norm_dx / norm_x, epsilon);
      280 
      281 	     if norm_dx <= epsilon * norm_x
      282 	     then return;
      283 	end;
      284 
      285 	goto singular;
      286      end;
      287 
      288 singular:
      289 	     determinant = 0.0e0;
      290 
      291 inverse_done:
      292 	     if pr (1) = pr (2)
      293 	     then do;
      294 		     pr (2) -> array_dope.data -> A_inverse = A_inverse;
      295 		     free A_inverse in (string_area);
      296 		end;
      297 	end;
      298 
      299 	q_reg = 0;
      300 	return;
      301 
      302 /* transpose */
      303 
      304 switch (2):
      305 	row_max = pr (2) -> current_bounds (1) - 1;
      306 	if row_max <= 0
      307 	then goto array_error;
      308 
      309 	col_max = pr (2) -> current_bounds (2) - 1;
      310 	if col_max <= 0
      311 	then goto array_error;
      312 
      313 	source_pt = pr (1) -> array_dope.data;
      314 
      315 	if pr (1) ^= pr (2)
      316 	then sink_pt = pr (2) -> array_dope.data;
      317 	else allocate C set (sink_pt) in (string_area);
      318 
      319 	do i = 1 to row_max;
      320 	     do j = 1 to col_max;
      321 		sink_pt -> C (i, j) = source_pt -> C_transpose (j, i);
      322 	     end;
      323 	end;
      324 
      325 	if pr (1) = pr (2)
      326 	then do;
      327 		pr (2) -> array_dope.data -> C = sink_pt -> C;
      328 		free sink_pt -> C in (string_area);
      329 	     end;
      330 
      331 	q_reg = 0;
      332 	return;
      333 
      334 /* vector (1 x n) = vector (1 x p) * matrix (p x n) */
      335 
      336 switch (3):
      337 	p = pr (3) -> array_dope.current_bounds (1) - 1;
      338 	n = pr (3) -> array_dope.current_bounds (2) - 1;
      339 
      340 	call get_matrix_pointers;
      341 
      342 	if copy
      343 	then allocate vector_n set (p2) in (string_area);
      344 
      345 	do j = 1 to n;
      346 	     t = 0.0e0;
      347 
      348 	     do k = 1 to p;
      349 		t = t + p1 -> vector_p (k) * p3 -> matrix_pn (k, j);
      350 	     end;
      351 
      352 	     p2 -> vector_n (j) = t;
      353 	end;
      354 
      355 	if copy
      356 	then do;
      357 		pr (2) -> array_dope.data -> vector_n = p2 -> vector_n;
      358 		free p2 -> vector_n in (string_area);
      359 	     end;
      360 
      361 	q_reg = 0;
      362 	return;
      363 
      364 /* vector (m x 1) = matrix (m x p) * vector (p x 1) */
      365 
      366 switch (4):
      367 	m = pr (1) -> array_dope.current_bounds (1) - 1;
      368 	p = pr (1) -> array_dope.current_bounds (2) - 1;
      369 
      370 	call get_matrix_pointers;
      371 
      372 	if copy
      373 	then allocate vector_m set (p2) in (string_area);
      374 
      375 	do i = 1 to m;
      376 	     t = 0.0e0;
      377 
      378 	     do k = 1 to p;
      379 		t = t + p1 -> matrix_mp (i, k) * p3 -> vector_p (k);
      380 	     end;
      381 
      382 	     p2 -> vector_m (i) = t;
      383 	end;
      384 
      385 	if copy
      386 	then do;
      387 		pr (2) -> array_dope.data -> vector_m = p2 -> vector_m;
      388 		free p2 -> vector_m in (string_area);
      389 	     end;
      390 
      391 	q_reg = 0;
      392 	return;
      393 
      394 /* matrix (m x n) = matrix (m x p) * matrix (p x n) */
      395 
      396 switch (5):
      397 	m = pr (2) -> array_dope.current_bounds (1) - 1;
      398 	n = pr (2) -> array_dope.current_bounds (2) - 1;
      399 	p = pr (1) -> array_dope.current_bounds (2) - 1;
      400 
      401 	call get_matrix_pointers;
      402 
      403 	if copy
      404 	then allocate matrix_mn set (p2) in (string_area);
      405 	do i = 1 to m;
      406 	     do j = 1 to n;
      407 		t = 0.0e0;
      408 
      409 		do k = 1 to p;
      410 		     t = t + p1 -> matrix_mp (i, k) * p3 -> matrix_pn (k, j);
      411 		end;
      412 
      413 		p2 -> matrix_mn (i, j) = t;
      414 	     end;
      415 	end;
      416 
      417 	if copy
      418 	then do;
      419 		pr (2) -> array_dope.data -> matrix_mn = p2 -> matrix_mn;
      420 		free p2 -> matrix_mn in (string_area);
      421 	     end;
      422 
      423 	q_reg = 0;
      424 	return;
      425 
      426 /* errors */
      427 
      428 array_error:
      429 	q_reg = 139;
      430 
      431 get_matrix_pointers:
      432      proc;
      433 
      434 	p1 = pr (1) -> array_dope.data;
      435 	p3 = pr (3) -> array_dope.data;
      436 
      437 	copy = (pr (1) = pr (2)) | (pr (3) = pr (2));
      438 
      439 	if ^copy
      440 	then p2 = pr (2) -> array_dope.data;
      441 
      442      end;
      443 
      444      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/11/84  1223.8  basic_matrix_double_.pl1          >spec>on>basic>basic_matrix_double_.pl1
38           1    03/27/82  0439.4  basic_operator_frame.incl.pl1     >ldd>include>basic_operator_frame.incl.pl1
39           2    03/27/82  0439.4  basic_symbols.incl.pl1            >ldd>include>basic_symbols.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
A                                      based           float bin(63)            array dcl 70 ref 89 262
A_inverse                              based           float bin(63)            array dcl 70 set ref 80 170* 294* 294 295
B                                      parameter       float bin(63)            array dcl 207 in procedure "solve" ref 204 218
B                               000244 automatic       float bin(63)            array dcl 56 in begin block on line 51 set ref 154*
                                                                                  157* 161* 265
C                                      based           float bin(63)            array dcl 28 set ref 317 321* 327* 327 328
C_transpose                            based           float bin(63)            array dcl 28 ref 321
DX                              001374 automatic       float bin(63)            array dcl 56 set ref 268* 274
LU                                     based           float bin(63)            array dcl 53 set ref 89* 90 107 132 135 135* 139*
                                                                                  139 139 145 173 215 225 228
P                               000100 automatic       fixed bin(17,0)          array dcl 56 set ref 73 85* 107 107 127 128* 128
                                                                                  129* 132 135 135 139 139 139 145 173 215 218 225
                                                                                  228
R                               001064 automatic       float bin(63)            array dcl 56 set ref 265* 268*
X                               000554 automatic       float bin(63)            array dcl 56 in begin block on line 51 set ref 161*
                                                                                  170 247 262 273 274* 274 275
X                                      parameter       float bin(63)            array dcl 207 in procedure "solve" set ref 204 215
                                                                                  218* 225 228* 228
abs                                                    builtin function         dcl 23 ref 90 107 175 181 247 275
accuracy                        000010 internal static float bin(63)            dcl 15 set ref 252* 278*
addr                                                   builtin function         dcl 23 ref 89 90 107 132 135 135 139 139 139 145 173
                                                                                  215 225 228
ainvp                           002240 automatic       pointer                  dcl 68 set ref 78* 80* 170 294 295
ajj                             002222 automatic       float bin(63)            dcl 56 set ref 173* 175 181 187
ap                              002236 automatic       pointer                  dcl 68 set ref 76* 89 262
array_dope                             based           structure                level 1 dcl 2-1
basic_operators_frame                  based           structure                level 1 dcl 1-1
biggest                         002226 automatic       float bin(63)            dcl 56 set ref 104* 109 111* 116
bo_pt                           000100 automatic       pointer                  dcl 15 set ref 41* 42 46 76 78 78 78 80 101 125 125
                                                                                  175 178 178 181 184 184 187 187 193 193 197 197
                                                                                  288 291 291 294 295 299 304 309 313 315 315 315
                                                                                  317 325 325 327 328 331 336 338 342 357 358 361
                                                                                  366 368 372 387 388 391 396 398 399 403 419 420
                                                                                  423 428 434 435 437 437 437 437 439
bo_stack_pt                            parameter       pointer                  dcl 15 ref 12 41
col_max                         000127 automatic       fixed bin(17,0)          dcl 15 set ref 309* 310 317 320 321 327 328
copy                            000114 automatic       bit(1)                   dcl 15 set ref 342 355 372 385 403 417 437* 439
current_bounds            4            based           fixed bin(17,0)          array level 2 dcl 2-1 ref 46 304 309 336 338 366 368
                                                                                  396 398 399
data                                   based           pointer                  level 2 dcl 2-1 ref 76 78 294 313 315 327 357 387
                                                                                  419 434 435 439
determinant             124            based           float bin(63)            level 2 dcl 1-1 set ref 101* 125* 125 175 178* 178
                                                                                  181 184* 184 187* 187 193* 193 197* 197 288*
dot                             002320 automatic       float bin(63)            dcl 236 in procedure "improve" set ref 259* 262* 262
                                                                                  265
dot                             002270 automatic       float bin(63)            dcl 207 in procedure "solve" set ref 212* 215* 215
                                                                                  218 222* 225* 225 228
e                               002216 automatic       fixed bin(17,0)          dcl 56 set ref 150* 177* 177 183* 183 192 196
epsilon                         000005 constant        float bin(27)            initial dcl 240 ref 252 278 281
hbound                                                 builtin function         dcl 23 ref 73
i                               002214 automatic       fixed bin(17,0)          dcl 56 in begin block on line 51 set ref 84* 85 85
                                                                                  89 89 90 96* 106* 107 107 112* 134* 135 135 139
                                                                                  139* 153* 154* 169* 170 170* 192* 196*
i                               002272 automatic       fixed bin(17,0)          dcl 207 in procedure "solve" set ref 211* 214 215
                                                                                  218 218* 221* 224 225 228 228 228 228*
i                               000120 automatic       fixed bin(17,0)          dcl 15 in procedure "basic_matrix_double_" set ref
                                                                                  319* 321 321* 375* 379 382* 405* 410 413*
i                               002306 automatic       fixed bin(17,0)          dcl 236 in procedure "improve" set ref 246* 247*
                                                                                  257* 262 265 265* 272* 273 274 274 274 275*
iterations                      002310 automatic       fixed bin(17,0)          dcl 236 set ref 256* 278*
j                               002273 automatic       fixed bin(17,0)          dcl 207 in procedure "solve" set ref 214* 215 215*
                                                                                  224* 225 225*
j                               002215 automatic       fixed bin(17,0)          dcl 56 in begin block on line 51 set ref 88* 89 89
                                                                                  90* 127* 129 137* 139 139 139* 151* 157 170 173
                                                                                  173*
j                               000121 automatic       fixed bin(17,0)          dcl 15 in procedure "basic_matrix_double_" set ref
                                                                                  320* 321 321* 345* 349 352* 406* 410 413*
j                               002307 automatic       fixed bin(17,0)          dcl 236 in procedure "improve" set ref 261* 262 262*
k                               000122 automatic       fixed bin(17,0)          dcl 15 in procedure "basic_matrix_double_" set ref
                                                                                  348* 349 349* 378* 379 379* 409* 410 410*
k                               002217 automatic       fixed bin(17,0)          dcl 56 in begin block on line 51 set ref 103* 106
                                                                                  107 119 127 128 132 132 134 135 135 137 139*
m                               000123 automatic       fixed bin(17,0)          dcl 15 set ref 366* 372 375 387 388 396* 403 405 419
                                                                                  420
matrix_mn                              based           float bin(63)            array dcl 31 set ref 403 413* 419* 419 420
matrix_mp                              based           float bin(63)            array dcl 31 ref 379 410
matrix_pn                              based           float bin(63)            array dcl 31 ref 349 410
max                                                    builtin function         dcl 23 ref 90 175 247 275 278
max_iterations                         constant        float bin(27)            initial dcl 240 ref 256
maxval                          000010 constant        float bin(63)            initial dcl 62 ref 175
min                                                    builtin function         dcl 23 ref 181
minval                          000006 constant        float bin(63)            initial dcl 62 ref 181
multiplier                      002232 automatic       float bin(63)            dcl 56 set ref 135* 137 139
n                               000124 automatic       fixed bin(17,0)          dcl 15 set ref 338* 342 345 349 357 358 398* 403 406
                                                                                  410 413 419 420
norm_dx                         002314 automatic       float bin(63)            dcl 236 set ref 270* 275* 275 278 281
norm_row                        002224 automatic       float bin(63)            dcl 56 set ref 86* 90* 90 93 96
norm_x                          002312 automatic       float bin(63)            dcl 236 set ref 244* 247* 247 250 278 281
p                               000125 automatic       fixed bin(17,0)          dcl 15 set ref 336* 348 368* 378 379 399* 409 410
p1                              000106 automatic       pointer                  dcl 15 set ref 349 379 410 434*
p2                              000110 automatic       pointer                  dcl 15 set ref 342* 352 357 358 372* 382 387 388
                                                                                  403* 413 419 420 439*
p3                              000112 automatic       pointer                  dcl 15 set ref 349 379 410 435*
pividx                          002220 automatic       fixed bin(17,0)          dcl 56 set ref 112* 119 128 129
pivot                           002234 automatic       float bin(63)            dcl 56 set ref 132* 135
pr                                     based           pointer                  array level 2 dcl 1-1 ref 46 76 78 78 78 291 291 294
                                                                                  304 309 313 315 315 315 325 325 327 336 338 357
                                                                                  366 368 387 396 398 399 419 434 435 437 437 437
                                                                                  437 439
q_reg                    45            based           fixed bin(35,0)          level 3 dcl 1-1 set ref 42 299* 331* 361* 391* 423*
                                                                                  428*
regs                     40            based           structure                level 2 dcl 1-1
row_max                         000126 automatic       fixed bin(17,0)          dcl 15 set ref 46* 48 53 53 73 80 80 84 88 89 89 89
                                                                                  90 90 103 106 107 107 132 132 134 135 135 135 135
                                                                                  137 139 139 139 139 139 139 145 145 145 145 151
                                                                                  153 169 170 173 173 211 215 215 221 224 225 225
                                                                                  228 228 246 257 261 262 272 294 294 295 295 304*
                                                                                  306 317 319 321 327 328
scale_factor                    000012 constant        float bin(63)            initial dcl 62 ref 178 184 193 197
scales                          001704 automatic       float bin(63)            array dcl 56 set ref 96* 107
sink_pt                         000102 automatic       pointer                  dcl 15 set ref 315* 317* 321 327 328
size                            002230 automatic       float bin(63)            dcl 56 set ref 107* 109 111
source_pt                       000104 automatic       pointer                  dcl 15 set ref 313* 321
space                           000100 automatic       fixed bin(17,0)          array dcl 53 set ref 89 90 107 132 135 135 139 139
                                                                                  139 145 173 215 225 228
string_area                            based           area(65536)              dcl 26 ref 80 295 317 328 342 358 372 388 403 420
string_segment          106            based           pointer                  level 2 dcl 1-1 ref 80 295 317 328 342 358 372 388
                                                                                  403 420
t                               000116 automatic       float bin(63)            dcl 15 in procedure "basic_matrix_double_" set ref
                                                                                  346* 349* 349 352 376* 379* 379 382 407* 410* 410
                                                                                  413
t                               002316 automatic       float bin(63)            dcl 236 in procedure "improve" set ref 273* 275
vector_m                               based           float bin(63)            array dcl 31 set ref 372 382* 387* 387 388
vector_n                               based           float bin(63)            array dcl 31 set ref 342 352* 357* 357 358
vector_p                               based           float bin(63)            array dcl 31 ref 349 379

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
array_symbol                           based           structure                level 1 dcl 2-11
d_basic_operators_frame                based           structure                level 1 dcl 1-68
scalar_symbol                          based           structure                level 1 dcl 2-6

NAMES DECLARED BY EXPLICIT CONTEXT.
array_error                     002055 constant        label                    dcl 428 ref 48 73 306 310
basic_matrix_double_            000031 constant        entry                    external dcl 12
get_matrix_pointers             002061 constant        entry                    internal dcl 431 ref 340 370 401
improve                         001101 constant        entry                    internal dcl 233 ref 165
inverse_done                    000662 constant        label                    dcl 291 ref 202
singular                        000656 constant        label                    dcl 288 ref 93 116 145 285
solve                           000712 constant        entry                    internal dcl 204 ref 161 268
switch                          000000 constant        label                    array(5) dcl 46 set ref 42

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2156        2170    2126        2166
Length      2370    2126        12         164      27           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
basic_matrix_double_                109 external procedure  is an external procedure.  
begin block on line 51             1250 begin block         uses auto adjustable storage.  
solve                                   internal procedure  shares stack frame of begin block on line 51.  
improve                                 internal procedure  shares stack frame of begin block on line 51.  
get_matrix_pointers                     internal procedure  shares stack frame of external procedure basic_matrix_double_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 accuracy                    basic_matrix_double_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
basic_matrix_double_     000100 bo_pt                       basic_matrix_double_
                         000102 sink_pt                     basic_matrix_double_
                         000104 source_pt                   basic_matrix_double_
                         000106 p1                          basic_matrix_double_
                         000110 p2                          basic_matrix_double_
                         000112 p3                          basic_matrix_double_
                         000114 copy                        basic_matrix_double_
                         000116 t                           basic_matrix_double_
                         000120 i                           basic_matrix_double_
                         000121 j                           basic_matrix_double_
                         000122 k                           basic_matrix_double_
                         000123 m                           basic_matrix_double_
                         000124 n                           basic_matrix_double_
                         000125 p                           basic_matrix_double_
                         000126 row_max                     basic_matrix_double_
                         000127 col_max                     basic_matrix_double_
begin block on line 51   000100 space                       begin block on line 51
                         000100 P                           begin block on line 51
                         000244 B                           begin block on line 51
                         000554 X                           begin block on line 51
                         001064 R                           begin block on line 51
                         001374 DX                          begin block on line 51
                         001704 scales                      begin block on line 51
                         002214 i                           begin block on line 51
                         002215 j                           begin block on line 51
                         002216 e                           begin block on line 51
                         002217 k                           begin block on line 51
                         002220 pividx                      begin block on line 51
                         002222 ajj                         begin block on line 51
                         002224 norm_row                    begin block on line 51
                         002226 biggest                     begin block on line 51
                         002230 size                        begin block on line 51
                         002232 multiplier                  begin block on line 51
                         002234 pivot                       begin block on line 51
                         002236 ap                          begin block on line 51
                         002240 ainvp                       begin block on line 51
                         002270 dot                         solve
                         002272 i                           solve
                         002273 j                           solve
                         002306 i                           improve
                         002307 j                           improve
                         002310 iterations                  improve
                         002312 norm_x                      improve
                         002314 norm_dx                     improve
                         002316 t                           improve
                         002320 dot                         improve

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          r_e_as              enter_begin         leave_begin         return              tra_ext
alloc_auto_adj      ext_entry           alloc_based         free_based

NO EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000026        41 000036        42 000042        46 000044        48 000050        51 000051        53 000054
     73 000063        76 000071        78 000076        80 000106        84 000121        85 000131        86 000132
     88 000134        89 000145        90 000171        91 000177        93 000201        96 000203        97 000211
    101 000213       103 000217       104 000227       106 000231       107 000241       109 000265       111 000267
    112 000270       114 000272       116 000274       119 000276       125 000301       127 000306       128 000311
    129 000314       132 000316       134 000334       135 000345       137 000366       139 000377       140 000430
    141 000432       143 000434       145 000436       150 000446       151 000447       153 000457       154 000467
    155 000473       157 000475       161 000502       165 000504       169 000505       170 000515       171 000533
    173 000535       175 000553       177 000567       178 000570       181 000573       183 000606       184 000610
    187 000613       188 000616       192 000620       193 000627       194 000634       196 000636       197 000645
    198 000652       202 000655       288 000656       291 000662       294 000670       295 000705       297 000710
    204 000712       211 000714       212 000725       214 000727       215 000737       216 000761       218 000763
    219 001000       221 001002       222 001011       224 001013       225 001025       226 001047       228 001051
    229 001075       231 001100       233 001101       244 001102       246 001104       247 001115       248 001125
    250 001127       252 001131       253 001134       256 001135       257 001146       259 001157       261 001161
    262 001171       263 001206       265 001210       266 001216       268 001220       270 001222       272 001224
    273 001235       274 001241       275 001243       276 001252       278 001254       281 001270       283 001275
    285 001277       299 001300       300 001302       304 001303       306 001307       309 001310       310 001313
    313 001314       315 001317       317 001326       319 001342       320 001351       321 001361       322 001404
    323 001406       325 001410       327 001415       328 001434       331 001437       332 001441       336 001442
    338 001446       340 001451       342 001452       345 001464       346 001473       348 001475       349 001505
    350 001524       352 001526       353 001533       355 001535       357 001537       358 001553       361 001555
    362 001557       366 001560       368 001564       370 001567       372 001570       375 001602       376 001611
    378 001613       379 001623       380 001637       382 001641       383 001646       385 001650       387 001652
    388 001666       391 001670       392 001672       396 001673       398 001677       399 001702       401 001706
    403 001707       405 001725       406 001735       407 001745       409 001747       410 001757       411 002004
    413 002006       414 002021       415 002023       417 002025       419 002027       420 002047       423 002052
    424 002054       428 002055       444 002060       431 002061       434 002062       435 002066       437 002071
    439 002104       442 002110


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
