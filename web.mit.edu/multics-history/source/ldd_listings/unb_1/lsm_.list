	COMPILATION LISTING OF SEGMENT lsm_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/18/82  1640.9 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 lsm_: proc; return;
       19 
       20 /* Written on 05/02/70 by Edwin W. Meyer, Jr. */
       21 /* Modified for pl1 on 01/2170 by Edwin W. Meyer, Jr. */
       22 /* modified 6/25/73 by Lee J. Scheffler for a general cleanup and for compatibility with new gm_ */
       23 /* Modified 05/05/77 by CDT to make replace_blk refuse to replace symbols; otherwise symbol table messed its mind. */
       24 /* Modified 07/79 by CDT for general overhaul */
       25 /* Last modified 10/80 by CDT to make set_blk refuse to expand max-length
       26*   blocks BEFORE indirecting through them, not after */
       27 
       28 
       29 /* AUTOMATIC */
       30 
       31 dcl  old_type fixed bin,
       32      old_data_len fixed bin,
       33      temp_node fixed bin (18),
       34      new_node_ptr pointer;
       35 
       36 /* BUILTIN */
       37 
       38 dcl (addr, divide, max, min, size, unspec) builtin;
       39 
       40 /* EXTERNAL STATIC */
       41 
       42 dcl (graphic_error_table_$lsm_node_ob,
       43      graphic_error_table_$bad_node,
       44      graphic_error_table_$inv_node_type,
       45      graphic_error_table_$lsm_seg_full,
       46      graphic_error_table_$lsm_blk_len) external fixed bin (35);
       47 
       48 dcl  error_table_$unimplemented_version fixed bin (35) external static;
       49 
       50 dcl  sys_info$max_seg_size fixed bin (35) external static;
       51 
       52 /* BASED */
       53 
       54 dcl  based_segment (0: 65000) aligned fixed bin (18) based (lsm_segptr); /* dummy declaration for pointer creation
       55*						   and node referencing */
       56 
  1     1 /* Begin include file . . . lsm_formats.incl.pl1 */
  1     2 
  1     3 /* CONSTANTS */
  1     4 
  1     5 dcl (LSM_version_7 initial (7),			/* current version, root is always symtab */
  1     6      LSM_version_6 initial (6))			/* root wasn't automatically symtab */
  1     7      fixed bin static options (constant);
  1     8 
  1     9 dcl 1 lsm_constants aligned static options (constant),
  1    10     2 n_types fixed bin initial (9),
  1    11     2 types,
  1    12       3 indirect_type initial (1),
  1    13       3 fixed_type initial (2),
  1    14       3 float_type initial (3),
  1    15       3 bit_type initial (4),
  1    16       3 char_type initial (5),
  1    17       3 symtab_type initial (6),
  1    18       3 symbol_type initial (7),
  1    19       3 list_type initial (8),
  1    20       3 array_type initial (9),
  1    21     2 data_length_factors (9) initial (1, 1, 1, 36, 4, 1, 1, 1, 1),
  1    22     2 max_allocation fixed bin initial (4095),
  1    23     2 initial_component_slots fixed bin initial (8);
  1    24 
  1    25 dcl  lsm_segptr pointer;
  1    26 
  1    27 dcl 1 lsm aligned based (lsm_segptr),			/* declaration of head of lsm_ segment */
  1    28     2 version fixed bin,				/* number of lsm_ version that created this seg */
  1    29     2 free fixed bin (18),				/* word number of first free word in seg */
  1    30     2 root_symtab fixed bin (18),			/* node number of the root symbol table */
  1    31     2 lock bit (36) aligned,
  1    32     2 component_slots fixed bin,
  1    33     2 components fixed bin,
  1    34     2 pad (26) fixed bin (18),
  1    35     2 component_ptrs (lsm_constants.initial_component_slots refer (lsm.component_slots)) pointer unaligned;
  1    36 
  1    37 
  1    38 /* Formats of different node types used by lsm_ */
  1    39 
  1    40 dcl  node_ptr pointer;
  1    41 
  1    42 dcl 1 header aligned based (node_ptr),			/* Used in all formats below */
  1    43     2 type fixed bin (6) unsigned unaligned,		/* type of node */
  1    44     2 allocated_len fixed bin (12) unsigned unaligned,	/* allocated length of data space */
  1    45     2 data_len fixed bin (18) unsigned unaligned;		/* current length of data in block */
  1    46 						/* (in appropriate units) */
  1    47 
  1    48 dcl 1 any_node aligned based (node_ptr),		/* general node description */
  1    49     2 header like header aligned,
  1    50     2 data_space (0 refer (any_node.allocated_len)) bit (36) aligned;
  1    51 
  1    52 dcl 1 indirect_node aligned based (node_ptr),		/* internal to lsm_ */
  1    53     2 header like header,
  1    54     2 new_node fixed bin (18);			/* numberof reallocated node */
  1    55 
  1    56 dcl 1 fixed_node aligned based (node_ptr),		/* array of fixed bin (35) */
  1    57     2 header like header,
  1    58     2 element (0 refer (fixed_node.data_len)) fixed bin (35); /* array of values */
  1    59 
  1    60 dcl 1 float_node aligned based (node_ptr),		/* array of float binary (27) */
  1    61     2 header like header,
  1    62     2 element (0 refer (float_node.data_len)) float bin (27);
  1    63 
  1    64 dcl 1 bit_node aligned based (node_ptr),		/* string of bits */
  1    65     2 header like header,
  1    66     2 string bit (0 refer (bit_node.data_len));		/* bit string of max length */
  1    67 
  1    68 dcl 1 char_node aligned based (node_ptr),		/* string of characters */
  1    69     2 header like header,
  1    70     2 string char (0 refer (char_node.data_len)) unaligned; /* character string of max length */
  1    71 
  1    72 dcl 1 symtab_node aligned based (node_ptr),		/* symbol table node */
  1    73     2 header like header,
  1    74     2 bucket_root (0 : 1 refer (symtab_node.data_len)) fixed bin (18);
  1    75 						/* actually, it is (0 : data_len - 1), but there's no way to do */
  1    76 						/* this with a refer option, and it's invalid not to use refer */
  1    77 
  1    78 dcl 1 symbol_node aligned based (node_ptr),		/* symbol node */
  1    79     2 header like header,
  1    80     2 name_node fixed bin (18),			/* number of character string node containing symbol name */
  1    81     2 value_node fixed bin (18),			/* number of node that is the "value" of this symbol */
  1    82     2 next_node fixed bin (18);			/* number of next symbol node in this bucket chain */
  1    83 						/* =0 if this is last node o chain */
  1    84 
  1    85 dcl 1 list_node aligned based (node_ptr),		/* non-terminal list node */
  1    86     2 header like header,
  1    87     2 node (0 refer (list_node.data_len)) fixed bin (18);	/* numbers of nodes comprising this list */
  1    88 
  1    89 dcl 1 array_node aligned based (node_ptr),		/* non-terminal list with terminal properties */
  1    90     2 header like header,
  1    91     2 node (0 refer (array_node.data_len)) fixed bin (18);	/* numbers of nodes comprising this array */
  1    92 
  1    93 
  1    94 /* End include file . . . lsm_formats.incl.pl1 */
       57 
       58 
       59 get_blk:	entry (lsm_segptr, node, type, data_len, node_ptr, err_code);
       60 
       61 dcl (node fixed bin (18),
       62      type fixed bin,
       63      data_len fixed bin,
       64      err_code fixed bin (35)) parameter;
       65 
       66 	call get_node_info (lsm_segptr, node, type, data_len, node_ptr, err_code);
       67 	return;





       68 
       69 get_node_info: proc (lsm_segptr, node, type, data_len, node_ptr, err_code);
       70 
       71 dcl (lsm_segptr pointer,
       72      node fixed bin (18),
       73      type fixed bin,
       74      data_len fixed bin,
       75      err_code fixed bin (35),
       76      node_ptr pointer) parameter;
       77 
       78 	     type = lsm_constants.indirect_type;	/* to start loop off right */
       79 
       80 	     do while (type = lsm_constants.indirect_type); /* until we find a non-indirect node */
       81 		if node < size (lsm_segptr -> lsm) then
       82 		     if (lsm_segptr -> lsm.version = LSM_version_6) & (node = 3) then;
       83 						/* Old style segment and it's the symbol table */
       84 		     else do;
       85 			err_code = graphic_error_table_$lsm_node_ob; /* input block node is out of bounds */
       86 			return;
       87 		     end;
       88 		if node > lsm_segptr -> lsm.free then do;
       89 		     err_code = graphic_error_table_$lsm_node_ob;
       90 		     return;
       91 		end;
       92 
       93 		node_ptr = addr (lsm_segptr -> based_segment (node)); /* get address to data block */
       94 		type = node_ptr -> any_node.type;	/* get data type */
       95 		data_len = node_ptr -> any_node.data_len; /* get current length of data block */
       96 		if (type < 1) | (type > lsm_constants.n_types) then do;
       97 		     err_code = graphic_error_table_$bad_node;
       98 		     return;
       99 		end;
      100 
      101 		if type = lsm_constants.indirect_type then /* indirect type - get the true node */
      102 		     node = node_ptr -> indirect_node.new_node;
      103 	     end;
      104 
      105 	     err_code = 0;
      106 	     return;
      107 
      108 	end get_node_info;
      109 
      110 set_blk:	entry (lsm_segptr, node, type, data_len, node_ptr, err_code);
      111 
      112 /* This entry resets the size of the data space in an existing block */
      113 
      114 	if lsm_segptr -> lsm.version ^= LSM_version_7 then do;
      115 	     err_code = error_table_$unimplemented_version;
      116 	     return;
      117 	end;
      118 
      119 	call get_node_info (lsm_segptr, node, type, old_data_len, node_ptr, err_code);
      120 	if err_code ^= 0 then return;
      121 
      122 	if (type = symtab_type) | (type = symbol_type) then do;
      123 	     err_code = graphic_error_table_$inv_node_type;
      124 	     return;
      125 	end;
      126 
      127 	if node_ptr -> any_node.allocated_len >= cv_data_len_to_words (data_len, type) then do;
      128 	     node_ptr -> any_node.data_len = data_len;	/* current block is of sufficient length - reset */
      129 	     return;
      130 	end;
      131 
      132 /* otherwise we have to create a longer block */
      133 
      134 	call create_new_block (lsm_segptr, temp_node, type,
      135 	     max (min (data_len * 1.5e0 + 10, lsm_constants.max_allocation), data_len),
      136 	     new_node_ptr, err_code);
      137 						/* give a 50% expansion reserve but no more than max allowed */
      138 	if err_code ^= 0 then return;
      139 
      140 	new_node_ptr -> any_node.data_len = data_len;
      141 
      142 	unspec (new_node_ptr -> any_node.data_space) = unspec (node_ptr -> any_node.data_space);
      143 	node_ptr -> any_node.type = lsm_constants.indirect_type; /* set indirect block id and address into old block */
      144 	node_ptr -> indirect_node.new_node = temp_node;
      145 	node_ptr -> indirect_node.data_len = 1;
      146 
      147 	node = temp_node;
      148 	node_ptr = new_node_ptr;
      149 
      150 	return;



      151 
      152 cv_data_len_to_words: proc (data_len, type) returns (fixed bin);
      153 
      154 dcl  data_len fixed bin parameter,
      155      type fixed bin parameter;
      156 
      157 dcl  factor fixed bin,
      158      result fixed bin;
      159 
      160 	     factor = lsm_constants.data_length_factors (type);
      161 	     if factor = 1 then
      162 		result = max (1, data_len);
      163 	     else result = max (1, divide (data_len + factor - 1, factor, 17, 0));
      164 
      165 	     return (result);
      166 	end cv_data_len_to_words;
      167 
      168 replace_blk: entry (lsm_segptr, old_node, new_node, err_code);
      169 
      170 /* Replaces old_node with an indirect block pointing to new_node */
      171 
      172 dcl (old_node, new_node) fixed bin (18) parameter;
      173 
      174 	if lsm_segptr -> lsm.version ^= LSM_version_7 then do;
      175 	     err_code = error_table_$unimplemented_version;
      176 	     return;
      177 	end;
      178 
      179 	call get_node_info (lsm_segptr, new_node, 0, 0, node_ptr, err_code);
      180 						/* just to check its validity */
      181 	if err_code ^= 0 then return;
      182 
      183 	call get_node_info (lsm_segptr, old_node, old_type, 0, node_ptr, err_code);
      184 	if err_code ^= 0 then return;
      185 
      186 	if old_type = symbol_type then do;		/* can't change a symbol block in midstream. */
      187 	     err_code = graphic_error_table_$inv_node_type;
      188 	     return;
      189 	end;
      190 
      191 	node_ptr -> indirect_node.data_len = 2;		/* set cur length of block */
      192 	node_ptr -> indirect_node.type = lsm_constants.indirect_type; /* make it an indirect block */
      193 	node_ptr -> indirect_node.new_node = new_node;
      194 
      195 	return;
      196 
      197 make_blk:	entry (lsm_segptr, node, type, data_len, node_ptr, err_code);
      198 
      199 	call create_new_block (lsm_segptr, node, type, data_len, node_ptr, err_code);
      200 	return;



      201 
      202 create_new_block: proc (lsm_segptr, node, type, data_len, node_ptr, err_code);
      203 
      204 dcl (lsm_segptr pointer,
      205      node fixed bin (18),
      206      type fixed bin,
      207      data_len fixed bin,
      208      err_code fixed bin (35),
      209      node_ptr pointer) parameter;
      210 
      211 dcl  temp_allocated_len fixed bin;
      212 
      213 	     node = 0;				/* in case an error is encountered */
      214 
      215 	     if lsm_segptr -> lsm.version ^= LSM_version_7 then do;
      216 		err_code = error_table_$unimplemented_version;
      217 		return;
      218 	     end;
      219 
      220 
      221 	     if (type <= 0) | (type > lsm_constants.n_types) then do;
      222 		err_code = graphic_error_table_$bad_node;
      223 		return;
      224 	     end;
      225 
      226 	     node = lsm_segptr -> lsm.free;		/* get beginning of free block */
      227 	     node_ptr = addr (lsm_segptr -> based_segment (node));
      228 
      229 	     temp_allocated_len = cv_data_len_to_words (data_len, type);
      230 
      231 	     if temp_allocated_len > lsm_constants.max_allocation then do; /* block length is too long */
      232 		err_code = graphic_error_table_$lsm_blk_len;
      233 		return;
      234 	     end;
      235 
      236 	     if node + temp_allocated_len > sys_info$max_seg_size then do;
      237 		err_code = graphic_error_table_$lsm_seg_full;
      238 		return;
      239 	     end;
      240 
      241 	     node_ptr -> any_node.type = type;
      242 	     node_ptr -> any_node.allocated_len = temp_allocated_len;
      243 	     node_ptr -> any_node.data_len = data_len;
      244 
      245 	     lsm_segptr -> lsm.free = lsm_segptr -> lsm.free + temp_allocated_len + 1; /* update free cell */
      246 
      247 	     return;
      248 	end create_new_block;
      249 
      250 replicate: entry (lsm_segptr, template_node, new_copy_node, err_code);
      251 
      252 dcl (template_node fixed bin (18),			/* template of structure to be replicated */
      253      new_copy_node fixed bin (18)) parameter;		/* node id of replica */
      254 
      255 	call rep_struc_recurse (lsm_segptr, template_node, new_copy_node, err_code);
      256 	return;



      257 
      258 rep_struc_recurse: proc (lsm_segptr, template_node, new_copy_node, err_code);
      259 
      260 dcl (lsm_segptr pointer,
      261     (template_node, new_copy_node) fixed bin (18),
      262      err_code fixed bin (35)) parameter;
      263 
      264 dcl  type fixed bin,
      265      data_len fixed bin,
      266     (old_node_ptr, new_node_ptr) pointer,
      267      i fixed bin;
      268 
      269 	     new_copy_node = 0;
      270 
      271 	     if template_node = 0 then return;
      272 
      273 	     call get_node_info (lsm_segptr, template_node, type, data_len, old_node_ptr, err_code);
      274 	     if err_code ^= 0 then return;
      275 
      276 	     if type = symbol_type then do;		/* Do not replicate through symbols */
      277 		new_copy_node = template_node;
      278 		return;
      279 	     end;
      280 
      281 	     call create_new_block (lsm_segptr, new_copy_node, type, data_len, new_node_ptr, err_code);
      282 	     if err_code ^= 0 then return;
      283 
      284 	     if type = symtab_type then do;
      285 		err_code = graphic_error_table_$inv_node_type;
      286 		return;
      287 	     end;
      288 
      289 	     else if (type = array_type) | (type = list_type) then
      290 		do i = 1 to data_len;
      291 		call rep_struc_recurse (lsm_segptr, old_node_ptr -> list_node.node (i),
      292 		     new_node_ptr -> list_node.node (i), err_code);
      293 		if err_code ^= 0 then return;
      294 	     end;
      295 
      296 	     else unspec (new_node_ptr -> any_node.data_space) = unspec (old_node_ptr -> any_node.data_space);
      297 						/* simple real data type */
      298 
      299 	     return;
      300 	end rep_struc_recurse;
      301 
      302      end lsm_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/18/82  1625.5  lsm_.pl1                          >dumps>old>recomp>lsm_.pl1
57           1    12/17/79  1708.9  lsm_formats.incl.pl1              >ldd>include>lsm_formats.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
LSM_version_6                          constant        fixed bin(17,0)          initial dcl 1-5 ref 81
LSM_version_7                          constant        fixed bin(17,0)          initial dcl 1-5 ref 114 174 215
addr                                                   builtin function         dcl 38 ref 93 227
allocated_len             0(06)        based           fixed bin(12,0)          level 3 packed unsigned unaligned dcl 1-48 set ref
                                                                                  127 142 142 242* 296 296
any_node                               based           structure                level 1 dcl 1-48
array_type               11     000000 constant        fixed bin(17,0)          initial level 3 dcl 1-9 ref 289
based_segment                          based           fixed bin(18,0)          array dcl 54 set ref 93 227
data_len                               parameter       fixed bin(17,0)          dcl 204 in procedure "create_new_block" set ref 202
                                                                                  229* 243
data_len                               parameter       fixed bin(17,0)          dcl 61 in procedure "lsm_" set ref 59 66* 110 127*
                                                                                  128 134 134 134 134 140 197 199*
data_len                               parameter       fixed bin(17,0)          dcl 154 in procedure "cv_data_len_to_words" ref 152
                                                                                  161 163
data_len                  0(18)        based           fixed bin(18,0)          level 3 in structure "indirect_node" packed unsigned
                                                                                  unaligned dcl 1-52 in procedure "lsm_" set ref
                                                                                  145* 191*
data_len                        000101 automatic       fixed bin(17,0)          dcl 264 in procedure "rep_struc_recurse" set ref
                                                                                  273* 281* 289
data_len                  0(18)        based           fixed bin(18,0)          level 3 in structure "any_node" packed unsigned
                                                                                  unaligned dcl 1-48 in procedure "lsm_" set ref 95
                                                                                  128* 140* 243*
data_len                               parameter       fixed bin(17,0)          dcl 71 in procedure "get_node_info" set ref 69 95*
data_length_factors      12     000000 constant        fixed bin(17,0)          initial array level 2 dcl 1-9 ref 160
data_space                1            based           bit(36)                  array level 2 dcl 1-48 set ref 142* 142 296* 296
divide                                                 builtin function         dcl 38 ref 163
err_code                               parameter       fixed bin(35,0)          dcl 260 in procedure "rep_struc_recurse" set ref 258
                                                                                  273* 274 281* 282 285* 291* 293
err_code                               parameter       fixed bin(35,0)          dcl 61 in procedure "lsm_" set ref 59 66* 110 115*
                                                                                  119* 120 123* 134* 138 168 175* 179* 181 183* 184
                                                                                  187* 197 199* 250 255*
err_code                               parameter       fixed bin(35,0)          dcl 71 in procedure "get_node_info" set ref 69 85*
                                                                                  89* 97* 105*
err_code                               parameter       fixed bin(35,0)          dcl 204 in procedure "create_new_block" set ref 202
                                                                                  216* 222* 232* 237*
error_table_$unimplemented_version
                                000022 external static fixed bin(35,0)          dcl 48 ref 115 175 216
factor                          000100 automatic       fixed bin(17,0)          dcl 157 set ref 160* 161 163 163
free                      1            based           fixed bin(18,0)          level 2 dcl 1-27 set ref 88 226 245* 245
graphic_error_table_$bad_node   000012 external static fixed bin(35,0)          dcl 42 ref 97 222
graphic_error_table_$inv_node_type
                                000014 external static fixed bin(35,0)          dcl 42 ref 123 187 285
graphic_error_table_$lsm_blk_len
                                000020 external static fixed bin(35,0)          dcl 42 ref 232
graphic_error_table_$lsm_node_ob
                                000010 external static fixed bin(35,0)          dcl 42 ref 85 89
graphic_error_table_$lsm_seg_full
                                000016 external static fixed bin(35,0)          dcl 42 ref 237
header                                 based           structure                level 1 dcl 1-42 in procedure "lsm_"
header                                 based           structure                level 2 in structure "any_node" dcl 1-48
                                                                                  in procedure "lsm_"
header                                 based           structure                level 2 in structure "indirect_node" dcl 1-52
                                                                                  in procedure "lsm_"
i                               000106 automatic       fixed bin(17,0)          dcl 264 set ref 289* 291 291*
indirect_node                          based           structure                level 1 dcl 1-52
indirect_type             1     000000 constant        fixed bin(17,0)          initial level 3 dcl 1-9 ref 78 80 101 143 192
initial_component_slots
                         24     000000 constant        fixed bin(17,0)          initial level 2 dcl 1-9 ref 81
list_node                              based           structure                level 1 dcl 1-85
list_type                10     000000 constant        fixed bin(17,0)          initial level 3 dcl 1-9 ref 289
lsm                                    based           structure                level 1 dcl 1-27 set ref 81
lsm_constants                   000000 constant        structure                level 1 dcl 1-9
lsm_segptr                             parameter       pointer                  dcl 1-25 in procedure "lsm_" set ref 59 66* 110 114
                                                                                  119* 134* 168 174 179* 183* 197 199* 250 255*
lsm_segptr                             parameter       pointer                  dcl 71 in procedure "get_node_info" ref 69 81 81 88
                                                                                  93
lsm_segptr                             parameter       pointer                  dcl 260 in procedure "rep_struc_recurse" set ref 258
                                                                                  273* 281* 291*
lsm_segptr                             parameter       pointer                  dcl 204 in procedure "create_new_block" ref 202 215
                                                                                  226 227 245 245
max                                                    builtin function         dcl 38 ref 134 134 161 163
max_allocation           23     000000 constant        fixed bin(17,0)          initial level 2 dcl 1-9 ref 134 134 231
min                                                    builtin function         dcl 38 ref 134 134
n_types                         000000 constant        fixed bin(17,0)          initial level 2 dcl 1-9 ref 96 221
new_copy_node                          parameter       fixed bin(18,0)          dcl 252 in procedure "lsm_" set ref 250 255*
new_copy_node                          parameter       fixed bin(18,0)          dcl 260 in procedure "rep_struc_recurse" set ref 258
                                                                                  269* 277* 281*
new_node                               parameter       fixed bin(18,0)          dcl 172 in procedure "lsm_" set ref 168 179* 193
new_node                  1            based           fixed bin(18,0)          level 2 in structure "indirect_node" dcl 1-52
                                                                                  in procedure "lsm_" set ref 101 144* 193*
new_node_ptr                    000104 automatic       pointer                  dcl 31 in procedure "lsm_" set ref 134* 140 142 148
new_node_ptr                    000104 automatic       pointer                  dcl 264 in procedure "rep_struc_recurse" set ref
                                                                                  281* 291 296
node                                   parameter       fixed bin(18,0)          dcl 71 in procedure "get_node_info" set ref 69 81 81
                                                                                  88 93 101*
node                                   parameter       fixed bin(18,0)          dcl 204 in procedure "create_new_block" set ref 202
                                                                                  213* 226* 227 236
node                                   parameter       fixed bin(18,0)          dcl 61 in procedure "lsm_" set ref 59 66* 110 119*
                                                                                  147* 197 199*
node                      1            based           fixed bin(18,0)          array level 2 in structure "list_node" dcl 1-85
                                                                                  in procedure "lsm_" set ref 291* 291*
node_ptr                               parameter       pointer                  dcl 71 in procedure "get_node_info" set ref 69 93*
                                                                                  94 95 101
node_ptr                               parameter       pointer                  dcl 204 in procedure "create_new_block" set ref 202
                                                                                  227* 241 242 243
node_ptr                               parameter       pointer                  dcl 1-40 in procedure "lsm_" set ref 59 66* 110 119*
                                                                                  127 128 142 143 144 145 148* 179* 183* 191 192 193
                                                                                  197 199*
old_data_len                    000101 automatic       fixed bin(17,0)          dcl 31 set ref 119*
old_node                               parameter       fixed bin(18,0)          dcl 172 set ref 168 183*
old_node_ptr                    000102 automatic       pointer                  dcl 264 set ref 273* 291 296
old_type                        000100 automatic       fixed bin(17,0)          dcl 31 set ref 183* 186
result                          000101 automatic       fixed bin(17,0)          dcl 157 set ref 161* 163* 165
size                                                   builtin function         dcl 38 ref 81
symbol_type               7     000000 constant        fixed bin(17,0)          initial level 3 dcl 1-9 ref 122 186 276
symtab_type               6     000000 constant        fixed bin(17,0)          initial level 3 dcl 1-9 ref 122 284
sys_info$max_seg_size           000024 external static fixed bin(35,0)          dcl 50 ref 236
temp_allocated_len              000100 automatic       fixed bin(17,0)          dcl 211 set ref 229* 231 236 242 245
temp_node                       000102 automatic       fixed bin(18,0)          dcl 31 set ref 134* 144 147
template_node                          parameter       fixed bin(18,0)          dcl 252 in procedure "lsm_" set ref 250 255*
template_node                          parameter       fixed bin(18,0)          dcl 260 in procedure "rep_struc_recurse" set ref 258
                                                                                  271 273* 277
type                                   parameter       fixed bin(17,0)          dcl 71 in procedure "get_node_info" set ref 69 78*
                                                                                  80 94* 96 96 101
type                                   parameter       fixed bin(17,0)          dcl 61 in procedure "lsm_" set ref 59 66* 110 119*
                                                                                  122 122 127* 134* 197 199*
type                                   based           fixed bin(6,0)           level 3 in structure "indirect_node" packed unsigned
                                                                                  unaligned dcl 1-52 in procedure "lsm_" set ref
                                                                                  192*
type                            000100 automatic       fixed bin(17,0)          dcl 264 in procedure "rep_struc_recurse" set ref
                                                                                  273* 276 281* 284 289 289
type                                   based           fixed bin(6,0)           level 3 in structure "any_node" packed unsigned
                                                                                  unaligned dcl 1-48 in procedure "lsm_" set ref 94
                                                                                  143* 241*
type                                   parameter       fixed bin(17,0)          dcl 154 in procedure "cv_data_len_to_words" ref 152
                                                                                  160
type                                   parameter       fixed bin(17,0)          dcl 204 in procedure "create_new_block" set ref 202
                                                                                  221 221 229* 241
types                     1     000000 constant        structure                level 2 dcl 1-9
unspec                                                 builtin function         dcl 38 set ref 142* 142 296* 296
version                                based           fixed bin(17,0)          level 2 dcl 1-27 ref 81 114 174 215

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
array_node                             based           structure                level 1 dcl 1-89
bit_node                               based           structure                level 1 dcl 1-64
char_node                              based           structure                level 1 dcl 1-68
fixed_node                             based           structure                level 1 dcl 1-56
float_node                             based           structure                level 1 dcl 1-60
symbol_node                            based           structure                level 1 dcl 1-78
symtab_node                            based           structure                level 1 dcl 1-72

NAMES DECLARED BY EXPLICIT CONTEXT.
create_new_block                000646 constant        entry                    internal dcl 202 ref 134 199 281
cv_data_len_to_words            000613 constant        entry                    internal dcl 152 ref 127 229
get_blk                         000046 constant        entry                    external dcl 59
get_node_info                   000516 constant        entry                    internal dcl 69 ref 66 119 179 183 273
lsm_                            000032 constant        entry                    external dcl 18
make_blk                        000433 constant        entry                    external dcl 197
rep_struc_recurse               000757 constant        entry                    internal dcl 258 ref 255 291
replace_blk                     000314 constant        entry                    external dcl 168
replicate                       000467 constant        entry                    external dcl 250
set_blk                         000102 constant        entry                    external dcl 110

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1350        1376    1134        1360
Length      1604    1134        26         172     214           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lsm_                                 91 external procedure  is an external procedure.  
get_node_info                        64 internal procedure  is called by several nonquick procedures.  
cv_data_len_to_words                 66 internal procedure  is called by several nonquick procedures.  
create_new_block                     76 internal procedure  is called by several nonquick procedures.  
rep_struc_recurse                    89 internal procedure  calls itself recursively.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
create_new_block         000100 temp_allocated_len          create_new_block
cv_data_len_to_words     000100 factor                      cv_data_len_to_words
                         000101 result                      cv_data_len_to_words
lsm_                     000100 old_type                    lsm_
                         000101 old_data_len                lsm_
                         000102 temp_node                   lsm_
                         000104 new_node_ptr                lsm_
rep_struc_recurse        000100 type                        rep_struc_recurse
                         000101 data_len                    rep_struc_recurse
                         000102 old_node_ptr                rep_struc_recurse
                         000104 new_node_ptr                rep_struc_recurse
                         000106 i                           rep_struc_recurse

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          call_int_this       call_int_other      return              fl2_to_fx1          ext_entry
int_entry

NO EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$unimplemented_version                          graphic_error_table_$bad_node
graphic_error_table_$inv_node_type                          graphic_error_table_$lsm_blk_len
graphic_error_table_$lsm_node_ob                            graphic_error_table_$lsm_seg_full
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     18 000031        18 000037        59 000040        66 000056        67 000077       110 000100       114 000112
    115 000117       116 000122       119 000123       120 000143       122 000145       123 000153       124 000156
    127 000157       128 000200       129 000204       134 000205       138 000247       140 000251       142 000255
    143 000275       144 000300       145 000302       147 000304       148 000305       150 000306       168 000307
    174 000324       175 000331       176 000334       179 000335       181 000357       183 000361       184 000403
    186 000405       187 000410       188 000413       191 000414       192 000421       193 000425       195 000430
    197 000431       199 000443       200 000464       250 000465       255 000477       256 000514        69 000515
     78 000523        80 000526        81 000532        85 000545        86 000550        88 000551        89 000556
     90 000561        93 000562        94 000564        95 000567        96 000572        97 000577        98 000602
    101 000603       103 000607       105 000610       106 000611       152 000612       160 000620       161 000624
    163 000634       165 000643       202 000645       213 000653       215 000655       216 000661       217 000663
    221 000664       222 000670       223 000672       226 000673       227 000676       229 000700       231 000713
    232 000716       233 000722       236 000723       237 000730       238 000732       241 000733       242 000740
    243 000744       245 000747       247 000755       258 000756       269 000764       271 000766       273 000770
    274 001011       276 001014       277 001017       278 001021       281 001022       282 001043       284 001046
    285 001051       286 001054       289 001055       291 001070       293 001106       294 001111       296 001114
    299 001133


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
