	COMPILATION LISTING OF SEGMENT fort_converter
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 11/10/88  1343.9 mst Thu
	    Options: optimize map

        1 /****^  ******************************************************
        2*        *                                                    *
        3*        * Copyright, (C) Honeywell Limited, 1983             *
        4*        *                                                    *
        5*        * Copyright (c) 1972 by Massachusetts Institute of   *
        6*        * Technology and Honeywell Information Systems, Inc. *
        7*        *                                                    *
        8*        ****************************************************** */
        9 
       10 
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(86-07-14,BWong), approve(86-07-14,MCR7286), audit(86-07-17,Ginter),
       14*     install(86-07-28,MR12.0-1105):
       15*     Fix fortran bug 463.
       16*                                                   END HISTORY COMMENTS */
       17 
       18 
       19 /* format: style3,^delnl,linecom */
       20 fort_converter:
       21      proc (a_ptr);
       22 
       23 /* Written:	Oct 77 - May 78, GDC & PES			*/
       24 
       25 /* Modified:
       26*   02 Aug 85, BW - 463: Removed code to set must_save_stack_extent.
       27*		The saving will no longer be done because of fortran_io_
       28*		problems.
       29*   25 Oct 84, HH - 444: Remove generation of 'sub_index' operators for
       30*		substring lengths.
       31*   22 Jun 84, MM - Install typeless functions support.
       32*   18 Aug 83, HH - 399: 'effectively_constant' doesn't free quads correctly.
       33*   14 Aug 83, HH - 398: Leave loop index defined when removing implied loops
       34*		from I/O statements.
       35*   27 Jul 83, HH - 392: Prevent replacement of named string constants by the
       36*		string value in 'opt_subscript_op's.
       37*   17 Jun 83, HH - 383: Add support for 'process_param_list_op'.
       38*   14 Apr 83, HH - 376: Move support of 'len' builtin to the code generator.
       39*   31 Jan 83, HH - Install LA/VLA support.
       40*   28 Nov 82, HH - 361: ASSIGNment of a format which the parser has made
       41*	into a named constant is not handled correctly.
       42*   11 Nov 82, HH - 363: 'optimize_vector' used 'dimension.size (i)' even
       43*	when one of the bounds of that dimension was variable, and the
       44*	code to unthread the final opt statement neglected to link the
       45*	previous operator of the opt statement to the first operator.
       46*	Also, 'optimize_vector' forgot to remove calculation of the virtual
       47*	origin of an array that was to be written as a vector starting at
       48*	its first word.
       49*    5 May 82, TO   - Add runtime_stack_extent required for character*(*) function.
       50*   25 Mar 82, TO   - Fixed navy bug 3 - "end if" not processed by "process_hold_stack_entry"
       51*	if statement following does not have "put_in_map" set.  Typically failed
       52*	if following statement was "else if" without code.
       53*   16 Nov 81, MEP  - Fixed bug 343, cat now looks at subrprog options.ansi_77
       54*   28 October 1981, CRD - Support inquire statement.
       55*   20 October 1981, CRD - Internal files.
       56*   3 August 1981, CRD - Fix bug 332.
       57*   28 July 1981, CRD - Change assign_label to replace format label with
       58*	associated format variable.
       59*   13 July 1981, CRD - Force creation of back targets for zero trip DO loops.
       60*   10 June 1981, CRD - New polish for backspace/endfile/rewind.
       61*   12 May 1981, CRD - Add equiv_op, not_equiv_op.
       62*   13 March 1981, CRD - Implement assumed size arrays.
       63*   25 February 1981, CRD - Implement array lower bounds ^= 1.
       64*   9 December 1980, CRD - Implement Fortran 77 block IF statement.
       65*   19 November 1980, CRD - Implement Fortran 77 zero trip DO loops.  Also fix
       66*	a bug in which star extent arrays only got a virtual_origin symbol
       67*	if they had variable extents.  Also fix optimize_vector to handle
       68*	star extent arrays correctly.
       69*   17 August 1980, CRD - Fix bug in subscript handling.
       70*   14 August 1980, CRD - Fix bug in handling of CHAR builtin.
       71*   29 July 1980, CRD - Change many calls to create_constant to
       72*	create_integer_constant instead.
       73*   28 July 1980, CRD - Add code for LEN builtin.
       74*   30 June 1980, MEP - Add code for substr'ing 
       75*   23 June 1980, CRD - Add code to compute must_save_stack_extent.
       76*   23 June 1980, CRD - Check ansi77 mode for concatenation.
       77*   18 June 1980, CRD - Change concatenation routines to generate sub_index
       78*	operators for the length.
       79*   6 June 80, CRD - Changes for new concatenation representation in the quads.
       80*   5 May 80, CRD - Rewrote compress_concat, fixing bugs.
       81*   2 May 80, MEP+CRD - Fix bug 258.  Changed new_free_object to use currentsize
       82*	builtin instead of size.
       83*   1 May 80, CRD - Fix unreported bug (the main loop was not handling counts
       84*	properly.)
       85*   31 Mar 80, MEP - Add code to recognize the sharing of virtual origins.
       86*   18 Dec 79, PES - Change to accept (read write)_namelist_op rather than namelist_op, to fix
       87*	bug 249, in which the optimizer appears to ignore the fact that a namelist read sets
       88*	the values in the namelist.  Also, make string_op an illegal input.
       89*   17 Sept 79, RAB - change last_assigned_op from 97 to 99 for register optimizer
       90*   13 Aug 79, RAB - change last_assigned_op from 95 to 97 in preparation for concatenation & substr
       91*   12 Jul 79, PES - Make encode_op processing bump the ref_count of it's output operand
       92*	if it's an array ref node.  Part of making encode/decode work as documented.
       93*   26 Jun 79, PES - Fix bug 217, in which the appearance of a reference to an element of
       94*	a logical array in a compound if statement condition might cause compiler
       95*	error 446, uninitialized array subscript.
       96*   21 Jun 79, RAB - Fix bug 216, in which the conversion rules are not properly obeyed
       97*	for <non-integer>**<integer> in that the integer will be converted to match
       98*	the data type of <non-integer>.
       99*   05 Feb 79, PES - Fix bug 201, in which incorrect code is generated when optimizing
      100*	for <expression>**<positive_integer_constant> except when the positive
      101*	integer constant is a power of two, or one greater than a power of two.
      102*   13 Dec 78, PES - Fix bug 199, in which implied do loops in i/o statements may
      103*	not optimize properly if there is more than one variable contained at a
      104*	given level of nesting.
      105*   08 Dec 78, PES - Fix bug in handling of nested statement function invocations.
      106*   25 Oct 78, PES - Changes for larger common blocks and arrays.
      107*   04 Sep 78, PES - Fix bug in handling of division in subscripts, and
      108*   bug in handling of statement functions in subscripts.
      109*   28 Jul 78, PES - Audit changes, fix bug in handling of character string
      110*   temporaries (167).
      111**/
      112 
      113 /* In the comments, the construction <phrase> stands for a single token which is described by
      114*   phrase; the construction <...> stands for an arbitrary number of stack entries of irrelevant nature;
      115*   braces {} are used to enclose a group which is repeated one or more times;
      116*   and the top of the stack is enclosed in parens--typically (<>) since the top of the stack is normally
      117*   the first unused item rather than the last used item. */
      118 
      119 
      120 /*   arguments   */
      121 
      122 dcl	a_ptr		ptr;
      123 
      124 /*   automatic   */
      125 
      126 dcl	(
      127 	block_if_clause_count,
      128 	block_if_offset,
      129 	combination_type,
      130 	dim_size_offset,
      131 	eol_offset,
      132 	exit_offset,
      133 	first_free_object	init (1),
      134 	hold_offset,
      135 	i,
      136 	j,
      137 	last_io_op,
      138 	last_op_index,
      139 	next_statement_index,
      140 	n_ops,
      141 	one,
      142 	op_index,
      143 	polish_offset,
      144 	rand_data_type	(8),
      145 	rand_node_type	(8),
      146 	save_polish_offset,
      147 	sf_num_args,
      148 	sf_offset,
      149 	sub_offset,
      150 	temp_index,
      151 	true_rand,
      152 	tkx,
      153 	virtual_origin_offset,
      154 	work_stack_offset,
      155 	zero
      156 	)		fixed bin (18);
      157 
      158 dcl	(subscript_processing, first_statement_function_done, suspend_subscript,
      159 	calls_local_entries, concatenates_star_extents)
      160 			bit (1) aligned init ("0"b);
      161 
      162 dcl	1 sub_stack	aligned based (sub_stack_p),
      163 	  2 last		fixed bin (18),
      164 	  2 nested	bit (1),
      165 	  2 symbol_node	ptr unaligned,
      166 	  2 dim_node	ptr unaligned,
      167 	  2 n_dimensions	fixed bin (18),
      168 	  2 dimension	fixed bin (18),
      169 	  2 element,
      170 	    3 constant	fixed bin (18),
      171 	    3 var		fixed bin (18),
      172 	  2 cum,
      173 	    3 temp	fixed bin (18),
      174 	    3 constant	fixed bin (18),
      175 	  2 dim,
      176 	    3 mult	fixed bin (18),
      177 	    3 temp	fixed bin (18),
      178 	    3 offset	fixed bin (18);
      179 
      180 dcl	1 sf_stack	aligned based (sf_stack_p),
      181 	  2 last		fixed bin (18),
      182 	  2 polish_offset	fixed bin (18),
      183 	  2 sf		fixed bin (18),
      184 	  2 current_arg	fixed bin (18),
      185 	  2 cur_sf_param	fixed bin (18),
      186 	  2 def_chain	ptr unaligned,
      187 	  2 num_args	fixed bin (18),
      188 	  2 arg_info	(sf_num_args refer (sf_stack.num_args)),
      189 	    3 operand	fixed bin (18),
      190 	    3 chain_start	fixed bin (18),
      191 	    3 chain_end	fixed bin (18);
      192 
      193 dcl	1 exit_stack	aligned based (exit_stack_p),
      194 	  2 last		fixed bin (18),
      195 	  2 op		fixed bin (18),
      196 	  2 count		fixed bin (18),
      197 	  2 do_label	fixed bin (18),
      198 	  2 xmit_at_this_level
      199 			fixed bin (18),
      200 	  2 ptr		ptr unaligned,
      201 	  2 zero_trip_branch
      202 			fixed bin (18);
      203 
      204 dcl	1 eol_stack	aligned based (eol_stack_p),
      205 	  2 last		fixed bin (18),
      206 	  2 op		fixed bin (18),
      207 	  2 work_stack_offset
      208 			fixed bin (18);
      209 
      210 dcl	1 hold_stack	aligned based (hold_stack_p),
      211 	  2 last		fixed bin (18),
      212 	  2 op_code	fixed bin (18),
      213 	  2 ptr		ptr unaligned;
      214 
      215 dcl	stack		(0:511) fixed bin (18);
      216 
      217 dcl	1 fort_data$builtin_name
      218 			aligned external static structure,
      219 	  2 number_of_names fixed bin (15),
      220 	  2 description	(100),
      221 	    3 name	char (8) aligned,
      222 	    3 generic_name	bit (1) unaligned,
      223 	    3 reserved	bit (35) unaligned,
      224 	    3 generic_func	(4) fixed bin (18),
      225 	    3 result_type	fixed bin (18);
      226 
      227 declare	1 virtual_origin_list
      228 			aligned based (virtual_origin_list_ptr),
      229 	  2 last		fixed binary (18),
      230 	  2 symbol_node	pointer unaligned,
      231 	  2 element_size	fixed binary (17),
      232 	  2 numb_of_dims	fixed binary (17),
      233 	  2 units		fixed binary (3) unsigned;
      234 
      235 declare	1 block_if_stack	aligned based (block_if_stack_p),
      236 	  2 last		fixed binary (18),
      237 	  2 n_clauses	fixed binary (18),
      238 	  2 clause	fixed binary (18),
      239 	  2 test_op	fixed binary (18),
      240 	  2 n_jumps	fixed binary (18),
      241 	  2 jump		(block_if_clause_count refer (block_if_stack.n_clauses)) fixed binary (18);
      242 
      243 declare	1 dim_size_list	aligned based (dim_size_list_ptr),
      244 	  2 last		fixed binary (18),
      245 	  2 bits		aligned,
      246 	    3 var		unaligned,
      247 	      4 lower	bit (1) unaligned,
      248 	      4 upper	bit (1) unaligned,
      249 	    3 pad		bit (34) unaligned,
      250 	  2 lower_bound	fixed binary (24),
      251 	  2 upper_bound	fixed binary (24),
      252 	  2 size		fixed binary (24);
      253 
      254 dcl	(array_ptr, block_if_stack_p, dim_size_list_ptr, eol_stack_p,
      255 	exit_stack_p, hold_stack_p, last_opt_statement, last_quad_p, opst,
      256 	r, s, sf_stack_p, sf_substitute_ptr, shared_struc_ptr, stm_ptr,
      257 	sub_stack_p, subp_ptr, temp_node_ptr, temp_ptr, virtual_origin_base,
      258 	virtual_origin_list_ptr)
      259 			ptr;
      260 
      261 /*   based   */
      262 
      263 dcl	p		(0:polish_max_len - 1) fixed bin (18) aligned based (polish_base),
      264 	q		(0:quad_max_len - 1) fixed bin (18) aligned based (quadruple_base),
      265 	w		(0:object_max_len - 1) fixed bin (18) aligned based (object_base),
      266 	x		(0:operand_max_len - 1) fixed bin (18) aligned based (operand_base);
      267 
      268 dcl	(polish_base, quadruple_base, object_base, operand_base)
      269 			ptr;
      270 
      271 dcl	(polish_max_len, quad_max_len, object_max_len, operand_max_len)
      272 			fixed bin (18);
      273 
      274 /*   builtin   */
      275 
      276 dcl	(addr, binary, bit, char, currentsize, fixed, hbound, index, max, null, ptr, rel, size, string, substr, unspec)
      277 			builtin;
      278 
      279 /*   include files   */
      280 
  1     1 /* BEGIN fort_utilities.incl.pl1 */
  1     2 
  1     3 /* Created:	October 1977, Richard Barnes
  1     4*
  1     5*   Modified:
  1     6*	22 May 1978, DSL - add create_constant.
  1     7*	09 Oct 1978, PES - make create_(constant node) return fixed bin(18) unsigned.
  1     8*	13 Dec 1978, PES - Get create_node from include file, rather than copy.
  1     9**/
  1    10 
  2     1 /* BEGIN fort_create_node.incl.pl1 */
  2     2 
  2     3 /* Created:	October 1977, Richard Barnes
  2     4*
  2     5*   Modified:
  2     6*	22 May 1978, DSL - add create_constant.
  2     7*	09 Oct 1978, PES - make create_(constant node) return fixed bin(18) unsigned.
  2     8*	13 Dec 1978, PES - changes for large common and arrays.
  2     9**/
  2    10 create_node:   proc(type,length) returns(fixed bin (18));
  2    11 
  2    12 dcl	length			fixed bin;
  2    13 dcl	offset			fixed bin(18);
  2    14 dcl	type			fixed bin(4);
  2    15 dcl	storage(length)		fixed bin aligned based;
  2    16 dcl	x(0:operand_max_len-1)	fixed bin(35) aligned based(operand_base);
  2    17 dcl	(addr,char,ltrim,unspec)	builtin;
  2    18 
  2    19 
  2    20 	if (length + next_free_operand) < operand_max_len
  2    21 	   then do;
  2    22 	        offset = next_free_operand;
  2    23 	        next_free_operand = next_free_operand + length;
  2    24 	        unspec(addr(x(offset)) -> storage) = "0"b;
  2    25 	        addr(x(offset)) -> node.node_type = type;
  2    26 	        return(offset);
  2    27 	        end;
  2    28 	   else do;
  2    29 		call print_message(407, "operand region", ltrim(char(operand_max_len))); /* FATAL */
  2    30 	        end;
  2    31 
  2    32 	end create_node;
  2    33 
  2    34 /* END fort_create_node.incl.pl1 */
  1    11 
  1    12 
  1    13 create_constant:	proc(data_type,value) returns(fixed bin (18));
  1    14 
  1    15 dcl	(data_type,a_data_type) 	fixed bin(4);	/* data type of constant */
  1    16 dcl	(value,a_value)	 	bit(72) aligned;	/* value of constant */
  1    17 
  1    18 dcl	addr			builtin;
  1    19 dcl	binary			builtin;
  1    20 dcl	bool			builtin;
  1    21 dcl	char			builtin;
  1    22 dcl	data_size			fixed bin(17);
  1    23 dcl	decimal			builtin;
  1    24 dcl	hash_index		fixed bin;
  1    25 dcl	hash_table(0:hash_table_size-1) fixed bin(35) aligned based(operand_base);
  1    26 dcl	hash_table_size		fixed bin int static options(constant) init(211);
  1    27 dcl	hbound			builtin;
  1    28 dcl	ltrim			builtin;
  1    29 dcl	mod			builtin;
  1    30 dcl	mod_2_sum			bit(36) aligned;
  1    31 dcl	node_offset		fixed bin;
  1    32 dcl	node_ptr			pointer;
  1    33 dcl	size			builtin;
  1    34 dcl	v_array(2)		bit(36) aligned based(addr(a_value));
  1    35 dcl	x(0:operand_max_len-1)	fixed bin(35) aligned based(operand_base);
  1    36 
  3     1 /* BEGIN INCLUDE FILE relocation_bits.incl.pl1 */
  3     2 
  3     3 /* This include file defines the relocation bits as bit (6) entities.  See
  3     4*   also relbts.incl.pl1 and reloc_lower.incl.pl1. */
  3     5 
  3     6 dcl (	rc_a	initial("000000"b),		/* absolute */
  3     7 	rc_t	initial("010000"b),		/* text */
  3     8 	rc_nt	initial("010001"b),		/* negative text */
  3     9 	rc_lp18	initial("010010"b),		/* linkage, 18 bit */
  3    10 	rc_nlp18	initial("010011"b),		/* negative link, 18 bit */
  3    11 	rc_lp15	initial("010100"b),		/* linkage, 15 bit */
  3    12 	rc_dp	initial("010101"b),		/* def section */
  3    13 	rc_s	initial("010110"b),		/* symbol segment */
  3    14 	rc_ns	initial("010111"b),		/* negative symbol */
  3    15 	rc_is18	initial("011000"b),		/* internal static 18 */
  3    16 	rc_is15	initial("011001"b),		/* internal static 15 */
  3    17 	rc_lb	initial("011000"b),		/* link block */
  3    18 	rc_nlb	initial("011001"b),		/* negative link block */
  3    19 	rc_sr	initial("011010"b),		/* self relative */
  3    20 	rc_e	initial("011111"b))		/* escape */
  3    21 	bit(6) int static options(constant);
  3    22 
  3    23 /* END INCLUDE FILE relocation_bits.incl.pl1 */
  1    37 
  1    38 
  1    39 
  1    40 	a_data_type = data_type;
  1    41 	a_value = value;
  1    42 
  1    43 	if a_data_type = char_mode | a_data_type <= 0 | a_data_type > hbound(data_type_size,1)
  1    44 	then do;
  1    45 	     call print_message(452, ltrim(char(decimal(a_data_type,12)))); /* cannot create the node */
  1    46 	     end;
  1    47 	else data_size = data_type_size(a_data_type);
  1    48 
  1    49 	if data_size = 1
  1    50 	then do;
  1    51 	     mod_2_sum = v_array(1);
  1    52 	     v_array(2) = "0"b;
  1    53 	     end;
  1    54 	else mod_2_sum = bool(v_array(1),v_array(2),"0110"b);
  1    55 
  1    56 
  1    57 	hash_index = mod(binary(mod_2_sum,35),hash_table_size);
  1    58 
  1    59 	/* Search the hash table for the constant. */
  1    60 
  1    61 	node_offset = hash_table(hash_index);
  1    62 	do while(node_offset > 0);			/* search the entire bucket */
  1    63 	     node_ptr = addr(x(node_offset));
  1    64 
  1    65 	     if node_ptr -> constant.value = a_value	/* must be same value */
  1    66 	     then if node_ptr -> node.data_type = a_data_type /* and same data type */
  1    67 		then return(node_offset);
  1    68 
  1    69 	     node_offset = node_ptr -> node.hash_chain;	/* NB - pointer remains pointing at last item in bucket */
  1    70 	     end;
  1    71 
  1    72 	/* a new constant node must be created */
  1    73 
  1    74 	node_offset = create_node(constant_node, size(constant));
  1    75 
  1    76 	if hash_table(hash_index) = 0			/* Is this the first item in the bucket? */
  1    77 	then hash_table(hash_index) = node_offset;	/* yes */
  1    78 	else node_ptr -> node.hash_chain = node_offset;	/* no, add it to the end */
  1    79 
  1    80 	node_ptr = addr(x(node_offset));
  1    81 	node_ptr -> constant.data_type = a_data_type;
  1    82 	node_ptr -> constant.operand_type = constant_type;
  1    83 	node_ptr -> constant.is_addressable = "1"b;
  1    84 	node_ptr -> constant.reloc = rc_t;
  1    85 	node_ptr -> constant.value = a_value;
  1    86 
  1    87 	constant_info(data_size).constant_count = constant_info(data_size).constant_count + 1;
  1    88 
  1    89 	if constant_info(data_size).first_constant = 0	/* Is this the first item of this size? */
  1    90 	then constant_info(data_size).first_constant = node_offset; /* yes */
  1    91 	else addr(x(constant_info(data_size).last_constant)) -> constant.next_constant = node_offset; /* no, add it */
  1    92 
  1    93 	constant_info(data_size).last_constant = node_offset;
  1    94 
  1    95 	return(node_offset);
  1    96 
  1    97 	end create_constant;
  1    98 
  1    99 /* END fort_utilities.incl.pl1 */
      281 
      282 
  4     1 /* BEGIN fort_nodes.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(86-07-14,BWong), approve(86-07-14,MCR7382), audit(86-07-17,Ginter),
  4     7*     install(86-07-28,MR12.0-1105):
  4     8*     Fix fortran bug 473.
  4     9*  2) change(88-04-28,RWaters), approve(88-04-28,MCR7875), audit(88-07-13,Huen),
  4    10*     install(88-11-10,MR12.2-1209):
  4    11*     Implement SCP 6339: Allow character variable to be up to 128K-1 (131071)
  4    12*     character long.
  4    13*                                                   END HISTORY COMMENTS */
  4    14 
  4    15 
  4    16 /* Written: June 1976 by David Levin and Richard Barnes
  4    17*
  4    18*Modified:
  4    19*	Feb 24 1977 by G. Chang for the optimizer
  4    20*	Sept 12, 1977 by R. Barnes for the loop optimizer
  4    21*	Nov 16, 1977 by D. Levin to add machine state node for loop optimizer
  4    22*	Oct 09 1978 by P Smee for larger common and arrays.
  4    23*	Dec 05 1978 by P Smee for %options statement.
  4    24*	Jan 17 1979 by R Barnes for machine_state.value_in_xr
  4    25*	May 23 1979 by P Smee to add source.line_number
  4    26*	July 19 1979 by R Barnes for char mode changes
  4    27*	Sept 17 1979 by R Barnes for register optimizer changes
  4    28*	Oct 3 1979 by C R Davis for new EAQ management scheme.
  4    29*	29 Oct 1979 by C R Davis for machine_state.eaq.reserved.
  4    30*	3 Nov 1979 by R. Barnes for pointer node and to change
  4    31*		machine_state.next from a fixed bin to a pointer.
  4    32*	18 Dec 1979 by R. Barnes for loop_ref_count to finalize
  4    33*		changes for the register optimizer.
  4    34*	17 Dec 1979 by C R Davis for symbol.descriptor
  4    35*	22 Dec 1979 by R. Barnes to remove in_list.
  4    36*	22 Jan 1980 by P E Smee to try for long char arrays.
  4    37*	23 Jan 1980 by C R Davis to fix bugs with yesterday's changes.
  4    38*	4 Mar 1980 by C R Davis to rename node.multi_position to
  4    39*		node.stack_indirect, and to add machine_state.stack_extended
  4    40*		and machine_state.last_dynamic_temp.
  4    41*	5 Jun 1980 by M E Presser to alter arg_desc node for use
  4    42*		in stack-extensions and arg-descriptor generation.
  4    43*	16 July 1980 by C R Davis for symbol.variable_arglist.
  4    44*	8 Jan 81 by M E Presser for label.not_referencable
  4    45*	17 Feb 1981 by C R Davis for new dimension node layout.
  4    46*	11 March 1981 by MEP for dimension.assumed_size
  4    47*	 3 May   1982 by TO to add star_extent_function to subprogram node.
  4    48* Mod 1	25 August 1982 by TO to add VLA_chain and LA_chain to subprogram node.
  4    49* Mod 1     2 September 1982 by TO to add 5 more entries to storage_info in
  4    50*	     the subprogram node (13-17), and to add VLA and LA bits to the
  4    51*	     symbol node.
  4    52* Mod 1	 2 September 1982 by TO move fields around in nodes to get correct
  4    53*	     24 (really 35) bit fields and still maintain mapping between
  4    54*	     node, temporary, and array_ref (others limit to word 6 like node.)
  4    55*	19 Jun 83, HH - 145: Add 'branched_to', 'ends_do_loop' & 'loop_end'
  4    56*		to 'label' node.
  4    57*	19 Feb 86, BW & AG - 473.a: Add 'VLA' to 'arg_desc' node.
  4    58*END Modifications */
  4    59 
  4    60 
  4    61 	/* GENERAL NODE TEMPLATE */
  4    62 
  4    63 dcl	1 node			aligned based structure,
  4    64 
  4    65 	/* WORD 1 */
  4    66 
  4    67 	  2 node_type		fixed bin (4) unaligned,
  4    68 	  2 data_type		fixed bin (4) unaligned unsigned,
  4    69 	  2 operand_type		fixed bin (4) unaligned,
  4    70 
  4    71 	  2 addressing_bits		unaligned structure,
  4    72 	    3 is_addressable	bit (1),
  4    73 	    3 value_in,
  4    74 	      4 eaq		bit (1),
  4    75 	      4 x			bit (1),
  4    76 	    3 allocated		bit (1),
  4    77 	    3 needs_pointer		bit (1),
  4    78 	    3 stack_indirect	bit (1),
  4    79 	    3 large_address		bit (1),
  4    80 	    3 address_in_base	bit (1),
  4    81 	    3 dont_update		bit (1),		/* for optimizer */
  4    82 	    3 not_in_storage	bit (1),		/* for optimizer */
  4    83 	    3 globally_assigned	bit (1),		/* for optimizer */
  4    84 
  4    85 	  2 bits			unaligned structure,
  4    86 	    3 standard_bits,
  4    87 	      4 allocate		bit (1),
  4    88 	      4 set		bit (1),
  4    89 	      4 referenced		bit (1),
  4    90 	      4 passed_as_arg	bit (1),
  4    91 
  4    92 	    3 fill		bit (7),		/* These bits may be used by individual nodes. */
  4    93 
  4    94 	/* WORD 2 */
  4    95 
  4    96 	  2 address		aligned structure,
  4    97 	    3 base		bit (3) unaligned,	     /* For labels and constants, base and offset are */
  4    98 	    3 offset		fixed bin (14) unaligned, /* combined to: fixed bin (18) unsigned unaligned. */
  4    99 	    3 char_num		fixed bin (2) unaligned unsigned,
  4   100 	    3 bit_num		fixed bin (4) unaligned unsigned,
  4   101 	    3 fill		bit (4) unaligned,
  4   102 	    3 inhibit		bit (1) unaligned,
  4   103 	    3 ext_base		bit (1) unaligned,
  4   104 	    3 tag			bit (6) unaligned,
  4   105 
  4   106 	/* WORD 3 */
  4   107 
  4   108 	  2 units			fixed bin (3) unaligned unsigned,
  4   109 	  2 fill			bit (3) unaligned,	/* already used in symbol node */
  4   110 	  2 reloc_hold		bit (6) unaligned,
  4   111 	  2 reloc			bit (6) unaligned,
  4   112 	  2 addr_hold		bit (18) unaligned,
  4   113 
  4   114 	/* WORD 4. Must not change for constant, char_constant, header, label, or symbol nodes. */
  4   115 
  4   116 	  2 next			fixed bin (18) unsigned unaligned,
  4   117 	  2 hash_chain		fixed bin (18) unsigned unaligned, /* No hash chain for header nodes. */
  4   118 
  4   119 	/* WORD 5 */
  4   120 
  4   121 	  2 pad			fixed bin (18) unsigned unaligned,
  4   122 	  2 loop_ref_count		fixed bin (17) unaligned,	/* Only for symbols and temporaries. */
  4   123 
  4   124 	/* WORD 6 */
  4   125 
  4   126 	  2 location		fixed bin (24) aligned;       /* Only for array refs, symbols, temporaries, and headers. */
  4   127 
  4   128 	/* ARG DESCRIPTOR NODE */
  4   129 
  4   130 dcl	1 arg_desc		based aligned,
  4   131 
  4   132 	/* WORD 1 */
  4   133 
  4   134 	  2 node_type		fixed bin (4) unaligned,
  4   135 	  2 n_args		fixed bin (12) unaligned,
  4   136 	  2 pad			bit (18) unaligned,
  4   137 
  4   138 	/* WORDS 2 - N_ARGS + 1 */
  4   139 
  4   140 	  2 arg(num_args refer(n_args))	aligned,
  4   141 	    3 data_type		fixed bin (4) unaligned unsigned,
  4   142 	    3 must_be		unaligned,
  4   143 	      4 array		bit (1) unaligned,
  4   144 	      4 scalar		bit (1) unaligned,
  4   145 	      4 VLA		bit (1) unaligned,
  4   146 	    3 star_extents		bit (1) unaligned,
  4   147 	    3 pad			bit (9) unaligned,
  4   148 	    3 symbol		fixed bin (18) unaligned;
  4   149 
  4   150 dcl	num_args fixed bin;
  4   151 
  4   152 
  4   153 	/*  ARRAY REF NODE -- Must be same size as TEMPORARY NODE.  */
  4   154 
  4   155 dcl	1 array_ref		aligned based structure,
  4   156 
  4   157 	/* WORD 1 */
  4   158 
  4   159 	  2 node_type		fixed bin (4) unaligned,
  4   160 	  2 data_type		fixed bin (4) unaligned unsigned,
  4   161 	  2 operand_type		fixed bin (4) unaligned,
  4   162 
  4   163 	  2 addressing_bits		unaligned structure,
  4   164 	    3 is_addressable	bit (1),
  4   165 	    3 value_in,
  4   166 	      4 eaq		bit (1),
  4   167 	      4 x			bit (1),
  4   168 	    3 allocated		bit (1),
  4   169 	    3 needs_pointer		bit (1),
  4   170 	    3 stack_indirect	bit (1),
  4   171 	    3 large_address		bit (1),
  4   172 	    3 address_in_base	bit (1),
  4   173 	    3 dont_update		bit (1),		/* for optimizer */
  4   174 	    3 not_in_storage	bit (1),		/* for optimizer */
  4   175 	    3 globally_assigned	bit (1),		/* for optimizer */
  4   176 
  4   177 	  2 bits			unaligned structure,
  4   178 	    3 standard_bits,
  4   179 	      4 allocate		bit (1),
  4   180 	      4 set		bit (1),
  4   181 	      4 referenced		bit (1),
  4   182 	      4 passed_as_arg	bit (1),
  4   183 
  4   184 	    3 variable_length	bit (1),
  4   185 
  4   186 	    3 variable_offset	bit (1),
  4   187 
  4   188 	    3 invariant		bit (1),	/* must line up with temporary node */
  4   189 	    3 irreducible		bit (1),	/* .. */
  4   190 	    3 used_across_loops	bit (1),	/* .. */
  4   191 
  4   192 	    3 large_offset		bit (1),
  4   193 
  4   194 	    3 has_address		bit (1),
  4   195 
  4   196 	/* WORD 2 */
  4   197 
  4   198 	  2 address		aligned structure,
  4   199 	    3 base		bit (3) unaligned,
  4   200 	    3 offset		fixed bin (14) unaligned,
  4   201 	    3 char_num		fixed bin (2) unaligned unsigned,
  4   202 	    3 bit_num		fixed bin (4) unaligned unsigned,
  4   203 	    3 fill		bit (4) unaligned,
  4   204 	    3 inhibit		bit (1) unaligned,
  4   205 	    3 ext_base		bit (1) unaligned,
  4   206 	    3 tag			bit (6) unaligned,
  4   207 
  4   208 	/* WORD 3 */
  4   209 
  4   210 	  2 units			fixed bin (3) unaligned unsigned,
  4   211 	  2 fill			bit (3) unaligned,
  4   212 	  2 reloc_hold		bit (6) unaligned,
  4   213 	  2 reloc			bit (6) unaligned,
  4   214 	  2 addr_hold		bit (18) unaligned,
  4   215 
  4   216 	/* WORD 4 */
  4   217 
  4   218 	  2 next			fixed bin (18) unsigned unaligned,
  4   219 	  2 loop_end_fu_pos		fixed bin (17) unaligned,	/* must overlay temporary.loop_end_fu_pos */
  4   220 
  4   221 	/* WORD 5 */
  4   222 
  4   223 	  2 pad			fixed bin (18) unsigned unaligned,
  4   224 	  2 v_offset		fixed bin (18) unsigned unaligned,
  4   225 
  4   226 	/* WORD 6 */
  4   227 
  4   228 	  2 location		fixed bin (24) aligned,
  4   229 
  4   230 	/* WORD 7 */
  4   231 
  4   232 	  2 ref_count		fixed bin (17) unaligned,	/* must overlay temporary.ref_count */
  4   233 	  2 output_by		fixed bin (18) unsigned unal,		/* must overlay temporary.output_by */
  4   234 
  4   235 	/* WORD 8 */
  4   236 
  4   237 	  2 length		fixed bin (24) aligned,
  4   238 
  4   239 	/* WORD 9 */
  4   240 
  4   241 	  2 start_input_to 		fixed bin (18) unsigned unal,		/* must overlay temporary.start_input_to */
  4   242 	  2 end_input_to		fixed bin (18) unsigned unal,		/* must overlay temporary.end_input_to */
  4   243 
  4   244 	/* WORD 10 */
  4   245 
  4   246 	  2 ref_count_copy		fixed bin (17) unaligned,	/* must overlay temporary.ref_count_copy */
  4   247 	  2 parent		fixed bin (18) unsigned unaligned,
  4   248 
  4   249 	/* WORD 11 */
  4   250 
  4   251             2 unused                    fixed bin (24) aligned;	/*  Pad to size of 'temporary'.  */
  4   252 
  4   253 
  4   254 	/* CONSTANT NODE */
  4   255 
  4   256 dcl	1 constant		aligned based structure,
  4   257 
  4   258 	/* WORD 1 */
  4   259 
  4   260 	  2 node_type		fixed bin (4) unaligned,
  4   261 	  2 data_type		fixed bin (4) unaligned unsigned,
  4   262 	  2 operand_type		fixed bin (4) unaligned,
  4   263 
  4   264 	  2 addressing_bits		unaligned structure,
  4   265 	    3 is_addressable	bit (1),
  4   266 	    3 value_in,
  4   267 	      4 eaq		bit (1),
  4   268 	      4 x			bit (1),
  4   269 	    3 allocated		bit (1),
  4   270 	    3 needs_pointer		bit (1),
  4   271 	    3 stack_indirect	bit (1),
  4   272 	    3 large_address		bit (1),
  4   273 	    3 address_in_base	bit (1),
  4   274 	    3 dont_update		bit (1),		/* for optimizer */
  4   275 	    3 not_in_storage	bit (1),		/* for optimizer */
  4   276 	    3 globally_assigned	bit (1),		/* for optimizer */
  4   277 
  4   278 	  2 bits			unaligned structure,
  4   279 	    3 standard_bits,
  4   280 	      4 allocate		bit (1),
  4   281 	      4 set		bit (1),
  4   282 	      4 referenced		bit (1),
  4   283 	      4 passed_as_arg	bit (1),
  4   284 
  4   285 	    3 fill		bit (7),
  4   286 
  4   287 	/* WORD 2 */
  4   288 
  4   289 	  2 address		aligned structure,
  4   290 	    3 location		fixed bin (18) unsigned unaligned,
  4   291 	    3 op			bit (10) unaligned,
  4   292 	    3 inhibit		bit (1) unaligned,
  4   293 	    3 ext_base		bit (1) unaligned,
  4   294 	    3 tag			bit (6) unaligned,
  4   295 
  4   296 	/* WORD 3 */
  4   297 
  4   298 	  2 units			fixed bin (3) unaligned unsigned,
  4   299 	  2 fill			bit (3) unaligned,
  4   300 	  2 reloc_hold		bit (6) unaligned,
  4   301 	  2 reloc			bit (6) unaligned,
  4   302 	  2 addr_hold		bit (18) unaligned,
  4   303 
  4   304 	/* WORD 4 */
  4   305 
  4   306 	  2 next_constant		fixed bin (18) unsigned unaligned,
  4   307 	  2 hash_chain		fixed bin (18) unsigned unaligned,
  4   308 
  4   309 	/* WORDS 5 & 6 */
  4   310 
  4   311 	  2 value			bit (72) aligned;
  4   312 
  4   313 
  4   314 	/* CHARACTER CONSTANT NODE */
  4   315 
  4   316 dcl	1 char_constant		aligned based structure,
  4   317 
  4   318 	/* WORD 1 */
  4   319 
  4   320 	  2 node_type		fixed bin (4) unaligned,
  4   321 	  2 data_type		fixed bin (4) unaligned unsigned,
  4   322 	  2 operand_type		fixed bin (4) unaligned,
  4   323 
  4   324 	  2 addressing_bits		unaligned structure,
  4   325 	    3 is_addressable	bit (1),
  4   326 	    3 value_in,
  4   327 	      4 eaq		bit (1),
  4   328 	      4 x			bit (1),
  4   329 	    3 allocated		bit (1),
  4   330 	    3 needs_pointer		bit (1),
  4   331 	    3 stack_indirect	bit (1),
  4   332 	    3 large_address		bit (1),
  4   333 	    3 address_in_base	bit (1),
  4   334 	    3 dont_update		bit (1),		/* for optimizer */
  4   335 	    3 not_in_storage	bit (1),		/* for optimizer */
  4   336 	    3 globally_assigned	bit (1),		/* for optimizer */
  4   337 
  4   338 	  2 bits			unaligned structure,
  4   339 	    3 standard_bits,
  4   340 	      4 allocate		bit (1),
  4   341 	      4 set		bit (1),
  4   342 	      4 referenced		bit (1),
  4   343 	      4 passed_as_arg	bit (1),
  4   344 
  4   345 	    3 no_value_stored	bit (1),
  4   346 
  4   347 	    3 fill		bit (6),
  4   348 
  4   349 	/* WORD 2 */
  4   350 
  4   351 	  2 address		aligned structure,
  4   352 	    3 location		fixed bin (18) unsigned unaligned,
  4   353 	    3 char_num		fixed bin (2) unaligned unsigned,
  4   354 	    3 bit_num		fixed bin (4) unaligned unsigned,
  4   355 	    3 fill		bit (4) unaligned,
  4   356 	    3 inhibit		bit (1) unaligned,
  4   357 	    3 ext_base		bit (1) unaligned,
  4   358 	    3 tag			bit (6) unaligned,
  4   359 
  4   360 	/* WORD 3 */
  4   361 
  4   362 	  2 units			fixed bin (3) unaligned unsigned,
  4   363 	  2 fill			bit (3) unaligned,
  4   364 	  2 reloc_hold		bit (6) unaligned,
  4   365 	  2 reloc			bit (6) unaligned,
  4   366 	  2 addr_hold		bit (18) unaligned,
  4   367 
  4   368 	/* WORD 4 */
  4   369 
  4   370 	  2 next_constant		fixed bin (18) unsigned unaligned,
  4   371 	  2 hash_chain		fixed bin (18) unsigned unaligned,
  4   372 
  4   373 	/* WORDS 5 thru n */
  4   374 
  4   375 	  2 length		fixed bin (18) unsigned unaligned,
  4   376 	  2 value			char(char_constant_length refer(char_constant.length)) unaligned;
  4   377 
  4   378 dcl	char_constant_length	fixed bin (18) unsigned;
  4   379 
  4   380 
  4   381 	/* DIMENSION NODE */
  4   382 
  4   383 dcl	1 dimension		aligned based structure,
  4   384 
  4   385 	/* WORD 1 */
  4   386 
  4   387 	  2 node_type 		fixed bin (4) unaligned,	/* The only field in common with other nodes */
  4   388 
  4   389 	  2 number_of_dims		fixed bin (3) unaligned,	/* Number of dimensions */
  4   390 
  4   391 	  2 v_bound		(7) unaligned,		/* Variable bound info - up to 7 dims. */
  4   392 	    3 lower		bit (1) unaligned,		/* On if lower bound is variable */
  4   393 	    3 upper		bit (1) unaligned,		/* On if upper bound is variable */
  4   394 
  4   395 	  2 has_virtual_origin	bit (1) unaligned,		/* On if virtual_origin is valid */
  4   396 	  2 has_array_size		bit (1) unaligned,		/* On if array_size is valid */
  4   397 	  2 has_dim_sizes		bit (1) unaligned,		/* On if dim.size (*) is valid */
  4   398 
  4   399 	  2 variable_virtual_origin	bit (1) unaligned,		/* On if virtual_origin is variable */
  4   400 	  2 variable_array_size	bit (1) unaligned,		/* On if array_size is variable */
  4   401 	  2 assumed_size		bit (1) unaligned,		/* On if array has assumed size */
  4   402 
  4   403 	  2 fill			bit (7) unaligned,
  4   404 
  4   405 	/* WORD 2 */
  4   406 
  4   407 	  2 virtual_origin		fixed bin (24) aligned,
  4   408 
  4   409 	/* WORD 3 */
  4   410 
  4   411 	  2 element_count		fixed bin (24) aligned,
  4   412 
  4   413 	/* WORD 4 */
  4   414 
  4   415 	  2 array_size		fixed bin (24) aligned,	/* Expressed in symbol.units */
  4   416 
  4   417 	/* WORD 5 */
  4   418 
  4   419 	  2 VLA_base_addressor	fixed bin (18) aligned,
  4   420 
  4   421 	/* WORDS 6 - n (max = 26) */
  4   422 
  4   423 	  2 dim (num_dims refer (dimension.number_of_dims)) aligned,
  4   424 
  4   425 	    3 lower_bound		fixed bin (24) aligned,	/* Lower bound of this dimension */
  4   426 
  4   427 	    3 upper_bound		fixed bin (24) aligned,	/* Upper bound of this dimension */
  4   428 
  4   429 	    3 size		fixed bin (24) aligned;	/* No. of elements in this dimension */
  4   430 
  4   431 dcl	num_dims			fixed bin (3);
  4   432 
  4   433 
  4   434 	/* HEADER NODE */
  4   435 
  4   436 dcl	1 header			aligned based structure,
  4   437 
  4   438 	/* WORD 1 */
  4   439 
  4   440 	  2 node_type		fixed bin (4) unaligned,
  4   441 	  2 data_type		fixed bin (4) unaligned unsigned,
  4   442 	  2 operand_type		fixed bin (4) unaligned,
  4   443 
  4   444 	  2 addressing_bits		unaligned structure,
  4   445 	    3 is_addressable	bit (1),
  4   446 	    3 value_in,
  4   447 	      4 eaq		bit (1),
  4   448 	      4 x			bit (1),
  4   449 	    3 allocated		bit (1),
  4   450 	    3 needs_pointer		bit (1),
  4   451 	    3 stack_indirect	bit (1),
  4   452 	    3 large_address		bit (1),
  4   453 	    3 address_in_base	bit (1),
  4   454 	    3 dont_update		bit (1),		/* for optimizer */
  4   455 	    3 not_in_storage	bit (1),		/* for optimizer */
  4   456 	    3 globally_assigned	bit (1),		/* for optimizer */
  4   457 
  4   458 	  2 bits			unaligned structure,
  4   459 	    3 storage_info,
  4   460 	      4 standard_bits,
  4   461 		5 allocate	bit (1),
  4   462 		5 set		bit (1),
  4   463 		5 referenced	bit (1),
  4   464 		5 passed_as_arg	bit (1),
  4   465 	      4 initialed		bit (1),		/* On if any member has initial attribute. */
  4   466 
  4   467 	    3 alignment		structure unaligned,
  4   468 	      4 even		bit (1),
  4   469 	      4 odd		bit (1),
  4   470 	      4 character		bit (1),
  4   471 
  4   472 	    3 storage_class		structure unaligned,
  4   473 	      4 automatic		bit (1),
  4   474 	      4 static		bit (1),
  4   475 	      4 in_common		bit (1),
  4   476 
  4   477 	/* WORD 2 */
  4   478 
  4   479 	  2 address		aligned structure,
  4   480 	    3 base		bit (3) unaligned,
  4   481 	    3 offset		fixed bin (14) unaligned,
  4   482 	    3 char_num		fixed bin (2) unaligned unsigned,
  4   483 	    3 bit_num		fixed bin (4) unaligned unsigned,
  4   484 	    3 fill		bit (4) unaligned,
  4   485 	    3 inhibit		bit (1) unaligned,
  4   486 	    3 ext_base		bit (1) unaligned,
  4   487 	    3 tag			bit (6) unaligned,
  4   488 
  4   489 	/* WORD 3 */
  4   490 
  4   491 	  2 units			fixed bin (3) unaligned unsigned,
  4   492 	  2 VLA bit (1) unaligned,			/* chain for VLA's */
  4   493 	  2 LA bit (1) unaligned,			/* chain for LA's */
  4   494 	  2 fill bit (1) unaligned,
  4   495 	  2 reloc_hold		bit (6) unaligned,
  4   496 	  2 reloc			bit (6) unaligned,
  4   497 	  2 addr_hold		bit (18) unaligned,
  4   498 
  4   499 	/* WORD 4 */
  4   500 
  4   501 	  2 next_header		fixed bin (18) unsigned unaligned,
  4   502 	  2 first_element		fixed bin (18) unsigned unaligned,
  4   503 
  4   504 	/* WORD 5 */
  4   505 
  4   506 	  2 last_element		fixed bin (18) unsigned unaligned,
  4   507 	  2 name_length		fixed bin (17) unaligned,
  4   508 
  4   509 	/* WORD 6 */
  4   510 
  4   511 	  2 location		fixed bin (24) aligned,
  4   512 
  4   513 	/* WORD 7 */
  4   514 
  4   515 	  2 length		fixed bin (24) aligned,
  4   516 
  4   517 	/* WORD 8 */
  4   518 
  4   519 	  2 VLA_base_addressor	fixed bin (18) aligned,
  4   520 
  4   521 	/* WORDS 9 - n. This field is variable in length. Its length is zero for equivalence groups. */
  4   522 
  4   523 	  2 block_name		char(allocate_symbol_name refer (header.name_length)) aligned;
  4   524 
  4   525 dcl	allocate_symbol_name	fixed bin;
  4   526 
  4   527 
  4   528 	/* LABEL NODE */
  4   529 
  4   530 dcl	1 label			aligned based structure,
  4   531 
  4   532 	/* WORD 1 */
  4   533 
  4   534 	  2 node_type		fixed bin (4) unaligned,
  4   535 	  2 data_type		fixed bin (4) unaligned unsigned,
  4   536 	  2 operand_type		fixed bin (4) unaligned,
  4   537 
  4   538 	  2 addressing_bits		unaligned structure,
  4   539 	    3 is_addressable	bit (1),
  4   540 	    3 value_in,
  4   541 	      4 eaq		bit (1),
  4   542 	      4 x			bit (1),
  4   543 	    3 allocated		bit (1),
  4   544 	    3 needs_pointer		bit (1),
  4   545 	    3 stack_indirect	bit (1),
  4   546 	    3 large_address		bit (1),
  4   547 	    3 address_in_base	bit (1),
  4   548 	    3 dont_update		bit (1),		/* for optimizer */
  4   549 	    3 not_in_storage	bit (1),		/* for optimizer */
  4   550 	    3 globally_assigned	bit (1),		/* for optimizer */
  4   551 
  4   552 	  2 bits			unaligned structure,
  4   553 	    3 storage_info,
  4   554 	      4 standard_bits,
  4   555 		5 allocate	bit (1),
  4   556 		5 set		bit (1),
  4   557 		5 referenced	bit (1),
  4   558 		5 passed_as_arg	bit (1),
  4   559 	      4 referenced_executable bit (1),
  4   560 
  4   561 	    3 usage,	/* Label is on a non-executable stmnt if both bits are ON. */
  4   562 	      4 format		bit (1),
  4   563 	      4 executable		bit (1),
  4   564 
  4   565 	    3 restore_prs		bit (1),
  4   566 	    3 not_referencable	bit (1),
  4   567 	    3 branched_to		bit (1),
  4   568 	    3 ends_do_loop		bit (1),
  4   569 
  4   570 	/* WORD 2 */
  4   571 
  4   572 	  2 address		aligned structure,
  4   573 	    3 location		fixed bin (18) unsigned unaligned,
  4   574 	    3 op			bit (10) unaligned,
  4   575 	    3 inhibit		bit (1) unaligned,
  4   576 	    3 ext_base		bit (1) unaligned,
  4   577 	    3 tag			bit (6) unaligned,
  4   578 
  4   579 	/* WORD 3 */
  4   580 
  4   581 	  2 units			fixed bin (3) unaligned unsigned,
  4   582 	  2 fill			bit (3) unaligned,
  4   583 	  2 reloc_hold		bit (6) unaligned,
  4   584 	  2 reloc			bit (6) unaligned,
  4   585 	  2 addr_hold		bit (18) unaligned,
  4   586 
  4   587 	/* WORD 4 */
  4   588 
  4   589 	  2 next_label		fixed bin (18) unsigned unaligned,
  4   590 	  2 hash_chain		fixed bin (18) unsigned unaligned,
  4   591 
  4   592 	/* WORD 5 */
  4   593 
  4   594 	  2 format_var		fixed bin (18) unsigned unaligned,
  4   595 	  2 name			fixed bin (17) unaligned,
  4   596 
  4   597 	/* WORD 6 */
  4   598 
  4   599 	  2 statement		fixed bin (18) unsigned unaligned,
  4   600 	  2 loop_end		fixed bin (18) unsigned unaligned;
  4   601 
  4   602 
  4   603 	/*  LIBRARY NODE  */
  4   604 
  4   605 dcl	1 library			aligned based structure,
  4   606 
  4   607 	/* WORD 1 */
  4   608 
  4   609 	  2 node_type		fixed bin (4) unaligned, /* The only field in common with the other nodes. */
  4   610 	  2 fill 			bit (13) unaligned,
  4   611 	  2 next_library_node	fixed bin (18) unsigned unaligned,
  4   612 
  4   613 	/* WORD 2 */
  4   614 
  4   615 	  2 character_operand	fixed bin (18) unsigned aligned;
  4   616 
  4   617 
  4   618 	/* MACHINE_STATE NODE */
  4   619 
  4   620 dcl	1 machine_state		aligned based structure,
  4   621 
  4   622 	/* WORD 1 */
  4   623 
  4   624 	  2 node_type		fixed bin (4) unal,
  4   625 	  2 pad			bit (31) unal,
  4   626 
  4   627 	/* WORD 2 */
  4   628 
  4   629 	  2 next			pointer unaligned,
  4   630 
  4   631 	/* WORDS 3-104 */
  4   632 
  4   633 	  2 ms			aligned,
  4   634 
  4   635 	    3 eaq (4),				/* One for each of the A, Q, EAQ, and IND */
  4   636 	      4 name		fixed bin,
  4   637 	      4 number		fixed bin,
  4   638 	      4 variable(4)		fixed bin (18),
  4   639 	      4 reserved		bit (1) aligned,
  4   640 	    3 rounded		bit (1) aligned,
  4   641 	    3 indicators_valid	fixed bin (18),
  4   642 
  4   643 	    3 value_in_xr		bit (1) aligned,
  4   644 
  4   645 	    3 index_regs(0:7),
  4   646 	      4 bits		structure unaligned,
  4   647 	        5 global		bit (1),
  4   648 	        5 reserved		bit (1),
  4   649 	        5 mbz		bit (34),
  4   650 	      4 type		fixed bin (18),
  4   651 	      4 variable		fixed bin (18),
  4   652 	      4 used		fixed bin (18),
  4   653 	      4 mbz		fixed bin (18),
  4   654 
  4   655 	    3 address_in_base	bit (1) aligned,
  4   656 
  4   657 	    3 base_regs(0:7),
  4   658 	      4 bits		structure unaligned,
  4   659 	        5 global		bit (1),
  4   660 	        5 reserved		bit (1),
  4   661 	        5 mbz		bit (34),
  4   662 	      4 type		fixed bin (18),
  4   663 	      4 variable		fixed bin (18),
  4   664 	      4 used		fixed bin (18),
  4   665 	      4 offset		fixed bin (18),
  4   666 
  4   667 	    3 stack_extended	bit (1) aligned,
  4   668 	    3 last_dynamic_temp	fixed bin (18);
  4   669 
  4   670 	/* POINTER NODE */
  4   671 
  4   672 dcl	1 pointer			aligned based structure,
  4   673 
  4   674 	/* WORD 1 */
  4   675 
  4   676 	  2 node_type		fixed bin (4) unaligned,
  4   677 	  2 pad			bit (4) unaligned,
  4   678 	  2 code			fixed bin (9) unaligned unsigned,
  4   679 	  2 variable		fixed bin (18) unaligned unsigned,
  4   680 
  4   681 	/* WORD 2 */
  4   682 
  4   683 	  2 offset		fixed bin (18) unaligned unsigned,
  4   684 	  2 count			fixed bin (18) unaligned unsigned,
  4   685 
  4   686 	/* WORD 3 */
  4   687 
  4   688 	  2 hash_chain		fixed bin (18) aligned;
  4   689 
  4   690 
  4   691 	/* SOURCE NODE */
  4   692 
  4   693 dcl	1 source			aligned based structure,
  4   694 
  4   695 	/* WORD 1 */
  4   696 
  4   697 	  2 node_type		fixed bin (4) unal,
  4   698 	  2 pad			bit (13) unal,
  4   699 	  2 line_number		fixed bin (17) unaligned,
  4   700 
  4   701 	/* WORD 2 */
  4   702 
  4   703 	  2 uid			bit (36) aligned,
  4   704 
  4   705 	/* WORDS 3 & 4 */
  4   706 
  4   707 	  2 dtm			fixed bin (71) unaligned,
  4   708 
  4   709 	/* WORD 5 */
  4   710 
  4   711 	  2 next			fixed bin (18) unsigned unaligned,
  4   712 	  2 initial_subprogram	fixed bin (18) unsigned unaligned,
  4   713 
  4   714 	/* WORDS 6 - ? (depends on length of pathname) */
  4   715 
  4   716 	  2 pathname		char(256) varying;
  4   717 
  4   718 
  4   719 	/* STATEMENT NODE - This node only appears in the polish. */
  4   720 
  4   721 dcl	1 statement		aligned based structure,
  4   722 
  4   723 	/* WORD 1 */
  4   724 
  4   725 	  2 op_code		fixed bin aligned,	/* Always equal to "stat_op". */
  4   726 
  4   727 	/* WORD 2 */
  4   728 
  4   729 	  2 next			bit (18) unaligned,	/* "0"b = no next stmnt */
  4   730 	  2 location		bit (18) unaligned,	/* (18)"1"b = no text */
  4   731 
  4   732 	/* WORD 3 */
  4   733 
  4   734 	  2 source_id		structure unaligned,
  4   735 	    3 file		fixed bin (8) unsigned,	/* 0 = first file */
  4   736 	    3 line		bit (14),
  4   737 	    3 statement		bit (5),		/* 1 = first statement */
  4   738 
  4   739 	  2 length		bit (9) unaligned,
  4   740 
  4   741 	/* WORD 4 */
  4   742 
  4   743 	  2 bits			structure unaligned,
  4   744 	    3 put_in_map		bit (1) unaligned,
  4   745 	    3 put_in_profile	bit (1) unaligned,
  4   746 	    3 pad			bit (7) unaligned,
  4   747 
  4   748 	  2 start			fixed bin (26) unaligned;
  4   749 
  4   750 
  4   751 	/* SUBPROGRAM NODE */
  4   752 
  4   753 dcl	1 subprogram		aligned based structure,
  4   754 
  4   755 	/* WORD 1 */
  4   756 
  4   757 	  2 node_type		fixed bin (4) unaligned, /* The only field in common with the other nodes. */
  4   758 	  2 subprogram_type		fixed bin (3) unaligned,
  4   759 	  2 default_is		unaligned,
  4   760 	    3 auto		bit (1),
  4   761 	    3 static		bit (1),
  4   762 	  2 need_PS		bit (1) unaligned,
  4   763 	  2 need_prologue		bit (1) unaligned,
  4   764 	  2 multiple_entry		bit (1) unaligned,
  4   765 	  2 namelist_used		bit (1) unaligned,
  4   766 	  2 has_parameters		bit (1) unaligned,
  4   767 	  2 star_extent_function	bit (1) unaligned,
  4   768 	  2 fill			bit (1) unaligned,
  4   769 
  4   770 	  2 symbol		fixed bin (18) unsigned unaligned, /* symbol node for subprogram name */
  4   771 
  4   772 	/* WORD 2 */
  4   773 
  4   774 	  2 previous_subprogram	fixed bin (18) unsigned unaligned,
  4   775 	  2 next_subprogram		fixed bin (18) unsigned unaligned,
  4   776 
  4   777 	/* WORD 3 */
  4   778 
  4   779 	  2 common_chain		fixed bin (18) unsigned unaligned,
  4   780 	  2 equiv_chain		fixed bin (18) unsigned unaligned,
  4   781 
  4   782 	/* WORD 4 */
  4   783 
  4   784 	  2 first_symbol		fixed bin (18) unsigned unaligned,
  4   785 	  2 last_symbol		fixed bin (18) unsigned unaligned,
  4   786 
  4   787 	/* WORD 5 */
  4   788 
  4   789 	  2 first_label		fixed bin (18) unsigned unaligned,
  4   790 	  2 last_label		fixed bin (18) unsigned unaligned,
  4   791 
  4   792 	/* WORD 6 */
  4   793 
  4   794 	  2 first_polish		fixed bin (18) unsigned unaligned,
  4   795 	  2 last_polish		fixed bin (18) unsigned unaligned,
  4   796 
  4   797 	/* WORD 7 */
  4   798 
  4   799 	  2 map			unaligned,
  4   800 	    3 first		fixed bin (18) unsigned unaligned,
  4   801 	    3 last		fixed bin (18) unsigned unaligned,
  4   802 
  4   803 	/* WORD 8 */
  4   804 
  4   805 	  2 entry_info		fixed bin (18) unsigned unaligned,
  4   806 	  2 runtime		fixed bin (18) unsigned unaligned,
  4   807 
  4   808 	/* WORD 9 */
  4   809 
  4   810 	  2 first_quad		fixed bin (18) unsigned unaligned,
  4   811 	  2 last_quad		fixed bin (18) unsigned unaligned,
  4   812 
  4   813 	/* WORD 10 */
  4   814 
  4   815 	  2 options		aligned like fortran_options,
  4   816 
  4   817 	/* WORDS 11 - 44 */
  4   818 
  4   819 	  2 storage_info(17)	aligned,
  4   820 	    3 first		fixed bin (18) unsigned unaligned,
  4   821 	    3 last		fixed bin (18) unsigned unaligned,
  4   822 	    3 next_loc		fixed bin (18) aligned,
  4   823 
  4   824 	/* WORD 45 */
  4   825 
  4   826 	  2 loop_vector_p		pointer unaligned,
  4   827 
  4   828 	/* WORD 46 */
  4   829 
  4   830 	  2 n_loops		fixed bin (18) unsigned unaligned,
  4   831 	  2 max_operators		fixed bin (18) unsigned unaligned,
  4   832 
  4   833 	/* WORD 47 */
  4   834 
  4   835 	  2 VLA_chain		fixed bin (18) unsigned unaligned,  /* Mod 1 */
  4   836 	  2 LA_chain		fixed bin (18) unsigned unaligned,  /* Mod 1 */
  4   837 	/* WORD 48 */
  4   838 
  4   839 	  2 max_sym		fixed bin (18) aligned;
  4   840 
  4   841 
  4   842 	/* SYMBOL NODE */
  4   843 
  4   844 dcl	1 symbol			aligned based structure,
  4   845 
  4   846 	/* WORD 1 */
  4   847 
  4   848 	  2 node_type		fixed bin (4) unaligned,
  4   849 	  2 data_type		fixed bin (4) unaligned unsigned,
  4   850 	  2 operand_type		fixed bin (4) unaligned,
  4   851 
  4   852 	  2 addressing_bits		unaligned structure,
  4   853 	    3 is_addressable	bit (1),
  4   854 	    3 value_in,
  4   855 	      4 eaq		bit (1),
  4   856 	      4 x			bit (1),
  4   857 	    3 allocated		bit (1),
  4   858 	    3 needs_pointer		bit (1),
  4   859 	    3 stack_indirect	bit (1),
  4   860 	    3 large_address		bit (1),
  4   861 	    3 address_in_base 	bit (1),
  4   862 	    3 dont_update		bit (1),		/* for optimizer */
  4   863 	    3 not_in_storage	bit (1),		/* for optimizer */
  4   864 	    3 globally_assigned	bit (1),		/* for optimizer */
  4   865 
  4   866 	  2 bits			unaligned structure,
  4   867 	    3 storage_info,
  4   868 	      4 standard_bits,
  4   869 		5 allocate	bit (1),
  4   870 		5 set		bit (1),
  4   871 		5 referenced	bit (1),
  4   872 		5 passed_as_arg	bit (1),
  4   873 	      4 initialed		bit (1),		/* Allows variable to become a constant. */
  4   874 
  4   875 	    3 variable_arglist	bit (1),
  4   876 	    3 dummy_arg		bit (1),
  4   877 	    3 variable_extents	bit (1),
  4   878 	    3 needs_descriptors	bit (1),
  4   879 	    3 put_in_symtab		bit (1),
  4   880 	    3 by_compiler		bit (1),
  4   881 
  4   882 	/* WORD 2 */
  4   883 
  4   884 	  2 address		aligned structure,
  4   885 	    3 base		bit (3) unaligned,
  4   886 	    3 offset		fixed bin (14) unaligned,
  4   887 	    3 char_num		fixed bin (2) unaligned unsigned,
  4   888 	    3 bit_num		fixed bin (4) unaligned unsigned,
  4   889 	    3 fill		bit (4) unaligned,
  4   890 	    3 inhibit		bit (1) unaligned,
  4   891 	    3 ext_base		bit (1) unaligned,
  4   892 	    3 tag			bit (6) unaligned,
  4   893 
  4   894 	/* WORD 3 */
  4   895 
  4   896 	  2 units			fixed bin (3) unaligned unsigned,
  4   897 	  2 aliasable		bit (1) unaligned,
  4   898 	  2 has_constant_value	bit (1) unaligned,
  4   899 	  2 new_induction_var	bit (1) unaligned,
  4   900 	  2 reloc_hold		bit (6) unaligned,
  4   901 	  2 reloc			bit (6) unaligned,
  4   902 	  2 addr_hold		bit (18) unaligned,
  4   903 
  4   904 	/* WORD 4 */
  4   905 
  4   906 	  2 next_symbol		fixed bin (18) unsigned unaligned,
  4   907 	  2 hash_chain		fixed bin (18) unsigned unaligned,
  4   908 
  4   909 	/* WORD 5 */
  4   910 
  4   911 	  2 ext_attributes unaligned structure,
  4   912 	    3 VLA bit (1),				/* symbol is Very large Element */
  4   913 	    3 LA bit (1),				/* symbol is Large Element */
  4   914 	    3 pad bit (18-2),
  4   915 
  4   916 	  2 loop_ref_count		fixed bin (17) unaligned,
  4   917 
  4   918 	/* WORD 6 */
  4   919 
  4   920 	  2 location		fixed bin (24) aligned,
  4   921 
  4   922 	/* WORD 7 */
  4   923 
  4   924 	  2 v_length		fixed bin (18) unsigned unaligned,
  4   925 	  2 general		fixed bin (18) unsigned unaligned,
  4   926 
  4   927 	/* WORD 8 */
  4   928 
  4   929 	  2 parent		fixed bin (18) unsigned unaligned,
  4   930 	  2 next_member		fixed bin (18) unsigned unaligned,
  4   931 
  4   932 	/* WORD 9 */
  4   933 
  4   934 	  2 attributes		aligned structure,
  4   935 	    3 mode_bits		unaligned structure,
  4   936 	      4 char_size		fixed bin (20) unsigned,
  4   937 	      4 mode,
  4   938 	        5 integer		bit (1),
  4   939 	        5 real		bit (1),
  4   940 	        5 double_precision	bit (1),
  4   941 	        5 complex		bit (1),
  4   942 	        5 logical		bit (1),
  4   943 	        5 character		bit (1),
  4   944 	        5 label_value	bit (1),
  4   945 	        5 entry_value	bit (1),
  4   946 
  4   947 	    3 misc_attributes	unaligned structure,
  4   948 	      4 function		bit (1),
  4   949 	      4 subroutine		bit (1),
  4   950 	      4 entry_point		bit (1),
  4   951 	      4 external		bit (1),
  4   952 	      4 builtin		bit (1),
  4   953 	      4 stmnt_func		bit (1),
  4   954 	      4 namelist		bit (1),
  4   955 	      4 dimensioned		bit (1),
  4   956 
  4   957 	/* WORD 10 */
  4   958 
  4   959 	    3 storage_class		unaligned structure,
  4   960 	      4 automatic		bit (1),
  4   961 	      4 static		bit (1),
  4   962 	      4 in_common		bit (1),
  4   963 	      4 equivalenced	bit (1),
  4   964 	      4 parameter		bit (1),
  4   965 	      4 constant		bit (1),		/* If external or entry_point. */
  4   966 	      4 named_constant	bit (1),
  4   967 
  4   968 	    3 variable		bit (1) unaligned,
  4   969 	    3 in_equiv_stmnt	bit (1) unaligned,
  4   970 	    3 star_extents		bit (1) unaligned,
  4   971 	    3 descriptor		bit (1) unaligned,
  4   972 	  2 pad			bit (25) unaligned,
  4   973 
  4   974           /* WORD 11 */
  4   975 
  4   976 	  2 dimension		fixed bin (18) unsigned unaligned,	/* Bounds may be added after symbol is declared. */
  4   977 	  2 initial		fixed bin (18) unsigned unaligned,
  4   978 
  4   979           /* WORD 12 */
  4   980 
  4   981 	  2 runtime		bit (18) unaligned,
  4   982 	  2 name_length		fixed bin (17) unaligned,
  4   983 
  4   984           /* WORD 13 */
  4   985 
  4   986 	  2 coordinate		fixed bin (17) unaligned,	/* used by loop optimizer */
  4   987 	  2 element_size		fixed bin (17) unaligned,
  4   988 
  4   989           /* WORD 14 */
  4   990 
  4   991 	  2 secondary		pointer unaligned,		/* used by loop optimizer */
  4   992 
  4   993           /* WORD 15 */
  4   994 
  4   995 	  2 offset		fixed bin (24) aligned,
  4   996 
  4   997 	/* WORDS 16 - n. This field is variable in length. */
  4   998 
  4   999 	  2 name			char(allocate_symbol_name refer (symbol.name_length)) aligned;
  4  1000 
  4  1001 
  4  1002 
  4  1003 	/*  TEMPORARY NODE -- Must be same size as ARRAY REF NODE.  */
  4  1004 
  4  1005 dcl	1 temporary		aligned based structure,
  4  1006 
  4  1007 	/* WORD 1 */
  4  1008 
  4  1009 	  2 node_type		fixed bin (4) unaligned,
  4  1010 	  2 data_type		fixed bin (4) unaligned unsigned,
  4  1011 	  2 operand_type		fixed bin (4) unaligned,
  4  1012 
  4  1013 	  2 addressing_bits		unaligned structure,
  4  1014 	    3 is_addressable	bit (1),
  4  1015 	    3 value_in,
  4  1016 	      4 eaq		bit (1),
  4  1017 	      4 x			bit (1),
  4  1018 	    3 allocated		bit (1),
  4  1019 	    3 needs_pointer		bit (1),
  4  1020 	    3 stack_indirect	bit (1),
  4  1021 	    3 large_address		bit (1),
  4  1022 	    3 address_in_base	bit (1),
  4  1023 	    3 dont_update		bit (1),		/* for optimizer */
  4  1024 	    3 not_in_storage	bit (1),		/* for optimizer */
  4  1025 	    3 globally_assigned	bit (1),		/* for optimizer */
  4  1026 
  4  1027 	  2 bits			unaligned structure,
  4  1028 	    3 standard_bits,
  4  1029 	      4 allocate		bit (1),
  4  1030 	      4 set		bit (1),
  4  1031 	      4 referenced		bit (1),
  4  1032 	      4 passed_as_arg	bit (1),
  4  1033 
  4  1034 	    3 variable_length	bit (1),
  4  1035 
  4  1036 	    3 fill		bit (1),	/* can be used */
  4  1037 
  4  1038 	    3 invariant		bit (1),	/* must line up with array_ref node */
  4  1039 	    3 irreducible		bit (1),	/* .. */
  4  1040 	    3 used_across_loops	bit (1),	/* .. */
  4  1041 	    3 frozen_for_do		bit (1),
  4  1042 	    3 used_as_subscript	bit (1),
  4  1043 
  4  1044 	/* WORD 2 */
  4  1045 
  4  1046 	  2 address		aligned structure,
  4  1047 	    3 base		bit (3) unaligned,
  4  1048 	    3 offset		fixed bin (14) unaligned,
  4  1049 	    3 char_num		fixed bin (2) unaligned unsigned,
  4  1050 	    3 bit_num		fixed bin (4) unaligned unsigned,
  4  1051 	    3 fill		bit (4) unaligned,
  4  1052 	    3 inhibit		bit (1) unaligned,
  4  1053 	    3 ext_base		bit (1) unaligned,
  4  1054 	    3 tag			bit (6) unaligned,
  4  1055 
  4  1056 	/* WORD 3 */
  4  1057 
  4  1058 	  2 units			fixed bin (3) unaligned unsigned,
  4  1059 	  2 fill			bit (3) unaligned,
  4  1060 	  2 reloc_hold		bit (6) unaligned,
  4  1061 	  2 reloc			bit (6) unaligned,
  4  1062 	  2 addr_hold		bit (18) unaligned,
  4  1063 
  4  1064 	/* WORD 4 */
  4  1065 
  4  1066 	  2 next			fixed bin (18) unsigned unaligned,
  4  1067 	  2 loop_end_fu_pos		fixed bin (17) unaligned,	/* must overlay array_ref.loop_end_fu_pos */
  4  1068 
  4  1069 	/* WORD 5 */
  4  1070 
  4  1071 	  2 pad			fixed bin (18) unsigned unaligned,
  4  1072 	  2 loop_ref_count		fixed bin (17) unaligned,
  4  1073 
  4  1074 	/* WORD 6 */
  4  1075 
  4  1076 	  2 location		fixed bin (24) aligned,
  4  1077 
  4  1078 	/* WORD 7*/
  4  1079 
  4  1080 	  2 ref_count		fixed bin (17) unaligned,	/* must overlay array_ref.ref_count */
  4  1081 	  2 output_by		fixed bin (18) unsigned unal,		/* must overlay array_ref.output_by */
  4  1082 
  4  1083 	/* WORD 8 */
  4  1084 
  4  1085 	  2 size			fixed bin (24) aligned,		/* size in words */
  4  1086 
  4  1087 	/* WORD 9 */
  4  1088 
  4  1089 	  2 start_input_to		fixed bin (18) unsigned unal,		/* must overlay array_ref.start_input_to */
  4  1090 	  2 end_input_to		fixed bin (18) unsigned unal,		/* must overlay array_ref.end_input_to */
  4  1091 
  4  1092 	/* WORD 10 */
  4  1093 
  4  1094 	  2 ref_count_copy		fixed bin (17) unaligned,	/* must overlay array_ref.ref_count_copy */
  4  1095 	  2 ms_ref_count		fixed bin (17) unaligned,	/* counts occurances in saved machine states */
  4  1096 
  4  1097 	/* WORD 11 */
  4  1098 
  4  1099 	  2 length		fixed bin (24) aligned;	/* length in characters */
  4  1100 
  4  1101 /* END   fort_nodes.incl.pl1 */
      283 
      284 
  5     1 /* BEGIN fort_system_constants.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(86-07-14,BWong), approve(86-07-14,MCR7382), audit(86-07-17,Ginter),
  5     7*     install(86-07-28,MR12.0-1105):
  5     8*     Fix fortran bug 428.
  5     9*                                                   END HISTORY COMMENTS */
  5    10 
  5    11 
  5    12 /* Created:	June 1976, David Levin  */
  5    13 
  5    14 /* Modified:
  5    15*	15 Dec 85, RW - 428: Changed max_char_length from 256 to 512.
  5    16*	22 Jun 84, MM - Install typeless functions support.
  5    17*	17 Jun 83, HH - 383: Added 'process_param_list_op'.
  5    18*	12 Jan 83, HH - Added 'form_VLA_packed_ptr_op'.
  5    19*	05 Oct 82, HH - Added 'units_per_word'.
  5    20*	27 Sep 82, HH - Added 'max_fixed_bin_18', 'max_fixed_bin_24' and 'sys_info$max_seg_size'.
  5    21*		Removed 'max_stored_value' and 'min_stored_value'.
  5    22*	24 October 1981, ME Presser - added inquire_op.
  5    23*	20 October 1981, C R Davis - add (read write)_internal_file_op.
  5    24*   	11 May 1981, Marshall Presser - added op-codes for .EQV. and .NEQV.
  5    25*	28 April 1981, Marshall Presser - added default_main_entry_point_name
  5    26*	11 March 1981, Marshall Presser - add min_stored_value
  5    27*	8 December 1980, C R Davis - add block_if_op, else_if_op, else_op.
  5    28*	15 January 1980, C R Davis - add bits_per_char.
  5    29*	21 December 1979, Richard A. Barnes - add unrecoverable_errror and
  5    30*		max_error_level.
  5    31*	3 November 1979, Richard Barnes - add pointer_node.
  5    32*	17 September 1979, Richard Barnes - add load_preg_op & load_xreg_op
  5    33*	13 September 1979, Paul Smee - add colon and concat token types,
  5    34*		change value of EOS_token, remove default_char_size.
  5    35*	31 August 1979, Charlie Davis - change offset units to
  5    36*		be consistent with those in runtime symbols.
  5    37*	13 August 1979, Richard Barnes - add cat_op & substr_op
  5    38*	19 July 1979, Richard Barnes - char mode
  5    39*	10 October 1978, Paul Smee - double max_stored_value and bias.
  5    40*	15 June 1978, Paul Smee - add max_num_of_rands
  5    41*	16 November 1977, David Levin - add machine_state_node
  5    42*	12 September 1977, Richard Barnes - new ops for loop optimizer
  5    43*	30 August 1977, David Levin - change bias from 65536 to 131072.
  5    44*	5 July 1977, David Levin - add open_op, close_op, and iostat_op.
  5    45*	28 April 1977, David Levin - add xmit_vector_op in operator list
  5    46*	22 April 1977, David Levin - add max_prec_single, last_assigned_mode
  5    47*	24 February 1977, Gabriel Chang for the optimizer.
  5    48*	23 February 1977, David Levin to change name of count operand.
  5    49*	28 October 1976, David Levin and Gabriel Chang to add 2 new ops and
  5    50*		1 new node type.
  5    51*	2 September 1976, David Levin - add 8 new ops and change name of
  5    52*		data_op.
  5    53**/
  5    54 	/* SYSTEM CONSTANTS */
  5    55 
  5    56 dcl	bias		init(262144) fixed bin(19) int static options(constant);
  5    57 dcl	gap_value		init(0) fixed bin int static options(constant);
  5    58 dcl       max_fixed_bin_18    init(111111111111111111b) fixed bin (18) static options (constant);
  5    59 dcl       max_fixed_bin_24    init(111111111111111111111111b) fixed bin (24) static options (constant);
  5    60 dcl	max_num_of_rands	init(127) fixed bin int static options(constant);
  5    61 dcl       sys_info$max_seg_size
  5    62                               fixed bin (18) ext;
  5    63 
  5    64 dcl (	unrecoverable_error	init(3),
  5    65 	max_error_level	init(4))
  5    66 	fixed bin int static options(constant);
  5    67 
  5    68 dcl	(main_program	init(0),
  5    69 	 block_data	init(1),
  5    70 	 subroutine	init(2),
  5    71 	 function		init(3),
  5    72 	 chars_per_word	init(4),
  5    73 	 chars_per_dw	init(8),
  5    74 	 bits_per_char	init(9),
  5    75 	 first_auto_loc	init(64),
  5    76 	 max_prec_single	init(8)) fixed bin(9) int static options(constant);
  5    77 dcl	 max_char_length	init(512) fixed bin(10) int static options(constant);	
  5    78 
  5    79 dcl	blank_common_name	init("blnk*com") char(8) aligned int static options(constant);
  5    80 declare	default_main_entry_point_name
  5    81 			char (5) int static options (constant) initial ("main_");
  5    82 declare	unnamed_block_data_subprg_name
  5    83 			char (29) int static options (constant) initial ("unnamed block data subprogram");
  5    84 
  5    85 	/*  NODE TYPES	*/
  5    86 
  5    87 dcl	(fill_node	init(0),
  5    88 	 source_node	init(1),
  5    89 	 symbol_node	init(2),
  5    90 	 dimension_node	init(3),
  5    91 	 temporary_node	init(4),
  5    92 	 constant_node	init(5),
  5    93 	 label_node	init(6),
  5    94 	 header_node	init(7),
  5    95 	 char_constant_node	init(8),
  5    96 	 array_ref_node	init(9),
  5    97 	 proc_frame_node	init(10),
  5    98 	 library_node	init(11),
  5    99 	 subprogram_node	init(12),
  5   100 	 arg_desc_node	init(13),
  5   101 	 pointer_node	init(14),
  5   102 	 machine_state_node init(15)) fixed bin(4) aligned internal static options(constant);
  5   103 
  5   104 	/*  DATA TYPES	*/
  5   105 
  5   106 dcl	(int_mode  	init(1),
  5   107 	 real_mode 	init(2),
  5   108 	 dp_mode   	init(3),
  5   109 	 cmpx_mode 	init(4),
  5   110 	 logical_mode	init(5),
  5   111 	 char_mode 	init(6),
  5   112 	 typeless_mode	init(7),
  5   113 	 last_assigned_mode init(7)) fixed bin(4) aligned internal static options(constant);
  5   114 
  5   115 dcl	data_type_size(7)	init(1,1,2,2,1,0,1) fixed bin int static options(constant);
  5   116 
  5   117 
  5   118 	/*  OPERAND TYPES	*/
  5   119 
  5   120 dcl	(variable_type	init(1),
  5   121 	 constant_type	init(2),
  5   122 	 array_ref_type	init(3),
  5   123 	 temp_type	init(4),
  5   124 	 count_type	init(5),
  5   125 	 rel_constant	init(6),
  5   126 	 bif		init(7),
  5   127 	 statement_function	init(8),
  5   128 	 external		init(9),
  5   129 	 entry_type	init(10),
  5   130 	 dummy		init(11),
  5   131 	 error		init(12)) fixed bin(4) aligned internal static options(constant);
  5   132 
  5   133 
  5   134 	/* OFFSET UNITS */
  5   135 
  5   136 dcl
  5   137 	(word_units	init (0),
  5   138 	 bit_units	init (1),
  5   139 	 char_units	init (2),
  5   140 	 halfword_units	init (3)) fixed bin (3) aligned internal static options(constant);
  5   141 
  5   142 dcl        units_per_word     (0:3) init (1, 36, 4, 2) fixed bin (6) static options (constant);
  5   143 
  5   144 
  5   145 	/* TOKEN MASKS */
  5   146 
  5   147 dcl
  5   148 	(is_operand		initial("101000000"b),
  5   149 	 is_operator		initial("010000000"b),
  5   150 	 is_constant		initial("001000000"b),
  5   151 	 is_arith_constant		initial("000100000"b)) bit(9) aligned internal static options(constant);
  5   152 
  5   153 
  5   154 	/* TOKEN TYPES */
  5   155 
  5   156 dcl	(no_token		initial("000000000"b),
  5   157 	 ident		initial("100000000"b),
  5   158 	 plus		initial("010000001"b),
  5   159 	 minus		initial("010000010"b),
  5   160 	 asterisk		initial("010000011"b),
  5   161 	 slash		initial("010000100"b),
  5   162 	 expon		initial("010000101"b),
  5   163 	 not		initial("010000110"b),
  5   164 	 and		initial("010000111"b),
  5   165 	 or		initial("010001000"b),
  5   166 	 eq		initial("010001001"b),
  5   167 	 ne		initial("010001010"b),
  5   168 	 lt		initial("010001011"b),
  5   169 	 gt		initial("010001100"b),
  5   170 	 le		initial("010001101"b),
  5   171 	 ge		initial("010001110"b),
  5   172 	 assign		initial("010001111"b),
  5   173 	 comma		initial("010010000"b),
  5   174 	 left_parn	initial("010010001"b),
  5   175 	 right_parn	initial("010010010"b),
  5   176 	 apostrophe	initial("010010011"b),
  5   177 	 colon		initial("010010100"b),
  5   178 	 concat		initial("010010101"b),
  5   179 	 substr_left_parn	initial("010010110"b),
  5   180 	 eqv		initial("010010111"b),
  5   181 	 neqv		initial("010011000"b),
  5   182 	 EOS_token	initial("010011111"b),
  5   183 	 char_string	initial("001000001"b),
  5   184 	 logical_const	initial("001000010"b),
  5   185 	 false		initial("001000010"b),	/* Must be identical to true except low order bit off. */
  5   186 	 true		initial("001000011"b),	/* Must be identical to false except low order bit on. */
  5   187 	 label_const	initial("001000100"b),
  5   188 	 octal_const	initial("001000101"b),
  5   189 	 dec_int		initial("001100110"b),
  5   190 	 real_const	initial("001100111"b),
  5   191 	 double_const	initial("001101000"b),
  5   192 	 complex_const	initial("001101001"b)) bit(9) aligned internal static options(constant);
  5   193 
  5   194 
  5   195 	/* OPERATOR NAMES */
  5   196 
  5   197 declare
  5   198 	(assign_op		initial(1),
  5   199 	 add_op			initial(2),
  5   200 	 sub_op			initial(3),
  5   201 	 mult_op			initial(4),
  5   202 	 div_op			initial(5),
  5   203 	 exponentiation_op		initial(6),
  5   204 	 negate_op		initial(7),
  5   205 	 less_op			initial(8),
  5   206 	 less_or_equal_op		initial(9),
  5   207 	 equal_op			initial(10),
  5   208 	 not_equal_op		initial(11),
  5   209 	 greater_or_equal_op	initial(12),
  5   210 	 greater_op		initial(13),
  5   211 	 or_op			initial(14),
  5   212 	 and_op			initial(15),
  5   213 	 not_op			initial(16),
  5   214 	 jump_op			initial(17),
  5   215 	 jump_logical_op		initial(18),
  5   216 	 jump_arithmetic_op		initial(19),
  5   217 	 jump_computed_op		initial(20),
  5   218 	 jump_assigned_op		initial(21),
  5   219 	 assign_label_op		initial(22),
  5   220 	 read_op			initial(23),
  5   221 	 write_op			initial(24),
  5   222 	 format_op		initial(25),
  5   223 	 end_label_op		initial(26),
  5   224 	 error_label_op		initial(27),
  5   225 	 xmit_scalar_op		initial(28),
  5   226 	 xmit_array_op		initial(29),
  5   227 	 xmit_vector_op		initial(30),
  5   228 	 endfile_op		initial(31),
  5   229 	 rewind_op		initial(32),
  5   230 	 backspace_op		initial(33),
  5   231 	 margin_op		initial(34),
  5   232 	 openfile_op		initial(35),
  5   233 	 closefile_op		initial(36),
  5   234 	 record_number_op		initial(37),
  5   235 	 string_op		initial(38),
  5   236 	 string_length_op		initial(39),
  5   237 	 terminate_op		initial(40),
  5   238 	 return_op		initial(41),
  5   239 	 pause_op			initial(42),
  5   240 	 stop_op			initial(43),
  5   241 	 item_op			initial(44),
  5   242 	 exit_op			initial(45),
  5   243 	 eol_op			initial(46),
  5   244 	 do_op			initial(47),
  5   245 	 builtin_op		initial(48),
  5   246 	 sf_op			initial(49),
  5   247 	 sf_def_op		initial(50),
  5   248 	 subscript_op		initial(51),
  5   249 	 func_ref_op		initial(52),
  5   250 	 block_data_op		initial(53),
  5   251 	 increment_polish_op	initial(54),
  5   252 	 main_op			initial(55),
  5   253 	 func_op			initial(56),
  5   254 	 subr_op			initial(57),
  5   255 	 stat_op			initial(58),
  5   256 	 label_op			initial(59),
  5   257 	 call_op			initial(60),
  5   258 	 chain_op			initial(61),
  5   259 	 endunit_op		initial(62),
  5   260 	 non_executable		initial(63),
  5   261 	 no_op			initial(64),
  5   262 	 form_VLA_packed_ptr_op	initial(65),
  5   263 	 opt_subscript_op		initial(66),
  5   264 	 left_shift_op		initial(67),
  5   265 	 right_shift_op		initial(68),
  5   266 	 store_zero_op		initial(69),
  5   267 	 storage_add_op		initial(70),
  5   268 	 storage_sub_op		initial(71),
  5   269 	 neg_storage_add_op		initial(72),
  5   270 	 storage_add_one_op		initial(73),
  5   271 	 namelist_op		initial(74),
  5   272 	 open_op			initial(75),
  5   273 	 close_op			initial(76),
  5   274 	 iostat_op		initial(77),
  5   275 	 convert_to_int_op		initial(78),
  5   276 	 convert_to_real_op		initial(79),
  5   277 	 convert_to_dp_op		initial(80),
  5   278 	 convert_to_cmpx_op		initial(81),
  5   279 	 read_scalar_op		initial(82),
  5   280 	 read_array_op		initial(83),
  5   281 	 read_vector_op		initial(84),
  5   282 	 write_scalar_op		initial(85),
  5   283 	 write_array_op		initial(86),
  5   284 	 write_vector_op		initial(87),
  5   285 	 jump_true_op		initial(88),
  5   286 	 jump_false_op		initial(89),
  5   287 	 sub_index_op		initial(90),
  5   288 	 loop_end_op		initial(91),
  5   289 	 read_namelist_op		initial(92),
  5   290 	 write_namelist_op		initial(93),
  5   291 	 decode_string_op		initial(94),
  5   292 	 encode_string_op		initial(95),
  5   293 	 cat_op			initial(96),
  5   294 	 substr_op		initial(97),
  5   295 	 load_xreg_op		initial(98),
  5   296 	 load_preg_op		initial(99),
  5   297 	 block_if_op		initial(100),
  5   298 	 else_if_op		initial(101),
  5   299 	 else_op			initial(102),
  5   300 	 equiv_op			initial (103),
  5   301 	 not_equiv_op		initial (104),
  5   302 	 read_internal_file_op	initial (105),
  5   303 	 write_internal_file_op	initial (106),
  5   304 	 inquire_op		initial (107),
  5   305 	 process_param_list_op	initial (108),
  5   306 	 lhs_fld_op		initial (109),
  5   307 	 last_assigned_op		initial (109))  fixed bin(18) internal static options(constant);
  5   308 
  5   309 /* END   fort_system_constants.incl.pl1 */
      285 
      286 
      287 dcl	1 shared_globals	aligned based (shared_struc_ptr),
  6     1 
  6     2 /* BEGIN fort_shared_vars.incl.pl1 */
  6     3 
  6     4 
  6     5 
  6     6 /****^  HISTORY COMMENTS:
  6     7*  1) change(86-07-14,BWong), approve(86-07-14,MCR7286), audit(86-07-17,Ginter),
  6     8*     install(86-07-28,MR12.0-1105):
  6     9*     Fix fortran bug 463.
  6    10*                                                   END HISTORY COMMENTS */
  6    11 
  6    12 
  6    13 /* Created:	June 1976, David Levin
  6    14*
  6    15*	Modified:	30 Aug 76, David Levin - to add global variables for listing segment.
  6    16*	Modified:	22 Nov 76, Richard Barnes - to add profile_size
  6    17*	Modified: 24 Feb 77, Gabriel Chang - for the optimizer
  6    18*	Modified:	06 Oct 77, Richard Barnes - for the loop optimizer
  6    19*	Modified: 16 Nov 77, David Levin - add next_free_(temp array_ref).
  6    20*	Modified: 09 Oct 78, Paul Smee - for larger common and arrays.
  6    21*	Modified: 03 Apr 79, Paul Smee - add list of include file data.
  6    22*	Modified: 17 May 79, Paul Smee - add cur_statement_list.
  6    23*	Modified: 28 Jun 79, Paul Smee - add compile-time math entry arrays.
  6    24*	Modified: 13 Sep 79, Paul Smee - add default_char_size.
  6    25*	Modified:	18 Dec 79, Richard Barnes - add free and freei
  6    26*	Modified: 03 Mar 80, C R Davis - add must_save_stack_extent.
  6    27*	Modified: 15 Mar 82, T G Oke - add source (line_number, file_number).
  6    28*	Modified: 20 Sept 82, T G Oke - add VLA_is_256K flag
  6    29*	Modified: 22 Sept 82, T G Oke - add area creation info to pass to
  6    30*	     listing generator.
  6    31*	Modified: 17 May 83, M Mabey - add declared_options.
  6    32*	Modified: 02 Aug 85, B Wong - 463: changed 'must_save_stack_extent'
  6    33*	     to 'pad' since the variable is no longer used.
  6    34**/
  6    35 
  6    36 	  2 polish_base		ptr,
  6    37 	  2 operand_base		ptr,
  6    38 	  2 object_base		ptr,
  6    39 	  2 quadruple_base		ptr,
  6    40 	  2 opt_base		ptr,
  6    41 	  2 relocation_base		ptr,
  6    42 
  6    43 	  2 cref_base		ptr,		/* base of cross reference segment */
  6    44 	  2 source_line_base	ptr,		/* base of source line offset segment */
  6    45 	  2 listing_base		ptr,		/* base of listing info segment */
  6    46 	  2 cur_listing		ptr,		/* points to listing info for the active subprogram */
  6    47 
  6    48 	  2 free(2:4)		ptr,		/* free chains for optimizer */
  6    49 	  2 freei			ptr,		/* .. */
  6    50 
  6    51 	  2 polish_max_len		fixed bin (19),
  6    52 	  2 operand_max_len		fixed bin (19),
  6    53 	  2 object_max_len		fixed bin (19),
  6    54 	  2 quad_max_len		fixed bin (19),
  6    55 	  2 opt_max_len		fixed bin (19),
  6    56 
  6    57 	  2 next_free_polish	fixed bin (18),
  6    58 	  2 next_free_operand	fixed bin (18),
  6    59 	  2 next_free_object	fixed bin (18),
  6    60 	  2 next_free_listing	fixed bin (18),
  6    61 	  2 next_free_quad		fixed bin (18),
  6    62 	  2 next_free_array_ref	fixed bin (18),	/* Chain for freed array_ref nodes. */
  6    63 	  2 next_free_temp		fixed bin (18),	/* Chain for freed temporary nodes. */
  6    64 	  2 next_free_opt		fixed bin (18),
  6    65 
  6    66 	  2 first_segment		fixed bin,
  6    67 	  2 number_of_source_segments	fixed bin (8),
  6    68 	  2 number_of_lines		fixed bin,
  6    69 	  2 number_of_crefs		fixed bin,
  6    70 	  2 profile_size		fixed bin,
  6    71 
  6    72 	  2 main_entry_point_name	char (32) varying,
  6    73 
  6    74 	  2 cur_statement		fixed bin (18),
  6    75 	  2 cur_statement_list        fixed bin (17),
  6    76 	  2 cur_subprogram		fixed bin (18),
  6    77 	  2 first_subprogram	fixed bin (18),
  6    78 	  2 last_subprogram		fixed bin (18),
  6    79 	  2 unnamed_block_data_subprogram
  6    80 				fixed bin (18),
  6    81 	  2 first_entry_name	fixed bin (18),
  6    82 	  2 last_entry_name		fixed bin (18),
  6    83 
  6    84 	  2 constant_info (4)	aligned structure,
  6    85 	    3 constant_count	fixed bin (17),
  6    86 	    3 first_constant	fixed bin (18),
  6    87 	    3 last_constant		fixed bin (18),
  6    88 
  6    89 	  2 options		aligned,
  6    90 	    3 user_options		aligned like fortran_options,
  6    91 	    3 system_options	aligned,
  6    92 	      4 is_fast		bit (1) unaligned,
  6    93 	      4 namelist_used	bit (1) unaligned,
  6    94 	      4 compile_only	bit (1) unaligned,
  6    95 	      4 VLA_is_256K		bit (1) unaligned,	/* FLAG 255/256K code */
  6    96 	      4 pad		bit (32) unaligned,
  6    97 
  6    98 	  2 incl_data		aligned,
  6    99 	    3 incl_count		fixed bin,
  6   100 	    3 file_list (0:255),
  6   101 	      4 source_node_offset	fixed bin (18),
  6   102 	      4 incl_len		fixed bin (21),
  6   103 	      4 incl_ptr		unaligned ptr,
  6   104 
  6   105 	  2 create_constant		entry (fixed bin (4), bit (72) aligned) returns (fixed bin (18))
  6   106 				variable,
  6   107 	  2 create_char_constant	entry (char (*)) returns (fixed bin (18))
  6   108 				variable,
  6   109 	  2 print_message		entry options (variable)
  6   110 				variable,
  6   111 	  2 get_next_temp_segment	entry (ptr, fixed bin (18)) returns (ptr)
  6   112 				variable,
  6   113 	  2 negate_round (6)	entry (fixed bin (35), bit (72), bit (72), fixed bin (35))
  6   114 				returns (bit (72)) variable,
  6   115 	  2 negate_trunc (6)	entry (fixed bin (35), bit (72), bit (72), fixed bin (35))
  6   116 				returns (bit (72)) variable,
  6   117 	  2 binop_round (6,6)	entry (fixed bin (35), bit (72), bit (72), fixed bin (35))
  6   118 				returns (bit (72)) variable,
  6   119 	  2 binop_trunc (6,6)	entry (fixed bin (35), bit (72), bit (72), fixed bin (35))
  6   120 				returns (bit (72)) variable,
  6   121 	  2 comp_parm (6,6)		entry (fixed bin (35), bit (72), bit (72), fixed bin (35))
  6   122 				returns (bit (72)) variable,
  6   123 	  2 conv_round (6,6)		entry (bit (72), fixed bin (35))
  6   124 				returns (bit (72)) variable,
  6   125 	  2 conv_trunc (6,6)	entry (bit (72), fixed bin (35))
  6   126 				returns (bit (72)) variable,
  6   127 	  2 pad			bit (1) aligned,
  6   128 
  6   129 /* The following are used by "print_message - decode_source_id" if use_source_info set. */
  6   130 
  6   131 	  2 use_source_info		bit (1) aligned,
  6   132 	  2 source_file_number	fixed bin (35),
  6   133 	  2 source_line_number	fixed bin (35),
  6   134 	  2 Area_create_first	fixed bin (18),	/* start of text to do creation */
  6   135             2 Area_create_last	fixed bin (18),	/* Last item */
  6   136             2 Area_init_first		fixed bin (18),	/* start of text to init areas */
  6   137             2 Area_init_last		fixed bin (18),	/* Last item */
  6   138 	  2 declared_options	aligned like fortran_declared;
  6   139 
  6   140 dcl	num_of_word_constants	fixed bin (17) defined (constant_info (1).constant_count);
  6   141 dcl	first_word_constant		fixed bin (18) defined (constant_info (1).first_constant);
  6   142 dcl	last_word_constant		fixed bin (18) defined (constant_info (1).last_constant);
  6   143 
  6   144 dcl	num_of_dw_constants		fixed bin (17) defined (constant_info (2).constant_count);
  6   145 dcl	first_dw_constant		fixed bin (18) defined (constant_info (2).first_constant);
  6   146 dcl	last_dw_constant		fixed bin (18) defined (constant_info (2).last_constant);
  6   147 
  6   148 dcl	num_of_char_constants	fixed bin (17) defined (constant_info (3).constant_count);
  6   149 dcl	first_char_constant		fixed bin (18) defined (constant_info (3).first_constant);
  6   150 dcl	last_char_constant		fixed bin (18) defined (constant_info (3).last_constant);
  6   151 
  6   152 dcl	num_of_block_constants	fixed bin (17) defined (constant_info (4).constant_count);
  6   153 dcl	first_block_constant	fixed bin (18) defined (constant_info (4).first_constant);
  6   154 dcl	last_block_constant		fixed bin (18) defined (constant_info (4).last_constant);
  6   155 
  6   156 /* END   fort_shared_vars.incl.pl1 */
      288 
      289 
  7     1 /* BEGIN INCLUDE FILE fort_options.incl.pl1  */
  7     2 
  7     3 /****^  ***********************************************************
  7     4*        *                                                         *
  7     5*        * Copyright, (C) Honeywell Information Systems Inc., 1987 *
  7     6*        *                                                         *
  7     7*        *********************************************************** */
  7     8 
  7     9 /****^  HISTORY COMMENTS:
  7    10*  1) change(86-07-14,BWong), approve(86-07-14,MCR7382), audit(86-07-17,Ginter),
  7    11*     install(86-07-28,MR12.0-1105):
  7    12*     Fix fortran bug 473.
  7    13*  2) change(87-06-23,RWaters), approve(87-06-23,MCR7703), audit(87-07-10,Huen),
  7    14*     install(87-08-06,MR12.1-1069):
  7    15*     Implemented SCP 6315: fortran error-handling argument.
  7    16*                                                   END HISTORY COMMENTS */
  7    17 
  7    18 
  7    19 /*
  7    20*          Modified: 12 May 87 by RWaters added debug_io
  7    21*	Modified: 19 February 1986 by B. Wong & A. Ginter - 473.a: Correct
  7    22*		comments and size of pad field in fort_declared
  7    23*		and pad out dfast and fast bit masks to two words.
  7    24*	Modified: 09 October 1985 by B. Wong - 473: add VLA_auto, VLA_static,
  7    25*		VLA_parm, VLC, LA_auto, and LA_static.  Remove VLA and LA.
  7    26*	Modified: 28 March 1984 by M. Mabey - Install HFP support.
  7    27*	Modified: 21 September 1983 by M. Mabey - correct size of pad field in  fortran_declared.
  7    28*	Modified: 16 May 1983 by M. Mabey - add fortran_declared
  7    29*	Modified: 18 December 1982 by T. Oke - Add 'long_profile'.
  7    30*	Modified: 22 September 1982 by T. Oke - add VLA and LA
  7    31*	Modified:  3 May  1982 by T. Oke - add check_multiply
  7    32*	Modified: 06/24/81 by S. Herbst - add do_rounding & auto_zero to fast_mask and dfast_mask
  7    33*	Modified: 26 February 1980 by C R Davis - add fast_mask,  fix dfast_mask.
  7    34*	Modified: 31 January 1980 by C R Davis - add stringrange.
  7    35*	Modified: 13 September 1979 by Paul E. Smee--add ansi_77.
  7    36*	Modified: 05 December 1978 by Paul E. Smee--add do_rounding, auto_zero.
  7    37*	Modified:	25 January 1978 by Richard A. Barnes for the loop optimizer
  7    38**/
  7    39 
  7    40 declare
  7    41 
  7    42     1 fortran_options aligned based,
  7    43       2 use_library bit (1) unaligned,		/* (1) ON if library statements will be parsed */
  7    44       2 optimize bit (1) unaligned,		/* (2) ON if optimized code is to be produced */
  7    45       2 time bit (1) unaligned,		/* (3) ON for compile timing */
  7    46       2 source_format unaligned,
  7    47         3 has_line_numbers bit (1) unaligned,	/* (4) ON if each line begins with a line number */
  7    48         3 fold bit (1) unaligned,		/* (5) ON if variable names are to be folded to lowercase */
  7    49         3 card bit (1) unaligned,		/* (6) ON for card format */
  7    50         3 convert bit (1) unaligned,		/* (7) ON for card format to be converted */
  7    51       2 listing unaligned,
  7    52         3 source bit (1) unaligned,		/* (8) ON for listing of numbered source */
  7    53         3 symbol bit (1) unaligned,		/* (9) ON for listing with symbol map */
  7    54         3 map bit (1) unaligned,		/* (10) ON for listing with statement map */
  7    55         3 list bit (1) unaligned,		/* (11) ON for listing with assembler instructions */
  7    56       2 error_messages unaligned,
  7    57         3 brief bit (1) unaligned,		/* (12) ON for brief error messages */
  7    58         3 severity fixed bin (3),		/* (13-16) suppresses messages below this severity */
  7    59       2 debugging unaligned,
  7    60         3 subscriptrange bit (1) unaligned,	/* (17) ON for subscript range checking */
  7    61         3 stringrange bit (1) unaligned,	/* (18) ON for string range checking */
  7    62         3 brief_table bit (1) unaligned,	/* (19) ON for statement table */
  7    63         3 table bit (1) unaligned,		/* (20) ON for statement and symbol table */
  7    64         3 profile bit (1) unaligned,		/* (21) ON to generate code to meter statements */
  7    65         3 check bit (1) unaligned,		/* (22) ON for syntactic and semantic checking only */
  7    66       2 system_debugging unaligned,
  7    67         3 stop_after_cg bit (1) unaligned,	/* (23) ON if debug stop after code generator */
  7    68         3 stop_after_parse bit (1) unaligned,	/* (24) ON if debug stop after parse */
  7    69       2 relocatable bit (1) unaligned,		/* (25) ON if relocatable object segment generated */
  7    70       2 optimizing unaligned,
  7    71         3 time_optimizer bit (1) unaligned,	/* (26) ON if timings for optimizer requested */
  7    72 					/* (27) ON if optimizer can loosen safety constraints */
  7    73         3 ignore_articulation_blocks bit (1) unaligned,
  7    74         3 consolidate bit(1) unaligned,		/* (28) ON if optimizer should run consolidation phase */
  7    75       2 do_rounding bit(1) unaligned,		/* (29) ON if floating point round should be used */
  7    76       2 auto_zero bit(1) unaligned,		/* (30) ON if auto storage should be zeroed when allocated */
  7    77       2 ansi_77 bit (1) unaligned,		/* (31) ON if ansi77 rules are to be followed */
  7    78       2 check_multiply bit (1) unaligned,	/* (32) ON if check integer multiply extent */
  7    79       2 VLA_auto bit (1) unaligned,		/* (33) ON if auto VLA's being done */
  7    80       2 VLA_parm bit (1) unaligned,		/* (34) ON if parm VLA's being done */
  7    81       2 VLA_static bit (1) unaligned,		/* (35) ON if static VLA's being done */
  7    82       2 VLC bit (1) unaligned,		/* (36) ON if VLC's being done */
  7    83       2 LA_auto bit (1) unaligned,		/* (1)  ON if auto LA's being done */
  7    84       2 LA_static bit (1) unaligned,		/* (2)  ON if static LA's being done */
  7    85       2 long_profile bit (1) unaligned,		/* (3)  ON to generate long_profile */
  7    86       2 static_storage bit (1) unaligned,	/* (4)  ON if static storage */
  7    87       2 hfp bit (1) unaligned,		/* (5)  ON if using hex floating point math */
  7    88       2 debug_io bit (1) unaligned,               /* (6) */
  7    89       2 pad bit(30) unaligned;		/* (7-36) Pad bits */
  7    90 
  7    91 declare
  7    92 
  7    93    1  fortran_declared aligned based,
  7    94       2  ansi66 bit(1) unaligned,		/* (1) First word */
  7    95       2  ansi77 bit(1) unaligned,		/* (2) */
  7    96       2  auto bit(1) unaligned,		/* (3) */
  7    97       2  auto_zero bit(1) unaligned,		/* (4) */
  7    98       2  brief bit(1) unaligned,		/* (5) */
  7    99       2  binary_floating_point bit(1) unaligned,	/* (6) */
  7   100       2  brief_table bit(1) unaligned,		/* (7) */
  7   101       2  card bit(1) unaligned,		/* (8) */
  7   102       2  check bit(1) unaligned,		/* (9) */
  7   103       2  check_multiply bit(1) unaligned,	/* (10) */
  7   104       2  consolidate bit(1) unaligned,		/* (11) */
  7   105       2  debug bit(1) unaligned,		/* (12) */
  7   106       2  debug_cg bit(1) unaligned,		/* (13) */
  7   107       2  debug_io bit(1) unaligned,		/* (14) */
  7   108       2  default_full bit(1) unaligned,		/* (15) */
  7   109       2  default_safe bit(1) unaligned,		/* (16) */
  7   110       2  fold bit(1) unaligned,		/* (17) */
  7   111       2  free bit(1) unaligned,		/* (18) */
  7   112       2  full_optimize bit(1) unaligned,	/* (19) */
  7   113       2  hexadecimal_floating_point bit(1) unaligned,
  7   114 					/* (20) */
  7   115       2  la_auto bit(1) unaligned,		/* (21) */
  7   116       2  la_static bit(1) unaligned,		/* (22) */
  7   117       2  large_array bit(1) unaligned,		/* (23) */
  7   118       2  line_numbers bit(1) unaligned,		/* (24) */
  7   119       2  list bit(1) unaligned,		/* (25) */
  7   120       2  long bit(1) unaligned,		/* (26) */
  7   121       2  long_profile bit(1) unaligned,		/* (27) */
  7   122       2  map bit(1) unaligned,		/* (28) */
  7   123       2  no_auto_zero bit(1) unaligned,		/* (29) */
  7   124       2  no_check bit(1) unaligned,		/* (30) */
  7   125       2  no_fold bit(1) unaligned,		/* (31) */
  7   126       2  no_large_array bit(1) unaligned,	/* (32) */
  7   127       2  no_line_numbers bit(1) unaligned,	/* (33) */
  7   128       2  no_map bit(1) unaligned,		/* (34) */
  7   129       2  no_optimize bit(1) unaligned,		/* (35) */
  7   130       2  no_check_multiply bit(1) unaligned,	/* (36) */
  7   131       2  no_debug_io bit(1) unal,                 /* (1) Second Word */
  7   132       2  no_stringrange bit(1) unaligned,	/* (2) */
  7   133       2  no_subscriptrange bit(1) unaligned,	/* (3) */
  7   134       2  no_table bit(1) unaligned,		/* (4) */
  7   135       2  no_very_large_array bit(1) unaligned,	/* (5) */
  7   136       2  no_vla_parm bit(1) unaligned,		/* (6) */
  7   137       2  no_version bit(1) unaligned,		/* (7) */
  7   138       2  non_relocatable bit(1) unaligned,	/* (8) */
  7   139       2  optimize bit(1) unaligned,		/* (9) */
  7   140       2  profile bit(1) unaligned,		/* (10) */
  7   141       2  relocatable bit(1) unaligned,		/* (11) */
  7   142       2  round bit(1) unaligned,		/* (12) */
  7   143       2  safe_optimize bit(1) unaligned,	/* (13) */
  7   144       2  severity fixed bin(3) unaligned,	/* (14-16) */
  7   145       2  static bit(1) unaligned,		/* (17) */
  7   146       2  stringrange bit(1) unaligned,		/* (18) */
  7   147       2  subscriptrange bit(1) unaligned,	/* (19) */
  7   148       2  table bit(1) unaligned,		/* (20) */
  7   149       2  time bit(1) unaligned,		/* (21) */
  7   150       2  time_ot bit(1) unaligned,		/* (22) */
  7   151       2  top_down bit(1) unaligned,		/* (23) */
  7   152       2  truncate bit(1) unaligned,		/* (24) */
  7   153       2  version bit(1) unaligned,		/* (25) */
  7   154       2  very_large_array bit(1) unaligned,	/* (26) */
  7   155       2  very_large_common bit(1) unaligned,	/* (27) */
  7   156       2  vla_auto bit(1) unaligned,		/* (28) */
  7   157       2  vla_parm bit(1) unaligned,		/* (29) */
  7   158       2  vla_static bit(1) unaligned,		/* (30) */
  7   159       2  pad bit(6) unaligned;		/* (31-36) */
  7   160 
  7   161 
  7   162 declare					/* Options used by DFAST */
  7   163 
  7   164      dfast_mask bit (72) internal static options (constant) initial ("100110000000000010100000000011"b);
  7   165 	/* use_library, has_line_numbers, fold, subscriptrange, brief_table */
  7   166 
  7   167 
  7   168 declare					/* Options used by FAST */
  7   169 
  7   170      fast_mask bit (72) internal static options (constant) initial ("000100000000000010100000000011"b);
  7   171 	/* has_line_numbers, subscriptrange, brief_table */
  7   172 
  7   173 /* END INCLUDE FILE fort_options.incl.pl1 */
      290 
      291 
  8     1 /* BEGIN fort_opt_nodes.incl.pl1 */
  8     2 
  8     3 /* Created:	22 November 1977 by Richard A. Barnes for the optimizing Fortran compiler */
  8     4 
  8     5 /* Modified:	09 October 1978 by Paul E. Smee for larger common and arrays.
  8     6*   Modified:	2 June 1979 by RAB to speed up intersection of optimizer
  8     7*		machine states by adding operator.coordinate and
  8     8*		flow_unit.is_active_operator
  8     9*   Modified:	28 June 1979 by RAB to speed up compute_busy_on_exit by
  8    10*		adding flow_unit.dim_or_alias_or_not_set.
  8    11*   Modified:	02 July 1979 by RAB to fix 218 by moving loop_end_chain stuff
  8    12*		to flow_unit node from loop node.
  8    13*   Modified:	14 August 1979 by RAB to change flow_unit.dim_or_alias_or_not_set
  8    14*		to flow_unit.always_completely_set.
  8    15*   Modified:	17 September 1979 by RAB in preparation for register optimizer.
  8    16*   Modified:	20 September 1979 by RAB for index_value_analysis of register optimizer.
  8    17*   Modified:	03 November 1979 by RAB for flow_unit.refreshed for register optimizer.
  8    18*   Modified:	30 November 1979 by RAB to add more info to the loop node
  8    19*		for the register optimizer.
  8    20*   Modified:	18 December 1979 by RAB to make remainder of register
  8    21*		optimizer changes.
  8    22*   Modified:	17 December 1980 by CRD to add opt_statement.removable.
  8    23**/
  8    24 
  8    25 	/* CHAIN (2 words) */
  8    26 
  8    27 dcl	1 chain			based aligned,
  8    28 	2 next			pointer unaligned,
  8    29 	2 value			pointer unaligned;
  8    30 
  8    31 	/* EDGE (6 words) */
  8    32 
  8    33 dcl	1 edge			based aligned,
  8    34 	2 from			structure,
  8    35 	  3 value			ptr unal,
  8    36 	  3 next			ptr unal,
  8    37 	  3 back			ptr unal,
  8    38 	2 to			structure,
  8    39 	  3 value			ptr unal,
  8    40 	  3 next			ptr unal,
  8    41 	  3 back 			ptr unal;
  8    42 
  8    43 
  8    44 	/* FLOW_UNIT (22 words) */
  8    45 
  8    46 dcl	1 flow_unit		based aligned,
  8    47 	2 next			ptr unal,
  8    48 	2 back			ptr unal,
  8    49 	2 successors		ptr unal,
  8    50 	2 predecessors		ptr unal,
  8    51 	2 dominator		ptr unal,
  8    52 	2 loop			ptr unal,
  8    53 	2 next_in_loop		ptr unal,
  8    54 	2 loop_end_chain		ptr unal,
  8    55 	2 position		fixed bin(17) aligned,
  8    56 	2 number			fixed bin(17) unal,
  8    57 	2 n_in_loop_end		fixed bin(17) unal,
  8    58 	2 level_number		fixed bin(17) aligned,
  8    59 	2 first_statement		fixed bin (18) unsigned unal,
  8    60 	2 last_statement		fixed bin (18) unsigned unal,
  8    61 	2 insert_statement		fixed bin (18) unsigned unal,
  8    62 	2 insert_operator		fixed bin (18) unsigned unal,
  8    63 	2 info			structure unal,
  8    64 	  3 processed		bit(1),
  8    65 	  3 loop_entry		bit(1),
  8    66 	  3 falls_through		bit(1),
  8    67 	  3 has_label		bit(1),
  8    68 	  3 entry_pt		bit(1),
  8    69 	  3 in_queue		bit(1),
  8    70 	  3 is_back_target		bit(1),
  8    71 	  3 has_side_effects	bit(1),
  8    72 	  3 removed		bit(1),
  8    73 	  3 refreshed		bit(1),
  8    74 	  3 pad			bit(26),
  8    75 	2 used			ptr unal,
  8    76 	2 set			ptr unal,
  8    77 	2 busy_on_entry		ptr unal,
  8    78 	2 set_multiple		ptr unal,
  8    79 	2 busy_on_exit		ptr unal,
  8    80 	2 dominated_by		ptr unal,
  8    81 	2 is_active_operator	ptr unal,
  8    82 	2 always_completely_set	ptr unal;
  8    83 
  8    84 
  8    85 	/* INPUT_TO (3 words) */
  8    86 
  8    87 dcl	1 input_to		based aligned,
  8    88 	2 next			pointer unaligned,
  8    89 	2 operator		pointer unaligned,
  8    90 	2 which			fixed bin aligned;
  8    91 
  8    92 	/* LCHAIN (2 words) */
  8    93 
  8    94 dcl	1 lchain			based aligned,
  8    95 	2 next			pointer unaligned,
  8    96 	2 value			fixed bin(18) aligned;
  8    97 
  8    98 	/* LOOP (33 words) */
  8    99 
  8   100 dcl	1 loop			based aligned,
  8   101 	2 number			fixed bin(18),
  8   102 	2 depth			fixed bin(18),
  8   103 	2 father			pointer unaligned,
  8   104 	2 brother			pointer unaligned,
  8   105 	2 prev_brother		pointer unaligned,
  8   106 	2 son			pointer unaligned,
  8   107 	2 last_son		pointer unaligned,
  8   108 	2 entry_unit		pointer unaligned,
  8   109 	2 members			pointer unaligned,
  8   110 	2 back_target		pointer unaligned,
  8   111 	2 exits			pointer unaligned,
  8   112 	2 first_unit		pointer unaligned,
  8   113 	2 last_unit		pointer unaligned,
  8   114 	2 is_member		pointer unaligned,
  8   115 	2 is_exit			pointer unaligned,
  8   116 	2 articulation_blocks	pointer unaligned,
  8   117 	2 used			pointer unaligned,
  8   118 	2 set			pointer unaligned,
  8   119 	2 busy_on_exit		pointer unaligned,
  8   120 	2 set_multiple		pointer unaligned,
  8   121 	2 ancestors_and_me		pointer unaligned,
  8   122 	2 bits			structure unaligned,
  8   123 	  3 has_side_effects	bit(1),
  8   124 	  3 erases		structure unaligned,
  8   125 	    4 xr(0:7)		bit(1),
  8   126 	    4 pr(6)		bit(1),
  8   127 	  3 avoid_pr(6)		bit(1),
  8   128 	  3 all_xrs_globally_assigned	bit(1),
  8   129 	  3 pad			bit(14),
  8   130 	2 induction_var		pointer unaligned,
  8   131 	2 may_keep_in_xr		pointer unaligned,
  8   132 	2 computed		pointer unaligned,
  8   133 	2 xregs_used		fixed bin(4),
  8   134 	2 pregs_used		fixed bin(4),
  8   135 	2 global_xr_items		pointer unaligned,
  8   136 	2 global_pr_items		pointer unaligned,
  8   137 	2 range_list		pointer unaligned,
  8   138 	2 msp			pointer unaligned,
  8   139 	2 eligible_ind_var_op_var	pointer unaligned,
  8   140 	2 left_shift_chain		pointer unaligned;
  8   141 
  8   142 	/* OPERATOR */
  8   143 
  8   144 dcl	1 operator		based aligned,
  8   145 
  8   146 	/* WORD 1 */
  8   147 
  8   148 	  2 op_code		fixed bin(8) unal,
  8   149 	  2 assigns_constant_to_symbol bit(1) unal,
  8   150 	  2 freed			bit(1) unal,
  8   151 	  2 number		fixed bin(7) unsigned unal,
  8   152 	  2 coordinate		fixed bin(18) unsigned unal,
  8   153 
  8   154 	/* WORD 2 */
  8   155 
  8   156 	  2 next			fixed bin(18) unsigned unal,
  8   157 	  2 back			fixed bin(18) unsigned unal,
  8   158 
  8   159 	/* WORD 3 */
  8   160 
  8   161 	  2 primary		pointer unal,
  8   162 
  8   163 	/* WORD 4 */
  8   164 
  8   165 	  2 output		fixed bin(18) aligned,
  8   166 
  8   167 	/* WORDS 5 - n */
  8   168 
  8   169 	  2 operand(n_operands refer (operator.number))	fixed bin (18) aligned;
  8   170 
  8   171 dcl	n_operands		fixed bin;
  8   172 
  8   173 
  8   174 	/* OPT_STATEMENT */
  8   175 
  8   176 dcl	1 opt_statement		based aligned structure,
  8   177 
  8   178 	/* WORD 1 */
  8   179 
  8   180 	  2 op_code		fixed bin(8) unal,	/* must be stat_op */
  8   181 	  2 number		fixed bin(8) unal,	/* must be 0 */
  8   182 	  2 label 		fixed bin (18) unsigned unal,
  8   183 
  8   184 	/* WORD 2 */
  8   185 
  8   186 	  2 first_operator 		fixed bin (18) unsigned unal,
  8   187 	  2 prev_operator		fixed bin (18) unsigned unal,
  8   188 
  8   189 	/* WORD 3 */
  8   190 
  8   191 	  2 next			bit(18) unal,	/* "0"b = no next statement */
  8   192 	  2 back			bit(18) unal,	/* "0"b = no prev statement */
  8   193 
  8   194 	/* WORD 4 */
  8   195 
  8   196 	  2 source_id		structure unaligned,
  8   197 	    3 file		fixed bin (8) unsigned,	/* 0 = first file */
  8   198 	    3 line		bit(14),
  8   199 	    3 statement		bit(5),	/* 1 = first statement */
  8   200 
  8   201 	  2 length		bit(9) unaligned,
  8   202 
  8   203 	/* WORD 5 */
  8   204 
  8   205 	  2 bits			structure unaligned,
  8   206 	    3 put_in_map		bit(1),
  8   207 	    3 put_in_profile	bit(1),
  8   208 	    3 processed_by_converter	bit(1),
  8   209 	    3 referenced_backwards	bit(1),
  8   210 	    3 referenced_by_assign	bit(1),
  8   211 	    3 has_operator_list	bit(1),
  8   212 	    3 moved		bit(1),
  8   213 	    3 removable		bit(1),
  8   214 	    3 pad			bit(1),
  8   215 
  8   216 	  2 start			fixed bin(26) unaligned,
  8   217 
  8   218 	/* WORD 6 */
  8   219 
  8   220 	  2 location		bit(18) unaligned,	/* (18)"1"b = no code */
  8   221 	  2 machine_state		fixed bin (18) unsigned unaligned,
  8   222 
  8   223 	/* WORD 7 */
  8   224 
  8   225 	  2 flow_unit		pointer unaligned,
  8   226 
  8   227 	/* WORD 8 */
  8   228 
  8   229 	  2 operator_list		pointer unaligned;
  8   230 
  8   231 
  8   232 	/* PRIMARY (4 words) */
  8   233 
  8   234 dcl	1 primary			based aligned,
  8   235 	2 next			pointer unaligned,
  8   236 	2 last			pointer unaligned,
  8   237 	2 data			structure aligned,
  8   238 	  3 expression		pointer unaligned,
  8   239 	  3 flow_unit		pointer unaligned;
  8   240 
  8   241 	/* RANGE (3 words) */
  8   242 
  8   243 dcl	1 range			based aligned,
  8   244 	2 next			pointer unaligned,
  8   245 	2 variable		pointer unaligned,
  8   246 	2 bits			structure unaligned,
  8   247 	  3 range_bits		structure unaligned,
  8   248 	    4 fb17		bit(1),
  8   249 	    4 fb18_uns		bit(1),
  8   250 	  3 mbz			bit(34);
  8   251 
  8   252 
  8   253 /* END fort_opt_nodes.incl.pl1 */
      292 
      293 
      294 	call count_cases (i);
      295 	if i ^= last_assigned_op
      296 	then do;
      297 		call print_message (382, "The number of operator cases", "last_assigned_op");
      298 		return;
      299 	     end;
      300 
      301 	shared_struc_ptr = a_ptr;
      302 
      303 	polish_base = shared_globals.polish_base;
      304 	quadruple_base = shared_globals.quadruple_base;
      305 	object_base = shared_globals.object_base;
      306 	operand_base = shared_globals.operand_base;
      307 
      308 	polish_max_len = shared_globals.polish_max_len;
      309 	quad_max_len = shared_globals.quad_max_len;
      310 	object_max_len = shared_globals.object_max_len;
      311 	operand_max_len = shared_globals.operand_max_len;
      312 
      313 	eol_offset = 0;
      314 	eol_stack_p = addr (w (eol_offset));
      315 	hold_offset = 0;
      316 	hold_stack_p = addr (w (hold_offset));
      317 	sf_offset = 0;
      318 	sf_stack_p = addr (w (sf_offset));
      319 	exit_offset = 0;
      320 	exit_stack_p = addr (w (exit_offset));
      321 	sub_offset = 0;
      322 	sub_stack_p = addr (w (sub_offset));
      323 	virtual_origin_offset = 0;
      324 	virtual_origin_list_ptr, virtual_origin_base = addr (w (virtual_origin_offset));
      325 	block_if_offset = 0;
      326 	block_if_stack_p = addr (w (block_if_offset));
      327 	dim_size_offset = 0;
      328 	dim_size_list_ptr = addr (w (dim_size_offset));
      329 
      330 	one = create_integer_constant (1);
      331 
      332 	zero = create_integer_constant (0);
      333 
      334 	do cur_subprogram = shared_globals.first_subprogram repeat subp_ptr -> subprogram.next_subprogram
      335 	     while (cur_subprogram > 0);
      336 
      337 	     subp_ptr = addr (x (cur_subprogram));
      338 	     unspec (last_opt_statement) = "0"b;
      339 	     last_op_index = 0;
      340 	     work_stack_offset = 0;
      341 
      342 	     do cur_statement = subp_ptr -> subprogram.first_polish repeat fixed (stm_ptr -> statement.next, 18)
      343 		while (cur_statement > 0);
      344 
      345 		stm_ptr = addr (p (cur_statement));
      346 
      347 /* Make the statement node for the current statement. */
      348 
      349 		opst = create_opt_statement ();
      350 
      351 		next_statement_index = fixed (stm_ptr -> statement.next, 18);
      352 		if next_statement_index = 0
      353 		then next_statement_index = subp_ptr -> subprogram.last_polish + 1;
      354 		last_io_op = 0;
      355 
      356 		calls_local_entries = "0"b;
      357 		concatenates_star_extents = "0"b;
      358 
      359 		polish_offset = cur_statement + size (statement);
      360 
      361 /* Check for a label, and add it on if present.  The first test is needed as the top of the
      362*   polish might be <increment_polish> followed by a count which happens to look like a label op. */
      363 
      364 		if p (polish_offset) > last_assigned_op
      365 		then if p (polish_offset + 1) = label_op
      366 		     then do;
      367 			     opst -> opt_statement.label = p (polish_offset);
      368 			     addr (x (p (polish_offset))) -> label.statement = last_op_index;
      369 			     polish_offset = polish_offset + 2;
      370 			end;
      371 
      372 		call process_hold_stack_entry ();
      373 		opst -> opt_statement.processed_by_converter = "1"b;
      374 
      375 /* Copy tokens from the polish to the working stack one at a time.  When an operator is found,
      376*   process_operator is called to process it.  Symbols are checked to see if they are statement_function
      377*   dummy arguments, and if so the substitution is made.  The first time a particular dummy
      378*   argument is substituted, the quads which were used to evaluate it are rechained so they
      379*   immediately precede its use. */
      380 
      381 		do polish_offset = polish_offset by 1 while (polish_offset < next_statement_index);
      382 
      383 		     stack (work_stack_offset) = p (polish_offset);
      384 		     call bump_work_stack_offset (+1);
      385 
      386 		     if p (polish_offset) <= last_assigned_op & p (polish_offset) > 0
      387 		     then call process_operator ();
      388 		     else if p (polish_offset) > 0
      389 		     then if addr (x (stack (work_stack_offset - 1))) -> node.node_type = symbol_node
      390 			then if addr (x (stack (work_stack_offset - 1))) -> symbol.dummy_arg
      391 			     then do;
      392 				     do sf_substitute_ptr = sf_stack_p
      393 					repeat (addr (w (sf_substitute_ptr -> sf_stack.last)))
      394 					while (sf_substitute_ptr ^= addr (w (0)));
      395 
      396 					j = 0;
      397 
      398 					do i = sf_substitute_ptr -> sf_stack.def_chain -> symbol.next_member
      399 					     repeat (addr (x (i)) -> symbol.next_member) while (i ^= 0);
      400 
      401 					     j = j + 1;
      402 					     if i = stack (work_stack_offset - 1)
      403 					     then go to GOT_THE_SF_VAR;
      404 					end;
      405 				     end;
      406 
      407 				     call print_message (203);
      408 
      409 GOT_THE_SF_VAR:
      410 				     if sf_substitute_ptr ^= addr (w (0))
      411 				     then do;
      412 					     if sf_substitute_ptr -> sf_stack.arg_info (j).chain_start ^= 0
      413 					     then call rechain_arg (sf_substitute_ptr, j);
      414 					     stack (work_stack_offset - 1) =
      415 						sf_substitute_ptr -> sf_stack.arg_info (j).operand;
      416 					end;
      417 				end;
      418 		end;				/* Loop over polish for one statement */
      419 
      420 	     end;					/* Loop over statements */
      421 
      422 	end;					/* Loop over program units */
      423 
      424 	if virtual_origin_offset ^= 0			/* if virtual origin list created */
      425 	then call free_virtual_origin_list ();
      426 
      427 	if dim_size_offset ^= 0			/* if dimension size list created */
      428 	then call free_dim_size_list ();
      429 
      430 	return;					/* end of converter */
      431 
      432 process_operator:
      433      proc ();
      434 
      435 dcl	op_code		fixed bin (18);
      436 
      437 	op_code = stack (work_stack_offset - 1);
      438 	if op_code < 0 | op_code > last_assigned_op
      439 	then go to case (0);
      440 	go to case (op_code);
      441 
      442 count_cases:
      443      entry (number_of_cases);
      444 
      445 dcl	number_of_cases	fixed bin (18);
      446 
      447 	number_of_cases = hbound (case, 1);
      448 	return;
      449 
      450 case (0):						/*   ERROR   */
      451 
      452 /* No such thing as operator with op_code of 0. */
      453 
      454 	call print_message (200, char (op_code));
      455 	return;
      456 
      457 case (1):						/*   ASSIGN   */
      458 
      459 /* Stack is (<>) <assign_op> <right_hand_value> <target> <...>
      460*   Create an assignment op quad, with conversion if needed, and reduce stack
      461*   to (<>) <...> */
      462 
      463 	call process_assign ();
      464 	return;
      465 
      466 case (2):						/*   ADD   */
      467 case (3):						/*   SUB   */
      468 case (4):						/*   MULT   */
      469 case (5):						/*   DIV   */
      470 
      471 /* Stack is (<>) <binary_arith_op> <right_operand> <left_operand> <...>
      472*   Process the operation as appropriate, and reduce stack to (<>) <result_temporary> <...> */
      473 
      474 	call process_arith (subscript_processing & ^suspend_subscript);
      475 	return;
      476 
      477 case (6):						/*   EXP   */
      478 
      479 /* Stack is (<>) <exp_op> <right_operand> <left_operand> <...>
      480*   Process the operation and reduce stack to (<>) <result_temporary> <...> */
      481 
      482 	call process_expo (subscript_processing & ^suspend_subscript);
      483 	return;
      484 
      485 case (7):						/*   NEG   */
      486 
      487 /* Stack is (<>) <neg_op> <operand> <...>  In the case where we are not currently evaluating
      488*   a subscript expression, or we are evaluating a subscript expression but we have a true (non-zero) operand,
      489*   we share code with the not_op case.  If we are evaluating a subscript expression at present, and the operand
      490*   in the stack is a zero, it indicates that the true operand of the minus is the accumulated
      491*   subscript value in sub_stack, and we negate it directly. */
      492 
      493 	if ^subscript_processing | suspend_subscript
      494 	then go to case (16);
      495 	else if stack (work_stack_offset - 2) ^= 0
      496 	then go to case (16);
      497 	else do;
      498 		sub_stack.dim.offset = -sub_stack.dim.offset;
      499 		if sub_stack.dim.temp ^= 0
      500 		then sub_stack.dim.mult = -sub_stack.dim.mult;
      501 		call bump_work_stack_offset (-1);
      502 	     end;
      503 	return;
      504 
      505 case (8):						/*   LESS   */
      506 case (9):						/*   LESS_OR_EQUAL   */
      507 case (10):					/*   EQUAL   */
      508 case (11):					/*   NOT_EQUAL   */
      509 case (12):					/*   GREATER_OR_EQUAL   */
      510 case (13):					/*   GREATER   */
      511 
      512 /* Stack is (<>) <rel_op> <right_operand> <left_operand> <...>
      513*   we will simply make sure that the data types match, then share code with logical ops. */
      514 
      515 	call get_data_type (2);
      516 	call conversion;
      517 
      518 case (14):					/*   OR   */
      519 case (15):					/*   AND   */
      520 case (103):					/*   EQUIV   */
      521 case (104):					/*   NOT_EQUIV   */
      522 
      523 /* Stack is (<>) <rel_or_log_op> <right_operand> <left_operand> <...>
      524*   Create an appropriate quad, and reduce the stack to
      525*   (<>) <logical_temporary_result> <...> */
      526 
      527 	op_index = create_operator (2);
      528 	stack (work_stack_offset) = create_temporary ((logical_mode));
      529 	call bump_work_stack_offset (+1);
      530 	return;
      531 
      532 case (16):					/*   NOT   */
      533 
      534 /* Stack is (<>) <unary_minus_or_not> <operand> <...>
      535*   Create an appropriate quad, and reduce the stack to (<>) <result_temp> <...> */
      536 
      537 	call get_data_type (1);
      538 	op_index = create_operator (1);
      539 	stack (work_stack_offset) = create_temporary (rand_data_type (1));
      540 	call bump_work_stack_offset (+1);
      541 	return;
      542 
      543 case (17):					/*   JUMP   */
      544 
      545 /* Stack is (<>) <jump_op> <label> <...>
      546*   First check to see if this is a backwards reference, and if so, flag the target stmt.
      547*   If this jump was contained in a statement of form "if expr goto label,"
      548*   we will simply invert the sense of the containing if jump and replace its label  with
      549*   the label from the stack.  Otherwise, create a jump_op quad.
      550*   In any case, the stack is reduced to (<>) <...> */
      551 
      552 	call search_label (stack (work_stack_offset - 2));
      553 	if exit_offset > 0
      554 	then if exit_stack.op = jump_false_op
      555 	     then do;
      556 		     exit_stack.op, exit_stack.ptr -> operator.op_code = jump_true_op;
      557 		     exit_stack.ptr -> operator.operand (2) = stack (work_stack_offset - 2);
      558 		     call bump_work_stack_offset (-2);
      559 		     next_free_quad = next_free_quad - size (opt_statement);
      560 		     op_index = addr (q (last_op_index)) -> opt_statement.prev_operator;
      561 		     last_opt_statement = ptr (quadruple_base, addr (q (last_op_index)) -> opt_statement.back);
      562 		     last_op_index = op_index;
      563 		end;
      564 	     else op_index = create_operator (1);
      565 	else op_index = create_operator (1);
      566 	return;
      567 
      568 case (18):					/*   JUMP_LOGICAL   */
      569 
      570 /* Stack is (<>) <jump_logical_op> <logical_expression> <...>
      571*   We are processing the start of a logical if.  The conditionally executed part is terminated with
      572*   an exit_op, so push the exit stack.  Create a jump_false_op quad whose first operand
      573*   is the jump_logical_op and whose second operand is the logical expression.
      574*   Keep the pointer to this quad in the exit_stack so that we can replace the jump_logical_op with the
      575*   label of the next statement when we find out what it is.  In any case, reduce the stack
      576*   to (<>) <...> */
      577 
      578 	call push_exit_stack ();
      579 	exit_stack.op, stack (work_stack_offset) = jump_false_op;
      580 
      581 /*   The j_l_op will be replaced by a label */
      582 
      583 	call bump_work_stack_offset (+1);
      584 	op_index = create_operator (2);
      585 	exit_stack.count = 0;
      586 	exit_stack.ptr = last_quad_p;
      587 	return;
      588 
      589 case (19):					/*   JUMP_ARITHMETIC   */
      590 
      591 /* Stack is (<>) <jump_arithmetic_op> <label1> <label2> <label3> <expression_value> <...>
      592*   Check the labels which were supplied to see if any of them are backward references, and if so flag the targets.
      593*   Create a jump_arithmetic_op quad, and make a hold_stack entry to note that any labels which
      594*   were not supplied will have to be filled in with the following statement's label.
      595*   Reduce stack to (<>) <...> */
      596 
      597 	do i = work_stack_offset - 4 to work_stack_offset - 2;
      598 	     if stack (i) > last_assigned_op
      599 	     then call search_label (stack (i));
      600 	end;
      601 	op_index = create_operator (4);
      602 	call push_hold_stack ();
      603 	hold_stack.op_code = jump_arithmetic_op;
      604 	hold_stack.ptr = last_quad_p;
      605 	return;
      606 
      607 case (20):					/*   JUMP_COMPUTED   */
      608 
      609 /* Stack is (<>) <jump_computed_op> <count (of labels)> <...>
      610*   List of labels will be terminated with eol_op, and the expression will be terminated with exit_op,
      611*   so push both eol_stack and exit_stack.  Stack is reduced to
      612*   (<>) <count> <...> */
      613 
      614 	call push_exit_stack ();
      615 	call push_eol_stack ();
      616 	exit_stack.op = jump_computed_op;
      617 	exit_stack.count = stack (work_stack_offset - 1);
      618 	return;
      619 
      620 case (21):					/*   JUMP_ASSIGNED   */
      621 
      622 /* Stack is (<>) <jump_assigned_op> <label_variable> <...>
      623*   Generate jump_assigned quad with label_var as operand and reduce stack  to (<>) <...> */
      624 
      625 	op_index = create_operator (1);
      626 	return;
      627 
      628 case (22):					/*   ASSIGN_LABEL   */
      629 
      630 /* Stack is (<>) <assign_label_op> <label_variable> <label> <...>
      631*   Create assign_label_op quad with label as operand and label_variable as output
      632*   (This necessitates swapping them in the stack, for create_operator.)  If label_variable is
      633*   an array reference, increment it's ref_count.  Reduce stack to (<>) <...> */
      634 
      635 	if addr (x (stack (work_stack_offset - 3))) -> node.node_type = label_node
      636 	then if addr (x (stack (work_stack_offset - 3))) -> label.format
      637 	     then stack (work_stack_offset - 3) = addr (x (stack (work_stack_offset - 3))) -> label.format_var;
      638 	stack (work_stack_offset) = stack (work_stack_offset - 2);
      639 	stack (work_stack_offset - 2) = stack (work_stack_offset - 3);
      640 	stack (work_stack_offset - 3) = stack (work_stack_offset);
      641 	op_index = create_operator (1);
      642 	call bump_work_stack_offset (-1);
      643 	last_quad_p -> operator.output = stack (work_stack_offset);
      644 	if stack (work_stack_offset) > last_assigned_op
      645 	then if addr (x (stack (work_stack_offset))) -> node.node_type = array_ref_node
      646 	     then addr (x (stack (work_stack_offset))) -> array_ref.ref_count =
      647 		     addr (x (stack (work_stack_offset))) -> array_ref.ref_count + 1;
      648 	return;
      649 
      650 case (23):					/*   READ   */
      651 case (24):					/*   WRITE   */
      652 
      653 /* Stack is (<>) <read or write> <constant> <expression> <...>
      654*   Create a read or write node with 2 operands, and remember in last_io_op whether we are
      655*   currently processing a read or a write io operation.  Reduce stack to (<>) <...> */
      656 
      657 	last_io_op = stack (work_stack_offset - 1);
      658 	op_index = create_operator (2);
      659 	return;
      660 
      661 case (25):					/*   FORMAT   */
      662 case (26):					/*   END_LABEL   */
      663 case (27):					/*   ERROR_LABEL   */
      664 
      665 /* Stack is (<>) <one of above 3 ops> <appropriate operand> <...>
      666*   Create the appropriate quad and reduce stack to (<>) <...> */
      667 
      668 	op_index = create_operator (1);
      669 	return;
      670 
      671 case (28):					/*   XMIT_SCALAR   */
      672 case (29):					/*   XMIT_ARRAY   */
      673 
      674 /* Stack is (<>) <xmit_op> <variable> <...>
      675*   (This code is also used by xmit vector stuff, which has one extra operand...hence, n_ops.)
      676*   If the current io_statement is a read statement, generate an appropriate read_xx node, with
      677*   the given variable as the output.  If the variable is an array ref, increment its ref_count.
      678*   If the current io_statement is a write statement, generate an appropriate write_xx node,
      679*   with the given variable as an operand.
      680*   Stack is reduced to (<>) <...> */
      681 /* NOTE that this requires a certain ordering of the (xmit read write)_xx_ops */
      682 
      683 	n_ops = 0;
      684 xmit_ops:
      685 	if last_io_op = read_op
      686 	then do;
      687 		stack (work_stack_offset - 1) = stack (work_stack_offset - 1) + read_scalar_op - xmit_scalar_op;
      688 		op_index = create_operator (n_ops);
      689 		call bump_work_stack_offset (-1);
      690 		last_quad_p -> operator.output = stack (work_stack_offset);
      691 		if stack (work_stack_offset) > last_assigned_op
      692 		then if addr (x (stack (work_stack_offset))) -> node.node_type = array_ref_node
      693 		     then addr (x (stack (work_stack_offset))) -> array_ref.ref_count =
      694 			     addr (x (stack (work_stack_offset))) -> array_ref.ref_count + 1;
      695 	     end;
      696 	else do;
      697 		stack (work_stack_offset - 1) = stack (work_stack_offset - 1) + write_scalar_op - xmit_scalar_op;
      698 		op_index = create_operator (n_ops + 1);
      699 	     end;
      700 	if exit_offset ^= 0
      701 	then if exit_stack.op = do_op
      702 	     then exit_stack.xmit_at_this_level = exit_stack.xmit_at_this_level + 1;
      703 	return;
      704 
      705 case (30):					/*   XMIT_VECTOR   */
      706 
      707 /* Stack is (<>) <xmit_vector_op> <length> <variable_start> <...>
      708*   Set n_ops and then we can use xmit_op code above. */
      709 
      710 	n_ops = 1;
      711 	go to xmit_ops;
      712 
      713 case (31):					/*   ENDFILE   */
      714 case (32):					/*   REWIND   */
      715 case (33):					/*   BACKSPACE   */
      716 
      717 /* Stack is (<>) <one of above 3 ops> <job bits> <unit number> <...>
      718*   Create an appropriate quad with two operands as given, and reduce stack to (<>) <...> */
      719 
      720 	op_index = create_operator (2);
      721 	return;
      722 
      723 case (34):					/*   MARGIN   */
      724 
      725 /* Stack is (<>) <margin_op> <expr1> <expr2> <...>
      726*   Create an appropriate node with the 2 given operands, and reduce the stack
      727*   to (<>) <...> */
      728 
      729 	op_index = create_operator (2);
      730 	return;
      731 
      732 case (35):					/*   OPENFILE   */
      733 
      734 /* Stack is (<>) <openfile_op> <operand1> <operand2> <operand3> <...>
      735*   Create an openfile_op node with 3 operands, and reduce stack to (<>) <...> */
      736 
      737 	op_index = create_operator (3);
      738 	return;
      739 
      740 case (36):					/*   CLOSEFILE   */
      741 case (37):					/*   RECORD_NUMBER   */
      742 
      743 /* Stack is (<>) <one of above 2 ops> <operand> <...>
      744*   Create an appropriate node with 1 operand, reduce stack to (<>) <...> */
      745 
      746 	op_index = create_operator (1);
      747 	return;
      748 
      749 case (38):					/*   STRING   */
      750 
      751 /* The parse should not make these when optimizing.  Crawl off and die. */
      752 
      753 	go to case (0);
      754 
      755 case (39):					/*   STRING_LENGTH   */
      756 
      757 /* Stack is (<>) <string_length_op> <operand> <...>
      758*   Create the node with 1 operand and reduce stack to (<>) <...> */
      759 
      760 	op_index = create_operator (1);
      761 	return;
      762 
      763 case (40):					/*   TERMINATE   */
      764 
      765 /* end of io statement.  Reset last_io_op. */
      766 
      767 	last_io_op = 0;
      768 
      769 case (41):					/*   RETURN   */
      770 
      771 /* Stack is (<>) <terminate or return> <...>
      772*   Generate node with no operands, reduce stack to (<>) <...> */
      773 
      774 	op_index = create_operator (0);
      775 	return;
      776 
      777 case (42):					/*   PAUSE   */
      778 case (43):					/*   STOP   */
      779 
      780 /* Stack is (<>) <stop or pause> <operand> <...>
      781*   Generate node with 1 operand, reduce stack to (<>) <...> */
      782 
      783 	op_index = create_operator (1);
      784 	return;
      785 
      786 case (44):					/*   ITEM   */
      787 
      788 /* Stack is (<>) <item_op> <...>   Further details and action taken depend upon the type of
      789*   list being processed, which information is held in eol_stack.op */
      790 
      791 /* If current list is a subscript_op list then top of stack is
      792*   (<>) <item_op> <subscript_expr> <array_var> <...>
      793*   If this is the last dimension, process_1_subscript will return stack
      794*   (<>) <array_ref_node> <...>
      795*   Otherwise, it will return with stack (<>) <array_var> <...>
      796*   The subscript information is accumulated in the sub_stack entry .*/
      797 
      798 	if eol_stack.op = subscript_op
      799 	then call process_1_subscript ();
      800 
      801 /* If current list is  related to an open_op, close_op, or inquire_op, then top of
      802*   stack is (<>) <item_op> {<count> <halfword>} <...>
      803*   Throw away the item op, and increment the count of items (parse didn't count 'em).
      804*   Stack becomes (<>) {<count> <halfword>} <...> */
      805 
      806 	else if eol_stack.op = open_op | eol_stack.op = close_op | eol_stack.op = inquire_op
      807 	then do;
      808 		stack (eol_stack.work_stack_offset) = stack (eol_stack.work_stack_offset) + 1;
      809 		call bump_work_stack_offset (-1);
      810 	     end;
      811 
      812 /* If the current list is related to an active statement_function reference op, then top of stack
      813*   is (<>) <item_op> <statement_func argument> <...>
      814*   If too many arguments have been supplied, we simply throw this one away.  Otherwise, we
      815*   determine whether the argument data_type matches that of the corresponding dummy argument, and
      816*   if not, generate an appropriate conversion.  The argument is remembered in the arg_info array of
      817*   the sf_stack.  The current pointer into the quad chain is remembered as the end of the
      818*   calculations involved in evaluating this argument and as the start of the calculations involved
      819*   in calculating the next argument, if another is expected.  (If there were no calculations, i.e.
      820*   an element argument, these chain ptrs are set to zero.) These chains are used to allow
      821*   rechaining of the argument calculation in at the point of first use later on.  Both the item_op
      822*   and the argument are popped from the stack, leaving (<>) <...> */
      823 
      824 	else if eol_stack.op = sf_op
      825 	then do;
      826 		if sf_stack.cur_sf_param = 0
      827 		then do;
      828 			call bump_work_stack_offset (-2);
      829 			return;
      830 		     end;
      831 		i = sf_stack.cur_sf_param;
      832 		sf_stack.cur_sf_param = addr (x (i)) -> symbol.next_member;
      833 
      834 		if addr (x (i)) -> symbol.data_type ^= addr (x (stack (work_stack_offset - 2))) -> node.data_type
      835 		then do;
      836 			stack (work_stack_offset - 1) = convert_to_int_op + addr (x (i)) -> symbol.data_type - 1;
      837 			op_index = create_operator (1);
      838 			stack (work_stack_offset) = create_temporary ((addr (x (i)) -> symbol.data_type));
      839 			call bump_work_stack_offset (+2);
      840 		     end;
      841 		sf_stack.arg_info (sf_stack.current_arg).operand = stack (work_stack_offset - 2);
      842 		if sf_stack.arg_info (sf_stack.current_arg).chain_start = last_op_index
      843 		then sf_stack.arg_info (sf_stack.current_arg).chain_start = 0;
      844 		else do;
      845 			sf_stack.arg_info (sf_stack.current_arg).chain_end = last_op_index;
      846 			sf_stack.arg_info (sf_stack.current_arg).chain_start =
      847 			     addr (q (sf_stack.arg_info (sf_stack.current_arg).chain_start)) -> operator.next;
      848 		     end;
      849 		sf_stack.current_arg = sf_stack.current_arg + 1;
      850 		if sf_stack.current_arg <= sf_stack.num_args
      851 		then sf_stack.arg_info (sf_stack.current_arg).chain_start = last_op_index;
      852 		call bump_work_stack_offset (-2);
      853 	     end;
      854 
      855 /* If the current list is related to a block IF statement, then we have
      856*   reached the end of a clause.  If this is not the last clause of the block
      857*   IF, then we emit a jump_op to skip the remaining clauses.  If the clause
      858*   was started with an IF or ELSE IF, we create a hold_stack entry so that
      859*   the conditional branch to skip the clause may be filled in.  Also, if the
      860*   clause was started with an IF or ELSE IF, and this is not the last clause,
      861*   then we create a dummy opt_statement operator so that the test can branch
      862*   to the proper location. */
      863 
      864 	else if eol_stack.op = block_if_op
      865 	then do;
      866 		block_if_stack.clause = block_if_stack.clause + 1;
      867 
      868 		if block_if_stack.clause < block_if_stack.n_clauses
      869 		then do;
      870 			stack (work_stack_offset - 1) = 0;
      871 			stack (work_stack_offset) = jump_op;
      872 			call bump_work_stack_offset (+1);
      873 			op_index = create_operator (1);
      874 			block_if_stack.n_jumps = block_if_stack.n_jumps + 1;
      875 			block_if_stack.jump (block_if_stack.n_jumps) = op_index;
      876 			opst -> opt_statement.removable = "1"b;
      877 		     end;
      878 		else call bump_work_stack_offset (-1);
      879 
      880 		if block_if_stack.test_op ^= 0
      881 		then do;
      882 			call push_hold_stack ();
      883 			hold_stack.op_code = jump_false_op;
      884 			hold_stack.ptr = addr (q (block_if_stack.test_op));
      885 			if block_if_stack.clause < block_if_stack.n_clauses
      886 			then do;
      887 				opst = create_opt_statement ();
      888 				opst -> opt_statement.put_in_profile = "0"b;
      889 				opst -> opt_statement.put_in_map = "1"b;
      890 				call process_hold_stack_entry ();
      891 			     end;
      892 
      893 		     end;
      894 	     end;
      895 
      896 /* In any other case, stack is (<>) <item_op> <some list item> <...>
      897*   We simply toss the item op, leaving (<>) <some_list_item> <...> */
      898 
      899 	else call bump_work_stack_offset (-1);
      900 	return;
      901 
      902 case (45):					/*   EXIT   */
      903 
      904 /* Top of stack is (<>) <exit_op> <...>   Further details and action taken depend upon the type
      905*   of operation with which this exit_op is associated.  This information is held in exit_stack. */
      906 
      907 /* If the exit_op is related to a jump_true or jump_false op, then the top of stack
      908*   is (<>) <exit_op> <...>    Create a hold_stack entry, indicating that we will need to fill
      909*   in a label in the jump when we know the label of the next statement.  Throw away the exit op,
      910*   leaving (<>) <...> */
      911 
      912 	if exit_stack.op = jump_false_op | exit_stack.op = jump_true_op
      913 	then do;
      914 		call push_hold_stack ();
      915 		hold_stack.op_code = exit_stack.op;
      916 		hold_stack.ptr = exit_stack.ptr;
      917 		call bump_work_stack_offset (-1);
      918 	     end;
      919 
      920 /* If the current exit_op is related to a jump_computed_op, it terminates the expression calculation.
      921*   Top of stack is (<>) <exit_op> <expr> {<label>} <count> <...>   We convert the expr to integer, if it is not already,
      922*   check each of the labels to see if it involves a backwards reference, create a
      923*   jump_computed node with the expr, labels, and count as operands, and pop the whole mess off
      924*   the work stack, leaving (<>) <...> */
      925 
      926 	else if exit_stack.op = jump_computed_op
      927 	then do;
      928 		call get_data_type (1);
      929 		if rand_data_type (1) ^= int_mode
      930 		then do;
      931 			stack (work_stack_offset - 1) = convert_to_int_op;
      932 			op_index = create_operator (1);
      933 			call bump_work_stack_offset (+2);
      934 			stack (work_stack_offset - 2) = create_temporary ((int_mode));
      935 		     end;
      936 		stack (work_stack_offset - 1) = jump_computed_op;
      937 
      938 		do i = 1 to exit_stack.count + bias;
      939 		     call search_label (stack (work_stack_offset - exit_stack.count - bias - 3 + i));
      940 		end;
      941 
      942 		op_index = create_operator (exit_stack.count + bias + 2);
      943 	     end;
      944 
      945 /* If the current exit_op is related to an sf_op, it means we have been evaluating a statement_function
      946*   reference, which is done by saving the pointer into the polish at the point of reference and resetting
      947*   it to run through the sf_definition, which is terminated by the exit_op.  We must move the pointer
      948*   back to the point in the polish following the reference which is being evaluated.  The top of stack
      949*   is (<>) <exit_op> <sf_result> <...>
      950*   We check to see if the result data type matches that of the statement function, and if not, force  conversion.
      951*   We pop the sf_stack entry corresponding to this sf reference, since the evaluation is done.
      952*   The exit_op is tossed, leaving (<>) <sf_result> <...> */
      953 
      954 	else if exit_stack.op = sf_op
      955 	then do;
      956 		polish_offset = sf_stack.polish_offset;
      957 		if subscript_processing
      958 		then do;
      959 			if stack (work_stack_offset - 2) = 0 & sf_stack.def_chain -> symbol.data_type = int_mode
      960 			     & (sub_stack.dim.temp = 0
      961 			     | addr (x (sub_stack.dim.temp)) -> temporary.data_type = int_mode)
      962 			then ;
      963 			else do;
      964 				true_rand = 1;
      965 				call compress_subscript ();
      966 			     end;
      967 		     end;
      968 
      969 		if stack (work_stack_offset - 2) ^= 0
      970 		then do;
      971 			if addr (x (stack (work_stack_offset - 2))) -> node.data_type
      972 			     ^= sf_stack.def_chain -> symbol.data_type
      973 			then do;
      974 				stack (work_stack_offset - 1) =
      975 				     convert_to_int_op - 1 + sf_stack.def_chain -> symbol.data_type;
      976 				op_index = create_operator (1);
      977 				stack (work_stack_offset) =
      978 				     create_temporary ((sf_stack.def_chain -> symbol.data_type));
      979 				if sf_stack.def_chain -> symbol.data_type = char_mode
      980 				then addr (x (stack (work_stack_offset))) -> temporary.length =
      981 					get_char_size ((sf_stack.def_chain)) + bias;
      982 				call bump_work_stack_offset (+1);
      983 			     end;
      984 			else call bump_work_stack_offset (-1);
      985 		     end;
      986 		else call bump_work_stack_offset (-1);
      987 		call pop_sf_stack ();
      988 	     end;
      989 
      990 /*   If the current exit_op is related to a do_op,  we've reached the end of a do-group.
      991*   Top of stack is (<>) <exit_op> <*> <incr> <upper> <lower> <index_var> <...>
      992*   The entry <*> is a do_op if the do_index var is also being used as the iteration counter, and is a
      993*   compiler-generated unnamed symbol if a separate counter has been generated.
      994*   We generate code to increment the formal index variable.  If a separate counter is being used, it is also
      995*   incremented.  Nodes are then generated to test the index variable/counter and branch back if
      996*   not done.  If the next operation in the polish is not a statement op (i.e. if this is an implied do)
      997*   then we must generate a pseudo-statement to follow the do_group, so as not to confuse the optimizer.
      998*   We must also arrange for that statement or the next statement to come along to get a label, which
      999*   is used as the target of the zero_trip_branch generated at the beginning of the loop.
     1000*   The stack is left containing (<>) <...> */
     1001 
     1002 	else if exit_stack.op = do_op
     1003 	then do;
     1004 		if hold_offset ^= 0 & last_io_op = 0
     1005 		then do;
     1006 			opst = create_opt_statement ();
     1007 			opst -> opt_statement.put_in_profile = "0"b;
     1008 			opst -> opt_statement.put_in_map = "1"b;
     1009 			call process_hold_stack_entry ();
     1010 		     end;
     1011 
     1012 		stack (work_stack_offset - 1) /*   increment loop variable   */,
     1013 		     stack (work_stack_offset) = stack (work_stack_offset - 6);
     1014 		stack (work_stack_offset + 1) = stack (work_stack_offset - 3);
     1015 		stack (work_stack_offset + 2) = add_op;
     1016 		call bump_work_stack_offset (+3);
     1017 		call process_arith ("0"b);
     1018 
     1019 		stack (work_stack_offset) = assign_op;
     1020 		call bump_work_stack_offset (+1);
     1021 		call process_assign ();
     1022 
     1023 		if stack (work_stack_offset - 1) ^= do_op
     1024 						/*   a counter   */
     1025 		then do;
     1026 			stack (work_stack_offset) /*   increment counter   */,
     1027 			     stack (work_stack_offset + 1) = stack (work_stack_offset - 1);
     1028 			stack (work_stack_offset + 2) = one;
     1029 			stack (work_stack_offset + 3) = add_op;
     1030 			call bump_work_stack_offset (+4);
     1031 			call process_arith ("0"b);
     1032 
     1033 			stack (work_stack_offset) = assign_op;
     1034 			call bump_work_stack_offset (+1);
     1035 			call process_assign ();
     1036 			stack (work_stack_offset - 5) = stack (work_stack_offset);
     1037 		     end;
     1038 
     1039 		stack (work_stack_offset) = stack (work_stack_offset - 5);
     1040 		stack (work_stack_offset + 1) = stack (work_stack_offset - 3);
     1041 		stack (work_stack_offset + 2) = greater_op;
     1042 		call bump_work_stack_offset (+3);
     1043 		call get_data_type (2);
     1044 		call conversion;
     1045 		op_index = create_operator (2);
     1046 
     1047 		stack (work_stack_offset) = create_temporary ((logical_mode));
     1048 		call bump_work_stack_offset (+1);
     1049 		stack (work_stack_offset) = exit_stack.do_label;
     1050 		stack (work_stack_offset + 1) = jump_false_op;
     1051 		call search_label (stack (work_stack_offset));
     1052 
     1053 		call bump_work_stack_offset (+2);
     1054 		op_index = create_operator (2);
     1055 
     1056 		if p (polish_offset + 1) ^= stat_op
     1057 		then do;
     1058 			opst = create_opt_statement ();
     1059 			opst -> opt_statement.put_in_profile = "0"b;
     1060 			opst -> opt_statement.put_in_map = "1"b;
     1061 			if exit_stack.zero_trip_branch ^= 0
     1062 			then do;
     1063 				i, addr (q (exit_stack.zero_trip_branch)) -> operator.operand (2) =
     1064 				     create_label (last_op_index);
     1065 				addr (x (i)) -> label.referenced_executable = "1"b;
     1066 				opst -> opt_statement.label = i;
     1067 			     end;
     1068 		     end;
     1069 		else if exit_stack.zero_trip_branch ^= 0
     1070 		then do;
     1071 			call push_hold_stack ();
     1072 			hold_stack.op_code = jump_false_op;
     1073 			hold_stack.ptr = addr (q (exit_stack.zero_trip_branch));
     1074 		     end;
     1075 		call bump_work_stack_offset (-5);
     1076 	     end;
     1077 
     1078 /* If an exit_op shows up under any other circumstances, it's a level 4 error.  Go bomb out!!!!! */
     1079 
     1080 	else call print_message (200, "45");
     1081 
     1082 /* Having processed the exit_op, pop its entry from the exit_stack. */
     1083 
     1084 	call pop_exit_stack ();
     1085 	return;
     1086 
     1087 case (46):					/*   EOL   */
     1088 
     1089 /* Top of stack is (<>) <eol_op> <...>   Further details and action taken depend upon the type
     1090*   of operation with which this eol_op is associated.  This information is held in eol_stack.
     1091*   Note that process_eol_stack also pops the eol_stack. */
     1092 
     1093 /* If the eol is associated with a jump_computed op, it terminates the list of labels.  Stack is
     1094*   (<>) <eol_op> {<label>} <count> <...>    We can't create the node until we have
     1095*   evaluated the controlling expression.  Simply throw out the eol_op and pop the eol_stack,
     1096*   leaving the stack as (<>) {<label>} <count> <...> */
     1097 
     1098 	if eol_stack.op = jump_computed_op
     1099 	then do;
     1100 		call bump_work_stack_offset (-1);
     1101 		call pop_eol_stack ();
     1102 	     end;
     1103 
     1104 /*   If the eol_op is associated with a chain_op, the top of the stack is
     1105*   (<>) <eol_op> {<expression>} <count> <string expr> <string expr> <...>
     1106*   Call process_eol_stack to combine the whole mess into a chain_op node, and clean up the stack.
     1107*   Stack will be left containing (<>) <...> */
     1108 
     1109 	else if eol_stack.op = chain_op
     1110 	then call process_eol_stack (1, 3);
     1111 
     1112 /* If the eol_op is associuated with an open or close op, the top of the stack is
     1113*   (<>) <eol_op> {<count> <halfword>} <count> <const> <const> <expr> <...>
     1114*   Call process_eol_stack to combine the whole mess into an appropriate node, and clean up the stack.
     1115*   Stack will be left containing (<>) <...> */
     1116 
     1117 	else if eol_stack.op = open_op | eol_stack.op = close_op
     1118 	then call process_eol_stack (2, 4);
     1119 
     1120 /* If the eol_op is associated with a call, top of the stack is
     1121*   (<>) <eol_op> {<args>} <count> <entry> <...>
     1122*   Call process_eol_stack to produce an appropriate node, and clean up the stack.
     1123*   Stack will be left containing (<>) <...> */
     1124 
     1125 	else if eol_stack.op = call_op
     1126 	then call process_eol_stack (1, 2);
     1127 
     1128 /* If the eol_op is associated with a process_param_list_op, top of stack is
     1129*   (<>) <eol_op> {<args>} <count> <...>
     1130*   Call process_eol_stack to produce an appropriate node, and clean up the stack.
     1131*   Stack will be left containing (<>) <...> */
     1132 
     1133 	else if eol_stack.op = process_param_list_op
     1134 	then call process_eol_stack (1, 1);
     1135 
     1136 /* If the eol_op is associated with a func_ref_op, the top of the stack is
     1137*   (<>) <eol_op> {<arg>} <count> <func> <...>
     1138*   Call process_eol_stack to create the func_ref_node, and create_temporary to create a temp for its output.
     1139*   Stack is left containing (<>) <function_value> <...> */
     1140 
     1141 	else if eol_stack.op = func_ref_op
     1142 	then do;
     1143 		call process_eol_stack (1, 2);
     1144 		temp_node_ptr = addr (x (addr (q (op_index)) -> operator.operand (1)));
     1145 		stack (work_stack_offset) = create_temporary ((temp_node_ptr -> symbol.data_type));
     1146 		if temp_node_ptr -> symbol.data_type = char_mode
     1147 		then addr (x (stack (work_stack_offset))) -> temporary.length = get_char_size (temp_node_ptr) + bias;
     1148 		call bump_work_stack_offset (+1);
     1149 	     end;
     1150 
     1151 /* If the eol_op is associated with a builtin_op, the top of the stack is
     1152*   (<>) <eol_op> {<arg>} <count> <entry> <...>
     1153*   Call process_builtin to process the stack, build a builtin_node, pop the eol_stack,
     1154*   and clean up the work stack leaving (<>) <result> <...> */
     1155 
     1156 	else if eol_stack.op = builtin_op
     1157 	then do;
     1158 		call process_builtin ();
     1159 	     end;
     1160 
     1161 /* If the eol_op is associated with a subscript_op, we've already done all the work when we saw the item_op.
     1162*   Top of stack is (<>) <eol_op> <array_ref_node> <...>
     1163*   We pop the sub_stack and the eol_stack, and clean up the work stack, leaving
     1164*   (<>) <array_ref_node> <...> */
     1165 
     1166 	else if eol_stack.op = subscript_op
     1167 	then do;
     1168 		call bump_work_stack_offset (-1);
     1169 		call pop_sub_stack ();
     1170 		call pop_eol_stack ();
     1171 	     end;
     1172 
     1173 /* If the eol_op is associated with a statement_function reference, all needed info will have been placed into the sf_stack
     1174*   by now.  The top of the stack is merely (<>) <eol_op> <...>   Process_sf_stack will cause the sf_to
     1175*   be evaluated by saving the current pointer into the polish, setting it to point back into the sf definition
     1176*   and cleaning the eol off of the work stack, leaving (<>) <...>.  The converter will process happly thru the sf definition
     1177*   generating cnodes with appropriate subscript substitutions, until it hits the exit_op
     1178*   at the end of the definition.  Then the polish pointer will be reset.  process_sf pops the eol_stack and
     1179*   pushes an entry onto the exit_stack. */
     1180 
     1181 	else if eol_stack.op = sf_op
     1182 	then call process_sf ();
     1183 
     1184 /* If the eol_op is associated with a block IF statement, we have reached the
     1185*   end of the entire block IF (i.e. the ENDIF statement).  The jump_ops
     1186*   which appear at the end of each clause but the last must now be filled in.
     1187*   This is accomplished by creating a hold_stack entry for the block_if_op.
     1188*   When the hold_stack entry is processed, the block_if_stack will be popped.
     1189*   The eol_stack is popped explicitly here. */
     1190 
     1191 	else if eol_stack.op = block_if_op
     1192 	then do;
     1193 		call pop_eol_stack ();
     1194 		call push_hold_stack ();
     1195 		hold_stack.op_code = block_if_op;
     1196 		hold_stack.ptr = null ();
     1197 		call bump_work_stack_offset (-1);
     1198 		opst -> opt_statement.removable = "1"b;
     1199 	     end;
     1200 
     1201 /* If the eol_op is associated with an inquire_op, the top of the stack is
     1202*   (<>) <eol_op> {<count> <halfword>} <count> <fields specified> <job bits> <...>
     1203*   Call process_eol_stack to combine all of this into a single operator, popping
     1204*   the eol_stack and leaving the operand stack as (<>) <...> */
     1205 
     1206 	else if eol_stack.op = inquire_op
     1207 	then call process_eol_stack (2, 3);
     1208 
     1209 /* Any other eol_op which may turn up is a level 4 error.  Go away and die!!! */
     1210 
     1211 	else call print_message (200, "46");
     1212 	return;
     1213 
     1214 case (47):					/*   DO_OP   */
     1215 
     1216 /* Top of stack is (<>) <do_op> <incr> <upper> <lower> <index var> <...>
     1217*   The do group will be terminated by an exit_op, so we push the exit_stack to remember that we expect it.
     1218*   Match_index_type is called to convert the upper, lower, and incr to match the index var, if needed.
     1219*   If the increment is an integer constant (which implies index is integer) then if the upper bound is
     1220*   not constant we assign it to a frozen_for_do temporary.  If the increment is not an integer constant,
     1221*   we generate the nodes necessary to compute a counter value which will actually be used for loop control.
     1222*   If it is necessary to generate such a counter, it will replace the do_op in the stack.
     1223*   If the increment is not constant, and we are compiling in ansi77 mode, the value of the increment
     1224*   must be assigned to a frozen_for_do temporary, which replaces the original increment in the stack.
     1225*   Whether or not a counter is generated, we must compile a conditional branch to skip the entire
     1226*   loop if it should be executed zero times.  The offset of the branch is remembered in
     1227*   exit_stack.zero_trip_branch, so that the correct label may be filled in later.
     1228*   After the conditional jump is emitted, a statement op is emitted to force the creation of a new
     1229*   flow unit, which will serve as the back target of the loop.
     1230*   If last_io_op ^= 0 we are processing an implied do in an io statement.  Optimize_vector will be called
     1231*   to see if the implied do can be optimized into an xmit_vector op.  If this optimization is done
     1232*   the assorted do info will be purged from the stack, and the polish input stack will be modified to contain
     1233*   an xmit_vector_op and appropriate count and vector info.  This is the one case where the converter may
     1234*   modify the polish input.
     1235*   If this is not an implied do, or is an unoptimizable implied do, a node will be generated to initialize the loop
     1236*   variable.  If not an implied do, a hold_stack entry will be generated, to remember that the label of the
     1237*   next statement must be kept as it begins the do-group; if an implied do, a statement_node will be generated,
     1238*   and it's label remembered, for the end_of_loop code to branch back to.
     1239*   The stack will be left as is, with the possible exception of a count  (if generated) replacing the do_op. */
     1240 
     1241 	call push_exit_stack ();
     1242 	exit_stack.op = do_op;
     1243 	exit_stack.xmit_at_this_level = 0;
     1244 	exit_stack.ptr = null;
     1245 	exit_stack.zero_trip_branch = 0;
     1246 	call match_index_type ();
     1247 	r = addr (x (stack (work_stack_offset - 2)));
     1248 
     1249 	if r -> node.node_type = constant_node & r -> node.data_type = int_mode
     1250 	then do;
     1251 		s = addr (x (stack (work_stack_offset - 3)));
     1252 		if s -> node.node_type ^= constant_node
     1253 		then do;
     1254 			stack (work_stack_offset) = stack (work_stack_offset - 3);
     1255 			stack (work_stack_offset + 1) = assign_op;
     1256 			call bump_work_stack_offset (+2);
     1257 			op_index = create_operator (1);
     1258 			stack (work_stack_offset - 3) = create_temporary ((int_mode));
     1259 			temp_ptr -> temporary.frozen_for_do = "1"b;
     1260 		     end;
     1261 	     end;
     1262 	else do;
     1263 		if r -> node.node_type ^= constant_node
     1264 		then if subp_ptr -> subprogram.options.ansi_77
     1265 		     then do;
     1266 			     stack (work_stack_offset) = stack (work_stack_offset - 2);
     1267 			     stack (work_stack_offset + 1) = assign_op;
     1268 			     call bump_work_stack_offset (+2);
     1269 			     op_index = create_operator (1);
     1270 			     stack (work_stack_offset - 2) = create_temporary ((r -> node.data_type));
     1271 			     temp_ptr -> temporary.frozen_for_do = "1"b;
     1272 			end;
     1273 
     1274 		stack (work_stack_offset) = stack (work_stack_offset - 3);
     1275 		stack (work_stack_offset + 1) = stack (work_stack_offset - 4);
     1276 		stack (work_stack_offset + 2) = sub_op;
     1277 		call bump_work_stack_offset (+3);
     1278 		call process_arith ("0"b);
     1279 
     1280 		stack (work_stack_offset) = stack (work_stack_offset - 3);
     1281 		stack (work_stack_offset + 1) = div_op;
     1282 		call bump_work_stack_offset (+2);
     1283 		call process_arith ("0"b);
     1284 
     1285 		if addr (x (stack (work_stack_offset - 1))) -> node.data_type ^= int_mode
     1286 		then do;
     1287 			stack (work_stack_offset) = convert_to_int_op;
     1288 			call bump_work_stack_offset (+1);
     1289 			op_index = create_operator (1);
     1290 			call bump_work_stack_offset (+1);
     1291 			stack (work_stack_offset - 1) = create_temporary ((int_mode));
     1292 		     end;
     1293 
     1294 		call bump_work_stack_offset (-1);
     1295 
     1296 /* replace <upper> with the loop count just computed */
     1297 
     1298 		stack (work_stack_offset - 3) = stack (work_stack_offset);
     1299 
     1300 /* initialize counter to zero */
     1301 
     1302 		stack (work_stack_offset - 1) = create_var ();
     1303 		stack (work_stack_offset) = zero;
     1304 		stack (work_stack_offset + 1) = assign_op;
     1305 		call bump_work_stack_offset (+2);
     1306 		call process_assign ();
     1307 		call bump_work_stack_offset (+1);
     1308 	     end;
     1309 	if last_io_op ^= 0
     1310 	then do;
     1311 		save_polish_offset = polish_offset;
     1312 		call optimize_vector ();
     1313 		if polish_offset < save_polish_offset
     1314 		then return;
     1315 	     end;
     1316 
     1317 /*   initialize loop variable   */
     1318 
     1319 	stack (work_stack_offset) = stack (work_stack_offset - 5);
     1320 	stack (work_stack_offset + 1) = stack (work_stack_offset - 4);
     1321 	stack (work_stack_offset + 2) = assign_op;
     1322 	call bump_work_stack_offset (+3);
     1323 	call process_assign ();
     1324 	exit_stack.ptr = last_quad_p;
     1325 
     1326 /* generate conditional branch for zero trip loop */
     1327 
     1328 	if subp_ptr -> subprogram.options.ansi_77
     1329 	then do;
     1330 		if r -> node.node_type = constant_node & r -> node.data_type = int_mode
     1331 		then do;
     1332 			stack (work_stack_offset) = stack (work_stack_offset - 3);
     1333 			stack (work_stack_offset + 1) = stack (work_stack_offset - 4);
     1334 			if substr (r -> constant.value, 1, 1)
     1335 						/* if < 0 */
     1336 			then stack (work_stack_offset + 2) = less_or_equal_op;
     1337 			else stack (work_stack_offset + 2) = greater_or_equal_op;
     1338 		     end;
     1339 		else do;
     1340 			stack (work_stack_offset) = stack (work_stack_offset - 3);
     1341 			stack (work_stack_offset + 1) = zero;
     1342 			stack (work_stack_offset + 2) = greater_or_equal_op;
     1343 		     end;
     1344 		call bump_work_stack_offset (+3);
     1345 		op_index = create_operator (2);
     1346 		stack (work_stack_offset) = create_temporary ((logical_mode));
     1347 		stack (work_stack_offset + 1) = 0;
     1348 		stack (work_stack_offset + 2) = jump_false_op;
     1349 		call bump_work_stack_offset (+3);
     1350 		op_index = create_operator (2);
     1351 		exit_stack.zero_trip_branch = op_index;
     1352 
     1353 		opst = create_opt_statement ();
     1354 		opst -> opt_statement.put_in_profile = "0"b;
     1355 		opst -> opt_statement.put_in_map = "1"b;
     1356 	     end;
     1357 
     1358 	if last_io_op ^= 0
     1359 	then do;
     1360 		opst = create_opt_statement ();
     1361 		opst -> opt_statement.put_in_profile = "0"b;
     1362 		opst -> opt_statement.put_in_map = "1"b;
     1363 		opst -> opt_statement.label, i = create_label (last_op_index);
     1364 		opst -> opt_statement.referenced_backwards = "1"b;
     1365 		addr (x (i)) -> label.referenced_executable = "1"b;
     1366 		exit_stack.do_label = i;
     1367 	     end;
     1368 	else do;
     1369 		call push_hold_stack ();
     1370 		hold_stack.op_code = stat_op;
     1371 		hold_stack.ptr = opst;
     1372 	     end;
     1373 	return;
     1374 
     1375 case (48):					/*   BUILTIN   */
     1376 
     1377 /* Top of stack is (<>) <builtin_op> <count> <function> <...>
     1378*   Processing happens when we see the eol_op.  Push the eol_stack and pitch the builtin_op, leaving the stack as
     1379*   (<>) <count> <function> <...> */
     1380 	call push_eol_stack ();
     1381 	return;
     1382 
     1383 case (49):					/*   SF   */
     1384 
     1385 /* Top of stack is (<>) <sf_op> <count> <function> <...>
     1386*   Processing occurs when we see the eol_op.  Push the eol_stack and pitch the sf_op.  We must also
     1387*   create an entry in the sf_stack to hold info about the arguments as they are evaluated, and to
     1388*   remember the function name and count.  Stack becomes (<>) <...> */
     1389 
     1390 	call push_eol_stack ();
     1391 	call push_sf_stack ();
     1392 	return;
     1393 
     1394 case (50):					/*   SF_DEF   */
     1395 
     1396 /* Nothing to do for statement function definitions.  Stack is (<>) <sf_def_op> <function> <...>
     1397*   Set symbol.initial for the function name to point to the definition in the polish.
     1398*   If this is the first sf_def, set put_in_map on the statement node
     1399*   for the jump around the definitions to 0 in order to prevent anomalies in the object listing.
     1400*   Pitch the statement node since there will be no statement.  Skip past the definition in the
     1401*   polish stack.  Clean up the work stack, leaving (<>) <...> */
     1402 
     1403 	addr (x (stack (work_stack_offset - 2))) -> symbol.initial = polish_offset + 1;
     1404 	call bump_work_stack_offset (-2);
     1405 	do polish_offset = polish_offset + 1 by 1 while (p (polish_offset) ^= exit_op);
     1406 	end;
     1407 
     1408 	if ^first_statement_function_done
     1409 	then unspec (addr (q (fixed (opst -> opt_statement.back, 18))) -> opt_statement.bits) = "0"b;
     1410 	first_statement_function_done = "1"b;
     1411 	next_free_quad = next_free_quad - size (opt_statement);
     1412 	op_index = addr (q (last_op_index)) -> opt_statement.prev_operator;
     1413 	last_opt_statement = ptr (quadruple_base, addr (q (last_op_index)) -> opt_statement.back);
     1414 	last_op_index = op_index;
     1415 	opst = last_opt_statement;
     1416 	profile_size = profile_size - 1;
     1417 	return;
     1418 
     1419 case (51):					/*   SUBSCRIPT   */
     1420 
     1421 /* Top of stack is (<>) <subscript_op> <count> <array_var> <...>
     1422*   We set up an eol_stack entry, since this construct will be terminated with an eol, and a
     1423*   sub_stack entry to keep track of the subscript calculations.  Set the subscript_processing flag
     1424*   for the arithmetic_op processing routines.  We call initialize_subscript to give the array
     1425*   its dimension sizes and virtual origin.  The stack becomes (<>) <array_var> <...> */
     1426 
     1427 	call push_eol_stack ();
     1428 	call push_sub_stack ();
     1429 	subscript_processing = "1"b;
     1430 	call bump_work_stack_offset (-1);
     1431 	sub_stack.n_dimensions = stack (work_stack_offset) + bias;
     1432 	sub_stack.symbol_node = addr (x (stack (work_stack_offset - 1)));
     1433 	sub_stack.dim_node = addr (x (sub_stack.symbol_node -> symbol.dimension));
     1434 	sub_stack.dim.mult = 1;
     1435 	sub_stack.dimension = 1;
     1436 	sub_stack.cum.temp = 0;
     1437 	sub_stack.cum.constant = 0;
     1438 	sub_stack.dim.temp = 0;
     1439 
     1440 	if sub_stack.symbol_node -> symbol.star_extents
     1441 	then do;
     1442 		sub_stack.element.constant = 1;
     1443 		sub_stack.element.var = sub_stack.symbol_node -> symbol.v_length;
     1444 	     end;
     1445 	else do;
     1446 		sub_stack.element.constant = sub_stack.symbol_node -> symbol.element_size;
     1447 		sub_stack.element.var = 0;
     1448 	     end;
     1449 
     1450 	call initialize_subscript ((sub_stack.symbol_node));
     1451 
     1452 /*  If this is a VLA, generate a quad to subtract the virtual origin from    */
     1453 /*  the base address of the VLA and leave the difference in 'cum.temp'.  We  */
     1454 /*  don't need to treat a constant virtual origin of zero specially, since   */
     1455 /*  the optimizer ignores a subtraction of zero!                             */
     1456 
     1457 	if sub_stack.symbol_node -> symbol.VLA
     1458 	then do;
     1459 		stack (work_stack_offset) = sub_stack.dim_node -> dimension.VLA_base_addressor;
     1460 		if sub_stack.dim_node -> dimension.variable_virtual_origin
     1461 		then stack (work_stack_offset + 1) = sub_stack.dim_node -> dimension.virtual_origin;
     1462 		else stack (work_stack_offset + 1) =
     1463 			create_integer_constant (sub_stack.dim_node -> dimension.virtual_origin
     1464 			- sub_stack.symbol_node -> symbol.offset);
     1465 		stack (work_stack_offset + 2) = sub_op;
     1466 		call bump_work_stack_offset (+3);
     1467 		call process_arith ("0"b);
     1468 		call bump_work_stack_offset (-1);
     1469 		sub_stack.cum.temp = stack (work_stack_offset);
     1470 	     end;
     1471 
     1472 	return;
     1473 
     1474 case (52):					/*   FUNC_REF   */
     1475 
     1476 /* Top of stack is (<>) <func_ref_op> <count> <function> <...>   Simply create an eol_stack
     1477*   entry, and pitch the func_ref_op, leaving (<>) <count> <function> <...> */
     1478 
     1479 	calls_local_entries = is_local ((stack (work_stack_offset - 3)));
     1480 	call push_eol_stack ();
     1481 	return;
     1482 
     1483 case (53):					/*   BLOCK_DATA   */
     1484 
     1485 /* Top of stack is (<>) <block_data_op> <...>   Create a node of 0 operands, and pop the op,
     1486*   leaving (<>) <...>*/
     1487 
     1488 	op_index = create_operator (0);
     1489 	return;
     1490 
     1491 case (54):					/*   INCREMENT_POLISH   */
     1492 
     1493 /* Top of stack is (<>) <increment_polish_op> <...  and the next item in the polish stack
     1494*   is the number of polish entries to skip over.  Move the polish pointer ahead the given
     1495*   amount, and toss the increment_polish_op, leaving the stack as (<>) <...> */
     1496 
     1497 	call bump_work_stack_offset (-1);
     1498 	polish_offset = polish_offset + p (polish_offset + 1) + 1;
     1499 	if polish_offset > polish_max_len
     1500 	then call print_message (201);
     1501 	return;
     1502 
     1503 case (55):					/*   MAIN   */
     1504 case (56):					/*   FUNC   */
     1505 case (57):					/*   SUBR   */
     1506 
     1507 /* Top of stack is (<>) <main or func or subr> <count> <entry> <...>
     1508*   Create an appropriate quad with the 2 given operands, and reduce the
     1509*   stack to (<>) <...> */
     1510 
     1511 	op_index = create_operator (2);
     1512 	return;
     1513 
     1514 case (58):					/*   STAT   */
     1515 case (59):					/*   LABEL   */
     1516 
     1517 /* Stat and label ops are supposed to be processed by the calling program.  If any show up here
     1518*   something foul has occurred.  Go crawl into a hole and die. */
     1519 
     1520 	go to case (0);
     1521 
     1522 case (60):					/*   CALL   */
     1523 
     1524 /* Top of stack is (<>) <call_op> <count> <external> <...>.  Push an eol_stack
     1525*   entry, since processing has to await the list, and pop the call_op leaving
     1526*   (<>) <count> <external> <...>. */
     1527 
     1528 	calls_local_entries = is_local ((stack (work_stack_offset - 3)));
     1529 	call push_eol_stack ();
     1530 	return;
     1531 
     1532 case (61):					/*   CHAIN   */
     1533 
     1534 /* Top of stack is (<>) <chain_op> <count> <string_expr> <string_expr> <...>.
     1535*   Push an eol_stack entry, since processing has to await the list, and pop
     1536*   the chain_op, leaving (<>) <count> <string_expr> <string_expr> <...>. */
     1537 
     1538 	call push_eol_stack ();
     1539 	return;
     1540 
     1541 case (62):					/*   ENDUNIT   */
     1542 
     1543 /* Top of stack is (<>) <endunit_op> <...>  Make a node of 0 operands, pop the op,
     1544*   leaving (<>) <...>  and set subprogram.last_quad to point to the node. */
     1545 
     1546 	op_index = create_operator (0);
     1547 	subp_ptr -> subprogram.last_quad = op_index;
     1548 	return;
     1549 
     1550 case (63):					/*   NON_EXECUTABLE   */
     1551 case (64):					/*   NO_OP   */
     1552 
     1553 /* Top of stack is (<>) <one of above 2 ops> <...>   Make a node of 0 operands, and pop the op,
     1554*   leaving (<>) <...> */
     1555 
     1556 	op_index = create_operator (0);
     1557 	return;
     1558 
     1559 case (65):					/*   INDIRECT_SCAN   */
     1560 case (66):					/*   OPT_SUBSCRIPT   */
     1561 case (67):					/*   LEFT_SHIFT   */
     1562 case (68):					/*   RIGHT_SHIFT   */
     1563 case (69):					/*   STORE_ZERO   */
     1564 case (70):					/*   STORAGE_ADD   */
     1565 case (71):					/*   STORAGE_SUB   */
     1566 case (72):					/*   NEG_STORAGE_ADD   */
     1567 case (73):					/*   STORAGE_ADD_ONE   */
     1568 case (74):					/*   NAMELIST   */
     1569 
     1570 /* None of the above 10 ops is supposed to be output by the parse.  If they show up, we've
     1571*   screwed up somewhere.  Crawl off and die. */
     1572 
     1573 	go to case (0);
     1574 
     1575 case (75):					/*   OPEN   */
     1576 case (76):					/*   CLOSE   */
     1577 
     1578 /* Top of stack is (<>) <open or close _op> <count> <constant> <constant> <expr> <...>
     1579*   Push an eol_stack entry, and toss the op, leaving the stack as
     1580*   (<>) <count> <constant> <constant> <expr> <...> */
     1581 
     1582 	call push_eol_stack ();
     1583 	return;
     1584 
     1585 case (77):					/*   IO_STAT   */
     1586 
     1587 /* Top of stack is (<>) <iostat_op> <var> <...>   Iostat takes no operands, and uses var as its
     1588*   output.  Create a node of 0 variables, attach var as its output, and increment var's reference count if
     1589*   var is an array_ref.  Clean stack, leaving (<>) <...> */
     1590 
     1591 	op_index = create_operator (0);
     1592 	call bump_work_stack_offset (-1);
     1593 	last_quad_p -> operator.output = stack (work_stack_offset);
     1594 	if stack (work_stack_offset) > last_assigned_op
     1595 	then if addr (x (stack (work_stack_offset))) -> node.node_type = array_ref_node
     1596 	     then addr (x (stack (work_stack_offset))) -> array_ref.ref_count =
     1597 		     addr (x (stack (work_stack_offset))) -> array_ref.ref_count + 1;
     1598 	return;
     1599 
     1600 case (78):					/*   CONVERT_TO_INT   */
     1601 case (79):					/*   CONVERT_TO_REAL   */
     1602 case (80):					/*   CONVERT_TO_DP   */
     1603 case (81):					/*   CONVERT_TO_CMPX   */
     1604 case (82):					/*   READ_SCALAR   */
     1605 case (83):					/*   READ_ARRAY   */
     1606 case (84):					/*   READ_VECTOR   */
     1607 case (85):					/*   WRITE_SCALAR   */
     1608 case (86):					/*   WRITE_ARRAY   */
     1609 case (87):					/*   WRITE_VECTOR   */
     1610 case (88):					/*   JUMP_TRUE   */
     1611 case (89):					/*   JUMP_FALSE   */
     1612 case (90):					/*   SUB_INDEX   */
     1613 case (91):					/*   LOOP_END_OP   */
     1614 
     1615 /* Last 14 ops are not output by parse.  If we see one here, it's an error. Go off and die! */
     1616 
     1617 	go to case (0);
     1618 
     1619 case (92):					/*   READ_NAMELIST_OP   */
     1620 case (93):					/*   WRITE_NAMELIST_OP   */
     1621 
     1622 /* Top of stack is (<>) <(read write)_namelist_op> <expr> <...>   Create the node with one operand.
     1623*   Clean off the stack, leaving (<>) <...> */
     1624 
     1625 	op_index = create_operator (1);
     1626 	return;
     1627 
     1628 case (94):					/*   DECODE_STRING_OP   */
     1629 case (105):					/*   READ_INTERNAL_FILE   */
     1630 
     1631 /* Top of stack is (<>) <decode_string_op> <operand> <...>
     1632*   Create a node of 1 operand, and clean up the stack, leaving (<>) <...> */
     1633 
     1634 	op_index = create_operator (1);
     1635 	return;
     1636 
     1637 case (95):					/*   ENCODE_STRING_OP   */
     1638 case (106):					/*   WRITE_INTERNAL_FILE   */
     1639 
     1640 /* Top of stack is (<>) <encode_string_op> <output_operand> <...>
     1641*   Create a node of 0 operands, and fill in the output.
     1642*   Clean up the stack, leaving (<>) <...> */
     1643 
     1644 	op_index = create_operator (0);
     1645 	call bump_work_stack_offset (-1);
     1646 	last_quad_p -> operator.output = stack (work_stack_offset);
     1647 	if stack (work_stack_offset) > last_assigned_op
     1648 	then if addr (x (stack (work_stack_offset))) -> node.node_type = array_ref_node
     1649 	     then addr (x (stack (work_stack_offset))) -> array_ref.ref_count =
     1650 		     addr (x (stack (work_stack_offset))) -> array_ref.ref_count + 1;
     1651 	return;
     1652 
     1653 case (96):					/*   CAT_OP   */
     1654 
     1655 /* Top of stack is (<>) <cat_op> <right_operand> <left_operand> <...>
     1656*   Create a quad to compute the length of the result, and run it through a
     1657*   sub_index operator.  Then create a quad for the concatenation itself.
     1658*   Linearize adjacent concatenation operators by calling compress_concat.
     1659*   The stack is left (<>) <output_temp> <...> */
     1660 
     1661 	if ^subp_ptr -> subprogram.options.ansi_77
     1662 	then call print_message (153);
     1663 
     1664 	concatenates_star_extents = is_star_extent ((stack (work_stack_offset - 3)))
     1665 	     | is_star_extent ((stack (work_stack_offset - 2)));
     1666 
     1667 	i = get_char_size (addr (x (stack (work_stack_offset - 3))));
     1668 	if i < 0
     1669 	then i = create_integer_constant (i + bias);
     1670 	stack (work_stack_offset - 1) = i;
     1671 
     1672 	i = get_char_size (addr (x (stack (work_stack_offset - 2))));
     1673 	if i < 0
     1674 	then i = create_integer_constant (i + bias);
     1675 	stack (work_stack_offset) = i;
     1676 
     1677 	stack (work_stack_offset + 1) = add_op;
     1678 	call bump_work_stack_offset (+2);
     1679 	call process_arith ("0"b);
     1680 	stack (work_stack_offset) = sub_index_op;
     1681 	call bump_work_stack_offset (+1);
     1682 	op_index = create_operator (1);
     1683 	stack (work_stack_offset) = create_temporary ((int_mode));
     1684 	stack (work_stack_offset + 1) = cat_op;
     1685 	call bump_work_stack_offset (+2);
     1686 	op_index = create_operator (3);
     1687 	stack (work_stack_offset) = create_temporary ((char_mode));
     1688 	call bump_work_stack_offset (+1);
     1689 	call compress_concat ();
     1690 	return;
     1691 
     1692 case (97):					/*   SUBSTR_OP   */
     1693 
     1694 /* Top of stack is (<>) <substr_op><upper_bound><lower_bound><parent>...
     1695*    Create an opt_substr node in the quads with 4 operand: symbol, constant-offset,
     1696*    variable offset, and length.  All this processing is done in process_substr,
     1697*    and the stack is left as: (<>) <array_ref> ... */
     1698 
     1699 	call process_substr ();
     1700 	return;
     1701 
     1702 case (98):					/* LOAD_XREG_OP */
     1703 case (99):					/* LOAD_PREG_OP */
     1704 
     1705 /* The parse should not create either of the last two ops.  Crawl off and die. */
     1706 
     1707 	go to case (0);
     1708 
     1709 case (100):					/* BLOCK_IF_OP */
     1710 
     1711 /* Top of stack is (<>) <block_if_op> <clause_count> <predicate> <...>
     1712*   We push the eol_stack, since the block_if_op begins a list of clauses,
     1713*   and we push an entry onto the block_if_stack to remember various things
     1714*   about this block IF statement.  A jump_false_op based on the predicate
     1715*   is generated to skip the first clause.  The stack is left (<>) <...> */
     1716 
     1717 	call push_eol_stack ();
     1718 
     1719 	block_if_clause_count = stack (work_stack_offset - 1) + bias;
     1720 	call push_block_if_stack ();
     1721 	block_if_stack.clause = 0;
     1722 	block_if_stack.n_jumps = 0;
     1723 
     1724 	stack (work_stack_offset - 1) = 0;
     1725 	stack (work_stack_offset) = jump_false_op;
     1726 	call bump_work_stack_offset (+1);
     1727 	op_index = create_operator (2);
     1728 
     1729 	block_if_stack.test_op = op_index;
     1730 
     1731 	return;
     1732 
     1733 case (101):					/* ELSE_IF_OP */
     1734 
     1735 /* Top of stack is (<>) <else_if_op> <predicate> <...>
     1736*   We emit a jump_false_op based on the predicate to skip this clause of
     1737*   the block IF.  The stack is left (<>) <...> */
     1738 
     1739 	stack (work_stack_offset - 1) = 0;
     1740 	stack (work_stack_offset) = jump_false_op;
     1741 	call bump_work_stack_offset (+1);
     1742 	op_index = create_operator (2);
     1743 	block_if_stack.test_op = op_index;
     1744 	return;
     1745 
     1746 case (102):					/* ELSE_OP */
     1747 
     1748 /* The else_op takes no arguments, and does nothing except mark the beginning
     1749*   of a simple ELSE clause.  We need do nothing with it here. */
     1750 
     1751 	block_if_stack.test_op = 0;
     1752 	call bump_work_stack_offset (-1);
     1753 	return;
     1754 
     1755 case (107):					/* INQUIRE */
     1756 
     1757 /* Top of stack is (<>) <inquire op> <count> <fields specified> <job bits> <...>
     1758*   Push an eol_stack entry, and pop the inquire op, leaving the stack as
     1759*   (<>) <count> <fields specified> <job bits> <...> */
     1760 
     1761 	call push_eol_stack ();
     1762 	return;
     1763 
     1764 case (108):					/* PROCESS_PARAM_LIST */
     1765 
     1766 /* Top of stack is (<>) <process_param_list_op> <count> <...>
     1767*   Push an eol_stack entry and toss the operator, leaving the stack as
     1768*   (<>) <count> <...> */
     1769 
     1770 	call push_eol_stack ();
     1771 	return;
     1772 
     1773 case (109):					/* LHS_FLD */
     1774 
     1775 /* Top of stack is (<>) <lhs_fld_op> <right_hand_side> <argument3>
     1776*   <argument2> <argument1> <...> */
     1777 
     1778 	call process_lhs_fld ();
     1779 	return;
     1780 
     1781      end process_operator;
     1782 
     1783 process_assign:
     1784      proc ();
     1785 
     1786 /* Called with the top of stack (<>) <assign_op> <right_side> <target> <...>
     1787*   Does appropriate things with the assignment, as indicated below, and Cleans out the stack,
     1788*   leaving (<>) <...> */
     1789 
     1790 /* Get rand_data_type(1) (= data type of target), rand_data_type(2) (= data type of source), and combination_type, which is
     1791*   a function of rand_data_type(1) and rand_data_type(2) */
     1792 
     1793 	call get_data_type (2);
     1794 	go to assign_l (combination_type);
     1795 
     1796 assign_l (1):					/*  INTEGER = INTEGER   */
     1797 	go to no_convert;
     1798 assign_l (2):					/*  REAL = INTEGER  */
     1799 assign_l (3):					/*  DP = INTEGER  */
     1800 assign_l (4):					/*  CMPX = INTEGER  */
     1801 assign_l (5):					/*  INTEGER = REAL  */
     1802 	go to convert;
     1803 assign_l (6):					/*  REAL = REAL  */
     1804 assign_l (7):					/*  DP = REAL  */
     1805 assign_l (8):					/*  CMPX = REAL  */
     1806 	go to no_convert;
     1807 assign_l (9):					/*  INTEGER = DP  */
     1808 	go to convert;
     1809 assign_l (10):					/*  REAL = DP  */
     1810 assign_l (11):					/*  DP = DP  */
     1811 assign_l (12):					/*  CMPX = DP  */
     1812 	go to no_convert;
     1813 assign_l (13):					/*  INTEGER = CMPX  */
     1814 convert:
     1815 
     1816 /* Explicit convert generated iff one side of assign is integer
     1817*   and the other side is non_integer arithmetic data_type. */
     1818 
     1819 /* NOTE: This block requires a certain ordering of the convert_to_xx operators. */
     1820 
     1821 	stack (work_stack_offset) = stack (work_stack_offset - 2);
     1822 	stack (work_stack_offset + 1) = convert_to_int_op - 1 + rand_data_type (1);
     1823 	call bump_work_stack_offset (+2);
     1824 	op_index = create_operator (1);
     1825 	stack (work_stack_offset - 2) = create_temporary (rand_data_type (1));
     1826 
     1827 assign_l (14):					/*  REAL = CMPX  */
     1828 assign_l (15):					/*  DP = CMPX  */
     1829 assign_l (16):					/*  DP = DP  */
     1830 assign_l (17):					/*  anything = data_type>complex  */
     1831 assign_l (18):					/*  data_type>complex = data_type<=complex  */
     1832 no_convert:
     1833 
     1834 /* IF the target is an array_ref, we must increment its reference count */
     1835 
     1836 	if stack (work_stack_offset - 3) > last_assigned_op
     1837 	then if addr (x (stack (work_stack_offset - 3))) -> node.node_type = array_ref_node
     1838 	     then addr (x (stack (work_stack_offset - 3))) -> array_ref.ref_count =
     1839 		     addr (x (stack (work_stack_offset - 3))) -> array_ref.ref_count + 1;
     1840 
     1841 /* If the assignment is of a function return value to a variable of the same data type, then we
     1842*   will simply place the target of the assignment into the output entry of the function_ref node
     1843*   and not generate an assignment node. */
     1844 
     1845 	if rand_data_type (1) = rand_data_type (2)
     1846 	then do;
     1847 		call get_node_type (2);
     1848 		if rand_node_type (2) = temporary_node
     1849 		then if addr (q (addr (x (stack (work_stack_offset - 2))) -> temporary.output_by)) -> operator.op_code
     1850 			= func_ref_op
     1851 		     then if rand_data_type (1) ^= char_mode
     1852 			     | (get_char_size (addr (x (stack (work_stack_offset - 2))))
     1853 			     = get_char_size (addr (x (stack (work_stack_offset - 3)))))
     1854 			then do;
     1855 				addr (q (op_index)) -> operator.output = stack (work_stack_offset - 3);
     1856 				call bump_work_stack_offset (-3);
     1857 				return;
     1858 			     end;
     1859 	     end;
     1860 
     1861 /* Make the assignment node, and clean up the stack. */
     1862 
     1863 	op_index = create_operator (1);
     1864 	call bump_work_stack_offset (-1);
     1865 	last_quad_p -> operator.output = stack (work_stack_offset);
     1866 	return;
     1867      end process_assign;
     1868 
     1869 process_arith:
     1870      proc (subscript_mode);
     1871 
     1872 dcl	constant_value	fixed bin (18);
     1873 dcl	subscript_mode	bit (1) aligned;
     1874 
     1875 /* Called with top of stack (<>) <+|-|/|*> <right_hand_rand> <left_hand_rand> <...>
     1876*   Does appropriate things with the binary op, and returns leaving the result in the stack,
     1877*   as (<>) <value> <...> */
     1878 
     1879 	call get_data_type (2);
     1880 	call get_node_type (2);
     1881 
     1882 /* If the operator is add or multiply, we'll put the operands into a consistent order
     1883*   to improve the likelihood of finding common sub_expressions. */
     1884 
     1885 	if stack (work_stack_offset - 1) = add_op | stack (work_stack_offset - 1) = mult_op
     1886 	then if rand_node_type (1) > rand_node_type (2)
     1887 		| (rand_node_type (1) = rand_node_type (2)
     1888 		& stack (work_stack_offset - 3) > stack (work_stack_offset - 2))
     1889 	     then do;
     1890 		     stack (work_stack_offset) = stack (work_stack_offset - 3);
     1891 		     stack (work_stack_offset - 3) = stack (work_stack_offset - 2);
     1892 		     stack (work_stack_offset - 2) = stack (work_stack_offset);
     1893 		     call get_data_type (2);
     1894 		     call get_node_type (2);
     1895 		end;
     1896 
     1897 /* If we are not currently processing a subscript expression, the two operands in the stack are
     1898*   the true operands, and we must simply create an appropriate node with 2 operands,
     1899*   with an appropriate conversion if needed, create a temporary for the output value,
     1900*   and go away. */
     1901 
     1902 	if ^subscript_mode
     1903 	then do;
     1904 		call conversion;
     1905 		op_index = create_operator (2);
     1906 		stack (work_stack_offset) = create_temporary (max (rand_data_type (1), rand_data_type (2)));
     1907 		call bump_work_stack_offset (+1);
     1908 		return;
     1909 	     end;
     1910 	if stack (work_stack_offset - 1) <= 1 | stack (work_stack_offset - 1) > 5
     1911 	then call print_message (200, char (stack (work_stack_offset - 1)));
     1912 
     1913 /* If we are currently processing a subscript expression, the situation becomes more complex.  In
     1914*   an effort to minimize calculation at run time, an attempt is made to pull any constant parts of
     1915*   the subscript calculation out at compile time.  To this end, thefollowing is done:
     1916*
     1917*   It is assumed that the "effective element length" of the current dimension can be represented by
     1918*   the expression <constant>*<variable>, stored in sub_stack entries element.constant and
     1919*   element.var, respectively.
     1920*
     1921*   It is assumed that the cumulative effective subscript, including the effect of all dimensions up
     1922*   to and including the latest one completely processed, can be represented by the expression
     1923*   <constant>+<variable>, stored in sub_stack entries cum.constant and cum.temp respectively.  This
     1924*   form was chosen because it is the form ultimately needed when the array_ref_op node is created.
     1925*
     1926*   It is assumed that the current subscript being evaluated can be expressed by the expression
     1927*   <constant_multiplier>*<variable>+<constant_offset>, stored in sub_stack entries dim.mult,
     1928*   dim.temp, and dim.offset, respectively.  This expression will be refered to in the following
     1929*   documentation as the accumulated current dimension.
     1930*
     1931*   A value of true binary 0 is placed in the workstack in place of a normal operand to indicate
     1932*   that the accummulated current dimension is to be used for that operand. */
     1933 
     1934 /* true_rand indicates which of the 2 operands is a normal operand if the accumulated current
     1935*   dimension is one of the operands.  If both operands are true operands, true_rand is set to -1 */
     1936 
     1937 	if rand_data_type (1) = 0
     1938 	then true_rand = 2;
     1939 	else if rand_data_type (2) = 0
     1940 	then true_rand = 1;
     1941 	else do;
     1942 		true_rand = -1;
     1943 		call conversion;
     1944 		call get_data_type (2);
     1945 	     end;
     1946 	call get_node_type (2);
     1947 	go to case (stack (work_stack_offset - 1) - 1);
     1948 
     1949 case (1):						/*  ADD  */
     1950 	if true_rand = -1
     1951 	then do;
     1952 
     1953 /* If the accumulated current dimension does not take part in the expression at all, then we have
     1954*   to see what it is.  If there is no accumulated current dimension, then we are herewith beginning
     1955*   a new dimension.  Simply stick the left_hand operand into the appropriate dim.  entry, according
     1956*   to whether it is constant or not, set true_rand to indicate that the left_hand operand is the
     1957*   accumulated current dimension, and continue.  Otherwise simply create the appropriate operator
     1958*   node and leave the result in the stack. */
     1959 
     1960 		if sub_stack.dim.temp = 0 & sub_stack.dim.offset = 0
     1961 		then do;
     1962 			if effectively_constant (work_stack_offset - 3, 1, constant_value)
     1963 			then sub_stack.dim.offset = constant_value;
     1964 			else sub_stack.dim.temp = stack (work_stack_offset - 3);
     1965 			true_rand = 2;
     1966 		     end;
     1967 		else do;
     1968 			op_index = create_operator (2);
     1969 			stack (work_stack_offset) = create_temporary (max (rand_data_type (1), rand_data_type (2)));
     1970 			call bump_work_stack_offset (+1);
     1971 			return;
     1972 		     end;
     1973 	     end;
     1974 
     1975 /* If the true_operand is a constant, just add its value to sub_stack.dim.offset.*/
     1976 
     1977 	if effectively_constant (work_stack_offset - 4 + true_rand, true_rand, constant_value)
     1978 	then do;
     1979 		sub_stack.dim.offset = sub_stack.dim.offset + constant_value;
     1980 		call bump_work_stack_offset (-3);
     1981 	     end;
     1982 
     1983 /* Or, if there is not yet a variable part of the accumulated current dimension, put the true operand
     1984*   into dim.temp */
     1985 
     1986 	else if sub_stack.dim.temp = 0
     1987 	then do;
     1988 		sub_stack.dim.temp = stack (work_stack_offset - 4 + true_rand);
     1989 		call bump_work_stack_offset (-3);
     1990 	     end;
     1991 
     1992 /* Otherwise create nodes to compute <dim.mult>*<dim.temp> + <true operand>, and place the result
     1993*   into dim.temp, resetting dim.mult to 1. */
     1994 
     1995 	else call compress_subscript ();
     1996 
     1997 /* Leave a 0 in the stack to indicate that the result is being held in the accumulated current dimension. */
     1998 
     1999 	call bump_work_stack_offset (+1);
     2000 	stack (work_stack_offset - 1) = 0;
     2001 	return;
     2002 
     2003 case (2):						/* SUBTRACT */
     2004 	if true_rand = -1
     2005 	then do;
     2006 
     2007 /* If the accumulated current dimension does not take part in the expression at all, then we have
     2008*   to see what it is.  If there is no accumulated current dimension, then we are herewith beginning
     2009*   a new dimension.  Simply stick the left_hand operand into the appropriate dim entry, according
     2010*   to whether it is constant or not, set true_rand to indicate that the left_hand operand is the
     2011*   accumulated current dimension, and continue.  Otherwise, simply create the appropriate operator
     2012*   node and leave the result in the stack. */
     2013 
     2014 		if sub_stack.dim.temp = 0 & sub_stack.dim.offset = 0
     2015 		then do;
     2016 			if effectively_constant (work_stack_offset - 3, 1, constant_value)
     2017 			then sub_stack.dim.offset = constant_value;
     2018 			else sub_stack.dim.temp = stack (work_stack_offset - 3);
     2019 			true_rand = 2;
     2020 		     end;
     2021 		else do;
     2022 			op_index = create_operator (2);
     2023 			stack (work_stack_offset) = create_temporary (max (rand_data_type (1), rand_data_type (2)));
     2024 			call bump_work_stack_offset (+1);
     2025 			return;
     2026 		     end;
     2027 	     end;
     2028 
     2029 /* If the true_rand is a constant, then we check which operand it is, since - does not commute.  If
     2030*   the true operand is the right_hand side, just subtract it from dim.offset.  If the true operand
     2031*   is the left_hand side, we must negate the dim.mult entry and set dim.offset to the
     2032*      operand - dim.offset */
     2033 
     2034 	if effectively_constant (work_stack_offset - 4 + true_rand, true_rand, constant_value)
     2035 	then do;
     2036 		if true_rand = 2
     2037 		then sub_stack.dim.offset = sub_stack.dim.offset - constant_value;
     2038 		else do;
     2039 			sub_stack.dim.offset = constant_value - sub_stack.dim.offset;
     2040 			if sub_stack.dim.temp ^= 0
     2041 			then sub_stack.dim.mult = -sub_stack.dim.mult;
     2042 		     end;
     2043 		call bump_work_stack_offset (-3);
     2044 	     end;
     2045 
     2046 /* If the true operand is not constant, and there is no accumulated variable part, then if the true
     2047*   operand is the right_hand side, put it in dim.temp and set the dim.mult to -1.  If the true
     2048*   operand is on the left, put it in dim.temp and negate dim.offset */
     2049 
     2050 	else if sub_stack.dim.temp = 0
     2051 	then do;
     2052 		sub_stack.dim.temp = stack (work_stack_offset - 4 + true_rand);
     2053 		if true_rand = 2
     2054 		then sub_stack.dim.mult = -1;
     2055 		else sub_stack.dim.offset = -sub_stack.dim.offset;
     2056 		call bump_work_stack_offset (-3);
     2057 	     end;
     2058 
     2059 /* Otherwise create nodes to compute <dim.mult>*<dim.temp> and to produce the subtraction with the
     2060*   true operand.  Place the result into dim.temp, and reset dim.mult to 1 */
     2061 
     2062 	else call compress_subscript ();
     2063 
     2064 /* Leave a 0 in the stack to indicate that the result is being held in accumulated current
     2065*   dimension. */
     2066 
     2067 	call bump_work_stack_offset (+1);
     2068 	stack (work_stack_offset - 1) = 0;
     2069 	return;
     2070 
     2071 case (3):						/*  MULT  */
     2072 	if true_rand = -1
     2073 	then do;
     2074 
     2075 /* If the accumulated current dimension does not take part in the expression at all, then we have
     2076*   to see what it is.  If there is no accumulated current dimension, then we are herewith beginning
     2077*   a new dimension.  Simply stick the left_hand operand into the appropriate dim entry according to
     2078*   whether it is constant or not, set true_rand to indicate that the left_hand operand is the
     2079*   accumulated current dimension, and continue.  Otherwise, simply create the appropriate operator
     2080*   node and leave the result in the stack. */
     2081 
     2082 		if sub_stack.dim.temp = 0 & sub_stack.dim.offset = 0
     2083 		then do;
     2084 			if effectively_constant (work_stack_offset - 3, 1, constant_value)
     2085 			then sub_stack.dim.offset = constant_value;
     2086 			else sub_stack.dim.temp = stack (work_stack_offset - 3);
     2087 			true_rand = 2;
     2088 		     end;
     2089 		else do;
     2090 			op_index = create_operator (2);
     2091 			stack (work_stack_offset) = create_temporary (max (rand_data_type (1), rand_data_type (2)));
     2092 			call bump_work_stack_offset (+1);
     2093 			return;
     2094 		     end;
     2095 	     end;
     2096 
     2097 /* If the true_rand is a constant, then simply multiply dim.offset by it, and also multiply
     2098*   dim.mult by it if dim.temp is non_zero.  (Processing is easier if mult is guaranteed to be 1
     2099*   when there is no dim.temp part.) */
     2100 
     2101 	if effectively_constant (work_stack_offset - 4 + true_rand, true_rand, constant_value)
     2102 	then do;
     2103 		sub_stack.dim.offset = sub_stack.dim.offset * constant_value;
     2104 		if sub_stack.dim.temp ^= 0
     2105 		then sub_stack.dim.mult = sub_stack.dim.mult * constant_value;
     2106 		call bump_work_stack_offset (-3);
     2107 	     end;
     2108 
     2109 /* Or, if the true_rand is variable and there is no variable part in the current dimension, simply
     2110*   put the operand into dim.temp, move the former dim.offset into dim.mult, and zero dim.offset. */
     2111 
     2112 	else if sub_stack.dim.temp = 0
     2113 	then do;
     2114 		sub_stack.dim.mult = sub_stack.dim.offset;
     2115 		sub_stack.dim.offset = 0;
     2116 		sub_stack.dim.temp = stack (work_stack_offset - 4 + true_rand);
     2117 		call bump_work_stack_offset (-3);
     2118 	     end;
     2119 
     2120 /* Otherwise, create nodes to reduce the entire accumulated current dimension to a single temp,
     2121*   perform the new multiplication, and place the result into sub_stack.dim.temp, resetting the
     2122*   dim.offset to 0 and the dim.mult to 1. */
     2123 
     2124 	else call compress_subscript ();
     2125 
     2126 /* Leave a 0 in the stack to indicate that the result is being held in accumulated current dimension. */
     2127 
     2128 	call bump_work_stack_offset (+1);
     2129 	stack (work_stack_offset - 1) = 0;
     2130 	return;
     2131 
     2132 case (4):						/* DIVIDE  */
     2133 
     2134 /* Operator nodes are always generated for divisions, because the truncation effect of FORTRAN
     2135*   integer division means they've basically gotta be done where the guy wrote them to avoid
     2136*   changing the meaning of the code. */
     2137 
     2138 	if true_rand = -1
     2139 	then do;
     2140 
     2141 /* If the accumulated current dimension does not take part in the calculation, then we must look to
     2142*   see what it is.  If there is no accumulated current dimension, we'll create a divide_op node and
     2143*   stick the output temp into dim.temp.  If there is an accumulated current dimension, make the
     2144*   node and stick the output temp into the stack. */
     2145 
     2146 		if sub_stack.dim.temp = 0 & sub_stack.dim.offset = 0
     2147 		then do;
     2148 			sub_stack.dim.temp = subscript_arith (2);
     2149 			call bump_work_stack_offset (+1);
     2150 			stack (work_stack_offset - 1) = 0;
     2151 			return;
     2152 		     end;
     2153 		else do;
     2154 			op_index = create_operator (2);
     2155 			stack (work_stack_offset) = create_temporary (max (rand_data_type (1), rand_data_type (2)));
     2156 			call bump_work_stack_offset (+1);
     2157 			return;
     2158 		     end;
     2159 	     end;
     2160 
     2161 /* Or, if there is no variable part to the accumulated current dimension, we'll convert the offset
     2162*   part into the appropriate operand position in the stack, create the operator, and stick the
     2163*   result temp into dim.temp. */
     2164 
     2165 	if sub_stack.dim.temp = 0
     2166 	then do;
     2167 		stack (work_stack_offset - 1 - true_rand) =
     2168 		     create_integer_constant ((sub_stack.dim.offset));
     2169 		sub_stack.dim.temp = subscript_arith (2);
     2170 		sub_stack.dim.offset = 0;
     2171 	     end;
     2172 
     2173 /* Otherwise, create nodes to reduce the entire accumulated current dimension to a single temp,
     2174*   perform the division, and place the result into dim.temp, resetting dim.mult to 1 and dim.offset
     2175*   to 0. */
     2176 
     2177 	else call compress_subscript ();
     2178 
     2179 /* Leave a 0 in the stack to indicate the the result is being held in accumulated current dimension. */
     2180 
     2181 	call bump_work_stack_offset (+1);
     2182 	stack (work_stack_offset - 1) = 0;
     2183 	return;
     2184      end process_arith;
     2185 
     2186 compress_concat:
     2187      procedure ();
     2188 
     2189 /* Attempts to combine adjacent concatenation operators into a single
     2190*        operator with many operands.  Op_index points to the (binary)
     2191*        concatenation operator that was just created. */
     2192 
     2193 dcl	(cur_operator, old_operator)
     2194 			pointer;
     2195 dcl	(n, k, i)		fixed binary (18);
     2196 
     2197 	cur_operator = addr (q (op_index));
     2198 
     2199 /* If the first operand of the new concatenation operator is a temporary
     2200*        that was created by another concatenation operator, then splice the
     2201*        operands of the old operator into the beginning of the new one and
     2202*        unchain the old operator. */
     2203 
     2204 	if addr (x (cur_operator -> operator.operand (1))) -> node.node_type = temporary_node
     2205 	then do;
     2206 		old_operator = addr (q (addr (x (cur_operator -> operator.operand (1))) -> temporary.output_by));
     2207 		if old_operator -> operator.op_code = cat_op
     2208 		then do;
     2209 			n, cur_operator -> operator.number = old_operator -> operator.number + 1;
     2210 			cur_operator -> operator.operand (n) = cur_operator -> operator.operand (3);
     2211 			cur_operator -> operator.operand (n - 1) = cur_operator -> operator.operand (2);
     2212 			do i = 1 to n - 2;
     2213 			     cur_operator -> operator.operand (i) = old_operator -> operator.operand (i);
     2214 			end;
     2215 			next_free_quad = next_free_quad + n - 3;
     2216 			call unchain_cat_op (old_operator);
     2217 		     end;
     2218 	     end;
     2219 
     2220 /* If the last operand of the new concatenation operator is a temporary
     2221*        that was output by another concatenation operator, splice the operands
     2222*        of the old operator onto the end of the new one and unchain the old
     2223*        operator.  Note that the current operator is not necessarily a binary
     2224*        operator at this point. */
     2225 
     2226 	n = cur_operator -> operator.number;
     2227 	if addr (x (cur_operator -> operator.operand (n - 1))) -> node.node_type = temporary_node
     2228 	then do;
     2229 		old_operator = addr (q (addr (x (cur_operator -> operator.operand (n - 1))) -> temporary.output_by));
     2230 		if old_operator -> operator.op_code = cat_op
     2231 		then do;
     2232 			k = old_operator -> operator.number;
     2233 			cur_operator -> operator.number = n + k - 2;
     2234 			cur_operator -> operator.operand (n + k - 2) = cur_operator -> operator.operand (n);
     2235 			do i = 1 to k - 1;
     2236 			     cur_operator -> operator.operand (n + i - 2) = old_operator -> operator.operand (i);
     2237 			end;
     2238 			next_free_quad = next_free_quad + k - 2;
     2239 			call unchain_cat_op (old_operator);
     2240 		     end;
     2241 	     end;
     2242 
     2243      end compress_concat;
     2244 
     2245 
     2246 unchain_cat_op:
     2247      procedure (op_p);
     2248 
     2249 dcl	(op_p, p)		pointer;
     2250 
     2251 /* unchain_cat_op is called by compress_concat with a pointer to a
     2252*   concatenation operator node as its argument.  It removes the operator node
     2253*   from the quad chain, and releases its output temporary.  It also frees the
     2254*   sub_index operator (and its temporary) that was used for the length. */
     2255 
     2256 	p = op_p;
     2257 	call unchain (addr (q (addr (x (p -> operator.operand (p -> operator.number))) -> temporary.output_by)));
     2258 	call unchain (p);
     2259 	return;
     2260 
     2261      end unchain_cat_op;
     2262 
     2263 unchain:
     2264      procedure (op_ptr);
     2265 
     2266 /* Does actual unchaining and freeing for unchain_cat_op and elsewhere */
     2267 
     2268 dcl	op_ptr		pointer;
     2269 
     2270 	addr (q (op_ptr -> operator.next)) -> operator.back = op_ptr -> operator.back;
     2271 	addr (q (op_ptr -> operator.back)) -> operator.next = op_ptr -> operator.next;
     2272 	addr (x (op_ptr -> operator.output)) -> temporary.next = next_free_temp;
     2273 	next_free_temp = op_ptr -> operator.output;
     2274 
     2275      end unchain;
     2276 
     2277 process_expo:
     2278      proc (mode);
     2279 
     2280 dcl	(base, j, k, running_base)
     2281 			fixed bin (18);
     2282 dcl	mode		bit (1) aligned;
     2283 
     2284 /* process_expo is called with the stack in the form (<>) <exp_op> <base> <power> <...>.  If
     2285*   <power> is not a positive integer it generates an exp_op node, otherwise it generates a series
     2286*   of multiply nodes using Knuth's algorithm.  It returns with the stack looking like (<>) <result> <...>
     2287*   The tricky part deals with subscript computations.  If this exp op occurs inside a
     2288*   sub_script calculation, and one of the operands is the accumulated current dimension, then the
     2289*   accumulated current dimension is reduced to a single temp or constant and placed into the work
     2290*   stack; If inside a sub_script evaluation, then the result temp is placed into dim.temp and a 0
     2291*   placed into the work stack at the end of this calculation.  */
     2292 
     2293 	call get_data_type (2);
     2294 	if mode & (rand_data_type (1) = 0 | rand_data_type (2) = 0)
     2295 	then do;
     2296 		if rand_data_type (1) = 0
     2297 		then true_rand = 2;
     2298 		else true_rand = 1;
     2299 		if sub_stack.dim.temp = 0
     2300 		then do;
     2301 			stack (work_stack_offset - 1 - true_rand) =
     2302 			     create_integer_constant ((sub_stack.dim.offset));
     2303 			sub_stack.dim.offset = 0;
     2304 		     end;
     2305 		else call compress_subscript ();
     2306 		call get_data_type (2);
     2307 	     end;
     2308 
     2309 	if rand_data_type (2) = int_mode
     2310 	then do;
     2311 		r = addr (x (stack (work_stack_offset - 2)));
     2312 		if r -> node.node_type = constant_node
     2313 		then do;
     2314 			unspec (j) = r -> constant.value;
     2315 			if j = 0
     2316 			then do;
     2317 				stack (work_stack_offset - 3) = one;
     2318 				call bump_work_stack_offset (-2);
     2319 				return;
     2320 			     end;
     2321 
     2322 			if j = 1
     2323 			then do;
     2324 				call bump_work_stack_offset (-2);
     2325 				return;
     2326 			     end;
     2327 			if j > 1
     2328 			then do;
     2329 				k = index (r -> constant.value, "1"b);
     2330 				call bump_work_stack_offset (-2);
     2331 				base, running_base = stack (work_stack_offset - 1);
     2332 				do j = k + 1 to 36;
     2333 				     stack (work_stack_offset) = running_base;
     2334 				     stack (work_stack_offset + 1) = mult_op;
     2335 				     call bump_work_stack_offset (+2);
     2336 				     call process_arith ("0"b);
     2337 				     if substr (r -> constant.value, j, 1)
     2338 				     then do;
     2339 					     stack (work_stack_offset) = base;
     2340 					     stack (work_stack_offset + 1) = mult_op;
     2341 					     call bump_work_stack_offset (+2);
     2342 					     call process_arith ("0"b);
     2343 					end;
     2344 				     running_base = stack (work_stack_offset - 1);
     2345 				end;
     2346 				return;
     2347 			     end;
     2348 		     end;
     2349 	     end;
     2350 	if rand_data_type (2) ^= int_mode
     2351 	then call conversion;
     2352 
     2353 	op_index = create_operator (2);
     2354 	stack (work_stack_offset) = create_temporary (max (rand_data_type (1), rand_data_type (2)));
     2355 
     2356 	if mode & sub_stack.dim.temp = 0 & sub_stack.dim.offset = 0
     2357 	then do;
     2358 		sub_stack.dim.temp = stack (work_stack_offset);
     2359 		stack (work_stack_offset) = 0;
     2360 	     end;
     2361 	call bump_work_stack_offset (+1);
     2362      end process_expo;
     2363 
     2364 get_data_type:
     2365      proc (number);
     2366 
     2367 dcl	i		fixed bin (18),
     2368 	n		fixed bin (18),
     2369 	number		fixed bin (18);
     2370 dcl	r		ptr;
     2371 
     2372 /* get_data_type is called with a stack of the form (<>) <operator> {<operand>} <...> and an
     2373*   argument giving the number of operands.  The first (i.e.  leftmost) operand is the one deepest
     2374*   in the stack.  get data_type returns the data types of the "number" operands, in the array
     2375*   rand_data_type, with the first operand in rand_data_type(1), etc.  In addition, if the number of
     2376*   operands is 2, combination_type is set; this is used by the conversion handling routines when
     2377*   determining whether an explicit conversion should be generated.  An operand = to 0, representing
     2378*   the accumulated current dimension in a subscript calculation, is arbitrarily assigned a
     2379*   data_type of 0 */
     2380 
     2381 	do i = 1 to number;
     2382 	     n = stack (work_stack_offset - number - 2 + i);
     2383 	     if n < 0				/*   count   */
     2384 	     then rand_data_type (i) = int_mode;
     2385 	     else if n = 0
     2386 	     then rand_data_type (i) = 0;
     2387 	     else do;
     2388 		     r = addr (x (n));
     2389 		     rand_data_type (i) = r -> node.data_type;
     2390 		end;
     2391 	end;
     2392 	if number = 2
     2393 	then if rand_data_type (2) > cmpx_mode
     2394 	     then combination_type = 17;
     2395 	     else if rand_data_type (1) > cmpx_mode
     2396 	     then combination_type = 18;
     2397 	     else combination_type = 4 * (rand_data_type (2) - 1) + rand_data_type (1);
     2398 	return;
     2399      end get_data_type;
     2400 
     2401 bump_work_stack_offset:
     2402      proc (increment);
     2403 
     2404 dcl	increment		fixed bin (18);
     2405 
     2406 /* This was subroutinized to allow over and underflow checking. */
     2407 
     2408 	work_stack_offset = work_stack_offset + increment;
     2409 	if work_stack_offset < 0
     2410 	then call print_message (205);
     2411 	else if work_stack_offset > hbound (stack, 1)
     2412 	then call print_message (206, char (hbound (stack, 1)));
     2413 	return;
     2414      end bump_work_stack_offset;
     2415 
     2416 effectively_constant:
     2417      proc (offset, rand_no, value) returns (bit (1) aligned);
     2418 
     2419 dcl	(offset, rand_no, value)
     2420 			fixed bin (18);
     2421 dcl	r		ptr;
     2422 
     2423 /* effectively_constant checks to see if a given operand is either an integer constant, or a
     2424*   temporary which was generated by the unary negation of an integer constant.  If either case is
     2425*   true, it returns the effective positive or negative value in the third argument, and a function
     2426*   value of "1"b; otherwise, it returns a function value of "0"b.  in addition, if the operand was
     2427*   the result of negating a constant, it unchains the negate_op node from the quad chain and
     2428*   releases the temporary.  */
     2429 
     2430 	r = addr (x (stack (offset)));
     2431 	if rand_data_type (rand_no) ^= int_mode
     2432 	then return ("0"b);
     2433 	if rand_node_type (rand_no) = constant_node
     2434 	then do;
     2435 		unspec (value) = r -> constant.value;
     2436 		return ("1"b);
     2437 	     end;
     2438 
     2439 	if rand_node_type (rand_no) ^= temporary_node
     2440 	then return ("0"b);
     2441 
     2442 	r = addr (q (r -> temporary.output_by));
     2443 	if r -> operator.op_code ^= negate_op
     2444 	then return ("0"b);
     2445 	if addr (x (r -> operator.operand (1))) -> node.node_type ^= constant_node
     2446 	then return ("0"b);
     2447 
     2448 	unspec (value) = addr (x (r -> operator.operand (1))) -> constant.value;
     2449 	value = -value;
     2450 	if addr (x (r -> operator.output)) -> temporary.ref_count = 0
     2451 	then do;
     2452 		addr (x (r -> operator.output)) -> temporary.next = next_free_temp;
     2453 		next_free_temp = r -> operator.output;
     2454 		if r -> operator.next = 0
     2455 		then do;
     2456 			last_op_index, op_index = r -> operator.back;
     2457 			last_quad_p = addr (q (last_op_index));
     2458 			next_free_quad = last_quad_p -> operator.next;
     2459 			last_quad_p -> operator.next = 0;
     2460 		     end;
     2461 		else do;
     2462 			addr (q (r -> operator.next)) -> operator.back = r -> operator.back;
     2463 			addr (q (r -> operator.back)) -> operator.next = r -> operator.next;
     2464 		     end;
     2465 	     end;
     2466 	return ("1"b);
     2467      end effectively_constant;
     2468 
     2469 subscript_arith:
     2470      proc (n) returns (fixed bin (18));
     2471 
     2472 dcl	(data_type, n)	fixed bin (18);
     2473 
     2474 /* subscript_arith is used by the subscript processing routines instead of process_arith, to avoid
     2475*   recursion, which would be marvelously inconvenient in this case.  It is called with the stack
     2476*   containing (<>) <binary op> <operand> <operand> <...>, or (<>) <unary op> <operand> <...>
     2477*   It creates an appropriate operator node, with conversion made explicit if appropriate, generates an
     2478*   output temp to place into the node, and places the output temp into the stack as its result.
     2479*   The stack becomes (<>) <result> <...> */
     2480 
     2481 	call get_data_type (n);
     2482 	if n = 2
     2483 	then call conversion;
     2484 	op_index = create_operator (n);
     2485 	if n = 1
     2486 	then data_type = rand_data_type (1);
     2487 	else data_type = max (rand_data_type (1), rand_data_type (2));
     2488 	return (create_temporary (data_type));
     2489      end subscript_arith;
     2490 
     2491 get_node_type:
     2492      proc (number);
     2493 
     2494 dcl	(i, n, number)	fixed bin (18);
     2495 dcl	r		ptr;
     2496 
     2497 /* get_node_type is called with a stack of the form (<>) <operator> {<operand>} <...> and an
     2498*   argument giving the number of operands.  The first (i.e.  leftmost) operand is the one deepest
     2499*   in the stack.  get_node_type returns the node types of the operands in the array rand_node_type.
     2500*   An operand of 0, representing the accumulated current dimension, is arbitrarily given a
     2501*   node_type of 0.  */
     2502 
     2503 	do i = 1 to number;
     2504 	     n = stack (work_stack_offset - number - 2 + i);
     2505 	     if n = 0
     2506 	     then rand_node_type (i) = 0;
     2507 	     else do;
     2508 		     r = addr (x (n));
     2509 		     rand_node_type (i) = r -> node.node_type;
     2510 		end;
     2511 	end;
     2512 	return;
     2513      end get_node_type;
     2514 
     2515 compress_subscript:
     2516      proc ();
     2517 
     2518 /* compress_subscript is called when an operation must be evaluated which forces some reduction in
     2519*   the accumulated current dimension, so that it can take part in the evaluation.  It is normally
     2520*   called with the stack containing (<>) <operator> <operand1> <operand2> <...>, where one of the
     2521*   two operands is 0, indicating that the accumulated current dimension is to be used.  The return
     2522*   stack depends on the value of <operator>.  If operator is +, -, *, or / then the stack is
     2523*   cleaned off to (<>) <...>; otherwise, the returned stack is identical to the calling stack
     2524*   except that the operand which was 0 is replaced by a temp indicating the result of evaluating
     2525*   accumulated current dimension. */
     2526 
     2527 /* If dim.mult is = 1, there's no need to multiply .  Stuff dim.temp into 0 operand position. */
     2528 
     2529 	if sub_stack.dim.mult = 1
     2530 	then stack (work_stack_offset - 1 - true_rand) = sub_stack.dim.temp;
     2531 
     2532 /* If dim.mult is -1, use negate rather than mult.  Then stuff negate_op result into 0 operand position. */
     2533 
     2534 	else if sub_stack.dim.mult = -1
     2535 	then do;
     2536 		stack (work_stack_offset) = sub_stack.dim.temp;
     2537 		stack (work_stack_offset + 1) = negate_op;
     2538 		call bump_work_stack_offset (+2);
     2539 		tkx = work_stack_offset - 3 - true_rand;
     2540 		stack (tkx) = subscript_arith (1);
     2541 	     end;
     2542 
     2543 /* Otherwise, generate mult_op node for <dim.mult>*<dim.temp>, and stuff the result into 0 operand place. */
     2544 
     2545 	else do;
     2546 		stack (work_stack_offset) = sub_stack.dim.temp;
     2547 		stack (work_stack_offset + 1) = create_integer_constant ((sub_stack.dim.mult));
     2548 		stack (work_stack_offset + 2) = mult_op;
     2549 		call bump_work_stack_offset (+3);
     2550 		tkx = work_stack_offset - 4 - true_rand;
     2551 		stack (tkx) = subscript_arith (2);
     2552 	     end;
     2553 
     2554 /* Reset dim.mult. */
     2555 
     2556 	sub_stack.dim.mult = 1;
     2557 
     2558 /* If the operator is not add or subtract, then add in the offset, if any, to what's been
     2559*   calculated so far, and stick this new total result temp into the original 0 result place.  Reset
     2560*   dim.offset to 0. */
     2561 
     2562 	if stack (work_stack_offset - 1) ^= add_op | stack (work_stack_offset - 1) ^= sub_op
     2563 	then do;
     2564 		if sub_stack.dim.offset ^= 0
     2565 		then do;
     2566 			stack (work_stack_offset) = stack (work_stack_offset - 1 - true_rand);
     2567 			stack (work_stack_offset + 1) =
     2568 			     create_integer_constant ((sub_stack.dim.offset));
     2569 			stack (work_stack_offset + 2) = add_op;
     2570 			call bump_work_stack_offset (+3);
     2571 			tkx = work_stack_offset - 4 - true_rand;
     2572 			stack (tkx) = subscript_arith (2);
     2573 		     end;
     2574 		sub_stack.dim.offset = 0;
     2575 	     end;
     2576 
     2577 /* Now, if this is one of the basic 4 ops, generate a node for it, and stuff the result into dim.temp. */
     2578 
     2579 	if stack (work_stack_offset - 1) >= add_op & stack (work_stack_offset - 1) <= div_op
     2580 	then sub_stack.dim.temp = subscript_arith (2);
     2581 	return;
     2582      end compress_subscript;
     2583 
     2584 initialize_subscript:
     2585      procedure (symbol_ptr);
     2586 
     2587 /* initialize_subscript is called at the beginning of subscript processing to
     2588*   initialize the array's dimension information.  It computes the dimension
     2589*   sizes if they are constant, and allocates symbols for them if they are not.
     2590*   It computes the virtual origin if it is constant, and allocates a possibly
     2591*   shared symbol for it if it is not. */
     2592 
     2593 dcl	symbol_ptr	pointer;
     2594 
     2595 dcl	(s, d)		pointer;
     2596 dcl	(i, ndims)	fixed binary (3);
     2597 dcl	(sum, multiplier)	fixed binary (24);
     2598 
     2599 	s = symbol_ptr;
     2600 	d = addr (x (s -> symbol.dimension));
     2601 	ndims = d -> dimension.number_of_dims;
     2602 
     2603 	if ^d -> dimension.has_dim_sizes
     2604 	then do;
     2605 		do i = 1 to ndims - binary (d -> dimension.assumed_size, 1);
     2606 		     if string (d -> dimension.v_bound (i)) = "00"b
     2607 		     then d -> dimension.size (i) = d -> dimension.upper_bound (i)
     2608 			     - d -> dimension.lower_bound (i) + 1;
     2609 		     else if ^d -> dimension.v_bound (i).lower
     2610 			& d -> dimension.lower_bound (i) = 1
     2611 		     then d -> dimension.size (i) = d -> dimension.upper_bound (i);
     2612 		     else d -> dimension.size (i) = create_dim_size_var (d, i);
     2613 		end;
     2614 		d -> dimension.has_dim_sizes = "1"b;
     2615 	     end;
     2616 
     2617 	if ^d -> dimension.has_virtual_origin
     2618 	then do;
     2619 		if s -> symbol.star_extents
     2620 		then do;
     2621 
     2622 /* Star extent character arrays may not share virtual origins with any other
     2623*   arrays.  Always create a new symbol for the virtual origin. */
     2624 
     2625 			d -> dimension.virtual_origin = create_var ();
     2626 			d -> dimension.variable_virtual_origin = "1"b;
     2627 		     end;
     2628 
     2629 		else do;
     2630 
     2631 /* Try to compute the virtual origin.  If it turns out to be constant, there is
     2632*   no need to create a variable for it.  If it isn't constant, we try to share
     2633*   the virtual origin symbol with other arrays that have the same shape. */
     2634 
     2635 			sum = 0;
     2636 			multiplier = s -> symbol.element_size;
     2637 
     2638 			do i = 1 to ndims - 1 while (d -> dimension.virtual_origin = 0);
     2639 			     if string (d -> dimension.v_bound (i)) = "00"b
     2640 			     then do;
     2641 				     sum = sum + multiplier * d -> dimension.lower_bound (i);
     2642 				     multiplier = multiplier * d -> dimension.size (i);
     2643 				end;
     2644 			     else do;
     2645 				     d -> dimension.virtual_origin = create_virtual_origin_var (s);
     2646 				     d -> dimension.variable_virtual_origin = "1"b;
     2647 				end;
     2648 			end;
     2649 
     2650 			if d -> dimension.virtual_origin = 0
     2651 			then if ^d -> dimension.v_bound (ndims).lower
     2652 			     then d -> dimension.virtual_origin =
     2653 				     sum + multiplier * d -> dimension.lower_bound (ndims);
     2654 			     else do;
     2655 				     d -> dimension.virtual_origin = create_virtual_origin_var (s);
     2656 				     d -> dimension.variable_virtual_origin = "1"b;
     2657 				end;
     2658 		     end;
     2659 		d -> dimension.has_virtual_origin = "1"b;
     2660 	     end;
     2661 
     2662      end initialize_subscript;
     2663 
     2664 process_builtin:
     2665      proc ();
     2666 
     2667 dcl	(bif_index, char_size, data_type, gen_bif_index, i)
     2668 			fixed bin (18);
     2669 dcl	op_p		pointer;
     2670 
     2671 dcl	char_bif		fixed bin (18) static options (constant) init (65);
     2672 
     2673 /* process_builtin is called to process builtin function references.  When it is called the stack
     2674*   contains (<>) {<args>} <count> <function_id> <...>.  It creates an appropriate builtin function
     2675*   node with an output temporary, cleans out the stack, adds the temp, and returns with stack
     2676*   containing (<>) <output_temp> <...> */
     2677 
     2678 	bif_index = addr (x (stack (eol_stack.work_stack_offset - 1))) -> symbol.char_size;
     2679 
     2680 /* If the builtin name is a generic name, we must determine which actual function to use.	*/
     2681 
     2682 	if fort_data$builtin_name.description (bif_index).generic_name
     2683 	then do;
     2684 		data_type = 0;
     2685 
     2686 /* for generics, set the desired function data type to the max data type of its args. */
     2687 
     2688 		do i = eol_stack.work_stack_offset + 1 to work_stack_offset - 2;
     2689 		     data_type = max (data_type, addr (x (stack (i))) -> node.data_type);
     2690 		end;
     2691 
     2692 /* Now choose the appropriate specific func by using data_type as subscript. */
     2693 
     2694 		gen_bif_index = bif_index;
     2695 		if data_type < 1 | data_type > 4
     2696 		then bif_index = 0;
     2697 		else bif_index = fort_data$builtin_name.description (gen_bif_index).generic_func (data_type);
     2698 
     2699 /* If an appropriate specific does not exist, we'll just use the one with the highest data type. */
     2700 
     2701 		do i = 4 to 1 by -1 while (bif_index = 0);
     2702 		     bif_index = fort_data$builtin_name.description (gen_bif_index).generic_func (i);
     2703 		     data_type = i;
     2704 		end;
     2705 
     2706 /* As usual, if any args need conversion to/from integer, we'll make them explicit. */
     2707 
     2708 		do i = eol_stack.work_stack_offset + 1 to work_stack_offset - 2;
     2709 		     if addr (x (stack (i))) -> node.data_type ^= data_type
     2710 		     then if addr (x (stack (i))) -> node.data_type = int_mode | data_type = int_mode
     2711 			then do;
     2712 				stack (work_stack_offset) = stack (i);
     2713 				stack (work_stack_offset + 1) = convert_to_int_op + data_type - 1;
     2714 				call bump_work_stack_offset (+2);
     2715 				op_index = create_operator (1);
     2716 				stack (i) = create_temporary (data_type);
     2717 			     end;
     2718 		end;
     2719 	     end;
     2720 
     2721 /* now we can create the builtin node and set up the output temp.  process_eol_stack also pops the
     2722*   associated eol_stack entry. */
     2723 
     2724 	call process_eol_stack (1, 2);
     2725 	stack (work_stack_offset) = create_temporary (fort_data$builtin_name.description (bif_index).result_type);
     2726 	call bump_work_stack_offset (+1);
     2727 
     2728 /* If this is the CHAR builtin, we have to set the length field of the output
     2729*   temporary, or else the code generator will get confused. */
     2730 
     2731 	if bif_index = char_bif
     2732 	then temp_ptr -> temporary.length = 1;
     2733 
     2734 	return;
     2735 
     2736      end process_builtin;
     2737 
     2738 process_lhs_fld:
     2739      proc ();
     2740 
     2741 /*  Called with the top of the stack (<>) <lhs_fld> <right_hand_value>
     2742*    <argument3> <argument2> <argument1> <...>  Increments the reference
     2743*    count on the target argument (argument 3) if it is an array_ref.
     2744*    Makes the lhs_fld node, and then cleans out the stack, leaving
     2745*    (<> <...> */
     2746 
     2747 dcl	target		fixed bin (18);
     2748 
     2749 	if stack (work_stack_offset - 3) > last_assigned_op
     2750 	then if addr (x (stack (work_stack_offset - 3))) -> node.node_type = array_ref_node
     2751 	     then addr (x (stack (work_stack_offset - 3))) -> array_ref.ref_count =
     2752 		     addr (x (stack (work_stack_offset - 3))) -> array_ref.ref_count + 1;
     2753 
     2754 /* Make the lhs_fld node; set the output to the third argument. */
     2755 
     2756 	target = stack (work_stack_offset - 3);
     2757 	stack (work_stack_offset - 3) = stack (work_stack_offset - 2);
     2758 	stack (work_stack_offset - 2) = stack (work_stack_offset - 1);
     2759 	call bump_work_stack_offset (-1);
     2760 	op_index = create_operator (3);
     2761 	last_quad_p -> operator.output = target;
     2762 	return;
     2763      end process_lhs_fld;
     2764 
     2765 push_eol_stack:
     2766      proc ();
     2767 
     2768 	call bump_work_stack_offset (-1);
     2769 	eol_stack_p = addr (w (first_free_object));
     2770 	first_free_object = first_free_object + size (eol_stack);
     2771 	if first_free_object > operand_max_len
     2772 	then call print_message (202, "eol_stack");
     2773 	eol_stack.last = eol_offset;
     2774 	eol_offset = first_free_object - size (eol_stack);
     2775 	eol_stack.op = stack (work_stack_offset);
     2776 	eol_stack.work_stack_offset = work_stack_offset - 1;
     2777 	suspend_subscript = (eol_stack.op ^= subscript_op);
     2778 	return;
     2779      end push_eol_stack;
     2780 
     2781 process_eol_stack:
     2782      proc (units_per_item, extra_units);
     2783 
     2784 dcl	(units_per_item, extra_units)
     2785 			fixed bin (18);
     2786 
     2787 	stack (work_stack_offset - 1) = eol_stack.op;
     2788 	op_index = create_operator (units_per_item * (stack (eol_stack.work_stack_offset) + bias) + extra_units);
     2789 	call pop_eol_stack ();
     2790 	return;
     2791      end process_eol_stack;
     2792 
     2793 pop_eol_stack:
     2794      proc ();
     2795 
     2796 	eol_offset = eol_stack.last;
     2797 	unspec (eol_stack) = "0"b;
     2798 	eol_stack_p = addr (w (eol_offset));
     2799 	call new_free_object ();
     2800 	if eol_offset = 0
     2801 	then suspend_subscript = "0"b;
     2802 	else suspend_subscript = (eol_stack.op ^= subscript_op);
     2803 	return;
     2804      end pop_eol_stack;
     2805 
     2806 /* The hold stack is used when processing operators, such as logical jumps, which cannot be
     2807*   completely processed until the next statement node has been found.  push_hold_stack adds an
     2808*   entry to the hold_stack list, and pop_hold_stack deletes one.  */
     2809 
     2810 push_hold_stack:
     2811      proc ();
     2812 
     2813 	hold_stack_p = addr (w (first_free_object));
     2814 	first_free_object = first_free_object + size (hold_stack);
     2815 	if first_free_object > operand_max_len
     2816 	then call print_message (202, "hold_stack");
     2817 	hold_stack.last = hold_offset;
     2818 	hold_offset = first_free_object - size (hold_stack);
     2819 	return;
     2820      end push_hold_stack;
     2821 
     2822 pop_hold_stack:
     2823      proc ();
     2824 
     2825 	hold_offset = hold_stack.last;
     2826 	unspec (hold_stack) = "0"b;
     2827 	hold_stack_p = addr (w (hold_offset));
     2828 	call new_free_object ();
     2829 	return;
     2830      end pop_hold_stack;
     2831 
     2832 /* The sub_stack is used to contain special information needed for processing sub_script operators.
     2833*   push_sub_stack adds an entry to the sub_stack list, pop_sub_stack removes one.  */
     2834 
     2835 push_sub_stack:
     2836      proc ();
     2837 
     2838 	sub_stack_p = addr (w (first_free_object));
     2839 	first_free_object = first_free_object + size (sub_stack);
     2840 	if first_free_object > operand_max_len
     2841 	then call print_message (202, "sub_stack");
     2842 	sub_stack.last = sub_offset;
     2843 	sub_offset = first_free_object - size (sub_stack);
     2844 	sub_stack.nested = subscript_processing;
     2845 	return;
     2846      end push_sub_stack;
     2847 
     2848 pop_sub_stack:
     2849      proc ();
     2850 	subscript_processing = sub_stack.nested;
     2851 	sub_offset = sub_stack.last;
     2852 	unspec (sub_stack) = "0"b;
     2853 	sub_stack_p = addr (w (sub_offset));
     2854 	call new_free_object ();
     2855 	return;
     2856      end pop_sub_stack;
     2857 
     2858 /* The exit_stack is used when processing a semantic construct which is expected to be terminated
     2859*   by an exit_op.  push_exit_stack is called when the basic operator is found, to create an
     2860*   exit_stack entry.  When the corresponding exit_op has been found and the processing completed,
     2861*   pop_exit_stack is called to pop the entry.  */
     2862 
     2863 push_exit_stack:
     2864      proc ();
     2865 
     2866 	exit_stack_p = addr (w (first_free_object));
     2867 	first_free_object = first_free_object + size (exit_stack);
     2868 	if first_free_object > operand_max_len
     2869 	then call print_message (202, "exit_stack");
     2870 	exit_stack.last = exit_offset;
     2871 	exit_offset = first_free_object - size (exit_stack);
     2872 	return;
     2873      end push_exit_stack;
     2874 
     2875 pop_exit_stack:
     2876      proc ();
     2877 
     2878 	exit_offset = exit_stack.last;
     2879 	unspec (exit_stack) = "0"b;
     2880 	exit_stack_p = addr (w (exit_offset));
     2881 	call new_free_object ();
     2882 	return;
     2883      end pop_exit_stack;
     2884 
     2885 /* The sf_stack is used when processing a statement function invocation, to keep track of the
     2886*   various arguments and other such information.  The stack is needed to handle nested definitions
     2887*   and invocations.  push_sf_stack creates and initializes the sf_stack entry, when the sf_ref node
     2888*   is found.  The count and sf id are remembered and taken from the work stack.  pop_sf_stack is
     2889*   called to clear an entry from the sf_stack list.  */
     2890 
     2891 push_sf_stack:
     2892      proc ();
     2893 
     2894 	sf_stack_p = addr (w (first_free_object));
     2895 	sf_num_args = stack (work_stack_offset - 1) + bias;
     2896 	first_free_object = first_free_object + size (sf_stack);
     2897 	if first_free_object > operand_max_len
     2898 	then call print_message (202, "sf_stack");
     2899 	sf_stack.last = sf_offset;
     2900 	sf_offset = first_free_object - size (sf_stack);
     2901 	sf_stack.sf = stack (work_stack_offset - 2);
     2902 	sf_stack.def_chain = addr (x (sf_stack.sf));
     2903 	sf_stack.current_arg = 1;
     2904 	sf_stack.num_args = sf_num_args;
     2905 	sf_stack.arg_info (sf_stack.current_arg).chain_start = last_op_index;
     2906 	sf_stack.cur_sf_param = sf_stack.def_chain -> symbol.next_member;
     2907 	call bump_work_stack_offset (-2);
     2908 	return;
     2909      end push_sf_stack;
     2910 
     2911 pop_sf_stack:
     2912      proc ();
     2913 
     2914 	sf_offset = sf_stack.last;
     2915 	sf_num_args = sf_stack.num_args;
     2916 	unspec (sf_stack) = "0"b;
     2917 	sf_stack_p = addr (w (sf_offset));
     2918 	call new_free_object ();
     2919 	return;
     2920      end pop_sf_stack;
     2921 
     2922 /* the virtual origin list is used as an optimizing feature.  
     2923*   there are three routines associated with it:
     2924*	1. an add_link routine
     2925*	2. a free chain routine- called after each subprog is processed
     2926*	3. a routine to scan the list to determine if another link need be
     2927*	inserted or if the virtual origin can occur. */
     2928 
     2929 get_virtual_origin_link:
     2930      proc;
     2931 
     2932 /* like the push-pop subrs, this adds a link to the chain, the head of which 
     2933*    is the last link created */
     2934 
     2935 	virtual_origin_base, virtual_origin_list_ptr = addr (w (first_free_object));
     2936 	first_free_object = first_free_object + size (virtual_origin_list);
     2937 	if first_free_object > operand_max_len
     2938 	then call print_message (202, "virtual_origin_list");
     2939 	virtual_origin_list.last = virtual_origin_offset;
     2940 	virtual_origin_offset = first_free_object - size (virtual_origin_list);
     2941      end get_virtual_origin_link;
     2942 
     2943 free_virtual_origin_list:
     2944      proc;
     2945 
     2946 /* unlike the other pop-push routines, the virtual origin list grows during 
     2947*    the processing of one subprogram.  Hence we don't pop when finished with
     2948*    an item, but free the entire list at the end of the subprog. */
     2949 
     2950 	do while (virtual_origin_offset ^= 0);
     2951 	     virtual_origin_offset = virtual_origin_list.last;
     2952 	     unspec (virtual_origin_list) = "0"b;
     2953 	     virtual_origin_list_ptr = addr (w (virtual_origin_offset));
     2954 	     call new_free_object ();
     2955 	end /* loop */;
     2956 	virtual_origin_base = virtual_origin_list_ptr;
     2957 	return;
     2958      end free_virtual_origin_list;
     2959 
     2960 /* The block_if_stack is used to remember important details about block IF
     2961*   statements.  Entries are pushed on the block_if_stack when a block_if_op
     2962*   is encountered in the polish; entries are popped (after the corresponding
     2963*   ENDIF statement has been reached) by process_hold_stack_entry. */
     2964 
     2965 push_block_if_stack:
     2966      procedure ();
     2967 
     2968 	block_if_stack_p = addr (w (first_free_object));
     2969 	first_free_object = first_free_object + size (block_if_stack);
     2970 	if first_free_object > operand_max_len
     2971 	then call print_message (202, "block_if_stack");
     2972 	block_if_stack.last = block_if_offset;
     2973 	block_if_stack.n_clauses = block_if_clause_count;
     2974 	block_if_offset = first_free_object - size (block_if_stack);
     2975 	return;
     2976 
     2977      end push_block_if_stack;
     2978 
     2979 pop_block_if_stack:
     2980      procedure ();
     2981 
     2982 	block_if_offset = block_if_stack.last;
     2983 	unspec (block_if_stack) = "0"b;
     2984 	block_if_stack_p = addr (w (block_if_offset));
     2985 	call new_free_object ();
     2986 	return;
     2987 
     2988      end pop_block_if_stack;
     2989 
     2990 /* The dim_size_list is used in the sharing of dimension size variables.
     2991*   It is similar to the virtual_origin_list in that new entries are allocated
     2992*   during the processing of a subprogram, and all entries are deleted at the
     2993*   end of each subprogram. */
     2994 
     2995 get_dim_size_link:
     2996      procedure ();
     2997 
     2998 	dim_size_list_ptr = addr (w (first_free_object));
     2999 	first_free_object = first_free_object + size (dim_size_list);
     3000 	if first_free_object > operand_max_len
     3001 	then call print_message (202, "dim_size_list");
     3002 	dim_size_list.last = dim_size_offset;
     3003 	dim_size_offset = first_free_object - size (dim_size_list);
     3004 
     3005      end get_dim_size_link;
     3006 
     3007 
     3008 free_dim_size_list:
     3009      procedure ();
     3010 
     3011 	do while (dim_size_offset ^= 0);
     3012 	     dim_size_offset = dim_size_list.last;
     3013 	     unspec (dim_size_list) = "0"b;
     3014 	     dim_size_list_ptr = addr (w (dim_size_offset));
     3015 	     call new_free_object ();
     3016 	end;
     3017 
     3018      end free_dim_size_list;
     3019 
     3020 create_virtual_origin_var:
     3021      proc (symbol_ptr) returns (fixed binary (18));
     3022 
     3023 /* procedure to allow sharing of variables for arrays with identical virtual 
     3024*    origins which have:
     3025*	1. the same element size in the same units
     3026*	2. the same number of dimensions
     3027*	3. the same lower bounds in all dimensions
     3028*	4. the same upper bounds in all dimensions but the last. */
     3029 
     3030 declare	symbol_ptr	pointer /* ptr to the symbol for which a v_o is needed */;
     3031 
     3032 declare	elem_size		fixed bin (17);
     3033 declare	elem_units	fixed bin (17);
     3034 declare	dim_node		pointer;
     3035 declare	num_dims		fixed bin (17);
     3036 declare	vo_sharable	bit (1);
     3037 declare	this_array	pointer;
     3038 declare	this_dim_node	pointer;
     3039 declare	this_vo_var	fixed bin (18);
     3040 
     3041 	elem_size = symbol_ptr -> symbol.element_size;
     3042 	elem_units = symbol_ptr -> symbol.units;
     3043 	dim_node = addr (x (symbol_ptr -> symbol.dimension));
     3044 	num_dims = dim_node -> dimension.number_of_dims;
     3045 	virtual_origin_list_ptr = virtual_origin_base;
     3046 
     3047 /* scan thru the list of virtual origins, which have already been assigned
     3048*    and are potentially sharable.  If it matches present symbol in elem_size and 
     3049*     elem_units then explore the dim node. */
     3050 
     3051 	do while (virtual_origin_list_ptr ^= addr (w (0)));
     3052 	     if elem_size = virtual_origin_list.element_size
     3053 		& num_dims = virtual_origin_list.numb_of_dims
     3054 		& elem_units = virtual_origin_list.units
     3055 	     then do;				/* an examination of the dim_node */
     3056 		     this_array = virtual_origin_list.symbol_node;
     3057 		     this_dim_node = addr (x (this_array -> symbol.dimension));
     3058 		     vo_sharable =
     3059 			(dim_node -> dimension.lower_bound (num_dims)
     3060 			= this_dim_node -> dimension.lower_bound (num_dims))
     3061 			& (dim_node -> dimension.v_bound (num_dims).lower
     3062 			= this_dim_node -> dimension.v_bound (num_dims).lower);
     3063 		     do i = 1 to num_dims - 1 while (vo_sharable);
     3064 			if string (dim_node -> dimension.v_bound (i))
     3065 			     ^= string (this_dim_node -> dimension.v_bound (i))
     3066 			     | dim_node -> dimension.lower_bound (i) ^= this_dim_node -> dimension.lower_bound (i)
     3067 			     | dim_node -> dimension.upper_bound (i) ^= this_dim_node -> dimension.upper_bound (i)
     3068 			then vo_sharable = "0"b;
     3069 		     end;
     3070 
     3071 		     if vo_sharable
     3072 		     then do;
     3073 			     virtual_origin_list_ptr = virtual_origin_base;
     3074 			     return (this_dim_node -> dimension.virtual_origin);
     3075 			end;
     3076 		end /*further calculation */;
     3077 	     virtual_origin_list_ptr = addr (w (virtual_origin_list.last));
     3078 	end /* walk thru list of previously assigned vo's */;
     3079 
     3080 /* At this point, this array can not share a vo with any other.
     3081*   So, add its characteristics to the list, create a new variable,
     3082*   and then return. */
     3083 
     3084 	this_vo_var = create_var ();
     3085 	call get_virtual_origin_link ();
     3086 	virtual_origin_list.element_size = elem_size;
     3087 	virtual_origin_list.symbol_node = symbol_ptr;
     3088 	virtual_origin_list.numb_of_dims = num_dims;
     3089 	virtual_origin_list.units = elem_units;
     3090 	virtual_origin_list_ptr = virtual_origin_base;
     3091 	return (this_vo_var);
     3092      end create_virtual_origin_var;
     3093 
     3094 create_dim_size_var:
     3095      procedure (dim_p, dim_no) returns (fixed binary (24));
     3096 
     3097 /* This procedure attempts to share variables that are created for dimension
     3098*   sizes.  The dim_size_list is scanned for a variable which could represent
     3099*   the size of the dimension described by dim_p and dim_no.  If such a variable
     3100*   is found, it is returned.  Otherwise, a new variable is created, added to
     3101*   the dim_size_list, and returned. */
     3102 
     3103 dcl	(dim_p, d, p)	pointer;
     3104 dcl	(dim_no, i)	fixed binary (3);
     3105 
     3106 	d = dim_p;
     3107 	i = dim_no;
     3108 
     3109 	do p = dim_size_list_ptr repeat (addr (w (p -> dim_size_list.last)))
     3110 	     while (p ^= addr (w (0)));
     3111 
     3112 	     if string (d -> dimension.v_bound (i)) = string (p -> dim_size_list.var)
     3113 	     then if d -> dimension.lower_bound (i) = p -> dim_size_list.lower_bound
     3114 		then if d -> dimension.upper_bound (i) = p -> dim_size_list.upper_bound
     3115 		     then return (p -> dim_size_list.size);
     3116 
     3117 	end;
     3118 
     3119 	call get_dim_size_link ();
     3120 	string (dim_size_list.var) = string (d -> dimension.v_bound (i));
     3121 	dim_size_list.lower_bound = d -> dimension.lower_bound (i);
     3122 	dim_size_list.upper_bound = d -> dimension.upper_bound (i);
     3123 	dim_size_list.size = create_var ();
     3124 
     3125 	return (dim_size_list.size);
     3126 
     3127      end create_dim_size_var;
     3128 
     3129 new_free_object:
     3130      proc ();
     3131 
     3132 /* new_free_object is called by the pop_???_stack goodies, since they all make their linked lists
     3133*   in the same segment.  It is a quick and dirty way of making sure that the stack area is kept at
     3134*   a minimal size.  */
     3135 
     3136 	first_free_object =
     3137 	     max (sf_offset, exit_offset, eol_offset, hold_offset, sub_offset, virtual_origin_offset, block_if_offset,
     3138 	     dim_size_offset);
     3139 	if first_free_object = 0
     3140 	then first_free_object = 1;
     3141 	else if first_free_object = sf_offset
     3142 	then first_free_object = sf_offset + currentsize (sf_stack);
     3143 	else if first_free_object = exit_offset
     3144 	then first_free_object = exit_offset + currentsize (exit_stack);
     3145 	else if first_free_object = eol_offset
     3146 	then first_free_object = eol_offset + currentsize (eol_stack);
     3147 	else if first_free_object = hold_offset
     3148 	then first_free_object = hold_offset + currentsize (hold_stack);
     3149 	else if first_free_object = sub_offset
     3150 	then first_free_object = sub_offset + currentsize (sub_stack);
     3151 	else if first_free_object = virtual_origin_offset
     3152 	then first_free_object = virtual_origin_offset + currentsize (virtual_origin_list);
     3153 	else if first_free_object = block_if_offset
     3154 	then first_free_object = block_if_offset + currentsize (block_if_stack);
     3155 	else if first_free_object = dim_size_offset
     3156 	then first_free_object = dim_size_offset + currentsize (dim_size_list);
     3157 
     3158 	return;
     3159      end new_free_object;
     3160 
     3161 conversion:
     3162      proc ();
     3163 
     3164 /* conversion is called with a stack of the form (<>) <some operator> <arg2> <arg1> <...> It checks
     3165*   to see if one, but not both, of the args is an integer, and if so generates an explicit
     3166*   conversion node to convert it to the same data type as the other argument, and replaces it in
     3167*   the stack with the output temp of the convert node.  The stack is returned in the same form as
     3168*   it was received.  */
     3169 
     3170 dcl	arg_no		fixed bin (18);
     3171 
     3172 	if combination_type >= 17
     3173 	then return;
     3174 	if rand_data_type (1) = int_mode
     3175 	then if rand_data_type (2) = int_mode
     3176 	     then return;
     3177 	     else arg_no = 1;
     3178 	else if rand_data_type (2) = int_mode
     3179 	then arg_no = 2;
     3180 	else return;
     3181 
     3182 	stack (work_stack_offset) = stack (work_stack_offset - 4 + arg_no);
     3183 	stack (work_stack_offset + 1) = convert_to_int_op - 1 + rand_data_type (3 - arg_no);
     3184 	call bump_work_stack_offset (+2);
     3185 	op_index = create_operator (1);
     3186 	stack (work_stack_offset - 4 + arg_no) = create_temporary (rand_data_type (3 - arg_no));
     3187 	return;
     3188      end conversion;
     3189 
     3190 process_sf:
     3191      proc ();
     3192 
     3193 /* process_sf is called when we hit the eol_op terminating the polish entries for a
     3194*   statement_function invocation.  At this point the arguments for this invocation have all been
     3195*   processed and are held in the sf_stack entry, along with information about where in the quad
     3196*   chain the quads needed to evaluate any arguments which required calculation or conversion were
     3197*   put.  process_sf performs certain diddles so that the actual expansion of the statement function
     3198*   can be handled by the normal operator processing programs. */
     3199 
     3200 /* First check to see if the proper number of args were supplied.  If not, we'll print an error
     3201*   message and simply replace the whole sf evaluation with an uninitialized temp to allow continued
     3202*   processing for further error checking. */
     3203 
     3204 	if sf_stack.num_args ^= sf_stack.def_chain -> symbol.char_size
     3205 	then do;
     3206 		if sf_stack.num_args < sf_stack.def_chain -> symbol.char_size
     3207 		then call print_message (307, sf_stack.sf);
     3208 		else if sf_stack.num_args > sf_stack.def_chain -> symbol.char_size
     3209 		then call print_message (308, sf_stack.sf);
     3210 		call pop_eol_stack ();
     3211 		stack (work_stack_offset) = last_quad_p -> operator.output;
     3212 		stack (work_stack_offset - 1) = create_temporary ((sf_stack.def_chain -> symbol.data_type));
     3213 		last_quad_p -> operator.output = stack (work_stack_offset);
     3214 		call pop_sf_stack ();
     3215 		return;
     3216 	     end;
     3217 
     3218 /* Otherwise, if everything seems ok, we'll push an exit_stack entry, since sf definitions are
     3219*   terminated by an exit_op, toss the eol_stack entry, and force expansion of the sf code by
     3220*   remembering the current location in the polish stack (polish_offset) in the sf_stack, and
     3221*   resetting the polish pointer to refer to the first polish entry of the statement function
     3222*   definition.  When the exit_op is seen, polish_offset will be restored from the sf_stack, and the
     3223*   sf_result will be in the work stack. */
     3224 
     3225 	else do;
     3226 		call push_exit_stack ();
     3227 		exit_stack.op = sf_op;
     3228 		exit_stack.count = sf_stack.num_args;
     3229 		sf_stack.polish_offset = polish_offset;
     3230 		call pop_eol_stack ();
     3231 		call bump_work_stack_offset (-1);
     3232 		polish_offset = sf_stack.def_chain -> symbol.initial - 1;
     3233 	     end;
     3234 	return;
     3235      end process_sf;
     3236 
     3237 rechain_arg:
     3238      proc (sf_ptr, sf_entry);
     3239 
     3240 dcl	(sf_entry, start, stop)
     3241 			fixed bin (18);
     3242 dcl	(start_p, sf_ptr, stop_p)
     3243 			ptr;
     3244 
     3245 /* rechain_arg is called if a substitution has to be made for a statement_function dummy variable,
     3246*   and sf_stack.chain_start and chain_end for the associated value are non-zero.  This indicates
     3247*   that some quads had to be genrated to evaluate the variable, and that the variable has not yet
     3248*   been used.  It was decided to be desirable not to evaluate such arguments until immediately
     3249*   before they are used, so rechain_arg unchains the argument evaluation from the place in the
     3250*   chain where it was first generated, and rechains it at the current top of the chain.  It then
     3251*   resets chain_start and end to inhibit this action if the arg is used again.  A check is made
     3252*   first to make sure that the argument is not already the last thing on the quad chain.  */
     3253 
     3254 	start = sf_ptr -> sf_stack.arg_info (sf_entry).chain_start;
     3255 	stop = sf_ptr -> sf_stack.arg_info (sf_entry).chain_end;
     3256 	if stop ^= last_op_index
     3257 	then do;
     3258 		stop_p = addr (q (stop));
     3259 		start_p = addr (q (start));
     3260 		addr (q (start_p -> operator.back)) -> operator.next = stop_p -> operator.next;
     3261 		if stop_p -> operator.next ^= 0
     3262 		then addr (q (stop_p -> operator.next)) -> operator.back = start_p -> operator.back;
     3263 		addr (q (last_op_index)) -> operator.next = start;
     3264 		start_p -> operator.back = last_op_index;
     3265 		stop_p -> operator.next = 0;
     3266 		last_op_index, op_index = stop;
     3267 		last_quad_p = addr (q (stop));
     3268 	     end;
     3269 	sf_ptr -> sf_stack.arg_info (sf_entry).chain_start, sf_ptr -> sf_stack.arg_info (sf_entry).chain_end = 0;
     3270 	return;
     3271      end rechain_arg;
     3272 
     3273 process_1_subscript:
     3274      proc ();
     3275 
     3276 dcl	constant_value	fixed bin (18);
     3277 dcl	big_offset	bit (1) aligned;
     3278 
     3279 /* process_1_subscript is called during subscript processing, when an item op is hit, signifying that
     3280*   a subscript has now been completely evaluated.  The top of the stack looks like
     3281*   (<>) <item_op> <subscript_value> <array_var> <...>
     3282*   process_1_subscript performs the necessary actions to incorporate the effect of the current
     3283*   subscript into the total accumulated subscript value.  If this is not the last subscript
     3284*   (dimension) the stack will be cleared off and returned as (<>) <array_var> <...>, and various
     3285*   initializations will be performed so the next dimension can be evaluated.  If this is the last
     3286*   dimension, process_1_subscript will create the opt_subscript_node and the array_ref temp, and
     3287*   will return the stack as (<>) <array_ref_node> <...> (For a discussion of the manner in which
     3288*   the subscript values are accumulated, see the comments to the process_arith subroutine.  */
     3289 
     3290 /* If the <subscript_value> is 0, it means that the actual value is the accumulated current
     3291*   dimension, and we're ok; otherwise, move it into the appropriate part of the accumulated current
     3292*   dimension, so we have a standard form for further processing.  */
     3293 
     3294 	if stack (work_stack_offset - 2) ^= 0
     3295 	then do;
     3296 		call get_data_type (1);
     3297 		call get_node_type (1);
     3298 		if effectively_constant (work_stack_offset - 2, 1, constant_value)
     3299 		then sub_stack.dim.offset = constant_value;
     3300 		else sub_stack.dim.temp = stack (work_stack_offset - 2);
     3301 		stack (work_stack_offset - 2) = 0;
     3302 	     end;
     3303 	call bump_work_stack_offset (-2);
     3304 
     3305 /* Now the subscript is in the accumulated current dimension of sub_stack, in the form
     3306*   dim.mult*dim.temp + dim.offset.  dim.mult and dim.offset are known to be integer data_types.  If
     3307*   dim.temp is not an integer, we will call compress_subscript to force the calculation now, and
     3308*   convert the result to an integer.  After this the subscript will be in the same form, but all 3
     3309*   parts will be known to be integers.  */
     3310 
     3311 	if sub_stack.dim.temp ^= 0
     3312 	then if addr (x (sub_stack.dim.temp)) -> node.data_type ^= int_mode
     3313 	     then do;
     3314 		     true_rand = -1;
     3315 		     call compress_subscript ();
     3316 		     stack (work_stack_offset + 1) = convert_to_int_op;
     3317 		     call bump_work_stack_offset (+2);
     3318 		     op_index = create_operator (1);
     3319 		     sub_stack.dim.temp = create_temporary ((int_mode));
     3320 		end;
     3321 
     3322 /* Now we want to multiply the current dimensions subscript which is represented as shown above
     3323*   (known to be integer) by the effective length of one element in this dimension (i.e the number
     3324*   of words in storage which would be represented by an increase of 1 in this dimension) which is
     3325*   represented by the expression element.var*element.constant both parts of which are known to be
     3326*   integers.  This section is a collection of special cases designed to allow as much of the
     3327*   computation as possible to be done at the time of compilation.
     3328*
     3329*   The result will be placed back into the dim.???  entries, leaving an expression in the same
     3330*   form, but which now represents a number of words of storage rather than a subscript.  Finally
     3331*   element.??  will be updated for the next dimension calculation.  */
     3332 
     3333 	if sub_stack.element.var ^= 0
     3334 	then do;
     3335 
     3336 /* if there is an element.var, but no dim.temp, then we simply set dim.mult equal to
     3337*   dim.offset*element.constant, put element.var into dim.temp, and set dim.offset to 0		*/
     3338 
     3339 		if sub_stack.dim.temp = 0
     3340 		then do;
     3341 			sub_stack.dim.mult = sub_stack.dim.offset * sub_stack.element.constant;
     3342 			sub_stack.dim.temp = sub_stack.element.var;
     3343 			sub_stack.dim.offset = 0;
     3344 		     end;
     3345 
     3346 /* a little hairier if there is an element.var and a dim.temp, but no dim.offset.  Then we must
     3347*   multiply dim.mult by element.constant, and create a mult_op node to multipy dim.temp by
     3348*   element.var, placing the result temp into dim.temp */
     3349 
     3350 		else if sub_stack.dim.offset = 0
     3351 		then do;
     3352 			sub_stack.dim.mult = sub_stack.dim.mult * sub_stack.element.constant;
     3353 			stack (work_stack_offset) = sub_stack.dim.temp;
     3354 			stack (work_stack_offset + 1) = sub_stack.element.var;
     3355 			stack (work_stack_offset + 2) = mult_op;
     3356 			call bump_work_stack_offset (+3);
     3357 			call process_arith ("0"b);
     3358 			call bump_work_stack_offset (-1);
     3359 			sub_stack.dim.temp = stack (work_stack_offset);
     3360 		     end;
     3361 
     3362 /* worst case...  there is an element.var, a dim.temp, and a dim.offset.  in that case we must
     3363*   fully evaluate the dim calculation to multiply it by element.var.
     3364*
     3365*   First we generate a mult_op node to calculate dim.temp*dim.mult...unless dim.mult is 1, in which
     3366*   case this step is skipped, or -1, in which case a negate_op of dim.temp is generated instead.
     3367*   Then an add_op node to add in dim.offset is created.  Finally a mult_op node is generated to
     3368*   multiply this result by element.var The result of this operation is placed into dim.temp, and
     3369*   element.constant is placed into dim.mult.  dim.offset is zeroed.  */
     3370 
     3371 		else do;
     3372 			stack (work_stack_offset) = sub_stack.dim.temp;
     3373 			call bump_work_stack_offset (+1);
     3374 			if sub_stack.dim.mult = -1
     3375 			then do;
     3376 				stack (work_stack_offset) = negate_op;
     3377 				call bump_work_stack_offset (+1);
     3378 				op_index = create_operator (1);
     3379 				stack (work_stack_offset) = create_temporary ((int_mode));
     3380 				call bump_work_stack_offset (+1);
     3381 			     end;
     3382 			else if sub_stack.dim.mult ^= 1
     3383 			then do;
     3384 				stack (work_stack_offset) =
     3385 				     create_integer_constant ((sub_stack.dim.mult));
     3386 				stack (work_stack_offset + 1) = mult_op;
     3387 				call bump_work_stack_offset (+2);
     3388 				call process_arith ("0"b);
     3389 			     end;
     3390 			stack (work_stack_offset) =
     3391 			     create_integer_constant ((sub_stack.dim.offset));
     3392 			stack (work_stack_offset + 1) = add_op;
     3393 			call bump_work_stack_offset (+2);
     3394 			call process_arith ("0"b);
     3395 			stack (work_stack_offset) = sub_stack.element.var;
     3396 			stack (work_stack_offset + 1) = mult_op;
     3397 			call bump_work_stack_offset (+2);
     3398 			call process_arith ("0"b);
     3399 			call bump_work_stack_offset (-1);
     3400 			sub_stack.dim.temp = stack (work_stack_offset);
     3401 			sub_stack.dim.mult = sub_stack.element.constant;
     3402 			sub_stack.dim.offset = 0;
     3403 		     end;
     3404 
     3405 /* Time to update element entry.  If this is the last dimension, we'll skip this part.  Otherwise,
     3406*   we've got to look at dimension.dim associated with this dimension of this symbol.  (In case
     3407*   you've lost track, this is still part of the block done only if there was an element.var) */
     3408 
     3409 		if sub_stack.dimension ^= sub_stack.n_dimensions
     3410 		then do;
     3411 
     3412 /* if this dimension is a constant, just multiply element.constant by it.  */
     3413 
     3414 			if string (sub_stack.dim_node -> dimension.v_bound (sub_stack.dimension)) = "00"b
     3415 			then sub_stack.element.constant =
     3416 				sub_stack.element.constant
     3417 				* sub_stack.dim_node -> dimension.size (sub_stack.dimension);
     3418 
     3419 /* This dim not constant, gotta generate a mult_op node to multiply it times element.var, and stuff
     3420*   the result temp back into element.var */
     3421 
     3422 			else do;
     3423 				stack (work_stack_offset) = sub_stack.element.var;
     3424 				stack (work_stack_offset + 1) =
     3425 				     sub_stack.dim_node -> dimension.size (sub_stack.dimension);
     3426 				stack (work_stack_offset + 2) = mult_op;
     3427 				call bump_work_stack_offset (+3);
     3428 				call process_arith ("0"b);
     3429 				call bump_work_stack_offset (-1);
     3430 				sub_stack.element.var = stack (work_stack_offset);
     3431 			     end;
     3432 		     end;
     3433 	     end;
     3434 
     3435 	else do;
     3436 
     3437 /* If we got here, there's no element.var...  They should all be so easy...  Just multiply dim.mult
     3438*   and dim.offset by element.constant.  */
     3439 
     3440 		sub_stack.dim.mult = sub_stack.dim.mult * sub_stack.element.constant;
     3441 		sub_stack.dim.offset = sub_stack.dim.offset * sub_stack.element.constant;
     3442 
     3443 /* Like above, if this is not the last dimension, we gotta update element.???  (remember, there is
     3444*   no element.var here).  If the current dimension.dim is a constant, just multiply
     3445*   element.constant by it; if it's variable, stuff it in element.var */
     3446 
     3447 		if sub_stack.dimension ^= sub_stack.n_dimensions
     3448 		then do;
     3449 			if string (sub_stack.dim_node -> dimension.v_bound (sub_stack.dimension)) = "00"b
     3450 			then sub_stack.element.constant =
     3451 				sub_stack.element.constant
     3452 				* sub_stack.dim_node -> dimension.size (sub_stack.dimension);
     3453 			else sub_stack.element.var = sub_stack.dim_node -> dimension.size (sub_stack.dimension);
     3454 		     end;
     3455 	     end;
     3456 
     3457 /* Now we have to add the effect of the current dimension (dim.mult*dim.temp + dim.offset,
     3458*   remember) to the offset from the array effective origin accumulated so far from the previously
     3459*   processed subscripts.  Again, it's a bunch of special cases to minimize run_time calculation. */
     3460 
     3461 /* First, the simple part.  Add dim.offset into cum.constant, giving a new cum.constant */
     3462 
     3463 	sub_stack.cum.constant = sub_stack.cum.constant + sub_stack.dim.offset;
     3464 	if sub_stack.dim.temp ^= 0
     3465 	then do;
     3466 
     3467 /* There is also a dim.temp, if we got this far.  If dim.mult is -1, there are two possibilities.
     3468*   If there is not yet a cum.temp entry, we'll generate a negate_op of dim.temp, and stuff the
     3469*   output temp into cum.temp.  If there is already a cum.temp, we'll generate a subtract_op of
     3470*   cum.temp and dim.temp, and stuff the output into cum.temp.  */
     3471 
     3472 		if sub_stack.dim.mult = -1
     3473 		then do;
     3474 			if sub_stack.cum.temp = 0
     3475 			then do;
     3476 				stack (work_stack_offset) = sub_stack.dim.temp;
     3477 				stack (work_stack_offset + 1) = negate_op;
     3478 				call bump_work_stack_offset (+2);
     3479 				op_index = create_operator (1);
     3480 				sub_stack.cum.temp = create_temporary ((int_mode));
     3481 			     end;
     3482 			else do;
     3483 				stack (work_stack_offset) = sub_stack.cum.temp;
     3484 				stack (work_stack_offset + 1) = sub_stack.dim.temp;
     3485 				stack (work_stack_offset + 2) = sub_op;
     3486 				call bump_work_stack_offset (+3);
     3487 				call process_arith ("0"b);
     3488 				call bump_work_stack_offset (-1);
     3489 				sub_stack.cum.temp = stack (work_stack_offset);
     3490 			     end;
     3491 		     end;
     3492 
     3493 /* There's a dim.temp, and dim.mult was not -1.  We'll first generate a mult_op node with dim.mult
     3494*   and dim.temp (unless dim.mult is 1).  Then if cum_temp is nonzero, we'll generate an add_op node
     3495*   to add it in.  Finally we'll take the result, whatever it is, and stuff it back into cum.temp */
     3496 
     3497 		else do;
     3498 			stack (work_stack_offset) = sub_stack.dim.temp;
     3499 			call bump_work_stack_offset (+1);
     3500 			if sub_stack.dim.mult ^= 1
     3501 			then do;
     3502 				stack (work_stack_offset) =
     3503 				     create_integer_constant ((sub_stack.dim.mult));
     3504 				stack (work_stack_offset + 1) = mult_op;
     3505 				call bump_work_stack_offset (+2);
     3506 				call process_arith ("0"b);
     3507 			     end;
     3508 			if sub_stack.cum.temp ^= 0
     3509 			then do;
     3510 				stack (work_stack_offset) = sub_stack.cum.temp;
     3511 				stack (work_stack_offset + 1) = add_op;
     3512 				call bump_work_stack_offset (+2);
     3513 				call process_arith ("0"b);
     3514 			     end;
     3515 			call bump_work_stack_offset (-1);
     3516 			sub_stack.cum.temp = stack (work_stack_offset);
     3517 		     end;
     3518 	     end;
     3519 
     3520 /* Now we can reset dim.???  to compute the next dimension */
     3521 
     3522 	sub_stack.dim.mult = 1;
     3523 	sub_stack.dim.temp = 0;
     3524 	sub_stack.dim.offset = 0;
     3525 	sub_stack.dimension = sub_stack.dimension + 1;
     3526 	if sub_stack.dimension <= sub_stack.n_dimensions
     3527 	then return;
     3528 
     3529 /* That was the final dimension:  Make the opt_subscript_op node, with the
     3530*   array_ref_node as its output.  */
     3531 
     3532 
     3533 	if sub_stack.symbol_node -> symbol.VLA
     3534 	then do;
     3535 
     3536 /*  The 'create_opt_subscript' routine requires the nodes that contain the   */
     3537 /*  constant and variable offsets of the desired element to be entered into  */
     3538 /*  the work stack.  For VLA's, the constant offset is always zero and the   */
     3539 /*  variable offset is really a packed pointer to the desired array element. */
     3540 /*  Since we originally initialized 'cum.temp' to the address of the start   */
     3541 /*  of the array minus its virtual origin, 'cum.temp' is now the address of  */
     3542 /*  the desired array element, provided that none of the subscripts of the   */
     3543 /*  element were constant.  If there were some constant subscripts, their    */
     3544 /*  effect was accumulated in 'cum.constant' and we must generate a quad to  */
     3545 /*  add it to 'cum.temp' to get the address of the desired element.  If we   */
     3546 /*  are not dealing with 256K VLA's, the addressor contains the "logical"    */
     3547 /*  address of the element and we must generate a quad to convert it to a    */
     3548 /*  physical address (i.e. a packed pointer).                                */
     3549 
     3550 		stack (work_stack_offset) = zero;
     3551 		stack (work_stack_offset + 1) = sub_stack.cum.temp;
     3552 		call bump_work_stack_offset (+2);
     3553 
     3554 		if sub_stack.cum.constant ^= 0
     3555 		then do;				/*  Add 'cum.constant' to the addressor.  */
     3556 			stack (work_stack_offset) = create_integer_constant ((sub_stack.cum.constant));
     3557 			stack (work_stack_offset + 1) = add_op;
     3558 			call bump_work_stack_offset (+2);
     3559 			call process_arith ("0"b);
     3560 			cum.constant = 0;
     3561 		     end;
     3562 
     3563 		if ^VLA_is_256K
     3564 		then do				/*  Convert the addressor to a packed pointer.  */
     3565 			stack (work_stack_offset) = form_VLA_packed_ptr_op;
     3566 			call bump_work_stack_offset (+1);
     3567 			op_index = create_operator (1);
     3568 			stack (work_stack_offset) = create_temporary ((int_mode));
     3569 			call bump_work_stack_offset (+1);
     3570 		     end;
     3571 
     3572 		big_offset = "1"b;			/*  The addressor is too big for an X register.  */
     3573 	     end;
     3574 	else do;
     3575 
     3576 /* If the virtual origin of the array is a constant, just add it to cum.constant.  Move
     3577*   cum.constant and cum.temp into the work stack.  */
     3578 
     3579 		if ^sub_stack.dim_node -> dimension.variable_virtual_origin
     3580 		then sub_stack.cum.constant = sub_stack.cum.constant - sub_stack.dim_node -> dimension.virtual_origin;
     3581 		stack (work_stack_offset) = create_integer_constant ((sub_stack.cum.constant));
     3582 		stack (work_stack_offset + 1) = sub_stack.cum.temp;
     3583 		call bump_work_stack_offset (+2);
     3584 
     3585 /* If the virtual origin is not a constant, generate an appropriate node to subtract it from
     3586*   cum.temp This may be a negate_op if there was no cum.temp.  */
     3587 
     3588 		if sub_stack.dim_node -> dimension.variable_virtual_origin
     3589 		then do;
     3590 			if stack (work_stack_offset - 1) = 0
     3591 			then do;
     3592 				stack (work_stack_offset - 1) = sub_stack.dim_node -> dimension.virtual_origin;
     3593 				stack (work_stack_offset) = negate_op;
     3594 				call bump_work_stack_offset (+1);
     3595 				op_index = create_operator (1);
     3596 				stack (work_stack_offset) = create_temporary ((int_mode));
     3597 				call bump_work_stack_offset (+1);
     3598 			     end;
     3599 			else do;
     3600 				stack (work_stack_offset) = sub_stack.dim_node -> dimension.virtual_origin;
     3601 				stack (work_stack_offset + 1) = sub_op;
     3602 				call bump_work_stack_offset (+2);
     3603 				call process_arith ("0"b);
     3604 			     end;
     3605 		     end;
     3606 
     3607 /* If the variable offset might not fit into an index register, set the
     3608*   big_offset bit, which prevents a sub_index operator from being generated
     3609*   and causes the offset to be loaded into the A or Q.  We must have
     3610*   0 <= variable offset <= 262143 for an index register to be used.  Since we
     3611*   know 0 <= constant offset + variable offset <= array_size - 1, we can derive
     3612*   these two conditions for index register use:
     3613*   constant offset <= 0  AND  array_size - constant offset <= 262144.
     3614*   If either of these is not met, an index register may not be used. */
     3615 
     3616 		big_offset = "0"b;
     3617 		if sub_stack.symbol_node -> symbol.units = char_units
     3618 		then if sub_stack.cum.temp ^= 0
     3619 		     then if sub_stack.symbol_node -> symbol.variable_extents
     3620 			     | sub_stack.symbol_node -> symbol.star_extents
     3621 			     | sub_stack.cum.constant > 0
     3622 			     | sub_stack.dim_node -> dimension.array_size - sub_stack.cum.constant > 262144
     3623 			then big_offset = "1"b;
     3624 
     3625 /* Now if the variable part about to be used in the opt_subscript_op node is a
     3626*   temporary or array_ref (and it is not a big_offset) we've gotta run it
     3627*   through a sub_index_op node.  We must also set the output temp's
     3628*   used_as_subscript bit.  */
     3629 
     3630 		if (stack (work_stack_offset - 1) ^= 0) & (^big_offset)
     3631 		then do;
     3632 			if addr (x (stack (work_stack_offset - 1))) -> node.node_type ^= symbol_node
     3633 			then do;
     3634 				stack (work_stack_offset) = sub_index_op;
     3635 				call bump_work_stack_offset (+1);
     3636 				call get_data_type (1);
     3637 				op_index = create_operator (1);
     3638 				stack (work_stack_offset) = create_temporary (rand_data_type (1));
     3639 				call bump_work_stack_offset (+1);
     3640 				temp_ptr -> temporary.bits.used_as_subscript = "1"b;
     3641 			     end;
     3642 		     end;
     3643 	     end;
     3644 
     3645 /* At last we can create the opt_subscript_op node and its associated array_ref node */
     3646 
     3647 	stack (work_stack_offset) = opt_subscript_op;
     3648 	call bump_work_stack_offset (+1);
     3649 	call create_opt_subscript ("0"b);
     3650 	array_ptr -> array_ref.large_offset = big_offset;
     3651      end process_1_subscript;
     3652 
     3653 process_substr:
     3654      procedure ();
     3655 
     3656 /* process_substr is called when a substr_op is hit and does all required work.
     3657*    The top of the stack is: (<>)<substr_op><upper_bound><lower_bound><parent>...
     3658*    The parent is either a symbol (i.e. substr'ing a scalar) or an array ref (i.e.the parent is an array ref).
     3659*    An opt_subscript node is placed in the quads with 4 operands: (1) symbol, (2) constant-offset,
     3660*    (3)variable-offset, (4) length.  If the parent is an array-ref, then we must merge
     3661*    the offset info with that of the substr (this is like subscript processing). */
     3662 
     3663 declare	(parent_ptr, sympx, bound_ptr)
     3664 			pointer;
     3665 declare	(
     3666 	big_offset,
     3667 	bound_constant	(2),
     3668 	parent_is_array
     3669 	)		bit (1);
     3670 declare	(
     3671 	bound_index	(2),
     3672 	constant_part,
     3673 	parent_constant_part,
     3674 	parent_variable_part,
     3675 	true_parent_variable_part,
     3676 	substr_length,
     3677 	variable_part
     3678 	)		fixed binary (18);
     3679 
     3680 declare	(
     3681 	bound_value	(2),
     3682 	constant_value,
     3683 	parent_constant_value
     3684 	)		fixed binary (35);
     3685 
     3686 declare	int_image		fixed binary (35) based;
     3687 
     3688 /* first examine the parent for any array-ref-node info */
     3689 
     3690 	parent_ptr = addr (x (stack (work_stack_offset - 4)));
     3691 	if parent_ptr -> node.node_type = array_ref_node
     3692 	then do;
     3693 		parent_is_array = "1"b;
     3694 		sympx = addr (x (parent_ptr -> array_ref.parent));
     3695 		big_offset = parent_ptr -> array_ref.large_offset;
     3696 	     end;
     3697 	else do;
     3698 		parent_is_array = "0"b;
     3699 		sympx = parent_ptr;
     3700 		big_offset = "0"b;
     3701 	     end;
     3702 
     3703 	if sympx -> symbol.data_type ^= char_mode
     3704 	then call print_message (159, stack (work_stack_offset - 4));
     3705 
     3706 /* now examine the bounds - if constant and integer then bound is
     3707*    constant, else  it is variable and may need conversion to integer
     3708*    in this code bound_xxx (1)  refers to the lower bound and  bound_xxx(2)
     3709*    to the upper bound.   */
     3710 
     3711 	call get_data_type (2);
     3712 
     3713 	do i = 1 to 2;
     3714 	     bound_ptr = addr (x (stack (work_stack_offset - 4 + i)));
     3715 	     if rand_data_type (i) ^= int_mode
     3716 	     then do;
     3717 
     3718 /* we have to convert to integer */
     3719 
     3720 		     bound_constant (i) = "0"b;
     3721 		     stack (work_stack_offset) = stack (work_stack_offset - 4 + i);
     3722 		     stack (work_stack_offset + 1) = convert_to_int_op;
     3723 		     call bump_work_stack_offset (+2);
     3724 		     op_index = create_operator (1);
     3725 		     bound_index (i) = create_temporary ((int_mode));
     3726 		end;
     3727 	     else do;
     3728 
     3729 /* data type is integer - if constant, get its value */
     3730 
     3731 		     bound_constant (i) = (bound_ptr -> node.operand_type = constant_type);
     3732 		     bound_index (i) = stack (work_stack_offset - 4 + i);
     3733 		     if bound_constant (i)
     3734 		     then bound_value (i) = addr (bound_ptr -> constant.value) -> int_image;
     3735 		end;
     3736 
     3737 	end /* do loop */;
     3738 
     3739 /* next compute length and offset of the substr,
     3740*   remembering that length = upper_bound - lower_bound + 1, however computed */
     3741 
     3742 	if bound_constant (1)
     3743 	then do;
     3744 
     3745 /* lower bound is constant, so offset is also */
     3746 
     3747 
     3748 		constant_value = bound_value (1) - 1;
     3749 		variable_part = 0;
     3750 
     3751 		if bound_constant (2)
     3752 
     3753 /* if both are constant then length is constant */
     3754 
     3755 		then substr_length = create_integer_constant (bound_value (2) - bound_value (1) + 1);
     3756 		else substr_length = do_arith (sub_op, create_integer_constant ((constant_value)), bound_index (2));
     3757 	     end;
     3758 
     3759 	else do;
     3760 
     3761 /* lowerbound is variable, so both length and offset are */
     3762 
     3763 		constant_value = -1;
     3764 		variable_part = bound_index (1);
     3765 
     3766 /* if the upper_bound is constant, fold "1" into its value and subtract the
     3767*   lower bound from that, else two arithmetic operations are required */
     3768 
     3769 		if bound_constant (2)
     3770 		then substr_length =
     3771 			do_arith (sub_op, bound_index (1), create_integer_constant (bound_value (2) + 1));
     3772 		else substr_length = do_arith (add_op, do_arith (sub_op, bound_index (1), bound_index (2)), one);
     3773 	     end;
     3774 
     3775 /* if parent is an array, merge its offset info with that of the substr,
     3776*    otherwise, merely set that for the substr */
     3777 
     3778 	if parent_is_array
     3779 	then do;
     3780 		parent_constant_part = addr (q (parent_ptr -> array_ref.output_by)) -> operator.operand (2);
     3781 		parent_constant_value = addr (addr (x (parent_constant_part)) -> constant.value) -> int_image;
     3782 		true_parent_variable_part = addr (q (parent_ptr -> array_ref.output_by)) -> operator.operand (3);
     3783 
     3784 		constant_part = create_integer_constant (parent_constant_value + constant_value);
     3785 
     3786 		if true_parent_variable_part > 0
     3787 		then do;
     3788 			parent_variable_part = strip_sub_index (true_parent_variable_part);
     3789 			if variable_part = 0
     3790 			then variable_part = parent_variable_part;
     3791 			else variable_part = do_arith (add_op, parent_variable_part, variable_part);
     3792 		     end;
     3793 
     3794 /* Make sure the variable offset still fits in an index register. */
     3795 
     3796 		if ^sympx -> symbol.variable_extents & ^sympx -> symbol.star_extents
     3797 		then if variable_part ^= 0
     3798 		     then big_offset = constant_value + parent_constant_value > 0
     3799 			     | addr (x (sympx -> symbol.dimension)) -> dimension.array_size
     3800 			     - (constant_value + parent_constant_value) > 262144;
     3801 
     3802 	     end;
     3803 
     3804 	else do;
     3805 
     3806 /*  parent is a symbol */
     3807 
     3808 		constant_part = create_integer_constant ((constant_value));
     3809 
     3810 	     end;
     3811 
     3812 /*  if the offset is capable of being held in an index register,
     3813*    then run it thru a sub_index node & set output temp's used as subs bit */
     3814 
     3815 	if ^big_offset & variable_part ^= 0
     3816 	then if addr (x (variable_part)) -> node.node_type ^= symbol_node
     3817 	     then do;
     3818 		     stack (work_stack_offset) = variable_part;
     3819 		     stack (work_stack_offset + 1) = sub_index_op;
     3820 		     call bump_work_stack_offset (+2);
     3821 		     call get_data_type (1);
     3822 		     op_index = create_operator (1);
     3823 		     variable_part = create_temporary ((int_mode));
     3824 		     temp_ptr -> temporary.bits.used_as_subscript = "1"b;
     3825 		end;
     3826 
     3827 /* clean up the stack, pop on the opt_subscript_op and args, create the opt_subscript node in the quads */
     3828 
     3829 	call bump_work_stack_offset (-4);
     3830 	stack (work_stack_offset) = fixed (rel (sympx), 18);
     3831 	stack (work_stack_offset + 1) = constant_part;
     3832 	stack (work_stack_offset + 2) = variable_part;
     3833 	stack (work_stack_offset + 3) = substr_length;
     3834 	stack (work_stack_offset + 4) = opt_subscript_op;
     3835 	call bump_work_stack_offset (+5);
     3836 	call create_opt_subscript ("1"b);
     3837 	array_ptr -> array_ref.large_offset = big_offset;
     3838 
     3839 /* if the parent was an array with a variable part,
     3840*   unchain the old opt_subscript_node and free the sub_index operator and its temporary */
     3841 
     3842 	if parent_is_array
     3843 	then do;
     3844 		if true_parent_variable_part ^= parent_variable_part & true_parent_variable_part ^= 0
     3845 		then call unchain (addr (q (addr (x (true_parent_variable_part)) -> temporary.output_by)));
     3846 
     3847 		call unchain_opt_subscript (addr (q (parent_ptr -> array_ref.output_by)));
     3848 	     end;
     3849 
     3850 
     3851 	return;
     3852 
     3853 unchain_opt_subscript:
     3854      procedure (op_ptr);
     3855 
     3856 /* Does the actual unchaining of opt_subscript_nodes and freeing of 
     3857*    array_refs */
     3858 
     3859 dcl	op_ptr		pointer;
     3860 
     3861 	addr (q (op_ptr -> operator.next)) -> operator.back = op_ptr -> operator.back;
     3862 	addr (q (op_ptr -> operator.back)) -> operator.next = op_ptr -> operator.next;
     3863 	addr (x (op_ptr -> operator.output)) -> array_ref.next = next_free_array_ref;
     3864 	next_free_array_ref = op_ptr -> operator.output;
     3865 
     3866      end unchain_opt_subscript;
     3867 
     3868      end process_substr;
     3869 
     3870 do_arith:
     3871      procedure (operator, operand1, operand2) returns (fixed binary (18));
     3872 
     3873 /* called with a operator and the two operands -does the quad generation 
     3874*    and returns the temporary left on top of the stack by process_arith,
     3875*    however the stack itself is left unchanged by this call */
     3876 
     3877 declare	(operator, operand1, operand2)
     3878 			fixed binary (18);
     3879 
     3880 	stack (work_stack_offset) = operand2;
     3881 	stack (work_stack_offset + 1) = operand1;
     3882 	stack (work_stack_offset + 2) = operator;
     3883 	call bump_work_stack_offset (+3);
     3884 	call process_arith ("0"b);
     3885 	call bump_work_stack_offset (-1);
     3886 	return (stack (work_stack_offset));
     3887 
     3888      end do_arith;
     3889 
     3890 create_opt_subscript:
     3891      procedure (doing_substr);
     3892 
     3893 declare	doing_substr	bit (1);
     3894 declare	num_operands	fixed binary (18);
     3895 declare	array_parent_p	pointer;
     3896 declare	char_len		fixed binary (18);
     3897 
     3898 /* creates the opt_substr node and associated array ref node for a
     3899*    subscripted or substred variable  - assumes the stack looks like:
     3900*    (<>) <opt_subscript_op> [<length>] <variable_part> <constant_part> <parent>,
     3901*    the length operand only if doing_substr.  
     3902*    the stack is left as (<>) <array_ref_node> ...    */
     3903 
     3904 	if doing_substr
     3905 	then num_operands = 4;
     3906 	else num_operands = 3;
     3907 
     3908 	array_parent_p = addr (x (stack (work_stack_offset - num_operands - 1)));
     3909 
     3910 	rand_data_type (1) = array_parent_p -> symbol.data_type;
     3911 	op_index = create_operator (num_operands);
     3912 	stack (work_stack_offset) = create_node (array_ref_node, size (array_ref));
     3913 	last_quad_p -> operator.output = stack (work_stack_offset);
     3914 
     3915 	array_ptr = addr (x (stack (work_stack_offset)));
     3916 	array_ptr -> array_ref.output_by = op_index;
     3917 	array_ptr -> array_ref.operand_type = array_ref_type;
     3918 	array_ptr -> array_ref.ref_count = 0;
     3919 	array_ptr -> array_ref.data_type = rand_data_type (1);
     3920 	array_ptr -> array_ref.parent = last_quad_p -> operator.operand (1);
     3921 
     3922 	if array_ptr -> array_ref.data_type = char_mode
     3923 	then do;
     3924 		char_len = get_char_size (array_parent_p);
     3925 		if char_len < 0
     3926 		then array_ptr -> array_ref.length = char_len + bias;
     3927 		else do;
     3928 			array_ptr -> array_ref.length = char_len;
     3929 			array_ptr -> array_ref.variable_length = "1"b;
     3930 		     end;
     3931 	     end;
     3932 
     3933 	call bump_work_stack_offset (+1);
     3934 
     3935 	return;
     3936 
     3937      end create_opt_subscript;
     3938 
     3939 get_char_size:
     3940      procedure (node_p) returns (fixed binary (18));
     3941 
     3942 /* Returns the character length of the operand pointed to by
     3943*	   node_p.  Returns a count if the length is known to be constant,
     3944*	   otherwise returns an operand index. */
     3945 
     3946 dcl	(node_p, p, o)	pointer;
     3947 
     3948 	p = node_p;
     3949 
     3950 	if p -> node.node_type = char_constant_node
     3951 	then return (p -> char_constant.length - bias);
     3952 
     3953 	if p -> node.node_type = symbol_node
     3954 	then do;
     3955 		if p -> symbol.v_length ^= 0
     3956 		then return (p -> symbol.v_length);
     3957 		else return (p -> symbol.char_size + 1 - bias);
     3958 	     end;
     3959 
     3960 	if p -> node.node_type = array_ref_node
     3961 	then do;
     3962 		o = addr (q (p -> array_ref.output_by));
     3963 		if o -> operator.op_code = opt_subscript_op
     3964 		     & o -> operator.number = 4
     3965 		then return (strip_sub_index (o -> operator.operand (4)));
     3966 		else if p -> array_ref.variable_length
     3967 		then return (p -> array_ref.length);
     3968 		else return (p -> array_ref.length - bias);
     3969 	     end;
     3970 
     3971 	if p -> node.node_type = temporary_node
     3972 	then do;
     3973 		o = addr (q (p -> temporary.output_by));
     3974 		if o -> operator.op_code = cat_op
     3975 		then return (strip_sub_index (o -> operator.operand (o -> operator.number)));
     3976 		else if p -> temporary.variable_length
     3977 		then return (p -> temporary.length);
     3978 		else return (p -> temporary.length - bias);
     3979 	     end;
     3980 
     3981 	return (0);
     3982 
     3983      end get_char_size;
     3984 
     3985 
     3986 strip_sub_index:
     3987      procedure (operand) returns (fixed binary (18));
     3988 
     3989 /* If the operand is the output of a sub_index operator, return
     3990*	   the input of the operator.  Otherwise, just return the operand. */
     3991 
     3992 dcl	(operand, op)	fixed binary (18);
     3993 dcl	o		pointer;
     3994 
     3995 	op = operand;
     3996 
     3997 	if addr (x (op)) -> node.node_type = temporary_node
     3998 	then do;
     3999 		o = addr (q (addr (x (op)) -> temporary.output_by));
     4000 		if o -> operator.op_code = sub_index_op
     4001 		then op = o -> operator.operand (1);
     4002 	     end;
     4003 
     4004 	return (op);
     4005 
     4006      end strip_sub_index;
     4007 
     4008 
     4009 is_local:
     4010      procedure (operand) returns (bit (1) aligned);
     4011 
     4012 /* is_local is a predicate which returns true if the operand is
     4013*	   a subroutine or function that occurs in this compilation. */
     4014 
     4015 dcl	(operand, sym)	fixed binary (18);
     4016 dcl	(p, s)		pointer;
     4017 
     4018 	p = addr (x (operand));
     4019 
     4020 	if (^p -> symbol.external)
     4021 	then return ("0"b);
     4022 
     4023 /* Search list of entry symbols for one with the same name. */
     4024 
     4025 	do sym = first_entry_name repeat (s -> symbol.next_symbol) while (sym > 0);
     4026 	     s = addr (x (sym));
     4027 	     if s -> symbol.name = p -> symbol.name
     4028 	     then return ("1"b);
     4029 	end;
     4030 
     4031 	return ("0"b);
     4032 
     4033      end is_local;
     4034 
     4035 
     4036 is_star_extent:
     4037      procedure (operand) returns (bit (1) aligned);
     4038 
     4039 /* is_star_extent is a predicate that returns true if the operand
     4040*	   is a symbol of star extent, or a substring or array reference
     4041*	   whose parent is of star extent. */
     4042 
     4043 dcl	operand		fixed binary (18);
     4044 dcl	p		pointer;
     4045 
     4046 	p = addr (x (operand));
     4047 
     4048 	if p -> node.node_type = array_ref_node
     4049 	then p = addr (x (p -> array_ref.parent));
     4050 
     4051 	if p -> node.node_type = symbol_node
     4052 	then return (p -> symbol.star_extents);
     4053 	else return ("0"b);
     4054 
     4055      end is_star_extent;
     4056 
     4057 process_hold_stack_entry:
     4058      proc ();
     4059 
     4060 dcl	(i, j)		fixed bin (18);
     4061 
     4062 /* The hold stack is used to remember various things that need to be done to a statement after the
     4063*   next statement node has been processed.  */
     4064 
     4065 	if opst -> opt_statement.put_in_map | hold_stack.op_code = block_if_op
     4066 	then do while (hold_offset ^= 0);
     4067 
     4068 /* If the statement must have a label, but doesn't, make it one.  */
     4069 
     4070 		if hold_stack.op_code ^= jump_true_op
     4071 		then do;
     4072 			if opst -> opt_statement.label = 0
     4073 			then opst -> opt_statement.label = create_label (last_op_index);
     4074 			i = opst -> opt_statement.label;
     4075 			addr (x (i)) -> label.referenced_executable = "1"b;
     4076 		     end;
     4077 
     4078 /* If the last statement was an if statement whose conditionally executed part was not a goto, we
     4079*   need to tell it where to jump to if the test failed.  */
     4080 
     4081 		if hold_stack.op_code = jump_false_op
     4082 		then hold_stack.ptr -> operator.operand (2) = i;
     4083 
     4084 /* Now is where we optimize any variety of if statement by separating the tests in compound tests.	*/
     4085 
     4086 		if hold_stack.op_code = jump_false_op | hold_stack.op_code = jump_true_op
     4087 		then call optimize_if ((hold_stack.ptr));
     4088 
     4089 /* If last statement was an arithmetic if, there may be unspecified labels to fill in.  */
     4090 
     4091 		else if hold_stack.op_code = jump_arithmetic_op
     4092 		then do j = 2 to 4;
     4093 			if hold_stack.ptr -> operator.operand (j) < 0
     4094 			then hold_stack.ptr -> operator.operand (j) = i;
     4095 		     end;
     4096 
     4097 /* If we are at the end of a block IF statement, the jump operators at the
     4098*   ends of the clauses must be filled in. */
     4099 
     4100 		else if hold_stack.op_code = block_if_op
     4101 		then do;
     4102 			do j = 1 to block_if_stack.n_jumps;
     4103 			     addr (q (block_if_stack.jump (j))) -> operator.operand (1) = i;
     4104 			end;
     4105 			call pop_block_if_stack ();
     4106 		     end;
     4107 
     4108 /* Last possibility is that last statement was a do statement, and this is the first statement of
     4109*   the do group.  In that case, we must remember its label.  */
     4110 
     4111 		else exit_stack.do_label = i;
     4112 		call pop_hold_stack ();
     4113 	     end;
     4114 	return;
     4115      end process_hold_stack_entry;
     4116 
     4117 create_label:
     4118      proc (i) returns (fixed bin (18));
     4119 
     4120 dcl	(i, j)		fixed bin (18);
     4121 
     4122 /* create_label creates a label and attaches it to the opt_statement node whose offset in the quads
     4123*   is contained in i.  It returns the offset in x (the symbol area) of the label entry created.  */
     4124 
     4125 	j = create_node (label_node, size (label));
     4126 	addr (x (j)) -> label.statement = i;
     4127 	addr (x (j)) -> label.operand_type = rel_constant;
     4128 	addr (x (j)) -> label.executable, addr (x (j)) -> label.referenced, addr (x (j)) -> label.allocate,
     4129 	     addr (x (j)) -> label.set = "1"b;
     4130 	if subp_ptr -> subprogram.last_label = 0
     4131 	then subp_ptr -> subprogram.first_label = j;
     4132 	else addr (x (subp_ptr -> subprogram.last_label)) -> label.next_label = j;
     4133 	subp_ptr -> subprogram.last_label = j;
     4134 	return (j);
     4135      end create_label;
     4136 
     4137 search_label:
     4138      proc (n);
     4139 
     4140 dcl	n		fixed bin (18);
     4141 
     4142 /* search_label checks to determine if a reference to a label is a backwards reference, and if so
     4143*   sets the referenced_backwards bit in the statement to which the label belongs.  The argument is
     4144*   the offset in the symbol list of the label entry to be checked.  */
     4145 
     4146 	if addr (x (n)) -> label.statement ^= 0
     4147 	then if addr (q (addr (x (n)) -> label.statement)) -> opt_statement.processed_by_converter
     4148 	     then addr (q (addr (x (n)) -> label.statement)) -> opt_statement.referenced_backwards = "1"b;
     4149 	return;
     4150      end search_label;
     4151 
     4152 create_opt_statement:
     4153      proc () returns (ptr);
     4154 
     4155 dcl	i		fixed bin (18);
     4156 dcl	opst		ptr;
     4157 
     4158 /* create_opt_statement is called to create and initialize an opt_statement node.  It returns a
     4159*   pointer to the node created.  Most of the initialization data is taken directly from the
     4160*   statement node in the polish.  */
     4161 
     4162 	i = next_free_quad;
     4163 	next_free_quad = next_free_quad + size (opt_statement);
     4164 	if next_free_quad > quad_max_len
     4165 	then call print_message (407, "quadruple region", char (quad_max_len));
     4166 	opst = addr (q (i));
     4167 	unspec (opst -> opt_statement) = "0"b;
     4168 	if subp_ptr -> subprogram.last_polish = cur_statement
     4169 	then subp_ptr -> subprogram.last_quad = i;
     4170 	opst -> opt_statement.back = rel (last_opt_statement);
     4171 	if rel (last_opt_statement)
     4172 	then last_opt_statement -> opt_statement.next = rel (opst);
     4173 	if last_op_index ^= 0
     4174 	then addr (q (last_op_index)) -> operator.next = i;
     4175 	else subp_ptr -> subprogram.first_quad = i;
     4176 
     4177 	opst -> opt_statement.prev_operator = last_op_index;
     4178 	opst -> opt_statement.op_code = stat_op;
     4179 	opst -> opt_statement.source_id = stm_ptr -> statement.source_id;
     4180 	opst -> opt_statement.length = stm_ptr -> statement.length;
     4181 	opst -> opt_statement.put_in_map = stm_ptr -> statement.put_in_map;
     4182 	opst -> opt_statement.put_in_profile = stm_ptr -> statement.put_in_profile;
     4183 	opst -> opt_statement.start = stm_ptr -> statement.start;
     4184 	opst -> opt_statement.location = stm_ptr -> statement.location;
     4185 	opst -> opt_statement.flow_unit, opst -> opt_statement.operator_list = null;
     4186 
     4187 	last_op_index = i;
     4188 	last_opt_statement = opst;
     4189 	return (opst);
     4190      end create_opt_statement;
     4191 
     4192 create_operator:
     4193      proc (n) returns (fixed bin (18));
     4194 
     4195 dcl	i		fixed bin (18),
     4196 	j		fixed bin (18),
     4197 	n		fixed bin (18);
     4198 
     4199 /* create_operator is called with the stack containing (<>) <operator> <arg_n> ... <arg_1> <...>
     4200*   The number of args in the stack is passed as the argument n.  create_operator creates and inits
     4201*   an appropriate size node, stuffs the operator and operands into the node from the stack,
     4202*   increments the ref_counts for any of the operator args which are array_refs or temps, Cleans the
     4203*   operator and its args from the stack, and returns the offset in the quads of the created node.
     4204*   The stack is left as (<>) <...> upon return.  */
     4205 
     4206 	i = next_free_quad;
     4207 	n_operands = n;
     4208 	if n_operands > max_num_of_rands
     4209 	then call print_message (204, char (max_num_of_rands));
     4210 	next_free_quad = next_free_quad + size (operator);
     4211 	if next_free_quad > quad_max_len
     4212 	then call print_message (407, "quadruple region", char (quad_max_len));
     4213 
     4214 	last_quad_p = addr (q (i));
     4215 	unspec (last_quad_p -> operator) = "0"b;
     4216 	last_quad_p -> operator.back = last_op_index;
     4217 	if last_op_index ^= 0
     4218 	then addr (q (last_op_index)) -> operator.next = i;
     4219 	if opst -> opt_statement.first_operator = 0
     4220 	then opst -> opt_statement.first_operator = i;
     4221 	last_quad_p -> operator.op_code = stack (work_stack_offset - 1);
     4222 	last_quad_p -> operator.number = n_operands;
     4223 	last_quad_p -> operator.primary = null;
     4224 
     4225 	do j = 1 to n_operands;
     4226 	     last_quad_p -> operator.operand (j) = stack (work_stack_offset - n_operands - 2 + j);
     4227 	     if j > 1 | last_quad_p -> operator.op_code ^= opt_subscript_op
     4228 	     then last_quad_p -> operator.operand (j) = effective_operand (last_quad_p -> operator.operand (j));
     4229 	     if last_quad_p -> operator.operand (j) > last_assigned_op
     4230 	     then if addr (x (last_quad_p -> operator.operand (j))) -> node.node_type = temporary_node
     4231 		     | addr (x (last_quad_p -> operator.operand (j))) -> node.node_type = array_ref_node
     4232 		then addr (x (last_quad_p -> operator.operand (j))) -> temporary.ref_count =
     4233 			addr (x (last_quad_p -> operator.operand (j))) -> temporary.ref_count + 1;
     4234 	end;
     4235 
     4236 	call bump_work_stack_offset (-n_operands - 1);
     4237 	last_op_index = i;
     4238 	return (i);
     4239      end create_operator;
     4240 
     4241 create_temporary:
     4242      proc (data_type) returns (fixed bin (18));
     4243 
     4244 dcl	data_type		fixed bin (18);
     4245 
     4246 /* create_temporary is called specifically to create an output temp for an already created operator
     4247*   node.  It is called with the data_type to be used for the temp.  It creates a temporary node,
     4248*   places it into the output entry of the last operator node created, and returns the offset of the
     4249*   created temporary in the x (symbol) stack.  */
     4250 
     4251 	temp_index = create_node (temporary_node, size (temporary));
     4252 	temp_ptr = addr (x (temp_index));
     4253 	last_quad_p -> operator.output = temp_index;
     4254 	temp_ptr -> temporary.output_by = op_index;
     4255 	temp_ptr -> temporary.operand_type = temp_type;
     4256 	temp_ptr -> temporary.ref_count = 0;
     4257 	temp_ptr -> temporary.data_type = data_type;
     4258 	temp_ptr -> temporary.addressing_bits.not_in_storage = "1"b;
     4259 	return (temp_index);
     4260      end create_temporary;
     4261 
     4262 create_var:
     4263      proc () returns (fixed bin (18));
     4264 
     4265 dcl	var		fixed bin (18);
     4266 dcl	p		ptr;
     4267 
     4268 /* create_var is called when it is necessary to produce a new compiler-generated symbol.
     4269*   It creates an unnamed integer symbol entry in the symbol table, and returns the offset
     4270*   of the created entry.  */
     4271 
     4272 	allocate_symbol_name = 0;
     4273 	var = create_node (symbol_node, size (symbol));
     4274 	p = addr (x (var));
     4275 	p -> symbol.data_type = int_mode;
     4276 	p -> symbol.element_size = data_type_size (int_mode);
     4277 	p -> symbol.operand_type = variable_type;
     4278 	p -> symbol.allocate, p -> symbol.referenced, p -> symbol.set, p -> symbol.by_compiler, p -> symbol.integer,
     4279 	     p -> symbol.automatic = "1"b;
     4280 
     4281 /* connect the node to the symbol chain */
     4282 
     4283 	addr (x (subp_ptr -> subprogram.last_symbol)) -> symbol.next_symbol = var;
     4284 	subp_ptr -> subprogram.last_symbol = var;
     4285 	return (var);
     4286      end create_var;
     4287 
     4288 create_integer_constant:
     4289      procedure (value) returns (fixed binary (18));
     4290 
     4291 dcl	value		fixed binary (19) aligned;
     4292 dcl	bit_value		bit (72) aligned;
     4293 
     4294 	bit_value = unspec (value);
     4295 	return (create_constant (int_mode, bit_value));
     4296 
     4297      end create_integer_constant;
     4298 
     4299 match_index_type:
     4300      proc ();
     4301 
     4302 dcl	i		fixed bin (18);
     4303 dcl	(i_ptr, c_ptr)	ptr;
     4304 
     4305 /* match_index_type is called when processing do loops, with the stack containing (<>) <do_op>
     4306*   <incr> <upper> <lower> <index_var> <...> It checks the data type of incr, upper, and lower
     4307*   against the data type of index_var, the nominal control variable.  If the data types do not
     4308*   match, it will generate an explicit conversion node to convert the errant value's data type to
     4309*   match the data_type of index_var.  The stack is in identical form upon return, except that incr,
     4310*   lower, and upper all have the same data type as index_var.  */
     4311 
     4312 	c_ptr = addr (x (stack (work_stack_offset - 5)));
     4313 	do i = 2 to 4;
     4314 	     i_ptr = addr (x (stack (work_stack_offset - i)));
     4315 	     if i_ptr -> node.data_type ^= c_ptr -> node.data_type
     4316 	     then do;
     4317 		     stack (work_stack_offset) = stack (work_stack_offset - i);
     4318 		     stack (work_stack_offset + 1) = convert_to_int_op + c_ptr -> node.data_type - 1;
     4319 		     call bump_work_stack_offset (+2);
     4320 		     op_index = create_operator (1);
     4321 		     stack (work_stack_offset - i) = create_temporary ((c_ptr -> node.data_type));
     4322 		end;
     4323 	end;
     4324 	return;
     4325      end match_index_type;
     4326 
     4327 optimize_if:
     4328      proc (if_node_p) recursive;
     4329 
     4330 dcl	(if_node_p, log_op_p)
     4331 			ptr;
     4332 dcl	(inverted_if, next, next_label)
     4333 			fixed bin (18);
     4334 
     4335 /* optimize_if is called from the top level program to break up if statements involving logical
     4336*   operators into a series of if_nodes each of which uses a single logical value (logical variable
     4337*   or expression involving relational operators.  This may serve to eliminate unneeded computation,
     4338*   since the if statement will take effect as soon as it is known that enough of the logical
     4339*   expression has been that any further tests would have no effect.  The basic transformations used
     4340*   are:
     4341*
     4342*   jump_true(target,or(a,b)) -> jump_true(target,a), jump_true(target,b)
     4343*
     4344*   jump_true(target,and(a,b)) -> jump_false(next,a), jump_true(target,b)
     4345*
     4346*   jump_true(target,not(a)) -> jump_false(target,a)
     4347*
     4348*   jump_false(target,and(a,b)) -> jump_false(target,a), jump_false(target,b)
     4349*
     4350*   jump_false(target,or(a,b)) -> jump_true(next,a), jump_false(target,b)
     4351*
     4352*   jump_false(target,not(a)) -> jump_true(target,a)
     4353*
     4354*   optimize_if recurses, and will unweave any arbitrary logical expression.  */
     4355 
     4356 	if if_node_p -> operator.op_code = jump_false_op
     4357 	then inverted_if = jump_true_op;
     4358 	else inverted_if = jump_false_op;
     4359 
     4360 /* If the test_expression is not a temp, it was a variable.  Can't do nuttin.  */
     4361 
     4362 	if addr (x (if_node_p -> operator.operand (1))) -> node.node_type ^= temporary_node
     4363 	then return;
     4364 
     4365 /* Otherwise get the operator used to produce the temporary.  */
     4366 
     4367 	log_op_p = addr (q (addr (x (if_node_p -> operator.operand (1))) -> temporary.output_by));
     4368 
     4369 /* If the op was .not., just invert the jump sense.  */
     4370 
     4371 	if log_op_p -> operator.op_code = not_op
     4372 	then do;
     4373 		if_node_p -> operator.op_code = inverted_if;
     4374 		if_node_p -> operator.operand (1) = log_op_p -> operator.operand (1);
     4375 	     end;
     4376 
     4377 /* If node is a jump true on an .or., or jump false on an .and., we just split it into 2 nodes with
     4378*   the same sense jump, One based on each side of the logical operator.  The left hand side will be
     4379*   put into a new jump node created by create_new_if, which will also call optimize_if to optimize
     4380*   that branch.  The right_hand side will replace the original test_expression in the original
     4381*   jump.  */
     4382 
     4383 	else if (if_node_p -> operator.op_code = jump_true_op & log_op_p -> operator.op_code = or_op)
     4384 	     | (if_node_p -> operator.op_code = jump_false_op & log_op_p -> operator.op_code = and_op)
     4385 	then do;
     4386 		call create_new_if (if_node_p, (if_node_p -> operator.op_code), (if_node_p -> operator.operand (2)),
     4387 		     (log_op_p -> operator.operand (1)));
     4388 		if_node_p -> operator.operand (1) = log_op_p -> operator.operand (2);
     4389 	     end;
     4390 
     4391 /* If node is a jump true on an .and., or jump false on an .or., do the same as in last case,
     4392*   except that the new jump created for the lhs is inverted in sense from the original jump.  */
     4393 
     4394 	else if (if_node_p -> operator.op_code = jump_true_op & log_op_p -> operator.op_code = and_op)
     4395 	     | (if_node_p -> operator.op_code = jump_false_op & log_op_p -> operator.op_code = or_op)
     4396 	then do;
     4397 
     4398 /* Find the next executable statement, and put a label on it if necessary. */
     4399 
     4400 		do next = if_node_p -> operator.next repeat (fixed (addr (q (next)) -> opt_statement.next, 18))
     4401 		     while (^addr (q (next)) -> opt_statement.put_in_map);
     4402 		end;
     4403 
     4404 		if addr (q (next)) -> opt_statement.label = 0
     4405 		then addr (q (next)) -> opt_statement.label = create_label (next);
     4406 		next_label = addr (q (next)) -> opt_statement.label;
     4407 		addr (x (next_label)) -> label.referenced_executable = "1"b;
     4408 		call create_new_if (if_node_p, (inverted_if), next_label, (log_op_p -> operator.operand (1)));
     4409 		if_node_p -> operator.operand (1) = log_op_p -> operator.operand (2);
     4410 	     end;
     4411 
     4412 /* If we get here, node has already been reduced as far as possible.  Just return.  */
     4413 
     4414 	else return;
     4415 
     4416 /* Call unchain_op to throw out the no longer needed logical operator node, and optimize_if to
     4417*   optimize the new chain created from the right_hand side of the original logical operator.  */
     4418 
     4419 	call unchain_op (log_op_p);
     4420 	call optimize_if ((if_node_p));
     4421 	return;
     4422 
     4423 create_label:
     4424      proc (i) returns (fixed bin (18));
     4425 
     4426 dcl	(i, j)		fixed bin (18);
     4427 
     4428 /* create_label creates a label and attaches it to the opt_statement node whose offset in the quads
     4429*   is contained in i.  It returns the offset in x (the symbol area) of the label entry created.
     4430*   This second copy of create label is included for the use of the if optimizing subroutines, which
     4431*   are recursive, so that the copy used by the remainder of the converter can remain a quick
     4432*   procedure.  */
     4433 
     4434 	j = create_node (label_node, size (label));
     4435 	addr (x (j)) -> label.statement = i;
     4436 	addr (x (j)) -> label.operand_type = rel_constant;
     4437 	addr (x (j)) -> label.executable, addr (x (j)) -> label.referenced, addr (x (j)) -> label.allocate,
     4438 	     addr (x (j)) -> label.set = "1"b;
     4439 	if subp_ptr -> subprogram.last_label = 0
     4440 	then subp_ptr -> subprogram.first_label = j;
     4441 	else addr (x (subp_ptr -> subprogram.last_label)) -> label.next_label = j;
     4442 	subp_ptr -> subprogram.last_label = j;
     4443 	return (j);
     4444      end create_label;
     4445 
     4446 /* This copy of create_node is used only by the if optimizing subprograms.  Giving them a separate
     4447*   copy prevents create_node from becoming non_quick when it is used everywhere else in the
     4448*   converter.  */
     4449 
  9     1 /* BEGIN fort_create_node.incl.pl1 */
  9     2 
  9     3 /* Created:	October 1977, Richard Barnes
  9     4*
  9     5*   Modified:
  9     6*	22 May 1978, DSL - add create_constant.
  9     7*	09 Oct 1978, PES - make create_(constant node) return fixed bin(18) unsigned.
  9     8*	13 Dec 1978, PES - changes for large common and arrays.
  9     9**/
  9    10 create_node:   proc(type,length) returns(fixed bin (18));
  9    11 
  9    12 dcl	length			fixed bin;
  9    13 dcl	offset			fixed bin(18);
  9    14 dcl	type			fixed bin(4);
  9    15 dcl	storage(length)		fixed bin aligned based;
  9    16 dcl	x(0:operand_max_len-1)	fixed bin(35) aligned based(operand_base);
  9    17 dcl	(addr,char,ltrim,unspec)	builtin;
  9    18 
  9    19 
  9    20 	if (length + next_free_operand) < operand_max_len
  9    21 	   then do;
  9    22 	        offset = next_free_operand;
  9    23 	        next_free_operand = next_free_operand + length;
  9    24 	        unspec(addr(x(offset)) -> storage) = "0"b;
  9    25 	        addr(x(offset)) -> node.node_type = type;
  9    26 	        return(offset);
  9    27 	        end;
  9    28 	   else do;
  9    29 		call print_message(407, "operand region", ltrim(char(operand_max_len))); /* FATAL */
  9    30 	        end;
  9    31 
  9    32 	end create_node;
  9    33 
  9    34 /* END fort_create_node.incl.pl1 */
     4450 
     4451 unchain_op:
     4452      proc (op_p);
     4453 
     4454 dcl	op_p		ptr;
     4455 
     4456 /* unchain_op is called by the if_optimizer with a pointer to a logical operator node as its
     4457*   argument.  It removes the operator node from the quad chain, and releases its output temporary. */
     4458 
     4459 	addr (q (op_p -> operator.next)) -> operator.back = op_p -> operator.back;
     4460 	addr (q (op_p -> operator.back)) -> operator.next = op_p -> operator.next;
     4461 	addr (x (op_p -> operator.output)) -> temporary.next = next_free_temp;
     4462 	next_free_temp = op_p -> operator.output;
     4463 	return;
     4464      end unchain_op;
     4465 
     4466      end optimize_if;
     4467 
     4468 create_new_if:
     4469      proc (parent_if_p, use_jump, jump_target, expression);
     4470 
     4471 dcl	(b_p, f_p, parent_if_p, ti_p, ts_p)
     4472 			ptr;
     4473 dcl	(back, expression, forward, jump_target, last_st, next_st, parent_if, ti, ts, use_jump)
     4474 			fixed bin (18);
     4475 
     4476 /* create_new_if is called by optimize_if to create a new operator node for the jump being created
     4477*   from the left_hand_side of a logical expression.  It is called with a pointer to the parent if
     4478*   node, the jump type to be used, the jump target to be used, and the offset in the symbols of the
     4479*   logical variable or temporary to be tested.  It creates both the operator node, and a statement
     4480*   node.  The statement node is needed so this jump will have a proper "next" when create_new_if
     4481*   calls optimize_if for this new jump node.  A label will be generated later, only if the
     4482*   statement node is actually used as a jump target.  */
     4483 
     4484 	n_operands = 2;
     4485 	ti = next_free_quad;
     4486 	ti_p = addr (q (ti));
     4487 	ts = next_free_quad + size (operator);
     4488 	ts_p = addr (q (ts));
     4489 	next_free_quad = ts + size (opt_statement);
     4490 	if next_free_quad > quad_max_len
     4491 	then call print_message (407, "quadruple_region", char (quad_max_len));
     4492 
     4493 	unspec (ts_p -> opt_statement) = "0"b;
     4494 	unspec (ti_p -> operator) = "0"b;
     4495 	next_st = parent_if_p -> operator.next;
     4496 	last_st = fixed (addr (q (next_st)) -> opt_statement.back, 18);
     4497 	parent_if = addr (q (next_st)) -> opt_statement.prev_operator;
     4498 
     4499 /*    rechain statement chain     */
     4500 
     4501 	addr (q (last_st)) -> opt_statement.next = bit (fixed (ts, 18), 18);
     4502 	ts_p -> opt_statement.back = bit (fixed (last_st, 18), 18);
     4503 	addr (q (next_st)) -> opt_statement.back = bit (fixed (ts, 18), 18);
     4504 	ts_p -> opt_statement.next = bit (fixed (next_st, 18), 18);
     4505 
     4506 /*     rechain operator chain     */
     4507 
     4508 	ts_p -> operator.back = ti;
     4509 	ti_p -> operator.next = ts;
     4510 	b_p = addr (x (expression));
     4511 	if b_p -> node.node_type ^= temporary_node & b_p -> node.node_type ^= array_ref_node
     4512 	then back = last_st;
     4513 	else back = b_p -> temporary.output_by;
     4514 	b_p = addr (q (back));
     4515 	forward = b_p -> operator.next;
     4516 	f_p = addr (q (forward));
     4517 	b_p -> operator.next = ti;
     4518 	ti_p -> operator.back = back;
     4519 	f_p -> operator.back = ts;
     4520 	ts_p -> operator.next = forward;
     4521 
     4522 /*     fill in nodes bit by bit     */
     4523 
     4524 	ts_p -> opt_statement.op_code = stat_op;
     4525 	ts_p -> opt_statement.source_id = addr (q (last_st)) -> opt_statement.source_id;
     4526 	ts_p -> opt_statement.length = addr (q (last_st)) -> opt_statement.length;
     4527 	ts_p -> opt_statement.start = addr (q (last_st)) -> opt_statement.start;
     4528 	ts_p -> opt_statement.location = stm_ptr -> opt_statement.location;
     4529 	ts_p -> opt_statement.processed_by_converter = "1"b;
     4530 	ts_p -> opt_statement.put_in_map = "1"b;
     4531 	ts_p -> opt_statement.flow_unit, ts_p -> opt_statement.operator_list = null;
     4532 
     4533 	ti_p -> operator.op_code = use_jump;
     4534 	ti_p -> operator.number = 2;
     4535 	ti_p -> operator.primary = null;
     4536 	ti_p -> operator.operand (2) = jump_target;
     4537 	ti_p -> operator.operand (1) = expression;
     4538 	call optimize_if ((ti_p));
     4539 	return;
     4540      end create_new_if;
     4541 
     4542 optimize_vector:
     4543      proc ();
     4544 
     4545 dcl	(do_position, eol_position, n_dims_used, inner_do_position, i, j, n_dims, low, high, low_value, high_value,
     4546 	vector_length, vector_length_temp)
     4547 			fixed bin (18);
     4548 dcl	(low_p, high_p, r, dim_p, symb_p)
     4549 			ptr;
     4550 dcl	(optimized_something, low_is_variable, high_is_variable, high_bounds_differ, low_bounds_differ,
     4551 	must_keep_remaining_loops)
     4552 			bit (1) aligned;
     4553 
     4554 
     4555 /* optimize_vector is called when a do_op is hit on the stack.  At this point the stack contains
     4556*   (<>) {<do_op or counter> <incr> <lower> <upper> <index_var>} <...>
     4557*   (In the best cases there will be more than one level of do_op nesting) optimize_vector is called
     4558*   only for implied do's in i/o ops, and by the time it is called the do_op initialization stuff is
     4559*   already in the quads.  optimize_vector attempts to convert the implied do's into xmit_vectors,
     4560*   removing as many of the nested implied do's as possible.
     4561*
     4562*   NOTE: This is the one section of the converter which may actually modify the polish input.  */
     4563 
     4564 /* Remember where we are */
     4565 
     4566 	inner_do_position, do_position = polish_offset;
     4567 
     4568 /* CHECK--transmitted item must be subscripted.  This test will also toss us out if we have not yet
     4569*   hit the most deeply nested do.  */
     4570 
     4571 	if p (do_position + 3) ^= subscript_op
     4572 	then go to NO_OPT_VECTOR;
     4573 
     4574 /* Get number of dimensions, and figure out where the eol should be.  */
     4575 
     4576 	n_dims = p (do_position + 2) + bias;
     4577 	eol_position = do_position + 4 + n_dims * 2;
     4578 
     4579 /* CHECK--subscripts must not contain expressions (quick & dirty, but effective method).  */
     4580 
     4581 	if p (eol_position) ^= eol_op
     4582 	then go to NO_OPT_VECTOR;
     4583 
     4584 	symb_p = addr (x (p (inner_do_position + 1)));
     4585 	dim_p = addr (x (symb_p -> symbol.dimension));
     4586 
     4587 	optimized_something = "0"b;
     4588 
     4589 /* initial vector length is just the element size.  final vector length will be
     4590*   vector_length*vector_length_temp.  The constant and variable parts are kept separate to enable
     4591*   maximum compile time evaluation.  */
     4592 
     4593 	if symb_p -> symbol.v_length = 0
     4594 	then do;
     4595 		vector_length = symb_p -> symbol.element_size;
     4596 		vector_length_temp = 0;
     4597 	     end;
     4598 	else do;
     4599 		vector_length = 1;
     4600 		vector_length_temp = symb_p -> symbol.v_length;
     4601 	     end;
     4602 
     4603 	n_dims_used = 0;
     4604 
     4605 /*  Check for validity at each contained level */
     4606 
     4607 	must_keep_remaining_loops = "0"b;
     4608 	do i = 1 by 1 while (^must_keep_remaining_loops);
     4609 
     4610 /* if work_stack_offset < 5 there are no more do_op entries in the stack.  We're done.  */
     4611 
     4612 	     if work_stack_offset < 5
     4613 	     then go to NO_MORE_DIMS;
     4614 
     4615 /* if the next thing down in the stack is not a do_op we're done.  */
     4616 
     4617 	     if stack (work_stack_offset - 1) ^= do_op
     4618 	     then go to NO_MORE_DIMS;
     4619 
     4620 /* CHECK--the subscript must be the same variable as the do index.  */
     4621 
     4622 	     if p (inner_do_position + 2 + i * 2) ^= stack (work_stack_offset - 5)
     4623 	     then go to NO_MORE_DIMS;
     4624 
     4625 /* CHECK--the increment must be a constant integer 1--at this point we know that this also means
     4626*   the index_var and upper and lower bounds are integer, since match_index_type was called before
     4627*   we were.  */
     4628 
     4629 	     if stack (work_stack_offset - 2) ^= one
     4630 	     then go to NO_MORE_DIMS;
     4631 
     4632 /* CHECK--the array item must be the only item in the list at this level.  */
     4633 
     4634 	     if p (eol_position + 1 + i) ^= exit_op | exit_stack.xmit_at_this_level ^= 0
     4635 	     then go to NO_MORE_DIMS;
     4636 
     4637 /* CHECK--this subscript must not be aliasable with any of the remaining subscripts */
     4638 
     4639 	     do j = i + 1 to n_dims;
     4640 		if aliasable (p (inner_do_position + 2 + i * 2), p (inner_do_position + 2 + j * 2))
     4641 		then go to NO_MORE_DIMS;
     4642 	     end;
     4643 
     4644 /* CHECK--contained do's must cover complete dimension--if that's true of this dimension, we'll
     4645*   keep going in this loop.  If not true of this dimension, we'll branch to ONE_MORE_DIM to see if
     4646*   this partial dimension can be taken out.  */
     4647 
     4648 	     low = stack (work_stack_offset - 4);
     4649 	     high = stack (work_stack_offset - 3);
     4650 	     low_p = addr (x (low));
     4651 	     high_p = addr (x (high));
     4652 
     4653 /* If we got this far, we're gonna take this level of implied do out.  */
     4654 
     4655 	     optimized_something = "1"b;
     4656 
     4657 /* If upper is not a constant, then it was output by an assign generated to make a frozen_for_do
     4658*   temp.  In that case we can pitch the assign_op node and the associated temp, and set high to be
     4659*   the original value before that assign was generated.  If the new high is a temp or array_ref,
     4660*   the assign would have caused its ref_count to be bumped, so we gotta decrement it.  */
     4661 
     4662 	     if high_p -> node.node_type ^= constant_node
     4663 	     then do;
     4664 		     r = addr (q (high_p -> temporary.output_by));
     4665 		     if r -> operator.next ^= 0
     4666 		     then addr (q (r -> operator.next)) -> operator.back = r -> operator.back;
     4667 		     else do;
     4668 			     last_quad_p = addr (q (r -> operator.back));
     4669 			     last_op_index, op_index = r -> operator.back;
     4670 			     next_free_quad = last_quad_p -> operator.next;
     4671 			end;
     4672 		     addr (q (r -> operator.back)) -> operator.next = r -> operator.next;
     4673 		     high_p -> temporary.next = next_free_temp;
     4674 		     next_free_temp = high;
     4675 		     stack (work_stack_offset - 3), high = r -> operator.operand (1);
     4676 		     high_p = addr (x (high));
     4677 		     if high_p -> node.node_type = temporary_node | high_p -> node.node_type = array_ref_node
     4678 		     then high_p -> temporary.ref_count = high_p -> temporary.ref_count - 1;
     4679 		end;
     4680 
     4681 /* Take out this level of implied do-loop.  The variables to watch are low_p
     4682*   and high_p, pointers to the symbol nodes for the lower and upper bounds,
     4683*   respectively, and low_value and high_value, which contain the bound values
     4684*   themselves if the corresponding bounds are constant.  The variables
     4685*   low_is_variable and high_is_variable serve as flags to indicate whether the
     4686*   bounds are constant or variable.  The tricky part is that we want to
     4687*   minimize run_time code -- the length used from this dim will be
     4688*   (high-low)+1, but we will compute it as either (high+1)-low or high-(low-1)
     4689*   if high or low is constant.  Have to take care not to do both (high+1) and
     4690*   (low-1) if both are constant.
     4691*
     4692*   If the low or high bound of the implied do-loop is not the same as the
     4693*   corresponding array bound, this implied loop either does not or might not
     4694*   cover the entire dimension and we must set 'must_keep_remaining_loops'.  */
     4695 
     4696 	     low_bounds_differ = "0"b;
     4697 	     if low_p -> node.node_type ^= constant_node
     4698 	     then do;
     4699 		     low_is_variable = "1"b;
     4700 		     low_value = 0;
     4701 		     if low ^= dim_p -> dimension.lower_bound (i)
     4702 		     then low_bounds_differ = "1"b;
     4703 		end;
     4704 	     else do;
     4705 		     low_is_variable = "0"b;
     4706 		     unspec (low_value) = low_p -> constant.value;
     4707 		     if dim_p -> dimension.v_bound (i).lower | dim_p -> dimension.lower_bound (i) ^= low_value
     4708 		     then do;
     4709 			     low_bounds_differ = "1"b;
     4710 			     if ^valid_subscript (dim_p, i, low_value)
     4711 			     then call print_message (422, low, stack (work_stack_offset - 5));
     4712 			end;
     4713 		end;
     4714 
     4715 	     high_bounds_differ = "0"b;
     4716 	     if high_p -> node.node_type ^= constant_node
     4717 	     then do;
     4718 		     high_is_variable = "1"b;
     4719 		     high_value = 0;
     4720 		     if high ^= dim_p -> dimension.upper_bound (i)
     4721 		     then high_bounds_differ = "1"b;
     4722 		end;
     4723 	     else do;
     4724 		     high_is_variable = "0"b;
     4725 		     unspec (high_value) = high_p -> constant.value;
     4726 		     if dim_p -> dimension.v_bound (i).upper | dim_p -> dimension.upper_bound (i) ^= high_value
     4727 		     then do;
     4728 			     high_bounds_differ = "1"b;
     4729 			     if ^valid_subscript (dim_p, i, high_value)
     4730 			     then call print_message (422, high, stack (work_stack_offset - 5));
     4731 			end;
     4732 		end;
     4733 
     4734 	     if low_bounds_differ | high_bounds_differ
     4735 	     then must_keep_remaining_loops = "1"b;
     4736 
     4737 /* If both bounds are constants, we'll just do the calculation of vector length here.  */
     4738 
     4739 	     if ^low_is_variable & ^high_is_variable
     4740 	     then vector_length = vector_length * (high_value - low_value + 1);
     4741 
     4742 /* otherwise, move the high node into the stack.  If high_value is constant, add one before
     4743*   creating the constant node.  Then, move the low node into the stack.  If low_value is constant
     4744*   we'll subtract one before creating the constant node, unless high was also constant (shouldn't
     4745*   happen, but better to test).  generate a sub_op node to take the difference.  If both high and
     4746*   low were non-constant values, have to generate an explicit add of one.  Finally, if there is
     4747*   already a vector length temp part, generate a mult node to multiply it in.  Take the result and
     4748*   stuff it into vector_length_temp, bump the count of dimensions removed, set the appropriate
     4749*   array_ref subscript in the polish to the lower bound for later origin calculation, and call
     4750*   unthread_do to pop the exit_stack, take the do entry off the work stack, and throw out any quads
     4751*   that were generated in the do initialization for this do.  */
     4752 
     4753 	     else do;
     4754 		     if ^high_is_variable
     4755 		     then do;
     4756 			     high_value = high_value + 1;
     4757 			     stack (work_stack_offset) = create_integer_constant ((high_value));
     4758 			end;
     4759 		     else stack (work_stack_offset) = high;
     4760 		     if low_is_variable | low_value ^= 1
     4761 		     then do;
     4762 			     if low_is_variable
     4763 			     then stack (work_stack_offset + 1) = low;
     4764 			     else do;
     4765 				     if high_is_variable
     4766 				     then low_value = low_value - 1;
     4767 				     stack (work_stack_offset + 1) = create_integer_constant ((low_value));
     4768 				     if high_is_variable
     4769 				     then low_value = low_value + 1;
     4770 				end;
     4771 			     stack (work_stack_offset + 2) = sub_op;
     4772 			     call bump_work_stack_offset (+3);
     4773 			     call process_arith ("0"b);
     4774 			     call bump_work_stack_offset (-1);
     4775 			end;
     4776 
     4777 		     if low_is_variable & high_is_variable
     4778 		     then do;
     4779 			     stack (work_stack_offset + 1) = one;
     4780 			     stack (work_stack_offset + 2) = add_op;
     4781 			     call bump_work_stack_offset (+3);
     4782 			     call process_arith ("0"b);
     4783 			     call bump_work_stack_offset (-1);
     4784 			end;
     4785 
     4786 		     if vector_length_temp ^= 0
     4787 		     then do;
     4788 			     stack (work_stack_offset + 1) = vector_length_temp;
     4789 			     stack (work_stack_offset + 2) = mult_op;
     4790 			     call bump_work_stack_offset (+3);
     4791 			     call process_arith ("0"b);
     4792 			     call bump_work_stack_offset (-1);
     4793 			end;
     4794 		     vector_length_temp = stack (work_stack_offset);
     4795 		end;
     4796 	     n_dims_used = n_dims_used + 1;
     4797 	     p (inner_do_position + 2 + n_dims_used * 2) = low;
     4798 	     call unthread_do;
     4799 	end;
     4800 
     4801 /* If we haven't accomplished anything really, just go away. */
     4802 
     4803 NO_MORE_DIMS:
     4804 	if ^optimized_something
     4805 	then go to NO_OPT_VECTOR;
     4806 
     4807 /* Now we reduce vector_length*vector_length_temp to a single temporary node which goes back into
     4808*   vector_length_temp.  Take care not to generate any unneeded ops, though.  */
     4809 
     4810 	if vector_length ^= 1
     4811 	then do;
     4812 		stack (work_stack_offset) = create_integer_constant ((vector_length));
     4813 		if vector_length_temp ^= 0
     4814 		then do;
     4815 			stack (work_stack_offset + 1) = vector_length_temp;
     4816 			stack (work_stack_offset + 2) = mult_op;
     4817 			call bump_work_stack_offset (+3);
     4818 			call process_arith ("0"b);
     4819 			call bump_work_stack_offset (-1);
     4820 		     end;
     4821 		vector_length_temp = stack (work_stack_offset);
     4822 	     end;
     4823 
     4824 /* Back polish_offset up a bit for safety.  Otherwise we might overwrite something we haven't
     4825*   processed yet.  5 is a safe number, since we've eliminated at least 1 do op, which used at least
     4826*   5 polish entries.  */
     4827 
     4828 	polish_offset = polish_offset - 5;
     4829 
     4830 /* Finally we create a proper polish xmit_vector_op entry.  If we took out all the dimensions
     4831*   and if the last loop we took out started at the first element of that dimension, we can discard
     4832*   the array ref stuff and just use the array; otherwise move the array ref stuff, which has
     4833*   been changed from it's original form to now represent the origin for the xmit_vector, towards
     4834*   the beginning of the polish stack.  Put in the length temp and an xmit_vector_op following it.
     4835*   Finally, an increment_polish to skip over an appropriate number of eliminated exit_ops.  On
     4836*   return, we'll go back and run across this new stuff and just pretend the parse put it there.  */
     4837 
     4838 	if n_dims_used = dim_p -> dimension.number_of_dims & ^low_bounds_differ
     4839 	then j = 1;
     4840 	else j = n_dims * 2 + 4;
     4841 	do i = 1 to j;
     4842 	     p (polish_offset + i) = p (inner_do_position + i);
     4843 	end;
     4844 	p (polish_offset + i) = vector_length_temp;
     4845 	i = i + 1;
     4846 	p (polish_offset + i) = xmit_vector_op;
     4847 	i = i + 1;
     4848 	if exit_offset ^= 0
     4849 	then if exit_stack.op = do_op
     4850 	     then exit_stack.xmit_at_this_level = exit_stack.xmit_at_this_level + 1;
     4851 	p (polish_offset + i) = increment_polish_op;
     4852 	p (polish_offset + i + 1) = eol_position + n_dims_used - polish_offset - i;
     4853 
     4854 NO_OPT_VECTOR:
     4855 	return;
     4856 
     4857 unthread_do:
     4858      proc ();
     4859 
     4860 dcl	st		fixed bin (18);
     4861 dcl	(a, o)		ptr;
     4862 
     4863 /* unthread_do is called by optimize_vector to remove no longer needed do initialization code.
     4864*   If exit_stack.ptr is nonnull, it points to an assign_op followed by an opt_statement node,
     4865*   both of which will be freed.  If exit_stack.zero_trip_branch is nonzero, there are three
     4866*   items between the assign_op and the opt_statement: a comparison of some sort, a
     4867*   jump_false operator, and an opt_statement node.  These will also be freed.
     4868*   Whether or not there are any operators to be freed, unthread_do pops the exit stack and
     4869*   replaces one level of DO on the work stack by an assignment to the loop index of the final
     4870*   loop value plus one. */
     4871 
     4872 	if exit_stack.ptr ^= null ()
     4873 	then do;
     4874 
     4875 /* unthread the assign_op */
     4876 
     4877 		a = exit_stack.ptr;
     4878 		call unthread (a);
     4879 		o = addr (x (a -> operator.operand (1)));
     4880 		if o -> node.node_type = temporary_node | o -> node.node_type = array_ref_node
     4881 		then o -> temporary.ref_count = o -> temporary.ref_count - 1;
     4882 
     4883 		a = addr (q (a -> operator.next));
     4884 
     4885 		if exit_stack.zero_trip_branch ^= 0
     4886 		then do;
     4887 
     4888 /* unthread the comparison operator */
     4889 
     4890 			call unthread (a);
     4891 			addr (x (a -> operator.output)) -> temporary.next = next_free_temp;
     4892 			next_free_temp = a -> operator.output;
     4893 
     4894 			a = addr (q (a -> operator.next));
     4895 
     4896 /* unthread the jump_false operator */
     4897 
     4898 			call unthread (a);
     4899 
     4900 			a = addr (q (a -> operator.next));
     4901 
     4902 /* unthread the inner opt_statement node */
     4903 
     4904 			call unthread (a);
     4905 			st = fixed (a -> opt_statement.back, 18);
     4906 			addr (q (st)) -> opt_statement.next = a -> opt_statement.next;
     4907 			st = fixed (a -> opt_statement.next, 18);
     4908 			addr (q (st)) -> opt_statement.back = a -> opt_statement.back;
     4909 
     4910 			a = addr (q (a -> opt_statement.first_operator));
     4911 
     4912 		     end;
     4913 
     4914 /* unthread the final opt_statement node */
     4915 
     4916 		st = fixed (a -> opt_statement.back, 18);
     4917 		addr (q (st)) -> opt_statement.next = a -> opt_statement.next;
     4918 		opst, last_opt_statement = addr (q (st));
     4919 		addr (x (a -> opt_statement.label)) -> label.statement = 0;
     4920 		if a -> opt_statement.first_operator = 0
     4921 		then do;
     4922 			last_op_index, op_index = a -> opt_statement.prev_operator;
     4923 			last_quad_p = addr (q (op_index));
     4924 			next_free_quad = last_quad_p -> operator.next;
     4925 			last_quad_p -> operator.next = 0;
     4926 		     end;
     4927 		else do;
     4928 			addr (q (a -> opt_statement.prev_operator)) -> operator.next =
     4929 			     a -> opt_statement.first_operator;
     4930 			addr (q (a -> opt_statement.first_operator)) -> operator.back =
     4931 			     a -> opt_statement.prev_operator;
     4932 		     end;
     4933 	     end;
     4934 
     4935 	call pop_exit_stack ();
     4936 
     4937 /* The stack is now (<>) <dp_op> <incr> <upper> <lower> <index var> <...>.
     4938*   Change it to (<>) <add_op> <upper> <one> <index var> <...> and process
     4939*   the add, leaving (<>) <sum> <index var> <...>.  Change that to (<>)
     4940*   <assign_op> <sum> <index var> <...>.  Process the assignment, leaving
     4941*   (<>) <...> and return. */
     4942 
     4943 	call bump_work_stack_offset (-1);		/* Discard <do_op>. */
     4944 	stack (work_stack_offset - 1) = add_op;		/* Replace <incr> with <add_op>. */
     4945 	stack (work_stack_offset - 3) = one;		/* Replace <lower> with <one>. */
     4946 	call process_arith ("0"b);			/* Replace <add_op> <upper> <one> by its <sum>. */
     4947 	stack (work_stack_offset) = assign_op;
     4948 	call bump_work_stack_offset (+1);
     4949 	call process_assign;
     4950 	return;
     4951 
     4952 unthread:
     4953      procedure (op);
     4954 
     4955 dcl	op		pointer;
     4956 
     4957 /* unthread is called by unthread_do to remove a single operator from the quad chain.
     4958*   It is assumed that the operator is not at the end of the chain. */
     4959 
     4960 	addr (q (op -> operator.next)) -> operator.back = op -> operator.back;
     4961 	addr (q (op -> operator.back)) -> operator.next = op -> operator.next;
     4962 	return;
     4963 
     4964      end unthread;
     4965 
     4966      end unthread_do;
     4967 
     4968 aliasable:
     4969      proc (offset1, offset2) returns (bit (1) aligned);
     4970 
     4971 dcl	offset1		fixed bin (18),
     4972 	offset2		fixed bin (18);
     4973 dcl	p1		ptr,
     4974 	p2		ptr;
     4975 
     4976 /* aliasable is called with the symbol table offsets of two variables or temps.  it returns "1"b if
     4977*   the two may be aliases of the same storage, "0"b otherwise.  */
     4978 
     4979 	if offset1 = offset2
     4980 	then return ("1"b);
     4981 	p1 = addr (x (offset1));
     4982 	p2 = addr (x (offset2));
     4983 	if p2 -> node.node_type ^= symbol_node
     4984 	then return ("0"b);
     4985 	if ^p1 -> symbol.equivalenced & ^p1 -> symbol.parameter
     4986 	then return ("0"b);
     4987 	if ^p2 -> symbol.equivalenced & ^p2 -> symbol.parameter
     4988 	then return ("0"b);
     4989 	return ("1"b);
     4990      end aliasable;
     4991 
     4992 valid_subscript:
     4993      procedure (dim_p, dim_no, value) returns (bit (1) aligned);
     4994 
     4995 /* valid_subscript checks value to see if it is a valid subscript value for
     4996*   dimension dim_no of the array described by the dimension node pointed to
     4997*   by dim_p.  If the value is known to fall outside the legal range, "0"b is
     4998*   returned.  In all other cases, "1"b is returned. */
     4999 
     5000 dcl	dim_p		pointer;
     5001 dcl	(dim_no, i)	fixed binary (18);
     5002 dcl	value		fixed binary (18);
     5003 
     5004 	i = dim_no;
     5005 
     5006 	if ^dim_p -> dimension.v_bound (i).lower
     5007 	then if value < dim_p -> dimension.lower_bound (i)
     5008 	     then return ("0"b);
     5009 
     5010 	if ^dim_p -> dimension.v_bound (i).upper
     5011 	then if value > dim_p -> dimension.upper_bound (i)
     5012 	     then return ("0"b);
     5013 
     5014 	return ("1"b);
     5015 
     5016      end valid_subscript;
     5017 
     5018      end optimize_vector;
     5019 
     5020 effective_operand:
     5021      proc (opnd) returns (fixed bin (18));
     5022 
     5023 /*  Function to replace an operand by its effective value.  */
     5024 
     5025 dcl	opnd		fixed bin (18);		/* incoming operand */
     5026 
     5027 dcl	op		fixed bin (18);		/* outgoing operand */
     5028 dcl	p		ptr;			/* pointer to symbol */
     5029 
     5030 	op = opnd;
     5031 	if op > 0
     5032 	then do;
     5033 		p = addr (x (op));
     5034 		if p -> node.node_type = label_node
     5035 		then if p -> label.format
     5036 		     then do;
     5037 			     op = p -> label.format_var;
     5038 			     p = addr (x (op));
     5039 			end;
     5040 		if p -> node.node_type = symbol_node
     5041 		then if p -> symbol.named_constant
     5042 		     then op = p -> symbol.initial;
     5043 	     end;
     5044 	return (op);
     5045      end effective_operand;
     5046 
     5047      end fort_converter;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/10/88  1336.9  fort_converter.pl1                >spec>install>MR12.2-1209>fort_converter.pl1
281          1    03/27/82  0437.1  fort_utilities.incl.pl1           >ldd>include>fort_utilities.incl.pl1
1-11         2    03/27/82  0437.8  fort_create_node.incl.pl1         >ldd>include>fort_create_node.incl.pl1
1-37         3    10/30/80  1648.7  relocation_bits.incl.pl1          >ldd>include>relocation_bits.incl.pl1
283          4    11/10/88  1314.2  fort_nodes.incl.pl1               >spec>install>MR12.2-1209>fort_nodes.incl.pl1
285          5    08/04/86  2015.0  fort_system_constants.incl.pl1    >ldd>include>fort_system_constants.incl.pl1
288          6    08/04/86  2015.0  fort_shared_vars.incl.pl1         >ldd>include>fort_shared_vars.incl.pl1
290          7    08/06/87  1153.7  fort_options.incl.pl1             >ldd>include>fort_options.incl.pl1
292          8    03/27/82  0424.8  fort_opt_nodes.incl.pl1           >ldd>include>fort_opt_nodes.incl.pl1
4450         9    03/27/82  0437.8  fort_create_node.incl.pl1         >ldd>include>fort_create_node.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
VLA                       4            based           bit(1)                   level 3 packed packed unaligned dcl 4-844 ref 1457
                                                                                  3533
VLA_base_addressor        4            based           fixed bin(18,0)          level 2 dcl 4-383 ref 1459
VLA_is_256K             115(03)        based           bit(1)                   level 4 packed packed unaligned dcl 287 ref 3563
a                               002344 automatic       pointer                  dcl 4861 set ref 4877* 4878* 4879 4883* 4883 4890*
                                                                                  4891 4892 4894* 4894 4898* 4900* 4900 4904* 4905
                                                                                  4906 4907 4908 4910* 4910 4916 4917 4919 4920 4922
                                                                                  4928 4928 4930 4930
a_data_type                     001272 automatic       fixed bin(4,0)           dcl 1-15 set ref 1-40* 1-43 1-43 1-43 1-45 1-45 1-47
                                                                                  1-65 1-81
a_ptr                                  parameter       pointer                  dcl 122 ref 20 301
a_value                         001274 automatic       bit(72)                  dcl 1-16 set ref 1-41* 1-51 1-52 1-54 1-54 1-65 1-85
add_op                                 constant        fixed bin(18,0)          initial dcl 5-197 set ref 1015 1029 1677 1885 2562
                                                                                  2569 2579 3392 3511 3557 3772* 3791* 4780 4944
addr                                                   builtin function         dcl 9-17 in procedure "create_node" ref 9-24 9-25
addr                                                   builtin function         dcl 2-17 in procedure "create_node" ref 2-24 2-25
addr                                                   builtin function         dcl 276 in procedure "fort_converter" ref 314 316
                                                                                  318 320 322 324 326 328 337 345 368 388 388 392
                                                                                  404 405 409 560 561 628 628 628 644 644 644 691
                                                                                  691 691 832 834 834 836 838 846 884 959 971 979
                                                                                  1063 1065 1073 1144 1144 1146 1247 1251 1285 1365
                                                                                  1394 1408 1412 1413 1432 1433 1594 1594 1594 1647
                                                                                  1647 1647 1667 1667 1672 1672 1827 1827 1827 1848
                                                                                  1848 1848 1848 1848 1848 1855 2197 2204 2206 2206
                                                                                  2227 2229 2229 2257 2257 2257 2257 2270 2271 2272
                                                                                  2311 2388 2430 2442 2445 2448 2450 2452 2457 2462
                                                                                  2463 2508 2600 2678 2689 2709 2709 2749 2749 2749
                                                                                  2769 2798 2813 2827 2838 2853 2866 2880 2894 2902
                                                                                  2917 2935 2953 2968 2984 2998 3014 3043 3051 3057
                                                                                  3077 3109 3117 3258 3259 3260 3261 3263 3267 3311
                                                                                  3632 3690 3694 3714 3733 3780 3781 3781 3782 3796
                                                                                  3815 3844 3844 3844 3844 3847 3847 3861 3862 3863
                                                                                  3908 3915 3962 3973 3997 3999 3999 4018 4026 4046
                                                                                  4048 4075 4103 4126 4127 4128 4128 4128 4128 4132
                                                                                  4146 4146 4146 4146 4146 4166 4173 4214 4217 4229
                                                                                  4229 4229 4229 4252 4274 4283 4312 4314 4362 4367
                                                                                  4367 4400 4402 4404 4404 4406 4407 4435 4436 4437
                                                                                  4437 4437 4437 4441 4459 4460 4461 4486 4488 4496
                                                                                  4497 4501 4503 4510 4514 4516 4525 4526 4527 4584
                                                                                  4585 4650 4651 4664 4665 4668 4672 4676 4879 4883
                                                                                  4891 4894 4900 4906 4908 4910 4917 4918 4919 4923
                                                                                  4928 4930 4960 4961 4981 4982 5033 5038
addr                                                   builtin function         dcl 1-18 in procedure "create_constant" ref 1-51
                                                                                  1-52 1-54 1-54 1-63 1-80 1-91
addressing_bits           0(14)        based           structure                level 2 in structure "temporary" packed packed
                                                                                  unaligned dcl 4-1005 in procedure "fort_converter"
addressing_bits           0(14)        based           structure                level 2 in structure "constant" packed packed
                                                                                  unaligned dcl 4-256 in procedure "fort_converter"
allocate                  0(25)        based           bit(1)                   level 5 in structure "symbol" packed packed
                                                                                  unaligned dcl 4-844 in procedure "fort_converter"
                                                                                  set ref 4278*
allocate                  0(25)        based           bit(1)                   level 5 in structure "label" packed packed unaligned
                                                                                  dcl 4-530 in procedure "fort_converter" set ref
                                                                                  4128* 4437*
allocate_symbol_name            001246 automatic       fixed bin(17,0)          dcl 4-525 set ref 4272* 4273 4273
and_op                                 constant        fixed bin(18,0)          initial dcl 5-197 ref 4383 4394
ansi_77                  11(30)        based           bit(1)                   level 3 packed packed unaligned dcl 4-753 ref 1263
                                                                                  1328 1653
arg_info                  7            based           structure                array level 2 dcl 180
arg_no                          001754 automatic       fixed bin(18,0)          dcl 3170 set ref 3177* 3178* 3182 3183 3186 3186
array_parent_p                  002072 automatic       pointer                  dcl 3895 set ref 3908* 3910 3924*
array_ptr                       001160 automatic       pointer                  dcl 254 set ref 3650 3837 3915* 3916 3917 3918 3919
                                                                                  3920 3922 3925 3928 3929
array_ref                              based           structure                level 1 dcl 4-155 set ref 3912 3912
array_ref_node                  000243 constant        fixed bin(4,0)           initial dcl 5-87 set ref 644 691 1594 1647 1827 2749
                                                                                  3691 3912* 3960 4048 4229 4511 4677 4880
array_ref_type                         constant        fixed bin(4,0)           initial dcl 5-120 ref 3917
array_size                3            based           fixed bin(24,0)          level 2 dcl 4-383 ref 3617 3796
assign_op                              constant        fixed bin(18,0)          initial dcl 5-197 ref 1019 1033 1255 1267 1304 1321
                                                                                  4947
assumed_size              0(28)        based           bit(1)                   level 2 packed packed unaligned dcl 4-383 ref 2605
attributes               10            based           structure                level 2 dcl 4-844
automatic                11            based           bit(1)                   level 4 packed packed unaligned dcl 4-844 set ref
                                                                                  4278*
b_p                             000142 automatic       pointer                  dcl 4471 set ref 4510* 4511 4511 4513 4514* 4515
                                                                                  4517
back                      2(18)        based           bit(18)                  level 2 in structure "opt_statement" packed packed
                                                                                  unaligned dcl 8-176 in procedure "fort_converter"
                                                                                  set ref 561 1408 1413 4170* 4496 4502* 4503* 4905
                                                                                  4908* 4908 4916
back                            000152 automatic       fixed bin(18,0)          dcl 4473 in procedure "create_new_if" set ref 4511*
                                                                                  4513* 4514 4518
back                      1(18)        based           fixed bin(18,0)          level 2 in structure "operator" packed packed
                                                                                  unsigned unaligned dcl 8-144 in procedure
                                                                                  "fort_converter" set ref 2270* 2270 2271 2456
                                                                                  2462* 2462 2463 3260 3261* 3261 3264* 3861* 3861
                                                                                  3862 4216* 4459* 4459 4460 4508* 4518* 4519* 4665*
                                                                                  4665 4668 4669 4672 4930* 4960* 4960 4961
base                            001400 automatic       fixed bin(18,0)          dcl 2280 set ref 2331* 2339
bias                                   constant        fixed bin(19,0)          initial dcl 5-56 ref 938 939 942 979 1146 1431 1668
                                                                                  1673 1719 2788 2895 3925 3950 3957 3968 3978 4576
bif_index                       001516 automatic       fixed bin(18,0)          dcl 2667 set ref 2678* 2682 2694 2695* 2697* 2701
                                                                                  2702* 2725 2731
big_offset                      002007 automatic       bit(1)                   dcl 3277 in procedure "process_1_subscript" set ref
                                                                                  3572* 3616* 3617* 3630 3650
big_offset                      002026 automatic       bit(1)                   packed unaligned dcl 3665 in procedure
                                                                                  "process_substr" set ref 3695* 3700* 3796* 3815
                                                                                  3837
binary                                                 builtin function         dcl 276 in procedure "fort_converter" ref 2605
binary                                                 builtin function         dcl 1-19 in procedure "create_constant" ref 1-57
bit                                                    builtin function         dcl 276 ref 4501 4502 4503 4504
bit_value                       002250 automatic       bit(72)                  dcl 4292 set ref 4294* 4295*
bits                      0(25)        based           structure                level 2 in structure "symbol" packed packed
                                                                                  unaligned dcl 4-844 in procedure "fort_converter"
bits                      3            based           structure                level 2 in structure "statement" packed packed
                                                                                  unaligned dcl 4-721 in procedure "fort_converter"
bits                      0(25)        based           structure                level 2 in structure "temporary" packed packed
                                                                                  unaligned dcl 4-1005 in procedure "fort_converter"
bits                      0(25)        based           structure                level 2 in structure "label" packed packed unaligned
                                                                                  dcl 4-530 in procedure "fort_converter"
bits                      1            based           structure                level 2 in structure "dim_size_list" dcl 243
                                                                                  in procedure "fort_converter"
bits                      4            based           structure                level 2 in structure "opt_statement" packed packed
                                                                                  unaligned dcl 8-176 in procedure "fort_converter"
                                                                                  set ref 1408*
bits                      0(25)        based           structure                level 2 in structure "array_ref" packed packed
                                                                                  unaligned dcl 4-155 in procedure "fort_converter"
block_if_clause_count           000100 automatic       fixed bin(18,0)          dcl 126 set ref 1719* 2969 2973 2974
block_if_offset                 000101 automatic       fixed bin(18,0)          dcl 126 set ref 325* 326 2972 2974* 2982* 2984 3136
                                                                                  3153 3153
block_if_op                            constant        fixed bin(18,0)          initial dcl 5-197 ref 864 1191 1195 4065 4100
block_if_stack                         based           structure                level 1 dcl 235 set ref 2969 2974 2983* 3153
block_if_stack_p                001162 automatic       pointer                  dcl 254 set ref 326* 866 866 868 868 874 874 875 875
                                                                                  880 884 885 885 1721 1722 1729 1743 1746 2968*
                                                                                  2969 2972 2973 2974 2982 2983 2984* 3153 4102 4103
bool                                                   builtin function         dcl 1-20 ref 1-54
bound_constant                  002027 automatic       bit(1)                   array packed unaligned dcl 3665 set ref 3720* 3731*
                                                                                  3733 3742 3751 3769
bound_index                     002032 automatic       fixed bin(18,0)          array dcl 3670 set ref 3725* 3732* 3756* 3764 3769*
                                                                                  3772* 3772* 3772* 3772*
bound_ptr                       002024 automatic       pointer                  dcl 3663 set ref 3714* 3731 3733
bound_value                     002042 automatic       fixed bin(35,0)          array dcl 3680 set ref 3733* 3748 3751 3751 3769
                                                                                  3769
builtin_op                             constant        fixed bin(18,0)          initial dcl 5-197 ref 1156
by_compiler               0(35)        based           bit(1)                   level 3 packed packed unaligned dcl 4-844 set ref
                                                                                  4278*
c_ptr                           002264 automatic       pointer                  dcl 4303 set ref 4312* 4315 4318 4321
call_op                                constant        fixed bin(18,0)          initial dcl 5-197 ref 1125
calls_local_entries             000156 automatic       bit(1)                   initial dcl 158 set ref 158* 356* 1474* 1522*
cat_op                                 constant        fixed bin(18,0)          initial dcl 5-197 ref 1684 2207 2230 3974
chain_end                11            based           fixed bin(18,0)          array level 3 dcl 180 set ref 845* 3255 3269*
chain_op                               constant        fixed bin(18,0)          initial dcl 5-197 ref 1109
chain_start              10            based           fixed bin(18,0)          array level 3 dcl 180 set ref 412 842 842* 846* 846
                                                                                  850* 2905* 3254 3269*
char                                                   builtin function         dcl 1-21 in procedure "create_constant" ref 1-45
                                                                                  1-45
char                                                   builtin function         dcl 2-17 in procedure "create_node" ref 2-29 2-29
char                                                   builtin function         dcl 276 in procedure "fort_converter" ref 450 450
                                                                                  1910 1910 2411 2411 4164 4164 4208 4208 4211 4211
                                                                                  4490 4490
char                                                   builtin function         dcl 9-17 in procedure "create_node" ref 9-29 9-29
char_bif                               constant        fixed bin(18,0)          initial dcl 2671 ref 2731
char_constant                          based           structure                level 1 dcl 4-316
char_constant_node                     constant        fixed bin(4,0)           initial dcl 5-87 ref 3950
char_len                        002074 automatic       fixed bin(18,0)          dcl 3896 set ref 3924* 3925 3925 3928
char_mode                              constant        fixed bin(4,0)           initial dcl 5-106 ref 1-43 979 1146 1687 1848 3703
                                                                                  3922
char_size                10            based           fixed bin(20,0)          level 4 packed packed unsigned unaligned dcl 4-844
                                                                                  ref 2678 3204 3206 3208 3957
char_units                             constant        fixed bin(3,0)           initial dcl 5-136 ref 3617
clause                    2            based           fixed bin(18,0)          level 2 dcl 235 set ref 866* 866 868 885 1721*
close_op                               constant        fixed bin(18,0)          initial dcl 5-197 ref 806 1117
cmpx_mode                              constant        fixed bin(4,0)           initial dcl 5-106 ref 2392 2395
combination_type                000102 automatic       fixed bin(18,0)          dcl 126 set ref 1794 2392* 2395* 2397* 3172
concatenates_star_extents       000157 automatic       bit(1)                   initial dcl 158 set ref 158* 357* 1664*
constant                  6            based           fixed bin(18,0)          level 3 in structure "sub_stack" dcl 162
                                                                                  in procedure "fort_converter" set ref 1442* 1446*
                                                                                  3341 3352 3401 3414* 3414 3440 3441 3449* 3449
constant                 11            based           fixed bin(18,0)          level 3 in structure "sub_stack" dcl 162
                                                                                  in procedure "fort_converter" set ref 1437* 3463*
                                                                                  3463 3554 3556 3560* 3579* 3579 3581 3617 3617
constant                               based           structure                level 1 dcl 4-256 in procedure "fort_converter" set
                                                                                  ref 1-74 1-74
constant_count           77            based           fixed bin(17,0)          array level 3 dcl 287 set ref 1-87* 1-87
constant_info            77            based           structure                array level 2 dcl 287
constant_node                          constant        fixed bin(4,0)           initial dcl 5-87 set ref 1-74* 1249 1252 1263 1330
                                                                                  2312 2433 2445 4662 4697 4716
constant_part                   002034 automatic       fixed bin(18,0)          dcl 3670 set ref 3784* 3808* 3831
constant_type                          constant        fixed bin(4,0)           initial dcl 5-120 ref 1-82 3731
constant_value                  002006 automatic       fixed bin(18,0)          dcl 3276 in procedure "process_1_subscript" set ref
                                                                                  3298* 3298
constant_value                  002044 automatic       fixed bin(35,0)          dcl 3680 in procedure "process_substr" set ref 3748*
                                                                                  3756 3756 3763* 3784 3796 3796 3808
constant_value                  001332 automatic       fixed bin(18,0)          dcl 1872 in procedure "process_arith" set ref 1962*
                                                                                  1962 1977* 1979 2016* 2016 2034* 2036 2039 2084*
                                                                                  2084 2101* 2103 2104
convert_to_int_op                      constant        fixed bin(18,0)          initial dcl 5-197 ref 836 931 974 1287 1822 2713
                                                                                  3183 3316 3722 4318
count                     2            based           fixed bin(18,0)          level 2 dcl 193 set ref 585* 617* 938 939 942 3228*
cum                      10            based           structure                level 2 dcl 162
cur_operator                    001342 automatic       pointer                  dcl 2193 set ref 2197* 2204 2206 2209 2210 2210 2211
                                                                                  2211 2213 2226 2227 2229 2233 2234 2234 2236
cur_sf_param              4            based           fixed bin(18,0)          level 2 dcl 180 set ref 826 831 832* 2906*
cur_statement            67            based           fixed bin(18,0)          level 2 dcl 287 set ref 342* 342* 345 359* 4168
cur_subprogram           71            based           fixed bin(18,0)          level 2 dcl 287 set ref 334* 334* 337*
current_arg               3            based           fixed bin(18,0)          level 2 dcl 180 set ref 841 842 842 845 846 846 849*
                                                                                  849 850 850 2903* 2905
currentsize                                            builtin function         dcl 276 ref 3141 3143 3145 3147 3149 3151 3153 3155
d                               001732 automatic       pointer                  dcl 3103 in procedure "create_dim_size_var" set ref
                                                                                  3106* 3112 3112 3112 3120 3121 3122
d                               001500 automatic       pointer                  dcl 2595 in procedure "initialize_subscript" set ref
                                                                                  2600* 2601 2603 2605 2606 2606 2606 2606 2609 2609
                                                                                  2609 2609 2612 2612* 2614 2617 2625 2626 2638 2639
                                                                                  2641 2642 2645 2646 2650 2650 2650 2650 2655 2656
                                                                                  2659
data_size                       001276 automatic       fixed bin(17,0)          dcl 1-22 set ref 1-47* 1-49 1-87 1-87 1-89 1-89 1-91
                                                                                  1-93
data_type                 0(05)        based           fixed bin(4,0)           level 2 in structure "symbol" packed packed unsigned
                                                                                  unaligned dcl 4-844 in procedure "fort_converter"
                                                                                  set ref 834 836 838 959 971 974 977 979 1145 1146
                                                                                  3212 3703 3910 4275*
data_type                              parameter       fixed bin(4,0)           dcl 1-15 in procedure "create_constant" ref 1-13
                                                                                  1-40
data_type                 0(05)        based           fixed bin(4,0)           level 2 in structure "constant" packed packed
                                                                                  unsigned unaligned dcl 4-256 in procedure
                                                                                  "fort_converter" set ref 1-81*
data_type                 0(05)        based           fixed bin(4,0)           level 2 in structure "array_ref" packed packed
                                                                                  unsigned unaligned dcl 4-155 in procedure
                                                                                  "fort_converter" set ref 3919* 3922
data_type                       001444 automatic       fixed bin(18,0)          dcl 2472 in procedure "subscript_arith" set ref
                                                                                  2485* 2487* 2488*
data_type                 0(05)        based           fixed bin(4,0)           level 2 in structure "temporary" packed packed
                                                                                  unsigned unaligned dcl 4-1005 in procedure
                                                                                  "fort_converter" set ref 959 4257*
data_type                              parameter       fixed bin(18,0)          dcl 4244 in procedure "create_temporary" ref 4241
                                                                                  4257
data_type                 0(05)        based           fixed bin(4,0)           level 2 in structure "node" packed packed unsigned
                                                                                  unaligned dcl 4-63 in procedure "fort_converter"
                                                                                  ref 1-65 834 971 1249 1270 1285 1330 2389 2689
                                                                                  2709 2709 3311 4315 4315 4318 4321
data_type                       001517 automatic       fixed bin(18,0)          dcl 2667 in procedure "process_builtin" set ref
                                                                                  2684* 2689* 2689 2695 2695 2697 2703* 2709 2709
                                                                                  2713 2716*
data_type_size                  000204 constant        fixed bin(17,0)          initial array dcl 5-115 ref 1-43 1-47 4276
decimal                                                builtin function         dcl 1-23 ref 1-45 1-45
def_chain                 5            based           pointer                  level 2 packed packed unaligned dcl 180 set ref 398
                                                                                  959 971 974 977 979 979 2902* 2906 3204 3206 3208
                                                                                  3212 3232
description               1     000010 external static structure                array level 2 dcl 217
dim                       5            based           structure                array level 2 in structure "dimension" dcl 4-383
                                                                                  in procedure "fort_converter"
dim                      12            based           structure                level 2 in structure "sub_stack" dcl 162
                                                                                  in procedure "fort_converter"
dim_no                                 parameter       fixed bin(18,0)          dcl 5001 in procedure "valid_subscript" ref 4992
                                                                                  5004
dim_no                                 parameter       fixed bin(3,0)           dcl 3104 in procedure "create_dim_size_var" ref 3094
                                                                                  3107
dim_node                  3            based           pointer                  level 2 in structure "sub_stack" packed packed
                                                                                  unaligned dcl 162 in procedure "fort_converter"
                                                                                  set ref 1433* 1459 1460 1460 1462 3414 3414 3424
                                                                                  3449 3449 3453 3579 3579 3588 3592 3600 3617
dim_node                        001712 automatic       pointer                  dcl 3034 in procedure "create_virtual_origin_var"
                                                                                  set ref 3043* 3044 3058 3058 3064 3064 3064
dim_p                           002320 automatic       pointer                  dcl 4548 in procedure "optimize_vector" set ref
                                                                                  4585* 4701 4707 4707 4710* 4720 4726 4726 4729*
                                                                                  4838
dim_p                                  parameter       pointer                  dcl 5000 in procedure "valid_subscript" ref 4992
                                                                                  5006 5006 5010 5010
dim_p                                  parameter       pointer                  dcl 3103 in procedure "create_dim_size_var" ref 3094
                                                                                  3106
dim_size_list                          based           structure                level 1 dcl 243 set ref 2999 3003 3013* 3155
dim_size_list_ptr               001164 automatic       pointer                  dcl 254 set ref 328* 2998* 2999 3002 3003 3012 3013
                                                                                  3014* 3109 3120 3121 3122 3123 3125 3155
dim_size_offset                 000103 automatic       fixed bin(18,0)          dcl 126 set ref 327* 328 427 3002 3003* 3011 3012*
                                                                                  3014 3136 3155 3155
dimension                 5            based           fixed bin(18,0)          level 2 in structure "sub_stack" dcl 162
                                                                                  in procedure "fort_converter" set ref 1435* 3409
                                                                                  3414 3414 3424 3447 3449 3449 3453 3525* 3525 3526
dimension                              based           structure                level 1 dcl 4-383 in procedure "fort_converter"
dimension                12(25)        based           fixed bin(18,0)          level 2 in structure "symbol" packed packed unsigned
                                                                                  unaligned dcl 4-844 in procedure "fort_converter"
                                                                                  ref 1433 2600 3043 3057 3796 4585
div_op                                 constant        fixed bin(18,0)          initial dcl 5-197 ref 1281 2579
do_label                  3            based           fixed bin(18,0)          level 2 dcl 193 set ref 1049 1366* 4111*
do_op                                  constant        fixed bin(18,0)          initial dcl 5-197 ref 700 1002 1023 1242 4617 4848
do_position                     002274 automatic       fixed bin(18,0)          dcl 4545 set ref 4566* 4571 4576 4577
doing_substr                           parameter       bit(1)                   packed unaligned dcl 3893 ref 3890 3904
dummy_arg                 0(31)        based           bit(1)                   level 3 packed packed unaligned dcl 4-844 ref 388
elem_size                       001710 automatic       fixed bin(17,0)          dcl 3032 set ref 3041* 3052 3086
elem_units                      001711 automatic       fixed bin(17,0)          dcl 3033 set ref 3042* 3052 3089
element                   6            based           structure                level 2 dcl 162
element_size             15(07)        based           fixed bin(17,0)          level 2 in structure "symbol" packed packed
                                                                                  unaligned dcl 4-844 in procedure "fort_converter"
                                                                                  set ref 1446 2636 3041 4276* 4595
element_size              2            based           fixed bin(17,0)          level 2 in structure "virtual_origin_list" dcl 227
                                                                                  in procedure "fort_converter" set ref 3052 3086*
eol_offset                      000104 automatic       fixed bin(18,0)          dcl 126 set ref 313* 314 2773 2774* 2796* 2798 2800
                                                                                  3136 3145 3145
eol_op                                 constant        fixed bin(18,0)          initial dcl 5-197 ref 4581
eol_position                    002275 automatic       fixed bin(18,0)          dcl 4545 set ref 4577* 4581 4634 4852
eol_stack                              based           structure                level 1 dcl 204 set ref 2770 2774 2797* 3145
eol_stack_p                     001166 automatic       pointer                  dcl 254 set ref 314* 786 806 806 806 808 808 824 864
                                                                                  1087 1109 1117 1117 1125 1133 1141 1156 1166 1181
                                                                                  1191 1206 2678 2688 2708 2769* 2770 2773 2774 2775
                                                                                  2776 2777 2787 2788 2796 2797 2798* 2802 3145
equivalenced             11(03)        based           bit(1)                   level 4 packed packed unaligned dcl 4-844 ref 4985
                                                                                  4987
executable                0(31)        based           bit(1)                   level 4 packed packed unaligned dcl 4-530 set ref
                                                                                  4128* 4437*
exit_offset                     000105 automatic       fixed bin(18,0)          dcl 126 set ref 319* 320 553 700 2870 2871* 2878*
                                                                                  2880 3136 3143 3143 4848
exit_op                                constant        fixed bin(18,0)          initial dcl 5-197 ref 1405 4634
exit_stack                             based           structure                level 1 dcl 193 set ref 2867 2871 2879* 3143
exit_stack_p                    001170 automatic       pointer                  dcl 254 set ref 320* 553 556 556 557 579 585 586 616
                                                                                  617 700 700 700 902 902 915 916 926 938 939 942
                                                                                  954 1002 1049 1061 1063 1069 1073 1242 1243 1244
                                                                                  1245 1324 1351 1366 2866* 2867 2870 2871 2878 2879
                                                                                  2880* 3143 3227 3228 4111 4634 4848 4848 4848 4872
                                                                                  4877 4885
expression                             parameter       fixed bin(18,0)          dcl 4473 ref 4468 4510 4537
ext_attributes            4            based           structure                level 2 packed packed unaligned dcl 4-844
external                 10(31)        based           bit(1)                   level 4 packed packed unaligned dcl 4-844 ref 4020
extra_units                            parameter       fixed bin(18,0)          dcl 2784 ref 2781 2788
f_p                             000144 automatic       pointer                  dcl 4471 set ref 4516* 4519
first_constant          100            based           fixed bin(18,0)          array level 3 dcl 287 set ref 1-89 1-89*
first_entry_name         75            based           fixed bin(18,0)          level 2 dcl 287 ref 4025
first_free_object               000106 automatic       fixed bin(18,0)          initial dcl 126 set ref 126* 2769 2770* 2770 2771
                                                                                  2774 2813 2814* 2814 2815 2818 2838 2839* 2839
                                                                                  2840 2843 2866 2867* 2867 2868 2871 2894 2896*
                                                                                  2896 2897 2900 2935 2936* 2936 2937 2940 2968
                                                                                  2969* 2969 2970 2974 2998 2999* 2999 3000 3003
                                                                                  3136* 3139 3139* 3141 3141* 3143 3143* 3145 3145*
                                                                                  3147 3147* 3149 3149* 3151 3151* 3153 3153* 3155
                                                                                  3155*
first_label               4            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-753
                                                                                  set ref 4130* 4439*
first_operator            1            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 8-176
                                                                                  set ref 4219 4219* 4910 4920 4928 4930
first_polish              5            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-753
                                                                                  ref 342
first_quad               10            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-753
                                                                                  set ref 4175*
first_statement_function_done   000154 automatic       bit(1)                   initial dcl 158 set ref 158* 1408 1410*
first_subprogram         72            based           fixed bin(18,0)          level 2 dcl 287 ref 334
fixed                                                  builtin function         dcl 276 ref 351 420 1408 3830 4402 4496 4501 4502
                                                                                  4503 4504 4905 4907 4916
flow_unit                 6            based           pointer                  level 2 packed packed unaligned dcl 8-176 set ref
                                                                                  4185* 4531*
form_VLA_packed_ptr_op                 constant        fixed bin(18,0)          initial dcl 5-197 ref 3563
format                    0(30)        based           bit(1)                   level 4 packed packed unaligned dcl 4-530 ref 628
                                                                                  5034
format_var                4            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-530
                                                                                  ref 628 5037
fort_data$builtin_name          000010 external static structure                level 1 dcl 217
fortran_declared                       based           structure                level 1 dcl 7-91
fortran_options                        based           structure                level 1 dcl 7-40
forward                         000153 automatic       fixed bin(18,0)          dcl 4473 set ref 4515* 4516 4520
frozen_for_do             0(34)        based           bit(1)                   level 3 packed packed unaligned dcl 4-1005 set ref
                                                                                  1259* 1271*
func_ref_op                            constant        fixed bin(18,0)          initial dcl 5-197 ref 1141 1848
gen_bif_index                   001520 automatic       fixed bin(18,0)          dcl 2667 set ref 2694* 2697 2702
generic_func              4     000010 external static fixed bin(18,0)          array level 3 dcl 217 ref 2697 2702
generic_name              3     000010 external static bit(1)                   array level 3 packed packed unaligned dcl 217 ref
                                                                                  2682
greater_op                             constant        fixed bin(18,0)          initial dcl 5-197 ref 1041
greater_or_equal_op                    constant        fixed bin(18,0)          initial dcl 5-197 ref 1337 1342
has_dim_sizes             0(25)        based           bit(1)                   level 2 packed packed unaligned dcl 4-383 set ref
                                                                                  2603 2614*
has_virtual_origin        0(23)        based           bit(1)                   level 2 packed packed unaligned dcl 4-383 set ref
                                                                                  2617 2659*
hash_chain                3(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-63
                                                                                  set ref 1-69 1-78*
hash_index                      001277 automatic       fixed bin(17,0)          dcl 1-24 set ref 1-57* 1-61 1-76 1-76
hash_table                             based           fixed bin(35,0)          array dcl 1-25 set ref 1-61 1-76 1-76*
hash_table_size                 021564 constant        fixed bin(17,0)          initial dcl 1-26 ref 1-57
hbound                                                 builtin function         dcl 1-27 in procedure "create_constant" ref 1-43
hbound                                                 builtin function         dcl 276 in procedure "fort_converter" ref 447 2411
                                                                                  2411 2411
high                            002304 automatic       fixed bin(18,0)          dcl 4545 set ref 4649* 4651 4674 4675* 4676 4720
                                                                                  4729* 4759
high_bounds_differ              002327 automatic       bit(1)                   dcl 4550 set ref 4715* 4720* 4728* 4734
high_is_variable                002326 automatic       bit(1)                   dcl 4550 set ref 4718* 4724* 4739 4754 4765 4768
                                                                                  4777
high_p                          002314 automatic       pointer                  dcl 4548 set ref 4651* 4662 4664 4673 4676* 4677
                                                                                  4677 4677 4677 4716 4725
high_value                      002306 automatic       fixed bin(18,0)          dcl 4545 set ref 4719* 4725* 4726 4729* 4739 4756*
                                                                                  4756 4757
hold_offset                     000107 automatic       fixed bin(18,0)          dcl 126 set ref 315* 316 1004 2817 2818* 2825* 2827
                                                                                  3136 3147 3147 4065
hold_stack                             based           structure                level 1 dcl 210 set ref 2814 2818 2826* 3147
hold_stack_p                    001172 automatic       pointer                  dcl 254 set ref 316* 603 604 883 884 915 916 1072
                                                                                  1073 1195 1196 1370 1371 2813* 2814 2817 2818 2825
                                                                                  2826 2827* 3147 4065 4070 4081 4081 4086 4086 4086
                                                                                  4091 4093 4093 4100
i                               002376 automatic       fixed bin(18,0)          dcl 5001 in procedure "valid_subscript" set ref
                                                                                  5004* 5006 5006 5010 5010
i                               002204 automatic       fixed bin(18,0)          dcl 4155 in procedure "create_opt_statement" set ref
                                                                                  4162* 4166 4168 4173 4175 4187
i                               001350 automatic       fixed bin(18,0)          dcl 2195 in procedure "compress_concat" set ref
                                                                                  2212* 2213 2213* 2235* 2236 2236*
i                               001412 automatic       fixed bin(18,0)          dcl 2367 in procedure "get_data_type" set ref 2381*
                                                                                  2382 2383 2385 2389*
i                               001454 automatic       fixed bin(18,0)          dcl 2494 in procedure "get_node_type" set ref 2503*
                                                                                  2504 2505 2509*
i                               001502 automatic       fixed bin(3,0)           dcl 2596 in procedure "initialize_subscript" set ref
                                                                                  2605* 2606 2606 2606 2606 2609 2609 2609 2609 2612
                                                                                  2612* 2638* 2639 2641 2642*
i                               002260 automatic       fixed bin(18,0)          dcl 4302 in procedure "match_index_type" set ref
                                                                                  4313* 4314 4317 4321*
i                               001521 automatic       fixed bin(18,0)          dcl 2667 in procedure "process_builtin" set ref
                                                                                  2688* 2689* 2701* 2702 2703* 2708* 2709 2709 2712
                                                                                  2716*
i                               002216 automatic       fixed bin(18,0)          dcl 4195 in procedure "create_operator" set ref
                                                                                  4206* 4214 4217 4219 4237 4238
i                               002300 automatic       fixed bin(18,0)          dcl 4545 in procedure "optimize_vector" set ref
                                                                                  4608* 4622 4634 4639 4640 4701 4707 4707 4710*
                                                                                  4720 4726 4726 4729* 4841* 4842 4842* 4844 4845*
                                                                                  4845 4846 4847* 4847 4851 4852 4852
i                                      parameter       fixed bin(18,0)          dcl 4426 in procedure "create_label" ref 4423 4435
i                               001736 automatic       fixed bin(3,0)           dcl 3104 in procedure "create_dim_size_var" set ref
                                                                                  3107* 3112 3112 3112 3120 3121 3122
i                               000110 automatic       fixed bin(18,0)          dcl 126 in procedure "fort_converter" set ref 294*
                                                                                  295 398* 398* 402* 404 589* 598 598* 831* 832 834
                                                                                  836 838 938* 939* 1063* 1065 1066 1363* 1365 1366
                                                                                  1667* 1668 1668* 1668 1670 1672* 1673 1673* 1673
                                                                                  1675 3063* 3064 3064 3064 3064 3064 3064* 3713*
                                                                                  3714 3715 3720 3721 3725 3731 3732 3732 3733 3733*
i                               002154 automatic       fixed bin(18,0)          dcl 4060 in procedure "process_hold_stack_entry" set
                                                                                  ref 4074* 4075 4081 4093 4103 4111
i                                      parameter       fixed bin(18,0)          dcl 4120 in procedure "create_label" ref 4117 4126
i_ptr                           002262 automatic       pointer                  dcl 4303 set ref 4314* 4315
if_node_p                              parameter       pointer                  dcl 4330 set ref 4327 4356 4362 4367 4373 4374 4383
                                                                                  4383 4386* 4386 4386 4388 4394 4394 4400 4408*
                                                                                  4409 4420
increment                              parameter       fixed bin(18,0)          dcl 2404 ref 2401 2408
increment_polish_op                    constant        fixed bin(18,0)          initial dcl 5-197 ref 4851
index                                                  builtin function         dcl 276 ref 2329
initial                  13(07)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-844
                                                                                  set ref 1394* 3232 5040
inner_do_position               002277 automatic       fixed bin(18,0)          dcl 4545 set ref 4566* 4584 4622 4640 4640 4797 4842
inquire_op                             constant        fixed bin(18,0)          initial dcl 5-197 ref 806 1206
int_image                              based           fixed bin(35,0)          dcl 3686 ref 3733 3781
int_mode                               constant        fixed bin(4,0)           initial dcl 5-106 set ref 929 934 959 959 1249 1258
                                                                                  1285 1291 1330 1683 2309 2350 2383 2431 2709 2709
                                                                                  3174 3174 3178 3311 3319 3379 3480 3568 3596 3715
                                                                                  3725 3823 4275 4276 4295*
integer                  10(20)        based           bit(1)                   level 5 packed packed unaligned dcl 4-844 set ref
                                                                                  4278*
inverted_if                     000102 automatic       fixed bin(18,0)          dcl 4332 set ref 4356* 4358* 4373 4408
is_addressable            0(14)        based           bit(1)                   level 3 packed packed unaligned dcl 4-256 set ref
                                                                                  1-83*
j                               000111 automatic       fixed bin(18,0)          dcl 126 in procedure "fort_converter" set ref 396*
                                                                                  401* 401 412 412* 414
j                               002301 automatic       fixed bin(18,0)          dcl 4545 in procedure "optimize_vector" set ref
                                                                                  4639* 4640* 4838* 4840* 4841
j                               001401 automatic       fixed bin(18,0)          dcl 2280 in procedure "process_expo" set ref 2314*
                                                                                  2315 2322 2327 2332* 2337*
j                               002155 automatic       fixed bin(18,0)          dcl 4060 in procedure "process_hold_stack_entry" set
                                                                                  ref 4091* 4093 4093* 4102* 4103*
j                               000114 automatic       fixed bin(18,0)          dcl 4426 in procedure "create_label" set ref 4434*
                                                                                  4435 4436 4437 4437 4437 4437 4439 4441 4442 4443
j                               002217 automatic       fixed bin(18,0)          dcl 4195 in procedure "create_operator" set ref
                                                                                  4225* 4226 4226 4227 4227 4227 4229 4229 4229 4229
                                                                                  4229*
j                               002166 automatic       fixed bin(18,0)          dcl 4120 in procedure "create_label" set ref 4125*
                                                                                  4126 4127 4128 4128 4128 4128 4130 4132 4133 4134
jump                      5            based           fixed bin(18,0)          array level 2 dcl 235 set ref 875* 4103
jump_arithmetic_op                     constant        fixed bin(18,0)          initial dcl 5-197 ref 603 4091
jump_computed_op                       constant        fixed bin(18,0)          initial dcl 5-197 ref 616 926 936 1087
jump_false_op                          constant        fixed bin(18,0)          initial dcl 5-197 ref 553 579 883 902 1050 1072 1348
                                                                                  1725 1740 4081 4086 4356 4358 4383 4394
jump_op                                constant        fixed bin(18,0)          initial dcl 5-197 ref 871
jump_target                            parameter       fixed bin(18,0)          dcl 4473 ref 4468 4536
jump_true_op                           constant        fixed bin(18,0)          initial dcl 5-197 ref 556 902 4070 4086 4356 4383
                                                                                  4394
k                               001402 automatic       fixed bin(18,0)          dcl 2280 in procedure "process_expo" set ref 2329*
                                                                                  2332
k                               001347 automatic       fixed bin(18,0)          dcl 2195 in procedure "compress_concat" set ref
                                                                                  2232* 2233 2234 2235 2238
label                                  based           structure                level 1 dcl 4-530 in procedure "fort_converter" set
                                                                                  ref 4125 4125 4434 4434
label                     0(18)        based           fixed bin(18,0)          level 2 in structure "opt_statement" packed packed
                                                                                  unsigned unaligned dcl 8-176 in procedure
                                                                                  "fort_converter" set ref 367* 1066* 1363* 4072
                                                                                  4072* 4074 4404 4404* 4406 4919
label_node                             constant        fixed bin(4,0)           initial dcl 5-87 set ref 628 4125* 4434* 5034
label_op                               constant        fixed bin(18,0)          initial dcl 5-197 ref 364
large_offset              0(34)        based           bit(1)                   level 3 packed packed unaligned dcl 4-155 set ref
                                                                                  3650* 3695 3837*
last                                   based           fixed bin(18,0)          level 2 in structure "eol_stack" dcl 204
                                                                                  in procedure "fort_converter" set ref 2773* 2796
last                                   based           fixed bin(18,0)          level 2 in structure "sf_stack" dcl 180 in procedure
                                                                                  "fort_converter" set ref 405 2899* 2914
last                                   based           fixed bin(18,0)          level 2 in structure "virtual_origin_list" dcl 227
                                                                                  in procedure "fort_converter" set ref 2939* 2951
                                                                                  3077
last                                   based           fixed bin(18,0)          level 2 in structure "block_if_stack" dcl 235
                                                                                  in procedure "fort_converter" set ref 2972* 2982
last                                   based           fixed bin(18,0)          level 2 in structure "sub_stack" dcl 162
                                                                                  in procedure "fort_converter" set ref 2842* 2851
last                                   based           fixed bin(18,0)          level 2 in structure "hold_stack" dcl 210
                                                                                  in procedure "fort_converter" set ref 2817* 2825
last                                   based           fixed bin(18,0)          level 2 in structure "dim_size_list" dcl 243
                                                                                  in procedure "fort_converter" set ref 3002* 3012
                                                                                  3117
last                                   based           fixed bin(18,0)          level 2 in structure "exit_stack" dcl 193
                                                                                  in procedure "fort_converter" set ref 2870* 2878
last_assigned_op                       constant        fixed bin(18,0)          initial dcl 5-197 ref 295 364 386 438 598 644 691
                                                                                  1594 1647 1827 2749 4229
last_constant           101            based           fixed bin(18,0)          array level 3 dcl 287 set ref 1-91 1-93*
last_io_op                      000112 automatic       fixed bin(18,0)          dcl 126 set ref 354* 650* 684 763* 1004 1309 1358
last_label                4(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-753
                                                                                  set ref 4130 4132 4133* 4439 4441 4442*
last_op_index                   000113 automatic       fixed bin(18,0)          dcl 126 set ref 339* 368 560 561 562* 842 845 850
                                                                                  1063* 1363* 1412 1413 1414* 2456* 2457 2905 3256
                                                                                  3263 3264 3266* 4072* 4173 4173 4177 4187* 4216
                                                                                  4217 4217 4237* 4669* 4922*
last_opt_statement              001174 automatic       pointer                  dcl 254 set ref 338* 561* 1413* 1415 4170 4171 4171
                                                                                  4188* 4918*
last_polish               5(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-753
                                                                                  ref 352 4168
last_quad                10(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-753
                                                                                  set ref 1547* 4168*
last_quad_p                     001176 automatic       pointer                  dcl 254 set ref 586 604 643 690 1324 1593 1646 1865
                                                                                  2457* 2458 2459 2761 3211 3213 3267* 3913 3920
                                                                                  4214* 4215 4216 4221 4222 4223 4226 4227 4227 4227
                                                                                  4229 4229 4229 4229 4229 4253 4668* 4670 4923*
                                                                                  4924 4925
last_st                         000154 automatic       fixed bin(18,0)          dcl 4473 set ref 4496* 4501 4502 4511 4525 4526 4527
last_symbol               3(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-753
                                                                                  set ref 4283 4284*
length                    4            based           fixed bin(18,0)          level 2 in structure "char_constant" packed packed
                                                                                  unsigned unaligned dcl 4-316 in procedure
                                                                                  "fort_converter" ref 3950
length                   12            based           fixed bin(24,0)          level 2 in structure "temporary" dcl 4-1005
                                                                                  in procedure "fort_converter" set ref 979* 1146*
                                                                                  2731* 3976 3978
length                    7            based           fixed bin(24,0)          level 2 in structure "array_ref" dcl 4-155
                                                                                  in procedure "fort_converter" set ref 3925* 3928*
                                                                                  3966 3968
length                    3(27)        based           bit(9)                   level 2 in structure "opt_statement" packed packed
                                                                                  unaligned dcl 8-176 in procedure "fort_converter"
                                                                                  set ref 4180* 4526* 4526
length                                 parameter       fixed bin(17,0)          dcl 9-12 in procedure "create_node" ref 9-10 9-20
                                                                                  9-23 9-24
length                    2(27)        based           bit(9)                   level 2 in structure "statement" packed packed
                                                                                  unaligned dcl 4-721 in procedure "fort_converter"
                                                                                  ref 4180
length                                 parameter       fixed bin(17,0)          dcl 2-12 in procedure "create_node" ref 2-10 2-20
                                                                                  2-23 2-24
less_or_equal_op                       constant        fixed bin(18,0)          initial dcl 5-197 ref 1334
location                  5            based           bit(18)                  level 2 in structure "opt_statement" packed packed
                                                                                  unaligned dcl 8-176 in procedure "fort_converter"
                                                                                  set ref 4184* 4528* 4528
location                  1(18)        based           bit(18)                  level 2 in structure "statement" packed packed
                                                                                  unaligned dcl 4-721 in procedure "fort_converter"
                                                                                  ref 4184
log_op_p                        000100 automatic       pointer                  dcl 4330 set ref 4367* 4371 4374 4383 4383 4386 4388
                                                                                  4394 4394 4408 4409 4419*
logical_mode                           constant        fixed bin(4,0)           initial dcl 5-106 ref 528 1047 1346
low                             002303 automatic       fixed bin(18,0)          dcl 4545 set ref 4648* 4650 4701 4710* 4762 4797
low_bounds_differ               002330 automatic       bit(1)                   dcl 4550 set ref 4696* 4701* 4709* 4734 4838
low_is_variable                 002325 automatic       bit(1)                   dcl 4550 set ref 4699* 4705* 4739 4760 4762 4777
low_p                           002312 automatic       pointer                  dcl 4548 set ref 4650* 4697 4706
low_value                       002305 automatic       fixed bin(18,0)          dcl 4545 set ref 4700* 4706* 4707 4710* 4739 4760
                                                                                  4765* 4765 4767 4768* 4768
lower                     0(09)        based           bit(1)                   array level 3 packed packed unaligned dcl 4-383 ref
                                                                                  2609 2650 3058 3058 4707 5006
lower_bound               5            based           fixed bin(24,0)          array level 3 in structure "dimension" dcl 4-383
                                                                                  in procedure "fort_converter" ref 2606 2609 2641
                                                                                  2650 3058 3058 3064 3064 3112 3121 4701 4707 5006
lower_bound               2            based           fixed bin(24,0)          level 2 in structure "dim_size_list" dcl 243
                                                                                  in procedure "fort_converter" set ref 3112 3121*
ltrim                                                  builtin function         dcl 9-17 in procedure "create_node" ref 9-29 9-29
ltrim                                                  builtin function         dcl 1-28 in procedure "create_constant" ref 1-45
                                                                                  1-45
ltrim                                                  builtin function         dcl 2-17 in procedure "create_node" ref 2-29 2-29
max                                                    builtin function         dcl 276 ref 1906 1906 1969 1969 2023 2023 2091 2091
                                                                                  2155 2155 2354 2354 2487 2689 3136
max_num_of_rands                021565 constant        fixed bin(17,0)          initial dcl 5-60 ref 4208 4208 4208
misc_attributes          10(28)        based           structure                level 3 packed packed unaligned dcl 4-844
mod                                                    builtin function         dcl 1-29 ref 1-57
mod_2_sum                       001300 automatic       bit(36)                  dcl 1-30 set ref 1-51* 1-54* 1-57
mode                                   parameter       bit(1)                   dcl 2282 in procedure "process_expo" ref 2277 2294
                                                                                  2356
mode                     10(20)        based           structure                level 4 in structure "symbol" packed packed
                                                                                  unaligned dcl 4-844 in procedure "fort_converter"
mode_bits                10            based           structure                level 3 packed packed unaligned dcl 4-844
mult                     12            based           fixed bin(18,0)          level 3 dcl 162 set ref 499* 499 1434* 2040* 2040
                                                                                  2053* 2104* 2104 2114* 2529 2534 2547 2556* 3341*
                                                                                  3352* 3352 3374 3382 3384 3401* 3440* 3440 3472
                                                                                  3500 3502 3522*
mult_op                                constant        fixed bin(18,0)          initial dcl 5-197 ref 1885 2334 2340 2548 3355 3386
                                                                                  3396 3426 3504 4789 4816
multiplier                      001505 automatic       fixed bin(24,0)          dcl 2597 set ref 2636* 2641 2642* 2642 2650
must_keep_remaining_loops       002331 automatic       bit(1)                   dcl 4550 set ref 4607* 4608 4734*
n                                      parameter       fixed bin(18,0)          dcl 4140 in procedure "search_label" ref 4137 4146
                                                                                  4146 4146
n                                      parameter       fixed bin(18,0)          dcl 4195 in procedure "create_operator" ref 4192
                                                                                  4207
n                               001346 automatic       fixed bin(18,0)          dcl 2195 in procedure "compress_concat" set ref
                                                                                  2209* 2210 2211 2212 2215 2226* 2227 2229 2233
                                                                                  2234 2234 2236
n                               001455 automatic       fixed bin(18,0)          dcl 2494 in procedure "get_node_type" set ref 2504*
                                                                                  2505 2508
n                               001413 automatic       fixed bin(18,0)          dcl 2367 in procedure "get_data_type" set ref 2382*
                                                                                  2383 2385 2388
n                                      parameter       fixed bin(18,0)          dcl 2472 in procedure "subscript_arith" set ref 2469
                                                                                  2481* 2482 2484* 2485
n_clauses                 1            based           fixed bin(18,0)          level 2 dcl 235 set ref 868 885 2973* 2983 3153
n_dimensions              4            based           fixed bin(18,0)          level 2 dcl 162 set ref 1431* 3409 3447 3526
n_dims                          002302 automatic       fixed bin(18,0)          dcl 4545 set ref 4576* 4577 4639 4840
n_dims_used                     002276 automatic       fixed bin(18,0)          dcl 4545 set ref 4603* 4796* 4796 4797 4838 4852
n_jumps                   4            based           fixed bin(18,0)          level 2 dcl 235 set ref 874* 874 875 1722* 4102
n_operands                      001247 automatic       fixed bin(17,0)          dcl 8-171 set ref 4207* 4208 4210 4222 4225 4226
                                                                                  4236 4484* 4487
n_ops                           000115 automatic       fixed bin(18,0)          dcl 126 set ref 671* 688* 698 705*
name                     20            based           char                     level 2 dcl 4-844 ref 4027 4027
name_length              14(07)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-844 ref 4027
                                                                                  4027
named_constant           11(06)        based           bit(1)                   level 4 packed packed unaligned dcl 4-844 ref 5040
ndims                           001503 automatic       fixed bin(3,0)           dcl 2596 set ref 2601* 2605 2638 2650 2650
negate_op                              constant        fixed bin(18,0)          initial dcl 5-197 ref 2443 2537 3376 3477 3593
nested                    1            based           bit(1)                   level 2 dcl 162 set ref 2844* 2850
next                      3            based           fixed bin(18,0)          level 2 in structure "array_ref" packed packed
                                                                                  unsigned unaligned dcl 4-155 in procedure
                                                                                  "fort_converter" set ref 3863*
next                            000103 automatic       fixed bin(18,0)          dcl 4332 in procedure "optimize_if" set ref 4400*
                                                                                  4400* 4402 4404 4404 4404* 4406
next                      2            based           bit(18)                  level 2 in structure "opt_statement" packed packed
                                                                                  unaligned dcl 8-176 in procedure "fort_converter"
                                                                                  set ref 4171* 4402 4501* 4504* 4906* 4906 4907
                                                                                  4917* 4917
next                      1            based           fixed bin(18,0)          level 2 in structure "operator" packed packed
                                                                                  unsigned unaligned dcl 8-144 in procedure
                                                                                  "fort_converter" set ref 846 2270 2271* 2271 2454
                                                                                  2458 2459* 2462 2463* 2463 3260* 3260 3261 3261
                                                                                  3263* 3265* 3861 3862* 3862 4173* 4217* 4400 4459
                                                                                  4460* 4460 4495 4509* 4515 4517* 4520* 4665 4665
                                                                                  4670 4672* 4672 4883 4894 4900 4924 4925* 4928*
                                                                                  4960 4961* 4961
next                      1            based           bit(18)                  level 2 in structure "statement" packed packed
                                                                                  unaligned dcl 4-721 in procedure "fort_converter"
                                                                                  ref 351 420
next                      3            based           fixed bin(18,0)          level 2 in structure "temporary" packed packed
                                                                                  unsigned unaligned dcl 4-1005 in procedure
                                                                                  "fort_converter" set ref 2272* 2452* 4461* 4673*
                                                                                  4891*
next_constant             3            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-256
                                                                                  set ref 1-91*
next_free_array_ref      46            based           fixed bin(18,0)          level 2 dcl 287 set ref 3863 3864*
next_free_operand        42            based           fixed bin(18,0)          level 2 dcl 287 set ref 2-20 2-22 2-23* 2-23 9-20
                                                                                  9-22 9-23* 9-23
next_free_quad           45            based           fixed bin(18,0)          level 2 dcl 287 set ref 559* 559 1411* 1411 2215*
                                                                                  2215 2238* 2238 2458* 4162 4163* 4163 4164 4206
                                                                                  4210* 4210 4211 4485 4487 4489* 4490 4670* 4924*
next_free_temp           47            based           fixed bin(18,0)          level 2 dcl 287 set ref 2272 2273* 2452 2453* 4461
                                                                                  4462* 4673 4674* 4891 4892*
next_label                      000104 automatic       fixed bin(18,0)          dcl 4332 in procedure "optimize_if" set ref 4406*
                                                                                  4407 4408*
next_label                3            based           fixed bin(18,0)          level 2 in structure "label" packed packed unsigned
                                                                                  unaligned dcl 4-530 in procedure "fort_converter"
                                                                                  set ref 4132* 4441*
next_member               7(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-844
                                                                                  ref 398 404 832 2906
next_st                         000155 automatic       fixed bin(18,0)          dcl 4473 set ref 4495* 4496 4497 4503 4504
next_statement_index            000114 automatic       fixed bin(18,0)          dcl 126 set ref 351* 352 352* 381
next_subprogram           1(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-753
                                                                                  ref 422
next_symbol               3            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-844
                                                                                  set ref 4029 4283*
node                                   based           structure                level 1 dcl 4-63
node_offset                     001301 automatic       fixed bin(17,0)          dcl 1-31 set ref 1-61* 1-62 1-63 1-65 1-69* 1-74*
                                                                                  1-76 1-78 1-80 1-89 1-91 1-93 1-95
node_p                                 parameter       pointer                  dcl 3946 ref 3939 3948
node_ptr                        001302 automatic       pointer                  dcl 1-32 set ref 1-63* 1-65 1-65 1-69 1-78 1-80*
                                                                                  1-81 1-82 1-83 1-84 1-85
node_type                              based           fixed bin(4,0)           level 2 packed packed unaligned dcl 4-63 set ref 388
                                                                                  2-25* 628 644 691 1249 1252 1263 1330 1594 1647
                                                                                  1827 2204 2227 2312 2445 2509 2749 3632 3691 3815
                                                                                  3950 3953 3960 3971 3997 4048 4051 4229 4229 4362
                                                                                  9-25* 4511 4511 4662 4677 4677 4697 4716 4880 4880
                                                                                  4983 5034 5040
not_in_storage            0(23)        based           bit(1)                   level 3 packed packed unaligned dcl 4-1005 set ref
                                                                                  4258*
not_op                                 constant        fixed bin(18,0)          initial dcl 5-197 ref 4371
null                                                   builtin function         dcl 276 ref 1196 1244 4185 4223 4531 4535 4872
num_args                  6            based           fixed bin(18,0)          level 2 dcl 180 set ref 850 2904* 2915 2916 3141
                                                                                  3204 3206 3208 3228
num_dims                        001714 automatic       fixed bin(17,0)          dcl 3035 set ref 3044* 3052 3058 3058 3058 3058 3063
                                                                                  3088
num_operands                    002070 automatic       fixed bin(18,0)          dcl 3894 set ref 3904* 3906* 3908 3911*
numb_of_dims              3            based           fixed bin(17,0)          level 2 dcl 227 set ref 3052 3088*
number                                 parameter       fixed bin(18,0)          dcl 2367 in procedure "get_data_type" ref 2364 2381
                                                                                  2382 2392
number                                 parameter       fixed bin(18,0)          dcl 2494 in procedure "get_node_type" ref 2491 2503
                                                                                  2504
number                    0(11)        based           fixed bin(7,0)           level 2 in structure "operator" packed packed
                                                                                  unsigned unaligned dcl 8-144 in procedure
                                                                                  "fort_converter" set ref 2209 2209* 2226 2232
                                                                                  2233* 2257 2257 3963 3974 4215 4222* 4494 4534*
number_of_cases                        parameter       fixed bin(18,0)          dcl 445 set ref 442 447*
number_of_dims            0(05)        based           fixed bin(3,0)           level 2 packed packed unaligned dcl 4-383 ref 2601
                                                                                  3044 4838
o                               002120 automatic       pointer                  dcl 3993 in procedure "strip_sub_index" set ref
                                                                                  3999* 4000 4000
o                               002346 automatic       pointer                  dcl 4861 in procedure "unthread_do" set ref 4879*
                                                                                  4880 4880 4880 4880
o                               002106 automatic       pointer                  dcl 3946 in procedure "get_char_size" set ref 3962*
                                                                                  3963 3963 3963 3973* 3974 3974 3974
object_base               4            based           pointer                  level 2 in structure "shared_globals" dcl 287
                                                                                  in procedure "fort_converter" ref 305
object_base                     001236 automatic       pointer                  dcl 268 in procedure "fort_converter" set ref 305*
                                                                                  314 316 318 320 322 324 326 328 392 405 409 2769
                                                                                  2798 2813 2827 2838 2853 2866 2880 2894 2917 2935
                                                                                  2953 2968 2984 2998 3014 3051 3077 3109 3117
object_max_len                  001244 automatic       fixed bin(18,0)          dcl 271 in procedure "fort_converter" set ref 310*
object_max_len           36            based           fixed bin(19,0)          level 2 in structure "shared_globals" dcl 287
                                                                                  in procedure "fort_converter" ref 310
offset                   14            based           fixed bin(18,0)          level 3 in structure "sub_stack" dcl 162
                                                                                  in procedure "fort_converter" set ref 498* 498
                                                                                  1960 1962* 1979* 1979 2014 2016* 2036* 2036 2039*
                                                                                  2039 2055* 2055 2082 2084* 2103* 2103 2114 2115*
                                                                                  2146 2167 2170* 2301 2303* 2356 2564 2567 2574*
                                                                                  3298* 3341 3343* 3350 3390 3402* 3441* 3441 3463
                                                                                  3524*
offset                   17            based           fixed bin(24,0)          level 2 in structure "symbol" dcl 4-844 in procedure
                                                                                  "fort_converter" ref 1462
offset                          001262 automatic       fixed bin(18,0)          dcl 2-13 in procedure "create_node" set ref 2-22*
                                                                                  2-24 2-25 2-26
offset                          000124 automatic       fixed bin(18,0)          dcl 9-13 in procedure "create_node" set ref 9-22*
                                                                                  9-24 9-25 9-26
offset                                 parameter       fixed bin(18,0)          dcl 2419 in procedure "effectively_constant" ref
                                                                                  2416 2430
offset1                                parameter       fixed bin(18,0)          dcl 4971 ref 4968 4979 4981
offset2                                parameter       fixed bin(18,0)          dcl 4971 ref 4968 4979 4982
old_operator                    001344 automatic       pointer                  dcl 2193 set ref 2206* 2207 2209 2213 2216* 2229*
                                                                                  2230 2232 2236 2239*
one                             000116 automatic       fixed bin(18,0)          dcl 126 set ref 330* 1028 2317 3772* 4629 4779 4945
op                        1            based           fixed bin(18,0)          level 2 in structure "eol_stack" dcl 204
                                                                                  in procedure "fort_converter" set ref 786 806 806
                                                                                  806 824 864 1087 1109 1117 1117 1125 1133 1141
                                                                                  1156 1166 1181 1191 1206 2775* 2777 2787 2802
op                        1            based           fixed bin(18,0)          level 2 in structure "exit_stack" dcl 193
                                                                                  in procedure "fort_converter" set ref 553 556*
                                                                                  579* 616* 700 902 902 915 926 954 1002 1242* 3227*
                                                                                  4848
op                              002116 automatic       fixed bin(18,0)          dcl 3992 in procedure "strip_sub_index" set ref
                                                                                  3995* 3997 3999 4000* 4004
op                                     parameter       pointer                  dcl 4955 in procedure "unthread" ref 4952 4960 4960
                                                                                  4961 4961
op                              002406 automatic       fixed bin(18,0)          dcl 5027 in procedure "effective_operand" set ref
                                                                                  5030* 5031 5033 5037* 5038 5040* 5044
op_code                   1            based           fixed bin(18,0)          level 2 in structure "hold_stack" dcl 210
                                                                                  in procedure "fort_converter" set ref 603* 883*
                                                                                  915* 1072* 1195* 1370* 4065 4070 4081 4086 4086
                                                                                  4091 4100
op_code                         001312 automatic       fixed bin(18,0)          dcl 435 in procedure "process_operator" set ref 437*
                                                                                  438 438 440 450 450
op_code                                based           fixed bin(8,0)           level 2 in structure "opt_statement" packed packed
                                                                                  unaligned dcl 8-176 in procedure "fort_converter"
                                                                                  set ref 4178* 4524*
op_code                                based           fixed bin(8,0)           level 2 in structure "operator" packed packed
                                                                                  unaligned dcl 8-144 in procedure "fort_converter"
                                                                                  set ref 556* 1848 2207 2230 2443 3963 3974 4000
                                                                                  4221* 4227 4356 4371 4373* 4383 4383 4383 4383
                                                                                  4386 4394 4394 4394 4394 4533*
op_index                        000117 automatic       fixed bin(18,0)          dcl 126 set ref 518* 538* 560* 562 564* 565* 584*
                                                                                  601* 620* 641* 658* 661* 688* 698* 713* 723* 732*
                                                                                  740* 755* 769* 777* 837* 873* 875 932* 942* 976*
                                                                                  1045* 1054* 1144 1257* 1269* 1289* 1345* 1350*
                                                                                  1351 1412* 1414 1483* 1503* 1541* 1547 1550* 1585*
                                                                                  1619* 1628* 1637* 1682* 1686* 1727* 1729 1742*
                                                                                  1743 1824* 1855 1863* 1905* 1968* 2022* 2090*
                                                                                  2154* 2197 2353* 2456* 2484* 2715* 2760* 2788*
                                                                                  3185* 3266* 3318* 3378* 3479* 3567* 3595* 3637*
                                                                                  3724* 3822* 3911* 3916 4254 4320* 4669* 4922* 4923
op_p                                   parameter       pointer                  dcl 2249 in procedure "unchain_cat_op" ref 2246 2256
op_p                                   parameter       pointer                  dcl 4454 in procedure "unchain_op" ref 4451 4459
                                                                                  4459 4460 4460 4461 4462
op_ptr                                 parameter       pointer                  dcl 2268 in procedure "unchain" ref 2263 2270 2270
                                                                                  2271 2271 2272 2273
op_ptr                                 parameter       pointer                  dcl 3859 in procedure "unchain_opt_subscript" ref
                                                                                  3853 3861 3861 3862 3862 3863 3864
open_op                                constant        fixed bin(18,0)          initial dcl 5-197 ref 806 1117
operand                                parameter       fixed bin(18,0)          dcl 4015 in procedure "is_local" ref 4009 4018
operand                                parameter       fixed bin(18,0)          dcl 3992 in procedure "strip_sub_index" ref 3986
                                                                                  3995
operand                   4            based           fixed bin(18,0)          array level 2 in structure "operator" dcl 8-144
                                                                                  in procedure "fort_converter" set ref 557* 1063*
                                                                                  1144 2204 2206 2210* 2210 2211* 2211 2213* 2213
                                                                                  2227 2229 2234* 2234 2236* 2236 2257 2257 2445
                                                                                  2448 3780 3782 3920 3963* 3974* 4000 4081* 4093
                                                                                  4093* 4103* 4226* 4227* 4227* 4229 4229 4229 4229
                                                                                  4229 4362 4367 4374* 4374 4386 4386 4388* 4388
                                                                                  4408 4409* 4409 4536* 4537* 4675 4879
operand                                parameter       fixed bin(18,0)          dcl 4043 in procedure "is_star_extent" ref 4036 4046
operand                   7            based           fixed bin(18,0)          array level 3 in structure "sf_stack" dcl 180
                                                                                  in procedure "fort_converter" set ref 414 841*
operand1                               parameter       fixed bin(18,0)          dcl 3877 ref 3870 3881
operand2                               parameter       fixed bin(18,0)          dcl 3877 ref 3870 3880
operand_base                    001240 automatic       pointer                  dcl 268 in procedure "fort_converter" set ref 306*
                                                                                  337 368 388 388 404 2-24 2-25 1-61 1-63 1-76 1-76
                                                                                  1-80 1-91 628 628 628 644 644 644 691 691 691 832
                                                                                  834 834 836 838 959 971 979 1065 1144 1146 1247
                                                                                  1251 1285 1365 1394 1432 1433 1594 1594 1594 1647
                                                                                  1647 1647 1667 1667 1672 1672 1827 1827 1827 1848
                                                                                  1848 1848 1848 1848 2204 2206 2227 2229 2257 2257
                                                                                  2272 2311 2388 2430 2445 2448 2450 2452 2508 2600
                                                                                  2678 2689 2709 2709 2749 2749 2749 2902 3043 3057
                                                                                  3311 3632 3690 3694 3714 3781 3796 3815 3844 3844
                                                                                  3863 3908 3915 3997 3999 4018 4026 4046 4048 4075
                                                                                  4126 4127 4128 4128 4128 4128 4132 4146 4146 4146
                                                                                  4229 4229 4229 4229 4252 4274 4283 4312 4314 4362
                                                                                  4367 4407 4435 4436 4437 4437 4437 4437 4441 9-24
                                                                                  9-25 4461 4510 4584 4585 4650 4651 4676 4879 4891
                                                                                  4919 4981 4982 5033 5038
operand_base              2            based           pointer                  level 2 in structure "shared_globals" dcl 287
                                                                                  in procedure "fort_converter" ref 306
operand_max_len          35            based           fixed bin(19,0)          level 2 in structure "shared_globals" dcl 287
                                                                                  in procedure "fort_converter" ref 311
operand_max_len                 001245 automatic       fixed bin(18,0)          dcl 271 in procedure "fort_converter" set ref 311*
                                                                                  2-20 2-29 2-29 2771 2815 2840 2868 2897 2937 2970
                                                                                  3000 9-20 9-29 9-29
operand_type              0(09)        based           fixed bin(4,0)           level 2 in structure "symbol" packed packed
                                                                                  unaligned dcl 4-844 in procedure "fort_converter"
                                                                                  set ref 4277*
operand_type              0(09)        based           fixed bin(4,0)           level 2 in structure "array_ref" packed packed
                                                                                  unaligned dcl 4-155 in procedure "fort_converter"
                                                                                  set ref 3917*
operand_type              0(09)        based           fixed bin(4,0)           level 2 in structure "temporary" packed packed
                                                                                  unaligned dcl 4-1005 in procedure "fort_converter"
                                                                                  set ref 4255*
operand_type              0(09)        based           fixed bin(4,0)           level 2 in structure "label" packed packed unaligned
                                                                                  dcl 4-530 in procedure "fort_converter" set ref
                                                                                  4127* 4436*
operand_type              0(09)        based           fixed bin(4,0)           level 2 in structure "node" packed packed unaligned
                                                                                  dcl 4-63 in procedure "fort_converter" ref 3731
operand_type              0(09)        based           fixed bin(4,0)           level 2 in structure "constant" packed packed
                                                                                  unaligned dcl 4-256 in procedure "fort_converter"
                                                                                  set ref 1-82*
operator                               based           structure                level 1 dcl 8-144 in procedure "fort_converter" set
                                                                                  ref 4210 4215* 4487 4494*
operator                               parameter       fixed bin(18,0)          dcl 3877 in procedure "do_arith" ref 3870 3882
operator_list             7            based           pointer                  level 2 packed packed unaligned dcl 8-176 set ref
                                                                                  4185* 4531*
opnd                                   parameter       fixed bin(18,0)          dcl 5025 ref 5020 5030
opst                            001200 automatic       pointer                  dcl 254 in procedure "fort_converter" set ref 349*
                                                                                  367 373 876 887* 888 889 1006* 1007 1008 1058*
                                                                                  1059 1060 1066 1198 1353* 1354 1355 1360* 1361
                                                                                  1362 1363 1364 1371 1408 1415* 4065 4072 4072 4074
                                                                                  4219 4219 4918*
opst                            002206 automatic       pointer                  dcl 4156 in procedure "create_opt_statement" set ref
                                                                                  4166* 4167 4170 4171 4177 4178 4179 4180 4181 4182
                                                                                  4183 4184 4185 4185 4188 4189
opt_statement                          based           structure                level 1 dcl 8-176 set ref 559 1411 4163 4167* 4489
                                                                                  4493*
opt_subscript_op                       constant        fixed bin(18,0)          initial dcl 5-197 ref 3647 3834 3963 4227
optimized_something             002324 automatic       bit(1)                   dcl 4550 set ref 4587* 4655* 4803
options                 113            based           structure                level 2 in structure "shared_globals" dcl 287
                                                                                  in procedure "fort_converter"
options                  11            based           structure                level 2 in structure "subprogram" dcl 4-753
                                                                                  in procedure "fort_converter"
or_op                                  constant        fixed bin(18,0)          initial dcl 5-197 ref 4383 4394
output                    3            based           fixed bin(18,0)          level 2 dcl 8-144 set ref 643* 690* 1593* 1646*
                                                                                  1855* 1865* 2272 2273 2450 2452 2453 2761* 3211
                                                                                  3213* 3863 3864 3913* 4253* 4461 4462 4891 4892
output_by                 6(18)        based           fixed bin(18,0)          level 2 in structure "array_ref" packed packed
                                                                                  unsigned unaligned dcl 4-155 in procedure
                                                                                  "fort_converter" set ref 3780 3782 3847 3847 3916*
                                                                                  3962
output_by                 6(18)        based           fixed bin(18,0)          level 2 in structure "temporary" packed packed
                                                                                  unsigned unaligned dcl 4-1005 in procedure
                                                                                  "fort_converter" set ref 1848 2206 2229 2257 2257
                                                                                  2442 3844 3844 3973 3999 4254* 4367 4513 4664
p                               002144 automatic       pointer                  dcl 4044 in procedure "is_star_extent" set ref 4046*
                                                                                  4048 4048* 4048 4051 4051
p                               002104 automatic       pointer                  dcl 3946 in procedure "get_char_size" set ref 3948*
                                                                                  3950 3950 3953 3955 3955 3957 3960 3962 3966 3966
                                                                                  3968 3971 3973 3976 3976 3978
p                               002240 automatic       pointer                  dcl 4266 in procedure "create_var" set ref 4274*
                                                                                  4275 4276 4277 4278 4278 4278 4278 4278 4278
p                               002410 automatic       pointer                  dcl 5028 in procedure "effective_operand" set ref
                                                                                  5033* 5034 5034 5037 5038* 5040 5040 5040
p                               002132 automatic       pointer                  dcl 4016 in procedure "is_local" set ref 4018* 4020
                                                                                  4027
p                               001362 automatic       pointer                  dcl 2249 in procedure "unchain_cat_op" set ref 2256*
                                                                                  2257 2257 2257 2257 2258*
p                               001734 automatic       pointer                  dcl 3103 in procedure "create_dim_size_var" set ref
                                                                                  3109* 3109* 3112 3112 3112 3112* 3117
p                                      based           fixed bin(18,0)          array dcl 263 in procedure "fort_converter" set ref
                                                                                  345 364 364 367 368 383 386 386 388 1056 1405 1498
                                                                                  4571 4576 4581 4584 4622 4634 4640* 4640* 4797*
                                                                                  4842* 4842 4844* 4846* 4851* 4852*
p1                              002364 automatic       pointer                  dcl 4973 set ref 4981* 4985 4985
p2                              002366 automatic       pointer                  dcl 4973 set ref 4982* 4983 4987 4987
parameter                11(04)        based           bit(1)                   level 4 packed packed unaligned dcl 4-844 ref 4985
                                                                                  4987
parent                   11(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-155
                                                                                  set ref 3694 3920* 4048
parent_constant_part            002035 automatic       fixed bin(18,0)          dcl 3670 set ref 3780* 3781
parent_constant_value           002045 automatic       fixed bin(35,0)          dcl 3680 set ref 3781* 3784 3796 3796
parent_if                       000156 automatic       fixed bin(18,0)          dcl 4473 set ref 4497*
parent_if_p                            parameter       pointer                  dcl 4471 ref 4468 4495
parent_is_array                 002030 automatic       bit(1)                   packed unaligned dcl 3665 set ref 3693* 3698* 3778
                                                                                  3842
parent_ptr                      002020 automatic       pointer                  dcl 3663 set ref 3690* 3691 3694 3695 3699 3780 3782
                                                                                  3847 3847
parent_variable_part            002036 automatic       fixed bin(18,0)          dcl 3670 set ref 3788* 3789 3791* 3844
polish_base                     001232 automatic       pointer                  dcl 268 in procedure "fort_converter" set ref 303*
                                                                                  345 364 364 367 368 383 386 386 388 1056 1405 1498
                                                                                  4571 4576 4581 4584 4622 4634 4640 4640 4797 4842
                                                                                  4842 4844 4846 4851 4852
polish_base                            based           pointer                  level 2 in structure "shared_globals" dcl 287
                                                                                  in procedure "fort_converter" ref 303
polish_max_len                  001242 automatic       fixed bin(18,0)          dcl 271 in procedure "fort_converter" set ref 308*
                                                                                  1499
polish_max_len           34            based           fixed bin(19,0)          level 2 in structure "shared_globals" dcl 287
                                                                                  in procedure "fort_converter" ref 308
polish_offset             1            based           fixed bin(18,0)          level 2 in structure "sf_stack" dcl 180 in procedure
                                                                                  "fort_converter" set ref 956 3229*
polish_offset                   000120 automatic       fixed bin(18,0)          dcl 126 in procedure "fort_converter" set ref 359*
                                                                                  364 364 367 368 369* 369 381* 381 381* 383 386 386
                                                                                  388* 956* 1056 1311 1313 1394 1405* 1405 1405*
                                                                                  1498* 1498 1498 1499 3229 3232* 4566 4828* 4828
                                                                                  4842 4844 4846 4851 4852 4852
prev_operator             1(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 8-176
                                                                                  set ref 560 1412 4177* 4497 4922 4928 4930
primary                   2            based           pointer                  level 2 packed packed unaligned dcl 8-144 set ref
                                                                                  4223* 4535*
print_message          1530            based           entry variable           level 2 dcl 287 ref 297 407 2-29 1-45 450 1080 1211
                                                                                  1499 1653 1910 2409 2411 2771 2815 2840 2868 2897
                                                                                  2937 2970 3000 3206 3208 3703 4164 4208 4211 9-29
                                                                                  4490 4710 4729
process_param_list_op                  constant        fixed bin(18,0)          initial dcl 5-197 ref 1133
processed_by_converter
                          4(02)        based           bit(1)                   level 3 packed packed unaligned dcl 8-176 set ref
                                                                                  373* 4146 4529*
profile_size             55            based           fixed bin(17,0)          level 2 dcl 287 set ref 1416* 1416
ptr                       5            based           pointer                  level 2 in structure "exit_stack" packed packed
                                                                                  unaligned dcl 193 in procedure "fort_converter"
                                                                                  set ref 556 557 586* 916 1244* 1324* 4872 4877
ptr                       2            based           pointer                  level 2 in structure "hold_stack" packed packed
                                                                                  unaligned dcl 210 in procedure "fort_converter"
                                                                                  set ref 604* 884* 916* 1073* 1196* 1371* 4081 4086
                                                                                  4093 4093
ptr                                                    builtin function         dcl 276 in procedure "fort_converter" ref 561 1413
put_in_map                3            based           bit(1)                   level 3 in structure "statement" packed packed
                                                                                  unaligned dcl 4-721 in procedure "fort_converter"
                                                                                  ref 4181
put_in_map                4            based           bit(1)                   level 3 in structure "opt_statement" packed packed
                                                                                  unaligned dcl 8-176 in procedure "fort_converter"
                                                                                  set ref 889* 1008* 1060* 1355* 1362* 4065 4181*
                                                                                  4400 4530*
put_in_profile            3(01)        based           bit(1)                   level 3 in structure "statement" packed packed
                                                                                  unaligned dcl 4-721 in procedure "fort_converter"
                                                                                  ref 4182
put_in_profile            4(01)        based           bit(1)                   level 3 in structure "opt_statement" packed packed
                                                                                  unaligned dcl 8-176 in procedure "fort_converter"
                                                                                  set ref 888* 1007* 1059* 1354* 1361* 4182*
q                                      based           fixed bin(18,0)          array dcl 263 set ref 560 561 846 884 1063 1073 1144
                                                                                  1408 1412 1413 1848 1855 2197 2206 2229 2257 2257
                                                                                  2270 2271 2442 2457 2462 2463 3258 3259 3260 3261
                                                                                  3263 3267 3780 3782 3844 3844 3847 3847 3861 3862
                                                                                  3962 3973 3999 4103 4146 4146 4166 4173 4214 4217
                                                                                  4367 4400 4402 4404 4404 4406 4459 4460 4486 4488
                                                                                  4496 4497 4501 4503 4514 4516 4525 4526 4527 4664
                                                                                  4665 4668 4672 4883 4894 4900 4906 4908 4910 4917
                                                                                  4918 4923 4928 4930 4960 4961
quad_max_len             37            based           fixed bin(19,0)          level 2 in structure "shared_globals" dcl 287
                                                                                  in procedure "fort_converter" ref 309
quad_max_len                    001243 automatic       fixed bin(18,0)          dcl 271 in procedure "fort_converter" set ref 309*
                                                                                  4164 4164 4164 4211 4211 4211 4490 4490 4490
quadruple_base            6            based           pointer                  level 2 in structure "shared_globals" dcl 287
                                                                                  in procedure "fort_converter" ref 304
quadruple_base                  001234 automatic       pointer                  dcl 268 in procedure "fort_converter" set ref 304*
                                                                                  560 561 561 846 884 1063 1073 1144 1408 1412 1413
                                                                                  1413 1848 1855 2197 2206 2229 2257 2257 2270 2271
                                                                                  2442 2457 2462 2463 3258 3259 3260 3261 3263 3267
                                                                                  3780 3782 3844 3844 3847 3847 3861 3862 3962 3973
                                                                                  3999 4103 4146 4146 4166 4173 4214 4217 4367 4400
                                                                                  4402 4404 4404 4406 4459 4460 4486 4488 4496 4497
                                                                                  4501 4503 4514 4516 4525 4526 4527 4664 4665 4668
                                                                                  4672 4883 4894 4900 4906 4908 4910 4917 4918 4923
                                                                                  4928 4930 4960 4961
r                               001202 automatic       pointer                  dcl 254 in procedure "fort_converter" set ref 1247*
                                                                                  1249 1249 1263 1270 1330 1330 1334 2311* 2312 2314
                                                                                  2329 2337
r                               001456 automatic       pointer                  dcl 2495 in procedure "get_node_type" set ref 2508*
                                                                                  2509
r                               002316 automatic       pointer                  dcl 4548 in procedure "optimize_vector" set ref
                                                                                  4664* 4665 4665 4665 4668 4669 4672 4672 4675
r                               001434 automatic       pointer                  dcl 2421 in procedure "effectively_constant" set ref
                                                                                  2430* 2435 2442* 2442 2443 2445 2448 2450 2452
                                                                                  2453 2454 2456 2462 2462 2463 2463
r                               001414 automatic       pointer                  dcl 2370 in procedure "get_data_type" set ref 2388*
                                                                                  2389
rand_data_type                  000121 automatic       fixed bin(18,0)          array dcl 126 set ref 539* 929 1822 1825* 1845 1845
                                                                                  1848 1906 1906 1906 1906 1937 1939 1969 1969 1969
                                                                                  1969 2023 2023 2023 2023 2091 2091 2091 2091 2155
                                                                                  2155 2155 2155 2294 2294 2296 2309 2350 2354 2354
                                                                                  2354 2354 2383* 2385* 2389* 2392 2395 2397 2397
                                                                                  2431 2485 2487 2487 3174 3174 3178 3183 3186*
                                                                                  3638* 3715 3910* 3919
rand_no                                parameter       fixed bin(18,0)          dcl 2419 ref 2416 2431 2433 2439
rand_node_type                  000131 automatic       fixed bin(18,0)          array dcl 126 set ref 1848 1885 1885 1885 1885 2433
                                                                                  2439 2505* 2509*
rc_t                                   constant        bit(6)                   initial packed unaligned dcl 3-6 ref 1-84
read_op                                constant        fixed bin(18,0)          initial dcl 5-197 ref 684
read_scalar_op                         constant        fixed bin(18,0)          initial dcl 5-197 ref 687
ref_count                 6            based           fixed bin(17,0)          level 2 in structure "array_ref" packed packed
                                                                                  unaligned dcl 4-155 in procedure "fort_converter"
                                                                                  set ref 644* 644 691* 691 1594* 1594 1647* 1647
                                                                                  1827* 1827 2749* 2749 3918*
ref_count                 6            based           fixed bin(17,0)          level 2 in structure "temporary" packed packed
                                                                                  unaligned dcl 4-1005 in procedure "fort_converter"
                                                                                  set ref 2450 4229* 4229 4256* 4677* 4677 4880*
                                                                                  4880
referenced                0(27)        based           bit(1)                   level 5 in structure "symbol" packed packed
                                                                                  unaligned dcl 4-844 in procedure "fort_converter"
                                                                                  set ref 4278*
referenced                0(27)        based           bit(1)                   level 5 in structure "label" packed packed unaligned
                                                                                  dcl 4-530 in procedure "fort_converter" set ref
                                                                                  4128* 4437*
referenced_backwards      4(03)        based           bit(1)                   level 3 packed packed unaligned dcl 8-176 set ref
                                                                                  1364* 4146*
referenced_executable
                          0(29)        based           bit(1)                   level 4 packed packed unaligned dcl 4-530 set ref
                                                                                  1065* 1365* 4075* 4407*
rel                                                    builtin function         dcl 276 ref 3830 4170 4171 4171
rel_constant                           constant        fixed bin(4,0)           initial dcl 5-120 ref 4127 4436
reloc                     2(12)        based           bit(6)                   level 2 packed packed unaligned dcl 4-256 set ref
                                                                                  1-84*
removable                 4(07)        based           bit(1)                   level 3 packed packed unaligned dcl 8-176 set ref
                                                                                  876* 1198*
result_type              10     000010 external static fixed bin(18,0)          array level 3 dcl 217 set ref 2725*
running_base                    001403 automatic       fixed bin(18,0)          dcl 2280 set ref 2331* 2333 2344*
s                               001204 automatic       pointer                  dcl 254 in procedure "fort_converter" set ref 1251*
                                                                                  1252
s                               001476 automatic       pointer                  dcl 2595 in procedure "initialize_subscript" set ref
                                                                                  2599* 2600 2619 2636 2645* 2655*
s                               002134 automatic       pointer                  dcl 4016 in procedure "is_local" set ref 4026* 4027
                                                                                  4029
save_polish_offset              000141 automatic       fixed bin(18,0)          dcl 126 set ref 1311* 1313
set                       0(26)        based           bit(1)                   level 5 in structure "symbol" packed packed
                                                                                  unaligned dcl 4-844 in procedure "fort_converter"
                                                                                  set ref 4278*
set                       0(26)        based           bit(1)                   level 5 in structure "label" packed packed unaligned
                                                                                  dcl 4-530 in procedure "fort_converter" set ref
                                                                                  4128* 4437*
sf                        2            based           fixed bin(18,0)          level 2 dcl 180 set ref 2901* 2902 3206* 3208*
sf_entry                               parameter       fixed bin(18,0)          dcl 3240 ref 3237 3254 3255 3269 3269
sf_num_args                     000142 automatic       fixed bin(18,0)          dcl 126 set ref 2895* 2896 2900 2904 2915*
sf_offset                       000143 automatic       fixed bin(18,0)          dcl 126 set ref 317* 318 2899 2900* 2914* 2917 3136
                                                                                  3141 3141
sf_op                                  constant        fixed bin(18,0)          initial dcl 5-197 ref 824 954 1181 3227
sf_ptr                                 parameter       pointer                  dcl 3242 ref 3237 3254 3255 3269 3269
sf_stack                               based           structure                level 1 dcl 180 set ref 2896 2900 2916* 3141
sf_stack_p                      001206 automatic       pointer                  dcl 254 set ref 318* 392 826 831 832 841 841 842 842
                                                                                  842 842 845 845 846 846 846 846 849 849 850 850
                                                                                  850 850 956 959 971 974 977 979 979 2894* 2896
                                                                                  2899 2900 2901 2902 2902 2903 2904 2905 2905 2906
                                                                                  2906 2914 2915 2916 2917* 3141 3204 3204 3206 3206
                                                                                  3206 3208 3208 3208 3212 3228 3229 3232
sf_substitute_ptr               001210 automatic       pointer                  dcl 254 set ref 392* 392* 398* 405 409 412 412* 414
shared_globals                         based           structure                level 1 dcl 287
shared_struc_ptr                001212 automatic       pointer                  dcl 254 set ref 297 301* 303 304 305 306 308 309 310
                                                                                  311 334 334 334 337 342 342 345 359 407 2-20 2-22
                                                                                  2-23 2-23 2-29 1-45 1-87 1-87 1-89 1-89 1-91 1-93
                                                                                  450 559 559 1080 1211 1411 1411 1416 1416 1499
                                                                                  1653 1910 2215 2215 2238 2238 2272 2273 2409 2411
                                                                                  2452 2453 2458 2771 2815 2840 2868 2897 2937 2970
                                                                                  3000 3206 3208 3563 3703 3863 3864 4025 4162 4163
                                                                                  4163 4164 4164 4168 4206 4208 4210 4210 4211 4211
                                                                                  9-20 9-22 9-23 9-23 9-29 4461 4462 4485 4487 4489
                                                                                  4490 4490 4670 4673 4674 4710 4729 4891 4892 4924
size                      7            based           fixed bin(24,0)          array level 3 in structure "dimension" dcl 4-383
                                                                                  in procedure "fort_converter" set ref 2606* 2609*
                                                                                  2612* 2642 3414 3424 3449 3453
size                                                   builtin function         dcl 276 in procedure "fort_converter" ref 359 559
                                                                                  1411 2770 2774 2814 2818 2839 2843 2867 2871 2896
                                                                                  2900 2936 2940 2969 2974 2999 3003 3912 3912 4125
                                                                                  4125 4163 4210 4251 4251 4273 4273 4434 4434 4487
                                                                                  4489
size                      4            based           fixed bin(24,0)          level 2 in structure "dim_size_list" dcl 243
                                                                                  in procedure "fort_converter" set ref 3112 3123*
                                                                                  3125
size                                                   builtin function         dcl 1-33 in procedure "create_constant" ref 1-74
                                                                                  1-74
source_id                 2            based           structure                level 2 in structure "statement" packed packed
                                                                                  unaligned dcl 4-721 in procedure "fort_converter"
                                                                                  ref 4179
source_id                 3            based           structure                level 2 in structure "opt_statement" packed packed
                                                                                  unaligned dcl 8-176 in procedure "fort_converter"
                                                                                  set ref 4179* 4525* 4525
st                              002342 automatic       fixed bin(18,0)          dcl 4860 set ref 4905* 4906 4907* 4908 4916* 4917
                                                                                  4918
stack                           000160 automatic       fixed bin(18,0)          array dcl 215 set ref 383* 388 388 402 414* 437 495
                                                                                  528* 539* 543* 557 579* 598 598* 617 628 628 628*
                                                                                  628 638* 638 639* 639 640* 640 643 644 644 644 644
                                                                                  650 687* 687 690 691 691 691 691 697* 697 808* 808
                                                                                  834 836* 838* 841 870* 871* 931* 934* 936* 939*
                                                                                  959 969 971 974* 977* 979 1012 1012* 1012* 1014*
                                                                                  1014 1015* 1019* 1023 1026 1026* 1026* 1028* 1029*
                                                                                  1033* 1036* 1036 1039* 1039 1040* 1040 1041* 1047*
                                                                                  1049* 1050* 1051* 1145* 1146 1247 1251 1254* 1254
                                                                                  1255* 1258* 1266* 1266 1267* 1270* 1274* 1274
                                                                                  1275* 1275 1276* 1280* 1280 1281* 1285 1287* 1291*
                                                                                  1298* 1298 1302* 1303* 1304* 1319* 1319 1320* 1320
                                                                                  1321* 1332* 1332 1333* 1333 1334* 1337* 1340* 1340
                                                                                  1341* 1342* 1346* 1347* 1348* 1394 1431 1432 1459*
                                                                                  1460* 1462* 1465* 1469 1474 1522 1593 1594 1594
                                                                                  1594 1594 1646 1647 1647 1647 1647 1664 1664 1667
                                                                                  1667 1670* 1672 1672 1675* 1677* 1680* 1683* 1684*
                                                                                  1687* 1719 1724* 1725* 1733* 1740* 1813* 1813
                                                                                  1822* 1825* 1827 1827 1827 1827 1848 1848 1848
                                                                                  1848 1848 1855 1865 1885 1885 1885 1885 1890* 1890
                                                                                  1891* 1891 1892* 1892 1906* 1910 1910 1910 1910
                                                                                  1947 1964 1969* 1988 2000* 2018 2023* 2052 2068*
                                                                                  2086 2091* 2116 2129* 2150* 2155* 2167* 2182*
                                                                                  2301* 2311 2317* 2331 2333* 2334* 2339* 2340* 2344
                                                                                  2354* 2358 2359* 2382 2411 2411 2411 2430 2504
                                                                                  2529* 2536* 2537* 2540* 2546* 2547* 2548* 2551*
                                                                                  2562 2562 2566* 2566 2567* 2569* 2572* 2579 2579
                                                                                  2678 2689 2709 2709 2712* 2712 2713* 2716* 2725*
                                                                                  2749 2749 2749 2749 2756 2757* 2757 2758* 2758
                                                                                  2775 2787* 2788 2895 2901 3182* 3182 3183* 3186*
                                                                                  3211* 3212* 3213 3294 3300 3301* 3316* 3353* 3354*
                                                                                  3355* 3359 3372* 3376* 3379* 3384* 3386* 3390*
                                                                                  3392* 3395* 3396* 3400 3423* 3424* 3426* 3430
                                                                                  3476* 3477* 3483* 3484* 3485* 3489 3498* 3502*
                                                                                  3504* 3510* 3511* 3516 3550* 3551* 3556* 3557*
                                                                                  3563* 3568* 3581* 3582* 3590 3592* 3593* 3596*
                                                                                  3600* 3601* 3630 3632 3634* 3638* 3647* 3690 3703*
                                                                                  3714 3721* 3721 3722* 3732 3818* 3819* 3830* 3831*
                                                                                  3832* 3833* 3834* 3880* 3881* 3882* 3886 3908
                                                                                  3912* 3913 3915 4221 4226 4312 4314 4317* 4317
                                                                                  4318* 4321* 4617 4622 4629 4648 4649 4675* 4710*
                                                                                  4729* 4757* 4759* 4762* 4767* 4771* 4779* 4780*
                                                                                  4788* 4789* 4794 4812* 4815* 4816* 4821 4944*
                                                                                  4945* 4947*
standard_bits             0(25)        based           structure                level 4 in structure "symbol" packed packed
                                                                                  unaligned dcl 4-844 in procedure "fort_converter"
standard_bits             0(25)        based           structure                level 4 in structure "label" packed packed unaligned
                                                                                  dcl 4-530 in procedure "fort_converter"
star_extents             11(09)        based           bit(1)                   level 3 packed packed unaligned dcl 4-844 ref 1440
                                                                                  2619 3617 3796 4051
start                     3(09)        based           fixed bin(26,0)          level 2 in structure "statement" packed packed
                                                                                  unaligned dcl 4-721 in procedure "fort_converter"
                                                                                  ref 4183
start                           001772 automatic       fixed bin(18,0)          dcl 3240 in procedure "rechain_arg" set ref 3254*
                                                                                  3259 3263
start                     4(09)        based           fixed bin(26,0)          level 2 in structure "opt_statement" packed packed
                                                                                  unaligned dcl 8-176 in procedure "fort_converter"
                                                                                  set ref 4183* 4527* 4527
start_p                         001774 automatic       pointer                  dcl 3242 set ref 3259* 3260 3261 3264
stat_op                                constant        fixed bin(18,0)          initial dcl 5-197 ref 1056 1370 4178 4524
statement                 5            based           fixed bin(18,0)          level 2 in structure "label" packed packed unsigned
                                                                                  unaligned dcl 4-530 in procedure "fort_converter"
                                                                                  set ref 368* 4126* 4146 4146 4146 4435* 4919*
statement                              based           structure                level 1 dcl 4-721 in procedure "fort_converter" ref
                                                                                  359
stm_ptr                         001214 automatic       pointer                  dcl 254 set ref 345* 351 420 4179 4180 4181 4182
                                                                                  4183 4184 4528
stop                            001773 automatic       fixed bin(18,0)          dcl 3240 set ref 3255* 3256 3258 3266 3267
stop_p                          001776 automatic       pointer                  dcl 3242 set ref 3258* 3260 3261 3261 3265
storage                                based           fixed bin(17,0)          array dcl 9-15 in procedure "create_node" set ref
                                                                                  9-24*
storage                                based           fixed bin(17,0)          array dcl 2-15 in procedure "create_node" set ref
                                                                                  2-24*
storage_class            11            based           structure                level 3 packed packed unaligned dcl 4-844
storage_info              0(25)        based           structure                level 3 in structure "label" packed packed unaligned
                                                                                  dcl 4-530 in procedure "fort_converter"
storage_info              0(25)        based           structure                level 3 in structure "symbol" packed packed
                                                                                  unaligned dcl 4-844 in procedure "fort_converter"
string                                                 builtin function         dcl 276 set ref 2606 2639 3064 3064 3112 3112 3120*
                                                                                  3120 3414 3449
sub_index_op                           constant        fixed bin(18,0)          initial dcl 5-197 ref 1680 3634 3819 4000
sub_offset                      000144 automatic       fixed bin(18,0)          dcl 126 set ref 321* 322 2842 2843* 2851* 2853 3136
                                                                                  3149 3149
sub_op                                 constant        fixed bin(18,0)          initial dcl 5-197 set ref 1276 1465 2562 3485 3601
                                                                                  3756* 3769* 3772* 3772* 4771
sub_stack                              based           structure                level 1 dcl 162 set ref 2839 2843 2852* 3149
sub_stack_p                     001216 automatic       pointer                  dcl 254 set ref 322* 498 498 499 499 499 959 959
                                                                                  1431 1432 1433 1433 1434 1435 1436 1437 1438 1440
                                                                                  1442 1443 1443 1446 1446 1447 1450 1457 1459 1460
                                                                                  1460 1462 1462 1469 1960 1960 1962 1964 1979 1979
                                                                                  1986 1988 2014 2014 2016 2018 2036 2036 2039 2039
                                                                                  2040 2040 2040 2050 2052 2053 2055 2055 2082 2082
                                                                                  2084 2086 2103 2103 2104 2104 2104 2112 2114 2114
                                                                                  2115 2116 2146 2146 2148 2165 2167 2169 2170 2299
                                                                                  2301 2303 2356 2356 2358 2529 2529 2534 2536 2546
                                                                                  2547 2556 2564 2567 2574 2579 2838* 2839 2842 2843
                                                                                  2844 2850 2851 2852 2853* 3149 3298 3300 3311 3311
                                                                                  3319 3333 3339 3341 3341 3341 3342 3342 3343 3350
                                                                                  3352 3352 3352 3353 3354 3359 3372 3374 3382 3384
                                                                                  3390 3395 3400 3401 3401 3402 3409 3409 3414 3414
                                                                                  3414 3414 3414 3414 3423 3424 3424 3430 3440 3440
                                                                                  3440 3441 3441 3441 3447 3447 3449 3449 3449 3449
                                                                                  3449 3449 3453 3453 3453 3463 3463 3463 3464 3472
                                                                                  3474 3476 3480 3483 3484 3489 3498 3500 3502 3508
                                                                                  3510 3516 3522 3523 3524 3525 3525 3526 3526 3533
                                                                                  3551 3554 3556 3560 3579 3579 3579 3579 3581 3582
                                                                                  3588 3592 3600 3617 3617 3617 3617 3617 3617 3617
subp_ptr                        001220 automatic       pointer                  dcl 254 set ref 337* 342 352 422 1263 1328 1547 1653
                                                                                  4130 4130 4132 4133 4168 4168 4175 4283 4284 4439
                                                                                  4439 4441 4442
subprogram                             based           structure                level 1 dcl 4-753
subscript_mode                         parameter       bit(1)                   dcl 1873 ref 1869 1902
subscript_op                           constant        fixed bin(18,0)          initial dcl 5-197 ref 786 1166 2777 2802 4571
subscript_processing            000153 automatic       bit(1)                   initial dcl 158 set ref 158* 466 477 485 957 1429*
                                                                                  2844 2850*
substr                                                 builtin function         dcl 276 ref 1334 2337
substr_length                   002040 automatic       fixed bin(18,0)          dcl 3670 set ref 3751* 3756* 3769* 3772* 3833
sum                             001504 automatic       fixed bin(24,0)          dcl 2597 set ref 2635* 2641* 2641 2650
suspend_subscript               000155 automatic       bit(1)                   initial dcl 158 set ref 158* 466 477 485 2777* 2800*
                                                                                  2802*
sym                             002130 automatic       fixed bin(18,0)          dcl 4015 set ref 4025* 4025* 4026*
symb_p                          002322 automatic       pointer                  dcl 4548 set ref 4584* 4585 4593 4595 4600
symbol                                 based           structure                level 1 dcl 4-844 set ref 4273 4273
symbol_node               2            based           pointer                  level 2 in structure "sub_stack" packed packed
                                                                                  unaligned dcl 162 in procedure "fort_converter"
                                                                                  set ref 1432* 1433 1440 1443 1446 1450 1457 1462
                                                                                  3533 3617 3617 3617
symbol_node               1            based           pointer                  level 2 in structure "virtual_origin_list" packed
                                                                                  packed unaligned dcl 227 in procedure
                                                                                  "fort_converter" set ref 3056 3087*
symbol_node                            constant        fixed bin(4,0)           initial dcl 5-87 in procedure "fort_converter" set
                                                                                  ref 388 3632 3815 3953 4051 4273* 4983 5040
symbol_ptr                             parameter       pointer                  dcl 2593 in procedure "initialize_subscript" ref
                                                                                  2584 2599
symbol_ptr                             parameter       pointer                  dcl 3030 in procedure "create_virtual_origin_var"
                                                                                  ref 3020 3041 3042 3043 3087
sympx                           002022 automatic       pointer                  dcl 3663 set ref 3694* 3699* 3703 3796 3796 3796
                                                                                  3830
system_options          115            based           structure                level 3 dcl 287
target                          001532 automatic       fixed bin(18,0)          dcl 2747 set ref 2756* 2761
temp                     13            based           fixed bin(18,0)          level 3 in structure "sub_stack" dcl 162
                                                                                  in procedure "fort_converter" set ref 499 959 959
                                                                                  1438* 1960 1964* 1986 1988* 2014 2018* 2040 2050
                                                                                  2052* 2082 2086* 2104 2112 2116* 2146 2148* 2165
                                                                                  2169* 2299 2356 2358* 2529 2536 2546 2579* 3300*
                                                                                  3311 3311 3319* 3339 3342* 3353 3359* 3372 3400*
                                                                                  3464 3476 3484 3498 3523*
temp                     10            based           fixed bin(18,0)          level 3 in structure "sub_stack" dcl 162
                                                                                  in procedure "fort_converter" set ref 1436* 1469*
                                                                                  3474 3480* 3483 3489* 3508 3510 3516* 3551 3582
                                                                                  3617
temp_index                      000145 automatic       fixed bin(18,0)          dcl 126 set ref 4251* 4252 4253 4259
temp_node_ptr                   001222 automatic       pointer                  dcl 254 set ref 1144* 1145 1146 1146*
temp_ptr                        001224 automatic       pointer                  dcl 254 set ref 1259 1271 2731 3640 3824 4252* 4254
                                                                                  4255 4256 4257 4258
temp_type                              constant        fixed bin(4,0)           initial dcl 5-120 ref 4255
temporary                              based           structure                level 1 dcl 4-1005 set ref 4251 4251
temporary_node                         constant        fixed bin(4,0)           initial dcl 5-87 set ref 1848 2204 2227 2439 3971
                                                                                  3997 4229 4251* 4362 4511 4677 4880
test_op                   3            based           fixed bin(18,0)          level 2 dcl 235 set ref 880 884 1729* 1743* 1746*
this_array                      001716 automatic       pointer                  dcl 3037 set ref 3056* 3057
this_dim_node                   001720 automatic       pointer                  dcl 3038 set ref 3057* 3058 3058 3064 3064 3064 3074
this_vo_var                     001722 automatic       fixed bin(18,0)          dcl 3039 set ref 3084* 3091
ti                              000157 automatic       fixed bin(18,0)          dcl 4473 set ref 4485* 4486 4508 4517
ti_p                            000146 automatic       pointer                  dcl 4471 set ref 4486* 4494 4509 4518 4533 4534 4535
                                                                                  4536 4537 4538
tkx                             000147 automatic       fixed bin(18,0)          dcl 126 set ref 2539* 2540 2550* 2551 2571* 2572
true_parent_variable_part       002037 automatic       fixed bin(18,0)          dcl 3670 set ref 3782* 3786 3788* 3844 3844 3844
                                                                                  3844
true_rand                       000146 automatic       fixed bin(18,0)          dcl 126 set ref 964* 1937* 1939* 1942* 1949 1965*
                                                                                  1977 1977* 1988 2003 2019* 2034 2034* 2036 2052
                                                                                  2053 2071 2087* 2101 2101* 2116 2132 2167 2296*
                                                                                  2298* 2301 2529 2539 2550 2566 2571 3314*
ts                              000160 automatic       fixed bin(18,0)          dcl 4473 set ref 4487* 4488 4489 4501 4503 4509 4519
ts_p                            000150 automatic       pointer                  dcl 4471 set ref 4488* 4493 4502 4504 4508 4520 4524
                                                                                  4525 4526 4527 4528 4529 4530 4531 4531
type                                   parameter       fixed bin(4,0)           dcl 9-14 in procedure "create_node" ref 9-10 9-25
type                                   parameter       fixed bin(4,0)           dcl 2-14 in procedure "create_node" ref 2-10 2-25
units                     4            based           fixed bin(3,0)           level 2 in structure "virtual_origin_list" unsigned
                                                                                  dcl 227 in procedure "fort_converter" set ref 3052
                                                                                  3089*
units                     2            based           fixed bin(3,0)           level 2 in structure "symbol" packed packed unsigned
                                                                                  unaligned dcl 4-844 in procedure "fort_converter"
                                                                                  ref 3042 3617
units_per_item                         parameter       fixed bin(18,0)          dcl 2784 ref 2781 2788
unspec                                                 builtin function         dcl 276 in procedure "fort_converter" set ref 338*
                                                                                  1408* 2314* 2435* 2448* 2797* 2826* 2852* 2879*
                                                                                  2916* 2952* 2983* 3013* 4167* 4215* 4294 4493*
                                                                                  4494* 4706* 4725*
unspec                                                 builtin function         dcl 2-17 in procedure "create_node" set ref 2-24*
unspec                                                 builtin function         dcl 9-17 in procedure "create_node" set ref 9-24*
upper                     0(10)        based           bit(1)                   array level 3 packed packed unaligned dcl 4-383 ref
                                                                                  4726 5010
upper_bound               3            based           fixed bin(24,0)          level 2 in structure "dim_size_list" dcl 243
                                                                                  in procedure "fort_converter" set ref 3112 3122*
upper_bound               6            based           fixed bin(24,0)          array level 3 in structure "dimension" dcl 4-383
                                                                                  in procedure "fort_converter" ref 2606 2609 3064
                                                                                  3064 3112 3122 4720 4726 5010
usage                     0(30)        based           structure                level 3 packed packed unaligned dcl 4-530
use_jump                               parameter       fixed bin(18,0)          dcl 4473 ref 4468 4533
used_as_subscript         0(35)        based           bit(1)                   level 3 packed packed unaligned dcl 4-1005 set ref
                                                                                  3640* 3824*
v_array                                based           bit(36)                  array dcl 1-34 set ref 1-51 1-52* 1-54 1-54
v_bound                   0(09)        based           structure                array level 2 packed packed unaligned dcl 4-383 ref
                                                                                  2606 2639 3064 3064 3112 3120 3414 3449
v_length                  6            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-844
                                                                                  ref 1443 3955 3955 4593 4600
value                                  parameter       bit(72)                  dcl 1-16 in procedure "create_constant" ref 1-13
                                                                                  1-41
value                                  parameter       fixed bin(18,0)          dcl 5002 in procedure "valid_subscript" ref 4992
                                                                                  5006 5010
value                                  parameter       fixed bin(18,0)          dcl 2419 in procedure "effectively_constant" set ref
                                                                                  2416 2435* 2448* 2449* 2449
value                     4            based           bit(72)                  level 2 in structure "constant" dcl 4-256
                                                                                  in procedure "fort_converter" set ref 1-65 1-85*
                                                                                  1334 2314 2329 2337 2435 2448 3733 3781 4706 4725
value                                  parameter       fixed bin(19,0)          dcl 4291 in procedure "create_integer_constant" ref
                                                                                  4288 4294
var                             002236 automatic       fixed bin(18,0)          dcl 4265 in procedure "create_var" set ref 4273*
                                                                                  4274 4283 4284 4285
var                       7            based           fixed bin(18,0)          level 3 in structure "sub_stack" dcl 162
                                                                                  in procedure "fort_converter" set ref 1443* 1447*
                                                                                  3333 3342 3354 3395 3423 3430* 3453*
var                       1            based           structure                level 3 in structure "dim_size_list" packed packed
                                                                                  unaligned dcl 243 in procedure "fort_converter"
                                                                                  set ref 3112 3120*
variable_extents          0(32)        based           bit(1)                   level 3 packed packed unaligned dcl 4-844 ref 3617
                                                                                  3796
variable_length           0(29)        based           bit(1)                   level 3 in structure "array_ref" packed packed
                                                                                  unaligned dcl 4-155 in procedure "fort_converter"
                                                                                  set ref 3929* 3966
variable_length           0(29)        based           bit(1)                   level 3 in structure "temporary" packed packed
                                                                                  unaligned dcl 4-1005 in procedure "fort_converter"
                                                                                  ref 3976
variable_part                   002041 automatic       fixed bin(18,0)          dcl 3670 set ref 3749* 3764* 3789 3789* 3791* 3791*
                                                                                  3796 3815 3815 3818 3823* 3832
variable_type                          constant        fixed bin(4,0)           initial dcl 5-120 ref 4277
variable_virtual_origin
                          0(26)        based           bit(1)                   level 2 packed packed unaligned dcl 4-383 set ref
                                                                                  1460 2626* 2646* 2656* 3579 3588
vector_length                   002307 automatic       fixed bin(18,0)          dcl 4545 set ref 4595* 4599* 4739* 4739 4810 4812
vector_length_temp              002310 automatic       fixed bin(18,0)          dcl 4545 set ref 4596* 4600* 4786 4788 4794* 4813
                                                                                  4815 4821* 4844
virtual_origin            1            based           fixed bin(24,0)          level 2 dcl 4-383 set ref 1460 1462 2625* 2638 2645*
                                                                                  2650 2650* 2655* 3074 3579 3592 3600
virtual_origin_base             001226 automatic       pointer                  dcl 254 set ref 324* 2935* 2956* 3045 3073 3090
virtual_origin_list                    based           structure                level 1 dcl 227 set ref 2936 2940 2952* 3151
virtual_origin_list_ptr         001230 automatic       pointer                  dcl 254 set ref 324* 2935* 2936 2939 2940 2951 2952
                                                                                  2953* 2956 3045* 3051 3052 3052 3052 3056 3073*
                                                                                  3077* 3077 3086 3087 3088 3089 3090* 3151
virtual_origin_offset           000150 automatic       fixed bin(18,0)          dcl 126 set ref 323* 324 424 2939 2940* 2950 2951*
                                                                                  2953 3136 3151 3151
vo_sharable                     001715 automatic       bit(1)                   packed unaligned dcl 3036 set ref 3058* 3063 3064*
                                                                                  3071
w                                      based           fixed bin(18,0)          array dcl 263 set ref 314 316 318 320 322 324 326
                                                                                  328 392 405 409 2769 2798 2813 2827 2838 2853 2866
                                                                                  2880 2894 2917 2935 2953 2968 2984 2998 3014 3051
                                                                                  3077 3109 3117
work_stack_offset         2            based           fixed bin(18,0)          level 2 in structure "eol_stack" dcl 204
                                                                                  in procedure "fort_converter" set ref 808 808 2678
                                                                                  2688 2708 2776* 2788
work_stack_offset               000151 automatic       fixed bin(18,0)          dcl 126 in procedure "fort_converter" set ref 340*
                                                                                  383 388 388 402 414 437 495 528 539 543 557 579
                                                                                  589 589 617 628 628 628 628 638 638 639 639 640
                                                                                  640 643 644 644 644 644 650 687 687 690 691 691
                                                                                  691 691 697 697 834 836 838 841 870 871 931 934
                                                                                  936 939 959 969 971 974 977 979 1012 1012 1012
                                                                                  1014 1014 1015 1019 1023 1026 1026 1026 1028 1029
                                                                                  1033 1036 1036 1039 1039 1040 1040 1041 1047 1049
                                                                                  1050 1051 1145 1146 1247 1251 1254 1254 1255 1258
                                                                                  1266 1266 1267 1270 1274 1274 1275 1275 1276 1280
                                                                                  1280 1281 1285 1287 1291 1298 1298 1302 1303 1304
                                                                                  1319 1319 1320 1320 1321 1332 1332 1333 1333 1334
                                                                                  1337 1340 1340 1341 1342 1346 1347 1348 1394 1431
                                                                                  1432 1459 1460 1462 1465 1469 1474 1522 1593 1594
                                                                                  1594 1594 1594 1646 1647 1647 1647 1647 1664 1664
                                                                                  1667 1667 1670 1672 1672 1675 1677 1680 1683 1684
                                                                                  1687 1719 1724 1725 1733 1740 1813 1813 1822 1825
                                                                                  1827 1827 1827 1827 1848 1848 1848 1848 1848 1855
                                                                                  1865 1885 1885 1885 1885 1890 1890 1891 1891 1892
                                                                                  1892 1906 1910 1910 1910 1910 1947 1962 1964 1969
                                                                                  1977 1988 2000 2016 2018 2023 2034 2052 2068 2084
                                                                                  2086 2091 2101 2116 2129 2150 2155 2167 2182 2301
                                                                                  2311 2317 2331 2333 2334 2339 2340 2344 2354 2358
                                                                                  2359 2382 2408* 2408 2409 2411 2504 2529 2536 2537
                                                                                  2539 2546 2547 2548 2550 2562 2562 2566 2566 2567
                                                                                  2569 2571 2579 2579 2688 2708 2712 2713 2725 2749
                                                                                  2749 2749 2749 2756 2757 2757 2758 2758 2775 2776
                                                                                  2787 2895 2901 3182 3182 3183 3186 3211 3212 3213
                                                                                  3294 3298 3300 3301 3316 3353 3354 3355 3359 3372
                                                                                  3376 3379 3384 3386 3390 3392 3395 3396 3400 3423
                                                                                  3424 3426 3430 3476 3477 3483 3484 3485 3489 3498
                                                                                  3502 3504 3510 3511 3516 3550 3551 3556 3557 3563
                                                                                  3568 3581 3582 3590 3592 3593 3596 3600 3601 3630
                                                                                  3632 3634 3638 3647 3690 3703 3714 3721 3721 3722
                                                                                  3732 3818 3819 3830 3831 3832 3833 3834 3880 3881
                                                                                  3882 3886 3908 3912 3913 3915 4221 4226 4312 4314
                                                                                  4317 4317 4318 4321 4612 4617 4622 4629 4648 4649
                                                                                  4675 4710 4729 4757 4759 4762 4767 4771 4779 4780
                                                                                  4788 4789 4794 4812 4815 4816 4821 4944 4945 4947
write_scalar_op                        constant        fixed bin(18,0)          initial dcl 5-197 ref 697
x                                      based           fixed bin(35,0)          array dcl 2-16 in procedure "create_node" set ref
                                                                                  2-24 2-25
x                                      based           fixed bin(18,0)          array dcl 263 in procedure "fort_converter" set ref
                                                                                  337 368 388 388 404 628 628 628 644 644 644 691
                                                                                  691 691 832 834 834 836 838 959 971 979 1065 1144
                                                                                  1146 1247 1251 1285 1365 1394 1432 1433 1594 1594
                                                                                  1594 1647 1647 1647 1667 1667 1672 1672 1827 1827
                                                                                  1827 1848 1848 1848 1848 1848 2204 2206 2227 2229
                                                                                  2257 2257 2272 2311 2388 2430 2445 2448 2450 2452
                                                                                  2508 2600 2678 2689 2709 2709 2749 2749 2749 2902
                                                                                  3043 3057 3311 3632 3690 3694 3714 3781 3796 3815
                                                                                  3844 3844 3863 3908 3915 3997 3999 4018 4026 4046
                                                                                  4048 4075 4126 4127 4128 4128 4128 4128 4132 4146
                                                                                  4146 4146 4229 4229 4229 4229 4252 4274 4283 4312
                                                                                  4314 4362 4367 4407 4435 4436 4437 4437 4437 4437
                                                                                  4441 4461 4510 4584 4585 4650 4651 4676 4879 4891
                                                                                  4919 4981 4982 5033 5038
x                                      based           fixed bin(35,0)          array dcl 1-35 in procedure "create_constant" set
                                                                                  ref 1-63 1-80 1-91
x                                      based           fixed bin(35,0)          array dcl 9-16 in procedure "create_node" set ref
                                                                                  9-24 9-25
xmit_at_this_level        4            based           fixed bin(18,0)          level 2 dcl 193 set ref 700* 700 1243* 4634 4848*
                                                                                  4848
xmit_scalar_op                         constant        fixed bin(18,0)          initial dcl 5-197 ref 687 697
xmit_vector_op                         constant        fixed bin(18,0)          initial dcl 5-197 ref 4846
zero                            000152 automatic       fixed bin(18,0)          dcl 126 set ref 332* 1303 1341 3550
zero_trip_branch          6            based           fixed bin(18,0)          level 2 dcl 193 set ref 1061 1063 1069 1073 1245*
                                                                                  1351* 4885

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
EOS_token                              internal static bit(9)                   initial dcl 5-156
and                                    internal static bit(9)                   initial dcl 5-156
apostrophe                             internal static bit(9)                   initial dcl 5-156
arg_desc                               based           structure                level 1 dcl 4-130
arg_desc_node                          internal static fixed bin(4,0)           initial dcl 5-87
assign                                 internal static bit(9)                   initial dcl 5-156
assign_label_op                        internal static fixed bin(18,0)          initial dcl 5-197
asterisk                               internal static bit(9)                   initial dcl 5-156
backspace_op                           internal static fixed bin(18,0)          initial dcl 5-197
bif                                    internal static fixed bin(4,0)           initial dcl 5-120
bit_units                              internal static fixed bin(3,0)           initial dcl 5-136
bits_per_char                          internal static fixed bin(9,0)           initial dcl 5-68
blank_common_name                      internal static char(8)                  initial dcl 5-79
block_data                             internal static fixed bin(9,0)           initial dcl 5-68
block_data_op                          internal static fixed bin(18,0)          initial dcl 5-197
chain                                  based           structure                level 1 dcl 8-27
char_constant_length                   automatic       fixed bin(18,0)          unsigned dcl 4-378
char_size                              automatic       fixed bin(18,0)          dcl 2667
char_string                            internal static bit(9)                   initial dcl 5-156
chars_per_dw                           internal static fixed bin(9,0)           initial dcl 5-68
chars_per_word                         internal static fixed bin(9,0)           initial dcl 5-68
closefile_op                           internal static fixed bin(18,0)          initial dcl 5-197
colon                                  internal static bit(9)                   initial dcl 5-156
comma                                  internal static bit(9)                   initial dcl 5-156
complex_const                          internal static bit(9)                   initial dcl 5-156
concat                                 internal static bit(9)                   initial dcl 5-156
convert_to_cmpx_op                     internal static fixed bin(18,0)          initial dcl 5-197
convert_to_dp_op                       internal static fixed bin(18,0)          initial dcl 5-197
convert_to_real_op                     internal static fixed bin(18,0)          initial dcl 5-197
count_type                             internal static fixed bin(4,0)           initial dcl 5-120
dec_int                                internal static bit(9)                   initial dcl 5-156
decode_string_op                       internal static fixed bin(18,0)          initial dcl 5-197
default_main_entry_point_name          internal static char(5)                  initial packed unaligned dcl 5-80
dfast_mask                             internal static bit(72)                  initial packed unaligned dcl 7-162
dimension_node                         internal static fixed bin(4,0)           initial dcl 5-87
double_const                           internal static bit(9)                   initial dcl 5-156
dp_mode                                internal static fixed bin(4,0)           initial dcl 5-106
dummy                                  internal static fixed bin(4,0)           initial dcl 5-120
edge                                   based           structure                level 1 dcl 8-33
else_if_op                             internal static fixed bin(18,0)          initial dcl 5-197
else_op                                internal static fixed bin(18,0)          initial dcl 5-197
encode_string_op                       internal static fixed bin(18,0)          initial dcl 5-197
end_label_op                           internal static fixed bin(18,0)          initial dcl 5-197
endfile_op                             internal static fixed bin(18,0)          initial dcl 5-197
endunit_op                             internal static fixed bin(18,0)          initial dcl 5-197
entry_type                             internal static fixed bin(4,0)           initial dcl 5-120
eq                                     internal static bit(9)                   initial dcl 5-156
equal_op                               internal static fixed bin(18,0)          initial dcl 5-197
equiv_op                               internal static fixed bin(18,0)          initial dcl 5-197
eqv                                    internal static bit(9)                   initial dcl 5-156
error                                  internal static fixed bin(4,0)           initial dcl 5-120
error_label_op                         internal static fixed bin(18,0)          initial dcl 5-197
expon                                  internal static bit(9)                   initial dcl 5-156
exponentiation_op                      internal static fixed bin(18,0)          initial dcl 5-197
external                               internal static fixed bin(4,0)           initial dcl 5-120
false                                  internal static bit(9)                   initial dcl 5-156
fast_mask                              internal static bit(72)                  initial packed unaligned dcl 7-168
fill_node                              internal static fixed bin(4,0)           initial dcl 5-87
first_auto_loc                         internal static fixed bin(9,0)           initial dcl 5-68
first_block_constant                   defined         fixed bin(18,0)          dcl 6-153
first_char_constant                    defined         fixed bin(18,0)          dcl 6-149
first_dw_constant                      defined         fixed bin(18,0)          dcl 6-145
first_word_constant                    defined         fixed bin(18,0)          dcl 6-141
flow_unit                              based           structure                level 1 dcl 8-46
format_op                              internal static fixed bin(18,0)          initial dcl 5-197
func_op                                internal static fixed bin(18,0)          initial dcl 5-197
function                               internal static fixed bin(9,0)           initial dcl 5-68
gap_value                              internal static fixed bin(17,0)          initial dcl 5-57
ge                                     internal static bit(9)                   initial dcl 5-156
gt                                     internal static bit(9)                   initial dcl 5-156
halfword_units                         internal static fixed bin(3,0)           initial dcl 5-136
header                                 based           structure                level 1 dcl 4-436
header_node                            internal static fixed bin(4,0)           initial dcl 5-87
ident                                  internal static bit(9)                   initial dcl 5-156
input_to                               based           structure                level 1 dcl 8-87
iostat_op                              internal static fixed bin(18,0)          initial dcl 5-197
is_arith_constant                      internal static bit(9)                   initial dcl 5-147
is_constant                            internal static bit(9)                   initial dcl 5-147
is_operand                             internal static bit(9)                   initial dcl 5-147
is_operator                            internal static bit(9)                   initial dcl 5-147
item_op                                internal static fixed bin(18,0)          initial dcl 5-197
jump_assigned_op                       internal static fixed bin(18,0)          initial dcl 5-197
jump_logical_op                        internal static fixed bin(18,0)          initial dcl 5-197
label_const                            internal static bit(9)                   initial dcl 5-156
last_assigned_mode                     internal static fixed bin(4,0)           initial dcl 5-106
last_block_constant                    defined         fixed bin(18,0)          dcl 6-154
last_char_constant                     defined         fixed bin(18,0)          dcl 6-150
last_dw_constant                       defined         fixed bin(18,0)          dcl 6-146
last_word_constant                     defined         fixed bin(18,0)          dcl 6-142
lchain                                 based           structure                level 1 dcl 8-94
le                                     internal static bit(9)                   initial dcl 5-156
left_parn                              internal static bit(9)                   initial dcl 5-156
left_shift_op                          internal static fixed bin(18,0)          initial dcl 5-197
less_op                                internal static fixed bin(18,0)          initial dcl 5-197
lhs_fld_op                             internal static fixed bin(18,0)          initial dcl 5-197
library                                based           structure                level 1 dcl 4-605
library_node                           internal static fixed bin(4,0)           initial dcl 5-87
load_preg_op                           internal static fixed bin(18,0)          initial dcl 5-197
load_xreg_op                           internal static fixed bin(18,0)          initial dcl 5-197
logical_const                          internal static bit(9)                   initial dcl 5-156
loop                                   based           structure                level 1 dcl 8-100
loop_end_op                            internal static fixed bin(18,0)          initial dcl 5-197
lt                                     internal static bit(9)                   initial dcl 5-156
machine_state                          based           structure                level 1 dcl 4-620
machine_state_node                     internal static fixed bin(4,0)           initial dcl 5-87
main_op                                internal static fixed bin(18,0)          initial dcl 5-197
main_program                           internal static fixed bin(9,0)           initial dcl 5-68
margin_op                              internal static fixed bin(18,0)          initial dcl 5-197
max_char_length                        internal static fixed bin(10,0)          initial dcl 5-77
max_error_level                        internal static fixed bin(17,0)          initial dcl 5-64
max_fixed_bin_18                       internal static fixed bin(18,0)          initial dcl 5-58
max_fixed_bin_24                       internal static fixed bin(24,0)          initial dcl 5-59
max_prec_single                        internal static fixed bin(9,0)           initial dcl 5-68
minus                                  internal static bit(9)                   initial dcl 5-156
namelist_op                            internal static fixed bin(18,0)          initial dcl 5-197
ne                                     internal static bit(9)                   initial dcl 5-156
neg_storage_add_op                     internal static fixed bin(18,0)          initial dcl 5-197
neqv                                   internal static bit(9)                   initial dcl 5-156
no_op                                  internal static fixed bin(18,0)          initial dcl 5-197
no_token                               internal static bit(9)                   initial dcl 5-156
non_executable                         internal static fixed bin(18,0)          initial dcl 5-197
not                                    internal static bit(9)                   initial dcl 5-156
not_equal_op                           internal static fixed bin(18,0)          initial dcl 5-197
not_equiv_op                           internal static fixed bin(18,0)          initial dcl 5-197
num_args                               automatic       fixed bin(17,0)          dcl 4-150
num_dims                               automatic       fixed bin(3,0)           dcl 4-431
num_of_block_constants                 defined         fixed bin(17,0)          dcl 6-152
num_of_char_constants                  defined         fixed bin(17,0)          dcl 6-148
num_of_dw_constants                    defined         fixed bin(17,0)          dcl 6-144
num_of_word_constants                  defined         fixed bin(17,0)          dcl 6-140
octal_const                            internal static bit(9)                   initial dcl 5-156
op_p                                   automatic       pointer                  dcl 2669
openfile_op                            internal static fixed bin(18,0)          initial dcl 5-197
or                                     internal static bit(9)                   initial dcl 5-156
pause_op                               internal static fixed bin(18,0)          initial dcl 5-197
plus                                   internal static bit(9)                   initial dcl 5-156
pointer                                based           structure                level 1 dcl 4-672
pointer_node                           internal static fixed bin(4,0)           initial dcl 5-87
primary                                based           structure                level 1 dcl 8-234
proc_frame_node                        internal static fixed bin(4,0)           initial dcl 5-87
range                                  based           structure                level 1 dcl 8-243
rc_a                                   internal static bit(6)                   initial packed unaligned dcl 3-6
rc_dp                                  internal static bit(6)                   initial packed unaligned dcl 3-6
rc_e                                   internal static bit(6)                   initial packed unaligned dcl 3-6
rc_is15                                internal static bit(6)                   initial packed unaligned dcl 3-6
rc_is18                                internal static bit(6)                   initial packed unaligned dcl 3-6
rc_lb                                  internal static bit(6)                   initial packed unaligned dcl 3-6
rc_lp15                                internal static bit(6)                   initial packed unaligned dcl 3-6
rc_lp18                                internal static bit(6)                   initial packed unaligned dcl 3-6
rc_nlb                                 internal static bit(6)                   initial packed unaligned dcl 3-6
rc_nlp18                               internal static bit(6)                   initial packed unaligned dcl 3-6
rc_ns                                  internal static bit(6)                   initial packed unaligned dcl 3-6
rc_nt                                  internal static bit(6)                   initial packed unaligned dcl 3-6
rc_s                                   internal static bit(6)                   initial packed unaligned dcl 3-6
rc_sr                                  internal static bit(6)                   initial packed unaligned dcl 3-6
read_array_op                          internal static fixed bin(18,0)          initial dcl 5-197
read_internal_file_op                  internal static fixed bin(18,0)          initial dcl 5-197
read_namelist_op                       internal static fixed bin(18,0)          initial dcl 5-197
read_vector_op                         internal static fixed bin(18,0)          initial dcl 5-197
real_const                             internal static bit(9)                   initial dcl 5-156
real_mode                              internal static fixed bin(4,0)           initial dcl 5-106
record_number_op                       internal static fixed bin(18,0)          initial dcl 5-197
return_op                              internal static fixed bin(18,0)          initial dcl 5-197
rewind_op                              internal static fixed bin(18,0)          initial dcl 5-197
right_parn                             internal static bit(9)                   initial dcl 5-156
right_shift_op                         internal static fixed bin(18,0)          initial dcl 5-197
sf_def_op                              internal static fixed bin(18,0)          initial dcl 5-197
slash                                  internal static bit(9)                   initial dcl 5-156
source                                 based           structure                level 1 dcl 4-693
source_node                            internal static fixed bin(4,0)           initial dcl 5-87
statement_function                     internal static fixed bin(4,0)           initial dcl 5-120
stop_op                                internal static fixed bin(18,0)          initial dcl 5-197
storage_add_one_op                     internal static fixed bin(18,0)          initial dcl 5-197
storage_add_op                         internal static fixed bin(18,0)          initial dcl 5-197
storage_sub_op                         internal static fixed bin(18,0)          initial dcl 5-197
store_zero_op                          internal static fixed bin(18,0)          initial dcl 5-197
string_length_op                       internal static fixed bin(18,0)          initial dcl 5-197
string_op                              internal static fixed bin(18,0)          initial dcl 5-197
subprogram_node                        internal static fixed bin(4,0)           initial dcl 5-87
subr_op                                internal static fixed bin(18,0)          initial dcl 5-197
subroutine                             internal static fixed bin(9,0)           initial dcl 5-68
substr_left_parn                       internal static bit(9)                   initial dcl 5-156
substr_op                              internal static fixed bin(18,0)          initial dcl 5-197
sys_info$max_seg_size                  external static fixed bin(18,0)          dcl 5-61
terminate_op                           internal static fixed bin(18,0)          initial dcl 5-197
true                                   internal static bit(9)                   initial dcl 5-156
typeless_mode                          internal static fixed bin(4,0)           initial dcl 5-106
units_per_word                         internal static fixed bin(6,0)           initial array dcl 5-142
unnamed_block_data_subprg_name         internal static char(29)                 initial packed unaligned dcl 5-82
unrecoverable_error                    internal static fixed bin(17,0)          initial dcl 5-64
word_units                             internal static fixed bin(3,0)           initial dcl 5-136
write_array_op                         internal static fixed bin(18,0)          initial dcl 5-197
write_internal_file_op                 internal static fixed bin(18,0)          initial dcl 5-197
write_namelist_op                      internal static fixed bin(18,0)          initial dcl 5-197
write_op                               internal static fixed bin(18,0)          initial dcl 5-197
write_vector_op                        internal static fixed bin(18,0)          initial dcl 5-197
xmit_array_op                          internal static fixed bin(18,0)          initial dcl 5-197

NAMES DECLARED BY EXPLICIT CONTEXT.
GOT_THE_SF_VAR                  000736 constant        label                    dcl 409 ref 402
NO_MORE_DIMS                    017604 constant        label                    dcl 4803 ref 4612 4617 4622 4629 4634 4640
NO_OPT_VECTOR                   017744 constant        label                    dcl 4854 ref 4571 4581 4803
aliasable                       020202 constant        entry                    internal dcl 4968 ref 4640
assign_l                        000156 constant        label                    array(18) dcl 1796 ref 1794
bump_work_stack_offset          007040 constant        entry                    internal dcl 2401 ref 384 501 529 540 558 583 642
                                                                                  689 809 828 839 852 872 878 899 917 933 982 984
                                                                                  986 1016 1020 1030 1034 1042 1048 1053 1075 1100
                                                                                  1148 1168 1197 1256 1268 1277 1282 1288 1290 1294
                                                                                  1305 1307 1322 1344 1349 1404 1430 1466 1468 1491
                                                                                  1592 1645 1678 1681 1685 1688 1726 1741 1752 1823
                                                                                  1856 1864 1907 1970 1980 1989 1999 2024 2043 2056
                                                                                  2067 2092 2106 2117 2128 2149 2156 2181 2318 2324
                                                                                  2330 2335 2341 2361 2538 2549 2570 2714 2726 2759
                                                                                  2768 2907 3184 3231 3303 3317 3356 3358 3373 3377
                                                                                  3380 3387 3393 3397 3399 3427 3429 3478 3486 3488
                                                                                  3499 3505 3512 3515 3552 3558 3566 3569 3583 3594
                                                                                  3597 3602 3635 3639 3648 3723 3820 3829 3835 3883
                                                                                  3885 3933 4236 4319 4772 4774 4781 4783 4790 4792
                                                                                  4817 4819 4943 4948
case                            000200 constant        label                    array(4) dcl 1949 in procedure "process_arith" ref
                                                                                  1947
case                            000000 constant        label                    array(0:109) dcl 450 in procedure "process_operator"
                                                                                  ref 438 440 447 485 495 749 1514 1559 1600 1702
compress_concat                 006232 constant        entry                    internal dcl 2186 ref 1689
compress_subscript              007353 constant        entry                    internal dcl 2515 ref 965 1995 2062 2124 2177 2305
                                                                                  3315
conversion                      011667 constant        entry                    internal dcl 3161 ref 516 1044 1904 1943 2350 2482
convert                         005076 constant        label                    dcl 1813 ref 1798 1807
count_cases                     001363 constant        entry                    internal dcl 442 ref 294
create_constant                 001124 constant        entry                    internal dcl 1-13 ref 4295
create_dim_size_var             011445 constant        entry                    internal dcl 3094 ref 2612
create_integer_constant         015601 constant        entry                    internal dcl 4288 ref 330 332 1462 1668 1673 2167
                                                                                  2301 2547 2567 3384 3390 3502 3556 3581 3751 3756
                                                                                  3756 3769 3769 3784 3808 4757 4767 4812
create_label                    016160 constant        entry                    internal dcl 4423 in procedure "optimize_if" ref
                                                                                  4404
create_label                    014735 constant        entry                    internal dcl 4117 in procedure "fort_converter" ref
                                                                                  1063 1363 4072
create_new_if                   016412 constant        entry                    internal dcl 4468 ref 4386 4408
create_node                     016241 constant        entry                    internal dcl 9-10 in procedure "optimize_if" ref
                                                                                  4434
create_node                     001006 constant        entry                    internal dcl 2-10 in procedure "fort_converter" ref
                                                                                  1-74 3912 4125 4251 4273
create_operator                 015207 constant        entry                    internal dcl 4192 ref 518 538 564 565 584 601 620
                                                                                  641 658 661 688 698 713 723 732 740 755 769 777
                                                                                  837 873 932 942 976 1045 1054 1257 1269 1289 1345
                                                                                  1350 1483 1503 1541 1550 1585 1619 1628 1637 1682
                                                                                  1686 1727 1742 1824 1863 1905 1968 2022 2090 2154
                                                                                  2353 2484 2715 2760 2788 3185 3318 3378 3479 3567
                                                                                  3595 3637 3724 3822 3911 4320
create_opt_statement            015035 constant        entry                    internal dcl 4152 ref 349 887 1006 1058 1353 1360
create_opt_subscript            014161 constant        entry                    internal dcl 3890 ref 3649 3836
create_temporary                015457 constant        entry                    internal dcl 4241 ref 528 539 838 934 977 1047 1145
                                                                                  1258 1270 1291 1346 1683 1687 1825 1906 1969 2023
                                                                                  2091 2155 2354 2488 2716 2725 3186 3212 3319 3379
                                                                                  3480 3568 3596 3638 3725 3823 4321
create_var                      015516 constant        entry                    internal dcl 4262 ref 1302 2625 3084 3123
create_virtual_origin_var       011247 constant        entry                    internal dcl 3020 ref 2645 2655
do_arith                        014127 constant        entry                    internal dcl 3870 ref 3756 3769 3772 3772 3772 3791
effective_operand               020306 constant        entry                    internal dcl 5020 ref 4227
effectively_constant            007113 constant        entry                    internal dcl 2416 ref 1962 1977 2016 2034 2084 2101
                                                                                  3298
fort_converter                  000351 constant        entry                    external dcl 20
free_dim_size_list              011230 constant        entry                    internal dcl 3008 ref 427
free_virtual_origin_list        011054 constant        entry                    internal dcl 2943 ref 424
get_char_size                   014301 constant        entry                    internal dcl 3939 ref 979 1146 1667 1672 1848 1848
                                                                                  3924
get_data_type                   006747 constant        entry                    internal dcl 2364 ref 505 532 928 1043 1793 1879
                                                                                  1893 1944 2293 2306 2481 3296 3636 3711 3821
get_dim_size_link               011166 constant        entry                    internal dcl 2995 ref 3119
get_node_type                   007316 constant        entry                    internal dcl 2491 ref 1847 1880 1894 1946 3297
get_virtual_origin_link         011006 constant        entry                    internal dcl 2929 ref 3085
initialize_subscript            007570 constant        entry                    internal dcl 2584 ref 1450
is_local                        014474 constant        entry                    internal dcl 4009 ref 1474 1522
is_star_extent                  014545 constant        entry                    internal dcl 4036 ref 1664 1664
match_index_type                015614 constant        entry                    internal dcl 4299 ref 1246
new_free_object                 011545 constant        entry                    internal dcl 3129 ref 2799 2828 2854 2881 2918 2954
                                                                                  2985 3015
no_convert                      005125 constant        label                    dcl 1827 ref 1796 1803 1809
optimize_if                     015710 constant        entry                    internal dcl 4327 ref 4086 4420 4538
optimize_vector                 016714 constant        entry                    internal dcl 4542 ref 1312
pop_block_if_stack              011145 constant        entry                    internal dcl 2979 ref 4105
pop_eol_stack                   010421 constant        entry                    internal dcl 2793 ref 1101 1170 1193 2789 3210 3230
pop_exit_stack                  010647 constant        entry                    internal dcl 2875 ref 1084 4935
pop_hold_stack                  010507 constant        entry                    internal dcl 2822 ref 4112
pop_sf_stack                    010763 constant        entry                    internal dcl 2911 ref 987 3214
pop_sub_stack                   010570 constant        entry                    internal dcl 2848 ref 1169
process_1_subscript             012203 constant        entry                    internal dcl 3273 ref 786
process_arith                   005244 constant        entry                    internal dcl 1869 ref 466 1017 1031 1278 1283 1467
                                                                                  1679 2336 2342 3357 3388 3394 3398 3428 3487 3506
                                                                                  3513 3559 3603 3884 4773 4782 4791 4818 4946
process_assign                  005062 constant        entry                    internal dcl 1783 ref 457 1021 1035 1306 1323 4949
process_builtin                 010031 constant        entry                    internal dcl 2664 ref 1158
process_eol_stack               010401 constant        entry                    internal dcl 2781 ref 1109 1117 1125 1133 1143 1206
                                                                                  2724
process_expo                    006471 constant        entry                    internal dcl 2277 ref 477
process_hold_stack_entry        014575 constant        entry                    internal dcl 4057 ref 372 890 1009
process_lhs_fld                 010255 constant        entry                    internal dcl 2738 ref 1773
process_operator                001353 constant        entry                    internal dcl 432 ref 386
process_sf                      011760 constant        entry                    internal dcl 3190 ref 1181
process_substr                  013405 constant        entry                    internal dcl 3653 ref 1692
push_block_if_stack             011075 constant        entry                    internal dcl 2965 ref 1720
push_eol_stack                  010317 constant        entry                    internal dcl 2765 ref 615 1375 1383 1419 1480 1529
                                                                                  1532 1575 1709 1755 1764
push_exit_stack                 010605 constant        entry                    internal dcl 2863 ref 568 607 1214 3226
push_hold_stack                 010445 constant        entry                    internal dcl 2810 ref 602 882 914 1071 1194 1369
push_sf_stack                   010662 constant        entry                    internal dcl 2891 ref 1391
push_sub_stack                  010522 constant        entry                    internal dcl 2835 ref 1428
rechain_arg                     012111 constant        entry                    internal dcl 3237 ref 412
search_label                    015014 constant        entry                    internal dcl 4137 ref 543 598 939 1051
strip_sub_index                 014446 constant        entry                    internal dcl 3986 ref 3788 3963 3974
subscript_arith                 007246 constant        entry                    internal dcl 2469 ref 2148 2169 2540 2551 2572 2579
unchain                         006435 constant        entry                    internal dcl 2263 ref 2257 2258 3844
unchain_cat_op                  006412 constant        entry                    internal dcl 2246 ref 2216 2239
unchain_op                      016360 constant        entry                    internal dcl 4451 ref 4419
unchain_opt_subscript           014073 constant        entry                    internal dcl 3853 ref 3847
unthread                        020164 constant        entry                    internal dcl 4952 ref 4878 4890 4898 4904
unthread_do                     017745 constant        entry                    internal dcl 4857 ref 4798
valid_subscript                 020242 constant        entry                    internal dcl 4992 ref 4710 4729
xmit_ops                        002027 constant        label                    dcl 684 ref 711

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     21636       21650   21570       21646
Length     22232   21570        12         346      45           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
fort_converter                     1948 external procedure  is an external procedure.  
create_node                             internal procedure  shares stack frame of external procedure fort_converter.  
create_constant                         internal procedure  shares stack frame of external procedure fort_converter.  
process_operator                        internal procedure  shares stack frame of external procedure fort_converter.  
process_assign                          internal procedure  shares stack frame of external procedure fort_converter.  
process_arith                           internal procedure  shares stack frame of external procedure fort_converter.  
compress_concat                         internal procedure  shares stack frame of external procedure fort_converter.  
unchain_cat_op                          internal procedure  shares stack frame of external procedure fort_converter.  
unchain                                 internal procedure  shares stack frame of external procedure fort_converter.  
process_expo                            internal procedure  shares stack frame of external procedure fort_converter.  
get_data_type                           internal procedure  shares stack frame of external procedure fort_converter.  
bump_work_stack_offset                  internal procedure  shares stack frame of external procedure fort_converter.  
effectively_constant                    internal procedure  shares stack frame of external procedure fort_converter.  
subscript_arith                         internal procedure  shares stack frame of external procedure fort_converter.  
get_node_type                           internal procedure  shares stack frame of external procedure fort_converter.  
compress_subscript                      internal procedure  shares stack frame of external procedure fort_converter.  
initialize_subscript                    internal procedure  shares stack frame of external procedure fort_converter.  
process_builtin                         internal procedure  shares stack frame of external procedure fort_converter.  
process_lhs_fld                         internal procedure  shares stack frame of external procedure fort_converter.  
push_eol_stack                          internal procedure  shares stack frame of external procedure fort_converter.  
process_eol_stack                       internal procedure  shares stack frame of external procedure fort_converter.  
pop_eol_stack                           internal procedure  shares stack frame of external procedure fort_converter.  
push_hold_stack                         internal procedure  shares stack frame of external procedure fort_converter.  
pop_hold_stack                          internal procedure  shares stack frame of external procedure fort_converter.  
push_sub_stack                          internal procedure  shares stack frame of external procedure fort_converter.  
pop_sub_stack                           internal procedure  shares stack frame of external procedure fort_converter.  
push_exit_stack                         internal procedure  shares stack frame of external procedure fort_converter.  
pop_exit_stack                          internal procedure  shares stack frame of external procedure fort_converter.  
push_sf_stack                           internal procedure  shares stack frame of external procedure fort_converter.  
pop_sf_stack                            internal procedure  shares stack frame of external procedure fort_converter.  
get_virtual_origin_link                 internal procedure  shares stack frame of external procedure fort_converter.  
free_virtual_origin_list                internal procedure  shares stack frame of external procedure fort_converter.  
push_block_if_stack                     internal procedure  shares stack frame of external procedure fort_converter.  
pop_block_if_stack                      internal procedure  shares stack frame of external procedure fort_converter.  
get_dim_size_link                       internal procedure  shares stack frame of external procedure fort_converter.  
free_dim_size_list                      internal procedure  shares stack frame of external procedure fort_converter.  
create_virtual_origin_var               internal procedure  shares stack frame of external procedure fort_converter.  
create_dim_size_var                     internal procedure  shares stack frame of external procedure fort_converter.  
new_free_object                         internal procedure  shares stack frame of external procedure fort_converter.  
conversion                              internal procedure  shares stack frame of external procedure fort_converter.  
process_sf                              internal procedure  shares stack frame of external procedure fort_converter.  
rechain_arg                             internal procedure  shares stack frame of external procedure fort_converter.  
process_1_subscript                     internal procedure  shares stack frame of external procedure fort_converter.  
process_substr                          internal procedure  shares stack frame of external procedure fort_converter.  
unchain_opt_subscript                   internal procedure  shares stack frame of external procedure fort_converter.  
do_arith                                internal procedure  shares stack frame of external procedure fort_converter.  
create_opt_subscript                    internal procedure  shares stack frame of external procedure fort_converter.  
get_char_size                           internal procedure  shares stack frame of external procedure fort_converter.  
strip_sub_index                         internal procedure  shares stack frame of external procedure fort_converter.  
is_local                                internal procedure  shares stack frame of external procedure fort_converter.  
is_star_extent                          internal procedure  shares stack frame of external procedure fort_converter.  
process_hold_stack_entry                internal procedure  shares stack frame of external procedure fort_converter.  
create_label                            internal procedure  shares stack frame of external procedure fort_converter.  
search_label                            internal procedure  shares stack frame of external procedure fort_converter.  
create_opt_statement                    internal procedure  shares stack frame of external procedure fort_converter.  
create_operator                         internal procedure  shares stack frame of external procedure fort_converter.  
create_temporary                        internal procedure  shares stack frame of external procedure fort_converter.  
create_var                              internal procedure  shares stack frame of external procedure fort_converter.  
create_integer_constant                 internal procedure  shares stack frame of external procedure fort_converter.  
match_index_type                        internal procedure  shares stack frame of external procedure fort_converter.  
optimize_if                         192 internal procedure  calls itself recursively.  
create_label                            internal procedure  shares stack frame of internal procedure optimize_if.  
create_node                             internal procedure  shares stack frame of internal procedure optimize_if.  
unchain_op                              internal procedure  shares stack frame of internal procedure optimize_if.  
create_new_if                           internal procedure  shares stack frame of internal procedure optimize_if.  
optimize_vector                         internal procedure  shares stack frame of external procedure fort_converter.  
unthread_do                             internal procedure  shares stack frame of external procedure fort_converter.  
unthread                                internal procedure  shares stack frame of external procedure fort_converter.  
aliasable                               internal procedure  shares stack frame of external procedure fort_converter.  
valid_subscript                         internal procedure  shares stack frame of external procedure fort_converter.  
effective_operand                       internal procedure  shares stack frame of external procedure fort_converter.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
fort_converter           000100 block_if_clause_count       fort_converter
                         000101 block_if_offset             fort_converter
                         000102 combination_type            fort_converter
                         000103 dim_size_offset             fort_converter
                         000104 eol_offset                  fort_converter
                         000105 exit_offset                 fort_converter
                         000106 first_free_object           fort_converter
                         000107 hold_offset                 fort_converter
                         000110 i                           fort_converter
                         000111 j                           fort_converter
                         000112 last_io_op                  fort_converter
                         000113 last_op_index               fort_converter
                         000114 next_statement_index        fort_converter
                         000115 n_ops                       fort_converter
                         000116 one                         fort_converter
                         000117 op_index                    fort_converter
                         000120 polish_offset               fort_converter
                         000121 rand_data_type              fort_converter
                         000131 rand_node_type              fort_converter
                         000141 save_polish_offset          fort_converter
                         000142 sf_num_args                 fort_converter
                         000143 sf_offset                   fort_converter
                         000144 sub_offset                  fort_converter
                         000145 temp_index                  fort_converter
                         000146 true_rand                   fort_converter
                         000147 tkx                         fort_converter
                         000150 virtual_origin_offset       fort_converter
                         000151 work_stack_offset           fort_converter
                         000152 zero                        fort_converter
                         000153 subscript_processing        fort_converter
                         000154 first_statement_function_done
                                                            fort_converter
                         000155 suspend_subscript           fort_converter
                         000156 calls_local_entries         fort_converter
                         000157 concatenates_star_extents   fort_converter
                         000160 stack                       fort_converter
                         001160 array_ptr                   fort_converter
                         001162 block_if_stack_p            fort_converter
                         001164 dim_size_list_ptr           fort_converter
                         001166 eol_stack_p                 fort_converter
                         001170 exit_stack_p                fort_converter
                         001172 hold_stack_p                fort_converter
                         001174 last_opt_statement          fort_converter
                         001176 last_quad_p                 fort_converter
                         001200 opst                        fort_converter
                         001202 r                           fort_converter
                         001204 s                           fort_converter
                         001206 sf_stack_p                  fort_converter
                         001210 sf_substitute_ptr           fort_converter
                         001212 shared_struc_ptr            fort_converter
                         001214 stm_ptr                     fort_converter
                         001216 sub_stack_p                 fort_converter
                         001220 subp_ptr                    fort_converter
                         001222 temp_node_ptr               fort_converter
                         001224 temp_ptr                    fort_converter
                         001226 virtual_origin_base         fort_converter
                         001230 virtual_origin_list_ptr     fort_converter
                         001232 polish_base                 fort_converter
                         001234 quadruple_base              fort_converter
                         001236 object_base                 fort_converter
                         001240 operand_base                fort_converter
                         001242 polish_max_len              fort_converter
                         001243 quad_max_len                fort_converter
                         001244 object_max_len              fort_converter
                         001245 operand_max_len             fort_converter
                         001246 allocate_symbol_name        fort_converter
                         001247 n_operands                  fort_converter
                         001262 offset                      create_node
                         001272 a_data_type                 create_constant
                         001274 a_value                     create_constant
                         001276 data_size                   create_constant
                         001277 hash_index                  create_constant
                         001300 mod_2_sum                   create_constant
                         001301 node_offset                 create_constant
                         001302 node_ptr                    create_constant
                         001312 op_code                     process_operator
                         001332 constant_value              process_arith
                         001342 cur_operator                compress_concat
                         001344 old_operator                compress_concat
                         001346 n                           compress_concat
                         001347 k                           compress_concat
                         001350 i                           compress_concat
                         001362 p                           unchain_cat_op
                         001400 base                        process_expo
                         001401 j                           process_expo
                         001402 k                           process_expo
                         001403 running_base                process_expo
                         001412 i                           get_data_type
                         001413 n                           get_data_type
                         001414 r                           get_data_type
                         001434 r                           effectively_constant
                         001444 data_type                   subscript_arith
                         001454 i                           get_node_type
                         001455 n                           get_node_type
                         001456 r                           get_node_type
                         001476 s                           initialize_subscript
                         001500 d                           initialize_subscript
                         001502 i                           initialize_subscript
                         001503 ndims                       initialize_subscript
                         001504 sum                         initialize_subscript
                         001505 multiplier                  initialize_subscript
                         001516 bif_index                   process_builtin
                         001517 data_type                   process_builtin
                         001520 gen_bif_index               process_builtin
                         001521 i                           process_builtin
                         001532 target                      process_lhs_fld
                         001710 elem_size                   create_virtual_origin_var
                         001711 elem_units                  create_virtual_origin_var
                         001712 dim_node                    create_virtual_origin_var
                         001714 num_dims                    create_virtual_origin_var
                         001715 vo_sharable                 create_virtual_origin_var
                         001716 this_array                  create_virtual_origin_var
                         001720 this_dim_node               create_virtual_origin_var
                         001722 this_vo_var                 create_virtual_origin_var
                         001732 d                           create_dim_size_var
                         001734 p                           create_dim_size_var
                         001736 i                           create_dim_size_var
                         001754 arg_no                      conversion
                         001772 start                       rechain_arg
                         001773 stop                        rechain_arg
                         001774 start_p                     rechain_arg
                         001776 stop_p                      rechain_arg
                         002006 constant_value              process_1_subscript
                         002007 big_offset                  process_1_subscript
                         002020 parent_ptr                  process_substr
                         002022 sympx                       process_substr
                         002024 bound_ptr                   process_substr
                         002026 big_offset                  process_substr
                         002027 bound_constant              process_substr
                         002030 parent_is_array             process_substr
                         002032 bound_index                 process_substr
                         002034 constant_part               process_substr
                         002035 parent_constant_part        process_substr
                         002036 parent_variable_part        process_substr
                         002037 true_parent_variable_part   process_substr
                         002040 substr_length               process_substr
                         002041 variable_part               process_substr
                         002042 bound_value                 process_substr
                         002044 constant_value              process_substr
                         002045 parent_constant_value       process_substr
                         002070 num_operands                create_opt_subscript
                         002072 array_parent_p              create_opt_subscript
                         002074 char_len                    create_opt_subscript
                         002104 p                           get_char_size
                         002106 o                           get_char_size
                         002116 op                          strip_sub_index
                         002120 o                           strip_sub_index
                         002130 sym                         is_local
                         002132 p                           is_local
                         002134 s                           is_local
                         002144 p                           is_star_extent
                         002154 i                           process_hold_stack_entry
                         002155 j                           process_hold_stack_entry
                         002166 j                           create_label
                         002204 i                           create_opt_statement
                         002206 opst                        create_opt_statement
                         002216 i                           create_operator
                         002217 j                           create_operator
                         002236 var                         create_var
                         002240 p                           create_var
                         002250 bit_value                   create_integer_constant
                         002260 i                           match_index_type
                         002262 i_ptr                       match_index_type
                         002264 c_ptr                       match_index_type
                         002274 do_position                 optimize_vector
                         002275 eol_position                optimize_vector
                         002276 n_dims_used                 optimize_vector
                         002277 inner_do_position           optimize_vector
                         002300 i                           optimize_vector
                         002301 j                           optimize_vector
                         002302 n_dims                      optimize_vector
                         002303 low                         optimize_vector
                         002304 high                        optimize_vector
                         002305 low_value                   optimize_vector
                         002306 high_value                  optimize_vector
                         002307 vector_length               optimize_vector
                         002310 vector_length_temp          optimize_vector
                         002312 low_p                       optimize_vector
                         002314 high_p                      optimize_vector
                         002316 r                           optimize_vector
                         002320 dim_p                       optimize_vector
                         002322 symb_p                      optimize_vector
                         002324 optimized_something         optimize_vector
                         002325 low_is_variable             optimize_vector
                         002326 high_is_variable            optimize_vector
                         002327 high_bounds_differ          optimize_vector
                         002330 low_bounds_differ           optimize_vector
                         002331 must_keep_remaining_loops   optimize_vector
                         002342 st                          unthread_do
                         002344 a                           unthread_do
                         002346 o                           unthread_do
                         002364 p1                          aliasable
                         002366 p2                          aliasable
                         002376 i                           valid_subscript
                         002406 op                          effective_operand
                         002410 p                           effective_operand
optimize_if              000100 log_op_p                    optimize_if
                         000102 inverted_if                 optimize_if
                         000103 next                        optimize_if
                         000104 next_label                  optimize_if
                         000114 j                           create_label
                         000124 offset                      create_node
                         000142 b_p                         create_new_if
                         000144 f_p                         create_new_if
                         000146 ti_p                        create_new_if
                         000150 ts_p                        create_new_if
                         000152 back                        create_new_if
                         000153 forward                     create_new_if
                         000154 last_st                     create_new_if
                         000155 next_st                     create_new_if
                         000156 parent_if                   create_new_if
                         000157 ti                          create_new_if
                         000160 ts                          create_new_if

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_g_a               r_e_as              r_ne_as             alloc_char_temp     call_ent_var_desc
call_int_this       call_int_other      return_mac          mdfx1               signal_op           shorten_stack
ext_entry           int_entry           index_bs_1_eis

NO EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
fort_data$builtin_name




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     20 000346       126 000356       158 000360       294 000365       295 000367       297 000372       298 000424
    301 000425       303 000431       304 000433       305 000435       306 000437       308 000441       309 000443
    310 000445       311 000447       313 000451       314 000452       315 000455       316 000456       317 000461
    318 000462       319 000465       320 000466       321 000471       322 000472       323 000475       324 000476
    325 000503       326 000504       327 000507       328 000510       330 000513       332 000517       334 000522
    337 000533       338 000535       339 000537       340 000540       342 000541       345 000551       349 000553
    351 000555       352 000561       354 000570       356 000571       357 000572       359 000573       364 000577
    367 000607       368 000612       369 000620       372 000622       373 000623       381 000626       383 000633
    384 000636       386 000642       388 000652       392 000666       396 000676       398 000677       401 000706
    402 000707       404 000712       405 000717       407 000723       409 000736       412 000744       414 000753
    418 000761       420 000763       422 000771       424 000777       427 001002       430 001005    2   10 001006
 2   20 001010    2   22 001015    2   23 001017    2   24 001021    2   25 001031    2   26 001036    2   29 001041
 2   30 001117    2   32 001120    1   13 001124    1   40 001126    1   41 001130    1   43 001134    1   45 001143
 1   46 001212    1   47 001214    1   49 001216    1   51 001221    1   52 001223    1   53 001224    1   54 001225
 1   57 001230    1   61 001234    1   62 001236    1   63 001240    1   65 001242    1   69 001257    1   70 001262
 1   74 001263    1   76 001271    1   78 001277    1   80 001302    1   81 001304    1   82 001311    1   83 001315
 1   84 001317    1   85 001321    1   87 001324    1   89 001330    1   91 001337    1   93 001346    1   95 001350
    432 001353       437 001354       438 001357       440 001362       442 001363       447 001365       448 001370
    450 001371       455 001417       457 001420       464 001421       466 001422       475 001430       477 001431
    483 001437       485 001440       495 001444       498 001447       499 001452       501 001456       503 001462
    505 001463       516 001467       518 001470       528 001474       529 001507       530 001513       532 001514
    538 001520       539 001524       540 001535       541 001541       543 001542       553 001551       556 001557
    557 001564       558 001567       559 001573       560 001576       561 001603       562 001612       563 001613
    564 001614       565 001621       566 001625       568 001626       579 001627       583 001634       584 001640
    585 001644       586 001646       587 001650       589 001651       598 001663       600 001675       601 001677
    602 001703       603 001704       604 001707       605 001711       607 001712       615 001713       616 001714
    617 001717       618 001722       620 001723       626 001727       628 001730       638 001747       639 001752
    640 001754       641 001756       642 001762       643 001766       644 001772       648 002010       650 002011
    658 002014       659 002020       661 002021       669 002025       671 002026       684 002027       687 002032
    688 002036       689 002040       690 002044       691 002050       695 002067       697 002070       698 002074
    700 002101       703 002110       705 002111       711 002113       713 002114       721 002120       723 002121
    730 002125       732 002126       738 002132       740 002133       747 002137       749 002140       755 002141
    761 002145       763 002146       769 002147       775 002152       777 002153       784 002157       786 002160
    806 002166       808 002174       809 002176       810 002202       824 002203       826 002205       828 002210
    829 002214       831 002215       832 002216       834 002222       836 002240       837 002243       838 002247
    839 002266       841 002272       842 002301       845 002312       846 002315       848 002325       849 002326
    850 002327       852 002336       853 002342       864 002343       866 002345       868 002347       870 002352
    871 002354       872 002356       873 002362       874 002366       875 002370       876 002373       877 002376
    878 002377       880 002403       882 002406       883 002407       884 002412       885 002416       887 002422
    888 002425       889 002430       890 002432       894 002433       899 002434       900 002440       902 002441
    914 002447       915 002450       916 002454       917 002456       918 002462       926 002463       928 002465
    929 002471       931 002474       932 002477       933 002503       934 002507       936 002522       938 002525
    939 002537       940 002553       942 002555       943 002564       954 002565       956 002567       957 002572
    959 002574       964 002617       965 002621       969 002622       971 002625       974 002642       976 002645
    977 002651       979 002670       982 002712       983 002716       984 002717       985 002723       986 002724
    987 002730       988 002731      1002 002732      1004 002734      1006 002740      1007 002742      1008 002745
   1009 002747      1012 002750      1014 002754      1015 002756      1016 002760      1017 002764      1019 002770
   1020 002773      1021 002777      1023 003000      1026 003004      1028 003006      1029 003010      1030 003012
   1031 003016      1033 003022      1034 003025      1035 003031      1036 003032      1039 003035      1040 003037
   1041 003041      1042 003043      1043 003047      1044 003053      1045 003054      1047 003060      1048 003073
   1049 003077      1050 003103      1051 003105      1053 003113      1054 003117      1056 003123      1058 003130
   1059 003132      1060 003135      1061 003137      1063 003142      1065 003152      1066 003156      1068 003161
   1069 003162      1071 003165      1072 003166      1073 003171      1074 003175      1075 003176      1076 003202
   1080 003203      1084 003224      1085 003225      1087 003226      1100 003232      1101 003236      1102 003237
   1109 003240      1117 003251      1125 003264      1133 003275      1141 003305      1143 003307      1144 003315
   1145 003322      1146 003337      1148 003354      1149 003360      1156 003361      1158 003363      1159 003364
   1166 003365      1168 003367      1169 003373      1170 003374      1171 003375      1181 003376      1191 003402
   1193 003404      1194 003405      1195 003406      1196 003411      1197 003413      1198 003417      1199 003422
   1206 003423      1211 003434      1212 003455      1214 003456      1242 003457      1243 003462      1244 003463
   1245 003465      1246 003466      1247 003467      1249 003473      1251 003505      1252 003511      1254 003515
   1255 003520      1256 003522      1257 003526      1258 003532      1259 003545      1261 003547      1263 003550
   1266 003557      1267 003562      1268 003564      1269 003570      1270 003574      1271 003611      1274 003613
   1275 003616      1276 003620      1277 003622      1278 003626      1280 003632      1281 003635      1282 003637
   1283 003643      1285 003647      1287 003657      1288 003662      1289 003666      1290 003672      1291 003676
   1294 003711      1298 003715      1302 003720      1303 003726      1304 003731      1305 003733      1306 003737
   1307 003740      1309 003744      1311 003746      1312 003750      1313 003751      1319 003755      1320 003760
   1321 003762      1322 003764      1323 003770      1324 003771      1328 003774      1330 004000      1332 004011
   1333 004014      1334 004016      1337 004025      1338 004027      1340 004030      1341 004033      1342 004035
   1344 004037      1345 004043      1346 004047      1347 004062      1348 004064      1349 004066      1350 004072
   1351 004076      1353 004101      1354 004103      1355 004106      1358 004110      1360 004112      1361 004114
   1362 004117      1363 004121      1364 004127      1365 004132      1366 004135      1367 004137      1369 004140
   1370 004141      1371 004144      1373 004146      1375 004147      1381 004150      1383 004151      1391 004152
   1392 004153      1394 004154      1404 004165      1405 004171      1406 004176      1408 004200      1410 004211
   1411 004213      1412 004216      1413 004223      1414 004232      1415 004233      1416 004234      1417 004236
   1419 004237      1428 004240      1429 004241      1430 004243      1431 004247      1432 004254      1433 004257
   1434 004266      1435 004270      1436 004271      1437 004272      1438 004273      1440 004274      1442 004301
   1443 004302      1444 004305      1446 004306      1447 004312      1450 004313      1457 004321      1459 004326
   1460 004333      1462 004343      1465 004356      1466 004361      1467 004365      1468 004371      1469 004375
   1472 004401      1474 004402      1480 004407      1481 004410      1483 004411      1489 004414      1491 004415
   1498 004421      1499 004426      1501 004443      1503 004444      1512 004450      1514 004451      1522 004452
   1529 004457      1530 004460      1532 004461      1539 004462      1541 004463      1547 004466      1548 004471
   1550 004472      1557 004475      1559 004476      1575 004477      1583 004500      1585 004501      1592 004504
   1593 004510      1594 004514      1598 004532      1600 004533      1619 004534      1626 004540      1628 004541
   1635 004545      1637 004546      1645 004551      1646 004555      1647 004561      1651 004577      1653 004600
   1664 004617      1667 004640      1668 004646      1670 004654      1672 004657      1673 004664      1675 004672
   1677 004675      1678 004677      1679 004703      1680 004707      1681 004712      1682 004716      1683 004722
   1684 004735      1685 004740      1686 004744      1687 004750      1688 004763      1689 004767      1690 004770
   1692 004771      1700 004772      1702 004773      1709 004774      1719 004775      1720 005001      1721 005002
   1722 005004      1724 005005      1725 005007      1726 005011      1727 005015      1729 005021      1731 005024
   1733 005025      1740 005027      1741 005031      1742 005035      1743 005041      1744 005044      1746 005045
   1752 005047      1753 005053      1755 005054      1762 005055      1764 005056      1771 005057      1773 005060
   1779 005061      1783 005062      1793 005063      1794 005067      1796 005071      1798 005072      1803 005073
   1807 005074      1809 005075      1813 005076      1822 005101      1823 005104      1824 005110      1825 005114
   1827 005125      1845 005144      1847 005147      1848 005153      1855 005215      1856 005222      1857 005226
   1863 005227      1864 005233      1865 005237      1866 005243      1869 005244      1879 005246      1880 005252
   1885 005256      1890 005273      1891 005275      1892 005277      1893 005301      1894 005305      1902 005311
   1904 005315      1905 005316      1906 005322      1907 005340      1908 005344      1910 005345      1937 005402
   1939 005407      1942 005414      1943 005416      1944 005417      1946 005423      1947 005427      1949 005432
   1960 005435      1962 005442      1964 005460      1965 005464      1966 005466      1968 005467      1969 005473
   1970 005511      1971 005515      1977 005516      1979 005527      1980 005532      1981 005536      1986 005537
   1988 005542      1989 005547      1990 005553      1995 005554      1999 005555      2000 005561      2001 005563
   2003 005564      2014 005567      2016 005574      2018 005612      2019 005616      2020 005620      2022 005621
   2023 005625      2024 005643      2025 005647      2034 005650      2036 005661      2039 005670      2040 005673
   2043 005677      2044 005703      2050 005704      2052 005707      2053 005714      2055 005722      2056 005724
   2057 005730      2062 005731      2067 005732      2068 005736      2069 005740      2071 005741      2082 005744
   2084 005751      2086 005767      2087 005773      2088 005775      2090 005776      2091 006002      2092 006020
   2093 006024      2101 006025      2103 006036      2104 006042      2106 006047      2107 006053      2112 006054
   2114 006057      2115 006061      2116 006062      2117 006067      2118 006073      2124 006074      2128 006075
   2129 006101      2130 006103      2132 006104      2146 006107      2148 006114      2149 006126      2150 006132
   2151 006134      2154 006135      2155 006141      2156 006157      2157 006163      2165 006164      2167 006167
   2169 006204      2170 006217      2171 006221      2177 006222      2181 006223      2182 006227      2183 006231
   2186 006232      2197 006233      2204 006236      2206 006243      2207 006247      2209 006253      2210 006264
   2211 006267      2212 006271      2213 006301      2214 006306      2215 006310      2216 006315      2226 006317
   2227 006323      2229 006331      2230 006335      2232 006341      2233 006345      2234 006353      2235 006361
   2236 006371      2237 006400      2238 006402      2239 006407      2243 006411      2246 006412      2256 006414
   2257 006417      2258 006432      2259 006434      2263 006435      2270 006437      2271 006445      2272 006452
   2273 006461      2275 006464      2277 006471      2293 006473      2294 006477      2296 006507      2298 006514
   2299 006516      2301 006521      2303 006536      2304 006540      2305 006541      2306 006542      2309 006546
   2311 006551      2312 006555      2314 006561      2315 006563      2317 006565      2318 006570      2319 006574
   2322 006575      2324 006577      2325 006603      2327 006604      2329 006605      2330 006612      2331 006616
   2332 006622      2333 006631      2334 006634      2335 006636      2336 006642      2337 006646      2339 006654
   2340 006657      2341 006661      2342 006665      2344 006671      2345 006674      2346 006676      2350 006677
   2353 006703      2354 006707      2356 006725      2358 006736      2359 006741      2361 006742      2362 006746
   2364 006747      2381 006751      2382 006761      2383 006770      2385 006775      2388 007001      2389 007003
   2391 007010      2392 007012      2395 007024      2397 007032      2398 007037      2401 007040      2408 007042
   2409 007044      2411 007062      2413 007112      2416 007113      2430 007115      2431 007121      2433 007127
   2435 007132      2436 007134      2439 007137      2442 007143      2443 007146      2445 007154      2448 007165
   2449 007167      2450 007171      2452 007176      2453 007203      2454 007205      2456 007211      2457 007215
   2458 007220      2459 007223      2460 007225      2462 007226      2463 007232      2464 007237      2466 007243
   2469 007246      2481 007250      2482 007256      2484 007263      2485 007274      2487 007303      2488 007310
   2491 007316      2503 007320      2504 007327      2505 007336      2508 007342      2509 007344      2511 007350
   2512 007352      2515 007353      2529 007354      2534 007367      2536 007371      2537 007374      2538 007376
   2539 007402      2540 007406      2541 007421      2546 007422      2547 007425      2548 007437      2549 007442
   2550 007446      2551 007452      2556 007465      2562 007470      2564 007476      2566 007500      2567 007505
   2569 007517      2570 007522      2571 007526      2572 007532      2574 007545      2579 007547      2581 007567
   2584 007570      2599 007572      2600 007575      2601 007603      2603 007607      2605 007612      2606 007627
   2609 007646      2612 007665      2613 007700      2614 007702      2617 007704      2619 007707      2625 007713
   2626 007720      2627 007722      2635 007723      2636 007724      2638 007730      2639 007744      2641 007752
   2642 007761      2643 007764      2645 007765      2646 007772      2648 007774      2650 007776      2655 010017
   2656 010024      2659 010026      2662 010030      2664 010031      2678 010032      2682 010041      2684 010047
   2688 010050      2689 010061      2690 010072      2694 010074      2695 010076      2697 010105      2701 010114
   2702 010123      2703 010132      2704 010134      2708 010137      2709 010151      2712 010165      2713 010171
   2714 010175      2715 010201      2716 010205      2718 010216      2724 010220      2725 010226      2726 010242
   2731 010246      2734 010254      2738 010255      2749 010256      2756 010275      2757 010277      2758 010301
   2759 010303      2760 010307      2761 010313      2762 010316      2765 010317      2768 010320      2769 010324
   2770 010327      2771 010331      2773 010360      2774 010362      2775 010365      2776 010371      2777 010374
   2778 010400      2781 010401      2787 010403      2788 010407      2789 010417      2790 010420      2793 010421
   2796 010422      2797 010424      2798 010430      2799 010432      2800 010433      2802 010437      2803 010444
   2810 010445      2813 010446      2814 010451      2815 010453      2817 010501      2818 010503      2819 010506
   2822 010507      2825 010510      2826 010512      2827 010516      2828 010520      2829 010521      2835 010522
   2838 010523      2839 010526      2840 010530      2842 010557      2843 010561      2844 010564      2845 010567
   2848 010570      2850 010571      2851 010574      2852 010576      2853 010601      2854 010603      2855 010604
   2863 010605      2866 010606      2867 010611      2868 010613      2870 010641      2871 010643      2872 010646
   2875 010647      2878 010650      2879 010652      2880 010656      2881 010660      2882 010661      2891 010662
   2894 010663      2895 010666      2896 010672      2897 010675      2899 010721      2900 010723      2901 010732
   2902 010736      2903 010740      2904 010742      2905 010744      2906 010751      2907 010755      2908 010762
   2911 010763      2914 010764      2915 010766      2916 010771      2917 011001      2918 011004      2919 011005
   2929 011006      2935 011007      2936 011014      2937 011016      2939 011046      2940 011050      2941 011053
   2943 011054      2950 011055      2951 011060      2952 011062      2953 011066      2954 011070      2955 011071
   2956 011072      2957 011074      2965 011075      2968 011076      2969 011101      2970 011104      2972 011132
   2973 011134      2974 011137      2975 011144      2979 011145      2982 011146      2983 011150      2984 011161
   2985 011164      2986 011165      2995 011166      2998 011167      2999 011172      3000 011174      3002 011222
   3003 011224      3005 011227      3008 011230      3011 011231      3012 011234      3013 011236      3014 011242
   3015 011244      3016 011245      3018 011246      3020 011247      3041 011251      3042 011257      3043 011262
   3044 011270      3045 011274      3051 011276      3052 011304      3056 011316      3057 011320      3058 011326
   3063 011346      3064 011361      3069 011403      3071 011405      3073 011407      3074 011411      3077 011416
   3078 011421      3084 011422      3085 011424      3086 011425      3087 011430      3088 011434      3089 011436
   3090 011440      3091 011442      3094 011445      3106 011447      3107 011452      3109 011454      3112 011464
   3117 011512      3119 011516      3120 011517      3121 011526      3122 011533      3123 011535      3125 011542
   3129 011545      3136 011546      3139 011575      3141 011602      3143 011613      3145 011621      3147 011627
   3149 011635      3151 011643      3153 011651      3155 011661      3158 011666      3161 011667      3172 011670
   3174 011674      3177 011703      3178 011706      3180 011714      3182 011715      3183 011723      3184 011731
   3185 011735      3186 011741      3187 011757      3190 011760      3204 011761      3206 011771      3208 012012
   3210 012032      3211 012033      3212 012037      3213 012055      3214 012061      3215 012062      3226 012063
   3227 012064      3228 012067      3229 012072      3230 012074      3231 012075      3232 012101      3234 012110
   3237 012111      3254 012113      3255 012122      3256 012124      3258 012126      3259 012130      3260 012133
   3261 012140      3263 012152      3264 012157      3265 012162      3266 012165      3267 012170      3268 012172
   3269 012174      3270 012202      3273 012203      3294 012204      3296 012207      3297 012213      3298 012217
   3300 012235      3301 012241      3303 012243      3311 012247      3314 012260      3315 012262      3316 012263
   3317 012266      3318 012272      3319 012276      3333 012311      3339 012314      3341 012316      3342 012321
   3343 012323      3344 012324      3350 012325      3352 012327      3353 012332      3354 012335      3355 012337
   3356 012341      3357 012345      3358 012351      3359 012355      3360 012361      3372 012362      3373 012365
   3374 012371      3376 012375      3377 012400      3378 012404      3379 012410      3380 012423      3381 012427
   3382 012430      3384 012432      3386 012444      3387 012447      3388 012453      3390 012457      3392 012473
   3393 012476      3394 012502      3395 012506      3396 012512      3397 012514      3398 012520      3399 012524
   3400 012530      3401 012534      3402 012536      3409 012537      3414 012542      3423 012560      3424 012563
   3426 012567      3427 012571      3428 012575      3429 012601      3430 012605      3433 012611      3440 012612
   3441 012615      3447 012620      3449 012623      3453 012641      3463 012645      3464 012647      3472 012651
   3474 012654      3476 012656      3477 012661      3478 012663      3479 012667      3480 012673      3481 012706
   3483 012707      3484 012711      3485 012713      3486 012715      3487 012721      3488 012725      3489 012731
   3491 012735      3498 012736      3499 012741      3500 012745      3502 012751      3504 012763      3505 012766
   3506 012772      3508 012776      3510 013001      3511 013003      3512 013005      3513 013011      3515 013015
   3516 013021      3522 013025      3523 013030      3524 013031      3525 013032      3526 013033      3533 013037
   3550 013043      3551 013046      3552 013050      3554 013054      3556 013057      3557 013071      3558 013074
   3559 013100      3560 013104      3563 013106      3566 013117      3567 013123      3568 013127      3569 013142
   3572 013146      3573 013150      3579 013151      3581 013160      3582 013173      3583 013177      3588 013203
   3590 013210      3592 013214      3593 013216      3594 013220      3595 013224      3596 013230      3597 013243
   3598 013247      3600 013250      3601 013252      3602 013254      3603 013260      3616 013264      3617 013265
   3630 013316      3632 013323      3634 013327      3635 013331      3636 013335      3637 013341      3638 013345
   3639 013356      3640 013362      3647 013364      3648 013367      3649 013373      3650 013377      3651 013404
   3653 013405      3690 013406      3691 013412      3693 013416      3694 013420      3695 013423      3696 013427
   3698 013430      3699 013431      3700 013432      3703 013433      3711 013460      3713 013464      3714 013471
   3715 013477      3720 013504      3721 013507      3722 013513      3723 013515      3724 013521      3725 013525
   3726 013540      3731 013541      3732 013552      3733 013555      3737 013563      3742 013565      3748 013570
   3749 013576      3751 013577      3756 013614      3757 013622      3763 013623      3764 013625      3769 013627
   3772 013643      3778 013647      3780 013651      3781 013656      3782 013661      3784 013663      3786 013673
   3788 013675      3789 013677      3791 013704      3796 013706      3802 013746      3808 013747      3815 013753
   3818 013763      3819 013766      3820 013770      3821 013774      3822 014000      3823 014004      3824 014010
   3829 014012      3830 014016      3831 014022      3832 014024      3833 014026      3834 014030      3835 014032
   3836 014036      3837 014042      3842 014047      3844 014051      3847 014064      3851 014072      3853 014073
   3861 014075      3862 014103      3863 014110      3864 014117      3866 014122      3870 014127      3880 014131
   3881 014134      3882 014136      3883 014140      3884 014144      3885 014150      3886 014154      3890 014161
   3904 014163      3906 014173      3908 014175      3910 014202      3911 014206      3912 014210      3913 014225
   3915 014231      3916 014234      3917 014236      3918 014242      3919 014244      3920 014251      3922 014253
   3924 014260      3925 014262      3928 014270      3929 014272      3933 014274      3935 014300      3939 014301
   3948 014303      3950 014306      3953 014320      3955 014322      3957 014330      3960 014336      3962 014340
   3963 014343      3966 014370      3968 014376      3971 014402      3973 014404      3974 014407      3976 014432
   3978 014440      3981 014444      3986 014446      3995 014450      3997 014452      3999 014456      4000 014463
   4004 014471      4009 014474      4018 014476      4020 014501      4025 014506      4026 014514      4027 014516
   4029 014536      4031 014542      4036 014545      4046 014547      4048 014552      4051 014561      4053 014573
   4057 014575      4065 014576      4070 014610      4072 014614      4074 014624      4075 014627      4081 014632
   4086 014641      4091 014657      4093 014667      4095 014677      4100 014702      4102 014704      4103 014715
   4104 014723      4105 014725      4106 014726      4111 014727      4112 014732      4113 014733      4114 014734
   4117 014735      4125 014737      4126 014743      4127 014752      4128 014757      4130 014767      4132 015000
   4133 015007      4134 015012      4137 015014      4146 015016      4149 015034      4152 015035      4162 015037
   4163 015042      4164 015044      4166 015104      4167 015107      4168 015112      4170 015122      4171 015125
   4173 015132      4175 015143      4177 015146      4178 015150      4179 015152      4180 015157      4181 015161
   4182 015165      4183 015171      4184 015173      4185 015176      4187 015201      4188 015203      4189 015204
   4192 015207      4206 015211      4207 015214      4208 015216      4210 015245      4211 015251      4214 015311
   4215 015314      4216 015326      4217 015330      4219 015337      4221 015346      4222 015352      4223 015357
   4225 015361      4226 015371      4227 015401      4229 015420      4234 015443      4236 015445      4237 015452
   4238 015454      4241 015457      4251 015461      4252 015465      4253 015470      4254 015473      4255 015475
   4256 015501      4257 015503      4258 015511      4259 015513      4262 015516      4272 015520      4273 015521
   4274 015530      4275 015533      4276 015537      4277 015545      4278 015551      4283 015565      4284 015574
   4285 015576      4288 015601      4294 015603      4295 015606      4299 015614      4312 015615      4313 015621
   4314 015627      4315 015634      4317 015646      4318 015652      4319 015656      4320 015662      4321 015666
   4323 015704      4324 015706      4327 015707      4356 015715      4358 015727      4362 015731      4367 015740
   4371 015744      4373 015751      4374 015754      4375 015756      4383 015757      4386 016005      4388 016027
   4389 016035      4394 016036      4400 016046      4402 016061      4404 016065      4406 016077      4407 016104
   4408 016110      4409 016132      4410 016140      4414 016141      4419 016142      4420 016144      4421 016157
   4423 016160      4434 016162      4435 016166      4436 016176      4437 016203      4439 016213      4441 016224
   4442 016234      4443 016237    9   10 016241    9   20 016243    9   22 016251    9   23 016253    9   24 016255
 9   25 016265    9   26 016272    9   29 016275    9   30 016353    9   32 016354      4451 016360      4459 016362
   4460 016371      4461 016377      4462 016406      4463 016411      4468 016412      4484 016414      4485 016417
   4486 016422      4487 016424      4488 016430      4489 016432      4490 016434      4493 016473      4494 016477
   4495 016512      4496 016520      4497 016525      4501 016530      4502 016541      4503 016547      4504 016554
   4508 016561      4509 016563      4510 016567      4511 016572      4513 016606      4514 016612      4515 016614
   4516 016617      4517 016621      4518 016625      4519 016630      4520 016633      4524 016637      4525 016641
   4526 016645      4527 016647      4528 016651      4529 016654      4530 016656      4531 016660      4533 016663
   4534 016670      4535 016674      4536 016677      4537 016701      4538 016703      4539 016713      4542 016714
   4566 016715      4571 016720      4576 016724      4577 016730      4581 016736      4584 016741      4585 016745
   4587 016753      4593 016754      4595 016760      4596 016764      4597 016765      4599 016766      4600 016770
   4603 016772      4607 016773      4608 016774      4612 017000      4617 017003      4622 017006      4629 017020
   4634 017023      4639 017034      4640 017045      4642 017075      4648 017077      4649 017102      4650 017104
   4651 017107      4655 017111      4662 017113      4664 017117      4665 017122      4668 017133      4669 017137
   4670 017141      4672 017145      4673 017152      4674 017156      4675 017160      4676 017163      4677 017165
   4696 017203      4697 017204      4699 017210      4700 017212      4701 017213      4703 017224      4705 017225
   4706 017226      4707 017231      4709 017245      4710 017247      4715 017300      4716 017301      4718 017305
   4719 017307      4720 017310      4722 017321      4724 017322      4725 017323      4726 017326      4728 017342
   4729 017344      4734 017375      4739 017403      4754 017417      4756 017421      4757 017422      4758 017435
   4759 017436      4760 017441      4762 017446      4765 017454      4767 017460      4768 017473      4771 017476
   4772 017501      4773 017505      4774 017511      4777 017515      4779 017521      4780 017524      4781 017526
   4782 017532      4783 017536      4786 017542      4788 017544      4789 017546      4790 017550      4791 017554
   4792 017560      4794 017564      4796 017567      4797 017570      4798 017601      4799 017602      4803 017604
   4810 017606      4812 017611      4813 017623      4815 017625      4816 017627      4817 017631      4818 017635
   4819 017641      4821 017645      4828 017650      4838 017652      4840 017664      4841 017670      4842 017677
   4843 017705      4844 017707      4845 017713      4846 017714      4847 017721      4848 017722      4851 017731
   4852 017736      4854 017744      4857 017745      4872 017746      4877 017752      4878 017754      4879 017756
   4880 017762      4883 017776      4885 020002      4890 020005      4891 020007      4892 020017      4894 020021
   4898 020024      4900 020026      4904 020032      4905 020034      4906 020040      4907 020044      4908 020047
   4910 020052      4916 020055      4917 020060      4918 020064      4919 020070      4920 020075      4922 020101
   4923 020105      4924 020107      4925 020113      4926 020115      4928 020116      4930 020123      4932 020127
   4933 020133      4935 020135      4943 020136      4944 020142      4945 020145      4946 020147      4947 020153
   4948 020156      4949 020162      4950 020163      4952 020164      4960 020166      4961 020174      4962 020201
   4968 020202      4979 020204      4981 020212      4982 020214      4983 020217      4985 020225      4987 020232
   4989 020237      4992 020242      5004 020244      5006 020246      5010 020266      5014 020303      5020 020306
   5030 020310      5031 020312      5033 020313      5034 020315      5037 020324      5038 020327      5040 020331
   5044 020345


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
