	COMPILATION LISTING OF SEGMENT basic_matrix_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 09/11/84  1244.5 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 /* format: style2 */
       11 
       12 basic_matrix_:
       13      proc (bo_stack_pt);
       14 
       15 /* modified 5/77 by Melanie Weaver  to increase internal precision */
       16 
       17 	dcl     (bo_stack_pt, bo_pt, sink_pt, source_pt, p1, p2, p3)
       18 				 ptr,
       19 	        copy		 bit (1) aligned,
       20 	        t			 float bin (63),
       21 	        accuracy		 float bin (63) static,
       22 	        (i, j, k, m, n, p, row_max, col_max)
       23 				 fixed bin;
       24 
       25 	dcl     (abs, addr, hbound, max, min)
       26 				 builtin;
       27 
       28 	dcl     basic_matrix_double_	 entry (ptr);
       29 
       30 	dcl     string_area		 area (65536) based (string_segment);
       31 
       32 	dcl     C			 (0:row_max, 0:col_max) float bin based,
       33 	        C_transpose		 (0:col_max, 0:row_max) float bin based;
       34 
       35 	dcl     vector_m		 (0:m) float bin based,
       36 	        vector_n		 (0:n) float bin based,
       37 	        vector_p		 (0:p) float bin based,
       38 	        matrix_mn		 (0:m, 0:n) float bin based,
       39 	        matrix_mp		 (0:m, 0:p) float bin based,
       40 	        matrix_pn		 (0:p, 0:n) float bin based;
       41 
  1     1 dcl	1 basic_operators_frame	aligned based(bo_pt),
  1     2 	2 pr(0:7)			ptr,
  1     3 	2 prev_sp			ptr,
  1     4 	2 next_sp			ptr,
  1     5 	2 return_ptr		ptr,
  1     6 	2 entry_ptr		ptr,
  1     7 	2 operator_and_lp_ptr	ptr,
  1     8 	2 arglist_ptr		ptr,
  1     9 	2 reserved		bit(72),
  1    10 	2 on_unit_relp(2)		bit(18) unaligned,
  1    11 	2 translator_id		bit(18) unaligned,
  1    12 	2 operator_return_offset	bit(18) unaligned,
  1    13 	2 regs,
  1    14 	  3 xr(0:7)		bit(18) unaligned,
  1    15 	  3 (a_reg,q_reg)		fixed bin(35),
  1    16 	  3 rest_of_regs(2)		bit(36) aligned,
  1    17 	2 print_using_pt		ptr,		/* N.B. this holds return loc, pos in struc must be the same
  1    18*						   as for ep basic as debuggers depend on this */
  1    19 	2 abort_label		label,
  1    20 	2 conversion_label		label,
  1    21 	2 size_label		label,
  1    22 	2 on_units(2),
  1    23 	  3 name			ptr,
  1    24 	  3 body			ptr,
  1    25 	  3 size			fixed bin,
  1    26 	  3 next			fixed bin,
  1    27 	2 program_header		ptr,
  1    28 	2 text_base_ptr		ptr,
  1    29 	2 string_segment		ptr,
  1    30 	2 fcb_pt			ptr,
  1    31 	2 arglist1(2)		ptr,
  1    32 	2 runtime_arglist(2)	ptr,
  1    33 	2 cpu_start		fixed bin(71),
  1    34 	2 determinant		float bin(63),
  1    35 	2 fcb(0:16)		ptr unaligned,
  1    36 	2 precision_lng 		fixed bin(17) unaligned,
  1    37 	2 file_number		fixed bin(17) unaligned,
  1    38 	2 (error_number,pdl)	fixed bin,
  1    39 	2 program_header_offset	bit(18) aligned,
  1    40 	2 numeric_data		unaligned,
  1    41 	  3 (finish,start)		fixed bin(17),
  1    42 	2 string_data		unaligned,
  1    43 	  3 (finish,start)		fixed bin(17),
  1    44 	2 random			fixed bin,
  1    45 	2 first_frame		bit(18),
  1    46 	2 last_frame		bit(18),
  1    47 	2 next_frame		bit(18),
  1    48 	2 number_read		fixed bin,
  1    49 	2 (pu_pos,pu_length)	fixed bin,
  1    50 	2 definitions		ptr unal,
  1    51 	2 fn_temp1		fixed bin,
  1    52 	2 fn_temp2		fixed bin,
  1    53 	2 entryname		ptr unal,
  1    54 	2 flags			unaligned,
  1    55 	  3 non_basic_caller	bit(1),
  1    56 	  3 main_program		bit(1),
  1    57 	  3 quits_disabled		bit(1),
  1    58 	  3 had_quit		bit(1),
  1    59 	  3 ignore_handler		bit(1),
  1    60 	  3 filler		bit(13),
  1    61 	2 number_length		fixed bin(17) unaligned,
  1    62 	2 string_value		bit(36),
  1    63 	2 temporaries(3)		aligned,
  1    64 	  3 temp			float bin,
  1    65 	  3 tpad			bit(36),
  1    66 	2 arg(1)			ptr;
  1    67 
  1    68 dcl	1 d_basic_operators_frame	aligned based(bo_pt),
  1    69 	2 x_pr(0:7)			ptr,
  1    70 	2 x_prev_sp			ptr,
  1    71 	2 x_next_sp			ptr,
  1    72 	2 x_return_ptr		ptr,
  1    73 	2 x_entry_ptr		ptr,
  1    74 	2 x_operator_and_lp_ptr	ptr,
  1    75 	2 x_arglist_ptr		ptr,
  1    76 	2 x_reserved		bit(72),
  1    77 	2 x_on_unit_relp(2)		bit(18) unaligned,
  1    78 	2 x_translator_id		bit(18) unaligned,
  1    79 	2 x_operator_return_offset	bit(18) unaligned,
  1    80 	2 x_regs,
  1    81 	  3 x_xr(0:7)		bit(18) unaligned,
  1    82 	  3 (x_a_reg,x_q_reg)	fixed bin,
  1    83 	  3 x_rest_of_regs(2)		bit(36) aligned,
  1    84 	2 x_print_using_pt		ptr,
  1    85 	2 x_abort_label		label,
  1    86 	2 x_conversion_label		label,
  1    87 	2 x_size_label		label,
  1    88 	2 x_on_units(2),
  1    89 	  3 x_name			ptr,
  1    90 	  3 x_body			ptr,
  1    91 	  3 x_size			fixed bin,
  1    92 	  3 x_next			fixed bin,
  1    93 	2 x_program_header		ptr,
  1    94 	2 x_text_base_ptr		ptr,
  1    95 	2 x_string_segment		ptr,
  1    96 	2 x_fcb_pt			ptr,
  1    97 	2 x_arglist1(2)		ptr,
  1    98 	2 x_runtime_arglist(2)	ptr,
  1    99 	2 x_cpu_start		fixed bin(71),
  1   100 	2 x_determinant		float bin(63),
  1   101 	2 x_fcb(0:16)		ptr unaligned,
  1   102 	2 x_precision_lng 		fixed bin(17) unaligned,
  1   103 	2 x_file_number		fixed bin(17) unaligned,
  1   104 	2 x_error_number		fixed bin,
  1   105 	2 x_pdl			fixed bin,
  1   106 	2 x_program_header_offset	bit(18) aligned,
  1   107 	2 x_numeric_data		unaligned,
  1   108 	  3 (x_finish,x_start)	fixed bin(17),
  1   109 	2 x_string_data		unaligned,
  1   110 	  3 (x_finish,x_start)	fixed bin(17),
  1   111 	2 x_random			fixed bin,
  1   112 	2 x_first_frame		bit(18),
  1   113 	2 x_last_frame		bit(18),
  1   114 	2 x_next_frame		bit(18),
  1   115 	2 x_number_read		fixed bin,
  1   116 	2 (x_pu_pos,x_pu_length)	fixed bin,
  1   117 	2 x_definitions		ptr unal,
  1   118 	2 x_fn_temp1		fixed bin,
  1   119 	2 x_fn_temp2		fixed bin,
  1   120 	2 x_entryname		ptr unal,
  1   121 	2 x_flags			unaligned,
  1   122 	  3 x_non_basic_caller	bit(1),
  1   123 	  3 x_main_program		bit(1),
  1   124 	  3 x_quits_disabled		bit(1),
  1   125 	  3 x_had_quit		bit(1),
  1   126 	  3 x_filler		bit(14),
  1   127 	2 x_number_length		fixed bin(17) unaligned,
  1   128 	2 x_string_value		bit(36),
  1   129 	2 d_temp(3)		float bin(63),
  1   130 	2 x_arg(1)			ptr;
       42 
  2     1 dcl	1 array_dope		aligned based,
  2     2 	2 data			ptr,
  2     3 	2 original_bounds(2)	fixed bin,
  2     4 	2 current_bounds(2)		fixed bin;
  2     5 
  2     6 dcl	1 scalar_symbol		aligned based,
  2     7 	2 name			char(2) unaligned,
  2     8 	2 parameter		bit(1) unaligned,
  2     9 	2 location		bit(17) unaligned;
  2    10 
  2    11 dcl	1 array_symbol		aligned based,
  2    12 	2 name			char(1) unaligned,
  2    13 	2 skip			bit(9) unaligned,
  2    14 	2 parameter		bit(1) unaligned,
  2    15 	2 location		bit(17) unaligned,
  2    16 	2 offset			fixed bin,
  2    17 	2 bounds(2)		fixed bin(17) unaligned;
       43 
       44 
       45 	bo_pt = bo_stack_pt;
       46 	if precision_lng ^= 1
       47 	then do;
       48 		call basic_matrix_double_ (bo_stack_pt);
       49 		return;
       50 	     end;
       51 	goto switch (q_reg);
       52 
       53 /* inverse */
       54 
       55 switch (1):
       56 	row_max = pr (2) -> current_bounds (1) - 1;
       57 	if row_max <= 0
       58 	then goto array_error;
       59 
       60 	begin;
       61 
       62 	     dcl	   space		      (row_max * row_max),
       63 		   LU		      (row_max, row_max) float bin (63) aligned based (addr (space));
       64 
       65 	     dcl	   P		      (100) fixed bin,
       66 		   (B, X, R, DX, scales)  dim (100) float bin (63),
       67 		   (i, j, e, k, pividx)   fixed bin,
       68 		   (ajj, norm_row, biggest, size, multiplier, pivot)
       69 				      float bin (63);
       70 
       71 	     dcl	   (
       72 		   scale_factor	      init (1.0e6),
       73 		   maxval		      init (1.0e6),
       74 		   minval		      init (1.0e-6)
       75 		   )		      float bin static;
       76 
       77 	     dcl	   (ap, ainvp)	      ptr;
       78 
       79 	     dcl	   A		      (0:row_max, 0:row_max) float bin based (ap),
       80 		   A_inverse	      (0:row_max, 0:row_max) float bin based (ainvp);
       81 
       82 	     if row_max > hbound (P, 1)
       83 	     then goto array_error;
       84 
       85 	     ap = pr (1) -> array_dope.data;
       86 
       87 	     if pr (1) ^= pr (2)
       88 	     then ainvp = pr (2) -> array_dope.data;
       89 	     else allocate A_inverse in (string_area);
       90 
       91 /* Initialize LU decomposition */
       92 
       93 	     do i = 1 to row_max;
       94 		P (i) = i;
       95 		norm_row = 0.0e0;
       96 
       97 		do j = 1 to row_max;
       98 		     LU (i, j) = A (i, j);
       99 		     norm_row = max (norm_row, abs (LU (i, j)));
      100 		end;
      101 
      102 		if norm_row = 0.0e0
      103 		then goto singular;
      104 
      105 		scales (i) = 1.0 / norm_row;
      106 	     end;
      107 
      108 /* Perform Gaussian elimination with partial pivoting and scaling */
      109 
      110 	     determinant = 1.0e0;
      111 
      112 	     do k = 1 to row_max - 1;
      113 		biggest = 0.0e0;
      114 
      115 		do i = k to row_max;
      116 		     size = abs (LU (P (i), k)) * scales (P (i));
      117 
      118 		     if size > biggest
      119 		     then do;
      120 			     biggest = size;
      121 			     pividx = i;
      122 			end;
      123 		end;
      124 
      125 		if biggest = 0.0e0
      126 		then goto singular;
      127 
      128 		if pividx ^= k
      129 		then do;
      130 
      131 /* Change sign of determinant and interchange
      132*		        permutation elements */
      133 
      134 			determinant = -determinant;
      135 
      136 			j = P (k);
      137 			P (k) = P (pividx);
      138 			P (pividx) = j;
      139 		     end;
      140 
      141 		pivot = LU (P (k), k);
      142 
      143 		do i = k + 1 to row_max;
      144 		     LU (P (i), k), multiplier = LU (P (i), k) / pivot;
      145 
      146 		     if multiplier ^= 0.0e0
      147 		     then do j = k + 1 to row_max;
      148 			     LU (P (i), j) = LU (P (i), j) - multiplier * LU (P (k), j);
      149 			end;
      150 		end;
      151 
      152 	     end;
      153 
      154 	     if LU (P (row_max), row_max) = 0
      155 	     then goto singular;
      156 
      157 /* Determine inverse and compute determinant */
      158 
      159 	     e = 0;
      160 	     do j = 1 to row_max;
      161 
      162 		do i = 1 to row_max;
      163 		     B (i) = 0;
      164 		end;
      165 
      166 		B (j) = 1.0e0;
      167 
      168 /* Solve AX = B for X */
      169 
      170 		call solve (X, B);
      171 
      172 /* Improve the solution */
      173 
      174 		call improve;
      175 
      176 /* Solution is column j of inverse */
      177 
      178 		do i = 1 to row_max;
      179 		     A_inverse (i, j) = X (i);
      180 		end;
      181 
      182 		ajj = LU (P (j), j);
      183 
      184 		if abs (determinant) > maxval / max (ajj, 1.0e0)
      185 		then do;
      186 			e = e + 1;
      187 			determinant = determinant / scale_factor;
      188 		     end;
      189 
      190 		if abs (determinant) < minval / min (ajj, 1.0e0)
      191 		then do;
      192 			e = e - 1;
      193 			determinant = determinant * scale_factor;
      194 		     end;
      195 
      196 		determinant = determinant * ajj;
      197 	     end;
      198 
      199 /* Correct exponent of determinant */
      200 
      201 	     do i = 1 to e by +1;
      202 		determinant = determinant * scale_factor;
      203 	     end;
      204 
      205 	     do i = -1 to e by -1;
      206 		determinant = determinant / scale_factor;
      207 	     end;
      208 
      209 /* ALL THRU */
      210 
      211 	     goto inverse_done;
      212 
      213 solve:
      214      proc (X, B);
      215 
      216 	dcl     (B, X)		 dim (100) float bin (63),
      217 	        dot		 float bin (63),
      218 	        (i, j)		 fixed bin;
      219 
      220 	do i = 1 to row_max;
      221 	     dot = 0.0e0;
      222 
      223 	     do j = 1 to i - 1;
      224 		dot = dot + LU (P (i), j) * X (j);
      225 	     end;
      226 
      227 	     X (i) = B (P (i)) - dot;
      228 	end;
      229 
      230 	do i = row_max by -1 to 1;
      231 	     dot = 0.0e0;
      232 
      233 	     do j = i + 1 to row_max;
      234 		dot = dot + LU (P (i), j) * X (j);
      235 	     end;
      236 
      237 	     X (i) = (X (i) - dot) / LU (P (i), i);
      238 	end;
      239 
      240      end;
      241 
      242 improve:
      243      proc;
      244 
      245 	dcl     (i, j, iterations)	 fixed binary,
      246 	        (norm_x, norm_dx, t)	 float bin (63),
      247 	        dot		 float bin (63);	/* MUST BE DOUBLE PRECISION */
      248 
      249 	dcl     max_iterations	 float bin static init (16),
      250 						/* about 2*log10(epsilon) */
      251 	        epsilon		 float bin static init (1e-8);
      252 
      253 	norm_x = 0.0e0;
      254 
      255 	do i = 1 to row_max;
      256 	     norm_x = max (norm_x, abs (X (i)));
      257 	end;
      258 
      259 	if norm_x = 0.0e0
      260 	then do;
      261 		accuracy = epsilon;
      262 		return;
      263 	     end;
      264 
      265 	do iterations = 1 to max_iterations;
      266 	     do i = 1 to row_max;
      267 
      268 		dot = 0.0e0;
      269 
      270 		do j = 1 to row_max;
      271 		     dot = dot + A (i, j) * X (j);
      272 		end;
      273 
      274 		R (i) = B (i) - dot;
      275 	     end;
      276 
      277 	     call solve (DX, R);
      278 
      279 	     norm_dx = 0.0e0;
      280 
      281 	     do i = 1 to row_max;
      282 		t = X (i);
      283 		X (i) = X (i) + DX (i);
      284 		norm_dx = max (norm_dx, abs (X (i) - t));
      285 	     end;
      286 
      287 	     if iterations = 1
      288 	     then accuracy = max (norm_dx / norm_x, epsilon);
      289 
      290 	     if norm_dx <= epsilon * norm_x
      291 	     then return;
      292 	end;
      293 
      294 	goto singular;
      295      end;
      296 
      297 singular:
      298 	     determinant = 0.0e0;
      299 
      300 inverse_done:
      301 	     if pr (1) = pr (2)
      302 	     then do;
      303 		     pr (2) -> array_dope.data -> A_inverse = A_inverse;
      304 		     free A_inverse in (string_area);
      305 		end;
      306 	end;
      307 
      308 	q_reg = 0;
      309 	return;
      310 
      311 /* transpose */
      312 
      313 switch (2):
      314 	row_max = pr (2) -> current_bounds (1) - 1;
      315 	if row_max <= 0
      316 	then goto array_error;
      317 
      318 	col_max = pr (2) -> current_bounds (2) - 1;
      319 	if col_max <= 0
      320 	then goto array_error;
      321 
      322 	source_pt = pr (1) -> array_dope.data;
      323 
      324 	if pr (1) ^= pr (2)
      325 	then sink_pt = pr (2) -> array_dope.data;
      326 	else allocate C set (sink_pt) in (string_area);
      327 
      328 	do i = 1 to row_max;
      329 	     do j = 1 to col_max;
      330 		sink_pt -> C (i, j) = source_pt -> C_transpose (j, i);
      331 	     end;
      332 	end;
      333 
      334 	if pr (1) = pr (2)
      335 	then do;
      336 		pr (2) -> array_dope.data -> C = sink_pt -> C;
      337 		free sink_pt -> C in (string_area);
      338 	     end;
      339 
      340 	q_reg = 0;
      341 	return;
      342 
      343 /* vector (1 x n) = vector (1 x p) * matrix (p x n) */
      344 
      345 switch (3):
      346 	p = pr (3) -> array_dope.current_bounds (1) - 1;
      347 	n = pr (3) -> array_dope.current_bounds (2) - 1;
      348 
      349 	call get_matrix_pointers;
      350 
      351 	if copy
      352 	then allocate vector_n set (p2) in (string_area);
      353 
      354 	do j = 1 to n;
      355 	     t = 0.0e0;
      356 
      357 	     do k = 1 to p;
      358 		t = t + p1 -> vector_p (k) * p3 -> matrix_pn (k, j);
      359 	     end;
      360 
      361 	     p2 -> vector_n (j) = t;
      362 	end;
      363 
      364 	if copy
      365 	then do;
      366 		pr (2) -> array_dope.data -> vector_n = p2 -> vector_n;
      367 		free p2 -> vector_n in (string_area);
      368 	     end;
      369 
      370 	q_reg = 0;
      371 	return;
      372 
      373 /* vector (m x 1) = matrix (m x p) * vector (p x 1) */
      374 
      375 switch (4):
      376 	m = pr (1) -> array_dope.current_bounds (1) - 1;
      377 	p = pr (1) -> array_dope.current_bounds (2) - 1;
      378 
      379 	call get_matrix_pointers;
      380 
      381 	if copy
      382 	then allocate vector_m set (p2) in (string_area);
      383 
      384 	do i = 1 to m;
      385 	     t = 0.0e0;
      386 
      387 	     do k = 1 to p;
      388 		t = t + p1 -> matrix_mp (i, k) * p3 -> vector_p (k);
      389 	     end;
      390 
      391 	     p2 -> vector_m (i) = t;
      392 	end;
      393 
      394 	if copy
      395 	then do;
      396 		pr (2) -> array_dope.data -> vector_m = p2 -> vector_m;
      397 		free p2 -> vector_m in (string_area);
      398 	     end;
      399 
      400 	q_reg = 0;
      401 	return;
      402 
      403 /* matrix (m x n) = matrix (m x p) * matrix (p x n) */
      404 
      405 switch (5):
      406 	m = pr (2) -> array_dope.current_bounds (1) - 1;
      407 	n = pr (2) -> array_dope.current_bounds (2) - 1;
      408 	p = pr (1) -> array_dope.current_bounds (2) - 1;
      409 
      410 	call get_matrix_pointers;
      411 
      412 	if copy
      413 	then allocate matrix_mn set (p2) in (string_area);
      414 	do i = 1 to m;
      415 	     do j = 1 to n;
      416 		t = 0.0e0;
      417 
      418 		do k = 1 to p;
      419 		     t = t + p1 -> matrix_mp (i, k) * p3 -> matrix_pn (k, j);
      420 		end;
      421 
      422 		p2 -> matrix_mn (i, j) = t;
      423 	     end;
      424 	end;
      425 
      426 	if copy
      427 	then do;
      428 		pr (2) -> array_dope.data -> matrix_mn = p2 -> matrix_mn;
      429 		free p2 -> matrix_mn in (string_area);
      430 	     end;
      431 
      432 	q_reg = 0;
      433 	return;
      434 
      435 /* errors */
      436 
      437 array_error:
      438 	q_reg = 139;
      439 
      440 get_matrix_pointers:
      441      proc;
      442 
      443 	p1 = pr (1) -> array_dope.data;
      444 	p3 = pr (3) -> array_dope.data;
      445 
      446 	copy = (pr (1) = pr (2)) | (pr (3) = pr (2));
      447 
      448 	if ^copy
      449 	then p2 = pr (2) -> array_dope.data;
      450 
      451      end;
      452 
      453      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/11/84  1223.8  basic_matrix_.pl1                 >spec>on>basic>basic_matrix_.pl1
42           1    03/27/82  0439.4  basic_operator_frame.incl.pl1     >ldd>include>basic_operator_frame.incl.pl1
43           2    03/27/82  0439.4  basic_symbols.incl.pl1            >ldd>include>basic_symbols.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
A                                      based           float bin(27)            array dcl 79 ref 98 271
A_inverse                              based           float bin(27)            array dcl 79 set ref 89 179* 303* 303 304
B                                      parameter       float bin(63)            array dcl 216 in procedure "solve" ref 213 227
B                               000244 automatic       float bin(63)            array dcl 65 in begin block on line 60 set ref 163*
                                                                                  166* 170* 274
C                                      based           float bin(27)            array dcl 32 set ref 326 330* 336* 336 337
C_transpose                            based           float bin(27)            array dcl 32 ref 330
DX                              001374 automatic       float bin(63)            array dcl 65 set ref 277* 283
LU                                     based           float bin(63)            array dcl 62 set ref 98* 99 116 141 144 144* 148*
                                                                                  148 148 154 182 224 234 237
P                               000100 automatic       fixed bin(17,0)          array dcl 65 set ref 82 94* 116 116 136 137* 137
                                                                                  138* 141 144 144 148 148 148 154 182 224 227 234
                                                                                  237
R                               001064 automatic       float bin(63)            array dcl 65 set ref 274* 277*
X                               000554 automatic       float bin(63)            array dcl 65 in begin block on line 60 set ref 170*
                                                                                  179 256 271 282 283* 283 284
X                                      parameter       float bin(63)            array dcl 216 in procedure "solve" set ref 213 224
                                                                                  227* 234 237* 237
abs                                                    builtin function         dcl 25 ref 99 116 184 190 256 284
accuracy                        000010 internal static float bin(63)            dcl 17 set ref 261* 287*
addr                                                   builtin function         dcl 25 ref 98 99 116 141 144 144 148 148 148 154 182
                                                                                  224 234 237
ainvp                           002240 automatic       pointer                  dcl 77 set ref 87* 89* 179 303 304
ajj                             002222 automatic       float bin(63)            dcl 65 set ref 182* 184 190 196
ap                              002236 automatic       pointer                  dcl 77 set ref 85* 98 271
array_dope                             based           structure                level 1 dcl 2-1
basic_matrix_double_            000012 constant        entry                    external dcl 28 ref 48
basic_operators_frame                  based           structure                level 1 dcl 1-1
biggest                         002226 automatic       float bin(63)            dcl 65 set ref 113* 118 120* 125
bo_pt                           000100 automatic       pointer                  dcl 17 set ref 45* 46 51 55 85 87 87 87 89 110 134
                                                                                  134 184 187 187 190 193 193 196 196 202 202 206
                                                                                  206 297 300 300 303 304 308 313 318 322 324 324
                                                                                  324 326 334 334 336 337 340 345 347 351 366 367
                                                                                  370 375 377 381 396 397 400 405 407 408 412 428
                                                                                  429 432 437 443 444 446 446 446 446 448
bo_stack_pt                            parameter       pointer                  dcl 17 set ref 12 45 48*
col_max                         000127 automatic       fixed bin(17,0)          dcl 17 set ref 318* 319 326 329 330 336 337
copy                            000114 automatic       bit(1)                   dcl 17 set ref 351 364 381 394 412 426 446* 448
current_bounds            4            based           fixed bin(17,0)          array level 2 dcl 2-1 ref 55 313 318 345 347 375 377
                                                                                  405 407 408
data                                   based           pointer                  level 2 dcl 2-1 ref 85 87 303 322 324 336 366 396
                                                                                  428 443 444 448
determinant             124            based           float bin(63)            level 2 dcl 1-1 set ref 110* 134* 134 184 187* 187
                                                                                  190 193* 193 196* 196 202* 202 206* 206 297*
dot                             002320 automatic       float bin(63)            dcl 245 in procedure "improve" set ref 268* 271* 271
                                                                                  274
dot                             002270 automatic       float bin(63)            dcl 216 in procedure "solve" set ref 221* 224* 224
                                                                                  227 231* 234* 234 237
e                               002216 automatic       fixed bin(17,0)          dcl 65 set ref 159* 186* 186 192* 192 201 205
epsilon                         000005 constant        float bin(27)            initial dcl 249 ref 261 287 290
hbound                                                 builtin function         dcl 25 ref 82
i                               002214 automatic       fixed bin(17,0)          dcl 65 in begin block on line 60 set ref 93* 94 94
                                                                                  98 98 99 105* 115* 116 116 121* 143* 144 144 148
                                                                                  148* 162* 163* 178* 179 179* 201* 205*
i                               002272 automatic       fixed bin(17,0)          dcl 216 in procedure "solve" set ref 220* 223 224
                                                                                  227 227* 230* 233 234 237 237 237 237*
i                               000120 automatic       fixed bin(17,0)          dcl 17 in procedure "basic_matrix_" set ref 328* 330
                                                                                  330* 384* 388 391* 414* 419 422*
i                               002306 automatic       fixed bin(17,0)          dcl 245 in procedure "improve" set ref 255* 256*
                                                                                  266* 271 274 274* 281* 282 283 283 283 284*
iterations                      002310 automatic       fixed bin(17,0)          dcl 245 set ref 265* 287*
j                               002273 automatic       fixed bin(17,0)          dcl 216 in procedure "solve" set ref 223* 224 224*
                                                                                  233* 234 234*
j                               000121 automatic       fixed bin(17,0)          dcl 17 in procedure "basic_matrix_" set ref 329* 330
                                                                                  330* 354* 358 361* 415* 419 422*
j                               002307 automatic       fixed bin(17,0)          dcl 245 in procedure "improve" set ref 270* 271 271*
j                               002215 automatic       fixed bin(17,0)          dcl 65 in begin block on line 60 set ref 97* 98 98
                                                                                  99* 136* 138 146* 148 148 148* 160* 166 179 182
                                                                                  182*
k                               002217 automatic       fixed bin(17,0)          dcl 65 in begin block on line 60 set ref 112* 115
                                                                                  116 128 136 137 141 141 143 144 144 146 148*
k                               000122 automatic       fixed bin(17,0)          dcl 17 in procedure "basic_matrix_" set ref 357* 358
                                                                                  358* 387* 388 388* 418* 419 419*
m                               000123 automatic       fixed bin(17,0)          dcl 17 set ref 375* 381 384 396 397 405* 412 414 428
                                                                                  429
matrix_mn                              based           float bin(27)            array dcl 35 set ref 412 422* 428* 428 429
matrix_mp                              based           float bin(27)            array dcl 35 ref 388 419
matrix_pn                              based           float bin(27)            array dcl 35 ref 358 419
max                                                    builtin function         dcl 25 ref 99 184 256 284 287
max_iterations                         constant        float bin(27)            initial dcl 249 ref 265
maxval                          000007 constant        float bin(27)            initial dcl 71 ref 184
min                                                    builtin function         dcl 25 ref 190
minval                          000006 constant        float bin(27)            initial dcl 71 ref 190
multiplier                      002232 automatic       float bin(63)            dcl 65 set ref 144* 146 148
n                               000124 automatic       fixed bin(17,0)          dcl 17 set ref 347* 351 354 358 366 367 407* 412 415
                                                                                  419 422 428 429
norm_dx                         002314 automatic       float bin(63)            dcl 245 set ref 279* 284* 284 287 290
norm_row                        002224 automatic       float bin(63)            dcl 65 set ref 95* 99* 99 102 105
norm_x                          002312 automatic       float bin(63)            dcl 245 set ref 253* 256* 256 259 287 290
p                               000125 automatic       fixed bin(17,0)          dcl 17 set ref 345* 357 377* 387 388 408* 418 419
p1                              000106 automatic       pointer                  dcl 17 set ref 358 388 419 443*
p2                              000110 automatic       pointer                  dcl 17 set ref 351* 361 366 367 381* 391 396 397
                                                                                  412* 422 428 429 448*
p3                              000112 automatic       pointer                  dcl 17 set ref 358 388 419 444*
pividx                          002220 automatic       fixed bin(17,0)          dcl 65 set ref 121* 128 137 138
pivot                           002234 automatic       float bin(63)            dcl 65 set ref 141* 144
pr                                     based           pointer                  array level 2 dcl 1-1 ref 55 85 87 87 87 300 300 303
                                                                                  313 318 322 324 324 324 334 334 336 345 347 366
                                                                                  375 377 396 405 407 408 428 443 444 446 446 446
                                                                                  446 448
precision_lng           147            based           fixed bin(17,0)          level 2 packed unaligned dcl 1-1 ref 46
q_reg                    45            based           fixed bin(35,0)          level 3 dcl 1-1 set ref 51 308* 340* 370* 400* 432*
                                                                                  437*
regs                     40            based           structure                level 2 dcl 1-1
row_max                         000126 automatic       fixed bin(17,0)          dcl 17 set ref 55* 57 62 62 82 89 89 93 97 98 98 98
                                                                                  99 99 112 115 116 116 141 141 143 144 144 144 144
                                                                                  146 148 148 148 148 148 148 154 154 154 154 160
                                                                                  162 178 179 182 182 220 224 224 230 233 234 234
                                                                                  237 237 255 266 270 271 281 303 303 304 304 313*
                                                                                  315 326 328 330 336 337
scale_factor                    000007 constant        float bin(27)            initial dcl 71 ref 187 193 202 206
scales                          001704 automatic       float bin(63)            array dcl 65 set ref 105* 116
sink_pt                         000102 automatic       pointer                  dcl 17 set ref 324* 326* 330 336 337
size                            002230 automatic       float bin(63)            dcl 65 set ref 116* 118 120
source_pt                       000104 automatic       pointer                  dcl 17 set ref 322* 330
space                           000100 automatic       fixed bin(17,0)          array dcl 62 set ref 98 99 116 141 144 144 148 148
                                                                                  148 154 182 224 234 237
string_area                            based           area(65536)              dcl 30 ref 89 304 326 337 351 367 381 397 412 429
string_segment          106            based           pointer                  level 2 dcl 1-1 ref 89 304 326 337 351 367 381 397
                                                                                  412 429
t                               002316 automatic       float bin(63)            dcl 245 in procedure "improve" set ref 282* 284
t                               000116 automatic       float bin(63)            dcl 17 in procedure "basic_matrix_" set ref 355*
                                                                                  358* 358 361 385* 388* 388 391 416* 419* 419 422
vector_m                               based           float bin(27)            array dcl 35 set ref 381 391* 396* 396 397
vector_n                               based           float bin(27)            array dcl 35 set ref 351 361* 366* 366 367
vector_p                               based           float bin(27)            array dcl 35 ref 358 388

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
array_symbol                           based           structure                level 1 dcl 2-11
d_basic_operators_frame                based           structure                level 1 dcl 1-68
scalar_symbol                          based           structure                level 1 dcl 2-6

NAMES DECLARED BY EXPLICIT CONTEXT.
array_error                     002006 constant        label                    dcl 437 ref 57 82 315 319
basic_matrix_                   000025 constant        entry                    external dcl 12
get_matrix_pointers             002012 constant        entry                    internal dcl 440 ref 349 379 410
improve                         001103 constant        entry                    internal dcl 242 ref 174
inverse_done                    000666 constant        label                    dcl 300 ref 211
singular                        000662 constant        label                    dcl 297 ref 102 125 154 294
solve                           000715 constant        entry                    internal dcl 213 ref 170 277
switch                          000000 constant        label                    array(5) dcl 55 ref 51

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2114        2130    2056        2124
Length      2326    2056        14         162      36           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
basic_matrix_                       113 external procedure  is an external procedure.  
begin block on line 60             1250 begin block         uses auto adjustable storage.  
solve                                   internal procedure  shares stack frame of begin block on line 60.  
improve                                 internal procedure  shares stack frame of begin block on line 60.  
get_matrix_pointers                     internal procedure  shares stack frame of external procedure basic_matrix_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 accuracy                    basic_matrix_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
basic_matrix_            000100 bo_pt                       basic_matrix_
                         000102 sink_pt                     basic_matrix_
                         000104 source_pt                   basic_matrix_
                         000106 p1                          basic_matrix_
                         000110 p2                          basic_matrix_
                         000112 p3                          basic_matrix_
                         000114 copy                        basic_matrix_
                         000116 t                           basic_matrix_
                         000120 i                           basic_matrix_
                         000121 j                           basic_matrix_
                         000122 k                           basic_matrix_
                         000123 m                           basic_matrix_
                         000124 n                           basic_matrix_
                         000125 p                           basic_matrix_
                         000126 row_max                     basic_matrix_
                         000127 col_max                     basic_matrix_
begin block on line 60   000100 space                       begin block on line 60
                         000100 P                           begin block on line 60
                         000244 B                           begin block on line 60
                         000554 X                           begin block on line 60
                         001064 R                           begin block on line 60
                         001374 DX                          begin block on line 60
                         001704 scales                      begin block on line 60
                         002214 i                           begin block on line 60
                         002215 j                           begin block on line 60
                         002216 e                           begin block on line 60
                         002217 k                           begin block on line 60
                         002220 pividx                      begin block on line 60
                         002222 ajj                         begin block on line 60
                         002224 norm_row                    begin block on line 60
                         002226 biggest                     begin block on line 60
                         002230 size                        begin block on line 60
                         002232 multiplier                  begin block on line 60
                         002234 pivot                       begin block on line 60
                         002236 ap                          begin block on line 60
                         002240 ainvp                       begin block on line 60
                         002270 dot                         solve
                         002272 i                           solve
                         002273 j                           solve
                         002306 i                           improve
                         002307 j                           improve
                         002310 iterations                  improve
                         002312 norm_x                      improve
                         002314 norm_dx                     improve
                         002316 t                           improve
                         002320 dot                         improve

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          r_e_as              enter_begin         leave_begin         call_ext_out        return
tra_ext             alloc_auto_adj      ext_entry           alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
basic_matrix_double_

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000022        45 000032        46 000036        48 000042        49 000050        51 000051        55 000053
     57 000057        60 000060        62 000063        82 000071        85 000077        87 000104        89 000114
     93 000126        94 000137        95 000140        97 000142        98 000153        99 000175       100 000203
    102 000205       105 000207       106 000215       110 000217       112 000223       113 000233       115 000235
    116 000245       118 000271       120 000273       121 000274       123 000276       125 000300       128 000302
    134 000305       136 000312       137 000315       138 000320       141 000322       143 000340       144 000351
    146 000372       148 000403       149 000434       150 000436       152 000440       154 000442       159 000452
    160 000453       162 000463       163 000473       164 000477       166 000501       170 000506       174 000510
    178 000511       179 000521       180 000533       182 000535       184 000553       186 000571       187 000572
    190 000575       192 000612       193 000614       196 000617       197 000622       201 000624       202 000633
    203 000640       205 000642       206 000651       207 000656       211 000661       297 000662       300 000666
    303 000674       304 000710       306 000713       213 000715       220 000717       221 000727       223 000731
    224 000741       225 000763       227 000765       228 001002       230 001004       231 001013       233 001015
    234 001027       235 001051       237 001053       238 001077       240 001102       242 001103       253 001104
    255 001106       256 001117       257 001127       259 001131       261 001133       262 001136       265 001137
    266 001150       268 001161       270 001163       271 001173       272 001206       274 001210       275 001216
    277 001220       279 001222       281 001224       282 001235       283 001241       284 001243       285 001252
    287 001254       290 001270       292 001275       294 001277       308 001300       309 001302       313 001303
    315 001307       318 001310       319 001313       322 001314       324 001317       326 001326       328 001341
    329 001351       330 001361       331 001374       332 001376       334 001400       336 001405       337 001423
    340 001426       341 001430       345 001431       347 001435       349 001440       351 001441       354 001452
    355 001461       357 001463       358 001473       359 001505       361 001507       362 001512       364 001514
    366 001516       367 001531       370 001533       371 001535       375 001536       377 001542       379 001545
    381 001546       384 001557       385 001567       387 001571       388 001601       389 001612       391 001614
    392 001617       394 001621       396 001623       397 001636       400 001640       401 001642       405 001643
    407 001647       408 001652       410 001656       412 001657       414 001674       415 001703       416 001713
    418 001715       419 001725       420 001742       422 001744       423 001753       424 001755       426 001757
    428 001761       429 002000       432 002003       433 002005       437 002006       453 002011       440 002012
    443 002013       444 002017       446 002022       448 002035       451 002041


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
