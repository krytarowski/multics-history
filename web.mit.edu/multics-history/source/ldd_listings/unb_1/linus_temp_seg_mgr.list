	COMPILATION LISTING OF SEGMENT linus_temp_seg_mgr
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/29/86  0959.1 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend */
       12 linus_temp_seg_mgr:
       13 	proc ();
       14 
       15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       16 	/*								        */
       17 	/*    This program implements the temporary segment management features	        */
       18 	/*    as used by the LINUS report writer (and possibly other modules later).	        */
       19 	/*								        */
       20 	/*    Last Modified: (date and reason):					        */
       21 	/*    04/06/83         original coding by Dave Schimke			        */
       22 	/*                     taken from get_temporary_segments_.pl1, but modified to add      */
       23 	/*                     directory specification.				        */
       24 	/*								        */
       25 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       26 
       27 
       28 /* Parameters */
       29 
       30 dcl  a_lcb_ptr ptr;
       31 dcl  a_caller char (*);
       32 dcl  a_dir char (*);
       33 dcl  a_ptrs (*) ptr;
       34 dcl  a_ptr ptr;
       35 dcl  a_code fixed bin (35);
       36 
       37 /**/
       38 
       39 get_segments:
       40 	entry (a_lcb_ptr, a_caller, a_dir, a_ptr, a_code);
       41 
       42 	n_segs = dim (a_ptrs, 1);			/* get number of segments wanted */
       43 	array_ptr = addr (a_ptrs);			/* get ptr to the array of ptrs */
       44 
       45 gts_join:
       46 	call initialize;
       47 	a_code = 0;
       48 	n_found = 0;				/* initialize indicating we've found no free entries */
       49  	if a_dir = ""
       50 	     then dir_name = get_pdir_ ();
       51 	else dir_name = a_dir;	     
       52 	status_ip = addr(status_info);
       53 	call expand_pathname_ (dir_name, containing_dir, dir_entryname, code);
       54 	if code ^= 0 then do;
       55 	     a_code = code;
       56 	     return;
       57 	     end;
       58 	call hcs_$status_long (containing_dir, dir_entryname, 1, status_ip, null(), code);
       59 	if code ^= 0 & code ^= error_table_$no_s_permission then do;
       60 	     a_code = code;
       61 	     return;
       62 	     end;
       63 	
       64 	dir_uid = status_info.long.uid;
       65 	
       66 	if block_ptr = null then do;			/* we haven't yet gotten any segments */
       67 	     temp_seg_info.number_of_temp_segs,
       68 		n_blocks = n_segs;			/* so get the exact amount requested */ 
       69 	     allocate block in (area) set (block_ptr);	/* get the needed storage */
       70 	     temp_seg_info.seg_block_ptr = block_ptr;
       71 	     old_blocks = 0;			/* needed by get_new_segments routine */
       72 	     call get_new_segments;			/* do the work in this subr */
       73 	     return;
       74 	     end;
       75 
       76 	do i = 1 to n_blocks while (n_found < n_segs);	/* search for the necessary free segments */
       77 	     if (^block (i).used & block(i).uid = dir_uid)
       78 		then do;				/* we found another free one */
       79 		block (i).used = "1"b;		/* mark entry as being used */
       80 		block (i).caller = a_caller;		/* save name of whose using it */
       81 		n_found = n_found + 1;
       82 		ptrs (n_found) = block (i).segptr;
       83 		end;
       84 	end;
       85 	if n_found < n_segs then do;			/* there weren't enough free ones */
       86 	     new_blocks = n_blocks + n_segs - n_found;	/* get more storage, just large enough */
       87 	     old_blocks = n_blocks;
       88 
       89 	     allocate new_block in (area) set (new_block_ptr);
       90 						/* get the needed storage */
       91 	     new_block_ptr -> block = block;		/* copy the current structure */
       92 	     free block in (area);
       93 	     temp_seg_info.number_of_temp_segs,
       94 		n_blocks = new_blocks;
       95 	     temp_seg_info.seg_block_ptr,
       96 		block_ptr = new_block_ptr;
       97 	     call get_new_segments;			/* get the needed segments */
       98 	     end;
       99 
      100 	return;
      101 
      102 get_new_segments:
      103      proc;
      104 
      105 dcl  (i, j) fixed bin;
      106 
      107 	do i = old_blocks + 1 to n_blocks;		/* initialize the new entries */
      108 	     block (i).used = "1"b;			/* the caller will use these blocks */
      109 	     block (i).caller = a_caller;		/* ditto */
      110 	     block (i).uid = dir_uid;		          /* save the dir_uid */
      111 	     ename2 = unique_chars_ (unique_bits_ ()) || ".temp.";
      112 	     ename = substr(ename2, 1, 20);
      113 	     call hcs_$make_seg (dir_name, ename, "", 01110b, block (i).segptr, code);
      114 	     if code ^= 0 then do;
      115 		call undo;
      116 		return;
      117 		end;
      118 	     segment_number = bin (baseno (block (i).segptr), 18);
      119 	     do j = 1 to 4;
      120 		segno (j) = substr ("01234567", bin (digit (j), 3) + 1, 1);
      121 	     end;
      122 	     call hcs_$chname_seg (block (i).segptr, ename, ename2, code);
      123 	     if code ^= 0 then do;
      124 		call undo;
      125 		return;
      126 		end;
      127 
      128 	     call hcs_$set_safety_sw_seg (block (i).segptr, "1"b, code);
      129 
      130 	     block (i).name = substr(ename2, 1, 25);
      131 	     n_found = n_found + 1;
      132 	     ptrs (n_found) = block (i).segptr;
      133 	end;
      134 
      135 undo:
      136 	proc;
      137 
      138 	     a_code = code;
      139 	     temp_seg_info.number_of_temp_segs,
      140 		n_blocks = old_blocks;		/* reset to the way things were */
      141 	     do j = old_blocks + 1 to i - 1;		/* clean up the segments we already got */
      142 		call delete_$ptr (block (j).segptr, "100100"b, "", code);
      143 	     end;
      144 
      145 	end;
      146      end;						/*						*/
      147 get_segment:
      148      entry (a_lcb_ptr, a_caller, a_dir, a_ptr, a_code);
      149 
      150 	n_segs = 1;				/* only 1 segment is being processed */
      151 	array_ptr = addr (a_ptr);
      152 	go to gts_join;				/*						*/
      153 release_segments:
      154      entry (a_lcb_ptr, a_caller, a_ptrs, a_code);
      155 
      156           n_segs = dim (a_ptrs, 1);			/* get number of segments wanted */
      157 	array_ptr = addr (a_ptrs);			/* get ptr to the array of ptrs */
      158 
      159 rts_join:
      160           call initialize;
      161 	a_code = 0;
      162 	do i = 1 to n_segs;				/* release each segment passed in */
      163 	     if ptrs (i) ^= null then do;
      164 		found_it = "0"b;			/* flag says we've not yet found this segment */
      165 		do j = 1 to n_blocks while (^found_it); /* search for segment in array */
      166 		     if block (j).used then do;	/* candidate, see if right one */
      167 			if ptrs (i) = block (j).segptr then do;
      168 						/* we found the given segment */
      169 			     if block (j).caller ^= substr(a_caller, 1, min (length (a_caller),32))
      170 			     then a_code = error_table_$argerr;
      171 			     else do;		/* the right guy (as far as we care) */
      172 				call hcs_$truncate_seg (block (j).segptr, 0, code);
      173 						/* truncate now */
      174 				if code ^= 0 then a_code = code;
      175 						/* accumulate error */
      176 				block (j).used = "0"b;
      177 						/* ditto */
      178 				block (j).caller = "";
      179 				ptrs (i) = null;
      180 				found_it = "1"b;
      181 				end;
      182 			     end;
      183 			end;
      184 		end;
      185 		if ^found_it then a_code = error_table_$argerr;
      186 		end;
      187 	end;
      188 	return;
      189 
      190 /**/
      191 release_segment:
      192      entry (a_lcb_ptr, a_caller, a_ptr, a_code);
      193 
      194           n_segs = 1;				/* only 1 segment is being processed */
      195 	array_ptr = addr (a_ptr);
      196 	goto rts_join;
      197 
      198 /**/
      199 terminate:
      200 	entry (a_lcb_ptr, a_code);
      201 
      202 	call initialize;
      203 	a_code = 0;
      204 	do i = 1 to n_blocks;			/* delete all */
      205 	     if block(i).used then call com_err_ (0, "linus_temp_seg_mgr", "Warning. An unreleased temp seg has been found. (^a)", block(i).caller);
      206 	     call delete_$ptr (block(i).segptr, "100100"b, "linus_temp_seg_mgr", a_code);
      207 	     end;
      208 	call release_temp_segment_ ("linus_temp_seg_mgr", temp_seg_info.work_area_ptr, a_code);
      209 	lcb.temp_seg_info_ptr = null;
      210 	return;
      211 /**/
      212 initialize:
      213 	proc;
      214 
      215 	lcb_ptr = a_lcb_ptr;
      216 	sci_ptr = lcb.subsystem_control_info_ptr;
      217 	info_ptr = lcb.temp_seg_info_ptr;
      218 	if info_ptr = null then do;
      219 	     allocate temp_seg_info in (lcb.static_area) set (info_ptr);
      220 	     lcb.temp_seg_info_ptr = info_ptr;
      221 	     end;
      222 	area_p = temp_seg_info.work_area_ptr;
      223 	if area_p = null then do;
      224 	     call get_temp_segment_ ("linus_temp_seg_mgr", temp_seg_info.work_area_ptr, a_code);
      225 	     allocate area_info set (area_infop);
      226 	     area_info.version = 1;
      227 	     area_info.control.extend = "0"b;
      228 	     area_info.control.zero_on_alloc = "0"b;
      229 	     area_info.control.zero_on_free = "0"b;
      230 	     area_info.control.no_freeing = "0"b;
      231 	     area_info.control.system = "0"b;
      232 	     area_info.owner = a_caller;
      233 	     area_info.pad = "0"b;
      234 	     area_info.size = sys_info$max_seg_size;
      235 	     area_info.areap = temp_seg_info.work_area_ptr;
      236 	     call define_area_ (area_infop, a_code);
      237 	     area_p = temp_seg_info.work_area_ptr;
      238 	     free area_info;
      239 	     end;
      240 	block_ptr = temp_seg_info.seg_block_ptr;
      241 	n_blocks = temp_seg_info.number_of_temp_segs;
      242 end initialize;
      243 /* Automatic */
      244 
      245 dcl  area_p ptr init (null);
      246 dcl  array_ptr ptr;
      247 dcl  block_ptr ptr init (null);
      248 dcl  code fixed bin (35);
      249 dcl  containing_dir char(168);
      250 dcl  dir_entryname char(32);
      251 dcl  dir_name char(168);
      252 dcl  dir_uid bit(36) unal;
      253 dcl  ename char (20);
      254 dcl  ename2 char (32);
      255 dcl  found_it bit (1);
      256 dcl  i fixed bin;
      257 dcl  info_ptr ptr;
      258 dcl  j fixed bin;
      259 dcl  n_blocks fixed bin init (0);
      260 dcl  n_found fixed bin;
      261 dcl  n_segs fixed bin;
      262 dcl  new_block_ptr ptr;
      263 dcl  new_blocks fixed bin;
      264 dcl  old_blocks fixed bin;
      265 dcl  sci_ptr ptr;
      266 dcl  segment_number fixed bin;
      267 dcl  segno (4) char (1) defined (ename2) pos (22);
      268 dcl  status_ip ptr;
      269 
      270 /* Based */
      271 
      272 dcl  area area based (area_p);
      273 dcl  1 block (n_blocks) aligned based (block_ptr),
      274        2 caller char (32),
      275        2 segptr ptr,
      276        2 name char (25),
      277        2 uid bit(36) unal,
      278        2 used bit (1);
      279 dcl  1 temp_seg_info based (info_ptr),
      280        2 number_of_temp_segs fixed bin init (0),
      281        2 seg_block_ptr ptr init(null),
      282        2 work_area_ptr ptr init(null);
      283 dcl  1 new_block (new_blocks) aligned based (new_block_ptr) like block;
      284 dcl  1 octal_digits aligned based (addr (segment_number)),
      285        2 filler bit (24) unal,
      286        2 digit (4) bit (3) unal;
      287 dcl  ptrs (n_segs) ptr based (array_ptr);
      288 dcl 1 status_info like status_branch;
      289 
      290 /* Builtin */
      291 
      292 dcl  (addr, baseno, bin, dim, fixed, length, min, null, rel, substr) builtin;
      293 
      294 /* Entries */
      295 
      296 dcl  com_err_ entry() options(variable);
      297 dcl  define_area_ entry (ptr, fixed bin(35));
      298 dcl  delete_$ptr entry (ptr, bit(6), char(*), fixed bin(35));
      299 dcl  expand_pathname_ entry (char(*), char(*), char(*), fixed bin(35));
      300 dcl  get_pdir_ entry() returns(char(168));
      301 dcl  get_temp_segment_ entry (char(*), ptr, fixed bin(35));
      302 dcl  hcs_$chname_seg entry (ptr, char (*), char (*), fixed bin (35));
      303 dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
      304 dcl  hcs_$status_long entry (char(*), char(*), fixed bin(1), ptr, ptr, fixed bin(35));
      305 dcl  hcs_$set_safety_sw_seg entry (ptr, bit (1), fixed bin (35));
      306 dcl  hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35));
      307 dcl  release_temp_segment_ entry (char(*), ptr, fixed bin(35));
      308 dcl  unique_bits_ entry returns (bit (70));
      309 dcl  unique_chars_ entry (bit (*)) returns (char (15));
      310 
      311 /* External */
      312 
      313 dcl  error_table_$argerr fixed bin (35) ext;
      314 dcl  error_table_$no_s_permission fixed bin(35) ext static;
      315 dcl  sys_info$max_seg_size fixed bin(35) ext static;
      316 
      317 
  1     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  1     2 
  1     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  1     4 
  1     5 dcl  area_infop ptr;
  1     6 
  1     7 dcl 1 area_info aligned based (area_infop),
  1     8     2 version fixed bin,				/* version number for this structure is 1 */
  1     9     2 control aligned like area_control,		/* control bits for the area */
  1    10     2 owner char (32) unal,				/* creator of the area */
  1    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  1    12     2 size fixed bin (18),				/* size of the area in words */
  1    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  1    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  1    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  1    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  1    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  1    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  1    19 
  1    20 dcl 1 area_control aligned based,
  1    21     2 extend bit (1) unal,				/* says area is extensible */
  1    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  1    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  1    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  1    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  1    26     2 system bit (1) unal,				/* says area is managed by system */
  1    27     2 pad bit (30) unal;
  1    28 
  1    29 /* END INCLUDE FILE area_info.incl.pl1 */
      318 
  2     1 /* BEGIN INCLUDE FILE linus_lcb.incl.pl1 -- jaw 8/30/77 */
  2     2    
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(86-04-23,Dupuis), approve(86-05-23,MCR7188), audit(86-07-23,GWMay),
  2     7*     install(86-07-29,MR12.0-1106):
  2     8*     Added general_work_area_ptr and renamed sfr_ptr to
  2     9*     force_retrieve_scope_ptr.
  2    10*                                                   END HISTORY COMMENTS */
  2    11 
  2    12 
  2    13 /* HISTORY:
  2    14*
  2    15*   78-09-29 J. C. C. Jagernauth: Modified for MR7.0.
  2    16*
  2    17*   81-05-11  Rickie E.  Brinegar: added security bit and andministrator bit as
  2    18*   a part of the attribute level control work.
  2    19*   
  2    20*   81-06-17  Rickie E.  Brinegar: deleted the sd_ptr as a part of removing the
  2    21*   scope_data  structure  from  LINUS.   LINUS now depends totally on MRDS for
  2    22*   scope information.
  2    23*   
  2    24*   81-11-11  Rickie  E.   Brinegar:  added the timing bit and three fields for
  2    25*   retaining  various  vcpu  times  to  be collected when in timing mode.  The
  2    26*   times  to  be collected are: LINUS parsing time, LINUS processing time, and
  2    27*   MRDS processing time.
  2    28*
  2    29*   82-01-15  DJ  Schimke:  Added the build_increment and build_start fields as
  2    30*   part of the line numbering implementation.  This allows for possible  later
  2    31*   LINUS control of the build defaults.
  2    32* 
  2    33*   82-03-01 Paul W. Benjamin: Removed linus_prompt_chars_ptr, as that 
  2    34*   information is now retained by ssu_.  Removed parse_timer as no longer
  2    35*   meaningful.  Added linus_version.  Added iteration bit.  Added 6 entry 
  2    36*   variables for ssu_ replaceable procedures.  Added actual_input_iocbp.
  2    37*
  2    38*   82-06-23 Al Dupuis: Added subsystem_control_info_ptr, 
  2    39*   subsystem_invocation_level, and selection_expression_identifier.
  2    40*
  2    41*   82-08-26 DJ Schimke: Added report_control_info_ptr, and
  2    42*   table_control_info_ptr. 
  2    43*
  2    44*   82-10-19 DJ Schimke: Added ssu_abort_line.
  2    45*
  2    46*   83-06-06 Bert Moberg: Added print_search_order (pso) and no_optimize (no_ot)
  2    47*
  2    48*   83-04-07 DJ Schimke: Added temp_seg_info_ptr.
  2    49*
  2    50*   83-08-26 Al Dupuis: Added query_temp_segment_ptr.
  2    51**/
  2    52     
  2    53 dcl 1 lcb aligned based (lcb_ptr),			/* LINUS control block */
  2    54     2 db_index fixed bin (35),			/* index of open data base, or 0 */
  2    55     2 rb_len fixed bin (21),				/* length of request buffer */
  2    56     2 lila_count fixed bin (35),			/* number of LILA text lines */
  2    57     2 lila_chars fixed bin (35),			/* number of LILA source test chars */
  2    58     2 trans_id fixed bin (35),			/* used by checkpoint and rollback facilities (MR7.0) */
  2    59     2 lila_fn char (32) unal,				/* entry name of lila data file */
  2    60     2 prompt_flag bit (1) unal,			/* on if in prompt mode */
  2    61     2 test_flag bit (1) unal,				/* on if in test mode */
  2    62     2 new_version bit (1) unal init (1),		/* on for new version data base (MR7.0) */
  2    63     2 secured_db bit (1) unal,                              /* on if the db is in a secure state */
  2    64     2 administrator bit (1) unal,                           /* on if the user is a db administrator */
  2    65     2 timing_mode bit (1) unal,                             /* on if timing is to be done */
  2    66     2 iteration bit (1) unal,				/* interpret parens as iteration sets */
  2    67     2 pso_flag bit (1) unal,				/* add print_search_order to select */
  2    68     2 no_ot_flag bit (1) unal,			/* add no_optimize to select */
  2    69     2 reserved bit (27) unal,
  2    70     2 liocb_ptr ptr,				/* iocb ptr for lila file */
  2    71     2 rb_ptr ptr,					/* ptr to request buffer */
  2    72     2 is_ptr ptr,					/* iocb ptr for currentinput stream switch */
  2    73     2 cal_ptr ptr,					/* ptr to current arg list for invoke (or null) */
  2    74     2 ttn_ptr ptr,					/* pointer to table info structure */
  2    75     2 force_retrieve_scope_info_ptr ptr,		/* structure pointer to force retrieve scope operation */
  2    76     2 lv_ptr ptr,					/* pointer linus variables */
  2    77     2 si_ptr ptr,					/* pointer to select_info structure */
  2    78     2 setfi_ptr ptr,				/* pointer to set function information */
  2    79     2 sclfi_ptr ptr,				/* pointer to user declared scalar fun. names */
  2    80     2 ivs_ptr ptr,					/* pointer to stack of invoke iocb pointers */
  2    81     2 lit_ptr ptr,					/* pointer to literal pool */
  2    82     2 lvv_ptr ptr,					/* pointer to linus variable alloc. pool  */
  2    83     2 rd_ptr ptr,					/* point to readied files mode information (MR7.0) */
  2    84     2 rt_ptr ptr,                                           /* point to table of relation names and their readied modes
  2    85*                                                               (MR7.0) */
  2    86     2 actual_input_iocbp ptr,				/* ptr to input while in macros */
  2    87     2 lila_promp_chars_ptr ptr,			/* pointer to the prompt characters for lila */
  2    88     2 linus_area_ptr ptr,				/* LINUS temporary segment pointer */
  2    89     2 lila_area_ptr ptr,				/* LILA temporary segment pointer */
  2    90     2 i_o_area_ptr ptr,				/* temporary segment pointer used by write, print, create_list */
  2    91     2 rel_array_ptr ptr,                                    /* ptr to array of names rslt info structure
  2    92*                                                               for current lila expression */
  2    93     2 unused_timer float bin (63),			/* future expansion */
  2    94     2 request_time float bin (63),                          /* How much request time was spent
  2    95*                                                                in LINUS. (-1 = user has just enabled 
  2    96*						    timing, do not report) */
  2    97     2 mrds_time float bin (63),                             /* How much time was spent in MRDS */
  2    98     2 build_increment fixed bin,			/* default increment for build mode */
  2    99     2 build_start fixed bin,				/* default start count for build mode */
  2   100     2 linus_version char (4),				/* current version of LINUS */
  2   101     2 subsystem_control_info_ptr ptr,                       /* the same ptr passed by ssu_ to each request procedure */
  2   102     2 subsystem_invocation_level fixed bin,                 /* identifies this invocation of LINUS */
  2   103     2 selection_expression_identifier fixed bin,            /* identifies the current processed selection expression */
  2   104     2 report_control_info_ptr ptr,			/* pointer to linus_report_control_info structure */
  2   105     2 table_control_info_ptr ptr,			/* pointer to linus_table control structure */
  2   106     2 temp_seg_info_ptr ptr,				/* pointer to linus_temp_seg_mgr control structure */
  2   107     2 query_temp_segment_ptr ptr,			/* points to temp seg used for manipulating query */
  2   108     2 general_work_area_ptr ptr,			/* a freeing area for general use */
  2   109     2 word_pad (6) bit (36) unal,
  2   110 						/* procedures that will be optionally */
  2   111 						/* replaced by the user.  Saved so they */
  2   112 						/* can be reinstated if desired. */
  2   113     2 ssu_abort_line entry options (variable),
  2   114     2 ssu_post_request_line variable entry (ptr),
  2   115     2 ssu_pre_request_line variable entry (ptr),
  2   116 
  2   117     2 curr_lit_offset fixed bin (35),			/* index of first free bit in lit. pool */
  2   118     2 curr_lv_val_offset fixed bin (35),		/* index of first free bit lv. val. pool */
  2   119     2 static_area area (sys_info$max_seg_size - fixed (rel (addr (lcb.static_area))) + 1);
  2   120 
  2   121 dcl  lcb_ptr ptr;
  2   122 
  2   123 /* END INCLUDE FILE linus_lcb.incl.pl1 */
      319 
  3     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  3     2 
  3     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  3     4 
  3     5 /* This include file contains branch and link structures returned by
  3     6*   hcs_$status_ and hcs_$status_long. */
  3     7 
  3     8 dcl 1 status_branch aligned based (status_ptr),
  3     9     2 short aligned,
  3    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  3    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  3    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  3    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  3    14       3 dtu bit (36) unaligned,			/* date/time last used */
  3    15       3 mode bit (5) unaligned,			/* caller's effective access */
  3    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  3    17       3 pad1 bit (8) unaligned,
  3    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  3    19 
  3    20 /* Limit of information returned by hcs_$status_ */
  3    21 
  3    22     2 long aligned,
  3    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  3    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  3    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  3    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  3    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  3    28       3 pad2 bit (8) unaligned,
  3    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  3    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  3    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  3    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  3    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  3    34       3 pad3 bit (5) unaligned,
  3    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  3    36       3 uid bit (36) unaligned;			/* unique ID */
  3    37 
  3    38 dcl 1 status_link aligned based (status_ptr),
  3    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  3    40     2 nnames fixed bin (16) unaligned unsigned,
  3    41     2 names_relp bit (18) unaligned,
  3    42     2 dtem bit (36) unaligned,
  3    43     2 dtd bit (36) unaligned,
  3    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  3    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  3    46 
  3    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  3    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  3    49 						/* array of names returned */
  3    50      status_pathname character (status_link.pathname_length) aligned
  3    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  3    52 						/* link target path */
  3    53      status_area_ptr pointer,
  3    54      status_ptr pointer;
  3    55 
  3    56 dcl (Link initial (0),
  3    57      Segment initial (1),
  3    58      Directory initial (2)) fixed bin internal static options (constant);
  3    59 						/* values for type fields declared above */
  3    60 
  3    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
      320 
      321 
      322      end linus_temp_seg_mgr;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/29/86  0939.7  linus_temp_seg_mgr.pl1            >special_ldd>install>MR12.0-1106>linus_temp_seg_mgr.pl1
318          1    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
319          2    07/29/86  0937.8  linus_lcb.incl.pl1                >special_ldd>install>MR12.0-1106>linus_lcb.incl.pl1
320          3    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_caller                               parameter       char                     unaligned dcl 31 ref 39 80 109 147 153 169 169 191
                                                                                  232
a_code                                 parameter       fixed bin(35,0)          dcl 35 set ref 39 47* 55* 60* 138* 147 153 161* 169*
                                                                                  174* 185* 191 199 203* 206* 208* 224* 236*
a_dir                                  parameter       char                     unaligned dcl 32 ref 39 49 51 147
a_lcb_ptr                              parameter       pointer                  dcl 30 ref 39 147 153 191 199 215
a_ptr                                  parameter       pointer                  dcl 34 set ref 39 147 151 191 195
a_ptrs                                 parameter       pointer                  array dcl 33 set ref 42 43 153 156 157
addr                                                   builtin function         dcl 292 ref 43 52 120 151 157 195
area                                   based           area(1024)               dcl 272 ref 69 89 92
area_control                           based           structure                level 1 dcl 1-20
area_info                              based           structure                level 1 dcl 1-7 set ref 225 238
area_infop                      000316 automatic       pointer                  dcl 1-5 set ref 225* 226 227 228 229 230 231 232 233
                                                                                  234 235 236* 238
area_p                          000100 automatic       pointer                  initial dcl 245 set ref 69 89 92 222* 223 237* 245*
areap                    16            based           pointer                  level 2 dcl 1-7 set ref 235*
array_ptr                       000102 automatic       pointer                  dcl 246 set ref 43* 82 132 151* 157* 163 167 179
                                                                                  195*
baseno                                                 builtin function         dcl 292 ref 118
bin                                                    builtin function         dcl 292 ref 118 120
block                                  based           structure                array level 1 dcl 273 set ref 69 91* 91 92
block_ptr                       000104 automatic       pointer                  initial dcl 247 set ref 66 69* 70 77 77 79 80 82 91
                                                                                  92 95* 108 109 110 113 118 122 128 130 132 142 166
                                                                                  167 169 172 176 178 205 205 206 240* 247*
caller                                 based           char(32)                 array level 2 dcl 273 set ref 80* 109* 169 178* 205*
code                            000106 automatic       fixed bin(35,0)          dcl 248 set ref 53* 54 55 58* 59 59 60 113* 114 122*
                                                                                  123 128* 138 142* 172* 174 174
com_err_                        000010 constant        entry                    external dcl 296 ref 205
containing_dir                  000107 automatic       char(168)                unaligned dcl 249 set ref 53* 58*
control                   1            based           structure                level 2 dcl 1-7
define_area_                    000012 constant        entry                    external dcl 297 ref 236
delete_$ptr                     000014 constant        entry                    external dcl 298 ref 142 206
digit                     0(24)        based           bit(3)                   array level 2 packed unaligned dcl 284 ref 120
dim                                                    builtin function         dcl 292 ref 42 156
dir_entryname                   000161 automatic       char(32)                 unaligned dcl 250 set ref 53* 58*
dir_name                        000171 automatic       char(168)                unaligned dcl 251 set ref 49* 51* 53* 113*
dir_uid                         000243 automatic       bit(36)                  unaligned dcl 252 set ref 64* 77 110
ename                           000244 automatic       char(20)                 unaligned dcl 253 set ref 112* 113* 122*
ename2                          000251 automatic       char(32)                 unaligned dcl 254 set ref 111* 112 120* 120 122* 130
error_table_$argerr             000044 external static fixed bin(35,0)          dcl 313 ref 169 185
error_table_$no_s_permission    000046 external static fixed bin(35,0)          dcl 314 ref 59
expand_pathname_                000016 constant        entry                    external dcl 299 ref 53
extend                    1            based           bit(1)                   level 3 packed unaligned dcl 1-7 set ref 227*
found_it                        000261 automatic       bit(1)                   unaligned dcl 255 set ref 164* 165 180* 185
get_pdir_                       000020 constant        entry                    external dcl 300 ref 49
get_temp_segment_               000022 constant        entry                    external dcl 301 ref 224
hcs_$chname_seg                 000024 constant        entry                    external dcl 302 ref 122
hcs_$make_seg                   000026 constant        entry                    external dcl 303 ref 113
hcs_$set_safety_sw_seg          000032 constant        entry                    external dcl 305 ref 128
hcs_$status_long                000030 constant        entry                    external dcl 304 ref 58
hcs_$truncate_seg               000034 constant        entry                    external dcl 306 ref 172
i                               000340 automatic       fixed bin(17,0)          dcl 105 in procedure "get_new_segments" set ref 107*
                                                                                  108 109 110 113 118 122 128 130 132* 141
i                               000262 automatic       fixed bin(17,0)          dcl 256 in procedure "linus_temp_seg_mgr" set ref
                                                                                  76* 77 77 79 80 82* 162* 163 167 179* 204* 205 205
                                                                                  206*
info_ptr                        000264 automatic       pointer                  dcl 257 set ref 67 70 93 95 139 208 217* 218 219*
                                                                                  220 222 224 235 237 240 241
j                               000266 automatic       fixed bin(17,0)          dcl 258 in procedure "linus_temp_seg_mgr" set ref
                                                                                  165* 166 167 169 172 176 178*
j                               000341 automatic       fixed bin(17,0)          dcl 105 in procedure "get_new_segments" set ref 119*
                                                                                  120 120* 141* 142*
lcb                                    based           structure                level 1 dcl 2-53
lcb_ptr                         000320 automatic       pointer                  dcl 2-121 set ref 209 215* 216 217 219 220
length                                                 builtin function         dcl 292 ref 169
long                      4     000304 automatic       structure                level 2 dcl 288
min                                                    builtin function         dcl 292 ref 169
n_blocks                        000267 automatic       fixed bin(17,0)          initial dcl 259 set ref 67* 69 76 86 87 91 92 93*
                                                                                  107 139* 165 204 241* 259*
n_found                         000270 automatic       fixed bin(17,0)          dcl 260 set ref 48* 76 81* 81 82 85 86 131* 131 132
n_segs                          000271 automatic       fixed bin(17,0)          dcl 261 set ref 42* 67 76 85 86 150* 156* 162 194*
name                     12            based           char(25)                 array level 2 dcl 273 set ref 130*
new_block                              based           structure                array level 1 dcl 283 ref 89
new_block_ptr                   000272 automatic       pointer                  dcl 262 set ref 89* 91 95
new_blocks                      000274 automatic       fixed bin(17,0)          dcl 263 set ref 86* 89 93
no_freeing                1(04)        based           bit(1)                   level 3 packed unaligned dcl 1-7 set ref 230*
null                                                   builtin function         dcl 292 ref 58 58 66 163 179 209 218 219 219 223 245
                                                                                  247
number_of_temp_segs                    based           fixed bin(17,0)          initial level 2 dcl 279 set ref 67* 93* 139* 219*
                                                                                  241
octal_digits                           based           structure                level 1 dcl 284
old_blocks                      000275 automatic       fixed bin(17,0)          dcl 264 set ref 71* 87* 107 139 141
owner                     2            based           char(32)                 level 2 packed unaligned dcl 1-7 set ref 232*
pad                       1(06)        based           bit(30)                  level 3 packed unaligned dcl 1-7 set ref 233*
ptrs                                   based           pointer                  array dcl 287 set ref 82* 132* 163 167 179*
release_temp_segment_           000036 constant        entry                    external dcl 307 ref 208
sci_ptr                         000276 automatic       pointer                  dcl 265 set ref 216*
seg_block_ptr             2            based           pointer                  initial level 2 dcl 279 set ref 70* 95* 219* 240
segment_number                  000300 automatic       fixed bin(17,0)          dcl 266 set ref 118* 120
segno                                  defined         char(1)                  array unaligned dcl 267 set ref 120*
segptr                   10            based           pointer                  array level 2 dcl 273 set ref 82 113* 118 122* 128*
                                                                                  132 142* 167 172* 206*
size                     13            based           fixed bin(18,0)          level 2 dcl 1-7 set ref 234*
static_area             144            based           area                     level 2 dcl 2-53 ref 219
status_branch                          based           structure                level 1 dcl 3-8
status_info                     000304 automatic       structure                level 1 unaligned dcl 288 set ref 52
status_ip                       000302 automatic       pointer                  dcl 268 set ref 52* 58*
substr                                                 builtin function         dcl 292 ref 112 120 130 169
subsystem_control_info_ptr
                        102            based           pointer                  level 2 dcl 2-53 ref 216
sys_info$max_seg_size           000050 external static fixed bin(35,0)          dcl 315 ref 234
system                    1(05)        based           bit(1)                   level 3 packed unaligned dcl 1-7 set ref 231*
temp_seg_info                          based           structure                level 1 unaligned dcl 279 set ref 219
temp_seg_info_ptr       112            based           pointer                  level 2 dcl 2-53 set ref 209* 217 220*
uid                      21            based           bit(36)                  array level 2 in structure "block" packed unaligned
                                                                                  dcl 273 in procedure "linus_temp_seg_mgr" set ref
                                                                                  77 110*
uid                      11     000304 automatic       bit(36)                  level 3 in structure "status_info" packed unaligned
                                                                                  dcl 288 in procedure "linus_temp_seg_mgr" set ref
                                                                                  64
unique_bits_                    000040 constant        entry                    external dcl 308 ref 111 111
unique_chars_                   000042 constant        entry                    external dcl 309 ref 111
used                     22            based           bit(1)                   array level 2 dcl 273 set ref 77 79* 108* 166 176*
                                                                                  205
version                                based           fixed bin(17,0)          level 2 dcl 1-7 set ref 226*
work_area_ptr             4            based           pointer                  initial level 2 dcl 279 set ref 208* 219* 222 224*
                                                                                  235 237
zero_on_alloc             1(01)        based           bit(1)                   level 3 packed unaligned dcl 1-7 set ref 228*
zero_on_free              1(02)        based           bit(1)                   level 3 packed unaligned dcl 1-7 set ref 229*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Directory                              internal static fixed bin(17,0)          initial dcl 3-56
Link                                   internal static fixed bin(17,0)          initial dcl 3-56
Segment                                internal static fixed bin(17,0)          initial dcl 3-56
area_info_version_1                    internal static fixed bin(17,0)          initial dcl 1-3
fixed                                                  builtin function         dcl 292
rel                                                    builtin function         dcl 292
status_area_ptr                        automatic       pointer                  dcl 3-47
status_entry_names                     based           char(32)                 array dcl 3-47
status_link                            based           structure                level 1 dcl 3-38
status_pathname                        based           char                     dcl 3-47
status_ptr                             automatic       pointer                  dcl 3-47

NAMES DECLARED BY EXPLICIT CONTEXT.
get_new_segments                001103 constant        entry                    internal dcl 102 ref 72 97
get_segment                     000425 constant        entry                    external dcl 147
get_segments                    000100 constant        entry                    external dcl 39
gts_join                        000141 constant        label                    dcl 45 ref 152
initialize                      001452 constant        entry                    internal dcl 212 ref 45 159 202
linus_temp_seg_mgr              000064 constant        entry                    external dcl 12
release_segment                 000661 constant        entry                    external dcl 191
release_segments                000465 constant        entry                    external dcl 153
rts_join                        000517 constant        label                    dcl 159 ref 196
terminate                       000713 constant        entry                    external dcl 199
undo                            001373 constant        entry                    internal dcl 135 ref 115 124

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2116        2170    1630        2126
Length      2462    1630        52         255     265           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
linus_temp_seg_mgr                  404 external procedure  is an external procedure.  
get_new_segments                        internal procedure  shares stack frame of external procedure linus_temp_seg_mgr.  
undo                                    internal procedure  shares stack frame of external procedure linus_temp_seg_mgr.  
initialize                              internal procedure  shares stack frame of external procedure linus_temp_seg_mgr.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
linus_temp_seg_mgr       000100 area_p                      linus_temp_seg_mgr
                         000102 array_ptr                   linus_temp_seg_mgr
                         000104 block_ptr                   linus_temp_seg_mgr
                         000106 code                        linus_temp_seg_mgr
                         000107 containing_dir              linus_temp_seg_mgr
                         000161 dir_entryname               linus_temp_seg_mgr
                         000171 dir_name                    linus_temp_seg_mgr
                         000243 dir_uid                     linus_temp_seg_mgr
                         000244 ename                       linus_temp_seg_mgr
                         000251 ename2                      linus_temp_seg_mgr
                         000261 found_it                    linus_temp_seg_mgr
                         000262 i                           linus_temp_seg_mgr
                         000264 info_ptr                    linus_temp_seg_mgr
                         000266 j                           linus_temp_seg_mgr
                         000267 n_blocks                    linus_temp_seg_mgr
                         000270 n_found                     linus_temp_seg_mgr
                         000271 n_segs                      linus_temp_seg_mgr
                         000272 new_block_ptr               linus_temp_seg_mgr
                         000274 new_blocks                  linus_temp_seg_mgr
                         000275 old_blocks                  linus_temp_seg_mgr
                         000276 sci_ptr                     linus_temp_seg_mgr
                         000300 segment_number              linus_temp_seg_mgr
                         000302 status_ip                   linus_temp_seg_mgr
                         000304 status_info                 linus_temp_seg_mgr
                         000316 area_infop                  linus_temp_seg_mgr
                         000320 lcb_ptr                     linus_temp_seg_mgr
                         000340 i                           get_new_segments
                         000341 j                           get_new_segments

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        return              shorten_stack       ext_entry
ext_entry_desc      alloc_based         alloc_based_storage free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      define_area_                  delete_$ptr                   expand_pathname_
get_pdir_                     get_temp_segment_             hcs_$chname_seg               hcs_$make_seg
hcs_$set_safety_sw_seg        hcs_$status_long              hcs_$truncate_seg             release_temp_segment_
unique_bits_                  unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$argerr           error_table_$no_s_permission  sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    245 000055       247 000057       259 000060        12 000063        39 000072        42 000126        43 000136
     45 000141        47 000142        48 000143        49 000144        51 000163        52 000166        53 000170
     54 000214        55 000216        56 000217        58 000220        59 000260        60 000265        61 000266
     64 000267        66 000271        67 000275        69 000300        70 000306        71 000310        72 000311
     73 000312        76 000313        77 000326        79 000337        80 000341        81 000350        82 000351
     84 000357        85 000361        86 000364        87 000370        89 000372        91 000400        92 000410
     93 000412        95 000415        97 000421       100 000422       147 000423       150 000453       151 000455
    152 000457       153 000460       156 000504       157 000514       159 000517       161 000520       162 000521
    163 000531       164 000537       165 000540       166 000551       167 000556       169 000567       172 000606
    174 000622       176 000625       178 000630       179 000634       180 000640       184 000642       185 000644
    187 000651       188 000653       191 000654       194 000702       195 000704       196 000706       199 000707
    202 000724       203 000725       204 000726       205 000735       206 001004       207 001045       208 001047
    209 001077       210 001102       102 001103       107 001104       108 001115       109 001121       110 001130
    111 001132       112 001172       113 001176       114 001241       115 001243       116 001244       118 001245
    119 001253       120 001261       121 001273       122 001275       123 001330       124 001332       125 001333
    128 001334       130 001353       131 001361       132 001362       133 001370       146 001372       135 001373
    138 001374       139 001376       141 001401       142 001413       143 001447       145 001451       212 001452
    215 001453       216 001457       217 001461       218 001463       219 001467       220 001501       222 001503
    223 001506       224 001512       225 001542       226 001546       227 001550       228 001552       229 001554
    230 001556       231 001560       232 001562       233 001570       234 001572       235 001575       236 001600
    237 001610       238 001613       240 001615       241 001620       242 001622


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
