	COMPILATION LISTING OF SEGMENT rmdb_add_rmdb_history
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1333.9 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 rmdb_add_rmdb_history:
        8 add_rmdb_history:
        9      proc (db_model_ptr, type_of_object_restructured, object_name,
       10 	operation, secondary_object_name, error_message, code);
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
       15*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
       16*     Add new operations create_(attribute domain), delete_(attribute domain),
       17*     rename_(attribute domain)
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /*
       22*   .		       BEGIN_DESCRIPTION
       23*   This procedure is used to record a database  restructuring  event
       24*   in the data model by allocating a rmdb_history_entry structure in
       25*   the data model and linking it to the  end  of  a  chain  of  such
       26*   structures   which   record   previous   events.   The  chain  is
       27*   doubly  linked with offsets to the first and last elements in the
       28*   data model.
       29*
       30*   There  are  three  objects  in  a  mrds  database  that  can   be
       31*   restructured:  domains,  attributes  and  relations.  Things like
       32*   indices and edit_procs  are  considered  part  of  relations  and
       33*   domains respectively.
       34*
       35*   This code has developed  it  own  data  structures  to  record  a
       36*   restructuring  event  rather  than  using  the changer structures
       37*   which are already in the data and file models and  were  designed
       38*   to  be  used  when  restructuring was implemented. The reason for
       39*   this is two fold. First the  changer  structures  are  associated
       40*   with  each  of  the  domain,  attribute,  and relation structures
       41*   therefore certain types of restructuring like adding a  secondary
       42*   index  to  a relation would see two changer structures allocated,
       43*   one for the relation  and  one  for  the  attribute.  Second  the
       44*   changer structures record only the date-time of the event and the
       45*   person id  who  did  it  but  not  what  was  done.  The  changer
       46*   structures  where  not removed from the data and file models when
       47*   this code  was  implemented  becuase  one  only  1  structure  is
       48*   actually  allocated  and  that  one contains the date-time of the
       49*   creation and the creator of the  database  which  is  still  very
       50*   usefull.  Second for compatability reasons the data base and file
       51*   models must remain the same size so the 18 bits used to store the
       52*   offset to the structure would still have to be in the models.
       53*
       54*   quits are delayed while the datamodel is actually being updated.
       55*   .		       END_DESCRIPTION
       56*
       57*   Known Bugs:
       58*
       59*   Other Problems:
       60*
       61*   .                       HISTORY
       62*   82-04-13 Davids: written
       63*
       64*   82-05-04 Davids: modified so that the rmdb_history_entry  list
       65*   .                is  doubly  linked  with offsets to the first
       66*   .                and last entries in the data model.
       67*
       68*   82-06-22 Davids: declared some implicitly  declared  builtins,
       69*   .                changed  call to clock_ to a reference to the
       70*   .                pl1  clock  builtin,  and  put  a  quit_delay
       71*   .                sequence around the allocate and link code.
       72*
       73*   82-07-07 Roger Lackey: added rmdb_add_history entry point for binding.
       74**/
       75 
       76    /* PARAMETERS */
       77 
       78 	dcl     db_model_ptr	 ptr;		/* (input) pointer to the database model */
       79 	dcl     type_of_object_restructured fixed bin;	/* (input) index indicating the type of
       80*						   .       object that has been restructured */
       81 	dcl     object_name		 char (32);	/* (input) name of the object that has been restructured */
       82 	dcl     operation		 fixed bin;	/* (input) index indicating the
       83*						   .       type of restructuring that was done */
       84 	dcl     secondary_object_name	 char (32);	/* (input) name of any secondary object involved with
       85*						   .       the restructuring, i.e. attr name that was indexed */
       86 	dcl     error_message	 char (500);	/* (output) standard error message */
       87 	dcl     code		 fixed bin (35);	/* (output) standard error code */
       88 
       89 /* INTERNAL AUTOMATIC */
       90 
       91 	dcl     last_rmdb_history_entry_ptr ptr;	/* pointer to last entry in history list */
       92 	dcl     new_rmdb_history_entry_ptr ptr;		/* pointer to the structure just allocated */
       93 	dcl     quit_signaled	 bit (1);		/* true if the user hit a quit during the
       94*                                                               execution of the critical region */
       95 
       96 /* INTERNAL CONSTANTS */
       97 
       98 	dcl     NULL_OFFSET		 bit (18) init ("111111111111111111"b) internal static options (constant);
       99 
      100 /* EXTERNAL CONSTANTS */
      101 
      102 	dcl     error_table_$action_not_performed fixed bin (35) ext static;
      103 	dcl     error_table_$area_too_small fixed bin (35) ext static;
      104 	dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
      105 
      106 
      107 /* ENTRIES */
      108 
      109 	dcl     get_group_id_	 entry () returns (char (32));
      110 	dcl     ioa_$rs		 entry () options (variable);
      111 
      112 /* CONDITIONS */
      113 
      114 	dcl     area		 condition;
      115 	dcl     quit		 condition;
      116 
      117 
      118 /* BUILTINS */
      119 
      120 	dcl     addr		 builtin;
      121 	dcl     clock		 builtin;
      122 	dcl     fixed		 builtin;
      123 	dcl     length		 builtin;
      124 	dcl     pointer		 builtin;
      125 	dcl     rel		 builtin;
      126 
      127 /* INCLUDES */
      128 
  1     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  1     6*     modified to save space occupied by model
  1     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  1     8*     to add mdbm_secured bit in db_model
  1     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  1    10*     collapsed the following into an unused_offset array:
  1    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  1    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  1    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  1    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  1    15*       unused_1
  1    16*     Also changed the name of unused_2 to restructuring_history_offset
  1    17*     and changed the comment on the changer structure to indicate
  1    18*     that it will contain on database creation information.
  1    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  1    20*     used one of the unused_offsets to point to a message which indicates
  1    21*     why the db is inconsistent. The offset will be null when the db is created
  1    22*     and set the first time the message is used. this is so it will be
  1    23*     consistent with existing data bases. Also added the message structure.
  1    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  1    25*     added the undo_request element to the message structure
  1    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  1    27*     changed unused_offset (12) to last_restructruring_history_offset and
  1    28*     changed restructuring_history_offset to first_restructuring_history_offset
  1    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  1    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  1    31*     1 => vfile database and 2 => page_file database. Up to this point all
  1    32*     database types were equal to 1.
  1    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  1    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  1    35*     flags. This will allow information about transactions and dm_file
  1    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  1    37*     change is compatable with all datamodels created by the released version
  1    38*     of mrds.
  1    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  1    40*     added the rollback_on flag to the db_type_flags since it appears that you
  1    41*     can have a dmfile database that requires transactions but does not have any
  1    42*     journalizing. Also switched the order of the transactions_needed and
  1    43*     concurrency_on flags - this makes the change compatable with existing
  1    44*     dmfile databases except when displaying the model since concurrency_on and
  1    45*     rollback_on will be off in the model even though the dmfile relations had
  1    46*     them on during creation.
  1    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  1    48*      Removed ctl_file_path_ptr.
  1    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  1    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  1    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  1    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  1    53*      in the flag word for rmdb copying.
  1    54*                                                   END HISTORY COMMENTS */
  1    55 
  1    56 
  1    57 /* this include file contains the structures that go into the make up
  1    58*   of the "db_model" segment in the model for the database.
  1    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  1    60*
  1    61*   the db_model structure goes at the base of the segment, and contains items unique to
  1    62*   the whole databse. in addition, it has an area of size to fill the
  1    63*   rest of a segment, that holds the lists of files and domains in the database.
  1    64*   these lists are singly forward linked lists. all "pointers" in the database model
  1    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  1    66*   since actual pointers are process dependent on segment number.
  1    67*   the remaining structures are first a path_entry one to save pathnames in,
  1    68*   and the stack_item and constent structures, used to save a boolean
  1    69*   expression in polish form, with the stack represented by a linked list.
  1    70*   the final structure is one for identifying the status of version information */
  1    71 
  1    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  1    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  1    74 	     2 db_type_flags      unal,
  1    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  1    76 	       3 unused	      (13) bit (1) unal,
  1    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  1    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  1    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  1    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  1    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  1    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  1    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  1    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  1    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  1    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  1    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  1    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  1    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  1    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  1    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  1    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  1    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  1    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  1    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  1    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  1    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  1    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  1    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  1   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  1   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  1   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  1   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  1   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  1   105 
  1   106      dcl	   dbm_ptr	      ptr;
  1   107 
  1   108 /* the files in the database each have a file_info containing
  1   109*   their name, the file_model for each file is found by initiating the
  1   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  1   111*   the file_info list is a singly linked list in definition order */
  1   112 
  1   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  1   114 	     2 file_name	      char (30),		/* name of file */
  1   115 	     2 file_id	      bit (36),		/* id number of file */
  1   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  1   117 	     2 unused	      unal bit (18);	/* for future expansion */
  1   118 
  1   119      dcl	   fi_ptr		      ptr;
  1   120 
  1   121 /* each domain used in the database will have a domain info saved in the db_model
  1   122*   segment. it describes the domain of the given name, and it's options.
  1   123*   the domain_info's form a singly linked list in definition order */
  1   124 
  1   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  1   126 	     2 name	      char (32),		/* name of domain */
  1   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  1   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  1   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  1   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  1   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  1   132 	     2 reserved	      bit (31) unal,
  1   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  1   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  1   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  1   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  1   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  1   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  1   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  1   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  1   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  1   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  1   143 	     2 str_err_path_ptr   unal bit (18),
  1   144 	     2 str_after_path_ptr unal bit (18),
  1   145 	     2 get_before_path_ptr unal bit (18),
  1   146 	     2 get_err_path_ptr   unal bit (18),
  1   147 	     2 get_after_path_ptr unal bit (18),
  1   148 	     2 mod_before_path_ptr unal bit (18),
  1   149 	     2 mod_err_path_ptr   unal bit (18),
  1   150 	     2 mod_after_path_ptr unal bit (18),
  1   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  1   152 	     2 unused_2	      unal bit (18),
  1   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  1   154 
  1   155      dcl	   di_ptr		      ptr;
  1   156 
  1   157 /* information necessary for attributes that are not used in any relation */
  1   158 
  1   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  1   160 	     2 name char (32),			/* name of attribute */
  1   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  1   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  1   163 	     2 unused (2) bit (18) unal;
  1   164 
  1   165      dcl     ua_ptr ptr;
  1   166 
  1   167 
  1   168 /* space saving pathname$entryname structure, to be allocated
  1   169*   only when a path$entry has to be saved, else only a bit(18)
  1   170*   offset takes up space in the main model structure */
  1   171 
  1   172      declare 1 path_entry	      based (path_entry_ptr),
  1   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  1   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  1   175 	     2 reserved	      unal bit (36);	/* for future use */
  1   176 
  1   177      declare path_entry_ptr	      ptr;
  1   178 
  1   179 
  1   180 
  1   181 
  1   182 
  1   183 /* declarations for model of postfix stack holding the check option boolean expression
  1   184*   the following encoding values indicate the corresponding type of stack element
  1   185*
  1   186*   1  =
  1   187*   2  ^=
  1   188*   3  >
  1   189*   4  <
  1   190*   5  >=
  1   191*   6  <=
  1   192*
  1   193*   10  and
  1   194*   20  or
  1   195*   30  not
  1   196*
  1   197*   40  - (minus)
  1   198*
  1   199*   50  domain variable(same name as domain)
  1   200*
  1   201*   60  constant(number, bit string, or character string)
  1   202*
  1   203**/
  1   204 
  1   205 
  1   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  1   207 	     2 next	      bit (18),		/* link to next in list */
  1   208 	     2 type	      fixed binary,		/* code for this element type */
  1   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  1   210*						   if this is a constant element type */
  1   211 
  1   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  1   213 
  1   214 
  1   215 
  1   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  1   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  1   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  1   219 
  1   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  1   221 
  1   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  1   223 
  1   224 /* version structure, giving status of source for CMDB/RMDB,
  1   225*   status of model, and status of resultant */
  1   226 
  1   227 /* version number is in form MM.N.Y
  1   228*   where MM is the major version number, N is the minor version alteration,
  1   229*   and Y is the lastest modification to that alteration,
  1   230*   where M and N represent numbers 0-9, and Y is a letter */
  1   231 
  1   232      declare 1 version_status	      unal based (version_status_ptr),
  1   233 	     2 cmdb_rmdb,
  1   234 	       3 major	      fixed bin,
  1   235 	       3 minor	      fixed bin,
  1   236 	       3 modification     char (4),
  1   237 	     2 model,
  1   238 	       3 major	      fixed bin,
  1   239 	       3 minor	      fixed bin,
  1   240 	       3 modification     char (4),
  1   241 	     2 resultant,
  1   242 	       3 major	      fixed bin,
  1   243 	       3 minor	      fixed bin,
  1   244 	       3 modification     char (4);
  1   245 
  1   246      declare version_status_ptr     ptr;
  1   247 
  1   248 
  1   249 /* maintains information only about the db creation */
  1   250 
  1   251      declare 1 changer	      unal based (changer_ptr),
  1   252 	     2 id		      char (32),
  1   253 	     2 time	      fixed bin (71),
  1   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  1   255 
  1   256      declare changer_ptr	      ptr;
  1   257 
  1   258 
  1   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  1   260 	     02 len	      fixed bin,		/* length of the message */
  1   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  1   262 	     02 name	      char (32),		/* name of thing that set the message */
  1   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  1   264*                                                               that caused the database to become inconsistent */
  1   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  1   266 
  1   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  1   268 
  1   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  1   270 
  1   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  1   272 
  1   273 
      129 
      130 
  2     1 /* BEGIN INCLUDE FILE rmdb_history_entry.incl.pl1 -- nsd, 82-04-09 */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(75-01-01,WhoKnows), approve(), audit(), install():
  2     7*     Written.
  2     8*  2) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
  2     9*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  2    10*     Added RMDB_ADD_(ATTR DMN)_OP, RMDB_RN_(ATTR DMN REL)_OP.
  2    11*                                                   END HISTORY COMMENTS */
  2    12 
  2    13 
  2    14 /*
  2    15*   This include file contains the rmdb_history_entry structure which
  2    16*   is  used for maintaining a history of the databases restructuring
  2    17*   events. It also contains a set of constants used in  loading  the
  2    18*   structure.
  2    19*
  2    20*   The restructuring history is applied against the  database  as  a
  2    21*   whole  instead of against each structure in the db_model and file
  2    22*   models which was the approach originally  implemented  but  never
  2    23*   really  used  (except  to  record the database creation). This is
  2    24*   because 1 database restructuring event, i.e. adding a  new  index
  2    25*   to a relation will change several of the structures in the model.
  2    26*
  2    27*   For a detailed explaination of the use of this structure and  the
  2    28*   constants see the rmdb_add_rmdb_event module.
  2    29**/
  2    30 
  2    31 dcl 01 rmdb_history_entry aligned based (rmdb_history_entry_ptr),
  2    32     02 user_id char (32),				/* person_id.project_id.tag */
  2    33     02 date_time_restructured fixed bin (71),
  2    34     02 type_of_object_restructured fixed bin,		/* taken from constants below */
  2    35     02 object_name char (32),
  2    36     02 operation fixed bin,				/* taken from constants below */
  2    37     02 secondary_object_name char (32),			/* i.e. name of attr just indexed in a restructured relation */
  2    38     02 offset_to_next_entry bit (18) unal,
  2    39     02 offset_to_previous_entry bit (18) unal;
  2    40 	
  2    41 
  2    42 dcl  rmdb_history_entry_ptr ptr;
  2    43 
  2    44 
  2    45 dcl  RMDB_DOMAIN_TYPE init (1) fixed bin internal static options (constant);
  2    46 dcl  RMDB_ATTR_TYPE init (2) fixed bin internal static options (constant);
  2    47 dcl  RMDB_REL_TYPE init (3) fixed bin internal static options (constant);
  2    48 
  2    49 
  2    50 dcl  RMDB_ADD_REL_OP init (1) fixed bin internal static options (constant);
  2    51 dcl  RMDB_DEL_REL_OP init (2) fixed bin internal static options (constant);
  2    52 dcl  RMDB_ADD_IDX_OP init (3) fixed bin internal static options (constant);
  2    53 dcl  RMDB_DEL_IDX_OP init (4) fixed bin internal static options (constant);
  2    54 dcl  RMDB_ADD_ATTR_OP init (5) fixed bin int static options (constant);
  2    55 dcl  RMDB_DEL_ATTR_OP init (6) fixed bin int static options (constant);
  2    56 dcl  RMDB_ADD_DMN_OP init (7) fixed bin int static options (constant);
  2    57 dcl  RMDB_DEL_DMN_OP init (8) fixed bin int static options (constant);
  2    58 dcl  RMDB_RN_ATTR_OP init (9) fixed bin int static options (constant);
  2    59 dcl  RMDB_RN_DMN_OP init (10) fixed bin int static options (constant);
  2    60 dcl  RMDB_RN_REL_OP init (11) fixed bin int static options (constant);
  2    61 
  2    62 /* END INCLUDE FILE rmdb_history_entry.incl.pl1 */
      131 
      132 
      133 /*
      134*   The user has not yet hit a quit
      135**/
      136 
      137 	quit_signaled = "0"b;
      138 
      139 
      140 
      141 /*
      142*   Check the ranges on the object_type and operation to be sure that
      143*   garbage will not be stored in the model.
      144**/
      145 
      146 
      147 	if type_of_object_restructured < 1 | type_of_object_restructured > RMDB_REL_TYPE
      148 	then do;
      149 		code = error_table_$action_not_performed;
      150 		call ioa_$rs ("type of object restructured indicator <^i> not within range of 1 -- ^i",
      151 		     error_message, length (error_message), type_of_object_restructured, RMDB_REL_TYPE);
      152 		goto exit_rmdb_add_rmdb_history;
      153 	     end;
      154 	else
      155 	     if operation < 1 | operation > RMDB_RN_REL_OP
      156 	then do;
      157 		code = error_table_$action_not_performed;
      158 		call ioa_$rs ("type of operation indicator <^i> not within range of 1 -- ^i",
      159 		     error_message, length (error_message), operation, RMDB_RN_REL_OP);
      160 		goto exit_rmdb_add_rmdb_history;
      161 	     end;
      162 	else do;
      163 		error_message = "";
      164 		code = 0;
      165 	     end;
      166 
      167 
      168 
      169 
      170 
      171 /*
      172*   In the event that the area in the data model  is  so  small  that
      173*   another  rmdb_history_event structure cannot be allocated, return
      174*   a suitable message to the user instead of having him blow up with
      175*   an area condition.
      176**/
      177 
      178 
      179 	on area begin;
      180 		error_message = "Area in model is not large enough to " ||
      181 		     "allocate another history entry - database will not be restructured";
      182 		code = error_table_$area_too_small;
      183 		goto exit_rmdb_add_rmdb_history;
      184 	     end;
      185 
      186 /*
      187*   Make sure that the caller  cannot  interrupt  while  the  history
      188*   entry is being added to the model. But if he hits a quit remember
      189*   so it can be signaled after the model is updated.
      190**/
      191 
      192 	on quit quit_signaled = "1"b;
      193 
      194 
      195 
      196 /*
      197*   allocate a new the rmdb_history_entry structure and fill it.
      198**/
      199 
      200 	allocate rmdb_history_entry set (new_rmdb_history_entry_ptr) in (db_model_ptr -> db_model.dbm_area);
      201 
      202 	new_rmdb_history_entry_ptr -> rmdb_history_entry.user_id = get_group_id_ ();
      203 	new_rmdb_history_entry_ptr -> rmdb_history_entry.date_time_restructured = clock;
      204 	new_rmdb_history_entry_ptr -> rmdb_history_entry.type_of_object_restructured = type_of_object_restructured;
      205 	new_rmdb_history_entry_ptr -> rmdb_history_entry.object_name = object_name;
      206 	new_rmdb_history_entry_ptr -> rmdb_history_entry.operation = operation;
      207 	new_rmdb_history_entry_ptr -> rmdb_history_entry.secondary_object_name = secondary_object_name;
      208 	new_rmdb_history_entry_ptr -> rmdb_history_entry.offset_to_next_entry = NULL_OFFSET;
      209 
      210 
      211 
      212 
      213 
      214 /*
      215*   Link  the  new  structure  to  the  end  of  the  chain.   If the
      216*   first_restructuring_history_offset  in  the  db_model  is null it
      217*   implies  that this is the first restructuring event and that this
      218*   structure   will   be   the   first   in   the   list.    If  the
      219*   restructuring_history_offset     is     not    null    use    the
      220*   last_restructuring_history_offset  to  find the last entry in the
      221*   list.     The    last    thing    done    is    to   update   the
      222*   last_restructuring_history_offset  in  the  data  model  with the
      223*   offset to the just created structure.
      224**/
      225 
      226 
      227 	if db_model_ptr -> db_model.first_restructuring_history_offset = NULL_OFFSET
      228 	then do;
      229 		db_model_ptr -> db_model.first_restructuring_history_offset = rel (new_rmdb_history_entry_ptr);
      230 		new_rmdb_history_entry_ptr -> rmdb_history_entry.offset_to_previous_entry = NULL_OFFSET;
      231 	     end;
      232 	else do;
      233 		last_rmdb_history_entry_ptr = pointer (db_model_ptr,
      234 		     db_model_ptr -> db_model.last_restructuring_history_offset);
      235 		last_rmdb_history_entry_ptr -> rmdb_history_entry.offset_to_next_entry = rel (new_rmdb_history_entry_ptr);
      236 		new_rmdb_history_entry_ptr -> rmdb_history_entry.offset_to_previous_entry =
      237 		     db_model_ptr -> db_model.last_restructuring_history_offset;
      238 	     end;
      239 
      240 	db_model_ptr -> db_model.last_restructuring_history_offset = rel (new_rmdb_history_entry_ptr);
      241 
      242 exit_rmdb_add_rmdb_history:
      243 
      244 /*
      245*   If the user hit a quit now is the time to signal it for him 
      246**/
      247 
      248 	if quit_signaled
      249 	then do;
      250 		revert quit;
      251 		signal quit;
      252 	     end;
      253 
      254 	return;
      255      end rmdb_add_rmdb_history;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1142.9  rmdb_add_rmdb_history.pl1         >special_ldd>install>MR12.0-1187>rmdb_add_rmdb_history.pl1
129          1    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
131          2    10/16/86  1139.6  rmdb_history_entry.incl.pl1       >special_ldd>install>MR12.0-1187>rmdb_history_entry.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NULL_OFFSET                            constant        bit(18)                  initial unaligned dcl 98 ref 208 227 230
RMDB_REL_TYPE                   000010 constant        fixed bin(17,0)          initial dcl 2-47 set ref 147 150*
RMDB_RN_REL_OP                  000000 constant        fixed bin(17,0)          initial dcl 2-60 set ref 154 158*
area                            000106 stack reference condition                dcl 114 ref 179
clock                                                  builtin function         dcl 121 ref 203
code                                   parameter       fixed bin(35,0)          dcl 87 set ref 7 7 149* 157* 164* 182*
date_time_restructured
                         10            based           fixed bin(71,0)          level 2 dcl 2-31 set ref 203*
db_model                               based           structure                level 1 dcl 1-72
db_model_ptr                           parameter       pointer                  dcl 78 ref 7 7 200 227 229 233 233 236 240
dbm_area                 34            based           area                     level 2 dcl 1-72 ref 200
error_message                          parameter       char(500)                unaligned dcl 86 set ref 7 7 150* 150 150 158* 158
                                                                                  158 163* 180*
error_table_$action_not_performed
                                000010 external static fixed bin(35,0)          dcl 102 ref 149 157
error_table_$area_too_small     000012 external static fixed bin(35,0)          dcl 103 ref 182
first_restructuring_history_offset
                         32            based           bit(18)                  level 2 packed unaligned dcl 1-72 set ref 227 229*
get_group_id_                   000014 constant        entry                    external dcl 109 ref 202
ioa_$rs                         000016 constant        entry                    external dcl 110 ref 150 158
last_restructuring_history_offset
                         31            based           bit(18)                  level 2 packed unaligned dcl 1-72 set ref 233 236
                                                                                  240*
last_rmdb_history_entry_ptr     000100 automatic       pointer                  dcl 91 set ref 233* 235
length                                                 builtin function         dcl 123 ref 150 150 158 158
new_rmdb_history_entry_ptr      000102 automatic       pointer                  dcl 92 set ref 200* 202 203 204 205 206 207 208 229
                                                                                  230 235 236 240
object_name              13            based           char(32)                 level 2 in structure "rmdb_history_entry" dcl 2-31
                                                                                  in procedure "add_rmdb_history" set ref 205*
object_name                            parameter       char(32)                 unaligned dcl 81 in procedure "add_rmdb_history" ref
                                                                                  7 7 205
offset_to_next_entry     34            based           bit(18)                  level 2 packed unaligned dcl 2-31 set ref 208* 235*
offset_to_previous_entry
                         34(18)        based           bit(18)                  level 2 packed unaligned dcl 2-31 set ref 230* 236*
operation                              parameter       fixed bin(17,0)          dcl 82 in procedure "add_rmdb_history" set ref 7 7
                                                                                  154 154 158* 206
operation                23            based           fixed bin(17,0)          level 2 in structure "rmdb_history_entry" dcl 2-31
                                                                                  in procedure "add_rmdb_history" set ref 206*
pointer                                                builtin function         dcl 124 ref 233
quit                            000114 stack reference condition                dcl 115 ref 192 250 251
quit_signaled                   000104 automatic       bit(1)                   unaligned dcl 93 set ref 137* 192* 242
rel                                                    builtin function         dcl 125 ref 229 235 240
rmdb_history_entry                     based           structure                level 1 dcl 2-31 set ref 200
secondary_object_name                  parameter       char(32)                 unaligned dcl 84 in procedure "add_rmdb_history" ref
                                                                                  7 7 207
secondary_object_name
                         24            based           char(32)                 level 2 in structure "rmdb_history_entry" dcl 2-31
                                                                                  in procedure "add_rmdb_history" set ref 207*
type_of_object_restructured            parameter       fixed bin(17,0)          dcl 79 in procedure "add_rmdb_history" set ref 7 7
                                                                                  147 147 150* 204
type_of_object_restructured
                         12            based           fixed bin(17,0)          level 2 in structure "rmdb_history_entry" dcl 2-31
                                                                                  in procedure "add_rmdb_history" set ref 204*
user_id                                based           char(32)                 level 2 dcl 2-31 set ref 202*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
RMDB_ADD_ATTR_OP                       internal static fixed bin(17,0)          initial dcl 2-54
RMDB_ADD_DMN_OP                        internal static fixed bin(17,0)          initial dcl 2-56
RMDB_ADD_IDX_OP                        internal static fixed bin(17,0)          initial dcl 2-52
RMDB_ADD_REL_OP                        internal static fixed bin(17,0)          initial dcl 2-50
RMDB_ATTR_TYPE                         internal static fixed bin(17,0)          initial dcl 2-46
RMDB_DEL_ATTR_OP                       internal static fixed bin(17,0)          initial dcl 2-55
RMDB_DEL_DMN_OP                        internal static fixed bin(17,0)          initial dcl 2-57
RMDB_DEL_IDX_OP                        internal static fixed bin(17,0)          initial dcl 2-53
RMDB_DEL_REL_OP                        internal static fixed bin(17,0)          initial dcl 2-51
RMDB_DOMAIN_TYPE                       internal static fixed bin(17,0)          initial dcl 2-45
RMDB_RN_ATTR_OP                        internal static fixed bin(17,0)          initial dcl 2-58
RMDB_RN_DMN_OP                         internal static fixed bin(17,0)          initial dcl 2-59
addr                                                   builtin function         dcl 120
alloc_length                           internal static fixed bin(35,0)          dcl 1-222
changer                                based           structure                level 1 packed unaligned dcl 1-251
changer_ptr                            automatic       pointer                  dcl 1-256
constant                               based           structure                level 1 unaligned dcl 1-216
constant_ptr                           automatic       pointer                  dcl 1-220
dbm_ptr                                automatic       pointer                  dcl 1-106
di_ptr                                 automatic       pointer                  dcl 1-155
domain_info                            based           structure                level 1 dcl 1-125
fi_ptr                                 automatic       pointer                  dcl 1-119
file_info                              based           structure                level 1 dcl 1-113
fixed                                                  builtin function         dcl 122
message_str                            based           structure                level 1 packed unaligned dcl 1-259
message_str_len                        automatic       fixed bin(17,0)          dcl 1-269
message_str_ptr                        automatic       pointer                  dcl 1-267
path_entry                             based           structure                level 1 packed unaligned dcl 1-172
path_entry_ptr                         automatic       pointer                  dcl 1-177
rmdb_history_entry_ptr                 automatic       pointer                  dcl 2-42
stack_item                             based           structure                level 1 unaligned dcl 1-206
stack_item_ptr                         automatic       pointer                  dcl 1-212
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 104
ua_ptr                                 automatic       pointer                  dcl 1-165
unreferenced_attribute                 based           structure                level 1 dcl 1-159
version_status                         based           structure                level 1 packed unaligned dcl 1-232
version_status_ptr                     automatic       pointer                  dcl 1-246

NAMES DECLARED BY EXPLICIT CONTEXT.
add_rmdb_history                000115 constant        entry                    external dcl 7
exit_rmdb_add_rmdb_history      000414 constant        label                    dcl 242 ref 152 160 183
rmdb_add_rmdb_history           000125 constant        entry                    external dcl 7

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       536         556     423         546
Length      1006     423        20         214     112           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
add_rmdb_history                    124 external procedure  is an external procedure.  
on unit on line 179                  64 on unit               
on unit on line 192                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
add_rmdb_history         000100 last_rmdb_history_entry_ptr add_rmdb_history
                         000102 new_rmdb_history_entry_ptr  add_rmdb_history
                         000104 quit_signaled               add_rmdb_history

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          tra_ext_1           signal_op           enable_op
ext_entry           int_entry           op_alloc_           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_group_id_                 ioa_$rs

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$area_too_small




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      7 000107       137 000132       147 000133       149 000141       150 000143       152 000177       154 000200
    157 000205       158 000207       160 000243       163 000244       164 000250       179 000251       180 000265
    182 000273       183 000275       192 000300       200 000320       202 000330       203 000343       204 000346
    205 000351       206 000355       207 000357       208 000363       227 000365       229 000373       230 000375
    231 000377       233 000400       235 000405       236 000407       240 000412       242 000414       250 000416
    251 000417       254 000422


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
