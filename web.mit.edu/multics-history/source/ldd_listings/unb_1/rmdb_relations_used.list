	COMPILATION LISTING OF SEGMENT rmdb_relations_used
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1340.1 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /* format: ^inddcls,^indattr,indnoniterend,^indnoniterdo,indend,tree,^case,insnl,comcol61,dclind5,declareind5,delnl */
        8 
        9 /*DESCRIPTION
       10*  Given a list of objects to delete (domains or attributes, depending upon
       11*  which entry point into this subroutine is used), this subroutine creates
       12*  a list of relations that are used along with a per-relation list of attributes
       13*  to be deleted in that relation. This list is then used in another subroutine
       14*  to create a new copy of those relations without the specified attributes.
       15*  The information to prepare these lists comes from the temporary crossreference
       16*  vfile.
       17**/
       18 
       19 /****^  HISTORY COMMENTS:
       20*  1) change(86-01-14,Spitzer), approve(86-01-14,MCR7311),
       21*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
       22*     written
       23*                                                   END HISTORY COMMENTS */
       24 
       25 rmdb_relations_used:
       26      proc;
       27 
       28 	return;					/* not an entry point */
       29 
       30 rmdb_relations_used$domains:
       31      entry (Irmdb_ctl_ptr, Idelete_object_info_ptr, Iarea_ptr, Odomain_list_ptr, Oattribute_list_ptr, Orelation_list_ptr,
       32 	Oerror_message, Ocode);
       33 
       34 	domain_entry = "1"b;
       35 	goto COMMON;
       36 
       37 rmdb_relations_used$attributes:
       38      entry (Irmdb_ctl_ptr, Idelete_object_info_ptr, Iarea_ptr, Odomain_list_ptr, Oattribute_list_ptr, Orelation_list_ptr,
       39 	Oerror_message, Ocode);
       40 
       41 	domain_entry = "0"b;
       42 	goto COMMON;
       43 
       44 COMMON:						/* copy input variables */
       45 	rmdb_ctl_ptr = Irmdb_ctl_ptr;
       46 	delete_object_info_ptr = Idelete_object_info_ptr;
       47 	user_area_ptr = Iarea_ptr;
       48 
       49 /* initialize output variables */
       50 	Odomain_list_ptr, Oattribute_list_ptr, Orelation_list_ptr = null;
       51 	Oerror_message = "";
       52 	Ocode = 0;
       53 
       54 	temp_ptrs (*) = null;
       55 	max_seg_size = sys_info$max_seg_size * 4;
       56 	db_path = rmdb_ctl.absolute_db_path;
       57 	local_iocb = rmdb_ctl.crossref_file_info.iocb_ptr;
       58 
       59 	on cleanup call cleaner;
       60 
       61 	call mdbm_util_$get_temp_segments_path (rmdb_ctl.temp_dir_path, myname, temp_ptrs, code);
       62 	if code ^= 0
       63 	then do;
       64 	     error_message = "Cannot get a temp segment in " || rtrim(rmdb_ctl.temp_dir_path) || ".";
       65 	     call error (code, error_message);
       66 	     end;
       67 	
       68 /* use the 1st temp segment for reading records from the crossref file */
       69 	crossref_info_record_ptr = temp_ptrs (1);
       70 
       71 /* Since we are now going to allocate lots of structures in the user area, set
       72*   up an area condition so we can return some intelligent error message if we
       73*   overflow it. */
       74 	on area call error (error_table_$area_too_small, "Input user area.");
       75 
       76 	if domain_entry
       77 	then do;					/* create and fill the domain_list structure */
       78 	     domain_list_count = delete_object_info.count;
       79 	     allocate domain_list in (user_area) set (domain_list_ptr);
       80 
       81 	     do domain_idx = 1 to domain_list_count;
       82 
       83 /* Get the domain record from the crossreference file */
       84 		call mdbm_util_$xref_find_record (local_iocb, DOMAIN_KEY_HEAD, delete_object_info.name (domain_idx),
       85 		     crossref_info_record_ptr, max_seg_size, error_message, code);
       86 		if code ^= 0
       87 		then if code = error_table_$no_record
       88 		     then call error (mrds_error_$no_model_dom, delete_object_info.name (domain_idx));
       89 		     else call error (code, error_message);
       90 
       91 /* It's there, fill in the domain_list entry */
       92 		domain_list.name (domain_idx) = make_name (delete_object_info.name (domain_idx));
       93 
       94 /* Create this domain's corresponding attribute_list structure (the list of
       95*   attributes that are used by this domain). If the domain is unreferenced,
       96*   this ptr will be set to null. */
       97 		if crossref_info_record.count = 0
       98 		then attribute_list_ptr = null;
       99 		else do;
      100 		     attribute_list_count = crossref_info_record.count;
      101 		     allocate attribute_list in (user_area) set (attribute_list_ptr);
      102 
      103 /* Fill in the attribute_list structure for this domain. This will contain the
      104*   list of attributes used within a single specific domain. */
      105 		     do attribute_list_idx = 1 to attribute_list_count;
      106 			attribute_list.name (attribute_list_idx) =
      107 			     make_name (crossref_info_record.object (attribute_list_idx));
      108 			end;			/* do attribute_list_idx */
      109 		     end;
      110 
      111 		domain_list.attribute_list_ptr (domain_idx) = attribute_list_ptr;
      112 		end;				/* do domain_idx */
      113 	     end;					/* if domain_entry */
      114 	else do;					/* must have entered through the attribute EP */
      115 
      116 /* Indicate there is no domain_list structure when entered through the domain
      117*   entry point. */
      118 	     domain_list_ptr = null;
      119 
      120 /* Create the attribute_list structure. */
      121 	     attribute_list_count = delete_object_info.count;
      122 	     allocate attribute_list in (user_area) set (attribute_list_ptr);
      123 
      124 /* Populate the attribute_list structure with the objects from the
      125*   delete_object_info structure. */
      126 	     do attribute_list_idx = 1 to attribute_list_count;
      127 		attribute_list.name (attribute_list_idx) = make_name (delete_object_info.name (attribute_list_idx));
      128 		attribute_list.attribute_ptr (attribute_list_idx) = null;
      129 		end;				/* do attribute_list_idx */
      130 	     end;
      131 
      132 /* Process the attribute_list structure, producing the list of relations used
      133*   in all the specified attributes. The list of unique relations is built upon
      134*   a temp segment and then copied into an allocated structure, as we don't know
      135*   a priori how many relations there will be. */
      136 	relation_list_ptr = temp_ptrs (2);
      137 	if domain_entry
      138 	then do domain_idx = 1 to domain_list.count;
      139 		attribute_list_ptr = domain_list.attribute_list_ptr (domain_idx);
      140 		call get_relation_names;
      141 		end;				/* do domain_idx */
      142 	else call get_relation_names;
      143 
      144 /* Create the relation_list structure that is to be returned to the caller. */
      145 	relation_list_count = relation_list.count;
      146 	allocate relation_list in (user_area) set (relation_list_ptr);
      147 
      148 /* Copy the contents of the temp_ptrs (2) -> relation_list.name into
      149*   relation_list_ptr -> relation_list.name. */
      150 	relation_list_ptr -> relation_list.name = temp_ptrs (2) -> relation_list.name;
      151 
      152 /* Now process the relation_list structure. We have to initiate the relation.m
      153*   segments and create a relation structure for each referenced relation. Note
      154*   that we don't have to terminate the segments because we will 1) leave the
      155*   pointer to it in the relation structure, and 2) we will shortly delete the
      156*   segment anyway. */
      157 
      158 	do relation_idx = 1 to relation_list.count;
      159 	     relation_model_name = rtrim (unmake_name (relation_list.name (relation_idx))) || ".m";
      160 	     call initiate_file_ (db_path, relation_model_name, RW_ACCESS, fm_ptr, (0), code);
      161 	     if code ^= 0
      162 	     then call error (code, "Initiating " || pathname_ (db_path, relation_model_name));
      163 
      164 /* Get attribute count of this relation from the relation_info structure in the
      165*   file_model. */
      166 	     ri_ptr = ptr (fm_ptr, file_model.rel_ptr);
      167 	     relation_attribute_count = rel_info.num_attr;
      168 
      169 /* Create and populate the relation structure for this relation. */
      170 	     allocate relation in (user_area) set (relation_ptr);
      171 	     relation.name = unmake_name (relation_list.name (relation_idx));
      172 	     relation.file_model_ptr = fm_ptr;
      173 
      174 	     relation_list.relation_ptr (relation_idx) = relation_ptr;
      175 
      176 /* Fill in the list of attributes in this relation. */
      177 	     ai_ptr = ptr (fm_ptr, rel_info.attr_ptr);
      178 	     do attribute_idx = 1 to relation_attribute_count;
      179 		unspec (relation.attribute (attribute_idx).flags) = "0"b;
      180 		relation.attribute.attribute_info_ptr (attribute_idx) = ai_ptr;
      181 		relation.attribute.domain_info_ptr (attribute_idx) = attr_info.domain_ptr;
      182 		relation.attribute_names (attribute_idx) = make_name ((attr_info.name));
      183 		relation.attribute.flags.part_of_key (attribute_idx) = attr_info.key_attr;
      184 		ai_ptr = ptr (fm_ptr, attr_info.fwd_thread);
      185 		end;				/* do attribute_idx */
      186 	     end;					/* relation_idx */
      187 
      188 /* Finally, we need to turn on the delete flag for each attribute in each
      189*   referenced relation that is to be deleted. */
      190 	if domain_entry
      191 	then do domain_idx = 1 to domain_list.count;
      192 		attribute_list_ptr = domain_list.attribute_list_ptr (domain_idx);
      193 		call mark_deleted_attributes;
      194 		end;				/* do domain_idx */
      195 	else call mark_deleted_attributes;
      196 
      197 /* Return the pointers to the structures we have just generated. */
      198 	Orelation_list_ptr = relation_list_ptr;
      199 	Oattribute_list_ptr = attribute_list_ptr;
      200 	Odomain_list_ptr = domain_list_ptr;
      201 
      202 	call error (0, "");
      203 
      204 make_name:
      205      proc (input_name) returns (char (33));
      206 
      207 dcl  input_name char (*) parameter;
      208 
      209 	return (OBJECT_HEAD || input_name);
      210      end make_name;
      211 
      212 unmake_name:
      213      proc (input_name) returns (char (32));
      214 
      215 dcl  input_name char (33) parameter;
      216 
      217 	return (substr (input_name, 2, 32));
      218      end unmake_name;
      219 
      220 /* Process the current attribute_list structure: retrieve the attribute
      221*   crossreference record for each attribute (this contains the list of relations
      222*   that the attribute is used within). Search the relation_list structure for
      223*   each relation. If it is not found, add the relation to the end of the
      224*   relation_list. Then place the index of that relation in the attribute
      225*   structure. */
      226 
      227 get_relation_names:
      228      proc;
      229 
      230 dcl  attribute_name char (32);
      231 dcl  search_name char (33);
      232 dcl  position fixed bin;
      233 
      234 	do attribute_list_idx = 1 to attribute_list.count;
      235 	     attribute_name =unmake_name (attribute_list.name (attribute_list_idx));
      236 	     call mdbm_util_$xref_find_record (local_iocb, ATTRIBUTE_KEY_HEAD,
      237 		attribute_name, crossref_info_record_ptr, max_seg_size,
      238 		error_message, code);
      239 	     if code ^= 0
      240 	     then if code = error_table_$no_record
      241 		then call error (mrds_error_$no_model_attr, attribute_name);
      242 		else call error (code, error_message);
      243 
      244 	     if crossref_info_record.count = 0
      245 	     then attribute_list.attribute_ptr (attribute_list_idx) = null;
      246 	     else do;
      247 
      248 /* Create the attribute structure. */
      249 		attribute_count = crossref_info_record.count;
      250 		allocate attribute in (user_area) set (attribute_ptr);
      251 
      252 /* Each relation in the current crossref_info_record contains the attribute that
      253*   we are processing now. Place the index of each referenced relation (in the
      254*   relation_list structure) in the attribute structure. */
      255 		do attribute_idx = 1 to attribute_count;
      256 		     search_name = substr (crossref_info_record_objects, 1 + (33 * (attribute_idx - 1)), 33);
      257 		     position = index (relation_list_names, search_name);
      258 
      259 		     if position = 0
      260 		     then do;			/* add it on the end */
      261 			position, relation_list.count = relation_list.count + 1;
      262 			relation_list.name (position) = search_name;
      263 			end;
      264 		     else position = divide (position, 33, 17, 0) + 1;
      265 
      266 		     attribute.relation_idx (attribute_idx) = position;
      267 
      268 		     end;				/* do attribute_idx */
      269 
      270 		attribute_list.attribute_ptr (attribute_list_idx) = attribute_ptr;
      271 		end;
      272 
      273 	     attribute_list.domain_info_ptr (attribute_list_idx) = crossref_info_record.offset;
      274 	     end;					/* do attribute_list_idx */
      275 
      276 	return;
      277      end get_relation_names;
      278 
      279 /*DESCRIPTION
      280*  Take the list pointed to by the current attribute_list_ptr, processing it
      281*  by marking all attributes in the referenced relation to be deleted. */
      282 
      283 mark_deleted_attributes:
      284      proc;
      285 
      286 dcl  position fixed bin;
      287 dcl  search_name char (33);
      288 
      289 	do attribute_list_idx = 1 to attribute_list.count;
      290 	     attribute_ptr = attribute_list.attribute_ptr (attribute_list_idx);
      291 	     if attribute_ptr ^= null
      292 	     then do;				/* the attribute was referenced in at least a single relation */
      293 		search_name = attribute_list.name (attribute_list_idx);
      294 		do attribute_idx = 1 to attribute.count;
      295 		     relation_ptr = relation_list.relation_ptr (attribute.relation_idx (attribute_idx));
      296 		     position = index (relation_attribute_names, search_name);
      297 		     if position ^= 0
      298 		     then do;			/* found the place, mark the attribute to be deleted */
      299 			position = divide (position, 33, 17, 0) + 1;
      300 			relation.attribute (position).flags.delete = "1"b;
      301 			end;
      302 		     end;				/* do attribute_idx */
      303 		end;
      304 	     end;					/* do attribute_list_idx */
      305 
      306 	return;
      307      end mark_deleted_attributes;
      308 
      309 /*DESCRIPTION
      310*  Error handler and cleanup handler. This is the only way to exit these
      311*  subroutines.
      312**/
      313 
      314 error:
      315      proc (code, msg);
      316 
      317 dcl  code fixed bin (35) parameter;
      318 dcl  msg char (*) parameter;
      319 
      320 	Ocode = code;
      321 	Oerror_message = msg;
      322 	goto RETURN_TO_CALLER;
      323      end error;
      324 
      325 RETURN_TO_CALLER:
      326 	call cleaner;
      327 	return;
      328 
      329 cleaner:
      330      proc;
      331 
      332 dcl  cleaner_code fixed bin (35);
      333 
      334 	if temp_ptrs (1) ^= null
      335 	then call mdbm_util_$free_temp_segments (myname, temp_ptrs, cleaner_code);
      336 
      337 	return;
      338      end cleaner;
      339 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      340 
  2     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  2     6*     modified to save space occupied by model
  2     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  2     8*     to add mdbm_secured bit in db_model
  2     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  2    10*     collapsed the following into an unused_offset array:
  2    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  2    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  2    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  2    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  2    15*       unused_1
  2    16*     Also changed the name of unused_2 to restructuring_history_offset
  2    17*     and changed the comment on the changer structure to indicate
  2    18*     that it will contain on database creation information.
  2    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  2    20*     used one of the unused_offsets to point to a message which indicates
  2    21*     why the db is inconsistent. The offset will be null when the db is created
  2    22*     and set the first time the message is used. this is so it will be
  2    23*     consistent with existing data bases. Also added the message structure.
  2    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  2    25*     added the undo_request element to the message structure
  2    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  2    27*     changed unused_offset (12) to last_restructruring_history_offset and
  2    28*     changed restructuring_history_offset to first_restructuring_history_offset
  2    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  2    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  2    31*     1 => vfile database and 2 => page_file database. Up to this point all
  2    32*     database types were equal to 1.
  2    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  2    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  2    35*     flags. This will allow information about transactions and dm_file
  2    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  2    37*     change is compatable with all datamodels created by the released version
  2    38*     of mrds.
  2    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  2    40*     added the rollback_on flag to the db_type_flags since it appears that you
  2    41*     can have a dmfile database that requires transactions but does not have any
  2    42*     journalizing. Also switched the order of the transactions_needed and
  2    43*     concurrency_on flags - this makes the change compatable with existing
  2    44*     dmfile databases except when displaying the model since concurrency_on and
  2    45*     rollback_on will be off in the model even though the dmfile relations had
  2    46*     them on during creation.
  2    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  2    48*      Removed ctl_file_path_ptr.
  2    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  2    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  2    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  2    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  2    53*      in the flag word for rmdb copying.
  2    54*                                                   END HISTORY COMMENTS */
  2    55 
  2    56 
  2    57 /* this include file contains the structures that go into the make up
  2    58*   of the "db_model" segment in the model for the database.
  2    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  2    60*
  2    61*   the db_model structure goes at the base of the segment, and contains items unique to
  2    62*   the whole databse. in addition, it has an area of size to fill the
  2    63*   rest of a segment, that holds the lists of files and domains in the database.
  2    64*   these lists are singly forward linked lists. all "pointers" in the database model
  2    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  2    66*   since actual pointers are process dependent on segment number.
  2    67*   the remaining structures are first a path_entry one to save pathnames in,
  2    68*   and the stack_item and constent structures, used to save a boolean
  2    69*   expression in polish form, with the stack represented by a linked list.
  2    70*   the final structure is one for identifying the status of version information */
  2    71 
  2    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  2    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  2    74 	     2 db_type_flags      unal,
  2    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  2    76 	       3 unused	      (13) bit (1) unal,
  2    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  2    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  2    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  2    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  2    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  2    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  2    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  2    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  2    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  2    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  2    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  2    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  2    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  2    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  2    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  2    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  2    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  2    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  2    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  2    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  2    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  2    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  2    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  2   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  2   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  2   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  2   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  2   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  2   105 
  2   106      dcl	   dbm_ptr	      ptr;
  2   107 
  2   108 /* the files in the database each have a file_info containing
  2   109*   their name, the file_model for each file is found by initiating the
  2   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  2   111*   the file_info list is a singly linked list in definition order */
  2   112 
  2   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  2   114 	     2 file_name	      char (30),		/* name of file */
  2   115 	     2 file_id	      bit (36),		/* id number of file */
  2   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  2   117 	     2 unused	      unal bit (18);	/* for future expansion */
  2   118 
  2   119      dcl	   fi_ptr		      ptr;
  2   120 
  2   121 /* each domain used in the database will have a domain info saved in the db_model
  2   122*   segment. it describes the domain of the given name, and it's options.
  2   123*   the domain_info's form a singly linked list in definition order */
  2   124 
  2   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  2   126 	     2 name	      char (32),		/* name of domain */
  2   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  2   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  2   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  2   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  2   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  2   132 	     2 reserved	      bit (31) unal,
  2   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  2   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  2   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  2   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  2   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  2   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  2   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  2   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  2   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  2   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  2   143 	     2 str_err_path_ptr   unal bit (18),
  2   144 	     2 str_after_path_ptr unal bit (18),
  2   145 	     2 get_before_path_ptr unal bit (18),
  2   146 	     2 get_err_path_ptr   unal bit (18),
  2   147 	     2 get_after_path_ptr unal bit (18),
  2   148 	     2 mod_before_path_ptr unal bit (18),
  2   149 	     2 mod_err_path_ptr   unal bit (18),
  2   150 	     2 mod_after_path_ptr unal bit (18),
  2   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  2   152 	     2 unused_2	      unal bit (18),
  2   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  2   154 
  2   155      dcl	   di_ptr		      ptr;
  2   156 
  2   157 /* information necessary for attributes that are not used in any relation */
  2   158 
  2   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  2   160 	     2 name char (32),			/* name of attribute */
  2   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  2   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  2   163 	     2 unused (2) bit (18) unal;
  2   164 
  2   165      dcl     ua_ptr ptr;
  2   166 
  2   167 
  2   168 /* space saving pathname$entryname structure, to be allocated
  2   169*   only when a path$entry has to be saved, else only a bit(18)
  2   170*   offset takes up space in the main model structure */
  2   171 
  2   172      declare 1 path_entry	      based (path_entry_ptr),
  2   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  2   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  2   175 	     2 reserved	      unal bit (36);	/* for future use */
  2   176 
  2   177      declare path_entry_ptr	      ptr;
  2   178 
  2   179 
  2   180 
  2   181 
  2   182 
  2   183 /* declarations for model of postfix stack holding the check option boolean expression
  2   184*   the following encoding values indicate the corresponding type of stack element
  2   185*
  2   186*   1  =
  2   187*   2  ^=
  2   188*   3  >
  2   189*   4  <
  2   190*   5  >=
  2   191*   6  <=
  2   192*
  2   193*   10  and
  2   194*   20  or
  2   195*   30  not
  2   196*
  2   197*   40  - (minus)
  2   198*
  2   199*   50  domain variable(same name as domain)
  2   200*
  2   201*   60  constant(number, bit string, or character string)
  2   202*
  2   203**/
  2   204 
  2   205 
  2   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  2   207 	     2 next	      bit (18),		/* link to next in list */
  2   208 	     2 type	      fixed binary,		/* code for this element type */
  2   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  2   210*						   if this is a constant element type */
  2   211 
  2   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  2   213 
  2   214 
  2   215 
  2   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  2   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  2   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  2   219 
  2   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  2   221 
  2   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  2   223 
  2   224 /* version structure, giving status of source for CMDB/RMDB,
  2   225*   status of model, and status of resultant */
  2   226 
  2   227 /* version number is in form MM.N.Y
  2   228*   where MM is the major version number, N is the minor version alteration,
  2   229*   and Y is the lastest modification to that alteration,
  2   230*   where M and N represent numbers 0-9, and Y is a letter */
  2   231 
  2   232      declare 1 version_status	      unal based (version_status_ptr),
  2   233 	     2 cmdb_rmdb,
  2   234 	       3 major	      fixed bin,
  2   235 	       3 minor	      fixed bin,
  2   236 	       3 modification     char (4),
  2   237 	     2 model,
  2   238 	       3 major	      fixed bin,
  2   239 	       3 minor	      fixed bin,
  2   240 	       3 modification     char (4),
  2   241 	     2 resultant,
  2   242 	       3 major	      fixed bin,
  2   243 	       3 minor	      fixed bin,
  2   244 	       3 modification     char (4);
  2   245 
  2   246      declare version_status_ptr     ptr;
  2   247 
  2   248 
  2   249 /* maintains information only about the db creation */
  2   250 
  2   251      declare 1 changer	      unal based (changer_ptr),
  2   252 	     2 id		      char (32),
  2   253 	     2 time	      fixed bin (71),
  2   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  2   255 
  2   256      declare changer_ptr	      ptr;
  2   257 
  2   258 
  2   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  2   260 	     02 len	      fixed bin,		/* length of the message */
  2   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  2   262 	     02 name	      char (32),		/* name of thing that set the message */
  2   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  2   264*                                                               that caused the database to become inconsistent */
  2   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  2   266 
  2   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  2   268 
  2   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  2   270 
  2   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  2   272 
  2   273 
      341 
  3     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  3     6*     modified to save space occupied by model
  3     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  3     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  3     9*     the number of secondary indices in the relation - it was always zero.
  3    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  3    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  3    12*     DMS conversion.
  3    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  3    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  3    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  3    16*     for relation manager changes.
  3    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  3    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  3    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  3    20*     <rel> files are good (for rmdb)
  3    21*                                                   END HISTORY COMMENTS */
  3    22 
  3    23 
  3    24 /* each file in the database will have a model segment with the name
  3    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  3    26*   the file_model structure is allocated at the base of the segment for a given file.
  3    27*   it contains an area with which all other structures in this include file are allocated.
  3    28*   these structures contain the information about which relations, foreign keys,
  3    29*   and attributes are members of this file. all lists are singly linked lists in
  3    30*   definition order. pointers to these structures are obtained by using the "pointer"
  3    31*   builtin function with arguments of the segment base pointer, and the
  3    32*   offset (bit (18)) relative to that pointer that is actually stored in
  3    33*   the file model itself. this is because pointer segment numbers are
  3    34*   per process dependent. the major lists pointed to by the file_model structure
  3    35*   are the list of relations in this file(each with a contained attribute list),
  3    36*   and the list of foreign keys whose parent relation resides in this file
  3    37*   (along with a participating attribute sublist, and the child relation list,
  3    38*   if they are also in this file) */
  3    39 
  3    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  3    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  3    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  3    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  3    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  3    45     2 reserved bit (32) unal,				/* reserved for future flags */
  3    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  3    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  3    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  3    49     2 pad_1 fixed bin (35),				/* for future use */
  3    50     2 pad_2 fixed bin (35),
  3    51     2 ratd_len fixed bin (21),			/* length of above */
  3    52     2 mratd_len fixed bin (21),			/* length of above */
  3    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  3    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  3    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  3    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  3    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  3    58     2 block_size unal fixed bin,			/* no. pages in block */
  3    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  3    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  3    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  3    62     2 num_rels unal fixed bin,			/* number of relations in file */
  3    63     2 num_links unal fixed bin,			/* number of links in file */
  3    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  3    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  3    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  3    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  3    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  3    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  3    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  3    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  3    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  3    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  3    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  3    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  3    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  3    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  3    78     2 open_eu_err_path_ptr unal bit (18),
  3    79     2 open_eu_after_path_ptr unal bit (18),
  3    80     2 open_er_before_path_ptr unal bit (18),
  3    81     2 open_er_err_path_ptr unal bit (18),
  3    82     2 open_er_after_path_ptr unal bit (18),
  3    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  3    84     2 open_neu_err_path_ptr unal bit (18),
  3    85     2 open_neu_after_path_ptr unal bit (18),
  3    86     2 open_ner_before_path_ptr unal bit (18),
  3    87     2 open_ner_err_path_ptr unal bit (18),
  3    88     2 open_ner_after_path_ptr unal bit (18),
  3    89     2 open_pu_before_path_ptr unal bit (18),
  3    90     2 open_pu_err_path_ptr unal bit (18),
  3    91     2 open_pu_after_path_ptr unal bit (18),
  3    92     2 open_pr_before_path_ptr unal bit (18),
  3    93     2 open_pr_err_path_ptr unal bit (18),
  3    94     2 open_pr_after_path_ptr unal bit (18),
  3    95     2 open_cu_before_path_ptr unal bit (18),
  3    96     2 open_cu_err_path_ptr unal bit (18),
  3    97     2 open_cu_after_path_ptr unal bit (18),
  3    98     2 open_cr_before_path_ptr unal bit (18),
  3    99     2 open_cr_err_path_ptr unal bit (18),
  3   100     2 open_cr_after_path_ptr unal bit (18),
  3   101     2 close_before_path_ptr unal bit (18),
  3   102     2 close_err_path_ptr unal bit (18),
  3   103     2 close_after_path_ptr unal bit (18),
  3   104     2 unused_1 unal bit (18),				/* for future expansion */
  3   105     2 unused_2 unal bit (18),
  3   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  3   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  3   108 dcl  fm_ptr ptr;
  3   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  3   110 dcl  atd_ptr ptr;
  3   111 dcl  atd_len fixed bin;
  3   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  3   113     2 ncomponents fixed bin,
  3   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  3   115 dcl  cna_ptr ptr;
  3   116 dcl  ncomp_init fixed bin;
  3   117 
  3   118 /* a rel_info structure contains information describing a relation.
  3   119*   a relation may only occur in one file, thus there is one rel_info
  3   120*   per relation per database, each stored in the file_model area for
  3   121*   the file that contains it. the list of rel_info's in this file
  3   122*   form a singly linked list in definition order.
  3   123*   the rel_info itself points to a list of the attributes it contains,
  3   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  3   125 
  3   126 dcl 1 rel_info aligned based (ri_ptr),
  3   127     2 name char (32),				/* relation name */
  3   128     2 id  bit (36) aligned,				/* relation id number */
  3   129     2 hashed bit (1) unal,				/* on if hashed */
  3   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  3   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  3   132     2 system bit (1) unal,				/* on if dont care how stored */
  3   133     2 indexed bit (1) unal,				/* on if secondary index */
  3   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  3   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  3   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  3   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  3   138     2 reserved bit (27) unal,				/* for future flags */
  3   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  3   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  3   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  3   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  3   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  3   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  3   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  3   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  3   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  3   148     2 unused_3 unal fixed bin,			/* element that was never used */
  3   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  3   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  3   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  3   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  3   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  3   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  3   155     2 attr_ptr unal bit (18),				/* to attr. info */
  3   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  3   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  3   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  3   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  3   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  3   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  3   162     2 link_err_path_ptr unal bit (18),
  3   163     2 link_after_path_ptr unal bit (18),
  3   164     2 unlk_before_path_ptr unal bit (18),
  3   165     2 unlk_err_path_ptr unal bit (18),
  3   166     2 unlk_after_path_ptr unal bit (18),
  3   167     2 str_before_path_ptr unal bit (18),
  3   168     2 str_err_path_ptr unal bit (18),
  3   169     2 str_after_path_ptr unal bit (18),
  3   170     2 del_before_path_ptr unal bit (18),
  3   171     2 del_err_path_ptr unal bit (18),
  3   172     2 del_after_path_ptr unal bit (18),
  3   173     2 mod_before_path_ptr unal bit (18),
  3   174     2 mod_err_path_ptr unal bit (18),
  3   175     2 mod_after_path_ptr unal bit (18),
  3   176     2 find_before_path_ptr unal bit (18),
  3   177     2 find_err_path_ptr unal bit (18),
  3   178     2 find_after_path_ptr unal bit (18),
  3   179     2 retr_before_path_ptr unal bit (18),
  3   180     2 retr_err_path_ptr unal bit (18),
  3   181     2 retr_after_path_ptr unal bit (18),
  3   182     2 unused_1 unal bit (18),				/* for future expansion */
  3   183     2 unused_2 unal bit (18),
  3   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  3   185 dcl  ri_ptr ptr;
  3   186 
  3   187 /* a attr_info structure contains information about an attribute in a given relation.
  3   188*   since attributes may appear in more than one relation, each occurence of an attribute
  3   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  3   190*   the list is singly linked in definition order. the attr_info describes
  3   191*   the data it represents, and how that data is used during a database search. */
  3   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  3   193     2 name char (32),				/* name of attribute */
  3   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  3   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  3   196     2 link_attr bit (1) unal,				/* on if participates in link */
  3   197     2 reserved bit (33) unal,
  3   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  3   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  3   200     2 key_order unal fixed bin,			/* relative posit. in key */
  3   201     2 bit_offset fixed bin (35),			/* position in tuple */
  3   202     2 bit_length fixed bin (35),			/* length if fixed */
  3   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  3   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  3   205     2 domain_ptr unal bit (18),			/* to domain info */
  3   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  3   207     2 fwd_thread unal bit (18),			/* to next in list */
  3   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  3   209 dcl  ai_ptr ptr;
  3   210 
  3   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  3   212*   each time a foreign key definition indicates a relation as it's parent,
  3   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  3   214*   a relation can be parent and/or child in any number of foreign keys.
  3   215*   the parent_link_info structure describes the foreign key, and also points
  3   216*   to a list of the attributes that participate in this foreign key.
  3   217*   (this could be from 1 up to all attributes in the relation)
  3   218*   the attr_list structures are in a singly linked list in definition order
  3   219*   for this purpose. also pointed to is a list of child_link_info's
  3   220*   that describe the child relations in this foreign key. since foreign keys
  3   221*   may span files, not all related child_link_info's have to be in this file's
  3   222*   model area. */
  3   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  3   224     2 name char (32),				/* name of link */
  3   225     2 singular bit (1) unal,				/* on if system owned link */
  3   226     2 temp bit (1) unal,				/* on if temp. order */
  3   227     2 first bit (1) unal,				/* insertion indicators */
  3   228     2 last bit (1) unal,
  3   229     2 next bit (1) unal,
  3   230     2 prior bit (1) unal,
  3   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  3   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  3   233     2 dup_first bit (1) unal,				/* duplicates first */
  3   234     2 dup_last bit (1) unal,				/* duplicates last */
  3   235     2 indexed bit (1) unal,				/* locate parent via index */
  3   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  3   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  3   238     2 thread_27 bit (1) unal,
  3   239     2 thread_18 bit (1) unal,
  3   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  3   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  3   242     2 reserved bit (19) unal,				/* reserved for future flags */
  3   243     2 index_id aligned bit (8),			/* id of index if indexed */
  3   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  3   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  3   246     2 n_children unal fixed bin,			/* no. children in link */
  3   247     2 child_fn char (30),				/* file name for first child in list */
  3   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  3   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  3   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  3   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  3   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  3   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  3   254     2 sort_err_path_ptr unal bit (18),
  3   255     2 sort_after_path_ptr unal bit (18),
  3   256     2 srch_before_path_ptr unal bit (18),
  3   257     2 srch_err_path_ptr unal bit (18),
  3   258     2 srch_after_path_ptr unal bit (18),
  3   259     2 link_before_path_ptr unal bit (18),
  3   260     2 link_err_path_ptr unal bit (18),
  3   261     2 link_after_path_ptr unal bit (18),
  3   262     2 unlk_before_path_ptr unal bit (18),
  3   263     2 unlk_err_path_ptr unal bit (18),
  3   264     2 unlk_after_path_ptr unal bit (18),
  3   265     2 unused_1 unal bit (18),				/* for future expansion */
  3   266     2 unused_2 unal bit (18),
  3   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  3   268 dcl  pli_ptr ptr;
  3   269 
  3   270 /* a child_link_info structure is the counter part of a parent_link_info
  3   271*   for foreign key child relations. each time a relation is defined to be
  3   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  3   273*   this list is singly linked in foreign key definition order.
  3   274*   the child_link_info points to a list of participating attributes from the
  3   275*   child relation by means of a singly linked list of attr_list structures
  3   276*   in definition order. the number of attributes in the parent attr_list
  3   277*   and the child attr_list lists are the same with corresponding attr_list
  3   278*   attributes having the same domain. all child_link_infos in this file
  3   279*   are on a seperately linked list. this may not include all
  3   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  3   281*   since foreign keys may span files, and the child_link_info will
  3   282*   reside in the file containing it's associated relation_info. */
  3   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  3   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  3   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  3   286     2 fixed bit (1) unal,				/* on if membership fixed */
  3   287     2 optional bit (1) unal,				/* on if membership optional */
  3   288     2 auto bit (1) unal,				/* on if insertion automatic */
  3   289     2 manual bit (1) unal,				/* on if insertion manual */
  3   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  3   291     2 range_sel bit (1) unal,				/* on if range type selection */
  3   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  3   293     2 key_dup_last bit (1) unal,
  3   294     2 key_null bit (1) unal,				/* on if null allowed */
  3   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  3   296     2 sel_current bit (1) unal,
  3   297     2 sel_key bit (1) unal,
  3   298     2 sel_proc bit (1) unal,
  3   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  3   300     2 reserved bit (21) unal,
  3   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  3   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  3   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  3   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  3   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  3   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  3   307     2 parent_fn char (30),				/* file name for parent info */
  3   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  3   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  3   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  3   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  3   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  3   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  3   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  3   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  3   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  3   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  3   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  3   319     2 link_err_path_ptr unal bit (18),
  3   320     2 link_after_path_ptr unal bit (18),
  3   321     2 unlk_before_path_ptr unal bit (18),
  3   322     2 unlk_err_path_ptr unal bit (18),
  3   323     2 unlk_after_path_ptr unal bit (18),
  3   324     2 srch_before_path_ptr unal bit (18),
  3   325     2 srch_err_path_ptr unal bit (18),
  3   326     2 srch_after_path_ptr unal bit (18),
  3   327     2 unused_1 unal bit (18),				/* for future expansion */
  3   328     2 unused_2 unal bit (18) ;
  3   329 dcl  cli_ptr ptr;
  3   330 
  3   331 /* the attr_list structure is associated with the parent_link_info
  3   332*   and child_link_info structures to represent by means of a singly linked list
  3   333*   the participating attributes from relations in a foreign key.
  3   334*   the parent_link_info has a list for the parent relation,
  3   335*   and the child_link_info has a list for the child relation.
  3   336*   the participating attributes are a subset(not necessary proper) of
  3   337*   those attributes contained in a relation definition.
  3   338*   there are equal numbers of attr_list structures in the parent and
  3   339*   child lists of the same foreign key. the corresponding attributes in these
  3   340*   lists must have the same domain. */
  3   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  3   342     2 attr_fn char (30),				/* file name for attr. */
  3   343     2 attr_ptr unal bit (18),				/* to attr info block */
  3   344     2 fwd_thread unal bit (18);			/* to next in list */
  3   345 dcl  al_ptr ptr;
  3   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  3   347     2 ascend bit (1) unal,				/* ascending order */
  3   348     2 descend bit (1) unal,				/* descending order */
  3   349     2 reserved bit (34) unal,
  3   350     2 attr_ptr unal bit (18),				/* to attr info */
  3   351     2 fwd_thread unal bit (18);			/* to next in list */
  3   352 dcl  sk_ptr ptr;
  3   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  3   354     2 attr_ptr unal bit (18),				/* to attr info */
  3   355     2 fwd_thread unal bit (18);			/* to next in list */
  3   356 dcl  dp_ptr ptr;
  3   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  3   358     2 link_fn char (30),				/* file name for thru link */
  3   359     2 link_ptr unal bit (18),				/* to parent link info */
  3   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  3   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  3   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  3   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  3   364     2 fwd_thread unal bit (18);			/* to next in chain */
  3   365 dcl  sc_ptr ptr;
  3   366 
  3   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  3   368 
  3   369 
      342 
  4     1 /* BEGIN - mrds_rmdb_ctl.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(82-03-26,Davids), approve(), audit(), install():
  4     7*     created
  4     8*  2) change(82-05-26,Davids), approve(), audit(), install():
  4     9*     added db_model_ptr
  4    10*  3) change(82-06-09,Harvey), approve(), audit(), install():
  4    11*     deleted ssu_ routines ptr storage
  4    12*  4) change(82-08-20,Davids), approve(), audit(), install():
  4    13*     added the relmgr like reference and included the rmdb_relmgr_entries
  4    14*     include file
  4    15*  5) change(83-05-24,Davids), approve(), audit(), install():
  4    16*     added the saved_res_version_ptr element
  4    17*  6) change(84-10-23,Benjamin), approve(), audit(), install():
  4    18*     added flags (just database_readied_by_rmdb for now).
  4    19*  7) change(85-11-08,Spitzer), approve(85-11-08,MCR7311),
  4    20*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  4    21*     added crossref_file_info.
  4    22*                                                   END HISTORY COMMENTS */
  4    23 
  4    24 
  4    25 dcl 01 rmdb_ctl based (rmdb_ctl_ptr),
  4    26     02 version fixed bin,
  4    27     02 rmdb_version char (16) varying,
  4    28     02 absolute_db_path char (168),
  4    29     02 temp_dir_path char (168),
  4    30     02 work_area_ptr ptr,
  4    31     02 db_model_ptr ptr,
  4    32     02 saved_res_version_ptr ptr,
  4    33     02 crossref_file_info,
  4    34        03 iocb_ptr ptr,
  4    35        03 name char (32),
  4    36     02 relmgr_entries like rmdb_relmgr_entries,
  4    37     02 flags,
  4    38        03 database_readied_by_rmdb bit (1) unal,
  4    39        03 unused bit (35) unal;
  4    40     	
  4    41 dcl  RMDB_CTL_VERSION_1 fixed bin init (1) internal static options (constant);
  4    42 
  4    43 dcl  rmdb_ctl_ptr ptr;
  4    44 
  4    45 
  5     1 /*  START OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(82-08-20,Davids), approve(), audit(), install():
  5     6*     written
  5     7*  2) change(86-01-28,Spitzer), approve(86-01-28,MCR7311),
  5     8*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  5     9*     add get_tuples_by_spec, put_tuple, put_tuples, create_cursor entry points.
  5    10*  3) change(86-08-21,Blair), approve(86-08-21,MCR7311),
  5    11*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  5    12*     Back out the entries get_tuples_by_spec and put_tuples since they aren't
  5    13*     sufficiently well tested to be reliable.  Replace with get_tuple_id and
  5    14*     get_tuple_by_id.
  5    15*                                                   END HISTORY COMMENTS */
  5    16 
  5    17 
  5    18 dcl 01 rmdb_relmgr_entries based (rmdb_relmgr_entries_ptr),
  5    19      02 create_relation entry (char (*), char (*), ptr, ptr, bit (36) aligned,
  5    20 	bit (36) aligned, fixed bin (35)),
  5    21      02 delete_relation entry (char (*), char (*), fixed bin (35)),
  5    22      02 open entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  5    23      02 close entry (bit (36) aligned, fixed bin (35)),
  5    24      02 create_index entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17),
  5    25 	bit (36) aligned, fixed bin (35)),
  5    26      02 delete_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35)),
  5    27      02 put_tuple entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  5    28      02 get_tuple_id entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  5    29      02 get_tuple_by_id entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  5    30      02 create_cursor entry (bit (36) aligned, ptr, ptr, fixed bin (35));
  5    31 
  5    32 dcl rmdb_relmgr_entries_ptr ptr;
  5    33 
  5    34 /*  END OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4    46 
  4    47 
  4    48 
  4    49 /* END - mrds_rmdb_ctl.incl.pl1 */
      343 
  6     1 /*  START OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 /****^  HISTORY COMMENTS:
  6     4*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
  6     5*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  6     6*     written.
  6     7*                                                   END HISTORY COMMENTS */
  6     8 
  6     9 /*DESCRIPTION
  6    10*  The following structures are the definition of the records with the keyed
  6    11*  vfile that is built during restructuring. This file serves as a crossreference
  6    12*  of unique attributes and domains used within the specified MRDS database. Each
  6    13*  object is a char (33); the first byte is set to an unprintable character so we
  6    14*  can use the index builtin to find a specific object.
  6    15**/
  6    16 
  6    17 dcl crossref_info_record_ptr ptr;
  6    18 dcl crossref_info_record_count fixed bin (21);
  6    19 dcl 1 crossref_info_record based (crossref_info_record_ptr),
  6    20      2 offset bit (18) unal,
  6    21      2 pad bit (18) unal,
  6    22      2 count fixed bin (21),
  6    23      2 entry (crossref_info_record_count refer (crossref_info_record.count)) unaligned,
  6    24       3 object_head char (1),
  6    25       3 object char (32);
  6    26 
  6    27 dcl crossref_info_record_objects char (33*crossref_info_record.count)
  6    28 			   based (addr (crossref_info_record.entry(1)));
  6    29 dcl OBJECT_HEAD char (1) int static options (constant) init (" ");
  6    30 
  6    31 dcl ATTRIBUTE_KEY_HEAD char (10) int static options (constant) init ("attribute:");
  6    32 dcl DOMAIN_KEY_HEAD char (7) int static options (constant) init ("domain:");
  6    33 dcl RELATION_KEY_HEAD char (9) int static options (constant) init ("relation:");
  6    34 
  6    35 /*DESCRIPTION
  6    36*  The following structures are used to contain sufficient crossreference
  6    37*  information for the delete_attribute and delete_domain requests. These
  6    38*  requests require a more complete view of a crossreference tree, associating
  6    39*  domains, attributes and relations in 2 directions.
  6    40**/
  6    41 
  6    42 dcl domain_list_ptr ptr;
  6    43 dcl domain_list_count fixed bin;
  6    44 dcl domain_list_names char (33*domain_list.count) based (addr (domain_list.name(1)));
  6    45 dcl 1 domain_list based (domain_list_ptr),
  6    46      2 count fixed bin,				/* number of domains in the list */
  6    47      2 name (domain_list_count refer (domain_list.count))
  6    48 	  char (33) unaligned,			/* name of this domain */
  6    49      2 attribute_list_ptr (domain_list_count refer (domain_list.count))
  6    50 		      ptr;			/* -> attribute_list structure */
  6    51 
  6    52 dcl attribute_list_ptr ptr;
  6    53 dcl attribute_list_count fixed bin;
  6    54 dcl attribute_list_names char (33*attribute_list.count) based (addr (attribute_list.name(1)));
  6    55 dcl 1 attribute_list based (attribute_list_ptr),
  6    56      2 count fixed bin,				/* number of attributes in the list */
  6    57      2 name (attribute_list_count refer (attribute_list.count))
  6    58 	  char (33) unaligned,			/* name of this attribute */
  6    59      2 domain_info_ptr (attribute_list_count refer (attribute_list.count))
  6    60 		   bit (18) unal,			/* offset in db_model of the domain_info structure for this attribute */
  6    61      2 attribute_ptr (attribute_list_count refer (attribute_list.count))
  6    62 		 ptr;				/* -> attribute structure */
  6    63 
  6    64 dcl relation_list_ptr ptr;
  6    65 dcl relation_list_count fixed bin;
  6    66 dcl relation_list_names char (33*relation_list.count) based (addr (relation_list.name (1)));
  6    67 dcl 1 relation_list based (relation_list_ptr),
  6    68      2 count fixed bin,				/* number of relations that are to be touched in this operation */
  6    69      2 name (relation_list_count refer (relation_list.count))
  6    70 	  char (33) unaligned,			/* name of this relation */
  6    71      2 relation_ptr (relation_list_count refer (relation_list.count))
  6    72 		ptr;				/* -> relation structure */
  6    73 
  6    74 dcl relation_ptr ptr;
  6    75 dcl relation_attribute_count fixed bin;
  6    76 dcl relation_attribute_names char (33*relation.attribute_count) based (addr (relation.attribute_names (1)));
  6    77 dcl 1 relation based (relation_ptr),
  6    78      2 name char (32),				/* name of the relation */
  6    79      2 file_model_ptr ptr,				/* -> relation.m segment */
  6    80      2 copy_file_model_ptr ptr,
  6    81      2 attribute_count fixed bin,			/* number of attributes defined for this relation */
  6    82      2 mbz fixed bin (35),
  6    83      2 attribute (relation_attribute_count refer (relation.attribute_count)),
  6    84       3 flags aligned,
  6    85         4 delete bit (1) unaligned,			/* ON: delete this attribute */
  6    86         4 new bit (1) unaligned,			/* ON: this attribute is added to the relation */
  6    87         4 part_of_key bit (1) unaligned,                    /* ON: this attribute is part of the primary key */
  6    88         4 to_be_deleted bit (1) unaligned,
  6    89         4 pad bit (32) unaligned,
  6    90       3 domain_info_ptr bit (18) aligned,		/* -> db_model domain_info structure */
  6    91       3 attribute_info_ptr ptr,			/* -> file_model attribute_info structure */
  6    92       3 value_ptr ptr,				/* if flags.new, this -> the value of the column to be stored */
  6    93 						/*   it must be of the correct data type as specified by the domain */
  6    94      2 attribute_names (relation_attribute_count refer (relation.attribute_count))
  6    95 		   char (33) unaligned;
  6    96 
  6    97 dcl attribute_ptr ptr;
  6    98 dcl attribute_count fixed bin;
  6    99 dcl 1 attribute based (attribute_ptr),
  6   100      2 count fixed bin,				/* number of relations this attribute is used in */
  6   101      2 relation_idx (attribute_count refer (attribute.count))
  6   102 		fixed bin;			/* index into list of relation names */
  6   103 
  6   104 /*  END OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      344 
  7     1 /*  START OF:	rmdb_delete_object_info.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 
  7     4 /****^  HISTORY COMMENTS:
  7     5*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
  7     6*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  7     7*     Contains the list of domains or attributes to delete. If flags.check is on,
  7     8*     query the user on the switch indicated by check_iocb_ptr.
  7     9*                                                   END HISTORY COMMENTS */
  7    10 
  7    11 dcl delete_object_info_count fixed bin (17);
  7    12 dcl delete_object_info_ptr ptr;
  7    13 dcl delete_object_info_version_1 char (8) int static options (constant) init ("doi 1.0");
  7    14 
  7    15 dcl 1 delete_object_info based (delete_object_info_ptr),
  7    16      2 version char (8),
  7    17      2 check_iocb_ptr ptr,				/* switch to use for check output */
  7    18      2 query_iocb_ptr ptr,				/* switch to use for query input */
  7    19      2 flags aligned,
  7    20       3 all bit (1) unaligned,
  7    21       3 unreferenced bit (1) unaligned,			/* delete only unreferenced object */
  7    22       3 check bit (1) unaligned,			/* display actions to take when deleting, don't actually delete */
  7    23       3 long bit (2) unaligned,			/* if flags.check, do delete operations */
  7    24       3 force bit (1) unaligned,			/* don't query user */
  7    25       3 inhibit_errors bit (1) unaligned,		/* don't display errors if an object isn't found */
  7    26       3 pad bit (29) unaligned,
  7    27      2 request_name char (32),			/* name to use in queries and error messages */
  7    28      2 count fixed bin (17),
  7    29      2 name (delete_object_info_count refer (delete_object_info.count))
  7    30 	  char (32);
  7    31 
  7    32 /*  END OF:	rmdb_delete_object_info.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      345 
      346 
      347 dcl  addr builtin;
      348 dcl  area condition;
      349 dcl  attribute_idx fixed bin;
      350 dcl  attribute_list_idx fixed bin;
      351 dcl  cleanup condition;
      352 dcl  code fixed bin (35);
      353 dcl  divide builtin;
      354 dcl  db_path char (168);
      355 dcl  domain_entry bit (1) aligned;
      356 dcl  domain_idx fixed bin;
      357 dcl  error_message char (500);
      358 dcl  error_table_$area_too_small fixed bin (35) ext static;
      359 dcl  error_table_$no_record fixed bin(35) ext static;
      360 dcl fixed builtin;
      361 dcl  Iarea_ptr ptr parameter;
      362 dcl  Idelete_object_info_ptr ptr parameter;
      363 dcl  index builtin;
      364 dcl  initiate_file_ entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
      365 dcl  Irmdb_ctl_ptr ptr parameter;
      366 dcl  local_iocb ptr;				/* -> IOCB for crossref file */
      367 dcl  max_seg_size fixed bin (21);
      368 dcl  mrds_error_$no_model_attr fixed bin(35) ext static;
      369 dcl  mrds_error_$no_model_dom fixed bin(35) ext static;
      370 dcl  myname char (32) int static options (constant) init ("rmdb");
      371 dcl  null builtin;
      372 dcl  Oattribute_list_ptr ptr parameter;
      373 dcl  Ocode fixed bin (35) parameter;
      374 dcl  Odomain_list_ptr ptr parameter;
      375 dcl  Oerror_message char (*) parameter;
      376 dcl  Orelation_list_ptr ptr parameter;
      377 dcl  pathname_ entry (char (*), char (*)) returns (char (168));
      378 dcl  ptr builtin;
      379 dcl  rel builtin;
      380 dcl  relation_idx fixed bin;
      381 dcl  relation_model_name char (32);
      382 dcl  mdbm_util_$get_temp_segments_path entry (char (*), char (*), (*) ptr, fixed bin (35));
      383 dcl  mdbm_util_$free_temp_segments entry (char (*), (*) ptr, fixed bin (35));
      384 dcl  mdbm_util_$xref_find_record entry (ptr, char (*), char (*), ptr, fixed bin (21), char (*), fixed bin (35));
      385 dcl  rtrim builtin;
      386 dcl  substr builtin;
      387 dcl  sys_info$max_seg_size fixed bin (35) ext static;
      388 dcl  temp_ptrs (2) ptr;
      389 dcl  unspec builtin;
      390 dcl  user_area area based (user_area_ptr);
      391 dcl  user_area_ptr ptr;
      392 
      393      end rmdb_relations_used;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1143.2  rmdb_relations_used.pl1           >special_ldd>install>MR12.0-1187>rmdb_relations_used.pl1
340          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
341          2    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
342          3    10/16/86  1139.9  mdbm_file_model.incl.pl1          >special_ldd>install>MR12.0-1187>mdbm_file_model.incl.pl1
343          4    10/16/86  1139.6  mrds_rmdb_ctl.incl.pl1            >special_ldd>install>MR12.0-1187>mrds_rmdb_ctl.incl.pl1
4-46         5    10/16/86  1140.2  rmdb_relmgr_entries.incl.pl1      >special_ldd>install>MR12.0-1187>rmdb_relmgr_entries.incl.pl1
344          6    10/16/86  1140.3  rmdb_crossref_info.incl.pl1       >special_ldd>install>MR12.0-1187>rmdb_crossref_info.incl.pl1
345          7    10/16/86  1140.3  rmdb_delete_object_info.incl.pl1  >special_ldd>install>MR12.0-1187>rmdb_delete_object_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTRIBUTE_KEY_HEAD              000012 constant        char(10)                 initial unaligned dcl 6-31 set ref 236*
DOMAIN_KEY_HEAD                 000010 constant        char(7)                  initial unaligned dcl 6-32 set ref 84*
Iarea_ptr                              parameter       pointer                  dcl 361 ref 30 37 47
Idelete_object_info_ptr                parameter       pointer                  dcl 362 ref 30 37 46
Irmdb_ctl_ptr                          parameter       pointer                  dcl 365 ref 30 37 44
OBJECT_HEAD                     002400 constant        char(1)                  initial unaligned dcl 6-29 ref 209
Oattribute_list_ptr                    parameter       pointer                  dcl 372 set ref 30 37 50* 199*
Ocode                                  parameter       fixed bin(35,0)          dcl 373 set ref 30 37 52* 320*
Odomain_list_ptr                       parameter       pointer                  dcl 374 set ref 30 37 50* 200*
Oerror_message                         parameter       char                     unaligned dcl 375 set ref 30 37 51* 321*
Orelation_list_ptr                     parameter       pointer                  dcl 376 set ref 30 37 50* 198*
RW_ACCESS                       000015 constant        bit(3)                   initial unaligned dcl 1-11 set ref 160*
absolute_db_path          6            based           char(168)                level 2 packed unaligned dcl 4-25 ref 56
addr                                                   builtin function         dcl 347 ref 256 257 296
ai_ptr                          000104 automatic       pointer                  dcl 3-209 set ref 177* 180 181 182 183 184* 184
area                            000140 stack reference condition                dcl 348 ref 74
attr_info                              based           structure                level 1 dcl 3-192
attr_ptr                 24(18)        based           bit(18)                  level 2 packed unaligned dcl 3-126 ref 177
attribute                16            based           structure                array level 2 in structure "relation" unaligned
                                                                                  dcl 6-77 in procedure "rmdb_relations_used"
attribute                              based           structure                level 1 unaligned dcl 6-99 in procedure
                                                                                  "rmdb_relations_used" set ref 250
attribute_count                 000134 automatic       fixed bin(17,0)          dcl 6-98 in procedure "rmdb_relations_used" set ref
                                                                                  249* 250 250 255
attribute_count          14            based           fixed bin(17,0)          level 2 in structure "relation" dcl 6-77
                                                                                  in procedure "rmdb_relations_used" set ref 170*
                                                                                  182 296 296
attribute_idx                   000146 automatic       fixed bin(17,0)          dcl 349 set ref 178* 179 180 181 182 183* 255* 256
                                                                                  266* 294* 295*
attribute_info_ptr       20            based           pointer                  array level 3 dcl 6-77 set ref 180*
attribute_list                         based           structure                level 1 unaligned dcl 6-55 set ref 101 122
attribute_list_count            000120 automatic       fixed bin(17,0)          dcl 6-53 set ref 100* 101 101 101 101 105 121* 122
                                                                                  122 122 122 126
attribute_list_idx              000147 automatic       fixed bin(17,0)          dcl 350 set ref 105* 106 106* 126* 127 127 128* 234*
                                                                                  235 244 270 273* 289* 290 293*
attribute_list_ptr                     based           pointer                  array level 2 in structure "domain_list" dcl 6-45
                                                                                  in procedure "rmdb_relations_used" set ref 111*
                                                                                  139 192
attribute_list_ptr              000116 automatic       pointer                  dcl 6-52 in procedure "rmdb_relations_used" set ref
                                                                                  97* 101* 106 111 122* 127 128 139* 192* 199 234
                                                                                  235 244 270 273 289 290 293
attribute_name                  000504 automatic       char(32)                 unaligned dcl 230 set ref 235* 236* 239*
attribute_names                        based           char(33)                 array level 2 packed unaligned dcl 6-77 set ref 182*
                                                                                  296
attribute_ptr                          based           pointer                  array level 2 in structure "attribute_list" dcl 6-55
                                                                                  in procedure "rmdb_relations_used" set ref 128*
                                                                                  244* 270* 290
attribute_ptr                   000132 automatic       pointer                  dcl 6-97 in procedure "rmdb_relations_used" set ref
                                                                                  250* 266 270 290* 291 294 295
cleaner_code                    000100 automatic       fixed bin(35,0)          dcl 332 set ref 334*
cleanup                         000150 stack reference condition                dcl 351 ref 59
code                                   parameter       fixed bin(35,0)          dcl 317 in procedure "error" ref 314 320
code                            000156 automatic       fixed bin(35,0)          dcl 352 in procedure "rmdb_relations_used" set ref
                                                                                  61* 62 65* 84* 86 86 89* 160* 161 161* 236* 239
                                                                                  239 242*
count                                  based           fixed bin(17,0)          level 2 in structure "attribute" dcl 6-99
                                                                                  in procedure "rmdb_relations_used" set ref 250*
                                                                                  294
count                                  based           fixed bin(17,0)          level 2 in structure "relation_list" dcl 6-67
                                                                                  in procedure "rmdb_relations_used" set ref 145
                                                                                  146* 150 150 150 150 150 158 174 257 261 261* 295
count                    17            based           fixed bin(17,0)          level 2 in structure "delete_object_info" dcl 7-15
                                                                                  in procedure "rmdb_relations_used" ref 78 121
count                                  based           fixed bin(17,0)          level 2 in structure "domain_list" dcl 6-45
                                                                                  in procedure "rmdb_relations_used" set ref 79* 111
                                                                                  137 139 190 192
count                                  based           fixed bin(17,0)          level 2 in structure "attribute_list" dcl 6-55
                                                                                  in procedure "rmdb_relations_used" set ref 101*
                                                                                  122* 128 128 234 244 244 270 270 273 289 290 290
count                     1            based           fixed bin(21,0)          level 2 in structure "crossref_info_record" dcl 6-19
                                                                                  in procedure "rmdb_relations_used" ref 97 100 244
                                                                                  249 256
crossref_file_info      140            based           structure                level 2 unaligned dcl 4-25
crossref_info_record                   based           structure                level 1 unaligned dcl 6-19
crossref_info_record_objects           based           char                     unaligned dcl 6-27 ref 256
crossref_info_record_ptr        000110 automatic       pointer                  dcl 6-17 set ref 69* 84* 97 100 106 236* 244 249 256
                                                                                  256 273
db_path                         000157 automatic       char(168)                unaligned dcl 354 set ref 56* 160* 161*
delete                   16            based           bit(1)                   array level 4 packed unaligned dcl 6-77 set ref 300*
delete_object_info                     based           structure                level 1 unaligned dcl 7-15
delete_object_info_ptr          000136 automatic       pointer                  dcl 7-12 set ref 46* 78 84 86 92 121 127
divide                                                 builtin function         dcl 353 ref 264 299
domain_entry                    000231 automatic       bit(1)                   dcl 355 set ref 34* 41* 76 137 190
domain_idx                      000232 automatic       fixed bin(17,0)          dcl 356 set ref 81* 84 86 92 92 111* 137* 139* 190*
                                                                                  192*
domain_info_ptr                        based           bit(18)                  array level 2 in structure "attribute_list" packed
                                                                                  unaligned dcl 6-55 in procedure
                                                                                  "rmdb_relations_used" set ref 273*
domain_info_ptr          17            based           bit(18)                  array level 3 in structure "relation" dcl 6-77
                                                                                  in procedure "rmdb_relations_used" set ref 181*
domain_list                            based           structure                level 1 unaligned dcl 6-45 set ref 79
domain_list_count               000114 automatic       fixed bin(17,0)          dcl 6-43 set ref 78* 79 79 79 81
domain_list_ptr                 000112 automatic       pointer                  dcl 6-42 set ref 79* 92 111 118* 137 139 190 192 200
domain_ptr               17            based           bit(18)                  level 2 packed unaligned dcl 3-192 ref 181
entry                     2            based           structure                array level 2 packed unaligned dcl 6-19 set ref 256
error_message                   000233 automatic       char(500)                unaligned dcl 357 set ref 64* 65* 84* 89* 236* 242*
error_table_$area_too_small     000010 external static fixed bin(35,0)          dcl 358 set ref 74*
error_table_$no_record          000012 external static fixed bin(35,0)          dcl 359 ref 86 239
file_model                             based           structure                level 1 dcl 3-40
file_model_ptr           10            based           pointer                  level 2 dcl 6-77 set ref 172*
flags                    16            based           structure                array level 3 dcl 6-77 set ref 179*
fm_ptr                          000100 automatic       pointer                  dcl 3-108 set ref 160* 166 166 172 177 184
fwd_thread               20            based           bit(18)                  level 2 packed unaligned dcl 3-192 ref 184
index                                                  builtin function         dcl 363 ref 257 296
initiate_file_                  000014 constant        entry                    external dcl 364 ref 160
input_name                             parameter       char                     unaligned dcl 207 in procedure "make_name" ref 204
                                                                                  209
input_name                             parameter       char(33)                 unaligned dcl 215 in procedure "unmake_name" ref 212
                                                                                  217
iocb_ptr                140            based           pointer                  level 3 dcl 4-25 ref 57
key_attr                 10            based           bit(1)                   level 2 packed unaligned dcl 3-192 ref 183
local_iocb                      000430 automatic       pointer                  dcl 366 set ref 57* 84* 236*
max_seg_size                    000432 automatic       fixed bin(21,0)          dcl 367 set ref 55* 84* 236*
mdbm_util_$free_temp_segments   000026 constant        entry                    external dcl 383 ref 334
mdbm_util_$get_temp_segments_path
                                000024 constant        entry                    external dcl 382 ref 61
mdbm_util_$xref_find_record     000030 constant        entry                    external dcl 384 ref 84 236
mrds_error_$no_model_attr       000016 external static fixed bin(35,0)          dcl 368 set ref 239*
mrds_error_$no_model_dom        000020 external static fixed bin(35,0)          dcl 369 set ref 86*
msg                                    parameter       char                     unaligned dcl 318 ref 314 321
myname                          000000 constant        char(32)                 initial unaligned dcl 370 set ref 61* 334*
name                      1            based           char(33)                 array level 2 in structure "domain_list" packed
                                                                                  unaligned dcl 6-45 in procedure
                                                                                  "rmdb_relations_used" set ref 92*
name                      1            based           char(33)                 array level 2 in structure "attribute_list" packed
                                                                                  unaligned dcl 6-55 in procedure
                                                                                  "rmdb_relations_used" set ref 106* 127* 235* 293
name                      1            based           char(33)                 array level 2 in structure "relation_list" packed
                                                                                  unaligned dcl 6-67 in procedure
                                                                                  "rmdb_relations_used" set ref 150* 150 159* 171*
                                                                                  257 262*
name                                   based           char(32)                 level 2 in structure "attr_info" dcl 3-192
                                                                                  in procedure "rmdb_relations_used" ref 182
name                                   based           char(32)                 level 2 in structure "relation" packed unaligned
                                                                                  dcl 6-77 in procedure "rmdb_relations_used" set
                                                                                  ref 171*
name                     20            based           char(32)                 array level 2 in structure "delete_object_info"
                                                                                  packed unaligned dcl 7-15 in procedure
                                                                                  "rmdb_relations_used" set ref 84* 86* 92* 127*
null                                                   builtin function         dcl 371 ref 50 54 97 118 128 244 291 334
num_attr                 12            based           fixed bin(17,0)          level 2 packed unaligned dcl 3-126 ref 167
object                    2(09)        based           char(32)                 array level 3 packed unaligned dcl 6-19 set ref 106*
offset                                 based           bit(18)                  level 2 packed unaligned dcl 6-19 ref 273
part_of_key              16(02)        based           bit(1)                   array level 4 packed unaligned dcl 6-77 set ref 183*
pathname_                       000022 constant        entry                    external dcl 377 ref 161
position                        000525 automatic       fixed bin(17,0)          dcl 232 in procedure "get_relation_names" set ref
                                                                                  257* 259 261* 262 264* 264 266
position                        000536 automatic       fixed bin(17,0)          dcl 286 in procedure "mark_deleted_attributes" set
                                                                                  ref 296* 297 299* 299 300
ptr                                                    builtin function         dcl 378 ref 166 177 184
rel_info                               based           structure                level 1 dcl 3-126
rel_ptr                  20(27)        based           bit(18)                  level 2 packed unaligned dcl 3-40 ref 166
relation                               based           structure                level 1 unaligned dcl 6-77 set ref 170
relation_attribute_count        000130 automatic       fixed bin(17,0)          dcl 6-75 set ref 167* 170 170 170 178
relation_attribute_names               based           char                     unaligned dcl 6-76 ref 296
relation_idx                    000433 automatic       fixed bin(17,0)          dcl 380 in procedure "rmdb_relations_used" set ref
                                                                                  158* 159 171 174*
relation_idx              1            based           fixed bin(17,0)          array level 2 in structure "attribute" dcl 6-99
                                                                                  in procedure "rmdb_relations_used" set ref 266*
                                                                                  295
relation_list                          based           structure                level 1 unaligned dcl 6-67 set ref 146
relation_list_count             000124 automatic       fixed bin(17,0)          dcl 6-65 set ref 145* 146 146 146
relation_list_names                    based           char                     unaligned dcl 6-66 ref 257
relation_list_ptr               000122 automatic       pointer                  dcl 6-64 set ref 136* 145 146* 150 158 159 171 174
                                                                                  198 257 257 261 261 262 295
relation_model_name             000434 automatic       char(32)                 unaligned dcl 381 set ref 159* 160* 161*
relation_ptr                    000126 automatic       pointer                  dcl 6-74 in procedure "rmdb_relations_used" set ref
                                                                                  170* 171 172 174 179 180 181 182 183 295* 296 296
                                                                                  300
relation_ptr                           based           pointer                  array level 2 in structure "relation_list" dcl 6-67
                                                                                  in procedure "rmdb_relations_used" set ref 174*
                                                                                  295
ri_ptr                          000102 automatic       pointer                  dcl 3-185 set ref 166* 167 177
rmdb_ctl                               based           structure                level 1 unaligned dcl 4-25
rmdb_ctl_ptr                    000106 automatic       pointer                  dcl 4-43 set ref 44* 56 57 61 64
rmdb_relmgr_entries                    based           structure                level 1 unaligned dcl 5-18
rtrim                                                  builtin function         dcl 385 ref 64 159
search_name                     000537 automatic       char(33)                 unaligned dcl 287 in procedure
                                                                                  "mark_deleted_attributes" set ref 293* 296
search_name                     000514 automatic       char(33)                 unaligned dcl 231 in procedure "get_relation_names"
                                                                                  set ref 256* 257 262
substr                                                 builtin function         dcl 386 ref 217 256
sys_info$max_seg_size           000032 external static fixed bin(35,0)          dcl 387 ref 55
temp_dir_path            60            based           char(168)                level 2 packed unaligned dcl 4-25 set ref 61* 64
temp_ptrs                       000444 automatic       pointer                  array dcl 388 set ref 54* 61* 69 136 150 334 334*
unspec                                                 builtin function         dcl 389 set ref 179*
user_area                              based           area(1024)               dcl 390 ref 79 101 122 146 170 250
user_area_ptr                   000450 automatic       pointer                  dcl 391 set ref 47* 79 101 122 146 170 250

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-33
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
RELATION_KEY_HEAD                      internal static char(9)                  initial unaligned dcl 6-33
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RMDB_CTL_VERSION_1                     internal static fixed bin(17,0)          initial dcl 4-41
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
al_ptr                                 automatic       pointer                  dcl 3-345
alloc_length                           internal static fixed bin(35,0)          dcl 2-222
atd                                    based           char                     unaligned dcl 3-109
atd_len                                automatic       fixed bin(17,0)          dcl 3-111
atd_ptr                                automatic       pointer                  dcl 3-110
attr_list                              based           structure                level 1 dcl 3-341
attribute_list_names                   based           char                     unaligned dcl 6-54
changer                                based           structure                level 1 packed unaligned dcl 2-251
changer_ptr                            automatic       pointer                  dcl 2-256
child_link_info                        based           structure                level 1 dcl 3-283
cli_ptr                                automatic       pointer                  dcl 3-329
cna_ptr                                automatic       pointer                  dcl 3-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 3-112
constant                               based           structure                level 1 unaligned dcl 2-216
constant_ptr                           automatic       pointer                  dcl 2-220
crossref_info_record_count             automatic       fixed bin(21,0)          dcl 6-18
db_model                               based           structure                level 1 dcl 2-72
dbm_ptr                                automatic       pointer                  dcl 2-106
delete_object_info_count               automatic       fixed bin(17,0)          dcl 7-11
delete_object_info_version_1           internal static char(8)                  initial unaligned dcl 7-13
di_ptr                                 automatic       pointer                  dcl 2-155
domain_info                            based           structure                level 1 dcl 2-125
domain_list_names                      based           char                     unaligned dcl 6-44
dp_ptr                                 automatic       pointer                  dcl 3-356
dup_prev                               based           structure                level 1 dcl 3-353
fi_ptr                                 automatic       pointer                  dcl 2-119
file_info                              based           structure                level 1 dcl 2-113
fixed                                                  builtin function         dcl 360
message_str                            based           structure                level 1 packed unaligned dcl 2-259
message_str_len                        automatic       fixed bin(17,0)          dcl 2-269
message_str_ptr                        automatic       pointer                  dcl 2-267
ncomp_init                             automatic       fixed bin(17,0)          dcl 3-116
parent_link_info                       based           structure                level 1 dcl 3-223
path_entry                             based           structure                level 1 packed unaligned dcl 2-172
path_entry_ptr                         automatic       pointer                  dcl 2-177
pli_ptr                                automatic       pointer                  dcl 3-268
rel                                                    builtin function         dcl 379
rmdb_relmgr_entries_ptr                automatic       pointer                  dcl 5-32
sc_ptr                                 automatic       pointer                  dcl 3-365
select_chain                           based           structure                level 1 dcl 3-357
sk_ptr                                 automatic       pointer                  dcl 3-352
sort_key                               based           structure                level 1 dcl 3-346
stack_item                             based           structure                level 1 unaligned dcl 2-206
stack_item_ptr                         automatic       pointer                  dcl 2-212
ua_ptr                                 automatic       pointer                  dcl 2-165
unreferenced_attribute                 based           structure                level 1 dcl 2-159
version_status                         based           structure                level 1 packed unaligned dcl 2-232
version_status_ptr                     automatic       pointer                  dcl 2-246

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          000142 constant        label                    dcl 44 set ref 35 42
RETURN_TO_CALLER                001615 constant        label                    dcl 325 ref 322
cleaner                         002345 constant        entry                    internal dcl 329 ref 59 325
error                           002311 constant        entry                    internal dcl 314 ref 65 74 86 89 161 202 239 242
get_relation_names              001664 constant        entry                    internal dcl 227 ref 140 142
make_name                       001622 constant        entry                    internal dcl 204 ref 92 106 127 182
mark_deleted_attributes         002161 constant        entry                    internal dcl 283 ref 193 195
rmdb_relations_used             000070 constant        entry                    external dcl 25
rmdb_relations_used$attributes  000125 constant        entry                    external dcl 37
rmdb_relations_used$domains     000105 constant        entry                    external dcl 30
unmake_name                     001654 constant        entry                    internal dcl 212 ref 159 171 235

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2644        2700    2403        2654
Length      3302    2403        34         366     240           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rmdb_relations_used                 546 external procedure  is an external procedure.  
on unit on line 59                   64 on unit               
on unit on line 74                   80 on unit               
make_name                               internal procedure  shares stack frame of external procedure rmdb_relations_used.  
unmake_name                             internal procedure  shares stack frame of external procedure rmdb_relations_used.  
get_relation_names                      internal procedure  shares stack frame of external procedure rmdb_relations_used.  
mark_deleted_attributes                 internal procedure  shares stack frame of external procedure rmdb_relations_used.  
error                                65 internal procedure  is called by several nonquick procedures.  
cleaner                              80 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cleaner                  000100 cleaner_code                cleaner
rmdb_relations_used      000100 fm_ptr                      rmdb_relations_used
                         000102 ri_ptr                      rmdb_relations_used
                         000104 ai_ptr                      rmdb_relations_used
                         000106 rmdb_ctl_ptr                rmdb_relations_used
                         000110 crossref_info_record_ptr    rmdb_relations_used
                         000112 domain_list_ptr             rmdb_relations_used
                         000114 domain_list_count           rmdb_relations_used
                         000116 attribute_list_ptr          rmdb_relations_used
                         000120 attribute_list_count        rmdb_relations_used
                         000122 relation_list_ptr           rmdb_relations_used
                         000124 relation_list_count         rmdb_relations_used
                         000126 relation_ptr                rmdb_relations_used
                         000130 relation_attribute_count    rmdb_relations_used
                         000132 attribute_ptr               rmdb_relations_used
                         000134 attribute_count             rmdb_relations_used
                         000136 delete_object_info_ptr      rmdb_relations_used
                         000146 attribute_idx               rmdb_relations_used
                         000147 attribute_list_idx          rmdb_relations_used
                         000156 code                        rmdb_relations_used
                         000157 db_path                     rmdb_relations_used
                         000231 domain_entry                rmdb_relations_used
                         000232 domain_idx                  rmdb_relations_used
                         000233 error_message               rmdb_relations_used
                         000430 local_iocb                  rmdb_relations_used
                         000432 max_seg_size                rmdb_relations_used
                         000433 relation_idx                rmdb_relations_used
                         000434 relation_model_name         rmdb_relations_used
                         000444 temp_ptrs                   rmdb_relations_used
                         000450 user_area_ptr               rmdb_relations_used
                         000504 attribute_name              get_relation_names
                         000514 search_name                 get_relation_names
                         000525 position                    get_relation_names
                         000536 position                    mark_deleted_attributes
                         000537 search_name                 mark_deleted_attributes

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     alloc_temp          cat_realloc_chars   call_ext_out_desc   call_int_this_desc  call_int_this
call_int_other_desc call_int_other      return_mac          tra_ext_1           bound_ck_signal     enable_op
shorten_stack       ext_entry           ext_entry_desc      int_entry           int_entry_desc      set_chars_eis
index_chars_eis     op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
initiate_file_                mdbm_util_$free_temp_segments mdbm_util_$get_temp_segments_path
mdbm_util_$xref_find_record   pathname_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$area_too_small   error_table_$no_record        mrds_error_$no_model_attr     mrds_error_$no_model_dom
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     25 000067        28 000075        30 000076        34 000120        35 000122        37 000123        41 000140
     42 000141        44 000142        46 000146        47 000151        50 000154        51 000160        52 000165
     54 000166        55 000201        56 000205        57 000211        59 000213        61 000235        62 000263
     64 000265        65 000325        69 000342        74 000344        76 000404        78 000406        79 000411
     81 000432        84 000441        86 000506        89 000535        92 000551        97 000601       100 000607
    101 000610       105 000636       106 000645       108 000673       111 000675       112 000713       113 000715
    118 000716       121 000720       122 000723       126 000751       127 000757       128 001007       129 001033
    136 001035       137 001037       139 001051       140 001066       141 001067       142 001072       145 001073
    146 001075       150 001116       158 001165       159 001175       160 001240       161 001277       166 001343
    167 001353       170 001356       171 001376       172 001414       174 001417       177 001434       178 001442
    179 001451       180 001454       181 001456       182 001462       183 001514       184 001525       185 001532
    186 001534       190 001536       192 001547       193 001564       194 001565       195 001570       198 001571
    199 001574       200 001576       202 001600       325 001615       327 001621       204 001622       209 001633
    212 001654       217 001656       227 001664       234 001665       235 001675       236 001712       239 001752
    242 001774       244 002010       249 002040       250 002041       255 002051       256 002057       257 002064
    259 002075       261 002076       262 002102       263 002106       264 002107       266 002112       268 002115
    270 002117       273 002142       274 002156       276 002160       283 002161       289 002162       290 002171
    291 002213       293 002217       294 002225       295 002235       296 002253       297 002274       299 002275
    300 002300       302 002303       304 002305       306 002307       314 002310       320 002324       321 002331
    322 002341       329 002344       334 002352       337 002377


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
