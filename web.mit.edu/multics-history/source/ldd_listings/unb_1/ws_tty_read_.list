	COMPILATION LISTING OF SEGMENT ws_tty_read_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 01/24/89  0849.2 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /****^  HISTORY COMMENTS:
       10*  1) change(86-12-05,RBarstad), approve(86-12-11,MCR7585),
       11*     audit(87-08-05,Gilcrease), install(87-08-07,MR12.1-1075):
       12*     Created.
       13*                                                   END HISTORY COMMENTS */
       14 
       15 /* format: style3,^ifthenstmt,indthenelse,^indnoniterdo,^indprocbody,initcol3,dclind5,idind32 */
       16 ws_tty_read_:
       17      proc ();
       18      return;
       19 
       20 /* ------------------------  DESCRIPTION  ---------------------------------- */
       21 
       22 /****^ VERSION 1.72
       23*							
       24*     ws_tty_ entries to support video mode in MOWSE work station
       25* 							
       26*     ws_tty_$read_echoed 					
       27*     ws_tty_$read
       28*     ws_tty_$read_with_mark
       29*
       30**/
       31 
       32 /* ------------------------  PARAMETERS  ----------------------------------- */
       33 
       34 dcl  I_n_chars_to_read	       fixed bin (21) parm;	/* maximum number of chars to return */
       35 dcl  I_offset		       fixed bin (21) parm;	/* offset in buffer to start at */
       36 dcl  I_buffer		       char (*) parm;	/* caller's buffer used by read_with_mark */
       37 dcl  I_buffer_ptr		       ptr parm;		/* pointer to caller's buffer */
       38 dcl  I_screen_left		       fixed bin parm;	/* Space left on line, negotiate entry */
       39 dcl  I_iocb_ptr		       ptr parm;		/* io ptr for iox */
       40 dcl  I_never_block		       bit (1) aligned parm;
       41 dcl  O_code		       fixed bin (35) parm;	/* error code */
       42 dcl  O_echoed		       fixed bin (21) parm;	/* Chars echoed by interrupt side */
       43 dcl  O_mark_index		       fixed bin (21) parm;	/* index in returned string of "mark" */
       44 dcl  O_n_chars_read		       fixed bin (21) parm;	/* actual number of characters returned */
       45 dcl  O_state		       fixed bin parm;	/* tty state, 1 ignored, 2 listening, 5 dialed */
       46 
       47 /* ------------------------  AUTOMATIC  ------------------------------------ */
       48 
       49 dcl  code			       fixed bin (35);	/* error code */
       50 dcl  echoed		       fixed bin (21);	/* Chars echoed by interrupt side */
       51 dcl  iocb_ptr		       ptr;		/* iocb pointer for iox */
       52 dcl  mark_index		       fixed bin (21);	/* local copy */
       53 dcl  get_msg_id		       char (3);		/* message id actually returned from WSTERM */
       54 dcl  n_chars_to_read	       fixed bin (21);	/* maximum number of chars to return */
       55 dcl  n_chars_read		       fixed bin (21);	/* actual number of characters returned */
       56 dcl  never_block		       bit (1) aligned;
       57 dcl  offset		       fixed bin (21);	/* offset in buffer to start at */
       58 dcl  buffer_ptr		       ptr;		/* pointer to caller's buffer */
       59 dcl  read_ptr		       ptr;		/* actuall ptr to read buffer */
       60 dcl  read_data		       char (2);		/* read count */
       61 dcl  read_data_len		       fixed bin (21);	/* size of read data */
       62 dcl  read_data_ptr		       ptr;
       63 dcl  screen_left		       fixed bin;		/* Space left on line, negotiate entry */
       64 dcl  state		       fixed bin;		/* tty state, 1 ignored, 2 listening, 5 dialed */
       65 dcl  total_chars_read	       fixed bin;
       66 dcl  read_flags		       bit (9);
       67 
       68 /* ------------------------  BASED  ---------------------------------------- */
       69 
       70 dcl  based_chars		       (0:offset) char (1) based unal;
       71 						/* to bump write ptr */
       72 
       73 /* ------------------------  CONSTANTS  ------------------------------------ */
       74 
       75 dcl  (
       76      ME			       char (12) init ("ws_tty_read_"),
       77      BYTE_SIZE		       fixed bin init (256),
       78      FALSE		       bit (1) init ("0"b),
       79      TRUE			       bit (1) init ("1"b)
       80      )			       internal static options (constant);
       81 
       82 /* ------------------------  EXTERNALS  ------------------------------------ */
       83 
       84 dcl  (
       85      error_table_$bad_arg,
       86      error_table_$improper_data_format
       87      )			       fixed bin (35) external static;
       88 
       89 /* ------------------------  ENTRIES  -------------------------------------- */
       90 
       91 dcl  ws_tty_mgr_$ok_iocb	       entry (ptr, ptr, ptr, fixed bin (35)) returns (bit (1));
       92 dcl  ws_tty_mgr_$send_message	       entry (ptr, char (3), bit (9), ptr, fixed bin (21));
       93 dcl  ws_tty_mgr_$get_message	       entry (ptr, ptr, fixed bin (21), fixed bin (21), char (3));
       94 dcl  ws_trace_		       entry () options (variable);
       95 
       96 /* ------------------------  BUILTINS and CONDITIONS  ---------------------- */
       97 
       98 dcl  (addr, divide, length, max, min) builtin;
       99 
      100 dcl  cleanup		       condition;
      101 
      102 
      103 /* ------------------------  PROGRAM  -------------------------------------- */
      104 
      105 read:
      106      entry (I_iocb_ptr, I_buffer_ptr, I_offset, I_n_chars_to_read, O_n_chars_read, O_state, O_code);
      107 
      108 /**** get params */
      109      buffer_ptr = I_buffer_ptr;
      110      offset = I_offset;
      111      n_chars_to_read = I_n_chars_to_read;
      112 
      113 /**** init */
      114      code = 0;
      115      state = 0;
      116      n_chars_read = 0;
      117      on cleanup call clean_up;
      118 
      119      if ws_tty_data$Flags.Trace = TRUE
      120 	then call ws_trace_ ("^a$read entry: iocb_ptr=^p, buffer_ptr=^p, offset=^i, chars=^i.", ME, I_iocb_ptr,
      121 		buffer_ptr, offset, n_chars_to_read);
      122 
      123 /**** check environment */
      124      if ^ws_tty_mgr_$ok_iocb (I_iocb_ptr, iocb_ptr, mowse_io_data_ptr, code)
      125 	then goto read_exit;
      126 
      127 /**** get buffer ptrs and sizes */
      128 
      129      if n_chars_to_read < 0
      130 	then do;
      131 	     code = error_table_$bad_arg;
      132 	     goto read_exit;
      133 	end;
      134 
      135      read_ptr = addr (buffer_ptr -> based_chars (offset));
      136 
      137      read_data = convert_read_count (n_chars_to_read);
      138      read_data_ptr = addr (read_data);
      139      read_data_len = length (read_data);
      140 
      141      if ws_tty_data$Flags.Trace = TRUE
      142 	then call ws_trace_ ("^a$read: read_count=^i.", ME, mowse_io_data.ws.read_count);
      143 
      144 /**** read it */
      145      if (mowse_io_data.ws.read_count = 0) | (n_chars_to_read = 0)
      146 	then do;
      147 	     call ws_tty_mgr_$send_message (iocb_ptr, WS_READ_WITH_NO_ECHO, WS_FLAG_NONE, read_data_ptr, read_data_len);
      148 	     mowse_io_data.ws.read_count = mowse_io_data.ws.read_count + 1;
      149 	end;
      150 
      151      call ws_tty_mgr_$get_message (iocb_ptr, read_ptr, n_chars_to_read, n_chars_read, get_msg_id);
      152 
      153 /**** check what was read */
      154      if get_msg_id = WS_END_NON_ECHOED_INPUT
      155 	then mowse_io_data.ws.read_count = mowse_io_data.ws.read_count - 1;
      156      else if get_msg_id ^= WS_UNECHOED_INPUT_CHARS
      157 	then code = error_table_$improper_data_format;
      158 
      159 read_done:
      160      O_n_chars_read = n_chars_read;
      161 
      162 read_exit:
      163      if ws_tty_data$Flags.Trace = TRUE
      164 	then call ws_trace_ ("^a$read exit: n_chars_read=^i, state=^i, code=^i.^/", ME, n_chars_read, state, code);
      165 
      166      O_state = state;
      167      O_code = code;
      168      return;
      169 
      170 read_echoed:
      171      entry (I_iocb_ptr, I_buffer_ptr, I_offset, I_n_chars_to_read, O_n_chars_read, O_echoed, I_screen_left, O_state,
      172 	O_code);
      173 
      174 /**** get params */
      175      buffer_ptr = I_buffer_ptr;
      176      offset = I_offset;
      177      n_chars_to_read = I_n_chars_to_read;
      178      screen_left = I_screen_left;
      179 
      180 /**** init */
      181      code = 0;
      182      state = 0;
      183      n_chars_read = 0;
      184      echoed = 0;
      185      get_msg_id = "   ";
      186      total_chars_read = 0;
      187      on cleanup call clean_up;
      188 
      189      if ws_tty_data$Flags.Trace
      190 	then call ws_trace_ (
      191 		"^a$read_echoed entry: iocb_ptr=^p, buffer_ptr=^p, offset=^i, chars=^i, screen=^i, O_echoed=^i.", ME,
      192 		I_iocb_ptr, buffer_ptr, offset, n_chars_to_read, screen_left, O_echoed);
      193 
      194 /**** check environment */
      195 
      196      if ^ws_tty_mgr_$ok_iocb (I_iocb_ptr, iocb_ptr, mowse_io_data_ptr, code)
      197 	then goto read_echoed_exit;
      198 
      199 /**** get buffer ptrs and sizes */
      200 
      201      if n_chars_to_read = 0
      202 	then goto read_echoed_done;
      203 
      204      if n_chars_to_read < 0
      205 	then do;
      206 	     code = error_table_$bad_arg;
      207 	     goto read_echoed_exit;
      208 	end;
      209 
      210      read_ptr = addr (buffer_ptr -> based_chars (offset));
      211 
      212      if ws_tty_data$Flags.Trace = TRUE
      213 	then call ws_trace_ ("^a$read_echoed: read_count=^i.", ME, mowse_io_data.ws.read_count);
      214 
      215 /**** read it */
      216      if screen_left ^= 0 /* turn echo ON, OR return any previously entered non-echoed input */
      217 	then do;
      218 	     n_chars_to_read = min (n_chars_to_read, screen_left);
      219 	     read_data = convert_read_count (n_chars_to_read);
      220 	     read_data_ptr = addr (read_data);
      221 	     read_data_len = length (read_data);
      222 
      223 	     if (mowse_io_data.ws.read_count > 0)	/* non-echoed input to clean up */
      224 		then do;
      225 		     call ws_tty_mgr_$send_message (iocb_ptr, WS_READ_WITH_NO_ECHO, WS_FLAG_NO_BLOCK, read_data_ptr,
      226 			read_data_len);
      227 		     mowse_io_data.ws.read_count = mowse_io_data.ws.read_count + 1;
      228 
      229 		     do while (mowse_io_data.ws.read_count > 0);
      230 			call ws_tty_mgr_$get_message (iocb_ptr, read_ptr, n_chars_to_read, n_chars_read, get_msg_id);
      231 
      232 			total_chars_read = total_chars_read + n_chars_read;
      233 			if get_msg_id = WS_END_NON_ECHOED_INPUT
      234 			     then mowse_io_data.ws.read_count = mowse_io_data.ws.read_count - 1;
      235 
      236 			else if (get_msg_id = WS_UNECHOED_INPUT_CHARS)
      237 			     then do;		/* not end, prepare to read again */
      238 				offset = offset + n_chars_read;
      239 				n_chars_to_read = n_chars_to_read - n_chars_read;
      240 				read_ptr = addr (buffer_ptr -> based_chars (offset));
      241 				read_data = convert_read_count (n_chars_to_read);
      242 			     end;
      243 
      244 			else if (get_msg_id = " ") & (n_chars_read = 0)
      245 						/* special case from start control order */
      246 			     then /* ignore */;
      247 
      248 			else code = error_table_$improper_data_format;
      249 		     end /* do while */;
      250 		end /* if mowse_io_data.ws.read_count > 0 */;
      251 
      252 	     /* now finally, we can read echoed input, but only if there was no unechoed input*/
      253 	     if total_chars_read = 0
      254 		then call ws_tty_mgr_$send_message (iocb_ptr, WS_READ_WITH_ECHO, WS_FLAG_NONE, read_data_ptr,
      255 			read_data_len);
      256 
      257 	end /* screen_left ^= 0 */;
      258 
      259 	else /* screen_left = 0, turn echo OFF */
      260 	     do while ((get_msg_id ^= WS_END_ECHOED_INPUT) & (n_chars_to_read > 0) & (code = 0));
      261 		call ws_tty_mgr_$get_message (iocb_ptr, read_ptr, n_chars_to_read, n_chars_read, get_msg_id);
      262 
      263 		total_chars_read = total_chars_read + n_chars_read;
      264 		if get_msg_id = WS_END_ECHOED_INPUT	/* the end */
      265 		     then do;
      266 			echoed = echoed + n_chars_read;
      267 			mowse_io_data.ws.read_count = 0; /* just in case */
      268 		     end;
      269 		     else do /* not WS_END_ECHOED_INPUT, prepare to read again */;
      270 			offset = offset + n_chars_read;
      271 			n_chars_to_read = n_chars_to_read - n_chars_read;
      272 			read_ptr = addr (buffer_ptr -> based_chars (offset));
      273 			read_data = convert_read_count (n_chars_to_read);
      274 
      275 			if get_msg_id = WS_ECHOED_INPUT_CHARS
      276 			     then echoed = echoed + n_chars_read;
      277 
      278 			else if (get_msg_id = " ") & (n_chars_read = 0)
      279 			     /* special case from start control order */
      280 			     then do;
      281 				n_chars_to_read = 0 /* force stop and exit */;
      282 			     end;
      283 
      284 			else code = error_table_$improper_data_format;
      285 		     end /* else not WS_END_ECHOED_INPUT */;
      286 	     end /* do while */;
      287 
      288 read_echoed_done:
      289      O_n_chars_read = total_chars_read;
      290      O_echoed = echoed;
      291 
      292 read_echoed_exit:
      293      if ws_tty_data$Flags.Trace
      294 	then call ws_trace_ ("^a$read_echoed exit: total_chars_read=^i, echoed=^i, state=^i, code=^i.^/", ME,
      295 		total_chars_read, echoed, state, code);
      296 
      297      O_state = state;
      298      O_code = code;
      299      return;
      300 
      301 read_with_mark:
      302      entry (I_iocb_ptr, I_buffer, I_never_block, O_n_chars_read, O_mark_index, O_state, O_code);
      303 
      304 /**** get params */
      305      never_block = I_never_block;
      306 
      307 /**** init */
      308      code = 0;
      309      state = 0;
      310      mark_index = 0;
      311      n_chars_read = 0;
      312      total_chars_read = 0;
      313      offset = 0;
      314      on cleanup call clean_up;
      315 
      316      if ws_tty_data$Flags.Trace
      317 	then call ws_trace_ ("^a$read_with_mark entry: iocb_ptr=^p, never-block=^i.", ME, I_iocb_ptr, never_block);
      318 
      319 /**** check environment */
      320      if ^ws_tty_mgr_$ok_iocb (I_iocb_ptr, iocb_ptr, mowse_io_data_ptr, code)
      321 	then goto read_with_mark_exit;
      322 
      323 /**** get buffer ptrs and sizes */
      324 
      325      buffer_ptr = addr (I_buffer);
      326      n_chars_to_read = length (I_buffer);
      327 
      328      if n_chars_to_read < 0
      329 	then do;
      330 	     code = error_table_$bad_arg;
      331 	     goto read_with_mark_exit;
      332 	end;
      333 
      334      read_ptr = buffer_ptr;
      335 
      336      read_data = convert_read_count (n_chars_to_read);
      337      read_data_ptr = addr (read_data);
      338      read_data_len = length (read_data);
      339 
      340      if never_block
      341 	then read_flags = WS_FLAG_NO_BLOCK;
      342 	else read_flags = WS_FLAG_NONE;
      343 
      344 /**** read it */
      345      if ws_tty_data$Flags.Trace = TRUE
      346 	then call ws_trace_ ("^a$read_with_mark: read_count=^i.", ME, mowse_io_data.ws.read_count);
      347 
      348      if (mowse_io_data.ws.read_count = 0) | (n_chars_to_read = 0) | (never_block)
      349 	then do;
      350 	     call ws_tty_mgr_$send_message (iocb_ptr, WS_READ_WITH_NO_ECHO, read_flags, read_data_ptr, read_data_len);
      351 	     mowse_io_data.ws.read_count = mowse_io_data.ws.read_count + 1;
      352 	end;
      353 
      354 unechoed_get_message:      /* come here to complete last unecho read request */
      355      call ws_tty_mgr_$get_message (iocb_ptr, read_ptr, n_chars_to_read, n_chars_read, get_msg_id);
      356 
      357 /**** check what was read */
      358      if get_msg_id = WS_END_NON_ECHOED_INPUT
      359 	then mowse_io_data.ws.read_count = mowse_io_data.ws.read_count - 1;
      360      else if get_msg_id ^= WS_UNECHOED_INPUT_CHARS
      361 	then if (get_msg_id = " ") & (n_chars_read = 0)	/* special case from start control order */
      362 		then /* ignore */;
      363 		else code = error_table_$improper_data_format;
      364 
      365      total_chars_read = total_chars_read + n_chars_read;
      366 
      367      if never_block & (mowse_io_data.ws.read_count > 0)
      368 	then do;
      369 	     offset = offset + n_chars_read;
      370 	     read_ptr = addr (buffer_ptr -> based_chars (offset));
      371 	     n_chars_to_read = max (0, n_chars_to_read - n_chars_read);
      372 	     read_data = convert_read_count (n_chars_to_read);
      373 	     goto unechoed_get_message;
      374 	end;
      375 
      376      if (total_chars_read > 0) & (code = 0)
      377 	then if mowse_io_data.ws.flags.mark_set
      378 		then do;
      379 		     mark_index = 1;
      380 		     mowse_io_data.ws.flags.mark_set = FALSE;
      381 		end;
      382 
      383 read_with_mark_exit:
      384      if ws_tty_data$Flags.Trace
      385 	then call ws_trace_ ("^a$read_with_mark exit: total_chars_read=^i, mark_index=^i, state=^i, code=^i.^/", ME,
      386 		total_chars_read, mark_index, state, code);
      387 
      388      O_n_chars_read = total_chars_read;
      389      O_mark_index = mark_index;
      390      O_state = state;
      391      O_code = code;
      392      return;
      393 
      394 /* ------------------------  END PROGRAM  ---------------------------------- */
      395 
      396 /* ------------------------  INTERNAL PROCEDURES  -------------------------- */
      397 
      398 clean_up:
      399      proc;
      400      n_chars_read, O_n_chars_read = 0;
      401      state = 0;
      402      return;
      403      end clean_up;
      404 
      405 /* ------------------------------------------------------------------------- */
      406 
      407 convert_read_count:
      408      proc (count) returns (char (2));
      409 
      410 dcl  count		       fixed bin (21) parm;
      411 dcl  count_chars		       char (2);
      412 dcl  1 count_bytes		       unaligned based (addr (count_chars)),
      413        2 hi		       fixed bin (8),
      414        2 lo		       fixed bin (8);
      415 
      416      if count < BYTE_SIZE
      417 	then do;
      418 	     count_bytes.hi = 0;
      419 	     count_bytes.lo = count;
      420 	end;
      421 	else do;
      422 	     count_bytes.hi = divide (count, BYTE_SIZE, 3);
      423 	     count_bytes.lo = count - (BYTE_SIZE * count_bytes.hi);
      424 	end;
      425      return (count_chars);
      426      end convert_read_count;
      427 
      428 /* ------------------------  INCLUDES  ------------------------------------- */
      429 
  1     1 /* BEGIN INCLUDE FILE ws_control_ids */
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(86-06-05,RBarstad), approve(86-12-11,MCR7585),
  1     5*     audit(87-01-28,Gilcrease), install(87-08-07,MR12.1-1075):
  1     6*     ws_tty_ <-> WSTERM message control ids
  1     7*  2) change(87-01-15,RBarstad), approve(87-01-15,MCR7585),
  1     8*     audit(87-01-28,Gilcrease), install(87-08-07,MR12.1-1075):
  1     9*     added control message flags
  1    10*                                                   END HISTORY COMMENTS */
  1    11 
  1    12 /* message control ids */
  1    13      dcl	   (
  1    14 	   WS_ABORT	       init ("ABT"),
  1    15 	   WS_ENTER_SYNC_MODE      init ("ESM"),
  1    16 	   WS_SYNC_MODE_ENTERED    init ("SME"),
  1    17 	   WS_EXIT_SYNC_MODE       init ("XSM"),
  1    18 	   WS_SYNC_MODE_EXITED     init ("SMX"),
  1    19 	   WS_END_ECHOED_INPUT     init ("EEI"),
  1    20 	   WS_END_NON_ECHOED_INPUT init ("ENI"),
  1    21 	   WS_READ_WITH_NO_ECHO    init ("RNE"),
  1    22 	   WS_READ_WITH_ECHO       init ("RWE"),
  1    23 	   WS_SET_BREAK_TABLE      init ("SBT"),
  1    24 	   WS_SET_TTY_MODES	       init ("STM"),
  1    25 	   WS_ECHOED_INPUT_CHARS   init ("EIC"),
  1    26 	   WS_UNECHOED_INPUT_CHARS init ("UIC"),
  1    27 	   WS_PRINTER_ON	       init ("PON"),
  1    28 	   WS_PRINTER_OFF	       init ("POF"),
  1    29 	   WS_DISPLAY_TEXT	       init ("DTX"),
  1    30 	   WS_ORDER	       init ("ORD")
  1    31 	   ) char (3) internal static options (constant);
  1    32 
  1    33 /* control message flags */
  1    34      dcl	   (
  1    35 	   WS_FLAG_NONE	       init ("000000000"b),
  1    36              WS_FLAG_NO_BLOCK        init ("010000000"b)  /* don't block on read */
  1    37 	   ) bit (9) internal static options (constant);
  1    38 
  1    39 /* END INCLUDE FILE ws_control_ids */
      430 
      431 
  2     1 /* BEGIN INCLUDE FILE ws_tty_data */
  2     2 
  2     3 /****^  HISTORY COMMENTS:
  2     4*  1) change(86-12-05,RBarstad), approve(86-12-11,MCR7585),
  2     5*     audit(86-12-12,Gilcrease), install(87-08-07,MR12.1-1075):
  2     6*     ws_tty_ external static
  2     7*                                                   END HISTORY COMMENTS */
  2     8 
  2     9 dcl 1 ws_tty_data$Flags	aligned external static,
  2    10       3 Debug		bit (1) unaligned,
  2    11       3 Trace		bit (1) unaligned,
  2    12       3 Pad 		bit (34) unaligned;
  2    13 
  2    14 /* END INCLUDE FILE ws_tty_data */
      432 
      433 
  3     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  3     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  3     3*      version number to IOX2. */
  3     4 /* format: style2 */
  3     5 
  3     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  3     7 	     2 version	      character (4) aligned,	/* IOX2 */
  3     8 	     2 name	      char (32),		/* I/O name of this block. */
  3     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  3    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  3    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  3    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  3    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  3    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  3    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  3    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  3    17 						/* open(p,mode,not_used,s) */
  3    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  3    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  3    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  3    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    24 						/* put_chars(p,bufptr,buflen,s) */
  3    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  3    26 						/* modes(p,newmode,oldmode,s) */
  3    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  3    28 						/* position(p,u1,u2,s) */
  3    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  3    30 						/* control(p,order,infptr,s) */
  3    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  3    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    34 						/* write_record(p,bufptr,buflen,s) */
  3    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  3    36 						/* rewrite_record(p,bufptr,buflen,s) */
  3    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  3    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    39 						/* seek_key(p,key,len,s) */
  3    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    41 						/* read_key(p,key,len,s) */
  3    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  3    43 						/* read_length(p,len,s) */
  3    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  3    45 						/* open_file(p,mode,desc,not_used,s) */
  3    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  3    47 						/* close_file(p,desc,s) */
  3    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  3    49 						/* detach(p,desc,s) */
  3    50 
  3    51      declare iox_$iocb_version_sentinel
  3    52 			      character (4) aligned external static;
  3    53 
  3    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      434 
      435 
  4     1 /*  BEGIN INCLUDE FILE:	mowse_io_data.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3 /****^  HISTORY COMMENTS:
  4     4*  1) change(87-04-16,Flegel), approve(87-07-15,MCR7580),
  4     5*     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
  4     6*     Created.
  4     7*  2) change(87-06-23,Flegel), approve(87-06-23,MCR7649),
  4     8*     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
  4     9*     Converted to support the use of event channels.
  4    10*  3) change(88-10-06,Flegel), approve(88-11-16,MCR8023), audit(88-12-12,Lee),
  4    11*     install(89-01-24,MR12.3-1012):
  4    12*     phx21215 - Added mowse_io_data.channel_info.foreground to use to generate
  4    13*                events when something happens in the foreground.
  4    14*                                                   END HISTORY COMMENTS */
  4    15 
  4    16 /* format: style4,indattr,ifthen,^indcomtxt,thendo,^indproc,^indblkcom,initcol1,declareind8,dclind4,struclvlind3,comcol55 */
  4    17 dcl mowse_io_data_ptr      ptr;
  4    18 dcl 01 mowse_io_data       based (mowse_io_data_ptr),
  4    19        02 open_descrip     char (19) var,
  4    20        02 iocb_ptr	       ptr aligned,		    /* mowse_tty iocb pointer */
  4    21        02 default_iocb_ptr ptr aligned,		    /* mowse_i/o iocb pointer */
  4    22        02 attach_descrip   char (256) var,	    /* Attach description */
  4    23        02 old_modes	       char (256) unal,	    /* Modes on previous iocb */
  4    24 
  4    25        02 current_modes    char (256) unal,	    /* Current mode settings */
  4    26        02 WSTERM_modes     (11) char (1),	    /* Encoded modes for WSTERM */
  4    27        02 cv_trans_struc_ptr ptr,		    /* Conversion table pointer */
  4    28 
  4    29        02 info_ptr	       ptr,		    /* Application control info seg */
  4    30        02 mcb_ptr	       ptr,		    /* Internal MCB to MOWSE */
  4    31        02 sleepers	       ptr,		    /* Queue of sleeping applications */
  4    32        02 dozers	       fixed bin (35),	    /* Number of unhandled sleeper wakeups */
  4    33 
  4    34        02 ws,				    /* Vidoe system control */
  4    35 	03 flags,
  4    36 	   04 trace      bit (1) unal,
  4    37 	   04 debug      bit (1) unal,
  4    38 	   04 mark_set   bit (1) unal,
  4    39 	   04 video_mode bit (1) unal,	    /* State (on/off) of video */
  4    40 	   04 more_input bit (1) unal,	    /* Last read unfinished */
  4    41 	   04 pad	       bit (31) unal,
  4    42 	03 read_count    fixed bin (17),	    /* count of unfinished read commands sent */
  4    43 	03 ips_mask      bit (36) aligned,
  4    44 
  4    45        02 sus_data,				    /* sus_ information */
  4    46 	03 sus_entry     ptr,		    /* Saved sus_ signal handler */
  4    47 	03 activated     bit (1) unal,	    /* If sus_ has been signaled */
  4    48 	03 pad	       bit (35) unal,
  4    49 
  4    50        02 channel_info,			    /* Event channel info */
  4    51 	03 process_id    bit (36) aligned,	    /* This process */
  4    52 	03 wake_info,
  4    53 	   04 wake_map   (0:127) bit (1) unal,	    /* Break chars */
  4    54 	   04 pad	       bit (16) unal,
  4    55 	03 user_input    like wait_info,	    /* Input wait channel */
  4    56 	03 packet_transmitter like wait_info,	    /* Write events */
  4    57 	03 packet_receiver,			    /* hcs_ events */
  4    58 	   04 channel    fixed bin (71),	    /* Channel id */
  4    59 	03 packet_dispatcher,		    /* Dispatch channels */
  4    60 	   04 sync_channel fixed bin (71),	    /* Process when quiet */
  4    61 	   04 async_channel fixed bin (71),	    /* Process NOW! */
  4    62 	03 foreground,			    /* MF - phx21215 - read/write_status, get_event_channel info */
  4    63 	   04 channel    fixed bin (71),	    /* Event channel */
  4    64 
  4    65        02 debug_iocb_ptr   ptr,		    /* Debug file IOCB */
  4    66        02 trace_iocb_ptr   ptr,		    /* Trace file IOCB */
  4    67 
  4    68        02 timer_info       (8),
  4    69 	03 wakeup	       fixed bin (71),	    /* Seconds from last in queue */
  4    70 	03 timer_id      fixed bin,		    /* Who owns this wakeup */
  4    71 
  4    72        02 switches,				    /* Control switches */
  4    73 	03 quit_enable   bit (1) unal,	    /* Quit processing state */
  4    74 	03 reset_write   bit (1) unal,	    /* resetwrite requested */
  4    75 	03 disconnect_active bit (1) unal,	    /* Disconnection occuring */
  4    76 	03 rs_pending    (2) bit (1) unal,	    /* Reset occuring */
  4    77 	03 ds_pending    (2) bit (1) unal,	    /* Disconnect occuring */
  4    78 	03 br_pending    bit (1) unal,	    /* Break occurring */
  4    79 	03 brk_pending   bit (1) unal,	    /* Break occuring (quit) */
  4    80 	03 info_stored   bit (1) unal,	    /* Info segment stored */
  4    81 	03 connect_active bit (1) unal,	    /* Connection in progress */
  4    82 	03 start_issued  bit (1) unal,	    /* Indicates start order pending */
  4    83 	03 pad	       bit (24) unal,
  4    84 
  4    85        02 task,
  4    86 	03 active	       (0:2) bit (1) unal,	    /* Tasks which are active */
  4    87 	03 pad	       bit (33) unal,
  4    88 
  4    89        02 user_input,			    /* User_i/o input data */
  4    90 	03 in	       fixed bin (21),	    /* Next free slot in repository */
  4    91 	03 out	       fixed bin (21),	    /* Head of data */
  4    92 	03 queue	       (0:4095) char (1),	    /* Repository */
  4    93 
  4    94        02 l_dat	       (0:1),		    /* Local data message queue */
  4    95 	03 in_ptr	       ptr,		    /* Incoming messages */
  4    96 	03 out_ptr       ptr,		    /* Outgoing messages */
  4    97 
  4    98        02 r,				    /* Receiver data */
  4    99 	03 eop	       char (1),		    /* End of packet character */
  4   100 	03 sop	       char (1),		    /* Start of packet character */
  4   101 	03 esc	       (0:2) char (1),	    /* 3 escape characters */
  4   102 	03 esc_count     fixed bin,		    /* Number of escaped chars in received packet */
  4   103 	03 asn	       (0:1) fixed bin (3),	    /* Acknowledge sequence number */
  4   104 	03 dat	       (0:1, 0:3) char (124) var, /* Data queues */
  4   105 	03 pkt	       (0:2) char (129) var,	    /* Packet queue */
  4   106 	03 pktin	       fixed bin,		    /* Next packet character in */
  4   107 	03 pktout	       fixed bin,		    /* Head of packet */
  4   108 	03 psn	       (0:1) fixed bin,	    /* SN for each channel */
  4   109 	03 esckey	       bit (9) unal,	    /* Decoding 2nd character escape */
  4   110 	03 ignoring      (0:1) bit (1) unal,	    /* Ignore data during synchronization */
  4   111 	03 pad	       bit (25) unal,
  4   112 
  4   113        02 s,				    /* Sender data */
  4   114 	03 eop	       char (1),		    /* End of packet character */
  4   115 	03 sop	       char (1),		    /* Start of packet character */
  4   116 	03 esc	       (0:2) char (1),	    /* 3 escape characters */
  4   117 	03 dat	       (0:1, 0:3) char (124) var, /* Data queue */
  4   118 	03 psn	       (0:1) fixed bin (3),	    /* Packet sequence number */
  4   119 	03 lasn	       (0:1) fixed bin (3),	    /* Last ack sent */
  4   120 	03 nasn	       (0:1) fixed bin (3),	    /* Next ack to be sent */
  4   121 	03 escreq	       (0:255) bit (1) unal,	    /* Characters to be escaped */
  4   122 	03 pad	       bit (32) unal;
  4   123 
  4   124 /* Wait channel control struncture */
  4   125 
  4   126 dcl 01 wait_info	       based,
  4   127        02 channel	       fixed bin (71) aligned,    /* Channel ID */
  4   128        02 count	       fixed bin,		    /* Waiting count */
  4   129        02 flags,
  4   130 	03 transmitted   bit (1) unal,	    /* Wakeup already generated */
  4   131 	03 pad	       bit (35) unal;
  4   132 
  4   133 /*  END INCLUDE FILE:	mowse_io_data.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  */
      436 
      437 
      438      end ws_tty_read_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/24/89  0849.2  ws_tty_read_.pl1                  >spec>install>MR12.3-1012>ws_tty_read_.pl1
430          1    08/10/87  1335.8  ws_control_ids.incl.pl1           >ldd>include>ws_control_ids.incl.pl1
432          2    08/10/87  1335.8  ws_tty_data.incl.pl1              >ldd>include>ws_tty_data.incl.pl1
434          3    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
436          4    01/24/89  0847.4  mowse_io_data.incl.pl1            >spec>install>MR12.3-1012>mowse_io_data.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BYTE_SIZE                              constant        fixed bin(17,0)          initial dcl 75 ref 416 422 423
FALSE                                  constant        bit(1)                   initial packed unaligned dcl 75 ref 380
I_buffer                               parameter       char                     packed unaligned dcl 36 set ref 301 325 326
I_buffer_ptr                           parameter       pointer                  dcl 37 ref 105 109 170 175
I_iocb_ptr                             parameter       pointer                  dcl 39 set ref 105 119* 124* 170 189* 196* 301 316*
                                                                                  320*
I_n_chars_to_read                      parameter       fixed bin(21,0)          dcl 34 ref 105 111 170 177
I_never_block                          parameter       bit(1)                   dcl 40 ref 301 305
I_offset                               parameter       fixed bin(21,0)          dcl 35 ref 105 110 170 176
I_screen_left                          parameter       fixed bin(17,0)          dcl 38 ref 170 178
ME                              000007 constant        char(12)                 initial packed unaligned dcl 75 set ref 119* 141*
                                                                                  162* 189* 212* 292* 316* 345* 383*
O_code                                 parameter       fixed bin(35,0)          dcl 41 set ref 105 167* 170 298* 301 391*
O_echoed                               parameter       fixed bin(21,0)          dcl 42 set ref 170 189* 290*
O_mark_index                           parameter       fixed bin(21,0)          dcl 43 set ref 301 389*
O_n_chars_read                         parameter       fixed bin(21,0)          dcl 44 set ref 105 159* 170 288* 301 388* 400*
O_state                                parameter       fixed bin(17,0)          dcl 45 set ref 105 166* 170 297* 301 390*
TRUE                                   constant        bit(1)                   initial packed unaligned dcl 75 ref 119 141 162 212
                                                                                  345
Trace                     0(01) 000024 external static bit(1)                   level 2 packed packed unaligned dcl 2-9 ref 119 141
                                                                                  162 189 212 292 316 345 383
WS_ECHOED_INPUT_CHARS           000002 constant        char(3)                  initial packed unaligned dcl 1-13 ref 275
WS_END_ECHOED_INPUT             000006 constant        char(3)                  initial packed unaligned dcl 1-13 ref 259 264
WS_END_NON_ECHOED_INPUT         000005 constant        char(3)                  initial packed unaligned dcl 1-13 ref 154 233 358
WS_FLAG_NONE                    000025 constant        bit(9)                   initial packed unaligned dcl 1-34 set ref 147* 253*
                                                                                  342
WS_FLAG_NO_BLOCK                000000 constant        bit(9)                   initial packed unaligned dcl 1-34 set ref 225* 340
WS_READ_WITH_ECHO               000003 constant        char(3)                  initial packed unaligned dcl 1-13 set ref 253*
WS_READ_WITH_NO_ECHO            000004 constant        char(3)                  initial packed unaligned dcl 1-13 set ref 147* 225*
                                                                                  350*
WS_UNECHOED_INPUT_CHARS         000001 constant        char(3)                  initial packed unaligned dcl 1-13 ref 156 236 360
addr                                                   builtin function         dcl 98 ref 135 138 210 220 240 272 325 337 370 418
                                                                                  419 422 423 423
based_chars                            based           char(1)                  array packed unaligned dcl 70 set ref 135 210 240
                                                                                  272 370
buffer_ptr                      000112 automatic       pointer                  dcl 58 set ref 109* 119* 135 175* 189* 210 240 272
                                                                                  325* 334 370
cleanup                         000126 stack reference condition                dcl 100 ref 117 187 314
code                            000100 automatic       fixed bin(35,0)          dcl 49 set ref 114* 124* 131* 156* 162* 167 181*
                                                                                  196* 206* 248* 259 284* 292* 298 308* 320* 330*
                                                                                  363* 376 383* 391
count                                  parameter       fixed bin(21,0)          dcl 410 ref 407 416 419 422 423
count_bytes                            based           structure                level 1 packed packed unaligned dcl 412
count_chars                     000152 automatic       char(2)                  packed unaligned dcl 411 set ref 418 419 422 423 423
                                                                                  425
divide                                                 builtin function         dcl 98 ref 422
echoed                          000101 automatic       fixed bin(21,0)          dcl 50 set ref 184* 266* 266 275* 275 290 292*
error_table_$bad_arg            000010 external static fixed bin(35,0)          dcl 84 ref 131 206 330
error_table_$improper_data_format
                                000012 external static fixed bin(35,0)          dcl 84 ref 156 248 284 363
flags                   327            based           structure                level 3 packed packed unaligned dcl 4-18
get_msg_id                      000105 automatic       char(3)                  packed unaligned dcl 53 set ref 151* 154 156 185*
                                                                                  230* 233 236 244 259 261* 264 275 278 354* 358 360
                                                                                  360
hi                                     based           fixed bin(8,0)           level 2 packed packed unaligned dcl 412 set ref 418*
                                                                                  422* 423
iocb_ptr                        000102 automatic       pointer                  dcl 51 set ref 124* 147* 151* 196* 225* 230* 253*
                                                                                  261* 320* 350* 354*
length                                                 builtin function         dcl 98 ref 139 221 326 338
lo                        0(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 412 set ref 419*
                                                                                  423*
mark_index                      000104 automatic       fixed bin(21,0)          dcl 52 set ref 310* 379* 383* 389
mark_set                327(02)        based           bit(1)                   level 4 packed packed unaligned dcl 4-18 set ref 376
                                                                                  380*
max                                                    builtin function         dcl 98 ref 371
min                                                    builtin function         dcl 98 ref 218
mowse_io_data                          based           structure                level 1 unaligned dcl 4-18
mowse_io_data_ptr               000134 automatic       pointer                  dcl 4-17 set ref 124* 141 145 148 148 154 154 196*
                                                                                  212 223 227 227 229 233 233 267 320* 345 348 351
                                                                                  351 358 358 367 376 380
n_chars_read                    000107 automatic       fixed bin(21,0)          dcl 55 set ref 116* 151* 159 162* 183* 230* 232 238
                                                                                  239 244 261* 263 266 270 271 275 278 311* 354* 360
                                                                                  365 369 371 400*
n_chars_to_read                 000106 automatic       fixed bin(21,0)          dcl 54 set ref 111* 119* 129 137* 145 151* 177* 189*
                                                                                  201 204 218* 218 219* 230* 239* 239 241* 259 261*
                                                                                  271* 271 273* 281* 326* 328 336* 348 354* 371* 371
                                                                                  372*
never_block                     000110 automatic       bit(1)                   dcl 56 set ref 305* 316* 340 348 367
offset                          000111 automatic       fixed bin(21,0)          dcl 57 set ref 110* 119* 135 176* 189* 210 238* 238
                                                                                  240 270* 270 272 313* 369* 369 370
read_count              330            based           fixed bin(17,0)          level 3 dcl 4-18 set ref 141* 145 148* 148 154* 154
                                                                                  212* 223 227* 227 229 233* 233 267* 345* 348 351*
                                                                                  351 358* 358 367
read_data                       000116 automatic       char(2)                  packed unaligned dcl 60 set ref 137* 138 139 219*
                                                                                  220 221 241* 273* 336* 337 338 372*
read_data_len                   000117 automatic       fixed bin(21,0)          dcl 61 set ref 139* 147* 221* 225* 253* 338* 350*
read_data_ptr                   000120 automatic       pointer                  dcl 62 set ref 138* 147* 220* 225* 253* 337* 350*
read_flags                      000125 automatic       bit(9)                   packed unaligned dcl 66 set ref 340* 342* 350*
read_ptr                        000114 automatic       pointer                  dcl 59 set ref 135* 151* 210* 230* 240* 261* 272*
                                                                                  334* 354* 370*
screen_left                     000122 automatic       fixed bin(17,0)          dcl 63 set ref 178* 189* 216 218
state                           000123 automatic       fixed bin(17,0)          dcl 64 set ref 115* 162* 166 182* 292* 297 309* 383*
                                                                                  390 401*
total_chars_read                000124 automatic       fixed bin(17,0)          dcl 65 set ref 186* 232* 232 253 263* 263 288 292*
                                                                                  312* 365* 365 376 383* 388
wait_info                              based           structure                level 1 unaligned dcl 4-126
ws                      327            based           structure                level 2 unaligned dcl 4-18
ws_trace_                       000022 constant        entry                    external dcl 94 ref 119 141 162 189 212 292 316 345
                                                                                  383
ws_tty_data$Flags               000024 external static structure                level 1 dcl 2-9
ws_tty_mgr_$get_message         000020 constant        entry                    external dcl 93 ref 151 230 261 354
ws_tty_mgr_$ok_iocb             000014 constant        entry                    external dcl 91 ref 124 196 320
ws_tty_mgr_$send_message        000016 constant        entry                    external dcl 92 ref 147 225 253 350

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
WS_ABORT                               internal static char(3)                  initial packed unaligned dcl 1-13
WS_DISPLAY_TEXT                        internal static char(3)                  initial packed unaligned dcl 1-13
WS_ENTER_SYNC_MODE                     internal static char(3)                  initial packed unaligned dcl 1-13
WS_EXIT_SYNC_MODE                      internal static char(3)                  initial packed unaligned dcl 1-13
WS_ORDER                               internal static char(3)                  initial packed unaligned dcl 1-13
WS_PRINTER_OFF                         internal static char(3)                  initial packed unaligned dcl 1-13
WS_PRINTER_ON                          internal static char(3)                  initial packed unaligned dcl 1-13
WS_SET_BREAK_TABLE                     internal static char(3)                  initial packed unaligned dcl 1-13
WS_SET_TTY_MODES                       internal static char(3)                  initial packed unaligned dcl 1-13
WS_SYNC_MODE_ENTERED                   internal static char(3)                  initial packed unaligned dcl 1-13
WS_SYNC_MODE_EXITED                    internal static char(3)                  initial packed unaligned dcl 1-13
iocb                                   based           structure                level 1 dcl 3-6
iox_$iocb_version_sentinel             external static char(4)                  dcl 3-51

NAMES DECLARED BY EXPLICIT CONTEXT.
clean_up                        002045 constant        entry                    internal dcl 398 ref 117 187 314
convert_read_count              002057 constant        entry                    internal dcl 407 ref 137 219 241 273 336 372
read                            000256 constant        entry                    external dcl 105
read_done                       000555 constant        label                    dcl 159
read_echoed                     000634 constant        entry                    external dcl 170
read_echoed_done                001325 constant        label                    dcl 288 set ref 201
read_echoed_exit                001332 constant        label                    dcl 292 ref 196 207
read_exit                       000557 constant        label                    dcl 162 ref 124 132
read_with_mark                  001407 constant        entry                    external dcl 301
read_with_mark_exit             001770 constant        label                    dcl 383 ref 320 331
unechoed_get_message            001660 constant        label                    dcl 354 ref 373
ws_tty_read_                    000242 constant        entry                    external dcl 16

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2306        2334    2122        2316
Length      2634    2122        26         263     164           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ws_tty_read_                        186 external procedure  is an external procedure.  
on unit on line 117                  64 on unit               
on unit on line 187                  64 on unit               
on unit on line 314                  64 on unit               
clean_up                             64 internal procedure  is called by several nonquick procedures.  
convert_read_count                      internal procedure  shares stack frame of external procedure ws_tty_read_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ws_tty_read_             000100 code                        ws_tty_read_
                         000101 echoed                      ws_tty_read_
                         000102 iocb_ptr                    ws_tty_read_
                         000104 mark_index                  ws_tty_read_
                         000105 get_msg_id                  ws_tty_read_
                         000106 n_chars_to_read             ws_tty_read_
                         000107 n_chars_read                ws_tty_read_
                         000110 never_block                 ws_tty_read_
                         000111 offset                      ws_tty_read_
                         000112 buffer_ptr                  ws_tty_read_
                         000114 read_ptr                    ws_tty_read_
                         000116 read_data                   ws_tty_read_
                         000117 read_data_len               ws_tty_read_
                         000120 read_data_ptr               ws_tty_read_
                         000122 screen_left                 ws_tty_read_
                         000123 state                       ws_tty_read_
                         000124 total_chars_read            ws_tty_read_
                         000125 read_flags                  ws_tty_read_
                         000134 mowse_io_data_ptr           ws_tty_read_
                         000152 count_chars                 convert_read_count

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_other      return_mac          enable_op           ext_entry
ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ws_trace_                     ws_tty_mgr_$get_message       ws_tty_mgr_$ok_iocb           ws_tty_mgr_$send_message

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$improper_data_format                           ws_tty_data$Flags




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     16 000241        18 000247       105 000250       109 000272       110 000276       111 000300       114 000302
    115 000303       116 000304       117 000305       119 000327       124 000373       129 000416       131 000420
    132 000423       135 000424       137 000430       138 000432       139 000434       141 000436       145 000473
    147 000500       148 000517       151 000521       154 000540       156 000550       159 000555       162 000557
    166 000620       167 000622       168 000624       170 000625       175 000650       176 000654       177 000656
    178 000660       181 000662       182 000663       183 000664       184 000665       185 000666       186 000670
    187 000671       189 000713       196 000764       201 001007       204 001011       206 001012       207 001015
    210 001016       212 001022       216 001054       218 001056       219 001062       220 001064       221 001066
    223 001070       225 001073       227 001112       229 001114       230 001117       232 001136       233 001140
    236 001150       238 001152       239 001154       240 001156       241 001162       242 001164       244 001165
    248 001176       249 001201       253 001202       257 001223       259 001224       261 001234       263 001253
    264 001255       266 001261       267 001263       268 001265       270 001266       271 001270       272 001272
    273 001276       275 001300       278 001307       281 001317       282 001320       284 001321       286 001324
    288 001325       290 001327       292 001332       297 001374       298 001376       299 001400       301 001401
    305 001431       308 001435       309 001436       310 001437       311 001440       312 001441       313 001442
    314 001443       316 001465       320 001521       325 001544       326 001547       328 001551       330 001552
    331 001555       334 001556       336 001557       337 001561       338 001563       340 001565       342 001573
    345 001575       348 001627       350 001637       351 001656       354 001660       358 001677       360 001707
    363 001722       365 001725       367 001727       369 001735       370 001737       371 001743       372 001751
    373 001753       376 001754       379 001764       380 001766       383 001770       388 002032       389 002034
    390 002037       391 002041       392 002043       398 002044       400 002052       401 002055       402 002056
    407 002057       416 002061       418 002064       419 002066       420 002070       422 002071       423 002074
    425 002104


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
