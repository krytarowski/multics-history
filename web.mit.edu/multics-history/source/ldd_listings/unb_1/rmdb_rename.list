	COMPILATION LISTING OF SEGMENT rmdb_rename
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1337.8 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /* format: ^inddcls,^indattr,indnoniterend,^indnoniterdo,indend,tree,^case,insnl,comcol61,dclind5,declareind5,delnl */
        8 
        9 /*DESCRIPTION
       10*  This subroutine implements renaming of domains, attributes and relation.
       11**/
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
       15*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
       16*     written
       17*                                                   END HISTORY COMMENTS */
       18 
       19 rmdb_rename:
       20      proc (Irmdb_ctl_ptr, Irename_object_info_ptr, Oerror_message, Ocode);
       21 
       22 	rmdb_ctl_ptr = Irmdb_ctl_ptr;
       23 	rename_object_info_ptr = Irename_object_info_ptr;
       24 	local_iocb = rmdb_ctl.crossref_file_info.iocb_ptr;
       25 	dbm_ptr = rmdb_ctl.db_model_ptr;
       26 
       27 	if rename_object_info.version ^= rename_object_info_version_1
       28 	then call error (error_table_$unimplemented_version,
       29 		"Version " || rename_object_info.version || " for the rename_object_info structure.");
       30 
       31 	if /* case */ rename_object_info.type = RENAME_ATTRIBUTE
       32 	then do;
       33 	     rename_entry = rename_attribute;
       34 	     key_head = ATTRIBUTE_KEY_HEAD;
       35 	     end;
       36 	else if rename_object_info.type = RENAME_DOMAIN
       37 	then do;
       38 	     rename_entry = rename_domain;
       39 	     key_head = DOMAIN_KEY_HEAD;
       40 	     end;
       41 	else if rename_object_info.type = RENAME_RELATION
       42 	then do;
       43 	     rename_entry = rename_relation;
       44 	     key_head = RELATION_KEY_HEAD;
       45 	     end;
       46 	else call error (mrds_error_$internal_error,
       47 		"Rename operation of type " || ltrim (char (rename_object_info.type)));
       48 
       49 	if local_iocb = null
       50 	then do;
       51 	     call mdbm_util_$xref_build (rmdb_ctl.temp_dir_path, rmdb_ctl.absolute_db_path, dbm_ptr,
       52 		rmdb_ctl.crossref_file_info.name, local_iocb, error_message, code);
       53 	     if code ^= 0
       54 	     then call error (code, error_message);
       55 	     rmdb_ctl.crossref_file_info.iocb_ptr = local_iocb;
       56 	     end;
       57 
       58 	max_seg_size = sys_info$max_seg_size * 4;
       59 
       60 	tempp, fm_ptr = null;
       61 	on cleanup call cleaner;
       62 
       63 /* Verify all of the input arguments. See that all the from names are there and
       64*   all the to names aren't. */
       65 	do loop = 1 to rename_object_info.count;
       66 	     call mdbm_util_$xref_find_record (local_iocb, rtrim (key_head), rename_object_info.from (loop), null, 0,
       67 		error_message, code);
       68 	     if code ^= 0
       69 	     then if code = error_table_$no_record
       70 		then do;
       71 		     if rename_object_info.type = RENAME_ATTRIBUTE
       72 		     then code = mrds_error_$no_model_attr;
       73 		     else if rename_object_info.type = RENAME_DOMAIN
       74 			then code = mrds_error_$no_model_dom;
       75 			else code = mrds_error_$no_model_rel;
       76 		     call error (code, rename_object_info.from (loop));
       77 		     end;
       78 		else call error (code, error_message);
       79 
       80 	     call mdbm_util_$xref_find_record (local_iocb, rtrim (key_head), rename_object_info.to (loop), null, 0,
       81 		error_message, code);
       82 	     if code = 0
       83 	     then do;
       84 		if rename_object_info.type = RENAME_ATTRIBUTE
       85 		then code = mrds_error_$attr_already_exists;
       86 		else if rename_object_info.type = RENAME_DOMAIN
       87 		     then code = mrds_error_$domain_already_defined;
       88 		     else code = mrds_error_$dup_rel;
       89 		call error (code, rename_object_info.to (loop));
       90 		end;
       91 	     else if code ^= error_table_$no_record
       92 		then call error (code, error_message);
       93 	     end;					/* do loop */
       94 
       95 	call mdbm_util_$get_temp_segment_path (rmdb_ctl.temp_dir_path, myname, tempp, code);
       96 	if code ^= 0
       97 	then call error (code, "Unable to get temp segments.");
       98 
       99 /* Actually rename the suckers now. */
      100 	do loop = 1 to rename_object_info.count;
      101 	     call rename_entry (rename_object_info.from (loop), rename_object_info.to (loop));
      102 	     end;					/* do loop */
      103 
      104 	call cleaner;
      105 	call error (0, "");
      106 
      107 RETURN_TO_CALLER:
      108 	return;
      109 
      110 cleaner:
      111      proc;
      112 
      113 	if tempp ^= null
      114 	then call mdbm_util_$free_temp_segment (myname, tempp, (0));
      115 	if fm_ptr ^= null
      116 	then call terminate_file_ (fm_ptr, 0, TERM_FILE_TERM, (0));
      117 	return;
      118      end cleaner;
      119 
      120 error:
      121      proc (cd, msg);
      122 
      123 dcl  cd fixed bin (35) parameter;
      124 dcl  msg char (*) parameter;
      125 
      126 	Ocode = cd;
      127 	if Ocode = 0
      128 	then Oerror_message = "";
      129 	else Oerror_message = msg;
      130 
      131 	call cleaner;
      132 	goto RETURN_TO_CALLER;
      133 
      134      end error;
      135 
      136 /*DESCRIPTION
      137*  This implements renaming a single attribute. Note that quits are trapped
      138*  during critical code. Steps Are:
      139*  - if the attribute is unreferenced rename the attribute in db_model
      140*  - otherwise
      141*    - mark the db and resultant inconsistent.
      142*    - get the attribute xref record.
      143*    - for each relation in the xref
      144*      - initiate the file_model
      145*      - find the attribute within the file_model
      146*      - rename the attribute within the file_model
      147*      - rename the attribute within the referenced domain xref record
      148*    - mark the db consistent
      149*  - rename the attribute xref record.
      150*  - add a history entry
      151**/
      152 
      153 rename_attribute:
      154      proc (ra_from, ra_to);
      155 
      156 dcl  ra_attribute_xref_ptr ptr;
      157 dcl  ra_from char (*) parameter;
      158 dcl  ra_loop fixed bin;
      159 dcl  ra_relation_name char (32);
      160 dcl  ra_to char (*) parameter;
      161 dcl  ra_unreferenced_domain bit (1) aligned;
      162 
      163 	ra_unreferenced_domain = "0"b;
      164 	goto RENAME_ATTRIBUTE_COMMON;
      165 
      166 rename_attribute$unreferenced_domain:
      167      entry (ra_from, ra_to);
      168 
      169 	ra_unreferenced_domain = "1"b;
      170 	goto RENAME_ATTRIBUTE_COMMON;
      171 
      172 RENAME_ATTRIBUTE_COMMON:
      173 
      174 	ra_attribute_xref_ptr = tempp;
      175 
      176 /* Get the attribute crossreference record */
      177 	call mdbm_util_$xref_find_record (local_iocb, ATTRIBUTE_KEY_HEAD, ra_from, ra_attribute_xref_ptr, max_seg_size,
      178 	     error_message, code);
      179 	if code ^= 0
      180 	then call error (code, error_message);
      181 
      182 /* BEGIN CRITICAL CODE */
      183 	quit_occurred = FALSE;
      184 	on quit quit_occurred = TRUE; 
      185 
      186 /* disallow renaming of generated attributes */
      187 	di_ptr = ptr (dbm_ptr, ra_attribute_xref_ptr -> crossref_info_record.offset);
      188 	if domain_info.name = ra_from
      189 	then call error (error_table_$unsupported_operation, 
      190 	     "Attempt to rename a generated attribute: " || ra_from);
      191 
      192 	if ra_attribute_xref_ptr -> crossref_info_record.count = 0
      193 	then if ra_unreferenced_domain		/* unreferenced attribute */
      194 	     then do;				/* this is the generated attribute */
      195 		call mdbm_util_$xref_modify_record_name (local_iocb, ATTRIBUTE_KEY_HEAD, ra_from, ra_to, ra_attribute_xref_ptr, error_message, code);
      196 		if code ^= 0
      197 		then call error (code, error_message);
      198 		di_ptr = ptr (dbm_ptr, ra_attribute_xref_ptr -> crossref_info_record.offset);
      199 		call mdbm_util_$xref_modify_reference_name (local_iocb, DOMAIN_KEY_HEAD, (domain_info.name), ra_from,
      200 		     ra_to, error_message, code);
      201 		if code ^= 0
      202 		then call error (code, error_message);
      203 		end;
      204 	     else do;
      205 		continue = TRUE;
      206 		do ua_ptr = ptr (dbm_ptr, db_model.unreferenced_attribute_ptr)
      207 		     repeat ptr (dbm_ptr, unreferenced_attribute.fwd_thread) while (rel (ua_ptr) ^= NULL_OFFSET & continue);
      208 		     if unreferenced_attribute.name = ra_from
      209 		     then do;
      210 			unreferenced_attribute.name = ra_to;
      211 			continue = FALSE;
      212 			di_ptr = ptr (dbm_ptr, ra_attribute_xref_ptr -> crossref_info_record.offset);
      213 			call mdbm_util_$xref_modify_reference_name (local_iocb, DOMAIN_KEY_HEAD, (domain_info.name), ra_from,
      214 			     ra_to, error_message, code);
      215 			if code ^= 0
      216 			then call error (code, error_message);
      217 			call mdbm_util_$xref_modify_record_name (local_iocb, ATTRIBUTE_KEY_HEAD, ra_from, ra_to, 
      218 			     null(), error_message, code);
      219 			if code ^= 0
      220 			then call error (code, error_message);
      221 			end;
      222 		     end;				/* do ua_ptr */
      223 		end;
      224 	else do;					/* referenced attribute */
      225 
      226 /* Mark database inconsistent */
      227 	     rmdb_ctl.saved_res_version_ptr -> based_char8 = "RESTRUCT";
      228 	     if ra_unreferenced_domain
      229 	     then call mdbm_util_$inconsistent_set (dbm_ptr, "rename_domain",
      230 		     "Renaming domain " || rtrim (ra_from) || " to " || rtrim (ra_to),
      231 		     "undo_rename " || rtrim (ra_to) || " " || rtrim (ra_from));
      232 	     else call mdbm_util_$inconsistent_set (dbm_ptr, "rename_attribute",
      233 		     "Renaming attribute " || rtrim (ra_from) || " to " || rtrim (ra_to),
      234 		     "undo_rename " || rtrim (ra_to) || " " || rtrim (ra_from));
      235 
      236 	     fm_ptr = null;
      237 	     on cleanup call cleaner;
      238 
      239 /* Do for all relations this attribute is referenced in */
      240 	     do ra_loop = 1 to ra_attribute_xref_ptr -> crossref_info_record.count;
      241 
      242 /* Try to open the file_model */
      243 		ra_relation_name = rtrim (ra_attribute_xref_ptr -> crossref_info_record.object (ra_loop)) || ".m";
      244 		call initiate_file_ (rmdb_ctl.absolute_db_path, ra_relation_name, RW_ACCESS, fm_ptr, (0), code);
      245 		if code ^= 0
      246 		then call error (code, "Initiating relation " || ra_relation_name);
      247 
      248 /* rename the attr_info name in the file_model */
      249 		ri_ptr = ptr (fm_ptr, file_model.rel_ptr);
      250 		continue = TRUE;
      251 		do ai_ptr = ptr (fm_ptr, rel_info.attr_ptr) repeat ptr (fm_ptr, attr_info.fwd_thread)
      252 		     while (rel (ai_ptr) ^= NULL_OFFSET & continue);
      253 		     if attr_info.name = ra_from
      254 		     then do;
      255 			attr_info.name = ra_to;
      256 			continue = FALSE;
      257 			end;
      258 		     end;				/* do ai_ptr */
      259 
      260 		call terminate_file_ (fm_ptr, 0, TERM_FILE_TERM, (0));
      261 		end;				/* do ra_loop */
      262 
      263 /* Modify the attribute name in the domain reference record */
      264 		di_ptr = ptr (dbm_ptr, ra_attribute_xref_ptr -> crossref_info_record.offset);
      265 		call mdbm_util_$xref_modify_reference_name (local_iocb, DOMAIN_KEY_HEAD, (domain_info.name), ra_from,
      266 		     ra_to, error_message, code);
      267 		if code ^= 0
      268 		then call error (code, error_message);
      269 
      270 /* Modify the name on the attribute crossreference record */
      271 	     call mdbm_util_$xref_modify_record_name (local_iocb, ATTRIBUTE_KEY_HEAD, ra_from, ra_to,
      272 		ra_attribute_xref_ptr, error_message, code);
      273 	     if code ^= 0
      274 	     then call error (code, error_message);
      275 
      276 	     call mdbm_util_$inconsistent_reset (dbm_ptr);
      277 	     end;
      278 
      279 /* Add history entry */
      280 
      281 	if ^ra_unreferenced_domain
      282 	then call rmdb_add_rmdb_history (dbm_ptr, RMDB_ATTR_TYPE, (ra_from), RMDB_RN_ATTR_OP, (ra_to), (""), (0));
      283 
      284 /* END CRITICAL CODE */
      285 	revert quit;
      286 	if quit_occurred
      287 	then signal quit;
      288 
      289 	return;
      290      end rename_attribute;
      291 
      292 /*DESCRIPTION
      293* This implements renaming a single domain. Note that quits are trapped during
      294*   critical code. Steps are:
      295*   - rename domain_info in db_model
      296*   - get the domain xref record
      297*   - if the domain is referenced
      298*     - for each attribute in the domain xref record 
      299*       - change the domain name in each attribute xref record
      300*   - change the name on the domain xref record
      301*   - add a history entry
      302**/
      303 
      304 rename_domain:
      305      proc (rd_from, rd_to);
      306 
      307 dcl  rd_domain_xref_ptr ptr;
      308 dcl  rd_from char (*) parameter;
      309 dcl  rd_loop fixed bin;
      310 dcl  rd_to char (*) parameter;
      311 
      312 	rd_domain_xref_ptr = tempp;
      313 
      314 /* BEGIN CRITICAL CODE */
      315 
      316 	quit_occurred = FALSE;
      317 	on quit quit_occurred = TRUE;
      318 
      319 /* Get the domain xref record. */
      320 	call mdbm_util_$xref_find_record (local_iocb, DOMAIN_KEY_HEAD, rd_from, rd_domain_xref_ptr, max_seg_size,
      321 	     error_message, code);
      322 	if code ^= 0
      323 	then call error (code, error_message);
      324 
      325 /* Get a pointer to the domain_info structure in the db_model */
      326 	di_ptr = ptr (dbm_ptr, rd_domain_xref_ptr -> crossref_info_record.offset);
      327 	if domain_info.name ^= rd_from
      328 	then call error (mrds_error_$internal_error, "Domain " || rtrim (domain_info.name) || " should be " || rd_from);
      329 
      330 /* Make sure the new domain name isn't an attribute based on this domain */
      331 	continue = TRUE;
      332 	do rd_loop = 1 to rd_domain_xref_ptr -> crossref_info_record.count 
      333 	     while (continue);
      334 	     if rd_domain_xref_ptr -> crossref_info_record.object (rd_loop) = rd_to
      335 	     then continue = FALSE;
      336 	     end;
      337 	if ^continue
      338 	then call error (error_table_$unsupported_operation, 
      339 	     "The new domain name has already been used for an attribute based on this domain: " || rd_to);
      340 
      341 /* Make sure the new domain name hasn't been used for an attribute already. */
      342 	call mdbm_util_$xref_find_record (local_iocb, rtrim (ATTRIBUTE_KEY_HEAD), rd_to, null, 0, error_message, code);
      343 	if code = 0
      344 	then call error (error_table_$unsupported_operation,
      345 	     "The new domain name has already been used for an attribute in the database: " || rd_to);
      346 
      347 /* Change the name in domain_info */
      348 	domain_info.name = rd_to;
      349 
      350 /* Rename the domain xref record key. */
      351 	call mdbm_util_$xref_modify_record_name (local_iocb, DOMAIN_KEY_HEAD, rd_from, rd_to, rd_domain_xref_ptr,
      352 	     error_message, code);
      353 	if code ^= 0
      354 	then call error (code, error_message);
      355 
      356 /* Rename the generated attribute record for this domain, along with all
      357*   relation referenced for this generated attribute. */
      358 	call rename_attribute$unreferenced_domain (rd_from, rd_to);
      359 
      360 	call rmdb_add_rmdb_history (dbm_ptr, RMDB_DOMAIN_TYPE, (rd_from), RMDB_RN_DMN_OP, (rd_to), (""), (0));
      361 
      362 /* END CRITICAL CODE */
      363 	revert quit; 
      364 	if quit_occurred
      365 	then signal quit;				/* finally signal it */
      366 
      367 	return;
      368      end rename_domain;
      369 
      370 /*DESCRIPTION
      371*  This implements renaming a single relation. Note that quits are disabled 
      372*  during critical code. Steps are:
      373*  - mark db and resultant inconsistent
      374*  - rename file_info in db_model
      375*  - if the relation is a vfile
      376*    - rename the relation file
      377*  -otherwise
      378*    - copy the relation to the new named relation using copy_
      379*    - delete the original relation
      380*  - rename the file_model segment
      381*  - add a history entry
      382*  - mark the db consistent
      383**/
      384 
      385 rename_relation:
      386      proc (rr_from, rr_to);
      387 
      388 dcl  rr_from char (*) parameter;
      389 dcl  rr_from_model_name char (32);
      390 dcl  rr_relation_xref_ptr ptr;
      391 dcl  rr_to char (*) parameter;
      392 dcl  rr_to_model_name char (32);
      393 
      394 	rr_relation_xref_ptr = tempp;
      395 
      396 /* BEGIN CRITICAL CODE */
      397 	quit_occurred = FALSE;
      398 	on quit quit_occurred = TRUE;
      399 
      400 	call mdbm_util_$xref_find_record (local_iocb, RELATION_KEY_HEAD, rr_from, rr_relation_xref_ptr, max_seg_size,
      401 	     error_message, code);
      402 	if code ^= 0
      403 	then call error (code, error_message);
      404 
      405 	fi_ptr = ptr (dbm_ptr, rr_relation_xref_ptr -> crossref_info_record.offset);
      406 	if file_info.file_name ^= rr_from
      407 	then call error (mrds_error_$internal_error,
      408 		"Relation " || rtrim (file_info.file_name) || " should be " || rr_from);
      409 
      410 	rr_from_model_name = rtrim (rr_from) || ".m";
      411 
      412 	fm_ptr = null;
      413 	on cleanup call cleaner;
      414 	call initiate_file_ (rmdb_ctl.absolute_db_path, rr_from_model_name, RW_ACCESS, fm_ptr, (0), code);
      415 	if code ^= 0
      416 	then call error (code, "Initiating file_model for relation " || rr_from);
      417 
      418 	rmdb_ctl.saved_res_version_ptr -> based_char8 = "RESTRUCT";
      419 	call mdbm_util_$inconsistent_set (dbm_ptr, "rename_relation",
      420 	     "Renaming relation " || rtrim (rr_from) || " to " || rr_to,
      421 	     "undo_rename " || rtrim (rr_to) || " " || rtrim (rr_from));
      422 
      423 	file_info.file_name = rr_to;
      424 	ri_ptr = ptr (fm_ptr, file_model.rel_ptr);
      425 	rel_info.name = rr_to;
      426 
      427 	if db_model.db_type_flags.vfile_type
      428 	then call fs_util_$chname_file (rmdb_ctl.absolute_db_path, rr_from, rr_from, rr_to, code);
      429 	else do;
      430 	     copy_options_ptr = addr (local_copy_options);
      431 	     copy_options.version = COPY_OPTIONS_VERSION_1;
      432 	     copy_options.caller_name = myname;
      433 	     copy_options.source_dir, copy_options.target_dir = rmdb_ctl.absolute_db_path;
      434 	     copy_options.source_name = rr_from;
      435 	     copy_options.target_name = rr_to;
      436 
      437 	     unspec (copy_options.flags) = "0"b;
      438 	     copy_options.flags.no_name_dup = TRUE;
      439 	     copy_options.flags.force = TRUE;
      440 	     copy_options.flags.delete = TRUE;
      441 	     copy_options.flags.mbz = "0"b;
      442 
      443 	     unspec (copy_options.copy_items) = "0"b;
      444 	     copy_options.copy_items.acl = TRUE;
      445 	     copy_options.copy_items.ring_brackets = FALSE;
      446 	     copy_options.copy_items.dumper_switches = FALSE;
      447 	     copy_options.copy_items.mbz = "0"b;
      448 
      449 	     file_model.relation_copy_good = FALSE;
      450 	     call fs_util_$copy (copy_options_ptr, code);
      451 
      452 /* Do this delete because file_manager_ has a bug: it doesn't get around to
      453*   abiding by the flags. When/if DM is fixed the next group of statements may
      454*   be removed. */
      455 	     if code = 0
      456 	     then do;
      457 		acl_ptr = null;
      458 		call fs_util_$list_acl (copy_options.source_dir, copy_options.source_name, GENERAL_ACL_VERSION_1,
      459 		     addr (my_area), acl_ptr, code);
      460 		if code ^= 0
      461 		then call error (code, "Getting acl to relation " || copy_options.source_name);
      462 
      463 		call fs_util_$replace_acl (copy_options.source_dir, copy_options.target_name, acl_ptr, "0"b, code);
      464 		if code ^= 0
      465 		then call error (code, "Setting acl on relation " || copy_options.target_name);
      466 
      467 		file_model.relation_copy_good = TRUE;
      468 
      469 		call fs_util_$delentry_file (copy_options.source_dir, copy_options.source_name, code);
      470 		if code ^= 0
      471 		then call error (code, "Deleting the old relation " || copy_options.source_name);
      472 		end;
      473 	     end;
      474 
      475 	if code ^= 0
      476 	then call error (code, "Renaming relation " || rtrim (rr_from) || " to " || rr_to);
      477 
      478 	do ai_ptr = ptr (fm_ptr, rel_info.attr_ptr)
      479 	            repeat ptr (fm_ptr, attr_info.fwd_thread)
      480 	            while (rel (ai_ptr) ^= NULL_OFFSET);
      481 	     call mdbm_util_$xref_modify_reference_name (local_iocb, ATTRIBUTE_KEY_HEAD, (attr_info.name), rr_from, rr_to, error_message, code);
      482 	     if code ^= 0
      483 	     then call error (code, error_message);
      484 	     end;
      485 
      486 	call terminate_file_ (fm_ptr, 0, TERM_FILE_TERM, code);
      487 	if code ^= 0
      488 	then call error (code, "Terminating file_model for relation " || rr_from);
      489 
      490 	rr_to_model_name = rtrim (rr_to) || ".m";
      491 
      492 	call fs_util_$chname_file (rmdb_ctl.absolute_db_path, rr_from_model_name, rr_from_model_name, rr_to_model_name,
      493 	     code);
      494 	if code ^= 0
      495 	then call error (code, "Renaming relation " || rtrim (rr_from_model_name) || " to " || rr_to_model_name);
      496 
      497 	call mdbm_util_$xref_modify_record_name (local_iocb, RELATION_KEY_HEAD, rr_from, rr_to, rr_relation_xref_ptr,
      498 	     error_message, code);
      499 	if code ^= 0
      500 	then call error (code, error_message);
      501 
      502 	call rmdb_add_rmdb_history (dbm_ptr, RMDB_REL_TYPE, (rr_from), RMDB_RN_REL_OP, (rr_to), (""), (0));
      503 
      504 	call mdbm_util_$inconsistent_reset (dbm_ptr);
      505 
      506 /* END CRITICAL CODE */
      507 	revert quit;
      508 	if quit_occurred
      509 	then signal quit;
      510 
      511 	return;
      512      end rename_relation;
      513 
      514 /*DESCRIPTION
      515*  This entry point attempts to undo the actions of the rename requests.
      516*  These can only be run when the database is marked inconsistent, and
      517*  attempt to recover all the information possible. They don't report any
      518*  errors that may be caused by items missing, mis-named, etc as these could
      519*  result from a system or process interruption during a rename request. Note
      520*  that we don't have to update the crossreference file in the [pd], as we are
      521*  operating in an environment that hasn't created it yet. Also note that if
      522*  there is an interruption during the undo process, it may be restarted the next
      523*  time the specified database is touched. Certain operations may be retried,
      524*  however, if they don't complete this request will continue on trying to undo
      525*  the entire operation. The database inconsistent switch doesn't get reset until
      526*  the entire undo operation succeeds.
      527**/
      528 
      529 rmdb_rename$undo_rename:
      530      entry (Isci_ptr, Iinfo_ptr);
      531 
      532 	call initialize;
      533 	if operation = "rename_domain"
      534 	then call undo_domain;
      535 	else if operation = "rename_attribute"
      536 	     then call undo_attribute;
      537 	     else if operation = "rename_relation"
      538 		then call undo_relation;
      539 
      540 	call mdbm_util_$inconsistent_reset (dbm_ptr);
      541 	return;
      542 
      543 undo_domain:
      544      proc;
      545 
      546 	continue = TRUE;
      547 
      548 /* do for all domains in the database */
      549 	do di_ptr = ptr (dbm_ptr, db_model.domain_ptr) repeat ptr (dbm_ptr, domain_info.fwd_thread)
      550 	     while (rel (di_ptr) ^= NULL_OFFSET & continue);
      551 	     if domain_info.name = from_name
      552 	     then do;
      553 		continue = FALSE;
      554 		domain_info.name = to_name;
      555 		end;
      556 	     end;
      557 
      558 	return;
      559      end undo_domain;
      560 
      561 undo_relation:
      562      proc;
      563 
      564 	continue = TRUE;
      565 
      566 /* do for all relations in the database */
      567 	do fi_ptr = ptr (dbm_ptr, db_model.file_ptr) repeat ptr (dbm_ptr, file_info.fwd_ptr)
      568 	     while (rel (fi_ptr) ^= NULL_OFFSET & continue);
      569 	     if file_info.file_name = from_name
      570 	     then do;
      571 		file_info.file_name = substr (to_name, 1, length (file_info.file_name));
      572 		continue = FALSE;
      573 		end;
      574 	     end;
      575 
      576 	tempp, fm_ptr = null;
      577 	on cleanup call cleaner;
      578 
      579 	call initiate_file_ (rmdb_ctl.absolute_db_path, to_name, RW_ACCESS, fm_ptr, (0), code);
      580 	if code ^= 0
      581 	then if code ^= error_table_$noentry
      582 	     then goto RETURN_TO_CALLER;
      583 	     else do;
      584 		call initiate_file_ (rmdb_ctl.absolute_db_path, from_name, RW_ACCESS, fm_ptr, (0), code);
      585 		if code ^= 0
      586 		then goto RETURN_TO_CALLER;
      587 		call fs_util_$chname_file (rmdb_ctl.absolute_db_path, from_name, from_name, to_name, code);
      588 		end;
      589 
      590 	ri_ptr = ptr (fm_ptr, file_model.rel_ptr);
      591 	rel_info.name = to_name;
      592 
      593 	if db_model.db_type_flags.vfile_type
      594 	then call fs_util_$chname_file (rmdb_ctl.absolute_db_path, from_name, from_name, to_name, (0));
      595 	else if file_model.relation_copy_good
      596 	     then do;
      597 		copy_options_ptr = addr (local_copy_options);
      598 		copy_options.version = COPY_OPTIONS_VERSION_1;
      599 		copy_options.caller_name = "undo_rename";
      600 		copy_options.source_dir, copy_options.target_dir = rmdb_ctl.absolute_db_path;
      601 		copy_options.source_name = from_name;
      602 		copy_options.target_name = to_name;
      603 
      604 		unspec (copy_options.flags) = "0"b;
      605 		copy_options.flags.no_name_dup = TRUE;
      606 		copy_options.flags.force = TRUE;
      607 		copy_options.flags.delete = TRUE;
      608 		copy_options.flags.mbz = "0"b;
      609 
      610 		unspec (copy_options.copy_items) = "0"b;
      611 		copy_options.copy_items.acl = TRUE;
      612 		copy_options.copy_items.ring_brackets = FALSE;
      613 		copy_options.copy_items.dumper_switches = FALSE;
      614 		copy_options.copy_items.mbz = "0"b;
      615 
      616 		call fs_util_$copy (copy_options_ptr, code);
      617 
      618 /* Do this delete because file_manager_ has a bug: it doesn't get around to
      619*        abiding by the flags. When/if DM is fixed the next group of statements may
      620*        be removed. */
      621 		if code = 0
      622 		then do;
      623 		     acl_ptr = null;
      624 		     call fs_util_$list_acl (copy_options.source_dir, copy_options.source_name, GENERAL_ACL_VERSION_1,
      625 			addr (my_area), acl_ptr, code);
      626 		     if code = 0
      627 		     then do;
      628 			call fs_util_$replace_acl (copy_options.source_dir, copy_options.target_name, acl_ptr, "0"b,
      629 			     code);
      630 			if code = 0
      631 			then call fs_util_$delentry_file (copy_options.source_dir, copy_options.source_name, (0));
      632 			end;
      633 		     end;
      634 
      635 		file_model.relation_copy_good = FALSE;
      636 		end;
      637 	     else call fs_util_$delentry_file (rmdb_ctl.absolute_db_path, from_name, (0));
      638 
      639 	call terminate_file_ (fm_ptr, 0, TERM_FILE_TERM, (0));
      640 	fm_ptr = null;
      641 	return;
      642      end undo_relation;
      643 
      644 undo_attribute:
      645      proc;
      646 
      647 	continue = TRUE;
      648 
      649 /* do for all unreferenced attributes in the db model */
      650 	do ai_ptr = ptr (dbm_ptr, db_model.unreferenced_attribute_ptr) repeat ptr (dbm_ptr, attr_info.fwd_thread)
      651 	     while (rel (ai_ptr) ^= NULL_OFFSET & continue);
      652 	     if attr_info.name = from_name
      653 	     then do;
      654 		attr_info.name = to_name;
      655 		continue = FALSE;
      656 		end;
      657 	     end;					/* do ai_ptr */
      658 
      659 	if continue
      660 	then do;					/* the attribute is referenced somewhere */
      661 	     fm_ptr, tempp = null;
      662 	     on cleanup call cleaner;
      663 
      664 /* Do for all relations in the database */
      665 	     do fi_ptr = ptr (dbm_ptr, db_model.file_ptr) repeat ptr (dbm_ptr, file_info.fwd_ptr)
      666 		while (rel (fi_ptr) ^= NULL_OFFSET);
      667 		call initiate_file_ (rmdb_ctl.absolute_db_path, (file_info.file_name), R_ACCESS, fm_ptr, (0), code);
      668 		if code = 0
      669 		then do;
      670 		     continue = TRUE;
      671 		     ri_ptr = ptr (fm_ptr, file_model.rel_ptr);
      672 
      673 /* Do for all attribute within a single relation */
      674 		     do ai_ptr = ptr (fm_ptr, rel_info.attr_ptr) repeat ptr (fm_ptr, attr_info.fwd_thread)
      675 			while (rel (ai_ptr) ^= NULL_OFFSET & continue);
      676 			if attr_info.name = from_name
      677 			then do;
      678 			     attr_info.name = to_name;
      679 			     continue = FALSE;
      680 			     end;
      681 			end;			/* do ai_ptr */
      682 		     call terminate_file_ (fm_ptr, 0, TERM_FILE_TERM, (0));
      683 		     fm_ptr = null;
      684 		     end;
      685 		end;				/* do fi_ptr */
      686 	     end;
      687 
      688 	return;
      689      end undo_attribute;
      690 
      691 initialize:
      692      proc ();
      693 
      694 dcl  i_nargs fixed bin;
      695 
      696 	sci_ptr = Isci_ptr;
      697 	rmdb_ctl_ptr = Iinfo_ptr;
      698 	dbm_ptr = rmdb_ctl.db_model_ptr;
      699 	if dbm_ptr = null
      700 	then goto RETURN_TO_CALLER;			/* no database opened yet */
      701 
      702 	call mdbm_util_$inconsistent_get_info (dbm_ptr, incon_value, operation, (""), (""));
      703 	if ^incon_value
      704 	then call ssu_$abort_line (sci_ptr, 0, "This request can only be called when making the database consistent.");
      705 
      706 	call ssu_$arg_count (sci_ptr, i_nargs);
      707 	if i_nargs ^= 2
      708 	then goto RETURN_TO_CALLER;
      709 
      710 	call ssu_$arg_ptr (sci_ptr, 1, argp, argl);
      711 	from_name = arg;
      712 	call ssu_$arg_ptr (sci_ptr, 2, argp, argl);
      713 	to_name = arg;
      714 
      715 	return;
      716      end initialize;
      717 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      718 
      719 
  2     1 /* Begin include file -- acl_structures.incl.pl1 BIM 3/82 */
  2     2 /* format: style3,indcomtxt,idind30 */
  2     3 
  2     4 declare   acl_ptr                       pointer;
  2     5 declare   acl_count                     fixed bin;
  2     6 
  2     7 declare 1 general_acl                   aligned based (acl_ptr), /* for fs_util_ */
  2     8           2 version                     char (8) aligned,
  2     9           2 count                       fixed bin,
  2    10           2 entries                     (acl_count refer (general_acl.count)) aligned like general_acl_entry;
  2    11 
  2    12 declare 1 general_acl_entry             based,
  2    13           2 access_name                 character (32) unaligned,
  2    14           2 mode                        bit (36) aligned,
  2    15           2 status_code                 fixed bin (35);
  2    16 
  2    17 
  2    18 declare 1 general_extended_acl          aligned based (acl_ptr), /* for fs_util_ */
  2    19           2 version                     char (8) aligned,
  2    20           2 count                       fixed bin,
  2    21           2 entries                     (acl_count refer (general_extended_acl.count)) aligned like general_extended_acl_entry;
  2    22 
  2    23 declare 1 general_extended_acl_entry    aligned based,
  2    24           2 access_name                 character (32) unaligned,
  2    25           2 mode                        bit (36) aligned,
  2    26           2 extended_mode               bit (36) aligned,
  2    27           2 status_code                 fixed bin (35);
  2    28 
  2    29 
  2    30 declare 1 general_delete_acl            aligned based (acl_ptr), /* for file_system_ */
  2    31           2 version                     char (8) aligned,
  2    32           2 count                       fixed bin,
  2    33           2 entries                     (acl_count refer (general_delete_acl.count)) aligned like delete_acl_entry;
  2    34 
  2    35 declare 1 general_delete_acl_entry      aligned based,
  2    36           2 access_name                 character (32) unaligned,
  2    37           2 status_code                 fixed bin (35);
  2    38 
  2    39 
  2    40 declare 1 segment_acl                   aligned based (acl_ptr),
  2    41           2 version                     fixed bin,
  2    42           2 count                       fixed bin,
  2    43           2 entries                     (acl_count refer (segment_acl.count)) aligned like segment_acl_entry;
  2    44 
  2    45 declare 1 segment_acl_entry             like general_extended_acl_entry aligned based;
  2    46 declare 1 segment_acl_array             (acl_count) aligned like segment_acl_entry based (acl_ptr);
  2    47 
  2    48 
  2    49 declare 1 directory_acl                 aligned based (acl_ptr),
  2    50           2 version                     fixed bin,
  2    51           2 count                       fixed bin,
  2    52           2 entries                     (acl_count refer (directory_acl.count)) aligned like directory_acl_entry;
  2    53 
  2    54 declare 1 directory_acl_entry           like general_acl_entry aligned based;
  2    55 declare 1 directory_acl_array           (acl_count) aligned like directory_acl_entry based (acl_ptr);
  2    56 
  2    57 
  2    58 declare 1 delete_acl                    based (acl_ptr) aligned,
  2    59           2 version                     fixed bin,
  2    60           2 count                       fixed bin,
  2    61           2 entries                     (acl_count refer (delete_acl.count)) aligned like delete_acl_entry;
  2    62 
  2    63 declare 1 delete_acl_entry              like general_delete_acl_entry aligned based;
  2    64 declare 1 delete_acl_array              (acl_count) aligned like delete_acl_entry based (acl_ptr);
  2    65 
  2    66 
  2    67 declare  (SEG_ACL_VERSION_1             init ("sga1"),
  2    68           DIR_ACL_VERSION_1             init ("dra1"),
  2    69           DELETE_ACL_VERSION_1          init ("dla1"))
  2    70                                         char (4) int static options (constant);
  2    71 
  2    72 declare  (GENERAL_ACL_VERSION_1         init ("gacl001"),
  2    73           GENERAL_EXTENDED_ACL_VERSION_1 init ("gxacl001"),
  2    74           GENERAL_DELETE_ACL_VERSION_1  init ("gdacl001"))
  2    75                                         char (8) internal static options (constant);
  2    76 
  2    77 declare   ACL_VERSION_1                 fixed bin init (1) int static options (constant);
  2    78 
  2    79 /* End include file acl_structures.incl.pl1 */
      720 
      721 
  3     1 /* BEGIN INCLUDE FILE:  copy_flags.incl.pl1 */
  3     2 
  3     3 /* Flags for attributes that should/may be copied by the copy_ subroutine. This include file is
  3     4*   required by suffix_info.incl.pl1 and copy_options.incl.pl1
  3     5*
  3     6*   Jay Pattin 6/23/83 */
  3     7 
  3     8 declare   1 copy_flags                  aligned based,      /* ON means that this attribute may be copied by copy_ */
  3     9           2 names                       bit (1) unaligned,
  3    10           2 acl                         bit (1) unaligned,
  3    11           2 ring_brackets               bit (1) unaligned,
  3    12           2 max_length                  bit (1) unaligned,
  3    13           2 copy_switch                 bit (1) unaligned,
  3    14           2 safety_switch               bit (1) unaligned,
  3    15           2 dumper_switches             bit (1) unaligned,
  3    16           2 entry_bound                 bit (1) unaligned,  /* only for vanilla object segments */
  3    17           2 extend                      bit (1) unaligned,  /* copy_ may append to end of existing object */
  3    18           2 update                      bit (1) unaligned,  /* copy_ may replace contents of existing object */
  3    19           2 mbz                         bit (26) unaligned;
  3    20 
  3    21 /* END INCLUDE FILE:  copy_flags.incl.pl1 */
      722 
      723 
  4     1 /* BEGIN INCLUDE FILE: copy_options.incl.pl1 */
  4     2 
  4     3 /* This structure declares the input structure used by the copy_ subroutine.
  4     4*
  4     5*   NOTE: This include file depends on declarations in the include file
  4     6*   copy_flags.incl.pl1.
  4     7*
  4     8*   Jay Pattin 6/1/83 */
  4     9 
  4    10 declare   copy_options_ptr              ptr;
  4    11 
  4    12 declare   1 copy_options                aligned based (copy_options_ptr),
  4    13           2 version                     char (8),           /* currently COPY_OPTIONS_VERSION_1 */
  4    14           2 caller_name                 char (32) unal,     /* Used in nd_handler_ call */
  4    15           2 source_dir                  char (168) unal,
  4    16           2 source_name                 char (32) unal,
  4    17           2 target_dir                  char (168) unal,
  4    18           2 target_name                 char (32) unal,
  4    19           2 flags,
  4    20             3 no_name_dup               bit (1) unaligned,  /* ON = don't call nd_handler_ */
  4    21             3 raw                       bit (1) unaligned,  /* ON = don't call object_type_, use hcs_ */
  4    22             3 force                     bit (1) unaligned,  /* ON = delete or force access to target */
  4    23             3 delete                    bit (1) unaligned,  /* ON = delete original after copy (for move) */
  4    24             3 target_err_switch         bit (1) unaligned,
  4    25             3 mbz                       bit (31) unaligned,
  4    26           2 copy_items                  like copy_flags;    /* see copy_flags.incl.pl1 */
  4    27 
  4    28 declare   COPY_OPTIONS_VERSION_1        char (8) static options (constant) init ("CPOPT001");
  4    29 
  4    30 /* END INCLUDE FILE: copy_options.incl.pl1 */
      724 
      725 
  5     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  5     6*     modified to save space occupied by model
  5     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  5     8*     to add mdbm_secured bit in db_model
  5     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  5    10*     collapsed the following into an unused_offset array:
  5    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  5    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  5    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  5    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  5    15*       unused_1
  5    16*     Also changed the name of unused_2 to restructuring_history_offset
  5    17*     and changed the comment on the changer structure to indicate
  5    18*     that it will contain on database creation information.
  5    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  5    20*     used one of the unused_offsets to point to a message which indicates
  5    21*     why the db is inconsistent. The offset will be null when the db is created
  5    22*     and set the first time the message is used. this is so it will be
  5    23*     consistent with existing data bases. Also added the message structure.
  5    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  5    25*     added the undo_request element to the message structure
  5    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  5    27*     changed unused_offset (12) to last_restructruring_history_offset and
  5    28*     changed restructuring_history_offset to first_restructuring_history_offset
  5    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  5    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  5    31*     1 => vfile database and 2 => page_file database. Up to this point all
  5    32*     database types were equal to 1.
  5    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  5    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  5    35*     flags. This will allow information about transactions and dm_file
  5    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  5    37*     change is compatable with all datamodels created by the released version
  5    38*     of mrds.
  5    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  5    40*     added the rollback_on flag to the db_type_flags since it appears that you
  5    41*     can have a dmfile database that requires transactions but does not have any
  5    42*     journalizing. Also switched the order of the transactions_needed and
  5    43*     concurrency_on flags - this makes the change compatable with existing
  5    44*     dmfile databases except when displaying the model since concurrency_on and
  5    45*     rollback_on will be off in the model even though the dmfile relations had
  5    46*     them on during creation.
  5    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  5    48*      Removed ctl_file_path_ptr.
  5    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  5    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  5    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  5    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  5    53*      in the flag word for rmdb copying.
  5    54*                                                   END HISTORY COMMENTS */
  5    55 
  5    56 
  5    57 /* this include file contains the structures that go into the make up
  5    58*   of the "db_model" segment in the model for the database.
  5    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  5    60*
  5    61*   the db_model structure goes at the base of the segment, and contains items unique to
  5    62*   the whole databse. in addition, it has an area of size to fill the
  5    63*   rest of a segment, that holds the lists of files and domains in the database.
  5    64*   these lists are singly forward linked lists. all "pointers" in the database model
  5    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  5    66*   since actual pointers are process dependent on segment number.
  5    67*   the remaining structures are first a path_entry one to save pathnames in,
  5    68*   and the stack_item and constent structures, used to save a boolean
  5    69*   expression in polish form, with the stack represented by a linked list.
  5    70*   the final structure is one for identifying the status of version information */
  5    71 
  5    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  5    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  5    74 	     2 db_type_flags      unal,
  5    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  5    76 	       3 unused	      (13) bit (1) unal,
  5    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  5    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  5    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  5    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  5    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  5    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  5    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  5    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  5    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  5    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  5    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  5    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  5    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  5    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  5    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  5    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  5    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  5    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  5    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  5    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  5    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  5    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  5    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  5   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  5   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  5   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  5   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  5   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  5   105 
  5   106      dcl	   dbm_ptr	      ptr;
  5   107 
  5   108 /* the files in the database each have a file_info containing
  5   109*   their name, the file_model for each file is found by initiating the
  5   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  5   111*   the file_info list is a singly linked list in definition order */
  5   112 
  5   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  5   114 	     2 file_name	      char (30),		/* name of file */
  5   115 	     2 file_id	      bit (36),		/* id number of file */
  5   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  5   117 	     2 unused	      unal bit (18);	/* for future expansion */
  5   118 
  5   119      dcl	   fi_ptr		      ptr;
  5   120 
  5   121 /* each domain used in the database will have a domain info saved in the db_model
  5   122*   segment. it describes the domain of the given name, and it's options.
  5   123*   the domain_info's form a singly linked list in definition order */
  5   124 
  5   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  5   126 	     2 name	      char (32),		/* name of domain */
  5   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  5   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  5   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  5   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  5   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  5   132 	     2 reserved	      bit (31) unal,
  5   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  5   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  5   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  5   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  5   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  5   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  5   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  5   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  5   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  5   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  5   143 	     2 str_err_path_ptr   unal bit (18),
  5   144 	     2 str_after_path_ptr unal bit (18),
  5   145 	     2 get_before_path_ptr unal bit (18),
  5   146 	     2 get_err_path_ptr   unal bit (18),
  5   147 	     2 get_after_path_ptr unal bit (18),
  5   148 	     2 mod_before_path_ptr unal bit (18),
  5   149 	     2 mod_err_path_ptr   unal bit (18),
  5   150 	     2 mod_after_path_ptr unal bit (18),
  5   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  5   152 	     2 unused_2	      unal bit (18),
  5   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  5   154 
  5   155      dcl	   di_ptr		      ptr;
  5   156 
  5   157 /* information necessary for attributes that are not used in any relation */
  5   158 
  5   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  5   160 	     2 name char (32),			/* name of attribute */
  5   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  5   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  5   163 	     2 unused (2) bit (18) unal;
  5   164 
  5   165      dcl     ua_ptr ptr;
  5   166 
  5   167 
  5   168 /* space saving pathname$entryname structure, to be allocated
  5   169*   only when a path$entry has to be saved, else only a bit(18)
  5   170*   offset takes up space in the main model structure */
  5   171 
  5   172      declare 1 path_entry	      based (path_entry_ptr),
  5   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  5   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  5   175 	     2 reserved	      unal bit (36);	/* for future use */
  5   176 
  5   177      declare path_entry_ptr	      ptr;
  5   178 
  5   179 
  5   180 
  5   181 
  5   182 
  5   183 /* declarations for model of postfix stack holding the check option boolean expression
  5   184*   the following encoding values indicate the corresponding type of stack element
  5   185*
  5   186*   1  =
  5   187*   2  ^=
  5   188*   3  >
  5   189*   4  <
  5   190*   5  >=
  5   191*   6  <=
  5   192*
  5   193*   10  and
  5   194*   20  or
  5   195*   30  not
  5   196*
  5   197*   40  - (minus)
  5   198*
  5   199*   50  domain variable(same name as domain)
  5   200*
  5   201*   60  constant(number, bit string, or character string)
  5   202*
  5   203**/
  5   204 
  5   205 
  5   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  5   207 	     2 next	      bit (18),		/* link to next in list */
  5   208 	     2 type	      fixed binary,		/* code for this element type */
  5   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  5   210*						   if this is a constant element type */
  5   211 
  5   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  5   213 
  5   214 
  5   215 
  5   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  5   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  5   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  5   219 
  5   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  5   221 
  5   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  5   223 
  5   224 /* version structure, giving status of source for CMDB/RMDB,
  5   225*   status of model, and status of resultant */
  5   226 
  5   227 /* version number is in form MM.N.Y
  5   228*   where MM is the major version number, N is the minor version alteration,
  5   229*   and Y is the lastest modification to that alteration,
  5   230*   where M and N represent numbers 0-9, and Y is a letter */
  5   231 
  5   232      declare 1 version_status	      unal based (version_status_ptr),
  5   233 	     2 cmdb_rmdb,
  5   234 	       3 major	      fixed bin,
  5   235 	       3 minor	      fixed bin,
  5   236 	       3 modification     char (4),
  5   237 	     2 model,
  5   238 	       3 major	      fixed bin,
  5   239 	       3 minor	      fixed bin,
  5   240 	       3 modification     char (4),
  5   241 	     2 resultant,
  5   242 	       3 major	      fixed bin,
  5   243 	       3 minor	      fixed bin,
  5   244 	       3 modification     char (4);
  5   245 
  5   246      declare version_status_ptr     ptr;
  5   247 
  5   248 
  5   249 /* maintains information only about the db creation */
  5   250 
  5   251      declare 1 changer	      unal based (changer_ptr),
  5   252 	     2 id		      char (32),
  5   253 	     2 time	      fixed bin (71),
  5   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  5   255 
  5   256      declare changer_ptr	      ptr;
  5   257 
  5   258 
  5   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  5   260 	     02 len	      fixed bin,		/* length of the message */
  5   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  5   262 	     02 name	      char (32),		/* name of thing that set the message */
  5   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  5   264*                                                               that caused the database to become inconsistent */
  5   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  5   266 
  5   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  5   268 
  5   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  5   270 
  5   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  5   272 
  5   273 
      726 
      727 
  6     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  6     6*     modified to save space occupied by model
  6     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  6     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  6     9*     the number of secondary indices in the relation - it was always zero.
  6    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  6    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  6    12*     DMS conversion.
  6    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  6    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  6    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  6    16*     for relation manager changes.
  6    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  6    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  6    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  6    20*     <rel> files are good (for rmdb)
  6    21*                                                   END HISTORY COMMENTS */
  6    22 
  6    23 
  6    24 /* each file in the database will have a model segment with the name
  6    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  6    26*   the file_model structure is allocated at the base of the segment for a given file.
  6    27*   it contains an area with which all other structures in this include file are allocated.
  6    28*   these structures contain the information about which relations, foreign keys,
  6    29*   and attributes are members of this file. all lists are singly linked lists in
  6    30*   definition order. pointers to these structures are obtained by using the "pointer"
  6    31*   builtin function with arguments of the segment base pointer, and the
  6    32*   offset (bit (18)) relative to that pointer that is actually stored in
  6    33*   the file model itself. this is because pointer segment numbers are
  6    34*   per process dependent. the major lists pointed to by the file_model structure
  6    35*   are the list of relations in this file(each with a contained attribute list),
  6    36*   and the list of foreign keys whose parent relation resides in this file
  6    37*   (along with a participating attribute sublist, and the child relation list,
  6    38*   if they are also in this file) */
  6    39 
  6    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  6    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  6    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  6    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  6    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  6    45     2 reserved bit (32) unal,				/* reserved for future flags */
  6    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  6    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  6    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  6    49     2 pad_1 fixed bin (35),				/* for future use */
  6    50     2 pad_2 fixed bin (35),
  6    51     2 ratd_len fixed bin (21),			/* length of above */
  6    52     2 mratd_len fixed bin (21),			/* length of above */
  6    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  6    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  6    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  6    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  6    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  6    58     2 block_size unal fixed bin,			/* no. pages in block */
  6    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  6    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  6    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  6    62     2 num_rels unal fixed bin,			/* number of relations in file */
  6    63     2 num_links unal fixed bin,			/* number of links in file */
  6    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  6    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  6    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  6    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  6    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  6    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  6    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  6    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  6    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  6    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  6    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  6    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  6    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  6    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  6    78     2 open_eu_err_path_ptr unal bit (18),
  6    79     2 open_eu_after_path_ptr unal bit (18),
  6    80     2 open_er_before_path_ptr unal bit (18),
  6    81     2 open_er_err_path_ptr unal bit (18),
  6    82     2 open_er_after_path_ptr unal bit (18),
  6    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  6    84     2 open_neu_err_path_ptr unal bit (18),
  6    85     2 open_neu_after_path_ptr unal bit (18),
  6    86     2 open_ner_before_path_ptr unal bit (18),
  6    87     2 open_ner_err_path_ptr unal bit (18),
  6    88     2 open_ner_after_path_ptr unal bit (18),
  6    89     2 open_pu_before_path_ptr unal bit (18),
  6    90     2 open_pu_err_path_ptr unal bit (18),
  6    91     2 open_pu_after_path_ptr unal bit (18),
  6    92     2 open_pr_before_path_ptr unal bit (18),
  6    93     2 open_pr_err_path_ptr unal bit (18),
  6    94     2 open_pr_after_path_ptr unal bit (18),
  6    95     2 open_cu_before_path_ptr unal bit (18),
  6    96     2 open_cu_err_path_ptr unal bit (18),
  6    97     2 open_cu_after_path_ptr unal bit (18),
  6    98     2 open_cr_before_path_ptr unal bit (18),
  6    99     2 open_cr_err_path_ptr unal bit (18),
  6   100     2 open_cr_after_path_ptr unal bit (18),
  6   101     2 close_before_path_ptr unal bit (18),
  6   102     2 close_err_path_ptr unal bit (18),
  6   103     2 close_after_path_ptr unal bit (18),
  6   104     2 unused_1 unal bit (18),				/* for future expansion */
  6   105     2 unused_2 unal bit (18),
  6   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  6   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  6   108 dcl  fm_ptr ptr;
  6   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  6   110 dcl  atd_ptr ptr;
  6   111 dcl  atd_len fixed bin;
  6   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  6   113     2 ncomponents fixed bin,
  6   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  6   115 dcl  cna_ptr ptr;
  6   116 dcl  ncomp_init fixed bin;
  6   117 
  6   118 /* a rel_info structure contains information describing a relation.
  6   119*   a relation may only occur in one file, thus there is one rel_info
  6   120*   per relation per database, each stored in the file_model area for
  6   121*   the file that contains it. the list of rel_info's in this file
  6   122*   form a singly linked list in definition order.
  6   123*   the rel_info itself points to a list of the attributes it contains,
  6   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  6   125 
  6   126 dcl 1 rel_info aligned based (ri_ptr),
  6   127     2 name char (32),				/* relation name */
  6   128     2 id  bit (36) aligned,				/* relation id number */
  6   129     2 hashed bit (1) unal,				/* on if hashed */
  6   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  6   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  6   132     2 system bit (1) unal,				/* on if dont care how stored */
  6   133     2 indexed bit (1) unal,				/* on if secondary index */
  6   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  6   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  6   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  6   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  6   138     2 reserved bit (27) unal,				/* for future flags */
  6   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  6   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  6   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  6   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  6   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  6   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  6   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  6   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  6   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  6   148     2 unused_3 unal fixed bin,			/* element that was never used */
  6   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  6   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  6   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  6   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  6   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  6   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  6   155     2 attr_ptr unal bit (18),				/* to attr. info */
  6   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  6   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  6   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  6   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  6   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  6   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  6   162     2 link_err_path_ptr unal bit (18),
  6   163     2 link_after_path_ptr unal bit (18),
  6   164     2 unlk_before_path_ptr unal bit (18),
  6   165     2 unlk_err_path_ptr unal bit (18),
  6   166     2 unlk_after_path_ptr unal bit (18),
  6   167     2 str_before_path_ptr unal bit (18),
  6   168     2 str_err_path_ptr unal bit (18),
  6   169     2 str_after_path_ptr unal bit (18),
  6   170     2 del_before_path_ptr unal bit (18),
  6   171     2 del_err_path_ptr unal bit (18),
  6   172     2 del_after_path_ptr unal bit (18),
  6   173     2 mod_before_path_ptr unal bit (18),
  6   174     2 mod_err_path_ptr unal bit (18),
  6   175     2 mod_after_path_ptr unal bit (18),
  6   176     2 find_before_path_ptr unal bit (18),
  6   177     2 find_err_path_ptr unal bit (18),
  6   178     2 find_after_path_ptr unal bit (18),
  6   179     2 retr_before_path_ptr unal bit (18),
  6   180     2 retr_err_path_ptr unal bit (18),
  6   181     2 retr_after_path_ptr unal bit (18),
  6   182     2 unused_1 unal bit (18),				/* for future expansion */
  6   183     2 unused_2 unal bit (18),
  6   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  6   185 dcl  ri_ptr ptr;
  6   186 
  6   187 /* a attr_info structure contains information about an attribute in a given relation.
  6   188*   since attributes may appear in more than one relation, each occurence of an attribute
  6   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  6   190*   the list is singly linked in definition order. the attr_info describes
  6   191*   the data it represents, and how that data is used during a database search. */
  6   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  6   193     2 name char (32),				/* name of attribute */
  6   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  6   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  6   196     2 link_attr bit (1) unal,				/* on if participates in link */
  6   197     2 reserved bit (33) unal,
  6   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  6   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  6   200     2 key_order unal fixed bin,			/* relative posit. in key */
  6   201     2 bit_offset fixed bin (35),			/* position in tuple */
  6   202     2 bit_length fixed bin (35),			/* length if fixed */
  6   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  6   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  6   205     2 domain_ptr unal bit (18),			/* to domain info */
  6   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  6   207     2 fwd_thread unal bit (18),			/* to next in list */
  6   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  6   209 dcl  ai_ptr ptr;
  6   210 
  6   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  6   212*   each time a foreign key definition indicates a relation as it's parent,
  6   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  6   214*   a relation can be parent and/or child in any number of foreign keys.
  6   215*   the parent_link_info structure describes the foreign key, and also points
  6   216*   to a list of the attributes that participate in this foreign key.
  6   217*   (this could be from 1 up to all attributes in the relation)
  6   218*   the attr_list structures are in a singly linked list in definition order
  6   219*   for this purpose. also pointed to is a list of child_link_info's
  6   220*   that describe the child relations in this foreign key. since foreign keys
  6   221*   may span files, not all related child_link_info's have to be in this file's
  6   222*   model area. */
  6   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  6   224     2 name char (32),				/* name of link */
  6   225     2 singular bit (1) unal,				/* on if system owned link */
  6   226     2 temp bit (1) unal,				/* on if temp. order */
  6   227     2 first bit (1) unal,				/* insertion indicators */
  6   228     2 last bit (1) unal,
  6   229     2 next bit (1) unal,
  6   230     2 prior bit (1) unal,
  6   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  6   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  6   233     2 dup_first bit (1) unal,				/* duplicates first */
  6   234     2 dup_last bit (1) unal,				/* duplicates last */
  6   235     2 indexed bit (1) unal,				/* locate parent via index */
  6   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  6   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  6   238     2 thread_27 bit (1) unal,
  6   239     2 thread_18 bit (1) unal,
  6   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  6   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  6   242     2 reserved bit (19) unal,				/* reserved for future flags */
  6   243     2 index_id aligned bit (8),			/* id of index if indexed */
  6   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  6   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  6   246     2 n_children unal fixed bin,			/* no. children in link */
  6   247     2 child_fn char (30),				/* file name for first child in list */
  6   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  6   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  6   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  6   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  6   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  6   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  6   254     2 sort_err_path_ptr unal bit (18),
  6   255     2 sort_after_path_ptr unal bit (18),
  6   256     2 srch_before_path_ptr unal bit (18),
  6   257     2 srch_err_path_ptr unal bit (18),
  6   258     2 srch_after_path_ptr unal bit (18),
  6   259     2 link_before_path_ptr unal bit (18),
  6   260     2 link_err_path_ptr unal bit (18),
  6   261     2 link_after_path_ptr unal bit (18),
  6   262     2 unlk_before_path_ptr unal bit (18),
  6   263     2 unlk_err_path_ptr unal bit (18),
  6   264     2 unlk_after_path_ptr unal bit (18),
  6   265     2 unused_1 unal bit (18),				/* for future expansion */
  6   266     2 unused_2 unal bit (18),
  6   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  6   268 dcl  pli_ptr ptr;
  6   269 
  6   270 /* a child_link_info structure is the counter part of a parent_link_info
  6   271*   for foreign key child relations. each time a relation is defined to be
  6   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  6   273*   this list is singly linked in foreign key definition order.
  6   274*   the child_link_info points to a list of participating attributes from the
  6   275*   child relation by means of a singly linked list of attr_list structures
  6   276*   in definition order. the number of attributes in the parent attr_list
  6   277*   and the child attr_list lists are the same with corresponding attr_list
  6   278*   attributes having the same domain. all child_link_infos in this file
  6   279*   are on a seperately linked list. this may not include all
  6   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  6   281*   since foreign keys may span files, and the child_link_info will
  6   282*   reside in the file containing it's associated relation_info. */
  6   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  6   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  6   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  6   286     2 fixed bit (1) unal,				/* on if membership fixed */
  6   287     2 optional bit (1) unal,				/* on if membership optional */
  6   288     2 auto bit (1) unal,				/* on if insertion automatic */
  6   289     2 manual bit (1) unal,				/* on if insertion manual */
  6   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  6   291     2 range_sel bit (1) unal,				/* on if range type selection */
  6   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  6   293     2 key_dup_last bit (1) unal,
  6   294     2 key_null bit (1) unal,				/* on if null allowed */
  6   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  6   296     2 sel_current bit (1) unal,
  6   297     2 sel_key bit (1) unal,
  6   298     2 sel_proc bit (1) unal,
  6   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  6   300     2 reserved bit (21) unal,
  6   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  6   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  6   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  6   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  6   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  6   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  6   307     2 parent_fn char (30),				/* file name for parent info */
  6   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  6   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  6   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  6   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  6   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  6   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  6   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  6   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  6   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  6   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  6   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  6   319     2 link_err_path_ptr unal bit (18),
  6   320     2 link_after_path_ptr unal bit (18),
  6   321     2 unlk_before_path_ptr unal bit (18),
  6   322     2 unlk_err_path_ptr unal bit (18),
  6   323     2 unlk_after_path_ptr unal bit (18),
  6   324     2 srch_before_path_ptr unal bit (18),
  6   325     2 srch_err_path_ptr unal bit (18),
  6   326     2 srch_after_path_ptr unal bit (18),
  6   327     2 unused_1 unal bit (18),				/* for future expansion */
  6   328     2 unused_2 unal bit (18) ;
  6   329 dcl  cli_ptr ptr;
  6   330 
  6   331 /* the attr_list structure is associated with the parent_link_info
  6   332*   and child_link_info structures to represent by means of a singly linked list
  6   333*   the participating attributes from relations in a foreign key.
  6   334*   the parent_link_info has a list for the parent relation,
  6   335*   and the child_link_info has a list for the child relation.
  6   336*   the participating attributes are a subset(not necessary proper) of
  6   337*   those attributes contained in a relation definition.
  6   338*   there are equal numbers of attr_list structures in the parent and
  6   339*   child lists of the same foreign key. the corresponding attributes in these
  6   340*   lists must have the same domain. */
  6   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  6   342     2 attr_fn char (30),				/* file name for attr. */
  6   343     2 attr_ptr unal bit (18),				/* to attr info block */
  6   344     2 fwd_thread unal bit (18);			/* to next in list */
  6   345 dcl  al_ptr ptr;
  6   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  6   347     2 ascend bit (1) unal,				/* ascending order */
  6   348     2 descend bit (1) unal,				/* descending order */
  6   349     2 reserved bit (34) unal,
  6   350     2 attr_ptr unal bit (18),				/* to attr info */
  6   351     2 fwd_thread unal bit (18);			/* to next in list */
  6   352 dcl  sk_ptr ptr;
  6   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  6   354     2 attr_ptr unal bit (18),				/* to attr info */
  6   355     2 fwd_thread unal bit (18);			/* to next in list */
  6   356 dcl  dp_ptr ptr;
  6   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  6   358     2 link_fn char (30),				/* file name for thru link */
  6   359     2 link_ptr unal bit (18),				/* to parent link info */
  6   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  6   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  6   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  6   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  6   364     2 fwd_thread unal bit (18);			/* to next in chain */
  6   365 dcl  sc_ptr ptr;
  6   366 
  6   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  6   368 
  6   369 
      728 
      729 
  7     1 /* BEGIN - mrds_rmdb_ctl.incl.pl1 */
  7     2 
  7     3 
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(82-03-26,Davids), approve(), audit(), install():
  7     7*     created
  7     8*  2) change(82-05-26,Davids), approve(), audit(), install():
  7     9*     added db_model_ptr
  7    10*  3) change(82-06-09,Harvey), approve(), audit(), install():
  7    11*     deleted ssu_ routines ptr storage
  7    12*  4) change(82-08-20,Davids), approve(), audit(), install():
  7    13*     added the relmgr like reference and included the rmdb_relmgr_entries
  7    14*     include file
  7    15*  5) change(83-05-24,Davids), approve(), audit(), install():
  7    16*     added the saved_res_version_ptr element
  7    17*  6) change(84-10-23,Benjamin), approve(), audit(), install():
  7    18*     added flags (just database_readied_by_rmdb for now).
  7    19*  7) change(85-11-08,Spitzer), approve(85-11-08,MCR7311),
  7    20*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  7    21*     added crossref_file_info.
  7    22*                                                   END HISTORY COMMENTS */
  7    23 
  7    24 
  7    25 dcl 01 rmdb_ctl based (rmdb_ctl_ptr),
  7    26     02 version fixed bin,
  7    27     02 rmdb_version char (16) varying,
  7    28     02 absolute_db_path char (168),
  7    29     02 temp_dir_path char (168),
  7    30     02 work_area_ptr ptr,
  7    31     02 db_model_ptr ptr,
  7    32     02 saved_res_version_ptr ptr,
  7    33     02 crossref_file_info,
  7    34        03 iocb_ptr ptr,
  7    35        03 name char (32),
  7    36     02 relmgr_entries like rmdb_relmgr_entries,
  7    37     02 flags,
  7    38        03 database_readied_by_rmdb bit (1) unal,
  7    39        03 unused bit (35) unal;
  7    40     	
  7    41 dcl  RMDB_CTL_VERSION_1 fixed bin init (1) internal static options (constant);
  7    42 
  7    43 dcl  rmdb_ctl_ptr ptr;
  7    44 
  7    45 
  8     1 /*  START OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(82-08-20,Davids), approve(), audit(), install():
  8     6*     written
  8     7*  2) change(86-01-28,Spitzer), approve(86-01-28,MCR7311),
  8     8*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  8     9*     add get_tuples_by_spec, put_tuple, put_tuples, create_cursor entry points.
  8    10*  3) change(86-08-21,Blair), approve(86-08-21,MCR7311),
  8    11*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  8    12*     Back out the entries get_tuples_by_spec and put_tuples since they aren't
  8    13*     sufficiently well tested to be reliable.  Replace with get_tuple_id and
  8    14*     get_tuple_by_id.
  8    15*                                                   END HISTORY COMMENTS */
  8    16 
  8    17 
  8    18 dcl 01 rmdb_relmgr_entries based (rmdb_relmgr_entries_ptr),
  8    19      02 create_relation entry (char (*), char (*), ptr, ptr, bit (36) aligned,
  8    20 	bit (36) aligned, fixed bin (35)),
  8    21      02 delete_relation entry (char (*), char (*), fixed bin (35)),
  8    22      02 open entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  8    23      02 close entry (bit (36) aligned, fixed bin (35)),
  8    24      02 create_index entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17),
  8    25 	bit (36) aligned, fixed bin (35)),
  8    26      02 delete_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35)),
  8    27      02 put_tuple entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  8    28      02 get_tuple_id entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  8    29      02 get_tuple_by_id entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  8    30      02 create_cursor entry (bit (36) aligned, ptr, ptr, fixed bin (35));
  8    31 
  8    32 dcl rmdb_relmgr_entries_ptr ptr;
  8    33 
  8    34 /*  END OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7    46 
  7    47 
  7    48 
  7    49 /* END - mrds_rmdb_ctl.incl.pl1 */
      730 
      731 
  9     1 /*  START OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  9     2 
  9     3 /****^  HISTORY COMMENTS:
  9     4*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
  9     5*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  9     6*     written.
  9     7*                                                   END HISTORY COMMENTS */
  9     8 
  9     9 /*DESCRIPTION
  9    10*  The following structures are the definition of the records with the keyed
  9    11*  vfile that is built during restructuring. This file serves as a crossreference
  9    12*  of unique attributes and domains used within the specified MRDS database. Each
  9    13*  object is a char (33); the first byte is set to an unprintable character so we
  9    14*  can use the index builtin to find a specific object.
  9    15**/
  9    16 
  9    17 dcl crossref_info_record_ptr ptr;
  9    18 dcl crossref_info_record_count fixed bin (21);
  9    19 dcl 1 crossref_info_record based (crossref_info_record_ptr),
  9    20      2 offset bit (18) unal,
  9    21      2 pad bit (18) unal,
  9    22      2 count fixed bin (21),
  9    23      2 entry (crossref_info_record_count refer (crossref_info_record.count)) unaligned,
  9    24       3 object_head char (1),
  9    25       3 object char (32);
  9    26 
  9    27 dcl crossref_info_record_objects char (33*crossref_info_record.count)
  9    28 			   based (addr (crossref_info_record.entry(1)));
  9    29 dcl OBJECT_HEAD char (1) int static options (constant) init (" ");
  9    30 
  9    31 dcl ATTRIBUTE_KEY_HEAD char (10) int static options (constant) init ("attribute:");
  9    32 dcl DOMAIN_KEY_HEAD char (7) int static options (constant) init ("domain:");
  9    33 dcl RELATION_KEY_HEAD char (9) int static options (constant) init ("relation:");
  9    34 
  9    35 /*DESCRIPTION
  9    36*  The following structures are used to contain sufficient crossreference
  9    37*  information for the delete_attribute and delete_domain requests. These
  9    38*  requests require a more complete view of a crossreference tree, associating
  9    39*  domains, attributes and relations in 2 directions.
  9    40**/
  9    41 
  9    42 dcl domain_list_ptr ptr;
  9    43 dcl domain_list_count fixed bin;
  9    44 dcl domain_list_names char (33*domain_list.count) based (addr (domain_list.name(1)));
  9    45 dcl 1 domain_list based (domain_list_ptr),
  9    46      2 count fixed bin,				/* number of domains in the list */
  9    47      2 name (domain_list_count refer (domain_list.count))
  9    48 	  char (33) unaligned,			/* name of this domain */
  9    49      2 attribute_list_ptr (domain_list_count refer (domain_list.count))
  9    50 		      ptr;			/* -> attribute_list structure */
  9    51 
  9    52 dcl attribute_list_ptr ptr;
  9    53 dcl attribute_list_count fixed bin;
  9    54 dcl attribute_list_names char (33*attribute_list.count) based (addr (attribute_list.name(1)));
  9    55 dcl 1 attribute_list based (attribute_list_ptr),
  9    56      2 count fixed bin,				/* number of attributes in the list */
  9    57      2 name (attribute_list_count refer (attribute_list.count))
  9    58 	  char (33) unaligned,			/* name of this attribute */
  9    59      2 domain_info_ptr (attribute_list_count refer (attribute_list.count))
  9    60 		   bit (18) unal,			/* offset in db_model of the domain_info structure for this attribute */
  9    61      2 attribute_ptr (attribute_list_count refer (attribute_list.count))
  9    62 		 ptr;				/* -> attribute structure */
  9    63 
  9    64 dcl relation_list_ptr ptr;
  9    65 dcl relation_list_count fixed bin;
  9    66 dcl relation_list_names char (33*relation_list.count) based (addr (relation_list.name (1)));
  9    67 dcl 1 relation_list based (relation_list_ptr),
  9    68      2 count fixed bin,				/* number of relations that are to be touched in this operation */
  9    69      2 name (relation_list_count refer (relation_list.count))
  9    70 	  char (33) unaligned,			/* name of this relation */
  9    71      2 relation_ptr (relation_list_count refer (relation_list.count))
  9    72 		ptr;				/* -> relation structure */
  9    73 
  9    74 dcl relation_ptr ptr;
  9    75 dcl relation_attribute_count fixed bin;
  9    76 dcl relation_attribute_names char (33*relation.attribute_count) based (addr (relation.attribute_names (1)));
  9    77 dcl 1 relation based (relation_ptr),
  9    78      2 name char (32),				/* name of the relation */
  9    79      2 file_model_ptr ptr,				/* -> relation.m segment */
  9    80      2 copy_file_model_ptr ptr,
  9    81      2 attribute_count fixed bin,			/* number of attributes defined for this relation */
  9    82      2 mbz fixed bin (35),
  9    83      2 attribute (relation_attribute_count refer (relation.attribute_count)),
  9    84       3 flags aligned,
  9    85         4 delete bit (1) unaligned,			/* ON: delete this attribute */
  9    86         4 new bit (1) unaligned,			/* ON: this attribute is added to the relation */
  9    87         4 part_of_key bit (1) unaligned,                    /* ON: this attribute is part of the primary key */
  9    88         4 to_be_deleted bit (1) unaligned,
  9    89         4 pad bit (32) unaligned,
  9    90       3 domain_info_ptr bit (18) aligned,		/* -> db_model domain_info structure */
  9    91       3 attribute_info_ptr ptr,			/* -> file_model attribute_info structure */
  9    92       3 value_ptr ptr,				/* if flags.new, this -> the value of the column to be stored */
  9    93 						/*   it must be of the correct data type as specified by the domain */
  9    94      2 attribute_names (relation_attribute_count refer (relation.attribute_count))
  9    95 		   char (33) unaligned;
  9    96 
  9    97 dcl attribute_ptr ptr;
  9    98 dcl attribute_count fixed bin;
  9    99 dcl 1 attribute based (attribute_ptr),
  9   100      2 count fixed bin,				/* number of relations this attribute is used in */
  9   101      2 relation_idx (attribute_count refer (attribute.count))
  9   102 		fixed bin;			/* index into list of relation names */
  9   103 
  9   104 /*  END OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      732 
      733 
 10     1 /* BEGIN INCLUDE FILE rmdb_history_entry.incl.pl1 -- nsd, 82-04-09 */
 10     2 
 10     3 
 10     4 
 10     5 /****^  HISTORY COMMENTS:
 10     6*  1) change(75-01-01,WhoKnows), approve(), audit(), install():
 10     7*     Written.
 10     8*  2) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
 10     9*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 10    10*     Added RMDB_ADD_(ATTR DMN)_OP, RMDB_RN_(ATTR DMN REL)_OP.
 10    11*                                                   END HISTORY COMMENTS */
 10    12 
 10    13 
 10    14 /*
 10    15*   This include file contains the rmdb_history_entry structure which
 10    16*   is  used for maintaining a history of the databases restructuring
 10    17*   events. It also contains a set of constants used in  loading  the
 10    18*   structure.
 10    19*
 10    20*   The restructuring history is applied against the  database  as  a
 10    21*   whole  instead of against each structure in the db_model and file
 10    22*   models which was the approach originally  implemented  but  never
 10    23*   really  used  (except  to  record the database creation). This is
 10    24*   because 1 database restructuring event, i.e. adding a  new  index
 10    25*   to a relation will change several of the structures in the model.
 10    26*
 10    27*   For a detailed explaination of the use of this structure and  the
 10    28*   constants see the rmdb_add_rmdb_event module.
 10    29**/
 10    30 
 10    31 dcl 01 rmdb_history_entry aligned based (rmdb_history_entry_ptr),
 10    32     02 user_id char (32),				/* person_id.project_id.tag */
 10    33     02 date_time_restructured fixed bin (71),
 10    34     02 type_of_object_restructured fixed bin,		/* taken from constants below */
 10    35     02 object_name char (32),
 10    36     02 operation fixed bin,				/* taken from constants below */
 10    37     02 secondary_object_name char (32),			/* i.e. name of attr just indexed in a restructured relation */
 10    38     02 offset_to_next_entry bit (18) unal,
 10    39     02 offset_to_previous_entry bit (18) unal;
 10    40 	
 10    41 
 10    42 dcl  rmdb_history_entry_ptr ptr;
 10    43 
 10    44 
 10    45 dcl  RMDB_DOMAIN_TYPE init (1) fixed bin internal static options (constant);
 10    46 dcl  RMDB_ATTR_TYPE init (2) fixed bin internal static options (constant);
 10    47 dcl  RMDB_REL_TYPE init (3) fixed bin internal static options (constant);
 10    48 
 10    49 
 10    50 dcl  RMDB_ADD_REL_OP init (1) fixed bin internal static options (constant);
 10    51 dcl  RMDB_DEL_REL_OP init (2) fixed bin internal static options (constant);
 10    52 dcl  RMDB_ADD_IDX_OP init (3) fixed bin internal static options (constant);
 10    53 dcl  RMDB_DEL_IDX_OP init (4) fixed bin internal static options (constant);
 10    54 dcl  RMDB_ADD_ATTR_OP init (5) fixed bin int static options (constant);
 10    55 dcl  RMDB_DEL_ATTR_OP init (6) fixed bin int static options (constant);
 10    56 dcl  RMDB_ADD_DMN_OP init (7) fixed bin int static options (constant);
 10    57 dcl  RMDB_DEL_DMN_OP init (8) fixed bin int static options (constant);
 10    58 dcl  RMDB_RN_ATTR_OP init (9) fixed bin int static options (constant);
 10    59 dcl  RMDB_RN_DMN_OP init (10) fixed bin int static options (constant);
 10    60 dcl  RMDB_RN_REL_OP init (11) fixed bin int static options (constant);
 10    61 
 10    62 /* END INCLUDE FILE rmdb_history_entry.incl.pl1 */
      734 
      735 
 11     1 /*  START OF:	rmdb_rename_object_info.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 11     2 
 11     3 
 11     4 /****^  HISTORY COMMENTS:
 11     5*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
 11     6*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 11     7*     Contains a list of attribute, domains or relations to rename
 11     8*                                                   END HISTORY COMMENTS */
 11     9 
 11    10 dcl rename_object_info_count fixed bin (17);
 11    11 dcl rename_object_info_ptr ptr;
 11    12 dcl rename_object_info_version_1 char (8) int static options (constant) init ("roi 1.0");
 11    13 
 11    14 dcl 1 rename_object_info based (rename_object_info_ptr),
 11    15      2 version char (8),
 11    16      2 type fixed bin (17) unal,
 11    17      2 count fixed bin (17),
 11    18      2 names (rename_object_info_count refer (rename_object_info.count)),
 11    19       3 from char (32),
 11    20       3 to char (32);
 11    21 
 11    22 dcl (RENAME_ATTRIBUTE init (1),
 11    23      RENAME_DOMAIN init (2),
 11    24      RENAME_RELATION init (3)) fixed bin (17) int static options (constant);
 11    25 
 11    26 /*  END OF:	rmdb_rename_object_info.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      736 
      737 
 12     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
 12     2 /* format: style2,^inddcls,idind32 */
 12     3 
 12     4 declare 1 terminate_file_switches	based,
 12     5 	2 truncate		bit (1) unaligned,
 12     6 	2 set_bc			bit (1) unaligned,
 12     7 	2 terminate		bit (1) unaligned,
 12     8 	2 force_write		bit (1) unaligned,
 12     9 	2 delete			bit (1) unaligned;
 12    10 
 12    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
 12    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
 12    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
 12    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
 12    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
 12    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
 12    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
 12    18 
 12    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      738 
      739 
      740 dcl  addr builtin;
      741 dcl  arg char (argl) based (argp);
      742 dcl  argl fixed bin (21);
      743 dcl  argp ptr;
      744 dcl  based_char8 char (8) based;
      745 dcl  char builtin;
      746 dcl  cleanup condition;
      747 dcl  code fixed bin (35);
      748 dcl  continue bit (1) aligned;
      749 dcl  empty builtin;
      750 dcl  error_message char (500);
      751 dcl  error_table_$no_record fixed bin (35) ext static;
      752 dcl  error_table_$noentry fixed bin (35) ext static;
      753 dcl  error_table_$unimplemented_version fixed bin (35) ext static;
      754 dcl  error_table_$unsupported_operation fixed bin (35) ext static;
      755 dcl  FALSE bit (1) aligned int static options (constant) init ("0"b);
      756 dcl  fixed builtin;
      757 dcl  from_name char (32);
      758 dcl  fs_util_$chname_file entry (char (*), char (*), char (*), char (*), fixed bin (35));
      759 dcl  fs_util_$copy entry (ptr, fixed bin (35));
      760 dcl  fs_util_$delentry_file entry (char (*), char (*), fixed bin (35));
      761 dcl  fs_util_$list_acl entry (char (*), char (*), char (*), ptr, ptr, fixed bin (35));
      762 dcl  fs_util_$replace_acl entry (char (*), char (*), ptr, bit (1), fixed bin (35));
      763 dcl  Iinfo_ptr ptr parameter;
      764 dcl  incon_value bit (1);
      765 dcl  initiate_file_ entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
      766 dcl  Irename_object_info_ptr ptr parameter;
      767 dcl  Irmdb_ctl_ptr ptr parameter;
      768 dcl  Isci_ptr ptr parameter;
      769 dcl  key_head char (32);
      770 dcl  length builtin;
      771 dcl  1 local_copy_options aligned like copy_options;
      772 dcl  local_iocb ptr;
      773 dcl  loop fixed bin;
      774 dcl  ltrim builtin;
      775 dcl  max_seg_size fixed bin (21);
      776 dcl  mdbm_util_$get_temp_segment_path entry (char (*), char (*), ptr, fixed bin (35));
      777 dcl  mdbm_util_$inconsistent_get_info entry (ptr, bit (1), char (*), char (*), char (*));
      778 dcl  mdbm_util_$inconsistent_reset entry (ptr);
      779 dcl  mdbm_util_$inconsistent_set entry (ptr, char (*), char (*), char (*));
      780 dcl  mdbm_util_$free_temp_segment entry (char (*), ptr, fixed bin (35));
      781 dcl  mrds_error_$attr_already_exists fixed bin (35) ext static;
      782 dcl  mrds_error_$domain_already_defined fixed bin (35) ext static;
      783 dcl  mrds_error_$dup_rel fixed bin (35) ext static;
      784 dcl  mrds_error_$internal_error fixed bin (35) ext static;
      785 dcl  mrds_error_$no_model_attr fixed bin (35) ext static;
      786 dcl  mrds_error_$no_model_dom fixed bin (35) ext static;
      787 dcl  mrds_error_$no_model_rel fixed bin (35) ext static;
      788 dcl  my_area area;
      789 dcl  myname char (32) int static options (constant) init ("rmdb_rename");
      790 dcl  null builtin;
      791 dcl  NULL_OFFSET bit (18) aligned int static options (constant) init ((18)"1"b);
      792 dcl  Ocode fixed bin (35) parameter;
      793 dcl  Oerror_message char (*) parameter;
      794 dcl  operation char (32);
      795 dcl  ptr builtin;
      796 dcl  quit condition;
      797 dcl  quit_occurred bit (1) aligned;
      798 dcl  rel builtin;
      799 dcl  rename_entry entry variable internal entry (char (*), char (*));
      800 dcl  rmdb_add_rmdb_history entry (ptr, fixed bin, char (32), fixed bin, char (32), char (500), fixed bin (35));
      801 dcl  mdbm_util_$xref_build entry (char (*), char (*), ptr, char (*), ptr, char (*), fixed bin (35));
      802 dcl  mdbm_util_$xref_find_record entry (ptr, char (*), char (*), ptr, fixed bin (21), char (*), fixed bin (35));
      803 dcl  mdbm_util_$xref_modify_record_name entry (ptr, char (*), char (*), char (*), ptr, char (*), fixed bin (35));
      804 dcl  mdbm_util_$xref_modify_reference_name entry (ptr, char (*), char (*), char (*), char (*), char (*), fixed bin (35));
      805 dcl  rtrim builtin;
      806 dcl  sci_ptr ptr;
      807 dcl  ssu_$abort_line entry () options (variable);
      808 dcl  ssu_$arg_count entry (ptr, fixed bin);
      809 dcl  ssu_$arg_ptr entry (ptr, fixed bin, ptr, fixed bin (21));
      810 dcl  substr builtin;
      811 dcl  sys_info$max_seg_size fixed bin (35) ext static;
      812 dcl  tempp ptr;
      813 dcl  terminate_file_ entry (ptr, fixed bin (24), bit (*), fixed bin (35));
      814 dcl  to_name char (32);
      815 dcl  TRUE bit (1) aligned int static options (constant) init ("1"b);
      816 dcl  unspec builtin;
      817 
      818      end rmdb_rename;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1142.8  rmdb_rename.pl1                   >special_ldd>install>MR12.0-1187>rmdb_rename.pl1
718          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
720          2    10/14/83  1606.6  acl_structures.incl.pl1           >ldd>include>acl_structures.incl.pl1
722          3    10/14/83  1606.7  copy_flags.incl.pl1               >ldd>include>copy_flags.incl.pl1
724          4    10/14/83  1606.7  copy_options.incl.pl1             >ldd>include>copy_options.incl.pl1
726          5    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
728          6    10/16/86  1139.9  mdbm_file_model.incl.pl1          >special_ldd>install>MR12.0-1187>mdbm_file_model.incl.pl1
730          7    10/16/86  1139.6  mrds_rmdb_ctl.incl.pl1            >special_ldd>install>MR12.0-1187>mrds_rmdb_ctl.incl.pl1
7-46         8    10/16/86  1140.2  rmdb_relmgr_entries.incl.pl1      >special_ldd>install>MR12.0-1187>rmdb_relmgr_entries.incl.pl1
732          9    10/16/86  1140.3  rmdb_crossref_info.incl.pl1       >special_ldd>install>MR12.0-1187>rmdb_crossref_info.incl.pl1
734         10    10/16/86  1139.6  rmdb_history_entry.incl.pl1       >special_ldd>install>MR12.0-1187>rmdb_history_entry.incl.pl1
736         11    10/16/86  1139.5  rmdb_rename_object_info.incl.pl1  >special_ldd>install>MR12.0-1187>rmdb_rename_object_info.incl.pl1
738         12    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTRIBUTE_KEY_HEAD              000022 constant        char(10)                 initial unaligned dcl 9-31 set ref 34 177* 195* 217*
                                                                                  271* 342 342 481*
COPY_OPTIONS_VERSION_1          000026 constant        char(8)                  initial unaligned dcl 4-28 ref 431 598
DOMAIN_KEY_HEAD                 000020 constant        char(7)                  initial unaligned dcl 9-32 set ref 39 199* 213* 265*
                                                                                  320* 351*
FALSE                                  constant        bit(1)                   initial dcl 755 ref 183 211 256 316 334 397 445 446
                                                                                  449 553 572 612 613 635 655 679
GENERAL_ACL_VERSION_1           000030 constant        char(8)                  initial unaligned dcl 2-72 set ref 458* 624*
Iinfo_ptr                              parameter       pointer                  dcl 763 ref 529 697
Irename_object_info_ptr                parameter       pointer                  dcl 766 ref 19 23
Irmdb_ctl_ptr                          parameter       pointer                  dcl 767 ref 19 22
Isci_ptr                               parameter       pointer                  dcl 768 ref 529 696
NULL_OFFSET                            constant        bit(18)                  initial dcl 791 ref 206 251 478 549 567 650 665 674
Ocode                                  parameter       fixed bin(35,0)          dcl 792 set ref 19 126* 127
Oerror_message                         parameter       char                     unaligned dcl 793 set ref 19 127* 129*
RELATION_KEY_HEAD               000014 constant        char(9)                  initial unaligned dcl 9-33 set ref 44 400* 497*
RENAME_ATTRIBUTE                       constant        fixed bin(17,0)          initial dcl 11-22 ref 31 71 84
RENAME_DOMAIN                          constant        fixed bin(17,0)          initial dcl 11-22 ref 36 73 86
RENAME_RELATION                        constant        fixed bin(17,0)          initial dcl 11-22 ref 41
RMDB_ATTR_TYPE                  000072 constant        fixed bin(17,0)          initial dcl 10-46 set ref 281*
RMDB_DOMAIN_TYPE                000076 constant        fixed bin(17,0)          initial dcl 10-45 set ref 360*
RMDB_REL_TYPE                   000074 constant        fixed bin(17,0)          initial dcl 10-47 set ref 502*
RMDB_RN_ATTR_OP                 000077 constant        fixed bin(17,0)          initial dcl 10-58 set ref 281*
RMDB_RN_DMN_OP                  000075 constant        fixed bin(17,0)          initial dcl 10-59 set ref 360*
RMDB_RN_REL_OP                  000073 constant        fixed bin(17,0)          initial dcl 10-60 set ref 502*
RW_ACCESS                       000032 constant        bit(3)                   initial unaligned dcl 1-11 set ref 244* 414* 579*
                                                                                  584*
R_ACCESS                        000054 constant        bit(3)                   initial unaligned dcl 1-11 set ref 667*
TERM_FILE_TERM                  000010 constant        bit(3)                   initial unaligned dcl 12-14 set ref 115* 260* 486*
                                                                                  639* 682*
TRUE                                   constant        bit(1)                   initial dcl 815 ref 184 205 250 317 331 398 438 439
                                                                                  440 444 467 546 564 605 606 607 611 647 670
absolute_db_path          6            based           char(168)                level 2 packed unaligned dcl 7-25 set ref 51* 244*
                                                                                  414* 427* 433 492* 579* 584* 587* 593* 600 637*
                                                                                  667*
acl                     157(01)        based           bit(1)                   level 3 packed unaligned dcl 4-12 set ref 444* 611*
acl_ptr                         000100 automatic       pointer                  dcl 2-4 set ref 457* 458* 463* 623* 624* 628*
addr                                                   builtin function         dcl 740 ref 430 458 458 597 624 624
ai_ptr                          000120 automatic       pointer                  dcl 6-209 set ref 251* 251* 253 255* 258 478* 478*
                                                                                  481* 484 650* 650* 652 654* 657 674* 674* 676 678*
                                                                                  681
arg                                    based           char                     unaligned dcl 741 ref 711 713
argl                            000126 automatic       fixed bin(21,0)          dcl 742 set ref 710* 711 712* 713
argp                            000130 automatic       pointer                  dcl 743 set ref 710* 711 712* 713
attr_info                              based           structure                level 1 dcl 6-192
attr_ptr                 24(18)        based           bit(18)                  level 2 packed unaligned dcl 6-126 ref 251 478 674
based_char8                            based           char(8)                  unaligned dcl 744 set ref 227* 418*
caller_name               2            based           char(32)                 level 2 packed unaligned dcl 4-12 set ref 432* 599*
cd                                     parameter       fixed bin(35,0)          dcl 123 ref 120 126
char                                                   builtin function         dcl 745 ref 46
cleanup                         000132 stack reference condition                dcl 746 ref 61 237 413 577 662
code                            000140 automatic       fixed bin(35,0)          dcl 747 set ref 51* 53 53* 66* 68 68 71* 73* 75* 76*
                                                                                  78* 80* 82 84* 86* 88* 89* 91 91* 95* 96 96* 177*
                                                                                  179 179* 195* 196 196* 199* 201 201* 213* 215 215*
                                                                                  217* 219 219* 244* 245 245* 265* 267 267* 271* 273
                                                                                  273* 320* 322 322* 342* 343 351* 353 353* 400* 402
                                                                                  402* 414* 415 415* 427* 450* 455 458* 460 460*
                                                                                  463* 464 464* 469* 470 470* 475 475* 481* 482 482*
                                                                                  486* 487 487* 492* 494 494* 497* 499 499* 579* 580
                                                                                  580 584* 585 587* 616* 621 624* 626 628* 630 667*
                                                                                  668
continue                        000141 automatic       bit(1)                   dcl 748 set ref 205* 206 211* 250* 251 256* 331* 332
                                                                                  334* 337 546* 549 553* 564* 567 572* 647* 650 655*
                                                                                  659 670* 674 679*
copy_flags                             based           structure                level 1 dcl 3-8
copy_items              157            based           structure                level 2 dcl 4-12 set ref 443* 610*
copy_options                           based           structure                level 1 dcl 4-12
copy_options_ptr                000102 automatic       pointer                  dcl 4-10 set ref 430* 431 432 433 433 434 435 437
                                                                                  438 439 440 441 443 444 445 446 447 450* 458 458
                                                                                  460 463 463 464 469 469 470 597* 598 599 600 600
                                                                                  601 602 604 605 606 607 608 610 611 612 613 614
                                                                                  616* 624 624 628 628 630 630
count                     3            based           fixed bin(17,0)          level 2 in structure "rename_object_info" dcl 11-14
                                                                                  in procedure "rmdb_rename" ref 65 100
count                     1            based           fixed bin(21,0)          level 2 in structure "crossref_info_record" dcl 9-19
                                                                                  in procedure "rmdb_rename" ref 192 240 332
crossref_file_info      140            based           structure                level 2 unaligned dcl 7-25
crossref_info_record                   based           structure                level 1 unaligned dcl 9-19
db_model                               based           structure                level 1 dcl 5-72
db_model_ptr            134            based           pointer                  level 2 dcl 7-25 ref 25 698
db_type_flags             0(18)        based           structure                level 2 packed unaligned dcl 5-72
dbm_ptr                         000104 automatic       pointer                  dcl 5-106 set ref 25* 51* 187 198 206 206 212 222
                                                                                  228* 232* 264 276* 281* 326 360* 405 419* 427 502*
                                                                                  504* 540* 549 549 556 567 567 574 593 650 650 657
                                                                                  665 665 685 698* 699 702*
delete                  156(03)        based           bit(1)                   level 3 packed unaligned dcl 4-12 set ref 440* 607*
delete_acl_entry                       based           structure                level 1 dcl 2-63
di_ptr                          000110 automatic       pointer                  dcl 5-155 set ref 187* 188 198* 199 212* 213 264*
                                                                                  265 326* 327 327 348 549* 549* 551 554* 556
directory_acl_entry                    based           structure                level 1 dcl 2-54
domain_info                            based           structure                level 1 dcl 5-125
domain_ptr               22(18)        based           bit(18)                  level 2 packed unaligned dcl 5-72 ref 549
dumper_switches         157(06)        based           bit(1)                   level 3 packed unaligned dcl 4-12 set ref 446* 613*
empty                                                  builtin function         dcl 749 ref 788
entry                     2            based           structure                array level 2 packed unaligned dcl 9-19
error_message                   000142 automatic       char(500)                unaligned dcl 750 set ref 51* 53* 66* 78* 80* 91*
                                                                                  177* 179* 195* 196* 199* 201* 213* 215* 217* 219*
                                                                                  265* 267* 271* 273* 320* 322* 342* 351* 353* 400*
                                                                                  402* 481* 482* 497* 499*
error_table_$no_record          000010 external static fixed bin(35,0)          dcl 751 ref 68 91
error_table_$noentry            000012 external static fixed bin(35,0)          dcl 752 ref 580
error_table_$unimplemented_version
                                000014 external static fixed bin(35,0)          dcl 753 set ref 27*
error_table_$unsupported_operation
                                000016 external static fixed bin(35,0)          dcl 754 set ref 188* 337* 343*
fi_ptr                          000106 automatic       pointer                  dcl 5-119 set ref 405* 406 406 423 567* 567* 569 571
                                                                                  571* 574 665* 665* 667* 685
file_info                              based           structure                level 1 dcl 5-113
file_model                             based           structure                level 1 dcl 6-40
file_name                              based           char(30)                 level 2 dcl 5-113 set ref 406 406 423* 569 571* 571
                                                                                  667
file_ptr                 22            based           bit(18)                  level 2 packed unaligned dcl 5-72 ref 567 665
flags                   156            based           structure                level 2 dcl 4-12 set ref 437* 604*
fm_ptr                          000114 automatic       pointer                  dcl 6-108 set ref 60* 115 115* 236* 244* 249 249 251
                                                                                  258 260* 412* 414* 424 424 449 467 478 484 486*
                                                                                  576* 579* 584* 590 590 595 635 639* 640* 661* 667*
                                                                                  671 671 674 681 682* 683*
force                   156(02)        based           bit(1)                   level 3 packed unaligned dcl 4-12 set ref 439* 606*
from                      4            based           char(32)                 array level 3 packed unaligned dcl 11-14 set ref 66*
                                                                                  76* 101*
from_name                       000337 automatic       char(32)                 unaligned dcl 757 set ref 551 569 584* 587* 587*
                                                                                  593* 593* 601 637* 652 676 711*
fs_util_$chname_file            000020 constant        entry                    external dcl 758 ref 427 492 587 593
fs_util_$copy                   000022 constant        entry                    external dcl 759 ref 450 616
fs_util_$delentry_file          000024 constant        entry                    external dcl 760 ref 469 630 637
fs_util_$list_acl               000026 constant        entry                    external dcl 761 ref 458 624
fs_util_$replace_acl            000030 constant        entry                    external dcl 762 ref 463 628
fwd_ptr                  11            based           bit(18)                  level 2 packed unaligned dcl 5-113 ref 574 685
fwd_thread               10(18)        based           bit(18)                  level 2 in structure "unreferenced_attribute" packed
                                                                                  unaligned dcl 5-159 in procedure "rmdb_rename" ref
                                                                                  222
fwd_thread               14(18)        based           bit(18)                  level 2 in structure "domain_info" packed unaligned
                                                                                  dcl 5-125 in procedure "rmdb_rename" ref 556
fwd_thread               20            based           bit(18)                  level 2 in structure "attr_info" packed unaligned
                                                                                  dcl 6-192 in procedure "rmdb_rename" ref 258 484
                                                                                  657 681
general_acl_entry                      based           structure                level 1 unaligned dcl 2-12
general_delete_acl_entry               based           structure                level 1 dcl 2-35
general_extended_acl_entry             based           structure                level 1 dcl 2-23
i_nargs                         002614 automatic       fixed bin(17,0)          dcl 694 set ref 706* 707
incon_value                     000347 automatic       bit(1)                   unaligned dcl 764 set ref 702* 703
initiate_file_                  000032 constant        entry                    external dcl 765 ref 244 414 579 584 667
iocb_ptr                140            based           pointer                  level 3 dcl 7-25 set ref 24 55*
key_head                        000350 automatic       char(32)                 unaligned dcl 769 set ref 34* 39* 44* 66 66 80 80
length                                                 builtin function         dcl 770 ref 571
local_copy_options              000360 automatic       structure                level 1 dcl 771 set ref 430 597
local_iocb                      000540 automatic       pointer                  dcl 772 set ref 24* 49 51* 55 66* 80* 177* 195* 199*
                                                                                  213* 217* 265* 271* 320* 342* 351* 400* 481* 497*
loop                            000542 automatic       fixed bin(17,0)          dcl 773 set ref 65* 66 76 80 89* 100* 101 101*
ltrim                                                  builtin function         dcl 774 ref 46
max_seg_size                    000543 automatic       fixed bin(21,0)          dcl 775 set ref 58* 177* 320* 400*
mbz                     157(10)        based           bit(26)                  level 3 in structure "copy_options" packed unaligned
                                                                                  dcl 4-12 in procedure "rmdb_rename" set ref 447*
                                                                                  614*
mbz                     156(05)        based           bit(31)                  level 3 in structure "copy_options" packed unaligned
                                                                                  dcl 4-12 in procedure "rmdb_rename" set ref 441*
                                                                                  608*
mdbm_util_$free_temp_segment    000044 constant        entry                    external dcl 780 ref 113
mdbm_util_$get_temp_segment_path
                                000034 constant        entry                    external dcl 776 ref 95
mdbm_util_$inconsistent_get_info
                                000036 constant        entry                    external dcl 777 ref 702
mdbm_util_$inconsistent_reset   000040 constant        entry                    external dcl 778 ref 276 504 540
mdbm_util_$inconsistent_set     000042 constant        entry                    external dcl 779 ref 228 232 419
mdbm_util_$xref_build           000066 constant        entry                    external dcl 801 ref 51
mdbm_util_$xref_find_record     000070 constant        entry                    external dcl 802 ref 66 80 177 320 342 400
mdbm_util_$xref_modify_record_name
                                000072 constant        entry                    external dcl 803 ref 195 217 271 351 497
mdbm_util_$xref_modify_reference_name
                                000074 constant        entry                    external dcl 804 ref 199 213 265 481
mrds_error_$attr_already_exists 000046 external static fixed bin(35,0)          dcl 781 ref 84
mrds_error_$domain_already_defined
                                000050 external static fixed bin(35,0)          dcl 782 ref 86
mrds_error_$dup_rel             000052 external static fixed bin(35,0)          dcl 783 ref 88
mrds_error_$internal_error      000054 external static fixed bin(35,0)          dcl 784 set ref 46* 327* 406*
mrds_error_$no_model_attr       000056 external static fixed bin(35,0)          dcl 785 ref 71
mrds_error_$no_model_dom        000060 external static fixed bin(35,0)          dcl 786 ref 73
mrds_error_$no_model_rel        000062 external static fixed bin(35,0)          dcl 787 ref 75
msg                                    parameter       char                     unaligned dcl 124 ref 120 129
my_area                         000544 automatic       area(1024)               dcl 788 set ref 458 458 624 624 788*
myname                          000000 constant        char(32)                 initial unaligned dcl 789 set ref 95* 113* 432
name                    142            based           char(32)                 level 3 in structure "rmdb_ctl" packed unaligned
                                                                                  dcl 7-25 in procedure "rmdb_rename" set ref 51*
name                                   based           char(32)                 level 2 in structure "rel_info" dcl 6-126
                                                                                  in procedure "rmdb_rename" set ref 425* 591*
name                                   based           char(32)                 level 2 in structure "attr_info" dcl 6-192
                                                                                  in procedure "rmdb_rename" set ref 253 255* 481
                                                                                  652 654* 676 678*
name                                   based           char(32)                 level 2 in structure "unreferenced_attribute"
                                                                                  dcl 5-159 in procedure "rmdb_rename" set ref 208
                                                                                  210*
name                                   based           char(32)                 level 2 in structure "domain_info" dcl 5-125
                                                                                  in procedure "rmdb_rename" set ref 188 199 213 265
                                                                                  327 327 348* 551 554*
names                     4            based           structure                array level 2 packed unaligned dcl 11-14
no_name_dup             156            based           bit(1)                   level 3 packed unaligned dcl 4-12 set ref 438* 605*
null                                                   builtin function         dcl 790 ref 49 60 66 66 80 80 113 115 217 217 236
                                                                                  342 342 412 457 576 623 640 661 683 699
object                    2(09)        based           char(32)                 array level 3 packed unaligned dcl 9-19 ref 243 334
offset                                 based           bit(18)                  level 2 packed unaligned dcl 9-19 ref 187 198 212
                                                                                  264 326 405
operation                       002544 automatic       char(32)                 unaligned dcl 794 set ref 533 535 537 702*
ptr                                                    builtin function         dcl 795 ref 187 198 206 212 222 249 251 258 264 326
                                                                                  405 424 478 484 549 556 567 574 590 650 657 665
                                                                                  671 674 681 685
quit                            000000 stack reference condition                dcl 796 ref 184 285 286 317 363 364 398 507 508
quit_occurred                   002554 automatic       bit(1)                   dcl 797 set ref 183* 184* 286 316* 317* 364 397*
                                                                                  398* 508
ra_attribute_xref_ptr           000100 automatic       pointer                  dcl 156 set ref 172* 177* 187 192 195* 198 212 240
                                                                                  243 264 271*
ra_from                                parameter       char                     unaligned dcl 157 set ref 153 166 177* 188 188 195*
                                                                                  199* 208 213* 217* 228 228 232 232 253 265* 271*
                                                                                  281
ra_loop                         000102 automatic       fixed bin(17,0)          dcl 158 set ref 240* 243*
ra_relation_name                000103 automatic       char(32)                 unaligned dcl 159 set ref 243* 244* 245
ra_to                                  parameter       char                     unaligned dcl 160 set ref 153 166 195* 199* 210 213*
                                                                                  217* 228 228 232 232 255 265* 271* 281
ra_unreferenced_domain          000113 automatic       bit(1)                   dcl 161 set ref 163* 169* 192 228 281
rd_domain_xref_ptr              000100 automatic       pointer                  dcl 307 set ref 312* 320* 326 332 334 351*
rd_from                                parameter       char                     unaligned dcl 308 set ref 304 320* 327 327 351* 358*
                                                                                  360
rd_loop                         000102 automatic       fixed bin(17,0)          dcl 309 set ref 332* 334*
rd_to                                  parameter       char                     unaligned dcl 310 set ref 304 334 337 342* 343 348
                                                                                  351* 358* 360
rel                                                    builtin function         dcl 798 ref 206 251 478 549 567 650 665 674
rel_info                               based           structure                level 1 dcl 6-126
rel_ptr                  20(27)        based           bit(18)                  level 2 packed unaligned dcl 6-40 ref 249 424 590
                                                                                  671
relation_copy_good        0(03)        based           bit(1)                   level 2 packed unaligned dcl 6-40 set ref 449* 467*
                                                                                  595 635*
rename_entry                    002556 automatic       entry variable           dcl 799 set ref 33* 38* 43* 101
rename_object_info                     based           structure                level 1 unaligned dcl 11-14
rename_object_info_ptr          000124 automatic       pointer                  dcl 11-11 set ref 23* 27 27 31 36 41 46 65 66 71 73
                                                                                  76 80 84 86 89 100 101 101
rename_object_info_version_1    000012 constant        char(8)                  initial unaligned dcl 11-12 ref 27
ri_ptr                          000116 automatic       pointer                  dcl 6-185 set ref 249* 251 424* 425 478 590* 591
                                                                                  671* 674
ring_brackets           157(02)        based           bit(1)                   level 3 packed unaligned dcl 4-12 set ref 445* 612*
rmdb_add_rmdb_history           000064 constant        entry                    external dcl 800 ref 281 360 502
rmdb_ctl                               based           structure                level 1 unaligned dcl 7-25
rmdb_ctl_ptr                    000122 automatic       pointer                  dcl 7-43 set ref 22* 24 25 51 51 51 55 95 227 244
                                                                                  414 418 427 433 492 579 584 587 593 600 637 667
                                                                                  697* 698
rmdb_relmgr_entries                    based           structure                level 1 unaligned dcl 8-18
rr_from                                parameter       char                     unaligned dcl 388 set ref 385 400* 406 406 410 415
                                                                                  419 419 427* 427* 434 475 481* 487 497* 502
rr_from_model_name              000100 automatic       char(32)                 unaligned dcl 389 set ref 410* 414* 492* 492* 494
rr_relation_xref_ptr            000110 automatic       pointer                  dcl 390 set ref 394* 400* 405 497*
rr_to                                  parameter       char                     unaligned dcl 391 set ref 385 419 419 423 425 427*
                                                                                  435 475 481* 490 497* 502
rr_to_model_name                000112 automatic       char(32)                 unaligned dcl 392 set ref 490* 492* 494
rtrim                                                  builtin function         dcl 805 ref 66 66 80 80 228 228 228 228 232 232 232
                                                                                  232 243 327 342 342 406 410 419 419 419 475 490
                                                                                  494
saved_res_version_ptr
                        136            based           pointer                  level 2 dcl 7-25 ref 227 418
sci_ptr                         002562 automatic       pointer                  dcl 806 set ref 696* 703* 706* 710* 712*
segment_acl_entry                      based           structure                level 1 dcl 2-45
source_dir               12            based           char(168)                level 2 packed unaligned dcl 4-12 set ref 433* 458*
                                                                                  463* 469* 600* 624* 628* 630*
source_name              64            based           char(32)                 level 2 packed unaligned dcl 4-12 set ref 434* 458*
                                                                                  460 469* 470 601* 624* 630*
ssu_$abort_line                 000076 constant        entry                    external dcl 807 ref 703
ssu_$arg_count                  000100 constant        entry                    external dcl 808 ref 706
ssu_$arg_ptr                    000102 constant        entry                    external dcl 809 ref 710 712
substr                                                 builtin function         dcl 810 ref 571
sys_info$max_seg_size           000104 external static fixed bin(35,0)          dcl 811 ref 58
target_dir               74            based           char(168)                level 2 packed unaligned dcl 4-12 set ref 433* 600*
target_name             146            based           char(32)                 level 2 packed unaligned dcl 4-12 set ref 435* 463*
                                                                                  464 602* 628*
temp_dir_path            60            based           char(168)                level 2 packed unaligned dcl 7-25 set ref 51* 95*
tempp                           002564 automatic       pointer                  dcl 812 set ref 60* 95* 113 113* 172 312 394 576*
                                                                                  661*
terminate_file_                 000106 constant        entry                    external dcl 813 ref 115 260 486 639 682
to                       14            based           char(32)                 array level 3 packed unaligned dcl 11-14 set ref 80*
                                                                                  89* 101*
to_name                         002566 automatic       char(32)                 unaligned dcl 814 set ref 554 571 579* 587* 591 593*
                                                                                  602 654 678 713*
type                      2            based           fixed bin(17,0)          level 2 packed unaligned dcl 11-14 ref 31 36 41 46
                                                                                  71 73 84 86
ua_ptr                          000112 automatic       pointer                  dcl 5-165 set ref 206* 206* 208 210* 222
unreferenced_attribute                 based           structure                level 1 dcl 5-159
unreferenced_attribute_ptr
                         23            based           bit(18)                  level 2 packed unaligned dcl 5-72 ref 206 650
unspec                                                 builtin function         dcl 816 set ref 437* 443* 604* 610*
version                                based           char(8)                  level 2 in structure "copy_options" dcl 4-12
                                                                                  in procedure "rmdb_rename" set ref 431* 598*
version                                based           char(8)                  level 2 in structure "rename_object_info" packed
                                                                                  unaligned dcl 11-14 in procedure "rmdb_rename" ref
                                                                                  27 27
vfile_type                0(35)        based           bit(1)                   level 3 packed unaligned dcl 5-72 ref 427 593

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACL_VERSION_1                          internal static fixed bin(17,0)          initial dcl 2-77
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DELETE_ACL_VERSION_1                   internal static char(4)                  initial unaligned dcl 2-67
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-33
DIR_ACL_VERSION_1                      internal static char(4)                  initial unaligned dcl 2-67
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
GENERAL_DELETE_ACL_VERSION_1           internal static char(8)                  initial unaligned dcl 2-72
GENERAL_EXTENDED_ACL_VERSION_1         internal static char(8)                  initial unaligned dcl 2-72
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
OBJECT_HEAD                            internal static char(1)                  initial unaligned dcl 9-29
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RMDB_ADD_ATTR_OP                       internal static fixed bin(17,0)          initial dcl 10-54
RMDB_ADD_DMN_OP                        internal static fixed bin(17,0)          initial dcl 10-56
RMDB_ADD_IDX_OP                        internal static fixed bin(17,0)          initial dcl 10-52
RMDB_ADD_REL_OP                        internal static fixed bin(17,0)          initial dcl 10-50
RMDB_CTL_VERSION_1                     internal static fixed bin(17,0)          initial dcl 7-41
RMDB_DEL_ATTR_OP                       internal static fixed bin(17,0)          initial dcl 10-55
RMDB_DEL_DMN_OP                        internal static fixed bin(17,0)          initial dcl 10-57
RMDB_DEL_IDX_OP                        internal static fixed bin(17,0)          initial dcl 10-53
RMDB_DEL_REL_OP                        internal static fixed bin(17,0)          initial dcl 10-51
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-30
SEG_ACL_VERSION_1                      internal static char(4)                  initial unaligned dcl 2-67
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
TERM_FILE_BC                           internal static bit(2)                   initial unaligned dcl 12-12
TERM_FILE_DELETE                       internal static bit(5)                   initial unaligned dcl 12-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 12-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial unaligned dcl 12-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial unaligned dcl 12-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial unaligned dcl 12-15
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
acl_count                              automatic       fixed bin(17,0)          dcl 2-5
al_ptr                                 automatic       pointer                  dcl 6-345
alloc_length                           internal static fixed bin(35,0)          dcl 5-222
atd                                    based           char                     unaligned dcl 6-109
atd_len                                automatic       fixed bin(17,0)          dcl 6-111
atd_ptr                                automatic       pointer                  dcl 6-110
attr_list                              based           structure                level 1 dcl 6-341
attribute                              based           structure                level 1 unaligned dcl 9-99
attribute_count                        automatic       fixed bin(17,0)          dcl 9-98
attribute_list                         based           structure                level 1 unaligned dcl 9-55
attribute_list_count                   automatic       fixed bin(17,0)          dcl 9-53
attribute_list_names                   based           char                     unaligned dcl 9-54
attribute_list_ptr                     automatic       pointer                  dcl 9-52
attribute_ptr                          automatic       pointer                  dcl 9-97
changer                                based           structure                level 1 packed unaligned dcl 5-251
changer_ptr                            automatic       pointer                  dcl 5-256
child_link_info                        based           structure                level 1 dcl 6-283
cli_ptr                                automatic       pointer                  dcl 6-329
cna_ptr                                automatic       pointer                  dcl 6-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 6-112
constant                               based           structure                level 1 unaligned dcl 5-216
constant_ptr                           automatic       pointer                  dcl 5-220
crossref_info_record_count             automatic       fixed bin(21,0)          dcl 9-18
crossref_info_record_objects           based           char                     unaligned dcl 9-27
crossref_info_record_ptr               automatic       pointer                  dcl 9-17
delete_acl                             based           structure                level 1 dcl 2-58
delete_acl_array                       based           structure                array level 1 dcl 2-64
directory_acl                          based           structure                level 1 dcl 2-49
directory_acl_array                    based           structure                array level 1 dcl 2-55
domain_list                            based           structure                level 1 unaligned dcl 9-45
domain_list_count                      automatic       fixed bin(17,0)          dcl 9-43
domain_list_names                      based           char                     unaligned dcl 9-44
domain_list_ptr                        automatic       pointer                  dcl 9-42
dp_ptr                                 automatic       pointer                  dcl 6-356
dup_prev                               based           structure                level 1 dcl 6-353
fixed                                                  builtin function         dcl 756
general_acl                            based           structure                level 1 dcl 2-7
general_delete_acl                     based           structure                level 1 dcl 2-30
general_extended_acl                   based           structure                level 1 dcl 2-18
message_str                            based           structure                level 1 packed unaligned dcl 5-259
message_str_len                        automatic       fixed bin(17,0)          dcl 5-269
message_str_ptr                        automatic       pointer                  dcl 5-267
ncomp_init                             automatic       fixed bin(17,0)          dcl 6-116
parent_link_info                       based           structure                level 1 dcl 6-223
path_entry                             based           structure                level 1 packed unaligned dcl 5-172
path_entry_ptr                         automatic       pointer                  dcl 5-177
pli_ptr                                automatic       pointer                  dcl 6-268
relation                               based           structure                level 1 unaligned dcl 9-77
relation_attribute_count               automatic       fixed bin(17,0)          dcl 9-75
relation_attribute_names               based           char                     unaligned dcl 9-76
relation_list                          based           structure                level 1 unaligned dcl 9-67
relation_list_count                    automatic       fixed bin(17,0)          dcl 9-65
relation_list_names                    based           char                     unaligned dcl 9-66
relation_list_ptr                      automatic       pointer                  dcl 9-64
relation_ptr                           automatic       pointer                  dcl 9-74
rename_object_info_count               automatic       fixed bin(17,0)          dcl 11-10
rmdb_history_entry                     based           structure                level 1 dcl 10-31
rmdb_history_entry_ptr                 automatic       pointer                  dcl 10-42
rmdb_relmgr_entries_ptr                automatic       pointer                  dcl 8-32
sc_ptr                                 automatic       pointer                  dcl 6-365
segment_acl                            based           structure                level 1 dcl 2-40
segment_acl_array                      based           structure                array level 1 dcl 2-46
select_chain                           based           structure                level 1 dcl 6-357
sk_ptr                                 automatic       pointer                  dcl 6-352
sort_key                               based           structure                level 1 dcl 6-346
stack_item                             based           structure                level 1 unaligned dcl 5-206
stack_item_ptr                         automatic       pointer                  dcl 5-212
terminate_file_switches                based           structure                level 1 packed unaligned dcl 12-4
version_status                         based           structure                level 1 packed unaligned dcl 5-232
version_status_ptr                     automatic       pointer                  dcl 5-246

NAMES DECLARED BY EXPLICIT CONTEXT.
RENAME_ATTRIBUTE_COMMON         001675 constant        label                    dcl 172 ref 164 170
RETURN_TO_CALLER                001412 constant        label                    dcl 107 ref 132 580 585 699 707
cleaner                         001466 constant        entry                    internal dcl 110 ref 61 104 131 237 413 577 662
error                           001557 constant        entry                    internal dcl 120 ref 27 46 53 76 78 89 91 96 105 179
                                                                                  188 196 201 215 219 245 267 273 322 327 337 343
                                                                                  353 402 406 415 460 464 470 475 482 487 494 499
initialize                      007611 constant        entry                    internal dcl 691 ref 532
rename_attribute                001627 constant        entry                    internal dcl 153 ref 33
rename_attribute$unreferenced_domain
                                001652 constant        entry                    internal dcl 166 ref 358
rename_domain                   003566 constant        entry                    internal dcl 304 ref 38
rename_relation                 004433 constant        entry                    internal dcl 385 ref 43
rmdb_rename                     000401 constant        entry                    external dcl 19
rmdb_rename$undo_rename         001417 constant        entry                    external dcl 529
undo_attribute                  007326 constant        entry                    internal dcl 644 ref 535
undo_domain                     006454 constant        entry                    internal dcl 543 ref 533
undo_relation                   006514 constant        entry                    internal dcl 561 ref 537

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10610       10720   10004       10620
Length     11534   10004       110         577     604           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rmdb_rename                        1526 external procedure  is an external procedure.  
on unit on line 61                   64 on unit               
cleaner                              98 internal procedure  is called by several nonquick procedures.  
error                                65 internal procedure  is called during a stack extension.  
rename_attribute                    308 internal procedure  is assigned to an entry variable, and enables or reverts conditions.  
on unit on line 184                  64 on unit               
on unit on line 237                  64 on unit               
rename_domain                       266 internal procedure  is assigned to an entry variable, and enables or reverts conditions.  
on unit on line 317                  64 on unit               
rename_relation                     325 internal procedure  is assigned to an entry variable, and enables or reverts conditions.  
on unit on line 398                  64 on unit               
on unit on line 413                  64 on unit               
undo_domain                             internal procedure  shares stack frame of external procedure rmdb_rename.  
undo_relation                       142 internal procedure  enables or reverts conditions.  
on unit on line 577                  64 on unit               
undo_attribute                      108 internal procedure  enables or reverts conditions.  
on unit on line 662                  64 on unit               
initialize                              internal procedure  shares stack frame of external procedure rmdb_rename.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rename_attribute         000100 ra_attribute_xref_ptr       rename_attribute
                         000102 ra_loop                     rename_attribute
                         000103 ra_relation_name            rename_attribute
                         000113 ra_unreferenced_domain      rename_attribute
rename_domain            000100 rd_domain_xref_ptr          rename_domain
                         000102 rd_loop                     rename_domain
rename_relation          000100 rr_from_model_name          rename_relation
                         000110 rr_relation_xref_ptr        rename_relation
                         000112 rr_to_model_name            rename_relation
rmdb_rename              000100 acl_ptr                     rmdb_rename
                         000102 copy_options_ptr            rmdb_rename
                         000104 dbm_ptr                     rmdb_rename
                         000106 fi_ptr                      rmdb_rename
                         000110 di_ptr                      rmdb_rename
                         000112 ua_ptr                      rmdb_rename
                         000114 fm_ptr                      rmdb_rename
                         000116 ri_ptr                      rmdb_rename
                         000120 ai_ptr                      rmdb_rename
                         000122 rmdb_ctl_ptr                rmdb_rename
                         000124 rename_object_info_ptr      rmdb_rename
                         000126 argl                        rmdb_rename
                         000130 argp                        rmdb_rename
                         000140 code                        rmdb_rename
                         000141 continue                    rmdb_rename
                         000142 error_message               rmdb_rename
                         000337 from_name                   rmdb_rename
                         000347 incon_value                 rmdb_rename
                         000350 key_head                    rmdb_rename
                         000360 local_copy_options          rmdb_rename
                         000540 local_iocb                  rmdb_rename
                         000542 loop                        rmdb_rename
                         000543 max_seg_size                rmdb_rename
                         000544 my_area                     rmdb_rename
                         002544 operation                   rmdb_rename
                         002554 quit_occurred               rmdb_rename
                         002556 rename_entry                rmdb_rename
                         002562 sci_ptr                     rmdb_rename
                         002564 tempp                       rmdb_rename
                         002566 to_name                     rmdb_rename
                         002614 i_nargs                     initialize

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other_desc call_int_other      return_mac          tra_ext_1           signal_op
enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry           int_entry_desc
op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
fs_util_$chname_file          fs_util_$copy                 fs_util_$delentry_file        fs_util_$list_acl
fs_util_$replace_acl          initiate_file_                mdbm_util_$free_temp_segment
mdbm_util_$get_temp_segment_path                            mdbm_util_$inconsistent_get_info
mdbm_util_$inconsistent_reset mdbm_util_$inconsistent_set   mdbm_util_$xref_build         mdbm_util_$xref_find_record
mdbm_util_$xref_modify_record_name                          mdbm_util_$xref_modify_reference_name
rmdb_add_rmdb_history         ssu_$abort_line               ssu_$arg_count                ssu_$arg_ptr
terminate_file_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$no_record        error_table_$noentry          error_table_$unimplemented_version
error_table_$unsupported_operation                          mrds_error_$attr_already_exists
mrds_error_$domain_already_defined                          mrds_error_$dup_rel           mrds_error_$internal_error
mrds_error_$no_model_attr     mrds_error_$no_model_dom      mrds_error_$no_model_rel      sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    788 000367        19 000374        22 000415        23 000421        24 000424        25 000426        27 000430
     31 000470        33 000477        34 000502        35 000505        36 000506        38 000510        39 000513
     40 000516        41 000517        43 000521        44 000524        45 000527        46 000530        49 000603
     51 000610        53 000650        55 000666        58 000671        60 000675        61 000700        65 000722
     66 000733        68 001023        71 001031        73 001042        75 001047        76 001051        77 001071
     78 001072        80 001106        82 001176        84 001201        86 001213        88 001221        89 001224
     90 001244        91 001245        93 001264        95 001266        96 001314       100 001335       101 001345
    102 001367       104 001371       105 001375       107 001412       529 001413       532 001425       533 001426
    535 001434       537 001445       540 001455       541 001464       110 001465       113 001473       115 001521
    117 001555       120 001556       126 001572       127 001577       129 001606       131 001616       132 001623
    153 001626       163 001647       164 001650       166 001651       169 001672       170 001674       172 001675
    177 001700       179 001743       183 001763       184 001765       187 002006       188 002014       192 002055
    195 002063       196 002126       198 002146       199 002154       201 002222       203 002242       205 002243
    206 002246       208 002262       210 002272       211 002277       212 002300       213 002305       215 002352
    217 002372       219 002437       222 002457       223 002467       227 002470       228 002476       232 002656
    236 003034       237 003040       240 003062       243 003073       244 003127       245 003170       249 003216
    250 003227       251 003231       253 003244       255 003254       256 003261       258 003262       260 003270
    261 003317       264 003321       265 003327       267 003375       271 003415       273 003460       276 003500
    281 003510       285 003555       286 003556       289 003564       304 003565       312 003606       316 003611
    317 003613       320 003634       322 003677       326 003717       327 003725       331 004022       332 004026
    334 004042       336 004054       337 004056       342 004116       343 004205       348 004246       351 004257
    353 004320       358 004340       360 004357       363 004422       364 004423       367 004431       385 004432
    394 004453       397 004456       398 004460       400 004501       402 004544       405 004564       406 004572
    410 004667       412 004721       413 004725       414 004747       415 005007       418 005046       419 005055
    423 005231       424 005242       425 005252       427 005256       430 005315       431 005317       432 005322
    433 005325       434 005337       435 005344       437 005351       438 005352       439 005354       440 005356
    441 005360       443 005362       444 005363       445 005365       446 005367       447 005371       449 005373
    450 005375       455 005406       457 005411       458 005413       460 005452       463 005501       464 005536
    467 005565       469 005570       470 005612       475 005641       478 005734       481 005750       482 006017
    484 006037       486 006047       487 006075       490 006134       492 006166       494 006217       497 006305
    499 006351       502 006371       504 006434       507 006444       508 006445       511 006453       543 006454
    546 006455       549 006457       551 006473       553 006500       554 006501       556 006504       558 006512
    561 006513       564 006521       567 006524       569 006540       571 006545       572 006550       574 006551
    576 006557       577 006562       579 006604       580 006644       584 006655       585 006715       587 006723
    590 006753       591 006764       593 006767       595 007023       597 007026       598 007030       599 007033
    600 007036       601 007050       602 007053       604 007056       605 007057       606 007061       607 007063
    608 007065       610 007067       611 007070       612 007072       613 007074       614 007076       616 007100
    621 007111       623 007114       624 007116       626 007155       628 007160       630 007214       635 007242
    636 007245       637 007246       639 007271       640 007321       641 007324       644 007325       647 007333
    650 007336       652 007352       654 007357       655 007362       657 007363       659 007371       661 007373
    662 007376       665 007420       667 007434       668 007477       670 007502       671 007504       674 007514
    676 007530       678 007535       679 007540       681 007541       682 007547       683 007576       685 007601
    688 007610       691 007611       696 007612       697 007616       698 007621       699 007623       702 007627
    703 007657       706 007707       707 007720       710 007723       711 007742       712 007747       713 007766
    715 007773


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
