	COMPILATION LISTING OF SEGMENT rmdb_ready_db
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1327.7 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 rmdb_ready_db: proc (db_path, quiesce_wait_time, entries_str_ptr, absolute_db_path,
        8 	db_model_ptr, saved_res_version_ptr, error_message, code);
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(86-01-28,Spitzer), approve(86-01-28,MCR7311),
       13*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
       14*     add initialization for relmgr_entries.(put_tuple get_tuples_by_spec).
       15*  2) change(86-08-21,Blair), approve(86-08-21,MCR7311),
       16*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
       17*     Back out the entry points get_tuples_by_spec and put_tuples as they
       18*     haven't been sufficiently tested to be reliable.  Put in get_tuple_id and
       19*     get_tuple_by_id.
       20*                                                   END HISTORY COMMENTS */
       21 
       22 
       23 /*
       24*   .		       BEGIN_DESCRIPTION
       25*   This module quiesces a data base in  preparation  for  its  being
       26*   restructured  and  checks  to  be  sure that the data base can be
       27*   restructured by the caller. It also returns  to  the  caller  the
       28*   absolute  path of the data base and a pointer to the db_model for
       29*   the database and a pointer the the version of the saved res.
       30*
       31*   The restrictions are:
       32*   .   only a data base may be restructured - the  path  cannot
       33*   .      refer to a submodel.
       34*   .   only a version 4 or latter data base may be restructured
       35*   .   the caller must be a DBA for the data base
       36*   .		       END_DESCRIPTION
       37*
       38*   Known Bugs:
       39*   Other Problems:
       40*
       41*   .                       HISTORY
       42*   82-03-22 Davids: Written
       43*
       44*   82-05-25 Davids: added code to initiate a pointer to the db_model
       45*   .                segment and return it to the caller.
       46*
       47*   82-05-26 Davids: changed   to   be	compatable   with   the  new
       48*   .                mu_quiesce$quiesce_quiet calling sequence.
       49*
       50*   82-05-26 Roger Lackey: changed mrds_dsl_get_version$get_path_info to
       51*                   dsl_$get_path_info for binding
       52*                      and
       53*                  mu_quiesce$quiesce_quiet to mdbm_util_$quiesce_quiet
       54*
       55*   82-08-20 Davids: added entries_str_ptr to the parameter list, included 
       56*                    the rmdb_relmgr_entries and mdbm_db_model include files
       57*                    and added code to set the values of the relmgr entries
       58*                    to the correct relation_manager based on the database type.
       59*
       60*   83-02-14 Davids: modified to use the new db_type_flags in the db_model
       61*   structure instead of the old numeric db_type.
       62*
       63*   83-05-24 Davids: Added code to initiate the saved rdbi segment and return
       64*   a pointer to the saved_res_version element.
       65*
       66*   83-10-04 Benjamin: Changed hcs_$initiate calls to initiate_file_.
       67*
       68*   84-10-23 Benjamin: Changed to not abort when mu_quiesce returns 
       69*   mrds_error_$my_quiesced_db.
       70**/
       71 
       72 /* PARAMETERS */
       73 
       74 	dcl     db_path		 char (168);	/* (input) data base path reative or absolute */
       75 	dcl     quiesce_wait_time	 fixed bin;	/* (input) length of time to wait before giving
       76*						   up tring to quiesce the data base */
       77 	dcl     entries_str_ptr	 ptr;		/* (input) pointer to the relmgr_entries structure whose
       78*                                                               elements will be set by this procedure */
       79 	dcl     absolute_db_path	 char (168);	/* (output) absoulte path of the data base */
       80 	dcl     db_model_ptr	 ptr;		/* (output) pointer to the db_model segment of the database */
       81 	dcl     saved_res_version_ptr	 ptr;		/* (output) pointer the saved_res_version element
       82*                                                               of the saved rdbi segment */
       83 	dcl     error_message	 char (500);	/* (output) text of error message in case of problems */
       84 	dcl     code		 fixed bin (35);	/* (output) standard error code */
       85 
       86 /* EXTERNAL STATIC */
       87 
       88 	dcl     error_table_$action_not_performed fixed bin (35) external static;
       89 	dcl     error_table_$no_dir	 fixed bin (35) ext static;
       90 	dcl     mrds_error_$my_quiesced_db fixed bin (35) ext static;
       91 	dcl     sys_info$max_seg_size	 fixed bin (35) external static;
       92 
       93 /* ENTRIES */
       94 
       95 	dcl     vfile_relmgr_$close	 entry (bit (36) aligned, fixed bin (35));
       96 	dcl     vfile_relmgr_$create_index entry (bit (36) aligned, ptr,
       97 				 bit (36) aligned, fixed bin, bit (36) aligned, fixed bin (35));
       98 	dcl     vfile_relmgr_$create_MRDS_relation entry (char (*), char (*), ptr,
       99 				 ptr, bit (36) aligned, bit (36) aligned, fixed bin (35));
      100 	dcl     vfile_relmgr_$destroy_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
      101 	dcl     vfile_relmgr_$destroy_relation_by_path entry (char (*), char (*), fixed bin (35));
      102 	dcl     vfile_relmgr_$open	 entry (char (*), char (*), bit (36) aligned, fixed bin (35));
      103 	dcl     vfile_relmgr_$put_tuple entry (ptr, ptr, bit (36) aligned, fixed bin(35));
      104 	dcl     vfile_relmgr_$create_cursor entry (bit(36) aligned, ptr, ptr, fixed bin(35));
      105           dcl     vfile_relmgr_$get_tuple_id entry (ptr, ptr, ptr, ptr, fixed bin (35));
      106 	dcl     vfile_relmgr_$get_tuple_by_id entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35));
      107 	     
      108 	dcl     relation_manager_$close entry (bit (36) aligned, fixed bin (35));
      109 	dcl     relation_manager_$create_index entry (bit (36) aligned, ptr,
      110 				 bit (36) aligned, fixed bin, bit (36) aligned, fixed bin (35));
      111 	dcl     relation_manager_$create_relation entry (char (*), char (*), ptr,
      112 				 ptr, bit (36) aligned, bit (36) aligned, fixed bin (35));
      113 	dcl     relation_manager_$destroy_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
      114 	dcl     relation_manager_$destroy_relation_by_path entry (char (*), char (*), fixed bin (35));
      115 	dcl     relation_manager_$open entry (char (*), char (*), bit (36) aligned, fixed bin (35));
      116 	dcl     relation_manager_$put_tuple entry (ptr, ptr, bit (36) aligned, fixed bin(35));
      117 	dcl     relation_manager_$create_cursor entry (bit(36) aligned, ptr, ptr, fixed bin(35));
      118           dcl     relation_manager_$get_tuple_id entry (ptr, ptr, ptr, ptr, fixed bin (35));
      119 	dcl     relation_manager_$get_tuple_by_id entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35));
      120 
      121 	dcl     ioa_$rs		 entry () options (variable);
      122 	dcl     initiate_file_	 entry (char (*), char (*), bit (*), ptr, fixed bin (24),
      123 				 fixed bin (35));
      124 	dcl     mdbm_util_$get_user_class entry (char (*), ptr, fixed bin, ptr, fixed bin (35));
      125 	dcl     dsl_$get_path_info	 entry (char (*), ptr, fixed bin, ptr, fixed bin (35));
      126 	dcl     dsl_$create_res_copy	 entry options (variable);
      127 	dcl     mdbm_util_$quiesce_quiet entry (char (168), fixed bin, fixed bin (35));
      128 
      129 /* INTERNAL AUTOMATIC */
      130 
      131 	dcl     area		 area (500);	/* local working area for structures to be allocated in */
      132 	dcl     bit_count		 fixed bin (24);	/* required in calls to initiate_file_ */
      133 	dcl     local_db_model_ptr	 ptr;		/* local copy of the pointer to the db_model seg */
      134 	dcl     saved_rdbi_ptr	 ptr;		/* pointer the the rm_db_info structure in the rdbi segment */
      135 
      136 
      137 /* BUILTINS */
      138 
      139 	dcl     addr		 builtin;
      140 	dcl     empty		 builtin;
      141 	dcl     fixed		 builtin;
      142 	dcl     length		 builtin;
      143 	dcl     null		 builtin;
      144 	dcl     rel		 builtin;
      145 	dcl     rtrim		 builtin;
      146 
      147 /* INCLUDE FILES */
      148 
  1     1 /* BEGIN INCLUDE FILE mrds_authorization.incl.pl1 - - 81-01-20 Jim Gray */
  1     2 
  1     3 /* HISTORY:
  1     4*
  1     5*   81-01-20 Jim Gray : original created for the mmi_$get_authorization interface
  1     6*
  1     7**/
  1     8 
  1     9 /* DESCRIPTION:
  1    10*
  1    11*   this structure returns the callers user_class
  1    12*   either database administrator or normal user.
  1    13*   Note that these separate classes were used to allow
  1    14*   future expansion to the user classes, rather than
  1    15*   make them logical "not"'s of one another.
  1    16*   NOTE: a DBA is always also a normal user, thus if the caller
  1    17*   is a DBA, his normal_user bit will be on also.
  1    18*
  1    19**/
  1    20 
  1    21 
  1    22 declare 1 mrds_authorization aligned based (mrds_authorization_ptr),
  1    23         2 version fixed bin,				/* version number of this structure */
  1    24         2 administrator bit (1) unal,			/* caller is a DBA */
  1    25         2 normal_user bit (1) unal,			/* caller has no special priviledges */
  1    26         2 mbz bit (34) unal ;
  1    27 
  1    28 
  1    29 declare  mrds_authorization_ptr ptr ;			/* pointer for referring to the structure */
  1    30 
  1    31 declare  mrds_authorization_structure_version fixed bin init (1) int static options (constant) ;
  1    32 
  1    33 /* END INCLUDE FILE mrds_authorization.incl.pl1 */
      149 
      150 
  2     1 /* BEGIN INCLUDE FILE mrds_path_info.incl.pl1 - -  Jim Gray 81-01-22 */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*   81-01-22 Jim Gray : originaly created for the dsl_$get_path_info interface,
  2     6*   a slight extension to the undocumented mrds_dsl_get_version$header.
  2     7*
  2     8**/
  2     9 
  2    10 /* DESCRIPTION:
  2    11*
  2    12*   This structure returns information about a relative pathname, given
  2    13*   to a pathname accepting mrds interface. The information returned
  2    14*   is the absolute pathname, plus in the case that
  2    15*   the relative path points to a mrds database or submodel
  2    16*   whether it is a model or a submodel, the mrds version of
  2    17*   the model or submodel, it's creator, and the time of creation.
  2    18*
  2    19**/
  2    20 
  2    21 
  2    22 declare 1 mrds_path_info aligned based (mrds_path_info_ptr),
  2    23         2 version fixed bin,				/* version number for this structure */
  2    24         2 absolute_path char (168),			/* the absolute path from the input relative path */
  2    25         2 type,
  2    26 	3 not_mrds bit (1) unal,			/* on => path not to model or submodel */
  2    27 	3 model bit (1) unal,			/* on => path to database model, thus possible .db suffix */
  2    28 	3 submodel bit (1) unal,			/* on => path to submodel, thus possible .dsm suffix */
  2    29 	3 mbz1 bit (33) unal,
  2    30         2 mrds_version fixed bin,			/* the mrds version number of the model or submodel */
  2    31         2 creator_id char (32),			/* the person.project.tag of the creator */
  2    32         2 creation_time fixed bin (71),			/* convert date to binary form of time model/submodel created */
  2    33         2 mbz2 bit (36) unal ;
  2    34 
  2    35 
  2    36 declare  mrds_path_info_ptr ptr ;
  2    37 
  2    38 declare  mrds_path_info_structure_version fixed bin init (1) int static options (constant) ;
  2    39 
  2    40 /* END  INCLUDE FILE mrds_path_info.incl.pl1 */
      151 
      152 
  3     1 /*  START OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(82-08-20,Davids), approve(), audit(), install():
  3     6*     written
  3     7*  2) change(86-01-28,Spitzer), approve(86-01-28,MCR7311),
  3     8*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  3     9*     add get_tuples_by_spec, put_tuple, put_tuples, create_cursor entry points.
  3    10*  3) change(86-08-21,Blair), approve(86-08-21,MCR7311),
  3    11*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  3    12*     Back out the entries get_tuples_by_spec and put_tuples since they aren't
  3    13*     sufficiently well tested to be reliable.  Replace with get_tuple_id and
  3    14*     get_tuple_by_id.
  3    15*                                                   END HISTORY COMMENTS */
  3    16 
  3    17 
  3    18 dcl 01 rmdb_relmgr_entries based (rmdb_relmgr_entries_ptr),
  3    19      02 create_relation entry (char (*), char (*), ptr, ptr, bit (36) aligned,
  3    20 	bit (36) aligned, fixed bin (35)),
  3    21      02 delete_relation entry (char (*), char (*), fixed bin (35)),
  3    22      02 open entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  3    23      02 close entry (bit (36) aligned, fixed bin (35)),
  3    24      02 create_index entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17),
  3    25 	bit (36) aligned, fixed bin (35)),
  3    26      02 delete_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35)),
  3    27      02 put_tuple entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  3    28      02 get_tuple_id entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  3    29      02 get_tuple_by_id entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  3    30      02 create_cursor entry (bit (36) aligned, ptr, ptr, fixed bin (35));
  3    31 
  3    32 dcl rmdb_relmgr_entries_ptr ptr;
  3    33 
  3    34 /*  END OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      153 
      154 
  4     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  4     6*     modified to save space occupied by model
  4     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  4     8*     to add mdbm_secured bit in db_model
  4     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  4    10*     collapsed the following into an unused_offset array:
  4    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  4    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  4    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  4    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  4    15*       unused_1
  4    16*     Also changed the name of unused_2 to restructuring_history_offset
  4    17*     and changed the comment on the changer structure to indicate
  4    18*     that it will contain on database creation information.
  4    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  4    20*     used one of the unused_offsets to point to a message which indicates
  4    21*     why the db is inconsistent. The offset will be null when the db is created
  4    22*     and set the first time the message is used. this is so it will be
  4    23*     consistent with existing data bases. Also added the message structure.
  4    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  4    25*     added the undo_request element to the message structure
  4    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  4    27*     changed unused_offset (12) to last_restructruring_history_offset and
  4    28*     changed restructuring_history_offset to first_restructuring_history_offset
  4    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  4    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  4    31*     1 => vfile database and 2 => page_file database. Up to this point all
  4    32*     database types were equal to 1.
  4    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  4    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  4    35*     flags. This will allow information about transactions and dm_file
  4    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  4    37*     change is compatable with all datamodels created by the released version
  4    38*     of mrds.
  4    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  4    40*     added the rollback_on flag to the db_type_flags since it appears that you
  4    41*     can have a dmfile database that requires transactions but does not have any
  4    42*     journalizing. Also switched the order of the transactions_needed and
  4    43*     concurrency_on flags - this makes the change compatable with existing
  4    44*     dmfile databases except when displaying the model since concurrency_on and
  4    45*     rollback_on will be off in the model even though the dmfile relations had
  4    46*     them on during creation.
  4    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  4    48*      Removed ctl_file_path_ptr.
  4    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  4    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  4    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  4    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  4    53*      in the flag word for rmdb copying.
  4    54*                                                   END HISTORY COMMENTS */
  4    55 
  4    56 
  4    57 /* this include file contains the structures that go into the make up
  4    58*   of the "db_model" segment in the model for the database.
  4    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  4    60*
  4    61*   the db_model structure goes at the base of the segment, and contains items unique to
  4    62*   the whole databse. in addition, it has an area of size to fill the
  4    63*   rest of a segment, that holds the lists of files and domains in the database.
  4    64*   these lists are singly forward linked lists. all "pointers" in the database model
  4    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  4    66*   since actual pointers are process dependent on segment number.
  4    67*   the remaining structures are first a path_entry one to save pathnames in,
  4    68*   and the stack_item and constent structures, used to save a boolean
  4    69*   expression in polish form, with the stack represented by a linked list.
  4    70*   the final structure is one for identifying the status of version information */
  4    71 
  4    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  4    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  4    74 	     2 db_type_flags      unal,
  4    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  4    76 	       3 unused	      (13) bit (1) unal,
  4    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  4    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  4    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  4    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  4    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  4    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  4    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  4    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  4    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  4    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  4    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  4    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  4    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  4    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  4    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  4    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  4    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  4    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  4    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  4    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  4    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  4    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  4    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  4   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  4   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  4   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  4   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  4   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  4   105 
  4   106      dcl	   dbm_ptr	      ptr;
  4   107 
  4   108 /* the files in the database each have a file_info containing
  4   109*   their name, the file_model for each file is found by initiating the
  4   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  4   111*   the file_info list is a singly linked list in definition order */
  4   112 
  4   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  4   114 	     2 file_name	      char (30),		/* name of file */
  4   115 	     2 file_id	      bit (36),		/* id number of file */
  4   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  4   117 	     2 unused	      unal bit (18);	/* for future expansion */
  4   118 
  4   119      dcl	   fi_ptr		      ptr;
  4   120 
  4   121 /* each domain used in the database will have a domain info saved in the db_model
  4   122*   segment. it describes the domain of the given name, and it's options.
  4   123*   the domain_info's form a singly linked list in definition order */
  4   124 
  4   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  4   126 	     2 name	      char (32),		/* name of domain */
  4   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  4   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  4   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  4   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  4   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  4   132 	     2 reserved	      bit (31) unal,
  4   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  4   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  4   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  4   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  4   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  4   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  4   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  4   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  4   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  4   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  4   143 	     2 str_err_path_ptr   unal bit (18),
  4   144 	     2 str_after_path_ptr unal bit (18),
  4   145 	     2 get_before_path_ptr unal bit (18),
  4   146 	     2 get_err_path_ptr   unal bit (18),
  4   147 	     2 get_after_path_ptr unal bit (18),
  4   148 	     2 mod_before_path_ptr unal bit (18),
  4   149 	     2 mod_err_path_ptr   unal bit (18),
  4   150 	     2 mod_after_path_ptr unal bit (18),
  4   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  4   152 	     2 unused_2	      unal bit (18),
  4   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  4   154 
  4   155      dcl	   di_ptr		      ptr;
  4   156 
  4   157 /* information necessary for attributes that are not used in any relation */
  4   158 
  4   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  4   160 	     2 name char (32),			/* name of attribute */
  4   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  4   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  4   163 	     2 unused (2) bit (18) unal;
  4   164 
  4   165      dcl     ua_ptr ptr;
  4   166 
  4   167 
  4   168 /* space saving pathname$entryname structure, to be allocated
  4   169*   only when a path$entry has to be saved, else only a bit(18)
  4   170*   offset takes up space in the main model structure */
  4   171 
  4   172      declare 1 path_entry	      based (path_entry_ptr),
  4   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  4   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  4   175 	     2 reserved	      unal bit (36);	/* for future use */
  4   176 
  4   177      declare path_entry_ptr	      ptr;
  4   178 
  4   179 
  4   180 
  4   181 
  4   182 
  4   183 /* declarations for model of postfix stack holding the check option boolean expression
  4   184*   the following encoding values indicate the corresponding type of stack element
  4   185*
  4   186*   1  =
  4   187*   2  ^=
  4   188*   3  >
  4   189*   4  <
  4   190*   5  >=
  4   191*   6  <=
  4   192*
  4   193*   10  and
  4   194*   20  or
  4   195*   30  not
  4   196*
  4   197*   40  - (minus)
  4   198*
  4   199*   50  domain variable(same name as domain)
  4   200*
  4   201*   60  constant(number, bit string, or character string)
  4   202*
  4   203**/
  4   204 
  4   205 
  4   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  4   207 	     2 next	      bit (18),		/* link to next in list */
  4   208 	     2 type	      fixed binary,		/* code for this element type */
  4   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  4   210*						   if this is a constant element type */
  4   211 
  4   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  4   213 
  4   214 
  4   215 
  4   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  4   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  4   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  4   219 
  4   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  4   221 
  4   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  4   223 
  4   224 /* version structure, giving status of source for CMDB/RMDB,
  4   225*   status of model, and status of resultant */
  4   226 
  4   227 /* version number is in form MM.N.Y
  4   228*   where MM is the major version number, N is the minor version alteration,
  4   229*   and Y is the lastest modification to that alteration,
  4   230*   where M and N represent numbers 0-9, and Y is a letter */
  4   231 
  4   232      declare 1 version_status	      unal based (version_status_ptr),
  4   233 	     2 cmdb_rmdb,
  4   234 	       3 major	      fixed bin,
  4   235 	       3 minor	      fixed bin,
  4   236 	       3 modification     char (4),
  4   237 	     2 model,
  4   238 	       3 major	      fixed bin,
  4   239 	       3 minor	      fixed bin,
  4   240 	       3 modification     char (4),
  4   241 	     2 resultant,
  4   242 	       3 major	      fixed bin,
  4   243 	       3 minor	      fixed bin,
  4   244 	       3 modification     char (4);
  4   245 
  4   246      declare version_status_ptr     ptr;
  4   247 
  4   248 
  4   249 /* maintains information only about the db creation */
  4   250 
  4   251      declare 1 changer	      unal based (changer_ptr),
  4   252 	     2 id		      char (32),
  4   253 	     2 time	      fixed bin (71),
  4   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  4   255 
  4   256      declare changer_ptr	      ptr;
  4   257 
  4   258 
  4   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  4   260 	     02 len	      fixed bin,		/* length of the message */
  4   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  4   262 	     02 name	      char (32),		/* name of thing that set the message */
  4   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  4   264*                                                               that caused the database to become inconsistent */
  4   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  4   266 
  4   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  4   268 
  4   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  4   270 
  4   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  4   272 
  4   273 
      155 
      156 
  5     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
  5     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  5     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
  5     9*                                                   END HISTORY COMMENTS */
  5    10 
  5    11 
  5    12 /* WARNING
  5    13*          If the rm_db_info structure is changed then the mrds_data_
  5    14*          item saved_res_version MUST be incremented to invalidate all
  5    15*          existing saved resultants
  5    16**/
  5    17 
  5    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
  5    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
  5    20*   resultant model that is created partially at database open  time,
  5    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
  5    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
  5    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
  5    24*   to  provide  an  efficient  means  of  accessing  database  model
  5    25*   information, as seen from the possibly submodel view of the user,
  5    26*   and his current state of "files readied". it is the  secure  part
  5    27*   because  it  contains  the  model  information  which needs to be
  5    28*   protected  from  general  knowledge,  and   this   segment   will
  5    29*   eventually  be  capable  of  being in a lower ring. the structure
  5    30*   itself points to four arrays that are  allocated  in  it's  area,
  5    31*   that  in  turn point to the other structures mentions above, also
  5    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
  5    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
  5    34*   relations,  initially  empty,  and  a  pair  for   normal   model
  5    35*   files/relations.  the  normal  rm_file_array  is initialized to a
  5    36*   list of all known file names, the rm_rel_array only gets relation
  5    37*   names   as   files  are  readied.  the  rm_file_array  points  to
  5    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
  5    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
  5    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
  5    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
  5    42*   file infos point to contained rel infos, the rel infos  point  to
  5    43*   contained  attr  infos,  and  those in turn to domain infos. (see
  5    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
  5    45*   foreign     keys    are    represented    by    the    structures
  5    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
  5    47*   pathnames  of the model and submodel, if any, are also maintained
  5    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
  5    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
  5    50*   individual include files for  further  organization  information,
  5    51*   and particular data structures.
  5    52*
  5    53*   HISTORY:
  5    54*
  5    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
  5    56*   so that define_area_ could be used to make it an extensible area
  5    57*
  5    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
  5    59*   resultant in mu_database_index easier to keep, since no reference
  5    60*   to the area is needed.
  5    61*
  5    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
  5    63*   resultant.
  5    64*
  5    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
  5    66*   structure.
  5    67*
  5    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
  5    69*   are  now  combined  into  the rel_array. Removed the control file
  5    70*   info which was unused. Added pointer  to  head  of  domain  list,
  5    71*   which is to be used to insure only one copy of each domain info.
  5    72*
  5    73*   83-05-19 Davids: Added the  saved_res_version element.
  5    74*
  5    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
  5    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
  5    77*   check, encode, or decode proc.
  5    78*
  5    79*   CAUTION: The structure entries from db_version to sm_path  should
  5    80*   not  be moved or have their declarations changed because they are
  5    81*   used in the handling of old version database openings.
  5    82*
  5    83*
  5    84**/
  5    85 
  5    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
  5    87 	     2 data	      like rm_db_info_data,
  5    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
  5    89 
  5    90      dcl	   rdbi_ptr	      ptr;
  5    91 
  5    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
  5    93*						   like reference to it without getting the area as well */
  5    94 	     2 db_version	      fixed bin,		/* version no. of db */
  5    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
  5    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
  5    97 	     2 db_path	      char (168),		/* abs. path of db. */
  5    98 	     2 sm_path	      char (168),		/* path of submodel or model */
  5    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
  5   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
  5   101 	     2 pad	      bit (34) unal,	/* for future use */
  5   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
  5   103*                                                               dbcb and rdbi segments in the db dir */
  5   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
  5   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
  5   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
  5   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
  5   108 
  5   109 /* END mdbm_rm_db_info.incl.pl1 */
  5   110 
  5   111 
      157 
      158 
  6     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  6     2*
  6     3*   Values for the "access mode" argument so often used in hardcore
  6     4*   James R. Davis 26 Jan 81  MCR 4844
  6     5*   Added constants for SM access 4/28/82 Jay Pattin
  6     6*   Added text strings 03/19/85 Chris Jones
  6     7**/
  6     8 
  6     9 
  6    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  6    11 dcl	(
  6    12 	N_ACCESS		   init ("000"b),
  6    13 	R_ACCESS		   init ("100"b),
  6    14 	E_ACCESS		   init ("010"b),
  6    15 	W_ACCESS		   init ("001"b),
  6    16 	RE_ACCESS		   init ("110"b),
  6    17 	REW_ACCESS	   init ("111"b),
  6    18 	RW_ACCESS		   init ("101"b),
  6    19 	S_ACCESS		   init ("100"b),
  6    20 	M_ACCESS		   init ("010"b),
  6    21 	A_ACCESS		   init ("001"b),
  6    22 	SA_ACCESS		   init ("101"b),
  6    23 	SM_ACCESS		   init ("110"b),
  6    24 	SMA_ACCESS	   init ("111"b)
  6    25 	)		   bit (3) internal static options (constant);
  6    26 
  6    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  6    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  6    29 
  6    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  6    31 			   static options (constant);
  6    32 
  6    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  6    34 			   static options (constant);
  6    35 
  6    36 dcl	(
  6    37 	N_ACCESS_BIN	   init (00000b),
  6    38 	R_ACCESS_BIN	   init (01000b),
  6    39 	E_ACCESS_BIN	   init (00100b),
  6    40 	W_ACCESS_BIN	   init (00010b),
  6    41 	RW_ACCESS_BIN	   init (01010b),
  6    42 	RE_ACCESS_BIN	   init (01100b),
  6    43 	REW_ACCESS_BIN	   init (01110b),
  6    44 	S_ACCESS_BIN	   init (01000b),
  6    45 	M_ACCESS_BIN	   init (00010b),
  6    46 	A_ACCESS_BIN	   init (00001b),
  6    47 	SA_ACCESS_BIN	   init (01001b),
  6    48 	SM_ACCESS_BIN	   init (01010b),
  6    49 	SMA_ACCESS_BIN	   init (01011b)
  6    50 	)		   fixed bin (5) internal static options (constant);
  6    51 
  6    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      159 
      160 
      161 /*
      162*   Initialize the output parameters
      163**/
      164 
      165 	absolute_db_path = "";
      166 	db_model_ptr = null ();
      167 	code = 0;
      168 	error_message = "";
      169 
      170 
      171 
      172 /*
      173*   use the pointer declared in with rmdb_relmgr_entries
      174**/
      175 
      176 	rmdb_relmgr_entries_ptr = entries_str_ptr;
      177 
      178 
      179 
      180 
      181 
      182 /*
      183*   Determine if the input path refers to a  data  base  model  or  a
      184*   submodel.  If a submodel return an error. Also determine the data
      185*   bases's version of its version  3  or  earlier  return  an  error
      186*   (restructuring  can  not  be  supported  by  models  eariler than
      187*   version 4).
      188**/
      189 
      190 
      191 	call dsl_$get_path_info (db_path, addr (area),
      192 	     mrds_path_info_structure_version, mrds_path_info_ptr, code);
      193 	if code ^= 0
      194 	then do;
      195 		call ioa_$rs ("Could not get database path info for ^a", error_message, length (error_message), db_path);
      196 		goto exit_rmdb_ready_db;
      197 	     end;
      198 
      199 	if mrds_path_info.type.submodel
      200 	then do;
      201 		code = error_table_$action_not_performed;
      202 		error_message = "Submodels may not be restructured";
      203 		goto exit_rmdb_ready_db;
      204 	     end;
      205 
      206 	if mrds_path_info.mrds_version <= 3
      207 	then do;
      208 		code = error_table_$action_not_performed;
      209 		error_message = "Version 3 and eariler data bases may not be restructured";
      210 		goto exit_rmdb_ready_db;
      211 	     end;
      212 
      213 /*
      214*   Determine the authorization of the caller, if he  is  not  a  DBA
      215*   return an error.
      216**/
      217 
      218 
      219 	call mdbm_util_$get_user_class ((mrds_path_info.absolute_path), addr (area),
      220 	     mrds_authorization_structure_version, mrds_authorization_ptr, code);
      221 	if code ^= 0
      222 	then do;
      223 		call ioa_$rs ("Unable to determine if you are a DBA for ^a", error_message,
      224 		     length (error_message), mrds_path_info.absolute_path);
      225 		goto exit_rmdb_ready_db;
      226 	     end;
      227 
      228 	if ^mrds_authorization.administrator
      229 	then do;
      230 		code = error_table_$action_not_performed;
      231 		error_message = "Only a data base's DBA may restructure the data base";
      232 		goto exit_rmdb_ready_db;
      233 	     end;
      234 
      235 
      236 
      237 
      238 
      239 /*
      240*   initiate a pointer to the db_model segment  of  the  database  so
      241*   that it is available for the other requests. the output parameter
      242*   will be set after the database is quiesced.
      243**/
      244 
      245 	local_db_model_ptr = null ();
      246 	call initiate_file_ ((mrds_path_info.absolute_path), "db_model", RW_ACCESS, local_db_model_ptr, bit_count, code);
      247 	if local_db_model_ptr = null ()
      248 	then do;
      249 		error_message = "Could not initiate the db_model segment";
      250 		goto exit_rmdb_ready_db;
      251 	     end;
      252 
      253 
      254 /*
      255*   Get a pointer to the saved_res_version value. If there is no saved
      256*   resultant - create one
      257**/
      258 
      259 	call initiate_file_ (rtrim (mrds_path_info.absolute_path) || ">resultant_segs.dir",
      260 	     "rdbi", RW_ACCESS, saved_rdbi_ptr, bit_count, code);
      261 	if code = error_table_$no_dir
      262 	then do;					/* create the saved resultant */
      263 		call dsl_$create_res_copy (mrds_path_info.absolute_path, code);
      264 		if code ^= 0
      265 		then do;
      266 			error_message = "Could not create and save a copy of the resultant.";
      267 			goto exit_rmdb_ready_db;
      268 		     end;
      269 		call initiate_file_ (rtrim (mrds_path_info.absolute_path) || ">resultant_segs.dir",
      270 		     "rdbi", RW_ACCESS, saved_rdbi_ptr, bit_count, code);
      271 	     end;
      272 	if saved_rdbi_ptr = null ()
      273 	then do;
      274 		error_message = "Could not initiate the saved resultant segment rdbi.";
      275 		goto exit_rmdb_ready_db;
      276 	     end;
      277 	saved_res_version_ptr = addr (saved_rdbi_ptr -> rm_db_info.saved_res_version);
      278 
      279 /*
      280*   Quiesce  the  database.
      281**/
      282 
      283 	call mdbm_util_$quiesce_quiet ((mrds_path_info.absolute_path), quiesce_wait_time, code);
      284 	if code ^= 0 & code ^= mrds_error_$my_quiesced_db
      285 	then do;
      286 		error_message = "The data base could not be quiesced.";
      287 		goto exit_rmdb_ready_db;
      288 	     end;
      289 
      290 
      291 
      292 
      293 /*
      294*   Setup the relation_manager entries that correspond with the
      295*   type of database being opened.
      296**/
      297 
      298 	if local_db_model_ptr -> db_model.db_type_flags.vfile_type
      299 	then do;
      300 		rmdb_relmgr_entries.create_relation = vfile_relmgr_$create_MRDS_relation;
      301 		rmdb_relmgr_entries.delete_relation = vfile_relmgr_$destroy_relation_by_path;
      302 		rmdb_relmgr_entries.open = vfile_relmgr_$open;
      303 		rmdb_relmgr_entries.close = vfile_relmgr_$close;
      304 		rmdb_relmgr_entries.create_index = vfile_relmgr_$create_index;
      305 		rmdb_relmgr_entries.delete_index = vfile_relmgr_$destroy_index;
      306 		rmdb_relmgr_entries.put_tuple = vfile_relmgr_$put_tuple;
      307 		rmdb_relmgr_entries.create_cursor = vfile_relmgr_$create_cursor;
      308 		rmdb_relmgr_entries.get_tuple_id = vfile_relmgr_$get_tuple_id;
      309 		rmdb_relmgr_entries.get_tuple_by_id = vfile_relmgr_$get_tuple_by_id;
      310 	     end;
      311 	else do;					/* dm_file database */
      312 		rmdb_relmgr_entries.create_relation = relation_manager_$create_relation;
      313 		rmdb_relmgr_entries.delete_relation = relation_manager_$destroy_relation_by_path;
      314 		rmdb_relmgr_entries.open = relation_manager_$open;
      315 		rmdb_relmgr_entries.close = relation_manager_$close;
      316 		rmdb_relmgr_entries.create_index = relation_manager_$create_index;
      317 		rmdb_relmgr_entries.delete_index = relation_manager_$destroy_index;
      318 		rmdb_relmgr_entries.put_tuple = relation_manager_$put_tuple;
      319 		rmdb_relmgr_entries.create_cursor = relation_manager_$create_cursor;
      320 		rmdb_relmgr_entries.get_tuple_id = relation_manager_$get_tuple_id;
      321 		rmdb_relmgr_entries.get_tuple_by_id = relation_manager_$get_tuple_by_id;
      322 	     end;
      323 
      324 
      325 
      326 
      327 
      328 /*
      329*   Since  everything  worked  ok   we   can   set   the   value   of
      330*   absolute_db_path and the db_model_ptr.
      331**/
      332 
      333 
      334 	absolute_db_path = mrds_path_info.absolute_path;
      335 	db_model_ptr = local_db_model_ptr;
      336 
      337 
      338 
      339 
      340 exit_rmdb_ready_db:
      341 	return;
      342 
      343      end rmdb_ready_db;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1315.0  rmdb_ready_db.pl1                 >special_ldd>install>MR12.2-1073>rmdb_ready_db.pl1
149          1    10/14/83  1608.8  mrds_authorization.incl.pl1       >ldd>include>mrds_authorization.incl.pl1
151          2    10/14/83  1608.8  mrds_path_info.incl.pl1           >ldd>include>mrds_path_info.incl.pl1
153          3    10/17/86  1404.6  rmdb_relmgr_entries.incl.pl1      >ldd>include>rmdb_relmgr_entries.incl.pl1
155          4    10/17/86  1404.3  mdbm_db_model.incl.pl1            >ldd>include>mdbm_db_model.incl.pl1
157          5    08/01/88  1310.7  mdbm_rm_db_info.incl.pl1          >special_ldd>install>MR12.2-1073>mdbm_rm_db_info.incl.pl1
159          6    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
RW_ACCESS                       000000 constant        bit(3)                   initial packed unaligned dcl 6-11 set ref 246* 259*
                                                                                  269*
absolute_db_path                       parameter       char(168)                packed unaligned dcl 79 set ref 7 165* 334*
absolute_path             1            based           char(168)                level 2 dcl 2-22 set ref 219 223* 246 259 263* 269
                                                                                  283 334
addr                                                   builtin function         dcl 139 ref 191 191 219 219 277
administrator             1            based           bit(1)                   level 2 packed packed unaligned dcl 1-22 ref 228
area                            000100 automatic       area(500)                dcl 131 set ref 131* 191 191 219 219
bit_count                       001064 automatic       fixed bin(24,0)          dcl 132 set ref 246* 259* 269*
close                    14            based           entry variable           level 2 dcl 3-18 set ref 303* 315*
code                                   parameter       fixed bin(35,0)          dcl 84 set ref 7 167* 191* 193 201* 208* 219* 221
                                                                                  230* 246* 259* 261 263* 264 269* 283* 284 284
create_cursor            44            based           entry variable           level 2 dcl 3-18 set ref 307* 319*
create_index             20            based           entry variable           level 2 dcl 3-18 set ref 304* 316*
create_relation                        based           entry variable           level 2 dcl 3-18 set ref 300* 312*
data                                   based           structure                level 2 dcl 5-86
db_model                               based           structure                level 1 dcl 4-72
db_model_ptr                           parameter       pointer                  dcl 80 set ref 7 166* 335*
db_path                                parameter       char(168)                packed unaligned dcl 74 set ref 7 191* 195*
db_type_flags             0(18)        based           structure                level 2 packed packed unaligned dcl 4-72
delete_index             24            based           entry variable           level 2 dcl 3-18 set ref 305* 317*
delete_relation           4            based           entry variable           level 2 dcl 3-18 set ref 301* 313*
dsl_$create_res_copy            000076 constant        entry                    external dcl 126 ref 263
dsl_$get_path_info              000074 constant        entry                    external dcl 125 ref 191
empty                                                  builtin function         dcl 140 ref 131
entries_str_ptr                        parameter       pointer                  dcl 77 ref 7 176
error_message                          parameter       char(500)                packed unaligned dcl 83 set ref 7 168* 195* 195 195
                                                                                  202* 209* 223* 223 223 231* 249* 266* 274* 286*
error_table_$action_not_performed
                                000010 external static fixed bin(35,0)          dcl 88 ref 201 208 230
error_table_$no_dir             000012 external static fixed bin(35,0)          dcl 89 ref 261
get_tuple_by_id          40            based           entry variable           level 2 dcl 3-18 set ref 309* 321*
get_tuple_id             34            based           entry variable           level 2 dcl 3-18 set ref 308* 320*
initiate_file_                  000070 constant        entry                    external dcl 122 ref 246 259 269
ioa_$rs                         000066 constant        entry                    external dcl 121 ref 195 223
length                                                 builtin function         dcl 142 ref 195 195 223 223
local_db_model_ptr              001066 automatic       pointer                  dcl 133 set ref 245* 246* 247 298 335
mdbm_util_$get_user_class       000072 constant        entry                    external dcl 124 ref 219
mdbm_util_$quiesce_quiet        000100 constant        entry                    external dcl 127 ref 283
mrds_authorization                     based           structure                level 1 dcl 1-22
mrds_authorization_ptr          001072 automatic       pointer                  dcl 1-29 set ref 219* 228
mrds_authorization_structure_version
                                000017 constant        fixed bin(17,0)          initial dcl 1-31 set ref 219*
mrds_error_$my_quiesced_db      000014 external static fixed bin(35,0)          dcl 90 ref 284
mrds_path_info                         based           structure                level 1 dcl 2-22
mrds_path_info_ptr              001074 automatic       pointer                  dcl 2-36 set ref 191* 199 206 219 223 246 259 263
                                                                                  269 283 334
mrds_path_info_structure_version
                                000017 constant        fixed bin(17,0)          initial dcl 2-38 set ref 191*
mrds_version             54            based           fixed bin(17,0)          level 2 dcl 2-22 ref 206
null                                                   builtin function         dcl 143 ref 166 245 247 272
open                     10            based           entry variable           level 2 dcl 3-18 set ref 302* 314*
put_tuple                30            based           entry variable           level 2 dcl 3-18 set ref 306* 318*
quiesce_wait_time                      parameter       fixed bin(17,0)          dcl 75 set ref 7 283*
relation_manager_$close         000042 constant        entry                    external dcl 108 ref 315
relation_manager_$create_cursor 000060 constant        entry                    external dcl 117 ref 319
relation_manager_$create_index  000044 constant        entry                    external dcl 109 ref 316
relation_manager_$create_relation
                                000046 constant        entry                    external dcl 111 ref 312
relation_manager_$destroy_index 000050 constant        entry                    external dcl 113 ref 317
relation_manager_$destroy_relation_by_path
                                000052 constant        entry                    external dcl 114 ref 313
relation_manager_$get_tuple_by_id
                                000064 constant        entry                    external dcl 119 ref 321
relation_manager_$get_tuple_id  000062 constant        entry                    external dcl 118 ref 320
relation_manager_$open          000054 constant        entry                    external dcl 115 ref 314
relation_manager_$put_tuple     000056 constant        entry                    external dcl 116 ref 318
rm_db_info                             based           structure                level 1 dcl 5-86
rm_db_info_data                        based           structure                level 1 unaligned dcl 5-92
rmdb_relmgr_entries                    based           structure                level 1 unaligned dcl 3-18
rmdb_relmgr_entries_ptr         001076 automatic       pointer                  dcl 3-32 set ref 176* 300 301 302 303 304 305 306
                                                                                  307 308 309 312 313 314 315 316 317 318 319 320
                                                                                  321
rtrim                                                  builtin function         dcl 145 ref 259 269
saved_rdbi_ptr                  001070 automatic       pointer                  dcl 134 set ref 259* 269* 272 277
saved_res_version       127            based           char(8)                  level 3 dcl 5-86 set ref 277
saved_res_version_ptr                  parameter       pointer                  dcl 81 set ref 7 277*
submodel                 53(02)        based           bit(1)                   level 3 packed packed unaligned dcl 2-22 ref 199
type                     53            based           structure                level 2 dcl 2-22
vfile_relmgr_$close             000016 constant        entry                    external dcl 95 ref 303
vfile_relmgr_$create_MRDS_relation
                                000022 constant        entry                    external dcl 98 ref 300
vfile_relmgr_$create_cursor     000034 constant        entry                    external dcl 104 ref 307
vfile_relmgr_$create_index      000020 constant        entry                    external dcl 96 ref 304
vfile_relmgr_$destroy_index     000024 constant        entry                    external dcl 100 ref 305
vfile_relmgr_$destroy_relation_by_path
                                000026 constant        entry                    external dcl 101 ref 301
vfile_relmgr_$get_tuple_by_id   000040 constant        entry                    external dcl 106 ref 309
vfile_relmgr_$get_tuple_id      000036 constant        entry                    external dcl 105 ref 308
vfile_relmgr_$open              000030 constant        entry                    external dcl 102 ref 302
vfile_relmgr_$put_tuple         000032 constant        entry                    external dcl 103 ref 306
vfile_type                0(35)        based           bit(1)                   level 3 packed packed unaligned dcl 4-72 ref 298

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 6-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 6-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 6-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 6-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 6-36
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 6-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 6-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 6-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 6-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 6-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 6-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 6-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 6-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
alloc_length                           internal static fixed bin(35,0)          dcl 4-222
changer                                based           structure                level 1 packed packed unaligned dcl 4-251
changer_ptr                            automatic       pointer                  dcl 4-256
constant                               based           structure                level 1 unaligned dcl 4-216
constant_ptr                           automatic       pointer                  dcl 4-220
dbm_ptr                                automatic       pointer                  dcl 4-106
di_ptr                                 automatic       pointer                  dcl 4-155
domain_info                            based           structure                level 1 dcl 4-125
fi_ptr                                 automatic       pointer                  dcl 4-119
file_info                              based           structure                level 1 dcl 4-113
fixed                                                  builtin function         dcl 141
message_str                            based           structure                level 1 packed packed unaligned dcl 4-259
message_str_len                        automatic       fixed bin(17,0)          dcl 4-269
message_str_ptr                        automatic       pointer                  dcl 4-267
path_entry                             based           structure                level 1 packed packed unaligned dcl 4-172
path_entry_ptr                         automatic       pointer                  dcl 4-177
rdbi_ptr                               automatic       pointer                  dcl 5-90
rel                                                    builtin function         dcl 144
stack_item                             based           structure                level 1 unaligned dcl 4-206
stack_item_ptr                         automatic       pointer                  dcl 4-212
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 91
ua_ptr                                 automatic       pointer                  dcl 4-165
unreferenced_attribute                 based           structure                level 1 dcl 4-159
version_status                         based           structure                level 1 packed packed unaligned dcl 4-232
version_status_ptr                     automatic       pointer                  dcl 4-246

NAMES DECLARED BY EXPLICIT CONTEXT.
exit_rmdb_ready_db              001143 constant        label                    dcl 340 ref 196 203 210 225 232 250 267 275 287
rmdb_ready_db                   000210 constant        entry                    external dcl 7

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1466        1570    1146        1476
Length      2140    1146       102         334     320           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rmdb_ready_db                       689 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rmdb_ready_db            000100 area                        rmdb_ready_db
                         001064 bit_count                   rmdb_ready_db
                         001066 local_db_model_ptr          rmdb_ready_db
                         001070 saved_rdbi_ptr              rmdb_ready_db
                         001072 mrds_authorization_ptr      rmdb_ready_db
                         001074 mrds_path_info_ptr          rmdb_ready_db
                         001076 rmdb_relmgr_entries_ptr     rmdb_ready_db

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          shorten_stack       ext_entry
op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
dsl_$create_res_copy          dsl_$get_path_info            initiate_file_                ioa_$rs
mdbm_util_$get_user_class     mdbm_util_$quiesce_quiet      relation_manager_$close
relation_manager_$create_cursor                             relation_manager_$create_index
relation_manager_$create_relation                           relation_manager_$destroy_index
relation_manager_$destroy_relation_by_path                  relation_manager_$get_tuple_by_id
relation_manager_$get_tuple_id                              relation_manager_$open        relation_manager_$put_tuple
vfile_relmgr_$close           vfile_relmgr_$create_MRDS_relation                          vfile_relmgr_$create_cursor
vfile_relmgr_$create_index    vfile_relmgr_$destroy_index   vfile_relmgr_$destroy_relation_by_path
vfile_relmgr_$get_tuple_by_id vfile_relmgr_$get_tuple_id    vfile_relmgr_$open            vfile_relmgr_$put_tuple

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$no_dir           mrds_error_$my_quiesced_db




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      7 000201       131 000215       165 000220       166 000225       167 000227       168 000230       176 000234
    191 000237       193 000271       195 000274       196 000326       199 000327       201 000333       202 000336
    203 000342       206 000343       208 000346       209 000351       210 000355       219 000356       221 000413
    223 000416       225 000451       228 000452       230 000456       231 000461       232 000465       245 000466
    246 000470       247 000533       249 000537       250 000544       259 000545       261 000634       263 000642
    264 000657       266 000662       267 000666       269 000667       271 000755       272 000756       274 000762
    275 000767       277 000770       283 000774       284 001013       286 001021       287 001025       298 001026
    300 001031       301 001037       302 001042       303 001045       304 001050       305 001053       306 001056
    307 001061       308 001064       309 001067       310 001072       312 001073       313 001101       314 001104
    315 001107       316 001112       317 001115       318 001120       319 001123       320 001126       321 001131
    334 001134       335 001141       340 001143


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
