	COMPILATION LISTING OF SEGMENT l6_ftf
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/18/82  1644.2 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* format: style3,linecom,ifthenstmt,indthenelse,^indnoniterdo,indend,initlm3,dclind5,idind32 */
       12 l6_ftf:
       13      proc ();
       14 
       15 /*
       16*
       17*   D_E_S_C_R_I_P_T_I_O_N_
       18*
       19*   This command sets up a file transfer server on the specified channel
       20*   that talks Level 6 FTF protocol.  It continues listening to the channel until
       21*   the user types "q" or "quit".
       22*
       23*
       24*   J_O_U_R_N_A_L_I_Z_A_T_I_O_N_
       25*
       26*   1) Written 6/79 by R.J.C. Kissel.
       27**/
       28 
       29 dcl  cu_$af_arg_count	       entry (fixed bin, fixed bin (35));
       30 dcl  nargs		       fixed bin;
       31 dcl  code			       fixed bin (35);
       32 dcl  com_err_		       entry options (variable);
       33 dcl  com_name		       char (6) internal static options (constant) init ("l6_ftf");
       34 dcl  error_table_$wrong_no_of_args   fixed bin (35) external;
       35 dcl  cu_$arg_ptr		       entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
       36 dcl  argp			       ptr;
       37 dcl  argl			       fixed bin (21);
       38 dcl  arg			       char (argl) based (argp);
       39 dcl  channel_name		       char (32);
       40 dcl  error_table_$bigarg	       fixed bin (35) external;
       41 dcl  length		       builtin;
       42 dcl  dial_manager_$privileged_attach entry (ptr, fixed bin (35));
       43 dcl  1 dial_manager_arg	       aligned,
       44        2 version		       fixed bin,
       45        2 dial_qualifier	       char (22),
       46        2 dial_channel	       fixed bin (71),
       47        2 channel_name	       char (32);
       48 dcl  ipc_$create_ev_chn	       entry (fixed bin (71), fixed bin (35));
       49 dcl  dial_event_chn		       fixed bin (71);
       50 dcl  convert_ipc_code_	       entry (fixed bin (35));
       51 dcl  iox_$attach_name	       entry (char (*), ptr, char (*), ptr, fixed bin (35));
       52 dcl  l6_switch_ptr		       ptr;
       53 dcl  null			       builtin;
       54 dcl  error_table_$not_detached       fixed bin (35) external;
       55 dcl  iox_$open		       entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
       56 dcl  error_table_$not_closed	       fixed bin (35) external;
       57 dcl  iox_$user_input	       ptr external;
       58 dcl  user_input_ptr		       ptr;
       59 dcl  iox_$control		       entry (ptr, char (*), ptr, fixed bin (35));
       60 dcl  1 read_status_info	       aligned,
       61        2 event_chn		       fixed bin (71),
       62        2 input_available	       bit (1);
       63 dcl  get_temp_segment_	       entry (char (*), ptr, fixed bin (35));
       64 dcl  release_temp_segment_	       entry (char (*), ptr, fixed bin (35));
       65 dcl  iobp			       ptr;
       66 dcl  io_buf		       char (sys_info$max_seg_size * 4) based aligned;
       67 dcl  sys_info$max_seg_size	       fixed bin (19) external;
       68 dcl  user_event_chn		       fixed bin (71);
       69 dcl  l6_event_chn		       fixed bin (71);
       70 dcl  l6_input_rdy		       bit (1);
       71 dcl  1 wait_list		       aligned,
       72        2 nchan		       fixed bin,
       73        2 pad		       fixed bin,
       74        2 channel_id		       (3) fixed bin (71);
       75 dcl  1 event_info		       aligned,
       76        2 channel_id		       fixed bin (71),
       77        2 message		       fixed bin (71),
       78        2 sender		       bit (36),
       79        2 origin,
       80          3 dev_signal	       bit (18) unaligned,
       81          3 ring		       bit (18) unaligned,
       82        2 channel_idx	       fixed bin;
       83 dcl  ipc_$block		       entry (ptr, ptr, fixed bin (35));
       84 dcl  ioa_			       entry options (variable);
       85 dcl  iox_$get_line		       entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
       86 dcl  cleanup		       condition;
       87 dcl  l6_ftf_switch		       char (13) internal static options (constant) init ("l6_ftf_switch");
       88 dcl  user_output_ptr	       ptr;
       89 dcl  error_output_ptr	       ptr;
       90 dcl  iox_$user_output	       ptr external;
       91 dcl  iox_$error_output	       ptr external;
       92 dcl  dialed		       bit (1);
       93 dcl  l6_attached		       bit (1);
       94 dcl  l6_open		       bit (1);
       95 dcl  iobl			       fixed bin (21);
       96 dcl  error_table_$not_act_fnc	       fixed bin (35) external;
       97 dcl  arg_idx		       fixed bin;
       98 dcl  long_flag		       bit (1);
       99 dcl  error_flag		       bit (1);
      100 dcl  iox_$modes		       entry (ptr, char (*), char (*), fixed bin (35));
      101 dcl  user_input_rdy		       bit (1);
      102 dcl  user_done		       bit (1);
      103 dcl  error_table_$badopt	       fixed bin (35) external;
      104 dcl  iox_$close		       entry (ptr, fixed bin (35));
      105 dcl  iox_$detach_iocb	       entry (ptr, fixed bin (35));
      106 dcl  dial_manager_$release_channel   entry (ptr, fixed bin (35));
      107 dcl  ipc_$delete_ev_chn	       entry (fixed bin (71), fixed bin (35));
      108 dcl  l6_ftf_		       entry (ptr, ptr, fixed bin (21), ptr, bit (1), ptr, bit (1), char (168), fixed bin (35));
      109 dcl  addr			       builtin;
      110 dcl  substr		       builtin;
      111 dcl  error_table_$noarg	       fixed bin (35) external;
      112 dcl  target_dir		       char (168);
      113 dcl  get_wdir_		       entry () returns (char (168));
      114 
      115 /*
      116*   Initialize everything for cleanup.
      117**/
      118 
      119 	user_input_ptr = iox_$user_input;
      120 	user_output_ptr = iox_$user_output;
      121 	error_output_ptr = iox_$error_output;
      122 
      123 	dial_channel = 0;
      124 	dialed = "0"b;
      125 
      126 	l6_attached = "0"b;
      127 	l6_open = "0"b;
      128 
      129 	iobp = null ();
      130 	iobl = 0;
      131 
      132 	long_flag = "0"b;
      133 	target_dir = get_wdir_ ();
      134 	channel_name = "";
      135 
      136 	on cleanup call Cleanup_Handler ();
      137 
      138 /*
      139*   Processs the command arguments.
      140**/
      141 
      142 	call cu_$af_arg_count (nargs, code);
      143 	if code ^= error_table_$not_act_fnc then goto ERROR_actfncall;
      144 
      145 	if nargs > 4 | nargs < 1 then goto ERROR_wrongargs;
      146 
      147 	do arg_idx = 1 to nargs by 1;
      148 
      149 	     call cu_$arg_ptr (arg_idx, argp, argl, code);
      150 	     if code ^= 0 then goto ERROR_arg;
      151 
      152 	     if substr (arg, 1, 1) = "-"
      153 		then do;				/* Process a control argument. */
      154 		     if arg = "-long" | arg = "-lg" then long_flag = "1"b;
      155 
      156 		     else if arg = "-target_dir" | arg = "-td"
      157 			then do;
      158 			     arg_idx = arg_idx + 1;
      159 			     if arg_idx > nargs then goto ERROR_missarg;
      160 
      161 			     call cu_$arg_ptr (arg_idx, argp, argl, code);
      162 			     if code ^= 0 then goto ERROR_arg;
      163 
      164 			     target_dir = arg;
      165 
      166 			     if target_dir = ">" then target_dir = "";
      167 						/* Special case the root. */
      168 			     end;
      169 
      170 		     else goto ERROR_controlarg;
      171 		     end;
      172 
      173 		else do;				/* Process the channel name. */
      174 		     if argl > length (channel_name) then goto ERROR_longchn;
      175 
      176 		     channel_name = arg;
      177 		     end;
      178 	end;
      179 
      180 	if channel_name = "" then goto ERROR_wrongargs;	/* This _m_u_s_t be specified. */
      181 
      182 
      183 
      184 /*
      185*   Now create an event channel for dial_manager_ to use and make
      186*   the call to get the specified channel attached.  At this point we will
      187*   get the user input event channel and an IO buffer and then block waiting for either a
      188*   dialup wakeup or some input from the user.
      189**/
      190 
      191 	call ipc_$create_ev_chn (dial_event_chn, code);
      192 	if code ^= 0 then goto ERROR_createchn;
      193 
      194 	dial_manager_arg.version = 1;
      195 	dial_manager_arg.dial_qualifier = "";
      196 	dial_manager_arg.dial_channel = dial_event_chn;
      197 	dial_manager_arg.channel_name = channel_name;
      198 
      199 	call dial_manager_$privileged_attach (addr (dial_manager_arg), code);
      200 	if code ^= 0
      201 	     then dialed = "1"b;			/* Assume it is already dialed. */
      202 	     else dialed = "0"b;
      203 
      204 	call iox_$control (user_input_ptr, "read_status", addr (read_status_info), code);
      205 	if code ^= 0 then goto ERROR_userstatus;
      206 
      207 	user_event_chn = read_status_info.event_chn;
      208 	user_input_rdy = read_status_info.input_available;
      209 
      210 	wait_list.nchan = 2;
      211 	wait_list.pad = 0;
      212 	wait_list.channel_id (1) = user_event_chn;
      213 	wait_list.channel_id (2) = dial_event_chn;
      214 
      215 	event_info.channel_id = 0;			/* Initialize this for the first time through the loop. */
      216 
      217 	call get_temp_segment_ (com_name, iobp, code);
      218 	if code ^= 0 then goto ERROR_getseg;
      219 
      220 	do while (^dialed);
      221 	     if user_input_rdy
      222 		then do;
      223 		     call Process_User_Input (user_done);
      224 		     if user_done then goto DONE;
      225 
      226 		     call iox_$control (user_input_ptr, "read_status", addr (read_status_info), code);
      227 		     if code ^= 0 then goto ERROR_userstatus;
      228 
      229 		     user_input_rdy = read_status_info.input_available;
      230 		     end;
      231 
      232 	     else if event_info.channel_id = dial_event_chn then dialed = "1"b;
      233 
      234 	     else do;
      235 		call ipc_$block (addr (wait_list), addr (event_info), code);
      236 		if code ^= 0 then goto ERROR_block;
      237 
      238 		if user_event_chn = event_info.channel_id
      239 		     then do;
      240 			call iox_$control (user_input_ptr, "read_status", addr (read_status_info), code);
      241 			if code ^= 0 then goto ERROR_userstatus;
      242 
      243 			user_input_rdy = read_status_info.input_available;
      244 			end;
      245 		end;
      246 	end;
      247 
      248 /*
      249*   Attach, open, and set the modes for the Level 6 channel, and
      250*   get a temp segment to use as an IO buffer.
      251**/
      252 
      253 	call iox_$attach_name (l6_ftf_switch, l6_switch_ptr, "tty_ " || channel_name, null (), code);
      254 	if code ^= 0 & code ^= error_table_$not_detached then goto ERROR_l6attach;
      255 
      256 	l6_attached = "1"b;				/* Set this for use by cleanup. */
      257 
      258 	call iox_$open (l6_switch_ptr, 3, "0"b, code);	/* For stream_input_output. */
      259 	if code ^= 0 & code ^= error_table_$not_closed then goto ERROR_l6open;
      260 
      261 	l6_open = "1"b;				/* Set this for use by cleanup. */
      262 
      263 	call iox_$modes (l6_switch_ptr, "rawi,rawo", "", code);
      264 	if code ^= 0 then goto ERROR_modes;
      265 
      266 /*
      267*   Read status on both the L6 and user switches in order to
      268*   initialize the variables to be used in the transfer loop.
      269**/
      270 
      271 	call iox_$control (user_input_ptr, "read_status", addr (read_status_info), code);
      272 	if code ^= 0 then goto ERROR_userstatus;
      273 
      274 	user_input_rdy = read_status_info.input_available;
      275 
      276 	call iox_$control (l6_switch_ptr, "read_status", addr (read_status_info), code);
      277 	if code ^= 0 then goto ERROR_l6status;
      278 
      279 	l6_event_chn = read_status_info.event_chn;
      280 	l6_input_rdy = read_status_info.input_available;
      281 
      282 	wait_list.nchan = 3;
      283 	wait_list.pad = 0;
      284 	wait_list.channel_id (1) = user_event_chn;
      285 	wait_list.channel_id (2) = l6_event_chn;
      286 	wait_list.channel_id (3) = dial_event_chn;
      287 
      288 	error_flag = "1"b;				/* Allow l6_ftf_ to print on error_output. */
      289 
      290 /*
      291*   This loop runs until the user types quit or q on his terminal.
      292**/
      293 
      294 	do while ("1"b);				/* Exit when user says he is done. */
      295 
      296 /*
      297*   This loop checks the input ready flags for both the L6 switch
      298*   and the user switch and processes any input it finds.  It continues
      299*   until no input is available on either switch at which point we block
      300*   on both switches, waiting for input.
      301**/
      302 
      303 	     do while (l6_input_rdy | user_input_rdy);
      304 
      305 		if l6_input_rdy
      306 		     then do;
      307 			call l6_ftf_ (l6_switch_ptr, iobp, length (iobp -> io_buf), user_output_ptr, long_flag,
      308 			     error_output_ptr, error_flag, target_dir, code);
      309 						/* Any messages have already been printed. */
      310 			if code ^= 0 then call iox_$control (l6_switch_ptr, "abort", null (), code);
      311 			if code ^= 0
      312 			     then call com_err_ (code, com_name, "Failed to abort L6 channel, continuing processing.");
      313 
      314 			call iox_$control (l6_switch_ptr, "read_status", addr (read_status_info), code);
      315 			if code ^= 0 then goto ERROR_l6status;
      316 
      317 			l6_input_rdy = read_status_info.input_available;
      318 			end;
      319 
      320 		if user_input_rdy
      321 		     then do;
      322 			call Process_User_Input (user_done);
      323 			if user_done then goto DONE;	/* Exit the outermost do loop. */
      324 
      325 			call iox_$control (user_input_ptr, "read_status", addr (read_status_info), code);
      326 			if code ^= 0 then goto ERROR_userstatus;
      327 
      328 			user_input_rdy = read_status_info.input_available;
      329 			end;
      330 	     end;
      331 
      332 /*
      333*   Block here.  When we wake up, verify that the switch which
      334*   caused the wakeup actually has input available and then reenter the
      335*   input processing loop.
      336**/
      337 
      338 	     call ipc_$block (addr (wait_list), addr (event_info), code);
      339 	     if code ^= 0 then goto ERROR_block;
      340 
      341 	     if l6_event_chn = event_info.channel_id
      342 		then do;
      343 		     call iox_$control (l6_switch_ptr, "read_status", addr (read_status_info), code);
      344 		     if code ^= 0 then goto ERROR_l6status;
      345 
      346 		     l6_input_rdy = read_status_info.input_available;
      347 		     end;
      348 
      349 	     else if user_event_chn = event_info.channel_id
      350 		then do;
      351 		     call iox_$control (user_input_ptr, "read_status", addr (read_status_info), code);
      352 		     if code ^= 0 then goto ERROR_userstatus;
      353 
      354 		     user_input_rdy = read_status_info.input_available;
      355 		     end;
      356 
      357 	     else if dial_event_chn = event_info.channel_id then goto ERROR_hangup;
      358 
      359 	     else goto ERROR_fatal;			/* Not an event channel we know about. */
      360 	end;
      361 
      362 DONE:
      363 	call Cleanup_Handler ();
      364 	return;
      365 
      366 ERROR_actfncall:
      367 	if code = 0
      368 	     then call com_err_ (0, com_name, "May not be called as an active function.");
      369 	     else call com_err_ (code, com_name);
      370 	goto DONE;
      371 
      372 ERROR_wrongargs:
      373 	call com_err_ (error_table_$wrong_no_of_args, com_name,
      374 	     "Usage: ^a channel_name {-long, -lg } {-target_dir path, -td path}", com_name);
      375 	goto DONE;
      376 
      377 ERROR_arg:
      378 	call com_err_ (code, com_name, "Accessing argument ^d.", arg_idx);
      379 	goto DONE;
      380 
      381 ERROR_controlarg:
      382 	call com_err_ (error_table_$badopt, com_name, "^a", arg);
      383 	goto DONE;
      384 
      385 ERROR_longchn:
      386 	call com_err_ (error_table_$bigarg, com_name, "^a", arg);
      387 	goto DONE;
      388 
      389 ERROR_createchn:
      390 	call convert_ipc_code_ (code);
      391 	call com_err_ (code, com_name, "Creating event channel for dial_manager_ to use.");
      392 	goto DONE;
      393 
      394 ERROR_l6attach:
      395 	call com_err_ (code, com_name, "Attaching ^a to tty_ through ^a.", channel_name, l6_ftf_switch);
      396 	goto DONE;
      397 
      398 ERROR_l6open:
      399 	call com_err_ (code, com_name, "Opening ^a.", l6_ftf_switch);
      400 	goto DONE;
      401 
      402 ERROR_modes:
      403 	call com_err_ (code, com_name, "Setting rawi and rawo on ^a.", l6_ftf_switch);
      404 	goto DONE;
      405 
      406 ERROR_getseg:
      407 	call com_err_ (code, com_name, "Getting IO buffer segment.");
      408 	goto DONE;
      409 
      410 ERROR_userstatus:
      411 	call com_err_ (code, com_name, "Reading status of user input.");
      412 	goto DONE;
      413 
      414 ERROR_l6status:
      415 	call com_err_ (code, com_name, "Reading status of ^a.", l6_ftf_switch);
      416 	goto DONE;
      417 
      418 ERROR_block:
      419 	call convert_ipc_code_ (code);
      420 	call com_err_ (code, com_name, "Waiting for input.");
      421 	goto DONE;
      422 
      423 ERROR_fatal:
      424 	call com_err_ (0, com_name, "Wakeup on unknown event channel ^o, from process ^.3b", event_info.channel_id,
      425 	     event_info.sender);
      426 	goto DONE;
      427 
      428 ERROR_missarg:
      429 	call com_err_ (error_table_$noarg, com_name, "For the ^a control argument.", arg);
      430 	goto DONE;
      431 
      432 ERROR_hangup:
      433 	call com_err_ (0, com_name, "Hangup signalled on ^a.", l6_ftf_switch);
      434 	goto DONE;
      435 
      436 Process_User_Input:
      437      proc (finished);
      438 
      439 dcl  finished		       bit (1);
      440 dcl  n_read		       fixed bin (21);
      441 
      442 	call iox_$get_line (user_input_ptr, iobp, length (iobp -> io_buf), n_read, code);
      443 
      444 	if n_read <= 1
      445 	     then do;
      446 		call ioa_ ("You may type quit or q to exit this invocation of ^a.", com_name);
      447 		finished = "0"b;
      448 		end;
      449 
      450 	else if substr (iobp -> io_buf, 1, n_read - 1) = "quit" | substr (iobp -> io_buf, 1, n_read - 1) = "q"
      451 	     then finished = "1"b;
      452 
      453 	else do;
      454 	     call ioa_ ("You may type quit or q to exit this invocation of ^a.", com_name);
      455 	     finished = "0"b;
      456 	     end;
      457      end Process_User_Input;
      458 
      459 Cleanup_Handler:
      460      proc ();
      461 
      462 /*
      463*   Notice that these if statements must be kept in their current order.
      464**/
      465 
      466 	if l6_open then call iox_$close (l6_switch_ptr, code);
      467 
      468 	if l6_attached then call iox_$detach_iocb (l6_switch_ptr, code);
      469 
      470 	if dialed then call dial_manager_$release_channel (addr (dial_manager_arg), code);
      471 
      472 	if dial_event_chn ^= 0 then call ipc_$delete_ev_chn (dial_channel, code);
      473 
      474 	if iobp ^= null () then call release_temp_segment_ (com_name, iobp, code);
      475 
      476      end Cleanup_Handler;
      477      end l6_ftf;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/18/82  1628.4  l6_ftf.pl1                        >dumps>old>recomp>l6_ftf.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 109 ref 199 199 204 204 226 226 235 235 235 235
                                                                                  240 240 271 271 276 276 314 314 325 325 338 338
                                                                                  338 338 343 343 351 351 470 470
arg                                    based           char                     unaligned dcl 38 set ref 152 154 154 156 156 164 176
                                                                                  381* 385* 428*
arg_idx                         000220 automatic       fixed bin(17,0)          dcl 97 set ref 147* 149* 158* 158 159 161* 377*
argl                            000104 automatic       fixed bin(21,0)          dcl 37 set ref 149* 152 154 154 156 156 161* 164 174
                                                                                  176 381 381 385 385 428 428
argp                            000102 automatic       pointer                  dcl 36 set ref 149* 152 154 154 156 156 161* 164 176
                                                                                  381 385 428
channel_id                2     000162 automatic       fixed bin(71,0)          array level 2 in structure "wait_list" dcl 71
                                                                                  in procedure "l6_ftf" set ref 212* 213* 284* 285*
                                                                                  286*
channel_id                      000172 automatic       fixed bin(71,0)          level 2 in structure "event_info" dcl 75
                                                                                  in procedure "l6_ftf" set ref 215* 232 238 341 349
                                                                                  357 423*
channel_name                    000105 automatic       char(32)                 unaligned dcl 39 in procedure "l6_ftf" set ref 134*
                                                                                  174 176* 180 197 253 394*
channel_name             12     000116 automatic       char(32)                 level 2 in structure "dial_manager_arg" dcl 43
                                                                                  in procedure "l6_ftf" set ref 197*
cleanup                         000202 stack reference condition                dcl 86 ref 136
code                            000101 automatic       fixed bin(35,0)          dcl 31 set ref 142* 143 149* 150 161* 162 191* 192
                                                                                  199* 200 204* 205 217* 218 226* 227 235* 236 240*
                                                                                  241 253* 254 254 258* 259 259 263* 264 271* 272
                                                                                  276* 277 307* 310 310* 311 311* 314* 315 325* 326
                                                                                  338* 339 343* 344 351* 352 366 369* 377* 389* 391*
                                                                                  394* 398* 402* 406* 410* 414* 418* 420* 442* 466*
                                                                                  468* 470* 472* 474*
com_err_                        000012 constant        entry                    external dcl 32 ref 311 366 369 372 377 381 385 391
                                                                                  394 398 402 406 410 414 420 423 428 432
com_name                        000004 constant        char(6)                  initial unaligned dcl 33 set ref 217* 311* 366* 369*
                                                                                  372* 372* 377* 381* 385* 391* 394* 398* 402* 406*
                                                                                  410* 414* 420* 423* 428* 432* 446* 454* 474*
convert_ipc_code_               000026 constant        entry                    external dcl 50 ref 389 418
cu_$af_arg_count                000010 constant        entry                    external dcl 29 ref 142
cu_$arg_ptr                     000016 constant        entry                    external dcl 35 ref 149 161
dial_channel             10     000116 automatic       fixed bin(71,0)          level 2 dcl 43 set ref 123* 196* 472*
dial_event_chn                  000140 automatic       fixed bin(71,0)          dcl 49 set ref 191* 196 213 232 286 357 472
dial_manager_$privileged_attach 000022 constant        entry                    external dcl 42 ref 199
dial_manager_$release_channel   000076 constant        entry                    external dcl 106 ref 470
dial_manager_arg                000116 automatic       structure                level 1 dcl 43 set ref 199 199 470 470
dial_qualifier            1     000116 automatic       char(22)                 level 2 dcl 43 set ref 195*
dialed                          000214 automatic       bit(1)                   unaligned dcl 92 set ref 124* 200* 202* 220 232* 470
error_flag                      000222 automatic       bit(1)                   unaligned dcl 99 set ref 288* 307*
error_output_ptr                000212 automatic       pointer                  dcl 89 set ref 121* 307*
error_table_$badopt             000070 external static fixed bin(35,0)          dcl 103 set ref 381*
error_table_$bigarg             000020 external static fixed bin(35,0)          dcl 40 set ref 385*
error_table_$noarg              000104 external static fixed bin(35,0)          dcl 111 set ref 428*
error_table_$not_act_fnc        000064 external static fixed bin(35,0)          dcl 96 ref 143
error_table_$not_closed         000036 external static fixed bin(35,0)          dcl 56 ref 259
error_table_$not_detached       000032 external static fixed bin(35,0)          dcl 54 ref 254
error_table_$wrong_no_of_args   000014 external static fixed bin(35,0)          dcl 34 set ref 372*
event_chn                       000146 automatic       fixed bin(71,0)          level 2 dcl 60 set ref 207 279
event_info                      000172 automatic       structure                level 1 dcl 75 set ref 235 235 338 338
finished                               parameter       bit(1)                   unaligned dcl 439 set ref 436 447* 450* 455*
get_temp_segment_               000044 constant        entry                    external dcl 63 ref 217
get_wdir_                       000106 constant        entry                    external dcl 113 ref 133
input_available           2     000146 automatic       bit(1)                   level 2 dcl 60 set ref 208 229 243 274 280 317 328
                                                                                  346 354
io_buf                                 based           char                     dcl 66 ref 307 307 442 442 450 450
ioa_                            000054 constant        entry                    external dcl 84 ref 446 454
iobl                            000217 automatic       fixed bin(21,0)          dcl 95 set ref 130*
iobp                            000152 automatic       pointer                  dcl 65 set ref 129* 217* 307* 307 307 442* 442 442
                                                                                  450 450 474 474*
iox_$attach_name                000030 constant        entry                    external dcl 51 ref 253
iox_$close                      000072 constant        entry                    external dcl 104 ref 466
iox_$control                    000042 constant        entry                    external dcl 59 ref 204 226 240 271 276 310 314 325
                                                                                  343 351
iox_$detach_iocb                000074 constant        entry                    external dcl 105 ref 468
iox_$error_output               000062 external static pointer                  dcl 91 ref 121
iox_$get_line                   000056 constant        entry                    external dcl 85 ref 442
iox_$modes                      000066 constant        entry                    external dcl 100 ref 263
iox_$open                       000034 constant        entry                    external dcl 55 ref 258
iox_$user_input                 000040 external static pointer                  dcl 57 ref 119
iox_$user_output                000060 external static pointer                  dcl 90 ref 120
ipc_$block                      000052 constant        entry                    external dcl 83 ref 235 338
ipc_$create_ev_chn              000024 constant        entry                    external dcl 48 ref 191
ipc_$delete_ev_chn              000100 constant        entry                    external dcl 107 ref 472
l6_attached                     000215 automatic       bit(1)                   unaligned dcl 93 set ref 126* 256* 468
l6_event_chn                    000156 automatic       fixed bin(71,0)          dcl 69 set ref 279* 285 341
l6_ftf_                         000102 constant        entry                    external dcl 108 ref 307
l6_ftf_switch                   000000 constant        char(13)                 initial unaligned dcl 87 set ref 253* 394* 398* 402*
                                                                                  414* 432*
l6_input_rdy                    000160 automatic       bit(1)                   unaligned dcl 70 set ref 280* 303 305 317* 346*
l6_open                         000216 automatic       bit(1)                   unaligned dcl 94 set ref 127* 261* 466
l6_switch_ptr                   000142 automatic       pointer                  dcl 52 set ref 253* 258* 263* 276* 307* 310* 314*
                                                                                  343* 466* 468*
length                                                 builtin function         dcl 41 ref 174 307 307 442 442
long_flag                       000221 automatic       bit(1)                   unaligned dcl 98 set ref 132* 154* 307*
n_read                          000306 automatic       fixed bin(21,0)          dcl 440 set ref 442* 444 450 450
nargs                           000100 automatic       fixed bin(17,0)          dcl 30 set ref 142* 145 145 147 159
nchan                           000162 automatic       fixed bin(17,0)          level 2 dcl 71 set ref 210* 282*
null                                                   builtin function         dcl 53 ref 129 253 253 310 310 474
pad                       1     000162 automatic       fixed bin(17,0)          level 2 dcl 71 set ref 211* 283*
read_status_info                000146 automatic       structure                level 1 dcl 60 set ref 204 204 226 226 240 240 271
                                                                                  271 276 276 314 314 325 325 343 343 351 351
release_temp_segment_           000046 constant        entry                    external dcl 64 ref 474
sender                    4     000172 automatic       bit(36)                  level 2 dcl 75 set ref 423*
substr                                                 builtin function         dcl 110 ref 152 450 450
sys_info$max_seg_size           000050 external static fixed bin(19,0)          dcl 67 ref 307 307 442 442 450 450
target_dir                      000225 automatic       char(168)                unaligned dcl 112 set ref 133* 164* 166 166* 307*
user_done                       000224 automatic       bit(1)                   unaligned dcl 102 set ref 223* 224 322* 323
user_event_chn                  000154 automatic       fixed bin(71,0)          dcl 68 set ref 207* 212 238 284 349
user_input_ptr                  000144 automatic       pointer                  dcl 58 set ref 119* 204* 226* 240* 271* 325* 351*
                                                                                  442*
user_input_rdy                  000223 automatic       bit(1)                   unaligned dcl 101 set ref 208* 221 229* 243* 274*
                                                                                  303 320 328* 354*
user_output_ptr                 000210 automatic       pointer                  dcl 88 set ref 120* 307*
version                         000116 automatic       fixed bin(17,0)          level 2 dcl 43 set ref 194*
wait_list                       000162 automatic       structure                level 1 dcl 71 set ref 235 235 338 338

NAMES DECLARED BY EXPLICIT CONTEXT.
Cleanup_Handler                 002704 constant        entry                    internal dcl 459 ref 136 362
DONE                            001700 constant        label                    dcl 362 set ref 224 323 370 375 379 383 387 392 396
                                                                                  400 404 408 412 416 421 426 430 434
ERROR_actfncall                 001705 constant        label                    dcl 366 ref 143
ERROR_arg                       002001 constant        label                    dcl 377 ref 150 162
ERROR_block                     002374 constant        label                    dcl 418 set ref 236 339
ERROR_controlarg                002032 constant        label                    dcl 381 ref 156
ERROR_createchn                 002117 constant        label                    dcl 389 ref 192
ERROR_fatal                     002433 constant        label                    dcl 423 ref 359
ERROR_getseg                    002271 constant        label                    dcl 406 ref 218
ERROR_hangup                    002525 constant        label                    dcl 432 ref 357
ERROR_l6attach                  002153 constant        label                    dcl 394 ref 254
ERROR_l6open                    002207 constant        label                    dcl 398 ref 259
ERROR_l6status                  002343 constant        label                    dcl 414 set ref 277 315 344
ERROR_longchn                   002065 constant        label                    dcl 385 set ref 174
ERROR_missarg                   002471 constant        label                    dcl 428 ref 159
ERROR_modes                     002240 constant        label                    dcl 402 ref 264
ERROR_userstatus                002316 constant        label                    dcl 410 ref 205 227 241 272 326 352
ERROR_wrongargs                 001751 constant        label                    dcl 372 ref 145 180
Process_User_Input              002557 constant        entry                    internal dcl 436 ref 223 322
l6_ftf                          000315 constant        entry                    external dcl 12

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3420        3530    3031        3430
Length      3772    3031       110         225     367           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
l6_ftf                              292 external procedure  is an external procedure.  
on unit on line 136                  64 on unit               
Process_User_Input                      internal procedure  shares stack frame of external procedure l6_ftf.  
Cleanup_Handler                      86 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
l6_ftf                   000100 nargs                       l6_ftf
                         000101 code                        l6_ftf
                         000102 argp                        l6_ftf
                         000104 argl                        l6_ftf
                         000105 channel_name                l6_ftf
                         000116 dial_manager_arg            l6_ftf
                         000140 dial_event_chn              l6_ftf
                         000142 l6_switch_ptr               l6_ftf
                         000144 user_input_ptr              l6_ftf
                         000146 read_status_info            l6_ftf
                         000152 iobp                        l6_ftf
                         000154 user_event_chn              l6_ftf
                         000156 l6_event_chn                l6_ftf
                         000160 l6_input_rdy                l6_ftf
                         000162 wait_list                   l6_ftf
                         000172 event_info                  l6_ftf
                         000210 user_output_ptr             l6_ftf
                         000212 error_output_ptr            l6_ftf
                         000214 dialed                      l6_ftf
                         000215 l6_attached                 l6_ftf
                         000216 l6_open                     l6_ftf
                         000217 iobl                        l6_ftf
                         000220 arg_idx                     l6_ftf
                         000221 long_flag                   l6_ftf
                         000222 error_flag                  l6_ftf
                         000223 user_input_rdy              l6_ftf
                         000224 user_done                   l6_ftf
                         000225 target_dir                  l6_ftf
                         000306 n_read                      Process_User_Input

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return              enable
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      convert_ipc_code_             cu_$af_arg_count              cu_$arg_ptr
dial_manager_$privileged_attach                             dial_manager_$release_channel get_temp_segment_
get_wdir_                     ioa_                          iox_$attach_name              iox_$close
iox_$control                  iox_$detach_iocb              iox_$get_line                 iox_$modes
iox_$open                     ipc_$block                    ipc_$create_ev_chn            ipc_$delete_ev_chn
l6_ftf_                       release_temp_segment_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$bigarg           error_table_$noarg            error_table_$not_act_fnc
error_table_$not_closed       error_table_$not_detached     error_table_$wrong_no_of_args iox_$error_output
iox_$user_input               iox_$user_output              sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000314       119 000322       120 000325       121 000330       123 000333       124 000335       126 000336
    127 000337       129 000340       130 000342       132 000343       133 000344       134 000352       136 000355
    142 000377       143 000410       145 000414       147 000421       149 000427       150 000444       152 000446
    154 000453       156 000467       158 000477       159 000500       161 000503       162 000520       164 000522
    166 000527       171 000536       174 000537       176 000542       178 000545       180 000547       191 000553
    192 000564       194 000566       195 000570       196 000573       197 000575       199 000600       200 000613
    202 000620       204 000621       205 000653       207 000655       208 000657       210 000661       211 000663
    212 000664       213 000666       215 000670       217 000672       218 000713       220 000715       221 000717
    223 000721       224 000723       226 000726       227 000760       229 000762       230 000764       232 000765
    235 000773       236 001012       238 001014       240 001017       241 001051       243 001053       246 001055
    253 001056       254 001116       256 001123       258 001125       259 001146       261 001153       263 001155
    264 001207       271 001211       272 001243       274 001245       276 001247       277 001301       279 001303
    280 001305       282 001307       283 001311       284 001312       285 001314       286 001316       288 001320
    303 001322       305 001326       307 001330       310 001362       311 001414       314 001442       315 001474
    317 001476       320 001500       322 001502       323 001504       325 001507       326 001541       328 001543
    330 001545       338 001546       339 001565       341 001567       343 001572       344 001624       346 001626
    347 001630       349 001631       351 001634       352 001666       354 001670       355 001672       357 001673
    359 001676       360 001677       362 001700       364 001704       366 001705       369 001734       370 001750
    372 001751       375 002000       377 002001       379 002031       381 002032       383 002064       385 002065
    387 002116       389 002117       391 002126       392 002152       394 002153       396 002206       398 002207
    400 002237       402 002240       404 002270       406 002271       408 002315       410 002316       412 002342
    414 002343       416 002373       418 002374       420 002403       421 002432       423 002433       426 002470
    428 002471       430 002524       432 002525       434 002556       436 002557       442 002561       444 002603
    446 002606       447 002626       448 002633       450 002634       454 002655       455 002675       457 002702
    459 002703       466 002711       468 002724       470 002740       472 002756       474 002772       476 003020


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
