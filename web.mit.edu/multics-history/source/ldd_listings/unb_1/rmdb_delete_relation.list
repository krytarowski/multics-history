	COMPILATION LISTING OF SEGMENT rmdb_delete_relation
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/09/86  1235.2 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /****^  HISTORY COMMENTS:
        8*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
        9*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       10*     This entry is being made to cover the change made on 85-05-06 by Thanh
       11*     Nguyen. (see mrds #136)
       12*  2) change(86-04-03,Spitzer), approve(86-04-03,MCR7311),
       13*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
       14*     Add updating the crossreference file.
       15*  3) change(86-12-03,Blair), approve(86-12-03,PBF7311), audit(86-12-05,Dupuis),
       16*     install(86-12-09,MR12.0-1237):
       17*     If we're executing the delete as a cleanup operation and the rel_name is
       18*     not in the model and there is no xref-file, we don't have anything to
       19*     unlink.
       20*                                                   END HISTORY COMMENTS */
       21 
       22 rmdb_delete_relation: proc (I_rmdb_ctl_ptr, I_rmdb_delete_rel_info_ptr, O_err_msg, O_err_code);
       23 
       24 /*                      BEGIN_DESCRIPTION
       25*
       26*   This  module implements the rmdb delete relation work. It unlinks
       27*   any  knowledge  of the  relation  from the db_model,  deletes the
       28*   file_model (rel_name.m) and deletes the rel_data file (rel_name).
       29*
       30*   This procedure contains two entry points:
       31*         rmdb_delete_relation$rmdb_delete_relation
       32*         rmdb_delete_relation$cleanup
       33*
       34*   The only difference is that cleanup entry point does NOT set the
       35*   inconsistent undo string.
       36*
       37*   		      END_DESCRIPTION
       38**/
       39 
       40 /* HISTORY
       41*   82-04-29  Written by R. Lackey
       42*
       43*   82-07-01  Roger Lackey :  Modified the calls to  mu_db_inconsistent to use
       44*   mdbm_util_$inconsistent_* for binding.
       45*
       46*   82-09-14 D. Woodka : Modified for DMS conversion. The call to delete_$path
       47*   to delete the relation's MSF was changed to a call to rmdb_relmgr_entries.
       48*   delete_relation. The cleanup_intercept handler was removed. 
       49*   The pointer rmdb_ctl_ptr is now passed in as an argument in order to pass
       50*   the relation_manager entry points.
       51*
       52*   83-02-09 Mike Kubicar : Added transaction processing include files.
       53*
       54*   83-02-14 Davids: modified to use the new db_type_flags in the db_model
       55*   structure instead of the old numeric db_type.
       56*
       57*   83-05-24 Davids: Added code to reset the saved_res_version so the saved
       58*   resultant will not get incorrectly used.
       59**/
       60 
       61 /*       PARAMETERS       */
       62 	dcl     I_rmdb_ctl_ptr	 ptr parameter;	/* Pointer to rmdb_ctl structure */
       63 	dcl     I_rmdb_delete_rel_info_ptr ptr parameter; /* Pointer rmdb_delete_rel_info structure */
       64 	dcl     O_err_code		 fixed bin (35) parameter; /* Error code */
       65 	dcl     O_err_msg		 char (*) parameter;/* Error message test */
       66 
       67 /* main entry point */
       68 
       69 	cleanup_entry_point = "0"b;
       70 	goto common;
       71 
       72 
       73 
       74 /* Cleanup entry point does not set undo string in inconsistence */
       75 
       76 cleanup: entry (I_rmdb_ctl_ptr, I_rmdb_delete_rel_info_ptr, O_err_msg, O_err_code);
       77 
       78 	cleanup_entry_point = "1"b;
       79 	goto common;
       80 
       81 
       82 
       83 common:
       84 
       85 	rmdb_delete_rel_info_ptr = I_rmdb_delete_rel_info_ptr;
       86 	rmdb_ctl_ptr = I_rmdb_ctl_ptr;
       87 	mstxn_txn_id = "0"b;
       88 	if rmdb_delete_rel_info.version ^= RMDB_DELETE_REL_INFO_VERSION_1 then
       89 	     call error (error_table_$unimplemented_version,
       90 		"For rmdb_delete_rel_info.version");
       91 
       92 	if rmdb_delete_rel_info.db_model_ptr -> db_model.db_type_flags.transactions_needed then do; /* Transactions needed, it's a protected dm file */
       93 		mstxn_transactions_needed = "1"b;
       94 		call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
       95 		if mstxn_code = 0 then do;
       96 			mstxn_txn_id = "0"b;
       97 			call error (error_table_$action_not_performed,
       98 			     "Relations may not be deleted while a transaction " ||
       99 			     "is in progress.  Commit or abort the transaction " ||
      100 			     "and try again.");
      101 		     end;
      102 	     end;
      103 	else mstxn_transactions_needed = "0"b;
      104 	mstxn_txn_id = "0"b;
      105 
      106 	db_path = rmdb_delete_rel_info.absolute_db_path;
      107 	dbm_ptr = rmdb_delete_rel_info.db_model_ptr;
      108 	rel_name = rtrim (rmdb_delete_rel_info.relation_name);
      109 	O_err_msg = "";
      110 	O_err_code = 0;
      111 
      112 	if db_path = "" then call error (mrds_error_$no_db_path, "");
      113 
      114 	exists_in_db_model = "0"b;			/* Don't know yet */
      115 	brief = rmdb_delete_rel_info.brief;
      116 
      117 	rmdb_ctl_ptr -> rmdb_ctl.saved_res_version_ptr -> based_char8 = "RESTRUCT";
      118 
      119 /* Critical code to unlink relation from db_model
      120*   QUITs will be intercepted and held until the unlink critical code is completed
      121**/
      122 
      123 	quit_intercept_flag = "0"b;
      124 
      125 	on quit quit_intercept_flag = "1"b;		/* hold off any QUITs til finished updating db_model */
      126 
      127 
      128 
      129 	call unlink_relation (exists_in_db_model);	/* Internal procedure */
      130 
      131 	if exists_in_db_model
      132 	then do;
      133 	     call terminate_file_ (fm_ptr, 0, TERM_FILE_DELETE, code);
      134 	     if code ^= 0 then do;
      135 
      136 		if code = error_table_$noentry then code = 0; /* File model not there */
      137 		else call error (code, rtrim (db_path) || ">" || rel_name || ".m");
      138 		end;
      139 	     end;
      140 
      141 /*  delete the relation */
      142 
      143 	on cleanup call mstxn_cleanup;
      144 	on any_other call mstxn_any_other;
  1     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the changes made on 85-05-06 and
  1     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
  1    10*     was removed because not all modules need the dbcb, and the
  1    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
  1    12*     list #136).
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 /*
  1    17*                    BEGIN_DESCRIPTION
  1    18*
  1    19*   A generalized routine accessed by all MRDS modules (with the temporary 
  1    20*   (perhaps) exception of restructuring modules) that must start transactions 
  1    21*   if none are present.  The intent is that it be executed as inline code.
  1    22*   The variable mstxn_transactions_needed must be set prior to entering this
  1    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
  1    24*   will suffice.  Included are procedures called mstxn_cleanup and 
  1    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
  1    26*   handlers in the program.  Such handlers should be established just prior to
  1    27*   the inclusion of this code and disabled just following the inclusion of
  1    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
  1    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
  1    30*   include file does the same, because this code might not have been entered 
  1    31*   yet when the handler is invoked.  Directly following this include file the 
  1    32*   contents of mstxn_code should be examined.  If zero, then either the 
  1    33*   transaction was successfully started or no transaction was required.  If the
  1    34*   mrds_finish_transaction code is referenced in general error handling 
  1    35*   situations where the possibility exists that the code in this include file 
  1    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
  1    37*   the beginning of the program.
  1    38*
  1    39*                    END_DESCRIPTION
  1    40*
  1    41*   Written 82-09-28 by Paul W. Benjamin.
  1    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
  1    43*   Modified 83-01-07 by PWB to not reference the dbcb.
  1    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
  1    45*		 any_other handler in situations where the module did
  1    46*		 not start the transaction.
  1    47*   Modified 83-05-05 by PWB to abandon when abort fails.
  1    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
  1    49*		 and abort.
  1    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
  1    51*		 transaction_bj_full conditions.
  1    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
  1    53*		 and to handle transaction_lock_timeout_.
  1    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
  1    55*                     dbcb.user_started_transaction flag.
  1    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
  1    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
  1    58*                     directory >ldd>include and >exl>mrd>i
  1    59**/
  1    60 
  1    61 dcl continue_to_signal_ entry (fixed bin(35));
  1    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
  1    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
  1    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
  1    65 dcl mstxn_code fixed bin (35);
  1    66 dcl mstxn_retries fixed;
  1    67 dcl mstxn_temp_code fixed bin (35);
  1    68 dcl mstxn_transactions_needed bit (1) aligned;
  1    69 dcl user_started_transaction bit (1) aligned;
  1    70 dcl mstxn_txn_id bit (36) aligned;
  1    71 dcl user_transaction_id bit (36) aligned;
  1    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
  1    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
  1    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
  1    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
  1    76 dcl transaction_manager_$handle_conditions entry ();
  1    77 dcl 1 mstxn_condition_info like condition_info;
  1    78 
  2     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*Designed by Matthew C. Pierret, 01/26/82.
  2     6*Coded by Jeffrey D. Ives, 04/30/82.
  2     7*Modified:
  2     8*10/18/82 by Steve Herbst: Names changed.
  2     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  2    10**/
  2    11 
  2    12 dcl (LOWEST_MODE init (1),
  2    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  2    14 
  2    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  2    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  2    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  2    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  2    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  2    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  2    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  2    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  2    23 
  2    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    79 

  1    80 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
  1    81 
  1    82 
  1    83 	mstxn_code = 0;
  1    84 	mstxn_txn_id = "0"b;
  1    85 	
  1    86 	if ^mstxn_transactions_needed			/* only need transactions */
  1    87 	     then goto mstxn_exit;			/* for protected page files */
  1    88 	mstxn_retries = 0;
  1    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
  1    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
  1    91 	     then do;				
  1    92 	     user_started_transaction = "1"b;
  1    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
  1    95 	     goto mstxn_exit;	
  1    96 	end;
  1    97 
  1    98 	user_started_transaction = "0"b;
  1    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
  1   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1   101 
  1   102 mstxn_cleanup:
  1   103 proc;
  1   104 
  1   105 /*  This procedure MUST be called by a cleanup handler. */
  1   106 
  1   107           if mstxn_txn_id ^= "0"b
  1   108           then do;
  1   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
  1   110 	     if mstxn_temp_code ^= 0
  1   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
  1   112 	end;
  1   113 	
  1   114      end mstxn_cleanup;
  1   115 
  1   116 mstxn_any_other:
  1   117 proc;
  1   118 
  1   119 /*  This procedure MUST be called by an any_other handler. */
  1   120 
  1   121           if mstxn_txn_id ^= "0"b
  1   122           then do;
  1   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
  1   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
  1   125 		then do;
  1   126 		mftxn_code = dm_error_$lock_deadlock;
  1   127 		goto mftxn_check_code;
  1   128 	     end;
  1   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
  1   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
  1   131 		then do;
  1   132 		mftxn_code = dm_error_$bj_journal_full;
  1   133 		goto mftxn_check_code;
  1   134 	     end;
  1   135 	     else call transaction_manager_$handle_conditions;
  1   136 	end;
  1   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
  1   138      end mstxn_any_other;
  1   139      
  1   140 mstxn_exit:
  1   141      
  1   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
      145 
      146 	if mstxn_code ^= 0
      147 	then call error (mstxn_code, "Could not start a transaction while deleting relation " || rtrim (rel_name) || ".");
      148 	call rmdb_ctl.relmgr_entries.delete_relation (db_path, rel_name, code);
      149 	if code ^= 0 then do;
      150 		if code = error_table_$noentry then code = 0; /* Relation data file not there */
      151 		else call error (code, rtrim (db_path) || ">" || rel_name);
      152 	     end;
      153 
      154 	call mdbm_util_$inconsistent_reset (dbm_ptr);	/* Make db consistent */
      155 
      156 /* If not cleanup_entrypoint then add the history entry to the db_model that we deleted it */
      157 
      158 	if ^cleanup_entry_point then
      159 	     call rmdb_add_rmdb_history (dbm_ptr, RMDB_REL_TYPE, (rel_name), RMDB_DEL_REL_OP, "", long_err_msg, code);
      160 
      161 	revert quit;
      162 
      163 	if quit_intercept_flag then signal quit;	/* Now signal the quit that was intercepted */
      164 
      165 	if ^exists_in_db_model & ^brief then call error (mrds_error_$no_model_rel, "^/" || rel_name);
      166 
      167 exit:
      168 	if O_err_code = mrds_error_$no_model_rel	/* Don't abort just for this */
      169 	then mftxn_code = 0;
      170 	else mftxn_code = O_err_code;
  4     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
  4     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*                    BEGIN_DESCRIPTION
  4    15*
  4    16*   A generalized routine accessed by all MRDS modules that begin and commit 
  4    17*   transactions.  The intent is that it be executed as inline code. It is 
  4    18*   assumed that mrds_start_transaction was executed previously in the 
  4    19*   procedure.  Prior to this include file the program should assign the value 
  4    20*   of its local error code to mftxn_code.  The program utilizing this
  4    21*   include file must supply a function labeled should_rollback that returns
  4    22*   bit (1).  This routine should examine the error code mftxn_code and whether
  4    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
  4    24*   means rollback.  This procedure may choose to simply return "0"b as it 
  4    25*   appears that MRDS will generally NOT rollback transactions.  This routine
  4    26*   does rollback and restart if the before journal is full but only attempts it
  4    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
  4    28*   where any data that was saved prior to the transaction is restored.  A 
  4    29*   procedure consisting solely of a return statement can be supplied if 
  4    30*   necessary.  After execution of this include file, mftxn_code must be
  4    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
  4    32*   then the commit has failed.  Otherwise it will be unchanged.
  4    33*
  4    34*                    END_DESCRIPTION
  4    35*
  4    36*   Written 82-09-30 by Paul W. Benjamin.
  4    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
  4    38*                     error code only when the transaction is in an error state.
  4    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
  4    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
  4    41*		 fails, and to abort rather than rollback when bj is full.
  4    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
  4    43*		 and rollback.
  4    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
  4    45*		 to by the mstxn_any_other procedure.
  4    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
  4    47*                     the user already started his own transaction.
  4    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
  4    49*                     the directory >ldd>include and >exl>mrd>i.
  4    50**/
  4    51 
  4    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
  4    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
  4    54 dcl mftxn_code fixed bin (35);
  4    55 dcl mftxn_temp_code fixed bin (35);
  4    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
  4    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
  4    58 	
  4    59 
  4    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
  4    61 	     then do;
  4    62 	     mftxn_code = 0;
  4    63 	     goto mftxn_exit;
  4    64 	end;
  4    65 mftxn_check_code:
  4    66 	if mftxn_code = 0
  4    67 	     then do;
  4    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
  4    69 	     if mftxn_code ^= 0
  4    70 		then do;
  4    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    72 		if mftxn_temp_code ^= 0
  4    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    74 	     end;
  4    75 	end;
  4    76 	else do;
  4    77 	     call restore_significant_data;
  4    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
  4    79 		& mstxn_retries < 1		
  4    80 		then do;
  4    81 		     mstxn_retries = mstxn_retries + 1;
  4    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    83 		     if mftxn_temp_code ^= 0
  4    84 			then do;
  4    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    86 			if mftxn_temp_code ^= 0
  4    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    88 		     end;
  4    89 		     else do;
  4    90 			mstxn_code = 0;
  4    91 			goto mstxn_exit;		/* go back and try again */
  4    92 		     end;
  4    93 		end;
  4    94 	     else if should_rollback ()		/* let the program decide */
  4    95 		then do;
  4    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    97 		if mftxn_temp_code ^= 0
  4    98 		     then do;
  4    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   100 		     if mftxn_temp_code ^= 0
  4   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   102 		end;
  4   103 		else do;
  4   104 		     mstxn_code = 0;
  4   105 		     goto mstxn_exit;		/* go back and try again */
  4   106 		end;
  4   107 	     end;
  4   108 	     else do;
  4   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   110 		if mftxn_temp_code ^= 0
  4   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   112 	     end;
  4   113 	end;
  4   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
  4   115 mftxn_exit:
  4   116      
  4   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
      171 
      172 	if mftxn_code ^= 0 then do;
      173 		O_err_code = mftxn_code;
      174 		O_err_msg = "Could not finish a transaction while deleting relation " || rtrim (rel_name) || ".";
      175 	     end;
      176 	return;
      177 
      178 /*  * * * * * * * * * *    unlink_relation   * * * * * * * * * * * *  *      */
      179 
      180 unlink_relation: proc (exists);
      181 
      182 	dcl     exists		 bit (1) parameter;
      183 	dcl     last_ua_ptr		 ptr;
      184 	dcl     record_buffer	 bit (72);
      185 
      186 	prev_fi_ptr = null;			/* Indicating db_model.file_ptr */
      187 
      188 /* Look for rel_name in file_info linked list */
      189 
      190 	exists = "0"b;
      191 
      192 	if db_model.file_ptr ^= NULL_OFFSET
      193 	then do fi_ptr = ptr (dbm_ptr, db_model.file_ptr)
      194 	     repeat ptr (dbm_ptr, file_info.fwd_ptr)
      195 	     while (^exists & rel (fi_ptr) ^= NULL_OFFSET);
      196 
      197 	     if file_info.file_name = rel_name then do;	/* Found the one were looking for */
      198 		     exists = "1"b;
      199 		     saved_fi_ptr = fi_ptr;		/* Pointer to one to be unlinked */
      200 		end;
      201 	     else prev_fi_ptr = fi_ptr;
      202 
      203 	end;
      204 
      205 	if ^exists then goto not_in_model;		/* Relation was not linked into db_model */
      206 
      207 	next_fi_ptr_offset = saved_fi_ptr -> file_info.fwd_ptr;
      208 
      209 	if ^cleanup_entry_point then call mdbm_util_$inconsistent_set (dbm_ptr, "delete_relation",
      210 		"Deleting relation " || rel_name, "delete_relation " || rel_name || " -brief");
      211 
      212 /* Indicate in all the attributes within this relation that they aren't
      213*   referenced within this relation. If any of the attributes becomes
      214*   unreferenced, create an unreferenced_attribute structure and link it into
      215*   the list in db_model. */
      216 
      217 	if rmdb_ctl.crossref_file_info.iocb_ptr = null
      218 	then do;
      219 	     call mdbm_util_$xref_build (rmdb_ctl.temp_dir_path, rmdb_ctl.absolute_db_path,
      220 		dbm_ptr, rmdb_ctl.crossref_file_info.name, rmdb_ctl.crossref_file_info.iocb_ptr,
      221 		long_err_msg, code);
      222 	     if code ^= 0 then call error (code, long_err_msg);
      223 	     end;
      224 not_in_model:
      225 	xref_iocb_ptr = rmdb_ctl.crossref_file_info.iocb_ptr;
      226 	if xref_iocb_ptr = null then return;
      227 
      228 	file_model_name = rtrim (rel_name) || ".m";
      229 	call initiate_file_ (db_path, file_model_name, R_ACCESS, fm_ptr, (0), code);
      230 	if code ^= 0 then
      231 	     if brief then do;
      232 		exists = "0"b;
      233 		return;
      234 		end;
      235 	     else call error (code, "Initiating " || file_model_name);
      236 
      237 	last_ua_ptr = null;
      238 	ri_ptr = ptr (fm_ptr, rel_ptr);
      239 
      240 	do ai_ptr = ptr (fm_ptr, rel_info.attr_ptr)
      241 		  repeat ptr (fm_ptr, attr_info.fwd_thread)
      242 		  while (rel (ai_ptr) ^= NULL_OFFSET);
      243 	     call mdbm_util_$xref_dereference (xref_iocb_ptr, ATTRIBUTE_KEY_HEAD,
      244 		(attr_info.name), rel_name, reference_count, long_err_msg, code);
      245 	     if code ^= 0 then call error (code, long_err_msg);
      246 
      247 	     if reference_count = 0 then do;
      248 		last_ua_ptr = null;
      249 		do ua_ptr = ptr (dbm_ptr, db_model.unreferenced_attribute_ptr)
      250 			  repeat ptr (dbm_ptr, unreferenced_attribute.fwd_thread)
      251 			  while (rel (ua_ptr) ^= NULL_OFFSET);
      252 		          last_ua_ptr = ua_ptr;
      253 		     end;				/* do last_ua_ptr */
      254 
      255 /* Check to see if the domain name and attribute name are the same. If so, then
      256*   this is a generated attribute and should not be added to the unreferenced
      257*   attribute list. */
      258 		di_ptr = ptr (dbm_ptr, attr_info.domain_ptr);
      259 		if domain_info.name = attr_info.name
      260 		then do;
      261 
      262 /* This is a generated attribute. Check the domain reference count. If it is 1,
      263*   then the domain becomes unreferenced. */
      264 		     crossref_info_record_ptr = addr (record_buffer);
      265 		     call mdbm_util_$xref_find_record (xref_iocb_ptr, DOMAIN_KEY_HEAD,
      266 			(domain_info.name), crossref_info_record_ptr, 8, long_err_msg, code);
      267 		     if code ^= 0 then call error (code, long_err_msg);
      268 
      269 		     if crossref_info_record.count = 1 /* 1 for the generated attribute */
      270 		     then domain_info.unreferenced = "1"b;
      271 		     end;
      272 		else do;				/* it's a real attribute */
      273 		     allocate unreferenced_attribute in (dbm_area) set (ua_ptr);
      274 
      275 		     unreferenced_attribute.name = attr_info.name;
      276 		     unreferenced_attribute.domain_ptr = attr_info.domain_ptr;
      277 		     unreferenced_attribute.unused (*) = NULL_OFFSET;
      278 		     unreferenced_attribute.fwd_thread = NULL_OFFSET;
      279 
      280 /* Link it on the end of the list */
      281 		     if last_ua_ptr = null
      282 		     then db_model.unreferenced_attribute_ptr = rel (ua_ptr);
      283 		     else last_ua_ptr -> unreferenced_attribute.fwd_thread = rel (ua_ptr);
      284 		     end;
      285 		end;
      286 	     end;					/* do ai_ptr */
      287 
      288 /* Unlink the file_info structure in db_model */
      289 
      290 	if ^exists 
      291 	then do;
      292 	     saved_fi_ptr = ptr (dbm_ptr, file_model.fi_ptr);
      293 	     free saved_fi_ptr -> file_info;
      294 	     exists = "1"b;
      295 	     return;
      296 	     end;
      297 
      298 	if prev_fi_ptr = null then /* Incase it was first in  list */
      299 	     db_model.file_ptr = next_fi_ptr_offset;
      300 
      301 	else prev_fi_ptr -> file_info.fwd_ptr = next_fi_ptr_offset; /* Link around current file_info structure */
      302 
      303 	db_model.num_unblk_files = db_model.num_unblk_files - 1; /* Just unlinked */
      304 	db_model.num_rels = db_model.num_rels - 1;
      305 
      306 	if ^brief & code ^= 0 then call error (code, long_err_msg); /* Error code from rmdb_add_rmdb_history */
      307 
      308 	call mdbm_util_$xref_delete_record (xref_iocb_ptr, RELATION_KEY_HEAD,  rel_name, long_err_msg, code);
      309 	if (code ^= 0) & (code ^= error_table_$no_record) & (^brief)
      310 	then call error (code, long_err_msg);
      311 
      312 	free saved_fi_ptr -> file_info;		/* Free unlinked file_info structure */
      313 
      314 	call adjust_bit_count_ ((db_path), "db_model", "1"b, bcnt, code);
      315 
      316      end unlink_relation;
      317 
      318 /***********
      319**
      320**   These routines are used by the transaction processing include files.
      321**   Restore_significant_data is called to reinitialize variables in case
      322**   of a rollback.  Should_rollback determines whether a transaction should
      323**   be rolled back or aborted on error.  Currently, it is always aborted.
      324**
      325***********/
      326 
      327 
      328 restore_significant_data:
      329      proc;
      330      end restore_significant_data;
      331 
      332 
      333 
      334 should_rollback:
      335      proc returns (bit (1));
      336 	return ("0"b);
      337      end should_rollback;
      338 
      339 /*  * * * * * * * * * * * * * *      error     * * * * * * * * * * * * * *   */
      340 
      341 
      342 
      343 error: proc (err_code, err_message);
      344 
      345 	dcl     err_code		 fixed bin (35);
      346 	dcl     err_message		 char (*);
      347 
      348 
      349 	O_err_code = err_code;
      350 	O_err_msg = err_message;
      351 	goto exit;
      352 
      353      end error;
      354 
  5     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  5     2*
  5     3*   Values for the "access mode" argument so often used in hardcore
  5     4*   James R. Davis 26 Jan 81  MCR 4844
  5     5*   Added constants for SM access 4/28/82 Jay Pattin
  5     6*   Added text strings 03/19/85 Chris Jones
  5     7**/
  5     8 
  5     9 
  5    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  5    11 dcl	(
  5    12 	N_ACCESS		   init ("000"b),
  5    13 	R_ACCESS		   init ("100"b),
  5    14 	E_ACCESS		   init ("010"b),
  5    15 	W_ACCESS		   init ("001"b),
  5    16 	RE_ACCESS		   init ("110"b),
  5    17 	REW_ACCESS	   init ("111"b),
  5    18 	RW_ACCESS		   init ("101"b),
  5    19 	S_ACCESS		   init ("100"b),
  5    20 	M_ACCESS		   init ("010"b),
  5    21 	A_ACCESS		   init ("001"b),
  5    22 	SA_ACCESS		   init ("101"b),
  5    23 	SM_ACCESS		   init ("110"b),
  5    24 	SMA_ACCESS	   init ("111"b)
  5    25 	)		   bit (3) internal static options (constant);
  5    26 
  5    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  5    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  5    29 
  5    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  5    31 			   static options (constant);
  5    32 
  5    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  5    34 			   static options (constant);
  5    35 
  5    36 dcl	(
  5    37 	N_ACCESS_BIN	   init (00000b),
  5    38 	R_ACCESS_BIN	   init (01000b),
  5    39 	E_ACCESS_BIN	   init (00100b),
  5    40 	W_ACCESS_BIN	   init (00010b),
  5    41 	RW_ACCESS_BIN	   init (01010b),
  5    42 	RE_ACCESS_BIN	   init (01100b),
  5    43 	REW_ACCESS_BIN	   init (01110b),
  5    44 	S_ACCESS_BIN	   init (01000b),
  5    45 	M_ACCESS_BIN	   init (00010b),
  5    46 	A_ACCESS_BIN	   init (00001b),
  5    47 	SA_ACCESS_BIN	   init (01001b),
  5    48 	SM_ACCESS_BIN	   init (01010b),
  5    49 	SMA_ACCESS_BIN	   init (01011b)
  5    50 	)		   fixed bin (5) internal static options (constant);
  5    51 
  5    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      355 
      356 
  6     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  6     6*     modified to save space occupied by model
  6     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  6     8*     to add mdbm_secured bit in db_model
  6     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  6    10*     collapsed the following into an unused_offset array:
  6    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  6    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  6    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  6    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  6    15*       unused_1
  6    16*     Also changed the name of unused_2 to restructuring_history_offset
  6    17*     and changed the comment on the changer structure to indicate
  6    18*     that it will contain on database creation information.
  6    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  6    20*     used one of the unused_offsets to point to a message which indicates
  6    21*     why the db is inconsistent. The offset will be null when the db is created
  6    22*     and set the first time the message is used. this is so it will be
  6    23*     consistent with existing data bases. Also added the message structure.
  6    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  6    25*     added the undo_request element to the message structure
  6    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  6    27*     changed unused_offset (12) to last_restructruring_history_offset and
  6    28*     changed restructuring_history_offset to first_restructuring_history_offset
  6    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  6    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  6    31*     1 => vfile database and 2 => page_file database. Up to this point all
  6    32*     database types were equal to 1.
  6    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  6    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  6    35*     flags. This will allow information about transactions and dm_file
  6    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  6    37*     change is compatable with all datamodels created by the released version
  6    38*     of mrds.
  6    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  6    40*     added the rollback_on flag to the db_type_flags since it appears that you
  6    41*     can have a dmfile database that requires transactions but does not have any
  6    42*     journalizing. Also switched the order of the transactions_needed and
  6    43*     concurrency_on flags - this makes the change compatable with existing
  6    44*     dmfile databases except when displaying the model since concurrency_on and
  6    45*     rollback_on will be off in the model even though the dmfile relations had
  6    46*     them on during creation.
  6    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  6    48*      Removed ctl_file_path_ptr.
  6    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  6    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  6    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  6    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  6    53*      in the flag word for rmdb copying.
  6    54*                                                   END HISTORY COMMENTS */
  6    55 
  6    56 
  6    57 /* this include file contains the structures that go into the make up
  6    58*   of the "db_model" segment in the model for the database.
  6    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  6    60*
  6    61*   the db_model structure goes at the base of the segment, and contains items unique to
  6    62*   the whole databse. in addition, it has an area of size to fill the
  6    63*   rest of a segment, that holds the lists of files and domains in the database.
  6    64*   these lists are singly forward linked lists. all "pointers" in the database model
  6    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  6    66*   since actual pointers are process dependent on segment number.
  6    67*   the remaining structures are first a path_entry one to save pathnames in,
  6    68*   and the stack_item and constent structures, used to save a boolean
  6    69*   expression in polish form, with the stack represented by a linked list.
  6    70*   the final structure is one for identifying the status of version information */
  6    71 
  6    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  6    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  6    74 	     2 db_type_flags      unal,
  6    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  6    76 	       3 unused	      (13) bit (1) unal,
  6    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  6    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  6    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  6    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  6    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  6    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  6    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  6    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  6    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  6    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  6    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  6    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  6    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  6    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  6    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  6    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  6    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  6    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  6    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  6    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  6    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  6    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  6    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  6   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  6   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  6   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  6   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  6   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  6   105 
  6   106      dcl	   dbm_ptr	      ptr;
  6   107 
  6   108 /* the files in the database each have a file_info containing
  6   109*   their name, the file_model for each file is found by initiating the
  6   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  6   111*   the file_info list is a singly linked list in definition order */
  6   112 
  6   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  6   114 	     2 file_name	      char (30),		/* name of file */
  6   115 	     2 file_id	      bit (36),		/* id number of file */
  6   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  6   117 	     2 unused	      unal bit (18);	/* for future expansion */
  6   118 
  6   119      dcl	   fi_ptr		      ptr;
  6   120 
  6   121 /* each domain used in the database will have a domain info saved in the db_model
  6   122*   segment. it describes the domain of the given name, and it's options.
  6   123*   the domain_info's form a singly linked list in definition order */
  6   124 
  6   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  6   126 	     2 name	      char (32),		/* name of domain */
  6   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  6   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  6   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  6   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  6   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  6   132 	     2 reserved	      bit (31) unal,
  6   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  6   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  6   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  6   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  6   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  6   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  6   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  6   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  6   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  6   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  6   143 	     2 str_err_path_ptr   unal bit (18),
  6   144 	     2 str_after_path_ptr unal bit (18),
  6   145 	     2 get_before_path_ptr unal bit (18),
  6   146 	     2 get_err_path_ptr   unal bit (18),
  6   147 	     2 get_after_path_ptr unal bit (18),
  6   148 	     2 mod_before_path_ptr unal bit (18),
  6   149 	     2 mod_err_path_ptr   unal bit (18),
  6   150 	     2 mod_after_path_ptr unal bit (18),
  6   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  6   152 	     2 unused_2	      unal bit (18),
  6   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  6   154 
  6   155      dcl	   di_ptr		      ptr;
  6   156 
  6   157 /* information necessary for attributes that are not used in any relation */
  6   158 
  6   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  6   160 	     2 name char (32),			/* name of attribute */
  6   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  6   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  6   163 	     2 unused (2) bit (18) unal;
  6   164 
  6   165      dcl     ua_ptr ptr;
  6   166 
  6   167 
  6   168 /* space saving pathname$entryname structure, to be allocated
  6   169*   only when a path$entry has to be saved, else only a bit(18)
  6   170*   offset takes up space in the main model structure */
  6   171 
  6   172      declare 1 path_entry	      based (path_entry_ptr),
  6   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  6   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  6   175 	     2 reserved	      unal bit (36);	/* for future use */
  6   176 
  6   177      declare path_entry_ptr	      ptr;
  6   178 
  6   179 
  6   180 
  6   181 
  6   182 
  6   183 /* declarations for model of postfix stack holding the check option boolean expression
  6   184*   the following encoding values indicate the corresponding type of stack element
  6   185*
  6   186*   1  =
  6   187*   2  ^=
  6   188*   3  >
  6   189*   4  <
  6   190*   5  >=
  6   191*   6  <=
  6   192*
  6   193*   10  and
  6   194*   20  or
  6   195*   30  not
  6   196*
  6   197*   40  - (minus)
  6   198*
  6   199*   50  domain variable(same name as domain)
  6   200*
  6   201*   60  constant(number, bit string, or character string)
  6   202*
  6   203**/
  6   204 
  6   205 
  6   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  6   207 	     2 next	      bit (18),		/* link to next in list */
  6   208 	     2 type	      fixed binary,		/* code for this element type */
  6   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  6   210*						   if this is a constant element type */
  6   211 
  6   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  6   213 
  6   214 
  6   215 
  6   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  6   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  6   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  6   219 
  6   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  6   221 
  6   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  6   223 
  6   224 /* version structure, giving status of source for CMDB/RMDB,
  6   225*   status of model, and status of resultant */
  6   226 
  6   227 /* version number is in form MM.N.Y
  6   228*   where MM is the major version number, N is the minor version alteration,
  6   229*   and Y is the lastest modification to that alteration,
  6   230*   where M and N represent numbers 0-9, and Y is a letter */
  6   231 
  6   232      declare 1 version_status	      unal based (version_status_ptr),
  6   233 	     2 cmdb_rmdb,
  6   234 	       3 major	      fixed bin,
  6   235 	       3 minor	      fixed bin,
  6   236 	       3 modification     char (4),
  6   237 	     2 model,
  6   238 	       3 major	      fixed bin,
  6   239 	       3 minor	      fixed bin,
  6   240 	       3 modification     char (4),
  6   241 	     2 resultant,
  6   242 	       3 major	      fixed bin,
  6   243 	       3 minor	      fixed bin,
  6   244 	       3 modification     char (4);
  6   245 
  6   246      declare version_status_ptr     ptr;
  6   247 
  6   248 
  6   249 /* maintains information only about the db creation */
  6   250 
  6   251      declare 1 changer	      unal based (changer_ptr),
  6   252 	     2 id		      char (32),
  6   253 	     2 time	      fixed bin (71),
  6   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  6   255 
  6   256      declare changer_ptr	      ptr;
  6   257 
  6   258 
  6   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  6   260 	     02 len	      fixed bin,		/* length of the message */
  6   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  6   262 	     02 name	      char (32),		/* name of thing that set the message */
  6   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  6   264*                                                               that caused the database to become inconsistent */
  6   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  6   266 
  6   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  6   268 
  6   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  6   270 
  6   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  6   272 
  6   273 
      357 
      358 
  7     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  7     2 
  7     3 
  7     4 /****^  HISTORY COMMENTS:
  7     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  7     6*     modified to save space occupied by model
  7     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  7     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  7     9*     the number of secondary indices in the relation - it was always zero.
  7    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  7    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  7    12*     DMS conversion.
  7    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  7    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  7    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  7    16*     for relation manager changes.
  7    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  7    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  7    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  7    20*     <rel> files are good (for rmdb)
  7    21*                                                   END HISTORY COMMENTS */
  7    22 
  7    23 
  7    24 /* each file in the database will have a model segment with the name
  7    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  7    26*   the file_model structure is allocated at the base of the segment for a given file.
  7    27*   it contains an area with which all other structures in this include file are allocated.
  7    28*   these structures contain the information about which relations, foreign keys,
  7    29*   and attributes are members of this file. all lists are singly linked lists in
  7    30*   definition order. pointers to these structures are obtained by using the "pointer"
  7    31*   builtin function with arguments of the segment base pointer, and the
  7    32*   offset (bit (18)) relative to that pointer that is actually stored in
  7    33*   the file model itself. this is because pointer segment numbers are
  7    34*   per process dependent. the major lists pointed to by the file_model structure
  7    35*   are the list of relations in this file(each with a contained attribute list),
  7    36*   and the list of foreign keys whose parent relation resides in this file
  7    37*   (along with a participating attribute sublist, and the child relation list,
  7    38*   if they are also in this file) */
  7    39 
  7    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  7    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  7    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  7    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  7    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  7    45     2 reserved bit (32) unal,				/* reserved for future flags */
  7    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  7    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  7    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  7    49     2 pad_1 fixed bin (35),				/* for future use */
  7    50     2 pad_2 fixed bin (35),
  7    51     2 ratd_len fixed bin (21),			/* length of above */
  7    52     2 mratd_len fixed bin (21),			/* length of above */
  7    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  7    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  7    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  7    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  7    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  7    58     2 block_size unal fixed bin,			/* no. pages in block */
  7    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  7    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  7    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  7    62     2 num_rels unal fixed bin,			/* number of relations in file */
  7    63     2 num_links unal fixed bin,			/* number of links in file */
  7    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  7    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  7    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  7    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  7    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  7    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  7    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  7    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  7    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  7    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  7    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  7    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  7    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  7    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  7    78     2 open_eu_err_path_ptr unal bit (18),
  7    79     2 open_eu_after_path_ptr unal bit (18),
  7    80     2 open_er_before_path_ptr unal bit (18),
  7    81     2 open_er_err_path_ptr unal bit (18),
  7    82     2 open_er_after_path_ptr unal bit (18),
  7    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  7    84     2 open_neu_err_path_ptr unal bit (18),
  7    85     2 open_neu_after_path_ptr unal bit (18),
  7    86     2 open_ner_before_path_ptr unal bit (18),
  7    87     2 open_ner_err_path_ptr unal bit (18),
  7    88     2 open_ner_after_path_ptr unal bit (18),
  7    89     2 open_pu_before_path_ptr unal bit (18),
  7    90     2 open_pu_err_path_ptr unal bit (18),
  7    91     2 open_pu_after_path_ptr unal bit (18),
  7    92     2 open_pr_before_path_ptr unal bit (18),
  7    93     2 open_pr_err_path_ptr unal bit (18),
  7    94     2 open_pr_after_path_ptr unal bit (18),
  7    95     2 open_cu_before_path_ptr unal bit (18),
  7    96     2 open_cu_err_path_ptr unal bit (18),
  7    97     2 open_cu_after_path_ptr unal bit (18),
  7    98     2 open_cr_before_path_ptr unal bit (18),
  7    99     2 open_cr_err_path_ptr unal bit (18),
  7   100     2 open_cr_after_path_ptr unal bit (18),
  7   101     2 close_before_path_ptr unal bit (18),
  7   102     2 close_err_path_ptr unal bit (18),
  7   103     2 close_after_path_ptr unal bit (18),
  7   104     2 unused_1 unal bit (18),				/* for future expansion */
  7   105     2 unused_2 unal bit (18),
  7   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  7   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  7   108 dcl  fm_ptr ptr;
  7   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  7   110 dcl  atd_ptr ptr;
  7   111 dcl  atd_len fixed bin;
  7   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  7   113     2 ncomponents fixed bin,
  7   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  7   115 dcl  cna_ptr ptr;
  7   116 dcl  ncomp_init fixed bin;
  7   117 
  7   118 /* a rel_info structure contains information describing a relation.
  7   119*   a relation may only occur in one file, thus there is one rel_info
  7   120*   per relation per database, each stored in the file_model area for
  7   121*   the file that contains it. the list of rel_info's in this file
  7   122*   form a singly linked list in definition order.
  7   123*   the rel_info itself points to a list of the attributes it contains,
  7   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  7   125 
  7   126 dcl 1 rel_info aligned based (ri_ptr),
  7   127     2 name char (32),				/* relation name */
  7   128     2 id  bit (36) aligned,				/* relation id number */
  7   129     2 hashed bit (1) unal,				/* on if hashed */
  7   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  7   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  7   132     2 system bit (1) unal,				/* on if dont care how stored */
  7   133     2 indexed bit (1) unal,				/* on if secondary index */
  7   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  7   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  7   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  7   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  7   138     2 reserved bit (27) unal,				/* for future flags */
  7   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  7   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  7   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  7   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  7   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  7   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  7   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  7   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  7   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  7   148     2 unused_3 unal fixed bin,			/* element that was never used */
  7   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  7   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  7   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  7   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  7   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  7   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  7   155     2 attr_ptr unal bit (18),				/* to attr. info */
  7   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  7   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  7   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  7   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  7   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  7   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  7   162     2 link_err_path_ptr unal bit (18),
  7   163     2 link_after_path_ptr unal bit (18),
  7   164     2 unlk_before_path_ptr unal bit (18),
  7   165     2 unlk_err_path_ptr unal bit (18),
  7   166     2 unlk_after_path_ptr unal bit (18),
  7   167     2 str_before_path_ptr unal bit (18),
  7   168     2 str_err_path_ptr unal bit (18),
  7   169     2 str_after_path_ptr unal bit (18),
  7   170     2 del_before_path_ptr unal bit (18),
  7   171     2 del_err_path_ptr unal bit (18),
  7   172     2 del_after_path_ptr unal bit (18),
  7   173     2 mod_before_path_ptr unal bit (18),
  7   174     2 mod_err_path_ptr unal bit (18),
  7   175     2 mod_after_path_ptr unal bit (18),
  7   176     2 find_before_path_ptr unal bit (18),
  7   177     2 find_err_path_ptr unal bit (18),
  7   178     2 find_after_path_ptr unal bit (18),
  7   179     2 retr_before_path_ptr unal bit (18),
  7   180     2 retr_err_path_ptr unal bit (18),
  7   181     2 retr_after_path_ptr unal bit (18),
  7   182     2 unused_1 unal bit (18),				/* for future expansion */
  7   183     2 unused_2 unal bit (18),
  7   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  7   185 dcl  ri_ptr ptr;
  7   186 
  7   187 /* a attr_info structure contains information about an attribute in a given relation.
  7   188*   since attributes may appear in more than one relation, each occurence of an attribute
  7   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  7   190*   the list is singly linked in definition order. the attr_info describes
  7   191*   the data it represents, and how that data is used during a database search. */
  7   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  7   193     2 name char (32),				/* name of attribute */
  7   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  7   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  7   196     2 link_attr bit (1) unal,				/* on if participates in link */
  7   197     2 reserved bit (33) unal,
  7   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  7   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  7   200     2 key_order unal fixed bin,			/* relative posit. in key */
  7   201     2 bit_offset fixed bin (35),			/* position in tuple */
  7   202     2 bit_length fixed bin (35),			/* length if fixed */
  7   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  7   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  7   205     2 domain_ptr unal bit (18),			/* to domain info */
  7   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  7   207     2 fwd_thread unal bit (18),			/* to next in list */
  7   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  7   209 dcl  ai_ptr ptr;
  7   210 
  7   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  7   212*   each time a foreign key definition indicates a relation as it's parent,
  7   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  7   214*   a relation can be parent and/or child in any number of foreign keys.
  7   215*   the parent_link_info structure describes the foreign key, and also points
  7   216*   to a list of the attributes that participate in this foreign key.
  7   217*   (this could be from 1 up to all attributes in the relation)
  7   218*   the attr_list structures are in a singly linked list in definition order
  7   219*   for this purpose. also pointed to is a list of child_link_info's
  7   220*   that describe the child relations in this foreign key. since foreign keys
  7   221*   may span files, not all related child_link_info's have to be in this file's
  7   222*   model area. */
  7   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  7   224     2 name char (32),				/* name of link */
  7   225     2 singular bit (1) unal,				/* on if system owned link */
  7   226     2 temp bit (1) unal,				/* on if temp. order */
  7   227     2 first bit (1) unal,				/* insertion indicators */
  7   228     2 last bit (1) unal,
  7   229     2 next bit (1) unal,
  7   230     2 prior bit (1) unal,
  7   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  7   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  7   233     2 dup_first bit (1) unal,				/* duplicates first */
  7   234     2 dup_last bit (1) unal,				/* duplicates last */
  7   235     2 indexed bit (1) unal,				/* locate parent via index */
  7   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  7   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  7   238     2 thread_27 bit (1) unal,
  7   239     2 thread_18 bit (1) unal,
  7   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  7   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  7   242     2 reserved bit (19) unal,				/* reserved for future flags */
  7   243     2 index_id aligned bit (8),			/* id of index if indexed */
  7   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  7   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  7   246     2 n_children unal fixed bin,			/* no. children in link */
  7   247     2 child_fn char (30),				/* file name for first child in list */
  7   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  7   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  7   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  7   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  7   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  7   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  7   254     2 sort_err_path_ptr unal bit (18),
  7   255     2 sort_after_path_ptr unal bit (18),
  7   256     2 srch_before_path_ptr unal bit (18),
  7   257     2 srch_err_path_ptr unal bit (18),
  7   258     2 srch_after_path_ptr unal bit (18),
  7   259     2 link_before_path_ptr unal bit (18),
  7   260     2 link_err_path_ptr unal bit (18),
  7   261     2 link_after_path_ptr unal bit (18),
  7   262     2 unlk_before_path_ptr unal bit (18),
  7   263     2 unlk_err_path_ptr unal bit (18),
  7   264     2 unlk_after_path_ptr unal bit (18),
  7   265     2 unused_1 unal bit (18),				/* for future expansion */
  7   266     2 unused_2 unal bit (18),
  7   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  7   268 dcl  pli_ptr ptr;
  7   269 
  7   270 /* a child_link_info structure is the counter part of a parent_link_info
  7   271*   for foreign key child relations. each time a relation is defined to be
  7   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  7   273*   this list is singly linked in foreign key definition order.
  7   274*   the child_link_info points to a list of participating attributes from the
  7   275*   child relation by means of a singly linked list of attr_list structures
  7   276*   in definition order. the number of attributes in the parent attr_list
  7   277*   and the child attr_list lists are the same with corresponding attr_list
  7   278*   attributes having the same domain. all child_link_infos in this file
  7   279*   are on a seperately linked list. this may not include all
  7   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  7   281*   since foreign keys may span files, and the child_link_info will
  7   282*   reside in the file containing it's associated relation_info. */
  7   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  7   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  7   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  7   286     2 fixed bit (1) unal,				/* on if membership fixed */
  7   287     2 optional bit (1) unal,				/* on if membership optional */
  7   288     2 auto bit (1) unal,				/* on if insertion automatic */
  7   289     2 manual bit (1) unal,				/* on if insertion manual */
  7   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  7   291     2 range_sel bit (1) unal,				/* on if range type selection */
  7   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  7   293     2 key_dup_last bit (1) unal,
  7   294     2 key_null bit (1) unal,				/* on if null allowed */
  7   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  7   296     2 sel_current bit (1) unal,
  7   297     2 sel_key bit (1) unal,
  7   298     2 sel_proc bit (1) unal,
  7   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  7   300     2 reserved bit (21) unal,
  7   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  7   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  7   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  7   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  7   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  7   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  7   307     2 parent_fn char (30),				/* file name for parent info */
  7   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  7   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  7   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  7   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  7   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  7   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  7   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  7   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  7   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  7   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  7   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  7   319     2 link_err_path_ptr unal bit (18),
  7   320     2 link_after_path_ptr unal bit (18),
  7   321     2 unlk_before_path_ptr unal bit (18),
  7   322     2 unlk_err_path_ptr unal bit (18),
  7   323     2 unlk_after_path_ptr unal bit (18),
  7   324     2 srch_before_path_ptr unal bit (18),
  7   325     2 srch_err_path_ptr unal bit (18),
  7   326     2 srch_after_path_ptr unal bit (18),
  7   327     2 unused_1 unal bit (18),				/* for future expansion */
  7   328     2 unused_2 unal bit (18) ;
  7   329 dcl  cli_ptr ptr;
  7   330 
  7   331 /* the attr_list structure is associated with the parent_link_info
  7   332*   and child_link_info structures to represent by means of a singly linked list
  7   333*   the participating attributes from relations in a foreign key.
  7   334*   the parent_link_info has a list for the parent relation,
  7   335*   and the child_link_info has a list for the child relation.
  7   336*   the participating attributes are a subset(not necessary proper) of
  7   337*   those attributes contained in a relation definition.
  7   338*   there are equal numbers of attr_list structures in the parent and
  7   339*   child lists of the same foreign key. the corresponding attributes in these
  7   340*   lists must have the same domain. */
  7   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  7   342     2 attr_fn char (30),				/* file name for attr. */
  7   343     2 attr_ptr unal bit (18),				/* to attr info block */
  7   344     2 fwd_thread unal bit (18);			/* to next in list */
  7   345 dcl  al_ptr ptr;
  7   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  7   347     2 ascend bit (1) unal,				/* ascending order */
  7   348     2 descend bit (1) unal,				/* descending order */
  7   349     2 reserved bit (34) unal,
  7   350     2 attr_ptr unal bit (18),				/* to attr info */
  7   351     2 fwd_thread unal bit (18);			/* to next in list */
  7   352 dcl  sk_ptr ptr;
  7   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  7   354     2 attr_ptr unal bit (18),				/* to attr info */
  7   355     2 fwd_thread unal bit (18);			/* to next in list */
  7   356 dcl  dp_ptr ptr;
  7   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  7   358     2 link_fn char (30),				/* file name for thru link */
  7   359     2 link_ptr unal bit (18),				/* to parent link info */
  7   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  7   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  7   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  7   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  7   364     2 fwd_thread unal bit (18);			/* to next in chain */
  7   365 dcl  sc_ptr ptr;
  7   366 
  7   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  7   368 
  7   369 
      359 
      360 
  8     1 /* BEGIN - mrds_rmdb_ctl.incl.pl1 */
  8     2 
  8     3 
  8     4 
  8     5 /****^  HISTORY COMMENTS:
  8     6*  1) change(82-03-26,Davids), approve(), audit(), install():
  8     7*     created
  8     8*  2) change(82-05-26,Davids), approve(), audit(), install():
  8     9*     added db_model_ptr
  8    10*  3) change(82-06-09,Harvey), approve(), audit(), install():
  8    11*     deleted ssu_ routines ptr storage
  8    12*  4) change(82-08-20,Davids), approve(), audit(), install():
  8    13*     added the relmgr like reference and included the rmdb_relmgr_entries
  8    14*     include file
  8    15*  5) change(83-05-24,Davids), approve(), audit(), install():
  8    16*     added the saved_res_version_ptr element
  8    17*  6) change(84-10-23,Benjamin), approve(), audit(), install():
  8    18*     added flags (just database_readied_by_rmdb for now).
  8    19*  7) change(85-11-08,Spitzer), approve(85-11-08,MCR7311),
  8    20*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  8    21*     added crossref_file_info.
  8    22*                                                   END HISTORY COMMENTS */
  8    23 
  8    24 
  8    25 dcl 01 rmdb_ctl based (rmdb_ctl_ptr),
  8    26     02 version fixed bin,
  8    27     02 rmdb_version char (16) varying,
  8    28     02 absolute_db_path char (168),
  8    29     02 temp_dir_path char (168),
  8    30     02 work_area_ptr ptr,
  8    31     02 db_model_ptr ptr,
  8    32     02 saved_res_version_ptr ptr,
  8    33     02 crossref_file_info,
  8    34        03 iocb_ptr ptr,
  8    35        03 name char (32),
  8    36     02 relmgr_entries like rmdb_relmgr_entries,
  8    37     02 flags,
  8    38        03 database_readied_by_rmdb bit (1) unal,
  8    39        03 unused bit (35) unal;
  8    40     	
  8    41 dcl  RMDB_CTL_VERSION_1 fixed bin init (1) internal static options (constant);
  8    42 
  8    43 dcl  rmdb_ctl_ptr ptr;
  8    44 
  8    45 
  9     1 /*  START OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  9     2 
  9     3 
  9     4 /****^  HISTORY COMMENTS:
  9     5*  1) change(82-08-20,Davids), approve(), audit(), install():
  9     6*     written
  9     7*  2) change(86-01-28,Spitzer), approve(86-01-28,MCR7311),
  9     8*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  9     9*     add get_tuples_by_spec, put_tuple, put_tuples, create_cursor entry points.
  9    10*  3) change(86-08-21,Blair), approve(86-08-21,MCR7311),
  9    11*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  9    12*     Back out the entries get_tuples_by_spec and put_tuples since they aren't
  9    13*     sufficiently well tested to be reliable.  Replace with get_tuple_id and
  9    14*     get_tuple_by_id.
  9    15*                                                   END HISTORY COMMENTS */
  9    16 
  9    17 
  9    18 dcl 01 rmdb_relmgr_entries based (rmdb_relmgr_entries_ptr),
  9    19      02 create_relation entry (char (*), char (*), ptr, ptr, bit (36) aligned,
  9    20 	bit (36) aligned, fixed bin (35)),
  9    21      02 delete_relation entry (char (*), char (*), fixed bin (35)),
  9    22      02 open entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  9    23      02 close entry (bit (36) aligned, fixed bin (35)),
  9    24      02 create_index entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17),
  9    25 	bit (36) aligned, fixed bin (35)),
  9    26      02 delete_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35)),
  9    27      02 put_tuple entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  9    28      02 get_tuple_id entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  9    29      02 get_tuple_by_id entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  9    30      02 create_cursor entry (bit (36) aligned, ptr, ptr, fixed bin (35));
  9    31 
  9    32 dcl rmdb_relmgr_entries_ptr ptr;
  9    33 
  9    34 /*  END OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  8    46 
  8    47 
  8    48 
  8    49 /* END - mrds_rmdb_ctl.incl.pl1 */
      361 
      362 
 10     1 /*  START OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 10     2 
 10     3 /****^  HISTORY COMMENTS:
 10     4*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
 10     5*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
 10     6*     written.
 10     7*                                                   END HISTORY COMMENTS */
 10     8 
 10     9 /*DESCRIPTION
 10    10*  The following structures are the definition of the records with the keyed
 10    11*  vfile that is built during restructuring. This file serves as a crossreference
 10    12*  of unique attributes and domains used within the specified MRDS database. Each
 10    13*  object is a char (33); the first byte is set to an unprintable character so we
 10    14*  can use the index builtin to find a specific object.
 10    15**/
 10    16 
 10    17 dcl crossref_info_record_ptr ptr;
 10    18 dcl crossref_info_record_count fixed bin (21);
 10    19 dcl 1 crossref_info_record based (crossref_info_record_ptr),
 10    20      2 offset bit (18) unal,
 10    21      2 pad bit (18) unal,
 10    22      2 count fixed bin (21),
 10    23      2 entry (crossref_info_record_count refer (crossref_info_record.count)) unaligned,
 10    24       3 object_head char (1),
 10    25       3 object char (32);
 10    26 
 10    27 dcl crossref_info_record_objects char (33*crossref_info_record.count)
 10    28 			   based (addr (crossref_info_record.entry(1)));
 10    29 dcl OBJECT_HEAD char (1) int static options (constant) init (" ");
 10    30 
 10    31 dcl ATTRIBUTE_KEY_HEAD char (10) int static options (constant) init ("attribute:");
 10    32 dcl DOMAIN_KEY_HEAD char (7) int static options (constant) init ("domain:");
 10    33 dcl RELATION_KEY_HEAD char (9) int static options (constant) init ("relation:");
 10    34 
 10    35 /*DESCRIPTION
 10    36*  The following structures are used to contain sufficient crossreference
 10    37*  information for the delete_attribute and delete_domain requests. These
 10    38*  requests require a more complete view of a crossreference tree, associating
 10    39*  domains, attributes and relations in 2 directions.
 10    40**/
 10    41 
 10    42 dcl domain_list_ptr ptr;
 10    43 dcl domain_list_count fixed bin;
 10    44 dcl domain_list_names char (33*domain_list.count) based (addr (domain_list.name(1)));
 10    45 dcl 1 domain_list based (domain_list_ptr),
 10    46      2 count fixed bin,				/* number of domains in the list */
 10    47      2 name (domain_list_count refer (domain_list.count))
 10    48 	  char (33) unaligned,			/* name of this domain */
 10    49      2 attribute_list_ptr (domain_list_count refer (domain_list.count))
 10    50 		      ptr;			/* -> attribute_list structure */
 10    51 
 10    52 dcl attribute_list_ptr ptr;
 10    53 dcl attribute_list_count fixed bin;
 10    54 dcl attribute_list_names char (33*attribute_list.count) based (addr (attribute_list.name(1)));
 10    55 dcl 1 attribute_list based (attribute_list_ptr),
 10    56      2 count fixed bin,				/* number of attributes in the list */
 10    57      2 name (attribute_list_count refer (attribute_list.count))
 10    58 	  char (33) unaligned,			/* name of this attribute */
 10    59      2 domain_info_ptr (attribute_list_count refer (attribute_list.count))
 10    60 		   bit (18) unal,			/* offset in db_model of the domain_info structure for this attribute */
 10    61      2 attribute_ptr (attribute_list_count refer (attribute_list.count))
 10    62 		 ptr;				/* -> attribute structure */
 10    63 
 10    64 dcl relation_list_ptr ptr;
 10    65 dcl relation_list_count fixed bin;
 10    66 dcl relation_list_names char (33*relation_list.count) based (addr (relation_list.name (1)));
 10    67 dcl 1 relation_list based (relation_list_ptr),
 10    68      2 count fixed bin,				/* number of relations that are to be touched in this operation */
 10    69      2 name (relation_list_count refer (relation_list.count))
 10    70 	  char (33) unaligned,			/* name of this relation */
 10    71      2 relation_ptr (relation_list_count refer (relation_list.count))
 10    72 		ptr;				/* -> relation structure */
 10    73 
 10    74 dcl relation_ptr ptr;
 10    75 dcl relation_attribute_count fixed bin;
 10    76 dcl relation_attribute_names char (33*relation.attribute_count) based (addr (relation.attribute_names (1)));
 10    77 dcl 1 relation based (relation_ptr),
 10    78      2 name char (32),				/* name of the relation */
 10    79      2 file_model_ptr ptr,				/* -> relation.m segment */
 10    80      2 copy_file_model_ptr ptr,
 10    81      2 attribute_count fixed bin,			/* number of attributes defined for this relation */
 10    82      2 mbz fixed bin (35),
 10    83      2 attribute (relation_attribute_count refer (relation.attribute_count)),
 10    84       3 flags aligned,
 10    85         4 delete bit (1) unaligned,			/* ON: delete this attribute */
 10    86         4 new bit (1) unaligned,			/* ON: this attribute is added to the relation */
 10    87         4 part_of_key bit (1) unaligned,                    /* ON: this attribute is part of the primary key */
 10    88         4 to_be_deleted bit (1) unaligned,
 10    89         4 pad bit (32) unaligned,
 10    90       3 domain_info_ptr bit (18) aligned,		/* -> db_model domain_info structure */
 10    91       3 attribute_info_ptr ptr,			/* -> file_model attribute_info structure */
 10    92       3 value_ptr ptr,				/* if flags.new, this -> the value of the column to be stored */
 10    93 						/*   it must be of the correct data type as specified by the domain */
 10    94      2 attribute_names (relation_attribute_count refer (relation.attribute_count))
 10    95 		   char (33) unaligned;
 10    96 
 10    97 dcl attribute_ptr ptr;
 10    98 dcl attribute_count fixed bin;
 10    99 dcl 1 attribute based (attribute_ptr),
 10   100      2 count fixed bin,				/* number of relations this attribute is used in */
 10   101      2 relation_idx (attribute_count refer (attribute.count))
 10   102 		fixed bin;			/* index into list of relation names */
 10   103 
 10   104 /*  END OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      363 
      364 
 11     1 /*  BEGIN INCLUDE         rmdb_delete_rel_info.incl.pl1	     */
 11     2 
 11     3 /* Contains name of relation to be deleted
 11     4*   dtabase_pathname
 11     5*   and arugment flags  like -force
 11     6**/
 11     7 
 11     8 /* HISTORY
 11     9*   82-04-30  Created  by Roger Lackey
 11    10*
 11    11*   82-06-25  Roger Lackey: Changed force bit to brief
 11    12**/
 11    13 
 11    14 
 11    15 dcl 1 rmdb_delete_rel_info aligned based (rmdb_delete_rel_info_ptr),
 11    16     2 version fixed bin,
 11    17     2 absolute_db_path char (168),			/* Absolute database pathname */
 11    18     2 db_model_ptr ptr,				/* Pointer to db_model */
 11    19     2 relation_name char (32),			/* Name of relation to be deleted */
 11    20     2 brief bit (1) unal,				/* On => Brief option */
 11    21     2 mbz bit (35) unal init ("0"b);			/* For future use */
 11    22 
 11    23 dcl  rmdb_delete_rel_info_ptr ptr;
 11    24 dcl  RMDB_DELETE_REL_INFO_VERSION_1 fixed bin int static options (constant) init (1);
 11    25 
 11    26 /*  END  INCLUDE         rmdb_delete_rel_info.incl.pl1	     */
      365 
      366 
 12     1 /* BEGIN INCLUDE FILE rmdb_history_entry.incl.pl1 -- nsd, 82-04-09 */
 12     2 
 12     3 
 12     4 
 12     5 /****^  HISTORY COMMENTS:
 12     6*  1) change(75-01-01,WhoKnows), approve(), audit(), install():
 12     7*     Written.
 12     8*  2) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
 12     9*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 12    10*     Added RMDB_ADD_(ATTR DMN)_OP, RMDB_RN_(ATTR DMN REL)_OP.
 12    11*                                                   END HISTORY COMMENTS */
 12    12 
 12    13 
 12    14 /*
 12    15*   This include file contains the rmdb_history_entry structure which
 12    16*   is  used for maintaining a history of the databases restructuring
 12    17*   events. It also contains a set of constants used in  loading  the
 12    18*   structure.
 12    19*
 12    20*   The restructuring history is applied against the  database  as  a
 12    21*   whole  instead of against each structure in the db_model and file
 12    22*   models which was the approach originally  implemented  but  never
 12    23*   really  used  (except  to  record the database creation). This is
 12    24*   because 1 database restructuring event, i.e. adding a  new  index
 12    25*   to a relation will change several of the structures in the model.
 12    26*
 12    27*   For a detailed explaination of the use of this structure and  the
 12    28*   constants see the rmdb_add_rmdb_event module.
 12    29**/
 12    30 
 12    31 dcl 01 rmdb_history_entry aligned based (rmdb_history_entry_ptr),
 12    32     02 user_id char (32),				/* person_id.project_id.tag */
 12    33     02 date_time_restructured fixed bin (71),
 12    34     02 type_of_object_restructured fixed bin,		/* taken from constants below */
 12    35     02 object_name char (32),
 12    36     02 operation fixed bin,				/* taken from constants below */
 12    37     02 secondary_object_name char (32),			/* i.e. name of attr just indexed in a restructured relation */
 12    38     02 offset_to_next_entry bit (18) unal,
 12    39     02 offset_to_previous_entry bit (18) unal;
 12    40 	
 12    41 
 12    42 dcl  rmdb_history_entry_ptr ptr;
 12    43 
 12    44 
 12    45 dcl  RMDB_DOMAIN_TYPE init (1) fixed bin internal static options (constant);
 12    46 dcl  RMDB_ATTR_TYPE init (2) fixed bin internal static options (constant);
 12    47 dcl  RMDB_REL_TYPE init (3) fixed bin internal static options (constant);
 12    48 
 12    49 
 12    50 dcl  RMDB_ADD_REL_OP init (1) fixed bin internal static options (constant);
 12    51 dcl  RMDB_DEL_REL_OP init (2) fixed bin internal static options (constant);
 12    52 dcl  RMDB_ADD_IDX_OP init (3) fixed bin internal static options (constant);
 12    53 dcl  RMDB_DEL_IDX_OP init (4) fixed bin internal static options (constant);
 12    54 dcl  RMDB_ADD_ATTR_OP init (5) fixed bin int static options (constant);
 12    55 dcl  RMDB_DEL_ATTR_OP init (6) fixed bin int static options (constant);
 12    56 dcl  RMDB_ADD_DMN_OP init (7) fixed bin int static options (constant);
 12    57 dcl  RMDB_DEL_DMN_OP init (8) fixed bin int static options (constant);
 12    58 dcl  RMDB_RN_ATTR_OP init (9) fixed bin int static options (constant);
 12    59 dcl  RMDB_RN_DMN_OP init (10) fixed bin int static options (constant);
 12    60 dcl  RMDB_RN_REL_OP init (11) fixed bin int static options (constant);
 12    61 
 12    62 /* END INCLUDE FILE rmdb_history_entry.incl.pl1 */
      367 
      368 
 13     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
 13     2 /* format: style2,^inddcls,idind32 */
 13     3 
 13     4 declare 1 terminate_file_switches	based,
 13     5 	2 truncate		bit (1) unaligned,
 13     6 	2 set_bc			bit (1) unaligned,
 13     7 	2 terminate		bit (1) unaligned,
 13     8 	2 force_write		bit (1) unaligned,
 13     9 	2 delete			bit (1) unaligned;
 13    10 
 13    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
 13    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
 13    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
 13    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
 13    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
 13    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
 13    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
 13    18 
 13    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      369 
      370 
      371 	dcl     addr		 builtin;
      372 	dcl     adjust_bit_count_	 entry (char (168) aligned, char (32) aligned, bit (1) aligned, fixed bin (35), fixed bin (35));
      373 	dcl     any_other		 condition;
      374 	dcl     based_char8		 char (8) based;
      375 	dcl     bcnt		 fixed bin (35);
      376 	dcl     cleanup		 condition;
      377 	dcl     cleanup_entry_point	 bit (1);
      378 	dcl     code		 fixed bin (35);
      379 	dcl     db_path		 char (168);
      380 	dcl     error_table_$action_not_performed fixed bin (35) ext static;
      381 	dcl     error_table_$noentry	 fixed bin (35) ext static;
      382 	dcl     error_table_$no_record fixed bin(35) ext static;
      383 	dcl     error_table_$unimplemented_version fixed bin (35) ext static;
      384 	dcl     exists_in_db_model	 bit (1);
      385 	dcl     file_model_name	 char (32);
      386 	dcl     fixed		 builtin;
      387 	dcl     initiate_file_	 entry (char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35));
      388 	dcl     long_err_msg	 char (500);
      389 	dcl     mdbm_util_$inconsistent_reset entry (ptr);
      390 	dcl     mdbm_util_$inconsistent_set entry (ptr, char (*), char (*), char (*));
      391 	dcl     mdbm_util_$xref_build	 entry (char(*), char(*), ptr, char(*), ptr, char(*), fixed bin(35));
      392 	dcl     mdbm_util_$xref_delete_record entry (ptr, char(*), char(*), char(*), fixed bin(35));
      393 	dcl     mdbm_util_$xref_dereference entry (ptr, char(*), char(*), char(*), fixed bin (21), char(*), fixed bin(35));
      394 	dcl     mdbm_util_$xref_find_record entry (ptr, char(*), char(*), ptr, fixed bin(21), char(*), fixed bin(35));
      395 	dcl     mrds_error_$no_db_path fixed bin (35) ext static;
      396 	dcl     mrds_error_$no_model_rel fixed bin (35) ext static;
      397 	dcl     next_fi_ptr_offset	 bit (18);
      398 	dcl     null		 builtin;
      399 	dcl     NULL_OFFSET		 int static bit (18) unal init ((18)"1"b) options (constant);
      400 	dcl     prev_fi_ptr		 ptr;
      401 	dcl     ptr		 builtin;
      402 	dcl     quit		 condition;
      403 	dcl     quit_intercept_flag	 bit (1);
      404 	dcl     reference_count	 fixed bin (21);
      405 	dcl     rel		 builtin;
      406 	dcl     rel_name		 char (32);
      407 	dcl     rmdb_add_rmdb_history	 entry (ptr, fixed bin, char (32), fixed bin, char (32), char (500), fixed bin (35));
      408 	dcl     rtrim		 builtin;
      409 	dcl     saved_fi_ptr	 ptr;
      410 	dcl     sys_info$max_seg_size	 fixed bin(35) ext static;
      411 	dcl     terminate_file_	 entry (ptr, fixed bin(24), bit(*), fixed bin(35));
      412 	dcl     xref_iocb_ptr	 ptr;
      413 
      414      end rmdb_delete_relation;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/09/86  1235.2  rmdb_delete_relation.pl1          >spec>install>1237>rmdb_delete_relation.pl1
145          1    02/05/86  1416.4  mrds_start_transaction.incl.pl1   >ldd>include>mrds_start_transaction.incl.pl1
1-79         2    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
1-81         3    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
171          4    02/05/86  1416.4  mrds_finish_transaction.incl.pl1  >ldd>include>mrds_finish_transaction.incl.pl1
355          5    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
357          6    10/17/86  1404.3  mdbm_db_model.incl.pl1            >ldd>include>mdbm_db_model.incl.pl1
359          7    10/17/86  1404.5  mdbm_file_model.incl.pl1          >ldd>include>mdbm_file_model.incl.pl1
361          8    10/17/86  1404.4  mrds_rmdb_ctl.incl.pl1            >ldd>include>mrds_rmdb_ctl.incl.pl1
8-46         9    10/17/86  1404.6  rmdb_relmgr_entries.incl.pl1      >ldd>include>rmdb_relmgr_entries.incl.pl1
363         10    10/17/86  1404.6  rmdb_crossref_info.incl.pl1       >ldd>include>rmdb_crossref_info.incl.pl1
365         11    10/14/83  1609.0  rmdb_delete_rel_info.incl.pl1     >ldd>include>rmdb_delete_rel_info.incl.pl1
367         12    10/17/86  1404.4  rmdb_history_entry.incl.pl1       >ldd>include>rmdb_history_entry.incl.pl1
369         13    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTRIBUTE_KEY_HEAD              000006 constant        char(10)                 initial unaligned dcl 10-31 set ref 243*
DOMAIN_KEY_HEAD                 000004 constant        char(7)                  initial unaligned dcl 10-32 set ref 265*
I_rmdb_ctl_ptr                         parameter       pointer                  dcl 62 ref 22 76 86
I_rmdb_delete_rel_info_ptr             parameter       pointer                  dcl 63 ref 22 76 83
NULL_OFFSET                            constant        bit(18)                  initial unaligned dcl 399 ref 192 192 240 249 277
                                                                                  278
O_err_code                             parameter       fixed bin(35,0)          dcl 64 set ref 22 76 110* 167 170 173* 349*
O_err_msg                              parameter       char                     unaligned dcl 65 set ref 22 76 109* 174* 350*
RELATION_KEY_HEAD               000001 constant        char(9)                  initial unaligned dcl 10-33 set ref 308*
RMDB_DELETE_REL_INFO_VERSION_1         constant        fixed bin(17,0)          initial dcl 11-24 ref 88
RMDB_DEL_REL_OP                 000041 constant        fixed bin(17,0)          initial dcl 12-51 set ref 158*
RMDB_REL_TYPE                   000037 constant        fixed bin(17,0)          initial dcl 12-47 set ref 158*
R_ACCESS                        000033 constant        bit(3)                   initial unaligned dcl 5-11 set ref 229*
TERM_FILE_DELETE                000000 constant        bit(5)                   initial unaligned dcl 13-17 set ref 133*
TM_NORMAL_MODE                  000042 constant        fixed bin(17,0)          initial dcl 2-15 set ref 1-99*
absolute_db_path          1            based           char(168)                level 2 in structure "rmdb_delete_rel_info"
                                                                                  dcl 11-15 in procedure "rmdb_delete_relation" ref
                                                                                  106
absolute_db_path          6            based           char(168)                level 2 in structure "rmdb_ctl" packed unaligned
                                                                                  dcl 8-25 in procedure "rmdb_delete_relation" set
                                                                                  ref 219*
addr                                                   builtin function         dcl 371 ref 1-123 1-123 264
adjust_bit_count_               000040 constant        entry                    external dcl 372 ref 314
ai_ptr                          000160 automatic       pointer                  dcl 7-209 set ref 240* 240* 243 258 259 275 276* 286
any_other                       000170 stack reference condition                dcl 373 ref 144
attr_info                              based           structure                level 1 dcl 7-192
attr_ptr                 24(18)        based           bit(18)                  level 2 packed unaligned dcl 7-126 ref 240
based_char8                            based           char(8)                  unaligned dcl 374 set ref 117*
bcnt                            000176 automatic       fixed bin(35,0)          dcl 375 set ref 314*
brief                    66            based           bit(1)                   level 2 packed unaligned dcl 11-15 set ref 115* 115
                                                                                  165 230 306 309
cleanup                         000200 stack reference condition                dcl 376 ref 143
cleanup_entry_point             000206 automatic       bit(1)                   unaligned dcl 377 set ref 69* 78* 158 209
code                            000207 automatic       fixed bin(35,0)          dcl 378 set ref 133* 134 136 136* 137* 148* 149 150
                                                                                  150* 151* 158* 219* 222 222* 229* 230 235* 243*
                                                                                  245 245* 265* 267 267* 306 306* 308* 309 309 309*
                                                                                  314*
condition_info                         based           structure                level 1 dcl 3-14
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 1-77 set ref 1-124 1-129 1-129
continue_to_signal_             000010 constant        entry                    external dcl 1-61 ref 1-137
count                     1            based           fixed bin(21,0)          level 2 dcl 10-19 ref 269
crossref_file_info      140            based           structure                level 2 unaligned dcl 8-25
crossref_info_record                   based           structure                level 1 unaligned dcl 10-19
crossref_info_record_ptr        000164 automatic       pointer                  dcl 10-17 set ref 264* 265* 269
db_model                               based           structure                level 1 dcl 6-72
db_model_ptr             54            based           pointer                  level 2 dcl 11-15 ref 92 107
db_path                         000210 automatic       char(168)                unaligned dcl 379 set ref 106* 112 137 148* 151 229*
                                                                                  314
db_type_flags             0(18)        based           structure                level 2 packed unaligned dcl 6-72
dbm_area                 34            based           area                     level 2 dcl 6-72 ref 273
dbm_ptr                         000144 automatic       pointer                  dcl 6-106 set ref 107* 154* 158* 192 192 192 203
                                                                                  209* 219* 249 249 253 258 273 281 292 298 303 303
                                                                                  304 304
delete_relation         156            based           entry variable           level 3 dcl 8-25 ref 148
di_ptr                          000150 automatic       pointer                  dcl 6-155 set ref 258* 259 265 269
dm_error_$bj_journal_full       000030 external static fixed bin(35,0)          dcl 4-52 ref 1-132
dm_error_$lock_deadlock         000032 external static fixed bin(35,0)          dcl 4-53 ref 4-78 1-126
dm_error_$no_current_transaction
                                000012 external static fixed bin(35,0)          dcl 1-62 ref 1-90
domain_info                            based           structure                level 1 dcl 6-125
domain_ptr               10            based           bit(18)                  level 2 in structure "unreferenced_attribute" packed
                                                                                  unaligned dcl 6-159 in procedure
                                                                                  "rmdb_delete_relation" set ref 276*
domain_ptr               17            based           bit(18)                  level 2 in structure "attr_info" packed unaligned
                                                                                  dcl 7-192 in procedure "rmdb_delete_relation" ref
                                                                                  258 276
err_code                               parameter       fixed bin(35,0)          dcl 345 ref 343 349
err_message                            parameter       char                     unaligned dcl 346 ref 343 350
error_table_$action_not_performed
                                000042 external static fixed bin(35,0)          dcl 380 set ref 97*
error_table_$no_record          000046 external static fixed bin(35,0)          dcl 382 ref 309
error_table_$noentry            000044 external static fixed bin(35,0)          dcl 381 ref 136 150
error_table_$unimplemented_version
                                000050 external static fixed bin(35,0)          dcl 383 set ref 88*
exists                                 parameter       bit(1)                   unaligned dcl 182 set ref 180 190* 192 198* 205 232*
                                                                                  290 294*
exists_in_db_model              000262 automatic       bit(1)                   unaligned dcl 384 set ref 114* 129* 131 165
fi_ptr                          000146 automatic       pointer                  dcl 6-119 in procedure "rmdb_delete_relation" set
                                                                                  ref 192* 192* 197 199 201* 203
fi_ptr                   22(27)        based           bit(18)                  level 2 in structure "file_model" packed unaligned
                                                                                  dcl 7-40 in procedure "rmdb_delete_relation" ref
                                                                                  292
file_info                              based           structure                level 1 dcl 6-113 set ref 293 312
file_model                             based           structure                level 1 dcl 7-40
file_model_name                 000263 automatic       char(32)                 unaligned dcl 385 set ref 228* 229* 235
file_name                              based           char(30)                 level 2 dcl 6-113 ref 197
file_ptr                 22            based           bit(18)                  level 2 packed unaligned dcl 6-72 set ref 192 192
                                                                                  298*
find_condition_info_            000014 constant        entry                    external dcl 1-64 ref 1-123
fm_ptr                          000154 automatic       pointer                  dcl 7-108 set ref 133* 229* 238 238 240 286 292
fwd_ptr                  11            based           bit(18)                  level 2 packed unaligned dcl 6-113 set ref 203 207
                                                                                  301*
fwd_thread               20            based           bit(18)                  level 2 in structure "attr_info" packed unaligned
                                                                                  dcl 7-192 in procedure "rmdb_delete_relation" ref
                                                                                  286
fwd_thread               10(18)        based           bit(18)                  level 2 in structure "unreferenced_attribute" packed
                                                                                  unaligned dcl 6-159 in procedure
                                                                                  "rmdb_delete_relation" set ref 253 278* 283*
initiate_file_                  000052 constant        entry                    external dcl 387 ref 229
iocb_ptr                140            based           pointer                  level 3 dcl 8-25 set ref 217 219* 224
last_ua_ptr                     000526 automatic       pointer                  dcl 183 set ref 237* 248* 252* 281 283
long_err_msg                    000273 automatic       char(500)                unaligned dcl 388 set ref 158* 219* 222* 243* 245*
                                                                                  265* 267* 306* 308* 309*
mdbm_util_$inconsistent_reset   000054 constant        entry                    external dcl 389 ref 154
mdbm_util_$inconsistent_set     000056 constant        entry                    external dcl 390 ref 209
mdbm_util_$xref_build           000060 constant        entry                    external dcl 391 ref 219
mdbm_util_$xref_delete_record   000062 constant        entry                    external dcl 392 ref 308
mdbm_util_$xref_dereference     000064 constant        entry                    external dcl 393 ref 243
mdbm_util_$xref_find_record     000066 constant        entry                    external dcl 394 ref 265
mftxn_code                      000142 automatic       fixed bin(35,0)          dcl 4-54 set ref 167* 170* 4-62* 4-65 4-68* 4-69
                                                                                  4-78 4-115 173 1-126* 1-132*
mftxn_temp_code                 000143 automatic       fixed bin(35,0)          dcl 4-55 set ref 4-71* 4-72 4-72* 4-82* 4-83 4-85*
                                                                                  4-86 4-86* 4-96* 4-97 4-99* 4-100 4-100* 4-109*
                                                                                  4-110 4-110*
mrds_error_$no_db_path          000070 external static fixed bin(35,0)          dcl 395 set ref 112*
mrds_error_$no_model_rel        000072 external static fixed bin(35,0)          dcl 396 set ref 165* 167
mstxn_code                      000100 automatic       fixed bin(35,0)          dcl 1-65 set ref 94* 95 1-83* 1-89* 1-90 1-99* 1-140
                                                                                  1-140* 4-90* 4-104* 1-137*
mstxn_condition_info            000110 automatic       structure                level 1 unaligned dcl 1-77 set ref 1-123 1-123
mstxn_retries                   000101 automatic       fixed bin(17,0)          dcl 1-66 set ref 1-88* 4-78 4-81* 4-81
mstxn_temp_code                 000102 automatic       fixed bin(35,0)          dcl 1-67 set ref 1-109* 1-110 1-110* 1-123*
mstxn_transactions_needed       000103 automatic       bit(1)                   dcl 1-68 set ref 93* 103* 1-86
mstxn_txn_id                    000105 automatic       bit(36)                  dcl 1-70 set ref 87* 94* 96* 104* 1-84* 1-89* 1-93
                                                                                  1-94* 1-99* 1-100 4-60 4-68* 4-71* 4-72* 4-82*
                                                                                  4-85* 4-86* 4-96* 4-99* 4-100* 4-109* 4-110*
                                                                                  4-114* 1-107 1-109* 1-110* 1-121
name                                   based           char(32)                 level 2 in structure "attr_info" dcl 7-192
                                                                                  in procedure "rmdb_delete_relation" ref 243 259
                                                                                  275
name                                   based           char(32)                 level 2 in structure "domain_info" dcl 6-125
                                                                                  in procedure "rmdb_delete_relation" ref 259 265
name                    142            based           char(32)                 level 3 in structure "rmdb_ctl" packed unaligned
                                                                                  dcl 8-25 in procedure "rmdb_delete_relation" set
                                                                                  ref 219*
name                                   based           char(32)                 level 2 in structure "unreferenced_attribute"
                                                                                  dcl 6-159 in procedure "rmdb_delete_relation" set
                                                                                  ref 275*
next_fi_ptr_offset              000470 automatic       bit(18)                  unaligned dcl 397 set ref 207* 298 301
null                                                   builtin function         dcl 398 ref 1-123 1-123 186 217 226 237 248 281 298
num_rels                 14            based           fixed bin(17,0)          level 2 packed unaligned dcl 6-72 set ref 304* 304
num_unblk_files          13(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 6-72 set ref 303* 303
prev_fi_ptr                     000472 automatic       pointer                  dcl 400 set ref 186* 201* 298 301
ptr                                                    builtin function         dcl 401 ref 192 203 238 240 249 253 258 286 292
quit                            000474 stack reference condition                dcl 402 ref 125 161 163
quit_intercept_flag             000502 automatic       bit(1)                   unaligned dcl 403 set ref 123* 125* 163
record_buffer                   000530 automatic       bit(72)                  unaligned dcl 184 set ref 264
reference_count                 000503 automatic       fixed bin(21,0)          dcl 404 set ref 243* 247
rel                                                    builtin function         dcl 405 ref 192 240 249 281 283
rel_info                               based           structure                level 1 dcl 7-126
rel_name                        000504 automatic       char(32)                 unaligned dcl 406 set ref 108* 137 1-140 148* 151
                                                                                  158 165 174 197 209 209 228 243* 308*
rel_ptr                  20(27)        based           bit(18)                  level 2 packed unaligned dcl 7-40 ref 238
relation_name            56            based           char(32)                 level 2 dcl 11-15 ref 108
relmgr_entries          152            based           structure                level 2 unaligned dcl 8-25
ri_ptr                          000156 automatic       pointer                  dcl 7-185 set ref 238* 240
rmdb_add_rmdb_history           000074 constant        entry                    external dcl 407 ref 158
rmdb_ctl                               based           structure                level 1 unaligned dcl 8-25
rmdb_ctl_ptr                    000162 automatic       pointer                  dcl 8-43 set ref 86* 117 148 217 219 219 219 219 224
rmdb_delete_rel_info                   based           structure                level 1 dcl 11-15
rmdb_delete_rel_info_ptr        000166 automatic       pointer                  dcl 11-23 set ref 83* 88 92 106 107 108 115 115 165
                                                                                  230 306 309
rmdb_relmgr_entries                    based           structure                level 1 unaligned dcl 9-18
rtrim                                                  builtin function         dcl 408 ref 108 137 1-140 151 174 228
saved_fi_ptr                    000514 automatic       pointer                  dcl 409 set ref 199* 207 292* 293 312
saved_res_version_ptr
                        136            based           pointer                  level 2 dcl 8-25 ref 117
temp_dir_path            60            based           char(168)                level 2 packed unaligned dcl 8-25 set ref 219*
terminate_file_                 000076 constant        entry                    external dcl 411 ref 133
transaction_manager_$abandon_txn
                                000016 constant        entry                    external dcl 1-72 ref 4-72 4-86 4-100 4-110 1-110
transaction_manager_$abort_txn  000020 constant        entry                    external dcl 1-73 ref 4-71 4-85 4-99 4-109 1-109
transaction_manager_$begin_txn  000022 constant        entry                    external dcl 1-74 ref 1-99
transaction_manager_$commit_txn 000034 constant        entry                    external dcl 4-56 ref 4-68
transaction_manager_$get_current_txn_id
                                000024 constant        entry                    external dcl 1-75 ref 94 1-89
transaction_manager_$handle_conditions
                                000026 constant        entry                    external dcl 1-76 ref 1-135
transaction_manager_$rollback_txn
                                000036 constant        entry                    external dcl 4-57 ref 4-82 4-96
transactions_needed       0(34)        based           bit(1)                   level 3 packed unaligned dcl 6-72 ref 92
ua_ptr                          000152 automatic       pointer                  dcl 6-165 set ref 249* 249* 252* 253 273* 275 276
                                                                                  277 278 281 283
unreferenced             10(04)        based           bit(1)                   level 2 packed unaligned dcl 6-125 set ref 269*
unreferenced_attribute                 based           structure                level 1 dcl 6-159 set ref 273
unreferenced_attribute_ptr
                         23            based           bit(18)                  level 2 packed unaligned dcl 6-72 set ref 249 281*
unused                   11            based           bit(18)                  array level 2 packed unaligned dcl 6-159 set ref
                                                                                  277*
user_started_transaction        000104 automatic       bit(1)                   dcl 1-69 set ref 1-92* 1-98* 4-60
user_transaction_id             000106 automatic       bit(36)                  dcl 1-71 set ref 1-93* 1-100*
version                                based           fixed bin(17,0)          level 2 dcl 11-15 ref 88
xref_iocb_ptr                   000516 automatic       pointer                  dcl 412 set ref 224* 226 243* 265* 308*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-33
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 2-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 2-12
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
OBJECT_HEAD                            internal static char(1)                  initial unaligned dcl 10-29
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
RMDB_ADD_ATTR_OP                       internal static fixed bin(17,0)          initial dcl 12-54
RMDB_ADD_DMN_OP                        internal static fixed bin(17,0)          initial dcl 12-56
RMDB_ADD_IDX_OP                        internal static fixed bin(17,0)          initial dcl 12-52
RMDB_ADD_REL_OP                        internal static fixed bin(17,0)          initial dcl 12-50
RMDB_ATTR_TYPE                         internal static fixed bin(17,0)          initial dcl 12-46
RMDB_CTL_VERSION_1                     internal static fixed bin(17,0)          initial dcl 8-41
RMDB_DEL_ATTR_OP                       internal static fixed bin(17,0)          initial dcl 12-55
RMDB_DEL_DMN_OP                        internal static fixed bin(17,0)          initial dcl 12-57
RMDB_DEL_IDX_OP                        internal static fixed bin(17,0)          initial dcl 12-53
RMDB_DOMAIN_TYPE                       internal static fixed bin(17,0)          initial dcl 12-45
RMDB_RN_ATTR_OP                        internal static fixed bin(17,0)          initial dcl 12-58
RMDB_RN_DMN_OP                         internal static fixed bin(17,0)          initial dcl 12-59
RMDB_RN_REL_OP                         internal static fixed bin(17,0)          initial dcl 12-60
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
TERM_FILE_BC                           internal static bit(2)                   initial unaligned dcl 13-12
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 13-16
TERM_FILE_TERM                         internal static bit(3)                   initial unaligned dcl 13-14
TERM_FILE_TRUNC                        internal static bit(1)                   initial unaligned dcl 13-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial unaligned dcl 13-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial unaligned dcl 13-15
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 2-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 2-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 2-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 2-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 2-20
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
al_ptr                                 automatic       pointer                  dcl 7-345
alloc_length                           internal static fixed bin(35,0)          dcl 6-222
atd                                    based           char                     unaligned dcl 7-109
atd_len                                automatic       fixed bin(17,0)          dcl 7-111
atd_ptr                                automatic       pointer                  dcl 7-110
attr_list                              based           structure                level 1 dcl 7-341
attribute                              based           structure                level 1 unaligned dcl 10-99
attribute_count                        automatic       fixed bin(17,0)          dcl 10-98
attribute_list                         based           structure                level 1 unaligned dcl 10-55
attribute_list_count                   automatic       fixed bin(17,0)          dcl 10-53
attribute_list_names                   based           char                     unaligned dcl 10-54
attribute_list_ptr                     automatic       pointer                  dcl 10-52
attribute_ptr                          automatic       pointer                  dcl 10-97
changer                                based           structure                level 1 packed unaligned dcl 6-251
changer_ptr                            automatic       pointer                  dcl 6-256
child_link_info                        based           structure                level 1 dcl 7-283
cli_ptr                                automatic       pointer                  dcl 7-329
cna_ptr                                automatic       pointer                  dcl 7-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 7-112
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
constant                               based           structure                level 1 unaligned dcl 6-216
constant_ptr                           automatic       pointer                  dcl 6-220
crossref_info_record_count             automatic       fixed bin(21,0)          dcl 10-18
crossref_info_record_objects           based           char                     unaligned dcl 10-27
domain_list                            based           structure                level 1 unaligned dcl 10-45
domain_list_count                      automatic       fixed bin(17,0)          dcl 10-43
domain_list_names                      based           char                     unaligned dcl 10-44
domain_list_ptr                        automatic       pointer                  dcl 10-42
dp_ptr                                 automatic       pointer                  dcl 7-356
dup_prev                               based           structure                level 1 dcl 7-353
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 1-63
fixed                                                  builtin function         dcl 386
message_str                            based           structure                level 1 packed unaligned dcl 6-259
message_str_len                        automatic       fixed bin(17,0)          dcl 6-269
message_str_ptr                        automatic       pointer                  dcl 6-267
ncomp_init                             automatic       fixed bin(17,0)          dcl 7-116
parent_link_info                       based           structure                level 1 dcl 7-223
path_entry                             based           structure                level 1 packed unaligned dcl 6-172
path_entry_ptr                         automatic       pointer                  dcl 6-177
pli_ptr                                automatic       pointer                  dcl 7-268
relation                               based           structure                level 1 unaligned dcl 10-77
relation_attribute_count               automatic       fixed bin(17,0)          dcl 10-75
relation_attribute_names               based           char                     unaligned dcl 10-76
relation_list                          based           structure                level 1 unaligned dcl 10-67
relation_list_count                    automatic       fixed bin(17,0)          dcl 10-65
relation_list_names                    based           char                     unaligned dcl 10-66
relation_list_ptr                      automatic       pointer                  dcl 10-64
relation_ptr                           automatic       pointer                  dcl 10-74
rmdb_history_entry                     based           structure                level 1 dcl 12-31
rmdb_history_entry_ptr                 automatic       pointer                  dcl 12-42
rmdb_relmgr_entries_ptr                automatic       pointer                  dcl 9-32
sc_ptr                                 automatic       pointer                  dcl 7-365
select_chain                           based           structure                level 1 dcl 7-357
sk_ptr                                 automatic       pointer                  dcl 7-352
sort_key                               based           structure                level 1 dcl 7-346
stack_item                             based           structure                level 1 unaligned dcl 6-206
stack_item_ptr                         automatic       pointer                  dcl 6-212
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 410
terminate_file_switches                based           structure                level 1 packed unaligned dcl 13-4
version_status                         based           structure                level 1 packed unaligned dcl 6-232
version_status_ptr                     automatic       pointer                  dcl 6-246

NAMES DECLARED BY EXPLICIT CONTEXT.
cleanup                         000247 constant        entry                    external dcl 76
common                          000265 constant        label                    dcl 83 ref 70 79
error                           002765 constant        entry                    internal dcl 343 ref 88 97 112 137 1-140 151 165 222
                                                                                  235 245 267 306 309
exit                            001206 constant        label                    dcl 167 ref 351
mftxn_check_code                001225 constant        label                    dcl 4-65 ref 1-127 1-133
mftxn_exit                      001445 constant        label                    dcl 4-115 ref 4-63
mstxn_any_other                 001546 constant        entry                    internal dcl 1-116 ref 144
mstxn_cleanup                   001514 constant        entry                    internal dcl 1-102 ref 143
mstxn_exit                      000724 constant        label                    dcl 1-140 ref 1-86 1-95 4-91 4-105
not_in_model                    002072 constant        label                    dcl 224 ref 205
restore_significant_data        002753 constant        entry                    internal dcl 328 ref 4-77
rmdb_delete_relation            000230 constant        entry                    external dcl 22
should_rollback                 002755 constant        entry                    internal dcl 334 ref 4-94
unlink_relation                 001643 constant        entry                    internal dcl 180 ref 129

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3460        3560    3034        3470
Length      4306    3034       100         511     423           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rmdb_delete_relation                538 external procedure  is an external procedure.  
on unit on line 125                  64 on unit               
on unit on line 143                  76 on unit               
on unit on line 144                  82 on unit               
mstxn_cleanup                           internal procedure  shares stack frame of on unit on line 143.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 144.  
unlink_relation                         internal procedure  shares stack frame of external procedure rmdb_delete_relation.  
restore_significant_data                internal procedure  shares stack frame of external procedure rmdb_delete_relation.  
should_rollback                         internal procedure  shares stack frame of external procedure rmdb_delete_relation.  
error                                65 internal procedure  is called during a stack extension.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rmdb_delete_relation     000100 mstxn_code                  rmdb_delete_relation
                         000101 mstxn_retries               rmdb_delete_relation
                         000102 mstxn_temp_code             rmdb_delete_relation
                         000103 mstxn_transactions_needed   rmdb_delete_relation
                         000104 user_started_transaction    rmdb_delete_relation
                         000105 mstxn_txn_id                rmdb_delete_relation
                         000106 user_transaction_id         rmdb_delete_relation
                         000110 mstxn_condition_info        rmdb_delete_relation
                         000142 mftxn_code                  rmdb_delete_relation
                         000143 mftxn_temp_code             rmdb_delete_relation
                         000144 dbm_ptr                     rmdb_delete_relation
                         000146 fi_ptr                      rmdb_delete_relation
                         000150 di_ptr                      rmdb_delete_relation
                         000152 ua_ptr                      rmdb_delete_relation
                         000154 fm_ptr                      rmdb_delete_relation
                         000156 ri_ptr                      rmdb_delete_relation
                         000160 ai_ptr                      rmdb_delete_relation
                         000162 rmdb_ctl_ptr                rmdb_delete_relation
                         000164 crossref_info_record_ptr    rmdb_delete_relation
                         000166 rmdb_delete_rel_info_ptr    rmdb_delete_relation
                         000176 bcnt                        rmdb_delete_relation
                         000206 cleanup_entry_point         rmdb_delete_relation
                         000207 code                        rmdb_delete_relation
                         000210 db_path                     rmdb_delete_relation
                         000262 exists_in_db_model          rmdb_delete_relation
                         000263 file_model_name             rmdb_delete_relation
                         000273 long_err_msg                rmdb_delete_relation
                         000470 next_fi_ptr_offset          rmdb_delete_relation
                         000472 prev_fi_ptr                 rmdb_delete_relation
                         000502 quit_intercept_flag         rmdb_delete_relation
                         000503 reference_count             rmdb_delete_relation
                         000504 rel_name                    rmdb_delete_relation
                         000514 saved_fi_ptr                rmdb_delete_relation
                         000516 xref_iocb_ptr               rmdb_delete_relation
                         000526 last_ua_ptr                 unlink_relation
                         000530 record_buffer               unlink_relation

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ext_out_desc   call_ext_out        call_int_this_desc
return_mac          tra_ext_1           signal_op           enable_op           shorten_stack       ext_entry_desc
int_entry           int_entry_desc      op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
adjust_bit_count_             continue_to_signal_           find_condition_info_          initiate_file_
mdbm_util_$inconsistent_reset mdbm_util_$inconsistent_set   mdbm_util_$xref_build         mdbm_util_$xref_delete_record
mdbm_util_$xref_dereference   mdbm_util_$xref_find_record   rmdb_add_rmdb_history         terminate_file_
transaction_manager_$abandon_txn                            transaction_manager_$abort_txn
transaction_manager_$begin_txn                              transaction_manager_$commit_txn
transaction_manager_$get_current_txn_id                     transaction_manager_$handle_conditions
transaction_manager_$rollback_txn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$lock_deadlock       dm_error_$no_current_transaction
error_table_$action_not_performed                           error_table_$no_record        error_table_$noentry
error_table_$unimplemented_version                          mrds_error_$no_db_path        mrds_error_$no_model_rel




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     22 000223        69 000243        70 000244        76 000245        78 000262        79 000264        83 000265
     86 000271        87 000274        88 000275        92 000320        93 000324        94 000326        95 000337
     96 000341        97 000342       102 000362       103 000363       104 000364       106 000365       107 000371
    108 000373       109 000407       110 000415       112 000416       114 000437       115 000440       117 000445
    123 000452       125 000453       129 000473       131 000475       133 000500       134 000526       136 000530
    137 000535       138 000617       143 000620       144 000636    1   83 000654    1   84 000655    1   86 000656
 1   88 000660    1   89 000661    1   90 000672    1   92 000676    1   93 000700    1   94 000702    1   95 000703
 1   98 000704    1   99 000705    1  100 000722    1  140 000724       148 001000       149 001022       150 001024
    151 001031       152 001103       154 001104       158 001113       161 001146       163 001147       165 001154
    167 001206       170 001215    4   60 001216    4   62 001223    4   63 001224    4   65 001225    4   68 001227
 4   69 001240    4   71 001242    4   72 001253    4   75 001266    4   77 001267    4   78 001270    4   81 001277
 4   82 001300    4   83 001313    4   85 001315    4   86 001326    4   88 001341    4   90 001342    4   91 001343
 4   93 001344    4   94 001345    4   96 001352    4   97 001366    4   99 001370    4  100 001401    4  102 001414
 4  104 001415    4  105 001416    4  107 001417    4  109 001420    4  110 001431    4  114 001444    4  115 001445
    173 001447       174 001451       175 001512       176 001513    1  102 001514    1  107 001515    1  109 001520
 1  110 001531    1  114 001545    1  116 001546    1  121 001547    1  123 001552    1  124 001571    1  126 001577
 1  127 001602    1  129 001605    1  132 001617    1  133 001622    1  135 001625    1  136 001632    1  137 001633
 1  138 001642       180 001643       186 001645       190 001647       192 001653       197 001675       198 001702
    199 001705       200 001706       201 001707       203 001710       205 001716       207 001724       209 001730
    217 002007       219 002015       222 002054       224 002072       226 002075       228 002102       229 002130
    230 002167       232 002175       233 002202       235 002203       237 002225       238 002227       240 002237
    243 002247       245 002314       247 002332       248 002334       249 002336       252 002347       253 002351
    258 002357       259 002365       264 002371       265 002373       267 002440       269 002456       271 002465
    273 002466       275 002474       276 002500       277 002502       278 002520       281 002522       283 002532
    286 002536       290 002545       292 002553       293 002563       294 002565       295 002572       298 002573
    301 002603       303 002606       304 002614       306 002621       308 002643       309 002674       312 002721
    314 002723       316 002752       328 002753       330 002754       334 002755       336 002757       343 002764
    349 003000       350 003005       351 003015


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
