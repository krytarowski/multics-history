	COMPILATION LISTING OF SEGMENT ge_parse_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/18/82  1658.6 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 ge_parse_: proc;
       12 
       13 /* A parser for command lines to graphic_editor.
       14*   Written 12/16/74 by C. D. Tavares. */
       15 /* Modified 08/14/75 by CDT to be clever in a different way about fake_area;
       16*   optimizer was generating insane "ic*" modifiers!! */
       17 /* Modified 10/20/75 by CDT to make newlines not be read as semicolons if last character on
       18*   input line was a comma. */
       19 /* Last modified 05/25/76 by CDT to make macro replacements get pushed instead of returned,
       20*   so one-to-many replacements would work (parenthesized macro args), and to correct problems
       21*   with termination/non-termination of segments from which parse input strings are read. */
       22 
       23 	return;
       24 
       25 init:	entry;
       26 
       27 dcl 1 in_use aligned static,
       28     2 stringp pointer initial (null),			/* pointer to string to be parsed */
       29     2 string_len fixed bin (21) initial (0),		/* length of string to be parsed */
       30     2 cur_char fixed bin (21) initial (1),		/* position at which to begin next parse */
       31     2 backup_sw bit (1) aligned initial (""b),		/* return old token, not new one */
       32     2 spaces_found bit (1) aligned initial (""b),		/* last character was a separator */
       33     2 already_got_rest bit (1) aligned initial (""b),	/* can't get rest_of_line twice */
       34     2 terminate_when_done bit (1) aligned initial (""b),	/* terminate (read) segment when done with it */
       35     2 info_ptr pointer initial (null),			/* pointer to macro args initial (null), if any */
       36     2 previous_type fixed bin,			/* type of previous token */
       37     2 previous_token char (200) varying initial ("");	/* previous token itself */
       38 
       39 dcl  level fixed bin initial (0) static;
       40 
       41 dcl (Dont_terminate initial ("0"b),
       42      Do_terminate initial ("1"b)) bit (1) static options (constant);
       43 
       44 dcl 1 stack (0:20) static aligned,
       45     2 stringp pointer,			/* pointer to string to be parsed */
       46     2 string_len fixed bin (21),		/* length of string to be parsed */
       47     2 cur_char fixed bin (21),		/* position at which to begin next parse */
       48     2 backup_sw bit (1) aligned,		/* return old token, not new one */
       49     2 spaces_found bit (1) aligned,		/* last character was a separator */
       50     2 already_got_rest bit (1) aligned,	/* can't get rest_of_line twice */
       51     2 terminate_when_done bit (1) aligned,	/* terminate (read) segment when done with it */
       52     2 info_ptr pointer,			/* pointer to macro args initial (null), if any */
       53     2 previous_type fixed bin,			/* type of previous token */
       54     2 previous_token char (200) varying;	/* previous token itself */
       55 
       56 	do level = 0 to 20;		/* initialize the array stack (0:20) */
       57 	     stack (level) = in_use;
       58 	end;
       59 	level = 0;		/*do housekeeping and set back to 0*/
       60 
       61 
       62 	do level = level to 1 by -1;			/* terminate leftover pointers if any */
       63 	     if stack (level).terminate_when_done then
       64 		call hcs_$terminate_noname (stack (level).stringp, code);
       65 
       66 	     else if stack (level).info_ptr ^= null then
       67 		free stack (level).info_ptr -> macro_info in (fake_area);
       68 	end;
       69 
       70 	in_use.stringp = null;
       71 	in_use.string_len = 0;
       72 	in_use.cur_char = 1;
       73 	in_use.backup_sw, in_use.already_got_rest = ""b;
       74 	in_use.info_ptr = null;
       75 	in_use.previous_token = "";
       76 	in_use.terminate_when_done = ""b;
       77 	level = 0;
       78 	return;
       79 
       80 	
       81 push_string: entry (stringp_arg, string_len_arg);		/* gives parser a string to parse */
       82 
       83 dcl  stringp_arg pointer parameter,
       84      string_len_arg fixed bin (21) parameter;
       85 
       86 	call common_push (stringp_arg, string_len_arg, null, Dont_terminate);
       87 
       88 common_push: proc (stringp_arg, string_len_arg, info_ptr, terminate_switch);
       89 
       90 dcl  stringp_arg pointer parameter,
       91      string_len_arg fixed bin (21) parameter,
       92      info_ptr pointer parameter,
       93      terminate_switch bit (1) parameter;
       94 
       95 	     level = max (0, level);
       96 	     in_use.already_got_rest = ""b;
       97 	     stack (level) = in_use;
       98 	     level = level + 1;
       99 	     if level > hbound (stack, 1) then signal subscriptrange;
      100 	     in_use.stringp = stringp_arg;		/* copy args into static */
      101 	     in_use.string_len = string_len_arg;
      102 	     in_use.cur_char = 1;			/* initialize other important variables */
      103 	     in_use.info_ptr = info_ptr;
      104 	     in_use.already_got_rest, in_use.backup_sw = ""b;
      105 	     in_use.terminate_when_done = terminate_switch;
      106 	     stack (level) = in_use;
      107 	     return;
      108 	end common_push;
      109 
      110 	return;
      111 
      112 	
      113 push_string_and_terminate: entry (stringp_arg, string_len_arg);
      114 
      115 	call common_push (stringp_arg, string_len_arg, null, Do_terminate);
      116 	return;
      117 	
      118 push_macro: entry (stringp_arg, string_len_arg, info_ptr_arg);
      119 
      120 dcl  info_ptr_arg pointer;
      121 
  1     1 /* --------------- BEGIN include file ge_macro_info.incl.pl1 --------------- */
  1     2 
  1     3 dcl 1 macro_info based,
  1     4     2 n_args fixed bin,
  1     5     2 x (n_macro_args refer (macro_info.n_args)),
  1     6       3 argument char (32) varying,
  1     7       3 replacement char (1020) varying;
  1     8 
  1     9 dcl  replacement_string_size fixed bin static initial (1020) options (constant);
  1    10 
  1    11 dcl 1 based_varying_string aligned based,
  1    12     2 somelength fixed bin (35),
  1    13     2 string char (0 refer (somelength)) aligned;
  1    14 
  1    15 dcl  n_macro_args fixed bin;
  1    16 
  1    17 dcl  macro_def char (200) varying;
  1    18 
  1    19 dcl  macro_info_p pointer;
  1    20 
  1    21 dcl  based_macro_bits bit (macro_bits_l) based (macro_bits_p),
  1    22      macro_bits_p pointer,
  1    23      macro_bits_l fixed bin;
  1    24 
  1    25 dcl  based_macro_arg char (32) based;
  1    26 
  1    27 /* ---------------- END include file ge_macro_info.incl.pl1 ---------------- */
      122 
      123 
      124 dcl  fake_area area based (fake_area_p),
      125      fake_area_p pointer;
      126 
      127 	call common_push (stringp_arg, string_len_arg, info_ptr_arg, Dont_terminate);
      128 	return;
      129 	
      130 get_token: entry (token, type, ignore_nl);		/* returns next token and type */
      131 
      132 dcl  token char (*) varying parameter,			/* token to be returned */
      133      type fixed bin parameter,			/* type of returned token */
      134      ignore_nl fixed bin parameter;
      135 
  2     1 /* --------------- BEGIN include file ge_token_types.incl.pl1 --------------- */
  2     2 
  2     3 dcl (Illegal initial (-2),
  2     4      Undefined initial (-1),
  2     5      Name initial (1),
  2     6      Break initial (2),
  2     7      Number initial (3)) fixed bin static;
  2     8 
  2     9 /* ---------------- END include file ge_token_types.incl.pl1 ---------------- */
      136 
      137 
      138 dcl (null, substr, index, search, verify) builtin;
      139 
      140 dcl  subscriptrange condition;
      141 
      142 dcl  NL char (1) static initial ("
      143 ");
      144 
      145 dcl (i, j) fixed bin (21);				/* hack variables */
      146 
      147 dcl  octal_sw bit (1) aligned,
      148      ioa_$rsnnl ext entry options (variable),
      149      cv_oct_ ext entry (char (*)) returns (fixed bin);
      150 
      151 dcl  junk float bin,
      152      code fixed bin (35);
      153 
      154 dcl  com_err_ ext entry options (variable),
      155      cv_float_ ext entry (char (*), fixed bin (35)) returns (float bin),
      156      ioa_ ext entry options (variable);
      157 
      158 dcl  based_string char (1044480) based (in_use.stringp),	/* two templates for overlaying token */
      159      based_string_array (1044480) char (1) unaligned based (in_use.stringp);
      160 
      161 dcl  terminators char (2) aligned static initial (";
      162 "),						/* semi and NL can terminate lines */
      163      separator_table char (2) initial ("	 ") static,	/* tab and space can separate tokens */
      164      alphanumeric_table char (63) static initial		/* these chars only may comprise single names */
      165     ("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_"),
      166      numeric_table char (11) static initial ("1234567890.");
      167 
      168 dcl  iox_$get_line ext entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
      169      iox_$user_input ext pointer,
      170      buffer char (200) aligned static,
      171      nelemt fixed bin (21);
      172 
      173 dcl  hcs_$terminate_noname ext entry (pointer, fixed bin (35));
      174 
      175 dcl  temp_bit bit (1) aligned;
      176 
      177 dcl  template_string char (template_len) based (template_ptr), /* more overlays */
      178      template_ptr pointer,
      179      template_len fixed bin (21);
      180 
      181 	if in_use.backup_sw then do;			/* wants last token over again */
      182 is_backup:
      183 	     token = in_use.previous_token;		/* use previous token */
      184 	     type = in_use.previous_type;
      185 	     in_use.backup_sw = ""b;
      186 	     return;
      187 	end;
      188 
      189 	in_use.backup_sw = ""b;			/* kill indicator */
      190 	in_use.already_got_rest = ""b;
      191 
      192 	if level = 0 then if in_use.stringp = null then do; /* no string ever been given */
      193 read_another_line:
      194 		buffer = "";
      195 		call iox_$get_line (iox_$user_input, addr (buffer), length (buffer), nelemt, code);
      196 		if code ^= 0 then do;
      197 		     call com_err_ (code, "ge_parse_$get_token", "Attempting command read.");
      198 		     token = "***ERROR ON READ****";
      199 		     return;
      200 		end;
      201 		in_use.cur_char = 1;
      202 		in_use.stringp = addr (buffer);
      203 		in_use.string_len = nelemt;
      204 		level = 0;
      205 	     end;
      206 
      207 get_another_token:
      208 	if in_use.cur_char > in_use.string_len then do;	/* all done string */
      209 pop_stack:     if level = 0 then goto read_another_line;
      210 	     level = level - 1;
      211 	     in_use = stack (level);
      212 	     fake_area_p = null ();			/* just so as not to generate a link */
      213 						/* to free_.   Nobody really uses this anyway! */
      214 	     if stack (level+1).info_ptr ^= null then free stack (level+1).info_ptr -> macro_info in (fake_area);
      215 						/* keeps link to free_ from being generated */
      216 	     else do;
      217 		if stack (level+1).terminate_when_done then
      218 		     call hcs_$terminate_noname (stack (level+1).stringp, 0);
      219 		if level = 0
      220 		then if in_use.cur_char >= in_use.string_len
      221 		     then call ioa_ ("Edit.");
      222 	     end;
      223 
      224 	     if in_use.backup_sw then goto is_backup;
      225 
      226 	     goto get_another_token;
      227 	end;
      228 
      229 	type = Name;				/* assume next token will be name */
      230 
      231 	temp_bit = in_use.spaces_found;		/* save this info */
      232 	call strip_blanks;				/* otherwise leading blanks on new lines fail */
      233 	in_use.spaces_found = in_use.spaces_found | temp_bit; /* if spaces found after last or before this */
      234 
      235 	call setup_template;			/* lay template over current position */
      236 
      237 /* find next character which can not be part of a token.  This is the next break character. */
      238 /* set i to that char - 1, i.e. i = length of next good token. */
      239 
      240 	if in_use.spaces_found then do;		/* Next token may be true float number */
      241 	     if based_string_array (in_use.cur_char) = "." /* want to scan for numbers, but not a leading DP */
      242 	     then j = 1;				/* search for numbers from next char, not this one */
      243 	     else j = 0;				/* else try from first char */
      244 
      245 	     if index ("1234567890", based_string_array (in_use.cur_char + j)) > 0 then do; /* got a number */
      246 		i = verify (template_string, numeric_table) - 1; /* search for end of it */
      247 		type = Number;			/* for now, anyway */
      248 	     end;
      249 	end;
      250 
      251 	if type = Name then i = verify (template_string, alphanumeric_table) - 1; /* assume we have non-number */
      252 
      253 	if i = -1 then i = template_len;		/* rest of string */
      254 
      255 	else if i = 0 then do;			/* first char was a break, return that char instead */
      256 	     i = 1;
      257 	     type = Break;
      258 	end;
      259 
      260 	token = substr (based_string, in_use.cur_char, i); /* send it upstairs */
      261 
      262 /* Of course, something made up of "+-." and digits may not be a true number!
      263*   On the other hand, something which was not preceded by a space (which is a
      264*   necessary condition for being a float number in GE) may by an integer numeric qualifier.
      265*   So we prepare to see what the token REALLY is. */
      266 
      267 	if type = Break then code = 1;		/* no chance! */
      268 	else junk = cv_float_ ((token), code);		/* see what cv_float_ thinks of it */
      269 	if (code ^= 0 & type = Number) then type = Name;	/* was illegally constructed for a number */
      270 	else if (code = 0 & type = Name) then type = Number; /* was really an integer */
      271 
      272 	if token = NL
      273 	then if (ignore_nl ^= 0
      274 	     | (in_use.previous_token = ","))
      275 	     then do;
      276 		in_use.cur_char = in_use.cur_char + 1;
      277 		call strip_blanks;
      278 		goto get_another_token;
      279 	     end;
      280 	     else token = ";";
      281 
      282 	if i = 1 then do;				/* may be a special break char/sequence, check */
      283 
      284 	     if based_string_array (in_use.cur_char) = ";"
      285 	     then if based_string_array (in_use.cur_char+1) = NL /* no reason to ever return the NL then */
      286 		then in_use.cur_char = in_use.cur_char + 1; /* skip NL */
      287 		else;				/* nugatory */
      288 
      289 	     else if based_string_array (in_use.cur_char) = """" then do; /* oh oh, quoted string */
      290 		type = Name;
      291 		in_use.cur_char = in_use.cur_char + 1;	/* prepare to search */
      292 more_charstring:	call setup_template;
      293 		j = index (template_string, """");	/* find next occurrence of quote */
      294 		if j = 0 then j = template_len;	/* no matching quote, use rest of string */
      295 		token = token || substr (template_string, 1, j); /* conc rest of found string */
      296 		in_use.cur_char = in_use.cur_char + j - 1; /* set to what's done, is bumped by 1 later */
      297 		if in_use.cur_char > in_use.string_len then goto exit_block; /* ran out of parsables */
      298 		if based_string_array (in_use.cur_char+1) = """" then do; /* oops, last quote was part of double quote */
      299 		     in_use.cur_char = in_use.cur_char + 2; /* jump to next piece to be searched */
      300 		     goto more_charstring;		/* not concatenating, by the way, that other quote */
      301 		end;
      302 	     end;
      303 
      304 	     else if based_string_array (in_use.cur_char) = "/"
      305 	     then if based_string_array (in_use.cur_char+1) = "*" then do; /* is comment */
      306 		     j = index (template_string, "*/"); /* find closing of comment */
      307 		     if j = 0 then j = template_len - 1; /* no closing, use rest of string */
      308 		     in_use.cur_char = in_use.cur_char + j + 2;
      309 		     goto get_another_token;		/* ignore the comment */
      310 		end;
      311 
      312 		else;
      313 
      314 	     else if based_string_array (in_use.cur_char) = "#" then do;
      315 		type = Name;
      316 		call setup_template;
      317 		if based_string_array (in_use.cur_char+1) = "o" then do;
      318 		     octal_sw = "1"b;
      319 		     in_use.cur_char = in_use.cur_char + 1;
      320 		end;
      321 		else octal_sw = ""b;
      322 
      323 		in_use.cur_char = in_use.cur_char + 1;
      324 		call setup_template;
      325 
      326 		if octal_sw then j = verify (template_string, "01234567") -1;
      327 		else j = verify (template_string, "0123456789") - 1;
      328 
      329 		if j = -1 then j = template_len;
      330 
      331 		token = substr (based_string, in_use.cur_char, j);
      332 		in_use.cur_char = in_use.cur_char + j - 1; /* will be bumped by 1 later */
      333 
      334 		if octal_sw then do;
      335 		     j = cv_oct_ ((token));
      336 		     call ioa_$rsnnl ("^d", token, 0, j);
      337 		end;
      338 
      339 		token = "#" || token;
      340 	     end;
      341 
      342 exit_block: end;
      343 
      344 	in_use.cur_char = in_use.cur_char + i;		/* go to next char to be looked at */
      345 
      346 	call strip_blanks;
      347 
      348 strip_blanks: proc;
      349 	     call setup_template;			/* prepare to search */
      350 
      351 	     in_use.spaces_found = "1"b;
      352 
      353 	     i = verify (template_string, separator_table) - 1; /* skip all the blanks and tabs */
      354 	     if i = -1 then i = template_len;
      355 
      356 	     if i > 0 then in_use.cur_char = in_use.cur_char + i; /* if there were any */
      357 	     else if token = "-" | token = "+"
      358 	     then in_use.spaces_found = "1"b;
      359 	     else if token ^= ";" then in_use.spaces_found = ""b;
      360 
      361 	end strip_blanks;
      362 
      363 	in_use.previous_token = token;
      364 	in_use.previous_type = type;
      365 
      366 	if in_use.info_ptr = null then return;		/* no macro substitution to do */
      367 	if type = Break then return;
      368 
      369 /* Macro substitution is done here. */
      370 
      371 	do i = 1 to in_use.info_ptr -> macro_info.n_args
      372 		while (token ^= in_use.info_ptr -> macro_info.argument (i));
      373 	end;
      374 
      375 	if i > in_use.info_ptr -> macro_info.n_args then return; /* no match */
      376 
      377 	call common_push (addr (addr (in_use.info_ptr -> macro_info.replacement (i)) -> based_varying_string.string),
      378 	     length (in_use.info_ptr -> macro_info.replacement (i)), null, Dont_terminate);
      379 						/* we push it, because parenthesized macro args can
      380*						   contain more than one token */
      381 
      382 	in_use.spaces_found, stack (level).spaces_found = "1"b;
      383 						/* in case next thing is a float number, we can't substitute for part of pathnames. */
      384 	goto get_another_token;
      385 
      386 
      387 	
      388 backup:	entry;					/* to make us reuse last token */
      389 
      390 	in_use.backup_sw = "1"b;			/* say we want to reuse previous token */
      391 	return;
      392 
      393 
      394 	
      395 peek_rest_of_line: entry (token);			/* lookahead entry */
      396 
      397 dcl  peek_entry bit (1) aligned initial (""b);
      398 
      399 	peek_entry = "1"b;
      400 
      401 get_rest_of_line: entry (token);			/* so spaces, tabs, etc. remain significant */
      402 
      403 	if in_use.stringp = null then do;		/* no string set yet */
      404 rest_null:     token = "";
      405 	     return;
      406 	end;
      407 
      408 	if in_use.cur_char > in_use.string_len then goto rest_null;
      409 
      410 	if in_use.already_got_rest then goto rest_null;
      411 
      412 	call setup_template;			/* prepare to search */
      413 
      414 	i = search (template_string, terminators);	/* find first NL or semi */
      415 	if i = 0 then i = 1;
      416 	token = substr (based_string, in_use.cur_char, i-1); /* return string up to that point */
      417 
      418 	if peek_entry then return;
      419 
      420 	in_use.already_got_rest = "1"b;
      421 	in_use.backup_sw = ""b;
      422 
      423 	in_use.cur_char = in_use.cur_char + i;
      424 	call strip_blanks;
      425 	return;
      426 
      427 flush_rest_of_line: entry;
      428 
      429 	in_use.cur_char = in_use.string_len + 1;	/* force EOF */
      430 	in_use.backup_sw = ""b;
      431 	in_use.already_got_rest = ""b;
      432 	return;
      433 
      434 setup_template: proc;				/* to set up based search string */
      435 
      436 	     template_len = in_use.string_len - in_use.cur_char + 1; /* length of entire string remaining */
      437 	     template_len = max (template_len, 0);
      438 	     template_ptr = addr (based_string_array (in_use.cur_char)); /* pointer to unused portion of string */
      439 	     return;
      440 
      441 	end setup_template;
      442 
      443      end ge_parse_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/18/82  1626.8  ge_parse_.pl1                     >dumps>old>recomp>ge_parse_.pl1
122          1    11/02/77  1738.4  ge_macro_info.incl.pl1            >ldd>include>ge_macro_info.incl.pl1
136          2    08/27/75  1700.7  ge_token_types.incl.pl1           >ldd>include>ge_token_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Break                                  constant        fixed bin(17,0)          initial dcl 2-3 ref 257 267 367
Do_terminate                    000026 constant        bit(1)                   initial unaligned dcl 41 set ref 115*
Dont_terminate                  000034 constant        bit(1)                   initial unaligned dcl 41 set ref 86* 127* 377*
NL                              003454 constant        char(1)                  initial unaligned dcl 142 ref 272 284
Name                                   constant        fixed bin(17,0)          initial dcl 2-3 ref 229 251 269 270 290 315
Number                                 constant        fixed bin(17,0)          initial dcl 2-3 ref 247 269 270
alphanumeric_table              000003 constant        char(63)                 initial unaligned dcl 161 ref 251
already_got_rest          6     000010 internal static bit(1)                   initial level 2 dcl 27 set ref 73* 96* 104* 190* 410
                                                                                  420* 431*
argument                  1            based           varying char(32)         array level 3 dcl 1-3 ref 371
backup_sw                 4     000010 internal static bit(1)                   initial level 2 dcl 27 set ref 73* 104* 181 185*
                                                                                  189* 224 390* 421* 430*
based_string                           based           char(1044480)            unaligned dcl 158 ref 260 331 416
based_string_array                     based           char(1)                  array unaligned dcl 158 set ref 241 245 284 284 289
                                                                                  298 304 304 314 317 438
based_varying_string                   based           structure                level 1 dcl 1-11
buffer                          002536 internal static char(200)                dcl 168 set ref 193* 195 195 195 195 202
code                            000106 automatic       fixed bin(35,0)          dcl 151 set ref 63* 195* 196 197* 267* 268* 269 270
com_err_                        002624 constant        entry                    external dcl 154 ref 197
cur_char                  3     000010 internal static fixed bin(21,0)          initial level 2 dcl 27 set ref 72* 102* 201* 207 219
                                                                                  241 245 260 276* 276 284 284 284* 284 289 291* 291
                                                                                  296* 296 297 298 299* 299 304 304 308* 308 314 317
                                                                                  319* 319 323* 323 331 332* 332 344* 344 356* 356
                                                                                  408 416 423* 423 429* 436 438
cv_float_                       002626 constant        entry                    external dcl 154 ref 268
cv_oct_                         002622 constant        entry                    external dcl 147 ref 335
fake_area                              based           area(1024)               dcl 124 ref 66 214
fake_area_p                     000100 automatic       pointer                  dcl 124 set ref 66 212* 214
hcs_$terminate_noname           002636 constant        entry                    external dcl 173 ref 63 217
i                               000102 automatic       fixed bin(21,0)          dcl 145 set ref 246* 251* 253 253* 255 256* 260 282
                                                                                  344 353* 354 354* 356 356 371* 371* 375 377 377
                                                                                  377 377 414* 415 415* 416 423
ignore_nl                              parameter       fixed bin(17,0)          dcl 132 ref 130 272
in_use                          000010 internal static structure                level 1 dcl 27 set ref 57 97 106 211*
index                                                  builtin function         dcl 138 ref 245 293 306
info_ptr                 10     000010 internal static pointer                  initial level 2 in structure "in_use" dcl 27
                                                                                  in procedure "ge_parse_" set ref 74* 103* 366 371
                                                                                  371 375 377 377 377 377
info_ptr                               parameter       pointer                  dcl 90 in procedure "common_push" ref 88 103
info_ptr                 10     000110 internal static pointer                  array level 2 in structure "stack" dcl 44
                                                                                  in procedure "ge_parse_" set ref 66 66 214 214
info_ptr_arg                           parameter       pointer                  dcl 120 set ref 118 127*
ioa_                            002630 constant        entry                    external dcl 154 ref 219
ioa_$rsnnl                      002620 constant        entry                    external dcl 147 ref 336
iox_$get_line                   002632 constant        entry                    external dcl 168 ref 195
iox_$user_input                 002634 external static pointer                  dcl 168 set ref 195*
j                               000103 automatic       fixed bin(21,0)          dcl 145 set ref 241* 243* 245 293* 294 294* 295 296
                                                                                  306* 307 307* 308 326* 327* 329 329* 331 332 335*
                                                                                  336*
junk                            000105 automatic       float bin(27)            dcl 151 set ref 268*
level                           000106 internal static fixed bin(17,0)          initial dcl 39 set ref 56* 57* 59* 62* 62* 63 63 66
                                                                                  66* 77* 95* 95 97 98* 98 99 106 192 204* 209 210*
                                                                                  210 211 214 214 217 217 219 382
macro_info                             based           structure                level 1 unaligned dcl 1-3 set ref 66 214
n_args                                 based           fixed bin(17,0)          level 2 dcl 1-3 ref 66 214 371 375
nelemt                          000107 automatic       fixed bin(21,0)          dcl 168 set ref 195* 203
null                                                   builtin function         dcl 138 ref 66 70 74 86 86 115 115 192 212 214 366
                                                                                  377 377 403
numeric_table                   000000 constant        char(11)                 initial unaligned dcl 161 ref 246
octal_sw                        000104 automatic       bit(1)                   dcl 147 set ref 318* 321* 326 334
peek_entry                      000115 automatic       bit(1)                   initial dcl 397 set ref 397* 399* 418
previous_token           13     000010 internal static varying char(200)        initial level 2 dcl 27 set ref 75* 182 272 363*
previous_type            12     000010 internal static fixed bin(17,0)          level 2 dcl 27 set ref 184 364*
replacement              12            based           varying char(1020)       array level 3 dcl 1-3 set ref 377 377 377 377
search                                                 builtin function         dcl 138 ref 414
separator_table                        constant        char(2)                  initial unaligned dcl 161 ref 353
somelength                             based           fixed bin(35,0)          level 2 dcl 1-11 ref 377 377
spaces_found              5     000110 internal static bit(1)                   array level 2 in structure "stack" dcl 44
                                                                                  in procedure "ge_parse_" set ref 382*
spaces_found              5     000010 internal static bit(1)                   initial level 2 in structure "in_use" dcl 27
                                                                                  in procedure "ge_parse_" set ref 231 233* 233 240
                                                                                  351* 357* 359* 382*
stack                           000110 internal static structure                array level 1 dcl 44 set ref 57* 97* 99 106* 211
string                    1            based           char                     level 2 dcl 1-11 set ref 377 377
string_len                2     000010 internal static fixed bin(21,0)          initial level 2 dcl 27 set ref 71* 101* 203* 207 219
                                                                                  297 408 429 436
string_len_arg                         parameter       fixed bin(21,0)          dcl 83 in procedure "ge_parse_" set ref 81 86* 113
                                                                                  115* 118 127*
string_len_arg                         parameter       fixed bin(21,0)          dcl 90 in procedure "common_push" ref 88 101
stringp                         000010 internal static pointer                  initial level 2 in structure "in_use" dcl 27
                                                                                  in procedure "ge_parse_" set ref 70* 100* 192 202*
                                                                                  241 245 260 284 284 289 298 304 304 314 317 331
                                                                                  403 416 438
stringp                         000110 internal static pointer                  array level 2 in structure "stack" dcl 44
                                                                                  in procedure "ge_parse_" set ref 63* 217*
stringp_arg                            parameter       pointer                  dcl 83 in procedure "ge_parse_" set ref 81 86* 113
                                                                                  115* 118 127*
stringp_arg                            parameter       pointer                  dcl 90 in procedure "common_push" ref 88 100
subscriptrange                  000000 stack reference condition                dcl 140 ref 99
substr                                                 builtin function         dcl 138 ref 260 295 331 416
temp_bit                        000110 automatic       bit(1)                   dcl 175 set ref 231* 233
template_len                    000114 automatic       fixed bin(21,0)          dcl 177 set ref 246 251 253 293 294 295 306 307 326
                                                                                  327 329 353 354 414 436* 437* 437
template_ptr                    000112 automatic       pointer                  dcl 177 set ref 246 251 293 295 306 326 327 353 414
                                                                                  438*
template_string                        based           char                     unaligned dcl 177 ref 246 251 293 295 306 326 327
                                                                                  353 414
terminate_switch                       parameter       bit(1)                   unaligned dcl 90 ref 88 105
terminate_when_done       7     000010 internal static bit(1)                   initial level 2 in structure "in_use" dcl 27
                                                                                  in procedure "ge_parse_" set ref 76* 105*
terminate_when_done       7     000110 internal static bit(1)                   array level 2 in structure "stack" dcl 44
                                                                                  in procedure "ge_parse_" set ref 63 217
terminators                            constant        char(2)                  initial dcl 161 ref 414
token                                  parameter       varying char             dcl 132 set ref 130 182* 198* 260* 268 272 280* 295*
                                                                                  295 331* 335 336* 339* 339 357 357 359 363 371 395
                                                                                  401 404* 416*
type                                   parameter       fixed bin(17,0)          dcl 132 set ref 130 184* 229* 247* 251 257* 267 269
                                                                                  269* 270 270* 290* 315* 364 367
verify                                                 builtin function         dcl 138 ref 246 251 326 327 353
x                         1            based           structure                array level 2 unaligned dcl 1-3

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Illegal                                internal static fixed bin(17,0)          initial dcl 2-3
Undefined                              internal static fixed bin(17,0)          initial dcl 2-3
based_macro_arg                        based           char(32)                 unaligned dcl 1-25
based_macro_bits                       based           bit                      unaligned dcl 1-21
macro_bits_l                           automatic       fixed bin(17,0)          dcl 1-21
macro_bits_p                           automatic       pointer                  dcl 1-21
macro_def                              automatic       varying char(200)        dcl 1-17
macro_info_p                           automatic       pointer                  dcl 1-19
n_macro_args                           automatic       fixed bin(17,0)          dcl 1-15
replacement_string_size                internal static fixed bin(17,0)          initial dcl 1-9

NAMES DECLARED BY EXPLICIT CONTEXT.
backup                          001517 constant        entry                    external dcl 388
common_push                     001673 constant        entry                    internal dcl 88 ref 86 115 127 377
exit_block                      001412 constant        label                    dcl 342 ref 297
flush_rest_of_line              001656 constant        entry                    external dcl 427
ge_parse_                       000107 constant        entry                    external dcl 11
get_another_token               000512 constant        label                    dcl 207 ref 226 278 309 384
get_rest_of_line                001555 constant        entry                    external dcl 401
get_token                       000337 constant        entry                    external dcl 130
init                            000117 constant        entry                    external dcl 25
is_backup                       000356 constant        label                    dcl 182 ref 224
more_charstring                 001075 constant        label                    dcl 292 ref 300
peek_rest_of_line               001534 constant        entry                    external dcl 395
pop_stack                       000516 constant        label                    dcl 209
push_macro                      000307 constant        entry                    external dcl 118
push_string                     000225 constant        entry                    external dcl 81
push_string_and_terminate       000255 constant        entry                    external dcl 113
read_another_line               000405 constant        label                    dcl 193 set ref 209
rest_null                       001576 constant        label                    dcl 404 ref 408 410
setup_template                  002021 constant        entry                    internal dcl 434 ref 235 292 316 324 349 412
strip_blanks                    001745 constant        entry                    internal dcl 348 ref 232 277 346 424

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 195 195 202 377 377 377 377 438
hbound                                                 builtin function         ref 99
length                                                 builtin function         ref 195 195 377 377
max                                                    builtin function         ref 95 437

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3674        6534    3467        3704
Length      7034    3467      2640         264     205        2610

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ge_parse_                           162 external procedure  is an external procedure.  
common_push                             internal procedure  shares stack frame of external procedure ge_parse_.  
strip_blanks                            internal procedure  shares stack frame of external procedure ge_parse_.  
setup_template                          internal procedure  shares stack frame of external procedure ge_parse_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 in_use                      ge_parse_
000106 level                       ge_parse_
000110 stack                       ge_parse_
002536 buffer                      ge_parse_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ge_parse_                000100 fake_area_p                 ge_parse_
                         000102 i                           ge_parse_
                         000103 j                           ge_parse_
                         000104 octal_sw                    ge_parse_
                         000105 junk                        ge_parse_
                         000106 code                        ge_parse_
                         000107 nelemt                      ge_parse_
                         000110 temp_bit                    ge_parse_
                         000112 template_ptr                ge_parse_
                         000114 template_len                ge_parse_
                         000115 peek_entry                  ge_parse_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        return              shorten_stack       ext_entry
ext_entry_desc      free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cv_float_                     cv_oct_                       hcs_$terminate_noname
ioa_                          ioa_$rsnnl                    iox_$get_line

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
iox_$user_input




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    397 000103        11 000106        23 000115        25 000116        56 000125        57 000133        58 000140
     59 000142        62 000143        63 000151        66 000166        68 000200        70 000204        71 000206
     72 000207        73 000211        74 000213        75 000215        76 000216        77 000217        78 000220
     81 000221        86 000233       110 000252       113 000253       115 000263       116 000302       118 000303
    127 000315       128 000332       130 000333       181 000353       182 000356       184 000371       185 000373
    186 000374       189 000375       190 000376       192 000377       193 000405       195 000411       196 000433
    197 000435       198 000467       199 000501       201 000502       202 000505       203 000507       204 000511
    207 000512       209 000516       210 000520       211 000522       212 000530       214 000533       217 000545
    219 000560       224 000600       226 000603       229 000604       231 000607       232 000611       233 000612
    235 000615       240 000616       241 000621       243 000632       245 000633       246 000646       247 000661
    251 000664       253 000703       255 000711       256 000713       257 000715       260 000717       267 000732
    268 000740       269 000770       270 001002       272 001012       276 001031       277 001033       278 001034
    280 001035       282 001045       284 001050       287 001067       289 001070       290 001072       291 001074
    292 001075       293 001076       294 001111       295 001114       296 001130       297 001135       298 001137
    299 001144       300 001146       302 001147       304 001150       306 001157       307 001172       308 001176
    309 001201       312 001202       314 001203       315 001205       316 001207       317 001210       318 001217
    319 001221       320 001222       321 001223       323 001224       324 001225       326 001226       327 001244
    329 001257       331 001263       332 001277       334 001303       335 001305       336 001333       339 001366
    340 001411       344 001412       346 001415       363 001416       364 001431       366 001433       367 001437
    371 001442       373 001465       375 001467       377 001473       382 001506       384 001515       388 001516
    390 001525       391 001530       395 001531       399 001550       401 001552       403 001571       404 001576
    405 001601       408 001602       410 001605       412 001607       414 001610       415 001624       416 001627
    418 001644       420 001646       421 001650       423 001651       424 001653       425 001654       427 001655
    429 001664       430 001670       431 001671       432 001672        88 001673        95 001675        96 001703
     97 001704        98 001711        99 001712       100 001716       101 001721       102 001723       103 001725
    104 001730       105 001731       106 001736       107 001744       348 001745       349 001746       351 001747
    353 001752       354 001765       356 001771       357 001775       359 002012       361 002020       434 002021
    436 002022       437 002027       438 002033       439 002041


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
