	COMPILATION LISTING OF SEGMENT fst_edit_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 01/19/88  1502.2 mst Tue
	    Options: optimize map

        1 /****^  ******************************************************
        2*        *                                                    *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987           *
        4*        *                                                    *
        5*        * Copyright (c) 1972 by Massachusetts Institute of   *
        6*        * Technology and Honeywell Information Systems, Inc. *
        7*        *                                                    *
        8*        ****************************************************** */
        9 
       10 
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(87-12-02,TLNguyen), approve(87-12-02,MCR7806),
       14*     audit(87-12-10,Lippard), install(88-01-19,MR12.2-1015):
       15*     Implementing SCP6357 and correct deviations from coding standards found
       16*     while researching the problems.
       17*     - fixed stringrange condition raised in the edit internal procedure
       18*       and in the parse_pathname internal procedure.
       19*     - replace the (get, release) temp_segments_ with (get, release) temp_
       20*       segment_ system routines in the merge_add internal procedure.
       21*     - replace the "Changes will be lost if you continue.  Do you want to
       22*       continue?" queried message with "Changes will be lost if you quit.
       23*       Do you want to quit?"
       24*     - Remove the acode, ioa_$ioa_switch_nnl, iox_$get_line, iox_$user_input
       25*       and len from the source because they are not referenced anywhere
       26*       within it.
       27*                                                   END HISTORY COMMENTS */
       28 
       29 
       30 fst_edit_: proc (edit_ptr, line, continue, print_prompt_char);
       31 
       32 /*  This procedure implements all the edit commands for FAST
       33*
       34*   Written 3/76 by S.E. Barr
       35*   Fix bug in save request that adds null chars 06/24/81 S. Herbst
       36*   Fix bug in locate request, bad substr lengths phx12352 10/25/83 C Spitzer
       37*	add cleanup of temp segments.
       38**/
       39 /* parameters */
       40 
       41 dcl  edit_ptr ptr;					/* ptr to edit_info structure */
       42 dcl  line char (*);					/* input:  user input line */
       43 dcl  continue fixed bin;				/* output:  -1 = quit;  0 = was edit;  1 = not edit  */
       44 dcl  print_prompt_char bit (1) unal;			/* output:  ON = print;  OFF = don't print */
       45 
       46 /* automatic */
       47 
       48 dcl  arg char (150) var;				/* argument from command line */
       49 dcl  code fixed bin (35);
       50 dcl  end_line fixed bin;				/* last line number in text usually = f.end_line_number */
       51 dcl  i fixed bin;
       52 dcl  increment fixed bin;				/* used to derive numbers for resequencing */
       53 dcl  input_line_length fixed bin;			/* length of command line:  get_arg */
       54 dcl  input_line_start fixed bin;			/* index into input line of unparsed characters  */
       55 dcl  message char (150);				/* error message */
       56 dcl  seq_number fixed bin;				/* first number to be used in resequencing */
       57 dcl  num fixed bin;					/* line number from command line */
       58 dcl  path char (168) var;				/* pathname for OLD, SAVE, or RUN commands */
       59 dcl  request fixed bin;				/* number of edit request */
       60 dcl  seg_length fixed bin (21);
       61 dcl  seg_ptr ptr;
       62 dcl  t_length fixed bin (21);				/* length of text usually = text_length */
       63 dcl  t_ptr ptr;					/* ptr to text usually = text_ptr */
       64 dcl  temp_length fixed bin (21);			/* length of the buffer contianing modifications */
       65 dcl  temp_ptr ptr;					/* ptr to edit buffer */
       66 dcl  temp_ptr_is_temp_seg bit (1) aligned;
       67 
       68 dcl (addr, addrel, divide, hbound, index, length, null, search, substr, reverse, verify) builtin;
       69 
       70 
       71 /* constants */
       72 
       73 dcl  ADD_TEXT fixed bin int static options (constant) init (0);
       74 dcl  command_names (-1:32) char (11) int static options (constant) init (
       75      "fast", "",
       76      "change", "c",					/* 1 */
       77      "delete_text", "dt",				/* 2 */
       78      "info", "info",				/* 3 */
       79      "input", "input",				/* 4 */
       80      "locate", "l",					/* 5 */
       81      "merge_text", "mgt",				/* 6 */
       82      "move_text", "mt",				/* 7 */
       83      "new", "new",					/* 8 */
       84      "old", "old",					/* 9 */
       85      "print_text", "pt",				/* 10 */
       86      "quit", "q",					/* 11 */
       87      "ready_off", "rdf",				/* 12 */
       88      "ready_on", "rdn",				/* 13 */
       89      "resequence", "rsq",				/* 14 */
       90      "run", "run",					/* 15 */
       91      "save", "save");				/* 16 */
       92 dcl  legal_path_chars char (65) int static options (constant) init ("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.>_");
       93 dcl  DIGIT char (10) int static options (constant) init ("0123456789");
       94 dcl  NEW_LINE char (1) int static options (constant) init ("
       95 ");
       96 dcl  WHITE_SPACE char (2) int static options (constant) init ("	 "); /* tab blank */
       97 dcl  SET bit (1) unal int static options (constant) init ("1"b); /* ON if should set end_line number */
       98 dcl  QUERY int static options (constant) init (1);	/* query if changes will be lost */
       99 dcl  NOT_EMPTY fixed bin int static options (constant) init (2); /* must have some text */
      100 dcl  CREATE bit (1) unal int static options (constant) init ("1"b); /* ON if should create, if not found;  get_seg_ptr */
      101 dcl  DEFAULT fixed bin int static options (constant) init (1); /* use entire text:  get_block */
      102 dcl  NO_DEFAULT fixed bin int static options (constant) init (2); /* line must be specified:  get_block */
      103 dcl  DEFAULT_LOC fixed bin int static options (constant) init (3); /* use end of text if last number not given:  get_block */
      104 dcl  max_num_digits fixed bin int static options (constant) init (5); /* max number = 99999 */
      105 
      106 /* based */
      107 
      108 dcl  alt char (f.alt_length) based (f.alt_ptr);		/* buffer containing new text lines */
      109 dcl 1 f aligned based (edit_ptr) like fst_edit_info;	/* per process data for editing */
      110 dcl  text char (t_length) based (t_ptr);		/* text being modified */
      111 dcl  seg char (seg_length) based (seg_ptr);		/* segment to add to  text  */
      112 dcl  temp char (f.max_seg_size) based (temp_ptr);		/* new copy of text with modifications */
      113 
      114 /* external */
      115 
      116 dcl  command_query_ entry() options(variable);
      117 dcl  get_temp_segment_ entry (char (*), ptr, fixed bin (35));
      118 dcl  dfast_error_ entry (fixed bin (35), char (*), char (*));
      119 dcl  fst_cv_line_num_ entry (char (*), fixed bin, fixed bin (35)) returns (bit (1) unal);
      120 dcl  fst_info_ entry (ptr);
      121 dcl  fst_info_$header entry (ptr, char (*) var);
      122 dcl  fst_run_ entry (ptr, char (*) var);
      123 dcl  fst_util_$change entry (ptr, fixed bin (21), fixed bin (21), char (*) var, char (*) var, fixed bin (21), fixed bin (35));
      124 dcl  fst_util_$input entry (ptr, fixed bin (21), fixed bin, fixed bin, fixed bin, fixed bin (21), fixed bin (35));
      125 dcl  fst_util_$merge entry (ptr, char (*), fixed bin (21), fixed bin, fixed bin (21), fixed bin (35));
      126 dcl  fst_util_$move entry (ptr, fixed bin (21), fixed bin (21), fixed bin (21), fixed bin, fixed bin (21), fixed bin (35));
      127 dcl  fst_util_$resequence entry (ptr, fixed bin, fixed bin, fixed bin (21), fixed bin (35));
      128 dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
      129 dcl  ioa_$ioa_switch entry options (variable);
      130 dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
      131 dcl  iox_$user_output ptr ext;
      132 dcl  release_temp_segment_ entry (char (*), ptr, fixed bin (35));
      133 
  1     1 /* BEGIN INCLUDE FILE ... fst_edit_info.incl.pl1 */
  1     2 
  1     3 dcl 1 fst_edit_info aligned based (edit_ptr),
  1     4     2 pathname char (168) var,			/* path last used with new, old, save command */
  1     5     2 text_ptr ptr,					/* ptr to text being edited */
  1     6     2 alt_ptr ptr,					/* ptr to text additions not  yet included */
  1     7     2 text_length fixed bin (21),			/* number of characters in text */
  1     8     2 alt_length fixed bin (21),			/* number of characters in pending changes */
  1     9     2 max_seg_size fixed bin (21),			/* max. number of characters per segment */
  1    10     2 working_dir char (168) var,			/* path of the working directory */
  1    11     2 end_line_number fixed bin,			/* value of line number of the last line */
  1    12     2 flags aligned,
  1    13       3 subsystem bit (1) unal,			/* ON if entered as subsystem,  OFF if command */
  1    14       3 text_modified bit (1) unal,			/* ON if changes since last save */
  1    15       3 basic_source bit (1) unal,			/* ON if name ends with .basic */
  1    16       3 prompt bit (1) unal,				/* ON if should prompt after commands */
  1    17       3 pad bit (32) unal;
  1    18 
  1    19 /* END INCLUDE FILE ... fst_edit_info.incl.pl1 */
      134 
  2     1 /*  BEGIN INCLUDE ... dfast_error_codes.incl.pl1  */
  2     2 
  2     3 dcl  error_alt_empty fixed bin (35) int static init (1)options (constant);
  2     4 dcl  error_max_size fixed bin (35) int static init (2)options (constant);
  2     5 dcl  error_cur_empty fixed bin (35) int static init (3)options (constant);
  2     6 dcl  error_not_saved fixed bin (35) int static init (4)options (constant);
  2     7 dcl  error_name_dup fixed bin (35) int static init (5)options (constant);
  2     8 dcl  error_long_rec fixed bin (35) int static init (6)options (constant);
  2     9 dcl  error_unknown_arg fixed bin (35) int static init (7)options (constant);
  2    10 dcl  error_no_expl fixed bin (35) int static init (8)options (constant);
  2    11 dcl  error_bad_name fixed bin (35) int static init (9)options (constant);
  2    12 dcl  error_bad_req fixed bin (35) int static init (10)options (constant);
  2    13 dcl  error_syntax_string fixed bin (35) int static init (11)options (constant);
  2    14 dcl  error_name_miss fixed bin (35) int static init (12)options (constant);
  2    15 dcl  error_no_comp fixed bin (35) int static init (13)options (constant);
  2    16 dcl  error_no_main fixed bin (35) int static init (14)options (constant);
  2    17 dcl  error_block_spec fixed bin (35) int static init (15)options (constant);
  2    18 dcl  error_obj_nop fixed bin (35) int static init (16)options (constant);
  2    19 dcl  error_sav_cur fixed bin (35) int static init (17)options (constant);
  2    20 dcl  error_bad_type fixed bin (35) int static init (18)options (constant);
  2    21 dcl  error_unkn_sys fixed bin (35) int static init (19)options (constant);
  2    22 dcl  error_no_suffix fixed bin (35) int static init (20)options (constant);
  2    23 dcl  error_no_nl fixed bin (35) int static init (21)options (constant);
  2    24 dcl  error_bad_sort fixed bin (35) int static init (22)options (constant);
  2    25 dcl  error_no_num fixed bin (35) int static init (23)options (constant);
  2    26 dcl  error_line_miss fixed bin (35) int static init (24)options (constant);
  2    27 dcl  error_request_miss fixed bin (35) int static init (25)options (constant);
  2    28 dcl  error_bad_line fixed bin (35) int static init (26)options (constant);
  2    29 dcl  error_no_string fixed bin (35) int static init (27)options (constant);
  2    30 dcl  error_line_order fixed bin (35) int static init (28)options (constant);
  2    31 dcl  error_max_lines fixed bin (35) int static init (29)options (constant);
  2    32 dcl  error_bad_pathname fixed bin (35) int static init (30)options (constant);
  2    33 dcl  error_access_mode fixed bin (35) int static init (31)options (constant);
  2    34 dcl  error_delimiter_miss fixed bin (35) int static init (32)options (constant);
  2    35 dcl  error_size_fixed_record fixed bin (35) int static init (33)options (constant);
  2    36 dcl  error_bad_rec_len fixed bin (35) int static init (34)options (constant);
  2    37 dcl  error_string_size fixed bin (35) int static init (35)options (constant);
  2    38 dcl  error_max_line_number  fixed bin (35) int static init (36)options (constant);
  2    39 dcl  error_max_args fixed bin (35) int static init (37)options (constant);
  2    40 dcl  error_name_sys fixed bin (35) int static init (38)options (constant);
  2    41 dcl  error_dprint_map fixed bin (35) int static init (39)options (constant);
  2    42 dcl  error_max_num fixed bin (35) int static options (constant) init (40);
  2    43 dcl  error_edit_max_num fixed bin (35) int static options (constant) init (41);
  2    44 dcl  error_un_num_text fixed bin (35) int static options (constant) init (42);
  2    45 dcl  error_no_new_line fixed bin (35) int static options (constant) init (43);
  2    46 
  2    47 /* END INCLUDE ... dfast_error_codes.incl.pl1 */
      135 
  3     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  3     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  3     3 /*	version number changed to 4, 08/10/78 WOS */
  3     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  3     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  3     6 
  3     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  3     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  3     9     2 switches aligned,                                     /* various bit switch values */
  3    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  3    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  3    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  3    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  3    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  3    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  3    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  3    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  3    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  3    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  3    20 
  3    21 /*  Limit of data defined for version 2 */
  3    22 
  3    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  3    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  3    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  3    26 						/* minimum of 30 seconds required for repeat */
  3    27 						/* otherwise, no repeat will occur */
  3    28 /* Limit of data defined for version 4 */
  3    29 
  3    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  3    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  3    32 
  3    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  3    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  3    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  3    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  3    37 
  3    38 /*	END INCLUDE FILE query_info.incl.pl1 */
      136 
      137 
      138 /*  */
      139 
      140 	message = "";
      141 	code = 0;
      142 	request = -1;
      143 
      144 	input_line_length = length (line);
      145 	if verify (substr (line, 1, 1), DIGIT) = 0 then request = ADD_TEXT;
      146 	else do;
      147 	     input_line_start = 1;
      148 	     input_line_length = input_line_length - 1;
      149 	     if get_arg (arg) then do;
      150 		do i = 1 to hbound (command_names, 1) while (request = -1);
      151 		     if arg = command_names (i) then request = divide (i + 1, 2, 17, 0);
      152 		end;
      153 
      154 		if request = -1 then do;
      155 		     if arg = "logout" & ^f.subsystem then do;
      156 			continue = 0;
      157 			call ioa_$ioa_switch (iox_$user_output, "Use quit");
      158 		     end;
      159 		     else continue = 1;
      160 		     return;
      161 		end;
      162 	     end;
      163 	end;
      164 
      165 	call edit (request);
      166 
      167 	if request ^= ADD_TEXT then print_prompt_char = f.prompt;
      168 	if code ^= 0 | message ^= "" then call dfast_error_ (code, command_names (request *2 -1), message);
      169 
      170 	return;
      171 
      172 
      173 /*  */
      174 edit:	proc (request);
      175 
      176 dcl  request fixed bin;
      177 
      178 /* automatic */
      179 
      180 dcl  done bit (1) unal;
      181 dcl  i fixed bin;
      182 dcl  string_found bit (1) unal;			/* ON if string was_found at least once */
      183 dcl  k fixed bin (21);
      184 dcl  input_length_save fixed bin;			/* length of user's command line */
      185 dcl  target_index fixed bin (21);
      186 dcl  num_chars fixed bin (21);
      187 dcl  old_string char (150) var;
      188 dcl  new_string char (150) var;
      189 dcl  start fixed bin (21);
      190 dcl  j fixed bin (21);
      191 dcl  cleanup condition;
      192 
      193 	     temp_ptr = f.alt_ptr;
      194 	     temp_ptr_is_temp_seg = "0"b;
      195 	     temp_length = 0;
      196 	     t_ptr = f.text_ptr;
      197 	     t_length = f.text_length;
      198 	     end_line = f.end_line_number;
      199 
      200 	     seg_ptr = null;
      201 	     on cleanup call term_seg;
      202 
      203 	     goto label (request);
      204 
      205 /*   */
      206 /* Line number text was input.  It is added to a temporary buffer to be processed laster.  If the line number
      207*   is greater than 99999 then the code is set.
      208**/
      209 label (0):
      210 
      211 dcl next_position fixed bin;
      212 
      213 	     next_position = 0;
      214 
      215 	     i = verify (line, DIGIT) -1;
      216 	     if i <= max_num_digits then do;
      217 		next_position = f.alt_length + 1;
      218 		f.alt_length = f.alt_length + input_line_length;
      219 		substr (alt, next_position, input_line_length) = line;
      220 	     end;
      221 	     else code = error_max_num;
      222 
      223 	     print_prompt_char = "0"b;
      224 	     return;
      225 
      226 /*  */
      227 
      228 /*  *	change  /<old_string>/<new_string>/  <first>  [<last>]
      229*   *
      230*   *  If the string could not be replaced at least once, an error code is set by fst_util_.
      231*   */
      232 label (1):
      233 	     if merge_add (NOT_EMPTY) then do;
      234 		if parse_strings ("1"b, old_string, new_string) then do;
      235 		     if get_block (NO_DEFAULT, start, num_chars) then do;
      236 
      237 			call fst_util_$change (edit_ptr, start, num_chars, old_string, new_string, temp_length, code);
      238 			if code = 0 then call switch_buffers (^SET);
      239 			else message = old_string;
      240 		     end;
      241 		end;
      242 	     end;
      243 
      244 	     return;
      245 
      246 
      247 
      248 /* *	delete_text  first  [last]
      249*   *
      250*   * This request deletes one or more lines from the temporary  text
      251**/
      252 label (2):
      253 
      254 dcl  num_left fixed bin (21);
      255 
      256 	     if merge_add (NOT_EMPTY) then do;
      257 		if get_block (NO_DEFAULT, start, num_chars) then do;
      258 		     num_left = f.text_length - start - num_chars + 1;
      259 		     if num_left > 0 then substr (text, start, num_left) = substr (text, start + num_chars, num_left);
      260 		     f.text_length = f.text_length - num_chars;
      261 		     f.text_modified = "1"b;
      262 		     if num_left = 0 then if set_end_number () then;
      263 		end;
      264 	     end;
      265 
      266 	     return;
      267 
      268 
      269 
      270 
      271 /* Info prints the pathname of the segment being modified, quota and money spent */
      272 label (3):
      273 	     call fst_info_ (edit_ptr);
      274 
      275 	     return;
      276 
      277 /*  */
      278 /* *	input  [<after_line>]  [<increment>]
      279*   *
      280*   *	num	is the line number of the line after which the input will be put.
      281*   *		This also determines the first number  (num  + increment - mod (num, increment)  )
      282*   *
      283*   *	start	is the index for first new line.
      284*   *
      285*   *  These defaults are used:
      286*   *	1.  If the increment is not given, it is 10.
      287*   *	2.  If after_line is not given, input is at the end of the text and f.end_line_number is used.
      288*   *	3.  If the buffer is empty and no arguments are specified the first number will be 100.
      289*   */
      290 label (4):
      291 	     if merge_add (0) then do;
      292 		start = f.text_length + 1;
      293 		seq_number = f.end_line_number;
      294 		increment = 10;
      295 		if parse_number (seq_number) then do;
      296 		     if find_first_line (1, "0"b, seq_number, start, num_chars) then do;
      297 			start = start + num_chars;
      298 			if parse_number (increment) then;
      299 		     end;
      300 		end;
      301 		else if f.text_length = 0 then seq_number = 90;
      302 		if start > f.text_length then num = 100000;
      303 		else if get_number (start, num) then;
      304 
      305 		if message = "" then do;
      306 		     call fst_util_$input (edit_ptr, start, seq_number, increment, num, temp_length, code);
      307 		     call switch_buffers (^SET);
      308 		end;
      309 	     end;
      310 
      311 	     return;
      312 
      313 /*   */
      314 /* *locate  /<string>/ [<first>]  [<last>]
      315*   *
      316*   * This request prints out all lines containing a given string.  The entire line is scanned for the string,
      317*   * including the line number.  It uses these defaults:
      318*   *
      319*   *	1.  If "last" is omitted, the text between "first" and the end of the text is used.
      320*   *	2.  If both "first" and "last" are omitted, the entire text is used.
      321*   *
      322*   * If the string is not found at least once, an error message is printed.
      323*   */
      324 label (5):
      325 	     if merge_add (NOT_EMPTY) then do;
      326 		if parse_strings ("0"b, old_string, "") then do;
      327 		     if get_block (DEFAULT_LOC, start, num_chars) then do;
      328 
      329 			string_found = "0"b;
      330 			do while (num_chars > 0);
      331 			     k = index (substr (text, start, num_chars), old_string);
      332 			     if k > 0 then do;
      333 				j = index (reverse (substr (text, start, k)), NEW_LINE) -1;
      334 				if j > 0 then do;
      335 				     start = start + k - j;
      336 				     num_chars = num_chars + j - k;
      337 				end;
      338 
      339 				j = index (substr (text, start, num_chars), NEW_LINE);
      340 				if j = 0 then j = num_chars;
      341 				call iox_$put_chars (iox_$user_output, addr (substr (text, start, 1)), j, code);
      342 				if code ^= 0 then return;
      343 				start = start + j;
      344 				num_chars = num_chars - j;
      345 				string_found = "1"b;
      346 			     end;
      347 			     else num_chars = 0;
      348 			end;
      349 			if ^string_found then message = "could not find " || old_string;
      350 		     end;
      351 		end;
      352 	     end;
      353 
      354 	     return;
      355 
      356 /*  */
      357 /*	merge_text  <path>	[<line_number>]
      358*   *
      359*   * This request merges the contents on an ascii segment into the temporary text after the line specified with
      360*   * line_number.  If line_number is not given, the segment is appended to the end of the temporary text.
      361*   * The segment specified will be resequenced so it must have line numbers.  The temporary text following the
      362*   * the merged text may be resequenced.  This is only done in cases where overlap of line numbers would
      363*   * have occured.
      364**/
      365 label (6):
      366 	     if merge_add (0) then do;
      367 		if parse_pathname (NO_DEFAULT, path) then do;
      368 		     if get_seg_ptr (^CREATE, path) then do;
      369 			if parse_number (num) then do;
      370 			     if find_first_line (1, "0"b, num, start, num_chars) then do;
      371 				start = start + num_chars;
      372 				seq_number = num;
      373 			     end;
      374 			end;
      375 			else do;
      376 			     start = f.text_length + 1;
      377 			     if start = 1 then seq_number = 90;
      378 			     else seq_number = f.end_line_number;
      379 			end;
      380 
      381 			if message = "" then do;
      382 			     call fst_util_$merge (edit_ptr, seg, start, seq_number, temp_length, code);
      383 			     call switch_buffers (SET);
      384 			end;
      385 			call term_seg;
      386 		     end;
      387 		end;
      388 		else if message = "" then message = "no pathname given";
      389 	     end;
      390 
      391 	     return;
      392 
      393 /*  */
      394 /* *	move_text <first>  [<last>] ,  [<after_line>]
      395*   *
      396*   * The block of lines specified by first and last is moved to a location following the line specified by
      397*   * after_line.  The lines that are moved are resequenced.
      398**/
      399 label (7):
      400 	     if merge_add (NOT_EMPTY) then do;
      401 		i = index (line, ",");
      402 		if i > 0 then do;
      403 		     input_length_save = input_line_length;
      404 		     input_line_length = i -1;
      405 		     if get_block (NO_DEFAULT, start, num_chars) then do;
      406 			input_line_length = input_length_save;
      407 			input_line_start = i + 1;
      408 			if parse_number (num) then do;
      409 			     if find_first_line (1, "0"b, num, target_index, j) then do;
      410 				target_index = target_index + j -1;
      411 				if target_index < start | target_index >= start + num_chars - 1 then do;
      412 				     call fst_util_$move (edit_ptr, start, num_chars, target_index,
      413 					num, temp_length, code);
      414 				     call switch_buffers (SET);
      415 				end;
      416 				else message = "target of move is inside range";
      417 			     end;
      418 			end;
      419 			else message = "line number missing";
      420 		     end;
      421 		end;
      422 		else message = "comma is missing";
      423 	     end;
      424 	     return;
      425 
      426 /*  */
      427 /* *	new  [<path>]
      428*   *
      429*   * This request causes the text to be truncated.  The merge_add procedure queries the user if this action
      430*   * would cause changes made to the text to be lost.  If path is not given, the default path is set to null.
      431**/
      432 label (8):
      433 	     if merge_add (QUERY) then do;
      434 		if parse_pathname (0, path) then do;
      435 		     f.pathname = path;
      436 		     call set_basic_source;
      437 		     f.text_length = 0;
      438 		     f.end_line_number = 0;
      439 		end;
      440 	     end;
      441 
      442 	     return;
      443 
      444 
      445 
      446 /* *	old  <path>
      447*   *
      448*   * This request causes text to be replaced with the contents of the segment specified. The merge_add
      449*   * procedure queries the user if this action would cause changes made to the text to be lost.
      450*   * The new text must be line numbered source code.
      451**/
      452 label (9):
      453 	     if merge_add (QUERY) then do;
      454 		if parse_pathname (NO_DEFAULT, path) then do;
      455 		     if get_seg_ptr (^CREATE, path) then do;
      456 			f.text_length, t_length = seg_length;
      457 			f.text_ptr -> text = seg_ptr -> text;
      458 			call term_seg;
      459 			f.pathname = path;
      460 			call set_basic_source;
      461 
      462 /*  This code sets the last line number for use later */
      463 
      464 			if f.text_length <= 1 then f.end_line_number = 0;
      465 			else if ^set_end_number () then do;
      466 			     f.text_length = 0;
      467 			     f.pathname = "";
      468 			end;
      469 
      470 		     end;
      471 		end;
      472 	     end;
      473 
      474 	     return;
      475 
      476 /*  */
      477 /* *	print_text  [-pn]  [<path>]  [-nhe]   [<first>]  [<last>]
      478**/
      479 label (10):
      480 
      481 dcl  header bit (1) unal;				/* ON if should print header  (no line numbers given) */
      482 
      483 /*  This code parses the arguments.  If the path is not given (path = "") then the temporary text is used */
      484 
      485 	     header = "1"b;
      486 	     path = "";
      487 	     done = "0"b;
      488 	     do while (^done & message = "");
      489 		if get_arg (arg) then do;
      490 		     if arg = "-pn" | arg = "-pathname" then do;
      491 			if ^get_arg (path) then message = "pathname is missing";
      492 		     end;
      493 		     else if arg = "-nhe" | arg = "-no_header" then header = "0"b;
      494 		     else if verify (substr (arg, 1, 1), DIGIT) > 0 then do;
      495 			if path = "" then path = arg;
      496 			else message = "syntax error in line number";
      497 		     end;
      498 		     else do;
      499 			input_line_start = input_line_start - length (arg);
      500 			done = "1"b;
      501 		     end;
      502 		end;
      503 		else done = "1"b;
      504 	     end;
      505 
      506 	     if message = "" then do;
      507 
      508 /* The segment is initiated and temp is changed to be new segment instead of temporary text for get_block
      509*   and other search routines. If the segment doesn't have line numbers, it can be printed if no lines were
      510*   specified.
      511**/
      512 
      513 		if path ^= "" then do;
      514 		     if verify (path, legal_path_chars) = 0 then do;
      515 			if get_seg_ptr (^CREATE, path) then do;
      516 			     t_ptr = seg_ptr;
      517 			     t_length = seg_length;
      518 			     if t_length = 0 then message = "segment is empty " || path;
      519 			     else if t_length > 1 then do;
      520 				j = index (reverse (substr (text, 1, t_length -1)), NEW_LINE);
      521 				if j = 0 then j = 1;
      522 				else j = t_length - j + 1;
      523 				if ^get_number (j, end_line) then do;
      524 				     if input_line_start > input_line_length | substr (line, input_line_start) = ""
      525 				     then message = "";
      526 				end;
      527 			     end;
      528 			end;
      529 		     end;
      530 		     else message = "illegal character in pathname " || path;
      531 		end;
      532 		else if merge_add (NOT_EMPTY) then;
      533 
      534 		if message = "" then do;
      535 		     if input_line_start <= input_line_length
      536 		     then if substr (line, input_line_start) ^= "" then header = "0"b;
      537 		     if get_block (DEFAULT, start, num_chars) then do;
      538 			if path = "" then path = f.pathname;
      539 			if header then call fst_info_$header (edit_ptr, path);;
      540 			call iox_$put_chars (iox_$user_output, addr (substr (text, start, 1)), num_chars, code);
      541 		     end;
      542 		end;
      543 		call term_seg;
      544 	     end;
      545 
      546 	     return;
      547 
      548 /*  */
      549 /*  The quit request is allowed for the FAST command, but not the subsystem.  It queries the user if the text has been 
      550*   modified since the last save.  It sets the parameter continue to -1 which causes the caller of fst_edit_ to quit.
      551**/
      552 label (11):
      553 
      554 	     if ^f.subsystem then do;
      555 		if merge_add (QUERY) then continue = -1;
      556 	     end;
      557 
      558 	     else message = "use logout";
      559 
      560 	     return;
      561 
      562 
      563 
      564 /* ready_off sets the parameter print_prompt_char so the listener will not prompt */
      565 label (12):
      566 
      567 	     f.prompt = "0"b;
      568 	     return;
      569 
      570 /* ready_on sets the parameter print_ready_char so the listener will prompt
      571**/
      572 label (13):
      573 
      574 	     f.prompt = "1"b;
      575 	     return;
      576 
      577 /*  */
      578 /* *	resequence  [<seq_number>]  [<increment>]
      579**/
      580 label (14):
      581 	     if merge_add (NOT_EMPTY) then do;
      582 		if parse_number (seq_number) then do;
      583 		     if ^parse_number (increment) then increment = 10;
      584 		end;
      585 		else do;
      586 		     seq_number = 100;
      587 		     increment = 10;
      588 		end;
      589 
      590 		if message = "" then do;
      591 		     call fst_util_$resequence (edit_ptr, seq_number, increment, temp_length, code);
      592 		     call switch_buffers (SET);
      593 		end;
      594 
      595 	     end;
      596 
      597 	     return;
      598 
      599 
      600 
      601 
      602 /* *	run  [<path>]
      603*   *
      604*   * If path is not given, the temporary text is run
      605**/
      606 label (15):
      607 
      608 	     if parse_pathname (0, path) then;
      609 	     if path = "" then if merge_add (NOT_EMPTY) then;
      610 
      611 	     if message = "" then call fst_run_ (edit_ptr, path);
      612 
      613 	     return;
      614 
      615 /*  */
      616 /* *	save	[<path>]
      617*   *
      618*   * This request causes text to be copied into the segment specified.  If the segment doesn't exist, it will
      619*   * be created.  If path is not given, the default pathname is used.  If the request is successful,
      620*   * the default pathname is changed.
      621**/
      622 label (16):
      623 
      624 dcl  hcs_$set_bc_seg entry (ptr, fixed bin (24), fixed bin (35));
      625 dcl  hcs_$truncate_seg entry (ptr, fixed bin (21), fixed bin (35));
      626 
      627 	     if merge_add (NOT_EMPTY) then do;
      628 		if parse_pathname (0, path) then do;
      629 		     if path = "" then path = f.pathname;
      630 		     if get_seg_ptr (CREATE, path) then do;
      631 			seg_ptr -> text = f.text_ptr -> text;
      632 			f.pathname = path;
      633 			call set_basic_source;
      634 			f.text_modified = "0"b;
      635 			call hcs_$set_bc_seg (seg_ptr, f.text_length * 9, code);
      636 			if code = 0 then call hcs_$truncate_seg
      637 			     (seg_ptr, divide (f.text_length + 3, 4, 21, 0), code);
      638 			call term_seg;
      639 		     end;
      640 		end;
      641 	     end;
      642 
      643 	     return;
      644 
      645 	end edit;
      646 
      647 /*  */
      648 /* *  This procedure finds the next token on the line.  Tokens are separated by blanks or tabs.
      649*   *  It uses the global variables:
      650*   *
      651*   *	line		parameter ;  user's input line
      652*   *	input_line_start	index to begin searching
      653*   *	input_line_length	number of characters in input line
      654*   *
      655*   *  If it finds a token, it returns "1"b after setting:
      656*   *	arg		token
      657*   *	input_line_start	index following token
      658*   *
      659*   *  Otherwise it returns "0"b
      660**/
      661 get_arg:	proc (arg) returns (bit (1));
      662 
      663 /* parameters */
      664 
      665 dcl  arg char (*) var;
      666 
      667 /* automatic */
      668 
      669 dcl  i fixed bin;
      670 dcl  len fixed bin;
      671 
      672 	     len = input_line_length - input_line_start + 1;
      673 
      674 	     if len > 0 then do;
      675 		i = verify (substr (line, input_line_start, len), WHITE_SPACE);
      676 		if i > 0 then do;
      677 		     input_line_start = input_line_start + i -1;
      678 		     len = len - i + 1;
      679 		     i = search (substr (line, input_line_start, len), WHITE_SPACE);
      680 		     if i = 0 then i = len;
      681 		     else i = i - 1;
      682 		     arg = substr (line, input_line_start, i);
      683 		     input_line_start = input_line_start + i;
      684 		     return ("1"b);
      685 		end;
      686 	     end;
      687 
      688 	     return ("0"b);
      689 
      690 	end get_arg;
      691 
      692 /*  */
      693 /* * This procedure gets the next tokens which should be first and last line numbers.  It returns an index into
      694*   * text and the number of characters in the block covered by the range.  There must be at least one line in the
      695*   * range.
      696*   * Default actions depend on default_code as follows:
      697*   *
      698*   *	NO_DEFAULT	range specification must be present
      699*   *	DEFAULT		use entire text
      700*   *	DEFAULT_LOC	if last line is not specified then the end of the text is assumed.
      701**/
      702 get_block: proc (default_code, block_start, block_length) returns (bit (1) unal);
      703 
      704 /* parameters */
      705 
      706 dcl  default_code fixed bin;
      707 dcl  block_start fixed bin (21);
      708 dcl  block_length fixed bin (21);
      709 
      710 /* automatic */
      711 
      712 dcl  equal bit (1) unal;
      713 dcl  line_start fixed bin (21);			/* index in text of line being compared */
      714 dcl  j fixed bin (21);
      715 dcl  num fixed bin;
      716 dcl  num_1 fixed bin;
      717 dcl  num_2 fixed bin;
      718 
      719 	     if parse_number (num_1) then do;
      720 		if parse_number (num_2) then do;
      721 		     equal = "0"b;
      722 		     if num_1 > num_2 then do;
      723 			message = "lines must be in increasing order";
      724 			return ("0"b);
      725 		     end;
      726 		end;
      727 
      728 		else if default_code = DEFAULT_LOC then do;
      729 		     equal = "0"b;
      730 		     num_2 = 99999;
      731 		end;
      732 		else equal = "1"b;
      733 
      734 		if find_first_line (1, equal, num_1, block_start, block_length) then do;
      735 
      736 		     if equal then return ("1"b);
      737 		     if num_2 >= end_line then block_length = t_length - block_start + 1;
      738 		     else do;
      739 			line_start = block_start;
      740 			block_length = 0;
      741 			do while (block_length = 0 & message = "");
      742 
      743 			     if get_number (line_start, num) then do;
      744 				if num_2 < num then do;
      745 				     block_length = line_start - block_start;
      746 				     if block_length = 0 then message = "line not found in text";
      747 				end;
      748 			     end;
      749 			     j = index (substr (text, line_start), NEW_LINE);
      750 			     if j = 0 then j = t_length - line_start + 1;
      751 			     line_start = line_start + j;
      752 			end;
      753 		     end;
      754 		end;
      755 	     end;
      756 
      757 	     else if default_code ^= NO_DEFAULT then do;
      758 		block_start = 1;
      759 		block_length = t_length;
      760 	     end;
      761 	     else message = "line number must be given";
      762 
      763 	     if message = "" then do;
      764 		if block_length > 0 then return ("1"b);
      765 		else message = "line not found in text";
      766 	     end;
      767 
      768 	     return ("0"b);
      769 
      770 	end get_block;
      771 
      772 /*  */
      773 /* * This procedure gets the next token and converts it to a line number.  It returns:
      774*   *
      775*   *	"1"b	if the next token was a number.
      776*   *	"0"b	if there was a syntax error or no more tokens.
      777**/
      778 parse_number: proc (num) returns (bit (1) unal);
      779 
      780 dcl  num fixed bin;					/* the number found */
      781 
      782 	     if get_arg (arg) then do;
      783 		if fst_cv_line_num_ ((arg), num, code) then return ("1"b);
      784 		message = arg;
      785 	     end;
      786 
      787 	     return ("0"b);
      788 
      789 	end parse_number;
      790 
      791 /*  */
      792 /* * This procedure is given a line number and it sets line start to the index in text of the line with taht line
      793*   * number or the next higher line.  If the exact line is  found, line_length is set.  Otherwise
      794*   * line_length is 0.
      795**/
      796 find_first_line: proc (index_start, must_be_equal, line_number, line_start, line_length) returns (bit (1) unal);
      797 
      798 /* parameters  */
      799 
      800 dcl  index_start fixed bin (21);
      801 dcl  must_be_equal bit (1) unal;
      802 dcl  line_start fixed bin (21);
      803 dcl  line_number fixed bin;
      804 dcl  line_length fixed bin (21);
      805 
      806 /* automatic */
      807 
      808 dcl  num fixed bin;
      809 
      810 	     line_start = index_start;
      811 
      812 	     do while (line_start <= t_length & message = "");
      813 		if get_number (line_start, num) then do;
      814 		     line_length = index (substr (text, line_start), NEW_LINE);
      815 		     if line_length = 0 then line_length = t_length - line_start + 1;
      816 		     if line_number <= num then do;
      817 			if line_number = num then return ("1"b);
      818 			if ^must_be_equal then do;
      819 			     line_length = 0;
      820 			     return ("1"b);
      821 			end;
      822 			message = "line not found in text";
      823 		     end;
      824 		     line_start = line_start + line_length;
      825 		end;
      826 	     end;
      827 
      828 	     line_length = 0;
      829 
      830 	     if message = "" then do;
      831 		if ^must_be_equal then return ("1"b);
      832 		else message = "line not found in text";
      833 	     end;
      834 
      835 	     return ("0"b);
      836 
      837 	end find_first_line;
      838 
      839 /*   */
      840 /* * This procedure is given an index into text and it sets the line number */
      841 get_number: proc (start, line_number) returns (bit (1) unal);
      842 
      843 dcl  start fixed bin (21);
      844 dcl  line_number fixed bin;
      845 dcl  i fixed bin (21);
      846 
      847 	     i = verify (substr (text, start), DIGIT);
      848 	     if i = 0 then i = t_length - start + 1;
      849 	     else i = i - 1;
      850 	     if i > 0 then do;
      851 		if fst_cv_line_num_ (substr (text, start, i), line_number, code) then return ("1"b);
      852 		message = substr (text, start, i);
      853 	     end;
      854 	     else message = "un-numbered line found in text";
      855 
      856 	     return ("0"b);
      857 
      858 	end get_number;
      859 
      860 /*  */
      861 /* * This procedure gets the next token from the command line and checks it for valid characters.
      862*   * It returns "1"b if the path was given and is valid or there are no more tokens.
      863*   * Otherwise it returns "0"b.
      864*   */
      865 parse_pathname: proc (default, path) returns (bit (1) unal);
      866 
      867 dcl  default fixed bin;				/* 0 = OK  if path  not specified;  NO_DEFAULT = erorr */
      868 dcl  path char (168) var;
      869 
      870 	     path = "";
      871 
      872 	     if get_arg (path) then do;
      873 		if verify (path, legal_path_chars) = 0 then return ("1"b);
      874 		message = "illegal character in pathname " || path;
      875 	     end;
      876 	     else if default ^= NO_DEFAULT then return ("1"b);
      877 
      878 	     else message = "pathname is missing";
      879 
      880 	     return ("0"b);
      881 
      882 	end parse_pathname;
      883 
      884 
      885 
      886 set_basic_source: proc;
      887 
      888 dcl reverse_pathname char (168) varying;
      889 
      890 dcl before builtin;
      891 
      892 	     reverse_pathname = reverse (f.pathname);
      893 	     if index (reverse_pathname, ".") > 1 then f.basic_source = (reverse (before (reverse_pathname, ".")) = "basic");
      894 	     else f.basic_source = "0"b;
      895 	     
      896 	     return;
      897 
      898 	end set_basic_source;
      899 
      900 
      901 
      902 /* This procedure sets end_line_number to the number of the last line in the segment.  */
      903 set_end_number: proc returns (bit (1) unal);
      904 
      905 dcl  start fixed bin (21);
      906 
      907 	     if f.text_length > 0 then do;
      908 		start = index (reverse (substr (text, 1, f.text_length -1)), NEW_LINE);
      909 		if start = 0 then start = 1;
      910 		else start = f.text_length - start + 1;
      911 		return (get_number (start, f.end_line_number));
      912 	     end;
      913 
      914 	     return ("0"b);
      915 
      916 	end set_end_number;
      917 
      918 /*   */
      919 /*  This procedure is given a pathname and it gets a pointer to the segment.
      920*   If create_if_not_found is set, it creates the segment.
      921*   If it is not set, it assumes the segment exists and contains line numbered text.
      922*   It returns "1"b if seg_ptr can be set and contains valid text.
      923*   If an error occurs message is set.
      924**/
      925 get_seg_ptr: proc (create_if_not_found, path) returns (bit (1));
      926 
      927 dcl  create_if_not_found bit (1);			/* ON if should create if it doesn't exist */
      928 dcl  path char (168) var;				/* path of the segment */
      929 
      930 dcl  fst_get_segment_ entry (bit (1) unal, char (*) var, char (*) var, ptr, fixed bin (21), fixed bin (35));
      931 
      932 	     if path ^= "" then do;
      933 		call fst_get_segment_ (create_if_not_found, path, f.working_dir, seg_ptr, seg_length, code);
      934 		if code = 0 then return ("1"b);
      935 		else message = path;
      936 	     end;
      937 	     else message = "pathname missing";
      938 
      939 	     return ("0"b);
      940 
      941 
      942 	end get_seg_ptr;
      943 
      944 /*  */
      945 /* * This procedure merges the pending changes to the temporary text.  If check is set, and there
      946*   * have been changes, since the last save, the user is queried, since editing will be lost.
      947*   *
      948*   * These conventions are followed in inserting the pending changes:
      949*   *
      950*   *	1.  If the new line appears in text, it replaces the old line.
      951*   *	2.  If the new line has num_chars = 0, it causes the old line in text to be deleted.
      952*   *	3.  If the new line does not appear in text, it is inserted.
      953**/
      954 merge_add: proc (check) returns (bit (1) unal);
      955 
      956 dcl  check fixed bin;
      957 
      958 /* automatic */
      959 
      960 dcl  answer char (20) var;				/* yes or no */
      961 dcl  i fixed bin (21);
      962 dcl  last_index fixed bin (21);
      963 dcl  line_length fixed bin (21);
      964 dcl  line_start fixed bin (21);
      965 dcl  save_ptr ptr;
      966 dcl  table_ptr ptr;
      967 
      968 dcl 1 t aligned based (table_ptr) like dfast_line_table;
      969 
      970 
      971 dcl  dfast_get_table_ entry (bit (1) unal, ptr, fixed bin (21), ptr, fixed bin (35));
  4     1 /* BEGIN ... dfast_line_table.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(87-12-03,TLNguyen), approve(87-12-03,MCR7806),
  4     7*     audit(87-12-10,Lippard), install(88-01-19,MR12.2-1015):
  4     8*     _ Replace the "dfast_line_table aligned based" with "dfast_line_table
  4     9*       aligned based (table_ptr)" and the "line (2)" array field with
  4    10*       "line (dfast_line_table.table_length)" to fixed subscript range
  4    11*       occured in the dfast_get_table_.pl1.
  4    12*                                                   END HISTORY COMMENTS */
  4    13 
  4    14 
  4    15 dcl 1 dfast_line_table aligned based (table_ptr),
  4    16     2 table_length fixed bin (21),
  4    17     2 line (dfast_line_table.table_length),
  4    18       3 number fixed bin,
  4    19       3 start fixed bin (21),
  4    20       3 num_chars fixed bin (21);
  4    21 
  4    22 /* END INCLUDE ... dfast_line_table.incl.pl1 */
      972 
      973 
      974 /*  */
      975 	     if check = QUERY then do;
      976 		if (f.text_modified & f.text_length > 0) | f.alt_length > 0 then do;
      977 		     query_info.version = query_info_version_6;
      978 		     query_info.yes_or_no_sw = "1"b;
      979 		     query_info.suppress_name_sw = "1"b;
      980 		     query_info.cp_escape_control = "10"b;
      981 		     call command_query_ (addr (query_info), answer, "fast",
      982 			"Changes will be lost if you quit.  Do you want to quit ? ");
      983 		     if answer = "yes" then do;
      984 			f.text_modified = "0"b;
      985 			f.alt_length = 0;
      986 			return ("1"b);
      987 		     end;
      988 		     else if answer = "no" then return ("0"b);
      989 		end;
      990 	     end;
      991 
      992 
      993 	     if f.alt_length > 0 then do;
      994 		table_ptr = addrel (f.alt_ptr, divide (f.alt_length + 3, 4, 21));
      995 		t.table_length = 0;
      996 		call dfast_get_table_ ("1"b, f.alt_ptr, f.alt_length, table_ptr, 0);
      997 		temp_length = 0;
      998 		temp_ptr = null;
      999 		call get_temp_segment_ ("fast", temp_ptr, code);
     1000 		if code = 0 then do;
     1001 		     temp_ptr_is_temp_seg = "1"b;
     1002 		     last_index = 0;
     1003 		     do i = 1 to t.table_length while (message = "");
     1004 			if find_first_line (last_index + 1, "0"b, (t.line (i).number), line_start, line_length) then do;
     1005 			     if last_index < line_start -1 then call copy
     1006 				(substr (text, last_index + 1, line_start - 1 - last_index ));
     1007 			     if t.line (i).num_chars > 0 then call copy (substr (alt, t.line (i).start,
     1008 				t.line (i).num_chars));
     1009 			     last_index = line_start + line_length - 1;
     1010 			end;
     1011 		     end;
     1012 		     if message = "" then do;
     1013 			if last_index < f.text_length then
     1014 			     call copy (substr (text, last_index + 1, f.text_length - last_index));
     1015 
     1016 /* Exchange ptrs so temp will become text.  temp_ptr is set so a buffer (previously text_ptr) can be freed. */
     1017 
     1018 			save_ptr = f.text_ptr;
     1019 			f.text_ptr = temp_ptr;
     1020 			f.text_length = temp_length;
     1021 			temp_ptr = save_ptr;
     1022 
     1023 			f.alt_length = 0;
     1024 			f.text_modified = "1"b;
     1025 			temp_length = 0;
     1026 			t_ptr = f.text_ptr;
     1027 			t_length = f.text_length;
     1028 			if t.line (t.table_length).number >= f.end_line_number then do;
     1029 			     if t.line (t.table_length).num_chars > 0 then f.end_line_number = t.line (t.table_length).number;
     1030 			     else if set_end_number () then;
     1031 			     end_line = f.end_line_number;
     1032 			end;
     1033 		     end;
     1034 		     if temp_ptr ^= null then call release_temp_segment_ ("fast", temp_ptr, code);
     1035 		     temp_ptr_is_temp_seg = "0"b;
     1036 		     temp_ptr = f.alt_ptr;
     1037 		end;
     1038 	     end;
     1039 
     1040 
     1041 	     if check = NOT_EMPTY then do;
     1042 		if t_length = 0 then do;
     1043 		     message = "buffer is empty";
     1044 		     return ("0"b);
     1045 		end;
     1046 	     end;
     1047 	     return ("1"b);
     1048 
     1049 	end merge_add;
     1050 
     1051 /*  */
     1052 /* This procedure switches the pointers so the temporary buffer becomes the temporary text.  The temp_ptr
     1053*   and the alter ptr are the same.
     1054**/
     1055 
     1056 switch_buffers: proc (set_last_number);
     1057 
     1058 dcl  set_last_number bit (1) unal;			/* ON if should set the last number */
     1059 
     1060 	     if code = 0 then do;
     1061 		f.alt_ptr = f.text_ptr;
     1062 		t_ptr, f.text_ptr = temp_ptr;
     1063 		t_length, f.text_length = temp_length;
     1064 		f.text_modified = "1"b;
     1065 
     1066 		if set_last_number then if set_end_number () then;
     1067 	     end;
     1068 
     1069 	     return;
     1070 
     1071 	end switch_buffers;
     1072 
     1073 /*  */
     1074 /* * This procedure parse two strings of the form:
     1075*   *
     1076*   *	/old_string/new_string/
     1077*   *
     1078*   *	where / can be any delimitor except blank or tab
     1079**/
     1080 parse_strings: proc (two_strings, old_string, new_string) returns (bit (1) unal);
     1081 
     1082 dcl  two_strings bit (1) unal;			/* ON if should set both strings */
     1083 dcl  old_string char (*) var;
     1084 dcl  new_string char (*) var;
     1085 
     1086 dcl  delimitor char (1);
     1087 dcl  start fixed bin;
     1088 dcl  i fixed bin;
     1089 
     1090 	     if input_line_start <= input_line_length then do;
     1091 		start = input_line_start;
     1092 		i = verify (substr (line, start, input_line_length-start+1), WHITE_SPACE) - 1;
     1093 		if i > -1 then do;
     1094 		     delimitor = substr (line, start + i, 1);
     1095 		     start = start + i + 1;
     1096 		     i = index (substr (line, start, input_line_length-start+1), delimitor) -1;
     1097 		     if i > 0 then do;
     1098 			old_string = substr (line, start, i);
     1099 			if two_strings then do;
     1100 			     start = start + i + 1;
     1101 			     i = index (substr (line, start, input_line_length-start+1), delimitor) -1;
     1102 			     if i>0 then new_string = substr (line, start, i);
     1103 			     else if i = 0 then new_string = "";
     1104 			     else message = "delimitor is missing  " || delimitor;
     1105 			end;
     1106 		     end;
     1107 
     1108 		     else if i = 0 then message = "string is missing";
     1109 		     else message = "delimitor missing " || delimitor;
     1110 		end;
     1111 		else message = "string is missing";
     1112 
     1113 		if message = "" then do;
     1114 		     input_line_start = start + i +1;
     1115 		     return ("1"b);
     1116 		end;
     1117 	     end;
     1118 	     else message = "string is missing";
     1119 
     1120 	     return ("0"b);
     1121 
     1122 	end parse_strings;
     1123 
     1124 /*  */
     1125 copy:	proc (string);
     1126 
     1127 dcl  string char (*);
     1128 
     1129 	     if temp_length + length (string) <= f.max_seg_size then do;
     1130 		substr (temp, temp_length + 1, length (string)) = string;
     1131 		temp_length = temp_length + length (string);
     1132 	     end;
     1133 	     else message = "segment would exceed max segment size";
     1134 
     1135 	     return;
     1136 
     1137 	end copy;
     1138 
     1139 
     1140 term_seg: proc;
     1141 
     1142 	if seg_ptr ^= null then call hcs_$terminate_noname (seg_ptr, (0));
     1143 	if temp_ptr ^= null & temp_ptr_is_temp_seg then call release_temp_segment_ ("fast", temp_ptr, (0));
     1144 
     1145 	end term_seg;
     1146 
     1147      end fst_edit_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/19/88  1459.5  fst_edit_.pl1                     >spec>install>MR12.2-1015>fst_edit_.pl1
134          1    12/03/76  1658.6  fst_edit_info.incl.pl1            >ldd>include>fst_edit_info.incl.pl1
135          2    03/27/82  0439.4  dfast_error_codes.incl.pl1        >ldd>include>dfast_error_codes.incl.pl1
136          3    03/11/83  1204.3  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
972          4    01/19/88  1501.5  dfast_line_table.incl.pl1         >spec>install>MR12.2-1015>dfast_line_table.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ADD_TEXT                               constant        fixed bin(17,0)          initial dcl 73 ref 145 167
CREATE                          000221 constant        bit(1)                   initial unaligned dcl 100 set ref 368 455 515 630*
DEFAULT                                constant        fixed bin(17,0)          initial dcl 101 set ref 537*
DEFAULT_LOC                            constant        fixed bin(17,0)          initial dcl 103 set ref 327* 728
DIGIT                           000021 constant        char(10)                 initial unaligned dcl 93 ref 145 215 494 847
NEW_LINE                               constant        char(1)                  initial unaligned dcl 94 ref 333 339 520 749 814 908
NOT_EMPTY                              constant        fixed bin(17,0)          initial dcl 99 set ref 232* 256* 324* 399* 532* 580*
                                                                                  609* 627* 1041
NO_DEFAULT                      000233 constant        fixed bin(17,0)          initial dcl 102 set ref 235* 257* 367* 405* 454* 757
                                                                                  876
QUERY                                  constant        fixed bin(17,0)          initial dcl 98 set ref 432* 452* 555* 975
SET                                    constant        bit(1)                   initial unaligned dcl 97 set ref 238 307 383* 414*
                                                                                  592*
WHITE_SPACE                            constant        char(2)                  initial unaligned dcl 96 ref 675 679 1092
addr                                                   builtin function         dcl 68 ref 341 341 540 540 981 981
addrel                                                 builtin function         dcl 68 ref 994
alt                                    based           char                     unaligned dcl 108 set ref 219* 1007 1007
alt_length               61            based           fixed bin(21,0)          level 2 dcl 109 set ref 217 218* 218 219 976 985*
                                                                                  993 994 996* 1007 1007 1023*
alt_ptr                  56            based           pointer                  level 2 dcl 109 set ref 193 219 994 996* 1007 1007
                                                                                  1036 1061*
answer                          000420 automatic       varying char(20)         dcl 960 set ref 981* 983 988
answer_iocbp              6     000316 automatic       pointer                  initial level 2 dcl 3-7 set ref 3-7*
arg                                    parameter       varying char             dcl 665 in procedure "get_arg" set ref 661 682*
arg                             000100 automatic       varying char(150)        dcl 48 in procedure "fst_edit_" set ref 149* 151 155
                                                                                  489* 490 490 493 493 494 495 499 782* 783 784
basic_source            137(02)        based           bit(1)                   level 3 packed unaligned dcl 109 set ref 893* 894*
before                                                 builtin function         dcl 890 ref 893
block_length                           parameter       fixed bin(21,0)          dcl 708 set ref 702 734* 737* 740* 741 745* 746 759*
                                                                                  764
block_start                            parameter       fixed bin(21,0)          dcl 707 set ref 702 734* 737 739 745 758*
check                                  parameter       fixed bin(17,0)          dcl 956 ref 954 975 1041
cleanup                         000230 stack reference condition                dcl 191 ref 201
code                            000147 automatic       fixed bin(35,0)          dcl 49 set ref 141* 168 168* 221* 237* 238 306* 341*
                                                                                  342 382* 412* 540* 591* 635* 636 636* 783* 851*
                                                                                  933* 934 999* 1000 1034* 1060
command_names                   000045 constant        char(11)                 initial array unaligned dcl 74 set ref 150 151 168*
command_query_                  000010 constant        entry                    external dcl 116 ref 981
continue                               parameter       fixed bin(17,0)          dcl 43 set ref 30 156* 159* 555*
cp_escape_control         1(02) 000316 automatic       bit(2)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7* 980*
create_if_not_found                    parameter       bit(1)                   unaligned dcl 927 set ref 925 933*
default                                parameter       fixed bin(17,0)          dcl 867 ref 865 876
default_code                           parameter       fixed bin(17,0)          dcl 706 ref 702 728 757
delimitor                       000454 automatic       char(1)                  unaligned dcl 1086 set ref 1094* 1096 1101 1104 1109
dfast_error_                    000014 constant        entry                    external dcl 118 ref 168
dfast_get_table_                000060 constant        entry                    external dcl 971 ref 996
dfast_line_table                       based           structure                level 1 dcl 4-15
divide                                                 builtin function         dcl 68 ref 151 636 636 994
done                            000100 automatic       bit(1)                   unaligned dcl 180 set ref 487* 488 500* 503*
edit_ptr                               parameter       pointer                  dcl 41 set ref 30 155 167 193 196 197 198 217 218
                                                                                  218 219 219 237* 258 260 260 261 272* 292 293 301
                                                                                  302 306* 376 378 382* 412* 435 437 438 456 457 459
                                                                                  464 464 466 467 538 539* 552 565 572 591* 611* 629
                                                                                  631 632 634 635 636 636 892 893 894 907 908 910
                                                                                  911 933 976 976 976 984 985 993 994 994 996 996
                                                                                  1007 1007 1007 1007 1013 1013 1013 1018 1019 1020
                                                                                  1023 1024 1026 1027 1028 1029 1031 1036 1061 1061
                                                                                  1062 1063 1064 1129 1130
end_line                        000150 automatic       fixed bin(17,0)          dcl 50 set ref 198* 523* 737 1031*
end_line_number         136            based           fixed bin(17,0)          level 2 dcl 109 set ref 198 293 378 438* 464* 911*
                                                                                  1028 1029* 1031
equal                           000250 automatic       bit(1)                   unaligned dcl 712 set ref 721* 729* 732* 734* 736
error_max_num                          constant        fixed bin(35,0)          initial dcl 2-42 ref 221
explanation_len          14     000316 automatic       fixed bin(21,0)          initial level 2 dcl 3-7 set ref 3-7*
explanation_ptr          12     000316 automatic       pointer                  initial level 2 dcl 3-7 set ref 3-7*
f                                      based           structure                level 1 dcl 109
flags                   137            based           structure                level 2 dcl 109
fst_cv_line_num_                000016 constant        entry                    external dcl 119 ref 783 851
fst_edit_info                          based           structure                level 1 dcl 1-3
fst_get_segment_                000056 constant        entry                    external dcl 930 ref 933
fst_info_                       000020 constant        entry                    external dcl 120 ref 272
fst_info_$header                000022 constant        entry                    external dcl 121 ref 539
fst_run_                        000024 constant        entry                    external dcl 122 ref 611
fst_util_$change                000026 constant        entry                    external dcl 123 ref 237
fst_util_$input                 000030 constant        entry                    external dcl 124 ref 306
fst_util_$merge                 000032 constant        entry                    external dcl 125 ref 382
fst_util_$move                  000034 constant        entry                    external dcl 126 ref 412
fst_util_$resequence            000036 constant        entry                    external dcl 127 ref 591
get_temp_segment_               000012 constant        entry                    external dcl 117 ref 999
hbound                                                 builtin function         dcl 68 ref 150
hcs_$set_bc_seg                 000052 constant        entry                    external dcl 622 ref 635
hcs_$terminate_noname           000040 constant        entry                    external dcl 128 ref 1142
hcs_$truncate_seg               000054 constant        entry                    external dcl 625 ref 636
header                          000240 automatic       bit(1)                   unaligned dcl 479 set ref 485* 493* 535* 539
i                               000302 automatic       fixed bin(21,0)          dcl 845 in procedure "get_number" set ref 847* 848
                                                                                  848* 849* 849 850 851 851 852
i                               000151 automatic       fixed bin(17,0)          dcl 51 in procedure "fst_edit_" set ref 150* 151
                                                                                  151*
i                               000100 automatic       fixed bin(17,0)          dcl 669 in procedure "get_arg" set ref 675* 676 677
                                                                                  678 679* 680 680* 681* 681 682 683
i                               000426 automatic       fixed bin(21,0)          dcl 961 in procedure "merge_add" set ref 1003* 1004
                                                                                  1007 1007 1007 1007 1007*
i                               000456 automatic       fixed bin(17,0)          dcl 1088 in procedure "parse_strings" set ref 1092*
                                                                                  1093 1094 1095 1096* 1097 1098 1100 1101* 1102
                                                                                  1102 1103 1108 1114
i                               000101 automatic       fixed bin(17,0)          dcl 181 in procedure "edit" set ref 215* 216 401*
                                                                                  402 404 407
increment                       000152 automatic       fixed bin(17,0)          dcl 52 set ref 294* 298* 306* 583* 583* 587* 591*
index                                                  builtin function         dcl 68 ref 331 333 339 401 520 749 814 893 908 1096
                                                                                  1101
index_start                            parameter       fixed bin(21,0)          dcl 800 ref 796 810
input_length_save               000104 automatic       fixed bin(17,0)          dcl 184 set ref 403* 406
input_line_length               000153 automatic       fixed bin(17,0)          dcl 53 set ref 144* 148* 148 218 219 403 404* 406*
                                                                                  524 535 672 1090 1092 1096 1101
input_line_start                000154 automatic       fixed bin(17,0)          dcl 54 set ref 147* 407* 499* 499 524 524 535 535
                                                                                  672 675 677* 677 679 682 683* 683 1090 1091 1114*
ioa_$ioa_switch                 000042 constant        entry                    external dcl 129 ref 157
iox_$put_chars                  000044 constant        entry                    external dcl 130 ref 341 540
iox_$user_output                000046 external static pointer                  dcl 131 set ref 157* 341* 540*
j                               000226 automatic       fixed bin(21,0)          dcl 190 in procedure "edit" set ref 333* 334 335 336
                                                                                  339* 340 340* 341* 343 344 409* 410 520* 521 521*
                                                                                  522* 522 523*
j                               000252 automatic       fixed bin(21,0)          dcl 714 in procedure "get_block" set ref 749* 750
                                                                                  750* 751
k                               000103 automatic       fixed bin(21,0)          dcl 183 set ref 331* 332 333 335 336
last_index                      000427 automatic       fixed bin(21,0)          dcl 962 set ref 1002* 1004 1005 1005 1005 1005 1005
                                                                                  1009* 1013 1013 1013 1013 1013
legal_path_chars                000024 constant        char(65)                 initial unaligned dcl 92 ref 514 873
len                             000101 automatic       fixed bin(17,0)          dcl 670 set ref 672* 674 675 678* 678 679 680
length                                                 builtin function         dcl 68 ref 144 499 1129 1130 1131
line                                   parameter       char                     unaligned dcl 42 in procedure "fst_edit_" ref 30 144
                                                                                  145 215 219 401 524 535 675 679 682 1092 1094 1096
                                                                                  1098 1101 1102
line                      1            based           structure                array level 2 in structure "t" dcl 968 in procedure
                                                                                  "merge_add"
line_length                            parameter       fixed bin(21,0)          dcl 804 in procedure "find_first_line" set ref 796
                                                                                  814* 815 815* 819* 824 828*
line_length                     000430 automatic       fixed bin(21,0)          dcl 963 in procedure "merge_add" set ref 1004* 1009
line_number                            parameter       fixed bin(17,0)          dcl 803 in procedure "find_first_line" ref 796 816
                                                                                  817
line_number                            parameter       fixed bin(17,0)          dcl 844 in procedure "get_number" set ref 841 851*
line_start                             parameter       fixed bin(21,0)          dcl 802 in procedure "find_first_line" set ref 796
                                                                                  810* 812 813* 814 815 824* 824
line_start                      000251 automatic       fixed bin(21,0)          dcl 713 in procedure "get_block" set ref 739* 743*
                                                                                  745 749 750 751* 751
line_start                      000431 automatic       fixed bin(21,0)          dcl 964 in procedure "merge_add" set ref 1004* 1005
                                                                                  1005 1005 1009
literal_sw                1(05) 000316 automatic       bit(1)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7*
max_num_digits                         constant        fixed bin(17,0)          initial dcl 104 ref 216
max_seg_size             62            based           fixed bin(21,0)          level 2 dcl 109 ref 1129 1130
message                         000155 automatic       char(150)                unaligned dcl 55 set ref 140* 168 168* 239* 305 349*
                                                                                  381 388 388* 416* 419* 422* 488 491* 496* 506 518*
                                                                                  524* 530* 534 558* 590 611 723* 741 746* 761* 763
                                                                                  765* 784* 812 822* 830 832* 852* 854* 874* 878*
                                                                                  935* 937* 1003 1012 1043* 1104* 1108* 1109* 1111*
                                                                                  1113 1118* 1133*
must_be_equal                          parameter       bit(1)                   unaligned dcl 801 ref 796 818 831
new_string                      000156 automatic       varying char(150)        dcl 188 in procedure "edit" set ref 234* 237*
new_string                             parameter       varying char             dcl 1084 in procedure "parse_strings" set ref 1080
                                                                                  1102* 1103*
next_position                   000236 automatic       fixed bin(17,0)          dcl 209 set ref 213* 217* 219
null                                                   builtin function         dcl 68 ref 3-7 3-7 3-7 200 998 1034 1142 1143
num                             000224 automatic       fixed bin(17,0)          dcl 57 in procedure "fst_edit_" set ref 302* 303*
                                                                                  306* 369* 370* 372 408* 409* 412*
num                                    parameter       fixed bin(17,0)          dcl 780 in procedure "parse_number" set ref 778 783*
num                             000253 automatic       fixed bin(17,0)          dcl 715 in procedure "get_block" set ref 743* 744
num                             000272 automatic       fixed bin(17,0)          dcl 808 in procedure "find_first_line" set ref 813*
                                                                                  816 817
num_1                           000254 automatic       fixed bin(17,0)          dcl 716 set ref 719* 722 734*
num_2                           000255 automatic       fixed bin(17,0)          dcl 717 set ref 720* 722 730* 737 744
num_chars                 3            based           fixed bin(21,0)          array level 3 in structure "t" dcl 968 in procedure
                                                                                  "merge_add" ref 1007 1007 1007 1029
num_chars                       000106 automatic       fixed bin(21,0)          dcl 186 in procedure "edit" set ref 235* 237* 257*
                                                                                  258 259 260 296* 297 327* 330 331 336* 336 339 340
                                                                                  344* 344 347* 370* 371 405* 411 412* 537* 540*
num_left                        000237 automatic       fixed bin(21,0)          dcl 252 set ref 258* 259 259 259 262
number                    1            based           fixed bin(17,0)          array level 3 dcl 968 ref 1004 1028 1029
old_string                             parameter       varying char             dcl 1083 in procedure "parse_strings" set ref 1080
                                                                                  1098*
old_string                      000107 automatic       varying char(150)        dcl 187 in procedure "edit" set ref 234* 237* 239
                                                                                  326* 331 349
padding                   1(07) 000316 automatic       bit(29)                  initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7*
path                                   parameter       varying char(168)        dcl 928 in procedure "get_seg_ptr" set ref 925 932
                                                                                  933* 935
path                                   parameter       varying char(168)        dcl 868 in procedure "parse_pathname" set ref 865
                                                                                  870* 872* 873 874
path                            000225 automatic       varying char(168)        dcl 58 in procedure "fst_edit_" set ref 367* 368*
                                                                                  434* 435 454* 455* 459 486* 491* 495 495* 513 514
                                                                                  515* 518 530 538 538* 539* 606* 609 611* 628* 629
                                                                                  629* 630* 632
pathname                               based           varying char(168)        level 2 dcl 109 set ref 435* 459* 467* 538 629 632*
                                                                                  892
print_prompt_char                      parameter       bit(1)                   unaligned dcl 44 set ref 30 167* 223*
prompt                  137(03)        based           bit(1)                   level 3 packed unaligned dcl 109 set ref 167 565*
                                                                                  572*
prompt_after_explanation
                          1(06) 000316 automatic       bit(1)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7*
query_code                3     000316 automatic       fixed bin(35,0)          initial level 2 dcl 3-7 set ref 3-7*
query_info                      000316 automatic       structure                level 1 dcl 3-7 set ref 981 981
query_info_version_6                   constant        fixed bin(17,0)          initial dcl 3-36 ref 977
question_iocbp            4     000316 automatic       pointer                  initial level 2 dcl 3-7 set ref 3-7*
release_temp_segment_           000050 constant        entry                    external dcl 132 ref 1034 1143
repeat_time              10     000316 automatic       fixed bin(71,0)          initial level 2 dcl 3-7 set ref 3-7*
request                         000300 automatic       fixed bin(17,0)          dcl 59 in procedure "fst_edit_" set ref 142* 145*
                                                                                  150 151* 154 165* 167 168
request                                parameter       fixed bin(17,0)          dcl 176 in procedure "edit" ref 174 203
reverse                                                builtin function         dcl 68 ref 333 520 892 893 908
reverse_pathname                000320 automatic       varying char(168)        dcl 888 set ref 892* 893 893
save_ptr                        000432 automatic       pointer                  dcl 965 set ref 1018* 1021
search                                                 builtin function         dcl 68 ref 679
seg                                    based           char                     unaligned dcl 111 set ref 382*
seg_length                      000301 automatic       fixed bin(21,0)          dcl 60 set ref 382 382 456 517 933*
seg_ptr                         000302 automatic       pointer                  dcl 61 set ref 200* 382 457 516 631 635* 636* 933*
                                                                                  1142 1142*
seq_number                      000223 automatic       fixed bin(17,0)          dcl 56 set ref 293* 295* 296* 301* 306* 372* 377*
                                                                                  378* 382* 582* 586* 591*
set_last_number                        parameter       bit(1)                   unaligned dcl 1058 ref 1056 1066
start                           000225 automatic       fixed bin(21,0)          dcl 189 in procedure "edit" set ref 235* 237* 257*
                                                                                  258 259 259 292* 296* 297* 297 302 303* 306* 327*
                                                                                  331 333 335* 335 339 341 341 343* 343 370* 371*
                                                                                  371 376* 377 382* 405* 411 411 412* 537* 540 540
start                                  parameter       fixed bin(21,0)          dcl 843 in procedure "get_number" ref 841 847 848
                                                                                  851 851 852
start                           000402 automatic       fixed bin(21,0)          dcl 905 in procedure "set_end_number" set ref 908*
                                                                                  909 909* 910* 910 911*
start                           000455 automatic       fixed bin(17,0)          dcl 1087 in procedure "parse_strings" set ref 1091*
                                                                                  1092 1092 1094 1095* 1095 1096 1096 1098 1100*
                                                                                  1100 1101 1101 1102 1114
start                     2            based           fixed bin(21,0)          array level 3 in structure "t" dcl 968 in procedure
                                                                                  "merge_add" ref 1007 1007
status_code               2     000316 automatic       fixed bin(35,0)          initial level 2 dcl 3-7 set ref 3-7*
string                                 parameter       char                     unaligned dcl 1127 ref 1125 1129 1130 1130 1131
string_found                    000102 automatic       bit(1)                   unaligned dcl 182 set ref 329* 345* 349
substr                                                 builtin function         dcl 68 set ref 145 219* 259* 259 331 333 339 341 341
                                                                                  494 520 524 535 540 540 675 679 682 749 814 847
                                                                                  851 851 852 908 1005 1005 1007 1007 1013 1013 1092
                                                                                  1094 1096 1098 1101 1102 1130*
subsystem               137            based           bit(1)                   level 3 packed unaligned dcl 109 ref 155 552
suppress_name_sw          1(01) 000316 automatic       bit(1)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7* 979*
suppress_spacing          1(04) 000316 automatic       bit(1)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7*
switches                  1     000316 automatic       structure                level 2 dcl 3-7
t                                      based           structure                level 1 dcl 968
t_length                        000304 automatic       fixed bin(21,0)          dcl 62 set ref 197* 259 259 331 333 339 341 341 456*
                                                                                  457 457 517* 518 519 520 520 522 540 540 631 631
                                                                                  737 749 750 759 812 814 815 847 848 851 851 852
                                                                                  908 1005 1005 1013 1013 1027* 1042 1063*
t_ptr                           000306 automatic       pointer                  dcl 63 set ref 196* 259 259 331 333 339 341 341 516*
                                                                                  520 540 540 749 814 847 851 851 852 908 1005 1005
                                                                                  1013 1013 1026* 1062*
table_length                           based           fixed bin(21,0)          level 2 dcl 968 set ref 995* 1003 1028 1029 1029
table_ptr                       000434 automatic       pointer                  dcl 966 set ref 994* 995 996* 1003 1004 1007 1007
                                                                                  1007 1007 1007 1028 1028 1029 1029 1029 1029
target_index                    000105 automatic       fixed bin(21,0)          dcl 185 set ref 409* 410* 410 411 411 412*
temp                                   based           char                     unaligned dcl 112 set ref 1130*
temp_length                     000310 automatic       fixed bin(21,0)          dcl 64 set ref 195* 237* 306* 382* 412* 591* 997*
                                                                                  1020 1025* 1063 1129 1130 1131* 1131
temp_ptr                        000312 automatic       pointer                  dcl 65 set ref 193* 998* 999* 1019 1021* 1034 1034*
                                                                                  1036* 1062 1130 1143 1143*
temp_ptr_is_temp_seg            000314 automatic       bit(1)                   dcl 66 set ref 194* 1001* 1035* 1143
text                                   based           char                     unaligned dcl 110 set ref 259* 259 331 333 339 341
                                                                                  341 457* 457 520 540 540 631* 631 749 814 847 851
                                                                                  851 852 908 1005 1005 1013 1013
text_length              60            based           fixed bin(21,0)          level 2 dcl 109 set ref 197 258 260* 260 292 301 302
                                                                                  376 437* 456* 464 466* 635 636 636 907 908 910 976
                                                                                  1013 1013 1013 1020* 1027 1063*
text_modified           137(01)        based           bit(1)                   level 3 packed unaligned dcl 109 set ref 261* 634*
                                                                                  976 984* 1024* 1064*
text_ptr                 54            based           pointer                  level 2 dcl 109 set ref 196 457 631 1018 1019* 1026
                                                                                  1061 1062*
two_strings                            parameter       bit(1)                   unaligned dcl 1082 ref 1080 1099
verify                                                 builtin function         dcl 68 ref 145 215 494 514 675 847 873 1092
version                         000316 automatic       fixed bin(17,0)          level 2 dcl 3-7 set ref 977*
working_dir              63            based           varying char(168)        level 2 dcl 109 set ref 933*
yes_or_no_sw              1     000316 automatic       bit(1)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7* 978*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
error_access_mode                      internal static fixed bin(35,0)          initial dcl 2-33
error_alt_empty                        internal static fixed bin(35,0)          initial dcl 2-3
error_bad_line                         internal static fixed bin(35,0)          initial dcl 2-28
error_bad_name                         internal static fixed bin(35,0)          initial dcl 2-11
error_bad_pathname                     internal static fixed bin(35,0)          initial dcl 2-32
error_bad_rec_len                      internal static fixed bin(35,0)          initial dcl 2-36
error_bad_req                          internal static fixed bin(35,0)          initial dcl 2-12
error_bad_sort                         internal static fixed bin(35,0)          initial dcl 2-24
error_bad_type                         internal static fixed bin(35,0)          initial dcl 2-20
error_block_spec                       internal static fixed bin(35,0)          initial dcl 2-17
error_cur_empty                        internal static fixed bin(35,0)          initial dcl 2-5
error_delimiter_miss                   internal static fixed bin(35,0)          initial dcl 2-34
error_dprint_map                       internal static fixed bin(35,0)          initial dcl 2-41
error_edit_max_num                     internal static fixed bin(35,0)          initial dcl 2-43
error_line_miss                        internal static fixed bin(35,0)          initial dcl 2-26
error_line_order                       internal static fixed bin(35,0)          initial dcl 2-30
error_long_rec                         internal static fixed bin(35,0)          initial dcl 2-8
error_max_args                         internal static fixed bin(35,0)          initial dcl 2-39
error_max_line_number                  internal static fixed bin(35,0)          initial dcl 2-38
error_max_lines                        internal static fixed bin(35,0)          initial dcl 2-31
error_max_size                         internal static fixed bin(35,0)          initial dcl 2-4
error_name_dup                         internal static fixed bin(35,0)          initial dcl 2-7
error_name_miss                        internal static fixed bin(35,0)          initial dcl 2-14
error_name_sys                         internal static fixed bin(35,0)          initial dcl 2-40
error_no_comp                          internal static fixed bin(35,0)          initial dcl 2-15
error_no_expl                          internal static fixed bin(35,0)          initial dcl 2-10
error_no_main                          internal static fixed bin(35,0)          initial dcl 2-16
error_no_new_line                      internal static fixed bin(35,0)          initial dcl 2-45
error_no_nl                            internal static fixed bin(35,0)          initial dcl 2-23
error_no_num                           internal static fixed bin(35,0)          initial dcl 2-25
error_no_string                        internal static fixed bin(35,0)          initial dcl 2-29
error_no_suffix                        internal static fixed bin(35,0)          initial dcl 2-22
error_not_saved                        internal static fixed bin(35,0)          initial dcl 2-6
error_obj_nop                          internal static fixed bin(35,0)          initial dcl 2-18
error_request_miss                     internal static fixed bin(35,0)          initial dcl 2-27
error_sav_cur                          internal static fixed bin(35,0)          initial dcl 2-19
error_size_fixed_record                internal static fixed bin(35,0)          initial dcl 2-35
error_string_size                      internal static fixed bin(35,0)          initial dcl 2-37
error_syntax_string                    internal static fixed bin(35,0)          initial dcl 2-13
error_un_num_text                      internal static fixed bin(35,0)          initial dcl 2-44
error_unkn_sys                         internal static fixed bin(35,0)          initial dcl 2-21
error_unknown_arg                      internal static fixed bin(35,0)          initial dcl 2-9
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 3-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 3-34
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 3-35

NAMES DECLARED BY EXPLICIT CONTEXT.
copy                            006173 constant        entry                    internal dcl 1125 ref 1005 1007 1013
edit                            000752 constant        entry                    internal dcl 174 ref 165
find_first_line                 004241 constant        entry                    internal dcl 796 ref 296 370 409 734 1004
fst_edit_                       000472 constant        entry                    external dcl 30
get_arg                         003543 constant        entry                    internal dcl 661 ref 149 489 491 782 872
get_block                       003661 constant        entry                    internal dcl 702 ref 235 257 327 405 537
get_number                      004404 constant        entry                    internal dcl 841 ref 303 523 743 813 911
get_seg_ptr                     005016 constant        entry                    internal dcl 925 ref 368 455 515 630
label                           000000 constant        label                    array(0:16) dcl 209 ref 203
merge_add                       005121 constant        entry                    internal dcl 954 ref 232 256 290 324 365 399 432 452
                                                                                  532 555 580 609 627
parse_number                    004132 constant        entry                    internal dcl 778 ref 295 298 369 408 582 583 719 720
parse_pathname                  004533 constant        entry                    internal dcl 865 ref 367 434 454 606 628
parse_strings                   005731 constant        entry                    internal dcl 1080 ref 234 326
set_basic_source                004643 constant        entry                    internal dcl 886 ref 436 460 633
set_end_number                  004732 constant        entry                    internal dcl 903 ref 262 465 1030 1066
switch_buffers                  005670 constant        entry                    internal dcl 1056 ref 238 307 383 414 592
term_seg                        006234 constant        entry                    internal dcl 1140 ref 201 385 458 543 638

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10124       10206    7622       10134
Length     10524    7622        62         302     301           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
fst_edit_                           250 external procedure  is an external procedure.  
edit                                522 internal procedure  enables or reverts conditions.  
on unit on line 201                  64 on unit               
get_arg                              67 internal procedure  is called by several nonquick procedures.  
get_block                               internal procedure  shares stack frame of internal procedure edit.  
parse_number                            internal procedure  shares stack frame of internal procedure edit.  
find_first_line                         internal procedure  shares stack frame of internal procedure edit.  
get_number                              internal procedure  shares stack frame of internal procedure edit.  
parse_pathname                          internal procedure  shares stack frame of internal procedure edit.  
set_basic_source                        internal procedure  shares stack frame of internal procedure edit.  
set_end_number                          internal procedure  shares stack frame of internal procedure edit.  
get_seg_ptr                             internal procedure  shares stack frame of internal procedure edit.  
merge_add                               internal procedure  shares stack frame of internal procedure edit.  
switch_buffers                          internal procedure  shares stack frame of internal procedure edit.  
parse_strings                           internal procedure  shares stack frame of internal procedure edit.  
copy                                 65 internal procedure  is called during a stack extension.  
term_seg                             86 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
edit                     000100 done                        edit
                         000101 i                           edit
                         000102 string_found                edit
                         000103 k                           edit
                         000104 input_length_save           edit
                         000105 target_index                edit
                         000106 num_chars                   edit
                         000107 old_string                  edit
                         000156 new_string                  edit
                         000225 start                       edit
                         000226 j                           edit
                         000236 next_position               edit
                         000237 num_left                    edit
                         000240 header                      edit
                         000250 equal                       get_block
                         000251 line_start                  get_block
                         000252 j                           get_block
                         000253 num                         get_block
                         000254 num_1                       get_block
                         000255 num_2                       get_block
                         000272 num                         find_first_line
                         000302 i                           get_number
                         000320 reverse_pathname            set_basic_source
                         000402 start                       set_end_number
                         000420 answer                      merge_add
                         000426 i                           merge_add
                         000427 last_index                  merge_add
                         000430 line_length                 merge_add
                         000431 line_start                  merge_add
                         000432 save_ptr                    merge_add
                         000434 table_ptr                   merge_add
                         000454 delimitor                   parse_strings
                         000455 start                       parse_strings
                         000456 i                           parse_strings
fst_edit_                000100 arg                         fst_edit_
                         000147 code                        fst_edit_
                         000150 end_line                    fst_edit_
                         000151 i                           fst_edit_
                         000152 increment                   fst_edit_
                         000153 input_line_length           fst_edit_
                         000154 input_line_start            fst_edit_
                         000155 message                     fst_edit_
                         000223 seq_number                  fst_edit_
                         000224 num                         fst_edit_
                         000225 path                        fst_edit_
                         000300 request                     fst_edit_
                         000301 seg_length                  fst_edit_
                         000302 seg_ptr                     fst_edit_
                         000304 t_length                    fst_edit_
                         000306 t_ptr                       fst_edit_
                         000310 temp_length                 fst_edit_
                         000312 temp_ptr                    fst_edit_
                         000314 temp_ptr_is_temp_seg        fst_edit_
                         000316 query_info                  fst_edit_
get_arg                  000100 i                           get_arg
                         000101 len                         get_arg

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other_desc call_int_other      return_mac          enable_op           shorten_stack       ext_entry_desc
int_entry           int_entry_desc      reverse_cs          set_chars_eis       index_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
command_query_                dfast_error_                  dfast_get_table_              fst_cv_line_num_
fst_get_segment_              fst_info_                     fst_info_$header              fst_run_
fst_util_$change              fst_util_$input               fst_util_$merge               fst_util_$move
fst_util_$resequence          get_temp_segment_             hcs_$set_bc_seg               hcs_$terminate_noname
hcs_$truncate_seg             ioa_$ioa_switch               iox_$put_chars                release_temp_segment_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     30 000465    3    7 000505       140 000535       141 000540       142 000541       144 000543       145 000545
    147 000562       148 000564       149 000566       150 000605       151 000616       152 000631       154 000633
    155 000636       156 000651       157 000652       158 000671       159 000672       160 000675       165 000676
    167 000704       168 000715       170 000750       174 000751       193 000757       194 000765       195 000766
    196 000767       197 000773       198 000775       200 000777       201 001001       203 001023       213 001026
    215 001027       216 001044       217 001046       218 001053       219 001055       220 001063       221 001064
    223 001066       224 001072       232 001073       234 001100       235 001110       237 001115       238 001155
    239 001166       244 001172       256 001173       257 001200       258 001205       259 001216       260 001232
    261 001234       262 001236       266 001245       272 001246       275 001257       290 001260       292 001266
    293 001275       294 001277       295 001301       296 001314       297 001344       298 001346       300 001362
    301 001363       302 001373       303 001405       305 001422       306 001427       307 001453       311 001460
    324 001461       326 001466       327 001477       329 001504       330 001505       331 001510       332 001523
    333 001524       334 001535       335 001536       336 001542       339 001546       340 001561       341 001564
    342 001605       343 001610       344 001612       345 001614       346 001616       347 001617       348 001620
    349 001621       350 001641       354 001642       365 001643       367 001651       368 001667       369 001710
    370 001724       371 001754       372 001756       374 001761       376 001762       377 001771       378 001776
    381 002000       382 002005       383 002045       385 002047       387 002054       388 002055       391 002065
    399 002066       401 002073       402 002110       403 002111       404 002113       405 002116       406 002123
    407 002126       408 002131       409 002144       410 002174       411 002200       412 002207       414 002234
    415 002236       416 002237       418 002243       419 002244       421 002250       422 002251       424 002254
    432 002255       434 002262       435 002301       436 002312       437 002313       438 002320       442 002321
    452 002322       454 002327       455 002345       456 002366       457 002375       458 002402       459 002407
    460 002420       464 002421       465 002432       466 002437       467 002444       474 002445       485 002446
    486 002450       487 002452       488 002453       489 002463       490 002503       491 002516       492 002542
    493 002543       494 002557       495 002567       496 002602       497 002605       499 002606       500 002610
    502 002612       503 002613       504 002615       506 002616       513 002623       514 002630       515 002643
    516 002663       517 002667       518 002671       519 002710       520 002713       521 002727       522 002733
    523 002737       524 002754       529 002776       530 002777       531 003014       532 003016       534 003023
    535 003030       537 003047       538 003054       539 003072       540 003112       543 003136       546 003143
    552 003144       555 003153       556 003164       558 003165       560 003170       565 003171       568 003177
    572 003200       575 003206       580 003207       582 003214       583 003230       584 003247       586 003250
    587 003253       590 003255       591 003262       592 003302       597 003304       606 003305       609 003324
    611 003337       613 003362       627 003363       628 003370       629 003407       630 003425       631 003442
    632 003455       633 003462       634 003463       635 003471       636 003507       638 003534       643 003541
    661 003542       672 003556       674 003563       675 003564       676 003601       677 003602       678 003605
    679 003611       680 003624       681 003630       682 003632       683 003644       684 003646       688 003653
    702 003661       719 003663       720 003670       721 003675       722 003676       723 003701       724 003705
    726 003713       728 003714       729 003720       730 003722       731 003724       732 003725       734 003727
    736 003755       737 003766       739 004000       740 004003       741 004004       743 004014       744 004021
    745 004024       746 004030       749 004035       750 004056       751 004063       752 004064       755 004065
    757 004066       758 004072       759 004074       760 004077       761 004100       763 004104       764 004111
    765 004121       768 004124       778 004132       782 004134       783 004155       784 004226       787 004233
    796 004241       810 004243       812 004245       813 004257       814 004274       815 004316       816 004323
    817 004326       818 004334       819 004341       820 004342       822 004347       824 004352       826 004354
    828 004355       830 004356       831 004362       832 004374       835 004377       841 004404       847 004406
    848 004430       849 004436       850 004440       851 004442       852 004511       853 004521       854 004522
    856 004525       865 004533       870 004535       872 004537       873 004557       874 004601       875 004617
    876 004621       878 004632       880 004636       886 004643       892 004644       893 004664       894 004725
    896 004731       903 004732       907 004734       908 004742       909 004756       910 004762       911 004766
    914 005011       925 005016       932 005020       933 005026       934 005067       935 005100       936 005106
    937 005107       939 005113       954 005121       975 005123       976 005126       977 005141       978 005143
    979 005145       980 005147       981 005153       983 005207       984 005214       985 005222       986 005223
    988 005231       993 005244       994 005252       995 005257       996 005260       997 005302       998 005304
    999 005306      1000 005331      1001 005334      1002 005336      1003 005337      1004 005354      1005 005373
   1007 005423      1009 005460      1011 005465      1012 005467      1013 005474      1018 005526      1019 005535
   1020 005537      1021 005543      1023 005545      1024 005550      1025 005552      1026 005553      1027 005555
   1028 005557      1029 005566      1030 005574      1031 005601      1034 005607      1035 005636      1036 005640
   1041 005645      1042 005651      1043 005653      1044 005656      1047 005663      1056 005670      1060 005672
   1061 005675      1062 005702      1063 005707      1064 005714      1066 005716      1069 005730      1080 005731
   1090 005747      1091 005753      1092 005754      1093 005773      1094 005775      1095 006002      1096 006004
   1097 006020      1098 006021      1099 006032      1100 006037      1101 006043      1102 006061      1103 006073
   1104 006077      1105 006112      1106 006113      1108 006114      1109 006121      1110 006134      1111 006136
   1113 006141      1114 006146      1115 006152      1117 006160      1118 006161      1120 006164      1125 006172
   1129 006206      1130 006215      1131 006225      1132 006226      1133 006227      1135 006232      1140 006233
   1142 006241      1143 006257      1145 006312


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
