ASSEMBLY LISTING OF SEGMENT >special_ldd>install>MR12.0-1206>lisp_alloc_.alm                 
ASSEMBLED ON:	11/05/86  1101.3 mst Wed
OPTIONS USED:	list 
ASSEMBLED BY:	ALM Version  6.7  October 1986  
ASSEMBLER CREATED:	10/08/86  1557.5 mst Wed

                                     1  " **************************************************************
                                     2  " *                                                            *
                                     3  " * Copyright, (C) Massachusetts Institute of Technology, 1973 *
                                     4  " *                                                            *
                                     5  " **************************************************************
    000000                           6  	name	lisp_alloc_	" lisp allocator.
                                     7  
                                     8  	use	static		" static variables.
                                     9  	join	/link/static
                                    10  
                        000010      11  	segdef	alloc_info
    000010                          12  alloc_info:
                        000010      13  	segdef	alloc_fault_word
    000010                          14  alloc_fault_word:
    000010  aa   000000 000000      15  	dec	0		" this word is non-zero to indicate that interrupts
                                    16  				" must be masked temporarily, while data is inconsistent.
                                    17  				" upper half is set to non-zero, lower two bits recor
                                    18  				" quit and alarm faults as they happen, for later signalling.
                                    19  
                        000011      20  	segdef	gc_blk_cntr
    000011                          21  gc_blk_cntr:
    000011  aa   000000 000000      22  	dec	0		" this word counts the number of blocks to garbage collection.
                                    23  				" if negative, that many more 16K blocks will be allocated.
                        000012      24  	segdef	seg_blk_cntr
    000012                          25  seg_blk_cntr:
    000012  aa   000000 000000      26  	dec	0		" this word counts the number of blocks left before the
                                    27  				" end of the current segment.
    000013  aa   000000 0110 03     28  	even
                        000014      29  	segdef	consptr
    000014  aa   077777 000043      30  consptr:	its	-1,1,ad		" this pointer points at the segment's ad indirect word.
    000015  aa   000001 000053 
                                    31  
                        000016      32  	segdef	cur_seg
    000016  aa   077777 000043      33  cur_seg:	its	-1,1		" this pointer points at the current segment's base.
    000017  aa   000001 000000 
                                    34  
                                    35  "
                                    36  	use	program
                                    37  	join	/text/program
                                    38  
                                    39  " subroutines to go from lisp calling discipline to PL/I and back.
                                    40  "
                                    41  
                                    42  	tempd	arglist(4),new_seg_ptr
                                    43  
                                    44  	even
    000000                          45  noargs:
    000000  aa   000000 000004      46  	oct	4
    000001  aa   000000 000000      47  	oct	0
    000002                          48  header_for_1_arg:
    000002  aa   000002 000004      49  	oct	2000004		" pl1 arg header, 1 argument.
    000003  aa   000000 000000      50  	oct	0
                                    51  
    000004                          52  save_for_pl1_call:			" routine to switch to PL/I conventions, and get a stack
                                    53  				" frame to call out from.
                                    54  
    000004  4a  4 00022 2501 20     55  	spriap	<lisp_static_vars_>|[stack_ptr]
    000005  4a  4 00024 7471 20     56  	stx7	<lisp_static_vars_>|[unmkd_ptr]+1
    000006  aa  1 00016 5541 00     57  	stc1	ab|in_pl1_code	" remember we are using these conventions now.
    000007  aa   000100 6270 00     58  	push
    000010  aa  7 00040 2721 20
    000011  4a  4 00026 3521 20     59  	eppbp	<lisp_alloc_>|[lisp_alloc_]	set entry pointer
    000012  aa  6 00026 2521 00     60  	spribp	sp|stack_frame.entry_ptr
    000013  aa   000000 7100 16     61  	tra	0,x6		" return. x6 is not used by save macro.
                                    62  
    000014                          63  pop_back_to_lisp:			" routine to get rid of stack frame, 
                                    64  				" and re-enter lisp code.
    000014  aa  7 00024 6521 00     65  	sprisp	sb|stack_header.stack_end_ptr
    000015  aa  6 00020 3721 20     66  	eppsp	sp|16,*		" get back to prev stack frame.
    000016                          67  switch_to_lisp:			" alternate entry for entering lisp conventions.
    000016  4a  4 00030 3511 20     68  	epbpab	<lisp_static_vars_>|[unmkd_ptr],*
    000017  4a  4 00032 3501 20     69  	eppap	<lisp_static_vars_>|[stack_ptr],*
    000020  4a  4 00024 2271 20     70  	ldx7	<lisp_static_vars_>|[unmkd_ptr]+1
    000021  aa  1 00016 4501 00     71  	stz	ab|in_pl1_code
    000022  aa   000000 7100 16     72  	tra	0,x6		" return to caller.
                                    73  
                                    74  
                                    75  "
                                    76  "	Subroutine to allocate 4 words for a cons. called with a tsx6.
                                    77  
    000023                          78  cons_alloc:
    000023  9a  4 00010 5541 00     79  	stc1	lp|alloc_fault_word		" inhibit interrupts.
    000024  9a  4 00014 3521 20     80  	eppbp	lp|consptr,*		" use pointer with ad modifier to do work.
    000025  0a   000056 6064 00     81  	ttn	tally_out
                                    82  
    000026                          83  ret_alloc:
    000026  9a  4 00010 0341 00     84  	ldac	lp|alloc_fault_word
    000027  aa   000007 3750 07     85  	ana	=o7,dl			" mask out low order bits.
    000030  aa   000000 6000 16     86  	tze	0,x6			" return if no interrupts.
                                    87  
                                    88  "
                                    89  "	code to handle faults in alloc here.
                                    90  "
    000031                          91  alloc_got_fault:				" operators for allocation join here after saving other things.
    000031  aa   000004 6270 17     92  	eax7	4,x7			" get space to save useful regs.
    000032  aa  1 77774 2521 17     93  	spribp	ab|-4,x7			" bp points to space we just allocated.
    000033  aa  1 77776 7551 17     94  	sta	ab|-2,x7			" a contains argument for fault decoding.
    000034  aa  1 77777 7461 17     95  	stx6	ab|-1,x7			" x6 contains eventual return address.
    000035  aa  1 77777 4451 17     96  	sxl5	ab|-1,x7
    000036  aa   777746 7060 04     97  	tsx6	save_for_pl1_call-*,ic	" save, and switch to pl1 conventions.
    000037  4a  4 00030 3521 20     98  	eppbp	<lisp_static_vars_>|[unmkd_ptr],*
    000040  aa  2 77776 3521 00     99  	eppbp	bp|-2			" get address of saved fault bits.
    000041  aa  6 00052 2521 00    100  	spribp	arglist+2			" and set as first arg to handler
    000042  aa   777740 2370 04    101  	ldaq	header_for_1_arg-*,ic	" get arglist header for 1 arg.
    000043  aa  6 00050 7571 00    102  	staq	arglist
    000044  aa  6 00050 3501 00    103  	eppap	arglist
    000045  4a  4 00034 3521 20    104  	short_call <lisp_default_handler_>|[alloc_fault]
    000046  aa  7 00036 6701 20
    000047  aa  6 00030 3701 20
    000050  aa   777744 7060 04    105  	tsx6	pop_back_to_lisp-*,ic	" remove stack frame, and reload ap,ab,x7.
    000051  aa  1 77777 2261 17    106  	ldx6	ab|-1,x7			" reload return address.
    000052  aa  1 77777 7251 17    107  	lxl5	ab|-1,x7			"reload saved x5.
    000053  aa  1 77774 3521 37    108  	eppbp	ab|-4,x7*			" reload pointer to space allocated.
    000054  aa   777774 6270 17    109  	eax7	-4,x7
    000055  aa   000000 7100 16    110  	tra	0,x6
                                   111  
                                   112  
                                   113  
                                   114  
                                   115  
    000056                         116  tally_out:
    000056  9a  4 00011 0541 00    117  	aos	lp|gc_blk_cntr		" one less block remains till gc.
    000057  aa   000002 6040 04    118  	tmi	2,ic			" if more before gc, continue.
    000060  aa   000102 7040 04    119  	tsx4	must_gc-*,ic		" if no more, go gc.
    000061  9a  4 00012 0541 00    120  	aos	lp|seg_blk_cntr		" one less block in segment, too.
    000062  aa   000035 6000 04    121  	tze	get_new_seg-*,ic		" get new segment if needed.
                                   122  
                                   123  				" otherwise, check for interrupt, and return.
    000063  0a   000026 7100 00    124  	tra	ret_alloc
                                   125  "
                                   126  " 	Subroutine to allocate words (multiple of 4) in q. Called with tsx6.
                                   127  
                        000064     128  	segdef	words_alloc
    000064                         129  words_alloc:
    000064  9a  4 00010 5541 00    130  	stc1	lp|alloc_fault_word		" inhibit interrupts.
    000065  aa   777774 6200 06    131  	eax0	-4,ql			" number of words to allocate.
    000066  9a  4 00014 3521 20    132  	eppbp	lp|consptr,*		" let the ad modifier do the work.
                                   133  					" if no tally out, keep going.
    000067  aa   000005 6064 04    134  	ttn	tally_done-*,ic		" otherwise, end of core block.
                                   135  
    000070                         136  alloc_loop:
    000070  aa   777774 6200 10    137  	eax0	-4,x0			" 4 more words gotten by ad modifier,
    000071  aa   777735 6040 04    138  	tmi	ret_alloc-*,ic		" if no more, then we can return!
    000072  9a  4 00014 6211 20    139  	eax1	lp|consptr,*		" ad modifier gets more space, as side effect.
    000073  aa   777775 6070 04    140  	ttf	alloc_loop-*,ic		" and if not at end of block, keep going.
                                   141  
    000074                         142  tally_done:
    000074  9a  4 00011 0541 00    143  	aos	lp|gc_blk_cntr		" reduce number of blocks before next gc.
    000075  aa   000002 6040 04    144  	tmi	2,ic			" if more before gc, continue.
    000076  aa   000064 7040 04    145  	tsx4	must_gc-*,ic		" if no more, garbage collect now.
    000077  9a  4 00012 0541 00    146  	aos	lp|seg_blk_cntr		" reduce number of blocks to seg end.
    000100  aa   777770 6040 04    147  	tmi	alloc_loop-*,ic		" if still more in segment, just continue.
    000101  aa   000016 7100 04    148  	tra	get_new_seg-*,ic
                                   149  
    000102                         150  locked_alloc:		" routine to alloc words when already locked, and no gc allowed
    000102  0a   000104 6210 00    151  	eax1	*+2	"simulate stc1 effect.
    000103  9a  4 00010 7411 00    152  	stx1	lp|alloc_fault_word
    000104  aa   777774 6200 06    153  	eax0	-4,ql
    000105  9a  4 00014 3521 20    154  	eppbp	lp|consptr,*
    000106  0a   000113 6064 00    155  	ttn	lock_tally_done
    000107                         156  lock_alloc_loop:
    000107  aa   777774 6200 10    157  	eax0	-4,x0
    000110  aa   000000 6040 16    158  	tmi	0,x6
    000111  9a  4 00014 6211 20    159  	eax1	lp|consptr,*
    000112  0a   000107 6070 00    160  	ttf	lock_alloc_loop
                                   161  
    000113                         162  lock_tally_done:
    000113  9a  4 00011 0541 00    163  	aos	lp|gc_blk_cntr		" caller's responsibility to check gc_blk_cntr.
    000114  9a  4 00012 0541 00    164  	aos	lp|seg_blk_cntr
    000115  0a   000107 6040 00    165  	tmi	lock_alloc_loop
    000116  0a   000117 7100 00    166  	tra	get_new_seg
                                   167  "
                                   168  "	Subroutine to get a new allocation segment. lp|alloc_fault_word is set,
                                   169  "	so a ret instruction will go back and redo allocation.
                                   170  
    000117                         171  get_new_seg:
    000117  aa   000002 6270 17    172  	eax7	2,x7			" get room for save of caller's return address
    000120  aa  1 77776 7461 17    173  	stx6	ab|-2,x7
    000121  aa  1 77776 4451 17    174  	sxl5	ab|-2,x7			" save x5 for lsubr callers.
    000122  aa  1 77777 7561 17    175  	stq	ab|-1,x7			" and num words to allocate.
    000123  aa   777661 7060 04    176  	tsx6	save_for_pl1_call-*,ic	" go to PL/I calling conventions.
    000124  aa  6 00060 3521 00    177  	eppbp	new_seg_ptr		" get address of pointer arg.
    000125  aa  6 00052 2521 00    178  	spribp	arglist+2
    000126  aa   777654 2370 04    179  	ldaq	header_for_1_arg-*,ic
    000127  aa  6 00050 7571 00    180  	staq	arglist
    000130  aa  6 00000 2541 00    181  	call 	<lisp_segment_manager_>|[get_lists](arglist)
    000131  aa  6 00050 3501 00
    000132  4a  4 00020 3521 20
    000133  aa  6 00040 7531 00
    000134  aa  7 00036 6701 20
    000135  aa  6 00000 1731 00
    000136  aa  6 00040 0731 00
    000137  9a  4 00016 2371 00    182  	ldaq	lp|cur_seg		" get cur segment ptr
    000140  aa  6 00060 3521 20    183  	eppbp	new_seg_ptr,*		" get pointer to new seg base.
    000141  aa  2 00000 7571 00    184  	staq	bp|0			" thread in old segment.
    000142  9a  4 00016 2521 00    185  	spribp	lp|cur_seg		" and make new segment the current segment.
    000143  aa  2 00002 3521 00    186  	eppbp	bp|2			" get pointer to ad tally word.
    000144  9a  4 00014 2521 00    187  	spribp	lp|consptr		" store it away.
    000145  aa   000053 2350 07    188  	lda	=o53,dl			" load ad modifier value
    000146  9a  4 00015 2551 00    189  	orsa	lp|consptr+1		" and put in the further modification 
                                   190  					" part of its pointer.
    000147  0a   001624 2350 00    191  	lda	=o4740004			" load actual tally word initial value
    000150  aa  2 00000 7551 00    192  	sta	bp|0			" and store it in segment's tally word.
    000151  aa   000020 3350 07    193  	lca	16,dl			" load minus number of 16K blocks in segment.
    000152  9a  4 00012 7551 00    194  	sta	lp|seg_blk_cntr		" so the end of segment will be caught.
    000153  aa   777641 7060 04    195  	tsx6	pop_back_to_lisp-*,ic
    000154  aa  1 77777 2361 17    196  	ldq	ab|-1,x7			" reload saved registers.
    000155  aa  1 77776 2261 17    197  	ldx6	ab|-2,x7
    000156  aa  1 77776 7251 17    198  	lxl5	ab|-2,x7			" reload x5 for lsubr callers.
    000157  aa   777776 6270 17    199  	eax7	-2,x7			" pop back unmarked stack,
    000160  9a  4 00010 2201 00    200  	ldx0	lp|alloc_fault_word	" and return to restart point of allocation routine.
    000161  aa   000000 7100 10    201  	tra	0,x0
                                   202  "
                                   203  "	Subroutine which calls the garbage collector, and reinitializes data
                                   204  "	before restarting allocation again.
                                   205  "	called with a tsx4, returns to just after tsx4 if gc inhibited, otherwise,
                                   206  "	returns to restart address in alloc_fault_word, as old allocation meaningless.
                                   207  "
                                   208  
    000162                         209  must_gc:
    000162  4a  4 00036 2341 20    210  	szn	<lisp_static_vars_>|[garbage_collect_inhibit]
    000163  aa   000000 6010 14    211  	tnz	0,x4			" return if gc inhibited, and don't gc until next block done.
                                   212  					" and don't gc till next block done.
    000164  aa   000002 6270 17    213  	eax7	2,x7			" get space to save registers.
    000165  aa  1 77776 7461 17    214  	stx6	ab|-2,x7
    000166  aa  1 77776 4451 17    215  	sxl5	ab|-2,x7			" save x5 for lsubr callers
    000167  aa  1 77777 7561 17    216  	stq	ab|-1,x7
    000170  aa   777614 7060 04    217  	tsx6	save_for_pl1_call-*,ic
    000171  aa   777607 3500 04    218  	eppap	noargs-*,ic
    000172  4a  4 00040 3521 20    219  	short_call <lisp_garbage_collector_>|[lisp_garbage_collector_]
    000173  aa  7 00036 6701 20
    000174  aa  6 00030 3701 20
    000175  aa   777617 7060 04    220  	tsx6	pop_back_to_lisp-*,ic
    000176  aa  1 77777 2361 17    221  	ldq	ab|-1,x7			" reload saved registers.
    000177  aa  1 77776 2261 17    222  	ldx6	ab|-2,x7			" ..
    000200  aa  1 77776 7251 17    223  	lxl5	ab|-2,x7
    000201  aa   777776 6270 17    224  	eax7	-2,x7
    000202  9a  4 00010 2201 00    225  	ldx0	lp|alloc_fault_word		" restart allocation again.
    000203  aa   000000 7100 10    226  	tra	0,x0
                                   227  "
                                   228  "operators for compiled code to allocate conses.
                                   229  " by using these operators, compiled code is made more compact
                                   230  " and locally more efficient.
                                   231  
                        000204     232  	segdef	cons_opr
    000204  0a   000264 7060 00    233  cons_opr:	tsx6	opr_cons
    000205                         234  cons_opr_com0:
    000205  aa  3 00000 7571 00    235  	staq	bb|0		store aq into car of allocated cons
    000206                         236  cons_opr_com1:
    000206  0a   000326 7060 00    237  	tsx6	opr_ck_fault	check for faults in cons
    000207  aa  3 00000 2371 00    238  	ldaq	bb|0		reload aq from car
    000210  aa  2 00000 7101 00    239  	tra	bp|0		return to caller
                                   240  
                        000211     241  	segdef	ncons_opr
    000211  0a   000264 7060 00    242  ncons_opr:tsx6	opr_cons
    000212                         243  ncons_opr_com:
    000212  aa  3 00000 7571 00    244  	staq	bb|0		store arg into car of allocated cons
    000213  aa  1 00012 2371 00    245  	ldaq	ab|nil
    000214  aa  3 00002 7571 00    246  	staq	bb|2		store nil into cdr of allocated cons
    000215  0a   000206 7100 00    247  	tra	cons_opr_com1
                                   248  
                        000216     249  	segdef 	xcons_opr
    000216  0a   000264 7060 00    250  xcons_opr:tsx6	opr_cons
    000217  aa  3 00002 7571 00    251  	staq	bb|2
    000220  0a   000326 7060 00    252  	tsx6	opr_ck_fault
    000221  aa  3 00002 2371 00    253  	ldaq	bb|2		reload aq from cdr of cons
    000222  aa  2 00000 7101 00    254  	tra	bp|0
                                   255  
                        000223     256  	segdef	begin_list_opr	operator to get the first element of a list
    000223                         257  begin_list_opr:
    000223  0a   000264 7060 00    258  	tsx6	opr_cons
    000224  aa  0 00002 3501 00    259  	eppap	ap|2		push result on stack for later list oprs.
    000225  aa  0 77776 2535 00    260  	spribb	ap|-2
    000226  0a   000205 7100 00    261  	tra	cons_opr_com0
                                   262  
                        000227     263  	segdef	append_list_opr
    000227                         264  append_list_opr:
    000227  0a   000264 7060 00    265  	tsx6	opr_cons
    000230  aa   000002 6260 00    266  	eax6	2		to save a register
    000231  aa  0 77776 2535 76    267  	spribb	ap|-2,*x6		rplacd onto old list
    000232  aa  0 77776 2535 00    268  	spribb	ap|-2		and store in old list place.
    000233  0a   000205 7100 00    269  	tra	cons_opr_com0
                                   270  
                        000234     271  	segdef	terminate_list_opr
    000234                         272  terminate_list_opr:
    000234  0a   000264 7060 00    273  	tsx6	opr_cons
    000235  aa   000002 6260 00    274  	eax6	2
    000236  aa  0 77776 2535 76    275  	spribb	ap|-2,*x6		rplacd onto end of list
    000237  aa  0 77776 3501 00    276  	eppap	ap|-2		wipe temp off stack
    000240  0a   000212 7100 00    277  	tra	ncons_opr_com	and set portions of new cons.
                                   278  
                                   279  
                                   280  " Operator to cons up a string
                                   281  " called by tspbp with length (in characters) in q
                                   282  " returns pointer to string in both bb and aq.  stringlength is stored
                                   283  
                        000241     284  	segdef	cons_string
                                   285  
    000241                         286  cons_string:
    000241  aa   000000 6250 06    287  	eax5	0,ql		save length
    000242  aa   000023 0760 07    288  	adq	15+4,dl		allow for length word + 4-word blocks
    000243  aa   000004 7320 00    289  	qrs	4		divide by 4 chars/wd + 4 wds/block
    000244  aa   000002 7360 00    290  	qls	2		then allow for words_alloc strangeness
    000245  aa   000002 6270 17    291  	eax7	2,x7		save caller's lp and address
    000246  aa  1 77776 5441 17    292  	sprplp	ab|-2,x7
    000247  aa  1 77777 5421 17    293  	sprpbp	ab|-1,x7
    000250  aa  1 00044 3701 20    294  	epplp	ab|system_lp,*
    000251  0a   000064 7060 00    295  	tsx6	words_alloc	get space for the string
    000252  aa  2 00000 3535 00    296  	eppbb	bp|0		and move pointer into proper register
    000253  aa  1 77776 7641 17    297  	lprplp	ab|-2,x7		restore regs
    000254  aa  1 77777 7621 17    298  	lprpbp	ab|-1,x7
    000255  aa  3 00000 4501 00    299  	stz	bb|0		set length word
    000256  aa  3 00000 4451 00    300  	sxl5	bb|0		..
    000257  aa  1 77776 2535 17    301  	spribb	ab|-2,x7		move bb into aq
    000260  aa  1 77776 2371 17    302  	ldaq	ab|-2,x7
    000261  aa   004000 2750 07    303  	ora	String,dl
    000262  aa   777776 6270 17    304  	eax7	-2,x7
    000263  aa  2 00000 7101 00    305  	tra	bp|0	
                                   306  "
                                   307  "  common routine to allocate a cons for the operators
                                   308  "
                                   309  "	uses lb to point to linkage section,
                                   310  "	returns result in bb,
                                   311  "	saves aq, bp, lp, x6.
                                   312  
    000264  aa  1 00044 3715 20    313  opr_cons:	epplb	ab|system_lp,*	get our lp into lb register
    000265  9a  5 00010 5541 00    314  	stc1	lb|alloc_fault_word	lock out interrupts
    000266  9a  5 00014 3535 20    315  	eppbb	lb|consptr,*	allocate a cons
    000267  aa   000000 6070 16    316  	ttf	0,x6		and if no tally runout, return
                                   317  
    000270  9a  5 00011 0541 00    318  	aos	lb|gc_blk_cntr	check for gc.
    000271  0a   000275 6040 00    319  	tmi	no_opr_gc
    000272  0a   000302 7040 00    320  	tsx4	save_regs_call	save regs and execute next instruction.
    000273  0a   000162 7100 00    321  	tra	must_gc
    000274  0a   000316 7040 00    322  	tsx4	unsave_regs
    000275  9a  5 00012 0541 00    323  no_opr_gc:aos	lb|seg_blk_cntr	check if out of segment room
    000276  aa   000000 6040 16    324  	tmi	0,x6		if not, can return
    000277  0a   000302 7040 00    325  	tsx4	save_regs_call
    000300  0a   000117 7100 00    326  	tra	get_new_seg
    000301  aa   000000 5060 07    327  	div	0,dl		get_new_seg returns to reallocate
                                   328  				" never to here (hopefully)
    000302                         329  save_regs_call:
    000302  aa  0 00002 3501 00    330  	eppap	ap|2
    000303  aa   000002 6270 17    331  	eax7	2,x7
    000304  aa  0 77776 7571 00    332  	staq	ap|-2		save aq on marked stack
    000305  aa  1 77776 5441 17    333  	sprplp	ab|-2,x7		save lp
    000306  aa  1 77777 5421 17    334  	sprpbp	ab|-1,x7	and bp
    000307  aa  5 00000 3701 00    335  	epplp	lb|0		get lb into lp.
    000310  9a  5 00010 2251 00    336  	ldx5	lb|alloc_fault_word	kludge saving restart address in x5
    000311  0a   000315 6230 00    337  	eax3	unsave_retry	and storing addr of unsaver in restart address
    000312  9a  5 00010 7431 00    338  	stx3	lb|alloc_fault_word
    000313  aa   000001 6240 14    339  	eax4	1,x4		get real return address
    000314  aa   777777 7160 14    340  	xec	-1,x4		and execute instruction after call
                                   341  
    000315                         342  unsave_retry:
    000315  aa   000000 6240 15    343  	eax4	0,x5		restart at allocation point
    000316                         344  unsave_regs:
    000316  aa  0 77776 2371 00    345  	ldaq	ap|-2		reload aq
    000317  aa  4 00000 3715 00    346  	epplb	lp|0		move lp into lb again
    000320  aa  1 77776 7641 17    347  	lprplp	ab|-2,x7		reload caller's lp
    000321  aa  1 77777 7621 17    348  	lprpbp	ab|-1,x7		and bp
    000322  9a  5 00010 7451 00    349  	stx5	lb|alloc_fault_word	restore stc1 word to original state
    000323  aa  0 77776 3501 00    350  	eppap	ap|-2		pop off stack
    000324  aa   777776 6270 17    351  	eax7	-2,x7
    000325  aa   000000 7100 14    352  	tra	0,x4		and return
                                   353  
                                   354  "
                                   355  " routine used by oprs to check for faults while allocating
                                   356  "
                                   357  "	clobbers a register.
                                   358  
    000326                         359  opr_ck_fault:
    000326  9a  5 00010 0341 00    360  	ldac	lb|alloc_fault_word	unit operation
    000327  aa   000007 3750 07    361  	ana	=o7,dl		mask out fault bits
    000330  aa   000000 6000 16    362  	tze	0,x6		if no fault, return
                                   363  
    000331  aa   000000 6250 16    364  	eax5	0,x6		save x6 in x5
    000332  aa   000004 6270 17    365  	eax7	4,x7
    000333  aa  1 77774 2535 17    366  	spribb	ab|-4,x7		save registers not saved in other allocator fault checker
    000334  aa  1 77776 6501 17    367  	sprilp	ab|-2,x7
    000335  aa  5 00000 3701 00    368  	epplp	lb|0
    000336  0a   000031 7060 00    369  	tsx6	alloc_got_fault
    000337  aa  4 00000 3715 00    370  	epplb	lp|0		unsave stuff
    000340  aa  1 77776 3701 37    371  	epplp	ab|-2,x7*
    000341  aa  1 77774 3535 37    372  	eppbb	ab|-4,x7*
    000342  aa   777774 6270 17    373  	eax7	-4,x7
    000343  aa   000000 7100 15    374  	tra	0,x5		return to caller
                                   375  "
                        000344     376  	entry	lisp_alloc_		" pl1 callable allocation routine.
    000344                         377  lisp_alloc_:
    000344  aa  0 00000 3521 00    378  	eppbp	ap|0			" get pointer to arg list.
    000345  aa   777451 7060 04    379  	tsx6	switch_to_lisp-*,ic		" load ab, ap, x7 etc.
    000346  aa   000002 6270 17    380  	eax7	2,x7			" get some space for second arg pointer save.
    000347  aa  2 00004 2371 00    381  	ldaq	bp|4			" load pointer to second arg.
    000350  aa  1 77776 7571 17    382  	staq	ab|-2,x7			" and save it.
    000351  aa  2 00002 2361 20    383  	ldq	bp|2,*			" load first arg, number of words needed.
    000352  aa   000003 0760 07    384  	adq	3,dl			" round it to mod 4.
    000353  aa   777774 3760 07    385  	anq	=o777774,dl		" and ignore high order bits too.
    000354  aa   777510 7060 04    386  	tsx6	words_alloc-*,ic		" allocate number of words in q, return in bp.
    000355  aa  1 77776 2521 37    387  	spribp	ab|-2,x7*			" save in second argument.
    000356  aa   777776 6270 17    388  	eax7	-2,x7
    000357                         389  ret_to_pl1:				" return to pl1 conventions.
    000357  4a  4 00022 2501 20    390  	spriap	<lisp_static_vars_>|[stack_ptr]
    000360  4a  4 00024 7471 20    391  	stx7	<lisp_static_vars_>|[unmkd_ptr]+1
    000361  aa  1 00016 5541 00    392  	stc1	ab|in_pl1_code
    000362  aa  7 00044 7101 20    393  	short_return			" return to caller, no stack frame exists.
                                   394  "
                                   395  "	Entries called from pl1 programs in the lisp system.
                                   396  "	called as lisp_special_fns_$xxxx.
                                   397  
                        000363     398  	entry	cons
    000363  aa   777433 7060 04    399  cons:	tsx6	switch_to_lisp-*,ic		" switch to lisp calling conventions.
    000364  aa   000004 6270 17    400  	eax7	4,x7			" get room to do a lisp call to cons_
    000365  aa  1 77774 6501 17    401  	sprilp	ab|-4,x7			" store lp
    000366  aa  1 77776 3571 17    402  	stcd	ab|-2,x7			" store return address.
    000367  aa   000075 7100 04    403  	tra	cons_-*,ic
    000370  aa  0 00002 3501 00    404  pl1_ret:	eppap	ap|2			" get room to push result on stack.
    000371  aa  0 77776 7571 00    405  	staq	ap|-2			" and push it.
    000372  aa   777765 7100 04    406  	tra	ret_to_pl1-*,ic		" return and switch back to pl1 conventions.
                                   407  
                        000373     408  	entry	xcons
    000373  aa   777423 7060 04    409  xcons:	tsx6	switch_to_lisp-*,ic
    000374  aa   000004 6270 17    410  	eax7	4,x7
    000375  aa  1 77774 6501 17    411  	sprilp	ab|-4,x7			" call to xcons_ via lisp call.
    000376  aa  1 77776 3571 17    412  	stcd	ab|-2,x7
    000377  aa   000101 7100 04    413  	tra	xcons_-*,ic
    000400  aa   777770 7100 04    414  	tra	pl1_ret-*,ic
                                   415  
                        000401     416  	entry	ncons
    000401  aa   777415 7060 04    417  ncons:	tsx6	switch_to_lisp-*,ic		" switch to lisp calling conventions.
    000402  aa   000004 6270 17    418  	eax7	4,x7
    000403  aa  1 77774 6501 17    419  	sprilp	ab|-4,x7
    000404  aa  1 77776 3571 17    420  	stcd	ab|-2,x7
    000405  aa   000100 7100 04    421  	tra	ncons_-*,ic
    000406  aa   777762 7100 04    422  	tra	pl1_ret-*,ic
                                   423  
                        000407     424  	entry	list
    000407  aa   777407 7060 04    425  list:	tsx6	switch_to_lisp-*,ic
    000410  aa  0 77777 7251 00    426  	lxl5	ap|-1			" laod number of args * -2
    000411  aa  0 77776 3501 00    427  	eppap	ap|-2			" pop off stack.
    000412  aa   000004 6270 17    428  	eax7	4,x7
    000413  aa  1 77774 6501 17    429  	sprilp	ab|-4,x7
    000414  aa  1 77776 3571 17    430  	stcd	ab|-2,x7
    000415  aa   000104 7100 04    431  	tra	list_-*,ic
    000416  aa   777752 7100 04    432  	tra	pl1_ret-*,ic
                                   433  
                        000417     434  	entry	list_star
    000417                         435  list_star:
    000417  0a   000016 7060 00    436  	tsx6	switch_to_lisp
    000420  aa  0 77777 7251 00    437  	lxl5	ap|-1			" laod number of args * -2
    000421  aa  0 77776 3501 00    438  	eppap	ap|-2			" pop off stack.
    000422  aa   000004 6270 17    439  	eax7	4,x7
    000423  aa  1 77774 6501 17    440  	sprilp	ab|-4,x7
    000424  aa  1 77776 3571 17    441  	stcd	ab|-2,x7
    000425  0a   000516 7100 00    442  	tra	list_star_
    000426  0a   000370 7100 00    443  	tra	pl1_ret
                                   444  
                        000427     445  	entry	gensym
    000427  aa   777367 7060 04    446  gensym:	tsx6	switch_to_lisp-*,ic
    000430  aa  0 77777 7251 00    447  	lxl5	ap|-1		get number args into x5
    000431  aa  0 77776 3501 00    448  	eppap	ap|-2		pop off stack
    000432  aa   000004 6270 17    449  	eax7	4,x7		get room to save lp and return link
    000433  aa  1 77774 6501 17    450  	sprilp	ab|-4,x7
    000434  aa  1 77776 3571 17    451  	stcd	ab|-2,x7
    000435  aa   000105 7100 04    452  	tra	gensym_-*,ic	and call lisp gensym function.
    000436  aa   777732 7100 04    453  	tra	pl1_ret-*,ic	then return
                                   454  
                        000437     455  	entry	subst
    000437  0a   000016 7060 00    456  subst:	tsx6	switch_to_lisp
    000440  aa   000004 6270 17    457  	eax7	4,x7
    000441  aa  1 77774 6501 17    458  	sprilp	ab|-4,x7
    000442  aa  1 77776 3571 17    459  	stcd	ab|-2,x7
    000443  0a   001051 7100 00    460  	tra	subst_
    000444  0a   000370 7100 00    461  	tra	pl1_ret
                                   462  
                        000445     463  	entry	nreverse
    000445  0a   000016 7060 00    464  nreverse:	tsx6	switch_to_lisp
    000446  aa   000004 6270 17    465  	eax7	4,x7
    000447  aa  1 77774 6501 17    466  	sprilp	ab|-4,x7
    000450  aa  1 77776 3571 17    467  	stcd	ab|-2,x7
    000451  0a   001022 7100 00    468  	tra	nreverse_
    000452  0a   000370 7100 00    469  	tra	pl1_ret
                                   470  
                                   471  
                        000453     472  	entry	get_fault_word
    000453                         473  get_fault_word:			" subroutine to get a copy of alloc_fault_word, and zero it at the same time.
                                   474  				" must be done in a way such that interrupts don't foul it up.
                                   475  				" interrupts can or new things into the fault word...
    000453  aa  0 00002 4501 20    476  	stz	ap|2,*		" zero result.
    000454  9a  4 00010 2351 00    477  gfw_lp:	lda	lp|alloc_fault_word	" get fault word.
    000455  aa  0 00002 2551 20    478  	orsa	ap|2,*		" or bits gotten into result.
    000456  9a  4 00010 6551 00    479  	ersa	lp|alloc_fault_word	" and clear those bits in the fault word.
    000457  aa   777775 6010 04    480  	tnz	gfw_lp-*,ic	" if more bits turned on since two insts. ago, get them.
    000460  aa  7 00044 7101 20    481  	short_return
                                   482  
                        000461     483  	entry	set_fault
    000461                         484  set_fault:
    000461  aa  0 00002 2351 20    485  	lda	ap|2,*
    000462  9a  4 00010 2551 00    486  	orsa	lp|alloc_fault_word		" set fault on.
    000463  aa  7 00044 7101 20    487  	short_return
                                   488  "
                        000464     489  	segdef	cons_
    000464  aa   777337 7060 04    490  cons_:	tsx6	cons_alloc-*,ic		"allocate 4 words for cons
    000465  aa  0 77774 2371 00    491  	ldaq	ap|-4			"load soon-to-be car
    000466  aa  2 00000 7571 00    492  	staq	bp|0			"make it car.
    000467  aa  0 77776 2371 00    493  	ldaq	ap|-2			"load soon-to-be cdr
    000470  aa  2 00002 7571 00    494  xcret:	staq	bp|2
    000471  aa  0 77776 2521 00    495  	spribp	ap|-2
    000472  aa  0 77776 2371 00    496  	ldaq	ap|-2			"get result in aq
    000473  aa  0 77774 3501 00    497  	eppap	ap|-4			"pop back  stack
    000474  aa  1 77774 3701 37    498  retrn:	epplp	ab|-4,x7*			"reload caller's lp
    000475  aa  1 77776 3521 37    499  	eppbp	ab|-2,x7*			"and bp
    000476  aa   777774 6270 17    500  	eax7	-4,x7
    000477  aa  2 00000 7101 00    501  	tra	bp|0			return
                                   502  
                        000500     503  	segdef	xcons_
    000500  aa   777323 7060 04    504  xcons_:	tsx6	cons_alloc-*,ic		"get 4 words
    000501  aa  0 77776 2371 00    505  	ldaq	ap|-2			"load car
    000502  aa  2 00000 7571 00    506  	staq	bp|0
    000503  aa  0 77774 2371 00    507  	ldaq	ap|-4			"load cdr
    000504  aa   777764 7100 04    508  	tra	xcret-*,ic		"and join with cons code.
                                   509  
                        000505     510  	segdef	ncons_
    000505  aa   777316 7060 04    511  ncons_:	tsx6	cons_alloc-*,ic		"get 4 words
    000506  aa  1 00012 2371 00    512  	ldaq	ab|nil
    000507  aa  2 00002 7571 00    513  	staq	bp|2
    000510  aa  0 77776 2371 00    514  	ldaq	ap|-2
    000511  aa  2 00000 7571 00    515  	staq	bp|0
    000512  aa  0 77776 2521 00    516  	spribp	ap|-2
    000513  aa  0 77776 2371 00    517  	ldaq	ap|-2
    000514  aa  0 77776 3501 00    518  	eppap	ap|-2
    000515  aa   777757 7100 04    519  	tra	retrn-*,ic
                                   520  
                        000516     521  	segdef	list_star_
    000516                         522  list_star_:
    000516  aa   000002 6250 15    523  	eax5	2,x5			"we need one fewer cons than list_ does
                                   524  					"Avoid ap push. Our 'cddddddr' tail is
                                   525  					"already same place as list's running tail.
    000517  0a   000526 6010 00    526  	tnz	list_lp			"so skip nil and make list
    000520  0a   000537 7100 00    527  	tra	ret_list			"one arg, we are noop, pop and return arg
                                   528  
                        000521     529  	segdef	list_
    000521  aa  0 00002 3501 00    530  list_:	eppap	ap|2			"get room for tail of list
    000522  aa  1 00012 2371 00    531  	ldaq	ab|nil			"load initial tail.
    000523  aa  0 77776 7571 00    532  	staq	ap|-2
    000524  aa   000000 1050 03    533  	cmpx5	0,du			"check x5 for no args.
    000525  aa   000012 6000 04    534  	tze	ret_list-*,ic
    000526  aa   777275 7060 04    535  list_lp:	tsx6	cons_alloc-*,ic
    000527  aa  0 77776 2371 00    536  	ldaq	ap|-2			"load tail of list
    000530  aa  2 00002 7571 00    537  	staq	bp|2			"and make it cdr
    000531  aa  0 77774 2371 00    538  	ldaq	ap|-4
    000532  aa  2 00000 7571 00    539  	staq	bp|0			"make next last thing car.
    000533  aa  0 77774 2521 00    540  	spribp	ap|-4
    000534  aa  0 77776 3501 00    541  	eppap	ap|-2			"pop off old tail.
    000535  aa   000002 6250 15    542  	eax5	2,x5		"one less arg.
    000536  aa   777770 6010 04    543  	tnz	list_lp-*,ic
    000537  aa  0 77776 2371 00    544  ret_list:	ldaq	ap|-2			"load last result.
    000540  aa  0 77776 3501 00    545  	eppap	ap|-2			"pop off stack
    000541  aa   777733 7100 04    546  	tra	retrn-*,ic
                                   547  
                                   548  
                                   549  " gensym function...coded in alm for speed.
                                   550  
                        000542     551  	segdef	gensym_		" regular lisp subr entry point.
    000542  aa   000000 1050 03    552  gensym_:	cmpx5	0,du		" check for any arguments
    000543  aa   000026 6040 04    553  	tmi	set_gensym_data-*,ic " and jump to special routine if so.
                                   554  
    000544                         555  gensym_begin:
    000544  aa   000010 2360 07    556  	ldq	8,dl		" need 8 words for the atom.
    000545  aa   777317 7060 04    557  	tsx6	words_alloc-*,ic
    000546  aa   000005 2350 07    558  	lda	5,dl		" put 5 in name length field.
    000547  aa  2 00004 7551 00    559  	sta	bp|4
    000550  aa  1 00012 2371 00    560  	ldaq	ab|nil		" and nil in property list.
    000551  aa  2 00002 7571 00    561  	staq	bp|2
                                   562  
    000552  aa  1 00043 0541 00    563  	aos	ab|gensym_data+1	increment the counter
    000553  aa  1 00043 2351 00    564  	lda	ab|gensym_data+1	check for wrap-around
    000554  aa   023417 4050 07    565  	cmg	9999,dl
    000555  aa   000002 6044 04    566  	tmoz	2,ic
    000556  aa  1 00043 4501 00    567  	stz	ab|gensym_data+1	wraps around to 0 instead of 1.  OK?
    000557  aa  0 00100 3015 00    568  	btd	(pr),(pr)		now convert to decimal and stick into pname
    000560  aa   100043 000004     569  	desc9a	ab|gensym_data+1,4
    000561  aa   200005 230004     570  	desc9ns	bp|5(1),4
    000562  aa  0 00100 1005 00    571  	mlr	(pr),(pr)		don't forget the "g"
    000563  aa   100042 000001     572  	desc9a	ab|gensym_data,1
    000564  aa   200005 000001     573  	desc9a	bp|5,1
    000565  aa  2 00000 2131 00    574  	epaq	bp|0		get atomic symbol as lisp object in aq
    000566  aa   000000 6350 01    575  	eaa	0,au		clear out ring number
    000567  aa   010043 2750 07    576  	ora	Atsym+35,dl	turn on type bit and 043 modifier
    000570  aa   777704 7100 04    577  	tra	retrn-*,ic
                                   578  
    000571                         579  set_gensym_data:
    000571  aa  0 77776 2371 00    580  	ldaq	ap|-2
    000572  aa   040047 1150 07    581  	cmpa	fixnum_type,dl		" check for new index
    000573  aa   000003 6010 04    582  	tnz	chk_prefix-*,ic
    000574  aa  1 00043 7561 00    583  	stq	ab|gensym_data+1		store new index in binary
    000575  aa   000006 7100 04    584  	tra	set_gensym_loop-*,ic
    000576                         585  chk_prefix:
    000576  aa   010000 3150 07    586  	cana	Atsym,dl		" prefix set from atomic symbol
    000577  aa   000010 6000 04    587  	tze	gensym_err-*,ic
    000600  aa  0 77776 3521 20    588  	eppbp	ap|-2,*
    000601  aa  2 00005 2351 00    589  	lda	bp|5		" get prefix,
    000602  aa  1 00042 7551 00    590  	sta	ab|gensym_data	"and save it.
                                   591  
    000603                         592  set_gensym_loop:
    000603  aa  0 77776 3501 00    593  	eppap	ap|-2
    000604  aa   000002 6250 15    594  	eax5	2,x5		" bump back pointers,
    000605  aa   777737 6050 04    595  	tpl	gensym_begin-*,ic	" and start if done with arguments.
    000606  aa   777763 7100 04    596  	tra	set_gensym_data-*,ic
                                   597  
    000607                         598  gensym_err:
    000607  aa   000004 6270 17    599  	eax7	4,x7		" get room for error data and save area.
    000610  aa   000170 2350 07    600  	lda	bad_arg_correctable,dl
    000611  aa   000133 3360 07    601  	lcq	-fn_gensym,dl
    000612  aa  1 77776 7571 17    602  	staq	ab|-2,x7
    000613  aa  1 77774 7451 17    603  	stx5	ab|-4,x7
    000614  aa   777170 7060 04    604  	tsx6	save_for_pl1_call-*,ic
    000615  aa   777163 3500 04    605  	eppap	noargs-*,ic
    000616  4a  4 00042 3521 20    606  	short_call <lisp_error_>|[lisp_error_]
    000617  aa  7 00036 6701 20
    000620  aa  6 00030 3701 20
    000621  aa   777173 7060 04    607  	tsx6	pop_back_to_lisp-*,ic
    000622  aa  1 77776 2251 17    608  	ldx5	ab|-2,x7
    000623  aa   777776 6270 17    609  	eax7	-2,x7
    000624  aa   777745 7100 04    610  	tra	set_gensym_data-*,ic	" try again if error returns.
                                   611  
                                   612  " copysymbol function. takes two args, first is atsym, second flag.
                                   613  " makes new atom with same pname as first, if flag is nil, it is otherwise unsharing.
                                   614  " if flag is t, will put copy of prop list on as its prop list, and copy the value.
                                   615  
                        000625     616  	segdef	copysymbol
    000625                         617  copysymbol:
    000625  aa  0 77774 2371 00    618  	ldaq	ap|-4		"get arg.
    000626  aa   010000 3150 07    619  	cana	Atsym,dl
    000627  0a   000632 6010 00    620  	tnz	copysym
    000630  aa  0 77774 3501 00    621  	eppap	ap|-4		" should be error? we just return arg.
    000631  0a   000474 7100 00    622  	tra	retrn
                                   623  
    000632  aa  0 00002 3501 00    624  copysym:	eppap	ap|2		" get working space.
    000633  aa  0 77772 3521 20    625  	eppbp	ap|-6,*
    000634  aa  2 00004 2361 00    626  	ldq	bp|4		" get length of pname
    000635  aa   000043 0760 07    627  	adq	35,dl		" round to 4 word multiple
    000636  aa   000004 7320 00    628  	qrs	4		" ..
    000637  aa   000002 7360 00    629  	qls	2		" ..
    000640  0a   000064 7060 00    630  	tsx6	words_alloc	" allocate new atom.
    000641  aa  0 77776 2521 00    631  	spribp	ap|-2
    000642  aa   010000 2350 07    632  	lda	Atsym,dl
    000643  aa  0 77776 2551 00    633  	orsa	ap|-2
                                   634  
    000644  aa  0 77772 3535 20    635  	eppbb	ap|-6,*		" get pointer to original atom.
    000645  aa  3 00004 2361 00    636  	ldq	bb|4		" get length
    000646  aa  2 00004 7561 00    637  	stq	bp|4		" and set length of new atom
    000647  aa  0 00140 1005 40    638  	mlr	(pr,rl),(pr,rl)	" move in name.
    000650  aa   300005 000006     639  	desc9a	bb|5,ql
    000651  aa   200005 000006     640  	desc9a	bp|5,ql		" done move
    000652  aa  0 77774 2371 00    641  	ldaq	ap|-4		" check falg.
    000653  aa  1 00012 1171 00    642  	cmpaq	ab|nil
    000654  0a   000657 6010 00    643  	tnz	copypropl
    000655  aa  2 00002 7571 00    644  	staq	bp|2		nullify prop list
    000656  0a   000700 7100 00    645  	tra	return_copy
                                   646  
    000657                         647  copypropl:
    000657  aa  3 00000 2371 00    648  	ldaq	bb|0		" get value
    000660  aa  2 00000 7571 00    649  	staq	bp|0
    000661  aa  0 00004 3501 00    650  	eppap	ap|4		" args for append
    000662  aa  0 77766 2371 00    651  	ldaq	ap|-10		" see if symbol being copied is nil
    000663  aa  1 00012 1171 00    652  	cmpaq	ab|nil
    000664  aa   000017 6000 04    653  	tze	copypropl_nil-*,ic	" yes, get property list from different place.
    000665  aa  3 00002 2371 00    654  	ldaq	bb|2		" get old prop list
    000666                         655  copypropl_0:
    000666  aa  0 77774 7571 00    656  	staq	ap|-4
    000667  aa  1 00012 2371 00    657  	ldaq	ab|nil
    000670  aa  0 77776 7571 00    658  	staq	ap|-2
    000671  aa   777774 6250 00    659  	eax5	-4
    000672  aa   000004 6270 17    660  	eax7	4,x7		" get room for push of return addr
    000673  aa  1 77774 6501 17    661  	sprilp	ab|-4,x7
    000674  aa  1 77776 3571 17    662  	stcd	ab|-2,x7
    000675  0a   000705 7100 00    663  	tra	append		" call append
    000676  aa  0 77776 3535 20    664  	eppbb	ap|-2,*		" get poiner to new atom
    000677  aa  3 00002 7571 00    665  	staq	bb|2		" and store new prop list
                                   666  
    000700                         667  return_copy:
    000700  aa  0 77776 2371 00    668  	ldaq	ap|-2
    000701  aa  0 77772 3501 00    669  	eppap	ap|-6
    000702  0a   000474 7100 00    670  	tra	retrn
                                   671  
    000703                         672  copypropl_nil:
    000703  4a  4 00044 2371 20    673  	ldaq	<lisp_static_vars_>|[property_list_of_nil]
    000704  aa   777762 7100 04    674  	tra	copypropl_0-*,ic
                                   675  
                                   676  
                                   677  "	append and nconc subroutines. both are lsubrs with any number of args.
                                   678  
                        000705     679  	segdef	append
                                   680  
    000705  aa   000000 1050 03    681  append:	cmpx5	0,du		" check for no args
    000706  aa   000064 6000 04    682  	tze	ret_nil-*,ic	" return nil in this case.
    000707  aa  0 00004 3501 00    683  	eppap	ap|4		" get room for result, and scanning pointer.
    000710  aa   000002 6270 17    684  	eax7	2,x7		" also, save stack popping point,
    000711  aa  1 77776 7451 17    685  	stx5	ab|-2,x7		" so x5 can be changed....
                                   686  
    000712                         687  skip_atoms:			" first skip leading atomic arguments.
    000712  aa  0 77774 2371 15    688  	ldaq	ap|-4,x5		" load next arg,
    000713  aa   000002 6250 15    689  	eax5	2,x5		" and move up stack,
    000714  aa   000031 6000 04    690  	tze	ret_arg-*,ic	" but if last arg, just return.
    000715  aa   077700 3150 07    691  	cana	Atomic,dl		" check for atom
    000716  aa   777774 6010 04    692  	tnz	skip_atoms-*,ic	" and skip if so.
                                   693  
    000717  aa   777104 7060 04    694  	tsx6	cons_alloc-*,ic	" allocate initial cons, and make it the result.
    000720  aa  0 77772 2371 35    695  	ldaq	ap|-6,x5*		" copy car of current list in...
    000721  aa  2 00000 7571 00    696  	staq	bp|0		" ....
    000722  aa  0 77774 2521 00    697  	spribp	ap|-4		" make this the result.
    000723  aa  0 77776 2521 00    698  aplp:	spribp	ap|-2		" make allocated cons the scan pointer.
    000724  aa  0 77772 3521 35    699  	eppbp	ap|-6,x5*		" move to next list cell of argument.
    000725  aa  2 00002 2371 00    700  	ldaq	bp|2		" ...
    000726  aa  0 77772 7571 15    701  	staq	ap|-6,x5		" ...
    000727  aa   077700 3150 07    702  chk_list:	cana	Atomic,dl		" check to see if we are still following a list.
    000730  aa   000007 6010 04    703  	tnz	end_list-*,ic
    000731  aa   777072 7060 04    704  	tsx6	cons_alloc-*,ic	" allocate another cell.
    000732  aa  0 77772 2371 35    705  	ldaq	ap|-6,x5*		" copy car of this list cell in.
    000733  aa  2 00000 7571 00    706  	staq	bp|0		" ...
    000734  aa   000002 6220 00    707  	eax2	2		" set cdr of scan pointer to new cell
    000735  aa  0 77776 2521 72    708  	spribp	ap|-2,*x2		" ...
    000736  aa   777765 7100 04    709  	tra	aplp-*,ic		" and continue, updating scan pointer.
                                   710  
    000737  aa  0 77774 2371 15    711  end_list:	ldaq	ap|-4,x5		" load next argument.
    000740  aa   000002 6250 15    712  	eax5	2,x5		" and move up arg list.
    000741  aa   777766 6040 04    713  	tmi	chk_list-*,ic	" if not last arg, continue.
    000742  aa  0 77776 3521 20    714  	eppbp	ap|-2,*		" otherwise, make last arg cdr of final list.
    000743  aa  2 00002 7571 00    715  	staq	bp|2		" ...
    000744  aa  0 77774 2371 00    716  	ldaq	ap|-4		" load result.
    000745  aa  1 77776 2251 17    717  ret_arg:	ldx5	ab|-2,x7		" reload x5.
    000746  aa   777776 6270 17    718  	eax7	-2,x7		" pop stack.
    000747  aa  0 77774 3501 15    719  	eppap	ap|-4,x5		" ...
    000750  aa   777524 7100 04    720  	tra	retrn-*,ic
                                   721  
                        000751     722  	segdef	nconc
                                   723  
    000751  aa   000000 6240 15    724  nconc:	eax4	0,x5		" save height of stack to restore to.
    000752  aa   000020 6000 04    725  	tze	ret_nil-*,ic	" if no args, nil is the result.
    000753  aa   000002 6250 15    726  	eax5	2,x5
    000754  aa   000013 6000 04    727  	tze	retn-*,ic		" if one arg, just return it.
                                   728  
    000755  aa  0 77774 3521 15    729  	eppbp	ap|-4,x5		" bp points so that bp|2 is replaced
                                   730  				" by next arg, always.
    000756  aa  2 00002 7201 00    731  nclp:	lxl0	bp|2		" load type field of cdr.
    000757  aa   077700 3000 03    732  	canx0	Atomic,du		" check for atom.
    000760  aa   000003 6010 04    733  	tnz	zap-*,ic
                                   734  
    000761  aa  2 00002 3521 20    735  	eppbp	bp|2,*		" go to cdr otherwise.
    000762  aa   777774 7100 04    736  	tra	nclp-*,ic		" and continue looking for end.
                                   737  
    000763  aa  0 00000 2371 15    738  zap:	ldaq	ap|0,x5		" load next arg.
    000764  aa  2 00002 7571 00    739  	staq	bp|2		" zap it in cdr of list.
    000765  aa   000002 6250 15    740  	eax5	2,x5		" bump number of args.
    000766  aa   777770 6010 04    741  	tnz	nclp-*,ic		" if more, continue down new list.
    000767  aa  0 00000 2371 14    742  retn:	ldaq	ap|0,x4		" load first arg,
    000770  aa  0 00000 3501 14    743  	eppap	ap|0,x4		" and return it.
    000771  aa   777503 7100 04    744  	tra	retrn-*,ic
                                   745  
    000772  aa  1 00012 2371 00    746  ret_nil:	ldaq	ab|nil		" load nil
    000773  aa   777501 7100 04    747  	tra	retrn-*,ic	" and return it.
                                   748  
                                   749  "	lisp reverse and nreverse functions...
                                   750  "	they reverse a list argument by copying in the first instance,
                                   751  "	or by rplacd's in the second instance.
                                   752  "	both are type 1 subrs.
                                   753  "
                        000774     754  	segdef	reverse
    000774  aa  0 77776 2371 00    755  reverse:	ldaq	ap|-2		load argument.
    000775  aa   077700 3150 07    756  	cana 	Atomic,dl		and check for atom
    000776  0a   001001 6000 00    757  	tze	not_atom_reverse
    000777  aa  0 77776 3501 00    758  	eppap	ap|-2
    001000  0a   000474 7100 00    759  	tra	retrn		return directly if not list.
    001001                         760  not_atom_reverse:
    001001  aa  0 00002 3501 00    761  	eppap	ap|2		get storage to play with.
    001002  aa  1 00012 2371 00    762  	ldaq	ab|nil		init result to nil.
    001003  aa  0 77776 7571 00    763  	staq	ap|-2
    001004  0a   000023 7060 00    764  rev_loop:	tsx6	cons_alloc	get a cons cell
    001005  aa  0 77776 2371 00    765  	ldaq	ap|-2		and move previous result into its cdr.
    001006  aa  2 00002 7571 00    766  	staq	bp|2		..
    001007  aa  0 77776 2521 00    767  	spribp	ap|-2		make this cons the new result.
    001010  aa  0 77774 3521 20    768  	eppbp	ap|-4,*		load the car of the remainder of the argument
    001011  aa  2 00000 2371 00    769  	ldaq	bp|0
    001012  aa  0 77776 7571 20    770  	staq	ap|-2,*		and move it into the car of the new result.
    001013  aa  2 00002 2371 00    771  	ldaq	bp|2		now load the cdr of the argument
    001014  aa  0 77774 7571 00    772  	staq	ap|-4		and make it the new argument.
    001015  aa   077700 3150 07    773  	cana	Atomic,dl	check to see if more to reverse.
    001016  0a   001004 6000 00    774  	tze	rev_loop		if more, continue....
    001017  aa  0 77776 2371 00    775  	ldaq	ap|-2		load up the result
    001020  aa  0 77774 3501 00    776  	eppap	ap|-4
    001021  0a   000474 7100 00    777  	tra	retrn		and return.
                                   778  
                                   779  
                        001022     780  	segdef	nreverse_		nreverse subr...pl1-callable version also in this module.
    001022  aa  0 00002 3501 00    781  nreverse_:eppap	ap|2		get a temporary
    001023  aa  1 00012 2371 00    782  	ldaq	ab|nil
    001024  aa  0 77776 7571 00    783  	staq	ap|-2
    001025  aa  0 77774 2371 00    784  	ldaq	ap|-4		unshare nreconc at this point 6/11/80
    001026  aa   077700 3150 07    785  	cana	Atomic,dl		atoms lose here
    001027  0a   001042 6010 00    786  	tnz	nrev_ret
    001030  aa  0 77774 3521 20    787  nrev_loop:eppbp	ap|-4,*		get pointer to cons...
    001031  aa  2 00002 2371 00    788  	ldaq	bp|2
    001032  aa  0 77774 7571 00    789  	staq	ap|-4		move its cdr to the result location.
    001033  aa  0 77776 2371 00    790  	ldaq	ap|-2		load previous result pointer.
    001034  aa  2 00002 7571 00    791  	staq	bp|2		and make it the cdr of the result.
    001035  aa  0 77776 2521 00    792  	spribp	ap|-2		now the back pointer points at the current cell.
    001036  aa  0 77774 2371 00    793  	ldaq	ap|-4		load the next result.
    001037  aa   077700 3150 07    794  	cana	Atomic,dl		check for atom, which would lose....
    001040  0a   001030 6000 00    795  	tze	nrev_loop
    001041  aa  0 77776 2371 00    796  	ldaq	ap|-2		load up the back pointer.
    001042  aa  0 77774 3501 00    797  nrev_ret: eppap	ap|-4
    001043  0a   000474 7100 00    798  	tra	retrn		return result.
                                   799  
                        001044     800  	segdef	nreconc_		nreconc subr...nreverse followed by nconc...joins here
    001044                         801  nreconc_:
    001044  aa  0 77774 2371 00    802  	ldaq	ap|-4
    001045  aa   077700 3150 07    803  	cana	Atomic,dl		check for atom which terminates list.
    001046  0a   001030 6000 00    804  	tze	nrev_loop		fixed nreconc 6/11/80 BSG
    001047  aa  0 77776 2371 00    805  	ldaq	ap|-2
    001050  0a   001042 7100 00    806  	tra	nrev_ret
                                   807  
                                   808  "	lisp subst subroutine...copies a list, making substitutions.
                                   809  
                        001051     810  	segdef	subst_		there is also a pl1-callable entry point.
    001051  aa   777772 6250 00    811  subst_:	eax5	-6		note the stack depth at entry time.
    001052  aa  0 77776 2371 00    812  	ldaq	ap|-2
    001053  0a   001056 7060 00    813  	tsx6	subst_loop	call the right subroutine to do the job.
    001054  aa  0 77772 3501 00    814  	eppap	ap|-6		pop stack
    001055  0a   000474 7100 00    815  	tra	retrn		and return.
                                   816  
    001056                         817  subst_loop:
    001056  aa  0 00002 1171 15    818  	cmpaq	ap|2,x5		compare current lisp value with second arg.
    001057  0a   001113 6000 00    819  	tze	ret_1st_arg	if same, replace with first arg.
    001060  aa   077700 3150 07    820  	cana	Atomic,dl		check to see if a leaf of the tree.
    001061  aa   000000 6010 16    821  	tnz	0,x6		and return if so.
                                   822  
    001062  aa   777776 6250 15    823  	eax5	-2,x5		add to the depth of the args.
    001063  aa  0 00002 3501 00    824  	eppap	ap|2		get room for recursion
    001064  aa   000002 6270 17    825  	eax7	2,x7		on both stacks.
    001065  aa  0 77776 7571 00    826  	staq	ap|-2		save argument.
    001066  aa  1 77776 7461 17    827  	stx6	ab|-2,x7		save return address
    001067  aa  0 77776 2371 20    828  	ldaq	ap|-2,*		load car of argument.
    001070  0a   001056 7060 00    829  	tsx6	subst_loop	call subst recursively.
    001071  aa  0 77776 3521 20    830  	eppbp	ap|-2,*
    001072  aa  0 77776 7571 00    831  	staq	ap|-2		store result of subst on car,
    001073  aa  2 00002 2371 00    832  	ldaq	bp|2		and load the cdr.
    001074  0a   001056 7060 00    833  	tsx6	subst_loop	call subst again.
    001075  aa  0 00002 3501 00    834  	eppap	ap|2		get room to save aq
    001076  aa  0 77776 7571 00    835  	staq	ap|-2
    001077  0a   000023 7060 00    836  	tsx6	cons_alloc	call the allocator.
    001100  aa  0 77774 2371 00    837  	ldaq	ap|-4		now fill in cons pointed at by bp.
    001101  aa  2 00000 7571 00    838  	staq	bp|0
    001102  aa  0 77776 2371 00    839  	ldaq	ap|-2
    001103  aa  2 00002 7571 00    840  	staq	bp|2
    001104  aa  0 77776 2521 00    841  	spribp	ap|-2		move bp to aq
    001105  aa  0 77776 2371 00    842  	ldaq	ap|-2
    001106  aa  0 77774 3501 00    843  	eppap	ap|-4		and pop stack.
    001107  aa   000002 6250 15    844  	eax5	2,x5
    001110  aa  1 77776 2261 17    845  	ldx6	ab|-2,x7		reload return address.
    001111  aa   777776 6270 17    846  	eax7	-2,x7		pop unmarked stack
    001112  aa   000000 7100 16    847  	tra	0,x6		and return.
                                   848  
    001113                         849  ret_1st_arg:
    001113  aa  0 00000 2371 15    850  	ldaq	ap|0,x5		load 1st arg to top call.
    001114  aa   000000 7100 16    851  	tra	0,x6		and return it.
                                   852  
                                   853  
                                   854  
                                   855  """ sublis hacked to use rpt instruction
                                   856  """ 74.04.27 by DAM
                                   857  
                                   858  " Register conventions
                                   859  "
                                   860  " aq	passing arguments in and out of sublis1
                                   861  " x7	unmkd pdl ptr as usual
                                   862  " x6	subroutine calling.  note sublis1 skip returns if it was unchanged.
                                   863  " x5	value to go in x0 for rpt to scan table.
                                   864  " x4	number of 256 - item table portions
                                   865  " x3	temp.
                                   866  " x2	always contains 2, for cdr'ing
                                   867  " x1	temp
                                   868  " x0	temp
                                   869  " bp	cons ptr
                                   870  " lb	temp
                                   871  " bb	-> array of atoms and substitute expressions in stack
                                   872  "
                                   873  " stack conventions
                                   874  "
                                   875  " ab|-2,x7	register save area for sublis_cons
                                   876  " ab|-1,x7	LH - save x6 for recursive calls.
                                   877  " 		RH - register save area for sublis_cons
                                   878  
                        001115     879  	segdef	sublis
                                   880  
                        000100     881  	bool rpt_tze,100
                                   882  
    001115                         883  sublis:	"" first step - construct a table from the first argument.
                                   884  
    001115  aa  0 00000 3535 00    885  	eppbb	ap|0		-> table
    001116  aa   000000 6250 00    886  	eax5	0		number of entries in table
    001117  aa   000002 6220 00    887  	eax2	2
    001120  aa  3 77774 2371 00    888  	ldaq	bb|-4		get list of dotted pairs
    001121  aa   077700 3150 07    889  sublis0:	cana	lisp_ptr.type,dl
    001122  0a   001135 6010 00    890  	tnz	got_sublis_table
    001123  aa  3 77774 3715 20    891  	epplb	bb|-4,*		get cons of list
    001124  aa  5 00000 2371 20    892  	ldaq	lb|0,*		get atomic symbol
    001125  aa  0 00004 3501 00    893  	eppap	ap|4		append to table
    001126  aa   000001 6250 15    894  	eax5	1,x5		increase count
    001127  aa  0 77774 7571 00    895  	staq	ap|-4
    001130  aa  5 00000 2371 72    896  	ldaq	lb|0,*2		get expression to substitute for symbol
    001131  aa  0 77776 7571 00    897  	staq	ap|-2
    001132  aa  5 00002 2371 00    898  	ldaq	lb|2		cdr the first argument
    001133  aa  3 77774 7571 00    899  	staq	bb|-4
    001134  0a   001121 7100 00    900  	tra	sublis0
                                   901  
    001135                         902  got_sublis_table:
    001135  aa   000000 6350 00    903  	eaa	0
    001136  aa   000000 6360 15    904  	eaq	0,x5		set up registers for rpt later
    001137  aa   000012 7370 00    905  	lls	10
    001140  aa   000000 7360 00    906  	qls	0
    001141  aa   000002 6010 04    907  	tnz	2,ic
    001142  aa   000001 1750 07    908  	 sba	 1,dl		0=256.
    001143  aa   000100 6250 02    909  	eax5	rpt_tze,qu	value to go in x0 (first rpt count)
    001144  aa   000001 6240 05    910  	eax4	1,al		value to go in x1 (number of repetitions)
    001145  0a   001153 6044 00    911  	tmoz	no_sublis		nothing to do.
                                   912  
                                   913  	"" second stage - begin scanning argument.
                                   914  
    001146  aa  3 77776 2371 00    915  	ldaq	bb|-2		second argument
    001147  0a   001156 7060 00    916  	tsx6	sublis1
    001150  aa   000000 0110 00    917  	nop	0		in case it skip returns.
                                   918  
    001151  aa  3 77774 3501 00    919  	eppap	bb|-4		pop stack and return the result
    001152  0a   000474 7100 00    920  	tra	retrn
                                   921  
                                   922  
    001153                         923  no_sublis:
    001153  aa  3 77776 2371 00    924  	ldaq	bb|-2
    001154  aa  3 77774 3501 00    925  	eppap	bb|-4
    001155  0a   000474 7100 00    926  	tra	retrn
                                   927  
    001156                         928  sublis1:	"" sublis the form in aq - return addr is at ab|-2,x7
                                   929  
    001156  aa   077700 3150 07    930  	cana	lisp_ptr.type,dl		atom?
    001157  0a   001174 6000 00    931  	tze	sublis2			no, cdr down it.
                                   932  " this is an atom, so look it up in the table.
                                   933  " HERE IS THE GROSSNESS:
                                   934  
    001160  aa   000000 6210 14    935  	eax1	0,x4
    001161  aa   000000 6230 00    936  	eax3	0
    001162  aa   000000 6200 15    937  	eax0	0,x5
    001163                         938  sublis_rpt:
    001163  aa   000000 5202 04    939  	rptx	,4
    001164  aa  3 00000 1171 13    940  	cmpaq	bb|0,x3
    001165  0a   001172 6070 00    941  	ttf	sublis_substitute_here
    001166  aa   000100 6200 00    942  	eax0	rpt_tze			repetitions after first are 256. at a time
    001167  aa   777777 6210 11    943  	eax1	-1,x1
    001170  0a   001163 6010 00    944  	tnz	sublis_rpt
    001171  aa   000001 7100 16    945  	tra	1,x6		not found, leave it the same.
                                   946  
    001172                         947  sublis_substitute_here:
    001172  aa  3 77776 2371 13    948  	ldaq	bb|-2,x3		x3 4 too high.  Pick up thing to be substituted.
    001173  aa   000000 7100 16    949  	tra	0,x6		return non-skipping to indicate change.
                                   950  
    001174                         951  sublis2:	"" sublis of a cons.  do car and cdr
                                   952  
    001174  aa   000002 6270 17    953  	eax7	2,x7
    001175  aa  0 00002 3501 00    954  	eppap	ap|2
    001176  aa  0 77776 7571 00    955  	staq	ap|-2
    001177  aa  1 77777 7461 17    956  	stx6	ab|-1,x7			save previous return address
    001200  aa  0 77776 2371 20    957  	ldaq	ap|-2,*			car
    001201  0a   001156 7060 00    958  	tsx6	sublis1
    001202  0a   001225 7100 00    959  	tra	sublis_car_changed		changed, have to make a new cons.
    001203  aa  0 77776 2371 72    960  	ldaq	ap|-2,*2			no, get cdr
    001204  0a   001156 7060 00    961  	tsx6	sublis1
    001205  0a   001213 7100 00    962  	tra	sublis_cdr_changed		changed, have to make a new cons.
    001206  aa  0 77776 2371 00    963  	ldaq	ap|-2			no change, return same old cons.
    001207  aa  0 77776 3501 00    964  	eppap	ap|-2
    001210  aa  1 77777 2261 17    965  	ldx6	ab|-1,x7
    001211  aa   777776 6270 17    966  	eax7	-2,x7
    001212  aa   000001 7100 16    967  	tra	1,x6
                                   968  
    001213                         969  sublis_cdr_changed:
    001213  0a   001235 7060 00    970  	tsx6	sublis_cons
    001214  aa  2 00002 7571 00    971  	staq	bp|2			store new cdr
    001215  aa  0 77776 2371 20    972  	ldaq	ap|-2,*
    001216  aa  2 00000 7571 00    973  	staq	bp|0			store new car
    001217  aa  0 77776 2521 00    974  	spribp	ap|-2			store back new cons
    001220                         975  sublis_change_exit:
    001220  aa  0 77776 2371 00    976  	ldaq	ap|-2
    001221  aa  0 77776 3501 00    977  	eppap	ap|-2
    001222  aa  1 77777 2261 17    978  	ldx6	ab|-1,x7
    001223  aa   777776 6270 17    979  	eax7	-2,x7
    001224  aa   000000 7100 16    980  	tra	0,x6			it changed
                                   981  
    001225                         982  sublis_car_changed:
    001225  0a   001235 7060 00    983  	tsx6	sublis_cons		make new cons
    001226  aa  2 00000 7571 00    984  	staq	bp|0			save car
    001227  aa  0 77776 2371 72    985  	ldaq	ap|-2,*2			get old cdr
    001230  aa  0 77776 2521 00    986  	spribp	ap|-2			store back new cons
    001231  0a   001156 7060 00    987  	tsx6	sublis1			sublis the cdr
    001232  aa   000000 0110 00    988  	nop	0			doesn't matter whether it changed
    001233  aa  0 77776 7571 72    989  	staq	ap|-2,*2			store cdr
    001234  0a   001220 7100 00    990  	tra	sublis_change_exit
                                   991  
                                   992  
    001235                         993  sublis_cons:	" special cons routine for sublis, avoids munging aq, bb, x5,x4,
                                   994  		" returns cons ptr in bp.
                                   995  		" called by tsx6
                                   996  
    001235  aa  0 00002 3501 00    997  	eppap	ap|2			got to save aq across ldac, gc
    001236  aa  0 77776 7571 00    998  	staq	ap|-2			save regs
    001237  aa  1 77776 7435 17    999  	sarbb	ab|-2,x7			KLUDGE
    001240  aa  1 77776 4441 17   1000  	sxl4	ab|-2,x7
    001241  aa  1 77777 4461 17   1001  	sxl6	ab|-1,x7
    001242  0a   000023 7060 00   1002  	tsx6	cons_alloc
    001243  aa  1 77777 7261 17   1003  	lxl6	ab|-1,x7
    001244  aa  1 77776 7241 17   1004  	lxl4	ab|-2,x7
    001245  aa  0 77776 2371 00   1005  	ldaq	ap|-2
    001246  aa  0 77776 3501 00   1006  	eppap	ap|-2			now how am I going to get out of this one?
    001247  aa  0 00000 3531 00   1007  	epbpbb	ap|0			KLUDGE
    001250  aa  1 77776 0531 17   1008  	adwpbb	ab|-2,x7			..	(note - due to hardware bug must be even address)
    001251  aa   000002 6220 00   1009  	eax2	2			x2 has to always have 2 in it.
    001252  aa   000000 7100 16   1010  	tra	0,x6
                                  1011  
                                  1012  "	functions to deal with value cells.
                                  1013  "	boundp returns t if bound, nil if not (changed 9/12/74)
                                  1014  "	makunbound makes an atom unbound at this binding level -- usually top level.
                                  1015  "
                        001253    1016  	segdef	boundp
    001253  aa   000000 6240 04   1017  boundp:	eax4	0,ic		" remember retry address.
    001254  aa  0 77776 2371 00   1018  	ldaq	ap|-2		" load argument.
    001255  aa   010000 3150 07   1019  	cana	Atsym,dl
    001256  aa   000021 6000 04   1020  	tze	not_atsym-*,ic	" signal error.
    001257  aa  0 77776 2371 20   1021  	ldaq	ap|-2,*		" load value cell.
    001260  aa   000004 6000 04   1022  	tze	not_bound-*,ic	" return nil if not bound.
    001261  aa  1 00014 2371 00   1023  	ldaq	ab|true
    001262  aa  0 77776 3501 00   1024  	eppap	ap|-2		" pop off argument
    001263  aa   777211 7100 04   1025  	tra	retrn-*,ic	" else return t
                                  1026  
    001264  aa  0 77776 3501 00   1027  not_bound: eppap	ap|-2	" pop off argument.
    001265  aa   777505 7100 04   1028  	tra	ret_nil-*,ic
                                  1029  
                        001266    1030  	segdef	makunbound
    001266  aa   000000 6240 04   1031  makunbound: eax4	0,ic		" remember retry address.
    001267  aa  0 77776 2371 00   1032  	ldaq	ap|-2
    001270  aa   010000 3150 07   1033  	cana	Atsym,dl
    001271  aa   000006 6000 04   1034  	tze	not_atsym-*,ic
    001272  aa   000000 4310 03   1035  	fld	0,du		" zero is the unbound marker.
    001273  aa  0 77776 7571 20   1036  	staq	ap|-2,*
    001274  aa  0 77776 2371 00   1037  	ldaq	ap|-2
    001275  aa  0 77776 3501 00   1038  	eppap	ap|-2
    001276  aa   777176 7100 04   1039  	tra	retrn-*,ic
    001277  aa   000170 2350 07   1040  not_atsym:lda	bad_arg_correctable,dl
    001300  0a   001253 1040 03   1041  	cmpx4	boundp,du		" determine which function got error.
    001301  aa   000003 6000 04   1042  	tze	3,ic
    001302  aa   000134 3360 07   1043  	lcq	-fn_makunbound,dl	" and load correct error code
    001303  aa   000002 7100 04   1044  	tra	2,ic		" ..
    001304  aa   000135 3360 07   1045  	lcq	-fn_boundp,dl	" ..
    001305  aa   000004 6270 17   1046  	eax7	4,x7
    001306  aa  1 77774 7441 17   1047  	stx4	ab|-4,x7		"save return address.
    001307  aa  1 77776 7571 17   1048  	staq	ab|-2,x7
    001310  aa   776474 7060 04   1049  	tsx6	save_for_pl1_call-*,ic
    001311  aa   776467 3500 04   1050  	eppap	noargs-*,ic
    001312  4a  4 00042 3521 20   1051  	short_call <lisp_error_>|[lisp_error_]
    001313  aa  7 00036 6701 20
    001314  aa  6 00030 3701 20
    001315  aa   776477 7060 04   1052  	tsx6	pop_back_to_lisp-*,ic
    001316  aa  1 77776 2241 17   1053  	ldx4	ab|-2,x7		" get back retry address.
    001317  aa   777776 6270 17   1054  	eax7	-2,x7
    001320  aa   000000 7100 14   1055  	tra	0,x4		" and retry.
                                  1056  "
                                  1057  " maknum function, returns unique number.
                        001321    1058  	segdef	maknum
                                  1059  
                 002412 753773    1060  	equ	prime,338417659 " or maybe 2796203
                        000040    1061  	equ	maknum_initial,32
    001321  aa   000002 6270 17   1062  maknum:	eax7	2,x7
    001322  9a  4 00010 5541 00   1063  	stc1	lp|alloc_fault_word
    001323  4a  4 00046 2341 20   1064  	szn	<lisp_static_vars_>|[maknum_mask]
    001324  0a   001335 6050 00   1065  	tpl	maknum1
    001325  aa   000100 2360 07   1066  	ldq	maknum_initial*2,dl
    001326  0a   000102 7060 00   1067  	tsx6	locked_alloc
    001327  4a  4 00050 2521 20   1068  	spribp	<lisp_static_vars_>|[maknum_table_ptr]
    001330  aa   000020 3360 07   1069  	lcq	maknum_initial/2,dl
    001331  4a  4 00052 7561 20   1070  	stq	<lisp_static_vars_>|[maknum_left]
    001332  4a  4 00054 4501 20   1071  	stz	<lisp_static_vars_>|[maknum_next]
    001333  aa   000377 2360 07   1072  	ldq	maknum_initial*8-1,dl
    001334  4a  4 00046 7561 20   1073  	stq	<lisp_static_vars_>|[maknum_mask]
    001335  aa  0 77776 2371 00   1074  maknum1:	ldaq	ap|-2
    001336  aa   060000 3150 07   1075  	cana	Fixed+Float,dl
    001337  0a   001342 6010 00   1076  	tnz	maknumber
    001340  aa   000022 7750 00   1077  	alr	18		" move seg number to Q...
    001341  aa   000022 7330 00   1078  	lrs	18
    001342                        1079  maknumber:
    001342  aa   000006 7310 00   1080  	ars	6		" type field to low char of A
    001343  aa  1 77776 7571 17   1081  	staq	ab|-2,x7
    001344  0a   001625 4020 00   1082  	mpy	=v36/prime
    001345  aa   000022 7320 00   1083  	qrs	18
    001346  aa   000003 7360 00   1084  	qls	3
    001347  4a  4 00056 3521 20   1085  	eppbp	<lisp_static_vars_>|[maknum_table_ptr],*
    001350  aa  1 77776 3715 17   1086  	epplb	ab|-2,x7
    001351  4a  4 00046 3761 20   1087  loopmake: anq	<lisp_static_vars_>|[maknum_mask]
    001352  aa  0 00100 1065 06   1088  	cmpc	(pr,ql),(pr)
    001353  aa   200000 600005    1089  	desc9a	bp|0(3),5
    001354  aa   500000 600005    1090  	desc9a	lb|0(3),5
    001355  0a   001364 6000 00   1091  	tze	found_maknum
                                  1092  
    001356  aa  0 00000 1065 06   1093  	cmpc	(pr,ql)
    001357  aa   200000 000004    1094  	desc9a	bp|0,4
    001360  aa   000000 000000    1095  	desc9a	0,0
    001361  0a   001400 6000 00   1096  	tze	maknewnum
    001362  aa   000010 0760 07   1097  	adq	8,dl
    001363  0a   001351 7100 00   1098  	tra	loopmake
                                  1099  
    001364                        1100  found_maknum:
    001364  aa   000002 7320 00   1101  	qrs	2
    001365  aa  2 00000 2361 06   1102  	ldq	bp|0,ql
    001366  aa   040047 2350 07   1103  	lda	fixnum_type,dl
    001367  aa  1 77776 7571 17   1104  	staq	ab|-2,x7
    001370  9a  4 00010 0341 00   1105  	ldac	lp|alloc_fault_word
    001371  aa   000007 3750 07   1106  	ana	=o7,dl
    001372  0a   001374 6000 00   1107  	tze	nomakfault
    001373  0a   000031 7060 00   1108  	tsx6	alloc_got_fault
                                  1109  
    001374                        1110  nomakfault:
    001374  aa  1 77776 2371 17   1111  	ldaq	ab|-2,x7
    001375  aa   777776 6270 17   1112  	eax7	-2,x7
    001376  aa  0 77776 3501 00   1113  	eppap	ap|-2
    001377  0a   000474 7100 00   1114  	tra	retrn
                                  1115  
                                  1116  
    001400                        1117  maknewnum:
    001400  4a  4 00052 0541 20   1118  	aos	<lisp_static_vars_>|[maknum_left]
    001401  0a   001413 6050 00   1119  	tpl	rehash
    001402  4a  4 00054 3535 20   1120  	eppbb	<lisp_static_vars_>|[maknum_next]
    001403  aa  3 00000 0541 00   1121  	aos	bb|0
    001404  aa  0 00106 1005 00   1122  	mlr	(pr),(pr,ql)
    001405  aa   300000 200003    1123  	desc9a	bb|0(1),3
    001406  aa   200000 000003    1124  	desc9a	bp|0,3
    001407  aa  0 00106 1005 00   1125  	mlr	(pr),(pr,ql)
    001410  aa   500000 600005    1126  	desc9a	lb|0(3),5
    001411  aa   200000 600005    1127  	desc9a	bp|0(3),5
    001412  0a   001364 7100 00   1128  	tra	found_maknum
                                  1129  
                                  1130  
                                  1131  
    001413                        1132  rehash:
    001413  4a  4 00046 2361 20   1133  	ldq	<lisp_static_vars_>|[maknum_mask]
    001414  aa   000001 7360 00   1134  	qls	1	"double table size
    001415  aa   000001 2760 07   1135  	orq	1,dl
    001416  4a  4 00046 7561 20   1136  	stq	<lisp_static_vars_>|[maknum_mask]
    001417  aa   000001 0760 07   1137  	adq	1,dl
    001420  aa   000017 7360 00   1138  	qls	18-3
    001421  aa  1 77776 7561 17   1139  	stq	ab|-2,x7
    001422  aa   000021 7320 00   1140  	qrs	18-1
    001423  0a   000102 7060 00   1141  	tsx6	locked_alloc	"alloc while already locked.
    001424  0a   001433 7060 00   1142  	tsx6	maknum_rehash
    001425  9a  4 00011 2341 00   1143  	szn	lp|gc_blk_cntr
    001426  0a   001335 6040 00   1144  	tmi	maknum1
                                  1145  
                                  1146  	" if overflowed gc limit, go to must_gc.
                                  1147  
    001427  0a   001335 6200 00   1148  	eax0	maknum1
    001430  9a  4 00010 7401 00   1149  	stx0	lp|alloc_fault_word
    001431  0a   000162 7040 00   1150  	tsx4	must_gc
    001432  0a   001335 7100 00   1151  	tra	maknum1
                                  1152  
                                  1153  " subroutine to rehash a maknum table into another.
                                  1154  " args: bp -> new table space.
                                  1155  "       <lisp_static_vars_>|[maknum_table_ptr] -> old table space.
                                  1156  "       ab|-2,x7 (DU) has size of old table in words.
                                  1157  "       <lisp_static_vars_>|[maknum_mask] has new table size in chars (-1)
                                  1158  " sets: maknum_table_ptr to point to new table.
                                  1159  "       maknum_left to trigger next rehash.
                                  1160  
    001433                        1161  maknum_rehash:
    001433  4a  4 00056 3535 20   1162  	eppbb	<lisp_static_vars_>|[maknum_table_ptr],*
    001434  4a  4 00050 2521 20   1163  	spribp	<lisp_static_vars_>|[maknum_table_ptr]
                                  1164  
    001435  aa  1 77777 4501 17   1165  	stz	ab|-1,x7	"count moves.
    001436  aa   000000 6200 00   1166  	eax0	0
    001437  aa  1 77776 1001 17   1167  rhsh_loop:cmpx0	ab|-2,x7
    001440  0a   001465 6000 00   1168  	tze	done_rhsh
    001441  aa  3 00000 2361 10   1169  	ldq	bb|0,x0	"check for stuff
    001442  0a   001463 6000 00   1170  	tze	skip_rhsh
    001443  aa  3 00001 2361 10   1171  	ldq	bb|1,x0
    001444  0a   001625 4020 00   1172  	mpy	=v36/prime
    001445  aa   000022 7320 00   1173  	qrs	18
    001446  aa   000003 7360 00   1174  	qls	3
    001447  4a  4 00046 3761 20   1175  rhshlp1:	anq	<lisp_static_vars_>|[maknum_mask]
    001450  aa  0 00000 1065 06   1176  	cmpc	(pr,ql)	"check for enpty slot
    001451  aa   200000 000004    1177  	desc9a	bp|0,4
    001452  aa   000000 000000    1178  	desc9a	0,0
    001453  0a   001456 6000 00   1179  	tze	insrt
    001454  aa   000010 0760 07   1180  	adq	8,dl
    001455  0a   001447 7100 00   1181  	tra	rhshlp1
    001456  aa   000002 7320 00   1182  insrt:	qrs	2
    001457  aa   000000 6210 06   1183  	eax1	0,ql
    001460  aa  3 00000 2371 10   1184  	ldaq	bb|0,x0
    001461  aa  2 00000 7571 11   1185  	staq	bp|0,x1
    001462  aa  1 77777 0541 17   1186  	aos	ab|-1,x7
    001463  aa   000002 6200 10   1187  skip_rhsh:eax0	2,x0
    001464  0a   001437 7100 00   1188  	tra	rhsh_loop
    001465                        1189  done_rhsh:
    001465  4a  4 00046 2351 20   1190  	lda	<lisp_static_vars_>|[maknum_mask]
    001466  aa   000001 0750 07   1191  	ada	1,dl
    001467  aa   000003 7310 00   1192  	ars	3
    001470  aa  1 77777 1751 17   1193  	sba	ab|-1,x7
    001471  aa   000000 5310 00   1194  	neg	0
    001472  aa   000001 7310 00   1195  	ars	1
    001473  4a  4 00052 7551 20   1196  	sta	<lisp_static_vars_>|[maknum_left]
    001474  aa   000000 7100 16   1197  	tra	0,x6
                                  1198  
                                  1199  " pl1-callable subroutine to rehash maknum table. called by
                                  1200  " garbage collector and saver.  doesn't expect table to be hashed.
                                  1201  " args: <lsv>|[maknum_table_ptr] -> source table.
                                  1202  "       <lsv>|[maknum_mask] is old size in chars -1.
                                  1203  "       <lsv>|[maknum_left] is number of entries used in old table.
                                  1204  " sets: the above, so that maknum will work.
                                  1205  
                        001475    1206  	entry	rehash_maknum
    001475                        1207  rehash_maknum:
    001475  0a   000016 7060 00   1208  	tsx6	switch_to_lisp
    001476  aa   000002 6270 17   1209  	eax7	2,x7
    001477  4a  4 00046 2361 20   1210  	ldq	<lisp_static_vars_>|[maknum_mask]
    001500  aa   000001 0760 07   1211  	adq	1,dl
    001501  aa   000020 7360 00   1212  	qls	18-2	" move to upper half, dividing by 4.
    001502  aa  1 77776 7561 17   1213  	stq	ab|-2,x7	" and put where rehash_maknum expects it.
    001503  4a  4 00052 2361 20   1214  	ldq	<lisp_static_vars_>|[maknum_left] " compute necessary ht size.
    001504  aa   000004 7320 00   1215  	qrs	4		" need next largest power of 2 > 32 and > number entries.
    001505  aa   000004 6200 00   1216  	eax0	4
    001506  aa   000001 6200 10   1217  nlgp2:	eax0	1,x0
    001507  aa   000001 7320 00   1218  	qrs	1
    001510  0a   001506 6010 00   1219  	tnz	nlgp2
    001511  aa   000001 2360 07   1220  	ldq	1,dl
    001512  aa   000004 7360 10   1221  	qls	4,x0	" (chars/word)*4*old_min_table_size
    001513  aa   000001 1760 07   1222  	sbq	1,dl
    001514  4a  4 00046 7561 20   1223  	stq	<lisp_static_vars_>|[maknum_mask]
    001515  aa   000001 0760 07   1224  	adq	1,dl
    001516  aa   000002 7320 00   1225  	qrs	2
    001517  0a   000064 7060 00   1226  	tsx6	words_alloc
    001520  0a   001433 7060 00   1227  	tsx6	maknum_rehash
    001521  aa   777776 6270 17   1228  	eax7	-2,x7
    001522  0a   000357 7100 00   1229  	tra	ret_to_pl1
                                  1230  
                        001523    1231  	segdef	munkam
    001523                        1232  munkam:
    001523  aa  0 77776 2351 00   1233  	lda	ap|-2		" get  type.
    001524  aa   040047 1150 07   1234  	cmpa	fixnum_type,dl
    001525  0a   001537 6010 00   1235  	tnz	munfound
    001526  aa  0 77777 2351 00   1236  	lda	ap|-1
    001527  4a  4 00046 2361 20   1237  	ldq	<lisp_static_vars_>|[maknum_mask]
    001530  0a   001537 6040 00   1238  	tmi	munfound
    001531  aa   000002 7320 00   1239  	qrs	2
    001532  4a  4 00056 3521 20   1240  	eppbp	<lisp_static_vars_>|[maknum_table_ptr],*
    001533  aa  2 77777 1151 06   1241  mnkamlp:	cmpa	bp|-1,ql
    001534  0a   001541 6000 00   1242  	tze	mfound
    001535  aa   000002 1760 07   1243  	sbq	2,dl
    001536  0a   001533 6050 00   1244  	tpl	mnkamlp
    001537                        1245  munfound:
    001537  aa  1 00012 2371 00   1246  	ldaq	ab|nil
    001540  0a   001556 7100 00   1247  	tra	retrnmun	"should  probably err out here.
                                  1248  
                                  1249  
                                  1250  
    001541  aa   000006 7350 00   1251  mfound:	als	6
    001542  aa   077700 3750 07   1252  	ana	lisp_ptr.type,dl
    001543  aa   060000 3150 07   1253  	cana	Fixed+Float,dl
    001544  0a   001554 6010 00   1254  	tnz	munnum
    001545  aa   000002 6270 17   1255  	eax7	2,x7
    001546  aa  2 00000 7621 06   1256  	lprpbp	bp|0,ql
    001547  aa  1 77776 2521 17   1257  	spribp	ab|-2,x7
    001550  aa  1 77776 2751 17   1258  	ora	ab|-2,x7
    001551  aa  1 77777 2361 17   1259  	ldq	ab|-1,x7
    001552  aa   777776 6270 17   1260  	eax7	-2,x7
    001553  0a   001556 7100 00   1261  	tra	retrnmun
    001554  aa   000047 2750 07   1262  munnum:	ora	=o47,dl
    001555  aa  2 00000 2361 06   1263  	ldq	bp|0,ql
    001556                        1264  retrnmun:
    001556  aa  0 77776 3501 00   1265  	eppap	ap|-2
    001557  0a   000474 7100 00   1266  	tra	retrn
                                  1267  "
                                  1268  	include	lisp_object_types
                                   1-1  
                                   1-2  " BEGIN INCLUDE FILE lisp_object_types.incl.alm
                                   1-3  "
                                   1-4  " D.A.Moon 14 July 72
                                   1-5  
                                   1-6  "These are bit masks used to check or set the type bits in lisp pointers
                                   1-7  "they should be used with cana instructions in the dl mode.
                                   1-8  "
                                   1-9  " Modified 1 Oct 1972 by Dan Bricklin to add bignum types.
                                  1-10  
                                  1-11  
                                  1-12  
                        077700    1-13  	bool	lisp_ptr.type,077700	"the whole type field
                                  1-14  
                        040000    1-15  	bool	Fixed,040000		"fixed number, stored in second word of ptr
                        020000    1-16  	bool	Float,020000		"floating number, stored in second word of ptr
                        061400    1-17  	bool	Numeric,061400		"fixed or float, big or little
                        010000    1-18  	bool	Atsym,010000		"Atomic symbol pointed at by ptr
                        077700    1-19  	bool	Atomic,077700		"any of these bits indicates an atom (non-list)
                        001000    1-20  	bool	Bignum,001000		"points to a bignum - fixed
                        060000    1-21  	bool	Uncollectable,060000	"not a pointer, also both bits on = "pdl_ptr"
                        004000    1-22  	bool	String,004000		"points at a lisp character string
                        002000    1-23  	bool	Subr,002000		"points at subr link
                        000400    1-24  	bool	System_Subr,000400		"marks a subr as being in the text of lisp bound seg.
                        000200    1-25  	bool	Array,000200		"points at an array,
                                  1-26  					" which is a special kind of subr
                        067500    1-27  	bool	Unevalable,067500		"any of these bits means
                                  1-28  					" does not have car and cdr
                        001000    1-29  	bool	Big_fixed,001000		"points to fixed bignum
                        000100    1-30  	bool	File,000100		"points to a file object (i.e. an iochan)
                                  1-31  
                                  1-32  "fields for making numbers, a fault tag is included in case someone takes the car or cdr of it
                                  1-33  
                        040047    1-34  	bool	fixnum_type,040047
                        020047    1-35  	bool	flonum_type,020047
                                  1-36  
                                  1-37  " END INCLUDE FILE: lisp_object_types.incl.alm
                                  1269  	include	lisp_stack_seg
                                   2-1  " BEGIN INCLUDE FILE lisp_stack_seg.incl.alm
                                   2-2  
                                   2-3  "	lisp stack segment header format
                                   2-4  "	Last modified by Reed 6/21/72
                                   2-5  "
                        000000     2-6  	equ	marked_stack_bottom,0	offset of ptr to bottom of marked stack
                        000002     2-7  	equ	unmkd_stack_bottom,2	offset of ptr to bottom of unmkd_stack
                        000004     2-8  	equ	stack_ptr_ptr,4		offset of ptr to lisp_static_vars_$stack_ptr
                        000006     2-9  	equ	unmkd_ptr_ptr,6		offset of ptr to lisp_static_vars_$unmkd_ptr's offset word
                        000010    2-10  	equ	array_pointer,8		points at cell of array most recently referenced
                        000012    2-11  	equ	nil,10			offset of cell containing pointer to nil...
                        000014    2-12  	equ	true,12			offset of cell containing pointer to t...
                        000016    2-13  	equ	in_pl1_code,14		offset of flag saying whether stack_ptr
                                  2-14  "					& unmkd_ptr or ap and ab|.,x7 are valid...if zero, ap,ab arevalid.
                                  2-15  " table of pointers to operators
                                  2-16  
                        000020    2-17  	equ	bind_op,16
                        000022    2-18  	equ	unbind_op,18
                        000024    2-19  	equ	errset1_op,20
                        000026    2-20  	equ	errset2_op,22
                        000030    2-21  	equ	unerrset_op,24
                        000032    2-22  	equ	call_op,26
                        000034    2-23  	equ	catch1_op,28
                        000036    2-24  	equ	catch2_op,30
                        000040    2-25  	equ	uncatch_op,32
                        000042    2-26  	equ	gensym_data,34	" data for gensym function
                                  2-27  
                        000044    2-28  	equ	system_lp,36		pointer to common linkage section for bound segment.
                        000046    2-29  	equ	iogbind_op,38		operator to help out with compiled iog.
                        000050    2-30  	equ	unseen_go_tag_op,40
                        000052    2-31  	equ	throw1_op,42
                        000054    2-32  	equ	throw2_op,44
                        000056    2-33  	equ	signp_op,46
                        000060    2-34  	equ	type_fields,48
                        000062    2-35  	equ	return_op,50
                        000064    2-36  	equ	err_op,52
                        000066    2-37  	equ	pl1_interface,54
                        000070    2-38  	equ	pl1_lsubr_interface,56
                        000072    2-39  	equ	cons_op,58		operator for compiled cons
                        000074    2-40  	equ	ncons_op,60		opeator for compiled cons with nil
                        000076    2-41  	equ	xcons_op,62		operator for compiled xcons
                        000100    2-42  	equ	begin_list_op,64		operator to begin compiled list code
                        000102    2-43  	equ	append_list_op,66		operator to get new list cell and hook on end
                        000104    2-44  	equ	terminate_list_op,68	operator to finish off list.
                        000106    2-45  	equ	compare_op,70
                        000110    2-46  	equ	link_opr,72
                        000112    2-47  	equ	array_operator,74
                        000114    2-48  	equ	dead_array_operator,76
                        000116    2-49  	equ	store_operator,78
                        000120    2-50  	equ	floating_store_operator,80
                        000122    2-51  	equ	array_info_for_store,82
                        000124    2-52  	equ	array_offset_for_store,84
                        000126    2-53  	equ	array_link_snap_opr,86
                        000130    2-54  	equ	create_string_desc_op,88	string desc for PL/I call
                        000132    2-55  	equ	create_array_desc_op,90	array desc for PL/I call
                        000134    2-56  	equ	pl1_call_op,92		PL/I call operator
                        000136    2-57  	equ	cons_string_op,94		operator to cons up a string
                        000140    2-58  	equ	create_varying_string_op,96
                        000142    2-59  	equ	unwp1_op,98		unwind-protect start
                        000144    2-60  	equ	unwp2_op,100		ditto, for compat.
                        000146    2-61  	equ	ununwp_op,102		End unwind-protect.
                        000150    2-62  	equ	irest_return_op,104 	Interrupt restore return
                        000152    2-63  	equ	pl1_call_nopop_op,106	PL1 call, dont pop PL1 frame
                        000154    2-64  	equ	rcv_char_star_op,108	Receive char * result, pop pl1frame
                                  2-65  	" spare 110
                        000174    2-66  	equ	begin_unmkd_stack,124	beginning of unmkd_stack
                                  2-67  
                                  2-68  " END INCLUDE FILE lisp_stack_seg.incl.alm
                                  2-69  
                                  1270  	include 	lisp_error_codes
                                   3-1  
                                   3-2  " BEGIN INCLUDE FILE lisp_error_codes.incl.alm
                                   3-3  
                                   3-4  "This contains codes to be stored on the unmkd pdl before calling
                                   3-5  "lisp_error_.  These codes, at ab|-2,x7, are used by lisp_error_
                                   3-6  "as an index into lisp_error_table_.
                                   3-7  
                        000144     3-8  	equ	undefined_atom,100			- correctable
                        000145     3-9  	equ	undefined_function,101		- correctable
                        000146    3-10  	equ	too_many_args,102			uncorrectable 
                        000147    3-11  	equ	too_few_args,103			..
                        000150    3-12  	equ	file_system_error,104		(obsolete)
                        000151    3-13  	equ	bad_argument,105			uncorrectable arg reject
                        000152    3-14  	equ	undefined_subr,106
                        000153    3-15  	equ	bad_function,107			"bad functional form"
                        000154    3-16  	equ	bad_bv,108			attempt to bind non-variable
                        000155    3-17  	equ	unseen_go_tag,109			correctable -> unevaled new tag
                        000156    3-18  	equ	throw_to_no_catch,110		..
                        000157    3-19  	equ	nonfixedarg,111			correctable
                        000160    3-20  	equ	parenmissing,112			uncorr reader error
                        000161    3-21  	equ	doterror,113			..
                        000162    3-22  	equ	illobj,114			..
                        000163    3-23  	equ	badmacro,115			..
                        000164    3-24  	equ	shortreadlist,116			..
                        000165    3-25  	equ	badreadlist,117			..
                        000166    3-26  	equ	array_bound_error,118		corr -> (array sub1 sub2...)
                        000167    3-27  	equ	car_cdr_error,119			uncorr - car or cdr of number
                        000170    3-28  	equ	bad_arg_correctable,120		correctable arg reject
                        000171    3-29  	equ	bad_prog_op,121			uncorr fail-act: go or return
                        000172    3-30  	equ	no_lexpr,122			uncorr fail-act: args or setarg
                        000173    3-31  	equ	wrong_no_args,123			correctable wna -> new expr value
                        000174    3-32  	equ	bad_ibase,124			corr
                        000175    3-33  	equ	bad_base,125			corr
                        000176    3-34  	equ	bad_input_source,126		corr - retry i/o
                        000177    3-35  	equ	bad_output_dest,127			..
                        000200    3-36  	equ	nihil_ex_nihile,128			uncorr - attempt to setq nil
                        000203    3-37  	equ	not_pdl_ptr,131			corr arg reject - for pdl ptr args
                        000206    3-38  	equ	bad_f_fcn,134			compiled call to fsubr with evaled args
                        000207    3-39  	equ	overflow_err,135			arithmetic overflow.
                        000210    3-40  	equ	mismatch_super_parens,136		uncorr reader error
                        000211    3-41  	equ	no_left_super_paren,137		..
                        000212    3-42  	equ	flonum_too_big,138			..
                        000213    3-43  	equ	quoterror,139			..
                        000214    3-44  	equ	badreadtable,140			..
                        000215    3-45  	equ	badobarray,141			..
                        000216    3-46  	equ	atan_0_0_err,142			(atan 0 0) doesn't work
                        000217    3-47  	equ	unable_to_float,143			corr arg reject - (float x)
                        000220    3-48  	equ	division_by_zero,144		uncorr (should really be corr)
                        000221    3-49  	equ	eof_in_object,145			corr fail-act -> keep reading anyway
                        000222    3-50  	equ	cant_filepos,146			corr fail-act -> new expr value
                        000223    3-51  	equ	filepos_oob,147			..
                        000224    3-52  	equ	file_sys_fun_err,148		corr f.s. err -> new expr value
                        000225    3-53  	equ	stars_left_in_name,149		..
                        000226    3-54  	equ	io_wrong_direction,150		..
                        000227    3-55  	equ	file_is_closed,151			..
                        000230    3-56  	equ	reopen_inconsistent,152		..
                        000231    3-57  	equ	bad_entry_name,153			..
                        000232    3-58  	equ	bad_do_format,154			bad do format in interp.
                        000233    3-59  	equ	not_an_array,155			bad array-type arg
                        000234    3-60  	equ	not_alpha_array,156			bad all-alphabetic array
                        000235    3-61  	equ	include_file_error,157		%include barfed
                        000236    3-62  	equ	stack_loss_error,158		stack overflew
                        000237    3-63  	equ	underflow_fault,159
                        000240    3-64  	equ	zerodivide_fault,160
                        000241    3-65  	equ	bad_array_subscript,161
                        000242    3-66  	equ	store_not_allowed,162
                        000243    3-67  	equ	dead_array_reference,163
                        000244    3-68  	equ	cant_subscript_readtable,164
                        000245    3-69  	equ	not_same_type,165
                        000246    3-70  	equ	special_array_type,166
                        000247    3-71  	equ	array_too_big,167
                        000250    3-72  	equ	argument_must_be_array,168
                        000251    3-73  	equ	store_function_misused,169
                                  3-74  
                                  3-75  " END INCLUDE FILE lisp_error_codes.incl.alm
                                  1271  	include 	lisp_name_codes
                                   4-1  
                                   4-2  " BEGIN INCLUDE FILE lisp_name_codes.incl.alm
                                   4-3  
                                   4-4  " These are codes for the names of functions which are stored into ab|-1,x7 before
                                   4-5  " calling lisp_error_ for a bad_argument or bad_arg_correctable error. They
                                   4-6  " are used so that the name of the function which is rejecting its argument
                                   4-7  " can be printed.  Please note that all these codes are negative.
                                   4-8  
                 777777 777766     4-9  	equ	fn_do,-10
                 777777 777765    4-10  	equ	fn_arg,-11
                 777777 777764    4-11  	equ	fn_setarg,-12
                 777777 777763    4-12  	equ	fn_status,-13
                 777777 777762    4-13  	equ	fn_sstatus,-14
                 777777 777761    4-14  	equ	fn_errprint,-15
                 777777 777760    4-15  	equ	fn_errframe,-16
                 777777 777757    4-16  	equ	fn_evalframe,-17
                 777777 777756    4-17  	equ	fn_defaultf,-18
                 777777 777752    4-18  	equ	fn_tyo,-22
                 777777 777751    4-19  	equ	fn_ascii,-23
                 777777 777750    4-20  	equ	fn_rplaca,-24
                 777777 777747    4-21  	equ	fn_definedp,-25
                 777777 777746    4-22  	equ	fn_setq,-26
                 777777 777745    4-23  	equ	fn_set,-27
                 777777 777744    4-24  	equ	fn_delete,-28
                 777777 777743    4-25  	equ	fn_delq,-29
                 777777 777742    4-26  	equ	fn_stringlength,-30
                 777777 777741    4-27  	equ	fn_catenate,-31
                 777777 777740    4-28  	equ	fn_array,-32
                 777777 777737    4-29  	equ	fn_substr,-33
                 777777 777736    4-30  	equ	fn_index,-34
                 777777 777735    4-31  	equ	fn_get_pname,-35
                 777777 777734    4-32  	equ	fn_make_atom,-36
                 777777 777733    4-33  	equ	fn_ItoC,-37
                 777777 777732    4-34  	equ	fn_CtoI,-38
                 777777 777731    4-35  	equ	fn_defsubr,-39
                 777777 777730    4-36  	equ	fn_star_array,-40
                 777777 777727    4-37  	equ	fn_args,-41
                 777777 777726    4-38  	equ	fn_sysp,-42
                 777777 777725    4-39  	equ	fn_get,-43
                 777777 777724    4-40  	equ	fn_getl,-44
                 777777 777723    4-41  	equ	fn_putprop,-45
                 777777 777722    4-42  	equ	fn_remprop,-46
                 777777 777721    4-43  	equ	fn_save,-47
                 777777 777720    4-44  	equ	fn_add1,-48
                 777777 777717    4-45  	equ	fn_sub1,-49
                 777777 777716    4-46  	equ	fn_greaterp,-50
                 777777 777715    4-47  	equ	fn_lessp,-51
                 777777 777714    4-48  	equ	fn_minus,-52
                 777777 777713    4-49  	equ	fn_plus,-53
                 777777 777712    4-50  	equ	fn_times,-54
                 777777 777711    4-51  	equ	fn_difference,-55
                 777777 777710    4-52  	equ	fn_quotient,-56
                 777777 777707    4-53  	equ	fn_abs,-57
                 777777 777706    4-54  	equ	fn_expt,-58
                 777777 777705    4-55  	equ	fn_boole,-59
                 777777 777704    4-56  	equ	fn_rot,-60
                 777777 777703    4-57  	equ	fn_lsh,-61
                 777777 777702    4-58  	equ	fn_signp,-62
                 777777 777701    4-59  	equ	fn_fix,-63
                 777777 777700    4-60  	equ	fn_float,-64
                 777777 777677    4-61  	equ	fn_remainder,-65
                 777777 777676    4-62  	equ	fn_max,-66
                 777777 777675    4-63  	equ	fn_min,-67
                 777777 777674    4-64  	equ	fn_add1_fix,-68
                 777777 777673    4-65  	equ	fn_add1_flo,-69
                 777777 777672    4-66  	equ	fn_sub1_fix,-70
                 777777 777671    4-67  	equ	fn_sub1_flo,-71
                 777777 777670    4-68  	equ	fn_plus_fix,-72
                 777777 777667    4-69  	equ	fn_plus_flo,-73
                 777777 777666    4-70  	equ	fn_times_fix,-74
                 777777 777665    4-71  	equ	fn_times_flo,-75
                 777777 777664    4-72  	equ	fn_diff_fix,-76
                 777777 777663    4-73  	equ	fn_diff_flo,-77
                 777777 777662    4-74  	equ	fn_quot_fix,-78
                 777777 777661    4-75  	equ	fn_quot_flo,-79
                 777777 777660    4-76  	equ	fn_eval,-80
                 777777 777657    4-77  	equ	fn_apply,-81
                 777777 777656    4-78  	equ	fn_prog,-82
                 777777 777655    4-79  	equ	fn_errset,-83
                 777777 777654    4-80  	equ	fn_catch,-84
                 777777 777653    4-81  	equ	fn_throw,-85
                 777777 777652    4-82  	equ	fn_store,-86
                 777777 777651    4-83  	equ	fn_defun,-87
                 777777 777650    4-84  	equ	fn_baktrace,-88
                 777777 777647    4-85  	equ	fn_bltarray,-89
                 777777 777646    4-86  	equ	fn_star_rearray,-90
                 777777 777645    4-87  	equ	fn_gensym,-91
                 777777 777644    4-88  	equ	fn_makunbound,-92
                 777777 777643    4-89  	equ	fn_boundp,-93
                 777777 777642    4-90  	equ	fn_star_status,-94
                 777777 777641    4-91  	equ	fn_star_sstatus,-95
                 777777 777640    4-92  	equ	fn_freturn,-96
                 777777 777637    4-93  	equ	fn_cos,-97
                 777777 777636    4-94  	equ	fn_sin,-98
                 777777 777635    4-95  	equ	fn_exp,-99
                 777777 777634    4-96  	equ	fn_log,-100
                 777777 777633    4-97  	equ	fn_sqrt,-101
                 777777 777632    4-98  	equ	fn_isqrt,-102
                 777777 777631    4-99  	equ	fn_atan,-103
                 777777 777630   4-100  	equ	fn_sleep,-104
                 777777 777627   4-101  	equ	fn_oddp,-105
                 777777 777626   4-102  	equ	fn_tyipeek,-106
                 777777 777625   4-103  	equ	fn_alarmclock,-107
                 777777 777624   4-104  	equ	fn_plusp,-108
                 777777 777623   4-105  	equ	fn_minusp,-109
                 777777 777622   4-106  	equ	fn_ls,-110
                 777777 777621   4-107  	equ	fn_eql,-111
                 777777 777620   4-108  	equ	fn_gt,-112
                 777777 777617   4-109  	equ	fn_alphalessp,-113
                 777777 777616   4-110  	equ	fn_samepnamep,-114
                 777777 777615   4-111  	equ	fn_getchar,-115
                 777777 777614   4-112  	equ	fn_opena,-116
                 777777 777613   4-113  	equ	fn_sxhash,-117
                 777777 777612   4-114  	equ	fn_gcd,-118
                 777777 777611   4-115  	equ	fn_allfiles,-119
                 777777 777610   4-116  	equ	fn_chrct,-120
                 777777 777607   4-117  	equ	fn_close,-121
                 777777 777606   4-118  	equ	fn_deletef,-122
                 777777 777605   4-119  	equ	fn_eoffn,-123
                 777777 777604   4-120  	equ	fn_filepos,-124
                 777777 777603   4-121  	equ	fn_inpush,-125
                 777777 777602   4-122  	equ	fn_linel,-126
                 777777 777601   4-123  	equ	fn_mergef,-127
                 777777 777600   4-124  	equ	fn_namelist,-128
                 777777 777577   4-125  	equ	fn_names,-129
                 777777 777576   4-126  	equ	fn_namestring,-130
                 777777 777575   4-127  	equ	fn_openi,-131
                 777777 777574   4-128  	equ	fn_openo,-132
                 777777 777573   4-129  	equ	fn_prin1,-133
                 777777 777572   4-130  	equ	fn_princ,-134
                 777777 777571   4-131  	equ	fn_print,-135
                 777777 777570   4-132  	equ	fn_read,-136
                 777777 777567   4-133  	equ	fn_readch,-137
                 777777 777566   4-134  	equ	fn_readstring,-138
                 777777 777565   4-135  	equ	fn_rename,-139
                 777777 777564   4-136  	equ	fn_shortnamestring,-140
                 777777 777563   4-137  	equ	fn_tyi,-141
                 777777 777562   4-138  	equ	fn_setsyntax,-142
                 777777 777561   4-139  	equ	fn_cursorpos,-143
                 777777 777560   4-140  	equ	fn_force_output,-144
                 777777 777557   4-141  	equ	fn_clear_input,-145
                 777777 777556   4-142  	equ	fn_random,-146
                 777777 777555   4-143  	equ	fn_haulong,-147
                 777777 777554   4-144  	equ	fn_haipart,-148
                 777777 777553   4-145  	equ	fn_cline,-149
                 777777 777552   4-146  	equ	fn_fillarray,-150
                 777777 777551   4-147  	equ	fn_listarray,-151
                 777777 777550   4-148  	equ	fn_sort,-152
                 777777 777547   4-149  	equ	fn_sortcar,-153
                 777777 777546   4-150  	equ	fn_zerop,-154
                 777777 777545   4-151  	equ	fn_listify,-155
                 777777 777544   4-152  	equ	fn_charpos,-156
                 777777 777543   4-153  	equ	fn_pagel,-157
                 777777 777542   4-154  	equ	fn_linenum,-158
                 777777 777541   4-155  	equ	fn_pagenum,-159
                 777777 777540   4-156  	equ	fn_endpagefn,-160
                 777777 777537   4-157  	equ	fn_arraydims,-161
                 777777 777536   4-158  	equ	fn_loadarrays,-162
                 777777 777535   4-159  	equ	fn_dumparrays,-163
                 777777 777534   4-160  	equ	fn_expt_fix,-164
                 777777 777533   4-161  	equ	fn_expt_flo,-165
                 777777 777532   4-162  	equ	fn_nointerrupt,-166
                 777777 777531   4-163  	equ	fn_open,-167
                 777777 777530   4-164  	equ	fn_in,-168
                 777777 777527   4-165  	equ	fn_out,-169
                 777777 777526   4-166  	equ	fn_truename,-170
                 777777 777525   4-167  	equ	fn_ifix,-171
                 777777 777524   4-168  	equ	fn_fsc,-172
                 777777 777523   4-169  	equ	fn_progv,-173
                 777777 777522   4-170  	equ	fn_mapatoms,-174
                 777777 777521   4-171  	equ	fn_unwind_protect,-175
                 777777 777520   4-172  	equ	fn_eval_when,-176
                 777777 777517   4-173  	equ	fn_read_from_string,-177
                 777777 777516   4-174  	equ	fn_displace,-178
                 777777 777515   4-175  	equ	fn_nth,-179
                 777777 777514   4-176  	equ	fn_nthcdr,-180
                 777777 777513   4-177  	equ	fn_includef,-181
                                 4-178  
                                 4-179  " END INCLUDE FILE lisp_name_codes.incl.alm
                                  1272  	include	stack_header
                                   5-1  "	BEGIN INCLUDE FILE ... stack_header.incl.alm  3/72  Bill Silver
                                   5-2  "
                                   5-3  "	modified 7/76 by M. Weaver for *system links and more system use of areas
                                   5-4  "	modified 3/77 by M. Weaver  to add rnt_ptr
                                   5-5  "	modified 7/77 by S. Webber to add run_unit_depth and assign_linkage_ptr
                                   5-6  "	modified 6/83 by J. Ives to add trace_frames and in_trace.
                                   5-7  
                                   5-8  " HISTORY COMMENTS:
                                   5-9  "  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
                                  5-10  "     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
                                  5-11  "     added the heap_header_ptr definition
                                  5-12  "  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
                                  5-13  "     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
                                  5-14  "     Modified to support control point management.  These changes were
                                  5-15  "     actually made in February 1985 by G. Palter.
                                  5-16  "  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
                                  5-17  "     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
                                  5-18  "     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
                                  5-19  "     bit pad after cur_lot_size for the cpm_enabled. This was done to save
                                  5-20  "     some space int the stack header and change the cpd_ptr unal to
                                  5-21  "     cpm_data_ptr (ITS pair).
                                  5-22  "                                                      END HISTORY COMMENTS
                                  5-23  
                        000004    5-24  	equ	stack_header.cpm_data_ptr,4		ptr to control point for this stack
                        000006    5-25  	equ	stack_header.combined_stat_ptr,6	ptr to separate static area
                                  5-26  
                        000010    5-27  	equ	stack_header.clr_ptr,8		ptr to area containing linkage sections
                        000012    5-28  	equ	stack_header.max_lot_size,10		number of words allowed in lot (DU)
                        000012    5-29  	equ	stack_header.main_proc_invoked,10	nonzero if main proc was invoked in run unit (DL)
                        000012    5-30  	equ	stack_header.run_unit_depth,10	number of active run units stacked (DL)
                        000013    5-31  	equ	stack_header.cur_lot_size,11		DU number of words (entries) in lot
                        000013    5-32            equ	stack_header.cpm_enabled,11		DL  non-zero if control point management is enabled
                        000014    5-33  	equ	stack_header.system_free_ptr,12	ptr to system storage area
                        000016    5-34  	equ	stack_header.user_free_ptr,14		ptr to user storage area
                                  5-35  
                        000020    5-36  	equ	stack_header.parent_ptr,16		ptr to parent stack or null
                        000022    5-37  	equ	stack_header.stack_begin_ptr,18	ptr to first stack frame
                        000024    5-38  	equ	stack_header.stack_end_ptr,20		ptr to next useable stack frame
                        000026    5-39  	equ	stack_header.lot_ptr,22		ptr to the lot for the current ring
                                  5-40  
                        000030    5-41  	equ	stack_header.signal_ptr,24		ptr to signal proc for current ring
                        000032    5-42  	equ	stack_header.bar_mode_sp,26		value of sp before entering bar mode
                        000034    5-43  	equ	stack_header.pl1_operators_ptr,28	ptr: pl1_operators_$operator_table
                        000036    5-44  	equ	stack_header.call_op_ptr,30		ptr to standard call operator
                                  5-45  
                        000040    5-46  	equ	stack_header.push_op_ptr,32		ptr to standard push operator
                        000042    5-47  	equ	stack_header.return_op_ptr,34		ptr to standard return operator
                        000044    5-48  	equ	stack_header.ret_no_pop_op_ptr,36	ptr: stand. return/ no pop operator
                        000046    5-49  	equ	stack_header.entry_op_ptr,38		ptr to standard entry operator
                                  5-50  
                        000050    5-51  	equ	stack_header.trans_op_tv_ptr,40	ptr to table of translator operator ptrs
                        000052    5-52  	equ	stack_header.isot_ptr,42		pointer to ISOT
                        000054    5-53  	equ	stack_header.sct_ptr,44		pointer to System Condition Table
                        000056    5-54  	equ	stack_header.unwinder_ptr,46		pointer to unwinder for current ring
                                  5-55  
                        000060    5-56  	equ	stack_header.sys_link_info_ptr,48	ptr to *system link name table
                        000062    5-57  	equ	stack_header.rnt_ptr,50		ptr to reference name table
                        000064    5-58  	equ	stack_header.ect_ptr,52		ptr to event channel table
                        000066    5-59  	equ	stack_header.assign_linkage_ptr,54	ptr to area for hcs_$assign_linkage calls
                        000070    5-60  	equ	stack_header.heap_header_ptr,56	ptr to heap header.
                        000072    5-61  	equ	stack_header.trace_frames,58		stack of trace_catch_ frames
                        000073    5-62  	equ	stach_header.trace_top_ptr,59		trace pointer
                        000074    5-63  	equ	stack_header.in_trace,60		trace antirecurse bit
                        000100    5-64  	equ	stack_header_end,64			length of stack header
                                  5-65  
                                  5-66  
                                  5-67  
                                  5-68  
                        000000    5-69  	equ	trace_frames.count,0		number of trace frames on stack
                        000001    5-70  	equ	trace_frames.top_ptr,1		packed pointer to top one
                                  5-71  
                                  5-72  "	The  following constant is an offset within the  pl1  operators table.
                                  5-73  "	It  references a  transfer vector table.
                                  5-74  
                        000551    5-75  	bool	tv_offset,551
                                  5-76  
                                  5-77  
                                  5-78  "	The  following constants are offsets within this transfer vector table.
                                  5-79  
                        001170    5-80  	equ	call_offset,tv_offset+271
                        001171    5-81  	equ	push_offset,tv_offset+272
                        001172    5-82  	equ	return_offset,tv_offset+273
                        001173    5-83  	equ	return_no_pop_offset,tv_offset+274
                        001174    5-84  	equ	entry_offset,tv_offset+275
                                  5-85  
                                  5-86  
                                  5-87  " 	END INCLUDE FILE stack_header.incl.alm
                                  1273  	include 	stack_frame
                                   6-1  "
                                   6-2  "	BEGIN INCLUDE FILE ... stack_frame.incl.alm   6/72 RBS
                                   6-3  "
                                   6-4  " Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr
                                   6-5  " Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager_bit & main_proc_bit
                                   6-6  " Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr
                                   6-7  "
                        000020     6-8  	equ	stack_frame.prev_sp,16
                        000020     6-9  	equ	stack_frame.condition_word,16
                        000022    6-10  	equ	stack_frame.next_sp,18
                        000022    6-11  	equ	stack_frame.signaller_word,18
                        000024    6-12  	equ	stack_frame.return_ptr,20
                        000026    6-13  	equ	stack_frame.entry_ptr,22
                        000030    6-14  	equ	stack_frame.operator_ptr,24
                        000030    6-15  	equ	stack_frame.lp_ptr,24
                        000032    6-16  	equ	stack_frame.arg_ptr,26
                        000034    6-17  	equ	stack_frame.static_ptr,28
                        000035    6-18  	equ	stack_frame.support_ptr,29	" only used by fortran I/O
                        000036    6-19  	equ	stack_frame.on_unit_rel_ptrs,30
                        000037    6-20  	equ	stack_frame.operator_ret_ptr,31
                        000037    6-21  	equ	stack_frame.translator_id,31
                        000040    6-22  	equ	stack_frame.regs,32
                        000060    6-23  	equ	stack_frame.min_length,48
                        000020    6-24  	equ	stack_frame.flag_word,16
                        020000    6-25  	bool	stack_frame.main_proc_bit,020000	(DL)
                        010000    6-26  	bool	stack_frame.run_unit_manager,010000	(DL)
                        004000    6-27  	bool	stack_frame.signal_bit,004000		(DL)
                        002000    6-28  	bool	stack_frame.crawl_out_bit,002000	(DL)
                        001000    6-29  	bool	stack_frame.signaller_bit,001000	(DL)
                        000400    6-30  	bool	stack_frame.link_trap_bit,000400	(DL)
                        000200    6-31  	bool	stack_frame.support_bit,000200	(DL)
                        000100    6-32  	bool	stack_frame.condition_bit,000100	(DL)
                                  6-33  
                                  6-34  "
                                  6-35  "	END INCLUDE FILE  ... stack_frame.incl.alm
                                  6-36  "
                                  1274  	end
ENTRY SEQUENCES
     
    001560  5a   000246 0000 00
    001561  aa  7 00046 2721 20
    001562  0a   000344 7100 00
    001563  5a   000241 0000 00
    001564  aa  7 00046 2721 20
    001565  0a   000363 7100 00
    001566  5a   000234 0000 00
    001567  aa  7 00046 2721 20
    001570  0a   000373 7100 00
    001571  5a   000227 0000 00
    001572  aa  7 00046 2721 20
    001573  0a   000401 7100 00
    001574  5a   000222 0000 00
    001575  aa  7 00046 2721 20
    001576  0a   000407 7100 00
    001577  5a   000214 0000 00
    001600  aa  7 00046 2721 20
    001601  0a   000417 7100 00
    001602  5a   000207 0000 00
    001603  aa  7 00046 2721 20
    001604  0a   000427 7100 00
    001605  5a   000202 0000 00
    001606  aa  7 00046 2721 20
    001607  0a   000437 7100 00
    001610  5a   000174 0000 00
    001611  aa  7 00046 2721 20
    001612  0a   000445 7100 00
    001613  5a   000165 0000 00
    001614  aa  7 00046 2721 20
    001615  0a   000453 7100 00
    001616  5a   000157 0000 00
    001617  aa  7 00046 2721 20
    001620  0a   000461 7100 00
    001621  5a   000016 0000 00
    001622  aa  7 00046 2721 20
    001623  0a   001475 7100 00
LITERALS
     
    001624  aa   000004 740004 
    001625  aa   002412 753773 
NAME DEFINITIONS FOR ENTRY POINTS AND SEGDEFS

    001626  5a   000003 000000 
    001627  5a   000414 600000 
    001630  aa   000000 000000 
    001631  55   000011 000002 
    001632  5a   000002 400003 
    001633  55   000006 000011 
    001634  aa  013 154 151 163
    001635  aa  160 137 141 154
    001636  aa  154 157 143 137
    001637  55   000016 000003 
    001640  0a   001523 400000 
    001641  55   000014 000003 
    001642  aa  006 155 165 156         munkam
    001643  aa  153 141 155 000
    001644  55   000025 000011 
    001645  0a   001622 500000 
    001646  55   000021 000003 
    001647  aa  015 162 145 150         rehash_maknum
    001650  aa  141 163 150 137
    001651  aa  155 141 153 156
    001652  aa  165 155 000 000
    001653  55   000032 000016 
    001654  0a   001321 400000 
    001655  55   000030 000003 
    001656  aa  006 155 141 153         maknum
    001657  aa  156 165 155 000
    001660  55   000040 000025 
    001661  0a   001266 400000 
    001662  55   000035 000003 
    001663  aa  012 155 141 153         makunbound
    001664  aa  165 156 142 157
    001665  aa  165 156 144 000
    001666  55   000045 000032 
    001667  0a   001253 400000 
    001670  55   000043 000003 
    001671  aa  006 142 157 165         boundp
    001672  aa  156 144 160 000
    001673  55   000052 000040 
    001674  0a   001115 400000 
    001675  55   000050 000003 
    001676  aa  006 163 165 142         sublis
    001677  aa  154 151 163 000
    001700  55   000057 000045 
    001701  0a   001051 400000 
    001702  55   000055 000003 
    001703  aa  006 163 165 142         subst_
    001704  aa  163 164 137 000
    001705  55   000065 000052 
    001706  0a   001044 400000 
    001707  55   000062 000003 
    001710  aa  010 156 162 145         nreconc_
    001711  aa  143 157 156 143
    001712  aa  137 000 000 000
    001713  55   000073 000057 
    001714  0a   001022 400000 
    001715  55   000070 000003 
    001716  aa  011 156 162 145         nreverse_
    001717  aa  166 145 162 163
    001720  aa  145 137 000 000
    001721  55   000100 000065 
    001722  0a   000774 400000 
    001723  55   000076 000003 
    001724  aa  007 162 145 166         reverse
    001725  aa  145 162 163 145
    001726  55   000105 000073 
    001727  0a   000751 400000 
    001730  55   000103 000003 
    001731  aa  005 156 143 157         nconc
    001732  aa  156 143 000 000
    001733  55   000112 000100 
    001734  0a   000705 400000 
    001735  55   000110 000003 
    001736  aa  006 141 160 160         append
    001737  aa  145 156 144 000
    001740  55   000120 000105 
    001741  0a   000625 400000 
    001742  55   000115 000003 
    001743  aa  012 143 157 160         copysymbol
    001744  aa  171 163 171 155
    001745  aa  142 157 154 000
    001746  55   000125 000112 
    001747  0a   000542 400000 
    001750  55   000123 000003 
    001751  aa  007 147 145 156         gensym_
    001752  aa  163 171 155 137
    001753  55   000132 000120 
    001754  0a   000521 400000 
    001755  55   000130 000003 
    001756  aa  005 154 151 163         list_
    001757  aa  164 137 000 000
    001760  55   000140 000125 
    001761  0a   000516 400000 
    001762  55   000135 000003 
    001763  aa  012 154 151 163         list_star_
    001764  aa  164 137 163 164
    001765  aa  141 162 137 000
    001766  55   000145 000132 
    001767  0a   000505 400000 
    001770  55   000143 000003 
    001771  aa  006 156 143 157         ncons_
    001772  aa  156 163 137 000
    001773  55   000152 000140 
    001774  0a   000500 400000 
    001775  55   000150 000003 
    001776  aa  006 170 143 157         xcons_
    001777  aa  156 163 137 000
    002000  55   000157 000145 
    002001  0a   000464 400000 
    002002  55   000155 000003 
    002003  aa  005 143 157 156         cons_
    002004  aa  163 137 000 000
    002005  55   000165 000152 
    002006  0a   001617 500000 
    002007  55   000162 000003 
    002010  aa  011 163 145 164         set_fault
    002011  aa  137 146 141 165
    002012  aa  154 164 000 000
    002013  55   000174 000157 
    002014  0a   001614 500000 
    002015  55   000170 000003 
    002016  aa  016 147 145 164         get_fault_word
    002017  aa  137 146 141 165
    002020  aa  154 164 137 167
    002021  aa  157 162 144 000
    002022  55   000202 000165 
    002023  0a   001611 500000 
    002024  55   000177 000003 
    002025  aa  010 156 162 145         nreverse
    002026  aa  166 145 162 163
    002027  aa  145 000 000 000
    002030  55   000207 000174 
    002031  0a   001606 500000 
    002032  55   000205 000003 
    002033  aa  005 163 165 142         subst
    002034  aa  163 164 000 000
    002035  55   000214 000202 
    002036  0a   001603 500000 
    002037  55   000212 000003 
    002040  aa  006 147 145 156         gensym
    002041  aa  163 171 155 000
    002042  55   000222 000207 
    002043  0a   001600 500000 
    002044  55   000217 000003 
    002045  aa  011 154 151 163         list_star
    002046  aa  164 137 163 164
    002047  aa  141 162 000 000
    002050  55   000227 000214 
    002051  0a   001575 500000 
    002052  55   000225 000003 
    002053  aa  004 154 151 163         list
    002054  aa  164 000 000 000
    002055  55   000234 000222 
    002056  0a   001572 500000 
    002057  55   000232 000003 
    002060  aa  005 156 143 157         ncons
    002061  aa  156 163 000 000
    002062  55   000241 000227 
    002063  0a   001567 500000 
    002064  55   000237 000003 
    002065  aa  005 170 143 157         xcons
    002066  aa  156 163 000 000
    002067  55   000246 000234 
    002070  0a   001564 500000 
    002071  55   000244 000003 
    002072  aa  004 143 157 156         cons
    002073  aa  163 000 000 000
    002074  55   000254 000241 
    002075  0a   001561 500000 
    002076  55   000251 000003 
    002077  aa  013 154 151 163         lisp_alloc_
    002100  aa  160 137 141 154
    002101  aa  154 157 143 137
    002102  55   000262 000246 
    002103  0a   000241 400000 
    002104  55   000257 000003 
    002105  aa  013 143 157 156         cons_string
    002106  aa  163 137 163 164
    002107  aa  162 151 156 147
    002110  55   000272 000254 
    002111  0a   000234 400000 
    002112  55   000265 000003 
    002113  aa  022 164 145 162         terminate_list_opr
    002114  aa  155 151 156 141
    002115  aa  164 145 137 154
    002116  aa  151 163 164 137
    002117  aa  157 160 162 000
    002120  55   000301 000262 
    002121  0a   000227 400000 
    002122  55   000275 000003 
    002123  aa  017 141 160 160         append_list_opr
    002124  aa  145 156 144 137
    002125  aa  154 151 163 164
    002126  aa  137 157 160 162
    002127  55   000310 000272 
    002130  0a   000223 400000 
    002131  55   000304 000003 
    002132  aa  016 142 145 147         begin_list_opr
    002133  aa  151 156 137 154
    002134  aa  151 163 164 137
    002135  aa  157 160 162 000
    002136  55   000316 000301 
    002137  0a   000216 400000 
    002140  55   000313 000003 
    002141  aa  011 170 143 157         xcons_opr
    002142  aa  156 163 137 157
    002143  aa  160 162 000 000
    002144  55   000324 000310 
    002145  0a   000211 400000 
    002146  55   000321 000003 
    002147  aa  011 156 143 157         ncons_opr
    002150  aa  156 163 137 157
    002151  aa  160 162 000 000
    002152  55   000332 000316 
    002153  0a   000204 400000 
    002154  55   000327 000003 
    002155  aa  010 143 157 156         cons_opr
    002156  aa  163 137 157 160
    002157  aa  162 000 000 000
    002160  55   000340 000324 
    002161  0a   000064 400000 
    002162  55   000335 000003 
    002163  aa  013 167 157 162         words_alloc
    002164  aa  144 163 137 141
    002165  aa  154 154 157 143
    002166  55   000345 000332 
    002167  2a   000016 400001 
    002170  55   000343 000003 
    002171  aa  007 143 165 162         cur_seg
    002172  aa  137 163 145 147
    002173  55   000352 000340 
    002174  2a   000014 400001 
    002175  55   000350 000003 
    002176  aa  007 143 157 156         consptr
    002177  aa  163 160 164 162
    002200  55   000361 000345 
    002201  2a   000012 400001 
    002202  55   000355 000003 
    002203  aa  014 163 145 147         seg_blk_cntr
    002204  aa  137 142 154 153
    002205  aa  137 143 156 164
    002206  aa  162 000 000 000
    002207  55   000367 000352 
    002210  2a   000011 400001 
    002211  55   000364 000003 
    002212  aa  013 147 143 137         gc_blk_cntr
    002213  aa  142 154 153 137
    002214  aa  143 156 164 162
    002215  55   000377 000361 
    002216  2a   000010 400001 
    002217  55   000372 000003 
    002220  aa  020 141 154 154         alloc_fault_word
    002221  aa  157 143 137 146
    002222  aa  141 165 154 164
    002223  aa  137 167 157 162
    002224  aa  144 000 000 000
    002225  55   000405 000367 
    002226  2a   000010 400001 
    002227  55   000402 000003 
    002230  aa  012 141 154 154         alloc_info
    002231  aa  157 143 137 151
    002232  aa  156 146 157 000
    002233  55   000002 000377 
    002234  6a   000000 400002 
    002235  55   000410 000003 
    002236  aa  014 163 171 155         symbol_table
    002237  aa  142 157 154 137
    002240  aa  164 141 142 154
    002241  aa  145 000 000 000

DEFINITIONS HASH TABLE

    002242  aa   000000 000131 
    002243  aa   000000 000000 
    002244  aa   000000 000000 
    002245  5a   000405 000000 
    002246  5a   000057 000000 
    002247  5a   000174 000000 
    002250  5a   000324 000000 
    002251  aa   000000 000000 
    002252  aa   000000 000000 
    002253  aa   000000 000000 
    002254  5a   000222 000000 
    002255  aa   000000 000000 
    002256  aa   000000 000000 
    002257  5a   000140 000000 
    002260  5a   000025 000000 
    002261  5a   000234 000000 
    002262  5a   000254 000000 
    002263  5a   000301 000000 
    002264  aa   000000 000000 
    002265  aa   000000 000000 
    002266  5a   000316 000000 
    002267  aa   000000 000000 
    002270  5a   000011 000000 
    002271  5a   000105 000000 
    002272  5a   000132 000000 
    002273  5a   000340 000000 
    002274  aa   000000 000000 
    002275  aa   000000 000000 
    002276  aa   000000 000000 
    002277  aa   000000 000000 
    002300  aa   000000 000000 
    002301  aa   000000 000000 
    002302  aa   000000 000000 
    002303  aa   000000 000000 
    002304  5a   000202 000000 
    002305  aa   000000 000000 
    002306  5a   000065 000000 
    002307  aa   000000 000000 
    002310  aa   000000 000000 
    002311  aa   000000 000000 
    002312  aa   000000 000000 
    002313  aa   000000 000000 
    002314  5a   000125 000000 
    002315  5a   000272 000000 
    002316  aa   000000 000000 
    002317  aa   000000 000000 
    002320  5a   000165 000000 
    002321  5a   000145 000000 
    002322  aa   000000 000000 
    002323  aa   000000 000000 
    002324  aa   000000 000000 
    002325  5a   000207 000000 
    002326  aa   000000 000000 
    002327  5a   000032 000000 
    002330  5a   000310 000000 
    002331  aa   000000 000000 
    002332  5a   000241 000000 
    002333  5a   000246 000000 
    002334  5a   000262 000000 
    002335  5a   000377 000000 
    002336  aa   000000 000000 
    002337  aa   000000 000000 
    002340  5a   000361 000000 
    002341  5a   000345 000000 
    002342  aa   000000 000000 
    002343  aa   000000 000000 
    002344  5a   000045 000000 
    002345  5a   000052 000000 
    002346  aa   000000 000000 
    002347  aa   000000 000000 
    002350  5a   000100 000000 
    002351  5a   000227 000000 
    002352  5a   000112 000000 
    002353  5a   000367 000000 
    002354  aa   000000 000000 
    002355  5a   000016 000000 
    002356  5a   000073 000000 
    002357  aa   000000 000000 
    002360  aa   000000 000000 
    002361  aa   000000 000000 
    002362  aa   000000 000000 
    002363  5a   000214 000000 
    002364  5a   000352 000000 
    002365  5a   000120 000000 
    002366  aa   000000 000000 
    002367  5a   000332 000000 
    002370  aa   000000 000000 
    002371  5a   000157 000000 
    002372  5a   000040 000000 
    002373  5a   000152 000000 

EXTERNAL NAMES

    002374  aa  013 155 141 153         maknum_next
    002375  aa  156 165 155 137
    002376  aa  156 145 170 164
    002377  aa  013 155 141 153         maknum_left
    002400  aa  156 165 155 137
    002401  aa  154 145 146 164
    002402  aa  020 155 141 153         maknum_table_ptr
    002403  aa  156 165 155 137
    002404  aa  164 141 142 154
    002405  aa  145 137 160 164
    002406  aa  162 000 000 000
    002407  aa  013 155 141 153         maknum_mask
    002410  aa  156 165 155 137
    002411  aa  155 141 163 153
    002412  aa  024 160 162 157         property_list_of_nil
    002413  aa  160 145 162 164
    002414  aa  171 137 154 151
    002415  aa  163 164 137 157
    002416  aa  146 137 156 151
    002417  aa  154 000 000 000
    002420  aa  013 154 151 163         lisp_error_
    002421  aa  160 137 145 162
    002422  aa  162 157 162 137
    002423  aa  027 154 151 163         lisp_garbage_collector_
    002424  aa  160 137 147 141
    002425  aa  162 142 141 147
    002426  aa  145 137 143 157
    002427  aa  154 154 145 143
    002430  aa  164 157 162 137
    002431  aa  027 147 141 162         garbage_collect_inhibit
    002432  aa  142 141 147 145
    002433  aa  137 143 157 154
    002434  aa  154 145 143 164
    002435  aa  137 151 156 150
    002436  aa  151 142 151 164
    002437  aa  013 141 154 154         alloc_fault
    002440  aa  157 143 137 146
    002441  aa  141 165 154 164
    002442  aa  025 154 151 163         lisp_default_handler_
    002443  aa  160 137 144 145
    002444  aa  146 141 165 154
    002445  aa  164 137 150 141
    002446  aa  156 144 154 145
    002447  aa  162 137 000 000
    002450  aa  011 165 156 155         unmkd_ptr
    002451  aa  153 144 137 160
    002452  aa  164 162 000 000
    002453  aa  011 163 164 141         stack_ptr
    002454  aa  143 153 137 160
    002455  aa  164 162 000 000
    002456  aa  021 154 151 163         lisp_static_vars_
    002457  aa  160 137 163 164
    002460  aa  141 164 151 143
    002461  aa  137 166 141 162
    002462  aa  163 137 000 000
    002463  aa  011 147 145 164         get_lists
    002464  aa  137 154 151 163
    002465  aa  164 163 000 000
    002466  aa  025 154 151 163         lisp_segment_manager_
    002467  aa  160 137 163 145
    002470  aa  147 155 145 156
    002471  aa  164 137 155 141
    002472  aa  156 141 147 145
    002473  aa  162 137 000 000

NO TRAP POINTER WORDS

TYPE PAIR BLOCKS

    002474  aa   000004 000000 
    002475  55   000630 000546 
    002476  aa   000004 000000 
    002477  55   000630 000551 
    002500  aa   000004 000000 
    002501  55   000630 000554 
    002502  aa   000004 000000 
    002503  55   000630 000561 
    002504  aa   000004 000000 
    002505  55   000630 000564 
    002506  aa   000004 000000 
    002507  55   000572 000572 
    002510  aa   000004 000000 
    002511  55   000575 000575 
    002512  aa   000004 000000 
    002513  55   000630 000603 
    002514  aa   000004 000000 
    002515  55   000614 000611 
    002516  aa   000004 000000 
    002517  55   000251 000251 
    002520  aa   000004 000000 
    002521  55   000630 000622 
    002522  aa   000004 000000 
    002523  55   000630 000625 
    002524  aa   000004 000000 
    002525  55   000640 000635 
    002526  aa   000001 000000 
    002527  aa   000000 000000 

INTERNAL EXPRESSION WORDS

    002530  5a   000646 000000 
    002531  5a   000650 000000 
    002532  5a   000652 000000 
    002533  5a   000654 000000 
    002534  5a   000656 000000 
    002535  5a   000660 000000 
    002536  5a   000662 000000 
    002537  5a   000664 000000 
    002540  5a   000666 000000 
    002541  5a   000672 000000 
    002542  5a   000670 000000 
    002543  5a   000672 000001 
    002544  5a   000674 000000 
    002545  5a   000676 000000 
LINKAGE INFORMATION
      
    000000  aa   000000 000000 
    000001  0a   001626 000000 
    000002  aa   000000 000000 
    000003  aa   000000 000000 
    000004  aa   000000 000000 
    000005  aa   000000 000000 
    000006  22   000020 000060 
    000007  a2   000000 000010 
    000020  9a   777760 0000 46         lisp_segment_manager_|get_lists
    000021  5a   000717 0000 00
    000022  9a   777756 0000 46         lisp_static_vars_|stack_ptr
    000023  5a   000716 0000 00
    000024  9a   777754 0000 46         lisp_static_vars_|unmkd_ptr
    000025  5a   000715 0000 00
    000026  9a   777752 0000 46         lisp_alloc_|lisp_alloc_
    000027  5a   000714 0000 00
    000030  9a   777750 0000 46         lisp_static_vars_|unmkd_ptr
    000031  5a   000713 0000 20
    000032  9a   777746 0000 46         lisp_static_vars_|stack_ptr
    000033  5a   000716 0000 20
    000034  9a   777744 0000 46         lisp_default_handler_|alloc_fault
    000035  5a   000712 0000 00
    000036  9a   777742 0000 46         lisp_static_vars_|garbage_collect_inhibit
    000037  5a   000711 0000 00
    000040  9a   777740 0000 46         lisp_garbage_collector_|lisp_garbage_collector_
    000041  5a   000710 0000 00
    000042  9a   777736 0000 46         lisp_error_|lisp_error_
    000043  5a   000707 0000 00
    000044  9a   777734 0000 46         lisp_static_vars_|property_list_of_nil
    000045  5a   000706 0000 00
    000046  9a   777732 0000 46         lisp_static_vars_|maknum_mask
    000047  5a   000705 0000 00
    000050  9a   777730 0000 46         lisp_static_vars_|maknum_table_ptr
    000051  5a   000704 0000 00
    000052  9a   777726 0000 46         lisp_static_vars_|maknum_left
    000053  5a   000703 0000 00
    000054  9a   777724 0000 46         lisp_static_vars_|maknum_next
    000055  5a   000702 0000 00
    000056  9a   777722 0000 46         lisp_static_vars_|maknum_table_ptr
    000057  5a   000704 0000 20
SYMBOL INFORMATION
     
SYMBOL TABLE HEADER
     
    000000  aa   000000 000001 
    000001  aa   163171 155142 
    000002  aa   164162 145145 
    000003  aa   000000 000004 
    000004  aa   000000 114732 
    000005  aa   732732 062314 
    000006  aa   000000 114775 
    000007  aa   676740 576270 
    000010  aa   141154 155040 
    000011  aa   040040 040040 
    000012  aa   000024 000040 
    000013  aa   000034 000040 
    000014  aa   000044 000100 
    000015  aa   000002 000002 
    000016  aa   000064 000000 
    000017  aa   000000 000376 
    000020  aa   000000 000234 
    000021  aa   000000 000352 
    000022  aa   000363 000234 
    000023  aa   000064 000000 
    000024  aa   101114 115040 
    000025  aa   126145 162163 
    000026  aa   151157 156040 
    000027  aa   040066 056067 
    000030  aa   040040 117143 
    000031  aa   164157 142145 
    000032  aa   162040 061071 
    000033  aa   070066 040040 
    000034  aa   107112 157150 
    000035  aa   156163 157156 
    000036  aa   056123 171163 
    000037  aa   115141 151156 
    000040  aa   164056 141040 
    000041  aa   040040 040040 
    000042  aa   040040 040040 
    000043  aa   040040 040040 
    000044  aa   154151 163164 
    000045  aa   040040 040040 
    000046  aa   040040 040040 
    000047  aa   040040 040040 
    000050  aa   040040 040040 
    000051  aa   040040 040040 
    000052  aa   040040 040040 
    000053  aa   040040 040040 
    000054  aa   040040 040040 
    000055  aa   040040 040040 
    000056  aa   040040 040040 
    000057  aa   040040 040040 
    000060  aa   040040 040040 
    000061  aa   040040 040040 
    000062  aa   040040 040040 
    000063  aa   040040 040040 
    000064  aa   000000 000001 
    000065  aa   000000 000007 
    000066  aa   000122 000060 
    000067  aa   147740 446304 
    000070  aa   000000 114774 
    000071  aa   461221 000000 
    000072  aa   000136 000047 
    000073  aa   106701 741731 
    000074  aa   000000 110670 
    000075  aa   211444 000000 
    000076  aa   000150 000044 
    000077  aa   120017 346605 
    000100  aa   000000 112002 
    000101  aa   404115 200000 
    000102  aa   000161 000046 
    000103  aa   106701 741746 
    000104  aa   000000 110670 
    000105  aa   211450 600000 
    000106  aa   000173 000045 
    000107  aa   120017 346602 
    000110  aa   000000 112002 
    000111  aa   404115 000000 
    000112  aa   000205 000066 
    000113  aa   147714 750316 
    000114  aa   000000 114774 
    000115  aa   453561 000000 
    000116  aa   000223 000041 
    000117  aa   052721 247134 
    000120  aa   000000 105272 
    000121  aa   317215 400000 
    000122  aa   076163 160145          >special_ldd>install>MR12.0-1206>lisp_alloc_.alm
    000123  aa   143151 141154 
    000124  aa   137154 144144 
    000125  aa   076151 156163 
    000126  aa   164141 154154 
    000127  aa   076115 122061 
    000130  aa   062056 060055 
    000131  aa   061062 060066 
    000132  aa   076154 151163 
    000133  aa   160137 141154 
    000134  aa   154157 143137 
    000135  aa   056141 154155 
    000136  aa   076154 144144          >ldd>include>lisp_object_types.incl.alm
    000137  aa   076151 156143 
    000140  aa   154165 144145 
    000141  aa   076154 151163 
    000142  aa   160137 157142 
    000143  aa   152145 143164 
    000144  aa   137164 171160 
    000145  aa   145163 056151 
    000146  aa   156143 154056 
    000147  aa   141154 155040 
    000150  aa   076154 144144          >ldd>include>lisp_stack_seg.incl.alm
    000151  aa   076151 156143 
    000152  aa   154165 144145 
    000153  aa   076154 151163 
    000154  aa   160137 163164 
    000155  aa   141143 153137 
    000156  aa   163145 147056 
    000157  aa   151156 143154 
    000160  aa   056141 154155 
    000161  aa   076154 144144          >ldd>include>lisp_error_codes.incl.alm
    000162  aa   076151 156143 
    000163  aa   154165 144145 
    000164  aa   076154 151163 
    000165  aa   160137 145162 
    000166  aa   162157 162137 
    000167  aa   143157 144145 
    000170  aa   163056 151156 
    000171  aa   143154 056141 
    000172  aa   154155 040040 
    000173  aa   076154 144144          >ldd>include>lisp_name_codes.incl.alm
    000174  aa   076151 156143 
    000175  aa   154165 144145 
    000176  aa   076154 151163 
    000177  aa   160137 156141 
    000200  aa   155145 137143 
    000201  aa   157144 145163 
    000202  aa   056151 156143 
    000203  aa   154056 141154 
    000204  aa   155040 040040 
    000205  aa   076163 160145          >special_ldd>install>MR12.0-1206>stack_header.incl.alm
    000206  aa   143151 141154 
    000207  aa   137154 144144 
    000210  aa   076151 156163 
    000211  aa   164141 154154 
    000212  aa   076115 122061 
    000213  aa   062056 060055 
    000214  aa   061062 060066 
    000215  aa   076163 164141 
    000216  aa   143153 137150 
    000217  aa   145141 144145 
    000220  aa   162056 151156 
    000221  aa   143154 056141 
    000222  aa   154155 040040 
    000223  aa   076154 144144          >ldd>include>stack_frame.incl.alm
    000224  aa   076151 156143 
    000225  aa   154165 144145 
    000226  aa   076163 164141 
    000227  aa   143153 137146 
    000230  aa   162141 155145 
    000231  aa   056151 156143 
    000232  aa   154056 141154 
    000233  aa   155040 040040 
               MULTICS ASSEMBLY CROSS REFERENCE LISTING

   Value        Symbol                   Source file   Line number

                alloc_fault              lisp_alloc_:  104.
          10    alloc_fault_word         lisp_alloc_:   13,   14,   79,   84,  130,  152,  200,  225,  314,  336,  338,  349,
                                                       360,  477,  479,  486, 1063, 1105, 1149.
          31    alloc_got_fault          lisp_alloc_:   91,  369, 1108.
          10    alloc_info               lisp_alloc_:   11,   12.
          70    alloc_loop               lisp_alloc_:  136,  140,  147.
         723    aplp                     lisp_alloc_:  698,  709.
         705    append                   lisp_alloc_:  663,  679,  681.
         102    append_list_op           lisp_stack_seg:      43.
         227    append_list_opr          lisp_alloc_:  263,  264.
          50    arglist                  lisp_alloc_:   42,  100,  102,  103,  178,  180,  181.
         250    argument_must_be_array   lisp_error_codes:    72.
         200    Array                    lisp_object_types:   25.
         166    array_bound_error        lisp_error_codes:    26.
         122    array_info_for_store     lisp_stack_seg:      51.
         126    array_link_snap_opr      lisp_stack_seg:      53.
         124    array_offset_for_store   lisp_stack_seg:      52.
         112    array_operator           lisp_stack_seg:      47.
          10    array_pointer            lisp_stack_seg:      10.
         247    array_too_big            lisp_error_codes:    71.
         216    atan_0_0_err             lisp_error_codes:    46.
       77700    Atomic                   lisp_alloc_:  691,  702,  732,  756,  773,  785,  794,  803,  820,
                                         lisp_object_types:   19.
       10000    Atsym                    lisp_alloc_:  576,  586,  619,  632, 1019, 1033,
                                         lisp_object_types:   18.
         163    badmacro                 lisp_error_codes:    23.
         215    badobarray               lisp_error_codes:    45.
         165    badreadlist              lisp_error_codes:    25.
         214    badreadtable             lisp_error_codes:    44.
         151    bad_argument             lisp_error_codes:    13.
         170    bad_arg_correctable      lisp_alloc_:  600, 1040,
                                         lisp_error_codes:    28.
         241    bad_array_subscript      lisp_error_codes:    65.
         175    bad_base                 lisp_error_codes:    33.
         154    bad_bv                   lisp_error_codes:    16.
         232    bad_do_format            lisp_error_codes:    58.
         231    bad_entry_name           lisp_error_codes:    57.
         153    bad_function             lisp_error_codes:    15.
         206    bad_f_fcn                lisp_error_codes:    38.
         174    bad_ibase                lisp_error_codes:    32.
         176    bad_input_source         lisp_error_codes:    34.
         177    bad_output_dest          lisp_error_codes:    35.
         171    bad_prog_op              lisp_error_codes:    29.
         100    begin_list_op            lisp_stack_seg:      42.
         223    begin_list_opr           lisp_alloc_:  256,  257.
         174    begin_unmkd_stack        lisp_stack_seg:      66.
        1000    Bignum                   lisp_object_types:   20.
        1000    Big_fixed                lisp_object_types:   29.
          20    bind_op                  lisp_stack_seg:      17.
        1253    boundp                   lisp_alloc_: 1016, 1017, 1041.
        1170    call_offset              stack_header:        80.
          32    call_op                  lisp_stack_seg:      22.
         222    cant_filepos             lisp_error_codes:    50.
         244    cant_subscript_readtable       lisp_error_codes:    68.
         167    car_cdr_error            lisp_error_codes:    27.
          34    catch1_op                lisp_stack_seg:      23.
          36    catch2_op                lisp_stack_seg:      24.
         727    chk_list                 lisp_alloc_:  702,  713.
         576    chk_prefix               lisp_alloc_:  582,  585.
         106    compare_op               lisp_stack_seg:      45.
         363    cons                     lisp_alloc_:  398,  399.
          14    consptr                  lisp_alloc_:   29,   30,   80,  132,  139,  154,  159,  187,  189,  315.
         464    cons_                    lisp_alloc_:  403,  489,  490.
          23    cons_alloc               lisp_alloc_:   78,  490,  504,  511,  535,  694,  704,  764,  836, 1002.
          72    cons_op                  lisp_stack_seg:      39.
         204    cons_opr                 lisp_alloc_:  232,  233.
         205    cons_opr_com0            lisp_alloc_:  234,  261,  269.
         206    cons_opr_com1            lisp_alloc_:  236,  247.
         241    cons_string              lisp_alloc_:  284,  286.
         136    cons_string_op           lisp_stack_seg:      57.
         657    copypropl                lisp_alloc_:  643,  647.
         666    copypropl_0              lisp_alloc_:  655,  674.
         703    copypropl_nil            lisp_alloc_:  653,  672.
         632    copysym                  lisp_alloc_:  620,  624.
         625    copysymbol               lisp_alloc_:  616,  617.
         132    create_array_desc_op     lisp_stack_seg:      55.
         130    create_string_desc_op    lisp_stack_seg:      54.
         140    create_varying_string_op       lisp_stack_seg:      58.
          16    cur_seg                  lisp_alloc_:   32,   33,  182,  185.
         114    dead_array_operator      lisp_stack_seg:      48.
         243    dead_array_reference     lisp_error_codes:    67.
         220    division_by_zero         lisp_error_codes:    48.
        1465    done_rhsh                lisp_alloc_: 1168, 1189.
         161    doterror                 lisp_error_codes:    21.
         737    end_list                 lisp_alloc_:  703,  711.
        1174    entry_offset             stack_header:        84.
         221    eof_in_object            lisp_error_codes:    49.
          24    errset1_op               lisp_stack_seg:      19.
          26    errset2_op               lisp_stack_seg:      20.
          64    err_op                   lisp_stack_seg:      36.
         100    File                     lisp_object_types:   30.
         223    filepos_oob              lisp_error_codes:    51.
         227    file_is_closed           lisp_error_codes:    55.
         150    file_system_error        lisp_error_codes:    12.
         224    file_sys_fun_err         lisp_error_codes:    52.
       40000    Fixed                    lisp_alloc_: 1075, 1253,
                                         lisp_object_types:   15.
       40047    fixnum_type              lisp_alloc_:  581, 1103, 1234,
                                         lisp_object_types:   34.
       20000    Float                    lisp_alloc_: 1075, 1253,
                                         lisp_object_types:   16.
         120    floating_store_operator  lisp_stack_seg:      50.
         212    flonum_too_big           lisp_error_codes:    42.
       20047    flonum_type              lisp_object_types:   35.
      777707    fn_abs                   lisp_name_codes:     53.
      777720    fn_add1                  lisp_name_codes:     44.
      777674    fn_add1_fix              lisp_name_codes:     64.
      777673    fn_add1_flo              lisp_name_codes:     65.
      777625    fn_alarmclock            lisp_name_codes:    103.
      777611    fn_allfiles              lisp_name_codes:    115.
      777617    fn_alphalessp            lisp_name_codes:    109.
      777657    fn_apply                 lisp_name_codes:     77.
      777765    fn_arg                   lisp_name_codes:     10.
      777727    fn_args                  lisp_name_codes:     37.
      777740    fn_array                 lisp_name_codes:     28.
      777537    fn_arraydims             lisp_name_codes:    157.
      777751    fn_ascii                 lisp_name_codes:     19.
      777631    fn_atan                  lisp_name_codes:     99.
      777650    fn_baktrace              lisp_name_codes:     84.
      777647    fn_bltarray              lisp_name_codes:     85.
      777705    fn_boole                 lisp_name_codes:     55.
      777643    fn_boundp                lisp_alloc_: 1045,
                                         lisp_name_codes:     89.
      777654    fn_catch                 lisp_name_codes:     80.
      777741    fn_catenate              lisp_name_codes:     27.
      777544    fn_charpos               lisp_name_codes:    152.
      777610    fn_chrct                 lisp_name_codes:    116.
      777557    fn_clear_input           lisp_name_codes:    141.
      777553    fn_cline                 lisp_name_codes:    145.
      777607    fn_close                 lisp_name_codes:    117.
      777637    fn_cos                   lisp_name_codes:     93.
      777732    fn_CtoI                  lisp_name_codes:     34.
      777561    fn_cursorpos             lisp_name_codes:    139.
      777756    fn_defaultf              lisp_name_codes:     17.
      777747    fn_definedp              lisp_name_codes:     21.
      777731    fn_defsubr               lisp_name_codes:     35.
      777651    fn_defun                 lisp_name_codes:     83.
      777744    fn_delete                lisp_name_codes:     24.
      777606    fn_deletef               lisp_name_codes:    118.
      777743    fn_delq                  lisp_name_codes:     25.
      777711    fn_difference            lisp_name_codes:     51.
      777664    fn_diff_fix              lisp_name_codes:     72.
      777663    fn_diff_flo              lisp_name_codes:     73.
      777516    fn_displace              lisp_name_codes:    174.
      777766    fn_do                    lisp_name_codes:      9.
      777535    fn_dumparrays            lisp_name_codes:    159.
      777540    fn_endpagefn             lisp_name_codes:    156.
      777605    fn_eoffn                 lisp_name_codes:    119.
      777621    fn_eql                   lisp_name_codes:    107.
      777760    fn_errframe              lisp_name_codes:     15.
      777761    fn_errprint              lisp_name_codes:     14.
      777655    fn_errset                lisp_name_codes:     79.
      777660    fn_eval                  lisp_name_codes:     76.
      777757    fn_evalframe             lisp_name_codes:     16.
      777520    fn_eval_when             lisp_name_codes:    172.
      777635    fn_exp                   lisp_name_codes:     95.
      777706    fn_expt                  lisp_name_codes:     54.
      777534    fn_expt_fix              lisp_name_codes:    160.
      777533    fn_expt_flo              lisp_name_codes:    161.
      777604    fn_filepos               lisp_name_codes:    120.
      777552    fn_fillarray             lisp_name_codes:    146.
      777701    fn_fix                   lisp_name_codes:     59.
      777700    fn_float                 lisp_name_codes:     60.
      777560    fn_force_output          lisp_name_codes:    140.
      777640    fn_freturn               lisp_name_codes:     92.
      777524    fn_fsc                   lisp_name_codes:    168.
      777612    fn_gcd                   lisp_name_codes:    114.
      777645    fn_gensym                lisp_alloc_:  601,
                                         lisp_name_codes:     87.
      777725    fn_get                   lisp_name_codes:     39.
      777615    fn_getchar               lisp_name_codes:    111.
      777724    fn_getl                  lisp_name_codes:     40.
      777735    fn_get_pname             lisp_name_codes:     31.
      777716    fn_greaterp              lisp_name_codes:     46.
      777620    fn_gt                    lisp_name_codes:    108.
      777554    fn_haipart               lisp_name_codes:    144.
      777555    fn_haulong               lisp_name_codes:    143.
      777525    fn_ifix                  lisp_name_codes:    167.
      777530    fn_in                    lisp_name_codes:    164.
      777513    fn_includef              lisp_name_codes:    177.
      777736    fn_index                 lisp_name_codes:     30.
      777603    fn_inpush                lisp_name_codes:    121.
      777632    fn_isqrt                 lisp_name_codes:     98.
      777733    fn_ItoC                  lisp_name_codes:     33.
      777715    fn_lessp                 lisp_name_codes:     47.
      777602    fn_linel                 lisp_name_codes:    122.
      777542    fn_linenum               lisp_name_codes:    154.
      777551    fn_listarray             lisp_name_codes:    147.
      777545    fn_listify               lisp_name_codes:    151.
      777536    fn_loadarrays            lisp_name_codes:    158.
      777634    fn_log                   lisp_name_codes:     96.
      777622    fn_ls                    lisp_name_codes:    106.
      777703    fn_lsh                   lisp_name_codes:     57.
      777734    fn_make_atom             lisp_name_codes:     32.
      777644    fn_makunbound            lisp_alloc_: 1043,
                                         lisp_name_codes:     88.
      777522    fn_mapatoms              lisp_name_codes:    170.
      777676    fn_max                   lisp_name_codes:     62.
      777601    fn_mergef                lisp_name_codes:    123.
      777675    fn_min                   lisp_name_codes:     63.
      777714    fn_minus                 lisp_name_codes:     48.
      777623    fn_minusp                lisp_name_codes:    105.
      777600    fn_namelist              lisp_name_codes:    124.
      777577    fn_names                 lisp_name_codes:    125.
      777576    fn_namestring            lisp_name_codes:    126.
      777532    fn_nointerrupt           lisp_name_codes:    162.
      777515    fn_nth                   lisp_name_codes:    175.
      777514    fn_nthcdr                lisp_name_codes:    176.
      777627    fn_oddp                  lisp_name_codes:    101.
      777531    fn_open                  lisp_name_codes:    163.
      777614    fn_opena                 lisp_name_codes:    112.
      777575    fn_openi                 lisp_name_codes:    127.
      777574    fn_openo                 lisp_name_codes:    128.
      777527    fn_out                   lisp_name_codes:    165.
      777543    fn_pagel                 lisp_name_codes:    153.
      777541    fn_pagenum               lisp_name_codes:    155.
      777713    fn_plus                  lisp_name_codes:     49.
      777624    fn_plusp                 lisp_name_codes:    104.
      777670    fn_plus_fix              lisp_name_codes:     68.
      777667    fn_plus_flo              lisp_name_codes:     69.
      777573    fn_prin1                 lisp_name_codes:    129.
      777572    fn_princ                 lisp_name_codes:    130.
      777571    fn_print                 lisp_name_codes:    131.
      777656    fn_prog                  lisp_name_codes:     78.
      777523    fn_progv                 lisp_name_codes:    169.
      777723    fn_putprop               lisp_name_codes:     41.
      777710    fn_quotient              lisp_name_codes:     52.
      777662    fn_quot_fix              lisp_name_codes:     74.
      777661    fn_quot_flo              lisp_name_codes:     75.
      777556    fn_random                lisp_name_codes:    142.
      777570    fn_read                  lisp_name_codes:    132.
      777567    fn_readch                lisp_name_codes:    133.
      777566    fn_readstring            lisp_name_codes:    134.
      777517    fn_read_from_string      lisp_name_codes:    173.
      777677    fn_remainder             lisp_name_codes:     61.
      777722    fn_remprop               lisp_name_codes:     42.
      777565    fn_rename                lisp_name_codes:    135.
      777704    fn_rot                   lisp_name_codes:     56.
      777750    fn_rplaca                lisp_name_codes:     20.
      777616    fn_samepnamep            lisp_name_codes:    110.
      777721    fn_save                  lisp_name_codes:     43.
      777745    fn_set                   lisp_name_codes:     23.
      777764    fn_setarg                lisp_name_codes:     11.
      777746    fn_setq                  lisp_name_codes:     22.
      777562    fn_setsyntax             lisp_name_codes:    138.
      777564    fn_shortnamestring       lisp_name_codes:    136.
      777702    fn_signp                 lisp_name_codes:     58.
      777636    fn_sin                   lisp_name_codes:     94.
      777630    fn_sleep                 lisp_name_codes:    100.
      777550    fn_sort                  lisp_name_codes:    148.
      777547    fn_sortcar               lisp_name_codes:    149.
      777633    fn_sqrt                  lisp_name_codes:     97.
      777762    fn_sstatus               lisp_name_codes:     13.
      777730    fn_star_array            lisp_name_codes:     36.
      777646    fn_star_rearray          lisp_name_codes:     86.
      777641    fn_star_sstatus          lisp_name_codes:     91.
      777642    fn_star_status           lisp_name_codes:     90.
      777763    fn_status                lisp_name_codes:     12.
      777652    fn_store                 lisp_name_codes:     82.
      777742    fn_stringlength          lisp_name_codes:     26.
      777717    fn_sub1                  lisp_name_codes:     45.
      777672    fn_sub1_fix              lisp_name_codes:     66.
      777671    fn_sub1_flo              lisp_name_codes:     67.
      777737    fn_substr                lisp_name_codes:     29.
      777613    fn_sxhash                lisp_name_codes:    113.
      777726    fn_sysp                  lisp_name_codes:     38.
      777653    fn_throw                 lisp_name_codes:     81.
      777712    fn_times                 lisp_name_codes:     50.
      777666    fn_times_fix             lisp_name_codes:     70.
      777665    fn_times_flo             lisp_name_codes:     71.
      777526    fn_truename              lisp_name_codes:    166.
      777563    fn_tyi                   lisp_name_codes:    137.
      777626    fn_tyipeek               lisp_name_codes:    102.
      777752    fn_tyo                   lisp_name_codes:     18.
      777521    fn_unwind_protect        lisp_name_codes:    171.
      777546    fn_zerop                 lisp_name_codes:    150.
        1364    found_maknum             lisp_alloc_: 1091, 1100, 1128.
                garbage_collect_inhibit  lisp_alloc_:  210.
          11    gc_blk_cntr              lisp_alloc_:   20,   21,  117,  143,  163,  318, 1143.
         427    gensym                   lisp_alloc_:  445,  446.
         542    gensym_                  lisp_alloc_:  452,  551,  552.
         544    gensym_begin             lisp_alloc_:  555,  595.
          42    gensym_data              lisp_alloc_:  563,  564,  567,  569,  572,  583,  590,
                                         lisp_stack_seg:      26.
         607    gensym_err               lisp_alloc_:  587,  598.
         453    get_fault_word           lisp_alloc_:  472,  473.
                get_lists                lisp_alloc_:  181.
         117    get_new_seg              lisp_alloc_:  121,  148,  166,  171,  326.
         454    gfw_lp                   lisp_alloc_:  477,  480.
        1135    got_sublis_table         lisp_alloc_:  890,  902.
           2    header_for_1_arg         lisp_alloc_:   48,  101,  179.
         162    illobj                   lisp_error_codes:    22.
         235    include_file_error       lisp_error_codes:    61.
        1456    insrt                    lisp_alloc_: 1179, 1182.
          16    in_pl1_code              lisp_alloc_:   57,   71,  392,
                                         lisp_stack_seg:      13.
          46    iogbind_op               lisp_stack_seg:      29.
         226    io_wrong_direction       lisp_error_codes:    54.
         150    irest_return_op          lisp_stack_seg:      62.
         110    link_opr                 lisp_stack_seg:      46.
         344    lisp_alloc_              lisp_alloc_:   59,  376,  377.
                lisp_default_handler_    lisp_alloc_:  104.
                lisp_error_              lisp_alloc_:  606, 1051.
                lisp_garbage_collector_  lisp_alloc_:  219.
       77700    lisp_ptr.type            lisp_alloc_:  889,  930, 1252,
                                         lisp_object_types:   13.
                lisp_segment_manager_    lisp_alloc_:  181.
                lisp_static_vars_        lisp_alloc_:   55,   56,   68,   69,   70,   98,  210,  390,  391,  673, 1064, 1068,
                                                      1070, 1071, 1073, 1085, 1087, 1118, 1120, 1133, 1136, 1162, 1163, 1175,
                                                      1190, 1196, 1210, 1214, 1223, 1237, 1240.
         407    list                     lisp_alloc_:  424,  425.
         521    list_                    lisp_alloc_:  431,  529,  530.
         526    list_lp                  lisp_alloc_:  526,  535,  543.
         417    list_star                lisp_alloc_:  434,  435.
         516    list_star_               lisp_alloc_:  442,  521,  522.
         102    locked_alloc             lisp_alloc_:  150, 1067, 1141.
         107    lock_alloc_loop          lisp_alloc_:  156,  160,  165.
         113    lock_tally_done          lisp_alloc_:  155,  162.
        1351    loopmake                 lisp_alloc_: 1087, 1098.
        1400    maknewnum                lisp_alloc_: 1096, 1117.
        1321    maknum                   lisp_alloc_: 1058, 1062.
        1335    maknum1                  lisp_alloc_: 1065, 1074, 1144, 1148, 1151.
        1342    maknumber                lisp_alloc_: 1076, 1079.
          40    maknum_initial           lisp_alloc_: 1061, 1066, 1069, 1072.
                maknum_left              lisp_alloc_: 1070, 1118, 1196, 1214.
                maknum_mask              lisp_alloc_: 1064, 1073, 1087, 1133, 1136, 1175, 1190, 1210, 1223, 1237.
                maknum_next              lisp_alloc_: 1071, 1120.
        1433    maknum_rehash            lisp_alloc_: 1142, 1161, 1227.
                maknum_table_ptr         lisp_alloc_: 1068, 1085, 1162, 1163, 1240.
        1266    makunbound               lisp_alloc_: 1030, 1031.
           0    marked_stack_bottom      lisp_stack_seg:       6.
        1541    mfound                   lisp_alloc_: 1242, 1251.
         210    mismatch_super_parens    lisp_error_codes:    40.
        1533    mnkamlp                  lisp_alloc_: 1241, 1244.
        1537    munfound                 lisp_alloc_: 1235, 1238, 1245.
        1523    munkam                   lisp_alloc_: 1231, 1232.
        1554    munnum                   lisp_alloc_: 1254, 1262.
         162    must_gc                  lisp_alloc_:  119,  145,  209,  321, 1150.
         756    nclp                     lisp_alloc_:  731,  736,  741.
         751    nconc                    lisp_alloc_:  722,  724.
         401    ncons                    lisp_alloc_:  416,  417.
         505    ncons_                   lisp_alloc_:  421,  510,  511.
          74    ncons_op                 lisp_stack_seg:      40.
         211    ncons_opr                lisp_alloc_:  241,  242.
         212    ncons_opr_com            lisp_alloc_:  243,  277.
          60    new_seg_ptr              lisp_alloc_:   42,  177,  183.
         200    nihil_ex_nihile          lisp_error_codes:    36.
          12    nil                      lisp_alloc_:  245,  512,  531,  560,  642,  652,  657,  746,  762,  782, 1246,
                                         lisp_stack_seg:      11.
        1506    nlgp2                    lisp_alloc_: 1217, 1219.
           0    noargs                   lisp_alloc_:   45,  218,  605, 1050.
        1374    nomakfault               lisp_alloc_: 1107, 1110.
         157    nonfixedarg              lisp_error_codes:    19.
         234    not_alpha_array          lisp_error_codes:    60.
         233    not_an_array             lisp_error_codes:    59.
        1001    not_atom_reverse         lisp_alloc_:  757,  760.
        1277    not_atsym                lisp_alloc_: 1020, 1034, 1040.
        1264    not_bound                lisp_alloc_: 1022, 1027.
         203    not_pdl_ptr              lisp_error_codes:    37.
         245    not_same_type            lisp_error_codes:    69.
         211    no_left_super_paren      lisp_error_codes:    41.
         172    no_lexpr                 lisp_error_codes:    30.
         275    no_opr_gc                lisp_alloc_:  319,  323.
        1153    no_sublis                lisp_alloc_:  911,  923.
        1044    nreconc_                 lisp_alloc_:  800,  801.
         445    nreverse                 lisp_alloc_:  463,  464.
        1022    nreverse_                lisp_alloc_:  468,  780,  781.
        1030    nrev_loop                lisp_alloc_:  787,  795,  804.
        1042    nrev_ret                 lisp_alloc_:  786,  797,  806.
       61400    Numeric                  lisp_object_types:   17.
         326    opr_ck_fault             lisp_alloc_:  237,  252,  359.
         264    opr_cons                 lisp_alloc_:  233,  242,  250,  258,  265,  273,  313.
         207    overflow_err             lisp_error_codes:    39.
         160    parenmissing             lisp_error_codes:    20.
         152    pl1_call_nopop_op        lisp_stack_seg:      63.
         134    pl1_call_op              lisp_stack_seg:      56.
          66    pl1_interface            lisp_stack_seg:      37.
          70    pl1_lsubr_interface      lisp_stack_seg:      38.
         370    pl1_ret                  lisp_alloc_:  404,  414,  422,  432,  443,  453,  461,  469.
          14    pop_back_to_lisp         lisp_alloc_:   63,  105,  195,  220,  607, 1052.
      753773    prime                    lisp_alloc_: 1060, 1082, 1172.
           0    program                  lisp_alloc_:   36,   37.
                property_list_of_nil     lisp_alloc_:  673.
        1171    push_offset              stack_header:        81.
         213    quoterror                lisp_error_codes:    43.
         154    rcv_char_star_op         lisp_stack_seg:      64.
        1413    rehash                   lisp_alloc_: 1119, 1132.
        1475    rehash_maknum            lisp_alloc_: 1206, 1207.
         230    reopen_inconsistent      lisp_error_codes:    56.
         767    retn                     lisp_alloc_:  727,  742.
         474    retrn                    lisp_alloc_:  498,  519,  546,  577,  622,  670,  720,  744,  747,  759,  777,  798,
                                                       815,  920,  926, 1025, 1039, 1114, 1266.
        1556    retrnmun                 lisp_alloc_: 1247, 1261, 1264.
         700    return_copy              lisp_alloc_:  645,  667.
        1173    return_no_pop_offset     stack_header:        83.
        1172    return_offset            stack_header:        82.
          62    return_op                lisp_stack_seg:      35.
        1113    ret_1st_arg              lisp_alloc_:  819,  849.
          26    ret_alloc                lisp_alloc_:   83,  124,  138.
         745    ret_arg                  lisp_alloc_:  690,  717.
         537    ret_list                 lisp_alloc_:  527,  534,  544.
         772    ret_nil                  lisp_alloc_:  682,  725,  746, 1028.
         357    ret_to_pl1               lisp_alloc_:  389,  406, 1229.
         774    reverse                  lisp_alloc_:  754,  755.
        1004    rev_loop                 lisp_alloc_:  764,  774.
        1447    rhshlp1                  lisp_alloc_: 1175, 1181.
        1437    rhsh_loop                lisp_alloc_: 1167, 1188.
         100    rpt_tze                  lisp_alloc_:  881,  909,  942.
           4    save_for_pl1_call        lisp_alloc_:   52,   97,  176,  217,  604, 1049.
         302    save_regs_call           lisp_alloc_:  320,  325,  329.
          12    seg_blk_cntr             lisp_alloc_:   24,   25,  120,  146,  164,  194,  323.
         461    set_fault                lisp_alloc_:  483,  484.
         571    set_gensym_data          lisp_alloc_:  553,  579,  596,  610.
         603    set_gensym_loop          lisp_alloc_:  584,  592.
         164    shortreadlist            lisp_error_codes:    24.
          56    signp_op                 lisp_stack_seg:      33.
         712    skip_atoms               lisp_alloc_:  687,  692.
        1463    skip_rhsh                lisp_alloc_: 1170, 1187.
         246    special_array_type       lisp_error_codes:    70.
          73    stach_header.trace_top_ptr     stack_header:        62.
          32    stack_frame.arg_ptr      stack_frame:   16.
         100    stack_frame.condition_bit      stack_frame:   32.
          20    stack_frame.condition_word     stack_frame:    9.
        2000    stack_frame.crawl_out_bit      stack_frame:   28.
          26    stack_frame.entry_ptr    lisp_alloc_:   60,
                                         stack_frame:   13.
          20    stack_frame.flag_word    stack_frame:   24.
         400    stack_frame.link_trap_bit      stack_frame:   30.
          30    stack_frame.lp_ptr       stack_frame:   15.
       20000    stack_frame.main_proc_bit      stack_frame:   25.
          60    stack_frame.min_length   stack_frame:   23.
          22    stack_frame.next_sp      stack_frame:   10.
          36    stack_frame.on_unit_rel_ptrs   stack_frame:   19.
          30    stack_frame.operator_ptr       stack_frame:   14.
          37    stack_frame.operator_ret_ptr   stack_frame:   20.
          20    stack_frame.prev_sp      stack_frame:    8.
          40    stack_frame.regs         stack_frame:   22.
          24    stack_frame.return_ptr   stack_frame:   12.
       10000    stack_frame.run_unit_manager   stack_frame:   26.
        1000    stack_frame.signaller_bit      stack_frame:   29.
          22    stack_frame.signaller_word     stack_frame:   11.
        4000    stack_frame.signal_bit   stack_frame:   27.
          34    stack_frame.static_ptr   stack_frame:   17.
         200    stack_frame.support_bit  stack_frame:   31.
          35    stack_frame.support_ptr  stack_frame:   18.
          37    stack_frame.translator_id      stack_frame:   21.
          66    stack_header.assign_linkage_ptr      stack_header:        59.
          32    stack_header.bar_mode_sp       stack_header:        42.
          36    stack_header.call_op_ptr       stack_header:        44.
          10    stack_header.clr_ptr     stack_header:        27.
           6    stack_header.combined_stat_ptr       stack_header:        25.
           4    stack_header.cpm_data_ptr      stack_header:        24.
          13    stack_header.cpm_enabled       stack_header:        32.
          13    stack_header.cur_lot_size      stack_header:        31.
          64    stack_header.ect_ptr     stack_header:        58.
          46    stack_header.entry_op_ptr      stack_header:        49.
          70    stack_header.heap_header_ptr   stack_header:        60.
          74    stack_header.in_trace    stack_header:        63.
          52    stack_header.isot_ptr    stack_header:        52.
          26    stack_header.lot_ptr     stack_header:        39.
          12    stack_header.main_proc_invoked       stack_header:        29.
          12    stack_header.max_lot_size      stack_header:        28.
          20    stack_header.parent_ptr  stack_header:        36.
          34    stack_header.pl1_operators_ptr       stack_header:        43.
          40    stack_header.push_op_ptr       stack_header:        46.
          42    stack_header.return_op_ptr     stack_header:        47.
          44    stack_header.ret_no_pop_op_ptr       stack_header:        48.
          62    stack_header.rnt_ptr     stack_header:        57.
          12    stack_header.run_unit_depth    stack_header:        30.
          54    stack_header.sct_ptr     stack_header:        53.
          30    stack_header.signal_ptr  stack_header:        41.
          22    stack_header.stack_begin_ptr   stack_header:        37.
          24    stack_header.stack_end_ptr     lisp_alloc_:   65,
                                               stack_header:        38.
          14    stack_header.system_free_ptr   stack_header:        33.
          60    stack_header.sys_link_info_ptr       stack_header:        56.
          72    stack_header.trace_frames      stack_header:        61.
          50    stack_header.trans_op_tv_ptr   stack_header:        51.
          56    stack_header.unwinder_ptr      stack_header:        54.
          16    stack_header.user_free_ptr     stack_header:        34.
         100    stack_header_end         stack_header:        64.
         236    stack_loss_error         lisp_error_codes:    62.
                stack_ptr                lisp_alloc_:   55,   69,  390.
           4    stack_ptr_ptr            lisp_stack_seg:       8.
         225    stars_left_in_name       lisp_error_codes:    53.
          10    static                   lisp_alloc_:    8,    9.
         251    store_function_misused   lisp_error_codes:    73.
         242    store_not_allowed        lisp_error_codes:    66.
         116    store_operator           lisp_stack_seg:      49.
        4000    String                   lisp_alloc_:  303,
                                         lisp_object_types:   22.
        1115    sublis                   lisp_alloc_:  879,  883.
        1121    sublis0                  lisp_alloc_:  889,  900.
        1156    sublis1                  lisp_alloc_:  916,  928,  958,  961,  987.
        1174    sublis2                  lisp_alloc_:  931,  951.
        1225    sublis_car_changed       lisp_alloc_:  959,  982.
        1213    sublis_cdr_changed       lisp_alloc_:  962,  969.
        1220    sublis_change_exit       lisp_alloc_:  975,  990.
        1235    sublis_cons              lisp_alloc_:  970,  983,  993.
        1163    sublis_rpt               lisp_alloc_:  938,  944.
        1172    sublis_substitute_here   lisp_alloc_:  941,  947.
        2000    Subr                     lisp_object_types:   23.
         437    subst                    lisp_alloc_:  455,  456.
        1051    subst_                   lisp_alloc_:  460,  810,  811.
        1056    subst_loop               lisp_alloc_:  813,  817,  829,  833.
          16    switch_to_lisp           lisp_alloc_:   67,  379,  399,  409,  417,  425,  436,  446,  456,  464, 1208.
          44    system_lp                lisp_alloc_:  294,  313,
                                         lisp_stack_seg:      28.
         400    System_Subr              lisp_object_types:   24.
          74    tally_done               lisp_alloc_:  134,  142.
          56    tally_out                lisp_alloc_:   81,  116.
         104    terminate_list_op        lisp_stack_seg:      44.
         234    terminate_list_opr       lisp_alloc_:  271,  272.
          52    throw1_op                lisp_stack_seg:      31.
          54    throw2_op                lisp_stack_seg:      32.
         156    throw_to_no_catch        lisp_error_codes:    18.
         147    too_few_args             lisp_error_codes:    11.
         146    too_many_args            lisp_error_codes:    10.
           0    trace_frames.count       stack_header:        69.
           1    trace_frames.top_ptr     stack_header:        70.
          14    true                     lisp_alloc_: 1023,
                                         lisp_stack_seg:      12.
         551    tv_offset                stack_header:        75,   80,   81,   82,   83,   84.
          60    type_fields              lisp_stack_seg:      34.
         217    unable_to_float          lisp_error_codes:    47.
          22    unbind_op                lisp_stack_seg:      18.
          40    uncatch_op               lisp_stack_seg:      25.
       60000    Uncollectable            lisp_object_types:   21.
         144    undefined_atom           lisp_error_codes:     8.
         145    undefined_function       lisp_error_codes:     9.
         152    undefined_subr           lisp_error_codes:    14.
         237    underflow_fault          lisp_error_codes:    63.
          30    unerrset_op              lisp_stack_seg:      21.
       67500    Unevalable               lisp_object_types:   27.
                unmkd_ptr                lisp_alloc_:   56,   68,   70,   98,  391.
           6    unmkd_ptr_ptr            lisp_stack_seg:       9.
           2    unmkd_stack_bottom       lisp_stack_seg:       7.
         316    unsave_regs              lisp_alloc_:  322,  344.
         315    unsave_retry             lisp_alloc_:  337,  342.
         155    unseen_go_tag            lisp_error_codes:    17.
          50    unseen_go_tag_op         lisp_stack_seg:      30.
         146    ununwp_op                lisp_stack_seg:      61.
         142    unwp1_op                 lisp_stack_seg:      59.
         144    unwp2_op                 lisp_stack_seg:      60.
          64    words_alloc              lisp_alloc_:  128,  129,  295,  386,  557,  630, 1226.
         173    wrong_no_args            lisp_error_codes:    31.
         373    xcons                    lisp_alloc_:  408,  409.
         500    xcons_                   lisp_alloc_:  413,  503,  504.
          76    xcons_op                 lisp_stack_seg:      41.
         216    xcons_opr                lisp_alloc_:  249,  250.
         470    xcret                    lisp_alloc_:  494,  508.
         763    zap                      lisp_alloc_:  733,  738.
         240    zerodivide_fault         lisp_error_codes:    64.


NO FATAL ERRORS


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
