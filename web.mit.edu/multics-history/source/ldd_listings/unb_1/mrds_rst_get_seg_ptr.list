	COMPILATION LISTING OF SEGMENT mrds_rst_get_seg_ptr
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/18/85  1101.2 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 mrds_rst_get_seg_ptr: proc (rsc_ptr, head_of_list_ptr, seg_name, create_sw, seg_ptr, code);
       19 
       20 /* This procedure searches the specified list in rsc for for the segment name
       21*   If the create_sw is ON and the
       22*   segment name was not found in the specified list the segment name is
       23*   added to the list and the segment created.
       24*   If the create_sw is ON and the segment name was found in the list the seg_ptr returned
       25*   is null and code = mrds_error_$rst_list_duplicate.
       26*
       27*   if create_sw = OFF then the bit count is adjusted on the segment and the segment is inititated if possible.
       28*
       29*   The segment pointer and code are returned by this procedure.
       30**/
       31 
       32 
       33 /*  	HISTORY
       34*   Initially written by Roger D.Lackey Sept, 78
       35*   Modified by R. D. Lackey January 16, 1979 to add adjust_bit_count
       36*
       37*   81-01-31 Jim Gray : added call to set needed access for DBA types,
       38*   if access violation occurred. also changed to only make call
       39*   to adjust_bit_count and/or initiate, if the seg ptr or bit count unknown
       40*   in order to improve performance.
       41*
       42*   82-07-02 R. Harvey : changed reference of dmd$set_needed_access to
       43*   dmd_$set_needed_access
       44**/
       45 
       46 
       47 
       48 /*	PARAMETERS	*/
       49 
       50 /* dcl rsc_ptr  pointer; 				/* (INPUT) Pointer to rsc (restructuring control) segment */
       51 	dcl     head_of_list_ptr	 ptr;		/* (INPUT) Pointer to head of list to be searched */
       52 	dcl     seg_name		 char (32) aligned; /* (INPUT) Name of segment we are searching for */
       53 	dcl     create_sw		 bit (1);		/* (INPUT) On => create segment */
       54 	dcl     seg_ptr		 ptr;		/* (OUTPUT) Pointer to segment (may be null) */
       55 	dcl     code		 fixed bin (35);	/* (OUTPUT) Error code */
       56 
       57 Start:
       58 
       59 	call mrds_rst_list_element$add (seg_name, SEG_INFO, rsc_ptr, head_of_list_ptr, seg_info_ptr, code);
       60 
       61 	if code = 0 | code = mrds_error_$rst_list_duplicate then do;
       62 
       63 		if code = 0 then do;		/* Entry was added to list */
       64 
       65 			seg_info.name = seg_name;	/* Init seg info stuff */
       66 			if head_of_list_ptr = rsc.h_n_seg_info_ls_ptr then
       67 			     seg_info.dir = rsc.temp_dir;
       68 			else seg_info.dir = rsc.dbp;
       69 			seg_info.seg_ptr = null;
       70 			seg_info.bcnt = 0;
       71 
       72 		     end;
       73 
       74 		if create_sw then do;		/* create_sw = ON the want to create a seg */
       75 
       76 			if code = 0 then do;	/* Entry was added to the list */
       77 
       78 				call hcs_$make_seg (seg_info.dir, seg_info.name, "", 10, seg_info.seg_ptr, code);
       79 				seg_ptr = seg_info.seg_ptr;
       80 
       81 			     end;
       82 		     end;
       83 
       84 /* BEGIN CHANGE 81-01-31 ***************************************************** */
       85 
       86 		else do;				/* Create_sw = OFF */
       87 
       88 			if ^(seg_info.seg_ptr = null () | seg_info.bcnt = 0) then do; /* already set */
       89 				code = 0;
       90 				seg_ptr = seg_info.seg_ptr;
       91 			     end;
       92 			else do;
       93 
       94 				call adjust_bit_count_ (seg_info.dir, seg_info.name, "1"b, bit_count, code);
       95 				if code = error_table_$moderr then do;
       96 					call dmd_$set_needed_access
       97 					     (seg_info.dir, code); /* fails if caller not DBA */
       98 					if code ^= 0 then
       99 					     code = error_table_$moderr;
      100 					else call adjust_bit_count_ (seg_info.dir, seg_info.name, "1"b, bit_count, code);
      101 
      102 				     end;
      103 
      104 				if code = 0 then
      105 				     call hcs_$initiate_count (seg_info.dir, seg_info.name, "",
      106 					seg_info.bcnt, 0, seg_info.seg_ptr, code);
      107 				seg_ptr = seg_info.seg_ptr;
      108 			     end;
      109 
      110 /* END CHANGE 81-01-31 ****************************************************** */
      111 
      112 		     end;
      113 
      114 
      115 	     end;
      116 
      117 	else seg_ptr = null;			/* Something was wrong */
      118 
      119 
      120 exit:	return;
      121 
      122 /*	OTHERS	*/
      123 
      124 	dcl     bit_count		 fixed bin (35);	/* For adjust bit count */
      125 	dcl     adjust_bit_count_	 entry (char (168), char (32), bit (1) aligned, fixed bin (35), fixed bin (35));
      126 	dcl     hcs_$initiate_count	 entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
      127 	dcl     hcs_$make_seg	 entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
      128 	dcl     mrds_rst_list_element$add entry (char (32) aligned, fixed bin, ptr, ptr, ptr, fixed bin (35));
      129 	dcl     mrds_error_$rst_list_duplicate ext fixed bin (35);
      130 	dcl     sys_info$max_seg_size	 ext fixed bin (35);
      131 	dcl     (addr, fixed, null, rel) builtin;
      132 	declare error_table_$moderr	 fixed bin (35) ext;/* incorrect access */
      133 	declare dmd_$set_needed_access entry (char (*), fixed bin (35)); /* sets access for DBA types */
      134 
  1     1 /* BEGIN INCLUDE FILE mrds_rst_rsc.incl.pl1		RDL  7/7/78	*/
  1     2 
  1     3 /* Modified 8/21/78 by RDL */
  1     4 
  1     5 /* Modified 9/11/78 	by RDL to add directive and stmt pointers */
  1     6 
  1     7 /* Modified 11/4/78		by RDL to add debug,trace,meter switches
  1     8*
  1     9*   Modified 3/29/79 by RDL to change s_seg_info_ptr to source_seg_ptr
  1    10*
  1    11*   Modified by Jim Gray - - Jan. 1980, to add flags to disallow blocked files, forieng keys, and restructuring.
  1    12*
  1    13*   Modified by Jim Gray - - Feb. 1980, to add command level flag for cmdb subroutine interface.
  1    14*
  1    15*   Modified by Jim Gray - - 80-11-06, to add bit for cmdb -secure option.
  1    16*
  1    17*   81-05-18 Jim Gray : added bit for max_attributes error message, so that
  1    18*   it would only be issued on first occurence.
  1    19*
  1    20*   82-08-19 Davids: added the db_type field.
  1    21*
  1    22*   83-02-18 Mike Kubicar : Removed the db_type field and added the 
  1    23*   db_relation_mode_flags substructure to define the modes applicable
  1    24*   to the database's relations.  Also removed assorted unsed fields
  1    25*   (names that included the word unused).
  1    26*
  1    27**/
  1    28 
  1    29 dcl 1 rsc based (rsc_ptr),				/* Restructuring control info */
  1    30     2 rsc_dir char (200),				/* pathname of directory containing rsc segment */
  1    31     2 dbp char (168),				/* Database absolute path */
  1    32     2 temp_dir char (168),				/* Path name of temp restrucuring directory */
  1    33     2 temp_dir_sw bit (1) unal,			/* On => temp dir has been created */
  1    34     2 db_quiesced_sw bit (1) unal,			/* On => database has been quiesced */
  1    35     2 o_db_open_sw bit (1) unal,			/* On => old database has been opened */
  1    36     2 n_db_open_sw bit (1) unal,			/* On => temp database is open */
  1    37     2 listing_seg_sw bit (1) unal,			/* On => listing segment has been created */
  1    38     2 skip_scanner_conversion bit (1) unal,		/* Skip conversion in scanner */
  1    39     2 cmdb_option bit (1) unal,			/* ON => this is a cmdb source, not restructuring */
  1    40     2 trace_sw bit (1) unal,				/* On -> trace mode in affect */
  1    41     2 debug_sw bit (1) unal,				/* On = debug mode (NOT IMPLEMENTED) */
  1    42     2 meter_sw bit (1) unal,				/* On = procedures call metering procedure */
  1    43     2 delete_db_sw bit (1) unal,			/* On = delete data base in cleanup */
  1    44     2 model_consistent_sw bit (1) unal,			/* On => Model is consistent */
  1    45     2 physical_started_sw bit (1) unal,			/* On => Physical restructuring started */
  1    46     2 physical_complete_sw bit (1) unal,		/* On => Physical restructuring completed */
  1    47     2 model_overflow bit (1) unal,			/* ON => model segment area condition occurred */
  1    48     2 max_files bit (1) unal,				/* ON => maximum number of files reached */
  1    49     2 allow_foreign_keys bit (1) unal,			/* on => allow foreign key statment */
  1    50     2 foreign_key_seen bit (1) unal,			/* on => foreign key definition in source */
  1    51     2 allow_blocked_files bit (1) unal,			/* on => allow file statement with blocked option */
  1    52     2 blocked_file_seen bit (1) unal,			/* on => blocked file definition in source */
  1    53     2 allow_restructuring bit (1) unal,			/* on => allow RMDB entry point */
  1    54     2 command_level bit (1) unal,			/* on => called from command unal, not subroutine level */
  1    55     2 secure bit (1) unal,				/* on => -secure option given for cmdb */
  1    56     2 max_attrs bit (1) unal,				/* on => max attrs/rel or max indexes/rel exceeded */
  1    57     2 db_relation_mode_flags,
  1    58       3 dm_file_type bit (1) unal,			/* on => relations are dm files */
  1    59       3 protection_on bit (1) unal,			/* on => relations need transactions */
  1    60       3 concurrency_on bit (1) unal,			/* on => concurrency control enabled */
  1    61       3 rollback_on bit (1) unal,			/* on => before journalling is enabled */
  1    62     2 severity_high fixed bin,			/* Highest severity level error encountered */
  1    63     2 phase fixed bin,				/* 000 = init
  1    64*						   100 = global list init
  1    65*						   200 = parse
  1    66*						   300 = physical init
  1    67*						   400 = physical */
  1    68     2 h_o_seg_info_ls_ptr ptr,			/* Pointer to head of old db seg_info list */
  1    69     2 h_n_seg_info_ls_ptr ptr,			/* Pointer to head of new db seg_info list */
  1    70     2 h_gfile_ptr ptr,				/* Pointer to head of global file list */
  1    71     2 h_gdom_ptr ptr,				/* Pointer to head of global domain list */
  1    72     2 h_gattr_ptr ptr,				/* Pointer to head of global attribute list */
  1    73     2 h_grel_ptr ptr,				/* Pointer to head of global relation list */
  1    74     2 h_glink_ptr ptr,				/* Pointer to head of global link list */
  1    75     2 o_dm_ptr ptr,					/* Pointer to old data model seg  (dm_model ) */
  1    76     2 n_dm_ptr ptr,					/* Pointer to temp data model seg */
  1    77     2 o_fn_hdr_ptr ptr,				/* Pointer to head of original file list (fn structure) */
  1    78     2 source_seg_ptr ptr,				/* Pointer to source_seg */
  1    79     2 listing_iocb_ptr ptr,				/* Pointer to listing segment iocb */
  1    80     2 directive_ptr ptr,				/* Pointer to directive type str in mrds_rst_semactics.incl.pl1 */
  1    81     2 stmt_ptr ptr,					/* Pointer to statement str in mrds_rst_sematics.incl.pl1 */
  1    82     2 trace_metering_iocb_ptr ptr,			/* Pointer to seg used by trace and metering */
  1    83     2 tree_node_area_ptr ptr,				/* pointer to working storage for tree nodes */
  1    84     2 tree_data,
  1    85       3 seg_info_area_ptr ptr,			/* seg info working storage area */
  1    86       3 gl_area_ptr ptr,				/* global list data work storage area */
  1    87       3 sl_area_ptr ptr,				/* sublist data work storage area */
  1    88     2 parse_info_area_ptr ptr,			/* parse interface work area storage */
  1    89     2 static_info_area_ptr ptr,			/* directive, stmt and other static work storage area */
  1    90     2 variable_length_area_ptr ptr,			/* varibale allocates work storage area */
  1    91     2 other_area_ptr ptr,				/* unspecified work area storage */
  1    92     2 wa area (sys_info$max_seg_size - fixed (rel (addr (rsc.wa))) + 1); /* Work area */
  1    93 
  1    94 dcl  rsc_ptr ptr;					/* Pointer to base of rsc segment */
  1    95 
  1    96 
  1    97 
  1    98 /* END INCLUDE FILE mrds_rst_rsc.incl.pl1				*/
  1    99 
      135 
      136 
  2     1 /* BEGIN INCLUDE FILE mrds_rst_global_lists.incl.pl1	jeg	7/17/78	*/
  2     2 
  2     3 /* note: mrds_rst_list_element$add and delete entries
  2     4*   makes use of the following structure type correspondence
  2     5*
  2     6*   structure_type = 1  refers to gl (global list element)
  2     7*
  2     8*   structure_type = 2 refers to sl (global sublist element)
  2     9*
  2    10*   structure_type = 3  refers to seg_info(segment information element)
  2    11*
  2    12**/
  2    13 
  2    14 
  2    15 dcl 1 gl aligned based (gl_ptr),			/* Template for global list entry */
  2    16     2 type fixed bin,				/* structure_type, usefull when overlay used */
  2    17     2 name char (32),				/* Item name */
  2    18     2 item_info_ptr ptr,				/* Pointer to info structure for this item */
  2    19     2 parse_info_ptr ptr,				/* Pointer to info obtained by parsing source */
  2    20     2 other_info_ptr ptr,				/* Pointer to additional info str if needed */
  2    21     2 item_sub_list_ptr ptr,				/* Pointer to sub list of items if neccessary for this his item */
  2    22     2 file_info_ptr ptr,				/* Pointer to file info for this entry */
  2    23     2 file_model_ptr ptr,				/* Pointer to file model for this entry */
  2    24     2 affected bit (1) unal,				/* ON => affected by some directive */
  2    25     2 cmdb bit (1) unal,				/* ON => affected by cmdb directive */
  2    26     2 undefine bit (1) unal,				/* ON => affected by undefine directive */
  2    27     2 define bit (1) unal,				/* ON => affected by define directive */
  2    28     2 redefine bit (1) unal,				/* ON => affected by redefine directive */
  2    29     2 superior_assigned bit (1) unal,			/* ON => has parent */
  2    30     2 inferior_assigned bit (1) unal,			/* ON => child present */
  2    31     2 complete bit (1) unal,				/* ON => all things present */
  2    32     2 consistant bit (1) unal,			/* ON => correct model */
  2    33     2 reserved bit (26) unal,				/* for future use */
  2    34     2 child_defined bit (1) unal ;			/* ON => global element entered by child */
  2    35 
  2    36 dcl  gl_ptr ptr;					/* Pointer to gl structure */
  2    37 
  2    38 
  2    39 
  2    40 dcl 1 sl aligned based (sl_ptr),			/* Template of sub list entry for global list */
  2    41     2 type fixed bin,				/* structure_type, usefull when overlay used */
  2    42     2 name char (32),				/* Name of item */
  2    43     2 item_info_ptr ptr,				/* Pointer to info structure for this entry */
  2    44     2 parse_info_ptr ptr,				/* Pointer to info obtained by parsing source */
  2    45     2 old_other_info_ptr ptr,				/* Pointer to old version of other info */
  2    46     2 new_other_info_ptr ptr,				/* Pointer to new version of other info */
  2    47     2 global_list_ptr ptr,				/* pointer to corresponding global list element */
  2    48     2 reserved bit (36) unal;				/* Reserved for future use */
  2    49 
  2    50 dcl  sl_ptr ptr;					/* Pointer to sub list structure */
  2    51 
  2    52 
  2    53 dcl 1 seg_info based (seg_info_ptr),			/* Info about segment initiated */
  2    54     2 name char (32),				/* Segment name */
  2    55     2 dir char (168),				/* Absolute path of containing directory */
  2    56     2 seg_ptr ptr,					/* Pointer to base of segment */
  2    57     2 bcnt fixed bin (24);				/* Bit count of segment */
  2    58 
  2    59 dcl  seg_info_ptr ptr;				/* Pointer to seg_info str */
  2    60 
  2    61 
  2    62 
  2    63 dcl  MAIN_LIST fixed bin internal static options (constant) init (1);
  2    64 dcl  SUB_LIST fixed bin internal static options (constant) init (2);
  2    65 dcl  SEG_INFO fixed bin internal static options (constant) init (3);
  2    66 
  2    67 declare 1 list_ovrly aligned based (list_ovrly_ptr),	/* overlay for top part of gl and sl list elements */
  2    68         2 type fixed bin,				/* structure_type, 1 => gl, 2 => sl */
  2    69         2 name char (32),				/* Name of item */
  2    70         2 item_info_ptr ptr,				/* pointer to info structure for this entry */
  2    71         2 parse_info_ptr ptr,				/* pointer to info obtained by parsing source */
  2    72         2 other_info_ptr ptr ;			/* pointer to additional info structure if needed */
  2    73 
  2    74 declare  list_ovrly_ptr ptr ;				/* pointer to overlay structure */
  2    75 
  2    76 
  2    77 declare  saved_child_count fixed bin based (saved_child_count_ptr) ; /* parent link structure child count */
  2    78 declare  saved_child_count_ptr ptr ;			/* pointer to remembered number of children */
  2    79 
  2    80 
  2    81 /* USES AND MEANING OF LIST ELEMENT ENTRIES
  2    82*
  2    83*   DOMAIN GLOBAL LIST --------------------------
  2    84*
  2    85*   gl.type - - MAIN_LIST
  2    86*   gl.name - - 32 char domain name
  2    87*   gl.item_info_ptr - - pointer to domain_info for this domain
  2    88*   gl.parse_info_ptr - - pointer to parse info structure
  2    89*   gl.other_info_ptr - - dbm_ptr, pointer to mdbm_db_model
  2    90*   gl.item_sub_list_ptr - - pointer to sublist of attributes using this domain
  2    91*   gl.file_info_ptr - - null ()
  2    92*   gl.file_model_ptr - - null ()
  2    93*   gl.superior_assigned - - ON => domain referenced by some relation
  2    94*   gl.inferior_assigned - - ON => referencing attribute present
  2    95*   gl.complete - - ON => domain_info present
  2    96*   gl.consistant - - always ON
  2    97*
  2    98*   DOMAIN GLOBAL LIST "REFERENCING ATTRIBUTES" SUBLIST ----------------
  2    99*
  2   100*   sl.type - - SUB_LIST
  2   101*   sl.name - - 32 char attribute name
  2   102*   sl.item_info_ptr - - pointer to this attribute's attribute_info
  2   103*   sl.parse_info_ptr - - pointer to parse info structure
  2   104*   sl.old_other_info_ptr - - null ()
  2   105*   sl.new_other_info_ptr - - pointer to this domain's global list element
  2   106*   sl.global_list_ptr - - pointer to attribute's global list element
  2   107*
  2   108*   ATTRIBUTE GLOBAL LIST -----------------
  2   109*
  2   110*   gl.type - - MAIN_LIST
  2   111*   gl.name - - 32 char attribute name
  2   112*   gl.item_info_ptr - - pointer to corresponding domain sublist element for this attribute
  2   113*   gl.parse_info_ptr - - pointer to parse info structure
  2   114*   gl.other_info_ptr - - domain_info of domain for this attribute
  2   115*   gl.item_sub_list_ptr - - pointer to sublist of relations that use this attribute
  2   116*   gl.file_info_ptr - - null (), use pointer(fm_ptr,file_model.fi_ptr)
  2   117*   gl.file_model_ptr - - null (), use pointer(ai_ptr,0), ai_ptr from corres. rel's attr sublist
  2   118*   gl.superior_assigned - - ON => relation contains this attribute
  2   119*   gl.inferior_assigned - - ON => attribute references known domain
  2   120*   gl.complete - - ON => attr_info present for this attribute
  2   121*   gl.consistant - - OFF => no domain for this attribute
  2   122*
  2   123*   ATTRIBUTE GLOBAL LIST "USED IN RELATION" SUBLIST ------------------
  2   124*
  2   125*   sl.type - - SUB_LIST
  2   126*   sl.name - - 32 char relation name
  2   127*   sl.item_info_ptr - - pointer to this relation's rel_info
  2   128*   sl.parse_info_ptr - - pointer to parse info structure
  2   129*   sl.old_other_info_ptr - - pointer to attribute's attr_info in this relation
  2   130*   sl.new_other_info_ptr - - pointer to this attribute's global list element
  2   131*   sl.global_list_ptr - - pointer to relation's global list element
  2   132*
  2   133*   RELATION GLOBAL LIST -------------------
  2   134*
  2   135*   gl.type - - MAIN_LIST
  2   136*   gl.name - - 32 char relation name
  2   137*   gl.item_info_ptr - - pointer to rel_info for this relation
  2   138*   gl.parse_info_ptr - - pointer to parse info structure
  2   139*   gl.other_info_ptr - - pointer to global list element of file containing this relation
  2   140*   gl.item_sub_list_ptr - - pointer to sublist of attributes in this relation
  2   141*   gl.file_info_ptr - - pointer to file_info of this relation's file
  2   142*   gl.file_model_ptr - - pointer to file_model of this relation's file
  2   143*   gl.superior_assigned - - ON => file present to hold this relation
  2   144*   gl.inferior_assigned - - ON => attribute's present in this relation
  2   145*   gl.complete - - ON => rel_info assigned to this relation
  2   146*   gl.consistant - - OFF => no attributes for this relation
  2   147*
  2   148*   RELATION GLOBAL LIST "CONTAINED ATTRIBUTE" SUBLIST ----------------
  2   149*
  2   150*   sl.type - - SUB_LIST
  2   151*   sl.name - - 32 char attribute name
  2   152*   sl.item_info_ptr - - pointer to this attribute's attribute_info
  2   153*   sl.parse_info_ptr - - pointer to parse info structure
  2   154*   sl.old_other_info_ptr - - pointer to domain_info for this attribute in old model
  2   155*   sl.new_other_info_ptr - - pointer to domain_info for this attribute in new model
  2   156*   sl.global_list_ptr - - pointer to attribute's global list element
  2   157*
  2   158*   FILE GLOBAL LIST -----------------------
  2   159*
  2   160*   gl.type - - MAIN_LIST
  2   161*   gl.name - - 30 char file name plus 2 trailing blanks
  2   162*   gl.item_info_ptr - - pointer to file_info for this file
  2   163*   gl.parse_info_ptr - - pointer to parse info structure
  2   164*   gl.other_info_ptr - - null ()
  2   165*   gl.item_sub_list_ptr - - pointer to sublist of relations contained in this file
  2   166*   gl.file_info_ptr - - pointer to file_info for this file
  2   167*   gl.file_model_ptr - - pointer to file_model for this file
  2   168*   gl.superior_assigned - - ON => file_model present for this file
  2   169*   gl.inferior_assigned - - ON => relation present for this file
  2   170*   gl.complete - - OFF => not formatted yet
  2   171*   gl.consistant - - ON => no relations present
  2   172*
  2   173*   FILE GLOBAL LIST "CONTAINED RELATION" SUBLIST ----------------
  2   174*
  2   175*   sl.type - - SUB_LIST
  2   176*   sl.name - - 32 char relation name
  2   177*   sl.item_info_ptr - - relation's rel_info pointer
  2   178*   sl.parse_info_ptr - - pointer to parse info structure
  2   179*   sl.old_other_info_ptr - - null ()
  2   180*   sl.new_other_info_ptr - - pointer to file global list element
  2   181*   sl.global_list_ptr - - pointer to relation's global list element
  2   182*
  2   183*   FOREIGN KEY GLOBAL LIST --------------------
  2   184*
  2   185*   gl.type - - MAIN_LIST
  2   186*   gl.name - - 32 char link(foreign key) name, parent_link_info.name
  2   187*   gl.item_info_ptr - - pointer to parent_link_info for this foreign key
  2   188*   gl.parse_info_ptr - - pointer to parse info structure
  2   189*   gl.other_info_ptr - - pointer to parent relation global list element
  2   190*   gl.item_sub_list_ptr - - pointer to sublist of child relations for this parent
  2   191*   gl.file_info_ptr - - pointer to file_info for parent relation's file
  2   192*   gl.file_model_ptr - - pointer to file_model for parent relation's file
  2   193*   gl.superior_assigned - - ON => parent present
  2   194*   gl.inferior_assigned - - ON => child present
  2   195*   gl.complete - - ON => pli_info and cli_info present
  2   196*   gl.consistant - - ON => rels/attrs found and corres domains match
  2   197*   gl.child_defined - - ON => not defined by parent, but by one of it's children
  2   198*
  2   199*   FOREIGN KEY GLOBAL LIST CHILDREN SUBLIST
  2   200*
  2   201*   sl.type - - SUB_LIST
  2   202*   sl.name - - 32 char name of relation representing this child
  2   203*   sl.item_info_ptr - - pointer to child_link_info for this child
  2   204*   sl.parse_info_ptr - - pointer to parse info structure
  2   205*   sl.old_other_info_ptr - - pointer to file_model holding this child relation
  2   206*   sl.new_other_info_ptr - - pointer to rel_info for this child
  2   207*   sl.global_list_ptr - - pointer to child relation global list element
  2   208*
  2   209*   NOTE: all pointers are to the new model unless otherwise indicated
  2   210*
  2   211**/
  2   212 
  2   213 /* END INCLUDE FILE mrds_rst_global_lists.incl.pl1	*/
  2   214 
      137 
      138 
  3     1 /* BEGIN INCLUDE FILE mrds_rst_tree.incl.pl1   jeg 7/19/78 */
  3     2 
  3     3 /* common declarations for threaded binary tree routines
  3     4*
  3     5*   The tree maintains an inorder list of it's keys.
  3     6*   this means that for a given node, any key in it's left subtree
  3     7*   is "less" than the given node's key and that any key in it's
  3     8*   right subtree is "greater" than the given node's key.
  3     9*
  3    10*   Threads are maintained to allow fast and easy traversal of the tree.
  3    11*   threads occupy the position of null pointers of an straight binary tree,
  3    12*   thus they only occur in leaf nodes.
  3    13*   left threads point to that nodes inorder predecessor.
  3    14*   right threads point to that nodes inorder successor.
  3    15*
  3    16*   note: root_ptr must be passed by reference
  3    17*   ( not by value ) so it can be changed .
  3    18*   Also, each parameter must be a different
  3    19*   variable. The same variable used for two
  3    20*   or more arguments when any of the tree
  3    21*   routines are called will produce errors */
  3    22 
  3    23 
  3    24 declare  key char (32) aligned ;			/* data key directing search */
  3    25 
  3    26 declare  root_ptr ptr ;				/* pointer to head of desired list */
  3    27 declare  node_ptr ptr ;				/* pointer to key node, when success */
  3    28 declare  parent_ptr ptr ;				/* pointer to direct parent of current node */
  3    29 declare  data_ptr ptr ;				/* pointer from tree node to data structure headed by node */
  3    30 declare  successor_ptr ptr ;				/* pointer to inorder successor of current node in tree */
  3    31 declare  successor_parent_ptr ptr ;			/* pointer to immediate tree parent of inorder successor node */
  3    32 declare  predecessor_ptr ptr ;			/* pointer to inorder predecessor of current node */
  3    33 declare  predecessor_parent_ptr ptr ;			/* pointer to direct parent of predecessor */
  3    34 declare  area_ptr ptr ;				/* pointer to based area for node allocation/freeing */
  3    35 
  3    36 declare  work_area area based (area_ptr) ;		/* area of storage for tree */
  3    37 
  3    38 declare  success bit (1) ;				/* on if operation successful */
  3    39 declare  thread bit (1) aligned ;			/* current thread indicator, on = thread, off = pointer */
  3    40 
  3    41 declare 1 node based (node_ptr) aligned,		/* tree element */
  3    42         2 data ptr,					/* data field link */
  3    43         2 key char (32),				/* data key */
  3    44         2 right,					/* right branch link */
  3    45 	3 thread bit (1),				/* indicates whether link is thread or pointer */
  3    46 	3 link ptr,				/* pointer to right descendent or thread to successor */
  3    47         2 left,					/* left branch link */
  3    48 	3 thread bit (1),				/* indicates whether link is thread or pointer */
  3    49 	3 link ptr,				/* pointer to left descendent or thread to predecessor */
  3    50         2 pad bit (34) ;				/* reserved for future flags */
  3    51 
  3    52 /* END INCLUDE FILE mrds_rst_tree.incl.pl1  */
  3    53 
  3    54 
  3    55 
  3    56 
      139 
      140 
      141 
      142      end mrds_rst_get_seg_ptr;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/85  0909.1  mrds_rst_get_seg_ptr.pl1          >special_ldd>online>mrds.pbf-04/18/85>mrds_rst_get_seg_ptr.pl1
135          1    10/14/83  1609.1  mrds_rst_rsc.incl.pl1             >ldd>include>mrds_rst_rsc.incl.pl1
137          2    10/14/83  1608.4  mrds_rst_global_lists.incl.pl1    >ldd>include>mrds_rst_global_lists.incl.pl1
139          3    10/14/83  1608.6  mrds_rst_tree.incl.pl1            >ldd>include>mrds_rst_tree.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
SEG_INFO                        000010 constant        fixed bin(17,0)          initial dcl 2-65 set ref 57*
adjust_bit_count_               000010 constant        entry                    external dcl 125 ref 94 100
bcnt                     64            based           fixed bin(24,0)          level 2 dcl 2-53 set ref 70* 88 104*
bit_count                       000100 automatic       fixed bin(35,0)          dcl 124 set ref 94* 100*
code                                   parameter       fixed bin(35,0)          dcl 55 set ref 18 57* 61 61 63 76 78* 89* 94* 95 96*
                                                                                  98 98* 100* 104 104*
create_sw                              parameter       bit(1)                   unaligned dcl 53 ref 18 74
dbp                      62            based           char(168)                level 2 packed unaligned dcl 1-29 ref 68
dir                      10            based           char(168)                level 2 packed unaligned dcl 2-53 set ref 66* 68*
                                                                                  78* 94* 96* 100* 104*
dmd_$set_needed_access          000024 constant        entry                    external dcl 133 ref 96
error_table_$moderr             000022 external static fixed bin(35,0)          dcl 132 ref 95 98
h_n_seg_info_ls_ptr     214            based           pointer                  level 2 dcl 1-29 ref 66
hcs_$initiate_count             000012 constant        entry                    external dcl 126 ref 104
hcs_$make_seg                   000014 constant        entry                    external dcl 127 ref 78
head_of_list_ptr                       parameter       pointer                  dcl 51 set ref 18 57* 66
mrds_error_$rst_list_duplicate  000020 external static fixed bin(35,0)          dcl 129 ref 61
mrds_rst_list_element$add       000016 constant        entry                    external dcl 128 ref 57
name                                   based           char(32)                 level 2 packed unaligned dcl 2-53 set ref 65* 78*
                                                                                  94* 100* 104*
null                                                   builtin function         dcl 131 ref 69 88 117
rsc                                    based           structure                level 1 unaligned dcl 1-29
rsc_ptr                                parameter       pointer                  dcl 1-94 set ref 18 57* 66 66 68
seg_info                               based           structure                level 1 unaligned dcl 2-53
seg_info_ptr                    000102 automatic       pointer                  dcl 2-59 set ref 57* 65 66 68 69 70 78 78 78 79 88
                                                                                  88 90 94 94 96 100 100 104 104 104 104 107
seg_name                               parameter       char(32)                 dcl 52 set ref 18 57* 65
seg_ptr                  62            based           pointer                  level 2 in structure "seg_info" dcl 2-53
                                                                                  in procedure "mrds_rst_get_seg_ptr" set ref 69*
                                                                                  78* 79 88 90 104* 107
seg_ptr                                parameter       pointer                  dcl 54 in procedure "mrds_rst_get_seg_ptr" set ref
                                                                                  18 79* 90* 107* 117*
temp_dir                134            based           char(168)                level 2 packed unaligned dcl 1-29 ref 66

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
MAIN_LIST                              internal static fixed bin(17,0)          initial dcl 2-63
SUB_LIST                               internal static fixed bin(17,0)          initial dcl 2-64
addr                                                   builtin function         dcl 131
area_ptr                               automatic       pointer                  dcl 3-34
data_ptr                               automatic       pointer                  dcl 3-29
fixed                                                  builtin function         dcl 131
gl                                     based           structure                level 1 dcl 2-15
gl_ptr                                 automatic       pointer                  dcl 2-36
key                                    automatic       char(32)                 dcl 3-24
list_ovrly                             based           structure                level 1 dcl 2-67
list_ovrly_ptr                         automatic       pointer                  dcl 2-74
node                                   based           structure                level 1 dcl 3-41
node_ptr                               automatic       pointer                  dcl 3-27
parent_ptr                             automatic       pointer                  dcl 3-28
predecessor_parent_ptr                 automatic       pointer                  dcl 3-33
predecessor_ptr                        automatic       pointer                  dcl 3-32
rel                                                    builtin function         dcl 131
root_ptr                               automatic       pointer                  dcl 3-26
saved_child_count                      based           fixed bin(17,0)          dcl 2-77
saved_child_count_ptr                  automatic       pointer                  dcl 2-78
sl                                     based           structure                level 1 dcl 2-40
sl_ptr                                 automatic       pointer                  dcl 2-50
success                                automatic       bit(1)                   unaligned dcl 3-38
successor_parent_ptr                   automatic       pointer                  dcl 3-31
successor_ptr                          automatic       pointer                  dcl 3-30
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 130
thread                                 automatic       bit(1)                   dcl 3-39
work_area                              based           area(1024)               dcl 3-36

NAMES DECLARED BY EXPLICIT CONTEXT.
Start                           000031 constant        label                    dcl 57
exit                            000347 constant        label                    dcl 120
mrds_rst_get_seg_ptr            000024 constant        entry                    external dcl 18

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       476         524     350         506
Length       762     350        26         222     126           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_rst_get_seg_ptr                140 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_rst_get_seg_ptr     000100 bit_count                   mrds_rst_get_seg_ptr
                         000102 seg_info_ptr                mrds_rst_get_seg_ptr

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
adjust_bit_count_             dmd_$set_needed_access        hcs_$initiate_count           hcs_$make_seg
mrds_rst_list_element$add

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$moderr           mrds_error_$rst_list_duplicate




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     18 000016        57 000031        61 000052        63 000060        65 000062        66 000067        68 000101
     69 000104        70 000106        74 000107        76 000114        78 000116        79 000156        82 000162
     88 000163        89 000172        90 000173        91 000175        94 000176        95 000217        96 000224
     98 000241       100 000250       104 000272       107 000340       115 000344       117 000345       120 000347


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
