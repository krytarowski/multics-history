	COMPILATION LISTING OF SEGMENT rmdb_delete_attribute
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 12/07/87  1321.2 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: ^inddcls,^indattr,indnoniterend,^indnoniterdo,indend,tree,^case,insnl,comcol61,dclind5,declareind5,delnl */
       10 
       11 /*DESCRIPTION
       12*  This subroutine deletes one or more attributes from a MRDS database. Each of
       13*  the attributes is examined, and a list of relations to be operated upon is
       14*  created. This is so that if more than one referenced attribute is being
       15*  deleted, each relation is only reformatted once. If an attribute is
       16*  unreferenced, it is simply removed from the db_model linked list. If it is
       17*  referenced, the relations that contain those attribute must be reformatted. */
       18 
       19 /****^  HISTORY COMMENTS:
       20*  1) change(85-02-07,Spitzer), approve(85-02-07,MCR7311),
       21*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
       22*     written
       23*  2) change(86-10-30,Blair), approve(86-10-30,PBF7311), audit(86-12-05,Dupuis),
       24*     install(86-12-09,MR12.0-1237):
       25*     Re-arrange the quit handler so that we only hold quits while we're
       26*     cleaning up the model, switching relation names and updating the xref and
       27*     history files.  No need elsewhere because once the model is marked
       28*     inconsistent the salvager will roll back the relations and model if
       29*     anything goes wrong.
       30*  3) change(87-09-30,Blair), approve(87-11-03,MCR7792), audit(87-11-30,Dupuis),
       31*     install(87-12-07,MR12.2-1008):
       32*     Set the undo_request variable to null so that if a problem occurs during
       33*     execution of this request we will not loop endlessly trying to execute
       34*     the request and roll the database back.  Set mstxn-txn_id to zero so we
       35*     don't get caught if we have a vfile_ database, but we try to abort a txn
       36*     during cleanup based on some residue value in the field,
       37*                                                   END HISTORY COMMENTS */
       38 
       39 rmdb_delete_attribute:
       40      proc (Irmdb_ctl_ptr, Idelete_object_info_ptr, Oerror_message, Ocode);
       41 
       42 	rmdb_ctl_ptr = Irmdb_ctl_ptr;
       43 	delete_object_info_ptr = Idelete_object_info_ptr;
       44 
       45 	user_area_ptr = null;
       46 
       47 	if delete_object_info.version ^= delete_object_info_version_1
       48 	then call error (error_table_$unimplemented_version,
       49 		"Version " || delete_object_info.version || " for delete_object_info structure.");
       50 
       51 	db_path = rmdb_ctl.absolute_db_path;		/* Create the xref file if not already created. */
       52 	if rmdb_ctl.crossref_file_info.iocb_ptr = null
       53 	then do;
       54 	     call mdbm_util_$xref_build (rmdb_ctl.temp_dir_path, db_path, rmdb_ctl.db_model_ptr,
       55 		rmdb_ctl.crossref_file_info.name, rmdb_ctl.crossref_file_info.iocb_ptr, error_message, code);
       56 	     if code ^= 0
       57 	     then call error (code, error_message);
       58 	     end;
       59 
       60 	local_iocb = rmdb_ctl.crossref_file_info.iocb_ptr;
       61 	mstxn_txn_id = "0"b;
       62 	
       63 	on cleanup
       64 	     begin;
       65 		call mdbm_util_$xref_destroy (rmdb_ctl.crossref_file_info.iocb_ptr, rmdb_ctl.temp_dir_path,
       66 		     rmdb_ctl.crossref_file_info.name, (""), (0));
       67 		call cleaner;
       68 	     end;
       69 
       70 	dbm_ptr = rmdb_ctl.db_model_ptr;
       71 
       72 	if delete_object_info.all
       73 	then call rmdb_delete_all$attributes (rmdb_ctl_ptr, error_message, code);
       74 	else do;
       75 
       76 /* Create a non-freeing, non-zeroing extensible area to allocate structures in.
       77*   When we return and finish using these structures, we will simply throw away
       78*   the area. */
       79 	     call mdbm_util_$get_temp_segment_path (rmdb_ctl.temp_dir_path, myname, user_area_ptr, code);
       80 	     if code ^= 0
       81 	     then call error (code, "Unable to get a temp segment in the temp dir.");
       82 
       83 	     unspec (ai) = "0"b;
       84 	     ai.version = area_info_version_1;
       85 	     ai.extend = "1"b;
       86 	     ai.dont_free = "1"b;
       87 	     ai.no_freeing = "1"b;
       88 	     ai.owner = myname;
       89 	     ai.size = sys_info$max_seg_size;
       90 	     ai.areap = user_area_ptr;
       91 
       92 	     call define_area_ (addr (ai), code);
       93 	     if code ^= 0
       94 	     then call error (code, "Defining a user area.");
       95 
       96 	     domain_list_ptr, attribute_list_ptr, relation_list_ptr = null;
       97 	     if delete_object_info.unreferenced
       98 	     then call make_unreferenced_attribute_list;
       99 	     else do;
      100 		call rmdb_relations_used$attributes (rmdb_ctl_ptr, delete_object_info_ptr, user_area_ptr,
      101 		     domain_list_ptr, attribute_list_ptr, relation_list_ptr, error_message, code);
      102 		if code ^= 0
      103 		then call error (code, error_message);
      104 
      105 		call check_for_deletion_of_generated_attributes;
      106 
      107 		if ^delete_object_info.force
      108 		then do;
      109 		     unspec (query_info) = "0"b;
      110 		     query_info.version = query_info_version_6;
      111 		     query_info.yes_or_no_sw = "1"b;
      112 		     query_info.suppress_name_sw = "1"b;
      113 		     query_info.question_iocbp = delete_object_info.check_iocb_ptr;
      114 		     query_info.answer_iocbp = delete_object_info.query_iocb_ptr;
      115 		     query_info.explanation_ptr = addr (QUERY_MSG);
      116 		     query_info.explanation_len = length (rtrim (QUERY_MSG));
      117 		     end;
      118 
      119 		call print_information;
      120 
      121 		if (delete_object_info.long = UNSPEC & delete_object_info.check)
      122 		then do;
      123 		     code = 0;
      124 		     call error (code, error_message);
      125 		     end;
      126 	     end;
      127 
      128 	     call check_for_deletion_of_primary_key;
      129 
      130 	     make_consistent_msg = "";          /* if anything goes wrong we can't retry */
      131 	
      132 
      133 	     call mdbm_util_$inconsistent_set (dbm_ptr, "delete_attribute", "Deleting attributes",
      134 		rtrim (make_consistent_msg));
      135 
      136 
      137 /* Invalidate the resultant. */
      138 	     if ^delete_object_info.unreferenced
      139 	     then do;
      140 		rmdb_ctl.saved_res_version_ptr -> based_char8 = "RESTRUCT";
      141 
      142 		last_unreferenced_attribute_ptr = null;
      143 		relation_good_count, save_code = 0;
      144 
      145 		do relation_index = 1 to relation_list.count;
      146 		     relation_ptr = relation_list.relation_ptr (relation_index);
      147 		     relation_good_count = relation_good_count + 1;
      148 		     call process_single_relation;
      149 		     if code ^= 0
      150 		     then do;
      151 			save_code = code;
      152 			goto cleanup_directory;
      153 		     end;				/* do relation_index */
      154 		end;
      155 /* If we get here, we have copied all the relations, so now we need to clean
      156*   up by deleting the copies of the file model and the old relations.       */
      157 
      158 cleanup_directory:	
      159 
      160 /* The real work starts here - hold quits till we're done */
      161 	     quit_occurred = "0"b;			/* BEGIN CRITICAL CODE */
      162 	     on quit quit_occurred = "1"b;
      163 
      164 	     do relation_index = 1 to relation_good_count;
      165 		     relation_ptr = relation_list.relation_ptr (relation_index);
      166 		     fm_ptr = relation.file_model_ptr;
      167 		     call transaction_in_progress;
      168 		     if mstxn_transactions_needed
      169 		     then do;
      170 			on cleanup
      171 			     begin;
      172 			     call mstxn_cleanup;
      173 			     call cleaner;
      174 			     end;
      175 			on any_other call mstxn_any_other;
  1     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the changes made on 85-05-06 and
  1     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
  1    10*     was removed because not all modules need the dbcb, and the
  1    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
  1    12*     list #136).
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 /*
  1    17*                    BEGIN_DESCRIPTION
  1    18*
  1    19*   A generalized routine accessed by all MRDS modules (with the temporary 
  1    20*   (perhaps) exception of restructuring modules) that must start transactions 
  1    21*   if none are present.  The intent is that it be executed as inline code.
  1    22*   The variable mstxn_transactions_needed must be set prior to entering this
  1    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
  1    24*   will suffice.  Included are procedures called mstxn_cleanup and 
  1    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
  1    26*   handlers in the program.  Such handlers should be established just prior to
  1    27*   the inclusion of this code and disabled just following the inclusion of
  1    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
  1    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
  1    30*   include file does the same, because this code might not have been entered 
  1    31*   yet when the handler is invoked.  Directly following this include file the 
  1    32*   contents of mstxn_code should be examined.  If zero, then either the 
  1    33*   transaction was successfully started or no transaction was required.  If the
  1    34*   mrds_finish_transaction code is referenced in general error handling 
  1    35*   situations where the possibility exists that the code in this include file 
  1    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
  1    37*   the beginning of the program.
  1    38*
  1    39*                    END_DESCRIPTION
  1    40*
  1    41*   Written 82-09-28 by Paul W. Benjamin.
  1    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
  1    43*   Modified 83-01-07 by PWB to not reference the dbcb.
  1    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
  1    45*		 any_other handler in situations where the module did
  1    46*		 not start the transaction.
  1    47*   Modified 83-05-05 by PWB to abandon when abort fails.
  1    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
  1    49*		 and abort.
  1    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
  1    51*		 transaction_bj_full conditions.
  1    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
  1    53*		 and to handle transaction_lock_timeout_.
  1    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
  1    55*                     dbcb.user_started_transaction flag.
  1    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
  1    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
  1    58*                     directory >ldd>include and >exl>mrd>i
  1    59**/
  1    60 
  1    61 dcl continue_to_signal_ entry (fixed bin(35));
  1    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
  1    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
  1    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
  1    65 dcl mstxn_code fixed bin (35);
  1    66 dcl mstxn_retries fixed;
  1    67 dcl mstxn_temp_code fixed bin (35);
  1    68 dcl mstxn_transactions_needed bit (1) aligned;
  1    69 dcl user_started_transaction bit (1) aligned;
  1    70 dcl mstxn_txn_id bit (36) aligned;
  1    71 dcl user_transaction_id bit (36) aligned;
  1    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
  1    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
  1    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
  1    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
  1    76 dcl transaction_manager_$handle_conditions entry ();
  1    77 dcl 1 mstxn_condition_info like condition_info;
  1    78 
  2     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*Designed by Matthew C. Pierret, 01/26/82.
  2     6*Coded by Jeffrey D. Ives, 04/30/82.
  2     7*Modified:
  2     8*10/18/82 by Steve Herbst: Names changed.
  2     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  2    10**/
  2    11 
  2    12 dcl (LOWEST_MODE init (1),
  2    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  2    14 
  2    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  2    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  2    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  2    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  2    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  2    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  2    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  2    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  2    23 
  2    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    79 

  1    80 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
  1    81 
  1    82 
  1    83 	mstxn_code = 0;
  1    84 	mstxn_txn_id = "0"b;
  1    85 	
  1    86 	if ^mstxn_transactions_needed			/* only need transactions */
  1    87 	     then goto mstxn_exit;			/* for protected page files */
  1    88 	mstxn_retries = 0;
  1    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
  1    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
  1    91 	     then do;				
  1    92 	     user_started_transaction = "1"b;
  1    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
  1    95 	     goto mstxn_exit;	
  1    96 	end;
  1    97 
  1    98 	user_started_transaction = "0"b;
  1    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
  1   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1   101 
  1   102 mstxn_cleanup:
  1   103 proc;
  1   104 
  1   105 /*  This procedure MUST be called by a cleanup handler. */
  1   106 
  1   107           if mstxn_txn_id ^= "0"b
  1   108           then do;
  1   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
  1   110 	     if mstxn_temp_code ^= 0
  1   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
  1   112 	end;
  1   113 	
  1   114      end mstxn_cleanup;
  1   115 
  1   116 mstxn_any_other:
  1   117 proc;
  1   118 
  1   119 /*  This procedure MUST be called by an any_other handler. */
  1   120 
  1   121           if mstxn_txn_id ^= "0"b
  1   122           then do;
  1   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
  1   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
  1   125 		then do;
  1   126 		mftxn_code = dm_error_$lock_deadlock;
  1   127 		goto mftxn_check_code;
  1   128 	     end;
  1   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
  1   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
  1   131 		then do;
  1   132 		mftxn_code = dm_error_$bj_journal_full;
  1   133 		goto mftxn_check_code;
  1   134 	     end;
  1   135 	     else call transaction_manager_$handle_conditions;
  1   136 	end;
  1   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
  1   138      end mstxn_any_other;
  1   139      
  1   140 mstxn_exit:
  1   141      
  1   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
      176 
      177                               if mstxn_code ^= 0
      178 			then call error (mstxn_code, "Could not start a transaction.");
      179 			end;
      180 		     call switch_names;
      181 
      182 		     if mstxn_transactions_needed
      183 		     then do;
      184 			mftxn_code = 0;
  4     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
  4     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*                    BEGIN_DESCRIPTION
  4    15*
  4    16*   A generalized routine accessed by all MRDS modules that begin and commit 
  4    17*   transactions.  The intent is that it be executed as inline code. It is 
  4    18*   assumed that mrds_start_transaction was executed previously in the 
  4    19*   procedure.  Prior to this include file the program should assign the value 
  4    20*   of its local error code to mftxn_code.  The program utilizing this
  4    21*   include file must supply a function labeled should_rollback that returns
  4    22*   bit (1).  This routine should examine the error code mftxn_code and whether
  4    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
  4    24*   means rollback.  This procedure may choose to simply return "0"b as it 
  4    25*   appears that MRDS will generally NOT rollback transactions.  This routine
  4    26*   does rollback and restart if the before journal is full but only attempts it
  4    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
  4    28*   where any data that was saved prior to the transaction is restored.  A 
  4    29*   procedure consisting solely of a return statement can be supplied if 
  4    30*   necessary.  After execution of this include file, mftxn_code must be
  4    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
  4    32*   then the commit has failed.  Otherwise it will be unchanged.
  4    33*
  4    34*                    END_DESCRIPTION
  4    35*
  4    36*   Written 82-09-30 by Paul W. Benjamin.
  4    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
  4    38*                     error code only when the transaction is in an error state.
  4    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
  4    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
  4    41*		 fails, and to abort rather than rollback when bj is full.
  4    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
  4    43*		 and rollback.
  4    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
  4    45*		 to by the mstxn_any_other procedure.
  4    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
  4    47*                     the user already started his own transaction.
  4    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
  4    49*                     the directory >ldd>include and >exl>mrd>i.
  4    50**/
  4    51 
  4    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
  4    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
  4    54 dcl mftxn_code fixed bin (35);
  4    55 dcl mftxn_temp_code fixed bin (35);
  4    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
  4    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
  4    58 	
  4    59 
  4    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
  4    61 	     then do;
  4    62 	     mftxn_code = 0;
  4    63 	     goto mftxn_exit;
  4    64 	end;
  4    65 mftxn_check_code:
  4    66 	if mftxn_code = 0
  4    67 	     then do;
  4    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
  4    69 	     if mftxn_code ^= 0
  4    70 		then do;
  4    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    72 		if mftxn_temp_code ^= 0
  4    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    74 	     end;
  4    75 	end;
  4    76 	else do;
  4    77 	     call restore_significant_data;
  4    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
  4    79 		& mstxn_retries < 1		
  4    80 		then do;
  4    81 		     mstxn_retries = mstxn_retries + 1;
  4    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    83 		     if mftxn_temp_code ^= 0
  4    84 			then do;
  4    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    86 			if mftxn_temp_code ^= 0
  4    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    88 		     end;
  4    89 		     else do;
  4    90 			mstxn_code = 0;
  4    91 			goto mstxn_exit;		/* go back and try again */
  4    92 		     end;
  4    93 		end;
  4    94 	     else if should_rollback ()		/* let the program decide */
  4    95 		then do;
  4    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    97 		if mftxn_temp_code ^= 0
  4    98 		     then do;
  4    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   100 		     if mftxn_temp_code ^= 0
  4   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   102 		end;
  4   103 		else do;
  4   104 		     mstxn_code = 0;
  4   105 		     goto mstxn_exit;		/* go back and try again */
  4   106 		end;
  4   107 	     end;
  4   108 	     else do;
  4   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   110 		if mftxn_temp_code ^= 0
  4   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   112 	     end;
  4   113 	end;
  4   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
  4   115 mftxn_exit:
  4   116      
  4   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
      185 
      186                               end;
      187 		     end;
      188 	     end;                               /* do relation_index */
      189 
      190 	     if save_code ^= 0
      191 	     then do;
      192 		call mdbm_util_$xref_destroy (rmdb_ctl.crossref_file_info.iocb_ptr, rmdb_ctl.temp_dir_path,   
      193 		     rmdb_ctl.crossref_file_info.name, (""), (0));
      194 	          call error (save_code, error_message);
      195 		end;
      196 	     	     
      197 /* Unlink the unreferenced_attribute structure in the db_model if any of the
      198*   attributes being deleted are unreferenced. */
      199 	     call delete_unreferenced_attribute_list;
      200 
      201 	     call mdbm_util_$inconsistent_reset (dbm_ptr);
      202 	     call process_xref_records;
      203 
      204 	     revert quit;				/* END CRITICAL CODE */
      205 	     if quit_occurred
      206 	     then signal quit;
      207 
      208 	     code = 0;
      209 	     end;
      210 
      211 	call error (code, error_message);
      212 
      213 /*DESCRIPTION
      214*  Error handler and cleanup handler. This is the only way to exit these
      215*  subroutines.
      216**/
      217 
      218 error:
      219      proc (code, msg);
      220 
      221 dcl  code fixed bin (35) parameter;
      222 dcl  msg char (*) parameter;
      223 
      224 	Ocode = code;
      225 	if code = 0
      226 	then Oerror_message = "";
      227 	else Oerror_message = msg;
      228 	goto RETURN_TO_CALLER;
      229      end error;
      230 
      231 RETURN_TO_CALLER:
      232 	call cleaner;
      233 	return;
      234 
      235 cleaner:
      236      proc;
      237 
      238 	if user_area_ptr ^= null
      239 	then do;
      240 	     call release_area_ (user_area_ptr);
      241 	     call mdbm_util_$free_temp_segment (myname, user_area_ptr, (0));
      242 	     end;
      243 
      244 	if mstxn_txn_id ^= "0"b
      245 	then do;
      246 	     call transaction_manager_$abort_txn (mstxn_txn_id, code);
      247 	     if code ^= 0
      248 	     then call transaction_manager_$abandon_txn (mstxn_txn_id, (0));
      249 	     end;
      250 
      251 	return;
      252      end cleaner;
      253 
      254 restore_significant_data:
      255      proc;
      256 	return;
      257      end restore_significant_data;
      258 
      259 should_rollback:
      260      proc returns (bit (1) aligned);
      261 	return ("0"b);
      262      end should_rollback;
      263 
      264 make_name:
      265      proc (input_name) returns (char (33));
      266 
      267 dcl  input_name char (*) parameter;
      268 
      269 	return (OBJECT_HEAD || input_name);
      270      end make_name;
      271 
      272 unmake_name:
      273      proc (input_name) returns (char (32));
      274 
      275 dcl  input_name char (*) parameter;
      276 
      277 	return (substr (input_name, 2, 32));
      278      end unmake_name;
      279 
      280 /*DESCRIPTION
      281*  This subroutine ensures that no transaction is in progress, and sets a flag
      282*  bit for use later. */
      283 
      284 transaction_in_progress:
      285      proc;
      286 
      287 	if db_model.db_type_flags.transactions_needed
      288 	then do;
      289 	     mstxn_transactions_needed = "1"b;
      290 	     call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
      291 	     if mstxn_code = 0
      292 	     then do;
      293 		mstxn_txn_id = "0"b;
      294 		call error (error_table_$action_not_performed,
      295 		     "A transaction is in progress. Commit or abort the transaction and try the operation again.");
      296 		end;
      297 	     end;
      298 	else mstxn_transactions_needed = "0"b;
      299 
      300 	return;
      301      end transaction_in_progress;
      302 
      303 
      304 /*DESCRIPTION
      305*  This subroutine checks all attributes in the attribute_list structure to
      306*  ensure that none of the requested attributes are generated attributes
      307*  (attributes that don't really exist, but are present because for each domain
      308*  there is a generated attribute with the same name). These cannot be deleted. */
      309 
      310 check_for_deletion_of_generated_attributes:
      311      proc;
      312 
      313 	do attribute_list_idx = 1 to attribute_list.count;
      314 	     di_ptr = ptr (dbm_ptr, attribute_list.domain_info_ptr (attribute_list_idx));
      315 	     if domain_info.name = unmake_name (attribute_list.name (attribute_list_idx))
      316 	     then if delete_object_info.inhibit_errors
      317 		then attribute_list.name (attribute_list_idx) = "";
      318 		else call error (error_table_$unsupported_operation,
      319 			"Attempt to delete a generated attribute " || domain_info.name);
      320 	     end;					/* do attribute_list_idx */
      321 
      322 	return;
      323      end check_for_deletion_of_generated_attributes;
      324 
      325 check_for_deletion_of_primary_key:
      326      proc;
      327 
      328 dcl attr_idx fixed bin;
      329 dcl deletion_attributes char (500);
      330 dcl no_primary_key bit (1) aligned;
      331 
      332 /* Check to make sure that we wouldn't be getting rid of a primary key. */
      333 
      334           deletion_attributes = "";
      335 	no_primary_key = "1"b;
      336 	do attribute_list_idx = 1 to attribute_list.count;
      337 	     attribute_ptr = attribute_list.attribute_ptr (attribute_list_idx);
      338 	     if attribute_ptr ^= null then do attr_idx = 1 to attribute.count;
      339 		relation_ptr = relation_list.relation_ptr (attribute.relation_idx (attr_idx));
      340 		do attribute_idx = 1 to relation.attribute_count;
      341 		     if relation.attribute(attribute_idx).flags.part_of_key 
      342 			& relation.attribute_names (attribute_idx) = attribute_list.name (attribute_list_idx)
      343 		     then do;
      344 			no_primary_key = "0"b;
      345 			relation.attribute(attribute_idx).flags.to_be_deleted = "1"b;
      346 			end;
      347 		end;
      348 	     end;
      349 	end;
      350 	if ^no_primary_key 
      351 	then do relation_index = 1 to relation_list.count while (^no_primary_key);
      352 	     relation_ptr = relation_list.relation_ptr(relation_index);
      353 	     do attribute_idx = 1 to relation.attribute_count while (^no_primary_key);
      354 		if relation.attribute(attribute_idx).flags.part_of_key 
      355 		then if ^relation.attribute(attribute_idx).flags.to_be_deleted
      356 		     then no_primary_key = "1"b;
      357 		     else do;
      358 			attribute_name = unmake_name (relation.attribute_names (attribute_idx));
      359 			relation.attribute(attribute_idx).flags.to_be_deleted = "0"b;
      360 			deletion_attributes = rtrim(deletion_attributes) || " " || rtrim(attribute_name);
      361 			end;
      362 		end;
      363 	     if ^no_primary_key 
      364 	     then do;
      365 		code = mrds_error_$no_primary_key;
      366 		call error (code, "Deletion of the attribute(s) " || rtrim(deletion_attributes) || " would result in no primary key in relation "  || rtrim(relation.name) || ".");
      367 		end;
      368 	end;
      369 	end check_for_deletion_of_primary_key;
      370 
      371 /*DESCRIPTION
      372*  Delete all the attribute crossreference records, and update all the domain
      373*  records to indicate that the attributes in attribute_list don't exist so
      374*  therefore cannot be referenced by a domain. */
      375 
      376 process_xref_records:
      377      proc;
      378 
      379 	do attribute_list_idx = 1 to attribute_list.count;
      380 	     if attribute_list.name (attribute_list_idx) ^= ""
      381 	     then do;
      382 		attribute_name = unmake_name (attribute_list.name (attribute_list_idx));
      383 		call mdbm_util_$xref_delete_record (local_iocb, ATTRIBUTE_KEY_HEAD, attribute_name, error_message,
      384 		     code);
      385 		if code ^= 0
      386 		then if (code ^= error_table_$no_record) & (^delete_object_info.inhibit_errors)
      387 		     then call error (code, error_message);
      388 
      389 		di_ptr = ptr (dbm_ptr, attribute_list.domain_info_ptr (attribute_list_idx));
      390 		call mdbm_util_$xref_dereference (local_iocb, DOMAIN_KEY_HEAD, (domain_info.name), attribute_name,
      391 		     reference_count , error_message, code);
      392 		if code ^= 0
      393 		then if ^delete_object_info.inhibit_errors
      394 		     then call error (code, error_message);
      395 
      396 		if reference_count <= 1 
      397 		then domain_info.unreferenced = "1"b;
      398 		
      399 		call rmdb_add_rmdb_history (dbm_ptr, RMDB_ATTR_TYPE, (domain_info.name), RMDB_DEL_ATTR_OP, attribute_name, (""), (0));
      400 		end;
      401 	     end;					/* do attribute_list_idx */
      402 
      403      end process_xref_records;
      404 
      405 /*DESCRIPTION
      406*  This subroutine frees the unreferenced_attribute structure in the db_model for
      407*  each attribute in the attribute_list. It assumes that each of the entries in
      408*  that list are unreferenced attributes. */
      409 
      410 delete_unreferenced_attribute_list:
      411      proc;
      412 
      413 	do attribute_list_idx = 1 to attribute_list.count;
      414 	     if (attribute_list.name (attribute_list_idx) ^= "")
      415 		& (attribute_list.attribute_ptr (attribute_list_idx) = null)
      416 	     then do;
      417 		di_ptr = ptr (dbm_ptr, attribute_list.domain_info_ptr (attribute_list_idx));
      418 		attribute_name = unmake_name (attribute_list.name (attribute_list_idx));
      419 		previous_ptr, save_ptr = null;
      420 		do ua_ptr = ptr (dbm_ptr, db_model.unreferenced_attribute_ptr)
      421 		     repeat ptr (dbm_ptr, unreferenced_attribute.fwd_thread)
      422 		     while ((rel (ua_ptr) ^= NULL_OFFSET) & (save_ptr = null));
      423 
      424 		     if attribute_name = unreferenced_attribute.name
      425 		     then save_ptr = ua_ptr;
      426 		     else previous_ptr = ua_ptr;
      427 		     end;				/* do ua_ptr */
      428 
      429 		if save_ptr ^= null
      430 		then do;
      431 		     if previous_ptr = null
      432 		     then db_model.unreferenced_attribute_ptr = save_ptr -> unreferenced_attribute.fwd_thread;
      433 		     else previous_ptr -> unreferenced_attribute.fwd_thread =
      434 			     save_ptr -> unreferenced_attribute.fwd_thread;
      435 
      436 		     free save_ptr -> unreferenced_attribute in (dbm_area);
      437 		     end;
      438 
      439 		call rmdb_add_rmdb_history (dbm_ptr, RMDB_ATTR_TYPE, (domain_info.name), RMDB_DEL_ATTR_OP, attribute_name, (""), (0));
      440 
      441 		end;
      442 	     end;					/* do attribute_list_idx */
      443 
      444 	return;
      445      end delete_unreferenced_attribute_list;
      446 
      447 /*DESCRIPTION
      448*  Create an attribute_list structure populated by all the entries in the
      449*  unreferenced_attribute list in the db_model. */
      450 
      451 make_unreferenced_attribute_list:
      452      proc;
      453 
      454 /* Count up the unreferenced attributes */
      455 	attribute_list_count = 0;
      456 	do ua_ptr = ptr (dbm_ptr, db_model.unreferenced_attribute_ptr)
      457 	     repeat ptr (dbm_ptr, unreferenced_attribute.fwd_thread) while (rel (ua_ptr) ^= NULL_OFFSET);
      458 	     attribute_list_count = attribute_list_count + 1;
      459 	     end;					/* do ua_ptr */
      460 
      461 	if attribute_list_count = 0
      462 	then if delete_object_info.inhibit_errors
      463 	     then call error (0, "");
      464 	     else call error (mrds_error_$no_unref_attr, "");
      465 
      466 /* Create the attribute_list structure and populate it. */
      467 	allocate attribute_list in (user_area) set (attribute_list_ptr);
      468 	attribute_list_count = 0;
      469 	do ua_ptr = ptr (dbm_ptr, db_model.unreferenced_attribute_ptr)
      470 	     repeat ptr (dbm_ptr, unreferenced_attribute.fwd_thread) while (rel (ua_ptr) ^= NULL_OFFSET);
      471 
      472 	     attribute_list_count = attribute_list_count + 1;
      473 	     attribute_list.name (attribute_list_count) = make_name ((unreferenced_attribute.name));
      474 	     attribute_list.attribute_ptr (attribute_list_count) = null;
      475 	     attribute_list.domain_info_ptr (attribute_list_count) = unreferenced_attribute.domain_ptr;
      476 	     end;					/* do ua_ptr */
      477 
      478 	return;
      479      end make_unreferenced_attribute_list;
      480 
      481 /*DESCRIPTION
      482*  Print the information for the -check option. Optionally query to check for
      483*  deletion. */
      484 
      485 print_information:
      486      proc;
      487 
      488 dcl  cancel_attribute bit (attribute_list.count);
      489 dcl  first_cancel_attribute fixed bin;
      490 
      491 	cancel_attribute = "0"b;
      492 	first_cancel_attribute = 0;
      493 
      494 	do attribute_list_idx = 1 to attribute_list.count;
      495 	     if attribute_list.name (attribute_list_idx) ^= ""
      496 	     then do;
      497 		attribute_ptr = attribute_list.attribute_ptr (attribute_list_idx);
      498 		attribute_name = unmake_name (attribute_list.name (attribute_list_idx));
      499 
      500 		if delete_object_info.check
      501 		then do;
      502 		     if attribute_ptr = null
      503 		     then call ioa_$ioa_switch (delete_object_info.check_iocb_ptr, "^/Attribute ""^a"" is unreferenced.",
      504 			attribute_name);
      505 		     else do;
      506 			call ioa_$ioa_switch_nnl (delete_object_info.check_iocb_ptr,
      507 			     "^/Attribute ""^a"" is used in relation^[s^]", attribute_name, attribute.count > 1);
      508 			do attribute_idx = 1 to attribute.count;
      509 			     relation_name = unmake_name (relation_list.name (attribute.relation_idx (attribute_idx)));
      510 			     if attribute_idx = 1
      511 			     then call ioa_$ioa_switch_nnl (delete_object_info.check_iocb_ptr, " ""^a""", relation_name);
      512 			     else call ioa_$ioa_switch_nnl (delete_object_info.check_iocb_ptr, "^[ and^;,^] ""^a""",
      513 				(attribute.count = attribute_idx), relation_name);
      514 			     end;			/* do attribute_idx */
      515 			call ioa_$ioa_switch_nnl (delete_object_info.check_iocb_ptr, ".^/");
      516 			end;
      517 		     end;
      518 		
      519 		if (delete_object_info.check & delete_object_info.long = UNSPEC) then;
      520 		else if ^delete_object_info.force 
      521 		then if ^query ()
      522 		     then do;
      523 			substr (cancel_attribute, attribute_list_idx, 1) = "1"b;
      524 			if first_cancel_attribute = 0
      525 			then first_cancel_attribute = attribute_list_idx;
      526 			end;
      527 
      528 		end;
      529 	     end;					/* do attribute_list_idx */
      530 
      531 	if first_cancel_attribute ^= 0
      532 	then call recalculate_attributes_deleted;
      533 
      534 	return;
      535 
      536 query:
      537      proc returns (bit (1) aligned);
      538 
      539 dcl  answer char (3);
      540 
      541 	call command_query_ (addr (query_info), answer, delete_object_info.request_name,
      542 	     "     Do you wish to delete the attribute " || rtrim(attribute_name) || " ?");
      543 	if answer = "no"
      544 	then return ("0"b);
      545 	else return ("1"b);
      546 
      547      end query;
      548 
      549 /*DESCRIPTION
      550*  If any of delete operations have been cancelled, this subroutine recalculates
      551*  which attributes of which relations have to be deleted. */
      552 
      553 recalculate_attributes_deleted:
      554      proc;
      555 
      556 dcl  have_attributes_to_process bit (1) aligned;
      557 dcl  position fixed bin;
      558 dcl  search_name char (33);
      559 
      560 /* First mark all attributes in all referenced relations undeleted. */
      561 	do relation_index = 1 to relation_list.count;
      562 	     relation_ptr = relation_list.relation_ptr (relation_index);
      563 	     unspec (relation.attribute (*).flags) = "0"b;
      564 	     end;					/* do relation_index */
      565 
      566 /* Now walk through the attribute list, marking each attribute in the relation
      567*   structures deleted or not. */
      568 	have_attributes_to_process = "0"b;
      569 	do attribute_list_idx = 1 to attribute_list.count;
      570 	     if substr (cancel_attribute, attribute_list_idx, 1)
      571 	     then attribute_list.name (attribute_list_idx) = "";
      572 	     else do;
      573 		have_attributes_to_process = "1"b;
      574 		attribute_ptr = attribute_list.attribute_ptr (attribute_list_idx);
      575 		if attribute_ptr ^= null
      576 		then do;
      577 		     search_name = attribute_list.name (attribute_list_idx);
      578 		     do attribute_idx = 1 to attribute.count;
      579 			relation_ptr = relation_list.relation_ptr (attribute.relation_idx (attribute_idx));
      580 			position = index (relation_attribute_names, search_name);
      581 			if position ^= 0
      582 			then do;
      583 			     position = divide (position, 33, 17, 0) + 1;
      584 			     relation.attribute (position).flags.delete = "1"b;
      585 			     end;
      586 			end;			/* do attribute_idx */
      587 		     end;
      588 		end;
      589 	     end;					/* do attribute_list_idx */
      590 
      591 	if ^have_attributes_to_process
      592 	then call error (0, "");
      593 
      594 	return;
      595      end recalculate_attributes_deleted;
      596 
      597      end print_information;
      598 
      599 /*DESCRIPTION
      600*  This subroutine either deletes all information pertaining to a relation (if
      601*  all attributes are deleted) or reformats it (if only some attributes are
      602*  deleted. */
      603 
      604 process_single_relation:
      605      proc;
      606 
      607 	if all_attributes_are_deleted ()
      608 	then call delete_relation_information;
      609 	else call rmdb_copy_relation (dbm_ptr, db_path, rmdb_ctl.temp_dir_path, addr (rmdb_ctl.relmgr_entries),
      610 		relation_ptr, error_message, code);
      611 	return;
      612      end process_single_relation;
      613 
      614 /* DESCRIPTION
      615**  This module was brought over from rmdb_copy_relation since we can't really 
      616**  clean up before we have finished with ALL the relations.  It performs 
      617**  several steps;  initiate the copy of the file_model (.k), get the name of
      618**  the associated relation, copy contents of new file_model to the old one,
      619**  move the data from the old file to the new one, delete the old relation,
      620**  rename the new relation to the old name (or physically copy to old name if
      621**  dm file), remove the copy of the file_info from the db_model and free the
      622**  space.  Finally, we must update the xref file to show that the relation is
      623**  no longer in the attribute key record. */
      624 	 
      625 
      626 switch_names:
      627      proc;
      628 
      629 dcl  1 local_status_branch like status_branch;
      630 dcl  create_model_name char (32);
      631 dcl  create_relation_name char (32);
      632 dcl  data_acl_ptr ptr;
      633 dcl  r_index fixed bin;
      634 dcl  index builtin;
      635 dcl  move_string char (move_string_length) based;
      636 dcl  move_string_length fixed bin (35);
      637 dcl  new_model_bit_count fixed bin (24);
      638 dcl  new_file_model_ptr ptr;
      639 dcl  last_file_info_ptr ptr;
      640 dcl  1 co aligned like copy_options;
      641 dcl  cvds bit (1) aligned;
      642 dcl  ivds bit (1) aligned;
      643 dcl  to_char fixed bin;
      644 
      645           create_model_name = rtrim (relation.name) || ".k";
      646 	status_area_ptr = user_area_ptr;
      647 	status_ptr = addr (local_status_branch);
      648 	call hcs_$status_ (db_path, create_model_name, 0, status_ptr, status_area_ptr, code);
      649 	to_char = index(status_entry_names (1), ".m");
      650 	to_char = to_char -1;
      651 	create_relation_name = rtrim(substr(status_entry_names (1), 1, to_char));
      652           call initiate_file_ (db_path, create_model_name, RW_ACCESS, new_file_model_ptr, new_model_bit_count, code);
      653 	if code ^= 0
      654           then call error (code, "While initiating the new_file_model for relation " || relation.name);
      655 	rmdb_relmgr_entries_ptr = addr (rmdb_ctl.relmgr_entries);
      656 
      657 /* Move the contents of the new relation.m to old relation.m. */
      658 	if (file_model.file_model_copy_good & file_model.relation_copy_good & save_code = 0)  
      659 	then do;
      660 	     move_string_length = divide (new_model_bit_count, 9, 35, 0);
      661 	     fm_ptr -> move_string = new_file_model_ptr -> move_string;
      662 
      663 /* Move the contents of the data relation. First we must get the attributes of
      664*   the old data file (ACL, mode switches) and move them to the new data file. */
      665 	     data_acl_ptr = null;
      666 	     call fs_util_$list_acl (db_path, relation.name, GENERAL_ACL_VERSION_1, user_area_ptr, data_acl_ptr, code);
      667 	     if code ^= 0
      668 	     then call error (code, "Getting the ACL to relation " || relation.name);
      669 
      670 	     call fs_util_$replace_acl (db_path, create_relation_name, data_acl_ptr, "1"b, code);
      671 	     if code ^= 0
      672 	     then call error (code, "Setting the ACL on relation " || create_relation_name);
      673 
      674 	     cvds, ivds = "0"b;
      675 	     call fs_util_$get_switch (db_path, relation.name, "complete_volume_dump", cvds, (0));
      676 	     call fs_util_$get_switch (db_path, relation.name, "incremental_volume_dump", ivds, (0));
      677 	     
      678 	     call fs_util_$set_switch (db_path, create_relation_name, "complete_volume_dump", cvds, (0));
      679 	     call fs_util_$set_switch (db_path, create_relation_name, "incremental_volume_dump", ivds, (0));
      680 
      681 /* Now get rid of the old data file. */
      682 	     call rmdb_relmgr_entries.delete_relation (db_path, relation.name, code);
      683 	     if code ^= 0
      684 	     then call error (code, "Deleting relation " || relation.name);
      685 
      686 /* If we are dealing with DM files, we need to physically copy the relation
      687*   file. If not, then we can simply rename the new one to the old name. */
      688 	     if mstxn_transactions_needed
      689 	     then do;
      690 		co.version = COPY_OPTIONS_VERSION_1;
      691 		co.caller_name = myname;
      692 		co.source_dir, co.target_dir = db_path;
      693 		co.source_name = create_relation_name;
      694 		co.target_name = relation.name;
      695 
      696 		unspec (co.flags) = "0"b;
      697 		unspec (co.copy_items) = "0"b;
      698 
      699 		call fs_util_$copy (addr (co), code);
      700 		if code ^= 0
      701 		then call error (code, "Copying the new data file onto the old data file for relation " || relation.name);
      702 		end;
      703 	     else do;
      704 		call hcs_$chname_file (db_path, create_relation_name, create_relation_name, relation.name, code);
      705 		if code ^= 0
      706 		then call error (code, "Renaming relation file from " || rtrim (create_relation_name) || " to " || relation.name);
      707 		end; 
      708 	     end;                      /* file_model and relation good */
      709 
      710 /* Since we renamed the new to the old, we can get rid of the new names. */
      711 /* We also replaced the original file_model with the new_one. */
      712 	call rmdb_relmgr_entries.delete_relation (db_path, create_relation_name, (0));
      713 	call delete_$path (db_path, create_model_name, "101111"b, myname, (0));
      714 
      715 /* Take the copy of the file_model out of the db_model */
      716 	if relation.copy_file_model_ptr ^= null
      717           then do;
      718 	     do fi_ptr = ptr (dbm_ptr, db_model.file_ptr) repeat ptr (dbm_ptr, file_info.fwd_ptr)
      719 		while (rel (fi_ptr) ^= rel (copy_file_model_ptr));
      720 		last_file_info_ptr = fi_ptr;
      721 		end;
      722 
      723 	     last_file_info_ptr -> file_info.fwd_ptr = copy_file_model_ptr -> file_info.fwd_ptr;
      724 	     free relation.copy_file_model_ptr -> file_info in (dbm_area);
      725 	     end;
      726 	
      727 	if (code ^= 0)
      728 	then if ^delete_object_info.inhibit_errors
      729 	     then call error (code, error_message);
      730 	     else ;				/* ignore the error */
      731 	else if save_code = 0
      732 		
      733 /* Now we have to update the crossreference file records for all attributes that
      734*   were deleted in this relation. */
      735 	     then do r_index = 1 to relation.attribute_count;
      736 		if relation.attribute (r_index).flags.delete
      737 		then do;
      738 		     attribute_name = unmake_name (relation.attribute_names (r_index));
      739 		     call mdbm_util_$xref_dereference (local_iocb, ATTRIBUTE_KEY_HEAD, attribute_name, relation.name,
      740 			reference_count, error_message, code);
      741 		     if (code ^= 0) & ^(delete_object_info.inhibit_errors)
      742 		     then call error (code, error_message);
      743 
      744 		     end;
      745 		end;				/* do relation_index */
      746 		
      747 	return;
      748      end switch_names;
      749 
      750 /*DESCRIPTION
      751*  This function searches the attribute list of the current relation and returns
      752*  true if all the attributes are marked for deletion. */
      753 all_attributes_are_deleted:
      754      proc returns (bit (1) aligned);
      755 
      756 dcl  attribute_idx fixed bin;
      757 
      758 	do attribute_idx = 1 to relation.attribute_count;
      759 	     if ^relation.attribute (attribute_idx).flags.delete
      760 	     then return ("0"b);
      761 	     end;					/* do relation_index */
      762 
      763 	return ("1"b);
      764      end all_attributes_are_deleted;
      765 
      766 
      767 delete_relation_information:
      768      proc;
      769 
      770 /* Unlink the file_info structure. */
      771 	save_ptr, previous_ptr = null;
      772 	do fi_ptr = ptr (dbm_ptr, db_model.file_ptr) repeat ptr (dbm_ptr, file_info.fwd_ptr)
      773 	     while ((save_ptr = null) & (rel (fi_ptr) ^= NULL_OFFSET));
      774 	     if file_info.file_name = relation.name
      775 	     then save_ptr = fi_ptr;
      776 	     else previous_ptr = fi_ptr;
      777 	     end;					/* do fi_ptr */
      778 
      779 	if save_ptr ^= null
      780 	then do;
      781 	     if previous_ptr = null
      782 	     then db_model.file_ptr = save_ptr -> file_info.fwd_ptr;
      783 	     else previous_ptr -> file_info.fwd_ptr = save_ptr -> file_info.fwd_ptr;
      784 
      785 	     free save_ptr -> file_info in (dbm_area);
      786 
      787 	     call mdbm_util_$xref_delete_record (local_iocb, RELATION_KEY_HEAD, relation.name, error_message, (0));
      788 	     end;
      789 
      790 /* Now delete the relation and relation.m files. */
      791 	call delete_file (relation.name);
      792 	call delete_file (rtrim (relation.name) || ".m");
      793 
      794 	db_model.num_blk_files = db_model.num_blk_files - 1;
      795 	db_model.num_rels = db_model.num_rels - 1;
      796 
      797 	call rmdb_add_rmdb_history (dbm_ptr, RMDB_REL_TYPE, relation.name, RMDB_DEL_REL_OP, "", (""), (0));
      798 	return;
      799 
      800 delete_file:
      801      proc (file_name);
      802 
      803 dcl  delete_$path entry (char (*), char (*), bit (36) aligned, char (*), fixed bin (35));
      804 dcl  file_name char (*) parameter;
      805 dcl  fs_util_$delentry_file entry (char (*), char (*), fixed bin (35));
      806 
      807 	call fs_util_$delentry_file (db_path, file_name, code);
      808 	if code = error_table_$unsupported_operation
      809 	then call delete_$path (db_path, file_name, "101111"b, myname, code);
      810 
      811 	if (code ^= 0) & (^delete_object_info.inhibit_errors)
      812 	then call error (code, "Deleting " || file_name);
      813 
      814 	return;
      815      end delete_file;
      816 
      817      end delete_relation_information;
      818 
      819 
  5     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  5     2*
  5     3*   Values for the "access mode" argument so often used in hardcore
  5     4*   James R. Davis 26 Jan 81  MCR 4844
  5     5*   Added constants for SM access 4/28/82 Jay Pattin
  5     6*   Added text strings 03/19/85 Chris Jones
  5     7**/
  5     8 
  5     9 
  5    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  5    11 dcl	(
  5    12 	N_ACCESS		   init ("000"b),
  5    13 	R_ACCESS		   init ("100"b),
  5    14 	E_ACCESS		   init ("010"b),
  5    15 	W_ACCESS		   init ("001"b),
  5    16 	RE_ACCESS		   init ("110"b),
  5    17 	REW_ACCESS	   init ("111"b),
  5    18 	RW_ACCESS		   init ("101"b),
  5    19 	S_ACCESS		   init ("100"b),
  5    20 	M_ACCESS		   init ("010"b),
  5    21 	A_ACCESS		   init ("001"b),
  5    22 	SA_ACCESS		   init ("101"b),
  5    23 	SM_ACCESS		   init ("110"b),
  5    24 	SMA_ACCESS	   init ("111"b)
  5    25 	)		   bit (3) internal static options (constant);
  5    26 
  5    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  5    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  5    29 
  5    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  5    31 			   static options (constant);
  5    32 
  5    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  5    34 			   static options (constant);
  5    35 
  5    36 dcl	(
  5    37 	N_ACCESS_BIN	   init (00000b),
  5    38 	R_ACCESS_BIN	   init (01000b),
  5    39 	E_ACCESS_BIN	   init (00100b),
  5    40 	W_ACCESS_BIN	   init (00010b),
  5    41 	RW_ACCESS_BIN	   init (01010b),
  5    42 	RE_ACCESS_BIN	   init (01100b),
  5    43 	REW_ACCESS_BIN	   init (01110b),
  5    44 	S_ACCESS_BIN	   init (01000b),
  5    45 	M_ACCESS_BIN	   init (00010b),
  5    46 	A_ACCESS_BIN	   init (00001b),
  5    47 	SA_ACCESS_BIN	   init (01001b),
  5    48 	SM_ACCESS_BIN	   init (01010b),
  5    49 	SMA_ACCESS_BIN	   init (01011b)
  5    50 	)		   fixed bin (5) internal static options (constant);
  5    51 
  5    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      820 
  6     1 /* Begin include file -- acl_structures.incl.pl1 BIM 3/82 */
  6     2 /* format: style3,indcomtxt,idind30 */
  6     3 
  6     4 declare   acl_ptr                       pointer;
  6     5 declare   acl_count                     fixed bin;
  6     6 
  6     7 declare 1 general_acl                   aligned based (acl_ptr), /* for fs_util_ */
  6     8           2 version                     char (8) aligned,
  6     9           2 count                       fixed bin,
  6    10           2 entries                     (acl_count refer (general_acl.count)) aligned like general_acl_entry;
  6    11 
  6    12 declare 1 general_acl_entry             based,
  6    13           2 access_name                 character (32) unaligned,
  6    14           2 mode                        bit (36) aligned,
  6    15           2 status_code                 fixed bin (35);
  6    16 
  6    17 
  6    18 declare 1 general_extended_acl          aligned based (acl_ptr), /* for fs_util_ */
  6    19           2 version                     char (8) aligned,
  6    20           2 count                       fixed bin,
  6    21           2 entries                     (acl_count refer (general_extended_acl.count)) aligned like general_extended_acl_entry;
  6    22 
  6    23 declare 1 general_extended_acl_entry    aligned based,
  6    24           2 access_name                 character (32) unaligned,
  6    25           2 mode                        bit (36) aligned,
  6    26           2 extended_mode               bit (36) aligned,
  6    27           2 status_code                 fixed bin (35);
  6    28 
  6    29 
  6    30 declare 1 general_delete_acl            aligned based (acl_ptr), /* for file_system_ */
  6    31           2 version                     char (8) aligned,
  6    32           2 count                       fixed bin,
  6    33           2 entries                     (acl_count refer (general_delete_acl.count)) aligned like delete_acl_entry;
  6    34 
  6    35 declare 1 general_delete_acl_entry      aligned based,
  6    36           2 access_name                 character (32) unaligned,
  6    37           2 status_code                 fixed bin (35);
  6    38 
  6    39 
  6    40 declare 1 segment_acl                   aligned based (acl_ptr),
  6    41           2 version                     fixed bin,
  6    42           2 count                       fixed bin,
  6    43           2 entries                     (acl_count refer (segment_acl.count)) aligned like segment_acl_entry;
  6    44 
  6    45 declare 1 segment_acl_entry             like general_extended_acl_entry aligned based;
  6    46 declare 1 segment_acl_array             (acl_count) aligned like segment_acl_entry based (acl_ptr);
  6    47 
  6    48 
  6    49 declare 1 directory_acl                 aligned based (acl_ptr),
  6    50           2 version                     fixed bin,
  6    51           2 count                       fixed bin,
  6    52           2 entries                     (acl_count refer (directory_acl.count)) aligned like directory_acl_entry;
  6    53 
  6    54 declare 1 directory_acl_entry           like general_acl_entry aligned based;
  6    55 declare 1 directory_acl_array           (acl_count) aligned like directory_acl_entry based (acl_ptr);
  6    56 
  6    57 
  6    58 declare 1 delete_acl                    based (acl_ptr) aligned,
  6    59           2 version                     fixed bin,
  6    60           2 count                       fixed bin,
  6    61           2 entries                     (acl_count refer (delete_acl.count)) aligned like delete_acl_entry;
  6    62 
  6    63 declare 1 delete_acl_entry              like general_delete_acl_entry aligned based;
  6    64 declare 1 delete_acl_array              (acl_count) aligned like delete_acl_entry based (acl_ptr);
  6    65 
  6    66 
  6    67 declare  (SEG_ACL_VERSION_1             init ("sga1"),
  6    68           DIR_ACL_VERSION_1             init ("dra1"),
  6    69           DELETE_ACL_VERSION_1          init ("dla1"))
  6    70                                         char (4) int static options (constant);
  6    71 
  6    72 declare  (GENERAL_ACL_VERSION_1         init ("gacl001"),
  6    73           GENERAL_EXTENDED_ACL_VERSION_1 init ("gxacl001"),
  6    74           GENERAL_DELETE_ACL_VERSION_1  init ("gdacl001"))
  6    75                                         char (8) internal static options (constant);
  6    76 
  6    77 declare   ACL_VERSION_1                 fixed bin init (1) int static options (constant);
  6    78 
  6    79 /* End include file acl_structures.incl.pl1 */
      821 
  7     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  7     2 
  7     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  7     4 
  7     5 dcl  area_infop ptr;
  7     6 
  7     7 dcl 1 area_info aligned based (area_infop),
  7     8     2 version fixed bin,				/* version number for this structure is 1 */
  7     9     2 control aligned like area_control,		/* control bits for the area */
  7    10     2 owner char (32) unal,				/* creator of the area */
  7    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  7    12     2 size fixed bin (18),				/* size of the area in words */
  7    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  7    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  7    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  7    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  7    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  7    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  7    19 
  7    20 dcl 1 area_control aligned based,
  7    21     2 extend bit (1) unal,				/* says area is extensible */
  7    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  7    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  7    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  7    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  7    26     2 system bit (1) unal,				/* says area is managed by system */
  7    27     2 pad bit (30) unal;
  7    28 
  7    29 /* END INCLUDE FILE area_info.incl.pl1 */
      822 
  8     1 /* BEGIN INCLUDE FILE:  copy_flags.incl.pl1 */
  8     2 
  8     3 /* Flags for attributes that should/may be copied by the copy_ subroutine. This include file is
  8     4*   required by suffix_info.incl.pl1 and copy_options.incl.pl1
  8     5*
  8     6*   Jay Pattin 6/23/83 */
  8     7 
  8     8 declare   1 copy_flags                  aligned based,      /* ON means that this attribute may be copied by copy_ */
  8     9           2 names                       bit (1) unaligned,
  8    10           2 acl                         bit (1) unaligned,
  8    11           2 ring_brackets               bit (1) unaligned,
  8    12           2 max_length                  bit (1) unaligned,
  8    13           2 copy_switch                 bit (1) unaligned,
  8    14           2 safety_switch               bit (1) unaligned,
  8    15           2 dumper_switches             bit (1) unaligned,
  8    16           2 entry_bound                 bit (1) unaligned,  /* only for vanilla object segments */
  8    17           2 extend                      bit (1) unaligned,  /* copy_ may append to end of existing object */
  8    18           2 update                      bit (1) unaligned,  /* copy_ may replace contents of existing object */
  8    19           2 mbz                         bit (26) unaligned;
  8    20 
  8    21 /* END INCLUDE FILE:  copy_flags.incl.pl1 */
      823 
  9     1 /* BEGIN INCLUDE FILE: copy_options.incl.pl1 */
  9     2 
  9     3 /* This structure declares the input structure used by the copy_ subroutine.
  9     4*
  9     5*   NOTE: This include file depends on declarations in the include file
  9     6*   copy_flags.incl.pl1.
  9     7*
  9     8*   Jay Pattin 6/1/83 */
  9     9 
  9    10 declare   copy_options_ptr              ptr;
  9    11 
  9    12 declare   1 copy_options                aligned based (copy_options_ptr),
  9    13           2 version                     char (8),           /* currently COPY_OPTIONS_VERSION_1 */
  9    14           2 caller_name                 char (32) unal,     /* Used in nd_handler_ call */
  9    15           2 source_dir                  char (168) unal,
  9    16           2 source_name                 char (32) unal,
  9    17           2 target_dir                  char (168) unal,
  9    18           2 target_name                 char (32) unal,
  9    19           2 flags,
  9    20             3 no_name_dup               bit (1) unaligned,  /* ON = don't call nd_handler_ */
  9    21             3 raw                       bit (1) unaligned,  /* ON = don't call object_type_, use hcs_ */
  9    22             3 force                     bit (1) unaligned,  /* ON = delete or force access to target */
  9    23             3 delete                    bit (1) unaligned,  /* ON = delete original after copy (for move) */
  9    24             3 target_err_switch         bit (1) unaligned,
  9    25             3 mbz                       bit (31) unaligned,
  9    26           2 copy_items                  like copy_flags;    /* see copy_flags.incl.pl1 */
  9    27 
  9    28 declare   COPY_OPTIONS_VERSION_1        char (8) static options (constant) init ("CPOPT001");
  9    29 
  9    30 /* END INCLUDE FILE: copy_options.incl.pl1 */
      824 
 10     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
 10     2 
 10     3 
 10     4 /****^  HISTORY COMMENTS:
 10     5*  1) change(79-02-01,Gray), approve(), audit(), install():
 10     6*     modified to save space occupied by model
 10     7*  2) change(80-11-03,Gray), approve(), audit(), install():
 10     8*     to add mdbm_secured bit in db_model
 10     9*  3) change(82-04-09,Davids), approve(), audit(), install():
 10    10*     collapsed the following into an unused_offset array:
 10    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
 10    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
 10    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
 10    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
 10    15*       unused_1
 10    16*     Also changed the name of unused_2 to restructuring_history_offset
 10    17*     and changed the comment on the changer structure to indicate
 10    18*     that it will contain on database creation information.
 10    19*  4) change(82-04-14,Davids), approve(), audit(), install():
 10    20*     used one of the unused_offsets to point to a message which indicates
 10    21*     why the db is inconsistent. The offset will be null when the db is created
 10    22*     and set the first time the message is used. this is so it will be
 10    23*     consistent with existing data bases. Also added the message structure.
 10    24*  5) change(82-04-28,Davids), approve(), audit(), install():
 10    25*     added the undo_request element to the message structure
 10    26*  6) change(82-05-04,Davids), approve(), audit(), install():
 10    27*     changed unused_offset (12) to last_restructruring_history_offset and
 10    28*     changed restructuring_history_offset to first_restructuring_history_offset
 10    29*  7) change(82-08-19,Davids), approve(), audit(), install():
 10    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
 10    31*     1 => vfile database and 2 => page_file database. Up to this point all
 10    32*     database types were equal to 1.
 10    33*  8) change(83-02-14,Davids), approve(), audit(), install():
 10    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
 10    35*     flags. This will allow information about transactions and dm_file
 10    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
 10    37*     change is compatable with all datamodels created by the released version
 10    38*     of mrds.
 10    39*  9) change(83-02-15,Davids), approve(), audit(), install():
 10    40*     added the rollback_on flag to the db_type_flags since it appears that you
 10    41*     can have a dmfile database that requires transactions but does not have any
 10    42*     journalizing. Also switched the order of the transactions_needed and
 10    43*     concurrency_on flags - this makes the change compatable with existing
 10    44*     dmfile databases except when displaying the model since concurrency_on and
 10    45*     rollback_on will be off in the model even though the dmfile relations had
 10    46*     them on during creation.
 10    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
 10    48*      Removed ctl_file_path_ptr.
 10    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
 10    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 10    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
 10    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
 10    53*      in the flag word for rmdb copying.
 10    54*                                                   END HISTORY COMMENTS */
 10    55 
 10    56 
 10    57 /* this include file contains the structures that go into the make up
 10    58*   of the "db_model" segment in the model for the database.
 10    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
 10    60*
 10    61*   the db_model structure goes at the base of the segment, and contains items unique to
 10    62*   the whole databse. in addition, it has an area of size to fill the
 10    63*   rest of a segment, that holds the lists of files and domains in the database.
 10    64*   these lists are singly forward linked lists. all "pointers" in the database model
 10    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
 10    66*   since actual pointers are process dependent on segment number.
 10    67*   the remaining structures are first a path_entry one to save pathnames in,
 10    68*   and the stack_item and constent structures, used to save a boolean
 10    69*   expression in polish form, with the stack represented by a linked list.
 10    70*   the final structure is one for identifying the status of version information */
 10    71 
 10    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
 10    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
 10    74 	     2 db_type_flags      unal,
 10    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
 10    76 	       3 unused	      (13) bit (1) unal,
 10    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
 10    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
 10    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
 10    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
 10    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
 10    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
 10    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
 10    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
 10    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
 10    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
 10    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
 10    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
 10    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
 10    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
 10    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
 10    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
 10    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
 10    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
 10    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
 10    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
 10    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
 10    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
 10    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
 10   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
 10   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
 10   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
 10   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
 10   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
 10   105 
 10   106      dcl	   dbm_ptr	      ptr;
 10   107 
 10   108 /* the files in the database each have a file_info containing
 10   109*   their name, the file_model for each file is found by initiating the
 10   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
 10   111*   the file_info list is a singly linked list in definition order */
 10   112 
 10   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
 10   114 	     2 file_name	      char (30),		/* name of file */
 10   115 	     2 file_id	      bit (36),		/* id number of file */
 10   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
 10   117 	     2 unused	      unal bit (18);	/* for future expansion */
 10   118 
 10   119      dcl	   fi_ptr		      ptr;
 10   120 
 10   121 /* each domain used in the database will have a domain info saved in the db_model
 10   122*   segment. it describes the domain of the given name, and it's options.
 10   123*   the domain_info's form a singly linked list in definition order */
 10   124 
 10   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
 10   126 	     2 name	      char (32),		/* name of domain */
 10   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
 10   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
 10   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
 10   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
 10   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
 10   132 	     2 reserved	      bit (31) unal,
 10   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
 10   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
 10   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
 10   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
 10   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
 10   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
 10   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
 10   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
 10   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
 10   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
 10   143 	     2 str_err_path_ptr   unal bit (18),
 10   144 	     2 str_after_path_ptr unal bit (18),
 10   145 	     2 get_before_path_ptr unal bit (18),
 10   146 	     2 get_err_path_ptr   unal bit (18),
 10   147 	     2 get_after_path_ptr unal bit (18),
 10   148 	     2 mod_before_path_ptr unal bit (18),
 10   149 	     2 mod_err_path_ptr   unal bit (18),
 10   150 	     2 mod_after_path_ptr unal bit (18),
 10   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
 10   152 	     2 unused_2	      unal bit (18),
 10   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
 10   154 
 10   155      dcl	   di_ptr		      ptr;
 10   156 
 10   157 /* information necessary for attributes that are not used in any relation */
 10   158 
 10   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
 10   160 	     2 name char (32),			/* name of attribute */
 10   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
 10   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
 10   163 	     2 unused (2) bit (18) unal;
 10   164 
 10   165      dcl     ua_ptr ptr;
 10   166 
 10   167 
 10   168 /* space saving pathname$entryname structure, to be allocated
 10   169*   only when a path$entry has to be saved, else only a bit(18)
 10   170*   offset takes up space in the main model structure */
 10   171 
 10   172      declare 1 path_entry	      based (path_entry_ptr),
 10   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
 10   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
 10   175 	     2 reserved	      unal bit (36);	/* for future use */
 10   176 
 10   177      declare path_entry_ptr	      ptr;
 10   178 
 10   179 
 10   180 
 10   181 
 10   182 
 10   183 /* declarations for model of postfix stack holding the check option boolean expression
 10   184*   the following encoding values indicate the corresponding type of stack element
 10   185*
 10   186*   1  =
 10   187*   2  ^=
 10   188*   3  >
 10   189*   4  <
 10   190*   5  >=
 10   191*   6  <=
 10   192*
 10   193*   10  and
 10   194*   20  or
 10   195*   30  not
 10   196*
 10   197*   40  - (minus)
 10   198*
 10   199*   50  domain variable(same name as domain)
 10   200*
 10   201*   60  constant(number, bit string, or character string)
 10   202*
 10   203**/
 10   204 
 10   205 
 10   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
 10   207 	     2 next	      bit (18),		/* link to next in list */
 10   208 	     2 type	      fixed binary,		/* code for this element type */
 10   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
 10   210*						   if this is a constant element type */
 10   211 
 10   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
 10   213 
 10   214 
 10   215 
 10   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
 10   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
 10   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
 10   219 
 10   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
 10   221 
 10   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
 10   223 
 10   224 /* version structure, giving status of source for CMDB/RMDB,
 10   225*   status of model, and status of resultant */
 10   226 
 10   227 /* version number is in form MM.N.Y
 10   228*   where MM is the major version number, N is the minor version alteration,
 10   229*   and Y is the lastest modification to that alteration,
 10   230*   where M and N represent numbers 0-9, and Y is a letter */
 10   231 
 10   232      declare 1 version_status	      unal based (version_status_ptr),
 10   233 	     2 cmdb_rmdb,
 10   234 	       3 major	      fixed bin,
 10   235 	       3 minor	      fixed bin,
 10   236 	       3 modification     char (4),
 10   237 	     2 model,
 10   238 	       3 major	      fixed bin,
 10   239 	       3 minor	      fixed bin,
 10   240 	       3 modification     char (4),
 10   241 	     2 resultant,
 10   242 	       3 major	      fixed bin,
 10   243 	       3 minor	      fixed bin,
 10   244 	       3 modification     char (4);
 10   245 
 10   246      declare version_status_ptr     ptr;
 10   247 
 10   248 
 10   249 /* maintains information only about the db creation */
 10   250 
 10   251      declare 1 changer	      unal based (changer_ptr),
 10   252 	     2 id		      char (32),
 10   253 	     2 time	      fixed bin (71),
 10   254 	     2 next	      bit (18);		/* to next in the singly linked list */
 10   255 
 10   256      declare changer_ptr	      ptr;
 10   257 
 10   258 
 10   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
 10   260 	     02 len	      fixed bin,		/* length of the message */
 10   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
 10   262 	     02 name	      char (32),		/* name of thing that set the message */
 10   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
 10   264*                                                               that caused the database to become inconsistent */
 10   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
 10   266 
 10   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
 10   268 
 10   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
 10   270 
 10   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
 10   272 
 10   273 
      825 
 11     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
 11     2 
 11     3 
 11     4 /****^  HISTORY COMMENTS:
 11     5*  1) change(79-02-01,JGray), approve(), audit(), install():
 11     6*     modified to save space occupied by model
 11     7*  2) change(82-05-19,Davids), approve(), audit(), install():
 11     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
 11     9*     the number of secondary indices in the relation - it was always zero.
 11    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
 11    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
 11    12*     DMS conversion.
 11    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
 11    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
 11    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
 11    16*     for relation manager changes.
 11    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
 11    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 11    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
 11    20*     <rel> files are good (for rmdb)
 11    21*                                                   END HISTORY COMMENTS */
 11    22 
 11    23 
 11    24 /* each file in the database will have a model segment with the name
 11    25*   file_name.m (i.e. the files name plus a suffix of ".m")
 11    26*   the file_model structure is allocated at the base of the segment for a given file.
 11    27*   it contains an area with which all other structures in this include file are allocated.
 11    28*   these structures contain the information about which relations, foreign keys,
 11    29*   and attributes are members of this file. all lists are singly linked lists in
 11    30*   definition order. pointers to these structures are obtained by using the "pointer"
 11    31*   builtin function with arguments of the segment base pointer, and the
 11    32*   offset (bit (18)) relative to that pointer that is actually stored in
 11    33*   the file model itself. this is because pointer segment numbers are
 11    34*   per process dependent. the major lists pointed to by the file_model structure
 11    35*   are the list of relations in this file(each with a contained attribute list),
 11    36*   and the list of foreign keys whose parent relation resides in this file
 11    37*   (along with a participating attribute sublist, and the child relation list,
 11    38*   if they are also in this file) */
 11    39 
 11    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
 11    41     2 temporary bit (1) unal,				/* on if file not part of db. */
 11    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
 11    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
 11    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
 11    45     2 reserved bit (32) unal,				/* reserved for future flags */
 11    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
 11    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
 11    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
 11    49     2 pad_1 fixed bin (35),				/* for future use */
 11    50     2 pad_2 fixed bin (35),
 11    51     2 ratd_len fixed bin (21),			/* length of above */
 11    52     2 mratd_len fixed bin (21),			/* length of above */
 11    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
 11    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
 11    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
 11    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
 11    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
 11    58     2 block_size unal fixed bin,			/* no. pages in block */
 11    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
 11    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
 11    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
 11    62     2 num_rels unal fixed bin,			/* number of relations in file */
 11    63     2 num_links unal fixed bin,			/* number of links in file */
 11    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
 11    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
 11    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
 11    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
 11    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
 11    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
 11    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
 11    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
 11    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
 11    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
 11    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
 11    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
 11    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
 11    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
 11    78     2 open_eu_err_path_ptr unal bit (18),
 11    79     2 open_eu_after_path_ptr unal bit (18),
 11    80     2 open_er_before_path_ptr unal bit (18),
 11    81     2 open_er_err_path_ptr unal bit (18),
 11    82     2 open_er_after_path_ptr unal bit (18),
 11    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
 11    84     2 open_neu_err_path_ptr unal bit (18),
 11    85     2 open_neu_after_path_ptr unal bit (18),
 11    86     2 open_ner_before_path_ptr unal bit (18),
 11    87     2 open_ner_err_path_ptr unal bit (18),
 11    88     2 open_ner_after_path_ptr unal bit (18),
 11    89     2 open_pu_before_path_ptr unal bit (18),
 11    90     2 open_pu_err_path_ptr unal bit (18),
 11    91     2 open_pu_after_path_ptr unal bit (18),
 11    92     2 open_pr_before_path_ptr unal bit (18),
 11    93     2 open_pr_err_path_ptr unal bit (18),
 11    94     2 open_pr_after_path_ptr unal bit (18),
 11    95     2 open_cu_before_path_ptr unal bit (18),
 11    96     2 open_cu_err_path_ptr unal bit (18),
 11    97     2 open_cu_after_path_ptr unal bit (18),
 11    98     2 open_cr_before_path_ptr unal bit (18),
 11    99     2 open_cr_err_path_ptr unal bit (18),
 11   100     2 open_cr_after_path_ptr unal bit (18),
 11   101     2 close_before_path_ptr unal bit (18),
 11   102     2 close_err_path_ptr unal bit (18),
 11   103     2 close_after_path_ptr unal bit (18),
 11   104     2 unused_1 unal bit (18),				/* for future expansion */
 11   105     2 unused_2 unal bit (18),
 11   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
 11   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
 11   108 dcl  fm_ptr ptr;
 11   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
 11   110 dcl  atd_ptr ptr;
 11   111 dcl  atd_len fixed bin;
 11   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
 11   113     2 ncomponents fixed bin,
 11   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
 11   115 dcl  cna_ptr ptr;
 11   116 dcl  ncomp_init fixed bin;
 11   117 
 11   118 /* a rel_info structure contains information describing a relation.
 11   119*   a relation may only occur in one file, thus there is one rel_info
 11   120*   per relation per database, each stored in the file_model area for
 11   121*   the file that contains it. the list of rel_info's in this file
 11   122*   form a singly linked list in definition order.
 11   123*   the rel_info itself points to a list of the attributes it contains,
 11   124*   and to any parent_link or child_link info's that involve it in a foreign key */
 11   125 
 11   126 dcl 1 rel_info aligned based (ri_ptr),
 11   127     2 name char (32),				/* relation name */
 11   128     2 id  bit (36) aligned,				/* relation id number */
 11   129     2 hashed bit (1) unal,				/* on if hashed */
 11   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
 11   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
 11   132     2 system bit (1) unal,				/* on if dont care how stored */
 11   133     2 indexed bit (1) unal,				/* on if secondary index */
 11   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
 11   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
 11   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
 11   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
 11   138     2 reserved bit (27) unal,				/* for future flags */
 11   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
 11   140     2 num_links_child unal fixed bin,			/* no. links in which child */
 11   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
 11   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
 11   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
 11   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
 11   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
 11   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
 11   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
 11   148     2 unused_3 unal fixed bin,			/* element that was never used */
 11   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
 11   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
 11   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
 11   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
 11   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
 11   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
 11   155     2 attr_ptr unal bit (18),				/* to attr. info */
 11   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
 11   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
 11   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
 11   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
 11   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
 11   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
 11   162     2 link_err_path_ptr unal bit (18),
 11   163     2 link_after_path_ptr unal bit (18),
 11   164     2 unlk_before_path_ptr unal bit (18),
 11   165     2 unlk_err_path_ptr unal bit (18),
 11   166     2 unlk_after_path_ptr unal bit (18),
 11   167     2 str_before_path_ptr unal bit (18),
 11   168     2 str_err_path_ptr unal bit (18),
 11   169     2 str_after_path_ptr unal bit (18),
 11   170     2 del_before_path_ptr unal bit (18),
 11   171     2 del_err_path_ptr unal bit (18),
 11   172     2 del_after_path_ptr unal bit (18),
 11   173     2 mod_before_path_ptr unal bit (18),
 11   174     2 mod_err_path_ptr unal bit (18),
 11   175     2 mod_after_path_ptr unal bit (18),
 11   176     2 find_before_path_ptr unal bit (18),
 11   177     2 find_err_path_ptr unal bit (18),
 11   178     2 find_after_path_ptr unal bit (18),
 11   179     2 retr_before_path_ptr unal bit (18),
 11   180     2 retr_err_path_ptr unal bit (18),
 11   181     2 retr_after_path_ptr unal bit (18),
 11   182     2 unused_1 unal bit (18),				/* for future expansion */
 11   183     2 unused_2 unal bit (18),
 11   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
 11   185 dcl  ri_ptr ptr;
 11   186 
 11   187 /* a attr_info structure contains information about an attribute in a given relation.
 11   188*   since attributes may appear in more than one relation, each occurence of an attribute
 11   189*   means that an attr_info for it will be put in that relations sublist of attributes.
 11   190*   the list is singly linked in definition order. the attr_info describes
 11   191*   the data it represents, and how that data is used during a database search. */
 11   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
 11   193     2 name char (32),				/* name of attribute */
 11   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
 11   195     2 index_attr bit (1) unal,			/* on if a secondary index */
 11   196     2 link_attr bit (1) unal,				/* on if participates in link */
 11   197     2 reserved bit (33) unal,
 11   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
 11   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
 11   200     2 key_order unal fixed bin,			/* relative posit. in key */
 11   201     2 bit_offset fixed bin (35),			/* position in tuple */
 11   202     2 bit_length fixed bin (35),			/* length if fixed */
 11   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
 11   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
 11   205     2 domain_ptr unal bit (18),			/* to domain info */
 11   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
 11   207     2 fwd_thread unal bit (18),			/* to next in list */
 11   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
 11   209 dcl  ai_ptr ptr;
 11   210 
 11   211 /* a parent_link_info structure is the carrier of foreign key definition info.
 11   212*   each time a foreign key definition indicates a relation as it's parent,
 11   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
 11   214*   a relation can be parent and/or child in any number of foreign keys.
 11   215*   the parent_link_info structure describes the foreign key, and also points
 11   216*   to a list of the attributes that participate in this foreign key.
 11   217*   (this could be from 1 up to all attributes in the relation)
 11   218*   the attr_list structures are in a singly linked list in definition order
 11   219*   for this purpose. also pointed to is a list of child_link_info's
 11   220*   that describe the child relations in this foreign key. since foreign keys
 11   221*   may span files, not all related child_link_info's have to be in this file's
 11   222*   model area. */
 11   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
 11   224     2 name char (32),				/* name of link */
 11   225     2 singular bit (1) unal,				/* on if system owned link */
 11   226     2 temp bit (1) unal,				/* on if temp. order */
 11   227     2 first bit (1) unal,				/* insertion indicators */
 11   228     2 last bit (1) unal,
 11   229     2 next bit (1) unal,
 11   230     2 prior bit (1) unal,
 11   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
 11   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
 11   233     2 dup_first bit (1) unal,				/* duplicates first */
 11   234     2 dup_last bit (1) unal,				/* duplicates last */
 11   235     2 indexed bit (1) unal,				/* locate parent via index */
 11   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
 11   237     2 thread_36 bit (1) unal,				/* thread size indicators */
 11   238     2 thread_27 bit (1) unal,
 11   239     2 thread_18 bit (1) unal,
 11   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
 11   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
 11   242     2 reserved bit (19) unal,				/* reserved for future flags */
 11   243     2 index_id aligned bit (8),			/* id of index if indexed */
 11   244     2 thread_index unal fixed bin,			/* index to threads in parent */
 11   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
 11   246     2 n_children unal fixed bin,			/* no. children in link */
 11   247     2 child_fn char (30),				/* file name for first child in list */
 11   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
 11   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
 11   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
 11   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
 11   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
 11   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
 11   254     2 sort_err_path_ptr unal bit (18),
 11   255     2 sort_after_path_ptr unal bit (18),
 11   256     2 srch_before_path_ptr unal bit (18),
 11   257     2 srch_err_path_ptr unal bit (18),
 11   258     2 srch_after_path_ptr unal bit (18),
 11   259     2 link_before_path_ptr unal bit (18),
 11   260     2 link_err_path_ptr unal bit (18),
 11   261     2 link_after_path_ptr unal bit (18),
 11   262     2 unlk_before_path_ptr unal bit (18),
 11   263     2 unlk_err_path_ptr unal bit (18),
 11   264     2 unlk_after_path_ptr unal bit (18),
 11   265     2 unused_1 unal bit (18),				/* for future expansion */
 11   266     2 unused_2 unal bit (18),
 11   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
 11   268 dcl  pli_ptr ptr;
 11   269 
 11   270 /* a child_link_info structure is the counter part of a parent_link_info
 11   271*   for foreign key child relations. each time a relation is defined to be
 11   272*   a child in a foreign key, it's list of child_link_infos will be added to.
 11   273*   this list is singly linked in foreign key definition order.
 11   274*   the child_link_info points to a list of participating attributes from the
 11   275*   child relation by means of a singly linked list of attr_list structures
 11   276*   in definition order. the number of attributes in the parent attr_list
 11   277*   and the child attr_list lists are the same with corresponding attr_list
 11   278*   attributes having the same domain. all child_link_infos in this file
 11   279*   are on a seperately linked list. this may not include all
 11   280*   child_link_infos for foreign keys whose parent relation resides in this file,
 11   281*   since foreign keys may span files, and the child_link_info will
 11   282*   reside in the file containing it's associated relation_info. */
 11   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
 11   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
 11   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
 11   286     2 fixed bit (1) unal,				/* on if membership fixed */
 11   287     2 optional bit (1) unal,				/* on if membership optional */
 11   288     2 auto bit (1) unal,				/* on if insertion automatic */
 11   289     2 manual bit (1) unal,				/* on if insertion manual */
 11   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
 11   291     2 range_sel bit (1) unal,				/* on if range type selection */
 11   292     2 key_dup_first bit (1) unal,			/* sort key flags */
 11   293     2 key_dup_last bit (1) unal,
 11   294     2 key_null bit (1) unal,				/* on if null allowed */
 11   295     2 sel_system bit (1) unal,			/* selection criteria flags */
 11   296     2 sel_current bit (1) unal,
 11   297     2 sel_key bit (1) unal,
 11   298     2 sel_proc bit (1) unal,
 11   299     2 no_null bit (1) unal,				/* if null key values not allowed */
 11   300     2 reserved bit (21) unal,
 11   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
 11   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
 11   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
 11   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
 11   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
 11   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
 11   307     2 parent_fn char (30),				/* file name for parent info */
 11   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
 11   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
 11   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
 11   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
 11   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
 11   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
 11   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
 11   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
 11   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
 11   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
 11   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
 11   319     2 link_err_path_ptr unal bit (18),
 11   320     2 link_after_path_ptr unal bit (18),
 11   321     2 unlk_before_path_ptr unal bit (18),
 11   322     2 unlk_err_path_ptr unal bit (18),
 11   323     2 unlk_after_path_ptr unal bit (18),
 11   324     2 srch_before_path_ptr unal bit (18),
 11   325     2 srch_err_path_ptr unal bit (18),
 11   326     2 srch_after_path_ptr unal bit (18),
 11   327     2 unused_1 unal bit (18),				/* for future expansion */
 11   328     2 unused_2 unal bit (18) ;
 11   329 dcl  cli_ptr ptr;
 11   330 
 11   331 /* the attr_list structure is associated with the parent_link_info
 11   332*   and child_link_info structures to represent by means of a singly linked list
 11   333*   the participating attributes from relations in a foreign key.
 11   334*   the parent_link_info has a list for the parent relation,
 11   335*   and the child_link_info has a list for the child relation.
 11   336*   the participating attributes are a subset(not necessary proper) of
 11   337*   those attributes contained in a relation definition.
 11   338*   there are equal numbers of attr_list structures in the parent and
 11   339*   child lists of the same foreign key. the corresponding attributes in these
 11   340*   lists must have the same domain. */
 11   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
 11   342     2 attr_fn char (30),				/* file name for attr. */
 11   343     2 attr_ptr unal bit (18),				/* to attr info block */
 11   344     2 fwd_thread unal bit (18);			/* to next in list */
 11   345 dcl  al_ptr ptr;
 11   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
 11   347     2 ascend bit (1) unal,				/* ascending order */
 11   348     2 descend bit (1) unal,				/* descending order */
 11   349     2 reserved bit (34) unal,
 11   350     2 attr_ptr unal bit (18),				/* to attr info */
 11   351     2 fwd_thread unal bit (18);			/* to next in list */
 11   352 dcl  sk_ptr ptr;
 11   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
 11   354     2 attr_ptr unal bit (18),				/* to attr info */
 11   355     2 fwd_thread unal bit (18);			/* to next in list */
 11   356 dcl  dp_ptr ptr;
 11   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
 11   358     2 link_fn char (30),				/* file name for thru link */
 11   359     2 link_ptr unal bit (18),				/* to parent link info */
 11   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
 11   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
 11   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
 11   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
 11   364     2 fwd_thread unal bit (18);			/* to next in chain */
 11   365 dcl  sc_ptr ptr;
 11   366 
 11   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
 11   368 
 11   369 
      826 
 12     1 /* BEGIN - mrds_rmdb_ctl.incl.pl1 */
 12     2 
 12     3 
 12     4 
 12     5 /****^  HISTORY COMMENTS:
 12     6*  1) change(82-03-26,Davids), approve(), audit(), install():
 12     7*     created
 12     8*  2) change(82-05-26,Davids), approve(), audit(), install():
 12     9*     added db_model_ptr
 12    10*  3) change(82-06-09,Harvey), approve(), audit(), install():
 12    11*     deleted ssu_ routines ptr storage
 12    12*  4) change(82-08-20,Davids), approve(), audit(), install():
 12    13*     added the relmgr like reference and included the rmdb_relmgr_entries
 12    14*     include file
 12    15*  5) change(83-05-24,Davids), approve(), audit(), install():
 12    16*     added the saved_res_version_ptr element
 12    17*  6) change(84-10-23,Benjamin), approve(), audit(), install():
 12    18*     added flags (just database_readied_by_rmdb for now).
 12    19*  7) change(85-11-08,Spitzer), approve(85-11-08,MCR7311),
 12    20*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 12    21*     added crossref_file_info.
 12    22*                                                   END HISTORY COMMENTS */
 12    23 
 12    24 
 12    25 dcl 01 rmdb_ctl based (rmdb_ctl_ptr),
 12    26     02 version fixed bin,
 12    27     02 rmdb_version char (16) varying,
 12    28     02 absolute_db_path char (168),
 12    29     02 temp_dir_path char (168),
 12    30     02 work_area_ptr ptr,
 12    31     02 db_model_ptr ptr,
 12    32     02 saved_res_version_ptr ptr,
 12    33     02 crossref_file_info,
 12    34        03 iocb_ptr ptr,
 12    35        03 name char (32),
 12    36     02 relmgr_entries like rmdb_relmgr_entries,
 12    37     02 flags,
 12    38        03 database_readied_by_rmdb bit (1) unal,
 12    39        03 unused bit (35) unal;
 12    40     	
 12    41 dcl  RMDB_CTL_VERSION_1 fixed bin init (1) internal static options (constant);
 12    42 
 12    43 dcl  rmdb_ctl_ptr ptr;
 12    44 
 12    45 
 13     1 /*  START OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 13     2 
 13     3 
 13     4 /****^  HISTORY COMMENTS:
 13     5*  1) change(82-08-20,Davids), approve(), audit(), install():
 13     6*     written
 13     7*  2) change(86-01-28,Spitzer), approve(86-01-28,MCR7311),
 13     8*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
 13     9*     add get_tuples_by_spec, put_tuple, put_tuples, create_cursor entry points.
 13    10*  3) change(86-08-21,Blair), approve(86-08-21,MCR7311),
 13    11*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
 13    12*     Back out the entries get_tuples_by_spec and put_tuples since they aren't
 13    13*     sufficiently well tested to be reliable.  Replace with get_tuple_id and
 13    14*     get_tuple_by_id.
 13    15*                                                   END HISTORY COMMENTS */
 13    16 
 13    17 
 13    18 dcl 01 rmdb_relmgr_entries based (rmdb_relmgr_entries_ptr),
 13    19      02 create_relation entry (char (*), char (*), ptr, ptr, bit (36) aligned,
 13    20 	bit (36) aligned, fixed bin (35)),
 13    21      02 delete_relation entry (char (*), char (*), fixed bin (35)),
 13    22      02 open entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
 13    23      02 close entry (bit (36) aligned, fixed bin (35)),
 13    24      02 create_index entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17),
 13    25 	bit (36) aligned, fixed bin (35)),
 13    26      02 delete_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35)),
 13    27      02 put_tuple entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
 13    28      02 get_tuple_id entry (ptr, ptr, ptr, ptr, fixed bin (35)),
 13    29      02 get_tuple_by_id entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
 13    30      02 create_cursor entry (bit (36) aligned, ptr, ptr, fixed bin (35));
 13    31 
 13    32 dcl rmdb_relmgr_entries_ptr ptr;
 13    33 
 13    34 /*  END OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 12    46 
 12    47 
 12    48 
 12    49 /* END - mrds_rmdb_ctl.incl.pl1 */
      827 
 14     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
 14     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
 14     3 /*	version number changed to 4, 08/10/78 WOS */
 14     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
 14     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
 14     6 
 14     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
 14     8     2 version fixed bin,				/* version of this structure - must be set, see below */
 14     9     2 switches aligned,                                     /* various bit switch values */
 14    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
 14    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
 14    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
 14    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
 14    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
 14    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
 14    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
 14    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
 14    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
 14    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
 14    20 
 14    21 /*  Limit of data defined for version 2 */
 14    22 
 14    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
 14    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
 14    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
 14    26 						/* minimum of 30 seconds required for repeat */
 14    27 						/* otherwise, no repeat will occur */
 14    28 /* Limit of data defined for version 4 */
 14    29 
 14    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
 14    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
 14    32 
 14    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
 14    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
 14    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
 14    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
 14    37 
 14    38 /*	END INCLUDE FILE query_info.incl.pl1 */
      828 
 15     1 /*  START OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 15     2 
 15     3 /****^  HISTORY COMMENTS:
 15     4*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
 15     5*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
 15     6*     written.
 15     7*                                                   END HISTORY COMMENTS */
 15     8 
 15     9 /*DESCRIPTION
 15    10*  The following structures are the definition of the records with the keyed
 15    11*  vfile that is built during restructuring. This file serves as a crossreference
 15    12*  of unique attributes and domains used within the specified MRDS database. Each
 15    13*  object is a char (33); the first byte is set to an unprintable character so we
 15    14*  can use the index builtin to find a specific object.
 15    15**/
 15    16 
 15    17 dcl crossref_info_record_ptr ptr;
 15    18 dcl crossref_info_record_count fixed bin (21);
 15    19 dcl 1 crossref_info_record based (crossref_info_record_ptr),
 15    20      2 offset bit (18) unal,
 15    21      2 pad bit (18) unal,
 15    22      2 count fixed bin (21),
 15    23      2 entry (crossref_info_record_count refer (crossref_info_record.count)) unaligned,
 15    24       3 object_head char (1),
 15    25       3 object char (32);
 15    26 
 15    27 dcl crossref_info_record_objects char (33*crossref_info_record.count)
 15    28 			   based (addr (crossref_info_record.entry(1)));
 15    29 dcl OBJECT_HEAD char (1) int static options (constant) init (" ");
 15    30 
 15    31 dcl ATTRIBUTE_KEY_HEAD char (10) int static options (constant) init ("attribute:");
 15    32 dcl DOMAIN_KEY_HEAD char (7) int static options (constant) init ("domain:");
 15    33 dcl RELATION_KEY_HEAD char (9) int static options (constant) init ("relation:");
 15    34 
 15    35 /*DESCRIPTION
 15    36*  The following structures are used to contain sufficient crossreference
 15    37*  information for the delete_attribute and delete_domain requests. These
 15    38*  requests require a more complete view of a crossreference tree, associating
 15    39*  domains, attributes and relations in 2 directions.
 15    40**/
 15    41 
 15    42 dcl domain_list_ptr ptr;
 15    43 dcl domain_list_count fixed bin;
 15    44 dcl domain_list_names char (33*domain_list.count) based (addr (domain_list.name(1)));
 15    45 dcl 1 domain_list based (domain_list_ptr),
 15    46      2 count fixed bin,				/* number of domains in the list */
 15    47      2 name (domain_list_count refer (domain_list.count))
 15    48 	  char (33) unaligned,			/* name of this domain */
 15    49      2 attribute_list_ptr (domain_list_count refer (domain_list.count))
 15    50 		      ptr;			/* -> attribute_list structure */
 15    51 
 15    52 dcl attribute_list_ptr ptr;
 15    53 dcl attribute_list_count fixed bin;
 15    54 dcl attribute_list_names char (33*attribute_list.count) based (addr (attribute_list.name(1)));
 15    55 dcl 1 attribute_list based (attribute_list_ptr),
 15    56      2 count fixed bin,				/* number of attributes in the list */
 15    57      2 name (attribute_list_count refer (attribute_list.count))
 15    58 	  char (33) unaligned,			/* name of this attribute */
 15    59      2 domain_info_ptr (attribute_list_count refer (attribute_list.count))
 15    60 		   bit (18) unal,			/* offset in db_model of the domain_info structure for this attribute */
 15    61      2 attribute_ptr (attribute_list_count refer (attribute_list.count))
 15    62 		 ptr;				/* -> attribute structure */
 15    63 
 15    64 dcl relation_list_ptr ptr;
 15    65 dcl relation_list_count fixed bin;
 15    66 dcl relation_list_names char (33*relation_list.count) based (addr (relation_list.name (1)));
 15    67 dcl 1 relation_list based (relation_list_ptr),
 15    68      2 count fixed bin,				/* number of relations that are to be touched in this operation */
 15    69      2 name (relation_list_count refer (relation_list.count))
 15    70 	  char (33) unaligned,			/* name of this relation */
 15    71      2 relation_ptr (relation_list_count refer (relation_list.count))
 15    72 		ptr;				/* -> relation structure */
 15    73 
 15    74 dcl relation_ptr ptr;
 15    75 dcl relation_attribute_count fixed bin;
 15    76 dcl relation_attribute_names char (33*relation.attribute_count) based (addr (relation.attribute_names (1)));
 15    77 dcl 1 relation based (relation_ptr),
 15    78      2 name char (32),				/* name of the relation */
 15    79      2 file_model_ptr ptr,				/* -> relation.m segment */
 15    80      2 copy_file_model_ptr ptr,
 15    81      2 attribute_count fixed bin,			/* number of attributes defined for this relation */
 15    82      2 mbz fixed bin (35),
 15    83      2 attribute (relation_attribute_count refer (relation.attribute_count)),
 15    84       3 flags aligned,
 15    85         4 delete bit (1) unaligned,			/* ON: delete this attribute */
 15    86         4 new bit (1) unaligned,			/* ON: this attribute is added to the relation */
 15    87         4 part_of_key bit (1) unaligned,                    /* ON: this attribute is part of the primary key */
 15    88         4 to_be_deleted bit (1) unaligned,
 15    89         4 pad bit (32) unaligned,
 15    90       3 domain_info_ptr bit (18) aligned,		/* -> db_model domain_info structure */
 15    91       3 attribute_info_ptr ptr,			/* -> file_model attribute_info structure */
 15    92       3 value_ptr ptr,				/* if flags.new, this -> the value of the column to be stored */
 15    93 						/*   it must be of the correct data type as specified by the domain */
 15    94      2 attribute_names (relation_attribute_count refer (relation.attribute_count))
 15    95 		   char (33) unaligned;
 15    96 
 15    97 dcl attribute_ptr ptr;
 15    98 dcl attribute_count fixed bin;
 15    99 dcl 1 attribute based (attribute_ptr),
 15   100      2 count fixed bin,				/* number of relations this attribute is used in */
 15   101      2 relation_idx (attribute_count refer (attribute.count))
 15   102 		fixed bin;			/* index into list of relation names */
 15   103 
 15   104 /*  END OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      829 
 16     1 /*  START OF:	rmdb_delete_object_info.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 16     2 
 16     3 
 16     4 /****^  HISTORY COMMENTS:
 16     5*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
 16     6*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
 16     7*     Contains the list of domains or attributes to delete. If flags.check is on,
 16     8*     query the user on the switch indicated by check_iocb_ptr.
 16     9*                                                   END HISTORY COMMENTS */
 16    10 
 16    11 dcl delete_object_info_count fixed bin (17);
 16    12 dcl delete_object_info_ptr ptr;
 16    13 dcl delete_object_info_version_1 char (8) int static options (constant) init ("doi 1.0");
 16    14 
 16    15 dcl 1 delete_object_info based (delete_object_info_ptr),
 16    16      2 version char (8),
 16    17      2 check_iocb_ptr ptr,				/* switch to use for check output */
 16    18      2 query_iocb_ptr ptr,				/* switch to use for query input */
 16    19      2 flags aligned,
 16    20       3 all bit (1) unaligned,
 16    21       3 unreferenced bit (1) unaligned,			/* delete only unreferenced object */
 16    22       3 check bit (1) unaligned,			/* display actions to take when deleting, don't actually delete */
 16    23       3 long bit (2) unaligned,			/* if flags.check, do delete operations */
 16    24       3 force bit (1) unaligned,			/* don't query user */
 16    25       3 inhibit_errors bit (1) unaligned,		/* don't display errors if an object isn't found */
 16    26       3 pad bit (29) unaligned,
 16    27      2 request_name char (32),			/* name to use in queries and error messages */
 16    28      2 count fixed bin (17),
 16    29      2 name (delete_object_info_count refer (delete_object_info.count))
 16    30 	  char (32);
 16    31 
 16    32 /*  END OF:	rmdb_delete_object_info.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      830 
 17     1 /* BEGIN INCLUDE FILE rmdb_history_entry.incl.pl1 -- nsd, 82-04-09 */
 17     2 
 17     3 
 17     4 
 17     5 /****^  HISTORY COMMENTS:
 17     6*  1) change(75-01-01,WhoKnows), approve(), audit(), install():
 17     7*     Written.
 17     8*  2) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
 17     9*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 17    10*     Added RMDB_ADD_(ATTR DMN)_OP, RMDB_RN_(ATTR DMN REL)_OP.
 17    11*                                                   END HISTORY COMMENTS */
 17    12 
 17    13 
 17    14 /*
 17    15*   This include file contains the rmdb_history_entry structure which
 17    16*   is  used for maintaining a history of the databases restructuring
 17    17*   events. It also contains a set of constants used in  loading  the
 17    18*   structure.
 17    19*
 17    20*   The restructuring history is applied against the  database  as  a
 17    21*   whole  instead of against each structure in the db_model and file
 17    22*   models which was the approach originally  implemented  but  never
 17    23*   really  used  (except  to  record the database creation). This is
 17    24*   because 1 database restructuring event, i.e. adding a  new  index
 17    25*   to a relation will change several of the structures in the model.
 17    26*
 17    27*   For a detailed explaination of the use of this structure and  the
 17    28*   constants see the rmdb_add_rmdb_event module.
 17    29**/
 17    30 
 17    31 dcl 01 rmdb_history_entry aligned based (rmdb_history_entry_ptr),
 17    32     02 user_id char (32),				/* person_id.project_id.tag */
 17    33     02 date_time_restructured fixed bin (71),
 17    34     02 type_of_object_restructured fixed bin,		/* taken from constants below */
 17    35     02 object_name char (32),
 17    36     02 operation fixed bin,				/* taken from constants below */
 17    37     02 secondary_object_name char (32),			/* i.e. name of attr just indexed in a restructured relation */
 17    38     02 offset_to_next_entry bit (18) unal,
 17    39     02 offset_to_previous_entry bit (18) unal;
 17    40 	
 17    41 
 17    42 dcl  rmdb_history_entry_ptr ptr;
 17    43 
 17    44 
 17    45 dcl  RMDB_DOMAIN_TYPE init (1) fixed bin internal static options (constant);
 17    46 dcl  RMDB_ATTR_TYPE init (2) fixed bin internal static options (constant);
 17    47 dcl  RMDB_REL_TYPE init (3) fixed bin internal static options (constant);
 17    48 
 17    49 
 17    50 dcl  RMDB_ADD_REL_OP init (1) fixed bin internal static options (constant);
 17    51 dcl  RMDB_DEL_REL_OP init (2) fixed bin internal static options (constant);
 17    52 dcl  RMDB_ADD_IDX_OP init (3) fixed bin internal static options (constant);
 17    53 dcl  RMDB_DEL_IDX_OP init (4) fixed bin internal static options (constant);
 17    54 dcl  RMDB_ADD_ATTR_OP init (5) fixed bin int static options (constant);
 17    55 dcl  RMDB_DEL_ATTR_OP init (6) fixed bin int static options (constant);
 17    56 dcl  RMDB_ADD_DMN_OP init (7) fixed bin int static options (constant);
 17    57 dcl  RMDB_DEL_DMN_OP init (8) fixed bin int static options (constant);
 17    58 dcl  RMDB_RN_ATTR_OP init (9) fixed bin int static options (constant);
 17    59 dcl  RMDB_RN_DMN_OP init (10) fixed bin int static options (constant);
 17    60 dcl  RMDB_RN_REL_OP init (11) fixed bin int static options (constant);
 17    61 
 17    62 /* END INCLUDE FILE rmdb_history_entry.incl.pl1 */
      831 
 18     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
 18     2 
 18     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
 18     4 
 18     5 /* This include file contains branch and link structures returned by
 18     6*   hcs_$status_ and hcs_$status_long. */
 18     7 
 18     8 dcl 1 status_branch aligned based (status_ptr),
 18     9     2 short aligned,
 18    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
 18    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
 18    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
 18    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
 18    14       3 dtu bit (36) unaligned,			/* date/time last used */
 18    15       3 mode bit (5) unaligned,			/* caller's effective access */
 18    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
 18    17       3 pad1 bit (8) unaligned,
 18    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
 18    19 
 18    20 /* Limit of information returned by hcs_$status_ */
 18    21 
 18    22     2 long aligned,
 18    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
 18    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
 18    25       3 lvid bit (36) unaligned,			/* logical volume ID */
 18    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
 18    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
 18    28       3 pad2 bit (8) unaligned,
 18    29       3 copy_switch bit (1) unaligned,			/* copy switch */
 18    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
 18    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
 18    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
 18    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
 18    34       3 pad3 bit (5) unaligned,
 18    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
 18    36       3 uid bit (36) unaligned;			/* unique ID */
 18    37 
 18    38 dcl 1 status_link aligned based (status_ptr),
 18    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
 18    40     2 nnames fixed bin (16) unaligned unsigned,
 18    41     2 names_relp bit (18) unaligned,
 18    42     2 dtem bit (36) unaligned,
 18    43     2 dtd bit (36) unaligned,
 18    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
 18    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
 18    46 
 18    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
 18    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
 18    49 						/* array of names returned */
 18    50      status_pathname character (status_link.pathname_length) aligned
 18    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
 18    52 						/* link target path */
 18    53      status_area_ptr pointer,
 18    54      status_ptr pointer;
 18    55 
 18    56 dcl (Link initial (0),
 18    57      Segment initial (1),
 18    58      Directory initial (2)) fixed bin internal static options (constant);
 18    59 						/* values for type fields declared above */
 18    60 
 18    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
      832 
      833 
      834 dcl  addr builtin;
      835 dcl  1 ai like area_info aligned;
      836 dcl  any_other condition;
      837 dcl  attribute_idx fixed bin;
      838 dcl  attribute_list_idx fixed bin;
      839 dcl  attribute_name char (32);
      840 dcl  based_char8 char (8) based;
      841 dcl  cleanup condition;
      842 dcl  code fixed bin (35);
      843 dcl  command_query_ entry () options (variable);
      844 dcl  db_path char (168);
      845 dcl  define_area_ entry (ptr, fixed bin (35));
      846 dcl  delete_$path entry (char(*), char(*), bit(36) aligned, char(*), fixed bin(35));
      847 dcl  divide builtin;
      848 dcl  error_message char (500);
      849 dcl  error_table_$action_not_performed fixed bin (35) ext static;
      850 dcl  error_table_$unsupported_operation fixed bin (35) ext static;
      851 dcl  error_table_$no_record fixed bin (35) ext static;
      852 dcl  error_table_$unimplemented_version fixed bin (35) ext static;
      853 dcl  fixed builtin;
      854 dcl  fs_util_$copy entry (ptr, fixed bin(35));
      855 dcl  fs_util_$get_switch entry (char(*), char(*), char(*), bit(1) aligned, fixed bin(35));
      856 dcl  fs_util_$list_acl entry (char(*), char(*), char(*), ptr, ptr, fixed bin(35));
      857 dcl  fs_util_$replace_acl entry (char(*), char(*), ptr, bit(1), fixed bin(35));
      858 dcl  fs_util_$set_switch entry (char(*), char(*), char(*), bit(1) aligned, fixed bin(35));
      859 dcl  hcs_$chname_file entry (char(*), char(*), char(*), char(*), fixed bin(35));
      860 dcl  hcs_$status_ entry (char(*), char(*), fixed bin(1), ptr, ptr, fixed bin(35));
      861 dcl  Idelete_object_info_ptr ptr parameter;
      862 dcl  index builtin;
      863 dcl  initiate_file_ entry (char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35));
      864 dcl  ioa_$ioa_switch entry () options (variable);
      865 dcl  ioa_$ioa_switch_nnl entry () options (variable);
      866 dcl  Irmdb_ctl_ptr ptr parameter;
      867 dcl  last_unreferenced_attribute_ptr ptr;
      868 dcl  length builtin;
      869 dcl  local_iocb ptr;
      870 dcl  make_consistent_msg char (500);
      871 dcl  mdbm_util_$get_temp_segment_path entry (char (*), char (*), ptr, fixed bin (35));
      872 dcl  mdbm_util_$inconsistent_reset entry (ptr);
      873 dcl  mdbm_util_$inconsistent_set entry options (variable);
      874 dcl  mdbm_util_$free_temp_segment entry (char (*), ptr, fixed bin (35));
      875 dcl  mdbm_util_$xref_build entry (char (*), char (*), ptr, char (*), ptr, char (*), fixed bin (35));
      876 dcl  mdbm_util_$xref_delete_record entry (ptr, char (*), char (*), char (*), fixed bin (35));
      877 dcl  mdbm_util_$xref_destroy entry (ptr, char (*), char (*), char (*), fixed bin (35));
      878 dcl  mdbm_util_$xref_dereference entry (ptr, char (*), char (*), char (*), fixed bin (21), char (*), fixed bin (35));
      879 dcl  mrds_error_$no_primary_key fixed bin (35) ext static;
      880 dcl  mrds_error_$no_unref_attr fixed bin (35) ext static;
      881 dcl  myname char (32) int static options (constant) init ("rmdb_delete_attribute");
      882 dcl  null builtin;
      883 dcl  NULL_OFFSET bit (18) unaligned int static options (constant) init ((18)"1"b);
      884 dcl  Ocode fixed bin (35) parameter;
      885 dcl  Oerror_message char (*) parameter;
      886 dcl  previous_ptr ptr;
      887 dcl  (ptr, pointer) builtin;
      888 dcl  QUERY_MSG char (256) int static options (constant)
      889 	init ("Answering yes will cause the specified attribute to be deleted from the
      890 currently readied MRDS database.");
      891 dcl  quit condition;
      892 dcl  quit_occurred bit (1) aligned;
      893 dcl  reference_count fixed bin (21);
      894 dcl  rel builtin;
      895 dcl  relation_good_count fixed bin;
      896 dcl  relation_index fixed bin;
      897 dcl  relation_name char (32);
      898 dcl  release_area_ entry (ptr);
      899 dcl  rmdb_add_rmdb_history entry (ptr, fixed bin, char (32), fixed bin, char (32), char (500), fixed bin (35));
      900 dcl  rmdb_copy_relation entry (ptr, char (*), char (*), ptr, ptr, char (*), fixed bin (35));
      901 dcl  rmdb_delete_all$attributes entry (ptr, char (*), fixed bin (35));
      902 dcl  rmdb_relations_used$attributes entry (ptr, ptr, ptr, ptr, ptr, ptr, char (*), fixed bin (35));
      903 dcl  rtrim builtin;
      904 dcl  save_code fixed bin (35);
      905 dcl  save_ptr ptr;
      906 dcl  substr builtin;
      907 dcl  sys_info$max_seg_size fixed bin (35) ext static;
      908 dcl  unspec builtin;
      909 dcl  UNSPEC bit (2) aligned int static options (constant) init ("00"b);
      910 dcl  user_area area based (user_area_ptr);
      911 dcl  user_area_ptr ptr;
      912 
      913      end rmdb_delete_attribute;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/07/87  1321.2  rmdb_delete_attribute.pl1         >spec>install>MR12.2-1008>rmdb_delete_attribute.pl1
176          1    02/05/86  1416.4  mrds_start_transaction.incl.pl1   >ldd>include>mrds_start_transaction.incl.pl1
1-79         2    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
1-81         3    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
185          4    02/05/86  1416.4  mrds_finish_transaction.incl.pl1  >ldd>include>mrds_finish_transaction.incl.pl1
820          5    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
821          6    10/14/83  1606.6  acl_structures.incl.pl1           >ldd>include>acl_structures.incl.pl1
822          7    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
823          8    10/14/83  1606.7  copy_flags.incl.pl1               >ldd>include>copy_flags.incl.pl1
824          9    10/14/83  1606.7  copy_options.incl.pl1             >ldd>include>copy_options.incl.pl1
825         10    10/17/86  1404.3  mdbm_db_model.incl.pl1            >ldd>include>mdbm_db_model.incl.pl1
826         11    10/17/86  1404.5  mdbm_file_model.incl.pl1          >ldd>include>mdbm_file_model.incl.pl1
827         12    10/17/86  1404.4  mrds_rmdb_ctl.incl.pl1            >ldd>include>mrds_rmdb_ctl.incl.pl1
12-46       13    10/17/86  1404.6  rmdb_relmgr_entries.incl.pl1      >ldd>include>rmdb_relmgr_entries.incl.pl1
828         14    03/11/83  1204.3  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
829         15    10/17/86  1404.6  rmdb_crossref_info.incl.pl1       >ldd>include>rmdb_crossref_info.incl.pl1
830         16    10/17/86  1404.6  rmdb_delete_object_info.incl.pl1  >ldd>include>rmdb_delete_object_info.incl.pl1
831         17    10/17/86  1404.4  rmdb_history_entry.incl.pl1       >ldd>include>rmdb_history_entry.incl.pl1
832         18    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTRIBUTE_KEY_HEAD              000120 constant        char(10)                 initial unaligned dcl 15-31 set ref 383* 739*
COPY_OPTIONS_VERSION_1          000124 constant        char(8)                  initial unaligned dcl 9-28 ref 690
DOMAIN_KEY_HEAD                 000116 constant        char(7)                  initial unaligned dcl 15-32 set ref 390*
GENERAL_ACL_VERSION_1           000126 constant        char(8)                  initial unaligned dcl 6-72 set ref 666*
Idelete_object_info_ptr                parameter       pointer                  dcl 861 ref 39 43
Irmdb_ctl_ptr                          parameter       pointer                  dcl 866 ref 39 42
NULL_OFFSET                            constant        bit(18)                  initial unaligned dcl 883 ref 420 456 469 772
OBJECT_HEAD                     007530 constant        char(1)                  initial unaligned dcl 15-29 ref 269
Ocode                                  parameter       fixed bin(35,0)          dcl 884 set ref 39 224*
Oerror_message                         parameter       char                     unaligned dcl 885 set ref 39 225* 227*
QUERY_MSG                       000000 constant        char(256)                initial unaligned dcl 888 set ref 115 116
RELATION_KEY_HEAD               000112 constant        char(9)                  initial unaligned dcl 15-33 set ref 787*
RMDB_ATTR_TYPE                  000177 constant        fixed bin(17,0)          initial dcl 17-46 set ref 399* 439*
RMDB_DEL_ATTR_OP                000176 constant        fixed bin(17,0)          initial dcl 17-55 set ref 399* 439*
RMDB_DEL_REL_OP                 000177 constant        fixed bin(17,0)          initial dcl 17-51 set ref 797*
RMDB_REL_TYPE                   000200 constant        fixed bin(17,0)          initial dcl 17-47 set ref 797*
RW_ACCESS                       000130 constant        bit(3)                   initial unaligned dcl 5-11 set ref 652*
TM_NORMAL_MODE                  000204 constant        fixed bin(17,0)          initial dcl 2-15 set ref 1-99*
UNSPEC                                 constant        bit(2)                   initial dcl 909 ref 121 519
absolute_db_path          6            based           char(168)                level 2 packed unaligned dcl 12-25 ref 51
addr                                                   builtin function         dcl 834 ref 92 92 115 1-123 1-123 541 541 580 609
                                                                                  609 647 655 699 699
ai                              000222 automatic       structure                level 1 dcl 835 set ref 83* 92 92
all                       6            based           bit(1)                   level 3 packed unaligned dcl 16-15 ref 72
answer                          000116 automatic       char(3)                  unaligned dcl 539 set ref 541* 543
answer_iocbp              6     000162 automatic       pointer                  initial level 2 dcl 14-7 set ref 114* 14-7*
any_other                       000246 stack reference condition                dcl 836 ref 175
area_control                           based           structure                level 1 dcl 7-20
area_info                              based           structure                level 1 dcl 7-7
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 7-3 ref 84
areap                    16     000222 automatic       pointer                  level 2 dcl 835 set ref 90*
attr_idx                        001050 automatic       fixed bin(17,0)          dcl 328 set ref 338* 339*
attribute                16            based           structure                array level 2 in structure "relation" unaligned
                                                                                  dcl 15-77 in procedure "rmdb_delete_attribute"
attribute                              based           structure                level 1 unaligned dcl 15-99 in procedure
                                                                                  "rmdb_delete_attribute"
attribute_count          14            based           fixed bin(17,0)          level 2 dcl 15-77 ref 340 341 353 358 580 580 731
                                                                                  738 758
attribute_idx                   000254 automatic       fixed bin(17,0)          dcl 837 in procedure "rmdb_delete_attribute" set ref
                                                                                  340* 341 341 345* 353* 354 354 358 359* 508* 509
                                                                                  510 512* 578* 579*
attribute_idx                   001554 automatic       fixed bin(17,0)          dcl 756 in procedure "all_attributes_are_deleted"
                                                                                  set ref 758* 759*
attribute_list                         based           structure                level 1 unaligned dcl 15-55 set ref 467
attribute_list_count            000204 automatic       fixed bin(17,0)          dcl 15-53 set ref 455* 458* 458 461 467 467 467 467
                                                                                  468* 472* 472 473 474 475
attribute_list_idx              000255 automatic       fixed bin(17,0)          dcl 838 set ref 313* 314 315 315* 336* 337 341* 379*
                                                                                  380 382 389* 413* 414 414 417 418* 494* 495 497
                                                                                  498 523 524* 569* 570 570 574 577*
attribute_list_ptr              000202 automatic       pointer                  dcl 15-52 set ref 96* 100* 313 314 315 315 336 337
                                                                                  341 379 380 382 389 413 414 414 417 418 467* 473
                                                                                  474 475 488 494 495 497 498 569 570 574 577
attribute_name                  000256 automatic       char(32)                 unaligned dcl 839 set ref 358* 360 382* 383* 390*
                                                                                  399* 418* 424 439* 498* 502* 506* 541 738* 739*
attribute_names                        based           char(33)                 array level 2 packed unaligned dcl 15-77 set ref 341
                                                                                  358* 580 738*
attribute_ptr                          based           pointer                  array level 2 in structure "attribute_list"
                                                                                  dcl 15-55 in procedure "rmdb_delete_attribute" set
                                                                                  ref 337 414 474* 497 574
attribute_ptr                   000212 automatic       pointer                  dcl 15-97 in procedure "rmdb_delete_attribute" set
                                                                                  ref 337* 338 338 339 497* 502 506 508 509 512 574*
                                                                                  575 578 579
based_char8                            based           char(8)                  unaligned dcl 840 set ref 140*
caller_name               2     001362 automatic       char(32)                 level 2 packed unaligned dcl 640 set ref 691*
cancel_attribute                000100 automatic       bit                      unaligned dcl 488 set ref 491* 523* 570
check                     6(02)        based           bit(1)                   level 3 packed unaligned dcl 16-15 ref 121 500 519
check_iocb_ptr            2            based           pointer                  level 2 dcl 16-15 set ref 113 502* 506* 510* 512*
                                                                                  515*
cleanup                         000266 stack reference condition                dcl 841 ref 63 170
co                              001362 automatic       structure                level 1 dcl 640 set ref 699 699
code                            000274 automatic       fixed bin(35,0)          dcl 842 in procedure "rmdb_delete_attribute" set ref
                                                                                  54* 56 56* 72* 79* 80 80* 92* 93 93* 100* 102 102*
                                                                                  123* 124* 149 151 208* 211* 246* 247 365* 366*
                                                                                  383* 385 385 385* 390* 392 392* 609* 648* 652* 653
                                                                                  653* 666* 667 667* 670* 671 671* 682* 683 683*
                                                                                  699* 700 700* 704* 705 705* 727 727* 739* 741 741*
                                                                                  807* 808 808* 811 811*
code                                   parameter       fixed bin(35,0)          dcl 221 in procedure "error" ref 218 224 225
command_query_                  000040 constant        entry                    external dcl 843 ref 541
condition_info                         based           structure                level 1 dcl 3-14
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 1-77 set ref 1-124 1-129 1-129
continue_to_signal_             000010 constant        entry                    external dcl 1-61 ref 1-137
control                   1     000222 automatic       structure                level 2 dcl 835
copy_file_model_ptr      12            based           pointer                  level 2 dcl 15-77 ref 716 718 723 724
copy_flags                             based           structure                level 1 dcl 8-8
copy_items              157     001362 automatic       structure                level 2 dcl 640 set ref 697*
copy_options                           based           structure                level 1 dcl 9-12
count                                  based           fixed bin(17,0)          level 2 in structure "relation_list" dcl 15-67
                                                                                  in procedure "rmdb_delete_attribute" ref 145 146
                                                                                  165 339 350 352 561 562 579
count                                  based           fixed bin(17,0)          level 2 in structure "attribute_list" dcl 15-55
                                                                                  in procedure "rmdb_delete_attribute" set ref 313
                                                                                  314 336 337 337 379 389 413 414 414 417 467* 474
                                                                                  474 475 488 494 497 497 569 574 574
count                                  based           fixed bin(17,0)          level 2 in structure "attribute" dcl 15-99
                                                                                  in procedure "rmdb_delete_attribute" ref 338 506
                                                                                  508 512 578
cp_escape_control         1(02) 000162 automatic       bit(2)                   initial level 3 packed unaligned dcl 14-7 set ref
                                                                                  14-7*
create_model_name               001330 automatic       char(32)                 unaligned dcl 630 set ref 645* 648* 652* 713*
create_relation_name            001340 automatic       char(32)                 unaligned dcl 631 set ref 651* 670* 671 678* 679*
                                                                                  693 704* 704* 705 712*
crossref_file_info      140            based           structure                level 2 unaligned dcl 12-25
cvds                            001542 automatic       bit(1)                   dcl 641 set ref 674* 675* 678*
data_acl_ptr                    001350 automatic       pointer                  dcl 632 set ref 665* 666* 670*
db_model                               based           structure                level 1 dcl 10-72
db_model_ptr            134            based           pointer                  level 2 dcl 12-25 set ref 54* 70
db_path                         000275 automatic       char(168)                unaligned dcl 844 set ref 51* 54* 609* 648* 652*
                                                                                  666* 670* 675* 676* 678* 679* 682* 692 704* 712*
                                                                                  713* 807* 808*
db_type_flags             0(18)        based           structure                level 2 packed unaligned dcl 10-72
dbm_area                 34            based           area                     level 2 dcl 10-72 ref 436 724 785
dbm_ptr                         000144 automatic       pointer                  dcl 10-106 set ref 70* 133* 201* 287 314 389 399*
                                                                                  417 420 420 427 431 436 439* 456 456 459 469 469
                                                                                  476 609* 718 718 721 724 772 772 777 781 785 794
                                                                                  794 795 795 797*
define_area_                    000042 constant        entry                    external dcl 845 ref 92
delete                   16            based           bit(1)                   array level 4 packed unaligned dcl 15-77 set ref
                                                                                  584* 736 759
delete_$path                    000044 constant        entry                    external dcl 846 in procedure
                                                                                  "rmdb_delete_attribute" ref 713
delete_$path                    000142 constant        entry                    external dcl 803 in procedure "delete_file" ref 808
delete_acl_entry                       based           structure                level 1 dcl 6-63
delete_object_info                     based           structure                level 1 unaligned dcl 16-15
delete_object_info_ptr          000214 automatic       pointer                  dcl 16-12 set ref 43* 47 47 72 97 100* 107 113 114
                                                                                  121 121 138 315 385 392 461 500 502 506 510 512
                                                                                  515 519 519 520 541 727 741 811
delete_object_info_version_1    000110 constant        char(8)                  initial unaligned dcl 16-13 ref 47
delete_relation           4            based           entry variable           level 2 dcl 13-18 ref 682 712
deletion_attributes             001051 automatic       char(500)                unaligned dcl 329 set ref 334* 360* 360 366
di_ptr                          000150 automatic       pointer                  dcl 10-155 set ref 314* 315 318 389* 390 396 399
                                                                                  417* 439
directory_acl_entry                    based           structure                level 1 dcl 6-54
divide                                                 builtin function         dcl 847 ref 583 660
dm_error_$bj_journal_full       000030 external static fixed bin(35,0)          dcl 4-52 ref 1-132
dm_error_$lock_deadlock         000032 external static fixed bin(35,0)          dcl 4-53 ref 4-78 1-126
dm_error_$no_current_transaction
                                000012 external static fixed bin(35,0)          dcl 1-62 ref 1-90
domain_info                            based           structure                level 1 dcl 10-125
domain_info_ptr                        based           bit(18)                  array level 2 packed unaligned dcl 15-55 set ref 314
                                                                                  389 417 475*
domain_list_ptr                 000200 automatic       pointer                  dcl 15-42 set ref 96* 100*
domain_ptr               10            based           bit(18)                  level 2 packed unaligned dcl 10-159 ref 475
dont_free                 1(03) 000222 automatic       bit(1)                   level 3 packed unaligned dcl 835 set ref 86*
error_message                   000347 automatic       char(500)                unaligned dcl 848 set ref 54* 56* 72* 100* 102* 124*
                                                                                  194* 211* 383* 385* 390* 392* 609* 727* 739* 741*
                                                                                  787*
error_table_$action_not_performed
                                000046 external static fixed bin(35,0)          dcl 849 set ref 294*
error_table_$no_record          000052 external static fixed bin(35,0)          dcl 851 ref 385
error_table_$unimplemented_version
                                000054 external static fixed bin(35,0)          dcl 852 set ref 47*
error_table_$unsupported_operation
                                000050 external static fixed bin(35,0)          dcl 850 set ref 318* 808
explanation_len          14     000162 automatic       fixed bin(21,0)          initial level 2 dcl 14-7 set ref 116* 14-7*
explanation_ptr          12     000162 automatic       pointer                  initial level 2 dcl 14-7 set ref 115* 14-7*
extend                    1     000222 automatic       bit(1)                   level 3 packed unaligned dcl 835 set ref 85*
fi_ptr                          000146 automatic       pointer                  dcl 10-119 set ref 718* 718* 720* 721 772* 772* 774
                                                                                  774 776* 777
file_info                              based           structure                level 1 dcl 10-113 set ref 724 785
file_model                             based           structure                level 1 dcl 11-40
file_model_copy_good      0(02)        based           bit(1)                   level 2 packed unaligned dcl 11-40 ref 658
file_model_ptr           10            based           pointer                  level 2 dcl 15-77 ref 166
file_name                              parameter       char                     unaligned dcl 804 in procedure "delete_file" set ref
                                                                                  800 807* 808* 811
file_name                              based           char(30)                 level 2 in structure "file_info" dcl 10-113
                                                                                  in procedure "rmdb_delete_attribute" ref 774
file_ptr                 22            based           bit(18)                  level 2 packed unaligned dcl 10-72 set ref 718 772
                                                                                  781*
find_condition_info_            000014 constant        entry                    external dcl 1-64 ref 1-123
first_cancel_attribute          000100 automatic       fixed bin(17,0)          dcl 489 set ref 492* 524 524* 531
flags                     6            based           structure                level 2 in structure "delete_object_info" dcl 16-15
                                                                                  in procedure "rmdb_delete_attribute"
flags                    16            based           structure                array level 3 in structure "relation" dcl 15-77
                                                                                  in procedure "rmdb_delete_attribute" set ref 563*
flags                   156     001362 automatic       structure                level 2 in structure "co" dcl 640 in procedure
                                                                                  "switch_names" set ref 696*
fm_ptr                          000154 automatic       pointer                  dcl 11-108 set ref 166* 658 658 661
force                     6(05)        based           bit(1)                   level 3 packed unaligned dcl 16-15 ref 107 520
fs_util_$copy                   000056 constant        entry                    external dcl 854 ref 699
fs_util_$delentry_file          000144 constant        entry                    external dcl 805 ref 807
fs_util_$get_switch             000060 constant        entry                    external dcl 855 ref 675 676
fs_util_$list_acl               000062 constant        entry                    external dcl 856 ref 666
fs_util_$replace_acl            000064 constant        entry                    external dcl 857 ref 670
fs_util_$set_switch             000066 constant        entry                    external dcl 858 ref 678 679
fwd_ptr                  11            based           bit(18)                  level 2 packed unaligned dcl 10-113 set ref 721 723*
                                                                                  723 777 781 783* 783
fwd_thread               10(18)        based           bit(18)                  level 2 packed unaligned dcl 10-159 set ref 427 431
                                                                                  433* 433 459 476
general_acl_entry                      based           structure                level 1 unaligned dcl 6-12
general_delete_acl_entry               based           structure                level 1 dcl 6-35
general_extended_acl_entry             based           structure                level 1 dcl 6-23
have_attributes_to_process      000126 automatic       bit(1)                   dcl 556 set ref 568* 573* 591
hcs_$chname_file                000070 constant        entry                    external dcl 859 ref 704
hcs_$status_                    000072 constant        entry                    external dcl 860 ref 648
index                                                  builtin function         dcl 634 in procedure "switch_names" ref 649
index                                                  builtin function         dcl 862 in procedure "rmdb_delete_attribute" ref 580
inhibit_errors            6(06)        based           bit(1)                   level 3 packed unaligned dcl 16-15 ref 315 385 392
                                                                                  461 727 741 811
initiate_file_                  000074 constant        entry                    external dcl 863 ref 652
input_name                             parameter       char                     unaligned dcl 267 in procedure "make_name" ref 264
                                                                                  269
input_name                             parameter       char                     unaligned dcl 275 in procedure "unmake_name" ref 272
                                                                                  277
ioa_$ioa_switch                 000076 constant        entry                    external dcl 864 ref 502
ioa_$ioa_switch_nnl             000100 constant        entry                    external dcl 865 ref 506 510 512 515
iocb_ptr                140            based           pointer                  level 3 dcl 12-25 set ref 52 54* 60 65* 192*
ivds                            001543 automatic       bit(1)                   dcl 642 set ref 674* 676* 679*
last_file_info_ptr              001360 automatic       pointer                  dcl 639 set ref 720* 723
last_unreferenced_attribute_ptr 000544 automatic       pointer                  dcl 867 set ref 142*
length                                                 builtin function         dcl 868 ref 116
literal_sw                1(05) 000162 automatic       bit(1)                   initial level 3 packed unaligned dcl 14-7 set ref
                                                                                  14-7*
local_iocb                      000546 automatic       pointer                  dcl 869 set ref 60* 383* 390* 739* 787*
local_status_branch             001316 automatic       structure                level 1 unaligned dcl 629 set ref 647
long                      6(03)        based           bit(2)                   level 3 packed unaligned dcl 16-15 ref 121 519
make_consistent_msg             000550 automatic       char(500)                unaligned dcl 870 set ref 130* 133 133
mdbm_util_$free_temp_segment    000110 constant        entry                    external dcl 874 ref 241
mdbm_util_$get_temp_segment_path
                                000102 constant        entry                    external dcl 871 ref 79
mdbm_util_$inconsistent_reset   000104 constant        entry                    external dcl 872 ref 201
mdbm_util_$inconsistent_set     000106 constant        entry                    external dcl 873 ref 133
mdbm_util_$xref_build           000112 constant        entry                    external dcl 875 ref 54
mdbm_util_$xref_delete_record   000114 constant        entry                    external dcl 876 ref 383 787
mdbm_util_$xref_dereference     000120 constant        entry                    external dcl 878 ref 390 739
mdbm_util_$xref_destroy         000116 constant        entry                    external dcl 877 ref 65 192
mftxn_code                      000142 automatic       fixed bin(35,0)          dcl 4-54 set ref 184* 4-62* 4-65 4-68* 4-69 4-78
                                                                                  1-126* 1-132*
mftxn_temp_code                 000143 automatic       fixed bin(35,0)          dcl 4-55 set ref 4-71* 4-72 4-72* 4-82* 4-83 4-85*
                                                                                  4-86 4-86* 4-96* 4-97 4-99* 4-100 4-100* 4-109*
                                                                                  4-110 4-110*
move_string                            based           char                     unaligned dcl 635 set ref 661* 661
move_string_length              001353 automatic       fixed bin(35,0)          dcl 636 set ref 660* 661 661
mrds_error_$no_primary_key      000122 external static fixed bin(35,0)          dcl 879 ref 365
mrds_error_$no_unref_attr       000124 external static fixed bin(35,0)          dcl 880 set ref 464*
msg                                    parameter       char                     unaligned dcl 222 ref 218 227
mstxn_code                      000100 automatic       fixed bin(35,0)          dcl 1-65 set ref 1-83* 1-89* 1-90 1-99* 1-140 1-140*
                                                                                  4-90* 4-104* 1-137* 290* 291
mstxn_condition_info            000110 automatic       structure                level 1 unaligned dcl 1-77 set ref 1-123 1-123
mstxn_retries                   000101 automatic       fixed bin(17,0)          dcl 1-66 set ref 1-88* 4-78 4-81* 4-81
mstxn_temp_code                 000102 automatic       fixed bin(35,0)          dcl 1-67 set ref 1-109* 1-110 1-110* 1-123*
mstxn_transactions_needed       000103 automatic       bit(1)                   dcl 1-68 set ref 168 1-86 182 289* 298* 688
mstxn_txn_id                    000105 automatic       bit(36)                  dcl 1-70 set ref 61* 1-84* 1-89* 1-93 1-94* 1-99*
                                                                                  1-100 4-60 4-68* 4-71* 4-72* 4-82* 4-85* 4-86*
                                                                                  4-96* 4-99* 4-100* 4-109* 4-110* 4-114* 1-107
                                                                                  1-109* 1-110* 1-121 244 246* 247* 290* 293*
myname                          000100 constant        char(32)                 initial unaligned dcl 881 set ref 79* 88 241* 691
                                                                                  713* 808*
name                    142            based           char(32)                 level 3 in structure "rmdb_ctl" packed unaligned
                                                                                  dcl 12-25 in procedure "rmdb_delete_attribute" set
                                                                                  ref 54* 65* 192*
name                                   based           char(32)                 level 2 in structure "unreferenced_attribute"
                                                                                  dcl 10-159 in procedure "rmdb_delete_attribute"
                                                                                  ref 424 473
name                                   based           char(32)                 level 2 in structure "domain_info" dcl 10-125
                                                                                  in procedure "rmdb_delete_attribute" ref 315 318
                                                                                  390 399 439
name                                   based           char(32)                 level 2 in structure "relation" packed unaligned
                                                                                  dcl 15-77 in procedure "rmdb_delete_attribute" set
                                                                                  ref 366 645 653 666* 667 675* 676* 682* 683 694
                                                                                  700 704* 705 739* 774 787* 791* 792 797*
name                      1            based           char(33)                 array level 2 in structure "relation_list" packed
                                                                                  unaligned dcl 15-67 in procedure
                                                                                  "rmdb_delete_attribute" set ref 509*
name                      1            based           char(33)                 array level 2 in structure "attribute_list" packed
                                                                                  unaligned dcl 15-55 in procedure
                                                                                  "rmdb_delete_attribute" set ref 315* 315* 341 380
                                                                                  382* 414 418* 473* 495 498* 570* 577
names_relp                0(18)        based           bit(18)                  level 3 packed unaligned dcl 18-8 ref 649 651
new_file_model_ptr              001356 automatic       pointer                  dcl 638 set ref 652* 661
new_model_bit_count             001354 automatic       fixed bin(24,0)          dcl 637 set ref 652* 660
no_freeing                1(04) 000222 automatic       bit(1)                   level 3 packed unaligned dcl 835 set ref 87*
no_primary_key                  001246 automatic       bit(1)                   dcl 330 set ref 335* 344* 350 350 353 354* 363
null                                                   builtin function         dcl 882 ref 45 52 96 142 14-7 14-7 14-7 1-123 1-123
                                                                                  238 338 414 419 420 429 431 474 502 575 665 716
                                                                                  771 772 779 781
num_blk_files            13            based           fixed bin(17,0)          level 2 packed unaligned dcl 10-72 set ref 794* 794
num_rels                 14            based           fixed bin(17,0)          level 2 packed unaligned dcl 10-72 set ref 795* 795
owner                     2     000222 automatic       char(32)                 level 2 packed unaligned dcl 835 set ref 88*
padding                   1(07) 000162 automatic       bit(29)                  initial level 3 packed unaligned dcl 14-7 set ref
                                                                                  14-7*
part_of_key              16(02)        based           bit(1)                   array level 4 packed unaligned dcl 15-77 set ref 341
                                                                                  354
pointer                                                builtin function         dcl 887 ref 649 651
position                        000127 automatic       fixed bin(17,0)          dcl 557 set ref 580* 581 583* 583 584
previous_ptr                    000746 automatic       pointer                  dcl 886 set ref 419* 426* 431 433 771* 776* 781 783
prompt_after_explanation
                          1(06) 000162 automatic       bit(1)                   initial level 3 packed unaligned dcl 14-7 set ref
                                                                                  14-7*
ptr                                                    builtin function         dcl 887 ref 314 389 417 420 427 456 459 469 476 718
                                                                                  721 772 777
query_code                3     000162 automatic       fixed bin(35,0)          initial level 2 dcl 14-7 set ref 14-7*
query_info                      000162 automatic       structure                level 1 dcl 14-7 set ref 109* 541 541
query_info_version_6                   constant        fixed bin(17,0)          initial dcl 14-36 ref 110
query_iocb_ptr            4            based           pointer                  level 2 dcl 16-15 ref 114
question_iocbp            4     000162 automatic       pointer                  initial level 2 dcl 14-7 set ref 113* 14-7*
quit                            000750 stack reference condition                dcl 891 ref 162 204 205
quit_occurred                   000756 automatic       bit(1)                   dcl 892 set ref 158* 162* 205
r_index                         001352 automatic       fixed bin(17,0)          dcl 633 set ref 731* 736 738*
reference_count                 000757 automatic       fixed bin(21,0)          dcl 893 set ref 390* 396 739*
rel                                                    builtin function         dcl 894 ref 420 456 469 718 718 772
relation                               based           structure                level 1 unaligned dcl 15-77
relation_attribute_names               based           char                     unaligned dcl 15-76 ref 580
relation_copy_good        0(03)        based           bit(1)                   level 2 packed unaligned dcl 11-40 ref 658
relation_good_count             000760 automatic       fixed bin(17,0)          dcl 895 set ref 143* 147* 147 164
relation_idx              1            based           fixed bin(17,0)          array level 2 dcl 15-99 ref 339 509 579
relation_index                  000761 automatic       fixed bin(17,0)          dcl 896 set ref 145* 146* 164* 165* 350* 352* 561*
                                                                                  562*
relation_list                          based           structure                level 1 unaligned dcl 15-67
relation_list_ptr               000206 automatic       pointer                  dcl 15-64 set ref 96* 100* 145 146 165 339 350 352
                                                                                  509 561 562 579
relation_name                   000762 automatic       char(32)                 unaligned dcl 897 set ref 509* 510* 512*
relation_ptr                           based           pointer                  array level 2 in structure "relation_list" dcl 15-67
                                                                                  in procedure "rmdb_delete_attribute" ref 146 165
                                                                                  339 352 562 579
relation_ptr                    000210 automatic       pointer                  dcl 15-74 in procedure "rmdb_delete_attribute" set
                                                                                  ref 146* 165* 166 339* 340 341 341 345 352* 353
                                                                                  354 354 358 359 366 562* 563 579* 580 580 584 609*
                                                                                  645 653 666 667 675 676 682 683 694 700 704 705
                                                                                  716 718 723 724 731 736 738 739 758 759 774 787
                                                                                  791 792 797
release_area_                   000126 constant        entry                    external dcl 898 ref 240
relmgr_entries          152            based           structure                level 2 unaligned dcl 12-25 set ref 609 609 655
repeat_time              10     000162 automatic       fixed bin(71,0)          initial level 2 dcl 14-7 set ref 14-7*
request_name              7            based           char(32)                 level 2 packed unaligned dcl 16-15 set ref 541*
rmdb_add_rmdb_history           000130 constant        entry                    external dcl 899 ref 399 439 797
rmdb_copy_relation              000132 constant        entry                    external dcl 900 ref 609
rmdb_ctl                               based           structure                level 1 unaligned dcl 12-25
rmdb_ctl_ptr                    000156 automatic       pointer                  dcl 12-43 set ref 42* 51 52 54 54 54 54 60 65 65 65
                                                                                  70 72* 79 100* 140 192 192 192 609 609 609 655
rmdb_delete_all$attributes      000134 constant        entry                    external dcl 901 ref 72
rmdb_relations_used$attributes  000136 constant        entry                    external dcl 902 ref 100
rmdb_relmgr_entries                    based           structure                level 1 unaligned dcl 13-18
rmdb_relmgr_entries_ptr         000160 automatic       pointer                  dcl 13-32 set ref 655* 682 712
rtrim                                                  builtin function         dcl 903 ref 116 133 133 360 360 366 366 541 645 651
                                                                                  705 792
save_code                       000772 automatic       fixed bin(35,0)          dcl 904 set ref 143* 151* 190 194* 658 731
save_ptr                        000774 automatic       pointer                  dcl 905 set ref 419* 420 424* 429 431 433 436 771*
                                                                                  772 774* 779 781 783 785
saved_res_version_ptr
                        136            based           pointer                  level 2 dcl 12-25 ref 140
search_name                     000130 automatic       char(33)                 unaligned dcl 558 set ref 577* 580
segment_acl_entry                      based           structure                level 1 dcl 6-45
short                                  based           structure                level 2 dcl 18-8
size                     13     000222 automatic       fixed bin(18,0)          level 2 dcl 835 set ref 89*
source_dir               12     001362 automatic       char(168)                level 2 packed unaligned dcl 640 set ref 692*
source_name              64     001362 automatic       char(32)                 level 2 packed unaligned dcl 640 set ref 693*
status_area_ptr                 000216 automatic       pointer                  dcl 18-47 set ref 646* 648* 649 651
status_branch                          based           structure                level 1 dcl 18-8
status_code               2     000162 automatic       fixed bin(35,0)          initial level 2 dcl 14-7 set ref 14-7*
status_entry_names                     based           char(32)                 array dcl 18-47 ref 649 651
status_ptr                      000220 automatic       pointer                  dcl 18-47 set ref 647* 648* 649 651
substr                                                 builtin function         dcl 906 set ref 277 523* 570 651
suppress_name_sw          1(01) 000162 automatic       bit(1)                   initial level 3 packed unaligned dcl 14-7 set ref
                                                                                  112* 14-7*
suppress_spacing          1(04) 000162 automatic       bit(1)                   initial level 3 packed unaligned dcl 14-7 set ref
                                                                                  14-7*
switches                  1     000162 automatic       structure                level 2 dcl 14-7
sys_info$max_seg_size           000140 external static fixed bin(35,0)          dcl 907 ref 89
target_dir               74     001362 automatic       char(168)                level 2 packed unaligned dcl 640 set ref 692*
target_name             146     001362 automatic       char(32)                 level 2 packed unaligned dcl 640 set ref 694*
temp_dir_path            60            based           char(168)                level 2 packed unaligned dcl 12-25 set ref 54* 65*
                                                                                  79* 192* 609*
to_be_deleted            16(03)        based           bit(1)                   array level 4 packed unaligned dcl 15-77 set ref
                                                                                  345* 354 359*
to_char                         001544 automatic       fixed bin(17,0)          dcl 643 set ref 649* 650* 650 651
transaction_manager_$abandon_txn
                                000016 constant        entry                    external dcl 1-72 ref 4-72 4-86 4-100 4-110 1-110
                                                                                  247
transaction_manager_$abort_txn  000020 constant        entry                    external dcl 1-73 ref 4-71 4-85 4-99 4-109 1-109 246
transaction_manager_$begin_txn  000022 constant        entry                    external dcl 1-74 ref 1-99
transaction_manager_$commit_txn 000034 constant        entry                    external dcl 4-56 ref 4-68
transaction_manager_$get_current_txn_id
                                000024 constant        entry                    external dcl 1-75 ref 1-89 290
transaction_manager_$handle_conditions
                                000026 constant        entry                    external dcl 1-76 ref 1-135
transaction_manager_$rollback_txn
                                000036 constant        entry                    external dcl 4-57 ref 4-82 4-96
transactions_needed       0(34)        based           bit(1)                   level 3 packed unaligned dcl 10-72 ref 287
ua_ptr                          000152 automatic       pointer                  dcl 10-165 set ref 420* 420* 424 424 426* 427 456*
                                                                                  456* 459 469* 469* 473 475* 476
unreferenced             10(04)        based           bit(1)                   level 2 in structure "domain_info" packed unaligned
                                                                                  dcl 10-125 in procedure "rmdb_delete_attribute"
                                                                                  set ref 396*
unreferenced              6(01)        based           bit(1)                   level 3 in structure "delete_object_info" packed
                                                                                  unaligned dcl 16-15 in procedure
                                                                                  "rmdb_delete_attribute" ref 97 138
unreferenced_attribute                 based           structure                level 1 dcl 10-159 set ref 436
unreferenced_attribute_ptr
                         23            based           bit(18)                  level 2 packed unaligned dcl 10-72 set ref 420 431*
                                                                                  456 469
unspec                                                 builtin function         dcl 908 set ref 83* 109* 563* 696* 697*
user_area                              based           area(1024)               dcl 910 ref 467
user_area_ptr                   000776 automatic       pointer                  dcl 911 set ref 45* 79* 90 100* 238 240* 241* 467
                                                                                  646 666*
user_started_transaction        000104 automatic       bit(1)                   dcl 1-69 set ref 1-92* 1-98* 4-60
user_transaction_id             000106 automatic       bit(36)                  dcl 1-71 set ref 1-93* 1-100*
version                         000222 automatic       fixed bin(17,0)          level 2 in structure "ai" dcl 835 in procedure
                                                                                  "rmdb_delete_attribute" set ref 84*
version                         001362 automatic       char(8)                  level 2 in structure "co" dcl 640 in procedure
                                                                                  "switch_names" set ref 690*
version                                based           char(8)                  level 2 in structure "delete_object_info" packed
                                                                                  unaligned dcl 16-15 in procedure
                                                                                  "rmdb_delete_attribute" ref 47 47
version                         000162 automatic       fixed bin(17,0)          level 2 in structure "query_info" dcl 14-7
                                                                                  in procedure "rmdb_delete_attribute" set ref 110*
yes_or_no_sw              1     000162 automatic       bit(1)                   initial level 3 packed unaligned dcl 14-7 set ref
                                                                                  111* 14-7*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACL_VERSION_1                          internal static fixed bin(17,0)          initial dcl 6-77
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
DELETE_ACL_VERSION_1                   internal static char(4)                  initial unaligned dcl 6-67
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-33
DIR_ACL_VERSION_1                      internal static char(4)                  initial unaligned dcl 6-67
Directory                              internal static fixed bin(17,0)          initial dcl 18-56
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
GENERAL_DELETE_ACL_VERSION_1           internal static char(8)                  initial unaligned dcl 6-72
GENERAL_EXTENDED_ACL_VERSION_1         internal static char(8)                  initial unaligned dcl 6-72
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 2-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 2-12
Link                                   internal static fixed bin(17,0)          initial dcl 18-56
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
RMDB_ADD_ATTR_OP                       internal static fixed bin(17,0)          initial dcl 17-54
RMDB_ADD_DMN_OP                        internal static fixed bin(17,0)          initial dcl 17-56
RMDB_ADD_IDX_OP                        internal static fixed bin(17,0)          initial dcl 17-52
RMDB_ADD_REL_OP                        internal static fixed bin(17,0)          initial dcl 17-50
RMDB_CTL_VERSION_1                     internal static fixed bin(17,0)          initial dcl 12-41
RMDB_DEL_DMN_OP                        internal static fixed bin(17,0)          initial dcl 17-57
RMDB_DEL_IDX_OP                        internal static fixed bin(17,0)          initial dcl 17-53
RMDB_DOMAIN_TYPE                       internal static fixed bin(17,0)          initial dcl 17-45
RMDB_RN_ATTR_OP                        internal static fixed bin(17,0)          initial dcl 17-58
RMDB_RN_DMN_OP                         internal static fixed bin(17,0)          initial dcl 17-59
RMDB_RN_REL_OP                         internal static fixed bin(17,0)          initial dcl 17-60
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
R_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-30
SEG_ACL_VERSION_1                      internal static char(4)                  initial unaligned dcl 6-67
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
Segment                                internal static fixed bin(17,0)          initial dcl 18-56
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 2-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 2-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 2-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 2-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 2-20
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
acl_count                              automatic       fixed bin(17,0)          dcl 6-5
acl_ptr                                automatic       pointer                  dcl 6-4
ai_ptr                                 automatic       pointer                  dcl 11-209
al_ptr                                 automatic       pointer                  dcl 11-345
alloc_length                           internal static fixed bin(35,0)          dcl 10-222
area_infop                             automatic       pointer                  dcl 7-5
atd                                    based           char                     unaligned dcl 11-109
atd_len                                automatic       fixed bin(17,0)          dcl 11-111
atd_ptr                                automatic       pointer                  dcl 11-110
attr_info                              based           structure                level 1 dcl 11-192
attr_list                              based           structure                level 1 dcl 11-341
attribute_count                        automatic       fixed bin(17,0)          dcl 15-98
attribute_list_names                   based           char                     unaligned dcl 15-54
changer                                based           structure                level 1 packed unaligned dcl 10-251
changer_ptr                            automatic       pointer                  dcl 10-256
child_link_info                        based           structure                level 1 dcl 11-283
cli_ptr                                automatic       pointer                  dcl 11-329
cna_ptr                                automatic       pointer                  dcl 11-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 11-112
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
constant                               based           structure                level 1 unaligned dcl 10-216
constant_ptr                           automatic       pointer                  dcl 10-220
copy_options_ptr                       automatic       pointer                  dcl 9-10
crossref_info_record                   based           structure                level 1 unaligned dcl 15-19
crossref_info_record_count             automatic       fixed bin(21,0)          dcl 15-18
crossref_info_record_objects           based           char                     unaligned dcl 15-27
crossref_info_record_ptr               automatic       pointer                  dcl 15-17
delete_acl                             based           structure                level 1 dcl 6-58
delete_acl_array                       based           structure                array level 1 dcl 6-64
delete_object_info_count               automatic       fixed bin(17,0)          dcl 16-11
directory_acl                          based           structure                level 1 dcl 6-49
directory_acl_array                    based           structure                array level 1 dcl 6-55
domain_list                            based           structure                level 1 unaligned dcl 15-45
domain_list_count                      automatic       fixed bin(17,0)          dcl 15-43
domain_list_names                      based           char                     unaligned dcl 15-44
dp_ptr                                 automatic       pointer                  dcl 11-356
dup_prev                               based           structure                level 1 dcl 11-353
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 1-63
fixed                                                  builtin function         dcl 853
general_acl                            based           structure                level 1 dcl 6-7
general_delete_acl                     based           structure                level 1 dcl 6-30
general_extended_acl                   based           structure                level 1 dcl 6-18
message_str                            based           structure                level 1 packed unaligned dcl 10-259
message_str_len                        automatic       fixed bin(17,0)          dcl 10-269
message_str_ptr                        automatic       pointer                  dcl 10-267
ncomp_init                             automatic       fixed bin(17,0)          dcl 11-116
parent_link_info                       based           structure                level 1 dcl 11-223
path_entry                             based           structure                level 1 packed unaligned dcl 10-172
path_entry_ptr                         automatic       pointer                  dcl 10-177
pli_ptr                                automatic       pointer                  dcl 11-268
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 14-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 14-34
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 14-35
rel_info                               based           structure                level 1 dcl 11-126
relation_attribute_count               automatic       fixed bin(17,0)          dcl 15-75
relation_list_count                    automatic       fixed bin(17,0)          dcl 15-65
relation_list_names                    based           char                     unaligned dcl 15-66
ri_ptr                                 automatic       pointer                  dcl 11-185
rmdb_history_entry                     based           structure                level 1 dcl 17-31
rmdb_history_entry_ptr                 automatic       pointer                  dcl 17-42
sc_ptr                                 automatic       pointer                  dcl 11-365
segment_acl                            based           structure                level 1 dcl 6-40
segment_acl_array                      based           structure                array level 1 dcl 6-46
select_chain                           based           structure                level 1 dcl 11-357
sk_ptr                                 automatic       pointer                  dcl 11-352
sort_key                               based           structure                level 1 dcl 11-346
stack_item                             based           structure                level 1 unaligned dcl 10-206
stack_item_ptr                         automatic       pointer                  dcl 10-212
status_link                            based           structure                level 1 dcl 18-38
status_pathname                        based           char                     dcl 18-47
version_status                         based           structure                level 1 packed unaligned dcl 10-232
version_status_ptr                     automatic       pointer                  dcl 10-246

NAMES DECLARED BY EXPLICIT CONTEXT.
RETURN_TO_CALLER                002305 constant        label                    dcl 231 ref 228
all_attributes_are_deleted      007052 constant        entry                    internal dcl 753 ref 607
check_for_deletion_of_generated_attributes
                                002733 constant        entry                    internal dcl 310 ref 105
check_for_deletion_of_primary_key
                                003053 constant        entry                    internal dcl 325 ref 128
cleaner                         002506 constant        entry                    internal dcl 235 ref 67 173 231
cleanup_directory               001536 constant        label                    dcl 158 ref 152
delete_file                     007340 constant        entry                    internal dcl 800 ref 791 792
delete_relation_information     007103 constant        entry                    internal dcl 767 ref 607
delete_unreferenced_attribute_list
                                004015 constant        entry                    internal dcl 410 ref 199
error                           002442 constant        entry                    internal dcl 218 ref 47 56 80 93 102 124 1-140 194
                                                                                  211 294 318 366 385 392 461 464 591 653 667 671
                                                                                  683 700 705 727 741 811
make_name                       002611 constant        entry                    internal dcl 264 ref 473
make_unreferenced_attribute_list
                                004241 constant        entry                    internal dcl 451 ref 97
mftxn_check_code                001756 constant        label                    dcl 4-65 ref 1-127 1-133
mftxn_exit                      002176 constant        label                    dcl 4-115 ref 4-63
mstxn_any_other                 002344 constant        entry                    internal dcl 1-116 ref 175
mstxn_cleanup                   002312 constant        entry                    internal dcl 1-102 ref 172
mstxn_exit                      001722 constant        label                    dcl 1-140 ref 1-86 1-95 4-91 4-105
print_information               004467 constant        entry                    internal dcl 485 ref 119
process_single_relation         005437 constant        entry                    internal dcl 604 ref 148
process_xref_records            003524 constant        entry                    internal dcl 376 ref 202
query                           005104 constant        entry                    internal dcl 536 ref 520
recalculate_attributes_deleted  005215 constant        entry                    internal dcl 553 ref 531
restore_significant_data        002603 constant        entry                    internal dcl 254 ref 4-77
rmdb_delete_attribute           000564 constant        entry                    external dcl 39
should_rollback                 002605 constant        entry                    internal dcl 259 ref 4-94
switch_names                    005512 constant        entry                    internal dcl 626 ref 180
transaction_in_progress         002666 constant        entry                    internal dcl 284 ref 167
unmake_name                     002644 constant        entry                    internal dcl 272 ref 315 358 382 418 498 509 738

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10430       10576    7536       10440
Length     11500    7536       146         666     671           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rmdb_delete_attribute              1752 external procedure  is an external procedure.  
on unit on line 63                   88 on unit               
on unit on line 162                  64 on unit               
on unit on line 170                  76 on unit               
on unit on line 175                  82 on unit               
mstxn_cleanup                           internal procedure  shares stack frame of on unit on line 170.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 175.  
error                                65 internal procedure  is called during a stack extension.  
cleaner                              84 internal procedure  is called by several nonquick procedures.  
restore_significant_data                internal procedure  shares stack frame of external procedure rmdb_delete_attribute.  
should_rollback                         internal procedure  shares stack frame of external procedure rmdb_delete_attribute.  
make_name                               internal procedure  shares stack frame of external procedure rmdb_delete_attribute.  
unmake_name                          65 internal procedure  is called by several nonquick procedures.  
transaction_in_progress                 internal procedure  shares stack frame of external procedure rmdb_delete_attribute.  
check_for_deletion_of_generated_attributes
                                        internal procedure  shares stack frame of external procedure rmdb_delete_attribute.  
check_for_deletion_of_primary_key
                                        internal procedure  shares stack frame of external procedure rmdb_delete_attribute.  
process_xref_records                    internal procedure  shares stack frame of external procedure rmdb_delete_attribute.  
delete_unreferenced_attribute_list
                                        internal procedure  shares stack frame of external procedure rmdb_delete_attribute.  
make_unreferenced_attribute_list
                                        internal procedure  shares stack frame of external procedure rmdb_delete_attribute.  
print_information                   190 internal procedure  uses auto adjustable storage.  
query                                   internal procedure  shares stack frame of internal procedure print_information.  
recalculate_attributes_deleted
                                        internal procedure  shares stack frame of internal procedure print_information.  
process_single_relation                 internal procedure  shares stack frame of external procedure rmdb_delete_attribute.  
switch_names                            internal procedure  shares stack frame of external procedure rmdb_delete_attribute.  
all_attributes_are_deleted              internal procedure  shares stack frame of external procedure rmdb_delete_attribute.  
delete_relation_information             internal procedure  shares stack frame of external procedure rmdb_delete_attribute.  
delete_file                         106 internal procedure  is called during a stack extension.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
print_information        000100 first_cancel_attribute      print_information
                         000100 cancel_attribute            print_information
                         000116 answer                      query
                         000126 have_attributes_to_process  recalculate_attributes_deleted
                         000127 position                    recalculate_attributes_deleted
                         000130 search_name                 recalculate_attributes_deleted
rmdb_delete_attribute    000100 mstxn_code                  rmdb_delete_attribute
                         000101 mstxn_retries               rmdb_delete_attribute
                         000102 mstxn_temp_code             rmdb_delete_attribute
                         000103 mstxn_transactions_needed   rmdb_delete_attribute
                         000104 user_started_transaction    rmdb_delete_attribute
                         000105 mstxn_txn_id                rmdb_delete_attribute
                         000106 user_transaction_id         rmdb_delete_attribute
                         000110 mstxn_condition_info        rmdb_delete_attribute
                         000142 mftxn_code                  rmdb_delete_attribute
                         000143 mftxn_temp_code             rmdb_delete_attribute
                         000144 dbm_ptr                     rmdb_delete_attribute
                         000146 fi_ptr                      rmdb_delete_attribute
                         000150 di_ptr                      rmdb_delete_attribute
                         000152 ua_ptr                      rmdb_delete_attribute
                         000154 fm_ptr                      rmdb_delete_attribute
                         000156 rmdb_ctl_ptr                rmdb_delete_attribute
                         000160 rmdb_relmgr_entries_ptr     rmdb_delete_attribute
                         000162 query_info                  rmdb_delete_attribute
                         000200 domain_list_ptr             rmdb_delete_attribute
                         000202 attribute_list_ptr          rmdb_delete_attribute
                         000204 attribute_list_count        rmdb_delete_attribute
                         000206 relation_list_ptr           rmdb_delete_attribute
                         000210 relation_ptr                rmdb_delete_attribute
                         000212 attribute_ptr               rmdb_delete_attribute
                         000214 delete_object_info_ptr      rmdb_delete_attribute
                         000216 status_area_ptr             rmdb_delete_attribute
                         000220 status_ptr                  rmdb_delete_attribute
                         000222 ai                          rmdb_delete_attribute
                         000254 attribute_idx               rmdb_delete_attribute
                         000255 attribute_list_idx          rmdb_delete_attribute
                         000256 attribute_name              rmdb_delete_attribute
                         000274 code                        rmdb_delete_attribute
                         000275 db_path                     rmdb_delete_attribute
                         000347 error_message               rmdb_delete_attribute
                         000544 last_unreferenced_attribute_ptr
                                                            rmdb_delete_attribute
                         000546 local_iocb                  rmdb_delete_attribute
                         000550 make_consistent_msg         rmdb_delete_attribute
                         000746 previous_ptr                rmdb_delete_attribute
                         000756 quit_occurred               rmdb_delete_attribute
                         000757 reference_count             rmdb_delete_attribute
                         000760 relation_good_count         rmdb_delete_attribute
                         000761 relation_index              rmdb_delete_attribute
                         000762 relation_name               rmdb_delete_attribute
                         000772 save_code                   rmdb_delete_attribute
                         000774 save_ptr                    rmdb_delete_attribute
                         000776 user_area_ptr               rmdb_delete_attribute
                         001050 attr_idx                    check_for_deletion_of_primary_key
                         001051 deletion_attributes         check_for_deletion_of_primary_key
                         001246 no_primary_key              check_for_deletion_of_primary_key
                         001316 local_status_branch         switch_names
                         001330 create_model_name           switch_names
                         001340 create_relation_name        switch_names
                         001350 data_acl_ptr                switch_names
                         001352 r_index                     switch_names
                         001353 move_string_length          switch_names
                         001354 new_model_bit_count         switch_names
                         001356 new_file_model_ptr          switch_names
                         001360 last_file_info_ptr          switch_names
                         001362 co                          switch_names
                         001542 cvds                        switch_names
                         001543 ivds                        switch_names
                         001544 to_char                     switch_names
                         001554 attribute_idx               all_attributes_are_deleted

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ext_out_desc
call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc call_int_other      return_mac
tra_ext_1           alloc_auto_adj      signal_op           enable_op           shorten_stack       ext_entry_desc
int_entry           int_entry_desc      set_chars_eis       index_chars_eis     op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
command_query_                continue_to_signal_           define_area_                  delete_$path
delete_$path                  find_condition_info_          fs_util_$copy                 fs_util_$delentry_file
fs_util_$get_switch           fs_util_$list_acl             fs_util_$replace_acl          fs_util_$set_switch
hcs_$chname_file              hcs_$status_                  initiate_file_                ioa_$ioa_switch
ioa_$ioa_switch_nnl           mdbm_util_$free_temp_segment  mdbm_util_$get_temp_segment_path
mdbm_util_$inconsistent_reset mdbm_util_$inconsistent_set   mdbm_util_$xref_build         mdbm_util_$xref_delete_record
mdbm_util_$xref_dereference   mdbm_util_$xref_destroy       release_area_                 rmdb_add_rmdb_history
rmdb_copy_relation            rmdb_delete_all$attributes    rmdb_relations_used$attributes
transaction_manager_$abandon_txn                            transaction_manager_$abort_txn
transaction_manager_$begin_txn                              transaction_manager_$commit_txn
transaction_manager_$get_current_txn_id                     transaction_manager_$handle_conditions
transaction_manager_$rollback_txn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$lock_deadlock       dm_error_$no_current_transaction
error_table_$action_not_performed                           error_table_$no_record
error_table_$unimplemented_version                          error_table_$unsupported_operation
mrds_error_$no_primary_key    mrds_error_$no_unref_attr     sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     39 000557   14    7 000577        42 000627        43 000633        45 000636        47 000640        51 000676
     52 000703        54 000707        56 000746        60 000764        61 000767        63 000770        65 001004
     67 001037        68 001044        70 001045        72 001050        79 001076        80 001124        83 001145
     84 001150        85 001152        86 001154        87 001156        88 001160        89 001163        90 001166
     92 001170        93 001202        96 001226        97 001232       100 001240       102 001300       105 001316
    107 001317       109 001323       110 001326       111 001330       112 001332       113 001334       114 001336
    115 001340       116 001342       119 001354       121 001360       123 001367       124 001370       128 001404
    130 001405       133 001410       138 001464       140 001471       142 001476       143 001500       145 001502
    146 001511       147 001526       148 001527       149 001530       151 001532       152 001533       154 001534
    158 001536       162 001537       164 001557       165 001567       166 001604       167 001606       168 001607
    170 001611       172 001625       173 001626       174 001633       175 001634    1   83 001652    1   84 001653
 1   86 001654    1   88 001656    1   89 001657    1   90 001670    1   92 001674    1   93 001676    1   94 001700
 1   95 001701    1   98 001702    1   99 001703    1  100 001720    1  140 001722       180 001743       182 001744
    184 001746    4   60 001747    4   62 001754    4   63 001755    4   65 001756    4   68 001760    4   69 001771
 4   71 001773    4   72 002004    4   75 002017    4   77 002020    4   78 002021    4   81 002030    4   82 002031
 4   83 002044    4   85 002046    4   86 002057    4   88 002072    4   90 002073    4   91 002074    4   93 002075
 4   94 002076    4   96 002103    4   97 002117    4   99 002121    4  100 002132    4  102 002145    4  104 002146
 4  105 002147    4  107 002150    4  109 002151    4  110 002162    4  114 002175       187 002176       190 002200
    192 002202       194 002235       199 002251       201 002252       202 002261       204 002262       205 002263
    208 002270       211 002271       231 002305       233 002311    1  102 002312    1  107 002313    1  109 002316
 1  110 002327    1  114 002343    1  116 002344    1  121 002345    1  123 002350    1  124 002367    1  126 002375
 1  127 002400    1  129 002403    1  132 002415    1  133 002420    1  135 002423    1  136 002430    1  137 002431
 1  138 002440       218 002441       224 002455       225 002462       227 002472       228 002502       235 002505
    238 002513       240 002520       241 002526       244 002551       246 002554       247 002565       251 002602
    254 002603       256 002604       259 002605       261 002607       264 002611       269 002622       272 002643
    277 002657       284 002666       287 002667       289 002672       290 002674       291 002705       293 002707
    294 002710       297 002730       298 002731       300 002732       310 002733       313 002734       314 002743
    315 002762       318 003025       320 003050       322 003052       325 003053       334 003054       335 003057
    336 003061       337 003071       338 003113       339 003127       340 003145       341 003155       344 003204
    345 003205       347 003210       348 003212       349 003214       350 003216       352 003231       353 003246
    354 003257       358 003272       359 003323       360 003330       361 003402       362 003403       363 003405
    365 003407       366 003412       367 003520       368 003521       369 003523       376 003524       379 003525
    380 003535       382 003543       383 003565       385 003616       389 003643       390 003663       392 003727
    396 003751       399 003757       401 004012       403 004014       410 004015       413 004016       414 004025
    417 004063       418 004100       419 004121       420 004124       424 004141       426 004150       427 004151
    429 004157       431 004163       433 004175       436 004201       439 004203       442 004236       444 004240
    451 004241       455 004242       456 004243       458 004255       459 004256       461 004265       464 004311
    467 004326       468 004354       469 004355       472 004367       473 004370       474 004416       475 004442
    476 004457       478 004465       485 004466       488 004474       491 004504       492 004512       494 004513
    495 004524       497 004532       498 004555       500 004577       502 004604       506 004635       508 004671
    509 004702       510 004730       512 004761       514 005017       515 005022       519 005042       520 005053
    523 005063       524 005071       529 005075       531 005100       534 005103       536 005104       541 005106
    543 005175       545 005211       553 005215       561 005216       562 005230       563 005245       564 005246
    568 005250       569 005251       570 005262       573 005275       574 005277       575 005321       577 005325
    578 005333       579 005344       580 005362       581 005403       583 005404       584 005407       586 005412
    589 005414       591 005416       594 005436       604 005437       607 005440       609 005447       611 005511
    626 005512       645 005513       646 005542       647 005545       648 005547       649 005604       650 005621
    651 005623       652 005640       653 005675       655 005722       658 005725       660 005733       661 005736
    665 005743       666 005745       667 006001       670 006026       671 006061       674 006105       675 006107
    676 006144       678 006204       679 006241       682 006301       683 006322       688 006347       690 006351
    691 006353       692 006356       693 006367       694 006372       696 006376       697 006377       699 006400
    700 006413       702 006440       704 006441       705 006467       707 006554       712 006555       713 006577
    716 006632       718 006637       720 006654       721 006656       723 006664       724 006670       727 006672
    730 006714       731 006715       736 006727       738 006734       739 006765       741 007025       745 007047
    747 007051       753 007052       758 007054       759 007065       761 007075       763 007077       767 007103
    771 007104       772 007107       774 007125       776 007135       777 007136       779 007144       781 007150
    783 007161       785 007165       787 007167       791 007221       792 007231       794 007270       795 007277
    797 007304       798 007336       800 007337       807 007353       808 007375       811 007436       814 007501


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
