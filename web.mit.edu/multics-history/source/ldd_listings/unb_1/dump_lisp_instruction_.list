	COMPILATION LISTING OF SEGMENT dump_lisp_instruction_
	Compiled by: Multics PL/I Compiler, Release 28b, of April 11, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 06/30/83  0842.0 mst Thu
	    Options: map single_symbol_list

        1 /* **************************************************************
        2*   *                                                            *
        3*   * Copyright, (C) Massachusetts Institute of Technology, 1973 *
        4*   *                                                            *
        5*   ************************************************************** */
        6 /* protect old protection notice */
        7 /* (c) Copyright 1973, Massachusetts Institute of Technology.
        8*       All rights reserved.					*/
        9 
       10 dump_lisp_instruction_:
       11 	proc(a_word, ic, a_tablep, a_tra_table_p) returns(char(*));
       12 
       13 /* modified 73.11.28 by DAM for new subr blocks */
       14 /* modified '78 by BSG for unwind-protect ops */
       15 
       16 dcl a_word bit(36) aligned parameter,
       17     a_tablep pointer parameter,
       18     ic fixed bin(18) parameter,
       19     a_tra_table_p pointer parameter;
       20 
       21 
       22 dcl
       23 	abr bit(1) unal defined(word) pos(30),
       24 	addr builtin,
       25 	addrb bit(18) unal defined(word) pos(1),
       26 	addrf fixed bin(17) unal based(addr(word)),
       27 	base bit(3) unal defined(word) pos(1),
       28 	bin builtin,
       29 	dl bit(6) int static init("000111"b),
       30 	du bit(6) int static init("000011"b),
       31 	mod bit(6) unal defined(word) pos(31),
       32 	offsetb bit(15) unal defined(word) pos(4),
       33 	offsetf fixed bin(14) unal based(addr(offsetb)),
       34 	opcode bit(9) unal defined(word) pos(19),
       35 	hopcode bit(1) unal defined (word) pos(28),	/* opcode extension */
       36 	output char(64) var,
       37 	operator fixed bin,
       38 	atom_name_ptr unaligned pointer,
       39 	atom_name char(10000) varying aligned based(atom_name_ptr),
       40 
       41 	link_info (1000) bit(27) aligned based,
       42 	1 link aligned automatic structure,		/* lisp itp link */
       43 	  2 address fixed bin(14) unaligned,
       44 	  2 snap bit(1) unaligned,
       45 	  2 constant bit(1) unaligned,
       46 	  2 f bit(1) unaligned,
       47 	  2 nargs bit(9) unaligned,
       48 
       49 	array_link_control_word(100) bit(36) aligned based,
       50 	1 array_link aligned automatic structure,
       51 	  2 type fixed bin(8) unaligned,
       52 	  2 ndims fixed bin(8) unaligned,
       53 	   2 address fixed bin(17) unaligned,
       54 
       55 	(comment_sw, atom_sw, link_sw, tempf) bit(1) aligned,
       56 	lbound builtin,
       57 	hbound builtin,
       58 	substr builtin,
       59 	convert_sfl_ entry(float bin(27), fixed bin) returns(char(*)),
       60 	word bit(36) init(a_word);
       61 
       62 dcl (mll_internal_error, mll_internal_error_2) condition;
       63 
       64 dcl tablep pointer init(a_tablep);
       65 
       66 /* table of all locations referenced by transfer instructions */
       67 
       68 dcl tra_table_p pointer init(a_tra_table_p),
       69 
       70     1 tra_table aligned based(tra_table_p),
       71     2 number_of_labels fixed bin,
       72     2 label(0 refer(number_of_labels)) structure,	/* sorted by address */
       73       3 address fixed bin(18),			/* location labelled */
       74       3 stack_ht fixed bin(18),			/* stack_height at tra here, -1 if not known yet */
       75       3 tra_from fixed bin(18),			/* loc of tra to here */
       76       3 save_bind_stack_ptr fixed bin,			/* Value of binding stack ptr */
       77       3 tra_from_others bit(1);			/* 1 -> tra_from is not only place that tras here */
       78 
       79 dcl constp pointer,
       80     1 word_pair aligned based,
       81       2 (w1, w2) fixed bin(35);
       82 
       83 	/* declare various tables which are based on tablep */
       84 
       85 dcl 1 table aligned structure based(tablep),
       86     2 stack_height fixed bin(17),			/* add to ap offset to get 2 * temp number */
       87     2 atom_table_size fixed bin,			/* size of atom_table array */
       88     2 link_table_ptr unaligned pointer,		/* -> array of itp link info */
       89     2 link_table_lbound fixed bin(18),			/* first lp| offset of itp link */
       90     2 link_table_hbound fixed bin(18),			/* last lp| offset of itp link */
       91     2 array_link_table_ptr unaligned pointer,		/* -> array of array_link control words */
       92     2 array_link_table_lbound fixed bin(18),		/* first lp| offset of array link */
       93     2 array_link_table_hbound fixed bin(18),		/* last lp| offset of array link */
       94     2 definition_table_size fixed bin,			/* size of definition_table array */
       95     2 constant_table_size fixed bin,			/* size of constant_table array */
       96     2 constant_table_lbound fixed bin(18),		/* first lp| offset of constant */
       97     2 constant_table_hbound fixed bin(18),		/* last lp| offset of constant */
       98     2 bind_stack_ptr fixed bin,			/* index of first unused entry in bind_stack */
       99     2 arg_twiddle fixed bin(18),			/* eax5 hacker */
      100     2 seg_ptr unaligned pointer,			/* -> text section */
      101     2 bind_stack (100) fixed bin,			/* table of sizes of nested binding blocks */
      102     2 atom_table (0 refer(atom_table_size)),		/* pointers to atomic symbols */
      103       3 ptr_to_name unaligned pointer,			/* -> varying string */
      104     2 definition_table(0 refer(definition_table_size)),	/* entries defined... */
      105       3 arg_pdl bit(18) unaligned,			/* number of pdl cells occupied by args */
      106       3 entrypoint bit(18) unaligned,			/* location of entry */
      107       3 ptr_to_name unaligned pointer,			/* -> varying string */
      108     2 constant_table(0 refer(constant_table_size)),
      109       3 atom_table_index fixed bin,			/* 0 if this constant not an atom */
      110 
      111     traref fixed bin(18),
      112     (labu, labx, labh) fixed bin;
      113 
      114 dcl
      115 	absolute(0:1023) bit(1) int static init(
      116 	(8)(1)"0"b,
      117 	(8)(1)"0"b,
      118 	(8)(1)"0"b,
      119 	(8)(1)"0"b,
      120 	(8)(1)"0"b,
      121 	(8)(1)"0"b,
      122 	(8)(1)"0"b,
      123 	(8)(1)"0"b,
      124 	(8)(1)"0"b,
      125 	(8)(1)"0"b,
      126 	(8)(1)"0"b,
      127 	(8)(1)"0"b,
      128 	(8)(1)"0"b,
      129 	(8)(1)"0"b,
      130 	(8)(1)"0"b,
      131 	(8)(1)"0"b,
      132 	(8)(1)"1"b,		/* cnaxN */
      133 	(5)(1)"0"b, "1"b, "1"b, "0"b,	/* cnaa, cnaq */
      134 	(8)(1)"0"b,
      135 	(8)(1)"0"b,
      136 	(8)(1)"0"b,
      137 	(8)(1)"0"b,
      138 	(8)(1)"1"b,		/* orxN */
      139 	(5)(1)"0"b, "1"b, "1"b, "0"b,	/* ora, orq */
      140 	(8)(1)"1"b,		/* canxN */
      141 	(5)(1)"0"b, "1"b, "1"b, "0"b,	/* cana, canq */
      142 	(8)(1)"0"b,
      143 	(8)(1)"0"b,
      144 	(8)(1)"0"b,
      145 	(8)(1)"0"b,
      146 	(8)(1)"1"b,		/* anxN */
      147 	(5)(1)"0"b, "1"b, "1"b, "0"b,	/* ana, anq */
      148 	(160)(1)"0"b,
      149 	(8)(1)"0"b,
      150 	(8)(1)"0"b,
      151 	(8)(1)"1"b,		/* erxN */
      152 	(5)(1)"0"b, "1"b, "1"b, "0"b,	/* era, erq */
      153 	(64)(1)"0"b,
      154 	(512)(1)"0"b);
      155 
      156 dcl
      157 	bases(0:8) char(3) aligned int static init(
      158 	 "ms|", "op|", "tp|", "cp|", "lp|", "rp|", "sp|", "sb|", "us|");
      159 
      160 dcl
      161 	op_names(4:52) char(25) varying static init(
      162 		"old array store ptr",
      163 		"nil",
      164 		"t",
      165 		"bad addr?",
      166 		"bind operator",
      167 		"unbind operator",
      168 		"errset operator 1",
      169 		"errset operator 2",
      170 		"errset remover",
      171 		"call operator",
      172 		"catch operator 1",
      173 		"catch operator 2",
      174 		"catch remover",
      175 		"bad addr?",
      176 		"bad addr?",
      177 		"iog binding operator",
      178 		"bad goto operator",
      179 		"throw operator 1",
      180 		"throw operator 2",
      181 		"set indicators from sign",
      182 		"fixtype,flotype",
      183 		"return operator",
      184 		"err operator",
      185 		"pl1-interface operator",
      186 		"pl1-l-interface operator",
      187 		"cons operator",
      188 		"ncons operator",
      189 		"xcons operator",
      190 		"begin list operator",
      191 		"append list operator",
      192 		"terminate list operator",
      193 		"numeric compare operator",
      194 		"bad addr?",
      195 		"array reference op?",
      196 		"dead array ref op?",
      197 		"store operator",
      198 		"flonum store operator",
      199 		"bad addr?",
      200 		"bad addr?",
      201 		"array link snap opr?",
      202 		"create string descriptor",
      203 		"create array descriptor",
      204 		"pl1 call operator",
      205 		"cons string operator",
      206 		"create var string desc op",
      207 		"unwind protect operator 1",
      208 		"unwind protect operator 2",
      209 		"unwind protect epilogue",
      210 		"interrupt restore return");
      211 
      212 dcl op_stack_adj(4:52) fixed bin static init(	/* stack adjustments of these operators */
      213 	0, 0, 0, 0,
      214 	0,		/* bind is special */
      215 	0,		/* unbind is special */
      216 	2,		/* errset1 */
      217 	0,		/* errset2 */
      218 	-2,		/* unerrset */
      219 	0,		/* call is special */
      220 	2,		/* catch1 */
      221 	0,		/* catch2 */
      222 	-2,		/* uncatch */
      223 	0,		/* prologue interpreter?? */
      224 	0,		/* ?? */
      225 	16,		/* iogbind */
      226 	0,		/* unseen go tag */
      227 	0,		/* throw1 (never returns) */
      228 	0,		/* throw2 (never returns) */
      229 	0,		/* signp */
      230 	0,		/* ?? */
      231 	0,		/* return (never returns) */
      232 	0,		/* err (never returns) */
      233 	0,		/* ?? */
      234 	0,		/* ?? */
      235 	0,		/* cons */
      236 	0,		/* ncons */
      237 	0,		/* xcons */
      238 	2,		/* list1 */
      239 	0,		/* list2 */
      240 	-2,		/* list3 */
      241 	0,		/* compare */
      242 	0,0,0,0,0,0,0,0,	/* array oprs */
      243 	0,0,0,0,		/* defpl1 operators */
      244 	0,0,0,0,0		/* var string desc and unm_prots */
      245     );
      246 
      247 dcl op_special (4:52) fixed bin static init(		/* special action code */
      248 	0, 0, 0, 0,
      249 	0,		/* bind */
      250 	1,		/* unbind */
      251 	0, 0, 0,
      252 	3,		/* call */
      253 	0, 0, 0, 0, 0,
      254 	2,		/* iog bind */
      255 	(33)0);
      256 
      257 dcl
      258 	tags(0:63) char(4) aligned int static init(
      259 	",00", ",au ", ",qu ", ",du ", ",ic ", ",al ", ",ql ", ",dl ",               
      260 	",x0 ", ",x1 ", ",x2 ", ",x3 ", ",x4 ", ",x5 ", ",x6 ", ",x7 ",               
      261 	",*  ", ",au*", ",qu*", ",23 ", ",ic*", ",al*", ",ql*", ",27 ",               
      262 	",x0*", ",x1*", ",x2*", ",x3*", ",x4*", ",x5*", ",x6*", ",x7*",               
      263 	",ft1", ",itb", ",42 ", ",its", ",sd ", ",scr", ",ft2", ",ft3",               
      264 	",ci ", ",i  ", ",sc ", ",ad ", ",di ", ",dir", ",id ", ",idc",               
      265 	",*n ", ",*au", ",*qu", ",*du", ",*ic", ",*al", ",*ql", ",*dl",               
      266 	",*x0", ",*x1", ",*x2", ",*x3", ",*x4", ",*x5", ",*x6", ",*x7");              
      267 
      268 dcl
      269 	op_codes(0:1023) char(8) aligned int static init(
      270 "arg  ", "mme  ", "drl  ", "***  ", "mme2 ", "mme3 ", "***  ", "mme4 ", 
      271 "***  ", "nop  ", "***  ", "***  ", "***  ", "cioc ", "***  ", "***  ", 
      272 "adlx0", "adlx1", "adlx2", "adlx3", "adlx4", "adlx5", "adlx6", "adlx7", 
      273 "***  ", "***  ", "ldqc ", "adl  ", "ldac ", "adla ", "adlq ", "adlaq",
      274 "asx0 ", "asx1 ", "asx2 ", "asx3 ", "asx4 ", "asx5 ", "asx6 ", "asx7 ", 
      275 "adwpms", "adwpop", "adwptp", "adwpcp", "aos  ", "asa  ", "asq  ", "***  ", 
      276 "adx0 ", "adx1 ", "adx2 ", "adx3 ", "adx4 ", "adx5 ", "adx6 ", "adx7 ", 
      277 "***  ", "awca ", "awcq ", "lreg ", "***  ", "ada  ", "adq  ", "adaq ", 
      278 "cmpx0", "cmpx1", "cmpx2", "cmpx3", "cmpx4", "cmpx5", "cmpx6", "cmpx7", 
      279 "***  ", "cwl  ", "***  ", "***  ", "***  ", "cmpa ", "cmpq ", "cmpaq", 
      280 "sblx0", "sblx1", "sblx2", "sblx3", "sblx4", "sblx5", "sblx6", "sblx7", 
      281 "***  ", "***  ", "***  ", "***  ", "***  ", "sbla ", "sblq ", "sblaq", 
      282 "ssx0 ", "ssx1 ", "ssx2 ", "ssx3 ", "ssx4 ", "ssx5 ", "ssx6 ", "ssx7 ", 
      283 "adwplp", "adwprp", "adwpsp", "adwpsb", "sdbr ", "ssa  ", "ssq  ", "zam  ", 
      284 "sbx0 ", "sbx1 ", "sbx2 ", "sbx3 ", "sbx4 ", "sbx5 ", "sbx6 ", "sbx7 ", 
      285 "***  ", "swca ", "swcq ", "ldb  ", "***  ", "sba  ", "sbq  ", "sbaq ", 
      286 "cnax0", "cnax1", "cnax2", "cnax3", "cnax4", "cnax5", "cnax6", "cnax7", 
      287 "***  ", "cmk  ", "absa ", "epaq ", "sznc ", "cnaa ", "cnaq ", "cnaaq",
      288 "ldx0 ", "ldx1 ", "ldx2 ", "ldx3 ", "ldx4 ", "ldx5 ", "ldx6 ", "ldx7 ", 
      289 "***  ", "rsw  ", "ldbr ", "rmcm ", "szn  ", "lda  ", "ldq  ", "ldaq ", 
      290 "orsx0", "orsx1", "orsx2", "orsx3", "orsx4", "orsx5", "orsx6", "orsx7", 
      291 "sprims", "spbpms", "spritp", "spbptp", "spri ", "orsa ", "orsq ", "lam  ", 
      292 "orx0 ", "orx1 ", "orx2 ", "orx3 ", "orx4 ", "orx5 ", "orx6 ", "orx7 ", 
      293 "tspms", "tspop", "call ", "tspcp", "***  ", "ora  ", "orq  ", "oraq ", 
      294 "canx0", "canx1", "canx2", "canx3", "canx4", "canx5", "canx6", "canx7", 
      295 "eawpms", "easpms", "eawptp", "easptp", "***  ", "cana ", "canq ", "canaq", 
      296 "lcx0 ", "lcx1 ", "lcx2 ", "lcx3 ", "lcx4 ", "lcx5 ", "lcx6 ", "lcx7 ", 
      297 "eawplp", "easplp", "eawpsp", "easpsp", "***  ", "lca  ", "lcq  ", "lcaq ", 
      298 "ansx0", "ansx1", "ansx2", "ansx3", "ansx4", "ansx5", "ansx6", "ansx7", 
      299 "eppms", "epbpop", "epptp", "epbpcp", "stac ", "ansa ", "ansq ", "stcd ", 
      300 "anx0 ", "anx1 ", "anx2 ", "anx3 ", "anx4 ", "anx5 ", "anx6 ", "anx7 ", 
      301 "epplp", "epbprp", "eppsp", "epbpsb", "***  ", "ana  ", "anq  ", "anaq ", 
      302 "***  ", "mpf  ", "mpy  ", "***  ", "***  ", "cmg  ", "***  ", "***  ", 
      303 "***  ", "lde  ", "***  ", "***  ", "***  ", "ade  ", "***  ", "***  ", 
      304 "***  ", "ufm  ", "***  ", "dufm ", "***  ", "fcmg ", "***  ", "dfcmg", 
      305 "fszn ", "fld  ", "***  ", "dfld ", "***  ", "ufa  ", "***  ", "dufa ", 
      306 "sxl0 ", "sxl1 ", "sxl2 ", "sxl3 ", "sxl4 ", "sxl5 ", "sxl6 ", "sxl7 ", 
      307 "stz  ", "smic ", "***  ", "lacl ", "stt  ", "fst  ", "ste  ", "dfst ", 
      308 "***  ", "fmp  ", "***  ", "dfmp ", "***  ", "***  ", "***  ", "***  ", 
      309 "fstr ", "***  ", "***  ", "***  ", "***  ", "fad  ", "***  ", "dfad ", 
      310 "rpl  ", "***  ", "***  ", "***  ", "***  ", "bcd  ", "div  ", "dvf  ", 
      311 "***  ", "***  ", "ldcf ", "fneg ", "***  ", "fcmp ", "***  ", "dfcmp", 
      312 "rpt  ", "***  ", "***  ", "***  ", "***  ", "fdi  ", "***  ", "dfdi ", 
      313 "***  ", "neg  ", "cam  ", "negl ", "***  ", "ufs  ", "***  ", "dufs ", 
      314 "sprpms", "sprpop", "sprptp", "sprpcp", "sprplp", "sprprp", "sprpsp", "sprpsb", 
      315 "***  ", "stba ", "stbq ", "smcm ", "stc1 ", "***  ", "***  ", "sam  ", 
      316 "rpd  ", "***  ", "***  ", "***  ", "***  ", "fdv  ", "***  ", "dfdv ", 
      317 "***  ", "***  ", "***  ", "fno  ", "***  ", "fsb  ", "***  ", "dfsb ", 
      318 "tze  ", "tnz  ", "tnc  ", "trc  ", "tmi  ", "tpl  ", "***  ", "ttf  ", 
      319 "rtcd ", "***  ", "***  ", "rcu  ", "teo  ", "teu  ", "dis  ", "tov  ", 
      320 "eax0 ", "eax1 ", "eax2 ", "eax3 ", "eax4 ", "eax5 ", "eax6 ", "eppus ", 
      321 "ret  ", "***  ", "***  ", "rccl ", "ldi  ", "eaa  ", "eaq  ", "ldt  ", 
      322 "ersx0", "ersx1", "ersx2", "ersx3", "ersx4", "ersx5", "ersx6", "ersx7", 
      323 "sprilp", "spbplp", "sprisp", "spbpsp", "***  ", "ersa ", "ersq ", "scu  ", 
      324 "erx0 ", "erx1 ", "erx2 ", "erx3 ", "erx4 ", "erx5 ", "erx6 ", "erx7 ", 
      325 "tsplp", "tsprp", "tspsp", "tspsb", "***  ", "era  ", "erq  ", "eraq ", 
      326 "tsx0 ", "tsx1 ", "tsx2 ", "tsx3 ", "tsx4 ", "tsx5 ", "tsx6 ", "tsx7 ", 
      327 "tra  ", "***  ", "***  ", "callsp","***  ", "tss  ", "xec  ", "xed  ",
      328 "lxl0 ", "lxl1 ", "lxl2 ", "lxl3 ", "lxl4 ", "lxl5 ", "lxl6 ", "lxl7 ", 
      329 "***  ", "ars  ", "qrs  ", "lrs  ", "***  ", "als  ", "qls  ", "lls  ", 
      330 "stx0 ", "stx1 ", "stx2 ", "stx3 ", "stx4 ", "stx5 ", "stx6 ", "stx7 ", 
      331 "stc2 ", "stca ", "stcq ", "sreg ", "sti  ", "sta  ", "stq  ", "staq ", 
      332 "lprpms", "lprpop", "lprptp", "lprpcp", "lprplp", "lprprp", "lprpsp", "lprpsb", 
      333 "***  ", "arl  ", "qrl  ", "lrl  ", "gtb  ", "alr  ", "qlr  ", "llr  ",
      334 (64)(1)"***",
      335 "mlr  ",
      336 (63)(1)"***",
      337 (32)(1)"***",
      338 (9)(1)"***",
      339 "spriop","***","spricp",(4)(1)"***",
      340 (16)(1)"***",
      341 (32)(1)"***",
      342 (9)(1)"***","eppop","***","eppcp",(4)(1)"***",
      343 (9)(1)"***","epprp","***","eppsb",(4)(1)"***",
      344 (64)(1)"***",
      345 (64)(1)"***",
      346 (4)(1)"***","tmoz","tpnz","ttn",(9)(1)"***",
      347 (16)(1)"***",
      348 (9)(1)"***","sprirp","***","sprisb",(4)(1)"***",
      349 (16)(1)"***",
      350 (64)(1)"***");
      351 
  1     1 /* lisp number format -- overlaid on standard its pointer. */
  1     2 
  1     3 
  1     4 dcl 1 fixnum_fmt based aligned,
  1     5       2 type_info bit(36) aligned,
  1     6       2 fixedb fixed bin,
  1     7 
  1     8     1 flonum_fmt based aligned,
  1     9       2 type_info bit(36) aligned,
  1    10       2 floatb float bin,
  1    11 
  1    12     fixnum_type bit(36) aligned static init("000000000000000000000100000000100111"b),
  1    13     flonum_type bit(36) aligned static init("000000000000000000000010000000100111"b);
  1    14 
  1    15 /* end of lisp number format */
  1    16 
      352 
      353 
      354 	comment_sw, atom_sw, link_sw, tempf = "0"b;
      355 
      356 	if word = "000140100540"b3			/*  hee hee */
      357 	     then return ("mlr     (pr,rl),(pr,rl)");
      358 
      359 	/* this hack is so we can remember eax5 instructions in case
      360*	   an lsubr later gets called. */
      361 
      362 	if opcode = "110010101"b			/* eax5 */
      363 	then arg_twiddle = addrf;
      364 
      365 	output = op_codes(bin(hopcode||opcode));
      366 
      367 	if abr then do;
      368 	   if base = "001"b then do;
      369 	        if mod = "17"b3 | mod = "37"b3
      370 						/* ab|n,x7 is special us ptr */
      371 		   then do;
      372 		        output = output || bases(8);
      373 		        output = output || cv_octal((offsetf));
      374 		        if mod & "010000"b then output = output || ",*";
      375 		        return(output);
      376 		   end;
      377              end;
      378 	   output = output || bases(bin(base));
      379 	   output = output || cv_octal((offsetf));
      380 	   if base = "001"b				/* ab| some offset... */
      381 	   then do;
      382 		operator = divide(offsetf,2,17,0);
      383 		if operator >= lbound(op_names,1)
      384 		then if operator <= hbound(op_names,1)
      385 		then comment_sw = "1"b;
      386 	        end;
      387 	   else if base = "000"b then			/* ms */
      388 	     if opcode = "011101000"b then do;		/* eppms instruction */
      389 		stack_height = stack_height + offsetf;
      390 		end;
      391 	     else do;				/* reference to a temporary cell */
      392 		tempf = "1"b;
      393 		end;
      394 	   else if base = "100"b then do;		/* reference to data in subr block */
      395 		if offsetf >= constant_table_lbound
      396 		then if offsetf <= constant_table_hbound
      397 		then if constant_table(divide(offsetf-constant_table_lbound, 2, 18, 0)+1).atom_table_index ^= 0
      398 		then do;
      399 		     atom_name_ptr = atom_table(constant_table(1+divide(offsetf-constant_table_lbound, 2, 18, 0)).atom_table_index).ptr_to_name;
      400 		     atom_sw = "1"b;
      401 		     end;
      402 
      403 		if offsetf >= link_table_lbound
      404 		then if offsetf <= link_table_hbound
      405 		then link_sw = "1"b;
      406 		end;
      407 	   end;
      408 
      409 	else if (mod=dl)|(absolute(bin(hopcode||opcode))&mod=du) then
      410 	   output = output || cv_octal(bin(addrb));
      411 	else if (mod=du)&(substr(output,1,1)="f") then
      412 	   output = output || cv_float((addrb));
      413 	else output = output || cv_octal((addrf));
      414 	if substr(word, 19, 18) = "000101000000000011"b	/* adwpms n,du */
      415 	then stack_height = stack_height + addrf;
      416 	else if mod = "000100"b then do;		/*  ,ic  */
      417 		output = output || ",ic		";
      418 		output = output || cv_octal(ic+addrf);
      419 		constp = addrel(seg_ptr, ic+addrf);
      420 
      421 		/* attempt to display the value of the constant referenced */
      422 
      423 		if opcode = "001001111"b		/* cmpaq */
      424 		 | opcode = "010011111"b then do;	/* ldaq */
      425 		     output = output || " = ";
      426 		     if constp -> fixnum_fmt.type_info = fixnum_type then do;
      427 			output = output || "fixnum ";
      428 			output = output || cv_dec((constp -> fixedb));
      429 			output = output || ".";	/* indicate decimal */
      430 			end;
      431 		     else if constp -> flonum_fmt.type_info = flonum_type then do;
      432 			output = output || "flonum ";
      433 			output = output || convert_sfl_(constp -> floatb, 7);
      434 			end;
      435 		     else do;		/* something random */
      436 			output = output || cv_octal_word(constp -> w1);
      437 			output = output || " ";
      438 			output = output || cv_octal_word(constp -> w2);
      439 			end;
      440 		     end;
      441 
      442 		else if (opcode & "100001100"b) = "000001100"b then do;  /* fixed point add subtract */
      443 		     output = output || " = ";
      444 		     output = output || cv_dec(constp -> w1);
      445 		     end;
      446 
      447                     else if (opcode & "111110000"b) = "110000000"b |
      448                             (opcode & "111110000"b) = "111000000"b then;  /* transfer */
      449 		else do;	/* Some random instruction, put it in octal */
      450 		     output = output || " = ";
      451 		     output = output || cv_octal_word(constp -> w1);
      452 		     end;
      453 
      454 		end;
      455 	else if mod^=""b then do;
      456 	   output = output || tags(bin(mod));
      457 	   end;
      458 
      459 
      460 	/* check for transfer +n,ic instructions.  If we find one,
      461*	   update its entry in label table to contain current stack_height */
      462 
      463 	if (rt_half & "111111000011111111"b) = "110000000000000100"b	/* conditional tra,ic */
      464 	 | rt_half = "111001000000000100"b then do;
      465 
      466 		traref = ic + addrf;
      467 		labu = 1;
      468 		labh = number_of_labels;
      469 		do while(labh >= labu);
      470 		   labx = labu + divide(labh-labu, 2, 17, 0);
      471 		   if label(labx).address = traref then do;
      472 			label(labx).stack_ht = stack_height;
      473 			label(labx).save_bind_stack_ptr = bind_stack_ptr;
      474 			go to end_tra_loop;
      475 			end;
      476 	 	   else if label(labx).address < traref then labu = labx+1;
      477 		   else labh = labx-1;
      478 		   end;
      479 		/* shouldn't come out this way (label not found) */
      480 end_tra_loop:		/* should come out this way */
      481 
      482 		end;		/* end of tra code */
      483 
      484 
      485 	if comment_sw
      486 	then do;
      487 	     output = output || "		";
      488 	     output = output || op_names(operator);
      489 	     stack_height = stack_height + op_stack_adj(operator);
      490 	     go to ophack(op_special(operator));
      491 ophack(0):     go to exit;		/* default case */
      492 
      493 ophack(1):     /* unbind */
      494 	     bind_stack_ptr = bind_stack_ptr - 1;
      495 	     if bind_stack_ptr <= 0 then signal mll_internal_error;
      496 	     stack_height = stack_height - bind_stack(bind_stack_ptr);
      497 	     go to exit;
      498 
      499 ophack(2):     /* iog bind */
      500 	     if bind_stack_ptr > hbound(bind_stack, 1) then signal mll_internal_error;
      501 	     bind_stack(bind_stack_ptr) = 16;
      502 	     bind_stack_ptr = bind_stack_ptr + 1;
      503 	     go to exit;
      504 
      505 ophack(3):     /* call */
      506 	     if ^ link_sw then output = output || "		?????";	/* you have lost badly */
      507 
      508 exit:	     end;
      509 
      510 	else if tempf then do;		/* put comment for reference to temporary */
      511 		output = output || "		temp ";
      512 		output = output || cv_dec(divide(offsetf+stack_height, 2, 18, 0));
      513 		end;
      514 
      515 	else if atom_sw then do;	/* display name of referenced atom */
      516 		output = output || "		";
      517 		if substr(word, 31, 2) = "00"b	/* not indirect */
      518 		then output = output || "'";		/* flag constant rather than variable */
      519 		output = output || atom_name_ptr -> atom_name;
      520 		end;
      521 
      522 	else if link_sw then do;	/* decode a link */
      523 
      524 		output = output || "		";
      525 		unspec(link) = link_table_ptr -> link_info(divide(offsetf-link_table_lbound, 2, 18, 0)+1);
      526 		if ^ link.constant then do;
      527 			output = output || "ms|";
      528 			output = output || cv_octal((link.address));
      529 			output = output || " (temp ";
      530 			output = output || cv_dec(divide(link.address+stack_height, 2, 18, 0));
      531 			output = output || ")";
      532 			end;
      533 		else do;
      534 		     if link.address >= constant_table_lbound
      535 		     then if link.address <= constant_table_hbound
      536 		     then if constant_table(1+divide(link.address-constant_table_lbound, 2, 18, 0)).atom_table_index ^= 0
      537 		     then do;		/* atomic function */
      538 			output = output || atom_table(constant_table(1+divide(link.address-constant_table_lbound, 2, 18, 0)).atom_table_index).ptr_to_name -> atom_name;
      539 			go to exitgroup;
      540 			end;
      541 		     /* nonatomic function */
      542 		     call lphack((link.address));
      543 
      544 	      exitgroup:
      545 		     end;
      546 
      547 		/* special flags */
      548 
      549 		if link.f then output = output || "  [F]";
      550 		if link.snap = "0"b then output = output || "  [nosnap]";
      551 
      552 		/* adjust stack height according to number of arguments */
      553 
      554 		if link.f then stack_height = stack_height - 2;
      555 		else if link.nargs = "111111111"b
      556 	               then stack_height = stack_height + arg_twiddle;
      557 		else stack_height = stack_height - 2*fixed(link.nargs, 9);
      558 
      559 		end;
      560 
      561 	else if abr then if base = "100"b then if opcode = "111001110"b then do;	/* xec of an array link */
      562 		unspec(array_link) = array_link_table_ptr -> array_link_control_word(
      563 				divide(offsetf-array_link_table_lbound, 4, 17, 0)+1);
      564 		output = output || "		array ";
      565 		if array_link.address >= constant_table_lbound
      566 		then if array_link.address <= constant_table_hbound
      567 		then if constant_table(1+divide(array_link.address-constant_table_lbound, 2, 17, 0)).atom_table_index ^= 0
      568 		then do;
      569 		     output = output || atom_table(constant_table(1+divide(array_link.address-constant_table_lbound,
      570 							2, 17, 0)).atom_table_index).ptr_to_name -> atom_name;
      571 		     end;
      572 		end;
      573 
      574 
      575 	return(output);
      576 
      577 dump_lisp_binding_word_:
      578 	entry(a_word, ic, a_tablep) returns(char(*));
      579 
      580 dcl
      581 	bind_class (0:7) char(5) varying static init(
      582 	"op|",
      583 	"ms|",
      584 	"lp|",
      585 	"",
      586 	"ms|",
      587 	"C(x5)",
      588 	"ms|",
      589 	"lp|"),
      590 
      591 	bind_tags (0:7) char(3) varying static init(
      592 	"",
      593 	"",
      594 	"",
      595 	",ic",
      596 	"",
      597 	"",
      598 	",*",
      599 	",*"),
      600 
      601 	rt_half bit(18) unal defined(word) pos(19),
      602 	rt_half_fb  fixed bin(17) unal based(addr(rt_half));
      603 
      604 	output = "bind    ";
      605 	if base = "100"b
      606 	then output = output || """argatom""";
      607 	else do;		/* binding atom, discover its name */
      608 	     if offsetf >= constant_table_lbound
      609 	     then if offsetf <= constant_table_hbound
      610 	     then if constant_table(1+divide(offsetf-constant_table_lbound, 2, 18, 0)).atom_table_index ^= 0
      611 	     then output = output || atom_table(constant_table(1+divide(offsetf-constant_table_lbound,2 , 18, 0)).atom_table_index).ptr_to_name -> atom_name;
      612 	     else call lphack((offsetf));
      613 	     else call lphack((offsetf));
      614 	     else call lphack((offsetf));
      615 
      616 	   end;
      617 
      618 	output = output || " to ";
      619 
      620 	output = output || bind_class(fixed(base,3));
      621 
      622 	if base ^= "101"b then do;
      623 		output = output || cv_octal((rt_half_fb));
      624 		output = output || bind_tags(fixed(base, 3));
      625 		end;
      626 	if base = "000"b		/* stack constant... */
      627 	then do;
      628 		operator = divide(rt_half_fb,2,17,0);
      629 		if operator >= lbound(op_names,1) & operator<= hbound(op_names,1)
      630 		then do;
      631 			if length(output) < 16 then output = output || "	";
      632 			output = output || "	";
      633 			output = output || op_names(operator);
      634 			end;
      635 	     end;
      636 
      637 	else if base = "001"b | base = "110"b | base = "100"b then do;	/* ms| */
      638 		if length(output) < 16 then output = output || "	";
      639 		output = output || "	temp ";
      640 		output = output || cv_dec(divide(rt_half_fb+stack_height, 2, 18, 0));
      641 		end;
      642 
      643 	else if base = "010"b | base = "111"b then do;	/* lp| */
      644 		if length(output) < 16 then output = output || "	";
      645 		output = output || "	";
      646 		if rt_half_fb >= constant_table_lbound
      647 		then if rt_half_fb <= constant_table_hbound
      648 		then if constant_table(1+divide(rt_half_fb-constant_table_lbound, 2, 18, 0)).atom_table_index ^= 0
      649 		then output = output || atom_table(constant_table(1+divide(rt_half_fb-constant_table_lbound, 2, 18, 0)).atom_table_index).ptr_to_name -> atom_name;
      650 		else call lphack((rt_half_fb));
      651 		else call lphack((rt_half_fb));
      652 		else call lphack((rt_half_fb));
      653 		end;
      654 
      655 	else if base = "011"b then do;		/*  ,ic  */
      656 		if length(output) < 16 then output = output || "	";
      657 		output = output || "	";
      658 		output = output || cv_octal(rt_half_fb+ic);
      659 		end;
      660 
      661 	return (output);
      662 
      663 
      664 
      665 lphack:  proc(xx);
      666 
      667 dcl xx fixed bin (17) parameter;
      668 
      669 	output = output || "lp|";
      670 	output = output || cv_octal((xx));
      671 	end lphack;
      672 
      673 cv_dec:  proc(value) returns(char(*));
      674 
      675 dcl value fixed bin(35),
      676     convert_binary_integer_$decimal_string entry(fixed bin(35)) returns(char(12) varying);
      677 
      678 	return(convert_binary_integer_$decimal_string(value));
      679 	end;
      680 
      681 
      682 cv_octal:
      683 	proc(value) returns(char(*));
      684 
      685 
      686 dcl
      687 	convert_binary_integer_$octal_string entry(fixed bin(35)) returns(char(13) var),
      688 	value fixed bin(35);
      689 
      690 
      691 	return(convert_binary_integer_$octal_string(value));
      692 
      693 	end;
      694 
      695 
      696 cv_float:
      697 	proc(value) returns(char(*));
      698 
      699 dcl
      700 	fnum float bin(27),
      701 	unspec builtin,
      702 	value bit(*);
      703 
      704 
      705 	unspec(fnum) = value;
      706 
      707 	return(convert_sfl_(fnum, 4));
      708 
      709 	end;
      710 
      711 cv_octal_word:  procedure(value) returns(char(12));
      712 
      713 dcl value fixed bin(35),
      714     bits bit(36) aligned,
      715     i fixed bin,
      716     (unspec, string, substr) builtin,
      717     results (12) char(1) unaligned,
      718     Zero bit(6) static init("000110"b);
      719 
      720 	bits = unspec(value);
      721 	do i = 1 to 12;
      722 	   unspec(results(i)) = Zero || substr(bits, 3*i-2, 3);
      723 	   end;
      724 	return(string(results));
      725 	end;
      726 
      727 
      728 	end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    06/29/83  1541.3  dump_lisp_instruction_.pl1        >special_ldd>on>06/27/83>dump_lisp_instruction_.pl1
352          1    03/27/82  0437.0  lisp_nums.incl.pl1                >ldd>include>lisp_nums.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

Zero                                   constant        bit(6)                   initial unaligned dcl 713 ref 722
a_tablep                               parameter       pointer                  dcl 16 ref 10 64 577
a_tra_table_p                          parameter       pointer                  dcl 16 ref 10 68
a_word                                 parameter       bit(36)                  dcl 16 ref 10 22 577
abr                                    defined         bit(1)                   unaligned dcl 22 ref 367 561
absolute                        005137 constant        bit(1)                   initial array unaligned dcl 114 ref 409
addr                                                   builtin function         dcl 22 ref 362 373 379 382 389 395 395 395 399 403
                                                                                  403 413 414 418 419 466 512 512 525 562 608 608
                                                                                  608 608 612 613 614 623 628 640 640 646 646 646
                                                                                  646 650 651 652 658
addrb                                  defined         bit(18)                  unaligned dcl 22 ref 409 409 411
addrel                                                 builtin function         ref 419
address                         000123 automatic       fixed bin(14,0)          level 2 in structure "link" packed unaligned dcl 22
                                                                                  in procedure "dump_lisp_instruction_" set ref 528
                                                                                  530 530 534 534 534 538 542
address                   1            based           fixed bin(18,0)          array level 3 in structure "tra_table" dcl 68
                                                                                  in procedure "dump_lisp_instruction_" ref 471 476
address                   0(18) 000124 automatic       fixed bin(17,0)          level 2 in structure "array_link" packed unaligned
                                                                                  dcl 22 in procedure "dump_lisp_instruction_" set
                                                                                  ref 565 565 565 569
addrf                                  based           fixed bin(17,0)          unaligned dcl 22 ref 362 413 414 418 419 466
arg_twiddle              15            based           fixed bin(18,0)          level 2 dcl 85 set ref 362* 555
array_link                      000124 automatic       structure                level 1 dcl 22 set ref 562*
array_link_control_word                based           bit(36)                  array dcl 22 ref 562
array_link_table_lbound
                          6            based           fixed bin(18,0)          level 2 dcl 85 ref 562
array_link_table_ptr      5            based           pointer                  level 2 packed unaligned dcl 85 ref 562
atom_name                              based           varying char(10000)      dcl 22 ref 519 538 569 608 646
atom_name_ptr                   000122 automatic       pointer                  unaligned dcl 22 set ref 399* 519
atom_sw                         000126 automatic       bit(1)                   dcl 22 set ref 354* 400* 515
atom_table              163            based           structure                array level 2 dcl 85
atom_table_index                       based           fixed bin(17,0)          array level 3 dcl 85 ref 395 399 534 538 565 569 608
                                                                                  608 646 646
atom_table_size           1            based           fixed bin(17,0)          level 2 dcl 85 ref 395 399 534 538 565 569 608 608
                                                                                  646 646
base                                   defined         bit(3)                   unaligned dcl 22 ref 368 378 380 387 394 561 605 620
                                                                                  622 624 626 637 637 637 643 643 655
bases                           005126 constant        char(3)                  initial array dcl 156 ref 372 378
bin                                                    builtin function         dcl 22 ref 365 378 409 409 409 456
bind_class                      000024 constant        varying char(5)          initial array dcl 580 ref 620
bind_stack               17            based           fixed bin(17,0)          array level 2 dcl 85 set ref 496 499 501*
bind_stack_ptr           14            based           fixed bin(17,0)          level 2 dcl 85 set ref 473 493* 493 495 496 499 501
                                                                                  502* 502
bind_tags                       000004 constant        varying char(3)          initial array dcl 580 ref 624
bits                            000172 automatic       bit(36)                  dcl 713 set ref 720* 722
comment_sw                      000125 automatic       bit(1)                   dcl 22 set ref 354* 383* 485
constant                  0(16) 000123 automatic       bit(1)                   level 2 packed unaligned dcl 22 set ref 526
constant_table                         based           structure                array level 2 dcl 85
constant_table_hbound
                         13            based           fixed bin(18,0)          level 2 dcl 85 ref 395 534 565 608 646
constant_table_lbound
                         12            based           fixed bin(18,0)          level 2 dcl 85 ref 395 395 399 534 534 538 565 565
                                                                                  569 608 608 608 646 646 646
constp                          000144 automatic       pointer                  dcl 79 set ref 419* 426 428 431 433 436 438 444 451
convert_binary_integer_$decimal_string
                                000012 constant        entry                    external dcl 675 ref 678
convert_binary_integer_$octal_string
                                000014 constant        entry                    external dcl 686 ref 691
convert_sfl_                    000010 constant        entry                    external dcl 22 ref 433 707
cv_dec                          010755 constant        entry                    internal dcl 673 ref 428 444 512 530 640
cv_float                        011033 constant        entry                    internal dcl 696 ref 411
cv_octal                        011004 constant        entry                    internal dcl 682 ref 373 379 409 413 418 528 623 658
                                                                                  670
cv_octal_word                   011111 constant        entry                    internal dcl 711 ref 436 438 451
definition_table_size
                         10            based           fixed bin(17,0)          level 2 dcl 85 ref 395 399 534 538 565 569 608 608
                                                                                  646 646
divide                                                 builtin function         ref 382 395 399 470 512 512 525 530 530 534 538 562
                                                                                  565 569 608 608 628 640 640 646 646
dl                                     constant        bit(6)                   initial unaligned dcl 22 ref 409
du                                     constant        bit(6)                   initial unaligned dcl 22 ref 409 411
dump_lisp_binding_word_         007727 constant        entry                    external dcl 577
dump_lisp_instruction_          005311 constant        entry                    external dcl 10
end_tra_loop                    007011 constant        label                    dcl 480 ref 474
exit                            007117 constant        label                    dcl 508 ref 491 497 503
exitgroup                       007515 constant        label                    dcl 544 ref 539
f                         0(17) 000123 automatic       bit(1)                   level 2 packed unaligned dcl 22 set ref 549 554
fixed                                                  builtin function         ref 557 620 624
fixedb                    1            based           fixed bin(17,0)          level 2 dcl 1-4 ref 428
fixnum_fmt                             based           structure                level 1 dcl 1-4
fixnum_type                            constant        bit(36)                  initial dcl 1-4 ref 426
floatb                    1            based           float bin(27)            level 2 dcl 1-4 set ref 433*
flonum_fmt                             based           structure                level 1 dcl 1-4
flonum_type                            constant        bit(36)                  initial dcl 1-4 ref 431
fnum                            000100 automatic       float bin(27)            dcl 699 set ref 705* 707*
hbound                                                 builtin function         dcl 22 ref 383 499 629
hopcode                                defined         bit(1)                   unaligned dcl 22 ref 365 409
i                               000173 automatic       fixed bin(17,0)          dcl 713 set ref 721* 722 722*
ic                                     parameter       fixed bin(18,0)          dcl 16 ref 10 418 419 466 577 658
label                     1            based           structure                array level 2 dcl 68
labh                            000151 automatic       fixed bin(17,0)          dcl 85 set ref 468* 469 470 477*
labu                            000147 automatic       fixed bin(17,0)          dcl 85 set ref 467* 469 470 470 476*
labx                            000150 automatic       fixed bin(17,0)          dcl 85 set ref 470* 471 472 473 476 476 477
lbound                                                 builtin function         dcl 22 ref 383 629
length                                                 builtin function         ref 631 638 644 656
link                            000123 automatic       structure                level 1 dcl 22 set ref 525*
link_info                              based           bit(27)                  array dcl 22 ref 525
link_sw                         000127 automatic       bit(1)                   dcl 22 set ref 354* 403* 505 522
link_table_hbound         4            based           fixed bin(18,0)          level 2 dcl 85 ref 403
link_table_lbound         3            based           fixed bin(18,0)          level 2 dcl 85 ref 403 525
link_table_ptr            2            based           pointer                  level 2 packed unaligned dcl 85 ref 525
lphack                          010700 constant        entry                    internal dcl 665 ref 542 612 613 614 650 651 652
mll_internal_error              000132 stack reference condition                dcl 62 ref 495 499
mll_internal_error_2            000000 stack reference condition                dcl 62
mod                                    defined         bit(6)                   unaligned dcl 22 ref 369 369 374 409 409 411 416 455
                                                                                  456
nargs                     0(18) 000123 automatic       bit(9)                   level 2 packed unaligned dcl 22 set ref 555 557
number_of_labels                       based           fixed bin(17,0)          level 2 dcl 68 ref 468
offsetb                                defined         bit(15)                  unaligned dcl 22 set ref 373 379 382 389 395 395 395
                                                                                  399 403 403 512 512 525 562 608 608 608 608 612
                                                                                  613 614
offsetf                                based           fixed bin(14,0)          unaligned dcl 22 ref 373 379 382 389 395 395 395 399
                                                                                  403 403 512 512 525 562 608 608 608 608 612 613
                                                                                  614
op_codes                        000054 constant        char(8)                  initial array dcl 268 ref 365
op_names                        004316 constant        varying char(25)         initial array dcl 160 ref 383 383 488 629 629 633
op_special                      004154 constant        fixed bin(17,0)          initial array dcl 247 ref 490
op_stack_adj                    004235 constant        fixed bin(17,0)          initial array dcl 212 ref 489
opcode                                 defined         bit(9)                   unaligned dcl 22 ref 362 365 387 409 423 423 442 447
                                                                                  447 561
operator                        000121 automatic       fixed bin(17,0)          dcl 22 set ref 382* 383 383 488 489 490 628* 629 629
                                                                                  633
ophack                          000000 constant        label                    array(0:3) dcl 491 ref 490
output                          000100 automatic       varying char(64)         dcl 22 set ref 365* 372* 372 373* 373 374* 374 375
                                                                                  378* 378 379* 379 409* 409 411 411* 411 413* 413
                                                                                  417* 417 418* 418 425* 425 427* 427 428* 428 429*
                                                                                  429 432* 432 433* 433 436* 436 437* 437 438* 438
                                                                                  443* 443 444* 444 450* 450 451* 451 456* 456 487*
                                                                                  487 488* 488 505* 505 511* 511 512* 512 516* 516
                                                                                  517* 517 519* 519 524* 524 527* 527 528* 528 529*
                                                                                  529 530* 530 531* 531 538* 538 549* 549 550* 550
                                                                                  564* 564 569* 569 575 604* 605* 605 608* 608 618*
                                                                                  618 620* 620 623* 623 624* 624 631 631* 631 632*
                                                                                  632 633* 633 638 638* 638 639* 639 640* 640 644
                                                                                  644* 644 645* 645 646* 646 656 656* 656 657* 657
                                                                                  658* 658 661 669* 669 670* 670
ptr_to_name             163            based           pointer                  array level 3 packed unaligned dcl 85 ref 399 538
                                                                                  569 608 646
results                         000174 automatic       char(1)                  array unaligned dcl 713 set ref 722* 724
rt_half                                defined         bit(18)                  unaligned dcl 580 set ref 463 463 623 628 640 640
                                                                                  646 646 646 646 650 651 652 658
rt_half_fb                             based           fixed bin(17,0)          unaligned dcl 580 ref 623 628 640 640 646 646 646
                                                                                  646 650 651 652 658
save_bind_stack_ptr       4            based           fixed bin(17,0)          array level 3 dcl 68 set ref 473*
seg_ptr                  16            based           pointer                  level 2 packed unaligned dcl 85 ref 419
snap                      0(15) 000123 automatic       bit(1)                   level 2 packed unaligned dcl 22 set ref 550
stack_height                           based           fixed bin(17,0)          level 2 dcl 85 set ref 389* 389 414* 414 472 489*
                                                                                  489 496* 496 512 512 530 530 554* 554 555* 555
                                                                                  557* 557 640 640
stack_ht                  2            based           fixed bin(18,0)          array level 3 dcl 68 set ref 472*
string                                                 builtin function         dcl 713 ref 724
substr                                                 builtin function         dcl 22 in procedure "dump_lisp_instruction_" ref 411
                                                                                  414 517
substr                                                 builtin function         dcl 713 in procedure "cv_octal_word" ref 722
table                                  based           structure                level 1 dcl 85
tablep                          000140 automatic       pointer                  initial dcl 64 set ref 64* 362 389 389 395 395 395
                                                                                  395 399 399 399 403 403 414 414 419 472 473 489
                                                                                  489 493 493 495 496 496 496 496 499 499 501 501
                                                                                  502 502 512 512 525 525 530 530 534 534 534 534
                                                                                  538 538 538 554 554 555 555 555 557 557 562 562
                                                                                  565 565 565 565 569 569 569 608 608 608 608 608
                                                                                  608 608 640 640 646 646 646 646 646 646 646
tags                            004054 constant        char(4)                  initial array dcl 257 ref 456
tempf                           000130 automatic       bit(1)                   dcl 22 set ref 354* 392* 510
tra_table                              based           structure                level 1 dcl 68
tra_table_p                     000142 automatic       pointer                  initial dcl 68 set ref 68* 468 471 472 473 476
traref                          000146 automatic       fixed bin(18,0)          dcl 85 set ref 466* 471 476
type_info                              based           bit(36)                  level 2 in structure "flonum_fmt" dcl 1-4
                                                                                  in procedure "dump_lisp_instruction_" ref 431
type_info                              based           bit(36)                  level 2 in structure "fixnum_fmt" dcl 1-4
                                                                                  in procedure "dump_lisp_instruction_" ref 426
unspec                                                 builtin function         dcl 699 in procedure "cv_float" set ref 705*
unspec                                                 builtin function         dcl 713 in procedure "cv_octal_word" set ref 720
                                                                                  722*
unspec                                                 builtin function         set ref 525 562*
value                                  parameter       bit                      unaligned dcl 699 in procedure "cv_float" ref 696
                                                                                  705
value                                  parameter       fixed bin(35,0)          dcl 686 in procedure "cv_octal" set ref 682 691*
value                                  parameter       fixed bin(35,0)          dcl 675 in procedure "cv_dec" set ref 673 678*
value                                  parameter       fixed bin(35,0)          dcl 713 in procedure "cv_octal_word" ref 711 720
w1                                     based           fixed bin(35,0)          level 2 dcl 79 set ref 436* 444* 451*
w2                        1            based           fixed bin(35,0)          level 2 dcl 79 set ref 438*
word                            000131 automatic       bit(36)                  initial unaligned dcl 22 set ref 22* 356 362 362 362
                                                                                  365 365 365 365 367 367 368 368 369 369 369 369
                                                                                  373 373 374 374 378 378 379 379 380 380 382 382
                                                                                  387 387 387 387 389 389 394 394 395 395 395 395
                                                                                  395 395 399 399 403 403 403 403 409 409 409 409
                                                                                  409 409 409 409 409 409 409 409 411 411 411 411
                                                                                  413 414 414 416 416 418 419 423 423 423 423 442
                                                                                  442 447 447 447 447 455 455 456 456 463 463 463
                                                                                  463 466 512 512 512 512 517 525 525 561 561 561
                                                                                  561 561 561 562 562 605 605 608 608 608 608 608
                                                                                  608 608 608 612 612 613 613 614 614 620 620 622
                                                                                  622 623 623 624 624 626 626 628 628 637 637 637
                                                                                  637 637 637 640 640 640 640 643 643 643 643 646
                                                                                  646 646 646 646 646 646 646 650 650 651 651 652
                                                                                  652 655 655 658 658
word_pair                              based           structure                level 1 dcl 79
xx                                     parameter       fixed bin(17,0)          dcl 667 ref 665 670

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11302       11320   11165       11312
Length     11532   11165        16         176     114           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dump_lisp_instruction_              175 external procedure  is an external procedure.  
lphack                                  internal procedure  shares stack frame of external procedure dump_lisp_instruction_.  
cv_dec                               74 internal procedure  uses returns(char(*)) or returns(bit(*)).  
cv_octal                             76 internal procedure  uses returns(char(*)) or returns(bit(*)).  
cv_float                             84 internal procedure  uses returns(char(*)) or returns(bit(*)).  
cv_octal_word                           internal procedure  shares stack frame of external procedure dump_lisp_instruction_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cv_float                 000100 fnum                        cv_float
dump_lisp_instruction_   000100 output                      dump_lisp_instruction_
                         000121 operator                    dump_lisp_instruction_
                         000122 atom_name_ptr               dump_lisp_instruction_
                         000123 link                        dump_lisp_instruction_
                         000124 array_link                  dump_lisp_instruction_
                         000125 comment_sw                  dump_lisp_instruction_
                         000126 atom_sw                     dump_lisp_instruction_
                         000127 link_sw                     dump_lisp_instruction_
                         000130 tempf                       dump_lisp_instruction_
                         000131 word                        dump_lisp_instruction_
                         000140 tablep                      dump_lisp_instruction_
                         000142 tra_table_p                 dump_lisp_instruction_
                         000144 constp                      dump_lisp_instruction_
                         000146 traref                      dump_lisp_instruction_
                         000147 labu                        dump_lisp_instruction_
                         000150 labx                        dump_lisp_instruction_
                         000151 labh                        dump_lisp_instruction_
                         000172 bits                        cv_octal_word
                         000173 i                           cv_octal_word
                         000174 results                     cv_octal_word

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_le_a              r_ge_a              call_ext_out_desc   call_ext_out        call_int_this_desc
mpfx2               signal              shorten_stack       ext_entry_desc      int_entry_desc      return_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
convert_binary_integer_$decimal_string                      convert_binary_integer_$octal_string
convert_sfl_

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     22 005271        64 005274        68 005277        10 005304       354 005325       356 005331       362 005343
    365 005354       367 005400       368 005403       369 005407       372 005422       373 005434       374 005475
    375 005514       378 005523       379 005542       380 005603       382 005610       383 005616       386 005624
    387 005625       389 005635       390 005642       392 005643       393 005645       394 005646       395 005652
    399 005710       400 005733       403 005735       407 005754       409 005755       411 006052       413 006126
    414 006166       416 006177       417 006203       418 006215       419 006256       423 006267       425 006304
    426 006316       427 006321       428 006333       429 006371       430 006401       431 006402       432 006405
    433 006417       434 006462       436 006464       437 006506       438 006515       440 006540       442 006541
    443 006547       444 006561       445 006615       447 006617       450 006637       451 006651       454 006673
    455 006674       456 006677       463 006716       466 006732       467 006737       468 006741       469 006743
    470 006747       471 006753       472 006760       473 006765       474 006773       476 006774       477 007005
    478 007010       485 007011       487 007013       488 007025       489 007043       490 007046       491 007050
    493 007051       495 007054       496 007061       497 007065       499 007066       501 007075       502 007101
    503 007102       505 007103       508 007117       510 007120       511 007122       512 007134       513 007177
    515 007201       516 007203       517 007215       519 007227       520 007242       522 007243       524 007245
    525 007257       526 007272       527 007275       528 007307       529 007346       530 007361       531 007422
    532 007432       534 007433       538 007456       539 007507       542 007510       549 007515       550 007532
    554 007547       555 007555       557 007566       559 007573       561 007574       562 007610       564 007623
    565 007635       569 007661       575 007713       577 007722       604 007743       605 007750       608 007767
    612 010062       613 010072       614 010102       618 010111       620 010123       622 010142       623 010146
    624 010207       626 010227       628 010232       629 010240       631 010247       632 010261       633 010270
    635 010306       637 010307       638 010330       639 010342       640 010354       641 010417       643 010421
    644 010434       645 010446       646 010455       650 010550       651 010560       652 010570       653 010577
    655 010600       656 010604       657 010616       658 010625       659 010670       661 010671       665 010700
    669 010702       670 010714       671 010752       673 010754       678 010762       682 011003       691 011011
    696 011032       705 011046       707 011053       711 011111       720 011113       721 011115       722 011123
    723 011141       724 011143


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
