	COMPILATION LISTING OF SEGMENT mrds_rst_model_alloc
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1347.4 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 /* HISTORY:
       19*
       20*   originally written by jim gray - - February 1979
       21*
       22*   82-05-11 Roger Lackey : Changed the way model_seg_path_dir and
       23*   model_seg_path_entry were deterimded form model_seg_path by replacing
       24*   old  code (which could get a stringsize condition)
       25*   with a call to expand_pathname_
       26*
       27*   83-02-17 Davids: explicitly declared variables that were declared by
       28*   context or implication and deleted declarations to variables that were
       29*   not referenced.
       30**/
       31 
       32 mrds_rst_model_alloc: procedure (rsc_ptr, model_seg_path, struct_type, struct_ptr);
       33 
       34 /*
       35*   .                        BEGIN_DESCRIPTION
       36*   this routine handles all allocations and freeing of structures to be
       37*   placed in the database model for a MRDS database, this includes either
       38*   the db_model segment, or one of the file_model segments.
       39*   there are a total of three entries, the normal entry is for allocation
       40*   of fixed length structures, the $variable entry is for allocation of
       41*   structures that are of variable length, based on one paramater,
       42*   and the $free entry is used to free a given allocation of a particular
       43*   structure type.
       44*   .                        END_DESCRIPTION
       45**/
       46 
       47 /* PARAMETERS:
       48*
       49*   normal entry ===
       50*   rsc_ptr - - (input) pointer to the common control segment "rsc"
       51*
       52*   model_seg_path - - (input) the absolute pathname of the segment in which
       53*   the allocation is to take place, thus the pathname of either
       54*   the db_model, or one of the file_models
       55*
       56*   struct_type - - (input) fixed binary number that indicates which structure
       57*   is to be allocated. the include file mrds_rst_struct_types
       58*   gives the constants that are used for that purpose.
       59*
       60*   struct_ptr - - (output) pointer to the newly allocated structure of the type given by struct_type.
       61*   it will be null, if the model area overflowed - the user must check for this.
       62*
       63*   $variable entry ===
       64*   struct_size - - (input) a fixed binary (35) number, in addition to those above,
       65*   that gives the length for the current allocation of this structure type,
       66*   that has a variable length based on one parameter.
       67*
       68*   $free entry ===
       69*   same as the normal entry, except struct_ptr is an input parameter,
       70*   and it points to the allocation instance to be freed.
       71**/
       72 
       73 /* establish on unit to capture model overflow */
       74 
       75 	on area
       76 	     begin;
       77 		struct_ptr = null ();		/* to tell caller we failed */
       78 		goto return_label;
       79 	     end;
       80 
       81 /* normal allocation entry point */
       82 
       83 	FREE = OFF;
       84 	goto common;
       85 
       86 
       87 /* freeing entry point */
       88 
       89 mrds_rst_model_alloc$free: entry (rsc_ptr, model_seg_path, struct_type, struct_ptr);
       90 
       91 	FREE = ON;
       92 
       93 /* determine if we are freeing a variable length allocation */
       94 
       95 	if struct_type <= hbound (case, 1) then
       96 	     goto common;
       97 	else goto var_common;
       98 
       99 
      100 common:
      101 
      102 	if ^rsc.trace_sw then ;
      103 	else call trace (ON);			/* input call */
      104 
      105 	call decode_model_seg_path ();
      106 
      107 /* check that the encoding for structure type is within the legal range */
      108 
      109 	if struct_type < lbound (case, 1) | struct_type > hbound (case, 1) then
      110 	     call bad_struct_type ();
      111 
      112 	else do;
      113 
      114 /* good structure type code, go to the allocate that it indicates for the
      115*   given structure to be allocated, and the area in which it will reside */
      116 
      117 		goto case (struct_type);
      118 
      119 
      120 /* db_model area structures */
      121 
      122 case (0):
      123 
      124 		if FREE then ;			/* can't free till not head of segment */
      125 		else do;
      126 			call hcs_$make_seg (model_seg_path_dir, model_seg_path_entry, "",
      127 			     01010b /* rw mode */, struct_ptr, error_code);
      128 			if error_code = 0 then ;
      129 			else call unable_to_make_segment ();
      130 		     end;
      131 		goto return_label;
      132 
      133 case (1):
      134 
      135 		if FREE then
      136 		     free struct_ptr -> file_info in (db_model_area);
      137 		else allocate file_info set (struct_ptr) in (db_model_area);
      138 		goto return_label;
      139 
      140 case (2):
      141 
      142 		if FREE then
      143 		     free struct_ptr -> domain_info in (db_model_area);
      144 		else allocate domain_info set (struct_ptr) in (db_model_area);
      145 		goto return_label;
      146 
      147 case (3):
      148 
      149 		if FREE then
      150 		     free struct_ptr -> path_entry in (db_model_area);
      151 		else allocate path_entry set (struct_ptr) in (db_model_area);
      152 		goto return_label;
      153 
      154 case (4):
      155 
      156 		if FREE then
      157 		     free struct_ptr -> stack_item in (db_model_area);
      158 		else allocate stack_item set (struct_ptr) in (db_model_area);
      159 		goto return_label;
      160 
      161 case (5):
      162 
      163 		if FREE then
      164 		     free struct_ptr -> version_status in (db_model_area);
      165 		else allocate version_status set (struct_ptr) in (db_model_area);
      166 		goto return_label;
      167 
      168 case (6):
      169 
      170 		if FREE then
      171 		     free struct_ptr -> changer in (db_model_area);
      172 		else allocate changer set (struct_ptr) in (db_model_area);
      173 		goto return_label;
      174 
      175 /* file_model  area structures */
      176 
      177 case (7):
      178 
      179 		if FREE then ;			/* can't free til not segment head */
      180 		else do;
      181 			call hcs_$make_seg (model_seg_path_dir, model_seg_path_entry, "", 01010b /* rw mode */,
      182 			     struct_ptr, error_code);
      183 			if error_code = 0 then ;
      184 			else call unable_to_make_segment ();
      185 		     end;
      186 		goto return_label;
      187 
      188 case (8):
      189 
      190 		if FREE then
      191 		     free struct_ptr -> rel_info in (file_model_area);
      192 		else allocate rel_info set (struct_ptr) in (file_model_area);
      193 		goto return_label;
      194 
      195 case (9):
      196 
      197 		if FREE then
      198 		     free struct_ptr -> attr_info in (file_model_area);
      199 		else allocate attr_info set (struct_ptr) in (file_model_area);
      200 		goto return_label;
      201 
      202 case (10):
      203 
      204 		if FREE then
      205 		     free struct_ptr -> parent_link_info in (file_model_area);
      206 		else allocate parent_link_info set (struct_ptr) in (file_model_area);
      207 		goto return_label;
      208 
      209 case (11):
      210 
      211 		if FREE then
      212 		     free struct_ptr -> child_link_info in (file_model_area);
      213 		else allocate child_link_info set (struct_ptr) in (file_model_area);
      214 		goto return_label;
      215 
      216 case (12):
      217 
      218 		if FREE then
      219 		     free struct_ptr -> attr_list in (file_model_area);
      220 		else allocate attr_list set (struct_ptr) in (file_model_area);
      221 		goto return_label;
      222 
      223 case (13):
      224 
      225 		if FREE then
      226 		     free struct_ptr -> sort_key in (file_model_area);
      227 		else allocate sort_key set (struct_ptr) in (file_model_area);
      228 		goto return_label;
      229 
      230 case (14):
      231 
      232 		if FREE then
      233 		     free struct_ptr -> dup_prev in (file_model_area);
      234 		else allocate dup_prev set (struct_ptr) in (file_model_area);
      235 		goto return_label;
      236 
      237 case (15):
      238 
      239 		if FREE then
      240 		     free struct_ptr -> select_chain in (file_model_area);
      241 		else allocate select_chain set (struct_ptr) in (file_model_area);
      242 		goto return_label;
      243 
      244 
      245 	     end;
      246 
      247 mrds_rst_model_alloc$variable: entry (rsc_ptr, model_seg_path, struct_type, struct_size, struct_ptr);
      248 
      249 /* entry to handle structures whose length is variable */
      250 
      251 	FREE = OFF;
      252 
      253 var_common:
      254 
      255 	if ^rsc.trace_sw then ;
      256 	else call trace (ON);			/* input call */
      257 
      258 /* establish on unit to capture model overflow */
      259 
      260 	on area
      261 	     begin;
      262 		struct_ptr = null ();		/* to tell caller we failed */
      263 		goto return_label;
      264 	     end;
      265 
      266 	call decode_model_seg_path ();
      267 
      268 	if struct_type < lbound (var_case, 1) | struct_type > hbound (var_case, 1) then
      269 	     call bad_struct_type ();
      270 	else if struct_size < 1 then
      271 	     call bad_struct_size ();
      272 
      273 	else do;
      274 
      275 /* good encoding and size given, go allocate the given structure
      276*   with the specified size, and place it according to the area policy */
      277 
      278 		goto var_case (struct_type);
      279 
      280 var_case (30):
      281 
      282 		if FREE then
      283 		     free struct_ptr -> constant in (db_model_area);
      284 		else do;
      285 			alloc_length = struct_size;
      286 			allocate constant set (struct_ptr) in (db_model_area);
      287 		     end;
      288 		goto return_label;
      289 
      290 var_case (31):
      291 
      292 		if FREE then
      293 		     free struct_ptr -> atd in (file_model_area);
      294 		else do;
      295 			atd_len = struct_size;
      296 			allocate atd set (struct_ptr) in (file_model_area);
      297 		     end;
      298 		goto return_label;
      299 
      300 var_case (32):
      301 
      302 		if FREE then
      303 		     free struct_ptr -> comp_no_array in (file_model_area);
      304 		else do;
      305 			ncomp_init = struct_size;
      306 			allocate comp_no_array set (struct_ptr) in (file_model_area);
      307 		     end;
      308 		goto return_label;
      309 
      310 	     end;
      311 
      312 return_label:
      313 
      314 	if ^rsc.trace_sw then ;
      315 	else call trace (OFF);			/* output call */
      316 
      317 
      318 	return;
      319 
      320 decode_model_seg_path: procedure ();
      321 
      322 /* get the pointer, directory, and entry for either the
      323*   file_model or db_model, depending on the model segment path input */
      324 
      325 	call expand_pathname_ (model_seg_path, model_seg_path_dir, model_seg_path_entry, error_code);
      326 	if error_code ^= 0 then
      327 	     call mrds_rst_error (rsc_ptr, 4, error_code,
      328 		"Bad pathname: " || model_seg_path);
      329 
      330 
      331 	else do;
      332 		seg_ptr = cv_ptr_ (model_seg_path, error_code);
      333 
      334 /* code ^= 0, if seg not created yet for db or file_model */
      335 
      336 		if error_code ^= 0 then do;
      337 			dbm_ptr = null ();
      338 			fm_ptr = null ();
      339 		     end;
      340 		else do;
      341 			if model_seg_path_entry = "db_model" then do;
      342 				dbm_ptr = seg_ptr;
      343 				fm_ptr = null ();
      344 			     end;
      345 			else do;
      346 				fm_ptr = seg_ptr;
      347 				dbm_ptr = null ();
      348 			     end;
      349 		     end;
      350 
      351 
      352 	     end;
      353 
      354      end;
      355 
      356 bad_struct_type: procedure ();
      357 
      358 /* error routine for bad structure encoding value */
      359 
      360 	call ioa_$rs ("^a ^d ^a", message, message_length,
      361 	     "LOGIC ERROR in mrds_rst_model_alloc,", struct_type,
      362 	     "is an invalid code for structure type.");
      363 	call mrds_rst_error (rsc_ptr, 4 /* severity */, mrds_error_$rst_logic_error, (message));
      364 
      365      end;
      366 
      367 bad_struct_size: procedure ();
      368 
      369 /* report bad strructure allocation length */
      370 
      371 	call ioa_$rs ("^a ^d ^a", message, message_length,
      372 	     "LOGIC ERROR in mrds_rst_model_alloc,", struct_size,
      373 	     "is an illegal structure allocation size.");
      374 	call mrds_rst_error (rsc_ptr, 4 /* severity */, mrds_error_$rst_logic_error, (message));
      375 
      376      end;
      377 
      378 unable_to_make_segment: procedure ();
      379 
      380 /* report trouble in making a model segment */
      381 
      382 	call ioa_$rs ("^a^a^a^a^a", message, message_length,
      383 	     "Unable to make the model segment with directory """,
      384 	     model_seg_path_dir, """ and entry portion """,
      385 	     model_seg_path_entry, """ in the database model.");
      386 	call mrds_rst_error (rsc_ptr, 4 /* severity */, error_code, (message));
      387 
      388      end;
      389 
      390 trace: procedure (in_out);
      391 
      392 /* common to metering routine */
      393 
      394 	struct_type_picture = struct_type;
      395 	call mrds_rst_meter (rsc_ptr, "mrds_rst_model_alloc", in_out, (struct_type_picture));
      396 
      397 
      398 	declare in_out		 bit (1);		/* on => input, off => output call */
      399 	declare struct_type_picture	 picture "99";	/* character version of encoding */
      400 
      401      end;
      402 
      403 	declare cv_ptr_		 entry (char (*), fixed bin (35)) returns (ptr); /* gets segments pointer from path */
      404 	declare seg_ptr		 ptr;		/* temp store for segment pointer */
      405 	declare mrds_error_$rst_logic_error fixed bin (35) external; /* program error */
      406 	declare error_code		 fixed bin (35);	/* 0 => no error, else coded error */
      407 	declare model_seg_path_dir	 char (168);	/* directory portion of pathname */
      408 	declare model_seg_path_entry	 char (32);	/* entry portion of pathname */
      409 	declare sys_info$max_seg_size	 fixed bin (35) external; /* system segment length */
      410 	declare (lbound, hbound, addr, fixed, rel, null) builtin;
      411 	declare mrds_rst_meter	 entry (ptr, char (*), bit (1), char (*)); /* trace routine */
      412 	declare ioa_$rs		 entry options (variable); /* string manipulator */
      413 	declare message		 char (96) varying; /* specifics of error */
      414 	declare message_length	 fixed bin (21);	/* length of returned message */
      415 	declare area		 condition;	/* will occur if model space used up */
      416 	declare mrds_rst_error	 entry (ptr, fixed bin, fixed bin (35), char (*)); /* common error routine */
      417 	declare FREE		 bit (1);		/* on => free, off => allocate */
      418 	declare struct_ptr		 ptr;		/* pointer to allocated structure, or instance tobe freed */
      419 	declare struct_type		 fixed bin;	/* encoding value for this structure to allocate or free */
      420 	declare struct_size		 fixed bin (35);	/* length to allocate for variable size struc tures */
      421 	declare model_seg_path	 char (*);	/* pathname of segment to allocate in */
      422 	declare ON		 bit (1) internal static options (constant) init ("1"b); /* true value */
      423 	declare OFF		 bit (1) internal static options (constant) init ("0"b); /* false value */
      424 	dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
      425 	declare hcs_$make_seg	 entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35)); /* creates segments */
      426 	declare file_model_area	 area based (addr (file_model.fm_area));
      427 	declare db_model_area	 area based (addr (db_model.dbm_area));
      428 
  1     1 /* BEGIN INCLUDE FILE mrds_rst_struct_types.incl.pl1 - - Jim Gray 2/20/79 */
  1     2 
  1     3 /* these constants are used to identify structures to be allocated
  1     4*   to the general purpose allocation routines */
  1     5 
  1     6 /*  HISTORY:
  1     7*    82-06-28 Roger Lackey : Removed struct types 52, 53, 54, 55, 56, 57, 58
  1     8*    Type 25 is no longer used and is handled with special code so bounds of 
  1     9*    array could continue to work */
  1    10 
  1    11 /* PARSE INFO STRUCTURES */
  1    12 
  1    13 declare  DOMAIN fixed bin internal static options (constant) init (1) ;
  1    14 declare  ATTRIBUTE_DOMAIN fixed bin internal static options (constant) init (2) ;
  1    15 declare  RELATION fixed bin internal static options (constant) init (3) ;
  1    16 declare  ATTRIBUTE fixed bin internal static options (constant) init (4) ;
  1    17 declare  FILE fixed bin internal static options (constant) init (5) ;
  1    18 declare  ITEM fixed bin internal static options (constant) init (6) ;
  1    19 declare  LINK fixed bin internal static options (constant) init (7) ;
  1    20 declare  FOREIGN_KEY fixed bin internal static options (constant) init (8) ;
  1    21 declare  CHILDREN fixed bin internal static options (constant) init (9) ;
  1    22 declare  INDEX fixed bin internal static options (constant) init (10) ;
  1    23 declare  DELETE_NAME fixed bin internal static options (constant) init (11) ;
  1    24 declare  DOM_LIST fixed bin internal static options (constant) init (12) ; /* in link handler */
  1    25 
  1    26 /* SEMANTIC STRUCTURES */
  1    27 
  1    28 declare  DIRECTIVE fixed bin internal static options (constant) init (13) ;
  1    29 declare  STMT fixed bin internal static options (constant) init (14) ;
  1    30 
  1    31 
  1    32 /* PARSING STRUCTURES */
  1    33 
  1    34 declare  LEX_STACK fixed bin internal static options (constant) init (15) ;
  1    35 declare  P_STRUCT fixed bin internal static options (constant) init (16) ;
  1    36 declare  CUR_LEX_TOP fixed bin internal static options (constant) init (17) ;
  1    37 declare  FIXUP_TOKEN fixed bin internal static options (constant) init (50) ; /* scanner */
  1    38 declare  STRING_SOURCE fixed bin internal static options (constant) init (51) ; /* semantics */
  1    39 declare  TOKEN fixed bin internal static options (constant) init (18) ;
  1    40 declare  OUTPUT_TEXT fixed bin internal static options (constant) init (19) ;
  1    41 
  1    42 
  1    43 /* DB_MODEL STRUCTURES */
  1    44 
  1    45 declare  DB_MODEL fixed bin internal static options (constant) init (0) ;
  1    46 declare  FILE_INFO fixed bin internal static options (constant) init (1) ;
  1    47 declare  DOMAIN_INFO fixed bin internal static options (constant) init (2) ;
  1    48 declare  PATH_ENTRY fixed bin internal static options (constant) init (3) ;
  1    49 declare  STACK_ITEM fixed bin internal static options (constant) init (4) ;
  1    50 declare  CONSTANT fixed bin internal static options (constant) init (30) ;
  1    51 declare  VERSION_STATUS fixed bin internal static options (constant) init (5) ;
  1    52 declare  CHANGER fixed bin internal static options (constant) init (6) ;
  1    53 
  1    54 
  1    55 /* FILE_MODEL STRUCTURES */
  1    56 
  1    57 declare  FILE_MODEL fixed bin internal static options (constant) init (7) ;
  1    58 declare  REL_INFO fixed bin internal static options (constant) init (8) ;
  1    59 declare  ATTR_INFO fixed bin internal static options (constant) init (9) ;
  1    60 declare  PARENT_LINK_INFO fixed bin internal static options (constant) init (10) ;
  1    61 declare  CHILD_LINK_INFO fixed bin internal static options (constant) init (11) ;
  1    62 declare  ATTR_LIST fixed bin internal static options (constant) init (12) ;
  1    63 declare  ATD fixed bin internal static options (constant) init (31) ;
  1    64 declare  COMP_NO_ARRAY fixed bin internal static options (constant) init (32) ;
  1    65 declare  SORT_KEY fixed bin internal static options (constant) init (13) ;
  1    66 declare  DUP_PREV fixed bin internal static options (constant) init (14) ;
  1    67 declare  SELECT_CHAIN fixed bin internal static options (constant) init (15) ;
  1    68 
  1    69 
  1    70 /* GLOBAL LIST STRUCTURES */
  1    71 
  1    72 declare  GL fixed bin internal static options (constant) init (20) ;
  1    73 declare  SL fixed bin internal static options (constant) init (21) ;
  1    74 declare  SEGINFO fixed bin internal static options (constant) init (22) ;
  1    75 declare  LIST_OVRLY fixed bin internal static options (constant) init (26) ;
  1    76 declare  SAVED_CHILD_COUNT fixed bin internal static options (constant) init (24) ; /* in global list build */
  1    77 declare  NODE fixed bin internal static options (constant) init (23) ;
  1    78 
  1    79 
  1    80 /* DISPLAY STRUCTURES */
  1    81 
  1    82 declare  DISPLAY_INFO fixed bin internal static options (constant) init (25) ;
  1    83 
  1    84 /*   Remove because nolonger used 82-06-28        
  1    85*  NAME_LIST fixed bin internal static options (constant) init (52) ;
  1    86*  PAI_ARRAY fixed bin internal static options (constant) init (53) ;
  1    87*  PAR_LK_ATTR_INFO fixed bin internal static options (constant) init (54) ;
  1    88*  CAI_ARRAY fixed bin internal static options (constant) init (55) ;
  1    89*  CHILD_LK_ATTR_INFO fixed bin internal static options (constant) init (56) ;
  1    90*  NAME_TABLE fixed bin internal static options (constant) init (57) ;
  1    91*  ATTR_TABLE fixed bin internal static options (constant) init (58) ;
  1    92**/
  1    93 
  1    94 /* END INCULDE FILE mrds_rst_struct_types */
  1    95 
      429 
  2     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  2     6*     modified to save space occupied by model
  2     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  2     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  2     9*     the number of secondary indices in the relation - it was always zero.
  2    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  2    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  2    12*     DMS conversion.
  2    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  2    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  2    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  2    16*     for relation manager changes.
  2    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  2    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  2    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  2    20*     <rel> files are good (for rmdb)
  2    21*                                                   END HISTORY COMMENTS */
  2    22 
  2    23 
  2    24 /* each file in the database will have a model segment with the name
  2    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  2    26*   the file_model structure is allocated at the base of the segment for a given file.
  2    27*   it contains an area with which all other structures in this include file are allocated.
  2    28*   these structures contain the information about which relations, foreign keys,
  2    29*   and attributes are members of this file. all lists are singly linked lists in
  2    30*   definition order. pointers to these structures are obtained by using the "pointer"
  2    31*   builtin function with arguments of the segment base pointer, and the
  2    32*   offset (bit (18)) relative to that pointer that is actually stored in
  2    33*   the file model itself. this is because pointer segment numbers are
  2    34*   per process dependent. the major lists pointed to by the file_model structure
  2    35*   are the list of relations in this file(each with a contained attribute list),
  2    36*   and the list of foreign keys whose parent relation resides in this file
  2    37*   (along with a participating attribute sublist, and the child relation list,
  2    38*   if they are also in this file) */
  2    39 
  2    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  2    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  2    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  2    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  2    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  2    45     2 reserved bit (32) unal,				/* reserved for future flags */
  2    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  2    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  2    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  2    49     2 pad_1 fixed bin (35),				/* for future use */
  2    50     2 pad_2 fixed bin (35),
  2    51     2 ratd_len fixed bin (21),			/* length of above */
  2    52     2 mratd_len fixed bin (21),			/* length of above */
  2    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  2    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  2    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  2    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  2    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  2    58     2 block_size unal fixed bin,			/* no. pages in block */
  2    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  2    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  2    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  2    62     2 num_rels unal fixed bin,			/* number of relations in file */
  2    63     2 num_links unal fixed bin,			/* number of links in file */
  2    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  2    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  2    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  2    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  2    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  2    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  2    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  2    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  2    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  2    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  2    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  2    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  2    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  2    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  2    78     2 open_eu_err_path_ptr unal bit (18),
  2    79     2 open_eu_after_path_ptr unal bit (18),
  2    80     2 open_er_before_path_ptr unal bit (18),
  2    81     2 open_er_err_path_ptr unal bit (18),
  2    82     2 open_er_after_path_ptr unal bit (18),
  2    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  2    84     2 open_neu_err_path_ptr unal bit (18),
  2    85     2 open_neu_after_path_ptr unal bit (18),
  2    86     2 open_ner_before_path_ptr unal bit (18),
  2    87     2 open_ner_err_path_ptr unal bit (18),
  2    88     2 open_ner_after_path_ptr unal bit (18),
  2    89     2 open_pu_before_path_ptr unal bit (18),
  2    90     2 open_pu_err_path_ptr unal bit (18),
  2    91     2 open_pu_after_path_ptr unal bit (18),
  2    92     2 open_pr_before_path_ptr unal bit (18),
  2    93     2 open_pr_err_path_ptr unal bit (18),
  2    94     2 open_pr_after_path_ptr unal bit (18),
  2    95     2 open_cu_before_path_ptr unal bit (18),
  2    96     2 open_cu_err_path_ptr unal bit (18),
  2    97     2 open_cu_after_path_ptr unal bit (18),
  2    98     2 open_cr_before_path_ptr unal bit (18),
  2    99     2 open_cr_err_path_ptr unal bit (18),
  2   100     2 open_cr_after_path_ptr unal bit (18),
  2   101     2 close_before_path_ptr unal bit (18),
  2   102     2 close_err_path_ptr unal bit (18),
  2   103     2 close_after_path_ptr unal bit (18),
  2   104     2 unused_1 unal bit (18),				/* for future expansion */
  2   105     2 unused_2 unal bit (18),
  2   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  2   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  2   108 dcl  fm_ptr ptr;
  2   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  2   110 dcl  atd_ptr ptr;
  2   111 dcl  atd_len fixed bin;
  2   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  2   113     2 ncomponents fixed bin,
  2   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  2   115 dcl  cna_ptr ptr;
  2   116 dcl  ncomp_init fixed bin;
  2   117 
  2   118 /* a rel_info structure contains information describing a relation.
  2   119*   a relation may only occur in one file, thus there is one rel_info
  2   120*   per relation per database, each stored in the file_model area for
  2   121*   the file that contains it. the list of rel_info's in this file
  2   122*   form a singly linked list in definition order.
  2   123*   the rel_info itself points to a list of the attributes it contains,
  2   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  2   125 
  2   126 dcl 1 rel_info aligned based (ri_ptr),
  2   127     2 name char (32),				/* relation name */
  2   128     2 id  bit (36) aligned,				/* relation id number */
  2   129     2 hashed bit (1) unal,				/* on if hashed */
  2   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  2   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  2   132     2 system bit (1) unal,				/* on if dont care how stored */
  2   133     2 indexed bit (1) unal,				/* on if secondary index */
  2   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  2   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  2   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  2   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  2   138     2 reserved bit (27) unal,				/* for future flags */
  2   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  2   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  2   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  2   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  2   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  2   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  2   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  2   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  2   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  2   148     2 unused_3 unal fixed bin,			/* element that was never used */
  2   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  2   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  2   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  2   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  2   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  2   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  2   155     2 attr_ptr unal bit (18),				/* to attr. info */
  2   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  2   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  2   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  2   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  2   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  2   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  2   162     2 link_err_path_ptr unal bit (18),
  2   163     2 link_after_path_ptr unal bit (18),
  2   164     2 unlk_before_path_ptr unal bit (18),
  2   165     2 unlk_err_path_ptr unal bit (18),
  2   166     2 unlk_after_path_ptr unal bit (18),
  2   167     2 str_before_path_ptr unal bit (18),
  2   168     2 str_err_path_ptr unal bit (18),
  2   169     2 str_after_path_ptr unal bit (18),
  2   170     2 del_before_path_ptr unal bit (18),
  2   171     2 del_err_path_ptr unal bit (18),
  2   172     2 del_after_path_ptr unal bit (18),
  2   173     2 mod_before_path_ptr unal bit (18),
  2   174     2 mod_err_path_ptr unal bit (18),
  2   175     2 mod_after_path_ptr unal bit (18),
  2   176     2 find_before_path_ptr unal bit (18),
  2   177     2 find_err_path_ptr unal bit (18),
  2   178     2 find_after_path_ptr unal bit (18),
  2   179     2 retr_before_path_ptr unal bit (18),
  2   180     2 retr_err_path_ptr unal bit (18),
  2   181     2 retr_after_path_ptr unal bit (18),
  2   182     2 unused_1 unal bit (18),				/* for future expansion */
  2   183     2 unused_2 unal bit (18),
  2   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  2   185 dcl  ri_ptr ptr;
  2   186 
  2   187 /* a attr_info structure contains information about an attribute in a given relation.
  2   188*   since attributes may appear in more than one relation, each occurence of an attribute
  2   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  2   190*   the list is singly linked in definition order. the attr_info describes
  2   191*   the data it represents, and how that data is used during a database search. */
  2   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  2   193     2 name char (32),				/* name of attribute */
  2   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  2   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  2   196     2 link_attr bit (1) unal,				/* on if participates in link */
  2   197     2 reserved bit (33) unal,
  2   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  2   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  2   200     2 key_order unal fixed bin,			/* relative posit. in key */
  2   201     2 bit_offset fixed bin (35),			/* position in tuple */
  2   202     2 bit_length fixed bin (35),			/* length if fixed */
  2   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  2   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  2   205     2 domain_ptr unal bit (18),			/* to domain info */
  2   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  2   207     2 fwd_thread unal bit (18),			/* to next in list */
  2   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  2   209 dcl  ai_ptr ptr;
  2   210 
  2   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  2   212*   each time a foreign key definition indicates a relation as it's parent,
  2   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  2   214*   a relation can be parent and/or child in any number of foreign keys.
  2   215*   the parent_link_info structure describes the foreign key, and also points
  2   216*   to a list of the attributes that participate in this foreign key.
  2   217*   (this could be from 1 up to all attributes in the relation)
  2   218*   the attr_list structures are in a singly linked list in definition order
  2   219*   for this purpose. also pointed to is a list of child_link_info's
  2   220*   that describe the child relations in this foreign key. since foreign keys
  2   221*   may span files, not all related child_link_info's have to be in this file's
  2   222*   model area. */
  2   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  2   224     2 name char (32),				/* name of link */
  2   225     2 singular bit (1) unal,				/* on if system owned link */
  2   226     2 temp bit (1) unal,				/* on if temp. order */
  2   227     2 first bit (1) unal,				/* insertion indicators */
  2   228     2 last bit (1) unal,
  2   229     2 next bit (1) unal,
  2   230     2 prior bit (1) unal,
  2   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  2   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  2   233     2 dup_first bit (1) unal,				/* duplicates first */
  2   234     2 dup_last bit (1) unal,				/* duplicates last */
  2   235     2 indexed bit (1) unal,				/* locate parent via index */
  2   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  2   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  2   238     2 thread_27 bit (1) unal,
  2   239     2 thread_18 bit (1) unal,
  2   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  2   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  2   242     2 reserved bit (19) unal,				/* reserved for future flags */
  2   243     2 index_id aligned bit (8),			/* id of index if indexed */
  2   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  2   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  2   246     2 n_children unal fixed bin,			/* no. children in link */
  2   247     2 child_fn char (30),				/* file name for first child in list */
  2   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  2   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  2   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  2   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  2   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  2   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  2   254     2 sort_err_path_ptr unal bit (18),
  2   255     2 sort_after_path_ptr unal bit (18),
  2   256     2 srch_before_path_ptr unal bit (18),
  2   257     2 srch_err_path_ptr unal bit (18),
  2   258     2 srch_after_path_ptr unal bit (18),
  2   259     2 link_before_path_ptr unal bit (18),
  2   260     2 link_err_path_ptr unal bit (18),
  2   261     2 link_after_path_ptr unal bit (18),
  2   262     2 unlk_before_path_ptr unal bit (18),
  2   263     2 unlk_err_path_ptr unal bit (18),
  2   264     2 unlk_after_path_ptr unal bit (18),
  2   265     2 unused_1 unal bit (18),				/* for future expansion */
  2   266     2 unused_2 unal bit (18),
  2   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  2   268 dcl  pli_ptr ptr;
  2   269 
  2   270 /* a child_link_info structure is the counter part of a parent_link_info
  2   271*   for foreign key child relations. each time a relation is defined to be
  2   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  2   273*   this list is singly linked in foreign key definition order.
  2   274*   the child_link_info points to a list of participating attributes from the
  2   275*   child relation by means of a singly linked list of attr_list structures
  2   276*   in definition order. the number of attributes in the parent attr_list
  2   277*   and the child attr_list lists are the same with corresponding attr_list
  2   278*   attributes having the same domain. all child_link_infos in this file
  2   279*   are on a seperately linked list. this may not include all
  2   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  2   281*   since foreign keys may span files, and the child_link_info will
  2   282*   reside in the file containing it's associated relation_info. */
  2   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  2   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  2   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  2   286     2 fixed bit (1) unal,				/* on if membership fixed */
  2   287     2 optional bit (1) unal,				/* on if membership optional */
  2   288     2 auto bit (1) unal,				/* on if insertion automatic */
  2   289     2 manual bit (1) unal,				/* on if insertion manual */
  2   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  2   291     2 range_sel bit (1) unal,				/* on if range type selection */
  2   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  2   293     2 key_dup_last bit (1) unal,
  2   294     2 key_null bit (1) unal,				/* on if null allowed */
  2   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  2   296     2 sel_current bit (1) unal,
  2   297     2 sel_key bit (1) unal,
  2   298     2 sel_proc bit (1) unal,
  2   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  2   300     2 reserved bit (21) unal,
  2   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  2   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  2   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  2   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  2   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  2   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  2   307     2 parent_fn char (30),				/* file name for parent info */
  2   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  2   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  2   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  2   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  2   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  2   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  2   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  2   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  2   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  2   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  2   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  2   319     2 link_err_path_ptr unal bit (18),
  2   320     2 link_after_path_ptr unal bit (18),
  2   321     2 unlk_before_path_ptr unal bit (18),
  2   322     2 unlk_err_path_ptr unal bit (18),
  2   323     2 unlk_after_path_ptr unal bit (18),
  2   324     2 srch_before_path_ptr unal bit (18),
  2   325     2 srch_err_path_ptr unal bit (18),
  2   326     2 srch_after_path_ptr unal bit (18),
  2   327     2 unused_1 unal bit (18),				/* for future expansion */
  2   328     2 unused_2 unal bit (18) ;
  2   329 dcl  cli_ptr ptr;
  2   330 
  2   331 /* the attr_list structure is associated with the parent_link_info
  2   332*   and child_link_info structures to represent by means of a singly linked list
  2   333*   the participating attributes from relations in a foreign key.
  2   334*   the parent_link_info has a list for the parent relation,
  2   335*   and the child_link_info has a list for the child relation.
  2   336*   the participating attributes are a subset(not necessary proper) of
  2   337*   those attributes contained in a relation definition.
  2   338*   there are equal numbers of attr_list structures in the parent and
  2   339*   child lists of the same foreign key. the corresponding attributes in these
  2   340*   lists must have the same domain. */
  2   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  2   342     2 attr_fn char (30),				/* file name for attr. */
  2   343     2 attr_ptr unal bit (18),				/* to attr info block */
  2   344     2 fwd_thread unal bit (18);			/* to next in list */
  2   345 dcl  al_ptr ptr;
  2   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  2   347     2 ascend bit (1) unal,				/* ascending order */
  2   348     2 descend bit (1) unal,				/* descending order */
  2   349     2 reserved bit (34) unal,
  2   350     2 attr_ptr unal bit (18),				/* to attr info */
  2   351     2 fwd_thread unal bit (18);			/* to next in list */
  2   352 dcl  sk_ptr ptr;
  2   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  2   354     2 attr_ptr unal bit (18),				/* to attr info */
  2   355     2 fwd_thread unal bit (18);			/* to next in list */
  2   356 dcl  dp_ptr ptr;
  2   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  2   358     2 link_fn char (30),				/* file name for thru link */
  2   359     2 link_ptr unal bit (18),				/* to parent link info */
  2   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  2   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  2   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  2   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  2   364     2 fwd_thread unal bit (18);			/* to next in chain */
  2   365 dcl  sc_ptr ptr;
  2   366 
  2   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  2   368 
  2   369 
      430 
  3     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  3     6*     modified to save space occupied by model
  3     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  3     8*     to add mdbm_secured bit in db_model
  3     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  3    10*     collapsed the following into an unused_offset array:
  3    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  3    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  3    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  3    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  3    15*       unused_1
  3    16*     Also changed the name of unused_2 to restructuring_history_offset
  3    17*     and changed the comment on the changer structure to indicate
  3    18*     that it will contain on database creation information.
  3    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  3    20*     used one of the unused_offsets to point to a message which indicates
  3    21*     why the db is inconsistent. The offset will be null when the db is created
  3    22*     and set the first time the message is used. this is so it will be
  3    23*     consistent with existing data bases. Also added the message structure.
  3    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  3    25*     added the undo_request element to the message structure
  3    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  3    27*     changed unused_offset (12) to last_restructruring_history_offset and
  3    28*     changed restructuring_history_offset to first_restructuring_history_offset
  3    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  3    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  3    31*     1 => vfile database and 2 => page_file database. Up to this point all
  3    32*     database types were equal to 1.
  3    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  3    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  3    35*     flags. This will allow information about transactions and dm_file
  3    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  3    37*     change is compatable with all datamodels created by the released version
  3    38*     of mrds.
  3    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  3    40*     added the rollback_on flag to the db_type_flags since it appears that you
  3    41*     can have a dmfile database that requires transactions but does not have any
  3    42*     journalizing. Also switched the order of the transactions_needed and
  3    43*     concurrency_on flags - this makes the change compatable with existing
  3    44*     dmfile databases except when displaying the model since concurrency_on and
  3    45*     rollback_on will be off in the model even though the dmfile relations had
  3    46*     them on during creation.
  3    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  3    48*      Removed ctl_file_path_ptr.
  3    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  3    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  3    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  3    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  3    53*      in the flag word for rmdb copying.
  3    54*                                                   END HISTORY COMMENTS */
  3    55 
  3    56 
  3    57 /* this include file contains the structures that go into the make up
  3    58*   of the "db_model" segment in the model for the database.
  3    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  3    60*
  3    61*   the db_model structure goes at the base of the segment, and contains items unique to
  3    62*   the whole databse. in addition, it has an area of size to fill the
  3    63*   rest of a segment, that holds the lists of files and domains in the database.
  3    64*   these lists are singly forward linked lists. all "pointers" in the database model
  3    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  3    66*   since actual pointers are process dependent on segment number.
  3    67*   the remaining structures are first a path_entry one to save pathnames in,
  3    68*   and the stack_item and constent structures, used to save a boolean
  3    69*   expression in polish form, with the stack represented by a linked list.
  3    70*   the final structure is one for identifying the status of version information */
  3    71 
  3    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  3    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  3    74 	     2 db_type_flags      unal,
  3    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  3    76 	       3 unused	      (13) bit (1) unal,
  3    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  3    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  3    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  3    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  3    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  3    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  3    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  3    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  3    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  3    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  3    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  3    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  3    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  3    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  3    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  3    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  3    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  3    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  3    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  3    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  3    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  3    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  3    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  3   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  3   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  3   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  3   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  3   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  3   105 
  3   106      dcl	   dbm_ptr	      ptr;
  3   107 
  3   108 /* the files in the database each have a file_info containing
  3   109*   their name, the file_model for each file is found by initiating the
  3   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  3   111*   the file_info list is a singly linked list in definition order */
  3   112 
  3   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  3   114 	     2 file_name	      char (30),		/* name of file */
  3   115 	     2 file_id	      bit (36),		/* id number of file */
  3   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  3   117 	     2 unused	      unal bit (18);	/* for future expansion */
  3   118 
  3   119      dcl	   fi_ptr		      ptr;
  3   120 
  3   121 /* each domain used in the database will have a domain info saved in the db_model
  3   122*   segment. it describes the domain of the given name, and it's options.
  3   123*   the domain_info's form a singly linked list in definition order */
  3   124 
  3   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  3   126 	     2 name	      char (32),		/* name of domain */
  3   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  3   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  3   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  3   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  3   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  3   132 	     2 reserved	      bit (31) unal,
  3   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  3   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  3   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  3   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  3   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  3   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  3   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  3   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  3   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  3   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  3   143 	     2 str_err_path_ptr   unal bit (18),
  3   144 	     2 str_after_path_ptr unal bit (18),
  3   145 	     2 get_before_path_ptr unal bit (18),
  3   146 	     2 get_err_path_ptr   unal bit (18),
  3   147 	     2 get_after_path_ptr unal bit (18),
  3   148 	     2 mod_before_path_ptr unal bit (18),
  3   149 	     2 mod_err_path_ptr   unal bit (18),
  3   150 	     2 mod_after_path_ptr unal bit (18),
  3   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  3   152 	     2 unused_2	      unal bit (18),
  3   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  3   154 
  3   155      dcl	   di_ptr		      ptr;
  3   156 
  3   157 /* information necessary for attributes that are not used in any relation */
  3   158 
  3   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  3   160 	     2 name char (32),			/* name of attribute */
  3   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  3   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  3   163 	     2 unused (2) bit (18) unal;
  3   164 
  3   165      dcl     ua_ptr ptr;
  3   166 
  3   167 
  3   168 /* space saving pathname$entryname structure, to be allocated
  3   169*   only when a path$entry has to be saved, else only a bit(18)
  3   170*   offset takes up space in the main model structure */
  3   171 
  3   172      declare 1 path_entry	      based (path_entry_ptr),
  3   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  3   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  3   175 	     2 reserved	      unal bit (36);	/* for future use */
  3   176 
  3   177      declare path_entry_ptr	      ptr;
  3   178 
  3   179 
  3   180 
  3   181 
  3   182 
  3   183 /* declarations for model of postfix stack holding the check option boolean expression
  3   184*   the following encoding values indicate the corresponding type of stack element
  3   185*
  3   186*   1  =
  3   187*   2  ^=
  3   188*   3  >
  3   189*   4  <
  3   190*   5  >=
  3   191*   6  <=
  3   192*
  3   193*   10  and
  3   194*   20  or
  3   195*   30  not
  3   196*
  3   197*   40  - (minus)
  3   198*
  3   199*   50  domain variable(same name as domain)
  3   200*
  3   201*   60  constant(number, bit string, or character string)
  3   202*
  3   203**/
  3   204 
  3   205 
  3   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  3   207 	     2 next	      bit (18),		/* link to next in list */
  3   208 	     2 type	      fixed binary,		/* code for this element type */
  3   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  3   210*						   if this is a constant element type */
  3   211 
  3   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  3   213 
  3   214 
  3   215 
  3   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  3   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  3   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  3   219 
  3   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  3   221 
  3   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  3   223 
  3   224 /* version structure, giving status of source for CMDB/RMDB,
  3   225*   status of model, and status of resultant */
  3   226 
  3   227 /* version number is in form MM.N.Y
  3   228*   where MM is the major version number, N is the minor version alteration,
  3   229*   and Y is the lastest modification to that alteration,
  3   230*   where M and N represent numbers 0-9, and Y is a letter */
  3   231 
  3   232      declare 1 version_status	      unal based (version_status_ptr),
  3   233 	     2 cmdb_rmdb,
  3   234 	       3 major	      fixed bin,
  3   235 	       3 minor	      fixed bin,
  3   236 	       3 modification     char (4),
  3   237 	     2 model,
  3   238 	       3 major	      fixed bin,
  3   239 	       3 minor	      fixed bin,
  3   240 	       3 modification     char (4),
  3   241 	     2 resultant,
  3   242 	       3 major	      fixed bin,
  3   243 	       3 minor	      fixed bin,
  3   244 	       3 modification     char (4);
  3   245 
  3   246      declare version_status_ptr     ptr;
  3   247 
  3   248 
  3   249 /* maintains information only about the db creation */
  3   250 
  3   251      declare 1 changer	      unal based (changer_ptr),
  3   252 	     2 id		      char (32),
  3   253 	     2 time	      fixed bin (71),
  3   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  3   255 
  3   256      declare changer_ptr	      ptr;
  3   257 
  3   258 
  3   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  3   260 	     02 len	      fixed bin,		/* length of the message */
  3   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  3   262 	     02 name	      char (32),		/* name of thing that set the message */
  3   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  3   264*                                                               that caused the database to become inconsistent */
  3   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  3   266 
  3   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  3   268 
  3   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  3   270 
  3   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  3   272 
  3   273 
      431 
  4     1 /* BEGIN INCLUDE FILE mrds_rst_rsc.incl.pl1		RDL  7/7/78	*/
  4     2 
  4     3 /* Modified 8/21/78 by RDL */
  4     4 
  4     5 /* Modified 9/11/78 	by RDL to add directive and stmt pointers */
  4     6 
  4     7 /* Modified 11/4/78		by RDL to add debug,trace,meter switches
  4     8*
  4     9*   Modified 3/29/79 by RDL to change s_seg_info_ptr to source_seg_ptr
  4    10*
  4    11*   Modified by Jim Gray - - Jan. 1980, to add flags to disallow blocked files, forieng keys, and restructuring.
  4    12*
  4    13*   Modified by Jim Gray - - Feb. 1980, to add command level flag for cmdb subroutine interface.
  4    14*
  4    15*   Modified by Jim Gray - - 80-11-06, to add bit for cmdb -secure option.
  4    16*
  4    17*   81-05-18 Jim Gray : added bit for max_attributes error message, so that
  4    18*   it would only be issued on first occurence.
  4    19*
  4    20*   82-08-19 Davids: added the db_type field.
  4    21*
  4    22*   83-02-18 Mike Kubicar : Removed the db_type field and added the 
  4    23*   db_relation_mode_flags substructure to define the modes applicable
  4    24*   to the database's relations.  Also removed assorted unsed fields
  4    25*   (names that included the word unused).
  4    26*
  4    27**/
  4    28 
  4    29 dcl 1 rsc based (rsc_ptr),				/* Restructuring control info */
  4    30     2 rsc_dir char (200),				/* pathname of directory containing rsc segment */
  4    31     2 dbp char (168),				/* Database absolute path */
  4    32     2 temp_dir char (168),				/* Path name of temp restrucuring directory */
  4    33     2 temp_dir_sw bit (1) unal,			/* On => temp dir has been created */
  4    34     2 db_quiesced_sw bit (1) unal,			/* On => database has been quiesced */
  4    35     2 o_db_open_sw bit (1) unal,			/* On => old database has been opened */
  4    36     2 n_db_open_sw bit (1) unal,			/* On => temp database is open */
  4    37     2 listing_seg_sw bit (1) unal,			/* On => listing segment has been created */
  4    38     2 skip_scanner_conversion bit (1) unal,		/* Skip conversion in scanner */
  4    39     2 cmdb_option bit (1) unal,			/* ON => this is a cmdb source, not restructuring */
  4    40     2 trace_sw bit (1) unal,				/* On -> trace mode in affect */
  4    41     2 debug_sw bit (1) unal,				/* On = debug mode (NOT IMPLEMENTED) */
  4    42     2 meter_sw bit (1) unal,				/* On = procedures call metering procedure */
  4    43     2 delete_db_sw bit (1) unal,			/* On = delete data base in cleanup */
  4    44     2 model_consistent_sw bit (1) unal,			/* On => Model is consistent */
  4    45     2 physical_started_sw bit (1) unal,			/* On => Physical restructuring started */
  4    46     2 physical_complete_sw bit (1) unal,		/* On => Physical restructuring completed */
  4    47     2 model_overflow bit (1) unal,			/* ON => model segment area condition occurred */
  4    48     2 max_files bit (1) unal,				/* ON => maximum number of files reached */
  4    49     2 allow_foreign_keys bit (1) unal,			/* on => allow foreign key statment */
  4    50     2 foreign_key_seen bit (1) unal,			/* on => foreign key definition in source */
  4    51     2 allow_blocked_files bit (1) unal,			/* on => allow file statement with blocked option */
  4    52     2 blocked_file_seen bit (1) unal,			/* on => blocked file definition in source */
  4    53     2 allow_restructuring bit (1) unal,			/* on => allow RMDB entry point */
  4    54     2 command_level bit (1) unal,			/* on => called from command unal, not subroutine level */
  4    55     2 secure bit (1) unal,				/* on => -secure option given for cmdb */
  4    56     2 max_attrs bit (1) unal,				/* on => max attrs/rel or max indexes/rel exceeded */
  4    57     2 db_relation_mode_flags,
  4    58       3 dm_file_type bit (1) unal,			/* on => relations are dm files */
  4    59       3 protection_on bit (1) unal,			/* on => relations need transactions */
  4    60       3 concurrency_on bit (1) unal,			/* on => concurrency control enabled */
  4    61       3 rollback_on bit (1) unal,			/* on => before journalling is enabled */
  4    62     2 severity_high fixed bin,			/* Highest severity level error encountered */
  4    63     2 phase fixed bin,				/* 000 = init
  4    64*						   100 = global list init
  4    65*						   200 = parse
  4    66*						   300 = physical init
  4    67*						   400 = physical */
  4    68     2 h_o_seg_info_ls_ptr ptr,			/* Pointer to head of old db seg_info list */
  4    69     2 h_n_seg_info_ls_ptr ptr,			/* Pointer to head of new db seg_info list */
  4    70     2 h_gfile_ptr ptr,				/* Pointer to head of global file list */
  4    71     2 h_gdom_ptr ptr,				/* Pointer to head of global domain list */
  4    72     2 h_gattr_ptr ptr,				/* Pointer to head of global attribute list */
  4    73     2 h_grel_ptr ptr,				/* Pointer to head of global relation list */
  4    74     2 h_glink_ptr ptr,				/* Pointer to head of global link list */
  4    75     2 o_dm_ptr ptr,					/* Pointer to old data model seg  (dm_model ) */
  4    76     2 n_dm_ptr ptr,					/* Pointer to temp data model seg */
  4    77     2 o_fn_hdr_ptr ptr,				/* Pointer to head of original file list (fn structure) */
  4    78     2 source_seg_ptr ptr,				/* Pointer to source_seg */
  4    79     2 listing_iocb_ptr ptr,				/* Pointer to listing segment iocb */
  4    80     2 directive_ptr ptr,				/* Pointer to directive type str in mrds_rst_semactics.incl.pl1 */
  4    81     2 stmt_ptr ptr,					/* Pointer to statement str in mrds_rst_sematics.incl.pl1 */
  4    82     2 trace_metering_iocb_ptr ptr,			/* Pointer to seg used by trace and metering */
  4    83     2 tree_node_area_ptr ptr,				/* pointer to working storage for tree nodes */
  4    84     2 tree_data,
  4    85       3 seg_info_area_ptr ptr,			/* seg info working storage area */
  4    86       3 gl_area_ptr ptr,				/* global list data work storage area */
  4    87       3 sl_area_ptr ptr,				/* sublist data work storage area */
  4    88     2 parse_info_area_ptr ptr,			/* parse interface work area storage */
  4    89     2 static_info_area_ptr ptr,			/* directive, stmt and other static work storage area */
  4    90     2 variable_length_area_ptr ptr,			/* varibale allocates work storage area */
  4    91     2 other_area_ptr ptr,				/* unspecified work area storage */
  4    92     2 wa area (sys_info$max_seg_size - fixed (rel (addr (rsc.wa))) + 1); /* Work area */
  4    93 
  4    94 dcl  rsc_ptr ptr;					/* Pointer to base of rsc segment */
  4    95 
  4    96 
  4    97 
  4    98 /* END INCLUDE FILE mrds_rst_rsc.incl.pl1				*/
  4    99 
      432 
      433 
      434      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1143.7  mrds_rst_model_alloc.pl1          >special_ldd>install>MR12.0-1187>mrds_rst_model_alloc.pl1
429          1    10/14/83  1609.0  mrds_rst_struct_types.incl.pl1    >ldd>include>mrds_rst_struct_types.incl.pl1
430          2    10/16/86  1139.9  mdbm_file_model.incl.pl1          >special_ldd>install>MR12.0-1187>mdbm_file_model.incl.pl1
431          3    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
432          4    10/14/83  1609.1  mrds_rst_rsc.incl.pl1             >ldd>include>mrds_rst_rsc.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
FREE                            000226 automatic       bit(1)                   unaligned dcl 417 set ref 83* 91* 122 133 140 147
                                                                                  154 161 168 177 188 195 202 209 216 223 230 237
                                                                                  251* 280 290 300
OFF                                    constant        bit(1)                   initial unaligned dcl 423 set ref 83 251 315*
ON                              000023 constant        bit(1)                   initial unaligned dcl 422 set ref 91 103* 256*
addr                                                   builtin function         dcl 410 ref 133 137 140 144 147 151 154 158 161 165
                                                                                  168 172 188 192 195 199 202 206 209 213 216 220
                                                                                  223 227 230 234 237 241 280 286 290 296 300 306
alloc_length                    000010 internal static fixed bin(35,0)          dcl 3-222 set ref 285* 286 286
area                            000220 stack reference condition                dcl 415 ref 75 260
atd                                    based           char                     unaligned dcl 2-109 ref 290 296
atd_len                         000232 automatic       fixed bin(17,0)          dcl 2-111 set ref 290 290 295* 296 296
attr_info                              based           structure                level 1 dcl 2-192 ref 195 199
attr_list                              based           structure                level 1 dcl 2-341 ref 216 220
changer                                based           structure                level 1 packed unaligned dcl 3-251 ref 168 172
child_link_info                        based           structure                level 1 dcl 2-283 ref 209 213
comp_no_array                          based           structure                level 1 packed unaligned dcl 2-112 set ref 300 306
constant                               based           structure                level 1 unaligned dcl 3-216 set ref 280 286
cv_ptr_                         000012 constant        entry                    external dcl 403 ref 332
db_model                               based           structure                level 1 dcl 3-72
db_model_area                          based           area(1024)               dcl 427 ref 133 137 140 144 147 151 154 158 161 165
                                                                                  168 172 280 286
dbm_area                 34            based           area                     level 2 dcl 3-72 set ref 133 137 140 144 147 151 154
                                                                                  158 161 165 168 172 280 286
dbm_ptr                         000234 automatic       pointer                  dcl 3-106 set ref 133 137 140 144 147 151 154 158
                                                                                  161 165 168 172 280 286 337* 342* 347*
domain_info                            based           structure                level 1 dcl 3-125 ref 140 144
dup_prev                               based           structure                level 1 dcl 2-353 ref 230 234
error_code                      000102 automatic       fixed bin(35,0)          dcl 406 set ref 126* 128 181* 183 325* 326 326* 332*
                                                                                  336 386*
expand_pathname_                000024 constant        entry                    external dcl 424 ref 325
file_info                              based           structure                level 1 dcl 3-113 ref 133 137
file_model                             based           structure                level 1 dcl 2-40
file_model_area                        based           area(1024)               dcl 426 ref 188 192 195 199 202 206 209 213 216 220
                                                                                  223 227 230 234 237 241 290 296 300 306
fm_area                  46            based           area                     level 2 dcl 2-40 set ref 188 192 195 199 202 206 209
                                                                                  213 216 220 223 227 230 234 237 241 290 296 300
                                                                                  306
fm_ptr                          000230 automatic       pointer                  dcl 2-108 set ref 188 192 195 199 202 206 209 213
                                                                                  216 220 223 227 230 234 237 241 290 296 300 306
                                                                                  338* 343* 346*
hbound                                                 builtin function         dcl 410 ref 95 109 268
hcs_$make_seg                   000026 constant        entry                    external dcl 425 ref 126 181
in_out                                 parameter       bit(1)                   unaligned dcl 398 set ref 390 395*
ioa_$rs                         000020 constant        entry                    external dcl 412 ref 360 371 382
lbound                                                 builtin function         dcl 410 ref 109 268
length                                 based           fixed bin(35,0)          level 2 dcl 3-216 set ref 280 286*
message                         000165 automatic       varying char(96)         dcl 413 set ref 360* 363 371* 374 382* 386
message_length                  000216 automatic       fixed bin(21,0)          dcl 414 set ref 360* 371* 382*
model_seg_path                         parameter       char                     unaligned dcl 421 set ref 32 89 247 325* 326 332*
model_seg_path_dir              000103 automatic       char(168)                unaligned dcl 407 set ref 126* 181* 325* 382*
model_seg_path_entry            000155 automatic       char(32)                 unaligned dcl 408 set ref 126* 181* 325* 341 382*
mrds_error_$rst_logic_error     000014 external static fixed bin(35,0)          dcl 405 set ref 363* 374*
mrds_rst_error                  000022 constant        entry                    external dcl 416 ref 326 363 374 386
mrds_rst_meter                  000016 constant        entry                    external dcl 411 ref 395
ncomp_init                      000233 automatic       fixed bin(17,0)          dcl 2-116 set ref 305* 306 306
ncomponents                            based           fixed bin(17,0)          level 2 packed unaligned dcl 2-112 set ref 300 306*
null                                                   builtin function         dcl 410 ref 77 262 337 338 343 347
parent_link_info                       based           structure                level 1 dcl 2-223 ref 202 206
path_entry                             based           structure                level 1 packed unaligned dcl 3-172 ref 147 151
rel_info                               based           structure                level 1 dcl 2-126 ref 188 192
rsc                                    based           structure                level 1 unaligned dcl 4-29
rsc_ptr                                parameter       pointer                  dcl 4-94 set ref 32 89 100 247 253 312 326* 363*
                                                                                  374* 386* 395*
seg_ptr                         000100 automatic       pointer                  dcl 404 set ref 332* 342 346
select_chain                           based           structure                level 1 dcl 2-357 ref 237 241
sort_key                               based           structure                level 1 dcl 2-346 ref 223 227
stack_item                             based           structure                level 1 unaligned dcl 3-206 ref 154 158
struct_ptr                             parameter       pointer                  dcl 418 set ref 32 77* 89 126* 133 137* 140 144* 147
                                                                                  151* 154 158* 161 165* 168 172* 181* 188 192* 195
                                                                                  199* 202 206* 209 213* 216 220* 223 227* 230 234*
                                                                                  237 241* 247 262* 280 286* 290 296* 300 306*
struct_size                            parameter       fixed bin(35,0)          dcl 420 set ref 247 270 285 295 305 371*
struct_type                            parameter       fixed bin(17,0)          dcl 419 set ref 32 89 95 109 109 117 247 268 268 278
                                                                                  360* 394
struct_type_picture             000276 automatic       picture(2)               unaligned dcl 399 set ref 394* 395
trace_sw                206(07)        based           bit(1)                   level 2 packed unaligned dcl 4-29 ref 100 253 312
version_status                         based           structure                level 1 packed unaligned dcl 3-232 ref 161 165

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ATD                                    internal static fixed bin(17,0)          initial dcl 1-63
ATTRIBUTE                              internal static fixed bin(17,0)          initial dcl 1-16
ATTRIBUTE_DOMAIN                       internal static fixed bin(17,0)          initial dcl 1-14
ATTR_INFO                              internal static fixed bin(17,0)          initial dcl 1-59
ATTR_LIST                              internal static fixed bin(17,0)          initial dcl 1-62
CHANGER                                internal static fixed bin(17,0)          initial dcl 1-52
CHILDREN                               internal static fixed bin(17,0)          initial dcl 1-21
CHILD_LINK_INFO                        internal static fixed bin(17,0)          initial dcl 1-61
COMP_NO_ARRAY                          internal static fixed bin(17,0)          initial dcl 1-64
CONSTANT                               internal static fixed bin(17,0)          initial dcl 1-50
CUR_LEX_TOP                            internal static fixed bin(17,0)          initial dcl 1-36
DB_MODEL                               internal static fixed bin(17,0)          initial dcl 1-45
DELETE_NAME                            internal static fixed bin(17,0)          initial dcl 1-23
DIRECTIVE                              internal static fixed bin(17,0)          initial dcl 1-28
DISPLAY_INFO                           internal static fixed bin(17,0)          initial dcl 1-82
DOMAIN                                 internal static fixed bin(17,0)          initial dcl 1-13
DOMAIN_INFO                            internal static fixed bin(17,0)          initial dcl 1-47
DOM_LIST                               internal static fixed bin(17,0)          initial dcl 1-24
DUP_PREV                               internal static fixed bin(17,0)          initial dcl 1-66
FILE                                   internal static fixed bin(17,0)          initial dcl 1-17
FILE_INFO                              internal static fixed bin(17,0)          initial dcl 1-46
FILE_MODEL                             internal static fixed bin(17,0)          initial dcl 1-57
FIXUP_TOKEN                            internal static fixed bin(17,0)          initial dcl 1-37
FOREIGN_KEY                            internal static fixed bin(17,0)          initial dcl 1-20
GL                                     internal static fixed bin(17,0)          initial dcl 1-72
INDEX                                  internal static fixed bin(17,0)          initial dcl 1-22
ITEM                                   internal static fixed bin(17,0)          initial dcl 1-18
LEX_STACK                              internal static fixed bin(17,0)          initial dcl 1-34
LINK                                   internal static fixed bin(17,0)          initial dcl 1-19
LIST_OVRLY                             internal static fixed bin(17,0)          initial dcl 1-75
NODE                                   internal static fixed bin(17,0)          initial dcl 1-77
OUTPUT_TEXT                            internal static fixed bin(17,0)          initial dcl 1-40
PARENT_LINK_INFO                       internal static fixed bin(17,0)          initial dcl 1-60
PATH_ENTRY                             internal static fixed bin(17,0)          initial dcl 1-48
P_STRUCT                               internal static fixed bin(17,0)          initial dcl 1-35
RELATION                               internal static fixed bin(17,0)          initial dcl 1-15
REL_INFO                               internal static fixed bin(17,0)          initial dcl 1-58
SAVED_CHILD_COUNT                      internal static fixed bin(17,0)          initial dcl 1-76
SEGINFO                                internal static fixed bin(17,0)          initial dcl 1-74
SELECT_CHAIN                           internal static fixed bin(17,0)          initial dcl 1-67
SL                                     internal static fixed bin(17,0)          initial dcl 1-73
SORT_KEY                               internal static fixed bin(17,0)          initial dcl 1-65
STACK_ITEM                             internal static fixed bin(17,0)          initial dcl 1-49
STMT                                   internal static fixed bin(17,0)          initial dcl 1-29
STRING_SOURCE                          internal static fixed bin(17,0)          initial dcl 1-38
TOKEN                                  internal static fixed bin(17,0)          initial dcl 1-39
VERSION_STATUS                         internal static fixed bin(17,0)          initial dcl 1-51
ai_ptr                                 automatic       pointer                  dcl 2-209
al_ptr                                 automatic       pointer                  dcl 2-345
atd_ptr                                automatic       pointer                  dcl 2-110
changer_ptr                            automatic       pointer                  dcl 3-256
cli_ptr                                automatic       pointer                  dcl 2-329
cna_ptr                                automatic       pointer                  dcl 2-115
constant_ptr                           automatic       pointer                  dcl 3-220
di_ptr                                 automatic       pointer                  dcl 3-155
dp_ptr                                 automatic       pointer                  dcl 2-356
fi_ptr                                 automatic       pointer                  dcl 3-119
fixed                                                  builtin function         dcl 410
message_str                            based           structure                level 1 packed unaligned dcl 3-259
message_str_len                        automatic       fixed bin(17,0)          dcl 3-269
message_str_ptr                        automatic       pointer                  dcl 3-267
path_entry_ptr                         automatic       pointer                  dcl 3-177
pli_ptr                                automatic       pointer                  dcl 2-268
rel                                                    builtin function         dcl 410
ri_ptr                                 automatic       pointer                  dcl 2-185
sc_ptr                                 automatic       pointer                  dcl 2-365
sk_ptr                                 automatic       pointer                  dcl 2-352
stack_item_ptr                         automatic       pointer                  dcl 3-212
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 409
ua_ptr                                 automatic       pointer                  dcl 3-165
unreferenced_attribute                 based           structure                level 1 dcl 3-159
version_status_ptr                     automatic       pointer                  dcl 3-246

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_struct_size                 001412 constant        entry                    internal dcl 367 ref 270
bad_struct_type                 001301 constant        entry                    internal dcl 356 ref 109 268
case                            000000 constant        label                    array(0:15) dcl 122 ref 95 109 109 117
common                          000262 constant        label                    dcl 100 ref 84 95
decode_model_seg_path           001130 constant        entry                    internal dcl 320 ref 105 266
mrds_rst_model_alloc            000171 constant        entry                    external dcl 32
mrds_rst_model_alloc$free       000235 constant        entry                    external dcl 89
mrds_rst_model_alloc$variable   000700 constant        entry                    external dcl 247
return_label                    001116 constant        label                    dcl 312 ref 78 131 138 145 152 159 166 173 186 193
                                                                                  200 207 214 221 228 235 242 263 288 298 308
trace                           001656 constant        entry                    internal dcl 390 ref 103 256 315
unable_to_make_segment          001523 constant        entry                    internal dcl 378 ref 129 184
var_case                        000020 constant        label                    array(30:32) dcl 280 ref 268 268 278
var_common                      000717 constant        label                    dcl 253 ref 97

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2124        2154    1740        2134
Length      2456    1740        30         265     164           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_rst_model_alloc                434 external procedure  is an external procedure.  
on unit on line 75                   64 on unit               
on unit on line 260                  64 on unit               
decode_model_seg_path                   internal procedure  shares stack frame of external procedure mrds_rst_model_alloc.  
bad_struct_type                         internal procedure  shares stack frame of external procedure mrds_rst_model_alloc.  
bad_struct_size                         internal procedure  shares stack frame of external procedure mrds_rst_model_alloc.  
unable_to_make_segment                  internal procedure  shares stack frame of external procedure mrds_rst_model_alloc.  
trace                                   internal procedure  shares stack frame of external procedure mrds_rst_model_alloc.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 alloc_length                mrds_rst_model_alloc

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_rst_model_alloc     000100 seg_ptr                     mrds_rst_model_alloc
                         000102 error_code                  mrds_rst_model_alloc
                         000103 model_seg_path_dir          mrds_rst_model_alloc
                         000155 model_seg_path_entry        mrds_rst_model_alloc
                         000165 message                     mrds_rst_model_alloc
                         000216 message_length              mrds_rst_model_alloc
                         000226 FREE                        mrds_rst_model_alloc
                         000230 fm_ptr                      mrds_rst_model_alloc
                         000232 atd_len                     mrds_rst_model_alloc
                         000233 ncomp_init                  mrds_rst_model_alloc
                         000234 dbm_ptr                     mrds_rst_model_alloc
                         000276 struct_type_picture         trace

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   return_mac          tra_ext_1           enable_op           shorten_stack
ext_entry_desc      int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cv_ptr_                       expand_pathname_              hcs_$make_seg                 ioa_$rs
mrds_rst_error                mrds_rst_meter

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mrds_error_$rst_logic_error




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     32 000164        75 000207        77 000223        78 000226        83 000231        84 000232        89 000233
     91 000253        95 000255        97 000261       100 000262       103 000271       105 000273       109 000274
    117 000303       122 000304       126 000307       128 000346       129 000351       131 000352       133 000353
    137 000360       138 000366       140 000367       144 000374       145 000402       147 000403       151 000410
    152 000416       154 000417       158 000424       159 000432       161 000433       165 000440       166 000446
    168 000447       172 000454       173 000462       177 000463       181 000466       183 000525       184 000530
    186 000531       188 000532       192 000537       193 000545       195 000546       199 000553       200 000561
    202 000562       206 000567       207 000575       209 000576       213 000603       214 000611       216 000612
    220 000617       221 000625       223 000626       227 000633       228 000641       230 000642       234 000647
    235 000655       237 000656       241 000663       242 000671       247 000672       251 000716       253 000717
    256 000726       260 000730       262 000744       263 000747       266 000752       268 000753       270 000763
    278 000770       280 000772       285 001004       286 001010       288 001025       290 001026       295 001036
    296 001041       298 001051       300 001052       305 001072       306 001075       308 001115       312 001116
    315 001125       318 001127       320 001130       325 001131       326 001160       331 001231       332 001232
    336 001255       337 001257       338 001261       339 001262       341 001263       342 001267       343 001271
    344 001273       346 001274       347 001276       354 001300       356 001301       360 001302       363 001350
    365 001410       367 001412       371 001413       374 001461       376 001521       378 001523       382 001524
    386 001614       388 001654       390 001656       394 001660       395 001672       401 001725


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
