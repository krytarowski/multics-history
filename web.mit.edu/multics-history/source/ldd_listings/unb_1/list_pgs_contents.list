	COMPILATION LISTING OF SEGMENT list_pgs_contents
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/18/82  1640.7 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 list_pgs_contents: lpc: proc;
       19 
       20 /* This command lists the symbols resident in a permanent graphic segment
       21*   (PGS).  Usage is explaned in the variable "explanation", which is printed
       22*   if called with no args.  The star convention is honored both for names of
       23*   PGS's and for symbols to be found.
       24*
       25*   Written 10/10/75 by C. D. Tavares.
       26*   Modified 02/08/80 by CDT to use lsm_ directly instead of using
       27*   graphic_manipulator and thereby wiping out the WGS. */
       28 
       29 
       30 /* AUTOMATIC */
       31 
       32 dcl  al fixed bin,
       33      ap pointer,
       34      arg_array (32) char (32),
       35      arg_satisfied (32) bit (1),
       36      code fixed bin (35),
       37      dname char (168),
       38      each_seg fixed bin,
       39      elements_used fixed bin,
       40      ename char (32),
       41      error_label label local,
       42      fake_array (1) fixed bin (18),
       43      i fixed bin,
       44      lsm_curl fixed bin,
       45      lsm_type fixed bin,
       46      nargs fixed bin;
       47 
       48 /* STATIC */
       49 
       50 dcl  sys_area_p pointer static initial (null);
       51 
       52 /* EXTERNAL STATIC */
       53 
       54 dcl  error_table_$too_many_args ext fixed bin (35) static,
       55      graphic_error_table_$inv_node_type ext fixed bin (35) static;
       56 
       57 /* CONSTANTS */
       58 
       59 dcl  explanation char (36) static initial ("Usage: lpc pgs_path {symbol_names}.");
       60 
       61 /* ENTRIES */
       62 
       63 dcl (com_err_, com_err_$suppress_name) ext entry options (variable),
       64      check_star_name_$entry ext entry (char (*), fixed bin (35)),
       65      cu_$arg_count ext entry (fixed bin),
       66      cu_$arg_ptr ext entry (fixed bin, pointer, fixed bin, fixed bin (35)),
       67      expand_path_ ext entry (pointer, fixed bin, pointer, pointer, fixed bin (35)),
       68      get_system_free_area_ ext entry returns (pointer),
       69      hcs_$star_ entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr, fixed bin (35)),
       70      hcs_$terminate_noname entry (ptr, fixed bin (35)),
       71      ioa_ ext entry options (variable),
       72      match_star_name_ ext entry (char (*), char (*), fixed bin (35)),
       73      sort_items_$char ext entry (pointer, fixed bin),
       74      suffixed_name_$make ext entry (char (*), char (*), char (32), fixed bin (35));
       75 
       76 /* BASED */
       77 
       78 dcl  arg based (ap) char (al),
       79      system_free_area area based (sys_area_p);
       80 
       81 /* BUILTINS AND CONDITIONS */
       82 
       83 dcl (addr, char, dim, length, null, sum) builtin;
       84 
       85 dcl  cleanup condition;
       86 
  1     1 /* --------------- BEGIN include file lsm_entry_dcls.incl.pl1 --------------- */
  1     2 
  1     3 dcl  lsm_$get_blk entry (ptr, fixed bin (18), fixed bin, fixed bin, ptr, fixed bin (35)),
  1     4      lsm_$make_blk entry (ptr, fixed bin (18), fixed bin, fixed bin, ptr, fixed bin (35)),
  1     5      lsm_$mk_char entry (ptr, char (*), fixed bin (18)),
  1     6      lsm_$replace_blk entry (ptr, fixed bin (18), fixed bin (18), fixed bin (35)),
  1     7      lsm_$replicate entry (ptr, fixed bin (18), fixed bin (18), fixed bin (35)),
  1     8      lsm_$set_blk entry (ptr, fixed bin (18), fixed bin, fixed bin, ptr, fixed bin (35));
  1     9 
  1    10 dcl  lsm_fs_$compact entry (ptr, fixed bin (18), fixed bin (35)),
  1    11      lsm_fs_$free entry (ptr, fixed bin (35)),
  1    12      lsm_fs_$init entry (ptr, fixed bin (35)),
  1    13      lsm_fs_$init_seg entry (ptr, char (*), char (*), fixed bin, fixed bin (35)),
  1    14      lsm_fs_$merge_symbol entry (ptr, ptr, fixed bin (18), bit (1), fixed bin, fixed bin (35)),
  1    15      lsm_fs_$move_struc entry (ptr, ptr, fixed bin (18), fixed bin (18), fixed bin (35)),
  1    16      lsm_fs_$pull entry (ptr, char (*), char (*), fixed bin (35)),
  1    17      lsm_fs_$push entry (ptr, char (*), char (*), fixed bin (35));
  1    18 
  1    19 dcl  lsm_sym_$find_table entry (pointer, fixed bin (18), fixed bin (35)),
  1    20      lsm_sym_$sym_list entry (ptr, (*) fixed bin (18), fixed bin, fixed bin (35)),
  1    21      lsm_sym_$symk entry (ptr, fixed bin, char (*), fixed bin (18), fixed bin (18), fixed bin (35)),
  1    22      lsm_sym_$symn entry (ptr, fixed bin, fixed bin (18), fixed bin (18), fixed bin (18), fixed bin (35));
  1    23 
  1    24 dcl (Find_symbol initial (0),				/* op codes for lsm_sym_$symk and lsm_sym_$symn */
  1    25      Find_or_create_symbol initial (1),
  1    26      Create_symbol initial (2),
  1    27      Delete_symbol initial (3)) fixed bin static options (constant);
  1    28 
  1    29 dcl (Find_seg initial (0),				/* Opcodes for lsm_fs_$init_seg */
  1    30      Create_seg initial (1),
  1    31      Clear_seg initial (2)) fixed bin static options (constant);
  1    32 
  1    33 /* ---------------- END include file lsm_entry_dcls.incl.pl1 ---------------- */
       87 
       88 
  2     1 /* Begin include file . . . lsm_node_types.incl.pl1 */
  2     2 
  2     3 /* Integer types corresponding to different lsm_ node times */
  2     4 
  2     5 dcl (indirect_type init (1),				/* internal to lsm_; used for forwarding references */
  2     6 						/* to a node whose storage space has increased */
  2     7      fixed_type init (2),				/* array of fixed bin (35) aligned values */
  2     8      float_type init (3),				/* array of float bin (27) aligned values */
  2     9      bit_type init (4),				/* bit string */
  2    10      char_type init (5),				/* character string */
  2    11      symtab_type init (6),				/* symbol table */
  2    12      symbol_type init (7),				/* symbol (name node + value node) */
  2    13      list_type init (8),				/* non-terminal list type */
  2    14      array_type init (9),				/* terminal array (like list) */
  2    15      type_max init (9))				/* maximum legal node type code */
  2    16      fixed bin (4) internal static;
  2    17 
  2    18 /* End include file . . . lsm_node_types.incl.pl1 */
       89 
       90 
  3     1 /* Begin include file . . . lsm_formats.incl.pl1 */
  3     2 
  3     3 /* CONSTANTS */
  3     4 
  3     5 dcl (LSM_version_7 initial (7),			/* current version, root is always symtab */
  3     6      LSM_version_6 initial (6))			/* root wasn't automatically symtab */
  3     7      fixed bin static options (constant);
  3     8 
  3     9 dcl 1 lsm_constants aligned static options (constant),
  3    10     2 n_types fixed bin initial (9),
  3    11     2 types,
  3    12       3 indirect_type initial (1),
  3    13       3 fixed_type initial (2),
  3    14       3 float_type initial (3),
  3    15       3 bit_type initial (4),
  3    16       3 char_type initial (5),
  3    17       3 symtab_type initial (6),
  3    18       3 symbol_type initial (7),
  3    19       3 list_type initial (8),
  3    20       3 array_type initial (9),
  3    21     2 data_length_factors (9) initial (1, 1, 1, 36, 4, 1, 1, 1, 1),
  3    22     2 max_allocation fixed bin initial (4095),
  3    23     2 initial_component_slots fixed bin initial (8);
  3    24 
  3    25 dcl  lsm_segptr pointer;
  3    26 
  3    27 dcl 1 lsm aligned based (lsm_segptr),			/* declaration of head of lsm_ segment */
  3    28     2 version fixed bin,				/* number of lsm_ version that created this seg */
  3    29     2 free fixed bin (18),				/* word number of first free word in seg */
  3    30     2 root_symtab fixed bin (18),			/* node number of the root symbol table */
  3    31     2 lock bit (36) aligned,
  3    32     2 component_slots fixed bin,
  3    33     2 components fixed bin,
  3    34     2 pad (26) fixed bin (18),
  3    35     2 component_ptrs (lsm_constants.initial_component_slots refer (lsm.component_slots)) pointer unaligned;
  3    36 
  3    37 
  3    38 /* Formats of different node types used by lsm_ */
  3    39 
  3    40 dcl  node_ptr pointer;
  3    41 
  3    42 dcl 1 header aligned based (node_ptr),			/* Used in all formats below */
  3    43     2 type fixed bin (6) unsigned unaligned,		/* type of node */
  3    44     2 allocated_len fixed bin (12) unsigned unaligned,	/* allocated length of data space */
  3    45     2 data_len fixed bin (18) unsigned unaligned;		/* current length of data in block */
  3    46 						/* (in appropriate units) */
  3    47 
  3    48 dcl 1 any_node aligned based (node_ptr),		/* general node description */
  3    49     2 header like header aligned,
  3    50     2 data_space (0 refer (any_node.allocated_len)) bit (36) aligned;
  3    51 
  3    52 dcl 1 indirect_node aligned based (node_ptr),		/* internal to lsm_ */
  3    53     2 header like header,
  3    54     2 new_node fixed bin (18);			/* numberof reallocated node */
  3    55 
  3    56 dcl 1 fixed_node aligned based (node_ptr),		/* array of fixed bin (35) */
  3    57     2 header like header,
  3    58     2 element (0 refer (fixed_node.data_len)) fixed bin (35); /* array of values */
  3    59 
  3    60 dcl 1 float_node aligned based (node_ptr),		/* array of float binary (27) */
  3    61     2 header like header,
  3    62     2 element (0 refer (float_node.data_len)) float bin (27);
  3    63 
  3    64 dcl 1 bit_node aligned based (node_ptr),		/* string of bits */
  3    65     2 header like header,
  3    66     2 string bit (0 refer (bit_node.data_len));		/* bit string of max length */
  3    67 
  3    68 dcl 1 char_node aligned based (node_ptr),		/* string of characters */
  3    69     2 header like header,
  3    70     2 string char (0 refer (char_node.data_len)) unaligned; /* character string of max length */
  3    71 
  3    72 dcl 1 symtab_node aligned based (node_ptr),		/* symbol table node */
  3    73     2 header like header,
  3    74     2 bucket_root (0 : 1 refer (symtab_node.data_len)) fixed bin (18);
  3    75 						/* actually, it is (0 : data_len - 1), but there's no way to do */
  3    76 						/* this with a refer option, and it's invalid not to use refer */
  3    77 
  3    78 dcl 1 symbol_node aligned based (node_ptr),		/* symbol node */
  3    79     2 header like header,
  3    80     2 name_node fixed bin (18),			/* number of character string node containing symbol name */
  3    81     2 value_node fixed bin (18),			/* number of node that is the "value" of this symbol */
  3    82     2 next_node fixed bin (18);			/* number of next symbol node in this bucket chain */
  3    83 						/* =0 if this is last node o chain */
  3    84 
  3    85 dcl 1 list_node aligned based (node_ptr),		/* non-terminal list node */
  3    86     2 header like header,
  3    87     2 node (0 refer (list_node.data_len)) fixed bin (18);	/* numbers of nodes comprising this list */
  3    88 
  3    89 dcl 1 array_node aligned based (node_ptr),		/* non-terminal list with terminal properties */
  3    90     2 header like header,
  3    91     2 node (0 refer (array_node.data_len)) fixed bin (18);	/* numbers of nodes comprising this array */
  3    92 
  3    93 
  3    94 /* End include file . . . lsm_formats.incl.pl1 */
       91 
       92 
  4     1 /* BEGIN INCLUDE FILE . . . star_structures.incl.pl1 */
  4     2 
  4     3 /* This include file contains structures for the hcs_$star_,
  4     4*   hcs_$star_list_ and hcs_$star_dir_list_ entry points.
  4     5*
  4     6*   Written 23 October 1978 by Monte Davidoff.
  4     7*   Modified January 1979 by Michael R. Jordan to use unsigned and different pointers for different structures.
  4     8*   Modified June 1981 by C. Hornig to count link pathnames more efficiently.
  4     9**/
  4    10 
  4    11 /* automatic */
  4    12 
  4    13 declare  star_branch_count fixed binary;		/* hcs_$star_list_, hcs_$star_dir_list_: matching branch count */
  4    14 declare  star_entry_count fixed binary;			/* hcs_$star_: number of matching entries */
  4    15 declare  star_entry_ptr pointer;			/* hcs_$star_: pointer to array of entry information */
  4    16 declare  star_list_branch_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to array of info */
  4    17 declare  star_link_count fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: matching link count */
  4    18 declare  star_linkx fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: index into star_links */
  4    19 declare  star_names_ptr pointer;			/* hcs_$star_: pointer to array of entry names */
  4    20 declare  star_list_names_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to entry names */
  4    21 declare  star_select_sw fixed binary (3);		/* hcs_$star_list_, hcs_$star_dir_list_: what info to return */
  4    22 
  4    23 /* based */
  4    24 
  4    25 /* hcs_$star_ entry structure */
  4    26 
  4    27 declare 1 star_entries (star_entry_count) aligned based (star_entry_ptr),
  4    28         2 type fixed binary (2) unsigned unaligned,
  4    29 						/* storage system type */
  4    30         2 nnames fixed binary (16) unsigned unaligned,
  4    31 						/* number of names of entry that match star_name */
  4    32         2 nindex fixed binary (18) unsigned unaligned;
  4    33 						/* index of first name in star_names */
  4    34 
  4    35 /* hcs_$star_ name structure */
  4    36 
  4    37 declare  star_names (sum (star_entries (*).nnames)) char (32) based (star_names_ptr);
  4    38 
  4    39 /* hcs_$star_list_ branch structure */
  4    40 
  4    41 declare 1 star_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  4    42         2 type fixed binary (2) unsigned unaligned,
  4    43 						/* storage system type */
  4    44         2 nnames fixed binary (16) unsigned unaligned,
  4    45 						/* number of names of entry that match star_name */
  4    46         2 nindex fixed binary (18) unsigned unaligned,
  4    47 						/* index of first name in star_list_names */
  4    48         2 dtcm bit (36) unaligned,			/* date-time contents of branch were last modified */
  4    49         2 dtu bit (36) unaligned,			/* date-time branch was last used */
  4    50         2 mode bit (5) unaligned,			/* user's access mode to the branch */
  4    51         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
  4    52         2 master_dir bit (1) unaligned,			/* is branch a master directory */
  4    53         2 pad bit (7) unaligned,
  4    54         2 records fixed binary (18) unsigned unaligned;
  4    55 						/* records used by branch */
  4    56 
  4    57 /* hcs_$star_dir_list_ branch structure */
  4    58 
  4    59 declare 1 star_dir_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  4    60         2 type fixed binary (2) unsigned unaligned,
  4    61 						/* storage system type */
  4    62         2 nnames fixed binary (16) unsigned unaligned,
  4    63 						/* number of names of entry that match star_name */
  4    64         2 nindex fixed binary (18) unsigned unaligned,
  4    65 						/* index of first name in star_list_names */
  4    66         2 dtem bit (36) unaligned,			/* date-time directory entry of branch was last modified */
  4    67         2 pad bit (36) unaligned,
  4    68         2 mode bit (5) unaligned,			/* user's access mode to the branch */
  4    69         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
  4    70         2 master_dir bit (1) unaligned,			/* is branch a master directory */
  4    71         2 bit_count fixed binary (24) unaligned;
  4    72 						/* bit count of the branch */
  4    73 
  4    74 /* hcs_$star_list_ and hcs_$star_dir_list_ link structure */
  4    75 
  4    76 declare 1 star_links (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  4    77         2 type fixed binary (2) unsigned unaligned,
  4    78 						/* storage system type */
  4    79         2 nnames fixed binary (16) unsigned unaligned,
  4    80 						/* number of names of entry that match star_name */
  4    81         2 nindex fixed binary (18) unsigned unaligned,
  4    82 						/* index of first name in star_list_names */
  4    83         2 dtem bit (36) unaligned,			/* date-time link was last modified */
  4    84         2 dtd bit (36) unaligned,			/* date-time the link was last dumped */
  4    85         2 pathname_len fixed binary (18) unsigned unaligned,
  4    86 						/* length of the pathname of the link */
  4    87         2 pathname_index fixed binary (18) unsigned unaligned;
  4    88 						/* index of start of pathname in star_list_names */
  4    89 
  4    90 /* hcs_$star_list_ and hcs_$star_dir_list_ name array */
  4    91 
  4    92 declare  star_list_names char (32) based (star_list_names_ptr)
  4    93 	dimension (star_links (star_branch_count + star_link_count).nindex
  4    94 	 + star_links (star_branch_count + star_link_count).nnames
  4    95 	 + divide (star_links (star_branch_count + star_link_count).pathname_len + 31, 32, 17, 0)
  4    96 	   * binary (
  4    97 	     (star_links (star_branch_count + star_link_count).type = star_LINK)
  4    98 	     & (star_select_sw >= star_LINKS_ONLY_WITH_LINK_PATHS), 1));
  4    99 
  4   100 /* hcs_$star_list_ and hcs_$star_dir_list_ link pathname */
  4   101 
  4   102 declare  star_link_pathname char (star_links (star_linkx).pathname_len)
  4   103          based (addr (star_list_names (star_links (star_linkx).pathname_index)));
  4   104 
  4   105 /* internal static */
  4   106 
  4   107 /* star_select_sw values */
  4   108 
  4   109 declare  star_LINKS_ONLY fixed binary (2) internal static options (constant) initial (1);
  4   110 declare  star_BRANCHES_ONLY fixed binary (2) internal static options (constant) initial (2);
  4   111 declare  star_ALL_ENTRIES fixed binary (2) internal static options (constant) initial (3);
  4   112 declare  star_LINKS_ONLY_WITH_LINK_PATHS
  4   113          fixed binary (3) internal static options (constant) initial (5);
  4   114 declare  star_ALL_ENTRIES_WITH_LINK_PATHS
  4   115          fixed binary (3) internal static options (constant) initial (7);
  4   116 
  4   117 /* storage system types */
  4   118 
  4   119 declare  star_LINK fixed binary (2) unsigned internal static options (constant) initial (0);
  4   120 declare  star_SEGMENT fixed binary (2) unsigned internal static options (constant) initial (1);
  4   121 declare  star_DIRECTORY fixed binary (2) unsigned internal static options (constant) initial (2);
  4   122 
  4   123 /* END INCLUDE FILE . . . star_structures.incl.pl1 */
       93 
       94 
       95 	error_label = returner;			/* tell "crump" to abort whole command if we fail now */
       96 
       97 	call cu_$arg_ptr (1, ap, al, code);		/* get name of PGS to be inspected */
       98 	if code ^= 0 then call crump (code, explanation); /* tell them how things are */
       99 
      100 	call expand_path_ (ap, al, addr (dname), addr (ename), code);
      101 	if code ^= 0 then call crump (code, arg);
      102 
      103 	call suffixed_name_$make ((ename), "pgs", ename, code); /* make sure suffix "pgs" is included */
      104 	if code ^= 0 then call crump (code, ename);
      105 
      106 	call cu_$arg_count (nargs);			/* see if any other args */
      107 	nargs = nargs - 1;				/* from now on, we use nargs only to count symbol args */
      108 
      109 	if nargs = 0 then do;			/* no specific symbols wanted; list everything */
      110 	     nargs = 1;
      111 	     arg_array (1) = "**";
      112 	end;
      113 
      114 	else do;					/* wants only certain symbols listed */
      115 	     if nargs > dim (arg_array, 1)
      116 	     then call crump (error_table_$too_many_args, "Max symbol names = " || char (dim (arg_array, 1)));
      117 						/* too many args, can't handle. */
      118 
      119 	     do i = 1 to nargs;			/* collect as many as we can handle */
      120 		call cu_$arg_ptr (i+1, ap, al, code);	/* get one symbol specification */
      121 		call check_star_name_$entry (arg, code); /* is it an OK entry/star name? */
      122 		if code > 3 then call crump (code, arg);
      123 		arg_array (i) = arg;		/* remember it */
      124 	     end;
      125 	end;
      126 
      127 
      128 	call check_star_name_$entry (ename, code);	/* was the PGS name a starname? */
      129 	if code > 3 then call crump (code, ename);	/* yes, and an illegal one too. */
      130 
      131 	if code = 0				/* not a star name */
      132 	then call process_pgs (ename);		/* process one and quit */
      133 
      134 	else do;					/* contains stars */
      135 
      136 	     if sys_area_p = null ()			/* get an area for hcs_$star */
      137 	     then sys_area_p = get_system_free_area_ ();
      138 
      139 	     call hcs_$star_ (dname, ename, star_BRANCHES_ONLY, sys_area_p, star_entry_count, star_entry_ptr, star_names_ptr, code);
      140 						/* see how many PGS's match starname */
      141 	     if code ^= 0 then call crump (code, ename);
      142 
      143 	     error_label = end_of_star_loop;		/* say on bomb-out, continue with next PGS */
      144 
      145 	     do each_seg = 1 to star_entry_count;	/* do once for each match */
      146 
      147 		call process_pgs (star_names (star_entries (each_seg).nindex)); /* process that one */
      148 
      149 end_of_star_loop:
      150 	     end;
      151 
      152 	     free star_names in (system_free_area), star_entries in (system_free_area);
      153 						/* clean up after ourselves */
      154 
      155 	end;
      156 
      157 returner:	return;
      158 
      159 process_pgs: proc (ename);				/* does the job for one PGS */
      160 
      161 dcl  ename char (32);
      162 
      163 dcl  segptr pointer;
      164 
      165 	     segptr = null;
      166 
      167 	     on cleanup call hcs_$terminate_noname (segptr, 0);
      168 
      169 	     call lsm_fs_$init_seg (segptr, dname, ename, Find_seg, code);
      170 	     if code ^= 0 then call crump (code, "^a>^a.");
      171 
      172 	     call lsm_sym_$sym_list (segptr, fake_array, elements_used, 0);
      173 						/* just to see how many symbols there are */
      174 	     if elements_used = 0 then		/* don't waste time */
      175 		call com_err_$suppress_name (0, "list_pgs_contents", "Symbol table is empty.^/");
      176 
      177 	     else begin;				/* allocates sufficient storage for arrays */
      178 
      179 dcl  node_array (elements_used) fixed bin (18);
      180 
      181 dcl 1 symbol_info (elements_used) aligned,		/* this holds our info; will be sorted */
      182     2 name_array char (64),				/* name of each symbol */
      183     2 prefix char (8);				/* "(null)" if the symbol is an empty symbol */
      184 
      185 dcl 1 based_symbol_info like symbol_info aligned based;	/* template for one symbol */
      186 
      187 dcl  name char (64),
      188      value fixed bin (18);
      189 
      190 dcl 1 sort_structure aligned,				/* as desired by sort_items_$char */
      191     2 useful_elements fixed bin (24),
      192     2 sort_ptrs (elements_used) pointer unaligned;
      193 
      194 dcl (i, j) fixed bin,
      195      found bit (1) aligned;
      196 
      197 		call lsm_sym_$sym_list (segptr, node_array, elements_used, code);
      198 						/* This time, do it in earnest, for the info. */
      199 		if code ^= 0			/* really unexpected */
      200 		then call crump (code, "Error while examining symbol table: num_syms = " || char (elements_used));
      201 
      202 		call ioa_ ("^/^2-^a>^a^/", dname, ename); /* print out heading identifying PGS */
      203 
      204 		do i = 1 to nargs;
      205 		     arg_satisfied (i) = ""b;		/* say this starname hasn't been matched yet */
      206 		end;
      207 
      208 		useful_elements = 0;		/* count of how many satisfy starname */
      209 
      210 		do i = 1 to elements_used;		/* loop thru elements matching starnames */
      211 
      212 		     call lsm_$get_blk (segptr, node_array (i), lsm_type, lsm_curl, node_ptr, code);
      213 		     if code = 0 then
      214 			if lsm_type ^= symbol_type then
      215 			     code = graphic_error_table_$inv_node_type;
      216 		     if code ^= 0 then do;		/* also greatly unexpected */
      217 			name = "";
      218 			call com_err_ (code, "list_pgs_contents", "Examining node ^o", node_array (i));
      219 		     end;
      220 
      221 		     else do;
      222 			value = node_ptr -> symbol_node.value_node;
      223 
      224 			call lsm_$get_blk (segptr, (node_ptr -> symbol_node.name_node), 0, 0, node_ptr, code);
      225 			name = node_ptr -> char_node.string;
      226 		     end;
      227 
      228 		     found = ""b;
      229 
      230 
      231 		     do j = 1 to nargs;		/* check against ALL starnames given */
      232 
      233 /* we don't stop matching when a match is found, because we are keeping track
      234*   of which starnames have never had a match, so that we can put out error
      235*   messages later about them.  Some symbols may satisfy more than one
      236*   starname, or the user could have typed the same starname twice.  We try
      237*   every entryname against every starname so that we know which starnames were
      238*   never really matched.  */
      239 
      240 			code = 0;
      241 			if arg_array (j) ^= "**" then
      242 			     call match_star_name_ (name, arg_array (j), code);
      243 			if code = 0 then do;	/* it matches! */
      244 			     arg_satisfied (j) = "1"b; /* say this arg has had at least one match */
      245 			     if ^found then do;	/* only put symbolname into sort list once */
      246 				found = "1"b;
      247 				useful_elements = useful_elements + 1; /* remember it in sorting structure */
      248 				symbol_info.name_array (useful_elements) = name;
      249 				if value = 0 then symbol_info.prefix (useful_elements) = "(null)  ";
      250 						/* symbol is an empty symbol */
      251 				else symbol_info.prefix (useful_elements) = "";
      252 
      253 				sort_ptrs (useful_elements) = addr (symbol_info.name_array (useful_elements));
      254 						/* this way, we only sort the ones we care about */
      255 			     end;
      256 			end;
      257 		     end;
      258 		end;
      259 
      260 		call hcs_$terminate_noname (segptr, 0); /* clean up */
      261 
      262 		if useful_elements = 0 then do;	/* nothing matched the starnames */
      263 		     call com_err_$suppress_name (0, "list_pgs_contents", "No symbols selected.^/");
      264 		     return;
      265 		end;
      266 
      267 		found = ""b;			/* no unmatched args have been found and printed yet */
      268 
      269 		do i = 1 to nargs;
      270 		     if ^arg_satisfied (i) then do;
      271 			call com_err_$suppress_name (0, "list_pgs_contents", """^a"" not found.", arg_array (i));
      272 						/* print out the args which were never matched */
      273 			found = "1"b;		/* say we found one */
      274 		     end;
      275 		end;
      276 
      277 		if found then call com_err_$suppress_name (0, "list_pgs_contents", "	"); /* keep format neat */
      278 
      279 		call ioa_ ("^d symbol^[s^;^]:^/", useful_elements, (useful_elements > 1)); /* say how many */
      280 
      281 		call sort_items_$char (addr (sort_structure), length (symbol_info.name_array (1)));
      282 						/* sort the names that matched */
      283 
      284 		do i = 1 to useful_elements;		/* now output the sorted names */
      285 		     call ioa_ ("^10a^a", sort_ptrs (i) -> based_symbol_info.prefix,
      286 			sort_ptrs (i) -> based_symbol_info.name_array);
      287 		end;
      288 	     end;
      289 
      290 	     call ioa_ ("");			/* be suave */
      291 	     return;
      292 
      293 	end process_pgs;
      294 	
      295 crump:	proc (code, reason);			/* the screamer */
      296 
      297 dcl  code fixed bin (35),
      298      reason char (*);
      299 
      300 	     call com_err_ (code, "list_pgs_contents", reason, dname, ename);
      301 						/* explain the problem to the user */
      302 	     goto error_label;			/* either abort whole command or resume with next PGS */
      303 	end;
      304 
      305      end list_pgs_contents;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/18/82  1625.5  list_pgs_contents.pl1             >dumps>old>recomp>list_pgs_contents.pl1
87           1    03/27/82  0439.3  lsm_entry_dcls.incl.pl1           >ldd>include>lsm_entry_dcls.incl.pl1
89           2    08/27/75  1700.7  lsm_node_types.incl.pl1           >ldd>include>lsm_node_types.incl.pl1
91           3    12/17/79  1708.9  lsm_formats.incl.pl1              >ldd>include>lsm_formats.incl.pl1
93           4    06/10/82  1045.5  star_structures.incl.pl1          >ldd>include>star_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Find_seg                        000050 constant        fixed bin(17,0)          initial dcl 1-29 set ref 169*
addr                                                   builtin function         dcl 83 ref 100 100 100 100 253 281 281
al                              000100 automatic       fixed bin(17,0)          dcl 32 set ref 97* 100* 101 101 120* 121 121 122 122
                                                                                  123
ap                              000102 automatic       pointer                  dcl 32 set ref 97* 100* 101 120* 121 122 123
arg                                    based           char                     unaligned dcl 78 set ref 101* 121* 122* 123
arg_array                       000104 automatic       char(32)                 array unaligned dcl 32 set ref 111* 115 115 123* 241
                                                                                  241* 271*
arg_satisfied                   000504 automatic       bit(1)                   array unaligned dcl 32 set ref 205* 244* 270
based_symbol_info                      based           structure                level 1 dcl 185
char                                                   builtin function         dcl 83 ref 115 199
char_node                              based           structure                level 1 dcl 3-68
check_star_name_$entry          000034 constant        entry                    external dcl 63 ref 121 128
cleanup                         000000 stack reference condition                dcl 85 ref 167
code                                   parameter       fixed bin(35,0)          dcl 297 in procedure "crump" set ref 295 300*
code                            000505 automatic       fixed bin(35,0)          dcl 32 in procedure "lpc" set ref 97* 98 98* 100*
                                                                                  101 101* 103* 104 104* 120* 121* 122 122* 128* 129
                                                                                  129* 131 139* 141 141* 169* 170 170* 197* 199 199*
                                                                                  212* 213 213* 216 218* 224* 240* 241* 243
com_err_                        000030 constant        entry                    external dcl 63 ref 218 300
com_err_$suppress_name          000032 constant        entry                    external dcl 63 ref 174 263 271 277
cu_$arg_count                   000036 constant        entry                    external dcl 63 ref 106
cu_$arg_ptr                     000040 constant        entry                    external dcl 63 ref 97 120
data_len                  0(18)        based           fixed bin(18,0)          level 3 packed unsigned unaligned dcl 3-68 ref 225
dim                                                    builtin function         dcl 83 ref 115 115
dname                           000506 automatic       char(168)                unaligned dcl 32 set ref 100 100 139* 169* 202* 300*
each_seg                        000560 automatic       fixed bin(17,0)          dcl 32 set ref 145* 147*
elements_used                   000561 automatic       fixed bin(17,0)          dcl 32 set ref 172* 174 179 181 190 197* 199 210
ename                           000562 automatic       char(32)                 unaligned dcl 32 in procedure "lpc" set ref 100 100
                                                                                  103 103* 104* 128* 129* 131* 139* 141* 300*
ename                                  parameter       char(32)                 unaligned dcl 161 in procedure "process_pgs" set ref
                                                                                  159 169* 202*
error_label                     000572 automatic       label variable           local dcl 32 set ref 95* 143* 302
error_table_$too_many_args      000024 external static fixed bin(35,0)          dcl 54 set ref 115*
expand_path_                    000042 constant        entry                    external dcl 63 ref 100
explanation                     000012 internal static char(36)                 initial unaligned dcl 59 set ref 98*
fake_array                      000576 automatic       fixed bin(18,0)          array dcl 32 set ref 172*
found                           000123 automatic       bit(1)                   dcl 194 set ref 228* 245 246* 267* 273* 277
get_system_free_area_           000044 constant        entry                    external dcl 63 ref 136
graphic_error_table_$inv_node_type
                                000026 external static fixed bin(35,0)          dcl 54 ref 213
hcs_$star_                      000046 constant        entry                    external dcl 63 ref 139
hcs_$terminate_noname           000050 constant        entry                    external dcl 63 ref 167 260
header                                 based           structure                level 1 dcl 3-42 in procedure "lpc"
header                                 based           structure                level 2 in structure "char_node" dcl 3-68
                                                                                  in procedure "lpc"
i                               000577 automatic       fixed bin(17,0)          dcl 32 in procedure "lpc" set ref 119* 120 123*
i                               000121 automatic       fixed bin(17,0)          dcl 194 in begin block on line 177 set ref 204* 205*
                                                                                  210* 212 218* 269* 270 271* 284* 285 285*
ioa_                            000052 constant        entry                    external dcl 63 ref 202 279 285 290
j                               000122 automatic       fixed bin(17,0)          dcl 194 set ref 231* 241 241 244*
length                                                 builtin function         dcl 83 ref 281 281
lsm_$get_blk                    000062 constant        entry                    external dcl 1-3 ref 212 224
lsm_curl                        000600 automatic       fixed bin(17,0)          dcl 32 set ref 212*
lsm_fs_$init_seg                000064 constant        entry                    external dcl 1-10 ref 169
lsm_sym_$sym_list               000066 constant        entry                    external dcl 1-19 ref 172 197
lsm_type                        000601 automatic       fixed bin(17,0)          dcl 32 set ref 212* 213
match_star_name_                000054 constant        entry                    external dcl 63 ref 241
name                            000100 automatic       char(64)                 unaligned dcl 187 set ref 217* 225* 241* 248
name_array                      000100 automatic       char(64)                 array level 2 in structure "symbol_info" dcl 181
                                                                                  in begin block on line 177 set ref 248* 253 281
                                                                                  281
name_array                             based           char(64)                 level 2 in structure "based_symbol_info" dcl 185
                                                                                  in begin block on line 177 set ref 285*
name_node                 1            based           fixed bin(18,0)          level 2 dcl 3-78 ref 224
nargs                           000602 automatic       fixed bin(17,0)          dcl 32 set ref 106* 107* 107 109 110* 115 119 204
                                                                                  231 269
nindex                    0(18)        based           fixed bin(18,0)          array level 2 packed unsigned unaligned dcl 4-27 ref
                                                                                  147
nnames                    0(02)        based           fixed bin(16,0)          array level 2 packed unsigned unaligned dcl 4-27 ref
                                                                                  152
node_array                      000100 automatic       fixed bin(18,0)          array dcl 179 set ref 197* 212* 218*
node_ptr                        000604 automatic       pointer                  dcl 3-40 set ref 212* 222 224 224* 225
null                                                   builtin function         dcl 83 ref 136 165
prefix                   20     000100 automatic       char(8)                  array level 2 in structure "symbol_info" dcl 181
                                                                                  in begin block on line 177 set ref 249* 251*
prefix                   20            based           char(8)                  level 2 in structure "based_symbol_info" dcl 185
                                                                                  in begin block on line 177 set ref 285*
reason                                 parameter       char                     unaligned dcl 297 set ref 295 300*
segptr                          000100 automatic       pointer                  dcl 163 set ref 165* 167* 169* 172* 197* 212* 224*
                                                                                  260*
sort_items_$char                000056 constant        entry                    external dcl 63 ref 281
sort_ptrs                 1     000121 automatic       pointer                  array level 2 packed unaligned dcl 190 set ref 253*
                                                                                  285 285
sort_structure                  000121 automatic       structure                level 1 dcl 190 set ref 281 281
star_BRANCHES_ONLY              000001 constant        fixed bin(2,0)           initial dcl 4-110 set ref 139*
star_entries                           based           structure                array level 1 dcl 4-27 ref 152
star_entry_count                000606 automatic       fixed bin(17,0)          dcl 4-14 set ref 139* 145 152 152
star_entry_ptr                  000610 automatic       pointer                  dcl 4-15 set ref 139* 147 152 152
star_names                             based           char(32)                 array unaligned dcl 4-37 set ref 147* 152
star_names_ptr                  000612 automatic       pointer                  dcl 4-19 set ref 139* 147 152
string                    1            based           char                     level 2 packed unaligned dcl 3-68 ref 225
suffixed_name_$make             000060 constant        entry                    external dcl 63 ref 103
sum                                                    builtin function         dcl 83 ref 152
symbol_info                     000100 automatic       structure                array level 1 dcl 181
symbol_node                            based           structure                level 1 dcl 3-78
symbol_type                            constant        fixed bin(4,0)           initial dcl 2-5 ref 213
sys_area_p                      000010 internal static pointer                  initial dcl 50 set ref 136 136* 139* 152 152
system_free_area                       based           area(1024)               dcl 78 ref 152 152
useful_elements                 000121 automatic       fixed bin(24,0)          level 2 dcl 190 set ref 208* 247* 247 248 249 251
                                                                                  253 253 262 279* 279 284
value                           000120 automatic       fixed bin(18,0)          dcl 187 set ref 222* 249
value_node                2            based           fixed bin(18,0)          level 2 dcl 3-78 ref 222

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Clear_seg                              internal static fixed bin(17,0)          initial dcl 1-29
Create_seg                             internal static fixed bin(17,0)          initial dcl 1-29
Create_symbol                          internal static fixed bin(17,0)          initial dcl 1-24
Delete_symbol                          internal static fixed bin(17,0)          initial dcl 1-24
Find_or_create_symbol                  internal static fixed bin(17,0)          initial dcl 1-24
Find_symbol                            internal static fixed bin(17,0)          initial dcl 1-24
LSM_version_6                          internal static fixed bin(17,0)          initial dcl 3-5
LSM_version_7                          internal static fixed bin(17,0)          initial dcl 3-5
any_node                               based           structure                level 1 dcl 3-48
array_node                             based           structure                level 1 dcl 3-89
array_type                             internal static fixed bin(4,0)           initial dcl 2-5
bit_node                               based           structure                level 1 dcl 3-64
bit_type                               internal static fixed bin(4,0)           initial dcl 2-5
char_type                              internal static fixed bin(4,0)           initial dcl 2-5
fixed_node                             based           structure                level 1 dcl 3-56
fixed_type                             internal static fixed bin(4,0)           initial dcl 2-5
float_node                             based           structure                level 1 dcl 3-60
float_type                             internal static fixed bin(4,0)           initial dcl 2-5
indirect_node                          based           structure                level 1 dcl 3-52
indirect_type                          internal static fixed bin(4,0)           initial dcl 2-5
list_node                              based           structure                level 1 dcl 3-85
list_type                              internal static fixed bin(4,0)           initial dcl 2-5
lsm                                    based           structure                level 1 dcl 3-27
lsm_$make_blk                   000000 constant        entry                    external dcl 1-3
lsm_$mk_char                    000000 constant        entry                    external dcl 1-3
lsm_$replace_blk                000000 constant        entry                    external dcl 1-3
lsm_$replicate                  000000 constant        entry                    external dcl 1-3
lsm_$set_blk                    000000 constant        entry                    external dcl 1-3
lsm_constants                          internal static structure                level 1 dcl 3-9
lsm_fs_$compact                 000000 constant        entry                    external dcl 1-10
lsm_fs_$free                    000000 constant        entry                    external dcl 1-10
lsm_fs_$init                    000000 constant        entry                    external dcl 1-10
lsm_fs_$merge_symbol            000000 constant        entry                    external dcl 1-10
lsm_fs_$move_struc              000000 constant        entry                    external dcl 1-10
lsm_fs_$pull                    000000 constant        entry                    external dcl 1-10
lsm_fs_$push                    000000 constant        entry                    external dcl 1-10
lsm_segptr                             automatic       pointer                  dcl 3-25
lsm_sym_$find_table             000000 constant        entry                    external dcl 1-19
lsm_sym_$symk                   000000 constant        entry                    external dcl 1-19
lsm_sym_$symn                   000000 constant        entry                    external dcl 1-19
star_ALL_ENTRIES                       internal static fixed bin(2,0)           initial dcl 4-111
star_ALL_ENTRIES_WITH_LINK_PATHS       internal static fixed bin(3,0)           initial dcl 4-114
star_DIRECTORY                         internal static fixed bin(2,0)           initial unsigned dcl 4-121
star_LINK                              internal static fixed bin(2,0)           initial unsigned dcl 4-119
star_LINKS_ONLY                        internal static fixed bin(2,0)           initial dcl 4-109
star_LINKS_ONLY_WITH_LINK_PATHS        internal static fixed bin(3,0)           initial dcl 4-112
star_SEGMENT                           internal static fixed bin(2,0)           initial unsigned dcl 4-120
star_branch_count                      automatic       fixed bin(17,0)          dcl 4-13
star_dir_list_branch                   based           structure                array level 1 dcl 4-59
star_link_count                        automatic       fixed bin(17,0)          dcl 4-17
star_link_pathname                     based           char                     unaligned dcl 4-102
star_links                             based           structure                array level 1 dcl 4-76
star_linkx                             automatic       fixed bin(17,0)          dcl 4-18
star_list_branch                       based           structure                array level 1 dcl 4-41
star_list_branch_ptr                   automatic       pointer                  dcl 4-16
star_list_names                        based           char(32)                 array unaligned dcl 4-92
star_list_names_ptr                    automatic       pointer                  dcl 4-20
star_select_sw                         automatic       fixed bin(3,0)           dcl 4-21
symtab_node                            based           structure                level 1 dcl 3-72
symtab_type                            internal static fixed bin(4,0)           initial dcl 2-5
type_max                               internal static fixed bin(4,0)           initial dcl 2-5

NAMES DECLARED BY EXPLICIT CONTEXT.
crump                           002126 constant        entry                    internal dcl 295 ref 98 101 104 115 122 129 141 170
                                                                                  199
end_of_star_loop                000703 constant        label                    dcl 149 ref 143
list_pgs_contents               000155 constant        entry                    external dcl 18
lpc                             000146 constant        entry                    external dcl 18
process_pgs                     000737 constant        entry                    internal dcl 159 ref 131 147
returner                        000735 constant        label                    dcl 157 ref 95

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2504        2574    2210        2514
Length      3100    2210        70         267     273          14

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lpc                                 482 external procedure  is an external procedure.  
process_pgs                         118 internal procedure  enables or reverts conditions.  
on unit on line 167                  72 on unit               
begin block on line 177             160 begin block         uses auto adjustable storage.  
crump                                94 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 sys_area_p                  lpc
000012 explanation                 lpc

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 177  000100 node_array                  begin block on line 177
                         000100 name                        begin block on line 177
                         000100 symbol_info                 begin block on line 177
                         000120 value                       begin block on line 177
                         000121 sort_structure              begin block on line 177
                         000121 i                           begin block on line 177
                         000122 j                           begin block on line 177
                         000123 found                       begin block on line 177
lpc                      000100 al                          lpc
                         000102 ap                          lpc
                         000104 arg_array                   lpc
                         000504 arg_satisfied               lpc
                         000505 code                        lpc
                         000506 dname                       lpc
                         000560 each_seg                    lpc
                         000561 elements_used               lpc
                         000562 ename                       lpc
                         000572 error_label                 lpc
                         000576 fake_array                  lpc
                         000577 i                           lpc
                         000600 lsm_curl                    lpc
                         000601 lsm_type                    lpc
                         000602 nargs                       lpc
                         000604 node_ptr                    lpc
                         000606 star_entry_count            lpc
                         000610 star_entry_ptr              lpc
                         000612 star_names_ptr              lpc
process_pgs              000100 segptr                      process_pgs

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               enter_begin         leave_begin         call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other_desc begin_return        return              tra_label_var       alloc_auto_adj
mpfx2               enable              ext_entry           int_entry           int_entry_desc      free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
check_star_name_$entry        com_err_                      com_err_$suppress_name        cu_$arg_count
cu_$arg_ptr                   expand_path_                  get_system_free_area_         hcs_$star_
hcs_$terminate_noname         ioa_                          lsm_$get_blk                  lsm_fs_$init_seg
lsm_sym_$sym_list             match_star_name_              sort_items_$char              suffixed_name_$make

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$too_many_args    graphic_error_table_$inv_node_type




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     18 000145        95 000162        97 000165        98 000203       100 000222       101 000245       103 000266
    104 000320       106 000336       107 000345       109 000347       110 000351       111 000353       112 000356
    115 000357       119 000413       120 000422       121 000441       122 000461       123 000503       124 000513
    128 000515       129 000532       131 000551       136 000562       139 000575       141 000640       143 000656
    145 000661       147 000670       149 000703       152 000705       157 000735       159 000736       165 000744
    167 000746       169 000775       170 001030       172 001052       174 001101       177 001135       179 001140
    181 001146       190 001153       197 001157       218 001167       197 001171       199 001217       202 001255
    204 001306       205 001317       206 001324       208 001326       210 001327       212 001340       213 001364
    216 001376       217 001400       218 001403       219 001442       222 001443       224 001446       225 001474
    228 001503       231 001504       240 001515       241 001520       243 001550       244 001554       245 001560
    246 001562       247 001564       248 001565       249 001574       251 001605       253 001612       257 001616
    258 001620       260 001622       262 001635       263 001637       264 001667       267 001671       269 001672
    270 001703       271 001711       273 001752       275 001754       277 001756       279 002007       281 002037
    284 002054       285 002063       287 002110       288 002112       290 002113       291 002124       295 002125
    300 002141       302 002176


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
