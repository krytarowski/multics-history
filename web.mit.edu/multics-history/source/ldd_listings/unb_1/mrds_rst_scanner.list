	COMPILATION LISTING OF SEGMENT mrds_rst_scanner
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/18/85  1103.8 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 /* HISTORY:
       19*
       20*   originally written by jim gray - - july 1978
       21*   Modified by Jim Gray - - 80-11-07, to have identifier_handler get legal characters from
       22*   a mrds_data_ item in common with the rest of mrds (this removed "." as a legal character)
       23*
       24*   80-12-15 Jim Gray : added check for last token being "-" ahead of edit proc
       25*   keywords, as part of un-reserving keywords in CMDB.
       26*
       27*   81-06-04 Jim Gray : removed token types no longer
       28*   acepted by mrds_rst_semantics, such as constants for the -check option
       29*   which was never implemented.
       30*
       31*   81-07-29 Jim Gray : added correct handling of a "/" by itself in the source.
       32*
       33*   83-10-01 Roger Lackey : Modified to correct multi-line comment sometimes
       34*            not putting all of comment in listing. (TR phx15198)
       35**/
       36 
       37 mrds_rst_scanner: procedure (lex_stack_ptr, stack_index);
       38 
       39 /* DESCRIPTION:
       40*   lexical analyzer or scanner for returning tokens from the restructuring source to the parser.
       41*   a token may be an identifier, keyword, number, special character or end of file.
       42*   an integer encoding value is also returned for use by the parser in identifying the token
       43*   and pointers to the token in the source, and the start of the current line are returned
       44*   as well as the line number and length of the token. A line numbered version of the original source can be produced.
       45*   comments and white space are skipped over, and any invalid characters are detected..
       46*
       47*   there are two entries:
       48*   init entry -  should be called first for initialization
       49*   normal entry - for returning tokens from the source
       50**/
       51 
       52 /* PARAMETERS:
       53*   === normal entry ===
       54*   lex_stack_ptr - - (input) pointer to the lexical stack
       55*
       56*   stack_index - - (input) stack element which is hold the returned token, etc.
       57*
       58*   lex_stack - - (output) the specified element contains the token pointer, length, encoding,
       59*   and line number and line start pointer
       60*
       61*   (output) for the line numbered listing goes to "source_segment".list
       62*
       63*   === init entry ===
       64*   err_ptr - - (input) pointer to retructure control segment
       65*
       66*   source_seg_ptr - - (input) pointer to the restructuring directives source segment
       67*
       68*   source_length - - (input) length in characters of the source segment */
       69 
       70 /* normal entry */
       71 
       72 	goto state (START);
       73 
       74 
       75 
       76 
       77 
       78 /* initialization entry */
       79 
       80 mrds_rst_scanner$init: entry (err_ptr, source_seg_ptr, source_length);
       81 
       82 
       83 /* get restructure conrol pointer, set up line number and pointer,
       84*   make first character and it's type available */
       85 
       86 	static_rsc_ptr = err_ptr;
       87 	call mrds_rst_rsc_alloc (static_rsc_ptr, TOKEN, accum_token_ptr);
       88 	call mrds_rst_rsc_alloc (static_rsc_ptr, OUTPUT_TEXT, output_text_ptr);
       89 	call get_next_char_init (source_seg_ptr, source_length, char_ptr, char_type, char);
       90 	call keyword_lookup ("check_proc", CHECK_PROC);
       91 	call keyword_lookup ("encode_proc", ENCODE_PROC);
       92 	call keyword_lookup ("decode_proc", DECODE_PROC);
       93 
       94 	return;
       95 
       96 
       97 
       98 
       99 
      100 
      101 
      102 
      103 
      104 /* START */
      105 state (0):
      106 
      107 
      108 /* using the type code for the current character, go to the appropiate state for that class of tokens,
      109*   the parser having initialized the current character before the first call, and scanner obtaining the next
      110*   character to be used when called again before returning to the parser */
      111 
      112 	token = "";
      113 	token_length = 0;
      114 	fixed_value = 0;
      115 	float_value = 0.0;
      116 	symbol_found = "0"b;
      117 	token_too_long_seen = "0"b;
      118 
      119 /* continue on next page
      120*
      121*   loop from start state to the recognition states,
      122*   while a token is not found, and end of source is not detected */
      123 
      124 	do while (^symbol_found);
      125 	     goto state (char_type);
      126 
      127 /* LETTER */
      128 state (1):
      129 
      130 /* letter found, accumulate characters that are letters, numbers, underscores, hyphens into an identifier token
      131*   then make checks for keywords and pathnames that may follow to provide correct parser and scanner encoding */
      132 
      133 	     call identifier_handler ();
      134 	     call stack_put ();
      135 	     symbol_found = "1"b;
      136 	     goto state (CASE_END);
      137 
      138 /* DIGIT */
      139 state (2):
      140 
      141 /* digit found, accumulate digits,
      142*   into a number and convert from ascii to binary */
      143 
      144 	     if ^number_convert () then ;
      145 	     else do;
      146 		     call stack_put ();
      147 		     symbol_found = "1"b;
      148 		end;
      149 	     goto state (CASE_END);
      150 
      151 /* SPECIAL */
      152 state (3):
      153 
      154 /* special character found, if slash, check for comment
      155*   else return encoding for the character */
      156 
      157 	     if comment_skip () then ;
      158 	     else do;
      159 
      160 /* not a comment, single character special instead, get it's encoding */
      161 
      162 		     call encode_special ();
      163 		     call stack_put ();
      164 		     symbol_found = "1"b;
      165 		end;
      166 	     goto state (CASE_END);
      167 
      168 
      169 /* A_PATH_ENTRY */
      170 state (4):
      171 
      172 /* start of a pathname or entry name detected */
      173 
      174 	     call path_entry_handler ();
      175 	     call stack_put ();
      176 	     symbol_found = "1"b;
      177 	     goto state (CASE_END);
      178 
      179 /* NL */
      180 state (5):
      181 
      182 /* new line detected */
      183 
      184 	     call get_next_char_new_line (char_ptr, char_type, char);
      185 	     symbol_found = "0"b;
      186 	     goto state (CASE_END);
      187 
      188 /* WHITE_SPACE */
      189 state (6):
      190 
      191 /* white space detected, skip over it */
      192 
      193 	     call get_next_char_non_white (char_ptr, char_type, char);
      194 	     symbol_found = "0"b;
      195 	     goto state (CASE_END);
      196 
      197 /* ILLEGAL */
      198 state (7):
      199 
      200 /* illegal character detected */
      201 
      202 	     call ioa_$rs ("^a^a^a ^d ^a ^d^a", message, message_length,
      203 		"Character """, char, """, before token number", token_count + 1, "on line", line_number, ".");
      204 	     call mrds_rst_error (static_rsc_ptr, 1 /* severity */, mrds_error_$rst_illegal_char, (message));
      205 	     call get_next_char (char_ptr, char_type, char);
      206 	     symbol_found = "0"b;
      207 	     goto state (CASE_END);
      208 
      209 /* EOF */
      210 state (8):
      211 
      212 /* end of input detected */
      213 
      214 	     encoding = EOI;
      215 	     token_ptr = char_ptr;
      216 	     call stack_put ();
      217 	     symbol_found = "1"b;
      218 	     goto state (CASE_END);
      219 
      220 /* CASE_END */
      221 state (9):
      222 
      223 	end;
      224 	return;
      225 
      226 stack_put: procedure ();
      227 
      228 /* increment the number of tokens seen in this line */
      229 
      230 	token_count = token_count + 1;
      231 
      232 /* routine to put the token info into the stack */
      233 
      234 	lex_stack (stack_index).symptr = token_ptr;
      235 	lex_stack (stack_index).symlen = token_length;
      236 	lex_stack (stack_index).line = line_number;
      237 	lex_stack (stack_index).symbol = encoding;
      238 	lex_stack (stack_index).val = fixed_value;
      239 	lex_stack (stack_index).float = float_value;
      240 	lex_stack (stack_index).line_strt = line_ptr;
      241 	lex_stack (stack_index).line_size = line_length;
      242 	lex_stack (stack_index).token_num = token_count;
      243 
      244 	previous_token_type = encoding;
      245      end;
      246 
      247 identifier_handler: procedure ();
      248 
      249 /* routine to assemble identifiers, make keyword encodings,
      250*   and set up for path names to follow certain keywords */
      251 
      252 	token_ptr = char_ptr;
      253 	do while (index (mrds_data_$valid_id_chars, char) ^= 0);
      254 	     call add_char_to_token ();
      255 	     call get_next_char (char_ptr, char_type, char);
      256 	end;
      257 
      258 /* find out if this is a keyword */
      259 
      260 	call keyword_lookup (token, encoding);
      261 	if encoding ^= 0 then ;
      262 	else encoding = IDENTIFIER;
      263 
      264 /* if this was a path name keyword, check for absolute pathname following(i.e. ">" next),
      265*   and set up char_type to get the pathname on the next call to scanner */
      266 
      267 	if encoding = CHECK_PROC | encoding = ENCODE_PROC | encoding = DECODE_PROC then do;
      268 
      269 
      270 /* do double check that the previous token was a "-", else
      271*   we don't really have an edit procedure keyword */
      272 
      273 		if previous_token_type ^= index (SPECIAL_LIST, "-") then
      274 		     encoding = IDENTIFIER;		/* not a real keyword */
      275 		else do;
      276 
      277 /* get next good character after keyword, it should be ">" */
      278 
      279 			temp_line_number = line_number;
      280 			good_char = "0"b;
      281 			do while (^good_char);
      282 			     if char_type ^= WHITE_SPACE & char_type ^= NL then
      283 				good_char = "1"b;
      284 			     else if char_type = WHITE_SPACE then
      285 				call get_next_char_non_white (char_ptr, char_type, char);
      286 			     else if char_type = NL then
      287 				call get_next_char_new_line (char_ptr, char_type, char);
      288 			end;
      289 			if char = ">" then
      290 			     char_type = A_PATH_ENTRY;
      291 			else do;
      292 
      293 				call ioa_$rs ("^a ^d^a ^d^a", message, message_length,
      294 				     "Absolute pathname missing or not starting with "">"" after token",
      295 				     token_count + 1, ", a procedure path keyword in line", temp_line_number, ".");
      296 				call mrds_rst_error (static_rsc_ptr, 2 /* severity */,
      297 				     mrds_error_$rst_missing_pathname, (message));
      298 
      299 			     end;
      300 		     end;
      301 
      302 	     end;
      303      end;
      304 
      305 add_char_to_token: procedure ();
      306 
      307 /* if max token size not exceeded, append current character
      308*   to the accumulating token variable, else truncate it at the max size  */
      309 
      310 	on stringsize /* capture max size exceeded */
      311 	     begin;
      312 
      313 /* issue error message on first occurence only */
      314 
      315 		if token_too_long_seen then ;
      316 		else do;
      317 			token_too_long_seen = "1"b;
      318 			call ioa_$rs ("^a ^d ^a ^d ^a", message, message_length,
      319 			     "A token on line", line_number, "exceeds the maximum string size of",
      320 			     mrds_data_$max_string_size, "characters, it is being truncated at that length.");
      321 			call mrds_rst_error (static_rsc_ptr, 2 /* severity */, mrds_error_$rst_token_too_long, (message));
      322 		     end;
      323 
      324 		goto truncate_token;
      325 
      326 	     end;
      327 
      328 /* normal action appends character to token */
      329 
      330 (stringsize): token = token || char;
      331 	token_length = token_length + 1;
      332 
      333 truncate_token:
      334 
      335 
      336      end;
      337 
      338 number_convert: procedure () returns (bit (1));
      339 
      340 /* routine to accumulate extent of number in ascii, and convert it to the
      341*   appropriate internal form and give it the required parser encoding */
      342 
      343 	fixup_done = "0"b;
      344 	token_ptr = char_ptr;
      345 
      346 /*    accumulate  positive integer numbers as the token */
      347 
      348 	mantissa_end = "0"b;
      349 	radix_found = "0"b;
      350 	do while (^mantissa_end);
      351 
      352 	     do while (char_type = DIGIT);
      353 		call add_char_to_token ();
      354 		call get_next_char (char_ptr, char_type, char);
      355 	     end;
      356 
      357 
      358 	     mantissa_end = "1"b;
      359 
      360 	end;
      361 
      362 
      363 /* good number found, check for possible exponent */
      364 
      365 	number_found = "1"b;
      366 
      367 /* number processed, assign the appropiate encoding value for the parser */
      368 
      369 	encoding = INTEGER;
      370 
      371 /* get the binary equivalent for this number, if semantics has not shut off converting */
      372 
      373 	if static_rsc_ptr -> rsc.skip_scanner_conversion then ;
      374 	else call binary_conversion ();
      375 
      376 
      377 /* return success for good number, failure for illegal character "." by itself, and use corrected token rather than source */
      378 
      379 	if ^fixup_done then ;
      380 	else call substitute_fixup_token ();
      381 
      382 	return (number_found);
      383 
      384 binary_conversion: procedure ();
      385 
      386 /* routine to do ascii to binary conversion of numbers */
      387 
      388 /* use the large number fixup on conversion overflow */
      389 
      390 	on size call fixup_conversion;
      391 	on fixedoverflow call fixup_conversion;
      392 	on overflow call fixup_conversion;
      393 	on underflow call fixup_conversion;
      394 	on conversion call fixup_conversion;
      395 
      396 /* convert the accumulated ascii token to binary */
      397 
      398 	fixed_value = fixed (binary (token));
      399 
      400 
      401 /* conversion error fixup return */
      402 SKIP_CONVERT:
      403 
      404 	return;
      405 
      406 
      407 
      408 fixup_conversion: procedure ();
      409 
      410 /* use the largest number in place of the one that is too big */
      411 
      412 	fixup_done = "1"b;
      413 
      414 	temp_token = copy ("1", 71) || "b";
      415 	fixed_value = fixed (binary (temp_token));
      416 	call ioa_$rs ("^a ^a ^a ^d ^a ^d ", message, message_length,
      417 	     "The number", token, "in line", line_number, "is too large, using value", fixed_value);
      418 	token = temp_token;
      419 
      420 	call mrds_rst_error (static_rsc_ptr, 2 /* severity */,
      421 	     mrds_error_$rst_conversion_error, (message));
      422 
      423 	goto SKIP_CONVERT;
      424 
      425      end;
      426 
      427      end;
      428 
      429      end;
      430 
      431 substitute_fixup_token: procedure ();
      432 
      433 /* save the fixup version of the token, and point to it rather than the source */
      434 
      435 	token_length = length (token);
      436 	call mrds_rst_rsc_alloc$variable (static_rsc_ptr, FIXUP_TOKEN, (token_length), token_ptr);
      437 	token_ptr -> fixup_token = token;
      438 
      439 
      440      end;
      441 
      442 comment_skip: procedure () returns (bit (1));
      443 
      444 /* check for presence of a comment, return failure if not found */
      445 
      446 	token_ptr = char_ptr;
      447 	token = char;
      448 	call get_next_char (char_ptr, char_type, char);
      449 	if (token = "/" & char ^= "*") | (token ^= "/") then do;
      450 		if token ^= "/" then
      451 		     result = "0"b;
      452 		else do;
      453 			result = "1"b;		/* skip over illegal character */
      454 			call ioa_$rs ("^a^a^a ^d ^a ^d^a", message, message_length,
      455 			     "Character """, token, """, before token number", token_count + 1, "on line", line_number, ".");
      456 			call mrds_rst_error (static_rsc_ptr, 1 /* severity */, mrds_error_$rst_illegal_char, (message));
      457 		     end;
      458 	     end;
      459 	else do;
      460 
      461 /* routine to bypass comments in the source */
      462 
      463 		comment_end = "0"b;
      464 		char = " ";
      465 		do while (^comment_end);
      466 
      467 		     do while (char ^= "*" & char_type ^= EOF);
      468 			if char_type ^= NL then
      469 			     call get_next_char_non_white (char_ptr, char_type, char);
      470 			if char_type = NL then
      471 			     call get_next_char_new_line (char_ptr, char_type, char);
      472 		     end;
      473 
      474 		     if char_type = EOF then
      475 			comment_end = "1"b;
      476 		     else do;
      477 			     call get_next_char (char_ptr, char_type, char);
      478 			     if char ^= "/" & char_type ^= EOF then ;
      479 			     else comment_end = "1"b;
      480 			     if char_type ^= NL then ;
      481 			     else call get_next_char_new_line (char_ptr, char_type, char);
      482 			end;
      483 
      484 		end;
      485 
      486 
      487 /* check for comment error */
      488 
      489 		if char_type ^= EOF then ;
      490 		else do;
      491 			call ioa_$rs ("^a ^d^a", message, message_length,
      492 			     "Comment ends line number", line_number, ".");
      493 			call mrds_rst_error (static_rsc_ptr, 2 /* severity */,
      494 			     mrds_error_$rst_comment_ends_source, (message));
      495 		     end;
      496 
      497 		token = "";
      498 		call get_next_char_non_white (char_ptr, char_type, char);
      499 		symbol_found = "0"b;
      500 		result = "1"b;
      501 
      502 	     end;
      503 
      504 	return (result);
      505 
      506      end;
      507 
      508 encode_special: procedure ();
      509 
      510 /* routine to produce the parser encoding of the special character just found */
      511 
      512 	token_length = 1;
      513 	special_index = index (SPECIAL_LIST, token);
      514 	if special_index ^= 0 then
      515 	     encoding = CODE (special_index);
      516 	else do;
      517 		encoding = EOI;
      518 		call ioa_$rs ("^a ^a ^a ^d^a", message, message_length,
      519 		     "Special character", token, "in line", line_number, ".");
      520 		call mrds_rst_error (static_rsc_ptr, 4 /* severity */, mrds_error_$rst_bad_encoding, (message));
      521 	     end;
      522 
      523      end;
      524 
      525 path_entry_handler: procedure ();
      526 
      527 /* routine to accumulate character strings representing either path names,
      528*   or entry names into tokens and give them the proper parser encoding */
      529 
      530 
      531 /* if path name detected by identifier handler, reset the ">" char_type to special */
      532 
      533 	if char ^= "$" then do;
      534 		encoding = PATH_NAME;
      535 		char_type = SPECIAL;
      536 	     end;
      537 
      538 /* else we have an entry name starting with "$", throw that character away */
      539 
      540 	else do;
      541 		encoding = ENTRY_NAME;
      542 		call get_next_char (char_ptr, char_type, char);
      543 	     end;
      544 
      545 /* get the length for and pointer to this path/entry name
      546*   path names end in white space or "$", entry names end in white space
      547*   a "," or ";" also ends them due to domain statement syntax */
      548 
      549 	token_ptr = char_ptr;
      550 	do while (char_type ^= WHITE_SPACE & char_type ^= NL & char_type ^= A_PATH_ENTRY & char_type ^= EOF
      551 	     & char ^= "," & char ^= ";");
      552 	     token_length = token_length + 1;
      553 	     call get_next_char (char_ptr, char_type, char);
      554 	end;
      555 
      556 /* check for name ending source prematurely */
      557 
      558 	if char_type ^= EOF then ;
      559 	else do;
      560 		call ioa_$rs ("^a ^d^a ^d^a", message, message_length,
      561 		     "Pathname is token", token_count + 1, ", on line", line_number, ".");
      562 		call mrds_rst_error (static_rsc_ptr, 2 /* severity */,
      563 		     mrds_error_$rst_pathname_ends_source, (message));
      564 	     end;
      565 
      566      end;
      567 
      568 get_next_character_routine: procedure ();		/* dummy entry, not used */
      569 
      570 /* This procedure has four entry points.
      571*   get_next_char_init   should be called first to set up things
      572*   get_next_char_new_line is used to advance the current line, output it, and get the first char
      573*   get_next_char_non_white skips white spaces until a valid character is found
      574*   get_next_char$get_next_char  returns only info about the next char in source
      575**/
      576 
      577 
      578 
      579 /* INIT */
      580 get_next_char_init: entry (s_seg_ptr, s_seg_len, chr_ptr, type, chr_val); /* This entry initializes internal stativ values */
      581 
      582 	seg_ptr = s_seg_ptr;			/* Save source segment pointer and length */
      583 	seg_len = s_seg_len;			/*   in internal static variable */
      584 	pos = 1;					/* Starting position is first character */
      585 	line_number = 0;
      586 
      587 
      588 
      589 /* NEW LINE */
      590 get_next_char_new_line: entry (chr_ptr, type, chr_val);	/* entry to advance to next line */
      591 
      592 	if pos > seg_len then ;
      593 	else do;
      594 
      595 /* find end of next line */
      596 
      597 		line_ptr = addr (char_string (pos));
      598 		line_length = index (substr (line_ptr -> source, 1, seg_len - pos + 1), NL_CHAR);
      599 		if line_length ^= 0 then ;		/* next lines NL found */
      600 		else line_length = seg_len - pos + 1;	/* segment doesn't end last line with NL */
      601 
      602 		line_number = line_number + 1;
      603 		token_count = 0;
      604 
      605 		if ^static_rsc_ptr -> rsc.listing_seg_sw then ;
      606 		else do;
      607 
      608 /* listing switch on, output the current line */
      609 
      610 			line_no_pic = line_number;
      611 			output_text = line_no_pic || "   " || substr (line_ptr -> source, 1, line_length);
      612 
      613 			call iox_$put_chars (static_rsc_ptr -> rsc.listing_iocb_ptr,
      614 			     addrel (addr (output_text), 1), length (output_text), code);
      615 			if code = 0 then ;
      616 			else do;
      617 				call ioa_$rs ("^a ^d ^a", message, message_length,
      618 				     "Error in trying to output line number", line_number, "to listing segment rmdb.list");
      619 				call mrds_rst_error (static_rsc_ptr, 4 /* severity */,
      620 				     mrds_error_$rst_io_error, (message));
      621 			     end;
      622 		     end;
      623 	     end;
      624 
      625 	goto get_first_char;
      626 
      627 
      628 /* NEXT NON WHITE */
      629 get_next_char_non_white: entry (chr_ptr, type, chr_val);	/* This entry skips white space */
      630 
      631 	if pos <= seg_len then do;			/* for positions less than segment length + 1 */
      632 
      633 		type = mrds_rst_translate (fixed (char_bits (pos), 9)); /* get character type */
      634 
      635 		do while (type = WHITE_SPACE & pos <= seg_len); /* Skip until type is not white space */
      636 		     pos = pos + 1;			/* Current position gets bumped */
      637 		     type = mrds_rst_translate (fixed (char_bits (pos), 9)); /* Determine caracter type */
      638 		end;
      639 						/* pos is the index of the next non-white-space character */
      640 	     end;
      641 
      642 
      643 
      644 /* NEXT CHAR */
      645 get_first_char: ;
      646 get_next_char: entry (chr_ptr, type, chr_val);		/* return next character in source */
      647 
      648 	if pos <= seg_len then do;			/* Not passed end of segment */
      649 		chr_val = char_string (pos);		/* Get character */
      650 		type = mrds_rst_translate (fixed (char_bits (pos), 9)); /* Get character type from table */
      651 		chr_ptr = addr (char_string (pos));	/* Get pointer to caracter */
      652 		pos = pos + 1;			/* Bump index to next char posiition */
      653 	     end;
      654 
      655 	else do;
      656 		type = EOF;			/* Position was beyond end of segment */
      657 		chr_val = " ";
      658 	     end;
      659 
      660 
      661 	return;
      662 
      663 /*	PARAMETERS	*/
      664 
      665 	dcl     s_seg_ptr		 ptr;		/* (INPUT) Pointer to source segment */
      666 	dcl     s_seg_len		 fixed bin (24);	/* (INPUT) Length of source segment in chars */
      667 
      668 	dcl     chr_val		 char (1);	/* (OUTPUT) Current character */
      669 	dcl     type		 fixed bin;	/* (OUTPUT) Character type from map */
      670 	dcl     chr_ptr		 ptr;		/* (OUTPUT) Pointer to current character */
      671 
      672 /*	STATIC VARIABLES	*/
      673 
      674 	dcl     pos		 fixed bin (24) internal static init (1); /* Index position in to character string */
      675 	dcl     seg_ptr		 ptr int static init (null); /* Pointer to input segment (source segment) */
      676 	dcl     seg_len		 fixed bin (24) int static init (0); /* Length of input segment (source) */
      677 	dcl     NL_CHAR		 char (1) internal static init ("
      678 ");						/* new line character */
      679 
      680 /*	OTHERS		*/
      681 
      682 	dcl     addr		 builtin;
      683 
      684 /* 	BASED VARIABLES	*/
      685 
      686 	dcl     char_string		 (seg_len) char (1) based (seg_ptr); /* Treat char string as char array */
      687 	dcl     char_bits		 (seg_len) bit (9) unal based (seg_ptr); /* Treat char string as bit array */
      688 
  1     1 /*  BEGIN INCLUDE FILE ..... mrds_rst_translate_mad.incl.pl1 ..... 06/05/81  1042.6 mst Fri JGray.Multics */
  1     2 /*  FROM INPUT SEGMENT mrds_rst_translate.mad */
  1     3 
  1     4 /* using ted$com >udd>LIS>Wardd>Wardd|mad  mrds_rst_translate.mad */
  1     5 
  1     6 dcl  mrds_rst_translate   (0:511)fixed bin static int options(constant) init(
  1     7 	/*
  1     8*	'000'777	7
  1     9*	'011	6
  1    10*	'013	6
  1    11*	'014	6
  1    12*	'040	6
  1    13*	'012	5
  1    14*	$	4
  1    15*	/	3
  1    16*	:	3
  1    17*	;	3
  1    18*	,	3
  1    19*	(	3
  1    20*	)	3
  1    21*	*	3
  1    22*	-	3
  1    23*	+	3
  1    24*	09	2
  1    25*	az	1
  1    26*	AZ	1
  1    27*	*/
  1    28 	 (9)7, 6, 5, (2)6, (19)7, 6, (3)7, 4, (3)7, (6)3, 7, 3,
  1    29 	 (10)2, (2)3, (5)7, (26)1, (6)7, (26)1, (389)7  );
  1    30 /*    END INCLUDE FILE ..... mrds_rst_translate_mad.incl.pl1 ..... */
      689 
      690      end get_next_character_routine;
      691 
      692 keyword_lookup: procedure (token, encodement);
      693 
      694 /* routine to do binary search of keywords known to mrds restructuring
      695*   against a supplied identifier and return an
      696*   encoded value for the keyword if a match if found, else return zero */
      697 
      698 /* initialize the starting range for the binary search
      699*   as that of the whole array, and set the
      700*   first probe point to its middle */
      701 
      702 	low = lbound (keyword, 1);
      703 	high = hbound (keyword, 1);
      704 	middle = (low + high) / 2;
      705 
      706 /* proceed to divide the range in half,
      707*   searching the half remaining that contains
      708*   the value range (in ascii sequence) of
      709*   the supplied identifier */
      710 
      711 	do while (token ^= keyword.name (middle) & high > low);
      712 
      713 	     if token > keyword.name (middle) then
      714 		low = middle + 1;
      715 	     else high = middle - 1;
      716 
      717 	     middle = (low + high) / 2;
      718 
      719 	end;
      720 
      721 /* check to see if the search was successful */
      722 
      723 	if token = keyword.name (middle) then
      724 	     encodement = keyword.value (middle);
      725 	else encodement = 0;
      726 
      727 /* the following declaration that includes the encoding
      728*   for keywords was generated by the keyword sorted list tool,
      729*   for use with the terminal encoding as derived from
      730*   use of the lrk tool on the mrds restructuring bnf - - see D. Ward's documentation */
      731 
  2     1 /* BEGIN INCLUDE FILE mrds_rst_keywords.incl.pl1       (Davids.Multics) 10/15/81  1622.5 mst Thu */
  2     2 
  2     3 /* Inputs: */
  2     4 /* >udd>Multics>Davids>tr>11714>mrds_rst_parse.result */
  2     5 /* >udd>Multics>Davids>tr>11714>mrds_rst_keywords.syn */
  2     6 dcl 1 keyword  (40) static internal options(constant),
  2     7       2 name char(18) var init(
  2     8  /*   1 */ "aligned"            /*  28 <aligned>     */
  2     9 ,/*   2 */ "attr"               /*  14 <attribute>   */
  2    10 ,/*   3 */ "attribute"          /*  14 <attribute>   */
  2    11 ,/*   4 */ "bin"                /*  21 <binary>      */
  2    12 ,/*   5 */ "binary"             /*  21 <binary>      */
  2    13 ,/*   6 */ "bit"                /*  25 <bit>         */
  2    14 ,/*   7 */ "char"               /*  24 <char>        */
  2    15 ,/*   8 */ "character"          /*  24 <char>        */
  2    16 ,/*   9 */ "check_proc"         /*  30 <check_proc>  */
  2    17 ,/*  10 */ "check_procedure"    /*  30 <check_proc>  */
  2    18 ,/*  11 */ "chkp"               /*  30 <check_proc>  */
  2    19 ,/*  12 */ "complex"            /*  18 <complex>     */
  2    20 ,/*  13 */ "cplx"               /*  18 <complex>     */
  2    21 ,/*  14 */ "dec"                /*  22 <decimal>     */
  2    22 ,/*  15 */ "decimal"            /*  22 <decimal>     */
  2    23 ,/*  16 */ "decode_dcl"         /*  33 <decode_dcl>  */
  2    24 ,/*  17 */ "decode_declaration" /*  33 <decode_dcl>  */
  2    25 ,/*  18 */ "decode_declare"     /*  33 <decode_dcl>  */
  2    26 ,/*  19 */ "decode_proc"        /*  32 <decode_proc> */
  2    27 ,/*  20 */ "decode_procedure"   /*  32 <decode_proc> */
  2    28 ,/*  21 */ "decp"               /*  32 <decode_proc> */
  2    29 ,/*  22 */ "dom"                /*  13 <domain>      */
  2    30 ,/*  23 */ "domain"             /*  13 <domain>      */
  2    31 ,/*  24 */ "encode_proc"        /*  31 <encode_proc> */
  2    32 ,/*  25 */ "encode_procedure"   /*  31 <encode_proc> */
  2    33 ,/*  26 */ "encp"               /*  31 <encode_proc> */
  2    34 ,/*  27 */ "fixed"              /*  19 <fixed>       */
  2    35 ,/*  28 */ "float"              /*  20 <float>       */
  2    36 ,/*  29 */ "floating"           /*  20 <float>       */
  2    37 ,/*  30 */ "index"              /*  16 <index>       */
  2    38 ,/*  31 */ "nonvarying"         /*  27 <nonvarying>  */
  2    39 ,/*  32 */ "prec"               /*  23 <precision>   */
  2    40 ,/*  33 */ "precision"          /*  23 <precision>   */
  2    41 ,/*  34 */ "real"               /*  17 <real>        */
  2    42 ,/*  35 */ "rel"                /*  15 <relation>    */
  2    43 ,/*  36 */ "relation"           /*  15 <relation>    */
  2    44 ,/*  37 */ "unal"               /*  29 <unaligned>   */
  2    45 ,/*  38 */ "unaligned"          /*  29 <unaligned>   */
  2    46 ,/*  39 */ "var"                /*  26 <varying>     */
  2    47 ,/*  40 */ "varying"            /*  26 <varying>     */
  2    48 			),
  2    49       2 value fixed bin(24) init(
  2    50  28,14,14,21,21,25,24,24,30,30,30,18,18,22,22,33,33,33,32,32
  2    51 ,32,13,13,31,31,31,19,20,20,16,27,23,23,17,15,15,29,29,26,26
  2    52 			);
  2    53 
  2    54 /*   END INCLUDE FILE mrds_rst_keywords.incl.pl1       */
      732 
      733 
      734 
      735 	dcl     low		 fixed binary;	/* current low search for part of array left to be searched */
      736 	dcl     high		 fixed binary;	/* current high search search */
      737 	dcl     middle		 fixed binary;	/* current probe point in array */
      738 	dcl     (lbound, hbound)	 builtin;		/* functions known to pl1 to get array bounds */
      739 	dcl     token		 char (*) varying;	/* identifier to be searched for as keyword */
      740 	dcl     encodement		 fixed binary;	/* encoding value to be given to found keyword */
      741 
      742      end;
      743 
      744 	dcl     stack_index		 fixed bin (24) aligned; /* place in lexical stack to put returned token */
      745 	dcl     encoding		 fixed binary;	/* integer value expected by parser to represent this token */
      746 	dcl     token_too_long_seen	 bit (1);		/* ON => previous error message issued */
      747 	dcl     stringsize		 condition;	/* target too small for string */
      748 	dcl     good_char		 bit (1);		/* on => character is not white space or new line char */
      749 	dcl     mantissa_end	 bit (1);		/* end of mantissa flag */
      750 	dcl     radix_found		 bit (1);		/* on => radix point found in mantissa */
      751 	dcl     fixed_value		 fixed binary (71); /* converted binary value of a fixed number */
      752 	dcl     float_value		 float binary (63); /* converted binary value of a float number */
      753 	dcl     symbol_found	 bit (1);		/* on => token has been found */
      754 	dcl     comment_end		 bit (1);		/* on => end of comment reached */
      755 	dcl     mrds_rst_rsc_alloc$variable entry (ptr, fixed bin, fixed bin (35), ptr); /* working area alloc routine */
      756 	dcl     mrds_rst_rsc_alloc	 entry (ptr, fixed bin, ptr); /* for non-variable allocations */
      757 	dcl     ioa_$rs		 entry options (variable); /* string manipulation routine for error messages */
      758 	dcl     message		 char (256) varying;/* error message with details */
      759 	dcl     message_length	 fixed binary;	/* length of error message */
      760 	dcl     mrds_rst_error	 entry (ptr, fixed binary, fixed binary (35), char (*)); /* error handling routine */
      761 	dcl     result		 bit (1);		/* on => a comment was found and skipped */
      762 	dcl     number_found	 bit (1);		/* off => "." by itself skipped as illegal */
      763 	dcl     token_ptr		 ptr;		/* pointer to token start in source */
      764 	dcl     (size, overflow, underflow, fixedoverflow, conversion) condition; /* trap for conversion overflow */
      765 	dcl     mrds_error_$rst_token_too_long fixed bin (35) external; /* token exceed max string size */
      766 	dcl     mrds_error_$rst_pathname_ends_source fixed binary (35) external; /* premature segment end by a name */
      767 	dcl     mrds_error_$rst_missing_pathname fixed binary (35) external; /* expected pathname missing after keyword */
      768 	dcl     mrds_error_$rst_conversion_error fixed binary (35) external; /* number convert onverflow error */
      769 	dcl     mrds_error_$rst_io_error fixed binary (35) external; /* error during io attempt */
      770 	dcl     mrds_error_$rst_comment_ends_source fixed binary (35) external; /* long comment error code */
      771 	dcl     mrds_error_$rst_illegal_char fixed binary (35) external; /* bad char error code */
      772 	dcl     mrds_error_$rst_bad_encoding fixed binary (35) external; /* bad integer code for special char */
      773 	dcl     special_index	 fixed binary;	/* index of special char encoding in the CODE array */
      774 	dcl     index		 builtin;		/* search function known to pl1 */
      775 	dcl     source_seg_ptr	 ptr;		/* pointer to restructuring directives source segment */
      776 	dcl     err_ptr		 ptr;		/* pointer to restructure control segment */
      777 	dcl     source_length	 fixed binary (24); /* character length of source segment */
      778 	dcl     sys_info$max_seg_size	 fixed binary (35) external; /* system constant for largest size segment */
      779 	dcl     (fixed, rel, addr)	 builtin;		/* functions known to pl1 */
      780 	dcl     temp_line_number	 fixed binary (21); /* storage for error line number */
      781 	dcl     line_no_pic		 picture "zzzzzz9"; /* number of output line, formatted */
      782 	dcl     source		 char (sys_info$max_seg_size) based; /* overlay to extract source lines */
      783 	dcl     fixup_done		 bit (1);		/* on => change made to token to correct error */
      784 	dcl     code		 fixed binary (35); /* error code from subroutine calls */
      785 	dcl     iox_$put_chars	 entry (ptr, ptr, fixed bin (21), fixed bin (35)); /* listing io routine */
      786 	dcl     (addrel, binary, copy, length, substr) builtin;
      787 	dcl     temp_token		 char (96) varying; /* temp storage for fixup value */
      788 	dcl     ENCODE_PROC		 fixed binary internal static; /* encoding value for keyword encode_proc */
      789 	dcl     DECODE_PROC		 fixed binary internal static; /* encoding value for keyword decode_proc */
      790 	dcl     CHECK_PROC		 fixed binary internal static; /* encoding value for keyword check_proc */
      791 	dcl     mrds_data_$valid_id_chars char (128) varying ext; /* common place for getting legal identifier characters */
      792 	dcl     previous_token_type	 fixed bin int static init (0); /* last token encoding */
      793 
      794 
  3     1 /* BEGIN INCLUDE FILE mrds_rst_parse_stack.incl.pl1  jeg 8/8/78 */
  3     2 
  3     3 declare 1 lex_stack (-5:50) based (lex_stack_ptr),
  3     4         2 symptr ptr,				/* pointer to terminal symbol in source input */
  3     5         2 symlen fixed binary (24),			/* length of terminal symbol in input */
  3     6         2 line fixed binary (24),			/* line number in source for this symbol */
  3     7         2 symbol fixed binary (24),			/* parser's encoding value for the terminal symbol */
  3     8         2 val fixed binary (71),			/* conversion value for numbers */
  3     9         2 float float binary (63),			/* conversion value if floating point number */
  3    10         2 line_strt ptr,				/* pointer to start of current line */
  3    11         2 line_size fixed binary (24),			/* current length of line */
  3    12         2 token_num fixed binary (24) ;			/* number of this token in current line,
  3    13*						   0 if <error_symbol> for missing or wrong symbol */
  3    14 
  3    15 declare  lex_stack_ptr ptr ;				/* pointer to lexical stack */
  3    16 
  3    17 declare  debug_sw bit (1) static init ("0"b) ;		/* on => output debug messages */
  3    18 
  3    19 dcl 1 p_struct (50) aligned based (p_struct_ptr),
  3    20     2 parse_stack fixed bin (24),			/* * parse stack */
  3    21     2 parse_stack2 fixed bin (24);			/* * copy of parse stack used
  3    22*						   with local error recovery */
  3    23 
  3    24 dcl  p_struct_ptr ptr ;
  3    25 
  3    26 
  3    27 dcl  cur_lex_top (50) fixed bin (24) aligned based (cur_lex_top_ptr) ; /* current lex top stack (with parse_stack) */
  3    28 
  3    29 declare  cur_lex_top_ptr ptr ;
  3    30 
  3    31 
  3    32 /* END INCLUDE FILE mrds_rst_parse_stack.incl.pl1 */
  3    33 
      795 
      796 
  4     1 /* INCLUDE	mrds_rst_scan.incl.pl1	Jim Gray	August, 1978	*/
  4     2 /* 81-06-04 Jim Gray : removed unused constants, and assigned new values
  4     3*   according to the -order option in the lrk input */
  4     4 
  4     5 dcl  LETTER fixed bin internal static options (constant) init (1);
  4     6 dcl  DIGIT fixed bin internal static options (constant) init (2);
  4     7 dcl  SPECIAL fixed bin internal static options (constant) init (3);
  4     8 dcl  A_PATH_ENTRY fixed bin internal static options (constant) init (4) ;
  4     9 dcl  NL fixed bin internal static options (constant) init (5);
  4    10 dcl  WHITE_SPACE fixed bin internal static options (constant) init (6);
  4    11 dcl  ILLEGAL fixed bin internal static options (constant) init (7);
  4    12 dcl  EOF fixed bin internal static options (constant) init (8);
  4    13 
  4    14 declare  START fixed binary internal static options (constant) init (0) ;
  4    15 declare  CASE_END fixed binary internal static options (constant) init (9) ;
  4    16 
  4    17 
  4    18 /* parser token encoding */
  4    19 
  4    20 declare  EOI fixed binary internal static options (constant) init (0) ;
  4    21 declare  PATH_NAME fixed binary internal static options (constant) init (9) ;
  4    22 declare  ENTRY_NAME fixed binary internal static options (constant) init (10) ;
  4    23 declare  INTEGER fixed binary internal static options (constant) init (11) ;
  4    24 declare  IDENTIFIER fixed binary internal static options (constant) init (12) ;
  4    25 
  4    26 /* encoding for specials "(", ")", ",", ";", ":", "-", "*", "+" */
  4    27    declare  SPECIAL_LIST char (8) internal static options (constant) init ("(),;:-*+") ; /* special characters */
  4    28 declare  CODE (8) fixed binary internal static options (constant) init (1, 2, 3, 4, 5, 6, 7, 8) ;
  4    29 
  4    30 /* static variables for scanner */
  4    31 
  4    32 declare  static_rsc_ptr ptr internal static ;		/* static storage for restructure control seg ptr */
  4    33 
  4    34 declare  char char (1) internal static ;		/* character returned by get_next_char */
  4    35 declare  char_type fixed binary internal static ;		/* integer encoding for this class of characters */
  4    36 declare  char_ptr ptr internal static ;			/* pointer to current character in source */
  4    37 declare  line_ptr ptr internal static ;			/* pointer to start of current line */
  4    38 declare  line_number fixed binary (24) internal static ;	/* current number of source line */
  4    39 declare  line_length fixed binary (24) internal static ;	/* current length of line */
  4    40 declare  token_count fixed binary (24) internal static ;	/* index in line(countber of) current token */
  4    41 
  4    42 /* END mrds_rst_scan.incl.pl1		*/
  4    43 
      797 
      798 
  5     1 /* BEGIN INCLUDE FILE mrds_rst_rsc.incl.pl1		RDL  7/7/78	*/
  5     2 
  5     3 /* Modified 8/21/78 by RDL */
  5     4 
  5     5 /* Modified 9/11/78 	by RDL to add directive and stmt pointers */
  5     6 
  5     7 /* Modified 11/4/78		by RDL to add debug,trace,meter switches
  5     8*
  5     9*   Modified 3/29/79 by RDL to change s_seg_info_ptr to source_seg_ptr
  5    10*
  5    11*   Modified by Jim Gray - - Jan. 1980, to add flags to disallow blocked files, forieng keys, and restructuring.
  5    12*
  5    13*   Modified by Jim Gray - - Feb. 1980, to add command level flag for cmdb subroutine interface.
  5    14*
  5    15*   Modified by Jim Gray - - 80-11-06, to add bit for cmdb -secure option.
  5    16*
  5    17*   81-05-18 Jim Gray : added bit for max_attributes error message, so that
  5    18*   it would only be issued on first occurence.
  5    19*
  5    20*   82-08-19 Davids: added the db_type field.
  5    21*
  5    22*   83-02-18 Mike Kubicar : Removed the db_type field and added the 
  5    23*   db_relation_mode_flags substructure to define the modes applicable
  5    24*   to the database's relations.  Also removed assorted unsed fields
  5    25*   (names that included the word unused).
  5    26*
  5    27**/
  5    28 
  5    29 dcl 1 rsc based (rsc_ptr),				/* Restructuring control info */
  5    30     2 rsc_dir char (200),				/* pathname of directory containing rsc segment */
  5    31     2 dbp char (168),				/* Database absolute path */
  5    32     2 temp_dir char (168),				/* Path name of temp restrucuring directory */
  5    33     2 temp_dir_sw bit (1) unal,			/* On => temp dir has been created */
  5    34     2 db_quiesced_sw bit (1) unal,			/* On => database has been quiesced */
  5    35     2 o_db_open_sw bit (1) unal,			/* On => old database has been opened */
  5    36     2 n_db_open_sw bit (1) unal,			/* On => temp database is open */
  5    37     2 listing_seg_sw bit (1) unal,			/* On => listing segment has been created */
  5    38     2 skip_scanner_conversion bit (1) unal,		/* Skip conversion in scanner */
  5    39     2 cmdb_option bit (1) unal,			/* ON => this is a cmdb source, not restructuring */
  5    40     2 trace_sw bit (1) unal,				/* On -> trace mode in affect */
  5    41     2 debug_sw bit (1) unal,				/* On = debug mode (NOT IMPLEMENTED) */
  5    42     2 meter_sw bit (1) unal,				/* On = procedures call metering procedure */
  5    43     2 delete_db_sw bit (1) unal,			/* On = delete data base in cleanup */
  5    44     2 model_consistent_sw bit (1) unal,			/* On => Model is consistent */
  5    45     2 physical_started_sw bit (1) unal,			/* On => Physical restructuring started */
  5    46     2 physical_complete_sw bit (1) unal,		/* On => Physical restructuring completed */
  5    47     2 model_overflow bit (1) unal,			/* ON => model segment area condition occurred */
  5    48     2 max_files bit (1) unal,				/* ON => maximum number of files reached */
  5    49     2 allow_foreign_keys bit (1) unal,			/* on => allow foreign key statment */
  5    50     2 foreign_key_seen bit (1) unal,			/* on => foreign key definition in source */
  5    51     2 allow_blocked_files bit (1) unal,			/* on => allow file statement with blocked option */
  5    52     2 blocked_file_seen bit (1) unal,			/* on => blocked file definition in source */
  5    53     2 allow_restructuring bit (1) unal,			/* on => allow RMDB entry point */
  5    54     2 command_level bit (1) unal,			/* on => called from command unal, not subroutine level */
  5    55     2 secure bit (1) unal,				/* on => -secure option given for cmdb */
  5    56     2 max_attrs bit (1) unal,				/* on => max attrs/rel or max indexes/rel exceeded */
  5    57     2 db_relation_mode_flags,
  5    58       3 dm_file_type bit (1) unal,			/* on => relations are dm files */
  5    59       3 protection_on bit (1) unal,			/* on => relations need transactions */
  5    60       3 concurrency_on bit (1) unal,			/* on => concurrency control enabled */
  5    61       3 rollback_on bit (1) unal,			/* on => before journalling is enabled */
  5    62     2 severity_high fixed bin,			/* Highest severity level error encountered */
  5    63     2 phase fixed bin,				/* 000 = init
  5    64*						   100 = global list init
  5    65*						   200 = parse
  5    66*						   300 = physical init
  5    67*						   400 = physical */
  5    68     2 h_o_seg_info_ls_ptr ptr,			/* Pointer to head of old db seg_info list */
  5    69     2 h_n_seg_info_ls_ptr ptr,			/* Pointer to head of new db seg_info list */
  5    70     2 h_gfile_ptr ptr,				/* Pointer to head of global file list */
  5    71     2 h_gdom_ptr ptr,				/* Pointer to head of global domain list */
  5    72     2 h_gattr_ptr ptr,				/* Pointer to head of global attribute list */
  5    73     2 h_grel_ptr ptr,				/* Pointer to head of global relation list */
  5    74     2 h_glink_ptr ptr,				/* Pointer to head of global link list */
  5    75     2 o_dm_ptr ptr,					/* Pointer to old data model seg  (dm_model ) */
  5    76     2 n_dm_ptr ptr,					/* Pointer to temp data model seg */
  5    77     2 o_fn_hdr_ptr ptr,				/* Pointer to head of original file list (fn structure) */
  5    78     2 source_seg_ptr ptr,				/* Pointer to source_seg */
  5    79     2 listing_iocb_ptr ptr,				/* Pointer to listing segment iocb */
  5    80     2 directive_ptr ptr,				/* Pointer to directive type str in mrds_rst_semactics.incl.pl1 */
  5    81     2 stmt_ptr ptr,					/* Pointer to statement str in mrds_rst_sematics.incl.pl1 */
  5    82     2 trace_metering_iocb_ptr ptr,			/* Pointer to seg used by trace and metering */
  5    83     2 tree_node_area_ptr ptr,				/* pointer to working storage for tree nodes */
  5    84     2 tree_data,
  5    85       3 seg_info_area_ptr ptr,			/* seg info working storage area */
  5    86       3 gl_area_ptr ptr,				/* global list data work storage area */
  5    87       3 sl_area_ptr ptr,				/* sublist data work storage area */
  5    88     2 parse_info_area_ptr ptr,			/* parse interface work area storage */
  5    89     2 static_info_area_ptr ptr,			/* directive, stmt and other static work storage area */
  5    90     2 variable_length_area_ptr ptr,			/* varibale allocates work storage area */
  5    91     2 other_area_ptr ptr,				/* unspecified work area storage */
  5    92     2 wa area (sys_info$max_seg_size - fixed (rel (addr (rsc.wa))) + 1); /* Work area */
  5    93 
  5    94 dcl  rsc_ptr ptr;					/* Pointer to base of rsc segment */
  5    95 
  5    96 
  5    97 
  5    98 /* END INCLUDE FILE mrds_rst_rsc.incl.pl1				*/
  5    99 
      799 
      800 
  6     1 /* BEGIN INCLUDE FILE mrds_rst_struct_types.incl.pl1 - - Jim Gray 2/20/79 */
  6     2 
  6     3 /* these constants are used to identify structures to be allocated
  6     4*   to the general purpose allocation routines */
  6     5 
  6     6 /*  HISTORY:
  6     7*    82-06-28 Roger Lackey : Removed struct types 52, 53, 54, 55, 56, 57, 58
  6     8*    Type 25 is no longer used and is handled with special code so bounds of 
  6     9*    array could continue to work */
  6    10 
  6    11 /* PARSE INFO STRUCTURES */
  6    12 
  6    13 declare  DOMAIN fixed bin internal static options (constant) init (1) ;
  6    14 declare  ATTRIBUTE_DOMAIN fixed bin internal static options (constant) init (2) ;
  6    15 declare  RELATION fixed bin internal static options (constant) init (3) ;
  6    16 declare  ATTRIBUTE fixed bin internal static options (constant) init (4) ;
  6    17 declare  FILE fixed bin internal static options (constant) init (5) ;
  6    18 declare  ITEM fixed bin internal static options (constant) init (6) ;
  6    19 declare  LINK fixed bin internal static options (constant) init (7) ;
  6    20 declare  FOREIGN_KEY fixed bin internal static options (constant) init (8) ;
  6    21 declare  CHILDREN fixed bin internal static options (constant) init (9) ;
  6    22 declare  INDEX fixed bin internal static options (constant) init (10) ;
  6    23 declare  DELETE_NAME fixed bin internal static options (constant) init (11) ;
  6    24 declare  DOM_LIST fixed bin internal static options (constant) init (12) ; /* in link handler */
  6    25 
  6    26 /* SEMANTIC STRUCTURES */
  6    27 
  6    28 declare  DIRECTIVE fixed bin internal static options (constant) init (13) ;
  6    29 declare  STMT fixed bin internal static options (constant) init (14) ;
  6    30 
  6    31 
  6    32 /* PARSING STRUCTURES */
  6    33 
  6    34 declare  LEX_STACK fixed bin internal static options (constant) init (15) ;
  6    35 declare  P_STRUCT fixed bin internal static options (constant) init (16) ;
  6    36 declare  CUR_LEX_TOP fixed bin internal static options (constant) init (17) ;
  6    37 declare  FIXUP_TOKEN fixed bin internal static options (constant) init (50) ; /* scanner */
  6    38 declare  STRING_SOURCE fixed bin internal static options (constant) init (51) ; /* semantics */
  6    39 declare  TOKEN fixed bin internal static options (constant) init (18) ;
  6    40 declare  OUTPUT_TEXT fixed bin internal static options (constant) init (19) ;
  6    41 
  6    42 
  6    43 /* DB_MODEL STRUCTURES */
  6    44 
  6    45 declare  DB_MODEL fixed bin internal static options (constant) init (0) ;
  6    46 declare  FILE_INFO fixed bin internal static options (constant) init (1) ;
  6    47 declare  DOMAIN_INFO fixed bin internal static options (constant) init (2) ;
  6    48 declare  PATH_ENTRY fixed bin internal static options (constant) init (3) ;
  6    49 declare  STACK_ITEM fixed bin internal static options (constant) init (4) ;
  6    50 declare  CONSTANT fixed bin internal static options (constant) init (30) ;
  6    51 declare  VERSION_STATUS fixed bin internal static options (constant) init (5) ;
  6    52 declare  CHANGER fixed bin internal static options (constant) init (6) ;
  6    53 
  6    54 
  6    55 /* FILE_MODEL STRUCTURES */
  6    56 
  6    57 declare  FILE_MODEL fixed bin internal static options (constant) init (7) ;
  6    58 declare  REL_INFO fixed bin internal static options (constant) init (8) ;
  6    59 declare  ATTR_INFO fixed bin internal static options (constant) init (9) ;
  6    60 declare  PARENT_LINK_INFO fixed bin internal static options (constant) init (10) ;
  6    61 declare  CHILD_LINK_INFO fixed bin internal static options (constant) init (11) ;
  6    62 declare  ATTR_LIST fixed bin internal static options (constant) init (12) ;
  6    63 declare  ATD fixed bin internal static options (constant) init (31) ;
  6    64 declare  COMP_NO_ARRAY fixed bin internal static options (constant) init (32) ;
  6    65 declare  SORT_KEY fixed bin internal static options (constant) init (13) ;
  6    66 declare  DUP_PREV fixed bin internal static options (constant) init (14) ;
  6    67 declare  SELECT_CHAIN fixed bin internal static options (constant) init (15) ;
  6    68 
  6    69 
  6    70 /* GLOBAL LIST STRUCTURES */
  6    71 
  6    72 declare  GL fixed bin internal static options (constant) init (20) ;
  6    73 declare  SL fixed bin internal static options (constant) init (21) ;
  6    74 declare  SEGINFO fixed bin internal static options (constant) init (22) ;
  6    75 declare  LIST_OVRLY fixed bin internal static options (constant) init (26) ;
  6    76 declare  SAVED_CHILD_COUNT fixed bin internal static options (constant) init (24) ; /* in global list build */
  6    77 declare  NODE fixed bin internal static options (constant) init (23) ;
  6    78 
  6    79 
  6    80 /* DISPLAY STRUCTURES */
  6    81 
  6    82 declare  DISPLAY_INFO fixed bin internal static options (constant) init (25) ;
  6    83 
  6    84 /*   Remove because nolonger used 82-06-28        
  6    85*  NAME_LIST fixed bin internal static options (constant) init (52) ;
  6    86*  PAI_ARRAY fixed bin internal static options (constant) init (53) ;
  6    87*  PAR_LK_ATTR_INFO fixed bin internal static options (constant) init (54) ;
  6    88*  CAI_ARRAY fixed bin internal static options (constant) init (55) ;
  6    89*  CHILD_LK_ATTR_INFO fixed bin internal static options (constant) init (56) ;
  6    90*  NAME_TABLE fixed bin internal static options (constant) init (57) ;
  6    91*  ATTR_TABLE fixed bin internal static options (constant) init (58) ;
  6    92**/
  6    93 
  6    94 /* END INCULDE FILE mrds_rst_struct_types */
  6    95 
      801 
      802 
  7     1 /* BEGIN INCLUDE FILE mrds_rst_parse_info.incl.pl1 -- oris, 6/30/78 */
  7     2 /* modified 9/6/78 -- jeg, for lrk parser - cmdb interface */
  7     3 /* modified 12/20/78 - - jeg, to add line number info for handlers */
  7     4 /* modified 3/15/79 - - jeg, to add scanner, semantic, and link handler variables to be allocated in rsc */
  7     5 /* Modified by Jim Gray - - 23-June-80, to separate max_string_size,
  7     6*   and max_line_size mrds_data_ items. */
  7     7 
  7     8 
  7     9 
  7    10 
  7    11 declare 1 domain aligned based (domain_ptr),
  7    12         2 name char (32),				/* name of this domain */
  7    13         2 descriptor bit (36),			/* Multics pl1 descriptor for domain type */
  7    14         2 varying_avg_length fixed bin (24),		/* average length of varying strings */
  7    15         2 options bit (1) unal,			/* ON => some option is present */
  7    16         2 pad bit (35) unal,
  7    17         2 check,
  7    18 	3 flag bit (1) unal,			/* ON => check option present */
  7    19 	3 pad bit (35) unal,
  7    20 	3 stack_ptr ptr,				/* pointer to postfix stack
  7    21*						   holding boolean expression */
  7    22 	3 stack_size fixed binary,			/* number of stack elements */
  7    23         2 check_proc,
  7    24 	3 flag bit (1) unal,			/* ON => check_proc option is present */
  7    25 	3 pad bit (35) unal,
  7    26 	3 path char (168),				/* check procedure pathname */
  7    27 	3 entry char (32),				/* check procedure entryname */
  7    28         2 encode_proc,
  7    29 	3 flag bit (1) unal,			/* ON => encode_proc option is present */
  7    30 	3 pad bit (35) unal,
  7    31 	3 path char (168),				/* encode procedure pathname */
  7    32 	3 entry char (32),				/* encode procedure entryname */
  7    33         2 decode_proc,
  7    34 	3 flag bit (1) unal,			/* ON => decode_proc option is present */
  7    35 	3 pad bit (35) unal,
  7    36 	3 path char (168),				/* decode procedure pathname */
  7    37 	3 entry char (32),				/* decode procedure entryname */
  7    38         2 decode_dcl,
  7    39 	3 flag bit (1) unal,			/* ON => decode declaration is present */
  7    40 	3 pad bit (35) unal,
  7    41 	3 descriptor bit (36),			/* decode declaration pl1 descriptor */
  7    42         2 line_num fixed bin (24) ;			/* line of domain name in source */
  7    43 
  7    44 
  7    45 declare  domain_ptr ptr ;
  7    46 
  7    47 
  7    48 
  7    49 
  7    50 
  7    51 dcl 1 relation aligned based (relation_ptr),
  7    52     2 a_ptr ptr,					/* ptr to attribute list for this relation */
  7    53     2 name char (32),				/* relation name */
  7    54     2 max_tup fixed bin,				/* maximum tuples for this relation if a blocked file */
  7    55     2 num_items fixed bin,				/* number of attributes in this relation */
  7    56     2 unused bit (36) unal,				/* future flags */
  7    57     2 line_num fixed bin (24) ;			/* line of relation name in source */
  7    58 
  7    59 
  7    60 dcl  relation_ptr ptr;
  7    61 
  7    62 
  7    63 dcl 1 attribute aligned based (attribute_ptr),
  7    64     2 next ptr,					/* ptr to next in list */
  7    65     2 name char (32),				/* name of attribute */
  7    66     2 pr_key bit (1) unal,				/* ON => part of primary key */
  7    67     2 pad bit (35) unal,
  7    68     2 defn_order fixed bin,				/* position within the relation */
  7    69     2 key_order fixed bin,				/* position within the primary key, if a key */
  7    70     2 line_num fixed bin (24) ;			/* line of attribute name in source */
  7    71 
  7    72 
  7    73 dcl  attribute_ptr ptr;
  7    74 
  7    75 
  7    76 
  7    77 dcl 1 attribute_domain aligned based (attdom_ptr),
  7    78     2 attr char (32),				/* attribute name */
  7    79     2 dom char (32),				/* domain name */
  7    80     2 default bit (1) unal,				/* on => defined as default attr, not by source */
  7    81     2 unused bit (35) unal,				/* future flags */
  7    82     2 line_num fixed bin (24) ;			/* line of attribute name in source */
  7    83 
  7    84 dcl  attdom_ptr ptr;				/* ptr to attribute_domain structure */
  7    85 
  7    86 
  7    87 
  7    88 
  7    89 dcl 1 file aligned based (file_ptr),
  7    90     2 i_ptr ptr,					/* ptr to item containing relation name */
  7    91     2 name char (30),				/* file name */
  7    92     2 type fixed bin,				/* blocked or unblocked */
  7    93 						/* type = 1 => unblocked,
  7    94*						   type = 2 => blocked */
  7    95     2 ppb fixed bin,				/* pages per block, if blocked */
  7    96     2 hbh fixed bin,				/* hash bucket headers per block */
  7    97     2 block fixed bin,				/* blocks per hash bucket headers */
  7    98     2 num_items fixed bin,				/* nbr. items -- relations -- in file */
  7    99     2 default bit (1) unal,				/* on => defined as default file, not by source */
  7   100     2 unused bit (35) unal,				/* future flags */
  7   101     2 line_num fixed bin (24) ;			/* line of file name in source */
  7   102 
  7   103 
  7   104 dcl  file_ptr ptr;					/* ptr to file structure */
  7   105 
  7   106 
  7   107 dcl 1 rel_index aligned based (index_ptr),
  7   108     2 i_ptr ptr,					/* ptr. to item containing index attr. name */
  7   109     2 rel_name char (32),				/* name of relation being indexed */
  7   110     2 num_items fixed bin,				/* nbr. items -- attributes -- indexed for a relation */
  7   111     2 unused bit (36) unal,				/* future flags */
  7   112     2 line_num fixed bin (24) ;			/* line of relation name in source */
  7   113 
  7   114 
  7   115 dcl  index_ptr ptr;					/* ptr to index structure */
  7   116 
  7   117 
  7   118 dcl 1 link aligned based (link_ptr),
  7   119     2 parent_ptr ptr,				/* ptr to foreign_key structure cont. parent rel. name */
  7   120     2 children_ptr ptr,				/* ptr. to list of children names for this link */
  7   121     2 clust_fl bit (1) unal,				/* ON => link is clustered in one file */
  7   122     2 pad bit (35) unal,
  7   123     2 name char (32),				/* name of this link */
  7   124     2 num_children fixed bin,				/* number of children for this link's parent */
  7   125     2 line_num fixed bin (24) ;			/* line of link name occurence in source */
  7   126 
  7   127 
  7   128 dcl  link_ptr ptr;					/* ptr to link structure */
  7   129 
  7   130 
  7   131 dcl 1 children aligned based (children_ptr),
  7   132     2 next ptr,					/* ptr to next in list */
  7   133     2 child_ptr ptr;				/* ptr. to foreign_key struct. containing child rel. name */
  7   134 
  7   135 
  7   136 dcl  children_ptr ptr;				/* ptr to children structure */
  7   137 
  7   138 
  7   139 dcl 1 foreign_key aligned based (forkey_ptr),
  7   140     2 i_ptr ptr,					/* ptr to item list containing foreign key attributes */
  7   141     2 rel_name char (32),				/* name of parent/child relation */
  7   142     2 num_items fixed bin,				/* nbr of attributes defining this foreign key */
  7   143     2 unused bit (36) unal,				/* future flags */
  7   144     2 line_num fixed bin (24) ;			/* line of relation occurence in source */
  7   145 
  7   146 
  7   147 dcl  forkey_ptr ptr;				/* ptr to foreign_key structure */
  7   148 
  7   149 
  7   150 dcl 1 item aligned based (item_ptr),
  7   151     2 next ptr,					/* ptr to next item in the list */
  7   152     2 name char (32),				/* name of item -- relation name or attribute name */
  7   153     2 unused bit (36) unal,				/* future flags */
  7   154     2 line_num fixed bin (24) ;			/* line of item occurence in source */
  7   155 
  7   156 
  7   157 dcl  item_ptr ptr;					/* ptr to item structure */
  7   158 
  7   159 
  7   160 declare 1 delete_name aligned based (delete_name_ptr),	/* overlay for  undefine parse information */
  7   161         2 overlay char (32),				/* name portion */
  7   162         2 unused bit (36) unal,			/* future flags */
  7   163         2 line_num fixed bin (24) ;			/* line number of name occurence in source */
  7   164 
  7   165 declare  delete_name_ptr ptr ;
  7   166 
  7   167 /* scanner variables */
  7   168 
  7   169 declare  token char (mrds_data_$max_string_size) varying
  7   170          based (accum_token_ptr) ;			/* temp store for accumulating the token */
  7   171 declare  accum_token_ptr ptr internal static ;		/* pointer to allocated accumulator store */
  7   172 declare  mrds_data_$max_string_size fixed bin (35) external ; /* max token  size in chars */
  7   173 declare  mrds_data_$max_line_size fixed bin (35) ext ;	/* max output listing line size */
  7   174 declare  token_length fixed binary (24) ;		/* current length of token */
  7   175 declare  output_text char (mrds_data_$max_line_size) varying
  7   176          based (output_text_ptr) ;			/* body of text for this line in output listing */
  7   177 declare  output_text_ptr ptr internal static ;		/* pointer to allocated output line storage */
  7   178 declare  fixup_token char (token_length) based ;		/* saved fixed up version of token */
  7   179 
  7   180 /* semantic variables */
  7   181 
  7   182 declare  source_size fixed bin (35) ;			/* length of source char string for any_to_any */
  7   183 declare  string_source_ptr ptr ;			/* pointer to source for any_to_any conversion */
  7   184 declare  string_source char (source_size) based (string_source_ptr) ; /* storage for expanded string constant */
  7   185 
  7   186 /* link handler variable */
  7   187 
  7   188 declare  dom_list_ptr ptr ;				/* pointer to domain list element */
  7   189 declare 1 dom_list based (dom_list_ptr),		/* element of parent attr domain ptr list */
  7   190         2 next ptr,					/* pointer to next in order on list */
  7   191         2 attr_name char (32) aligned,			/* parent attr's name */
  7   192         2 dom_info_ptr ptr ;				/* parent attr's domain ptr */
  7   193 
  7   194 /* END INCLUDE FILE mrds_rst_parse_info.incl.pl1 */
  7   195 
      803 
      804 
      805      end;
      806 
      807 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/85  0909.3  mrds_rst_scanner.pl1              >special_ldd>online>mrds.pbf-04/18/85>mrds_rst_scanner.pl1
689          1    10/14/83  1608.9  mrds_rst_translate.incl.pl1       >ldd>include>mrds_rst_translate.incl.pl1
732          2    10/14/83  1609.0  mrds_rst_keywords.incl.pl1        >ldd>include>mrds_rst_keywords.incl.pl1
795          3    10/14/83  1608.4  mrds_rst_parse_stack.incl.pl1     >ldd>include>mrds_rst_parse_stack.incl.pl1
797          4    10/14/83  1608.9  mrds_rst_scan.incl.pl1            >ldd>include>mrds_rst_scan.incl.pl1
799          5    10/14/83  1609.1  mrds_rst_rsc.incl.pl1             >ldd>include>mrds_rst_rsc.incl.pl1
801          6    10/14/83  1609.0  mrds_rst_struct_types.incl.pl1    >ldd>include>mrds_rst_struct_types.incl.pl1
803          7    10/14/83  1608.6  mrds_rst_parse_info.incl.pl1      >ldd>include>mrds_rst_parse_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
A_PATH_ENTRY                           constant        fixed bin(17,0)          initial dcl 4-8 ref 289 550
CASE_END                               constant        fixed bin(17,0)          initial dcl 4-15 ref 136 149 166 177 186 195 207 218
CHECK_PROC                      000012 internal static fixed bin(17,0)          dcl 790 set ref 90* 267
CODE                            001445 constant        fixed bin(17,0)          initial array dcl 4-28 ref 514
DECODE_PROC                     000011 internal static fixed bin(17,0)          dcl 789 set ref 92* 267
DIGIT                                  constant        fixed bin(17,0)          initial dcl 4-6 ref 352
ENCODE_PROC                     000010 internal static fixed bin(17,0)          dcl 788 set ref 91* 267
ENTRY_NAME                             constant        fixed bin(17,0)          initial dcl 4-22 ref 541
EOF                                    constant        fixed bin(17,0)          initial dcl 4-12 ref 467 474 478 489 550 558 656
EOI                                    constant        fixed bin(17,0)          initial dcl 4-20 ref 210 517
FIXUP_TOKEN                     001444 constant        fixed bin(17,0)          initial dcl 6-37 set ref 436*
IDENTIFIER                             constant        fixed bin(17,0)          initial dcl 4-24 ref 262 273
INTEGER                                constant        fixed bin(17,0)          initial dcl 4-23 ref 369
NL                                     constant        fixed bin(17,0)          initial dcl 4-9 ref 282 286 468 470 480 550
NL_CHAR                                constant        char(1)                  initial unaligned dcl 677 ref 598
OUTPUT_TEXT                     001442 constant        fixed bin(17,0)          initial dcl 6-40 set ref 88*
PATH_NAME                              constant        fixed bin(17,0)          initial dcl 4-21 ref 534
SPECIAL                                constant        fixed bin(17,0)          initial dcl 4-7 ref 535
SPECIAL_LIST                    001456 constant        char(8)                  initial unaligned dcl 4-27 ref 273 513
START                                  constant        fixed bin(17,0)          initial dcl 4-14 ref 72
TOKEN                           001443 constant        fixed bin(17,0)          initial dcl 6-39 set ref 87*
WHITE_SPACE                            constant        fixed bin(17,0)          initial dcl 4-10 ref 282 284 550 635
accum_token_ptr                 000030 internal static pointer                  dcl 7-171 set ref 87* 105 260 330 330 398 416 418
                                                                                  435 437 447 449 449 450 454 497 513 518
addr                                                   builtin function         dcl 682 ref 597 613 613 651
addrel                                                 builtin function         dcl 786 ref 613 613
binary                                                 builtin function         dcl 786 ref 398 415
char                            000016 internal static char(1)                  unaligned dcl 4-34 set ref 89* 180* 189* 198* 205*
                                                                                  253 255* 284* 286* 289 330 354* 447 448* 449 464*
                                                                                  467 468* 470* 477* 478 481* 498* 533 542* 550 550
                                                                                  553*
char_bits                              based           bit(9)                   array unaligned dcl 687 ref 633 637 650
char_ptr                        000020 internal static pointer                  dcl 4-36 set ref 89* 180* 189* 205* 215 252 255*
                                                                                  284* 286* 344 354* 446 448* 468* 470* 477* 481*
                                                                                  498* 542* 549 553*
char_string                            based           char(1)                  array unaligned dcl 686 set ref 597 649 651
char_type                       000017 internal static fixed bin(17,0)          dcl 4-35 set ref 89* 125 180* 189* 205* 255* 282 282
                                                                                  284 284* 286 286* 289* 352 354* 448* 467 468 468*
                                                                                  470 470* 474 477* 478 480 481* 489 498* 535* 542*
                                                                                  550 550 550 550 553* 558
chr_ptr                                parameter       pointer                  dcl 670 set ref 580 590 629 646 651*
chr_val                                parameter       char(1)                  unaligned dcl 668 set ref 580 590 629 646 649* 657*
code                            000227 automatic       fixed bin(35,0)          dcl 784 set ref 613* 615
comment_end                     000113 automatic       bit(1)                   unaligned dcl 754 set ref 463* 465 474* 479*
conversion                      000000 stack reference condition                dcl 764 ref 394
copy                                                   builtin function         dcl 786 ref 414
encodement                             parameter       fixed bin(17,0)          dcl 740 set ref 692 723* 725*
encoding                        000100 automatic       fixed bin(17,0)          dcl 745 set ref 210* 237 244 260* 261 262* 267 267
                                                                                  267 273* 369* 514* 517* 534* 541*
err_ptr                                parameter       pointer                  dcl 776 ref 80 86
fixed                                                  builtin function         dcl 779 ref 398 415 633 637 650
fixed_value                     000106 automatic       fixed bin(71,0)          dcl 751 set ref 114* 238 398* 415* 416*
fixedoverflow                   000000 stack reference condition                dcl 764 ref 391
fixup_done                      000226 automatic       bit(1)                   unaligned dcl 783 set ref 343* 379 412*
fixup_token                            based           char                     unaligned dcl 7-178 set ref 437*
float                    10            based           float bin(63)            array level 2 dcl 3-3 set ref 239*
float_value                     000110 automatic       float bin(63)            dcl 752 set ref 115* 239
good_char                       000102 automatic       bit(1)                   unaligned dcl 748 set ref 280* 281 282*
hbound                                                 builtin function         dcl 738 ref 703
high                            000357 automatic       fixed bin(17,0)          dcl 736 set ref 703* 704 711 715* 717
index                                                  builtin function         dcl 774 ref 253 273 513 598
ioa_$rs                         000046 constant        entry                    external dcl 757 ref 198 293 318 416 454 491 518 560
                                                                                  617
iox_$put_chars                  000074 constant        entry                    external dcl 785 ref 613
keyword                         000012 constant        structure                array level 1 unaligned dcl 2-6 ref 702 703
lbound                                                 builtin function         dcl 738 ref 702
length                                                 builtin function         dcl 786 ref 435 613 613
lex_stack                              based           structure                array level 1 unaligned dcl 3-3
lex_stack_ptr                          parameter       pointer                  dcl 3-15 ref 37 234 235 236 237 238 239 240 241 242
line                      3            based           fixed bin(24,0)          array level 2 dcl 3-3 set ref 236*
line_length                     000025 internal static fixed bin(24,0)          dcl 4-39 set ref 241 598* 599 600* 611
line_no_pic                     000224 automatic       picture(7)               unaligned dcl 781 set ref 610* 611
line_number                     000024 internal static fixed bin(24,0)          dcl 4-38 set ref 198* 236 279 318* 416* 454* 491*
                                                                                  518* 560* 585* 602* 602 610 617*
line_ptr                        000022 internal static pointer                  dcl 4-37 set ref 240 597* 598 611
line_size                14            based           fixed bin(24,0)          array level 2 dcl 3-3 set ref 241*
line_strt                12            based           pointer                  array level 2 dcl 3-3 set ref 240*
listing_iocb_ptr        240            based           pointer                  level 2 dcl 5-29 set ref 613*
listing_seg_sw          206(04)        based           bit(1)                   level 2 packed unaligned dcl 5-29 ref 605
low                             000356 automatic       fixed bin(17,0)          dcl 735 set ref 702* 704 711 713* 717
mantissa_end                    000103 automatic       bit(1)                   unaligned dcl 749 set ref 348* 350 358*
message                         000114 automatic       varying char(256)        dcl 758 set ref 198* 204 293* 296 318* 321 416* 420
                                                                                  454* 456 491* 493 518* 520 560* 562 617* 619
message_length                  000215 automatic       fixed bin(17,0)          dcl 759 set ref 198* 293* 318* 416* 454* 491* 518*
                                                                                  560* 617*
middle                          000360 automatic       fixed bin(17,0)          dcl 737 set ref 704* 711 713 713 715 717* 723 723
mrds_data_$max_line_size        000102 external static fixed bin(35,0)          dcl 7-173 ref 611
mrds_data_$max_string_size      000100 external static fixed bin(35,0)          dcl 7-172 set ref 105 260 318* 330 416 418 447 454
                                                                                  497 518
mrds_data_$valid_id_chars       000076 external static varying char(128)        dcl 791 ref 253
mrds_error_$rst_bad_encoding    000070 external static fixed bin(35,0)          dcl 772 set ref 520*
mrds_error_$rst_comment_ends_source
                                000064 external static fixed bin(35,0)          dcl 770 set ref 493*
mrds_error_$rst_conversion_error
                                000060 external static fixed bin(35,0)          dcl 768 set ref 420*
mrds_error_$rst_illegal_char    000066 external static fixed bin(35,0)          dcl 771 set ref 204* 456*
mrds_error_$rst_io_error        000062 external static fixed bin(35,0)          dcl 769 set ref 619*
mrds_error_$rst_missing_pathname
                                000056 external static fixed bin(35,0)          dcl 767 set ref 296*
mrds_error_$rst_pathname_ends_source
                                000054 external static fixed bin(35,0)          dcl 766 set ref 562*
mrds_error_$rst_token_too_long  000052 external static fixed bin(35,0)          dcl 765 set ref 321*
mrds_rst_error                  000050 constant        entry                    external dcl 760 ref 204 296 321 420 456 493 520 562
                                                                                  619
mrds_rst_rsc_alloc              000044 constant        entry                    external dcl 756 ref 87 88
mrds_rst_rsc_alloc$variable     000042 constant        entry                    external dcl 755 ref 436
mrds_rst_translate              000442 constant        fixed bin(17,0)          initial array dcl 1-6 ref 633 637 650
name                            000012 constant        varying char(18)         initial array level 2 dcl 2-6 ref 711 713 723
number_found                    000217 automatic       bit(1)                   unaligned dcl 762 set ref 365* 382
output_text                            based           varying char             dcl 7-175 set ref 611* 613 613 613 613
output_text_ptr                 000032 internal static pointer                  dcl 7-177 set ref 88* 611 613 613 613 613
overflow                        000000 stack reference condition                dcl 764 ref 392
pos                             000034 internal static fixed bin(24,0)          initial dcl 674 set ref 584* 592 597 598 600 631 633
                                                                                  635 636* 636 637 648 649 650 651 652* 652
previous_token_type             000013 internal static fixed bin(17,0)          initial dcl 792 set ref 244* 273
radix_found                     000104 automatic       bit(1)                   unaligned dcl 750 set ref 349*
result                          000216 automatic       bit(1)                   unaligned dcl 761 set ref 450* 453* 500* 504
rsc                                    based           structure                level 1 unaligned dcl 5-29
s_seg_len                              parameter       fixed bin(24,0)          dcl 666 ref 580 583
s_seg_ptr                              parameter       pointer                  dcl 665 ref 580 582
seg_len                         000040 internal static fixed bin(24,0)          initial dcl 676 set ref 583* 592 598 600 631 635 648
seg_ptr                         000036 internal static pointer                  initial dcl 675 set ref 582* 597 633 637 649 650 651
size                            000000 stack reference condition                dcl 764 ref 390
skip_scanner_conversion
                        206(05)        based           bit(1)                   level 2 packed unaligned dcl 5-29 ref 373
source                                 based           char                     unaligned dcl 782 ref 598 611
source_length                          parameter       fixed bin(24,0)          dcl 777 set ref 80 89*
source_seg_ptr                         parameter       pointer                  dcl 775 set ref 80 89*
special_index                   000222 automatic       fixed bin(17,0)          dcl 773 set ref 513* 514 514
stack_index                            parameter       fixed bin(24,0)          dcl 744 ref 37 234 235 236 237 238 239 240 241 242
static_rsc_ptr                  000014 internal static pointer                  dcl 4-32 set ref 86* 87* 88* 204* 296* 321* 373 420*
                                                                                  436* 456* 493* 520* 562* 605 613 619*
stringsize                      000000 stack reference condition                dcl 747 ref 310
substr                                                 builtin function         dcl 786 ref 598 611
symbol                    4            based           fixed bin(24,0)          array level 2 dcl 3-3 set ref 237*
symbol_found                    000112 automatic       bit(1)                   unaligned dcl 753 set ref 116* 124 135* 147* 164*
                                                                                  176* 185* 194* 206* 217* 499*
symlen                    2            based           fixed bin(24,0)          array level 2 dcl 3-3 set ref 235*
symptr                                 based           pointer                  array level 2 dcl 3-3 set ref 234*
sys_info$max_seg_size           000072 external static fixed bin(35,0)          dcl 778 ref 598 611
temp_line_number                000223 automatic       fixed bin(21,0)          dcl 780 set ref 279* 293*
temp_token                      000230 automatic       varying char(96)         dcl 787 set ref 414* 415 418
token                                  based           varying char             dcl 7-169 in procedure "mrds_rst_scanner" set ref
                                                                                  105* 260* 330* 330 398 416* 418* 435 437 447* 449
                                                                                  449 450 454* 497* 513 518*
token                                  parameter       varying char             dcl 739 in procedure "keyword_lookup" ref 692 711
                                                                                  713 723
token_count                     000026 internal static fixed bin(24,0)          dcl 4-40 set ref 198 230* 230 242 293 454 560 603*
token_length                    000261 automatic       fixed bin(24,0)          dcl 7-174 set ref 113* 235 331* 331 435* 436 437
                                                                                  512* 552* 552
token_num                15            based           fixed bin(24,0)          array level 2 dcl 3-3 set ref 242*
token_ptr                       000220 automatic       pointer                  dcl 763 set ref 215* 234 252* 344* 436* 437 446*
                                                                                  549*
token_too_long_seen             000101 automatic       bit(1)                   unaligned dcl 746 set ref 117* 315 317*
type                                   parameter       fixed bin(17,0)          dcl 669 set ref 580 590 629 633* 635 637* 646 650*
                                                                                  656*
underflow                       000000 stack reference condition                dcl 764 ref 393
val                       6            based           fixed bin(71,0)          array level 2 dcl 3-3 set ref 238*
value                     6     000012 constant        fixed bin(24,0)          initial array level 2 dcl 2-6 ref 723

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ATD                                    internal static fixed bin(17,0)          initial dcl 6-63
ATTRIBUTE                              internal static fixed bin(17,0)          initial dcl 6-16
ATTRIBUTE_DOMAIN                       internal static fixed bin(17,0)          initial dcl 6-14
ATTR_INFO                              internal static fixed bin(17,0)          initial dcl 6-59
ATTR_LIST                              internal static fixed bin(17,0)          initial dcl 6-62
CHANGER                                internal static fixed bin(17,0)          initial dcl 6-52
CHILDREN                               internal static fixed bin(17,0)          initial dcl 6-21
CHILD_LINK_INFO                        internal static fixed bin(17,0)          initial dcl 6-61
COMP_NO_ARRAY                          internal static fixed bin(17,0)          initial dcl 6-64
CONSTANT                               internal static fixed bin(17,0)          initial dcl 6-50
CUR_LEX_TOP                            internal static fixed bin(17,0)          initial dcl 6-36
DB_MODEL                               internal static fixed bin(17,0)          initial dcl 6-45
DELETE_NAME                            internal static fixed bin(17,0)          initial dcl 6-23
DIRECTIVE                              internal static fixed bin(17,0)          initial dcl 6-28
DISPLAY_INFO                           internal static fixed bin(17,0)          initial dcl 6-82
DOMAIN                                 internal static fixed bin(17,0)          initial dcl 6-13
DOMAIN_INFO                            internal static fixed bin(17,0)          initial dcl 6-47
DOM_LIST                               internal static fixed bin(17,0)          initial dcl 6-24
DUP_PREV                               internal static fixed bin(17,0)          initial dcl 6-66
FILE                                   internal static fixed bin(17,0)          initial dcl 6-17
FILE_INFO                              internal static fixed bin(17,0)          initial dcl 6-46
FILE_MODEL                             internal static fixed bin(17,0)          initial dcl 6-57
FOREIGN_KEY                            internal static fixed bin(17,0)          initial dcl 6-20
GL                                     internal static fixed bin(17,0)          initial dcl 6-72
ILLEGAL                                internal static fixed bin(17,0)          initial dcl 4-11
INDEX                                  internal static fixed bin(17,0)          initial dcl 6-22
ITEM                                   internal static fixed bin(17,0)          initial dcl 6-18
LETTER                                 internal static fixed bin(17,0)          initial dcl 4-5
LEX_STACK                              internal static fixed bin(17,0)          initial dcl 6-34
LINK                                   internal static fixed bin(17,0)          initial dcl 6-19
LIST_OVRLY                             internal static fixed bin(17,0)          initial dcl 6-75
NODE                                   internal static fixed bin(17,0)          initial dcl 6-77
PARENT_LINK_INFO                       internal static fixed bin(17,0)          initial dcl 6-60
PATH_ENTRY                             internal static fixed bin(17,0)          initial dcl 6-48
P_STRUCT                               internal static fixed bin(17,0)          initial dcl 6-35
RELATION                               internal static fixed bin(17,0)          initial dcl 6-15
REL_INFO                               internal static fixed bin(17,0)          initial dcl 6-58
SAVED_CHILD_COUNT                      internal static fixed bin(17,0)          initial dcl 6-76
SEGINFO                                internal static fixed bin(17,0)          initial dcl 6-74
SELECT_CHAIN                           internal static fixed bin(17,0)          initial dcl 6-67
SL                                     internal static fixed bin(17,0)          initial dcl 6-73
SORT_KEY                               internal static fixed bin(17,0)          initial dcl 6-65
STACK_ITEM                             internal static fixed bin(17,0)          initial dcl 6-49
STMT                                   internal static fixed bin(17,0)          initial dcl 6-29
STRING_SOURCE                          internal static fixed bin(17,0)          initial dcl 6-38
VERSION_STATUS                         internal static fixed bin(17,0)          initial dcl 6-51
addr                                                   builtin function         dcl 779
attdom_ptr                             automatic       pointer                  dcl 7-84
attribute                              based           structure                level 1 dcl 7-63
attribute_domain                       based           structure                level 1 dcl 7-77
attribute_ptr                          automatic       pointer                  dcl 7-73
children                               based           structure                level 1 dcl 7-131
children_ptr                           automatic       pointer                  dcl 7-136
cur_lex_top                            based           fixed bin(24,0)          array dcl 3-27
cur_lex_top_ptr                        automatic       pointer                  dcl 3-29
debug_sw                               internal static bit(1)                   initial unaligned dcl 3-17
delete_name                            based           structure                level 1 dcl 7-160
delete_name_ptr                        automatic       pointer                  dcl 7-165
dom_list                               based           structure                level 1 unaligned dcl 7-189
dom_list_ptr                           automatic       pointer                  dcl 7-188
domain                                 based           structure                level 1 dcl 7-11
domain_ptr                             automatic       pointer                  dcl 7-45
file                                   based           structure                level 1 dcl 7-89
file_ptr                               automatic       pointer                  dcl 7-104
foreign_key                            based           structure                level 1 dcl 7-139
forkey_ptr                             automatic       pointer                  dcl 7-147
index_ptr                              automatic       pointer                  dcl 7-115
item                                   based           structure                level 1 dcl 7-150
item_ptr                               automatic       pointer                  dcl 7-157
link                                   based           structure                level 1 dcl 7-118
link_ptr                               automatic       pointer                  dcl 7-128
p_struct                               based           structure                array level 1 dcl 3-19
p_struct_ptr                           automatic       pointer                  dcl 3-24
rel                                                    builtin function         dcl 779
rel_index                              based           structure                level 1 dcl 7-107
relation                               based           structure                level 1 dcl 7-51
relation_ptr                           automatic       pointer                  dcl 7-60
rsc_ptr                                automatic       pointer                  dcl 5-94
source_size                            automatic       fixed bin(35,0)          dcl 7-182
string_source                          based           char                     unaligned dcl 7-184
string_source_ptr                      automatic       pointer                  dcl 7-183

NAMES DECLARED BY EXPLICIT CONTEXT.
SKIP_CONVERT                    003530 constant        label                    dcl 402 ref 423
add_char_to_token               003066 constant        entry                    internal dcl 305 ref 254 353
binary_conversion               003356 constant        entry                    internal dcl 384 ref 374
comment_skip                    004002 constant        entry                    internal dcl 442 ref 152
encode_special                  004513 constant        entry                    internal dcl 508 ref 162
fixup_conversion                003532 constant        entry                    internal dcl 408 ref 390 391 392 393 394
get_first_char                  005451 constant        label                    dcl 645 ref 625
get_next_char                   005453 constant        entry                    internal dcl 646 ref 205 255 354 448 477 542 553
get_next_char_init              005104 constant        entry                    internal dcl 580 ref 89
get_next_char_new_line          005127 constant        entry                    internal dcl 590 ref 180 286 470 481
get_next_char_non_white         005401 constant        entry                    internal dcl 629 ref 189 284 468 498
get_next_character_routine      005102 constant        entry                    internal dcl 568
identifier_handler              002550 constant        entry                    internal dcl 247 ref 128
keyword_lookup                  005522 constant        entry                    internal dcl 692 ref 90 91 92 260
mrds_rst_scanner                001773 constant        entry                    external dcl 37
mrds_rst_scanner$init           002006 constant        entry                    external dcl 80
number_convert                  003263 constant        entry                    internal dcl 338 ref 139
path_entry_handler              004660 constant        entry                    internal dcl 525 ref 170
stack_put                       002472 constant        entry                    internal dcl 226 ref 134 146 163 175 216
state                           000000 constant        label                    array(0:9) dcl 105 ref 72 125 136 149 166 177 186
                                                                                  195 207 218
substitute_fixup_token          003750 constant        entry                    internal dcl 431 ref 380
truncate_token                  003262 constant        label                    dcl 333 ref 324

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6220        6324    5641        6230
Length      7034    5641       104         473     356          32

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_rst_scanner                    638 external procedure  is an external procedure.  
stack_put                               internal procedure  shares stack frame of external procedure mrds_rst_scanner.  
identifier_handler                      internal procedure  shares stack frame of external procedure mrds_rst_scanner.  
add_char_to_token                    70 internal procedure  enables or reverts conditions.  
on unit on line 310                 132 on unit               
number_convert                          internal procedure  shares stack frame of external procedure mrds_rst_scanner.  
binary_conversion                   252 internal procedure  enables or reverts conditions.  
on unit on line 390                  64 on unit               
on unit on line 391                  64 on unit               
on unit on line 392                  64 on unit               
on unit on line 393                  64 on unit               
on unit on line 394                  64 on unit               
fixup_conversion                    276 internal procedure  is called by several nonquick procedures.  
substitute_fixup_token                  internal procedure  shares stack frame of external procedure mrds_rst_scanner.  
comment_skip                            internal procedure  shares stack frame of external procedure mrds_rst_scanner.  
encode_special                          internal procedure  shares stack frame of external procedure mrds_rst_scanner.  
path_entry_handler                      internal procedure  shares stack frame of external procedure mrds_rst_scanner.  
get_next_character_routine              internal procedure  shares stack frame of external procedure mrds_rst_scanner.  
keyword_lookup                          internal procedure  shares stack frame of external procedure mrds_rst_scanner.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 ENCODE_PROC                 mrds_rst_scanner
000011 DECODE_PROC                 mrds_rst_scanner
000012 CHECK_PROC                  mrds_rst_scanner
000013 previous_token_type         mrds_rst_scanner
000014 static_rsc_ptr              mrds_rst_scanner
000016 char                        mrds_rst_scanner
000017 char_type                   mrds_rst_scanner
000020 char_ptr                    mrds_rst_scanner
000022 line_ptr                    mrds_rst_scanner
000024 line_number                 mrds_rst_scanner
000025 line_length                 mrds_rst_scanner
000026 token_count                 mrds_rst_scanner
000030 accum_token_ptr             mrds_rst_scanner
000032 output_text_ptr             mrds_rst_scanner
000034 pos                         get_next_character_routine
000036 seg_ptr                     get_next_character_routine
000040 seg_len                     get_next_character_routine

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_rst_scanner         000100 encoding                    mrds_rst_scanner
                         000101 token_too_long_seen         mrds_rst_scanner
                         000102 good_char                   mrds_rst_scanner
                         000103 mantissa_end                mrds_rst_scanner
                         000104 radix_found                 mrds_rst_scanner
                         000106 fixed_value                 mrds_rst_scanner
                         000110 float_value                 mrds_rst_scanner
                         000112 symbol_found                mrds_rst_scanner
                         000113 comment_end                 mrds_rst_scanner
                         000114 message                     mrds_rst_scanner
                         000215 message_length              mrds_rst_scanner
                         000216 result                      mrds_rst_scanner
                         000217 number_found                mrds_rst_scanner
                         000220 token_ptr                   mrds_rst_scanner
                         000222 special_index               mrds_rst_scanner
                         000223 temp_line_number            mrds_rst_scanner
                         000224 line_no_pic                 mrds_rst_scanner
                         000226 fixup_done                  mrds_rst_scanner
                         000227 code                        mrds_rst_scanner
                         000230 temp_token                  mrds_rst_scanner
                         000261 token_length                mrds_rst_scanner
                         000356 low                         keyword_lookup
                         000357 high                        keyword_lookup
                         000360 middle                      keyword_lookup

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              tra_ext             enable              shorten_stack       ext_entry           int_entry
trunc_fx2           stringsize          set_cs_eis          index_cs_eis        any_to_any_tr       divide_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_$rs                       iox_$put_chars                mrds_rst_error                mrds_rst_rsc_alloc
mrds_rst_rsc_alloc$variable

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mrds_data_$max_line_size      mrds_data_$max_string_size    mrds_data_$valid_id_chars     mrds_error_$rst_bad_encoding
mrds_error_$rst_comment_ends_source                         mrds_error_$rst_conversion_error
mrds_error_$rst_illegal_char  mrds_error_$rst_io_error      mrds_error_$rst_missing_pathname
mrds_error_$rst_pathname_ends_source                        mrds_error_$rst_token_too_long
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     37 001767        72 002000        80 002002        86 002013        87 002020        88 002032        89 002045
     90 002065        91 002107        92 002131        94 002153       105 002154       113 002156       114 002157
    115 002161       116 002163       117 002164       124 002165       125 002170       128 002173       134 002174
    135 002175       136 002177       139 002201       146 002213       147 002214       149 002216       152 002220
    162 002226       163 002227       164 002230       166 002232       170 002234       175 002235       176 002236
    177 002240       180 002242       185 002255       186 002256       189 002260       194 002273       195 002274
    198 002276       204 002400       205 002437       206 002453       207 002454       210 002456       215 002460
    216 002463       217 002464       218 002466       221 002470       224 002471       226 002472       230 002473
    234 002475       235 002504       236 002511       237 002516       238 002523       239 002530       240 002532
    241 002534       242 002540       244 002545       245 002547       247 002550       252 002551       253 002554
    254 002570       255 002574       256 002607       260 002610       261 002630       262 002633       267 002635
    273 002644       279 002661       280 002663       281 002664       282 002666       284 002677       286 002714
    288 002730       289 002731       293 002741       296 003024       299 003063       303 003064       305 003065
    310 003073       315 003107       317 003114       318 003116       321 003200       322 003241       324 003242
    330 003245       331 003260       333 003262       338 003263       343 003265       344 003266       348 003271
    349 003272       350 003273       352 003276       353 003302       354 003306       355 003321       358 003322
    360 003324       365 003325       369 003327       373 003331       374 003337       379 003343       380 003346
    382 003347       384 003355       390 003363       391 003405       392 003427       393 003451       394 003473
    398 003515       402 003530       408 003531       412 003537       414 003543       415 003562       416 003573
    418 003672       420 003706       423 003744       431 003750       435 003751       436 003754       437 003771
    440 004001       442 004002       446 004004       447 004007       448 004020       449 004032       450 004052
    453 004061       454 004063       456 004167       457 004226       458 004227       463 004230       464 004231
    465 004233       467 004236       468 004246       470 004262       472 004300       474 004301       477 004307
    478 004321       479 004332       480 004334       481 004340       484 004352       489 004353       491 004360
    493 004426       495 004465       497 004466       498 004470       499 004502       500 004503       504 004505
    508 004513       512 004514       513 004516       514 004527       517 004533       518 004535       520 004617
    521 004656       523 004657       525 004660       533 004661       534 004666       535 004670       536 004672
    541 004673       542 004675       549 004707       550 004712       552 004732       553 004733       554 004745
    558 004746       560 004752       562 005041       564 005100       566 005101       568 005102       580 005103
    582 005114       583 005121       584 005123       585 005125       590 005126       592 005137       597 005144
    598 005151       599 005166       600 005170       602 005173       603 005174       605 005175       610 005202
    611 005212       613 005244       615 005270       617 005273       619 005340       621 005377       625 005400
    629 005401       631 005411       633 005415       635 005426       636 005435       637 005436       638 005450
    645 005451       646 005452       648 005463       649 005467       650 005474       651 005504       652 005511
    653 005512       656 005513       657 005515       661 005521       692 005522       702 005533       703 005535
    704 005537       711 005546       713 005565       715 005600       717 005603       719 005613       723 005614
    725 005626       742 005627


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
