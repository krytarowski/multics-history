	COMPILATION LISTING OF SEGMENT hasp_host_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/17/88  1038.7 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* I/O Module for communications with a HASP host: This I/O module is designed
       14*   for use by the I/O daemon's workstation simulator (hasp_ws_sim_driver_).  
       15*   It communicates with the HASP host through a TTY channel controlled by the 
       16*   ring-0 HASP demultiplexer.
       17*
       18*   As each TTY channel connected through the HASP demultiplexer communicates 
       19*   with only a single device of the physical HASP host, this I/O module will
       20*   ensure that all I/O switches attached to a given channel have the same
       21*   device type.  (Multiple I/O switches are allowed to support multiple 
       22*   request types being attached to the same channel.) 
       23*
       24*   Note: The signon_record control order does not validate that supplied IPC
       25*         channel is an event-wait channel */
       26 
       27 
       28 /****^  HISTORY COMMENTS:
       29*  1) change(80-02-01,GPalter), approve(), audit(), install():
       30*     Created.
       31*     Modified: 1 September 1980 by G. Palter to remove stream mode support.
       32*     Modified: 2 December 1980 by G. Palter to properly set return code for
       33*        io_call control order.
       34*     Modified: 18 December 1980 by G. Palter to support -terminal_type for
       35*        input/output translations.
       36*     Modified: 13 January 1981 by G. Palter to pass the representation of a
       37*        space in the transmission medium's character code to hasp_util_.
       38*     Modified: 22 July 1981 by G. Palter to convert to version 2
       39*        dial_manager_, invoke release_channel when done with a particular
       40*        channel, and convert -signon/-no_signon from attach parameters to
       41*        control orders.
       42*     Modified: 26 July 1982 by G. Palter to add get_channel_info control order.
       43*     Modified: October 1982 by G. Palter to drastically improve write_record
       44*        performance by changing the order of calls to hcs_$tty_order,
       45*        hcs_$tty_write, and ipc_$block and to use mvt_ rather than the PL/I
       46*        translate builtin where appropriate.
       47*     Modified: 14 December 1982 by G. Palter to fix bugs in the read_record
       48*        entrypoint's handling of partial or very long input records
       49*        (HASP #001 and HASP #002) and to insure proper behavior of the
       50*        read_record entrypoint when the input record will not fit in the
       51*        caller's buffer.
       52*  2) change(87-03-17,LJAdams), approve(87-04-03,MCR7646),
       53*     audit(87-05-05,Gilcrease), install(87-05-14,MR12.1-1030):
       54*     Changed ttd_version to ttd_version_3.
       55*                                                   END HISTORY COMMENTS */
       56 
       57 
       58 /* format: on,style4,delnl,insnl,ifthenstmt,ifthen */
       59 
       60 hasp_host_:
       61      procedure ();
       62 
       63 	return;					/* not an entry */
       64 
       65 
       66 /* Parameters */
       67 
       68 dcl  P_iocb_ptr pointer parameter;			/* *: -> I/O switch being operated upon */
       69 dcl  P_code fixed binary (35) parameter;
       70 
       71 dcl  P_attach_options (*) character (*) varying parameter;	/* attach: attachment arguments */
       72 dcl  P_loud_sw bit (1) parameter;			/* attach: ON => attachment errors should call com_err_ */
       73 
       74 dcl  P_open_mode fixed binary parameter;		/* open: opening mode */
       75 dcl  P_open_sw bit (1) parameter;			/* open: obsolete parameter */
       76 
       77 dcl  P_record_lth fixed binary (21) parameter;		/* read_record: set to size of terminal_io_record read into
       78*						   buffer in characters;
       79*						   get_chars: set to # of characters read into buffer;
       80*						   write_record, put_chars: size of terminal_io_record to be
       81*						   written in characters */
       82 
       83 dcl  P_buffer_ptr pointer parameter;			/* read_record, get_chars: -> area to place result of read */
       84 dcl  P_buffer_lth fixed binary (21) parameter;		/* read_record, get_chars: size of area in characters */
       85 
       86 dcl  P_record_ptr pointer parameter;			/* write_record, put_chars: -> terminal_io_record
       87*						   to be written */
       88 
       89 dcl  P_order character (*) parameter;			/* control: name of control order to be performed */
       90 dcl  P_info_ptr pointer parameter;			/* control: -> additional information required to execute the
       91*						   control order */
       92 
       93 dcl  P_new_modes character (*) parameter;		/* modes: new modes to be set */
       94 dcl  P_old_modes character (*) parameter;		/* modes: set to modes in effect before change */
       95 
       96 
       97 /* Local copies of parameters */
       98 
       99 dcl  iocb_ptr pointer;
      100 dcl  code fixed binary (35);
      101 
      102 dcl  argument character (argument_lth) based (argument_ptr);/* based on attach options */
      103 dcl  argument_lth fixed binary (21);
      104 dcl  argument_ptr pointer;
      105 
      106 dcl  loud_sw bit (1) aligned;
      107 
      108 dcl  open_mode fixed binary;
      109 
      110 dcl  order character (32);
      111 dcl  info_ptr pointer;
      112 
      113 
      114 /* Remaining declarations */
      115 
      116 dcl  system_area area aligned based (system_area_ptr);
      117 dcl  system_area_ptr pointer;
      118 
      119 dcl  argument_idx fixed binary;			/* # of attach option being processed */
      120 
      121 dcl  (tty_channel, device_name) character (32);		/* required components of attach description */
      122 dcl  have_comm bit (1) aligned;			/* ON => -comm option given (required) */
      123 dcl  terminal_type character (32);			/* terminal type specifying translations (optional) */
      124 dcl  other_attach_options character (256) varying;	/* optional portions supplied by caller */
      125 
      126 dcl  device_type fixed binary;			/* local copy used for argument processing */
      127 dcl  idx fixed binary;
      128 
      129 dcl  character_value character (32);			/* unused values from argument processing */
      130 dcl  numeric_value fixed binary (35);
      131 
      132 dcl  1 ttd aligned like terminal_type_data;		/* used to call ttt_info_$terminal_data */
      133 
      134 dcl  1 dma aligned like dial_manager_arg;		/* used to attach the channel */
      135 
      136 dcl  1 local_event_wait_info aligned like event_wait_info;	/* for calls to ipc_$block */
      137 
      138 dcl  dialup_msg_channel character (32);			/* arguments to convert_dial_message_ */
      139 dcl  1 dialup_msg_flags aligned,
      140        2 dialed_up bit (1) unaligned,
      141        2 hungup bit (1) unaligned,
      142        2 control bit (1) unaligned,
      143        2 pad bit (33) unaligned;
      144 
      145 dcl  state fixed binary;				/* MCS channel state value */
      146 
      147 dcl  multiplexer_device_type fixed binary;		/* for "get_device_type" control order */
      148 
      149 dcl  1 tty_modes aligned,				/* used to change MCS modes */
      150        2 modes_lth fixed binary,
      151        2 modes character (256);
      152 
      153 dcl  1 read_status aligned,				/* for "read_status" control order */
      154        2 event_channel fixed binary (71),		/* channel to block on waiting for input to arrive */
      155        2 input_available bit (1);			/* ON => data in ring-0 waiting to be read */
      156 
      157 dcl  1 write_status aligned,				/* for "write_status" control order */
      158        2 event_channel fixed binary (71),		/* channel to block on waiting for write to complete */
      159        2 output_pending bit (1);			/* ON => data in ring-0 waiting to be sent */
      160 
      161 dcl  ips_mask bit (36);				/* IPS mask */
      162 
      163 dcl  cv_string_buffer character (cv_string_buffer_lth) based (cv_string_buffer_ptr);
      164 dcl  cv_string_buffer_used character (cv_string_buffer_used_lth) based (cv_string_buffer_ptr);
      165 dcl  (cv_string_buffer_lth, cv_string_buffer_used_lth) fixed binary (21);
      166 dcl  (cv_string_buffer_ptr, new_cv_string_buffer_ptr) pointer;
      167 
      168 dcl  io_buffer character (io_buffer_lth) unaligned based (io_buffer_ptr);
      169 dcl  (io_buffer_lth, io_buffer_used, io_buffer_read) fixed binary (21);
      170 dcl  io_buffer_ptr pointer;				/* buffer for I/O to/from the channel */
      171 
      172 dcl  cv_string_buffer_space character (384);		/* local space large enough for most conversions */
      173 dcl  io_buffer_space character (256) unaligned;		/* local space large enough for most I/O */
      174 
      175 dcl  (compress_code, expand_code) fixed binary (35);	/* code from hasp_util_$compress_text/expand_text */
      176 
      177 dcl  terminal_io_record_header_lth fixed binary (21);
      178 
      179 dcl  previous_data character (64) varying;		/* large enough for an SCB and associated data */
      180 
      181 dcl  (have_srcb, more_data_needed) bit (1) aligned;
      182 
      183 dcl  srcb_read character (1);				/* SRCB read from the device */
      184 
      185 dcl  srcb character (1) unaligned based (srcb_ptr);	/* SRCB character being constructed/interpreted */
      186 dcl  srcb_ptr pointer;
      187 
      188 dcl  1 hasp_printer_srcb unaligned based (srcb_ptr) like hasp_printer_srcb_byte;
      189 
      190 dcl  1 read_status_info aligned like read_status based (info_ptr);
      191 						/* data used by "read_status" control order */
      192 
      193 dcl  1 hangup_proc_info aligned based (info_ptr),		/* data used by "hangup_proc" control order */
      194        2 procedure entry variable,			/* procedure to invoke when line is hungup */
      195        2 data_ptr pointer,				/* user's data to be supplied to said procedure */
      196        2 priority fixed binary;			/* priority of this event call channel */
      197 
      198 dcl  1 get_channel_info aligned based (info_ptr) like tty_get_channel_info;
      199 
      200 dcl  NAME character (32) static options (constant) initial ("hasp_host_");
      201 
      202 /* format: off */
      203 dcl (NUL		initial (" "),
      204      ASCII_SPACE	initial (" "),
      205      EBCDIC_SPACE	initial ("@"))
      206 	character (1) static options (constant);
      207 
      208 dcl (LOWERCASE	initial ("abcdefghijklmnopqrstuvwxyz"),
      209      UPPERCASE	initial ("ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
      210 	character (26) static options (constant);
      211 
      212 dcl  ascii_to_ebcdic_$ae_table character (128) external;
      213 dcl  ebcdic_to_ascii_$ea_table character (256) external;
      214 
      215 dcl (error_table_$action_not_performed, error_table_$bad_conversion, error_table_$bad_mode, error_table_$badopt,
      216      error_table_$device_type_unknown, error_table_$eof_record, error_table_$improper_data_format,
      217      error_table_$incorrect_device_type, error_table_$invalid_read,
      218      error_table_$invalid_write, error_table_$io_no_permission, error_table_$long_record, error_table_$noalloc,
      219      error_table_$noarg, error_table_$not_attached, error_table_$not_closed, error_table_$not_detached,
      220      error_table_$not_open, error_table_$null_info_ptr, error_table_$short_record, error_table_$smallarg,
      221      error_table_$undefined_order_request, error_table_$unimplemented_version, error_table_$wrong_no_of_args)
      222 	fixed binary (35) external;
      223 /* format: on */
      224 
      225 dcl  com_err_ entry () options (variable);
      226 dcl  continue_to_signal_ entry (fixed binary (35));
      227 dcl  convert_dial_message_
      228 	entry (bit (72) aligned, character (*), character (*), fixed binary, 1 aligned like dialup_msg_flags,
      229 	fixed binary (35));
      230 dcl  convert_ipc_code_ entry (fixed binary (35));
      231 dcl  cu_$arg_list_ptr entry () returns (pointer);
      232 dcl  cu_$arg_ptr entry (fixed binary, pointer, fixed binary (21), fixed binary (35));
      233 dcl  cv_dec_check_ entry (character (*), fixed binary (35)) returns (fixed binary (35));
      234 dcl  dial_manager_$privileged_attach entry (pointer, fixed binary (35));
      235 dcl  dial_manager_$release_channel entry (pointer, fixed binary (35));
      236 dcl  get_system_free_area_ entry () returns (pointer);
      237 dcl  hasp_util_$compress_text
      238 	entry (pointer, fixed binary (21), fixed binary (21), pointer, fixed binary (21), fixed binary (21),
      239 	character (1) aligned, fixed binary (35));
      240 dcl  hasp_util_$expand_text
      241 	entry (pointer, fixed binary (21), fixed binary (21), pointer, fixed binary (21), fixed binary (21),
      242 	character (1) aligned, fixed binary (35));
      243 dcl  hcs_$assign_channel entry (fixed binary (71), fixed binary (35));
      244 dcl  hcs_$reset_ips_mask entry (bit (36), bit (36));
      245 dcl  hcs_$set_ips_mask entry (bit (36), bit (36));
      246 dcl  hcs_$tty_abort entry (fixed binary, fixed binary, fixed binary, fixed binary (35));
      247 dcl  hcs_$tty_attach entry (character (*), fixed binary (71), fixed binary, fixed binary, fixed binary (35));
      248 dcl  hcs_$tty_detach entry (fixed binary, fixed binary (71), fixed binary, fixed binary (35));
      249 dcl  hcs_$tty_order entry (fixed binary, character (*), pointer, fixed binary, fixed binary (35));
      250 dcl  hcs_$tty_read
      251 	entry (fixed binary, pointer, fixed binary (21), fixed binary (21), fixed binary (21), fixed binary,
      252 	fixed binary (35));
      253 dcl  hcs_$tty_write
      254 	entry (fixed binary, pointer, fixed binary (21), fixed binary (21), fixed binary (21), fixed binary,
      255 	fixed binary (35));
      256 dcl  ioa_$general_rs entry (pointer, fixed binary, fixed binary, character (*), fixed binary (21), bit (1), bit (1));
      257 dcl  iox_$err_no_operation entry ();
      258 dcl  iox_$propagate entry (pointer);
      259 dcl  ipc_$block entry (pointer, pointer, fixed binary (35));
      260 dcl  ipc_$create_ev_chn entry (fixed binary (71), fixed binary (35));
      261 dcl  ipc_$decl_ev_call_chn entry (fixed binary (71), entry, pointer, fixed binary, fixed binary (35));
      262 dcl  ipc_$decl_ev_wait_chn entry (fixed binary (71), fixed binary (35));
      263 dcl  ipc_$delete_ev_chn entry (fixed binary (71), fixed binary (35));
      264 dcl  mvt_ entry (pointer, pointer, fixed binary (21), character (512) aligned);
      265 dcl  timer_manager_$alarm_wakeup entry (fixed binary (71), bit (2), fixed binary (71));
      266 dcl  ttt_info_$terminal_data entry (character (*), fixed binary, fixed binary, pointer, fixed binary (35));
      267 
      268 dcl  (any_other, area, cleanup) condition;
      269 
      270 dcl  (addr, binary, copy, currentsize, divide, dimension, hbound, lbound, length, max, min, mod, null, rel,
      271      rtrim, string, substr, translate, unspec) builtin;
      272 
      273 
      274 /* Data describing a single switch attached through this I/O module */
      275 
      276 dcl  1 had aligned based (had_ptr),
      277        2 attach_description character (256) varying,	/* attach description for this I/O switch */
      278        2 open_description character (24) varying,		/* open description (mode) */
      279        2 channel_info_ptr pointer,			/* -> description of the channel */
      280        2 translations,
      281          3 input character (512),			/* received data -> ASCII translate table */
      282          3 output character (512),			/* ASCII -> transmittable data translate table */
      283          3 space character (1),			/* an ASCII space in remote device's character code */
      284        2 chain,					/* chain of I/O switches attached to this channel */
      285          3 next pointer,
      286          3 previous pointer;
      287 
      288 dcl  had_ptr pointer;
      289 
      290 
      291 /* Data describing a single TTY channel attached through this I/O module */
      292 
      293 dcl  1 channel_info aligned based (channel_info_ptr),
      294        2 name character (32),				/* name of channel described by this entry */
      295        2 device_type fixed binary,			/* type of device attached on this channel */
      296        2 devx fixed binary,				/* MCS identifier of this channel */
      297        2 event_channel fixed binary (71),		/* MCS signals events via this ipc_ channel */
      298        2 attach_event_channel fixed binary (71),		/* used to obtain the channel from the Answering Service */
      299        2 hads,					/* chain of I/O switches attached to this channel */
      300          3 first pointer,
      301          3 last pointer,
      302        2 held_input_ptr pointer,			/* -> input from this channel waiting for processing */
      303        2 chain,					/* chain of channels attached via this I/O module */
      304          3 previous pointer,
      305          3 next pointer,
      306        2 flags,
      307          3 attached bit (1) unaligned,			/* ON => channel has been attached from answering service */
      308          3 attach_channel_is_call bit (1) unaligned,	/* ON => attach channel has been converted to call channel */
      309          3 eof_pending bit (1) unaligned,		/* ON => next read should return error_table_$eof_record */
      310          3 pad bit (33) unaligned;
      311 
      312 dcl  channel_info_ptr pointer;
      313 
      314 dcl  first_channel_info_ptr pointer internal static initial (null ());
      315 dcl  last_channel_info_ptr pointer internal static initial (null ());
      316 
      317 
      318 /* Held input:  The read_record operation may read more data from ring-0 than necessary; this data is held in this
      319*   structure for later processing */
      320 
      321 dcl  1 held_input aligned based (held_input_ptr),
      322        2 n_elements_used fixed binary (21),		/* # of characters still being held */
      323        2 n_elements_allocated fixed binary (21),		/* # of characters initially held */
      324        2 data character (held_input_n_elements_allocated refer (held_input.n_elements_allocated));
      325 
      326 dcl  held_input_ptr pointer;
      327 dcl  held_input_n_elements_allocated fixed binary (21);
      328 
      329 /* Attach an I/O switch to a device of a HASP host */
      330 
      331 hasp_host_attach:
      332      entry (P_iocb_ptr, P_attach_options, P_loud_sw, P_code);
      333 
      334 	iocb_ptr = P_iocb_ptr;
      335 	loud_sw = P_loud_sw;
      336 	code = 0;					/* assume no errors yet */
      337 
      338 	had_ptr = null ();				/* avoid freeing garbage if I/O switch already attached */
      339 
      340 	if iocb_ptr -> iocb.attach_descrip_ptr ^= null () then do;
      341 	     P_code = error_table_$not_detached;	/* special case this error */
      342 	     if loud_sw then call com_err_ (P_code, NAME, "For switch ^a.", iocb_ptr -> iocb.name);
      343 	     return;
      344 	end;
      345 
      346 	system_area_ptr = get_system_free_area_ ();
      347 
      348 	on condition (cleanup) call cleanup_attachment ((0));
      349 
      350 
      351 /* Process attachment options */
      352 
      353 	if hbound (P_attach_options, 1) < 1 then
      354 	     call abort_attachment (error_table_$noarg,
      355 		"At least ""-comm"", ""-tty"", and  ""-device"" must be supplied.");
      356 
      357 	allocate had in (system_area) set (had_ptr);
      358 
      359 	have_comm = "0"b;				/* haven't seen -comm yet */
      360 	tty_channel = "";				/* haven't seen -tty yet */
      361 	device_name = "";				/* haven't seen -device yet */
      362 	terminal_type = "";				/* haven't seen -terminal_type yet */
      363 
      364 	other_attach_options = "";			/* optional stuff goes here */
      365 
      366 	had.open_description = "";
      367 	call set_translation (had.translations.input,	/* assume input is EBCDIC */
      368 	     addr (ebcdic_to_ascii_$ea_table), length (ebcdic_to_ascii_$ea_table));
      369 	call set_translation (had.translations.output, addr (ascii_to_ebcdic_$ae_table),
      370 	     length (ascii_to_ebcdic_$ae_table));
      371 	had.translations.space = EBCDIC_SPACE;		/* default translations */
      372 	had.channel_info_ptr = null ();		/* prevents abort from prematurely detaching channel */
      373 
      374 
      375 	do argument_idx = lbound (P_attach_options, 1) to hbound (P_attach_options, 1);
      376 
      377 	     argument_ptr = substraddr (P_attach_options (argument_idx), 1);
      378 						/* make accessing simpler */
      379 	     argument_lth = length (P_attach_options (argument_idx));
      380 
      381 	     if substr (argument, 1, 1) ^= "-" then	/* do not allow non-control arguments */
      382 		call abort_attachment (error_table_$wrong_no_of_args, "All options must be control arguments.");
      383 
      384 	     if (argument = "-comm") then do;		/* communications module: must be "hasp" */
      385 		character_value = get_string_argument ();
      386 		if (argument ^= "hasp") then call abort_attachment (0, "Communications module must be ""hasp"".");
      387 		have_comm = "1"b;			/* got the right value */
      388 	     end;
      389 
      390 	     else if (argument = "-tty") then		/* specification of TTY channel */
      391 		tty_channel = get_string_argument ();
      392 
      393 	     else if (argument = "-device") then do;	/* type of device on other end of channel */
      394 		device_name = get_string_argument ();
      395 		device_type = -1;
      396 		do idx = lbound (HASP_DEVICE_NAMES, 1) to hbound (HASP_DEVICE_NAMES, 1) while (device_type = -1);
      397 		     if HASP_DEVICE_NAMES (idx) = device_name then device_type = idx;
      398 		end;
      399 		if device_type = -1 then		/* unknown type */
      400 		     call abort_attachment (error_table_$device_type_unknown,
      401 			"Device type must be one of ^v(""^a"", ^)or ""^a""; not ""^a"".",
      402 			(dimension (HASP_DEVICE_NAMES, 1) - 1), HASP_DEVICE_NAMES, device_name);
      403 	     end;
      404 
      405 	     else if (argument = "-terminal_type") | (argument = "-ttp") then do;
      406 						/* terminal type: specifies input/output translations */
      407 		terminal_type = get_string_argument ();
      408 		terminal_type = translate (terminal_type, UPPERCASE, LOWERCASE);
      409 		ttd.version = ttd_version_3;		/* try to get input/output translations */
      410 		call ttt_info_$terminal_data (terminal_type, -1, 0, addr (ttd), code);
      411 		if code ^= 0 then call abort_attachment (code, "-terminal_type ^a", terminal_type);
      412 		if (ttd.tables.input_tr_ptr = null ()) | (ttd.tables.output_tr_ptr = null ()) then
      413 		     call abort_attachment (0, "Terminal type ""^a"" does not specify input and output translations.",
      414 			terminal_type);
      415 		call set_translation (had.translations.input,
      416 		     addr (ttd.tables.input_tr_ptr -> cv_trans_struc.cv_trans.value),
      417 		     dimension (ttd.tables.input_tr_ptr -> cv_trans_struc.cv_trans.value, 1));
      418 		call set_translation (had.translations.output,
      419 		     addr (ttd.tables.output_tr_ptr -> cv_trans_struc.cv_trans.value),
      420 		     dimension (ttd.tables.output_tr_ptr -> cv_trans_struc.cv_trans.value, 1));
      421 		had.translations.space = translate (ASCII_SPACE, had.translations.output);
      422 	     end;
      423 
      424 	     else if (argument = "-physical_line_length") | (argument = "-pll") then do;
      425 						/* supplied by calling I/O module:  ignored here */
      426 		numeric_value = get_numeric_argument ();
      427 		other_attach_options = other_attach_options || " -physical_line_length ";
      428 		other_attach_options = other_attach_options || argument;
      429 	     end;
      430 
      431 	     else if (argument = "-ebcdic") then	/* supplied by calling I/O module:  ignored here */
      432 		other_attach_options = other_attach_options || " -ebcdic";
      433 
      434 	     else if (argument = "-ascii") then		/* hasp_host_ doesn't support ASCII data */
      435 		call abort_attachment (0, "ASCII is not supported by this I/O module.");
      436 
      437 	     else if (argument = "-horizontal_tab") | (argument = "-htab") then
      438 		call abort_attachment (0, "Horizontal tabs are not supported by this I/O module.");
      439 
      440 	     else call abort_attachment (error_table_$badopt, """^a""", argument);
      441 	end;					/* of argument processing loop */
      442 
      443 
      444 /* Validate that all required information has been supplied and apply any needed defaults */
      445 
      446 	if ^have_comm then				/* must specify -comm */
      447 	     call abort_attachment (error_table_$noarg, """-comm""");
      448 
      449 	if (tty_channel = "") then			/* must specify -tty */
      450 	     call abort_attachment (error_table_$noarg, """-tty""");
      451 
      452 	if (device_name = "") then			/* must specify -device */
      453 	     call abort_attachment (error_table_$noarg, """-device""");
      454 
      455 
      456 /* Build the attach description */
      457 
      458 	had.attach_description = rtrim (NAME);
      459 	had.attach_description = had.attach_description || " -comm hasp -tty ";
      460 	had.attach_description = had.attach_description || rtrim (tty_channel);
      461 	had.attach_description = had.attach_description || " -device ";
      462 	had.attach_description = had.attach_description || rtrim (device_name);
      463 	if (terminal_type ^= "") then do;		/* optional -terminal_type was given */
      464 	     had.attach_description = had.attach_description || " -terminal_type ";
      465 	     had.attach_description = had.attach_description || rtrim (terminal_type);
      466 	end;
      467 	had.attach_description = had.attach_description || other_attach_options;
      468 
      469 
      470 /* Find the description of this channel:  Validate that all I/O switches attached to this channel are of for the same type
      471*   of I/O daemon device (printer, reader, etc.) */
      472 
      473 	do channel_info_ptr = first_channel_info_ptr repeat (channel_info.chain.next)
      474 	     while (channel_info_ptr ^= null ());
      475 	     if channel_info.name = tty_channel then go to FOUND_CHANNEL;
      476 	end;
      477 
      478 FOUND_CHANNEL:
      479 	if (channel_info_ptr = null ()) then do;	/* first use of the channel */
      480 	     allocate channel_info in (system_area) set (channel_info_ptr);
      481 	     channel_info.name = tty_channel;
      482 	     channel_info.device_type = device_type;
      483 	     channel_info.devx, channel_info.event_channel, channel_info.attach_event_channel = -1;
      484 	     channel_info.hads = null ();		/* no switches connected yet */
      485 	     channel_info.held_input_ptr = null ();	/* no read ahead yet */
      486 	     string (channel_info.flags) = ""b;		/* no special conditions yet */
      487 	     if first_channel_info_ptr = null () then
      488 		first_channel_info_ptr = channel_info_ptr;
      489 	     else last_channel_info_ptr -> channel_info.chain.next = channel_info_ptr;
      490 	     channel_info.chain.previous = last_channel_info_ptr;
      491 	     channel_info.chain.next = null ();
      492 	     last_channel_info_ptr = channel_info_ptr;
      493 	end;
      494 
      495 	else					/* channel in use: insure that device type is correct */
      496 	     if channel_info.device_type ^= device_type then
      497 	     call abort_attachment (error_table_$incorrect_device_type, "Device type of ^a is ""^a""; not ""^a"".",
      498 		tty_channel, HASP_DEVICE_NAMES (channel_info.device_type), HASP_DEVICE_NAMES (device_type));
      499 
      500 	if channel_info.hads.first = null () then
      501 	     channel_info.hads.first = had_ptr;		/* first switch for this channel */
      502 	else channel_info.hads.last -> had.chain.next = had_ptr;
      503 	had.chain.previous = channel_info.hads.last;
      504 	had.chain.next = null ();
      505 	channel_info.hads.last = had_ptr;
      506 
      507 	had.channel_info_ptr = channel_info_ptr;
      508 
      509 
      510 /* Acquire and attach the channel if necessary */
      511 
      512 	if channel_info.devx = -1 then do;
      513 
      514 /* Request the TTY channel from the Answering Service */
      515 
      516 	     call ipc_$create_ev_chn (channel_info.attach_event_channel, code);
      517 	     if code ^= 0 then call convert_ipc_code_ (code);
      518 	     if code ^= 0 then call abort_attachment (code, "Creating ipc_ channel.");
      519 
      520 	     dma.version = dial_manager_arg_version_2;
      521 	     dma.dial_channel = channel_info.attach_event_channel;
      522 	     dma.channel_name = tty_channel;
      523 	     dma.dial_qualifier, dma.dial_out_destination, dma.reservation_string = "";
      524 
      525 	     call dial_manager_$privileged_attach (addr (dma), code);
      526 	     if code = error_table_$action_not_performed then go to ASSUME_ATTACHED;
      527 	     if code ^= 0 then call abort_attachment (code, "Attempting to attach ^a.", tty_channel);
      528 
      529 	     event_wait_channel.n_channels = 1;
      530 	     event_wait_channel.channel_id (1) = channel_info.attach_event_channel;
      531 
      532 WAIT_FOR_ANSWERING_SERVICE:
      533 	     call ipc_$block (addr (event_wait_channel), addr (local_event_wait_info), code);
      534 						/* wait for answering service to give it to us */
      535 	     if code ^= 0 then call convert_ipc_code_ (code);
      536 	     if code ^= 0 then call abort_attachment (code, "Waiting for attachment to ^a.", tty_channel);
      537 
      538 	     call convert_dial_message_ (unspec (local_event_wait_info.message), dialup_msg_channel, ((32)" "), (0),
      539 		dialup_msg_flags, code);
      540 	     if code ^= 0 then call abort_attachment (code, "Interpreting attachment to ^a.", tty_channel);
      541 
      542 	     if ^dialup_msg_flags.dialed_up then do;
      543 		call com_err_ (0, NAME,
      544 		     "For switch ^a: Unexpected signal from answering service - ^[hangup^;control^] for channel ^a.",
      545 		     iocb_ptr -> iocb.name, dialup_msg_flags.hungup, dialup_msg_channel);
      546 		go to WAIT_FOR_ANSWERING_SERVICE;
      547 	     end;
      548 
      549 
      550 /* Create the event channel for ring-0:  try using a special channel first */
      551 
      552 ASSUME_ATTACHED:
      553 	     channel_info.attached = "1"b;		/* we have the channel from the answering service now */
      554 
      555 	     call hcs_$assign_channel (channel_info.event_channel, code);
      556 
      557 	     if code ^= 0 then do;			/* couldn't get fast channel: try standard one */
      558 		call ipc_$create_ev_chn (channel_info.event_channel, code);
      559 		if code ^= 0 then call convert_ipc_code_ (code);
      560 		if code ^= 0 then call abort_attachment (code, "Creating ipc_ channel.");
      561 	     end;
      562 
      563 
      564 /* Attach the channel through the ring-0 HASP multiplexer in MCS, validate the supplied device type, and set it's modes
      565*   to "rawi,rawo" */
      566 
      567 	     call hcs_$tty_attach (tty_channel, channel_info.event_channel, channel_info.devx, state, code);
      568 	     if state ^= 5 then code = error_table_$io_no_permission;
      569 	     if code ^= 0 then call abort_attachment (code, "Unable to attach to ^a.", tty_channel);
      570 
      571 	     call hcs_$tty_order (channel_info.devx, "get_device_type", addr (multiplexer_device_type), state, code);
      572 	     if state ^= 5 then code = error_table_$io_no_permission;
      573 	     if (code = 0) then
      574 		if (channel_info.device_type = multiplexer_device_type) then
      575 		     ;				/* proper device type for this channel */
      576 		else call abort_attachment (error_table_$incorrect_device_type,
      577 			"Device type of ^a is ""^a""; not ""^a"".", tty_channel,
      578 			HASP_DEVICE_NAMES (multiplexer_device_type), HASP_DEVICE_NAMES (channel_info.device_type));
      579 	     else if (code = error_table_$undefined_order_request) then
      580 		call abort_attachment (0, "^a is not connected to a HASP multiplexer.", tty_channel);
      581 	     else call abort_attachment (code, "Unable to determine device type of ^a.", tty_channel);
      582 
      583 	     tty_modes.modes = "rawi,rawo";
      584 	     tty_modes.modes_lth = length (tty_modes.modes);
      585 	     call hcs_$tty_order (channel_info.devx, "modes", addr (tty_modes), state, code);
      586 	     if state ^= 5 then code = error_table_$io_no_permission;
      587 	     if code ^= 0 then call abort_attachment (code, "Unable to set initial modes for ^a.", tty_channel);
      588 	end;
      589 
      590 
      591 /* Mask and complete construction of the IOCB */
      592 
      593 	ips_mask = ""b;
      594 
      595 	on condition (any_other) call any_other_handler ();
      596 
      597 	call hcs_$set_ips_mask (((36)"0"b), ips_mask);
      598 
      599 	iocb_ptr -> iocb.attach_descrip_ptr = addr (had.attach_description);
      600 	iocb_ptr -> iocb.attach_data_ptr = had_ptr;
      601 	iocb_ptr -> iocb.open = hasp_host_open;
      602 	iocb_ptr -> iocb.detach_iocb = hasp_host_detach;
      603 
      604 	call iox_$propagate (iocb_ptr);
      605 
      606 	call hcs_$reset_ips_mask (ips_mask, ips_mask);
      607 
      608 RETURN_FROM_ATTACH:
      609 	P_code = code;
      610 	return;
      611 
      612 /* Open an I/O switch connected to a HASP host:  only record oriented openings are supported */
      613 
      614 hasp_host_open:
      615      entry (P_iocb_ptr, P_open_mode, P_open_sw, P_code);
      616 
      617 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
      618 
      619 	if iocb_ptr -> iocb.open_descrip_ptr ^= null () then do;
      620 	     P_code = error_table_$not_closed;
      621 	     return;
      622 	end;
      623 
      624 	open_mode = P_open_mode;
      625 
      626 	if ^((open_mode = Sequential_input) | (open_mode = Sequential_output) | (open_mode = Sequential_input_output))
      627 	then do;
      628 	     P_code = error_table_$bad_mode;
      629 	     return;
      630 	end;
      631 
      632 	had_ptr = iocb_ptr -> iocb.attach_data_ptr;
      633 	channel_info_ptr = had.channel_info_ptr;
      634 
      635 	if (channel_info.device_type = HASP_PRINTER) | (channel_info.device_type = HASP_PUNCH) then
      636 	     if (open_mode = Sequential_output) then do;	/* printer/punch opened for output only */
      637 		P_code = error_table_$bad_mode;
      638 		return;
      639 	     end;
      640 
      641 	if (channel_info.device_type = HASP_READER) then
      642 	     if (open_mode = Sequential_input) then do;	/* reader opened for input only */
      643 		P_code = error_table_$bad_mode;
      644 		return;
      645 	     end;
      646 
      647 	had.open_description = rtrim (iox_modes (open_mode));
      648 
      649 	ips_mask = ""b;
      650 
      651 	on condition (any_other) call any_other_handler ();
      652 
      653 	call hcs_$set_ips_mask (((36)"0"b), ips_mask);
      654 
      655 	if ((open_mode = Sequential_input) | (open_mode = Sequential_input_output)) then
      656 	     iocb_ptr -> iocb.read_record = hasp_host_read_record;
      657 
      658 	if ((open_mode = Sequential_output) | (open_mode = Sequential_input_output)) then
      659 	     iocb_ptr -> iocb.write_record = hasp_host_write_record;
      660 
      661 	iocb_ptr -> iocb.control = hasp_host_control;
      662 	iocb_ptr -> iocb.modes = hasp_host_modes;
      663 
      664 	iocb_ptr -> iocb.close = hasp_host_close;
      665 	iocb_ptr -> iocb.detach_iocb = hasp_host_detach;
      666 
      667 	iocb_ptr -> iocb.open_descrip_ptr = addr (had.open_description);
      668 						/* it's now open */
      669 
      670 	call iox_$propagate (iocb_ptr);
      671 
      672 	call hcs_$reset_ips_mask (ips_mask, ips_mask);
      673 
      674 	P_code = 0;
      675 	return;
      676 
      677 /* Close an I/O switch connected to a HASP host */
      678 
      679 hasp_host_close:
      680      entry (P_iocb_ptr, P_code);
      681 
      682 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
      683 
      684 	if iocb_ptr -> iocb.open_descrip_ptr = null () then do;
      685 	     P_code = error_table_$not_open;
      686 	     return;
      687 	end;
      688 
      689 	ips_mask = ""b;
      690 
      691 	on condition (cleanup) call any_other_handler ();
      692 
      693 	call hcs_$set_ips_mask (((36)"0"b), ips_mask);
      694 
      695 	iocb_ptr -> iocb.open_descrip_ptr = null ();
      696 
      697 	iocb_ptr -> iocb.open = hasp_host_open;
      698 	iocb_ptr -> iocb.detach_iocb = hasp_host_detach;
      699 
      700 	iocb_ptr -> iocb.control, iocb_ptr -> iocb.modes, iocb_ptr -> iocb.read_record, iocb_ptr -> iocb.write_record =
      701 	     iox_$err_no_operation;
      702 
      703 	call iox_$propagate (iocb_ptr);
      704 
      705 	call hcs_$reset_ips_mask (ips_mask, ips_mask);
      706 
      707 	P_code = 0;
      708 
      709 	return;
      710 
      711 /* Detach an I/O switch from a device of a HASP host */
      712 
      713 hasp_host_detach:
      714      entry (P_iocb_ptr, P_code);
      715 
      716 	iocb_ptr = P_iocb_ptr;
      717 
      718 	if iocb_ptr -> iocb.attach_descrip_ptr = null () then do;
      719 	     P_code = error_table_$not_attached;
      720 	     return;
      721 	end;
      722 
      723 	if iocb_ptr -> iocb.open_descrip_ptr ^= null () then do;
      724 	     P_code = error_table_$not_closed;
      725 	     return;
      726 	end;
      727 
      728 	system_area_ptr = get_system_free_area_ ();
      729 
      730 	had_ptr = iocb_ptr -> iocb.attach_data_ptr;
      731 	channel_info_ptr = had.channel_info_ptr;
      732 
      733 	call cleanup_attachment (code);		/* remove this switch and the channel if necessary */
      734 
      735 	ips_mask = ""b;
      736 
      737 	on condition (any_other) call any_other_handler ();
      738 
      739 	call hcs_$set_ips_mask (((36)"0"b), ips_mask);
      740 
      741 	iocb_ptr -> iocb.attach_descrip_ptr = null ();	/* it's detached */
      742 
      743 	call iox_$propagate (iocb_ptr);
      744 
      745 	call hcs_$reset_ips_mask (ips_mask, ips_mask);
      746 
      747 	P_code = code;				/* in case trouble freeing the channel */
      748 	return;
      749 
      750 /* Read a record:  read a single record from the device, returning a "standard" terminal_io_record structure */
      751 
      752 hasp_host_read_record:
      753      entry (P_iocb_ptr, P_buffer_ptr, P_buffer_lth, P_record_lth, P_code);
      754 
      755 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
      756 	had_ptr = iocb_ptr -> iocb.attach_data_ptr;
      757 	channel_info_ptr = had.channel_info_ptr;
      758 	code = 0;
      759 
      760 	if (channel_info.device_type = HASP_READER) then do;
      761 	     P_code = error_table_$invalid_read;	/* can't read from the reader */
      762 	     return;
      763 	end;
      764 
      765 	system_area_ptr = get_system_free_area_ ();
      766 	cv_string_buffer_ptr = null ();		/* for cleanup handler */
      767 
      768 	on condition (cleanup)
      769 	     begin;
      770 		if cv_string_buffer_ptr ^= null () then
      771 		     if cv_string_buffer_ptr ^= addr (cv_string_buffer_space) then
      772 			free cv_string_buffer in (system_area);
      773 	     end;
      774 
      775 
      776 /* Check if last read_record operation read an EOF record containing some carriage control; if so, indicate the EOF
      777*   condition on this read as previous read just returned the slew control */
      778 
      779 	if channel_info.eof_pending then do;
      780 	     channel_info.eof_pending = "0"b;		/* only do this once per EOF */
      781 	     P_code = error_table_$eof_record;
      782 	     return;
      783 	end;
      784 
      785 
      786 /* Validate that there is room in the buffer to hold some actual data in addition to a terminal_io_record header */
      787 
      788 	terminal_io_record_ptr = P_buffer_ptr;
      789 
      790 	terminal_io_record_header_lth =		/* # of characters of buffer occupied by record's header */
      791 	     4 * (binary (rel (addr (terminal_io_record.data)), 18, 0) - binary (rel (terminal_io_record_ptr), 18, 0));
      792 
      793 	if terminal_io_record_header_lth >= P_buffer_lth then do;
      794 	     P_code = error_table_$smallarg;		/* supplied buffer is just TOO small */
      795 	     return;
      796 	end;
      797 
      798 	terminal_io_record_n_elements = P_buffer_lth - terminal_io_record_header_lth;
      799 						/* # of actual characters that will fit into the buffer */
      800 
      801 
      802 /* Obtain and unpack a record:  a record is constructed from any data obtained in prior calls to read_record in addition
      803*   to whatever data must be read from ring-0 in this call to complete the record.  Unpacking is performed on the data in
      804*   256 character sections until hasp_util_$expand_text detects the end-of-record sequence in the stream */
      805 
      806 	cv_string_buffer_ptr = addr (cv_string_buffer_space);
      807 	cv_string_buffer_lth = length (cv_string_buffer_space);
      808 	cv_string_buffer_used_lth = 0;		/* start putting data into automatic */
      809 
      810 	previous_data = "";				/* piece left from previous read */
      811 
      812 	srcb_ptr = addr (srcb_read);			/* a place to put the SRCB ... */
      813 	have_srcb = "0"b;				/* ... which hasn't been found yet */
      814 
      815 	more_data_needed = "1"b;
      816 
      817 
      818 	do while (more_data_needed);
      819 
      820 /* Select source of data for this time around:  if necessary, data will be read from ring-0 */
      821 
      822 	     if channel_info.held_input_ptr ^= null () then do;
      823 						/* read ahead: process as much of the block as can be used */
      824 		io_buffer_ptr = addr (channel_info.held_input_ptr -> held_input.data);
      825 		io_buffer_lth = channel_info.held_input_ptr -> held_input.n_elements_allocated;
      826 		io_buffer_read = channel_info.held_input_ptr -> held_input.n_elements_used;
      827 	     end;
      828 
      829 	     else do;				/* no more read ahead: obtain more data from ring-0 */
      830 		io_buffer_ptr = addr (io_buffer_space);
      831 		io_buffer_lth = length (io_buffer_space);
      832 		call read_io_buffer ();		/* sets io_buffer_read */
      833 		if code ^= 0 then go to RETURN_FROM_READ_RECORD;
      834 	     end;
      835 
      836 	     if length (previous_data) > 0 then do;	/* some data left over from previous junk: merge them */
      837 		held_input_n_elements_allocated = length (previous_data) + io_buffer_read;
      838 		allocate held_input in (system_area) set (held_input_ptr);
      839 		held_input.n_elements_used = held_input.n_elements_allocated;
      840 		substr (held_input.data, 1, length (previous_data)) = previous_data;
      841 		substr (held_input.data, (length (previous_data) + 1), io_buffer_read) =
      842 		     substr (io_buffer, 1, io_buffer_read);
      843 		if io_buffer_ptr ^= addr (io_buffer_space) then
      844 		     free channel_info.held_input_ptr -> held_input in (system_area);
      845 		channel_info.held_input_ptr = held_input_ptr;
      846 		io_buffer_ptr = addr (held_input.data);
      847 		io_buffer_lth, io_buffer_read = held_input.n_elements_used;
      848 		previous_data = "";
      849 	     end;
      850 
      851 
      852 /* Unpack the data:  stop when an end-of-record indicator is found */
      853 
      854 	     if have_srcb then
      855 		io_buffer_used = 0;			/* in middle of record: first character in buffer is SCB */
      856 	     else do;				/* first part of record: first character is SRCB */
      857 		srcb = substr (io_buffer, 1, 1);
      858 		io_buffer_used = 1;
      859 		have_srcb = "1"b;
      860 	     end;
      861 
      862 	     do while (more_data_needed & (io_buffer_used < io_buffer_read));
      863 
      864 		call hasp_util_$expand_text (substraddr (io_buffer, 1), io_buffer_read, io_buffer_used,
      865 		     substraddr (cv_string_buffer, 1), cv_string_buffer_lth, cv_string_buffer_used_lth,
      866 		     had.translations.space, expand_code);
      867 
      868 		if expand_code = 0 then more_data_needed = "0"b;
      869 						/* found end of record indicator */
      870 
      871 		else if expand_code = error_table_$short_record then ;
      872 						/* took entire buffer but need more */
      873 
      874 		else if expand_code = error_table_$long_record then do;
      875 						/* overflowed the output buffer: grow it and continue */
      876 		     cv_string_buffer_lth = 2 * cv_string_buffer_lth;
      877 		     on condition (area)
      878 			begin;			/* can't get enough room: record is not readable */
      879 			     code = error_table_$noalloc;
      880 			     go to RETURN_FROM_READ_RECORD;
      881 			end;
      882 		     allocate cv_string_buffer in (system_area) set (new_cv_string_buffer_ptr);
      883 		     revert condition (area);
      884 		     new_cv_string_buffer_ptr -> cv_string_buffer_used = cv_string_buffer_used;
      885 		     if cv_string_buffer_ptr ^= addr (cv_string_buffer_space) then
      886 			free cv_string_buffer in (system_area);
      887 		     cv_string_buffer_ptr = new_cv_string_buffer_ptr;
      888 		end;
      889 
      890 		else if (io_buffer_read - io_buffer_used) <= (HASP_MAX_NOT_COMPRESSED_TEXT_LTH + 1) then do;
      891 						/* possibly need to read more data from ring-0 */
      892 		     previous_data = substr (io_buffer, (io_buffer_used + 1), (io_buffer_read - io_buffer_used));
      893 		     io_buffer_used = io_buffer_read;	/* force to read some more data */
      894 		end;
      895 
      896 		else do;				/* data is definitely improperly formatted */
      897 		     code = error_table_$improper_data_format;
      898 		     go to RETURN_FROM_READ_RECORD;
      899 		end;
      900 	     end;
      901 
      902 	     if io_buffer_used = io_buffer_read then	/* have exhausted this buffer ... */
      903 		if io_buffer_ptr ^= addr (io_buffer_space) then do;
      904 		     free channel_info.held_input_ptr -> held_input in (system_area);
      905 		     channel_info.held_input_ptr = null ();
      906 		end;				/* ... so get rid of it so we can read some more */
      907 	end;
      908 
      909 	if io_buffer_used < io_buffer_read then do;	/* some data left over: save it */
      910 	     held_input_n_elements_allocated = io_buffer_read - io_buffer_used;
      911 	     allocate held_input in (system_area) set (held_input_ptr);
      912 	     held_input.n_elements_used = held_input.n_elements_allocated;
      913 	     held_input.data = substr (io_buffer, (io_buffer_used + 1), (io_buffer_read - io_buffer_used));
      914 	     if io_buffer_ptr ^= addr (io_buffer_space) then free channel_info.held_input_ptr -> held_input;
      915 	     channel_info.held_input_ptr = held_input_ptr;
      916 	end;
      917 
      918 
      919 /* Check for end of file:  An EOF record is a zero length record.  If an EOF record is found, check if the SRCB contains
      920*   carriage control information (line printer only), delay indicating the EOF until the next call to read_record and
      921*   return a zero length record with appropriate slew control; otherwise, return error_table_$eof_record.  If no EOF is
      922*   present, convert the data in the record to ASCII */
      923 
      924 	if (cv_string_buffer_used_lth = 0) then do;
      925 	     if (channel_info.device_type = HASP_PRINTER) then
      926 		if (srcb = substr (TEMPLATE_HASP_EOF_RECORD, 1, 1)) then
      927 		     code = error_table_$eof_record;
      928 		else do;
      929 		     channel_info.eof_pending = "1"b;
      930 		     terminal_io_record.n_elements = 0; /* no data in the record, just slew */
      931 		end;
      932 	     else code = error_table_$eof_record;
      933 	     if (code = error_table_$eof_record) then go to RETURN_FROM_READ_RECORD;
      934 	end;
      935 
      936 	else do;					/* data seems OK: convert it */
      937 	     terminal_io_record.n_elements = min (terminal_io_record_n_elements, cv_string_buffer_used_lth);
      938 	     if cv_string_buffer_used_lth > 0 then
      939 		call mvt_ (addr (cv_string_buffer_used), addr (terminal_io_record_data_chars),
      940 		     (terminal_io_record.n_elements), had.translations.input);
      941 	     if cv_string_buffer_used_lth > terminal_io_record_n_elements then code = error_table_$long_record;
      942 	end;					/* ... return as much as will fit */
      943 
      944 
      945 /* Control reaches here iff the record is read/converted successfully:  complete the terminal_io_record structure */
      946 
      947 	terminal_io_record.version = terminal_io_record_version_1;
      948 
      949 	if (channel_info.device_type = HASP_CONSOLE) then terminal_io_record.device_type = TELEPRINTER_DEVICE;
      950 	else if (channel_info.device_type = HASP_PRINTER) then terminal_io_record.device_type = PRINTER_DEVICE;
      951 	else if (channel_info.device_type = HASP_PUNCH) then terminal_io_record.device_type = PUNCH_DEVICE;
      952 
      953 	string (terminal_io_record.flags) = ""b;
      954 
      955 	if (channel_info.device_type = HASP_CONSOLE) | (channel_info.device_type = HASP_PUNCH) then do;
      956 						/* console or punch: slewing is fixed */
      957 	     terminal_io_record.slew_type = SLEW_BY_COUNT;
      958 	     terminal_io_record.slew_count = 1;
      959 	     terminal_io_record.preslew = "0"b;
      960 	end;
      961 
      962 	else do;					/* printer: interpret the SRCB */
      963 	     if hasp_printer_srcb.skip_to_channel then
      964 		terminal_io_record.slew_type = SLEW_TO_CHANNEL;
      965 	     else terminal_io_record.slew_type = SLEW_BY_COUNT;
      966 	     terminal_io_record.slew_count = hasp_printer_srcb.number;
      967 	     terminal_io_record.preslew = hasp_printer_srcb.prespace;
      968 	end;
      969 
      970 	terminal_io_record.element_size = 9;
      971 
      972 	P_record_lth = terminal_io_record_header_lth + terminal_io_record.n_elements;
      973 
      974 
      975 /* Cleanup */
      976 
      977 RETURN_FROM_READ_RECORD:
      978 	if cv_string_buffer_ptr ^= null () then
      979 	     if cv_string_buffer_ptr ^= addr (cv_string_buffer_space) then free cv_string_buffer in (system_area);
      980 
      981 	P_code = code;
      982 	return;
      983 
      984 /* Write a record:  write a single record to the device.  This record represents part or all of a single line and should
      985*   be the output of the prt_conv_ module using the remote_conv_ conversion coroutine, presently named hasp_host_conv_ */
      986 
      987 hasp_host_write_record:
      988      entry (P_iocb_ptr, P_record_ptr, P_record_lth, P_code);
      989 
      990 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
      991 	had_ptr = iocb_ptr -> iocb.attach_data_ptr;
      992 	channel_info_ptr = had.channel_info_ptr;
      993 	code = 0;
      994 
      995 	if (channel_info.device_type = HASP_PRINTER) | (channel_info.device_type = HASP_PUNCH) then do;
      996 	     P_code = error_table_$invalid_write;	/* can't write printer or punch */
      997 	     return;
      998 	end;
      999 
     1000 	system_area_ptr = get_system_free_area_ ();
     1001 	io_buffer_ptr = null ();			/* for cleanup handler */
     1002 
     1003 	on condition (cleanup)
     1004 	     begin;				/* free any temporary buffers */
     1005 		if io_buffer_ptr ^= null () then
     1006 		     if io_buffer_ptr ^= addr (io_buffer_space) then free io_buffer in (system_area);
     1007 	     end;
     1008 
     1009 
     1010 /* Validate input:  insure that the caller has supplied a complete terminal I/O record; insure that the terminal input
     1011*   record contains character as opposed to binary data */
     1012 
     1013 	terminal_io_record_ptr = P_record_ptr;
     1014 
     1015 	if terminal_io_record.version ^= terminal_io_record_version_1 then do;
     1016 	     P_code = error_table_$unimplemented_version;
     1017 	     return;
     1018 	end;
     1019 
     1020 	if mod (P_record_lth, 4) = 0 then		/* X+4-mod(X,4) fails when X is already a multiple of 4 */
     1021 	     if (4 * currentsize (terminal_io_record)) = P_record_lth then
     1022 		;				/* user supplied length agrees with computed length */
     1023 	     else do;
     1024 		P_code = error_table_$improper_data_format;
     1025 		return;
     1026 	     end;
     1027 	else					/* supplied length not multiple of 4:  must round it up */
     1028 	     if (4 * currentsize (terminal_io_record)) ^= (P_record_lth + 4 - mod (P_record_lth, 4)) then do;
     1029 	     P_code = error_table_$improper_data_format;
     1030 	     return;
     1031 	end;
     1032 
     1033 	if terminal_io_record.binary | terminal_io_record.preslew | (terminal_io_record.element_size ^= 9) then do;
     1034 	     P_code = error_table_$improper_data_format;
     1035 	     return;
     1036 	end;
     1037 
     1038 
     1039 /* Convert the data to the remote system's character code (in place) */
     1040 
     1041 	call mvt_ (addr (terminal_io_record_data_chars), addr (terminal_io_record_data_chars),
     1042 	     (terminal_io_record.n_elements), had.translations.output);
     1043 
     1044 
     1045 /* Compute size of I/O buffer required assuming no compression can be performed on the record.  If this size is not too
     1046*   large, the automatic buffer will be used; otherwise, a buffer will be allocated */
     1047 
     1048 	io_buffer_lth =
     1049 	     max (terminal_io_record.n_elements, 1)
     1050 	     +
     1051 	     divide ((terminal_io_record.n_elements + HASP_MAX_NOT_COMPRESSED_TEXT_LTH - 1),
     1052 	     HASP_MAX_NOT_COMPRESSED_TEXT_LTH, 17, 0) +	/* SCBs for the text */
     1053 	     2;					/* SRCB and end-of-record SCB */
     1054 
     1055 	if io_buffer_lth <= length (io_buffer_space) then do;
     1056 						/* space needed availabe in automatic */
     1057 	     io_buffer_ptr = addr (io_buffer_space);
     1058 	     io_buffer_lth = length (io_buffer_space);
     1059 	end;
     1060 	else do;					/* space required larger than automatic buffer */
     1061 	     on condition (area)
     1062 		begin;
     1063 		     code = error_table_$noalloc;	/* just TOO much */
     1064 		     go to RETURN_FROM_WRITE_RECORD;
     1065 		end;
     1066 	     allocate io_buffer in (system_area) set (io_buffer_ptr);
     1067 	end;
     1068 
     1069 
     1070 /* Create the record:  construct the SRCB for the record, compress the record (insuring that some data is present in the
     1071*   record), and add the terminating end-of-record SCB */
     1072 
     1073 	io_buffer_used = 0;				/* nothing in the output yet */
     1074 
     1075 	if (channel_info.device_type = HASP_CONSOLE) then call add_character_to_io_buffer (HASP_CONSOLE_SRCB);
     1076 	else if (channel_info.device_type = HASP_READER) then call add_character_to_io_buffer (TEMPLATE_HASP_CARD_SRCB);
     1077 
     1078 	if terminal_io_record.n_elements = 0 then	/* no data:  supply some to avoid lossage with RSCS */
     1079 	     call hasp_util_$compress_text (addr (had.translations.space), 1, (0), addr (io_buffer), length (io_buffer),
     1080 		io_buffer_used, had.translations.space, compress_code);
     1081 
     1082 	else call hasp_util_$compress_text (addr (terminal_io_record.data), (terminal_io_record.n_elements), (0),
     1083 		addr (io_buffer), length (io_buffer), io_buffer_used, had.translations.space, compress_code);
     1084 
     1085 	if compress_code ^= 0 then do;		/* failed:  yet above code insured there'd enough room */
     1086 WRITE_RECORD_BAD_DATA:
     1087 	     code = error_table_$improper_data_format;
     1088 	     go to RETURN_FROM_WRITE_RECORD;
     1089 	end;
     1090 
     1091 	call add_character_to_io_buffer (HASP_EOR_SCB);
     1092 
     1093 
     1094 /* Transmit the I/O block and return to the caller */
     1095 
     1096 	call write_io_buffer ();			/* needed in end_write_mode control order */
     1097 
     1098 RETURN_FROM_WRITE_RECORD:
     1099 	if io_buffer_ptr ^= null () then
     1100 	     if io_buffer_ptr ^= addr (io_buffer_space) then free io_buffer in (system_area);
     1101 
     1102 	P_code = code;
     1103 	return;
     1104 
     1105 /* Perform control operations on an I/O switch connected to a HASP host */
     1106 
     1107 hasp_host_control:
     1108      entry (P_iocb_ptr, P_order, P_info_ptr, P_code);
     1109 
     1110 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
     1111 	had_ptr = iocb_ptr -> iocb.attach_data_ptr;
     1112 	channel_info_ptr = had.channel_info_ptr;
     1113 
     1114 	order = P_order;
     1115 	info_ptr = P_info_ptr;
     1116 	code = 0;
     1117 
     1118 
     1119 	if (order = "io_call") then do;
     1120 
     1121 /* io_call command interface:  translate the supplied info into an ordinary control order */
     1122 
     1123 	     if info_ptr = null () then do;		/* need the order name */
     1124 		P_code = error_table_$undefined_order_request;
     1125 		return;
     1126 	     end;
     1127 
     1128 	     order = info_ptr -> io_call_info.order_name;
     1129 	     info_ptr = null ();
     1130 	end;
     1131 
     1132 
     1133 	if (order = "signon_record") then do;
     1134 
     1135 /* Send a SIGNON record to the host system: validate that the user supplied an event-wait channel, convert the SIGNON
     1136*   record itself to uppercase and the remote system's character code, and pass the control order to MCS for actual
     1137*   processing */
     1138 
     1139 	     if info_ptr = null () then
     1140 		code = error_table_$null_info_ptr;
     1141 
     1142 	     else do;
     1143 		signon_record_info_ptr = info_ptr;
     1144 
     1145 		if signon_record_info.version ^= SIGNON_RECORD_INFO_VERSION_1 then
     1146 		     code = error_table_$unimplemented_version;
     1147 						/* FINISH ME: validate IPC channel... */
     1148 		else do;				/* proper version */
     1149 		     signon_record_info.record = translate (signon_record_info.record, UPPERCASE, LOWERCASE);
     1150 		     signon_record_info.record = translate (signon_record_info.record, had.translations.output);
     1151 		     call hcs_$tty_order (channel_info.devx, "signon_record", signon_record_info_ptr, state, code);
     1152 		     if state ^= 5 then code = error_table_$io_no_permission;
     1153 		end;
     1154 	     end;
     1155 	end;
     1156 
     1157 
     1158 	else if (order = "runout") then do;
     1159 
     1160 /* Wait for all output to leave the FNP:  for HASP channels, we only wait for the output to leave the TTY channel and
     1161*   enter the multiplexer */
     1162 
     1163 	     write_status.output_pending = "1"b;	/* need do until */
     1164 
     1165 	     do while (write_status.output_pending);
     1166 
     1167 		call hcs_$tty_order (channel_info.devx, "write_status", addr (write_status), state, code);
     1168 		if state ^= 5 then code = error_table_$io_no_permission;
     1169 		if code ^= 0 then go to RETURN_FROM_CONTROL;
     1170 
     1171 		if write_status.output_pending then do;
     1172 		     event_wait_channel.n_channels = 1;
     1173 		     event_wait_channel.channel_id (1) = channel_info.event_channel;
     1174 		     call ipc_$block (addr (event_wait_channel), addr (local_event_wait_info), code);
     1175 		     if code ^= 0 then call convert_ipc_code_ (code);
     1176 		     if code ^= 0 then go to RETURN_FROM_CONTROL;
     1177 		end;
     1178 	     end;
     1179 	end;
     1180 
     1181 
     1182 	else if (order = "end_write_mode") then do;
     1183 
     1184 /* End a write operation:  for a card reader write an EOF record.  For all output devices, wait for all output to enter
     1185*   the multiplexer */
     1186 
     1187 	     if (channel_info.device_type = HASP_PRINTER) | (channel_info.device_type = HASP_PUNCH) then do;
     1188 		code = error_table_$invalid_write;
     1189 		go to RETURN_FROM_CONTROL;
     1190 	     end;
     1191 
     1192 	     if (channel_info.device_type = HASP_CONSOLE) then
     1193 		;				/* don't write an EOF record */
     1194 
     1195 	     else do;
     1196 		io_buffer_ptr = addr (TEMPLATE_HASP_EOF_RECORD);
     1197 		io_buffer_lth, io_buffer_used = length (TEMPLATE_HASP_EOF_RECORD);
     1198 		call write_io_buffer ();		/* send it */
     1199 		if code ^= 0 then go to RETURN_FROM_CONTROL;
     1200 	     end;
     1201 
     1202 	     call hasp_host_control (iocb_ptr, "runout", (null ()), code);
     1203 	end;
     1204 
     1205 
     1206 	else if (order = "read_status") then do;
     1207 
     1208 /* Indicate if input is available:  check local buffers before checking with ring-0 */
     1209 
     1210 	     if (info_ptr = null ()) then
     1211 		code = error_table_$null_info_ptr;
     1212 
     1213 	     else do;
     1214 		read_status_info.event_channel = channel_info.event_channel;
     1215 
     1216 		if (channel_info.held_input_ptr ^= null ()) | channel_info.eof_pending then
     1217 		     read_status_info.input_available = "1"b;
     1218 						/* got some here */
     1219 
     1220 		else do;
     1221 		     call hcs_$tty_order (channel_info.devx, "read_status", info_ptr, state, code);
     1222 		     if state ^= 5 then code = error_table_$io_no_permission;
     1223 		end;
     1224 	     end;
     1225 	end;
     1226 
     1227 
     1228 	else if (order = "resetread") then do;
     1229 
     1230 /* Flush pending input:  throw out any input being held locally and then perform an appropriate "abort" control on the
     1231*   channel */
     1232 
     1233 	     if channel_info.held_input_ptr ^= null () then
     1234 		free channel_info.held_input_ptr -> held_input in (system_area);
     1235 	     channel_info.held_input_ptr = null ();
     1236 	     channel_info.eof_pending = "0"b;
     1237 
     1238 	     call hcs_$tty_abort (channel_info.devx, (1), state, code);
     1239 	     if state ^= 5 then code = error_table_$io_no_permission;
     1240 	end;
     1241 
     1242 
     1243 	else if (order = "resetwrite") then do;
     1244 
     1245 /* Flush pending output:  perform the appropriate "abort" control order on the channel */
     1246 
     1247 	     call hcs_$tty_abort (channel_info.devx, (2), state, code);
     1248 	     if state ^= 5 then code = error_table_$io_no_permission;
     1249 	end;
     1250 
     1251 
     1252 	else if (order = "hangup_proc") then do;
     1253 
     1254 /* Caller supplies a procedure to be invoked when the channel used by this switch is hungup */
     1255 
     1256 	     if (info_ptr = null ()) then
     1257 		code = error_table_$null_info_ptr;
     1258 
     1259 	     else do;
     1260 		call ipc_$decl_ev_call_chn (channel_info.attach_event_channel, hangup_proc_info.procedure,
     1261 		     hangup_proc_info.data_ptr, hangup_proc_info.priority, code);
     1262 		if code ^= 0 then call convert_ipc_code_ (code);
     1263 		if code = 0 then channel_info.attach_channel_is_call = "1"b;
     1264 	     end;
     1265 	end;
     1266 
     1267 
     1268 	else if (order = "get_channel_info") then do;
     1269 
     1270 /* Return the name and MCS device index of the channel attached via this switch */
     1271 
     1272 	     if (info_ptr = null ()) then code = error_table_$null_info_ptr;
     1273 
     1274 	     else if get_channel_info.version ^= tty_get_channel_info_version then
     1275 		code = error_table_$unimplemented_version;
     1276 
     1277 	     else do;
     1278 		get_channel_info.devx = channel_info.devx;
     1279 		get_channel_info.channel_name = channel_info.name;
     1280 	     end;
     1281 	end;
     1282 
     1283 
     1284 	else if (order = "select_device") then ;	/* select a specific output device: ignored */
     1285 
     1286 	else if (order = "reset") then ;		/* reset the switch to a well-known state: ignored */
     1287 
     1288 
     1289 	else do;
     1290 
     1291 /* Unrecognized control order or "no_signon_record" order: pass it on to MCS */
     1292 
     1293 	     call hcs_$tty_order (channel_info.devx, order, info_ptr, state, code);
     1294 	     if state ^= 5 then code = error_table_$io_no_permission;
     1295 	end;
     1296 
     1297 RETURN_FROM_CONTROL:
     1298 	P_code = code;
     1299 	return;
     1300 
     1301 /* Change modes:  only the "non_edited" and "default" modes are recognized */
     1302 
     1303 hasp_host_modes:
     1304      entry (P_iocb_ptr, P_new_modes, P_old_modes, P_code);
     1305 
     1306 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
     1307 	had_ptr = iocb_ptr -> iocb.attach_data_ptr;
     1308 	P_old_modes = "";				/* no modes are reflected to caller */
     1309 	code = 0;
     1310 
     1311 	if (P_new_modes = "non_edited") | (P_new_modes = "default") then
     1312 	     ;
     1313 	else code = error_table_$bad_mode;
     1314 
     1315 	P_code = code;
     1316 	return;
     1317 
     1318 /* Remove an I/O switch which might be attached to the channel:  if this switch is the only one attached to the channel,
     1319*   the channel itself is detached */
     1320 
     1321 cleanup_attachment:
     1322      procedure (P_code);
     1323 
     1324 dcl  P_code fixed binary (35) parameter;		/* a parameter to allow callers to ignore it */
     1325 
     1326 	P_code = 0;
     1327 
     1328 	if had_ptr ^= null () then do;		/* there is an I/O switch */
     1329 
     1330 	     if had.channel_info_ptr ^= null () then do;	/* there is knowledge of the channel */
     1331 
     1332 		channel_info_ptr = had.channel_info_ptr;
     1333 
     1334 		if (had.chain.previous = null ()) then
     1335 		     channel_info.hads.first = had.chain.next;
     1336 		else had.chain.previous -> had.chain.next = had.chain.next;
     1337 
     1338 		if (had.chain.next = null ()) then
     1339 		     channel_info.hads.last = had.chain.previous;
     1340 		else had.chain.next -> had.chain.previous = had.chain.previous;
     1341 
     1342 		if (channel_info.hads.first = null ()) then call release_channel ();
     1343 						/* last switch connected to the channel */
     1344 	     end;
     1345 
     1346 	     free had in (system_area);
     1347 	     had_ptr = null ();			/* just to be sure */
     1348 	end;
     1349 
     1350 	return;
     1351 
     1352 
     1353 
     1354 /* Internal to cleanup_attachment:  release the knowledge associated with a TTY channel */
     1355 
     1356 release_channel:
     1357 	procedure ();
     1358 
     1359 	     if channel_info.devx ^= -1 then call hcs_$tty_detach (channel_info.devx, (0), (0), P_code);
     1360 
     1361 	     if channel_info.event_channel ^= -1 then call ipc_$delete_ev_chn (channel_info.event_channel, (0));
     1362 
     1363 	     if channel_info.attached then do;		/* give the channel back to the answering service */
     1364 		if channel_info.attach_channel_is_call then
     1365 		     call ipc_$decl_ev_wait_chn (channel_info.attach_event_channel, (0));
     1366 		dma.version = dial_manager_arg_version_2;
     1367 		dma.dial_channel = channel_info.attach_event_channel;
     1368 		dma.channel_name = channel_info.name;
     1369 		dma.dial_qualifier, dma.dial_out_destination, dma.reservation_string = "";
     1370 		call dial_manager_$release_channel (addr (dma), (0));
     1371 		channel_info.attached = "0"b;		/* assume success */
     1372 	     end;
     1373 
     1374 	     if channel_info.attach_event_channel ^= -1 then
     1375 		call ipc_$delete_ev_chn (channel_info.attach_event_channel, (0));
     1376 
     1377 	     if (channel_info.chain.previous = null ()) then
     1378 		first_channel_info_ptr = channel_info.chain.next;
     1379 	     else channel_info.chain.previous -> channel_info.chain.next = channel_info.chain.next;
     1380 
     1381 	     if (channel_info.chain.next = null ()) then
     1382 		last_channel_info_ptr = channel_info.chain.previous;
     1383 	     else channel_info.chain.next -> channel_info.chain.previous = channel_info.chain.previous;
     1384 
     1385 	     free channel_info in (system_area);
     1386 	     channel_info_ptr = null ();
     1387 
     1388 	     return;
     1389 
     1390 	end release_channel;
     1391 
     1392      end cleanup_attachment;
     1393 
     1394 /* Wrapper to protect against errors while IPS interrupts are masked */
     1395 
     1396 any_other_handler:
     1397      procedure () options (non_quick);
     1398 
     1399 	if ips_mask then call hcs_$reset_ips_mask (ips_mask, ips_mask);
     1400 	ips_mask = ""b;
     1401 
     1402 	call continue_to_signal_ ((0));		/* not interested, */
     1403 
     1404 	return;
     1405 
     1406      end any_other_handler;
     1407 
     1408 
     1409 
     1410 /* Abort a call to the attach entry:  print an error message if requested */
     1411 
     1412 abort_attachment:
     1413      procedure () options (variable, non_quick);
     1414 
     1415 dcl  the_code fixed binary (35) based (the_code_ptr);
     1416 dcl  the_code_ptr pointer;
     1417 
     1418 dcl  caller_message character (256);
     1419 
     1420 	call cu_$arg_ptr (1, the_code_ptr, (0), (0));
     1421 
     1422 	if loud_sw then do;				/* an error message is requested */
     1423 	     call ioa_$general_rs (cu_$arg_list_ptr (), 2, 3, caller_message, (0), "1"b, "0"b);
     1424 	     call com_err_ (the_code, NAME, "For switch ^a: ^a", iocb_ptr -> iocb.name, caller_message);
     1425 	end;
     1426 
     1427 	call cleanup_attachment ((0));		/* get rid of anything that was accomplished */
     1428 
     1429 	if the_code = 0 then
     1430 	     code = error_table_$action_not_performed;
     1431 	else code = the_code;			/* save the error code */
     1432 
     1433 	go to RETURN_FROM_ATTACH;
     1434 
     1435      end abort_attachment;
     1436 
     1437 /* Fetch the next argument from the attach options and validate that it is a non-null character string */
     1438 
     1439 get_string_argument:
     1440      procedure () returns (character (*));
     1441 
     1442 dcl  option_name character (32);
     1443 
     1444 	option_name = argument;			/* about to move on to the next one */
     1445 
     1446 	if (argument_idx = hbound (P_attach_options, 1)) then
     1447 	     call abort_attachment (error_table_$noarg, "Character string following ""^a"".", option_name);
     1448 
     1449 	argument_idx = argument_idx + 1;
     1450 
     1451 	argument_ptr = substraddr (P_attach_options (argument_idx), 1);
     1452 	argument_lth = length (P_attach_options (argument_idx));
     1453 
     1454 	if (argument = "") then
     1455 	     call abort_attachment (0, "Character string following ""^a"" must be non-null.", option_name);
     1456 
     1457 	return (argument);
     1458 
     1459      end get_string_argument;
     1460 
     1461 
     1462 
     1463 /* Fetch the next argument from the attach options and verify that it is a number */
     1464 
     1465 get_numeric_argument:
     1466      procedure () returns (fixed binary (35));
     1467 
     1468 dcl  option_name character (32);
     1469 dcl  the_value fixed binary (35);
     1470 
     1471 	option_name = argument;			/* about to move on to the next one */
     1472 
     1473 	if (argument_idx = hbound (P_attach_options, 1)) then
     1474 	     call abort_attachment (error_table_$noarg, "Number following ""^a"".", option_name);
     1475 
     1476 	argument_idx = argument_idx + 1;
     1477 
     1478 	argument_ptr = substraddr (P_attach_options (argument_idx), 1);
     1479 	argument_lth = length (P_attach_options (argument_idx));
     1480 
     1481 	the_value = cv_dec_check_ (argument, code);
     1482 
     1483 	if code ^= 0 then
     1484 	     call abort_attachment (error_table_$bad_conversion, """^a"" must be followed by a number; not ""^a"".",
     1485 		option_name, argument);
     1486 
     1487 	return (the_value);
     1488 
     1489      end get_numeric_argument;
     1490 
     1491 /* Set input/output translation to the given string:  If the string supplied is less than 512 characters, the out of range
     1492*   characters are translated to NULs */
     1493 
     1494 set_translation:
     1495      procedure (P_translate_table, P_translate_string_ptr, P_translate_string_lth);
     1496 
     1497 dcl  P_translate_table character (512) aligned parameter;	/* translate table */
     1498 dcl  P_translate_string_ptr pointer parameter;		/* -> translation string */
     1499 dcl  P_translate_string_lth fixed binary (21) parameter;	/* length of translation string */
     1500 
     1501 dcl  translate_string character (P_translate_string_lth) based (P_translate_string_ptr);
     1502 
     1503 	P_translate_table = translate_string;
     1504 
     1505 	if length (translate_string) < length (P_translate_table) then
     1506 	     substr (P_translate_table, (length (translate_string) + 1)) =
     1507 		copy (NUL, (length (P_translate_table) - length (translate_string)));
     1508 
     1509 	return;
     1510 
     1511      end set_translation;
     1512 
     1513 /* Read an I/O buffer:  block until some data arrives and perform a single read from ring-0 */
     1514 
     1515 read_io_buffer:
     1516      procedure ();
     1517 
     1518 	io_buffer_read = 0;				/* need do until here */
     1519 
     1520 	do while (io_buffer_read = 0);
     1521 
     1522 	     read_status.input_available = "0"b;	/* again, no do until */
     1523 
     1524 	     do while (^read_status.input_available);
     1525 
     1526 		call hcs_$tty_order (channel_info.devx, "read_status", addr (read_status), state, code);
     1527 		if state ^= 5 then code = error_table_$io_no_permission;
     1528 		if code ^= 0 then return;		/* punt! */
     1529 
     1530 		if ^read_status.input_available then do;/* need to wait for some input */
     1531 		     event_wait_channel.n_channels = 1;
     1532 		     event_wait_channel.channel_id (1) = channel_info.event_channel;
     1533 		     call ipc_$block (addr (event_wait_channel), addr (local_event_wait_info), code);
     1534 		     if code ^= 0 then call convert_ipc_code_ (code);
     1535 		     if code ^= 0 then return;
     1536 		end;
     1537 	     end;
     1538 
     1539 	     call hcs_$tty_read (channel_info.devx, addr (io_buffer), (0), io_buffer_lth, io_buffer_read, state, code);
     1540 	     if state ^= 5 then code = error_table_$io_no_permission;
     1541 	     if code ^= 0 then return;
     1542 	end;
     1543 
     1544 	return;
     1545 
     1546      end read_io_buffer;
     1547 
     1548 /* Add the specified character to the I/O buffer for later output */
     1549 
     1550 add_character_to_io_buffer:
     1551      procedure (P_character);
     1552 
     1553 dcl  P_character character (1) aligned parameter;
     1554 
     1555 	if io_buffer_used = length (io_buffer) then	/* no room in buffer */
     1556 	     go to WRITE_RECORD_BAD_DATA;
     1557 
     1558 	io_buffer_used = io_buffer_used + 1;
     1559 
     1560 	substr (io_buffer, io_buffer_used, 1) = P_character;
     1561 
     1562 	return;
     1563 
     1564      end add_character_to_io_buffer;
     1565 
     1566 /* Write an I/O buffer:  blocks until the entire buffer has been taken by ring-0 MCS */
     1567 
     1568 write_io_buffer:
     1569      procedure ();
     1570 
     1571 dcl  (transmitted, sent_on_call) fixed binary (21);
     1572 
     1573 
     1574 	transmitted = 0;				/* do until needed here */
     1575 
     1576 	do while (transmitted < io_buffer_used);
     1577 
     1578 	     call hcs_$tty_write (channel_info.devx, substraddr (io_buffer, (transmitted + 1)), (0),
     1579 		(io_buffer_used - transmitted), sent_on_call, state, code);
     1580 	     if state ^= 5 then code = error_table_$io_no_permission;
     1581 	     if code ^= 0 then return;		/* punt! */
     1582 
     1583 	     transmitted = transmitted + sent_on_call;	/* got some more through */
     1584 
     1585 	     if transmitted < io_buffer_used then do;	/* not done yet: wait 'till we should try again */
     1586 		call hcs_$tty_order (channel_info.devx, "write_status", addr (write_status), state, code);
     1587 		if state ^= 5 then code = error_table_$io_no_permission;
     1588 		if code ^= 0 then return;		/* punt! */
     1589 
     1590 		if write_status.output_pending then do; /* must really and truly wait */
     1591 		     event_wait_channel.n_channels = 1;
     1592 		     event_wait_channel.channel_id (1) = channel_info.event_channel;
     1593 		     call timer_manager_$alarm_wakeup (1, "11"b, event_wait_channel.channel_id (1));
     1594 		     call ipc_$block (addr (event_wait_channel), addr (local_event_wait_info), code);
     1595 		     if code ^= 0 then call convert_ipc_code_ (code);
     1596 		     if code ^= 0 then return;	/* punt! */
     1597 		end;
     1598 	     end;
     1599 	end;
     1600 
     1601 	return;					/* this return taken only on success */
     1602 
     1603      end write_io_buffer;
     1604 
     1605 /* substraddr:  Return a pointer to the specified character of a varying or nonvarying string.  When the substraddr
     1606*   builtin function is finally implemented, these internal procedures should be removed */
     1607 
     1608 dcl  substraddr
     1609 	generic (substraddr_nonvarying when (character (*) nonvarying, fixed binary precision (1:35)),
     1610 	substraddr_varying when (character (*) varying, fixed binary precision (1:35)));
     1611 
     1612 
     1613 substraddr_nonvarying:
     1614      procedure (P_string, P_position) returns (pointer);
     1615 
     1616 dcl  P_string character (*) nonvarying parameter;
     1617 dcl  P_position fixed binary (21) parameter;
     1618 
     1619 dcl  string_overlay (length (P_string)) character (1) unaligned based (addr (P_string));
     1620 
     1621 	return (addr (string_overlay (P_position)));
     1622 
     1623      end substraddr_nonvarying;
     1624 
     1625 
     1626 substraddr_varying:
     1627      procedure (P_string, P_position) returns (pointer);
     1628 
     1629 dcl  P_string character (*) varying parameter;
     1630 dcl  P_position fixed binary (21) parameter;
     1631 
     1632 dcl  1 string_overlay aligned based (addr (P_string)),
     1633        2 lth fixed binary (21),
     1634        2 characters (0 refer (string_overlay.lth)) character (1) unaligned;
     1635 
     1636 	return (addr (string_overlay.characters (P_position)));
     1637 
     1638      end substraddr_varying;
     1639 
  1     1 /* BEGIN INCLUDE FILE ... terminal_io_record.incl.pl1 */
  1     2 /* Created:  November 1979 by G. Palter */
  1     3 /* Modified: 26 March 1982 by G. Palter to make the structure more compatible with use of the like attribute */
  1     4 
  1     5 
  1     6 /* Record format used by I/O modules designed for communcation with remote I/O daemon stations */
  1     7 
  1     8 dcl 1 terminal_io_record aligned based (terminal_io_record_ptr),
  1     9       2 header,
  1    10         3 version fixed binary,
  1    11         3 device_type fixed binary,			/* type of device sending/receiving this record --
  1    12*						   reader/printer/punch/teleprinter */
  1    13         3 slew_control,				/* slew control data: used for printer and teleprinter only */
  1    14 	4 slew_type fixed binary (18) unaligned unsigned,	/* type of slewing operation before/after this line --
  1    15*						   by-count/top-of-form/inside-page/outside-page/to-channel */
  1    16 	4 slew_count fixed binary (18) unaligned unsigned,/* # of lines if by count; channel # if to channel */
  1    17         3 flags,
  1    18 	4 binary bit (1) unaligned,			/* ON => data in record should be written in binary mode */
  1    19 	4 preslew bit (1) unaligned,			/* ON => perform above slew before printing data;
  1    20*						   OFF => perform above slew after printing data */
  1    21 	4 pad bit (34) unaligned,
  1    22         3 element_size fixed binary,			/* # of bits in a data element */
  1    23         3 n_elements fixed binary (24),			/* # of elements in the record */
  1    24       2 data,					/* force word alignment */
  1    25         3 bits (terminal_io_record_n_elements refer (terminal_io_record.n_elements))
  1    26 	  bit (terminal_io_record_element_size refer (terminal_io_record.element_size)) unaligned;
  1    27 
  1    28 dcl  terminal_io_record_ptr pointer;
  1    29 
  1    30 dcl  terminal_io_record_element_size fixed binary;	/* used for allocating terminal_io_record structures */
  1    31 dcl  terminal_io_record_n_elements fixed binary (24);
  1    32 
  1    33 
  1    34 /* Manifest constants */
  1    35 
  1    36 dcl  terminal_io_record_version_1 fixed binary static options (constant) initial (1);
  1    37 
  1    38 dcl (TELEPRINTER_DEVICE	initial (1),
  1    39      READER_DEVICE		initial (2),
  1    40      PRINTER_DEVICE		initial (3),
  1    41      PUNCH_DEVICE		initial (4))
  1    42 	fixed binary static options (constant);
  1    43 
  1    44 dcl (SLEW_BY_COUNT		initial (1),
  1    45      SLEW_TO_TOP_OF_PAGE	initial (2),
  1    46      SLEW_TO_INSIDE_PAGE	initial (3),		/* skip to top of next inside page (head sheet) */
  1    47      SLEW_TO_OUTSIDE_PAGE	initial (4),		/* skip to top of next outside page (tail sheet) */
  1    48      SLEW_TO_CHANNEL	initial (5))		/* skip to specified channel stop */
  1    49 	fixed binary static options (constant);
  1    50 
  1    51 
  1    52 /* Data in record as a character string (terminal_io_record.element_size = 9) */
  1    53 
  1    54 dcl  terminal_io_record_data_chars character (terminal_io_record.n_elements) unaligned
  1    55 	based (addr (terminal_io_record.bits));
  1    56 
  1    57 dcl  terminal_io_record_data_chars_varying_max_len fixed binary (21);  /* Set this before using the varying string. */
  1    58 dcl  terminal_io_record_data_chars_varying character (terminal_io_record_data_chars_varying_max_len) varying
  1    59 	based (addr (terminal_io_record.n_elements));	/* varying string consists of length and data */
  1    60 
  1    61 
  1    62 /* Data in record as a bit string (terminal_io_record.element_size = 1) */
  1    63 
  1    64 dcl terminal_io_record_data_bits bit (terminal_io_record.n_elements) unaligned based (addr (terminal_io_record.bits));
  1    65 
  1    66 /* END INCLUDE FILE ... terminal_io_record.incl.pl1 */
     1640 
     1641 
  2     1 /* BEGIN INCLUDE FILE ... hasp_device_data.incl.pl1 */
  2     2 /* Created:  November 1979 by G. Palter */
  2     3 
  2     4 /* HASP device types */
  2     5 
  2     6 dcl (HASP_CONSOLE		initial (1),		/* operator's console */
  2     7      HASP_READER		initial (2),
  2     8      HASP_PRINTER		initial (3),
  2     9      HASP_PUNCH		initial (4))
  2    10 	fixed binary static options (constant);
  2    11 
  2    12 
  2    13 /* Name of each type of device as used by the remote I/O daemon software */
  2    14 
  2    15 dcl  HASP_DEVICE_NAMES (4) character (32) static options (constant) initial ("teleprinter", "reader", "printer", "punch");
  2    16 
  2    17 
  2    18 /* Maximum record length for each type of device */
  2    19 
  2    20 dcl  HASP_MAX_DEVICE_RECORD_LTHS (4) fixed binary (21) static options (constant) initial (80, 80, 132, 80);
  2    21 
  2    22 /* END INCLUDE FILE ... hasp_device_data.incl.pl1 */
     1642 
     1643 
  3     1 /* BEGIN INCLUDE FILE ... hasp_srcb_scb_bytes.incl.pl1 */
  3     2 /* Created:  October 1979 by G. Palter */
  3     3 
  3     4 /* HASP End-Of-File record */
  3     5 
  3     6 dcl 1 TEMPLATE_HASP_EOF_RECORD_BITS aligned static options (constant),
  3     7     2 srcb bit (9) unaligned initial ("200"b3),		/* SRCB -- 200-bit is always ON */
  3     8     2 eor_scb bit (9) unaligned initial ("000"b3);	/* SCB -- end of record */
  3     9 
  3    10 dcl TEMPLATE_HASP_EOF_RECORD character (2) aligned based (addr (TEMPLATE_HASP_EOF_RECORD_BITS));
  3    11 
  3    12 
  3    13 /* HASP Sub-Record Control Byte (SRCB) -- operator's console */
  3    14 
  3    15 dcl  HASP_CONSOLE_SRCB_BITS bit (9) aligned static options (constant) initial ("200"b3);
  3    16 dcl  HASP_CONSOLE_SRCB character (1) aligned based (addr (HASP_CONSOLE_SRCB_BITS));
  3    17 
  3    18 
  3    19 /* HASP Sub-Record Control Byte (SRCB) -- reader/punch */
  3    20 
  3    21 dcl 1 hasp_card_srcb_byte unaligned based (hasp_card_srcb_byte_ptr),
  3    22     2 pad1 bit (1) unaligned,				/* supplied by MCS */
  3    23     2 mbo1 bit (1) unaligned,				/* always ON */
  3    24     2 count_units fixed binary (2) unaligned unsigned,	/* SCB count units: 0 => 1; 1 => 2; 2 => 4 */
  3    25     2 binary bit (1) unaligned,			/* ON => binary data record */
  3    26     2 mbz1 bit (4) unaligned;				/* always OFF */
  3    27 
  3    28 dcl  hasp_card_srcb_byte_ptr pointer;
  3    29 
  3    30 dcl 1 TEMPLATE_HASP_CARD_SRCB_BITS aligned static options (constant),
  3    31     2 pad1 bit (1) unaligned initial ("0"b),
  3    32     2 mbo1 bit (1) unaligned initial ("1"b),
  3    33     2 count_units fixed binary (2) unaligned unsigned initial (0),	/* SCB counts single characters */
  3    34     2 binary bit (1) unaligned initial ("0"b),		/* not binary card */
  3    35     2 mbz1 bit (4) unaligned initial ("0000"b);
  3    36 
  3    37 dcl  TEMPLATE_HASP_CARD_SRCB character (1) aligned based (addr (TEMPLATE_HASP_CARD_SRCB_BITS));
  3    38 
  3    39 
  3    40 /* HASP Sub-Record Control Byte (SRCB) -- printer */
  3    41 
  3    42 dcl 1 hasp_printer_srcb_byte unaligned based (hasp_printer_srcb_byte_ptr),
  3    43     2 pad1 bit (1) unaligned,				/* supplied by MCS */
  3    44     2 mbo1 bit (1) unaligned,				/* always ON */
  3    45     2 mbz1 bit (1) unaligned,				/* always OFF */
  3    46     2 prespace bit (1) unaligned,			/* ON => pre-spacing; OFF => post-spacing */
  3    47     2 skip_to_channel bit (1) unaligned,		/* ON => skip to given channel; OFF => skip # lines */
  3    48     2 number fixed binary (4) unaligned unsigned;		/* channel # or # or lines to skip */
  3    49 
  3    50 dcl  hasp_printer_srcb_byte_ptr pointer;
  3    51 
  3    52 dcl 1 TEMPLATE_HASP_PRINTER_SRCB_BITS aligned static options (constant),
  3    53     2 pad1 bit (1) unaligned initial ("0"b),
  3    54     2 mbo1 bit (1) unaligned initial ("1"b),
  3    55     2 mbz1 bit (1) unaligned initial ("0"b),
  3    56     2 prespace bit (1) unaligned initial ("0"b),		/* post-spacing */
  3    57     2 skip_to_channel bit (1) unaligned initial ("0"b),	/* # of lines */
  3    58     2 number fixed binary (4) unaligned unsigned initial (1);
  3    59 
  3    60 dcl  TEMPLATE_HASP_PRINTER_SRCB character (1) aligned based (addr (TEMPLATE_HASP_PRINTER_SRCB_BITS));
  3    61 
  3    62 dcl  HASP_MAX_SLEW_COUNT fixed binary static options (constant) initial (3);
  3    63 						/* max slew of 3 insures proper operation with 370's */
  3    64 
  3    65 dcl 1 HASP_FORMS_CHANGE_SRCB_BITS aligned static options (constant),
  3    66     2 pad1 bit (1) unaligned initial ("0"b),
  3    67     2 mbo1 bit (1) unaligned initial ("1"b),
  3    68     2 mbz1 bit (1) unaligned initial ("0"b),
  3    69     2 change bit (6) unaligned initial ("16"b3);		/* change forms record */
  3    70 
  3    71 dcl  HASP_FORMS_CHANGE_SRCB character (1) aligned based (addr (HASP_FORMS_CHANGE_SRCB_BITS));
  3    72 
  3    73 
  3    74 /* HASP String Control Byte (SCB) */
  3    75 
  3    76 dcl 1 hasp_scb_byte unaligned based (hasp_scb_byte_ptr),
  3    77     2 pad1 bit (1) unaligned,				/* supplied by MCS */
  3    78     2 not_eor bit (1) unaligned,			/* ON => not an end of record indicator */
  3    79     2 not_compressed bit (1) unaligned,			/* ON => this SCB refers to a non-compressed string */
  3    80     2 variant bit (6) unaligned;			/* dependent on setting of hasp_scb_byte.not_compressed */
  3    81 
  3    82 dcl 1 hasp_not_compressed_scb_byte unaligned based (hasp_scb_byte_ptr),
  3    83     2 pad1 bit (1) unaligned,
  3    84     2 not_eor bit (1) unaligned,
  3    85     2 not_compressed bit (1) unaligned,			/* ON */
  3    86     2 count fixed binary (6) unaligned unsigned;		/* # of characters in string following the SCB */
  3    87 
  3    88 dcl 1 hasp_compressed_scb_byte unaligned based (hasp_scb_byte_ptr),
  3    89     2 pad1 bit (1) unaligned,
  3    90     2 not_eor bit (1) unaligned,
  3    91     2 not_compressed bit (1) unaligned,			/* OFF */
  3    92     2 not_blank bit (1) unaligned,			/* ON => repeated character isn't a blank and follows SCB */
  3    93     2 count fixed binary (5) unaligned unsigned;		/* # of occurrences of the character */
  3    94 
  3    95 dcl  hasp_scb_byte_ptr pointer;
  3    96 
  3    97 dcl  HASP_EOR_SCB_BITS bit (9) aligned static options (constant) initial ("000"b3);
  3    98 dcl  HASP_EOR_SCB character (1) aligned based (addr (HASP_EOR_SCB_BITS));
  3    99 
  3   100 dcl (HASP_MAX_NOT_COMPRESSED_TEXT_LTH	initial (62),	/* # of characters representable by a single SCB */
  3   101      HASP_MAX_COMPRESSED_TEXT_LTH	initial (31))	/* # of occurences of a character representable by
  3   102*						     a single SCB */
  3   103 	fixed binary static options (constant);
  3   104 
  3   105 /* END INCLUDE FILE ... hasp_srcb_scb_bytes.incl.pl1 */
     1644 
     1645 
  4     1 /* BEGIN INCLUDE FILE ... hasp_signon_record_info.incl.pl1 */
  4     2 /* Created:  July 1981 by G. Palter */
  4     3 
  4     4 /* Structure used by the signon_record control order of a HASP sub-channel */
  4     5 
  4     6 dcl 1 signon_record_info aligned based (signon_record_info_ptr),
  4     7       2 version fixed binary,
  4     8       2 pad bit (36),
  4     9       2 event_channel fixed binary (71),		/* IPC wait channel over which success/failure is signalled */
  4    10       2 record character (80) unaligned;		/*  actual record: hasp_host_ does necessary translations */
  4    11 
  4    12 dcl  signon_record_info_ptr pointer;
  4    13 
  4    14 dcl  SIGNON_RECORD_INFO_VERSION_1 fixed binary static options (constant) initial (1);
  4    15 
  4    16 
  4    17 /* Possible results of transmitting the SIGNON record: returned as the event message signalled by the multiplexer on the
  4    18*   supplied IPC event-wait channel */ 
  4    19 
  4    20 dcl (HASP_SIGNON_OK		initial (1),		/* remote system accepted the SIGNON record */
  4    21      HASP_SIGNON_REJECTED	initial (2),		/* remote system rejected it but allows a retry */
  4    22      HASP_SIGNON_HANGUP	initial (3))		/* remote system rejected it and disconnected the line */
  4    23 	fixed binary (71) static options (constant);
  4    24 
  4    25 /* END INCLUDE FILE ... hasp_signon_record_info.incl.pl1 */
     1646 
     1647 
  5     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  5     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  5     3*      version number to IOX2. */
  5     4 /* format: style2 */
  5     5 
  5     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  5     7 	     2 version	      character (4) aligned,	/* IOX2 */
  5     8 	     2 name	      char (32),		/* I/O name of this block. */
  5     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  5    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  5    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  5    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  5    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  5    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  5    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  5    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  5    17 						/* open(p,mode,not_used,s) */
  5    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  5    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  5    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  5    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  5    24 						/* put_chars(p,bufptr,buflen,s) */
  5    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  5    26 						/* modes(p,newmode,oldmode,s) */
  5    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  5    28 						/* position(p,u1,u2,s) */
  5    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  5    30 						/* control(p,order,infptr,s) */
  5    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  5    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  5    34 						/* write_record(p,bufptr,buflen,s) */
  5    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  5    36 						/* rewrite_record(p,bufptr,buflen,s) */
  5    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  5    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  5    39 						/* seek_key(p,key,len,s) */
  5    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  5    41 						/* read_key(p,key,len,s) */
  5    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  5    43 						/* read_length(p,len,s) */
  5    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  5    45 						/* open_file(p,mode,desc,not_used,s) */
  5    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  5    47 						/* close_file(p,desc,s) */
  5    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  5    49 						/* detach(p,desc,s) */
  5    50 
  5    51      declare iox_$iocb_version_sentinel
  5    52 			      character (4) aligned external static;
  5    53 
  5    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
     1648 
     1649 
  6     1 /* Begin include file ..... iox_modes.incl.pl1 */
  6     2 
  6     3 /* Written by C. D. Tavares, 03/17/75 */
  6     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  6     5 
  6     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  6     7     ("stream_input", "stream_output", "stream_input_output",
  6     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  6     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  6    10      "direct_input", "direct_output", "direct_update");
  6    11 
  6    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  6    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  6    14 
  6    15 dcl (Stream_input initial (1),
  6    16      Stream_output initial (2),
  6    17      Stream_input_output initial (3),
  6    18      Sequential_input initial (4),
  6    19      Sequential_output initial (5),
  6    20      Sequential_input_output initial (6),
  6    21      Sequential_update initial (7),
  6    22      Keyed_sequential_input initial (8),
  6    23      Keyed_sequential_output initial (9),
  6    24      Keyed_sequential_update initial (10),
  6    25      Direct_input initial (11),
  6    26      Direct_output initial (12),
  6    27      Direct_update initial (13)) fixed bin int static options (constant);
  6    28 
  6    29 /* End include file ..... iox_modes.incl.pl1 */
     1650 
     1651 
  7     1 /* Begin include file ..... io_call_info.incl.pl1 */
  7     2 
  7     3 /* This include file defines the info_structure used by an I/O module to perform an "io_call" order
  7     4*   on behalf of the io_call command. */
  7     5 /* Coded April 1976 by Larry Johnson */
  7     6 /* Changed June 1977 by Larry Johnson for "io_call_af" order */
  7     7 
  7     8      dcl	   io_call_infop	      ptr;
  7     9 
  7    10      dcl	   1 io_call_info	      aligned based (io_call_infop),
  7    11 	     2 version	      fixed bin,
  7    12 	     2 caller_name	      char (32),		/* Caller name for error messages */
  7    13 	     2 order_name	      char (32),		/* Actual name of the order to be performed */
  7    14 	     2 report	      entry variable options (variable),
  7    15 						/* Entry to ioa_ like procedure to report results */
  7    16 	     2 error	      entry variable options (variable),
  7    17 						/* Entry to com_err_ like procedure to report results */
  7    18 	     2 af_returnp	      ptr,		/* Pointer to return string if "io_call_af"  order */
  7    19 	     2 af_returnl	      fixed bin,		/* Length of string */
  7    20 	     2 fill	      (5) bit (36) aligned,
  7    21 	     2 nargs	      fixed bin,		/* Number of additional command arguments provided */
  7    22 	     2 max_arglen	      fixed bin,		/* Length of longest argument (used to define array) */
  7    23 	     2 args	      (0 refer (io_call_info.nargs)) char (0 refer (io_call_info.max_arglen)) varying;
  7    24 
  7    25      dcl	   io_call_af_ret	      char (io_call_info.af_returnl) based (io_call_info.af_returnp) varying;
  7    26 						/* Return string for active function */
  7    27 
  7    28 /* End include file ..... io_call_info.incl.pl1 */
     1652 
     1653 
  8     1 /* BEGIN INCLUDE FILE ... dial_manager_arg.incl.pl1 */
  8     2 
  8     3 /* Modified by E. N. Kittlitz 11/80 to add reservation string, move dial-out
  8     4*   destination from dial_qualifier, add dial_message.
  8     5*   Modified by Robert Coren 4/83 to add required access class stuff.
  8     6*   Modified 1984-08-27 BIM for V4, privileged_operation.
  8     7**/
  8     8 
  8     9 
  8    10 dcl  dial_manager_arg_version_2 fixed bin internal static initial (2) options (constant);
  8    11 dcl  dial_manager_arg_version_3 fixed bin internal static initial (3) options (constant);
  8    12 dcl  dial_manager_arg_version_4 fixed bin internal static initial (4) options (constant);
  8    13 
  8    14 dcl 1 dial_manager_arg based aligned,
  8    15     2 version fixed bin,				/* = 4 */
  8    16     2 dial_qualifier char (22),			/* identify different processes with same process group id */
  8    17     2 dial_channel fixed bin (71),			/* event wait channel */
  8    18     2 channel_name char (32),				/* channel name for privileged attach */
  8    19 						/* limit of version 1 structure */
  8    20     2 dial_out_destination char (32),			/* dial-out destination (e.g. phone_no) */
  8    21     2 reservation_string char (256),			/* reservation string */
  8    22     2 dial_message fixed bin (71),			/* OUTPUT: A.S. message received by dial_manager_ */
  8    23 						/* limit of version 2 structure */
  8    24     2 access_class bit (72),				/* access class to be associated with the attachment */
  8    25     2 flags aligned,
  8    26      3 access_class_required bit (1) unaligned,		/* indicates whether to enforce access_class */
  8    27      3 privileged_operation bit (1) unaligned,		/* for accept_dials, accepts dials from */
  8    28 						/* system_low:access_class */
  8    29 						/* no effect on other operations yet. */
  8    30      3 mbz bit (34) unaligned;			/* must be zero */
  8    31 
  8    32 /* END INCLUDE FILE ... dial_manager_arg.incl.pl1 */
     1654 
     1655 
  9     1 /* BEGIN INCLUDE FILE ... event_wait_channel.incl.pl1 */
  9     2 
  9     3 /* ipc_$block wait list with one channel
  9     4*
  9     5*   Written 9-May-79 by M. N. Davidoff.
  9     6**/
  9     7 
  9     8      declare 1 event_wait_channel   aligned,
  9     9 	     2 n_channels	      fixed bin initial (1),	/* number of channels */
  9    10 	     2 pad	      bit (36),
  9    11 	     2 channel_id	      (1) fixed bin (71);	/* event channel to wait on */
  9    12 
  9    13 /* END INCLUDE FILE ... event_wait_channel.incl.pl1 */
     1656 
     1657 
 10     1 /* BEGIN INCLUDE FILE event_wait_info.incl.pl1 */
 10     2 
 10     3 /* T. Casey, May 1978 */
 10     4 
 10     5 dcl  event_wait_info_ptr ptr;
 10     6 
 10     7 dcl 1 event_wait_info aligned based (event_wait_info_ptr),	/* argument structure filled in on return from ipc_$block */
 10     8     2 channel_id fixed bin (71),			/* event channel on which wakeup occurred */
 10     9     2 message fixed bin (71),				/* 72 bits of information passed by sender of wakeup */
 10    10     2 sender bit (36),				/* process id of sender */
 10    11     2 origin,
 10    12       3 dev_signal bit (18) unaligned,			/* "1"b if device signal */
 10    13       3 ring fixed bin (17) unaligned,			/* ring from which sent */
 10    14     2 channel_index fixed bin;			/* index of this channel in the event wait list */
 10    15 
 10    16 /* END INCLUDE FILE event_wait_info.incl.pl1 */
     1658 
     1659 
 11     1 /* BEGIN INCLUDE FiLE ... terminal_type_data.incl.pl1 */
 11     2 
 11     3 
 11     4 /****^  HISTORY COMMENTS:
 11     5*  1) change(77-05-19,JStern), approve(), audit(), install():
 11     6*     Created
 11     7*     Modified 8/14/79 by Robert Coren to convert to version 2 by adding
 11     8*        flow control parameters
 11     9*  2) change(87-03-09,LJAdams), approve(87-04-03,MCR7646),
 11    10*     audit(87-05-05,Gilcrease), install(87-08-04,MR12.1-1056):
 11    11*     Change the ttd_version to ttd_version_3.  Add the protocol field.
 11    12*                                                   END HISTORY COMMENTS */
 11    13 
 11    14 
 11    15 dcl 1 terminal_type_data aligned based (ttdp),		/* info structure for set_terminal_data order */
 11    16       2 version fixed bin,				/* structure version */
 11    17       2 old_type fixed bin,				/* old terminal type number, -1 => none */
 11    18       2 name char (32) unaligned,			/* terminal type name */
 11    19       2 tables,
 11    20         3 input_tr_ptr ptr,				/* input translation table ptr */
 11    21         3 output_tr_ptr ptr,				/* output translation table ptr */
 11    22         3 input_cv_ptr ptr,				/* input conversion table ptr */
 11    23         3 output_cv_ptr ptr,				/* output conversion table ptr */
 11    24         3 special_ptr ptr,				/* special chars table ptr */
 11    25         3 delay_ptr ptr,				/* delay table ptr */
 11    26       2 editing_chars unaligned,
 11    27         3 erase char (1) unaligned,
 11    28         3 kill char (1) unaligned,
 11    29       2 framing_chars unaligned,
 11    30         3 frame_begin char (1) unaligned,
 11    31         3 frame_end char (1) unaligned,
 11    32       2 flags unal,
 11    33         3 keyboard_locking bit (1),			/* ON to request keyboard locking and unlocking */
 11    34         3 input_timeout bit (1),
 11    35         3 output_block_acknowledge bit (1),
 11    36         3 mbz bit (15),
 11    37       2 line_delimiter char (1) unal,
 11    38       2 mbz bit (9) unal,
 11    39 
 11    40       /* the remainder of this structure is only present if version is 2 or more */
 11    41 
 11    42       2 flow_control_chars unal,
 11    43         3 input_suspend char (1),
 11    44         3 input_resume char (1),
 11    45         3 output_suspend_etb char (1),
 11    46         3 output_resume_ack char (1),
 11    47       2 output_buffer_size fixed bin,
 11    48 
 11    49       /* the remainder of this structure is only present if version is 3 or more */
 11    50       2 protocol fixed bin; /* 0=NONE; 1=MOWSE */
 11    51 
 11    52 
 11    53 dcl  ttdp ptr;					/* ptr to terminal_type_data structure */
 11    54 dcl  ttd_version_3 fixed bin int static options (constant) init (3);
 11    55 						/* current version of structure */
 11    56 
 11    57 
 11    58 /* END INCLUDE FILE ... terminal_type_data.incl.pl1 */
     1660 
     1661 
 12     1 /*	BEGIN INCLUDE FILE ... tty_convert.incl.pl1	*/
 12     2 
 12     3 /* tty_ conversion tables */
 12     4 /* Created 11/3/75 by Robert S. Coren */
 12     5 /* Info structures added 5/19/77 by Robert S. Coren */
 12     6 /* Length of cv_trans changed from 128 to 256 05/03/78 by Robert Coren */
 12     7 /* conversion table mnemonics added JRDavis 21 Aug 80 */
 12     8 /* fix special_chars_struc to have good refers Fri 13 Feb 81 JRDavis */
 12     9 
 12    10 
 12    11 /****^  HISTORY COMMENTS:
 12    12*  1) change(85-12-01,Negaret), approve(87-07-23,MCR7742),
 12    13*     audit(87-07-23,GDixon), install(87-08-04,MR12.1-1056):
 12    14*      Added INPUT_CONVERT_DSA_CR_PROCESSING constant.
 12    15*  2) change(88-01-22,Brunelle), approve(88-01-22,MCR7813),
 12    16*     audit(88-10-05,Blair), install(88-10-17,MR12.2-1171):
 12    17*     Expand c_chars definition from 3 chars to 15.  Change SPECIAL_VERSION
 12    18*     from 1 to 2.  Add version variable to get_special_info_struc and define
 12    19*     SPECIAL_INFO_STRUCT_VERSION_1.
 12    20*                                                   END HISTORY COMMENTS */
 12    21 
 12    22 
 12    23 /* format: style2,linecom,^indnoniterdo,indcomtxt,^inditerdo,dclind5,idind25 */
 12    24 
 12    25 
 12    26      dcl	1 special_chars	     aligned based,		/* table of special character sequences */
 12    27 	  2 nl_seq	     aligned like c_chars,	/* new-line sequence */
 12    28 	  2 cr_seq	     aligned like c_chars,	/* carriage-return sequence */
 12    29 	  2 bs_seq	     aligned like c_chars,	/* backspace sequence */
 12    30 	  2 tab_seq	     aligned like c_chars,	/* horizontal tab sequence */
 12    31 	  2 vt_seq	     aligned like c_chars,	/* vertical tab sequence */
 12    32 	  2 ff_seq	     aligned like c_chars,	/* form-feed sequence */
 12    33 	  2 printer_on	     aligned like c_chars,	/* printer-on sequence */
 12    34 	  2 printer_off	     aligned like c_chars,	/* printer_off sequence */
 12    35 	  2 red_ribbon_shift     aligned like c_chars,	/* red ribbon shift sequence */
 12    36 	  2 black_ribbon_shift   aligned like c_chars,	/* black ribbon shift sequence */
 12    37 	  2 end_of_page	     aligned like c_chars,	/* end-of-page warning sequence */
 12    38 	  2 escape_length	     fixed bin,		/* number of escape sequences */
 12    39 	  2 not_edited_escapes   (sc_escape_len refer (special_chars.escape_length)) like c_chars,
 12    40 						/* use in ^edited mode */
 12    41 	  2 edited_escapes	     (sc_escape_len refer (special_chars.escape_length)) like c_chars,
 12    42 						/* use in edited mode */
 12    43 	  2 input_escapes	     aligned,
 12    44 	    3 len		     fixed bin (8) unaligned, /* length of string */
 12    45 	    3 str		     char (sc_input_escape_len refer (special_chars.input_escapes.len)) unaligned,
 12    46 						/* escape sequence characters */
 12    47 	  2 input_results	     aligned,
 12    48 	    3 pad		     bit (9) unaligned,	/* so that strings will look the same */
 12    49 	    3 str		     char (sc_input_escape_len refer (special_chars.input_escapes.len)) unaligned;
 12    50 						/* results of escape sequences */
 12    51 
 12    52 
 12    53      dcl	c_chars_ptr	     ptr;
 12    54      dcl	1 c_chars		     based (c_chars_ptr) aligned,
 12    55 	  2 count		     fixed bin (8) unaligned,
 12    56 	  2 chars		     (15) char (1) unaligned;
 12    57 
 12    58      dcl	sc_escape_len	     fixed bin;		/* count of output escapes to allocate in special_chars  */
 12    59      dcl	sc_input_escape_len	     fixed bin;		/* count of input escapes to allocate in special_chars  */
 12    60 
 12    61 
 12    62      dcl	1 cv_trans	     based aligned,		/* conversion/translation table format */
 12    63 	  2 value		     (0:255) fixed bin (8) unal;
 12    64 
 12    65 
 12    66      dcl	1 delay		     based aligned,		/* delay counts for output */
 12    67 	  2 vert_nl	     fixed bin,
 12    68 	  2 horz_nl	     float bin,
 12    69 	  2 const_tab	     fixed bin,
 12    70 	  2 var_tab	     float bin,
 12    71 	  2 backspace	     fixed bin,
 12    72 	  2 vt_ff		     fixed bin;
 12    73 
 12    74 /* info structures used with orders */
 12    75 
 12    76      dcl	1 special_chars_struc    aligned based,
 12    77 	  2 version	     fixed bin,
 12    78 	  2 default	     fixed bin,		/* non-zero indicates use default */
 12    79 	  2 special_chars,				/* same as level-1 above */
 12    80 						/* has to be spelled out instead of using like */
 12    81 						/* because of refer options */
 12    82 	    3 nl_seq	     aligned like c_chars,	/* new-line sequence */
 12    83 	    3 cr_seq	     aligned like c_chars,	/* carriage-return sequence */
 12    84 	    3 bs_seq	     aligned like c_chars,	/* backspace sequence */
 12    85 	    3 tab_seq	     aligned like c_chars,	/* horizontal tab sequence */
 12    86 	    3 vt_seq	     aligned like c_chars,	/* vertical tab sequence */
 12    87 	    3 ff_seq	     aligned like c_chars,	/* form-feed sequence */
 12    88 	    3 printer_on	     aligned like c_chars,	/* printer-on sequence */
 12    89 	    3 printer_off	     aligned like c_chars,	/* printer_off sequence */
 12    90 	    3 red_ribbon_shift   aligned like c_chars,	/* red ribbon shift sequence */
 12    91 	    3 black_ribbon_shift aligned like c_chars,	/* black ribbon shift sequence */
 12    92 	    3 end_of_page	     aligned like c_chars,	/* end-of-page warning sequence */
 12    93 	    3 escape_length	     fixed bin,		/* number of escape sequences */
 12    94 	    3 not_edited_escapes (sc_escape_len refer (special_chars_struc.escape_length)) like c_chars,
 12    95 						/* use in ^edited mode */
 12    96 	    3 edited_escapes     (sc_escape_len refer (special_chars_struc.escape_length)) like c_chars,
 12    97 						/* use in edited mode */
 12    98 	    3 input_escapes	     aligned,
 12    99 	      4 len	     fixed bin (8) unaligned, /* length of string */
 12   100 	      4 str	     char (sc_input_escape_len refer (special_chars_struc.input_escapes.len)) unaligned,
 12   101 						/* escape sequence characters */
 12   102 	    3 input_results	     aligned,
 12   103 	      4 pad	     bit (9) unaligned,	/* so that strings will look the same */
 12   104 	      4 str	     char (sc_input_escape_len refer (special_chars_struc.input_escapes.len)) unaligned;
 12   105 						/* results of escape sequences */
 12   106 
 12   107      dcl	1 cv_trans_struc	     aligned based,		/* all conversion/translation tables */
 12   108 	  2 version	     fixed bin,
 12   109 	  2 default	     fixed bin,		/* as above */
 12   110 	  2 cv_trans	     like cv_trans;
 12   111 
 12   112      dcl	1 delay_struc	     aligned based,
 12   113 	  2 version	     fixed bin,
 12   114 	  2 default	     fixed bin,		/* as above */
 12   115 	  2 delay		     like delay;
 12   116 
 12   117      dcl	1 get_special_info_struc based aligned,		/* get_special order */
 12   118 	  2 version	     char (8),
 12   119 	  2 area_ptr	     pointer,
 12   120 	  2 table_ptr	     pointer;
 12   121 
 12   122      dcl	SPECIAL_INFO_STRUCT_VERSION_1
 12   123 			     char (8) int static options (constant) init ("sisv1000");
 12   124      dcl	SPECIAL_VERSION	     fixed bin int static options (constant) init (1);
 12   125      dcl	SPECIAL_VERSION_2	     fixed bin int static options (constant) init (2);
 12   126      dcl	DELAY_VERSION	     fixed bin int static options (constant) init (1);
 12   127      dcl	CV_TRANS_VERSION	     fixed bin int static options (constant) init (2);
 12   128 
 12   129      dcl	CV_TRANS_SIZE	     (2) fixed bin int static options (constant) init (127, 255);
 12   130 						/* indexed by version number */
 12   131 
 12   132 
 12   133 /* values for input and output conversion tables */
 12   134 
 12   135      dcl	(
 12   136 	INPUT_CONVERT_ORDINARY   init (0),
 12   137 	INPUT_CONVERT_BREAK	     init (1),
 12   138 	INPUT_CONVERT_ESCAPE     init (2),
 12   139 	INPUT_CONVERT_DISCARD    init (3),
 12   140 	INPUT_CONVERT_FORMFEED   init (4),
 12   141 	INPUT_CONVERT_PRECEDENCE_DISCARD
 12   142 			     init (5),
 12   143 	INPUT_CONVERT_DSA_CR_PROCESSING
 12   144 			     init (6)
 12   145 	)		     fixed bin (8) unaligned internal static options (constant);
 12   146 
 12   147      dcl	(
 12   148 	OUTPUT_CONVERT_ORDINARY  init (0),
 12   149 	OUTPUT_CONVERT_NEWLINE   init (1),
 12   150 	OUTPUT_CONVERT_CR	     init (2),
 12   151 	OUTPUT_CONVERT_HT	     init (3),
 12   152 	OUTPUT_CONVERT_BS	     init (4),
 12   153 	OUTPUT_CONVERT_VT	     init (5),
 12   154 	OUTPUT_CONVERT_FF	     init (6),
 12   155 	OUTPUT_CONVERT_OCTAL     init (7),
 12   156 	OUTPUT_CONVERT_RRS	     init (8),
 12   157 	OUTPUT_CONVERT_BRS	     init (9),
 12   158 	OUTPUT_CONVERT_NO_MOTION init (10),
 12   159 	OUTPUT_CONVERT_PRECEDENCE_NO_MOTION
 12   160 			     init (11),
 12   161 	OUTPUT_CONVERT_DONT_SEND init (12),
 12   162 	OUTPUT_CONVERT_NOT_USED_13
 12   163 			     init (13),
 12   164 	OUTPUT_CONVERT_NOT_USED_14
 12   165 			     init (14),
 12   166 	OUTPUT_CONVERT_NOT_USED_15
 12   167 			     init (15),
 12   168 	OUTPUT_CONVERT_NOT_USED_16
 12   169 			     init (16),
 12   170 	OUTPUT_CONVERT_FIRST_SPECIAL
 12   171 			     init (17)
 12   172 	)		     fixed bin (8) unaligned internal static options (constant);
 12   173 
 12   174 /*	END INCLUDE FILE ... tty_convert.incl.pl1 */
     1662 
     1663 
 13     1 /* BEGIN INCLUDE FILE ... tty_get_channel_info.incl.pl1 */
 13     2 
 13     3 /* for get_channel_info order to tty_ */
 13     4 
 13     5      dcl	   1 tty_get_channel_info aligned based,
 13     6 	     2 version	      fixed bin init (tty_get_channel_info_version),
 13     7 	     2 devx	      fixed bin,
 13     8 	     2 channel_name	      char (32);
 13     9 
 13    10      dcl	   tty_get_channel_info_version fixed bin init (1) internal static options (constant);
 13    11 
 13    12 /* END INCLUDE FILE ... tty_get_channel_info.incl.pl1 */
     1664 
     1665 
     1666      end hasp_host_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/17/88  1034.0  hasp_host_.pl1                    >spec>install>MR12.2-1171>hasp_host_.pl1
1640         1    11/12/82  1624.8  terminal_io_record.incl.pl1       >ldd>include>terminal_io_record.incl.pl1
1642         2    03/27/82  0436.6  hasp_device_data.incl.pl1         >ldd>include>hasp_device_data.incl.pl1
1644         3    03/27/82  0436.6  hasp_srcb_scb_bytes.incl.pl1      >ldd>include>hasp_srcb_scb_bytes.incl.pl1
1646         4    03/27/82  0429.7  hasp_signon_record_info.incl.pl1  >ldd>include>hasp_signon_record_info.incl.pl1
1648         5    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
1650         6    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
1652         7    07/19/79  1547.1  io_call_info.incl.pl1             >ldd>include>io_call_info.incl.pl1
1654         8    09/13/84  0921.5  dial_manager_arg.incl.pl1         >ldd>include>dial_manager_arg.incl.pl1
1656         9    06/29/79  1728.0  event_wait_channel.incl.pl1       >ldd>include>event_wait_channel.incl.pl1
1658        10    06/29/79  1727.8  event_wait_info.incl.pl1          >ldd>include>event_wait_info.incl.pl1
1660        11    08/06/87  0913.5  terminal_type_data.incl.pl1       >ldd>include>terminal_type_data.incl.pl1
1662        12    10/17/88  1024.1  tty_convert.incl.pl1              >spec>install>MR12.2-1171>tty_convert.incl.pl1
1664        13    01/28/81  0923.4  tty_get_channel_info.incl.pl1     >ldd>include>tty_get_channel_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ASCII_SPACE                     011610 constant        char(1)                  initial packed unaligned dcl 203 ref 421
EBCDIC_SPACE                           constant        char(1)                  initial packed unaligned dcl 203 ref 371
HASP_CONSOLE                           constant        fixed bin(17,0)          initial dcl 2-6 ref 949 955 1075 1192
HASP_CONSOLE_SRCB                      based           char(1)                  dcl 3-16 set ref 1075*
HASP_CONSOLE_SRCB_BITS          000120 constant        bit(9)                   initial dcl 3-15 set ref 1075
HASP_DEVICE_NAMES               000121 constant        char(32)                 initial array packed unaligned dcl 2-15 set ref 396
                                                                                  396 397 399 399* 495* 495* 576* 576*
HASP_EOR_SCB                           based           char(1)                  dcl 3-98 set ref 1091*
HASP_EOR_SCB_BITS                      constant        bit(9)                   initial dcl 3-97 set ref 1091
HASP_MAX_NOT_COMPRESSED_TEXT_LTH       constant        fixed bin(17,0)          initial dcl 3-100 ref 890 1048 1048
HASP_PRINTER                           constant        fixed bin(17,0)          initial dcl 2-6 ref 635 925 950 995 1187
HASP_PUNCH                             constant        fixed bin(17,0)          initial dcl 2-6 ref 635 951 955 995 1187
HASP_READER                            constant        fixed bin(17,0)          initial dcl 2-6 ref 641 760 1076
LOWERCASE                       000170 constant        char(26)                 initial packed unaligned dcl 208 ref 408 1149
NAME                            000177 constant        char(32)                 initial packed unaligned dcl 200 set ref 342* 458
                                                                                  543* 1424*
NUL                                    constant        char(1)                  initial packed unaligned dcl 203 ref 1505
PRINTER_DEVICE                         constant        fixed bin(17,0)          initial dcl 1-38 ref 950
PUNCH_DEVICE                           constant        fixed bin(17,0)          initial dcl 1-38 ref 951
P_attach_options                       parameter       varying char             array dcl 71 set ref 331 353 375 375 377* 379 1446
                                                                                  1451* 1452 1473 1478* 1479
P_buffer_lth                           parameter       fixed bin(21,0)          dcl 84 ref 752 793 798
P_buffer_ptr                           parameter       pointer                  dcl 83 ref 752 788
P_character                            parameter       char(1)                  dcl 1553 ref 1550 1560
P_code                                 parameter       fixed bin(35,0)          dcl 1324 in procedure "cleanup_attachment" set ref
                                                                                  1321 1326* 1359*
P_code                                 parameter       fixed bin(35,0)          dcl 69 in procedure "hasp_host_" set ref 331 341*
                                                                                  342* 608* 614 620* 628* 637* 643* 674* 679 685*
                                                                                  707* 713 719* 724* 747* 752 761* 781* 794* 981*
                                                                                  987 996* 1016* 1024* 1029* 1034* 1102* 1107 1124*
                                                                                  1297* 1303 1315*
P_info_ptr                             parameter       pointer                  dcl 90 ref 1107 1115
P_iocb_ptr                             parameter       pointer                  dcl 68 ref 331 334 614 617 679 682 713 716 752 755
                                                                                  987 990 1107 1110 1303 1306
P_loud_sw                              parameter       bit(1)                   packed unaligned dcl 72 ref 331 335
P_new_modes                            parameter       char                     packed unaligned dcl 93 ref 1303 1311 1311
P_old_modes                            parameter       char                     packed unaligned dcl 94 set ref 1303 1308*
P_open_mode                            parameter       fixed bin(17,0)          dcl 74 ref 614 624
P_open_sw                              parameter       bit(1)                   packed unaligned dcl 75 ref 614
P_order                                parameter       char                     packed unaligned dcl 89 ref 1107 1114
P_position                             parameter       fixed bin(21,0)          dcl 1630 in procedure "substraddr_varying" ref 1626
                                                                                  1636
P_position                             parameter       fixed bin(21,0)          dcl 1617 in procedure "substraddr_nonvarying" ref
                                                                                  1613 1621
P_record_lth                           parameter       fixed bin(21,0)          dcl 77 set ref 752 972* 987 1020 1020 1027 1027
P_record_ptr                           parameter       pointer                  dcl 86 ref 987 1013
P_string                               parameter       char                     packed unaligned dcl 1616 in procedure
                                                                                  "substraddr_nonvarying" set ref 1613 1621
P_string                               parameter       varying char             dcl 1629 in procedure "substraddr_varying" set ref
                                                                                  1626 1636
P_translate_string_lth                 parameter       fixed bin(21,0)          dcl 1499 ref 1494 1503 1505 1505 1505
P_translate_string_ptr                 parameter       pointer                  dcl 1498 ref 1494 1503 1505 1505 1505
P_translate_table                      parameter       char(512)                dcl 1497 set ref 1494 1503* 1505 1505* 1505
SIGNON_RECORD_INFO_VERSION_1           constant        fixed bin(17,0)          initial dcl 4-14 ref 1145
SLEW_BY_COUNT                          constant        fixed bin(17,0)          initial dcl 1-44 ref 957 965
SLEW_TO_CHANNEL                        constant        fixed bin(17,0)          initial dcl 1-44 ref 963
Sequential_input                       constant        fixed bin(17,0)          initial dcl 6-15 ref 626 641 655
Sequential_input_output                constant        fixed bin(17,0)          initial dcl 6-15 ref 626 655 658
Sequential_output                      constant        fixed bin(17,0)          initial dcl 6-15 ref 626 635 658
TELEPRINTER_DEVICE                     constant        fixed bin(17,0)          initial dcl 1-38 ref 949
TEMPLATE_HASP_CARD_SRCB                based           char(1)                  dcl 3-37 set ref 1076*
TEMPLATE_HASP_CARD_SRCB_BITS    000001 constant        structure                level 1 dcl 3-30 set ref 1076
TEMPLATE_HASP_EOF_RECORD               based           char(2)                  dcl 3-10 set ref 925 1196 1197
TEMPLATE_HASP_EOF_RECORD_BITS   000000 constant        structure                level 1 dcl 3-6 set ref 925 1196 1197
UPPERCASE                       000161 constant        char(26)                 initial packed unaligned dcl 208 ref 408 1149
actual_iocb_ptr          12            based           pointer                  level 2 dcl 5-6 ref 617 682 755 990 1110 1306
addr                                                   builtin function         dcl 270 ref 367 367 369 369 410 410 415 415 418 418
                                                                                  525 525 532 532 532 532 571 571 585 585 599 667
                                                                                  770 790 806 812 824 830 843 846 885 902 914 925
                                                                                  938 938 938 938 938 938 977 1005 1041 1041 1041
                                                                                  1041 1041 1041 1041 1041 1057 1075 1076 1078 1078
                                                                                  1078 1078 1082 1082 1082 1082 1091 1098 1167 1167
                                                                                  1174 1174 1174 1174 1196 1196 1197 1370 1370 1526
                                                                                  1526 1533 1533 1533 1533 1539 1539 1586 1586 1594
                                                                                  1594 1594 1594 1621 1621 1636 1636
any_other                       001130 stack reference condition                dcl 268 ref 595 651 737
area                            001136 stack reference condition                dcl 268 ref 877 883 1061
argument                               based           char                     packed unaligned dcl 102 set ref 381 384 386 390 393
                                                                                  405 405 424 424 428 431 434 437 437 440* 1444 1454
                                                                                  1457 1471 1481* 1483*
argument_idx                    000124 automatic       fixed bin(17,0)          dcl 119 set ref 375* 377 379* 1446 1449* 1449 1451
                                                                                  1452 1473 1476* 1476 1478 1479
argument_lth                    000103 automatic       fixed bin(21,0)          dcl 103 set ref 379* 381 384 386 390 393 405 405 424
                                                                                  424 428 431 434 437 437 440 440 1444 1452* 1454
                                                                                  1457 1471 1479* 1481 1481 1483 1483
argument_ptr                    000104 automatic       pointer                  dcl 104 set ref 377* 381 384 386 390 393 405 405 424
                                                                                  424 428 431 434 437 437 440 1444 1451* 1454 1457
                                                                                  1471 1478* 1481 1483
ascii_to_ebcdic_$ae_table       000014 external static char(128)                packed unaligned dcl 212 set ref 369 369 369 369
attach_channel_is_call
                         30(01)        based           bit(1)                   level 3 packed packed unaligned dcl 293 set ref
                                                                                  1263* 1364
attach_data_ptr          16            based           pointer                  level 2 dcl 5-6 set ref 600* 632 730 756 991 1111
                                                                                  1307
attach_descrip_ptr       14            based           pointer                  level 2 dcl 5-6 set ref 340 599* 718 741*
attach_description                     based           varying char(256)        level 2 dcl 276 set ref 458* 459* 459 460* 460 461*
                                                                                  461 462* 462 464* 464 465* 465 467* 467 599
attach_event_channel     14            based           fixed bin(71,0)          level 2 dcl 293 set ref 483* 516* 521 530 1260*
                                                                                  1364* 1367 1374 1374*
attached                 30            based           bit(1)                   level 3 packed packed unaligned dcl 293 set ref 552*
                                                                                  1363 1371*
binary                    3            based           bit(1)                   level 4 in structure "terminal_io_record" packed
                                                                                  packed unaligned dcl 1-8 in procedure "hasp_host_"
                                                                                  set ref 1033
binary                                                 builtin function         dcl 270 in procedure "hasp_host_" ref 790 790
bits                      6            based           bit                      array level 3 packed packed unaligned dcl 1-8 set
                                                                                  ref 938 938 1041 1041 1041 1041
c_chars                                based           structure                level 1 dcl 12-54
caller_message                  000102 automatic       char(256)                packed unaligned dcl 1418 set ref 1423* 1424*
chain                    24            based           structure                level 2 in structure "channel_info" dcl 293
                                                                                  in procedure "hasp_host_"
chain                   514            based           structure                level 2 in structure "had" dcl 276 in procedure
                                                                                  "hasp_host_"
channel_id                2     001170 automatic       fixed bin(71,0)          array level 2 dcl 9-8 set ref 530* 1173* 1532* 1592*
                                                                                  1593*
channel_info                           based           structure                level 1 dcl 293 set ref 480 1385
channel_info_ptr        110            based           pointer                  level 2 in structure "had" dcl 276 in procedure
                                                                                  "hasp_host_" set ref 372* 507* 633 731 757 992
                                                                                  1112 1330 1332
channel_info_ptr                001154 automatic       pointer                  dcl 312 in procedure "hasp_host_" set ref 473* 473*
                                                                                  475* 476 478 480* 481 482 483 483 483 484 485 486
                                                                                  487 489 490 491 492 495 495 500 500 502 503 505
                                                                                  507 512 516 521 530 552 555 558 567 567 571 573
                                                                                  576 585 633* 635 635 641 731* 757* 760 779 780 822
                                                                                  824 825 826 843 845 904 905 914 915 925 929 949
                                                                                  950 951 955 955 992* 995 995 1075 1076 1112* 1151
                                                                                  1167 1173 1187 1187 1192 1214 1216 1216 1221 1233
                                                                                  1233 1235 1236 1238 1247 1260 1263 1278 1279 1293
                                                                                  1332* 1334 1338 1342 1359 1359 1361 1361 1363 1364
                                                                                  1364 1367 1368 1371 1374 1374 1377 1377 1379 1379
                                                                                  1381 1381 1383 1383 1385 1386* 1526 1532 1539 1578
                                                                                  1586 1592
channel_name              2            based           char(32)                 level 2 in structure "get_channel_info" dcl 198
                                                                                  in procedure "hasp_host_" set ref 1279*
channel_name             12     000326 automatic       char(32)                 level 2 in structure "dma" dcl 134 in procedure
                                                                                  "hasp_host_" set ref 522* 1368*
character_value                 000261 automatic       char(32)                 packed unaligned dcl 129 set ref 385*
characters                1            based           char(1)                  array level 2 packed packed unaligned dcl 1632 set
                                                                                  ref 1636
cleanup                         001144 stack reference condition                dcl 268 ref 348 691 768 1003
close                    36            based           entry variable           level 2 dcl 5-6 set ref 664*
code                            000102 automatic       fixed bin(35,0)          dcl 100 set ref 336* 410* 411 411* 516* 517 517* 518
                                                                                  518* 525* 526 527 527* 532* 535 535* 536 536* 538*
                                                                                  540 540* 555* 557 558* 559 559* 560 560* 567* 568*
                                                                                  569 569* 571* 572* 573 579 581* 585* 586* 587 587*
                                                                                  608 733* 747 758* 833 879* 897* 925* 932* 933 941*
                                                                                  981 993* 1063* 1086* 1102 1116* 1139* 1145* 1151*
                                                                                  1152* 1167* 1168* 1169 1174* 1175 1175* 1176 1188*
                                                                                  1199 1202* 1210* 1221* 1222* 1238* 1239* 1247*
                                                                                  1248* 1256* 1260* 1262 1262* 1263 1272* 1274*
                                                                                  1293* 1294* 1297 1309* 1313* 1315 1429* 1431*
                                                                                  1481* 1483 1526* 1527* 1528 1533* 1534 1534* 1535
                                                                                  1539* 1540* 1541 1578* 1580* 1581 1586* 1587* 1588
                                                                                  1594* 1595 1595* 1596
com_err_                        000100 constant        entry                    external dcl 225 ref 342 543 1424
compress_code                   001076 automatic       fixed bin(35,0)          dcl 175 set ref 1078* 1082* 1085
continue_to_signal_             000102 constant        entry                    external dcl 226 ref 1402
control                  66            based           entry variable           level 2 dcl 5-6 set ref 661* 700*
convert_dial_message_           000104 constant        entry                    external dcl 227 ref 538
convert_ipc_code_               000106 constant        entry                    external dcl 230 ref 517 535 559 1175 1262 1534 1595
copy                                                   builtin function         dcl 270 ref 1505
cu_$arg_list_ptr                000110 constant        entry                    external dcl 231 ref 1423 1423
cu_$arg_ptr                     000112 constant        entry                    external dcl 232 ref 1420
currentsize                                            builtin function         dcl 270 ref 1020 1027
cv_dec_check_                   000114 constant        entry                    external dcl 233 ref 1481
cv_string_buffer                       based           char                     packed unaligned dcl 163 set ref 770 864* 864* 882
                                                                                  885 977
cv_string_buffer_lth            000622 automatic       fixed bin(21,0)          dcl 165 set ref 770 770 807* 864 864 864 864 864*
                                                                                  876* 876 882 882 885 885 977 977
cv_string_buffer_ptr            000624 automatic       pointer                  dcl 166 set ref 766* 770 770 770 806* 864 864 884
                                                                                  885 885 887* 938 938 977 977 977
cv_string_buffer_space          000636 automatic       char(384)                packed unaligned dcl 172 set ref 770 806 807 885 977
cv_string_buffer_used                  based           char                     packed unaligned dcl 164 set ref 884* 884 938 938
cv_string_buffer_used_lth       000623 automatic       fixed bin(21,0)          dcl 165 set ref 808* 864* 884 884 924 937 938 938
                                                                                  938 941
cv_trans                               based           structure                level 1 dcl 12-62 in procedure "hasp_host_"
cv_trans                  2            based           structure                level 2 in structure "cv_trans_struc" dcl 12-107
                                                                                  in procedure "hasp_host_"
cv_trans_struc                         based           structure                level 1 dcl 12-107
data                      2            based           char                     level 2 in structure "held_input" dcl 321
                                                                                  in procedure "hasp_host_" set ref 824 840* 841*
                                                                                  846 913*
data                      6            based           structure                level 2 in structure "terminal_io_record" dcl 1-8
                                                                                  in procedure "hasp_host_" set ref 790 1082 1082
data_ptr                  4            based           pointer                  level 2 dcl 193 set ref 1260*
delay                                  based           structure                level 1 dcl 12-66
detach_iocb              26            based           entry variable           level 2 dcl 5-6 set ref 602* 665* 698*
device_name                     000135 automatic       char(32)                 packed unaligned dcl 121 set ref 361* 394* 397 399*
                                                                                  452 462
device_type               1            based           fixed bin(17,0)          level 3 in structure "terminal_io_record" dcl 1-8
                                                                                  in procedure "hasp_host_" set ref 949* 950* 951*
device_type                     000257 automatic       fixed bin(17,0)          dcl 126 in procedure "hasp_host_" set ref 395* 396
                                                                                  397* 399 482 495 495
device_type              10            based           fixed bin(17,0)          level 2 in structure "channel_info" dcl 293
                                                                                  in procedure "hasp_host_" set ref 482* 495 495 573
                                                                                  576 635 635 641 760 925 949 950 951 955 955 995
                                                                                  995 1075 1076 1187 1187 1192
devx                      1            based           fixed bin(17,0)          level 2 in structure "get_channel_info" dcl 198
                                                                                  in procedure "hasp_host_" set ref 1278*
devx                     11            based           fixed bin(17,0)          level 2 in structure "channel_info" dcl 293
                                                                                  in procedure "hasp_host_" set ref 483* 512 567*
                                                                                  571* 585* 1151* 1167* 1221* 1238* 1247* 1278 1293*
                                                                                  1359 1359* 1526* 1539* 1578* 1586*
dial_channel             10     000326 automatic       fixed bin(71,0)          level 2 dcl 134 set ref 521* 1367*
dial_manager_$privileged_attach 000116 constant        entry                    external dcl 234 ref 525
dial_manager_$release_channel   000120 constant        entry                    external dcl 235 ref 1370
dial_manager_arg                       based           structure                level 1 dcl 8-14
dial_manager_arg_version_2             constant        fixed bin(17,0)          initial dcl 8-10 ref 520 1366
dial_out_destination     22     000326 automatic       char(32)                 level 2 dcl 134 set ref 523* 1369*
dial_qualifier            1     000326 automatic       char(22)                 level 2 dcl 134 set ref 523* 1369*
dialed_up                       000505 automatic       bit(1)                   level 2 packed packed unaligned dcl 139 set ref 542
dialup_msg_channel              000475 automatic       char(32)                 packed unaligned dcl 138 set ref 538* 543*
dialup_msg_flags                000505 automatic       structure                level 1 dcl 139 set ref 538*
dimension                                              builtin function         dcl 270 ref 399 415 415 418 418
divide                                                 builtin function         dcl 270 ref 1048
dma                             000326 automatic       structure                level 1 dcl 134 set ref 525 525 1370 1370
ebcdic_to_ascii_$ea_table       000016 external static char(256)                packed unaligned dcl 213 set ref 367 367 367 367
element_size              4            based           fixed bin(17,0)          level 3 dcl 1-8 set ref 938 938 970* 1020 1027 1033
                                                                                  1041 1041 1041 1041
eof_pending              30(02)        based           bit(1)                   level 3 packed packed unaligned dcl 293 set ref 779
                                                                                  780* 929* 1216 1236*
error_table_$action_not_performed
                                000020 external static fixed bin(35,0)          dcl 215 ref 526 1429
error_table_$bad_conversion     000022 external static fixed bin(35,0)          dcl 215 set ref 1483*
error_table_$bad_mode           000024 external static fixed bin(35,0)          dcl 215 ref 628 637 643 1313
error_table_$badopt             000026 external static fixed bin(35,0)          dcl 215 set ref 440*
error_table_$device_type_unknown
                                000030 external static fixed bin(35,0)          dcl 215 set ref 399*
error_table_$eof_record         000032 external static fixed bin(35,0)          dcl 215 ref 781 925 932 933
error_table_$improper_data_format
                                000034 external static fixed bin(35,0)          dcl 215 ref 897 1024 1029 1034 1086
error_table_$incorrect_device_type
                                000036 external static fixed bin(35,0)          dcl 215 set ref 495* 576*
error_table_$invalid_read       000040 external static fixed bin(35,0)          dcl 215 ref 761
error_table_$invalid_write      000042 external static fixed bin(35,0)          dcl 215 ref 996 1188
error_table_$io_no_permission   000044 external static fixed bin(35,0)          dcl 215 ref 568 572 586 1152 1168 1222 1239 1248
                                                                                  1294 1527 1540 1580 1587
error_table_$long_record        000046 external static fixed bin(35,0)          dcl 215 ref 874 941
error_table_$noalloc            000050 external static fixed bin(35,0)          dcl 215 ref 879 1063
error_table_$noarg              000052 external static fixed bin(35,0)          dcl 215 set ref 353* 446* 449* 452* 1446* 1473*
error_table_$not_attached       000054 external static fixed bin(35,0)          dcl 215 ref 719
error_table_$not_closed         000056 external static fixed bin(35,0)          dcl 215 ref 620 724
error_table_$not_detached       000060 external static fixed bin(35,0)          dcl 215 ref 341
error_table_$not_open           000062 external static fixed bin(35,0)          dcl 215 ref 685
error_table_$null_info_ptr      000064 external static fixed bin(35,0)          dcl 215 ref 1139 1210 1256 1272
error_table_$short_record       000066 external static fixed bin(35,0)          dcl 215 ref 871
error_table_$smallarg           000070 external static fixed bin(35,0)          dcl 215 ref 794
error_table_$undefined_order_request
                                000072 external static fixed bin(35,0)          dcl 215 ref 579 1124
error_table_$unimplemented_version
                                000074 external static fixed bin(35,0)          dcl 215 ref 1016 1145 1274
error_table_$wrong_no_of_args   000076 external static fixed bin(35,0)          dcl 215 set ref 381*
event_channel            12            based           fixed bin(71,0)          level 2 in structure "channel_info" dcl 293
                                                                                  in procedure "hasp_host_" set ref 483* 555* 558*
                                                                                  567* 1173 1214 1361 1361* 1532 1592
event_channel                          based           fixed bin(71,0)          level 2 in structure "read_status_info" dcl 190
                                                                                  in procedure "hasp_host_" set ref 1214*
event_wait_channel              001170 automatic       structure                level 1 dcl 9-8 set ref 532 532 1174 1174 1533 1533
                                                                                  1594 1594
event_wait_info                        based           structure                level 1 dcl 10-7
expand_code                     001077 automatic       fixed bin(35,0)          dcl 175 set ref 864* 868 871 874
first                    16            based           pointer                  level 3 dcl 293 set ref 500 500* 1334* 1342
first_channel_info_ptr          000010 internal static pointer                  initial dcl 314 set ref 473 487 487* 1377*
flags                     3            based           structure                level 3 in structure "terminal_io_record" dcl 1-8
                                                                                  in procedure "hasp_host_" set ref 953*
flags                    30            based           structure                level 2 in structure "channel_info" dcl 293
                                                                                  in procedure "hasp_host_" set ref 486*
get_channel_info                       based           structure                level 1 dcl 198
get_system_free_area_           000122 constant        entry                    external dcl 236 ref 346 728 765 1000
had                                    based           structure                level 1 dcl 276 set ref 357 1346
had_ptr                         001152 automatic       pointer                  dcl 288 set ref 338* 357* 366 367 369 371 372 415
                                                                                  418 421 421 458 459 459 460 460 461 461 462 462
                                                                                  464 464 465 465 467 467 500 502 503 504 505 507
                                                                                  599 600 632* 633 647 667 730* 731 756* 757 864 938
                                                                                  991* 992 1041 1078 1078 1078 1082 1111* 1112 1150
                                                                                  1307* 1328 1330 1332 1334 1334 1336 1336 1338 1338
                                                                                  1340 1340 1346 1347*
hads                     16            based           structure                level 2 dcl 293 set ref 484*
hangup_proc_info                       based           structure                level 1 dcl 193
hasp_printer_srcb                      based           structure                level 1 packed packed unaligned dcl 188
hasp_printer_srcb_byte                 based           structure                level 1 packed packed unaligned dcl 3-42
hasp_util_$compress_text        000124 constant        entry                    external dcl 237 ref 1078 1082
hasp_util_$expand_text          000126 constant        entry                    external dcl 240 ref 864
have_comm                       000145 automatic       bit(1)                   dcl 122 set ref 359* 387* 446
have_srcb                       001122 automatic       bit(1)                   dcl 181 set ref 813* 854 859*
hbound                                                 builtin function         dcl 270 ref 353 375 396 1446 1473
hcs_$assign_channel             000130 constant        entry                    external dcl 243 ref 555
hcs_$reset_ips_mask             000132 constant        entry                    external dcl 244 ref 606 672 705 745 1399
hcs_$set_ips_mask               000134 constant        entry                    external dcl 245 ref 597 653 693 739
hcs_$tty_abort                  000136 constant        entry                    external dcl 246 ref 1238 1247
hcs_$tty_attach                 000140 constant        entry                    external dcl 247 ref 567
hcs_$tty_detach                 000142 constant        entry                    external dcl 248 ref 1359
hcs_$tty_order                  000144 constant        entry                    external dcl 249 ref 571 585 1151 1167 1221 1293
                                                                                  1526 1586
hcs_$tty_read                   000146 constant        entry                    external dcl 250 ref 1539
hcs_$tty_write                  000150 constant        entry                    external dcl 253 ref 1578
header                                 based           structure                level 2 dcl 1-8
held_input                             based           structure                level 1 dcl 321 set ref 838 843 904 911 914 1233
held_input_n_elements_allocated 001160 automatic       fixed bin(21,0)          dcl 327 set ref 837* 838 838 910* 911 911
held_input_ptr                  001156 automatic       pointer                  dcl 326 in procedure "hasp_host_" set ref 838* 839
                                                                                  839 840 841 845 846 847 911* 912 912 913 915
held_input_ptr           22            based           pointer                  level 2 in structure "channel_info" dcl 293
                                                                                  in procedure "hasp_host_" set ref 485* 822 824 825
                                                                                  826 843 845* 904 905* 914 915* 1216 1233 1233
                                                                                  1235*
hungup                    0(01) 000505 automatic       bit(1)                   level 2 packed packed unaligned dcl 139 set ref 543*
idx                             000260 automatic       fixed bin(17,0)          dcl 127 set ref 396* 397 397*
info_ptr                        000120 automatic       pointer                  dcl 111 set ref 1115* 1123 1128 1129* 1139 1143 1210
                                                                                  1214 1216 1221* 1256 1260 1260 1260 1272 1274 1278
                                                                                  1279 1293*
input                   112            based           char(512)                level 3 dcl 276 set ref 367* 415* 938*
input_available           2     000612 automatic       bit(1)                   level 2 in structure "read_status" dcl 153
                                                                                  in procedure "hasp_host_" set ref 1522* 1524 1530
input_available           2            based           bit(1)                   level 2 in structure "read_status_info" dcl 190
                                                                                  in procedure "hasp_host_" set ref 1216*
input_tr_ptr             12     000272 automatic       pointer                  level 3 dcl 132 set ref 412 415 415 415 415
io_buffer                              based           char                     packed unaligned dcl 168 set ref 841 857 864* 864*
                                                                                  892 913 1005 1066 1078 1078 1078 1078 1082 1082
                                                                                  1082 1082 1098 1539 1539 1555 1560* 1578* 1578*
io_buffer_lth                   000630 automatic       fixed bin(21,0)          dcl 169 set ref 825* 831* 841 847* 857 864 864 864
                                                                                  864 892 913 1005 1005 1048* 1055 1058* 1066 1066
                                                                                  1078 1078 1078 1078 1082 1082 1082 1082 1098 1098
                                                                                  1197* 1539 1539 1539* 1555 1560 1578 1578 1578
                                                                                  1578
io_buffer_ptr                   000634 automatic       pointer                  dcl 170 set ref 824* 830* 841 843 846* 857 864 864
                                                                                  892 902 913 914 1001* 1005 1005 1005 1057* 1066*
                                                                                  1078 1078 1078 1078 1082 1082 1082 1082 1098 1098
                                                                                  1098 1196* 1539 1539 1555 1560 1578 1578
io_buffer_read                  000632 automatic       fixed bin(21,0)          dcl 169 set ref 826* 837 841 841 847* 862 864* 890
                                                                                  892 893 902 909 910 913 1518* 1520 1539*
io_buffer_space                 000776 automatic       char(256)                packed unaligned dcl 173 set ref 830 831 843 902 914
                                                                                  1005 1055 1057 1058 1098
io_buffer_used                  000631 automatic       fixed bin(21,0)          dcl 169 set ref 854* 858* 862 864* 890 892 892 893*
                                                                                  902 909 910 913 913 1073* 1078* 1082* 1197* 1555
                                                                                  1558* 1558 1560 1576 1578 1585
io_call_info                           based           structure                level 1 dcl 7-10
ioa_$general_rs                 000152 constant        entry                    external dcl 256 ref 1423
iocb                                   based           structure                level 1 dcl 5-6
iocb_ptr                        000100 automatic       pointer                  dcl 99 set ref 334* 340 342 543 599 600 601 602 604*
                                                                                  617* 619 632 655 658 661 662 664 665 667 670* 682*
                                                                                  684 695 697 698 700 700 700 700 703* 716* 718 723
                                                                                  730 741 743* 755* 756 990* 991 1110* 1111 1202*
                                                                                  1306* 1307 1424
iox_$err_no_operation           000154 constant        entry                    external dcl 257 ref 700
iox_$propagate                  000156 constant        entry                    external dcl 258 ref 604 670 703 743
iox_modes                       000002 constant        char(24)                 initial array dcl 6-6 ref 647
ipc_$block                      000160 constant        entry                    external dcl 259 ref 532 1174 1533 1594
ipc_$create_ev_chn              000162 constant        entry                    external dcl 260 ref 516 558
ipc_$decl_ev_call_chn           000164 constant        entry                    external dcl 261 ref 1260
ipc_$decl_ev_wait_chn           000166 constant        entry                    external dcl 262 ref 1364
ipc_$delete_ev_chn              000170 constant        entry                    external dcl 263 ref 1361 1374
ips_mask                        000621 automatic       bit(36)                  packed unaligned dcl 161 set ref 593* 597* 606* 606*
                                                                                  649* 653* 672* 672* 689* 693* 705* 705* 735* 739*
                                                                                  745* 745* 1399 1399* 1399* 1400*
last                     20            based           pointer                  level 3 dcl 293 set ref 502 503 505* 1338*
last_channel_info_ptr           000012 internal static pointer                  initial dcl 315 set ref 489 490 492* 1381*
lbound                                                 builtin function         dcl 270 ref 375 396
length                                                 builtin function         dcl 270 ref 367 367 369 369 379 584 807 831 836 837
                                                                                  840 841 1055 1058 1078 1078 1082 1082 1197 1452
                                                                                  1479 1505 1505 1505 1505 1505 1555
local_event_wait_info           000466 automatic       structure                level 1 dcl 136 set ref 532 532 1174 1174 1533 1533
                                                                                  1594 1594
loud_sw                         000106 automatic       bit(1)                   dcl 106 set ref 335* 342 1422
max                                                    builtin function         dcl 270 ref 1048
message                   2     000466 automatic       fixed bin(71,0)          level 2 dcl 136 set ref 538 538
min                                                    builtin function         dcl 270 ref 937
mod                                                    builtin function         dcl 270 ref 1020 1027
modes                    56            based           entry variable           level 2 in structure "iocb" dcl 5-6 in procedure
                                                                                  "hasp_host_" set ref 662* 700*
modes                     1     000510 automatic       char(256)                level 2 in structure "tty_modes" dcl 149
                                                                                  in procedure "hasp_host_" set ref 583* 584
modes_lth                       000510 automatic       fixed bin(17,0)          level 2 dcl 149 set ref 584*
more_data_needed                001123 automatic       bit(1)                   dcl 181 set ref 815* 818 862 868*
multiplexer_device_type         000507 automatic       fixed bin(17,0)          dcl 147 set ref 571 571 573 576
mvt_                            000172 constant        entry                    external dcl 264 ref 938 1041
n_channels                      001170 automatic       fixed bin(17,0)          initial level 2 dcl 9-8 set ref 529* 1172* 9-8*
                                                                                  1531* 1591*
n_elements                5            based           fixed bin(24,0)          level 3 dcl 1-8 set ref 930* 937* 938 938 938 972
                                                                                  1020 1027 1041 1041 1041 1041 1041 1048 1048 1078
                                                                                  1082
n_elements_allocated      1            based           fixed bin(21,0)          level 2 dcl 321 set ref 824 825 838* 839 840 841 843
                                                                                  846 904 911* 912 913 914 1233
n_elements_used                        based           fixed bin(21,0)          level 2 dcl 321 set ref 826 839* 847 912*
name                      1            based           char(32)                 level 2 in structure "iocb" dcl 5-6 in procedure
                                                                                  "hasp_host_" set ref 342* 543* 1424*
name                                   based           char(32)                 level 2 in structure "channel_info" dcl 293
                                                                                  in procedure "hasp_host_" set ref 475 481* 1279
                                                                                  1368
new_cv_string_buffer_ptr        000626 automatic       pointer                  dcl 166 set ref 882* 884 887
next                     26            based           pointer                  level 3 in structure "channel_info" dcl 293
                                                                                  in procedure "hasp_host_" set ref 476 489* 491*
                                                                                  1377 1379* 1379 1381 1383
next                    514            based           pointer                  level 3 in structure "had" dcl 276 in procedure
                                                                                  "hasp_host_" set ref 502* 504* 1334 1336* 1336
                                                                                  1338 1340
null                                                   builtin function         dcl 270 ref 338 340 372 412 412 473 478 484 485 487
                                                                                  491 500 504 619 684 695 718 723 741 766 770 822
                                                                                  905 977 1001 1005 1098 1123 1129 1139 1202 1210
                                                                                  1216 1233 1235 1256 1272 1328 1330 1334 1338 1342
                                                                                  1347 1377 1381 1386
number                    0(05)        based           fixed bin(4,0)           level 2 packed packed unsigned unaligned dcl 188 ref
                                                                                  966
numeric_value                   000271 automatic       fixed bin(35,0)          dcl 130 set ref 426*
open                     32            based           entry variable           level 2 dcl 5-6 set ref 601* 697*
open_descrip_ptr         20            based           pointer                  level 2 dcl 5-6 set ref 619 667* 684 695* 723
open_description        101            based           varying char(24)         level 2 dcl 276 set ref 366* 647* 667
open_mode                       000107 automatic       fixed bin(17,0)          dcl 108 set ref 624* 626 626 626 635 641 647 655 655
                                                                                  658 658
option_name                     001210 automatic       char(32)                 packed unaligned dcl 1468 in procedure
                                                                                  "get_numeric_argument" set ref 1471* 1473* 1483*
option_name                     000100 automatic       char(32)                 packed unaligned dcl 1442 in procedure
                                                                                  "get_string_argument" set ref 1444* 1446* 1454*
order                           000110 automatic       char(32)                 packed unaligned dcl 110 set ref 1114* 1119 1128*
                                                                                  1133 1158 1182 1206 1228 1243 1252 1268 1284 1286
                                                                                  1293*
order_name               11            based           char(32)                 level 2 dcl 7-10 ref 1128
other_attach_options            000156 automatic       varying char(256)        dcl 124 set ref 364* 427* 427 428* 428 431* 431 467
output                  312            based           char(512)                level 3 dcl 276 set ref 369* 418* 421 1041* 1150
output_pending            2     000616 automatic       bit(1)                   level 2 dcl 157 set ref 1163* 1165 1171 1590
output_tr_ptr            14     000272 automatic       pointer                  level 3 dcl 132 set ref 412 418 418 418 418
preslew                   3(01)        based           bit(1)                   level 4 packed packed unaligned dcl 1-8 set ref 959*
                                                                                  967* 1033
prespace                  0(03)        based           bit(1)                   level 2 packed packed unaligned dcl 188 ref 967
previous                 24            based           pointer                  level 3 in structure "channel_info" dcl 293
                                                                                  in procedure "hasp_host_" set ref 490* 1377 1379
                                                                                  1381 1383* 1383
previous                516            based           pointer                  level 3 in structure "had" dcl 276 in procedure
                                                                                  "hasp_host_" set ref 503* 1334 1336 1338 1340*
                                                                                  1340
previous_data                   001101 automatic       varying char(64)         dcl 179 set ref 810* 836 837 840 840 841 848* 892*
priority                  6            based           fixed bin(17,0)          level 2 dcl 193 set ref 1260*
procedure                              based           entry variable           level 2 dcl 193 set ref 1260*
read_record              72            based           entry variable           level 2 dcl 5-6 set ref 655* 700*
read_status                     000612 automatic       structure                level 1 dcl 153 set ref 1526 1526
read_status_info                       based           structure                level 1 dcl 190
record                    4            based           char(80)                 level 2 packed packed unaligned dcl 4-6 set ref
                                                                                  1149* 1149 1150* 1150
rel                                                    builtin function         dcl 270 ref 790 790
reservation_string       32     000326 automatic       char(256)                level 2 dcl 134 set ref 523* 1369*
rtrim                                                  builtin function         dcl 270 ref 458 460 462 465 647
sent_on_call                    001253 automatic       fixed bin(21,0)          dcl 1571 set ref 1578* 1583
signon_record_info                     based           structure                level 1 dcl 4-6
signon_record_info_ptr          001166 automatic       pointer                  dcl 4-12 set ref 1143* 1145 1149 1149 1150 1150
                                                                                  1151*
skip_to_channel           0(04)        based           bit(1)                   level 2 packed packed unaligned dcl 188 ref 963
slew_control              2            based           structure                level 3 dcl 1-8
slew_count                2(18)        based           fixed bin(18,0)          level 4 packed packed unsigned unaligned dcl 1-8 set
                                                                                  ref 958* 966*
slew_type                 2            based           fixed bin(18,0)          level 4 packed packed unsigned unaligned dcl 1-8 set
                                                                                  ref 957* 963* 965*
space                   512            based           char(1)                  level 3 dcl 276 set ref 371* 421* 864* 1078 1078
                                                                                  1078* 1082*
srcb                                   based           char(1)                  packed unaligned dcl 185 set ref 857* 925
srcb_ptr                        001126 automatic       pointer                  dcl 186 set ref 812* 857 925 963 966 967
srcb_read                       001124 automatic       char(1)                  packed unaligned dcl 183 set ref 812
state                           000506 automatic       fixed bin(17,0)          dcl 145 set ref 567* 568 571* 572 585* 586 1151*
                                                                                  1152 1167* 1168 1221* 1222 1238* 1239 1247* 1248
                                                                                  1293* 1294 1526* 1527 1539* 1540 1578* 1580 1586*
                                                                                  1587
string                                                 builtin function         dcl 270 set ref 486* 953*
string_overlay                         based           char(1)                  array packed unaligned dcl 1619 in procedure
                                                                                  "substraddr_nonvarying" set ref 1621
string_overlay                         based           structure                level 1 dcl 1632 in procedure "substraddr_varying"
substr                                                 builtin function         dcl 270 set ref 381 840* 841* 841 857 892 913 925
                                                                                  1505* 1560*
substraddr                                             generic function         dcl 1608 ref 377 864 864 864 864 1451 1478 1578 1578
system_area                            based           area(1024)               dcl 116 ref 357 480 770 838 843 882 885 904 911 977
                                                                                  1005 1066 1098 1233 1346 1385
system_area_ptr                 000122 automatic       pointer                  dcl 117 set ref 346* 357 480 728* 765* 770 838 843
                                                                                  882 885 904 911 977 1000* 1005 1066 1098 1233 1346
                                                                                  1385
tables                   12     000272 automatic       structure                level 2 dcl 132
terminal_io_record                     based           structure                level 1 dcl 1-8 set ref 1020 1027
terminal_io_record_data_chars          based           char                     packed unaligned dcl 1-54 set ref 938 938 1041 1041
                                                                                  1041 1041
terminal_io_record_header_lth   001100 automatic       fixed bin(21,0)          dcl 177 set ref 790* 793 798 972
terminal_io_record_n_elements   001164 automatic       fixed bin(24,0)          dcl 1-31 set ref 798* 937 941
terminal_io_record_ptr          001162 automatic       pointer                  dcl 1-28 set ref 788* 790 790 930 937 938 938 938
                                                                                  938 938 947 949 950 951 953 957 958 959 963 965
                                                                                  966 967 970 972 1013* 1015 1020 1027 1033 1033
                                                                                  1033 1041 1041 1041 1041 1041 1041 1041 1041 1041
                                                                                  1048 1048 1078 1082 1082 1082
terminal_io_record_version_1           constant        fixed bin(17,0)          initial dcl 1-36 ref 947 1015
terminal_type                   000146 automatic       char(32)                 packed unaligned dcl 123 set ref 362* 407* 408* 408
                                                                                  410* 411* 412* 463 465
terminal_type_data                     based           structure                level 1 dcl 11-15
the_code                               based           fixed bin(35,0)          dcl 1415 set ref 1424* 1429 1431
the_code_ptr                    000100 automatic       pointer                  dcl 1416 set ref 1420* 1424 1429 1431
the_value                       001220 automatic       fixed bin(35,0)          dcl 1469 set ref 1481* 1487
timer_manager_$alarm_wakeup     000174 constant        entry                    external dcl 265 ref 1593
translate                                              builtin function         dcl 270 ref 408 421 1149 1150
translate_string                       based           char                     packed unaligned dcl 1501 ref 1503 1505 1505 1505
translations            112            based           structure                level 2 dcl 276
transmitted                     001252 automatic       fixed bin(21,0)          dcl 1571 set ref 1574* 1576 1578 1578 1578 1583*
                                                                                  1583 1585
ttd                             000272 automatic       structure                level 1 dcl 132 set ref 410 410
ttd_version_3                          constant        fixed bin(17,0)          initial dcl 11-54 ref 409
ttt_info_$terminal_data         000176 constant        entry                    external dcl 266 ref 410
tty_channel                     000125 automatic       char(32)                 packed unaligned dcl 121 set ref 360* 390* 449 460
                                                                                  475 481 495* 522 527* 536* 540* 567* 569* 576*
                                                                                  579* 581* 587*
tty_get_channel_info                   based           structure                level 1 dcl 13-5
tty_get_channel_info_version           constant        fixed bin(17,0)          initial dcl 13-10 ref 1274
tty_modes                       000510 automatic       structure                level 1 dcl 149 set ref 585 585
unspec                                                 builtin function         dcl 270 ref 538 538
value                     2            based           fixed bin(8,0)           array level 3 packed packed unaligned dcl 12-107 set
                                                                                  ref 415 415 415 415 418 418 418 418
version                                based           fixed bin(17,0)          level 3 in structure "terminal_io_record" dcl 1-8
                                                                                  in procedure "hasp_host_" set ref 947* 1015
version                         000326 automatic       fixed bin(17,0)          level 2 in structure "dma" dcl 134 in procedure
                                                                                  "hasp_host_" set ref 520* 1366*
version                                based           fixed bin(17,0)          level 2 in structure "signon_record_info" dcl 4-6
                                                                                  in procedure "hasp_host_" ref 1145
version                                based           fixed bin(17,0)          initial level 2 in structure "get_channel_info"
                                                                                  dcl 198 in procedure "hasp_host_" ref 1274
version                         000272 automatic       fixed bin(17,0)          level 2 in structure "ttd" dcl 132 in procedure
                                                                                  "hasp_host_" set ref 409*
write_record             76            based           entry variable           level 2 dcl 5-6 set ref 658* 700*
write_status                    000616 automatic       structure                level 1 dcl 157 set ref 1167 1167 1586 1586

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CV_TRANS_SIZE                          internal static fixed bin(17,0)          initial array dcl 12-129
CV_TRANS_VERSION                       internal static fixed bin(17,0)          initial dcl 12-127
DELAY_VERSION                          internal static fixed bin(17,0)          initial dcl 12-126
Direct_input                           internal static fixed bin(17,0)          initial dcl 6-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 6-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 6-15
HASP_FORMS_CHANGE_SRCB                 based           char(1)                  dcl 3-71
HASP_FORMS_CHANGE_SRCB_BITS            internal static structure                level 1 dcl 3-65
HASP_MAX_COMPRESSED_TEXT_LTH           internal static fixed bin(17,0)          initial dcl 3-100
HASP_MAX_DEVICE_RECORD_LTHS            internal static fixed bin(21,0)          initial array dcl 2-20
HASP_MAX_SLEW_COUNT                    internal static fixed bin(17,0)          initial dcl 3-62
HASP_SIGNON_HANGUP                     internal static fixed bin(71,0)          initial dcl 4-20
HASP_SIGNON_OK                         internal static fixed bin(71,0)          initial dcl 4-20
HASP_SIGNON_REJECTED                   internal static fixed bin(71,0)          initial dcl 4-20
INPUT_CONVERT_BREAK                    internal static fixed bin(8,0)           initial packed unaligned dcl 12-135
INPUT_CONVERT_DISCARD                  internal static fixed bin(8,0)           initial packed unaligned dcl 12-135
INPUT_CONVERT_DSA_CR_PROCESSING        internal static fixed bin(8,0)           initial packed unaligned dcl 12-135
INPUT_CONVERT_ESCAPE                   internal static fixed bin(8,0)           initial packed unaligned dcl 12-135
INPUT_CONVERT_FORMFEED                 internal static fixed bin(8,0)           initial packed unaligned dcl 12-135
INPUT_CONVERT_ORDINARY                 internal static fixed bin(8,0)           initial packed unaligned dcl 12-135
INPUT_CONVERT_PRECEDENCE_DISCARD       internal static fixed bin(8,0)           initial packed unaligned dcl 12-135
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 6-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 6-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 6-15
OUTPUT_CONVERT_BRS                     internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
OUTPUT_CONVERT_BS                      internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
OUTPUT_CONVERT_CR                      internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
OUTPUT_CONVERT_DONT_SEND               internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
OUTPUT_CONVERT_FF                      internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
OUTPUT_CONVERT_FIRST_SPECIAL           internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
OUTPUT_CONVERT_HT                      internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
OUTPUT_CONVERT_NEWLINE                 internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
OUTPUT_CONVERT_NOT_USED_13             internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
OUTPUT_CONVERT_NOT_USED_14             internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
OUTPUT_CONVERT_NOT_USED_15             internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
OUTPUT_CONVERT_NOT_USED_16             internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
OUTPUT_CONVERT_NO_MOTION               internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
OUTPUT_CONVERT_OCTAL                   internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
OUTPUT_CONVERT_ORDINARY                internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
OUTPUT_CONVERT_PRECEDENCE_NO_MOTION    internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
OUTPUT_CONVERT_RRS                     internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
OUTPUT_CONVERT_VT                      internal static fixed bin(8,0)           initial packed unaligned dcl 12-147
READER_DEVICE                          internal static fixed bin(17,0)          initial dcl 1-38
SLEW_TO_INSIDE_PAGE                    internal static fixed bin(17,0)          initial dcl 1-44
SLEW_TO_OUTSIDE_PAGE                   internal static fixed bin(17,0)          initial dcl 1-44
SLEW_TO_TOP_OF_PAGE                    internal static fixed bin(17,0)          initial dcl 1-44
SPECIAL_INFO_STRUCT_VERSION_1          internal static char(8)                  initial packed unaligned dcl 12-122
SPECIAL_VERSION                        internal static fixed bin(17,0)          initial dcl 12-124
SPECIAL_VERSION_2                      internal static fixed bin(17,0)          initial dcl 12-125
Sequential_update                      internal static fixed bin(17,0)          initial dcl 6-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 6-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 6-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 6-15
TEMPLATE_HASP_PRINTER_SRCB             based           char(1)                  dcl 3-60
TEMPLATE_HASP_PRINTER_SRCB_BITS        internal static structure                level 1 dcl 3-52
c_chars_ptr                            automatic       pointer                  dcl 12-53
delay_struc                            based           structure                level 1 dcl 12-112
dial_manager_arg_version_3             internal static fixed bin(17,0)          initial dcl 8-11
dial_manager_arg_version_4             internal static fixed bin(17,0)          initial dcl 8-12
event_wait_info_ptr                    automatic       pointer                  dcl 10-5
get_special_info_struc                 based           structure                level 1 dcl 12-117
hasp_card_srcb_byte                    based           structure                level 1 packed packed unaligned dcl 3-21
hasp_card_srcb_byte_ptr                automatic       pointer                  dcl 3-28
hasp_compressed_scb_byte               based           structure                level 1 packed packed unaligned dcl 3-88
hasp_not_compressed_scb_byte           based           structure                level 1 packed packed unaligned dcl 3-82
hasp_printer_srcb_byte_ptr             automatic       pointer                  dcl 3-50
hasp_scb_byte                          based           structure                level 1 packed packed unaligned dcl 3-76
hasp_scb_byte_ptr                      automatic       pointer                  dcl 3-95
io_call_af_ret                         based           varying char             dcl 7-25
io_call_infop                          automatic       pointer                  dcl 7-8
iox_$iocb_version_sentinel             external static char(4)                  dcl 5-51
sc_escape_len                          automatic       fixed bin(17,0)          dcl 12-58
sc_input_escape_len                    automatic       fixed bin(17,0)          dcl 12-59
short_iox_modes                        internal static char(4)                  initial array dcl 6-12
special_chars                          based           structure                level 1 dcl 12-26
special_chars_struc                    based           structure                level 1 dcl 12-76
terminal_io_record_data_bits           based           bit                      packed unaligned dcl 1-64
terminal_io_record_data_chars_varying  based           varying char             dcl 1-58
terminal_io_record_data_chars_varying_max_len
                                       automatic       fixed bin(21,0)          dcl 1-57
terminal_io_record_element_size        automatic       fixed bin(17,0)          dcl 1-30
ttdp                                   automatic       pointer                  dcl 11-53

NAMES DECLARED BY EXPLICIT CONTEXT.
ASSUME_ATTACHED                 003340 constant        label                    dcl 552 ref 526
FOUND_CHANNEL                   002624 constant        label                    dcl 478 ref 475
RETURN_FROM_ATTACH              004072 constant        label                    dcl 608 ref 1433
RETURN_FROM_CONTROL             007420 constant        label                    dcl 1297 ref 1169 1176 1189 1199
RETURN_FROM_READ_RECORD         005720 constant        label                    dcl 977 ref 833 880 898 933
RETURN_FROM_WRITE_RECORD        006407 constant        label                    dcl 1098 ref 1064 1088
WAIT_FOR_ANSWERING_SERVICE      003124 constant        label                    dcl 532 ref 546
WRITE_RECORD_BAD_DATA           006374 constant        label                    dcl 1086 ref 1555
abort_attachment                010047 constant        entry                    internal dcl 1412 ref 353 381 386 399 411 412 434
                                                                                  437 440 446 449 452 495 518 527 536 540 560 569
                                                                                  576 579 581 587 1446 1454 1473 1483
add_character_to_io_buffer      011057 constant        entry                    internal dcl 1550 ref 1075 1076 1091
any_other_handler               010014 constant        entry                    internal dcl 1396 ref 595 651 691 737
cleanup_attachment              007513 constant        entry                    internal dcl 1321 ref 348 733 1427
get_numeric_argument            010433 constant        entry                    internal dcl 1465 ref 426
get_string_argument             010244 constant        entry                    internal dcl 1439 ref 385 390 394 407
hasp_host_                      001064 constant        entry                    external dcl 60
hasp_host_attach                001100 constant        entry                    external dcl 331
hasp_host_close                 004361 constant        entry                    external dcl 679 ref 664
hasp_host_control               006436 constant        entry                    external dcl 1107 ref 661 1202
hasp_host_detach                004525 constant        entry                    external dcl 713 ref 602 665 698
hasp_host_modes                 007430 constant        entry                    external dcl 1303 ref 662
hasp_host_open                  004102 constant        entry                    external dcl 614 ref 601 697
hasp_host_read_record           004674 constant        entry                    external dcl 752 ref 655
hasp_host_write_record          005747 constant        entry                    external dcl 987 ref 658
read_io_buffer                  010672 constant        entry                    internal dcl 1515 ref 832
release_channel                 007602 constant        entry                    internal dcl 1356 ref 1342
set_translation                 010636 constant        entry                    internal dcl 1494 ref 367 369 415 418
substraddr_nonvarying           011331 constant        entry                    internal dcl 1613 ref 864 864 864 864 1578 1578
substraddr_varying              011353 constant        entry                    internal dcl 1626 ref 377 1451 1478
write_io_buffer                 011074 constant        entry                    internal dcl 1568 ref 1096 1198

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     12760       13160   11614       12770
Length     14066   11614       200         672    1143           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
hasp_host_                          923 external procedure  is an external procedure.  
on unit on line 348                  72 on unit               
on unit on line 595                  64 on unit               
on unit on line 651                  64 on unit               
on unit on line 691                  64 on unit               
on unit on line 737                  64 on unit               
on unit on line 768                  66 on unit               
on unit on line 877                  64 on unit               
on unit on line 1003                 66 on unit               
on unit on line 1061                 64 on unit               
cleanup_attachment                   84 internal procedure  is called by several nonquick procedures.  
release_channel                         internal procedure  shares stack frame of internal procedure cleanup_attachment.  
any_other_handler                    71 internal procedure  is declared options(non_quick).  
abort_attachment                    178 internal procedure  is declared options(non_quick), and is declared options(variable).  
get_string_argument                 116 internal procedure  uses returns(char(*)) or returns(bit(*)).  
get_numeric_argument                    internal procedure  shares stack frame of external procedure hasp_host_.  
set_translation                         internal procedure  shares stack frame of external procedure hasp_host_.  
read_io_buffer                          internal procedure  shares stack frame of external procedure hasp_host_.  
add_character_to_io_buffer              internal procedure  shares stack frame of external procedure hasp_host_.  
write_io_buffer                         internal procedure  shares stack frame of external procedure hasp_host_.  
substraddr_nonvarying                   internal procedure  shares stack frame of external procedure hasp_host_.  
substraddr_varying                   65 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 first_channel_info_ptr      hasp_host_
000012 last_channel_info_ptr       hasp_host_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
abort_attachment         000100 the_code_ptr                abort_attachment
                         000102 caller_message              abort_attachment
get_string_argument      000100 option_name                 get_string_argument
hasp_host_               000100 iocb_ptr                    hasp_host_
                         000102 code                        hasp_host_
                         000103 argument_lth                hasp_host_
                         000104 argument_ptr                hasp_host_
                         000106 loud_sw                     hasp_host_
                         000107 open_mode                   hasp_host_
                         000110 order                       hasp_host_
                         000120 info_ptr                    hasp_host_
                         000122 system_area_ptr             hasp_host_
                         000124 argument_idx                hasp_host_
                         000125 tty_channel                 hasp_host_
                         000135 device_name                 hasp_host_
                         000145 have_comm                   hasp_host_
                         000146 terminal_type               hasp_host_
                         000156 other_attach_options        hasp_host_
                         000257 device_type                 hasp_host_
                         000260 idx                         hasp_host_
                         000261 character_value             hasp_host_
                         000271 numeric_value               hasp_host_
                         000272 ttd                         hasp_host_
                         000326 dma                         hasp_host_
                         000466 local_event_wait_info       hasp_host_
                         000475 dialup_msg_channel          hasp_host_
                         000505 dialup_msg_flags            hasp_host_
                         000506 state                       hasp_host_
                         000507 multiplexer_device_type     hasp_host_
                         000510 tty_modes                   hasp_host_
                         000612 read_status                 hasp_host_
                         000616 write_status                hasp_host_
                         000621 ips_mask                    hasp_host_
                         000622 cv_string_buffer_lth        hasp_host_
                         000623 cv_string_buffer_used_lth   hasp_host_
                         000624 cv_string_buffer_ptr        hasp_host_
                         000626 new_cv_string_buffer_ptr    hasp_host_
                         000630 io_buffer_lth               hasp_host_
                         000631 io_buffer_used              hasp_host_
                         000632 io_buffer_read              hasp_host_
                         000634 io_buffer_ptr               hasp_host_
                         000636 cv_string_buffer_space      hasp_host_
                         000776 io_buffer_space             hasp_host_
                         001076 compress_code               hasp_host_
                         001077 expand_code                 hasp_host_
                         001100 terminal_io_record_header_lth
                                                            hasp_host_
                         001101 previous_data               hasp_host_
                         001122 have_srcb                   hasp_host_
                         001123 more_data_needed            hasp_host_
                         001124 srcb_read                   hasp_host_
                         001126 srcb_ptr                    hasp_host_
                         001152 had_ptr                     hasp_host_
                         001154 channel_info_ptr            hasp_host_
                         001156 held_input_ptr              hasp_host_
                         001160 held_input_n_elements_allocated
                                                            hasp_host_
                         001162 terminal_io_record_ptr      hasp_host_
                         001164 terminal_io_record_n_elements
                                                            hasp_host_
                         001166 signon_record_info_ptr      hasp_host_
                         001170 event_wait_channel          hasp_host_
                         001210 option_name                 get_numeric_argument
                         001220 the_value                   get_numeric_argument
                         001252 transmitted                 write_io_buffer
                         001253 sent_on_call                write_io_buffer

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     call_ext_in_desc    call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other_desc call_int_other      return_mac          tra_ext_1           mdfx1
enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry           int_entry_desc
set_chars_eis       return_chars_eis    translate_2         fetch_chars_eis     op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      continue_to_signal_           convert_dial_message_         convert_ipc_code_
cu_$arg_list_ptr              cu_$arg_ptr                   cv_dec_check_
dial_manager_$privileged_attach                             dial_manager_$release_channel get_system_free_area_
hasp_util_$compress_text      hasp_util_$expand_text        hcs_$assign_channel           hcs_$reset_ips_mask
hcs_$set_ips_mask             hcs_$tty_abort                hcs_$tty_attach               hcs_$tty_detach
hcs_$tty_order                hcs_$tty_read                 hcs_$tty_write                ioa_$general_rs
iox_$err_no_operation         iox_$propagate                ipc_$block                    ipc_$create_ev_chn
ipc_$decl_ev_call_chn         ipc_$decl_ev_wait_chn         ipc_$delete_ev_chn            mvt_
timer_manager_$alarm_wakeup   ttt_info_$terminal_data

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
ascii_to_ebcdic_$ae_table     ebcdic_to_ascii_$ea_table     error_table_$action_not_performed
error_table_$bad_conversion   error_table_$bad_mode         error_table_$badopt
error_table_$device_type_unknown                            error_table_$eof_record
error_table_$improper_data_format                           error_table_$incorrect_device_type
error_table_$invalid_read     error_table_$invalid_write    error_table_$io_no_permission error_table_$long_record
error_table_$noalloc          error_table_$noarg            error_table_$not_attached     error_table_$not_closed
error_table_$not_detached     error_table_$not_open         error_table_$null_info_ptr    error_table_$short_record
error_table_$smallarg         error_table_$undefined_order_request
error_table_$unimplemented_version                          error_table_$wrong_no_of_args




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 9    8 001057        60 001063        63 001072       331 001073       334 001117       335 001123       336 001130
    338 001131       340 001133       341 001136       342 001141       343 001173       346 001174       348 001203
    353 001230       357 001255       359 001262       360 001263       361 001266       362 001271       364 001274
    366 001275       367 001276       369 001315       371 001335       372 001340       375 001342       377 001353
    379 001413       381 001427       384 001454       385 001462       386 001502       387 001531       388 001533
    390 001534       393 001561       394 001566       395 001606       396 001611       397 001622       398 001633
    399 001635       403 001676       405 001677       407 001707       408 001727       409 001741       410 001744
    411 002001       412 002026       415 002062       418 002102       421 002122       422 002133       424 002135
    426 002145       427 002147       428 002161       429 002174       431 002175       434 002214       437 002241
    440 002272       441 002320       446 002322       449 002343       452 002366       458 002413       459 002434
    460 002446       461 002472       462 002504       463 002530       464 002534       465 002546       467 002572
    473 002604       475 002614       476 002621       478 002624       480 002630       481 002635       482 002640
    483 002642       484 002647       485 002652       486 002653       487 002654       489 002662       490 002664
    491 002666       492 002670       493 002671       495 002672       500 002735       502 002745       503 002750
    504 002752       505 002754       507 002755       512 002756       516 002761       517 002772       518 003003
    520 003027       521 003031       522 003034       523 003037       525 003050       526 003063       527 003067
    529 003117       530 003121       532 003124       535 003143       536 003154       538 003201       540 003244
    542 003271       543 003274       546 003337       552 003340       555 003343       557 003354       558 003356
    559 003370       560 003401       567 003425       568 003456       569 003464       571 003514       572 003553
    573 003561       576 003570       579 003631       581 003661       583 003704       584 003707       585 003711
    586 003746       587 003754       593 004001       595 004002       597 004024       599 004037       600 004042
    601 004044       602 004050       604 004053       606 004062       608 004072       610 004074       614 004075
    617 004113       619 004120       620 004124       621 004127       624 004130       626 004132       628 004140
    629 004143       632 004144       633 004146       635 004150       637 004160       638 004163       641 004164
    643 004172       644 004175       647 004176       649 004227       651 004230       653 004252       655 004265
    658 004301       661 004313       662 004320       664 004323       665 004326       667 004331       670 004334
    672 004343       674 004353       675 004354       679 004355       682 004372       684 004377       685 004403
    686 004406       689 004407       691 004410       693 004432       695 004445       697 004450       698 004454
    700 004457       703 004503       705 004511       707 004521       709 004522       713 004523       716 004536
    718 004542       719 004546       720 004551       723 004552       724 004556       725 004561       728 004562
    730 004571       731 004574       733 004576       735 004604       737 004605       739 004627       741 004642
    743 004645       745 004654       747 004664       748 004666       752 004667       755 004707       756 004714
    757 004716       758 004720       760 004721       761 004724       762 004727       765 004730       766 004737
    768 004741       770 004755       773 004775       779 004776       780 005002       781 005004       782 005007
    788 005010       790 005014       793 005025       794 005030       795 005033       798 005034       806 005037
    807 005041       808 005043       810 005044       812 005045       813 005047       815 005050       818 005052
    822 005054       824 005061       825 005064       826 005066       827 005070       830 005071       831 005073
    832 005075       833 005076       836 005100       837 005102       838 005104       839 005116       840 005117
    841 005124       843 005131       845 005147       846 005152       847 005154       848 005157       854 005160
    857 005164       858 005171       859 005173       862 005175       864 005203       868 005303       871 005307
    874 005313       876 005315       877 005320       879 005334       880 005337       882 005342       883 005351
    884 005352       885 005357       887 005372       888 005374       890 005375       892 005404       893 005415
    894 005417       897 005420       898 005422       900 005423       902 005424       904 005435       905 005445
    907 005450       909 005451       910 005454       911 005457       912 005471       913 005472       914 005506
    915 005524       924 005527       925 005531       929 005546       930 005550       931 005552       932 005553
    933 005556       934 005562       937 005563       938 005570       941 005616       947 005624       949 005626
    950 005636       951 005644       953 005651       955 005653       957 005660       958 005662       959 005664
    960 005666       963 005667       965 005677       966 005701       967 005710       970 005713       972 005715
    977 005720       981 005737       982 005741       987 005742       990 005762       991 005767       992 005771
    993 005773       995 005774       996 006001       997 006004      1000 006005      1001 006014      1003 006016
   1005 006032      1007 006052      1013 006053      1015 006057      1016 006062      1017 006065      1020 006066
   1024 006104      1025 006107      1026 006110      1027 006111      1029 006125      1030 006130      1033 006131
   1034 006140      1035 006143      1041 006144      1048 006170      1055 006204      1057 006206      1058 006210
   1059 006212      1061 006213      1063 006227      1064 006232      1066 006235      1073 006244      1075 006245
   1076 006260      1078 006270      1082 006334      1085 006372      1086 006374      1088 006377      1091 006400
   1096 006406      1098 006407      1102 006426      1103 006430      1107 006431      1110 006455      1111 006462
   1112 006464      1114 006466      1115 006473      1116 006476      1119 006477      1123 006503      1124 006507
   1125 006512      1128 006513      1129 006516      1133 006520      1139 006524      1143 006534      1145 006536
   1149 006545      1150 006557      1151 006572      1152 006630      1155 006636      1158 006637      1163 006643
   1165 006645      1167 006650      1168 006710      1169 006716      1171 006720      1172 006722      1173 006724
   1174 006727      1175 006746      1176 006757      1178 006761      1179 006762      1182 006763      1187 006767
   1188 006774      1189 006777      1192 007000      1196 007003      1197 007005      1198 007010      1199 007011
   1202 007013      1203 007042      1206 007043      1210 007047      1214 007057      1216 007061      1221 007074
   1222 007130      1225 007136      1228 007137      1233 007143      1235 007156      1236 007161      1238 007163
   1239 007202      1240 007210      1243 007211      1247 007215      1248 007234      1249 007242      1252 007243
   1256 007247      1260 007257      1262 007277      1263 007310      1265 007315      1268 007316      1272 007322
   1274 007332      1278 007341      1279 007344      1281 007347      1284 007350      1286 007355      1293 007362
   1294 007412      1297 007420      1299 007422      1303 007423      1306 007454      1307 007461      1308 007463
   1309 007470      1311 007471      1313 007504      1315 007507      1316 007511      1321 007512      1326 007520
   1328 007522      1330 007527      1332 007534      1334 007536      1336 007546      1338 007551      1340 007562
   1342 007565      1346 007573      1347 007576      1350 007601      1356 007602      1359 007603      1361 007631
   1363 007652      1364 007657      1366 007674      1367 007677      1368 007702      1369 007705      1370 007716
   1371 007732      1374 007736      1377 007755      1379 007767      1381 007772      1383 010002      1385 010005
   1386 010007      1388 010012      1396 010013      1399 010021      1400 010033      1402 010035      1404 010045
   1412 010046      1420 010054      1422 010074      1423 010077      1424 010156      1427 010217      1429 010227
   1431 010236      1433 010240      1439 010243      1444 010251      1446 010257      1449 010310      1451 010312
   1452 010353      1454 010370      1457 010422      1465 010433      1471 010435      1473 010442      1476 010476
   1478 010477      1479 010537      1481 010553      1483 010575      1487 010632      1494 010636      1503 010640
   1505 010647      1509 010670      1515 010672      1518 010673      1520 010674      1522 010676      1524 010677
   1526 010702      1527 010741      1528 010747      1530 010752      1531 010754      1532 010756      1533 010761
   1534 011000      1535 011011      1537 011014      1539 011015      1540 011044      1541 011052      1542 011055
   1544 011056      1550 011057      1555 011061      1558 011064      1560 011065      1562 011073      1568 011074
   1574 011075      1576 011076      1578 011101      1580 011157      1581 011165      1583 011170      1585 011172
   1586 011175      1587 011235      1588 011243      1590 011246      1591 011250      1592 011252      1593 011255
   1594 011274      1595 011313      1596 011324      1599 011327      1601 011330      1613 011331      1621 011342
   1626 011352      1636 011366


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
