ASSEMBLY LISTING OF SEGMENT >dumps>old>recomp>basic_next_line.alm             
ASSEMBLED ON:	11/18/82  1704.7 mst Thu
OPTIONS USED:	list 
ASSEMBLED BY:	ALM Version  6.4  April 1981    
ASSEMBLER CREATED:	11/03/82  1423.6 mst Wed

                                     1  " ***********************************************************
                                     2  " *                                                         *
                                     3  " * Copyright, (C) Honeywell Information Systems Inc., 1982 *
                                     4  " *                                                         *
                                     5  " * Copyright (c) 1972 by Massachusetts Institute of        *
                                     6  " * Technology and Honeywell Information Systems, Inc.      *
                                     7  " *                                                         *
                                     8  " ***********************************************************
                                     9  
                                    10  " Procedure to process next input line for Multics Basic
                                    11  "
                                    12  " Initial Version: 25 February 1973 by BLW
                                    13  " Modified: 22 September 1973 by BLW to use EIS
                                    14  " Modified: 31 July 1980 by MBW to ignore blank lines
                                    15  " Modified: 27 October 1980 by MBW to handle multiple statements per line
                                    16  "
                                    17  " Usage:
                                    18  "	dcl basic_next_line entry(ptr);
                                    19  "
                                    20  "	call basic_next_line(addr(structure))
                                    21  "
                                    22  " where	structure		is our working storage, which is defined below
                                    23  "
                                    24  " If an error is found, structure.number is made negative:  the following codes are returned
                                    25  "	-1	line too long
                                    26  "	-2	no NL at end of segment
                                    27  "	-3	string doesn't end with quote
                                    28  "	-4	past end of segment at entry to basic_next_line
                                    29  "	-5	no line number at beginning of line
                                    30  "
                                    31  "	Layout of our work area structure
                                    32  "
                        000000      33  	equ	input_pt,0
                        000002      34  	equ	input_length,2
                        000003      35  	equ	input_pos,3
                        000004      36  	equ	line_number,4
                        000005      37  	equ	number,5
                        000006      38  	equ	class_tally,6
                        000007      39  	equ	original_class_tally,7
                        000010      40  	equ	ch_tally,8
                        000011      41  	equ	original_ch_tally,9
                        000012      42  	equ	save_ch_tally,10
                        000013      43  	equ	char,11
                        000014      44  	equ	statement_number,12
                        000015      45  	equ	statement_ending,13
                        000016      46  	equ	temp_ch,14
                        000030      47  	equ	class,24
                        000430      48  	equ	ch,24+256
                                    49  "
                                    50  "	The following character classes are used
                                    51  "
                        000001      52  	equ	plus,1
                        000002      53  	equ	minus,2
                        000003      54  	equ	times,3
                        000004      55  	equ	divide,4
                        000005      56  	equ	power,5
                        000006      57  	equ	concat,6
                        000007      58  	equ	letter,7
                        000010      59  	equ	digit,8
                        000011      60  	equ	decimal,9
                        000012      61  	equ	dollar,10
                        000013      62  	equ	punc,11
                        000014      63  	equ	relation,12
                        000015      64  	equ	assign,13
                        000016      65  	equ	nl,14
                        000017      66  	equ	quote,15
                        000020      67  	equ	invalid,16
                        000021      68  	equ	remark,17
                        000022      69  	equ	backslash,18
                                    70  "
                        000400      71  	equ	max_length,256
                                    72  "
                        000012      73  	bool	NL,12
                        000042      74  	bool	QUOTE,42
                        000051      75  	bool	RIGHT_PAREN,51
                                    76  "
                        000000      77  	segdef	basic_next_line
    000000                          78  basic_next_line:
    000000  aa  0 00002 3535 20     79  	epp3	ap|2,*		get ptr to our structure
    000001  aa  3 00000 3535 20     80  	epp3	3|0,*
                                    81  "
    000002                          82  next_line:
    000002  aa  3 00030 6351 00     83  	eaa	3|class		get offset of class buffer
    000003  aa  3 00007 7551 00     84  	sta	3|original_class_tally
    000004  aa  3 00006 7551 00     85  	sta	3|class_tally	and save
                                    86  "
    000005  aa  3 00430 6351 00     87  	eaa	3|ch		also form ch buffer tally
    000006  aa  3 00011 7551 00     88  	sta	3|original_ch_tally
    000007  aa  3 00010 7551 00     89  	sta	3|ch_tally
                                    90  "
    000010  aa  3 00002 2361 00     91  	ldq	3|input_length	get number chars remaining in segment
    000011  aa  3 00003 1761 00     92  	sbq	3|input_pos
    000012  aa  3 00002 7561 00     93  	stq	3|input_length
    000013  aa  3 00003 7211 00     94  	lxl1	3|input_pos
    000014  aa  3 00000 3521 20     95  	epp2	3|input_pt,*
    000015  aa  2 00000 5005 11     96  	a9bd	2|0,1		add in char offset
    000016  aa  3 00000 2521 00     97  	spri2	3|input_pt	save new input ptr
    000017  aa   000000 6210 00     98  	eax1	0		start at beginning of statement
    000020  aa  3 00003 4501 00     99  	stz	3|input_pos	initialize in case there's no line num
    000021  aa  3 00015 2351 00    100  	lda	3|statement_ending
    000022  aa  3 00014 7551 00    101  	sta	3|statement_number
    000023  0a   000037 6010 00    102  	tnz	scan_statement	only first statement has line number
                                   103  "
    000024  aa  0 00000 1645 40    104  	tct	(pr,rl)	scan over line number
    000025  aa   200000 000006     105  	desc9a	2|0,ql
    000026  0a   000460 0000 00    106  	arg	skip_table
    000027  aa  3 00013 0001 00    107  	arg	3|char
    000030  aa  3 00013 7211 00    108  	lxl1	3|char		get number of digits
    000031  0a   000250 6000 00    109  	tze	no_line_number
    000032  aa  0 00100 3055 40    110  	dtb	(pr,rl),(pr)	convert line number to binary
    000033  aa   200000 030011     111  	desc9ns	2|0,x1
    000034  aa   300004 000004     112  	desc9a	3|line_number,4
    000035  aa  3 00003 4411 00    113  	sxl1	3|input_pos
    000036  aa  3 00013 4501 00    114  	stz	3|char		so we can have leading zeros
                                   115  "
    000037                         116  scan_statement:
    000037  aa  3 00002 2361 00    117  	ldq	3|input_length	get number of chars remaining in segment
    000040  aa  3 00003 1761 00    118  	sbq	3|input_pos
    000041  0a   000206 6044 00    119  	tmoz	past_end		error if past end of segment
    000042  aa   000400 1160 07    120  	cmpq	max_length,dl	get min(left, max_length)
    000043  aa   000002 6040 04    121  	tmi	2,ic
    000044  aa   000400 2360 07    122  	ldq	max_length,dl
    000045  aa   000006 7360 00    123  	qls	6		and fill in tally count
    000046  aa  3 00006 2561 00    124  	orsq	3|class_tally
    000047  aa  3 00010 2561 00    125  	orsq	3|ch_tally
                                   126  "
    000050  aa   000001 0610 03    127  loop1:	adx1	1,du		update for next character
    000051  aa  0 00100 1005 11    128  	mlr	(pr,x1),(pr)	move char into word aligned buffer
    000052  aa   277777 600001     129  	desc9a	2|-1(3),1
    000053  aa   300013 600001     130  	desc9a	3|char(3),1
    000054  aa  3 00013 2351 00    131  	lda	3|char		get right justified char into a
    000055  0a   000260 2350 05    132  loop2:	lda	char_table,al	pick up table entry
    000056  0a   000050 6000 00    133  	tze	loop1		zero means skip
    000057  aa   000000 2360 07    134  	ldq	0,dl		clear q
    000060  aa   000022 7330 00    135  	lrs	18		shift class to al, replacement char to qu
    000061  aa   000016 1150 07    136  	cmpa	nl,dl		is this end of the line
    000062  0a   000153 6000 00    137  	tze	eol		yes, finish up and return
    000063  aa   000021 1150 07    138  	cmpa	remark,dl		is this start of remark
    000064  0a   000106 6000 00    139  	tze	rem		yes, go process
    000065  aa   000022 1150 07    140  	cmpa	backslash,dl	is this possible end of statement
    000066  0a   000164 6000 00    141  	tze	check_backslash	yes, check further before returning
    000067  aa  3 00006 7551 56    142  	sta	3|class_tally,id	store class in buffer
    000070  0a   000212 6070 00    143  	ttf	ok1		and continue if end of buffer not reached
                                   144  "
                                   145  "	input line is too long, skip to next new line
                                   146  "
    000071  aa  3 00003 4411 00    147  runout:	sxl1	3|input_pos	save input position
    000072  aa  3 00003 2361 00    148  	ldq	3|input_pos
    000073  aa  3 00002 1161 00    149  	cmpq	3|input_length	did we read past end
    000074  0a   000100 6040 00    150  	tmi	too_long
                                   151  "
                                   152  "	end of segment reached without NL
                                   153  "
    000075  aa   000002 3360 07    154  no_nl:	lcq	2,dl
    000076  aa  3 00005 7561 00    155  	stq	3|number		return error code
    000077  aa  7 00044 7101 20    156  	short_return
                                   157  "
                                   158  "	more characters than length of buffer, search for NL or BACKSLASH
                                   159  "
    000100  aa   000001 3360 07    160  too_long:	lcq	1,dl
                                   161  "
    000101                         162  nl_search:
    000101  aa  3 00005 7561 00    163  	stq	3|number		save error code
    000102  0a   000120 7030 00    164  	tsx3	search_subroutine
    000103  aa   000001 1150 07    165  	cmpa	1,dl		check for blank line
    000104  0a   000002 6000 00    166  	tze	next_line		ignore blank line
    000105  aa  7 00044 7101 20    167  	short_return
                                   168  "
                                   169  "	have start of remark, ignore all characters up to next NL or BACKSLASH
                                   170  "
    000106  0a   000120 7030 00    171  rem:	tsx3	search_subroutine
    000107  aa  3 00015 2351 00    172  	lda	3|statement_ending	check which case we have
    000110  aa   000000 1150 07    173  	cmpa	0,dl
    000111  0a   000115 6000 00    174  	tze	load_nl
    000112  aa   000022 2350 07    175  	lda	backslash,dl	join normal termination
    000113  aa   000000 2360 03    176  	ldq	=o134000000000,du
    000114  0a   000155 7100 00    177  	tra	end_join+1
    000115  aa   000016 2350 07    178  load_nl:	lda	nl,dl		join normal termination
    000116  aa   000000 2360 03    179  	ldq	=o12000000000,du
    000117  0a   000155 7100 00    180  	tra	end_join+1
                                   181  "
                                   182  "	common code to search for NL and then BACKSLASH
                                   183  "
    000120                         184  search_subroutine:
    000120  aa  3 00003 4411 00    185  	sxl1	3|input_pos	save input position
    000121  aa  3 00002 2361 00    186  	ldq	3|input_length	get number of chars remaining
    000122  aa  3 00003 1761 00    187  	sbq	3|input_pos
    000123  0a   000075 6044 00    188  	tmoz	no_nl
    000124  aa  0 00003 1245 51    189  	scm	(pr,rl,x1),(du)	look for NL
    000125  aa   200000 000006     190  	desc9a	2|0,ql
    000126  aa   012000 000000     191  	vfd	o9/012,27/0
    000127  aa  3 00013 0001 00    192  	arg	3|char
    000130  0a   000075 6064 00    193  	ttn	no_nl		error if NL not found
                                   194  "
                                   195  "	search for backslash in the line
                                   196  "
    000131  aa  3 00013 2351 00    197  	lda	3|char		get number of chars we skipped
    000132  aa  0 00003 1245 51    198  	scm	(pr,rl,x1),(du)	look for backslash in the line
    000133  aa   200000 000005     199  	desc9a	2|0,al
    000134  aa   134000 000000     200  	vfd	o9/134,27/0
    000135  aa  3 00013 0001 00    201  	arg	3|char
    000136  0a   000145 6064 00    202  	ttn	nl_case		no backslash found
    000137  aa  3 00013 2361 00    203  	ldq	3|char		get number of characters skipped
    000140  aa   000001 0760 07    204  	adq	1,dl
    000141  aa  3 00003 0561 00    205  	asq	3|input_pos
    000142  aa   000044 7370 00    206  	lls	36		move q to a
    000143  aa  3 00015 0541 00    207  	aos	3|statement_ending	indicate statement ended by backslash
    000144  aa   000000 7100 13    208  	tra	0,3		return
    000145                         209  nl_case:
    000145  aa   000001 0750 07    210  	ada	1,dl
    000146  aa  3 00003 0551 00    211  	asa	3|input_pos
    000147  aa  3 00015 4501 00    212  	stz	3|statement_ending	indicate statement ended by new_line
    000150  aa   000000 7100 13    213  	tra	0,3		return
                                   214  "
                                   215  "	end of statement reached, determine number read and return
                                   216  "
    000151  aa  3 00015 0541 00    217  eos:	aos	3|statement_ending
    000152  0a   000154 7100 00    218  	tra	end_join
                                   219  "
                                   220  "	end of line reached, determine number read and return
                                   221  "
    000153  aa  3 00015 4501 00    222  eol:	stz	3|statement_ending
    000154  aa  3 00003 4411 00    223  end_join:	sxl1	3|input_pos	save input position
    000155  aa  3 00006 7551 56    224  	sta	3|class_tally,id	save class
    000156  aa  3 00010 7561 56    225  	stq	3|ch_tally,id	and character
    000157  aa  3 00006 2361 00    226  	ldq	3|class_tally	get current tally word
    000160  aa  3 00007 1361 00    227  	sblq	3|original_class_tally compute number of characters stored
    000161  aa   000022 7720 00    228  	qrl	18		in lower
    000162  aa  3 00005 7561 00    229  	stq	3|number		save for caller
    000163  aa  7 00044 7101 20    230  	short_return		and exit
                                   231  "
                                   232  "	check for ) without updating input position
                                   233  "	\) probably is part of asc function
                                   234  "
    000164                         235  check_backslash:
    000164  aa   000000 6220 11    236  	eax2	0,1		copy current position
    000165                         237  rparen_search:
    000165  aa   000001 0620 03    238  	adx2	1,du		look at next character
    000166  aa  0 00100 1005 11    239  	mlr	(pr,x1),(pr)
    000167  aa   277777 600002     240  	desc9a	2|-1(3),2
    000170  aa   300016 600002     241  	desc9a	3|temp_ch(3),2
    000171  aa  3 00016 2351 00    242  	lda	3|temp_ch
    000172  0a   000260 2350 05    243  	lda	char_table,al
    000173  0a   000165 6000 00    244  	tze	rparen_search
    000174  aa   000000 2360 07    245  	ldq	0,dl		clear q
    000175  aa   000022 7330 00    246  	lrs	18		shift class to al, replacement char to qu
    000176  aa   000000 6230 02    247  	eax3	0,qu		save char following \
    000177  aa   000022 2350 07    248  	lda	backslash,dl	restore aq to continue processing
    000200  aa   000000 2360 03    249  	ldq	=o134000000000,du
    000201  aa   000051 1030 07    250  	cmpx3	RIGHT_PAREN,dl
    000202  0a   000151 6010 00    251  	tnz	eos		must be end of statement
    000203  aa  3 00006 7551 56    252  	sta	3|class_tally,id	store class in buffer
    000204  0a   000212 6070 00    253  	ttf	ok1		and continue if end of buffer not reached
    000205  0a   000071 7100 00    254  	tra	runout		input line is too long
                                   255  "
                                   256  "	already went to end of segment
                                   257  "
    000206                         258  past_end:
    000206  aa  3 00003 4411 00    259  	sxl1	3|input_pos	save input position
    000207  aa   000004 3360 07    260  	lcq	4,dl
    000210  aa  3 00005 7561 00    261  	stq	3|number
    000211  aa  7 00044 7101 20    262  	short_return
                                   263  "
    000212  aa  3 00010 7561 56    264  ok1:	stq	3|ch_tally,id	save character replacement
    000213  aa   000017 1150 07    265  	cmpa	quote,dl		is this start of a character string constant
    000214  0a   000050 6010 00    266  	tnz	loop1		no, continue main scan
                                   267  "
                                   268  "	have start of string constant
                                   269  "
    000215                         270  start_string:
    000215  aa  3 00010 2351 00    271  	lda	3|ch_tally		save current character tally for later
    000216  aa  3 00012 7551 00    272  	sta	3|save_ch_tally
                                   273  "
    000217                         274  string_loop:
    000217  0a   000252 7000 00    275  	tsx0	next_char		get next character
    000220  aa  3 00006 4501 56    276  	stz	3|class_tally,id	count number "stored"
    000221  0a   000071 6064 00    277  	ttn	runout		error if tally runout
    000222  aa   000012 1150 07    278  	cmpa	NL,dl		is this nl
    000223  0a   000244 6000 00    279  	tze	string_error	yes, have string error
    000224  aa   000042 1150 07    280  	cmpa	QUOTE,dl		is it a quote
    000225  0a   000231 6000 00    281  	tze	end_string	yes, may be end of string
    000226  aa   000033 7350 00    282  plop:	als	27		no, shift char to first byte
    000227  aa  3 00010 7551 56    283  	sta	3|ch_tally,id	and save
    000230  0a   000217 7100 00    284  	tra	string_loop	then do next char
    000231                         285  end_string:
    000231  0a   000252 7000 00    286  	tsx0	next_char		get character after quote
    000232  aa   000042 1150 07    287  	cmpa	QUOTE,dl		is it another quote
    000233  0a   000226 6000 00    288  	tze	plop		yes, put one quote in buffer
                                   289  "
                                   290  "	end of string reached, store number of characters in string
                                   291  "	in character corresponding to first quote
                                   292  "
    000234  aa  3 00006 0111 54    293  	nop	3|class_tally,di	backup position in class buffer
    000235  aa  3 00010 2221 00    294  	ldx2	3|ch_tally	get current position
    000236  aa  3 00012 1621 00    295  	sbx2	3|save_ch_tally	compute number of characters stored
    000237  aa   000000 6360 12    296  	eaq	0,2		number to qu
    000240  aa   000011 7360 00    297  	qls	9		shift to first byte
    000241  aa  3 00012 0111 54    298  	nop	3|save_ch_tally,di	backup character tally by 1
    000242  aa  3 00012 7561 51    299  	stq	3|save_ch_tally,i	and store in buffer
    000243  0a   000055 7100 00    300  	tra	loop2		and then join normal loop
                                   301  "
                                   302  "	reached NL without terminating string
                                   303  "
    000244                         304  string_error:
    000244  aa  3 00003 4411 00    305  	sxl1	3|input_pos	save input position
    000245  aa   000003 3360 07    306  	lcq	3,dl
    000246  aa  3 00005 7561 00    307  	stq	3|number
    000247  aa  7 00044 7101 20    308  	short_return
                                   309  "
    000250                         310  no_line_number:
    000250  aa   000005 3360 07    311  	lcq	5,dl
    000251  0a   000101 7100 00    312  	tra	nl_search
                                   313  "
                                   314  "	subroutine to get next character from input, entered on x0
                                   315  "
    000252                         316  next_char:
    000252  aa   000001 0610 03    317  	adx1	1,du		update input position
    000253  aa  0 00100 1005 11    318  	mlr	(pr,x1),(pr)
    000254  aa   277777 600001     319  	desc9a	2|-1(3),1
    000255  aa   300013 600001     320  	desc9a	3|char(3),1
    000256  aa  3 00013 2351 00    321  	lda	3|char		get right justified character
    000257  aa   000000 7100 10    322  	tra	0,0		and return
                                   323  "
                                   324  "	character table, format is 18/class,9/replacement,9/0
                                   325  "
    000260                         326  char_table:
    000260  aa   000020 000000     327  	vfd	18/invalid,o9/000	000 NUL
    000261  aa   000020 001000     328  	vfd	18/invalid,o9/001	001
    000262  aa   000020 002000     329  	vfd	18/invalid,o9/002	002
    000263  aa   000020 003000     330  	vfd	18/invalid,o9/003	003
    000264  aa   000020 004000     331  	vfd	18/invalid,o9/004	004
    000265  aa   000020 005000     332  	vfd	18/invalid,o9/005	005
    000266  aa   000020 006000     333  	vfd	18/invalid,o9/006	006
    000267  aa   000020 007000     334  	vfd	18/invalid,o9/007	007 BEL
    000270  aa   000020 010000     335  	vfd	18/invalid,o9/010	010 BS
    000271  aa   000000 000000     336  	vfd	36/0		011 HT
    000272  aa   000016 012000     337  	vfd	18/nl,o9/012	012 NL
    000273  aa   000020 013000     338  	vfd	18/invalid,o9/013	013 VT
    000274  aa   000020 014000     339  	vfd	18/invalid,o9/014	014 NP
    000275  aa   000000 000000     340  	vfd	36/0		015 CR (for compatibility with Dartmouth)
    000276  aa   000020 016000     341  	vfd	18/invalid,o9/016	016 RRS
    000277  aa   000020 017000     342  	vfd	18/invalid,o9/017	017 BRS
    000300  aa   000020 020000     343  	vfd	18/invalid,o9/020	020
    000301  aa   000020 021000     344  	vfd	18/invalid,o9/021	021
    000302  aa   000020 022000     345  	vfd	18/invalid,o9/022	022
    000303  aa   000020 023000     346  	vfd	18/invalid,o9/023	023
    000304  aa   000020 024000     347  	vfd	18/invalid,o9/024	024
    000305  aa   000020 025000     348  	vfd	18/invalid,o9/025	025
    000306  aa   000020 026000     349  	vfd	18/invalid,o9/026	026
    000307  aa   000020 027000     350  	vfd	18/invalid,o9/027	027
    000310  aa   000020 030000     351  	vfd	18/invalid,o9/030	030
    000311  aa   000020 031000     352  	vfd	18/invalid,o9/031	031
    000312  aa   000020 032000     353  	vfd	18/invalid,o9/032	032
    000313  aa   000020 033000     354  	vfd	18/invalid,o9/033	033
    000314  aa   000020 034000     355  	vfd	18/invalid,o9/034	034
    000315  aa   000020 035000     356  	vfd	18/invalid,o9/035	035
    000316  aa   000020 036000     357  	vfd	18/invalid,o9/036	036
    000317  aa   000020 037000     358  	vfd	18/invalid,o9/037	037
    000320  aa   000000 000000     359  	vfd	36/0		040 space
    000321  aa   000020 041000     360  	vfd	18/invalid,o9/041	041 !
    000322  aa   000017 042000     361  	vfd	18/quote,o9/042	042 "
    000323  aa   000013 043000     362  	vfd	18/punc,o9/043	043 #
    000324  aa   000012 044000     363  	vfd	18/dollar,o9/044	044 $
    000325  aa   000020 045000     364  	vfd	18/invalid,o9/045	045 %
    000326  aa   000006 046000     365  	vfd	18/concat,o9/046	046 &
    000327  aa   000021 047000     366  	vfd	18/remark,o9/047	047 '
    000330  aa   000013 050000     367  	vfd	18/punc,o9/050	050 (
    000331  aa   000013 051000     368  	vfd	18/punc,o9/051	051 )
    000332  aa   000003 052000     369  	vfd	18/times,o9/052	052 *
    000333  aa   000001 053000     370  	vfd	18/plus,o9/053	053 +
    000334  aa   000013 054000     371  	vfd	18/punc,o9/054	054 ,
    000335  aa   000002 055000     372  	vfd	18/minus,o9/055	055 -
    000336  aa   000011 056000     373  	vfd	18/decimal,o9/056	056 .
    000337  aa   000004 057000     374  	vfd	18/divide,o9/057	057 /
    000340  aa   000010 060000     375  	vfd	18/digit,o9/060	060 0
    000341  aa   000010 061000     376  	vfd	18/digit,o9/061	061 1
    000342  aa   000010 062000     377  	vfd	18/digit,o9/062	062 2
    000343  aa   000010 063000     378  	vfd	18/digit,o9/063	063 3
    000344  aa   000010 064000     379  	vfd	18/digit,o9/064	064 4
    000345  aa   000010 065000     380  	vfd	18/digit,o9/065	065 5
    000346  aa   000010 066000     381  	vfd	18/digit,o9/066	066 6
    000347  aa   000010 067000     382  	vfd	18/digit,o9/067	067 7
    000350  aa   000010 070000     383  	vfd	18/digit,o9/070	070 8
    000351  aa   000010 071000     384  	vfd	18/digit,o9/071	071 9
    000352  aa   000013 072000     385  	vfd	18/punc,o9/072	072 :
    000353  aa   000013 073000     386  	vfd	18/punc,o9/073	073 ;
    000354  aa   000014 074000     387  	vfd	18/relation,o9/074	074 <
    000355  aa   000015 075000     388  	vfd	18/assign,o9/075	075 =
    000356  aa   000014 076000     389  	vfd	18/relation,o9/076	076 >
    000357  aa   000020 077000     390  	vfd	18/invalid,o9/077	077 ?
    000360  aa   000020 100000     391  	vfd	18/invalid,o9/100	100 @
    000361  aa   000007 141000     392  	vfd	18/letter,o9/141	101 A
    000362  aa   000007 142000     393  	vfd	18/letter,o9/142	102 B
    000363  aa   000007 143000     394  	vfd	18/letter,o9/143	103 C
    000364  aa   000007 144000     395  	vfd	18/letter,o9/144	104 D
    000365  aa   000007 145000     396  	vfd	18/letter,o9/145	105 E
    000366  aa   000007 146000     397  	vfd	18/letter,o9/146	106 F
    000367  aa   000007 147000     398  	vfd	18/letter,o9/147	107 G
    000370  aa   000007 150000     399  	vfd	18/letter,o9/150	110 H
    000371  aa   000007 151000     400  	vfd	18/letter,o9/151	111 I
    000372  aa   000007 152000     401  	vfd	18/letter,o9/152	112 J
    000373  aa   000007 153000     402  	vfd	18/letter,o9/153	113 K
    000374  aa   000007 154000     403  	vfd	18/letter,o9/154	114 L
    000375  aa   000007 155000     404  	vfd	18/letter,o9/155	115 M
    000376  aa   000007 156000     405  	vfd	18/letter,o9/156	116 N
    000377  aa   000007 157000     406  	vfd	18/letter,o9/157	117 O
    000400  aa   000007 160000     407  	vfd	18/letter,o9/160	120 P
    000401  aa   000007 161000     408  	vfd	18/letter,o9/161	121 Q
    000402  aa   000007 162000     409  	vfd	18/letter,o9/162	122 R
    000403  aa   000007 163000     410  	vfd	18/letter,o9/163	123 S
    000404  aa   000007 164000     411  	vfd	18/letter,o9/164	124 T
    000405  aa   000007 165000     412  	vfd	18/letter,o9/165	125 U
    000406  aa   000007 166000     413  	vfd	18/letter,o9/166	126 V
    000407  aa   000007 167000     414  	vfd	18/letter,o9/167	127 W
    000410  aa   000007 170000     415  	vfd	18/letter,o9/170	130 X
    000411  aa   000007 171000     416  	vfd	18/letter,o9/171	131 Y
    000412  aa   000007 172000     417  	vfd	18/letter,o9/172	132 Z
    000413  aa   000013 133000     418  	vfd	18/punc,o9/133	133 [
    000414  aa   000022 134000     419  	vfd	18/backslash,o9/134	134 \
    000415  aa   000013 135000     420  	vfd	18/punc,o9/135	135 ]
    000416  aa   000005 136000     421  	vfd	18/power,o9/136	136 ^
    000417  aa   000020 137000     422  	vfd	18/invalid,o9/137	137 _
    000420  aa   000020 140000     423  	vfd	18/invalid,o9/140	140 `
    000421  aa   000007 141000     424  	vfd	18/letter,o9/141	141 a
    000422  aa   000007 142000     425  	vfd	18/letter,o9/142	142 b
    000423  aa   000007 143000     426  	vfd	18/letter,o9/143	143 c
    000424  aa   000007 144000     427  	vfd	18/letter,o9/144	144 d
    000425  aa   000007 145000     428  	vfd	18/letter,o9/145	145 e
    000426  aa   000007 146000     429  	vfd	18/letter,o9/146	146 f
    000427  aa   000007 147000     430  	vfd	18/letter,o9/147	147 g
    000430  aa   000007 150000     431  	vfd	18/letter,o9/150	150 h
    000431  aa   000007 151000     432  	vfd	18/letter,o9/151	151 i
    000432  aa   000007 152000     433  	vfd	18/letter,o9/152	152 j
    000433  aa   000007 153000     434  	vfd	18/letter,o9/153	153 k
    000434  aa   000007 154000     435  	vfd	18/letter,o9/154	154 l
    000435  aa   000007 155000     436  	vfd	18/letter,o9/155	155 m
    000436  aa   000007 156000     437  	vfd	18/letter,o9/156	156 n
    000437  aa   000007 157000     438  	vfd	18/letter,o9/157	157 o
    000440  aa   000007 160000     439  	vfd	18/letter,o9/160	160 p
    000441  aa   000007 161000     440  	vfd	18/letter,o9/161	161 q
    000442  aa   000007 162000     441  	vfd	18/letter,o9/162	162 r
    000443  aa   000007 163000     442  	vfd	18/letter,o9/163	163 s
    000444  aa   000007 164000     443  	vfd	18/letter,o9/164	164 t
    000445  aa   000007 165000     444  	vfd	18/letter,o9/165	165 u
    000446  aa   000007 166000     445  	vfd	18/letter,o9/166	166 v
    000447  aa   000007 167000     446  	vfd	18/letter,o9/167	167 w
    000450  aa   000007 170000     447  	vfd	18/letter,o9/170	170 x
    000451  aa   000007 171000     448  	vfd	18/letter,o9/171	171 y
    000452  aa   000007 172000     449  	vfd	18/letter,o9/172	172 z
    000453  aa   000013 173000     450  	vfd	18/punc,o9/173	173 {
    000454  aa   000020 174000     451  	vfd	18/invalid,o9/174	174 |
    000455  aa   000013 175000     452  	vfd	18/punc,o9/175	175 }
    000456  aa   000020 176000     453  	vfd	18/invalid,o9/176	176 ~
    000457  aa   000020 177000     454  	vfd	18/invalid,o9/177	177 PAD
                                   455  "
                                   456  "	Character table used to skip over string of digits
                                   457  "
    000460                         458  skip_table:
    000460  aa   777777 777777     459  	dec	-1,-1		000 - 007
    000461  aa   777777 777777 
    000462  aa   777777 777777     460  	dec	-1,-1		010 - 017
    000463  aa   777777 777777 
    000464  aa   777777 777777     461  	dec	-1,-1		020 - 027
    000465  aa   777777 777777 
    000466  aa   777777 777777     462  	dec	-1,-1		030 - 037
    000467  aa   777777 777777 
    000470  aa   777777 777777     463  	dec	-1,-1		040 - 047
    000471  aa   777777 777777 
    000472  aa   777777 777777     464  	dec	-1,-1		050 - 057
    000473  aa   777777 777777 
    000474  aa   000000 000000     465  	dec	0,0		060 - 067
    000475  aa   000000 000000 
    000476  aa   000000 777777     466  	vfd	18/0,18/-1,36/-1	070 - 077
    000477  aa   777777 777777 
    000500  aa   777777 777777     467  	dec	-1,-1		100 - 107
    000501  aa   777777 777777 
    000502  aa   777777 777777     468  	dec	-1,-1		110 - 117
    000503  aa   777777 777777 
    000504  aa   777777 777777     469  	dec	-1,-1		120 - 127
    000505  aa   777777 777777 
    000506  aa   777777 777777     470  	dec	-1,-1		130 - 137
    000507  aa   777777 777777 
    000510  aa   777777 777777     471  	dec	-1,-1		140 - 147
    000511  aa   777777 777777 
    000512  aa   777777 777777     472  	dec	-1,-1		150 - 157
    000513  aa   777777 777777 
    000514  aa   777777 777777     473  	dec	-1,-1		160 - 167
    000515  aa   777777 777777 
    000516  aa   777777 777777     474  	dec	-1,-1		170 - 177
    000517  aa   777777 777777 
                                   475  "
                                   476  	end

NO LITERALS
     
NAME DEFINITIONS FOR ENTRY POINTS AND SEGDEFS

    000520  5a   000003 000000 
    000521  5a   000030 600000 
    000522  aa   000000 000000 
    000523  55   000012 000002 
    000524  5a   000002 400003 
    000525  55   000006 000012 
    000526  aa  017 142 141 163
    000527  aa  151 143 137 156
    000530  aa  145 170 164 137
    000531  aa  154 151 156 145
    000532  55   000021 000003 
    000533  0a   000000 400000 
    000534  55   000015 000003 
    000535  aa  017 142 141 163         basic_next_line
    000536  aa  151 143 137 156
    000537  aa  145 170 164 137
    000540  aa  154 151 156 145
    000541  55   000002 000012 
    000542  6a   000000 400002 
    000543  55   000024 000003 
    000544  aa  014 163 171 155         symbol_table
    000545  aa  142 157 154 137
    000546  aa  164 141 142 154
    000547  aa  145 000 000 000

DEFINITIONS HASH TABLE

    000550  aa   000000 000015 
    000551  aa   000000 000000 
    000552  aa   000000 000000 
    000553  aa   000000 000000 
    000554  aa   000000 000000 
    000555  aa   000000 000000 
    000556  aa   000000 000000 
    000557  5a   000021 000000 
    000560  aa   000000 000000 
    000561  aa   000000 000000 
    000562  aa   000000 000000 
    000563  aa   000000 000000 
    000564  5a   000012 000000 
    000565  aa   000000 000000 

NO EXTERNAL NAMES

NO TRAP POINTER WORDS

TYPE PAIR BLOCKS

    000566  aa   000001 000000 
    000567  aa   000000 000000 

INTERNAL EXPRESSION WORDS

LINKAGE INFORMATION
      
    000000  aa   000000 000000 
    000001  0a   000520 000000 
    000002  aa   000000 000000 
    000003  aa   000000 000000 
    000004  aa   000000 000000 
    000005  aa   000000 000000 
    000006  22   000010 000010 
    000007  a2   000000 000000 
SYMBOL INFORMATION
     
SYMBOL TABLE HEADER
     
    000000  aa   000000 000001 
    000001  aa   163171 155142 
    000002  aa   164162 145145 
    000003  aa   000000 000004 
    000004  aa   000000 111316 
    000005  aa   510113 575622 
    000006  aa   000000 111341 
    000007  aa   510101 255265 
    000010  aa   141154 155040 
    000011  aa   040040 040040 
    000012  aa   000024 000040 
    000013  aa   000034 000040 
    000014  aa   000044 000100 
    000015  aa   000002 000002 
    000016  aa   000064 000000 
    000017  aa   000000 000146 
    000020  aa   000000 000104 
    000021  aa   000000 000135 
    000022  aa   000140 000104 
    000023  aa   000064 000000 
    000024  aa   101114 115040 
    000025  aa   126145 162163 
    000026  aa   151157 156040 
    000027  aa   040066 056064 
    000030  aa   040040 101160 
    000031  aa   162151 154040 
    000032  aa   061071 070061 
    000033  aa   040040 040040 
    000034  aa   110157 154155 
    000035  aa   163164 145144 
    000036  aa   164056 123171 
    000037  aa   163115 141151 
    000040  aa   156164 056155 
    000041  aa   040040 040040 
    000042  aa   040040 040040 
    000043  aa   040040 040040 
    000044  aa   154151 163164 
    000045  aa   040040 040040 
    000046  aa   040040 040040 
    000047  aa   040040 040040 
    000050  aa   040040 040040 
    000051  aa   040040 040040 
    000052  aa   040040 040040 
    000053  aa   040040 040040 
    000054  aa   040040 040040 
    000055  aa   040040 040040 
    000056  aa   040040 040040 
    000057  aa   040040 040040 
    000060  aa   040040 040040 
    000061  aa   040040 040040 
    000062  aa   040040 040040 
    000063  aa   040040 040040 
    000064  aa   000000 000001 
    000065  aa   000000 000001 
    000066  aa   000072 000045 
    000067  aa   113400 472243 
    000070  aa   000000 111341 
    000071  aa   471235 400000 
    000072  aa   076144 165155          >dumps>old>recomp>basic_next_line.alm
    000073  aa   160163 076157 
    000074  aa   154144 076162 
    000075  aa   145143 157155 
    000076  aa   160076 142141 
    000077  aa   163151 143137 
    000100  aa   156145 170164 
    000101  aa   137154 151156 
    000102  aa   145056 141154 
    000103  aa   155040 040040 
               MULTICS ASSEMBLY CROSS REFERENCE LISTING

   Value        Symbol                   Source file   Line number

          15    assign                   basic_next_line:     64,  388.
          22    backslash                basic_next_line:     69,  140,  175,  248,  419.
           0    basic_next_line          basic_next_line:     77,   78.
         430    ch                       basic_next_line:     48,   87.
          13    char                     basic_next_line:     43,  107,  108,  114,  130,  131,  192,  197,  201,  203,  320,  321.
         260    char_table               basic_next_line:    132,  243,  326.
         164    check_backslash          basic_next_line:    141,  235.
          10    ch_tally                 basic_next_line:     40,   89,  125,  225,  264,  271,  283,  294.
          30    class                    basic_next_line:     47,   83.
           6    class_tally              basic_next_line:     38,   85,  124,  142,  224,  226,  252,  276,  293.
           6    concat                   basic_next_line:     57,  365.
          11    decimal                  basic_next_line:     60,  373.
          10    digit                    basic_next_line:     59,  375,  376,  377,  378,  379,  380,  381,  382,  383,  384.
           4    divide                   basic_next_line:     55,  374.
          12    dollar                   basic_next_line:     61,  363.
         154    end_join                 basic_next_line:    177,  180,  218,  223.
         231    end_string               basic_next_line:    281,  285.
         153    eol                      basic_next_line:    137,  222.
         151    eos                      basic_next_line:    217,  251.
           2    input_length             basic_next_line:     34,   91,   93,  117,  149,  186.
           3    input_pos                basic_next_line:     35,   92,   94,   99,  113,  118,  147,  148,  185,  187,  205,
                                                             211,  223,  259,  305.
           0    input_pt                 basic_next_line:     33,   95,   97.
          20    invalid                  basic_next_line:     67,  327,  328,  329,  330,  331,  332,  333,  334,  335,  338,
                                                             339,  341,  342,  343,  344,  345,  346,  347,  348,  349,  350,
                                                             351,  352,  353,  354,  355,  356,  357,  358,  360,  364,  390,
                                                             391,  422,  423,  451,  453,  454.
           7    letter                   basic_next_line:     58,  392,  393,  394,  395,  396,  397,  398,  399,  400,  401,
                                                             402,  403,  404,  405,  406,  407,  408,  409,  410,  411,  412,
                                                             413,  414,  415,  416,  417,  424,  425,  426,  427,  428,  429,
                                                             430,  431,  432,  433,  434,  435,  436,  437,  438,  439,  440,
                                                             441,  442,  443,  444,  445,  446,  447,  448,  449.
           4    line_number              basic_next_line:     36,  112.
         115    load_nl                  basic_next_line:    174,  178.
          50    loop1                    basic_next_line:    127,  133,  266.
          55    loop2                    basic_next_line:    132,  300.
         400    max_length               basic_next_line:     71,  120,  122.
           2    minus                    basic_next_line:     53,  372.
         252    next_char                basic_next_line:    275,  286,  316.
           2    next_line                basic_next_line:     82,  166.
          12    NL                       basic_next_line:     73,  278.
          16    nl                       basic_next_line:     65,  136,  178,  337.
         145    nl_case                  basic_next_line:    202,  209.
         101    nl_search                basic_next_line:    162,  312.
         250    no_line_number           basic_next_line:    109,  310.
          75    no_nl                    basic_next_line:    154,  188,  193.
           5    number                   basic_next_line:     37,  155,  163,  229,  261,  307.
         212    ok1                      basic_next_line:    143,  253,  264.
          11    original_ch_tally        basic_next_line:     41,   88.
           7    original_class_tally     basic_next_line:     39,   84,  227.
         206    past_end                 basic_next_line:    119,  258.
         226    plop                     basic_next_line:    282,  288.
           1    plus                     basic_next_line:     52,  370.
           5    power                    basic_next_line:     56,  421.
          13    punc                     basic_next_line:     62,  362,  367,  368,  371,  385,  386,  418,  420,  450,  452.
          42    QUOTE                    basic_next_line:     74,  280,  287.
          17    quote                    basic_next_line:     66,  265,  361.
          14    relation                 basic_next_line:     63,  387,  389.
         106    rem                      basic_next_line:    139,  171.
          21    remark                   basic_next_line:     68,  138,  366.
          51    RIGHT_PAREN              basic_next_line:     75,  250.
         165    rparen_search            basic_next_line:    237,  244.
          71    runout                   basic_next_line:    147,  254,  277.
          12    save_ch_tally            basic_next_line:     42,  272,  295,  298,  299.
          37    scan_statement           basic_next_line:    102,  116.
         120    search_subroutine        basic_next_line:    164,  171,  184.
         460    skip_table               basic_next_line:    106,  458.
         215    start_string             basic_next_line:    270.
          15    statement_ending         basic_next_line:     45,  100,  172,  207,  212,  217,  222.
          14    statement_number         basic_next_line:     44,  101.
         244    string_error             basic_next_line:    279,  304.
         217    string_loop              basic_next_line:    274,  284.
          16    temp_ch                  basic_next_line:     46,  241,  242.
           3    times                    basic_next_line:     54,  369.
         100    too_long                 basic_next_line:    150,  160.


NO FATAL ERRORS


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
