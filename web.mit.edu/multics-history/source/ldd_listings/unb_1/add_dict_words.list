	COMPILATION LISTING OF SEGMENT add_dict_words
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1057.59_Tue_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(85-09-13,Spitzer), approve(85-09-13,MCR6618),
       12*     audit(85-10-30,Blair), install(85-12-16,MR12.0-1001):
       13*     Allow to read/write
       14*     MSFs.
       15*                                                   END HISTORY COMMENTS */
       16 
       17 add_dict_words: adw: proc;
       18 
       19 /* This program contains five commands used to modify and examine
       20*   dictionaries.  A dictionary is represented as an indexed file.
       21*   Each word in the dictionary is represented by a key in the file.
       22*   A dictionary file is somewhat unusual in that it has no actual
       23*   records.  Instead, the record descriptor word for each key is used
       24*   to store certain attributes (e.g. hyphenation points) for the
       25*   associated key.  The commands are:
       26*
       27*   1. add_dict_words	adds words to a dictionary
       28*
       29*   2. delete_dict_words	deletes words from a dictionary
       30*
       31*   3. list_dict_words	lists words in a dictionary
       32*
       33*   4. count_dict_words	reports the number of words in a dictionary
       34*
       35*   5. find_dict_words	finds words in the dictionaries defined by
       36*   .			the "dict" search list
       37**/
       38 
       39 /* Coded by J. Stern, 1/13/77 */
       40 /* Modified 9/77 by J. Stern to upgrade for installation */
       41 /* Modified 10/25/77 by J. Stern to add find_dict_words command */
       42 /* Modified 08/19/80 by P. Benjamin to fix bug when dict not first arg */
       43 /* Modified 12/17/80 by P. Benjamin to fix bug where ddw creates dict when not found */
       44 /* Modified 07/13/81 by P. Benjamin to fix bug where bad dict in search list
       45*			      causes processing to halt */
       46 
       47 /* Automatic */
       48 
       49 dcl  ring_brackets (3) fixed bin (6);
       50 dcl  bc fixed bin (24);
       51 dcl  max_seg_size fixed bin (35);
       52 dcl  component fixed bin;
       53 dcl  type fixed bin (2);
       54 dcl  msf bit (1) aligned;
       55 dcl (add_cmd, delete_cmd, list_cmd, count_cmd, find_cmd) bit (1) aligned init ("0"b);
       56 dcl  whoami char (20);
       57 dcl  arg_syntax char (120);
       58 dcl (nargs, words) fixed bin;
       59 dcl (argno, pn_argno) fixed bin;
       60 dcl  ap ptr;
       61 dcl  al fixed bin;
       62 dcl  code fixed bin (35);
       63 dcl (brief_opt, force_opt, raw_opt, output_file_opt, input_file_opt, count_opt, dictionary_opt) bit (1) aligned;
       64 dcl (pname, of_pname) char (168);
       65 dcl  switch char (32);
       66 dcl  atd char (256) varying;
       67 dcl  atd_len fixed bin;
       68 dcl  second_attach bit (1) aligned;
       69 dcl  iocb_ptr ptr;
       70 dcl  open_mode fixed bin;
       71 dcl (of_dname, if_dname) char (168);
       72 dcl (of_ename, if_ename) char (32);
       73 dcl (of_ptr, if_ptr, fcb_ptr) ptr;
       74 dcl (of_len, if_len) fixed bin (21);
       75 dcl  word_count fixed bin;
       76 dcl  dict_path char (168);
       77 dcl  temp_ptr ptr;
       78 dcl  bad_dict_ptr ptr;
       79 dcl  complained_once bit (1);
       80 		 		 
       81 dcl 1 add_key_info,
       82     2 flags aligned like ak_header.flags,
       83     2 descrip aligned like descriptor_template,
       84     2 key_len fixed bin,
       85     2 key char (256);
       86 
       87 dcl 1 delete_key_info like add_key_info;
       88 
       89 dcl 1 get_key_info,
       90     2 flags aligned like gk_header.flags,
       91     2 descrip aligned like descriptor_template,
       92     2 key_len fixed bin,
       93     2 key char (256);
       94 
       95 dcl 1 reassign_key_info,
       96     2 flags aligned like rk_header.flags,
       97     2 old_descrip aligned like descriptor_template,
       98     2 new_descrip aligned like descriptor_template,
       99     2 key_len fixed bin,
      100     2 key char (256);
      101 
      102 dcl 1 sh_info,
      103     2 rel_type fixed bin,
      104     2 head_len fixed bin,
      105     2 key_head char (256);
      106 
      107 dcl 1 info aligned like indx_info;
      108 
      109 dcl 1 fdw_control aligned,
      110     2 exact_match bit (1) unal,
      111     2 mbz bit (35) unal;
      112 
      113 
      114 /* Based */
      115 
      116 dcl  arg char (al) based (ap);
      117 dcl  of char (of_len) based (of_ptr);
      118 dcl  if char (if_len) based (if_ptr);
      119 dcl  if_vec (if_len) char (1) based (if_ptr);
      120 
      121 dcl 1 descriptor_template aligned based,
      122     2 hpoints (32) bit (1) unal,
      123     2 notrim bit (1) unal,
      124     2 pad bit (3) unal;
      125 
      126 dcl 1 bad_dict aligned based (bad_dict_ptr),
      127       2 n fixed bin,
      128       2 entry (0 refer (bad_dict.n)),
      129         3 ecode fixed bin (35),
      130         3 path char (168) unal;
      131 
      132 /* Conditions */
      133 
      134 dcl  cleanup condition;
      135 
      136 
      137 /* Static */
      138 
      139 dcl  stream_input fixed bin int static options (constant) init (1);
      140 dcl  keyed_sequential_input fixed bin int static options (constant) init (8);
      141 dcl  keyed_sequential_update fixed bin int static options (constant) init (10);
      142 
      143 dcl  error_table_$dirseg fixed bin(35) ext static;
      144 dcl  error_table_$long_record fixed bin(35) ext static;
      145 dcl  error_table_$short_record fixed bin(35) ext static;
      146 dcl  error_table_$zero_length_seg fixed bin (35) ext;
      147 dcl  error_table_$noarg fixed bin (35) ext;
      148 dcl  error_table_$badopt fixed bin (35) ext;
      149 dcl  error_table_$key_duplication fixed bin (35) ext;
      150 dcl  error_table_$no_record fixed bin (35) ext;
      151 dcl  error_table_$no_key fixed bin (35) ext;
      152 dcl  error_table_$end_of_info fixed bin (35) ext;
      153 dcl  error_table_$noentry fixed bin (35) ext;
      154 dcl  error_table_$wrong_no_of_args fixed bin (35) ext;
      155 dcl  error_table_$id_not_found fixed bin (35) ext;
      156 dcl  error_table_$fatal_error	fixed bin(35) ext static;
      157 dcl  error_table_$recoverable_error fixed bin(35) ext static;
      158 		 
      159 dcl  iox_$user_output ptr ext;
      160 dcl  sys_info$max_seg_size fixed bin(35) ext static;
      161 
      162 dcl  NL char (1) aligned int static options (constant) init ("
      163 ");
      164 
      165 
      166 /* Builtins */
      167 
      168 dcl (addr, copy, divide, index, length, max, min, null, rtrim, substr, string, unspec) builtin;
      169 
      170 
      171 /* Entries */
      172 
      173 dcl  cu_$arg_count entry (fixed bin);
      174 dcl  com_err_ entry options (variable);
      175 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
      176 dcl  iox_$attach_name entry (char(*), ptr, char(*), ptr, fixed bin(35));
      177 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
      178 dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
      179 dcl  iox_$position entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
      180 dcl  iox_$close entry (ptr, fixed bin (35));
      181 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
      182 dcl  iox_$destroy_iocb entry (ptr, fixed bin(35));
      183 dcl  ioa_ options (variable);
      184 dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
      185 dcl  hcs_$status_minf entry (char(*), char(*), fixed bin(1), fixed bin(2), fixed bin(24), fixed bin(35));
      186 dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
      187 dcl  initiate_file_ entry (char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35));
      188 dcl  terminate_file_ entry (ptr, fixed bin(24), bit(*), fixed bin(35));
      189 dcl  unique_chars_ entry (bit (*)) returns (char (15));
      190 dcl  absolute_pathname_$add_suffix entry (char (*), char (*), char (*), fixed bin (35));
      191 dcl  find_dict_word_ entry (char (*), bit (36) aligned, char (256), bit (36) aligned, char (168), ptr, fixed bin (35));
      192 dcl  get_temp_segment_ entry (char (*), ptr, fixed bin (35));
      193 dcl  release_temp_segment_ entry (char (*), ptr, fixed bin (35));
      194 dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
      195 dcl  iox_$get_line entry (ptr, ptr, fixed bin(21), fixed bin(21), fixed bin(35));
      196 dcl  pathname_ entry (char(*), char(*)) returns(char(168));
      197 dcl  msf_manager_$open entry (char(*), char(*), ptr, fixed bin(35));
      198 dcl  msf_manager_$close entry (ptr);
      199 dcl  msf_manager_$get_ptr entry (ptr, fixed bin, bit(1), ptr, fixed bin(24), fixed bin(35));
      200 dcl  make_msf_ entry (char(*), char(*), (3) fixed bin(6), fixed bin(35));
      201 dcl  unmake_msf_ entry (char(*), char(*), bit(1), (3) fixed bin(6), fixed bin(35));
      202 
      203 
      204 	add_cmd = "1"b;
      205 	whoami = "add_dict_words";
      206 	arg_syntax = "path words {-count} {-force} {-input_file path} {-raw} {-word word}";
      207 	go to join;
      208 
      209 delete_dict_words: ddw: entry;
      210 
      211 	delete_cmd = "1"b;
      212 	whoami = "delete_dict_words";
      213 	arg_syntax = "path words {-brief} {-count} {-input_file path} {-word word}";
      214 	go to join;
      215 
      216 list_dict_words: ldw: entry;
      217 
      218 	list_cmd = "1"b;
      219 	whoami = "list_dict_words";
      220 	arg_syntax = "path words {-brief} {-input_file path} {-output_file path} {-raw} {-word word}";
      221 	go to join;
      222 
      223 count_dict_words: cdw: entry;
      224 
      225 	count_cmd = "1"b;
      226 	whoami = "count_dict_words";
      227 	arg_syntax = "path";
      228 	go to join;
      229 
      230 find_dict_words: fdw: entry;
      231 
      232 	find_cmd = "1"b;
      233 	whoami = "find_dict_words";
      234 	arg_syntax = "words {-brief} {-dictionary} {-exact_match} {-input_file path} {-output_file path} {-raw} {-word word}";
      235 
      236 
      237 /* find out how many arguments we have */
      238 
      239 join:	call cu_$arg_count (nargs);
      240 	if list_cmd | count_cmd | find_cmd
      241 	then if nargs < 1
      242 	     then do;
      243 noarg:		code = error_table_$noarg;
      244 usage:		call com_err_ (code, whoami, "^/Usage:  ^a ^a", whoami, arg_syntax);
      245 		return;
      246 	     end;
      247 	     else;
      248 	else if nargs < 2
      249 	then go to noarg;
      250 
      251 /* examine the arguments */
      252 
      253 	brief_opt, force_opt, raw_opt, output_file_opt, input_file_opt, count_opt, dictionary_opt = "0"b;
      254 	if find_cmd
      255 	then do;
      256 	     pn_argno = 0;
      257 	     string (fdw_control) = ""b;
      258 	end;
      259 	else pn_argno = -1;
      260 	words = 0;
      261 	do argno = 1 to nargs;
      262 	     call cu_$arg_ptr (argno, ap, al, code);
      263 	     if index (arg, "-") ^= 1			/* not a control argument */
      264 	     then if pn_argno = -1			/* don't have dictionary path yet */
      265 		then do;				/* so this must be it */
      266 		     call absolute_pathname_$add_suffix (arg, "dict", pname, code);
      267 		     if code ^= 0
      268 		     then do;
      269 			call com_err_ (code, whoami, arg);
      270 			return;
      271 		     end;
      272 		     pn_argno = argno;
      273 		end;
      274 		else if count_cmd
      275 		then do;
      276 		     code = error_table_$wrong_no_of_args;
      277 		     go to usage;
      278 		end;
      279 		else words = words +1;		/* not dictionary path, must be a word */
      280 	     else do;				/* control argument */
      281 		if (delete_cmd | list_cmd | find_cmd) & (arg = "-bf" | arg = "-brief")
      282 		then brief_opt = "1"b;
      283 		else if add_cmd & (arg = "-fc" | arg = "-force")
      284 		then force_opt = "1"b;
      285 		else if (list_cmd | find_cmd) & (arg = "-of" | arg = "-output_file")
      286 		then do;
      287 		     argno = argno +1;
      288 		     if argno > nargs
      289 		     then go to noarg;
      290 		     call cu_$arg_ptr (argno, ap, al, code);
      291 		     of_pname = arg;
      292 		     output_file_opt = "1"b;
      293 		end;
      294 		else if ^count_cmd & (arg = "-if" | arg = "-input_file")
      295 		then do;
      296 		     argno = argno +1;
      297 		     if argno > nargs
      298 		     then go to noarg;
      299 		     input_file_opt = "1"b;
      300 		end;
      301 		else if (add_cmd | list_cmd | find_cmd) & arg = "-raw"
      302 		then raw_opt = "1"b;
      303 		else if (add_cmd | delete_cmd) & (arg = "-ct" | arg = "-count")
      304 		then count_opt = "1"b;
      305 		else if find_cmd & (arg = "-dict" | arg = "-dictionary")
      306 		then dictionary_opt = "1"b;
      307 		else if find_cmd & (arg = "-exm" | arg = "-exact_match")
      308 		then fdw_control.exact_match = "1"b;
      309 		else if ^count_cmd & arg = "-word"
      310 		then do;
      311 		     argno = argno + 1;
      312 		     if argno > nargs
      313 		     then go to noarg;
      314 		     words = words + 1;
      315 		end;
      316 		else do;
      317 		     call com_err_ (error_table_$badopt, whoami, "^a", arg);
      318 		     return;
      319 		end;
      320 	     end;
      321 	end;
      322 
      323 	if pn_argno = -1
      324 	then go to noarg;
      325 
      326 	if (add_cmd | delete_cmd | find_cmd) & ^input_file_opt & words = 0
      327 	then go to noarg;
      328 
      329 	iocb_ptr, fcb_ptr, of_ptr, if_ptr, temp_ptr, bad_dict_ptr = null;
      330 	max_seg_size = sys_info$max_seg_size * 4;
      331 
      332 	on cleanup call cleaner;
      333 
      334 	call get_temp_segment_ (whoami, bad_dict_ptr, code);
      335 	if code ^= 0
      336 	     then do;
      337 	     call com_err_ (code, whoami);
      338 	     goto clean_up;
      339 	end;
      340 	
      341 	complained_once = "0"b;			/* certain errors should be given only */
      342 						/* per command, not one per word */
      343 
      344 	if find_cmd
      345 	then go to check_of;
      346 
      347 /* attach and open the dictionary */
      348 
      349 	second_attach = "0"b;
      350 	switch = unique_chars_ (""b) || "." || whoami;	/* use unique I/O switch name */
      351 	atd = "vfile_ " || rtrim (pname);
      352 	atd = atd || " -share -old";			/* build attach description, assume dictionary exists */
      353 
      354 	if list_cmd
      355 	then open_mode = keyed_sequential_input;
      356 	else open_mode = keyed_sequential_update;
      357 
      358 attach:	call iox_$attach_name (switch, iocb_ptr, (atd), null, code);
      359 	if code ^= 0
      360 	then do;
      361 	     call com_err_ (code, whoami, "Cannot attach switch.  ^a", switch);
      362 	     return;
      363 	end;
      364 
      365 	if count_cmd
      366 	then go to get_count;
      367 
      368 	if second_attach				/* give warning of new dictionary creation */
      369 	then call ioa_ ("^a:  Creating ^a", whoami, pname);
      370 
      371 	call iox_$open (iocb_ptr, open_mode, "0"b, code);
      372 	if code ^= 0
      373 	then if code = error_table_$noentry & open_mode = keyed_sequential_update & ^second_attach
      374 	     then do;				/* no dictionary, warn user and then create one */
      375 
      376 		if delete_cmd			/* but not for ddw! */
      377 		     then do;
      378 		     call com_err_ (code, whoami, "^a", pname);
      379 		     goto clean_up;
      380 		end;
      381 
      382 		call close_file (iocb_ptr);
      383 
      384 		atd_len = length (rtrim (atd));
      385 		substr (atd, atd_len-3, 4) = "";	/* remove "-old" from attach description */
      386 		second_attach = "1"b;
      387 		go to attach;
      388 	     end;
      389 	     else do;
      390 		call com_err_ (code, whoami, "Cannot open file.  ^a", pname);
      391 		go to clean_up;
      392 	     end;
      393 
      394 /* make output segment if requested */
      395 
      396 	if list_cmd | find_cmd
      397 	then do;
      398 check_of:	     if output_file_opt
      399 	     then do;
      400 		call expand_pathname_ (of_pname, of_dname, of_ename, code);
      401 		if code ^= 0
      402 		then do;
      403 		     call com_err_ (code, whoami, "^a", of_pname);
      404 		     go to clean_up;
      405 		end;
      406 
      407 		call hcs_$status_minf (of_dname, of_ename, 1, type, bc, code);
      408 		if code = 0
      409 		then if type = 2			/* entry exists */
      410 		     then if bc = 0			/* DIR */
      411 			then do;			/* really a DIR */
      412 			     code = error_table_$dirseg;
      413 			     goto bad_of;
      414 			     end;
      415 			else do;			/* DIR & bc>0 = MSF */
      416 			     call unmake_msf_ (of_dname, of_ename, "0"b, ring_brackets, code);
      417 			     if code ^= 0 then goto bad_of;
      418 			     end;
      419 		     else ;			/* must be a SSF */
      420 		else if code ^= error_table_$noentry
      421 		     then goto bad_of;		/* allowed to be non-existent */
      422 
      423 		call hcs_$make_seg (of_dname, of_ename, "", 01010b, of_ptr, code);
      424 		if of_ptr = null
      425 		then do;
      426 bad_of:		     call com_err_ (code, whoami, "^a", pathname_ (of_dname, of_ename));
      427 		     go to clean_up;
      428 		end;
      429 	     end;
      430 	     else do;				/* get temp segment to buffer output */
      431 		call get_temp_segment_ (whoami, temp_ptr, code);
      432 		if code ^= 0
      433 		then do;
      434 		     call com_err_ (code, whoami, "Cannot get temporary segment.");
      435 		     go to clean_up;
      436 		end;
      437 		of_ptr = temp_ptr;
      438 	     end;
      439 
      440 	     component = 0;
      441 	end;
      442 
      443 /* initialize info for vfile_ control orders */
      444 
      445 	if delete_cmd
      446 	then do;
      447 	     sh_info.rel_type = 0;
      448 	     sh_info.head_len = 256;			/* max word size = 256 */
      449 	     string (delete_key_info.flags) = ""b;
      450 	end;
      451 	else if add_cmd
      452 	then do;
      453 	     string (add_key_info.flags) = ""b;
      454 	     add_key_info.input_key, add_key_info.input_desc = "1"b;
      455 	     if force_opt
      456 	     then do;
      457 		string (reassign_key_info.flags) = ""b;
      458 		reassign_key_info.input_new_desc = "1"b;
      459 	     end;
      460 	     go to gk_setup;
      461 	end;
      462 	else if list_cmd
      463 	then if words = 0 & ^input_file_opt
      464 	     then unspec (get_key_info.flags) = ""b;
      465 	     else do;
      466 gk_setup:		get_key_info.flags.input_key = "1"b;
      467 		get_key_info.input_desc = "0"b;
      468 		get_key_info.desc_code = 0;
      469 		get_key_info.rel_type = 0;
      470 		get_key_info.head_size = 256;
      471 		get_key_info.reset_pos = "0"b;
      472 		get_key_info.flags.pad = ""b;
      473 		get_key_info.version = gk_info_version_0;
      474 	     end;
      475 
      476 /* get to work */
      477 
      478 	of_len, word_count = 0;
      479 
      480 	if list_cmd & words = 0 & ^input_file_opt
      481 	then call list_all;
      482 	else do argno = 1 to nargs;		/* look again for words and input files */
      483 	     if argno = pn_argno
      484 		then argno = argno + 1;
      485 	     if argno > nargs
      486 		then goto get_out;
      487 	     call cu_$arg_ptr (argno, ap, al, code);
      488 	     if index (arg, "-") = 1
      489 	     then do;
      490 		if arg = "-if" | arg = "-input_file"
      491 		then do;
      492 		     argno = argno +1;
      493 		     call cu_$arg_ptr (argno, ap, al, code);
      494 		     call read_input_file;
      495 		end;
      496 		else if arg = "-of" | arg = "-output_file"
      497 		then argno = argno +1;
      498 		else if arg = "-word"
      499 		then do;
      500 		     argno = argno + 1;
      501 		     call cu_$arg_ptr (argno, ap, al, code);
      502 		     call process_word (arg);
      503 		end;
      504 	     end;
      505 	     else call process_word (arg);
      506 get_out:	     
      507 	end;
      508 
      509 
      510 /* print results for list and find */
      511 
      512 	if of_len > 0
      513 	then if output_file_opt
      514 	     then do;
      515 		call terminate_file_ (of_ptr, of_len * 9, TERM_FILE_TRUNC_BC_TERM, code);
      516 		if code ^= 0
      517 		then call com_err_ (code, whoami, "Setting bit count on ^a.", pathname_ (of_dname, of_ename));
      518 		end;
      519 	     else do;
      520 		call iox_$put_chars (iox_$user_output, of_ptr, of_len, code);
      521 		if code ^= 0
      522 		then call com_err_ (code, whoami, "Attempting to write on user_output switch.");
      523 		end;
      524 
      525 /* report counts if requested */
      526 
      527 	if count_opt
      528 	then do;
      529 	     call ioa_ ("number of words ^[added^;deleted^] = ^d", add_cmd, word_count);
      530 
      531 get_count:     indx_info.info_version = vfs_version_1;
      532 	     call iox_$control (iocb_ptr, "file_status", addr (indx_info), code);
      533 	     if code ^= 0
      534 	     then call com_err_ (code, whoami, "Cannot get dictionary word count.");
      535 	     else call ioa_ ("number of dictionary words = ^d", indx_info.num_keys);
      536 	end;
      537 
      538 /* clean up and leave */
      539 
      540 clean_up:	call cleaner;
      541 	return;
      542 
      543 cleaner:	proc;					/* cleanup procedure */
      544 
      545 	if iocb_ptr ^= null
      546 	then call close_file (iocb_ptr);
      547 
      548 	if of_ptr ^= null
      549 	then if of_ptr = temp_ptr
      550 	     then call release_temp_segment_ (whoami, temp_ptr, (0));
      551 	     else call terminate_file_ (of_ptr, 0, TERM_FILE_TERM, (0));
      552 
      553 	if if_ptr ^= null
      554 	then if msf
      555 	     then call close_file (if_ptr);
      556 	     else call terminate_file_ (if_ptr, 0, TERM_FILE_TERM, (0));
      557 
      558 	if bad_dict_ptr ^= null
      559 	then call release_temp_segment_ (whoami, bad_dict_ptr, (0));
      560 
      561 	if fcb_ptr ^= null
      562 	then call msf_manager_$close (fcb_ptr);
      563 
      564 	return;
      565 	end cleaner;
      566 
      567 /* This procedure reads words from an input file whose pathname
      568*   is given by the value of arg.  Words are assumed to be separated
      569*   by newlines.  Each word read is submitted to process_word.
      570**/
      571 
      572 read_input_file: proc;
      573 
      574 dcl (i, max_word_len, NL_index, word_len) fixed bin (21);
      575 dcl  word char (word_len) based (word_ptr);
      576 dcl  word_ptr ptr;
      577 dcl  if_buffer char (257);
      578 	       
      579 	     msf = "0"b;
      580 	     if_ptr = null;
      581 
      582 	     call expand_pathname_ (arg, if_dname, if_ename, code);
      583 	     if code ^= 0
      584 	     then do;
      585 		call com_err_ (code, whoami, "Input file ignored. ^a", arg);
      586 		return;
      587 	     end;
      588 
      589 	     call hcs_$status_minf (if_dname, if_ename, 1, type, bc, code);
      590 	     if code ^= 0 then do;
      591 bad_if:		call com_err_ (code, whoami, "Input file ignored. ^a", pathname_ (if_dname, if_ename));
      592 		goto EOF;
      593 		end;
      594 
      595 	     if type = 2
      596 	     then if bc = 0
      597 		then do;
      598 		     code = error_table_$dirseg;
      599 		     goto bad_if;
      600 		     end;
      601 		else msf = "1"b;
      602 	     else msf = "0"b;
      603 
      604 	     if msf then do;
      605 		atd = "vfile_ " || rtrim (if_dname);
      606 		atd = atd || ">";
      607 		atd = atd || rtrim (if_ename);
      608 		atd = atd || " -old";
      609 
      610 		call iox_$attach_name (unique_chars_ ("0"b) || whoami, if_ptr, (atd), null, code);
      611 		if code ^= 0 then goto bad_if;
      612 		call iox_$open (if_ptr, stream_input, "0"b, code);
      613 		if code ^= 0 then goto bad_if;
      614 
      615 		word_ptr = addr (if_buffer);
      616 		max_word_len = length (if_buffer);
      617 
      618 		call iox_$get_line (if_ptr, word_ptr, max_word_len, word_len, code);
      619 		end;
      620 	     else do;
      621 		call initiate_file_ (if_dname, if_ename, R_ACCESS, if_ptr, bc, code);
      622 		if if_ptr = null
      623 		then go to bad_if;
      624 
      625 		if_len = divide (bc, 9, 21, 0);
      626 		if if_len = 0
      627 		then do;
      628 		     code = error_table_$zero_length_seg;
      629 		     go to bad_if;
      630 		end;
      631 
      632 		i = 1;
      633 		end;
      634 
      635 	     do while ("1"b);
      636 		if msf
      637 		then if code ^= 0
      638 		     then if code = error_table_$end_of_info
      639 		          then goto EOF;
      640 			else if code = error_table_$long_record | code = error_table_$short_record
      641 			     then ;		/* allowable errors */
      642 			else goto bad_if;
      643 		     else do;
      644 			NL_index = index (word, NL);
      645 			if NL_index > 0
      646 			then word_len = NL_index - 1;
      647 			if word_len = -1
      648 			then goto read_next;
      649 			end;
      650 		else if i > if_len
      651 		     then goto EOF;
      652 		     else do;
      653 			word_len = index (substr (if, i), NL) -1;
      654 			if word_len = 0
      655 			then go to read_next;
      656 			if word_len = -1
      657 			then word_len = if_len - i + 1;
      658 			word_ptr = addr (if_vec (i));
      659 			end;
      660 
      661 		call process_word (word);
      662 
      663 read_next:
      664 		if msf
      665 		then call iox_$get_line (if_ptr, word_ptr, max_word_len, word_len, code);
      666 		else i = i + word_len +1;
      667 	     end;
      668 
      669 EOF:
      670 	if if_ptr ^= null
      671 	then if msf
      672 	     then call close_file (if_ptr);
      673 	     else do;
      674 		call terminate_file_ (if_ptr, 0, TERM_FILE_TERM, code);
      675 		if_ptr = null;
      676 		end;
      677 
      678 	return;
      679 	end read_input_file;
      680 
      681 close_file:
      682      proc (iocbp);
      683 
      684 dcl  iocbp ptr parameter;
      685 
      686 	if iocbp ^= null then do;
      687 	     call iox_$close (iocbp, (0));
      688 	     call iox_$detach_iocb (iocbp, (0));
      689 	     call iox_$destroy_iocb (iocbp, (0));
      690 	     iocbp = null;
      691 	     end;
      692 
      693 	return;
      694 	end close_file;
      695 
      696 /* This procedure selects the proper subroutine to process the current word. */
      697 
      698 process_word: proc (cur_word);
      699 
      700 dcl  cur_word char (*);
      701 
      702 
      703 	     if add_cmd
      704 	     then call add;
      705 	     else if delete_cmd
      706 	     then call delete;
      707 	     else if list_cmd
      708 	     then call list;
      709 	     else call find;
      710 
      711 /* This procedure adds the current word to the dictionary.  It first
      712*   scans the word for hyphenation and/or notrim.  If the word already
      713*   exists in the dictionary, it is not added (reassigned) unless the
      714*   force option was specified.
      715**/
      716 
      717 add:	     proc;
      718 
      719 dcl (i, j) fixed bin;
      720 dcl  keystr char (256) varying;
      721 dcl  next_char char (1);
      722 
      723 /* examine word for hyphenation and notrim, isolate the key */
      724 
      725 		string (add_key_info.descrip) = ""b;
      726 
      727 		if raw_opt
      728 		then do;
      729 		     if length (cur_word) > 256
      730 		     then do;
      731 big_word:			call com_err_ (0, whoami, "Word size exceeds 256.  Word ignored.  ^a", cur_word);
      732 			return;
      733 		     end;
      734 		     keystr = cur_word;
      735 		     go to add_key;
      736 		end;
      737 
      738 		keystr = "";
      739 		j = 1;
      740 		if substr (cur_word, 1, 1) = "^"	/* check for notrim */
      741 		then do;
      742 		     if length (cur_word) > 1
      743 		     then next_char = substr (cur_word, 2, 1);
      744 		     else next_char = " ";
      745 
      746 		     if next_char ^= "="		/* must be a notrim sign */
      747 		     then add_key_info.descrip.notrim = "1"b;
      748 
      749 		     if next_char = "=" | next_char = "^" /* must be a literal circumflex */
      750 		     then do;
      751 			keystr = "^";
      752 			j = 3;
      753 		     end;
      754 		     else j = 2;
      755 		end;
      756 
      757 		do j = j by 1 while (j <= length (cur_word));
      758 		     i = index (substr (cur_word, j), "-") -1;
      759 		     if i = -1
      760 		     then i = length (cur_word) - j + 1;
      761 
      762 		     if i > 0			/* add chars to key */
      763 		     then do;
      764 			if i + length (keystr) > 256
      765 			then go to big_word;
      766 			keystr = keystr || substr (cur_word, j, i);
      767 			j = j + i;		/* j points to next hyphen or circumflex */
      768 		     end;
      769 
      770 		     if j <= length (cur_word)	/* something left */
      771 		     then do;
      772 			if j < length (cur_word)
      773 			then next_char = substr (cur_word, j+1, 1);
      774 			else next_char = " ";
      775 
      776 			if next_char ^= "="		/* must be a hyphenation point */
      777 			then do;
      778 			     if length (keystr) = 0
      779 			     then do;
      780 				call com_err_ (0, whoami, "Hyphenation point precedes word.  Word ignored.  ^a", cur_word);
      781 				return;
      782 			     end;
      783 			     if substr (keystr, length (keystr), 1) = "-"
      784 			     then do;
      785 				call com_err_ (0, whoami, "Hyphenation point immediately follows hyphen.  Word ignored.  ^a", cur_word);
      786 				return;
      787 			     end;
      788 			     if length (keystr) > 32
      789 			     then do;
      790 				call com_err_ (0, whoami, "Hyphenation point occurs beyond 33rd character.  Word ignored.  ^a", cur_word);
      791 				return;
      792 			     end;
      793 			     add_key_info.descrip.hpoints (length (keystr)) = "1"b; /* indicate hyphenation point */
      794 			end;
      795 
      796 			if next_char = "=" | next_char = "-" /* must be a literal hyphen */
      797 			then do;
      798 			     if length (keystr) = 256
      799 			     then go to big_word;
      800 			     keystr = keystr || "-";	/* indicate literal hyphen */
      801 			     j = j + 1;		/* to skip over two character sequence */
      802 			end;
      803 		     end;
      804 		end;
      805 
      806 		if length (keystr) <= 32
      807 		then if add_key_info.descrip.hpoints (length (keystr))
      808 		     then do;
      809 			call com_err_ (0, whoami, "Hyphenation point follows word.  Word ignored.  ^a", cur_word);
      810 			return;
      811 		     end;
      812 
      813 /* add the word to the dictionary */
      814 
      815 add_key:		add_key_info.key = keystr;
      816 		add_key_info.key_len = length (keystr);
      817 
      818 		call iox_$control (iocb_ptr, "add_key", addr (add_key_info), code);
      819 		if code = 0
      820 		then do;
      821 		     word_count = word_count + 1;
      822 		     return;
      823 		end;
      824 
      825 		if code ^= error_table_$key_duplication
      826 		then do;
      827 		     call com_err_ (code, whoami, "Cannot add ""^a"".", keystr);
      828 		     return;
      829 		end;
      830 
      831 /* same word already in dictionary */
      832 /* see if it has the same descriptor */
      833 
      834 		get_key_info.key = add_key_info.key;
      835 		get_key_info.key_len = 256;
      836 		call iox_$control (iocb_ptr, "get_key", addr (get_key_info), code);
      837 		if code ^= 0
      838 		then do;
      839 		     call com_err_ (code, whoami, "Cannot determine if word already in dictionary.  Word ignored.  ^a", keystr);
      840 		     return;
      841 		end;
      842 
      843 		if string (get_key_info.descrip) = string (add_key_info.descrip) /* same descrip)tor */
      844 		then return;			/* nothing to do */
      845 
      846 		if force_opt | get_key_info.descrip.pad ^= ""b
      847 		then do;				/* give word a new descriptor */
      848 		     reassign_key_info.new_descrip = add_key_info.descrip;
      849 		     call iox_$control (iocb_ptr, "reassign_key", addr (reassign_key_info), code);
      850 		     if code ^= 0
      851 		     then call com_err_ (code, whoami, "Cannot reassign ""^a"".", keystr);
      852 		end;
      853 		else call com_err_ (0, whoami, "Word already in dictionary with different ^[hyphenation^;notrim^].  Word ignored.  ^a",
      854 		     (string (get_key_info.descrip.hpoints) ^= string (add_key_info.descrip.hpoints)), keystr);
      855 
      856 	     end add;
      857 
      858 /* A procedure to delete a word from the dictionary. */
      859 
      860 delete:	     proc;
      861 
      862 		if length (cur_word) > 256
      863 		then go to word_not_found;
      864 
      865 		sh_info.key_head = cur_word;
      866 		call iox_$control (iocb_ptr, "seek_head", addr (sh_info), code);
      867 		if code = 0
      868 		then call iox_$control (iocb_ptr, "delete_key", addr (delete_key_info), code);
      869 
      870 		if code ^= 0
      871 		then do;
      872 		     if code = error_table_$no_record | code = error_table_$no_key
      873 		     then
      874 word_not_found:		if brief_opt
      875 			then;
      876 			else call com_err_ (0, whoami, "Word not in dictionary.  ^a", cur_word);
      877 		     else call com_err_ (code, whoami, "Cannot delete ""^a"".", cur_word);
      878 		     return;
      879 		end;
      880 
      881 		word_count = word_count + 1;
      882 
      883 	     end delete;
      884 
      885 /* A procedure to list a word from the dictionary. */
      886 
      887 list:	     proc;
      888 
      889 		if length (cur_word) > 256
      890 		then go to word_not_found;
      891 
      892 		get_key_info.key = cur_word;
      893 		get_key_info.key_len = 256;
      894 		call iox_$control (iocb_ptr, "get_key", addr (get_key_info), code);
      895 		if code ^= 0
      896 		then do;
      897 		     if code = error_table_$no_record | code = error_table_$no_key
      898 		     then
      899 word_not_found:		if brief_opt
      900 			then;
      901 			else call com_err_ (0, whoami, "Word not in dictionary.  ^a", cur_word);
      902 		     else call com_err_ (code, whoami, "Cannot list ""^a"".", cur_word);
      903 		     return;
      904 		end;
      905 
      906 		call output_word (get_key_info.key, get_key_info.key_len, string (get_key_info.descrip));
      907 
      908 
      909 	     end list;
      910 
      911 /* A procedure to find a word in the sequence of dictionaries
      912*   defined by the "dict" search list.
      913**/
      914 
      915 find:	     proc;
      916 
      917 dcl  word_found char (256);
      918 dcl  desc_found bit (36) aligned;
      919 dcl  baddy fixed bin;
      920 	     
      921 
      922 		bad_dict.n = 0;
      923 
      924 		call find_dict_word_ ((cur_word), string (fdw_control), word_found, desc_found, dict_path, bad_dict_ptr, code);
      925 
      926 		if ^complained_once			/* for each command invocation */
      927 		     then do baddy = 1 to bad_dict.n;	/* report each bad dictionary */
      928 		     call com_err_ (bad_dict.entry.ecode (baddy), whoami, "^a", bad_dict.entry.path (baddy));
      929 		end;
      930 
      931 		if code ^= 0 
      932 		     then if code = error_table_$recoverable_error 
      933 		     then do;			/* print recoverable error message */
      934 			if ^complained_once		/* only once per command invocation */
      935 			     then do;		/* and don't abort */
      936 			     call com_err_ (code, whoami, "^/");
      937 			     complained_once = "1"b;
      938 			end;
      939 		     end;
      940 		else do;
      941 		     if code = error_table_$id_not_found /* this guy gets printed each time */
      942 		     then if brief_opt		/* unless it's suppressed */
      943 			then;
      944 		          else call com_err_ (0, whoami, "Word not found.  ^a", cur_word);
      945 		     else call com_err_ (code, whoami, "Cannot find ""^a"". ^[(Referencing dictionary ^a)^]",
      946 			cur_word, ((dict_path ^= "") & (code ^= error_table_$fatal_error)), dict_path);
      947 		     complained_once = "1"b;
      948 		     return;
      949 		end;
      950 
      951 		call output_word (word_found, length (rtrim (word_found)), desc_found);
      952 
      953 		
      954 	     end find;
      955 
      956 
      957 	end process_word;
      958 
      959 /* A procedure to list all words in the dictionary in order. */
      960 
      961 list_all:	proc;
      962 
      963 dcl  i fixed bin;
      964 
      965 	     i, code = 0;
      966 	     do while (code = 0);
      967 		call iox_$control (iocb_ptr, "get_key", addr (get_key_info), code);
      968 		if code = 0
      969 		then do;
      970 		     call output_word (get_key_info.key, get_key_info.key_len, string (get_key_info.descrip));
      971 		     i = i +1;
      972 		     call iox_$position (iocb_ptr, 0, 1, code);
      973 		end;
      974 	     end;
      975 
      976 	     if code ^= error_table_$end_of_info
      977 	     then call com_err_ (code, whoami, "Cannot list remaining words.");
      978 	     else if i = 0
      979 	     then if ^brief_opt
      980 		then call com_err_ (0, whoami, "No words in dictionary.");
      981 
      982 	end list_all;
      983 
      984 /* This procedure outputs a word.  If the raw option was not
      985*   specified, the word is edited to display its hyphenation
      986*   and notrim attributes.  If an output segment was specified,
      987*   the word is copied to that segment with a newline appended.
      988*   Otherwise, the word is printed on the user's terminal.
      989**/
      990 
      991 output_word: proc (word, word_len, word_desc);
      992 
      993 dcl  word char (256);
      994 dcl  word_len fixed bin;
      995 dcl  word_desc bit (36) aligned;
      996 
      997 dcl 1 desc aligned like descriptor_template based (addr (word_desc));
      998 
      999 dcl (i, i2, j) fixed bin;
     1000 dcl  out_buf char (300) varying;
     1001 
     1002 	     if raw_opt
     1003 	     then out_buf = substr (word, 1, word_len);
     1004 
     1005 	     else do;
     1006 		j = 1;
     1007 		if desc.notrim
     1008 		then out_buf = "^";
     1009 		else if substr (word, 1, 1) = "^"
     1010 		then do;
     1011 		     out_buf = "^=";
     1012 		     j = 2;
     1013 		end;
     1014 		else out_buf = "";
     1015 
     1016 		do while (j <= word_len);
     1017 
     1018 		     i = index (substr (word, j, word_len+1-j), "-") -1; /* find next hyphen */
     1019 		     if i = -1
     1020 		     then i = word_len + 1 - j;
     1021 
     1022 		     if j <= 32
     1023 		     then do;
     1024 			i2 = index (substr (string (desc.hpoints), j, 33-j), "1"b); /* find next hyphenation point */
     1025 			if i2 = 0
     1026 			then i2 = 257;
     1027 		     end;
     1028 		     else i2 = 257;
     1029 
     1030 		     i = min (i, i2);		/* get index of closest hyphen or hyphenation point */
     1031 		     if i > 0			/* we've skipped a few chars */
     1032 		     then do;			/* add them to output */
     1033 			out_buf = out_buf || substr (word, j, i);
     1034 			j = j + i;
     1035 			if i2 <= i		/* there is a hyphenation point */
     1036 			then out_buf = out_buf || "-"; /* show it */
     1037 		     end;
     1038 
     1039 		     if j <= word_len		/* haven't reached the end yet */
     1040 		     then if substr (word, j, 1) = "-"	/* there's a real hyphen */
     1041 			then do;			/* put it in the output */
     1042 			     if i2 > i		/* there is no hyphenation point */
     1043 			     then out_buf = out_buf || "-=";
     1044 			     else out_buf = out_buf || "-";
     1045 			     j = j + 1;
     1046 			end;
     1047 		end;
     1048 	     end;
     1049 
     1050 	     call output (out_buf);
     1051 
     1052 	     if dictionary_opt
     1053 	     then do;
     1054 		call output (copy (" ", max (1, 19 - length (out_buf))));
     1055 		call output (rtrim (dict_path));
     1056 	     end;
     1057 
     1058 	     call output ((NL));
     1059 	     return;
     1060 
     1061 output:
     1062      proc (str) recursive;
     1063 
     1064 dcl  str char (*) varying parameter;
     1065 dcl  (len, chars_that_fit) fixed bin (21);
     1066 
     1067 	len = length (str);
     1068 
     1069 	if of_len + len + 1 > max_seg_size
     1070 	then if output_file_opt
     1071 	     then do;
     1072 		chars_that_fit = max_seg_size - of_len;
     1073 		substr (of, of_len+1, chars_that_fit) = str;
     1074 
     1075 		if component = 0
     1076 		then do;
     1077 
     1078 		     call terminate_file_ (of_ptr, max_seg_size * 9, TERM_FILE_BC | TERM_FILE_TERM, code);
     1079 		     if code ^= 0 then goto bad_of;
     1080 
     1081 		     call make_msf_ (of_dname, of_ename, ring_brackets, code);
     1082 		     if code ^= 0 then goto bad_of;
     1083 
     1084 		     call msf_manager_$open (of_dname, of_ename, fcb_ptr, code);
     1085 		     if code ^= 0 then goto bad_of;
     1086 
     1087 		     call msf_manager_$get_ptr (fcb_ptr, 1, "1"b, of_ptr, bc, code);
     1088 		     if code ^= 0 then goto bad_of;
     1089 
     1090 		     component = 1;
     1091 		     end;
     1092 		else do;
     1093 		     call terminate_file_ (of_ptr, max_seg_size * 9, TERM_FILE_BC | TERM_FILE_TERM, code);
     1094 		     if code ^= 0 then goto bad_of;
     1095 
     1096 		     call msf_manager_$get_ptr (fcb_ptr, component+1, "1"b, of_ptr, bc, code);
     1097 		     if code ^= 0 then goto bad_of;
     1098 
     1099 		     component = component + 1;
     1100 		     end;
     1101 
     1102 		of_len = 0;			/* empty output file */
     1103 
     1104 		if len > chars_that_fit
     1105 		then call output (substr (str, chars_that_fit + 1));
     1106 		return;
     1107 		end;
     1108 	     else do;
     1109 		call iox_$put_chars (iox_$user_output, of_ptr, of_len, code);
     1110 		if code ^= 0 then do;
     1111 		     call com_err_ (code, whoami, "attempting to write on user_output switch.");
     1112 		     goto clean_up;
     1113 		     end;
     1114 
     1115 		of_len = 0;
     1116 		end;
     1117 
     1118 	substr (of, of_len+1, len) = str;
     1119 	of_len = of_len + len;
     1120 
     1121 	return;
     1122 	end output;
     1123 
     1124 	end output_word;
     1125 
     1126 
     1127 /* include files */
     1128 
  1     1      dcl	   1 uns_info	      based (addr (info)),	/* info structure for unstructured files */
  1     2 	     2 info_version	      fixed,		/* (Input) must =1--only one version
  1     3*						   currently supported */
  1     4 	     2 type	      fixed,		/* =1 */
  1     5 	     2 end_pos	      fixed (34),		/* length (bytes) not including header */
  1     6 	     2 flags	      aligned,
  1     7 	       3 pad1	      bit (2) unal,		/* used for lock_status in other files */
  1     8 	       3 header_present   bit (1) unal,		/* on if file code is set */
  1     9 	       3 pad2	      bit (33) unal,
  1    10 	     2 header_id	      fixed (35);		/* meaning is user defined */
  1    11      dcl	   1 seq_info	      based (addr (info)),	/* info structure for sequential files */
  1    12 	     2 info_version	      fixed,
  1    13 	     2 type	      fixed,		/* =2 */
  1    14 	     2 end_pos	      fixed (34),		/* record count */
  1    15 	     2 flags	      aligned,
  1    16 	       3 lock_status      bit (2) unal,		/* 0,1,2, or 3 to indicate not locked,
  1    17*						   locked by (other,this,dead) process */
  1    18 	       3 pad	      bit (34) unal,
  1    19 	     2 version	      fixed,		/* end_pos valid only in latest version */
  1    20 	     2 action	      fixed;		/* indicates if adjustment or rollback is needed */
  1    21      dcl	   1 blk_info	      based (addr (info)),	/* info structure for blocked files */
  1    22 	     2 info_version	      fixed,
  1    23 	     2 type	      fixed,		/* =3 */
  1    24 	     2 end_pos	      fixed (34),		/* record count */
  1    25 	     2 flags	      aligned,
  1    26 	       3 lock_status      bit (2) unal,		/* same as seq_info.= */
  1    27 	       3 pad	      bit (34) unal,
  1    28 	     2 version	      fixed,		/* only one currently supported */
  1    29 	     2 action	      fixed,		/* non-zero if truncation in progress, else =0 */
  1    30 	     2 max_rec_len	      fixed (21),		/* bytes--determines characteristiWc block size */
  1    31 	     2 pad	      fixed,		/* not used at this time */
  1    32 	     2 time_last_modified fixed (71);		/* time stamp for synchronization */
  1    33      dcl	   1 indx_info	      based (addr (info)),	/* info structure for indexed files */
  1    34 	     2 info_version	      fixed,
  1    35 	     2 type	      fixed,		/* =4 */
  1    36 	     2 records	      fixed (34),		/* record count */
  1    37 	     2 flags	      aligned,
  1    38 	       3 lock_status      bit (2) unal,		/* same as seq_info.= */
  1    39 	       3 pad	      bit (34) unal,
  1    40 	     2 version_info	      aligned,
  1    41 	       3 file_version     fixed (17) unal,	/* headers differ */
  1    42 	       3 program_version  fixed (17) unal,	/* may indicate bugs */
  1    43 	     2 action	      fixed,		/* non-zero code indicates update in progress */
  1    44 	     2 non_null_recs      fixed (34),		/* count of allocated recs */
  1    45 	     2 record_bytes	      fixed (34),		/* total record length */
  1    46 	     2 free_blocks	      fixed,		/* available record blocks */
  1    47 	     2 index_height	      fixed,		/* height of index tree (0 if empty) */
  1    48 	     2 nodes	      fixed,		/* nodes being used in the index */
  1    49 	     2 key_bytes	      fixed (34),		/* total length of keys */
  1    50 	     2 change_count	      fixed (35),		/* bumped on each file modification */
  1    51 	     2 num_keys	      fixed (34),		/* number of index entries */
  1    52 	     2 dup_keys	      fixed (34),		/* 0 if all keys are distinct, else 1 for each dup */
  1    53 	     2 dup_key_bytes      fixed (34),		/* total bytes of duplicate keys */
  1    54 	     2 word	      (1) fixed;		/* reserved for future use */
  1    55      dcl	   1 vbl_info	      based (addr (info)),	/* info structure for variable files */
  1    56 	     2 info_version	      fixed,
  1    57 	     2 type	      fixed,		/* =5 */
  1    58 	     2 end_pos	      fixed (34),		/* logical end of file--not necessarily allocation count */
  1    59 	     2 flags	      aligned,
  1    60 	       3 lock_status      bit (2) unal,		/* same as seq_info.= */
  1    61 	       3 pad	      bit (34) unal,
  1    62 	     2 version	      fixed,		/* only one currently supported */
  1    63 	     2 action	      fixed,		/* same as in indexed files */
  1    64 	     2 first_nz	      fixed (34),		/* position (numeric key) for first allocated record */
  1    65 	     2 last_nz	      fixed (34),		/* last allocated record position */
  1    66 	     2 change_count	      fixed (35);		/* used for synchronization */
  1    67      dcl	   vfs_version_1	      static internal fixed init (1);
  1    68 						/* should be used in
  1    69*						   assignments to info_version */
     1129 
  2     1 /* ak_info -- include file for info structures used by the following vfile_
  2     2*   control orders: "add_key", "delete_key", "get_key", and "reassign_key".
  2     3*   Created by M. Asherman 3/23/76
  2     4*   Modified 5/13/77 to add separate gk_info structure */
  2     5 
  2     6      dcl	   1 ak_info	      based (ak_info_ptr),
  2     7 	     2 header	      like ak_header,
  2     8 	     2 key	      char (ak_key_len refer (ak_info.header.key_len));
  2     9 
  2    10      dcl	   1 ak_header	      based (ak_info_ptr),
  2    11 	     2 flags	      aligned,
  2    12 	       3 input_key	      bit (1) unal,		/* set if key is input arg */
  2    13 	       3 input_desc	      bit (1) unal,		/* set if descriptor is an input arg */
  2    14 	       3 mbz	      bit (34) unal,	/* not used for the present */
  2    15 	     2 descrip	      fixed (35),		/* record designator */
  2    16 	     2 key_len	      fixed;
  2    17 
  2    18      dcl	   ak_info_ptr	      ptr;
  2    19      dcl	   ak_key_len	      fixed;
  2    20 
  2    21 
  2    22      dcl	   1 rk_info	      based (rk_info_ptr),
  2    23 	     2 header	      like rk_header,
  2    24 	     2 key	      char (rk_key_len refer (rk_info.header.key_len));
  2    25 
  2    26      dcl	   1 rk_header	      based (rk_info_ptr),
  2    27 	     2 flags	      aligned,
  2    28 	       3 input_key	      bit (1) unal,		/* same as above */
  2    29 	       3 input_old_desc   bit (1) unal,		/* set if specified entry has initial descrip
  2    30*						   given by old_descrip */
  2    31 	       3 input_new_desc   bit (1) unal,		/* set if new val for descrip is input in this struc */
  2    32 	       3 mbz	      bit (33) unal,
  2    33 	     2 old_descrip	      fixed (35),		/* used if first flag is set */
  2    34 	     2 new_descrip	      fixed (35),		/* used only if second flag is set */
  2    35 	     2 key_len	      fixed;
  2    36 
  2    37      dcl	   rk_info_ptr	      ptr;
  2    38      dcl	   rk_key_len	      fixed;
  2    39 
  2    40 
  2    41      dcl	   1 gk_info	      based (gk_info_ptr),	/* structure for get_key order */
  2    42 	     2 header	      like gk_header,
  2    43 	     2 key	      char (gk_key_len refer (gk_info.header.key_len));
  2    44 						/* may be Input as well as Output */
  2    45 
  2    46      dcl	   1 gk_header	      based (gk_info_ptr),
  2    47 	     2 flags	      aligned,
  2    48 	       3 input_key	      bit (1) unal,		/* if set, use key in this structure */
  2    49 	       3 input_desc	      bit (1) unal,		/* if set, descriptor given in this structure */
  2    50 	       3 desc_code	      fixed (2) unal,	/* 0=any, 1=current -- applies when input_desc="0"b */
  2    51 	       3 position_specification
  2    52 			      unal,
  2    53 	         4 current	      bit (1) unal,		/* otherwise next */
  2    54 	         4 rel_type	      fixed (2) unal,	/* as in seek_head, if input_key = "1"b */
  2    55 	         4 head_size      fixed bin (9) unsigned unaligned,
  2    56 						/* size of head for initial seek */
  2    57 	       3 reset_pos	      bit (1) unal,		/* if set, final position unchanged by this operation */
  2    58 	       3 pad	      bit (8) unal,
  2    59 	       3 version	      fixed (8) unal,
  2    60 	     2 descrip	      fixed (35),		/* Output, except when input_desc="1"b */
  2    61 	     2 key_len	      fixed;		/* Input when input_key="1"b, also Output in all cases */
  2    62 
  2    63      dcl	   gk_info_ptr	      ptr;
  2    64      dcl	   gk_key_len	      fixed;
  2    65 
  2    66      dcl	   gk_info_version_0      internal static fixed options (constant) init (0);
  2    67 
  2    68 /* end ak_info.incl.pl1 */
     1130 
  3     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  3     2 /* format: style2,^inddcls,idind32 */
  3     3 
  3     4 declare 1 terminate_file_switches	based,
  3     5 	2 truncate		bit (1) unaligned,
  3     6 	2 set_bc			bit (1) unaligned,
  3     7 	2 terminate		bit (1) unaligned,
  3     8 	2 force_write		bit (1) unaligned,
  3     9 	2 delete			bit (1) unaligned;
  3    10 
  3    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  3    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  3    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  3    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  3    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  3    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  3    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  3    18 
  3    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
     1131 
  4     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  4     2*
  4     3*   Values for the "access mode" argument so often used in hardcore
  4     4*   James R. Davis 26 Jan 81  MCR 4844
  4     5*   Added constants for SM access 4/28/82 Jay Pattin
  4     6*   Added text strings 03/19/85 Chris Jones
  4     7**/
  4     8 
  4     9 
  4    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  4    11 dcl	(
  4    12 	N_ACCESS		   init ("000"b),
  4    13 	R_ACCESS		   init ("100"b),
  4    14 	E_ACCESS		   init ("010"b),
  4    15 	W_ACCESS		   init ("001"b),
  4    16 	RE_ACCESS		   init ("110"b),
  4    17 	REW_ACCESS	   init ("111"b),
  4    18 	RW_ACCESS		   init ("101"b),
  4    19 	S_ACCESS		   init ("100"b),
  4    20 	M_ACCESS		   init ("010"b),
  4    21 	A_ACCESS		   init ("001"b),
  4    22 	SA_ACCESS		   init ("101"b),
  4    23 	SM_ACCESS		   init ("110"b),
  4    24 	SMA_ACCESS	   init ("111"b)
  4    25 	)		   bit (3) internal static options (constant);
  4    26 
  4    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  4    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  4    29 
  4    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  4    31 			   static options (constant);
  4    32 
  4    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  4    34 			   static options (constant);
  4    35 
  4    36 dcl	(
  4    37 	N_ACCESS_BIN	   init (00000b),
  4    38 	R_ACCESS_BIN	   init (01000b),
  4    39 	E_ACCESS_BIN	   init (00100b),
  4    40 	W_ACCESS_BIN	   init (00010b),
  4    41 	RW_ACCESS_BIN	   init (01010b),
  4    42 	RE_ACCESS_BIN	   init (01100b),
  4    43 	REW_ACCESS_BIN	   init (01110b),
  4    44 	S_ACCESS_BIN	   init (01000b),
  4    45 	M_ACCESS_BIN	   init (00010b),
  4    46 	A_ACCESS_BIN	   init (00001b),
  4    47 	SA_ACCESS_BIN	   init (01001b),
  4    48 	SM_ACCESS_BIN	   init (01010b),
  4    49 	SMA_ACCESS_BIN	   init (01011b)
  4    50 	)		   fixed bin (5) internal static options (constant);
  4    51 
  4    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
     1132 
     1133 
     1134      end add_dict_words;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1057.6  add_dict_words.pl1                >udd>sm>ds>w>ml>add_dict_words.pl1
1129         1    07/19/79  1647.0  vfs_info.incl.pl1                 >ldd>incl>vfs_info.incl.pl1
1130         2    07/19/79  1647.0  ak_info.incl.pl1                  >ldd>incl>ak_info.incl.pl1
1131         3    04/06/83  1339.4  terminate_file.incl.pl1           >ldd>incl>terminate_file.incl.pl1
1132         4    04/11/85  1552.6  access_mode_values.incl.pl1       >ldd>incl>access_mode_values.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NL                                     constant        char(1)                  initial dcl 162 ref 644 653 1058
NL_index                        001460 automatic       fixed bin(21,0)          dcl 574 set ref 644* 645 645
R_ACCESS                        000104 constant        bit(3)                   initial packed unaligned dcl 4-11 set ref 621*
TERM_FILE_BC                           constant        bit(2)                   initial packed unaligned dcl 3-12 ref 1078 1093
TERM_FILE_TERM                  000001 constant        bit(3)                   initial packed unaligned dcl 3-14 set ref 551* 556*
                                                                                  674* 1078 1093
TERM_FILE_TRUNC_BC_TERM         000000 constant        bit(3)                   initial packed unaligned dcl 3-15 set ref 515*
absolute_pathname_$add_suffix   000114 constant        entry                    external dcl 190 ref 266
add_cmd                         000110 automatic       bit(1)                   initial dcl 55 set ref 55* 204* 283 301 303 326 451
                                                                                  529* 703
add_key_info                    000677 automatic       structure                level 1 unaligned dcl 81 set ref 818 818
addr                                                   builtin function         dcl 168 ref 531 532 532 532 532 535 615 658 818 818
                                                                                  836 836 849 849 866 866 867 867 894 894 967 967
                                                                                  1007 1024
ak_header                              based           structure                level 1 unaligned dcl 2-10
al                              000166 automatic       fixed bin(17,0)          dcl 61 set ref 262* 263 266 266 269 269 281 281 283
                                                                                  283 285 285 290* 291 294 294 301 303 303 305 305
                                                                                  307 307 309 317 317 487* 488 490 490 493* 496 496
                                                                                  498 501* 502 502 505 505 582 582 585 585
ap                              000164 automatic       pointer                  dcl 60 set ref 262* 263 266 269 281 281 283 283 285
                                                                                  285 290* 291 294 294 301 303 303 305 305 307 307
                                                                                  309 317 487* 488 490 490 493* 496 496 498 501* 502
                                                                                  505 582 585
arg                                    based           char                     packed unaligned dcl 116 set ref 263 266* 269* 281
                                                                                  281 283 283 285 285 291 294 294 301 303 303 305
                                                                                  305 307 307 309 317* 488 490 490 496 496 498 502*
                                                                                  505* 582* 585*
arg_syntax                      000122 automatic       char(120)                packed unaligned dcl 57 set ref 206* 213* 220* 227*
                                                                                  234* 244*
argno                           000162 automatic       fixed bin(17,0)          dcl 59 set ref 261* 262* 272 287* 287 288 290* 296*
                                                                                  296 297 311* 311 312* 482* 483 483* 483 485 487*
                                                                                  492* 492 493* 496* 496 500* 500 501*
atd                             000333 automatic       varying char(256)        dcl 66 set ref 351* 352* 352 358 384 385* 605* 606*
                                                                                  606 607* 607 608* 608 610
atd_len                         000434 automatic       fixed bin(17,0)          dcl 67 set ref 384* 385
bad_dict                               based           structure                level 1 dcl 126
bad_dict_ptr                    000674 automatic       pointer                  dcl 78 set ref 329* 334* 558 558* 922 924* 926 928
                                                                                  928
baddy                           002031 automatic       fixed bin(17,0)          dcl 919 set ref 926* 928 928*
bc                              000103 automatic       fixed bin(24,0)          dcl 50 set ref 407* 408 589* 595 621* 625 1087*
                                                                                  1096*
brief_opt                       000170 automatic       bit(1)                   dcl 63 set ref 253* 281* 872 897 941 978
chars_that_fit                  000101 automatic       fixed bin(21,0)          dcl 1065 set ref 1072* 1073 1104 1104 1104
cleanup                         001440 stack reference condition                dcl 134 ref 332
code                            000167 automatic       fixed bin(35,0)          dcl 62 set ref 243* 244* 262* 266* 267 269* 276*
                                                                                  290* 334* 335 337* 358* 359 361* 371* 372 372 378*
                                                                                  390* 400* 401 403* 407* 408 412* 416* 417 420 423*
                                                                                  426* 431* 432 434* 487* 493* 501* 515* 516 516*
                                                                                  520* 521 521* 532* 533 533* 582* 583 585* 589* 590
                                                                                  591* 598* 610* 611 612* 613 618* 621* 628* 636 636
                                                                                  640 640 663* 674* 818* 819 825 827* 836* 837 839*
                                                                                  849* 850 850* 866* 867 867* 870 872 872 877* 894*
                                                                                  895 897 897 902* 924* 931 931 936* 941 945* 945
                                                                                  965* 966 967* 968 972* 976 976* 1078* 1079 1081*
                                                                                  1082 1084* 1085 1087* 1088 1093* 1094 1096* 1097
                                                                                  1109* 1110 1111*
com_err_                        000054 constant        entry                    external dcl 174 ref 244 269 317 337 361 378 390 403
                                                                                  426 434 516 521 533 585 591 731 780 785 790 809
                                                                                  827 839 850 853 876 877 901 902 928 936 944 945
                                                                                  976 978 1111
complained_once                 000676 automatic       bit(1)                   packed unaligned dcl 79 set ref 341* 926 934 937*
                                                                                  947*
component                       000105 automatic       fixed bin(17,0)          dcl 52 set ref 440* 1075 1090* 1096 1099* 1099
copy                                                   builtin function         dcl 168 ref 1054 1054
count_cmd                       000113 automatic       bit(1)                   initial dcl 55 set ref 55* 225* 240 274 294 309 365
count_opt                       000175 automatic       bit(1)                   dcl 63 set ref 253* 303* 527
cu_$arg_count                   000052 constant        entry                    external dcl 173 ref 239
cu_$arg_ptr                     000056 constant        entry                    external dcl 175 ref 262 290 487 493 501
cur_word                               parameter       char                     packed unaligned dcl 700 set ref 698 729 731* 734
                                                                                  740 742 742 757 758 759 766 770 772 772 780* 785*
                                                                                  790* 809* 862 865 876* 877* 889 892 901* 902* 924
                                                                                  944* 945*
delete_cmd                      000111 automatic       bit(1)                   initial dcl 55 set ref 55* 211* 281 303 326 376 445
                                                                                  705
delete_key_info                 001002 automatic       structure                level 1 unaligned dcl 87 set ref 867 867
desc                                   based           structure                level 1 dcl 997
desc_code                 0(02) 001105 automatic       fixed bin(2,0)           level 3 packed packed unaligned dcl 89 set ref 468*
desc_found                      002030 automatic       bit(36)                  dcl 918 set ref 924* 951*
descrip                   1     001105 automatic       structure                level 2 in structure "get_key_info" dcl 89
                                                                                  in procedure "adw" set ref 843 906 906 970 970
descrip                   1     000677 automatic       structure                level 2 in structure "add_key_info" dcl 81
                                                                                  in procedure "adw" set ref 725* 843 848
descriptor_template                    based           structure                level 1 dcl 121
dict_path                       000617 automatic       char(168)                packed unaligned dcl 76 set ref 924* 945 945* 1055
                                                                                  1055
dictionary_opt                  000176 automatic       bit(1)                   dcl 63 set ref 253* 305* 1052
divide                                                 builtin function         dcl 168 ref 625
ecode                     1            based           fixed bin(35,0)          array level 3 dcl 126 set ref 928*
entry                     1            based           structure                array level 2 dcl 126
error_table_$badopt             000022 external static fixed bin(35,0)          dcl 148 set ref 317*
error_table_$dirseg             000010 external static fixed bin(35,0)          dcl 143 ref 412 598
error_table_$end_of_info        000032 external static fixed bin(35,0)          dcl 152 ref 636 976
error_table_$fatal_error        000042 external static fixed bin(35,0)          dcl 156 ref 945
error_table_$id_not_found       000040 external static fixed bin(35,0)          dcl 155 ref 941
error_table_$key_duplication    000024 external static fixed bin(35,0)          dcl 149 ref 825
error_table_$long_record        000012 external static fixed bin(35,0)          dcl 144 ref 640
error_table_$no_key             000030 external static fixed bin(35,0)          dcl 151 ref 872 897
error_table_$no_record          000026 external static fixed bin(35,0)          dcl 150 ref 872 897
error_table_$noarg              000020 external static fixed bin(35,0)          dcl 147 ref 243
error_table_$noentry            000034 external static fixed bin(35,0)          dcl 153 ref 372 420
error_table_$recoverable_error  000044 external static fixed bin(35,0)          dcl 157 ref 931
error_table_$short_record       000014 external static fixed bin(35,0)          dcl 145 ref 640
error_table_$wrong_no_of_args   000036 external static fixed bin(35,0)          dcl 154 ref 276
error_table_$zero_length_seg    000016 external static fixed bin(35,0)          dcl 146 ref 628
exact_match                     001437 automatic       bit(1)                   level 2 packed packed unaligned dcl 109 set ref 307*
expand_pathname_                000100 constant        entry                    external dcl 184 ref 400 582
fcb_ptr                         000612 automatic       pointer                  dcl 73 set ref 329* 561 561* 1084* 1087* 1096*
fdw_control                     001437 automatic       structure                level 1 dcl 109 set ref 257* 924 924
find_cmd                        000114 automatic       bit(1)                   initial dcl 55 set ref 55* 232* 240 254 281 285 301
                                                                                  305 307 326 344 396
find_dict_word_                 000116 constant        entry                    external dcl 191 ref 924
flags                                  based           structure                level 2 in structure "ak_header" dcl 2-10
                                                                                  in procedure "adw"
flags                                  based           structure                level 2 in structure "gk_header" dcl 2-46
                                                                                  in procedure "adw"
flags                           001002 automatic       structure                level 2 in structure "delete_key_info" dcl 87
                                                                                  in procedure "adw" set ref 449*
flags                           001105 automatic       structure                level 2 in structure "get_key_info" dcl 89
                                                                                  in procedure "adw" set ref 462*
flags                                  based           structure                level 3 in structure "ak_info" dcl 2-6 in procedure
                                                                                  "adw"
flags                           000677 automatic       structure                level 2 in structure "add_key_info" dcl 81
                                                                                  in procedure "adw" set ref 453*
flags                                  based           structure                level 3 in structure "rk_info" dcl 2-22 in procedure
                                                                                  "adw"
flags                           001210 automatic       structure                level 2 in structure "reassign_key_info" dcl 95
                                                                                  in procedure "adw" set ref 457*
flags                                  based           structure                level 3 in structure "gk_info" dcl 2-41 in procedure
                                                                                  "adw"
flags                                  based           structure                level 2 in structure "rk_header" dcl 2-26
                                                                                  in procedure "adw"
force_opt                       000171 automatic       bit(1)                   dcl 63 set ref 253* 283* 455 846
get_key_info                    001105 automatic       structure                level 1 unaligned dcl 89 set ref 836 836 894 894 967
                                                                                  967
get_temp_segment_               000120 constant        entry                    external dcl 192 ref 334 431
gk_header                              based           structure                level 1 unaligned dcl 2-46
gk_info_version_0                      constant        fixed bin(17,0)          initial dcl 2-66 ref 473
hcs_$make_seg                   000104 constant        entry                    external dcl 186 ref 423
hcs_$status_minf                000102 constant        entry                    external dcl 185 ref 407 589
head_len                  1     001314 automatic       fixed bin(17,0)          level 2 dcl 102 set ref 448*
head_size                 0(09) 001105 automatic       fixed bin(9,0)           level 4 packed packed unsigned unaligned dcl 89 set
                                                                                  ref 470*
hpoints                   1     001105 automatic       bit(1)                   array level 3 in structure "get_key_info" packed
                                                                                  packed unaligned dcl 89 in procedure "adw" set ref
                                                                                  853
hpoints                                based           bit(1)                   array level 2 in structure "desc" packed packed
                                                                                  unaligned dcl 997 in procedure "output_word" ref
                                                                                  1024
hpoints                   1     000677 automatic       bit(1)                   array level 3 in structure "add_key_info" packed
                                                                                  packed unaligned dcl 81 in procedure "adw" set ref
                                                                                  793* 806 853
i                               002052 automatic       fixed bin(17,0)          dcl 999 in procedure "output_word" set ref 1018*
                                                                                  1019 1019* 1030* 1030 1031 1033 1034 1035 1042
i                               001456 automatic       fixed bin(21,0)          dcl 574 in procedure "read_input_file" set ref 632*
                                                                                  650 653 656 658 666* 666
i                               002042 automatic       fixed bin(17,0)          dcl 963 in procedure "list_all" set ref 965* 971*
                                                                                  971 978
i                               001602 automatic       fixed bin(17,0)          dcl 719 in procedure "add" set ref 758* 759 759* 762
                                                                                  764 766 767
i2                              002053 automatic       fixed bin(17,0)          dcl 999 set ref 1024* 1025 1025* 1028* 1030 1035
                                                                                  1042
if                                     based           char                     packed unaligned dcl 118 ref 653
if_buffer                       001464 automatic       char(257)                packed unaligned dcl 577 set ref 615 616
if_dname                        000513 automatic       char(168)                packed unaligned dcl 71 set ref 582* 589* 591* 591*
                                                                                  605 621*
if_ename                        000575 automatic       char(32)                 packed unaligned dcl 72 set ref 582* 589* 591* 591*
                                                                                  607 621*
if_len                          000615 automatic       fixed bin(21,0)          dcl 74 set ref 625* 626 650 653 656
if_ptr                          000610 automatic       pointer                  dcl 73 set ref 329* 553 553* 556* 580* 610* 612*
                                                                                  618* 621* 622 653 658 663* 669 669* 674* 675*
if_vec                                 based           char(1)                  array packed unaligned dcl 119 set ref 658
index                                                  builtin function         dcl 168 ref 263 488 644 653 758 1018 1024
indx_info                              based           structure                level 1 unaligned dcl 1-33 set ref 532 532
info                            001416 automatic       structure                level 1 dcl 107 set ref 531 532 532 535
info_version                           based           fixed bin(17,0)          level 2 dcl 1-33 set ref 531*
initiate_file_                  000106 constant        entry                    external dcl 187 ref 621
input_desc                0(01) 001105 automatic       bit(1)                   level 3 in structure "get_key_info" packed packed
                                                                                  unaligned dcl 89 in procedure "adw" set ref 467*
input_desc                0(01) 000677 automatic       bit(1)                   level 3 in structure "add_key_info" packed packed
                                                                                  unaligned dcl 81 in procedure "adw" set ref 454*
input_file_opt                  000174 automatic       bit(1)                   dcl 63 set ref 253* 299* 326 462 480
input_key                       000677 automatic       bit(1)                   level 3 in structure "add_key_info" packed packed
                                                                                  unaligned dcl 81 in procedure "adw" set ref 454*
input_key                       001105 automatic       bit(1)                   level 3 in structure "get_key_info" packed packed
                                                                                  unaligned dcl 89 in procedure "adw" set ref 466*
input_new_desc            0(02) 001210 automatic       bit(1)                   level 3 packed packed unaligned dcl 95 set ref 458*
ioa_                            000076 constant        entry                    external dcl 183 ref 368 529 535
iocb_ptr                        000436 automatic       pointer                  dcl 69 set ref 329* 358* 371* 382* 532* 545 545*
                                                                                  818* 836* 849* 866* 867* 894* 967* 972*
iocbp                                  parameter       pointer                  dcl 684 set ref 681 686 687* 688* 689* 690*
iox_$attach_name                000060 constant        entry                    external dcl 176 ref 358 610
iox_$close                      000070 constant        entry                    external dcl 180 ref 687
iox_$control                    000064 constant        entry                    external dcl 178 ref 532 818 836 849 866 867 894 967
iox_$destroy_iocb               000074 constant        entry                    external dcl 182 ref 689
iox_$detach_iocb                000072 constant        entry                    external dcl 181 ref 688
iox_$get_line                   000126 constant        entry                    external dcl 195 ref 618 663
iox_$open                       000062 constant        entry                    external dcl 177 ref 371 612
iox_$position                   000066 constant        entry                    external dcl 179 ref 972
iox_$put_chars                  000124 constant        entry                    external dcl 194 ref 520 1109
iox_$user_output                000046 external static pointer                  dcl 159 set ref 520* 1109*
j                               002054 automatic       fixed bin(17,0)          dcl 999 in procedure "output_word" set ref 1006*
                                                                                  1012* 1016 1018 1018 1019 1022 1024 1024 1033
                                                                                  1034* 1034 1039 1039 1045* 1045
j                               001603 automatic       fixed bin(17,0)          dcl 719 in procedure "add" set ref 739* 752* 754*
                                                                                  757* 757 757* 758 759 766 767* 767 770 772 772
                                                                                  801* 801*
key                       3     000677 automatic       char(256)                level 2 in structure "add_key_info" packed packed
                                                                                  unaligned dcl 81 in procedure "adw" set ref 815*
                                                                                  834
key                       3     001105 automatic       char(256)                level 2 in structure "get_key_info" packed packed
                                                                                  unaligned dcl 89 in procedure "adw" set ref 834*
                                                                                  892* 906* 970*
key_head                  2     001314 automatic       char(256)                level 2 packed packed unaligned dcl 102 set ref 865*
key_len                   2     000677 automatic       fixed bin(17,0)          level 2 in structure "add_key_info" dcl 81
                                                                                  in procedure "adw" set ref 816*
key_len                   2     001105 automatic       fixed bin(17,0)          level 2 in structure "get_key_info" dcl 89
                                                                                  in procedure "adw" set ref 835* 893* 906* 970*
keyed_sequential_input                 constant        fixed bin(17,0)          initial dcl 140 ref 354
keyed_sequential_update                constant        fixed bin(17,0)          initial dcl 141 ref 356 372
keystr                          001604 automatic       varying char(256)        dcl 720 set ref 734* 738* 751* 764 766* 766 778 783
                                                                                  783 788 793 798 800* 800 806 806 815 816 827* 839*
                                                                                  850* 853*
len                             000100 automatic       fixed bin(21,0)          dcl 1065 set ref 1067* 1069 1104 1118 1119
length                                                 builtin function         dcl 168 ref 384 616 729 742 757 759 764 770 772 778
                                                                                  783 788 793 798 806 806 816 862 889 951 951 1054
                                                                                  1054 1067
list_cmd                        000112 automatic       bit(1)                   initial dcl 55 set ref 55* 218* 240 281 285 301 354
                                                                                  396 462 480 707
make_msf_                       000140 constant        entry                    external dcl 200 ref 1081
max                                                    builtin function         dcl 168 ref 1054 1054
max_seg_size                    000104 automatic       fixed bin(35,0)          dcl 51 set ref 330* 1069 1072 1078 1093
max_word_len                    001457 automatic       fixed bin(21,0)          dcl 574 set ref 616* 618* 663*
min                                                    builtin function         dcl 168 ref 1030
msf                             000107 automatic       bit(1)                   dcl 54 set ref 553 579* 601* 602* 604 636 663 669
msf_manager_$close              000134 constant        entry                    external dcl 198 ref 561
msf_manager_$get_ptr            000136 constant        entry                    external dcl 199 ref 1087 1096
msf_manager_$open               000132 constant        entry                    external dcl 197 ref 1084
n                                      based           fixed bin(17,0)          level 2 dcl 126 set ref 922* 926
nargs                           000160 automatic       fixed bin(17,0)          dcl 58 set ref 239* 240 248 261 288 297 312 482 485
new_descrip               2     001210 automatic       structure                level 2 dcl 95 set ref 848*
next_char                       001705 automatic       char(1)                  packed unaligned dcl 721 set ref 742* 744* 746 749
                                                                                  749 772* 774* 776 796 796
notrim                    1(32) 000677 automatic       bit(1)                   level 3 in structure "add_key_info" packed packed
                                                                                  unaligned dcl 81 in procedure "adw" set ref 746*
notrim                    0(32)        based           bit(1)                   level 2 in structure "desc" packed packed unaligned
                                                                                  dcl 997 in procedure "output_word" ref 1007
null                                                   builtin function         dcl 168 ref 329 358 358 424 545 548 553 558 561 580
                                                                                  610 610 622 669 675 686 690
num_keys                 15            based           fixed bin(34,0)          level 2 dcl 1-33 set ref 535*
of                                     based           char                     packed unaligned dcl 117 set ref 1073* 1118*
of_dname                        000441 automatic       char(168)                packed unaligned dcl 71 set ref 400* 407* 416* 423*
                                                                                  426* 426* 516* 516* 1081* 1084*
of_ename                        000565 automatic       char(32)                 packed unaligned dcl 72 set ref 400* 407* 416* 423*
                                                                                  426* 426* 516* 516* 1081* 1084*
of_len                          000614 automatic       fixed bin(21,0)          dcl 74 set ref 478* 512 515 520* 1069 1072 1073 1073
                                                                                  1102* 1109* 1115* 1118 1118 1119* 1119
of_pname                        000251 automatic       char(168)                packed unaligned dcl 64 set ref 291* 400* 403*
of_ptr                          000606 automatic       pointer                  dcl 73 set ref 329* 423* 424 437* 515* 520* 548 548
                                                                                  551* 1073 1078* 1087* 1093* 1096* 1109* 1118
open_mode                       000440 automatic       fixed bin(17,0)          dcl 70 set ref 354* 356* 371* 372
out_buf                         002055 automatic       varying char(300)        dcl 1000 set ref 1002* 1007* 1011* 1014* 1033* 1033
                                                                                  1035* 1035 1042* 1042 1044* 1044 1050* 1054 1054
output_file_opt                 000173 automatic       bit(1)                   dcl 63 set ref 253* 292* 398 512 1069
pad                       1(33) 001105 automatic       bit(3)                   level 3 in structure "get_key_info" packed packed
                                                                                  unaligned dcl 89 in procedure "adw" set ref 846
pad                       0(19) 001105 automatic       bit(8)                   level 3 in structure "get_key_info" packed packed
                                                                                  unaligned dcl 89 in procedure "adw" set ref 472*
path                      2            based           char(168)                array level 3 packed packed unaligned dcl 126 set
                                                                                  ref 928*
pathname_                       000130 constant        entry                    external dcl 196 ref 426 426 516 516 591 591
pn_argno                        000163 automatic       fixed bin(17,0)          dcl 59 set ref 256* 259* 263 272* 323 483
pname                           000177 automatic       char(168)                packed unaligned dcl 64 set ref 266* 351 368* 378*
                                                                                  390*
position_specification
                          0(05) 001105 automatic       structure                level 3 packed packed unaligned dcl 89
raw_opt                         000172 automatic       bit(1)                   dcl 63 set ref 253* 301* 727 1002
reassign_key_info               001210 automatic       structure                level 1 unaligned dcl 95 set ref 849 849
rel_type                  0(06) 001105 automatic       fixed bin(2,0)           level 4 in structure "get_key_info" packed packed
                                                                                  unaligned dcl 89 in procedure "adw" set ref 469*
rel_type                        001314 automatic       fixed bin(17,0)          level 2 in structure "sh_info" dcl 102 in procedure
                                                                                  "adw" set ref 447*
release_temp_segment_           000122 constant        entry                    external dcl 193 ref 548 558
reset_pos                 0(18) 001105 automatic       bit(1)                   level 3 packed packed unaligned dcl 89 set ref 471*
ring_brackets                   000100 automatic       fixed bin(6,0)           array dcl 49 set ref 416* 1081*
rk_header                              based           structure                level 1 unaligned dcl 2-26
rtrim                                                  builtin function         dcl 168 ref 351 384 605 607 951 951 1055 1055
second_attach                   000435 automatic       bit(1)                   dcl 68 set ref 349* 368 372 386*
sh_info                         001314 automatic       structure                level 1 unaligned dcl 102 set ref 866 866
str                                    parameter       varying char             dcl 1064 ref 1061 1067 1073 1104 1104 1118
stream_input                    000107 constant        fixed bin(17,0)          initial dcl 139 set ref 612*
string                                                 builtin function         dcl 168 set ref 257* 449* 453* 457* 725* 843 843 853
                                                                                  853 906 906 924 924 970 970 1024
substr                                                 builtin function         dcl 168 set ref 385* 653 740 742 758 766 772 783
                                                                                  1002 1009 1018 1024 1033 1039 1073* 1104 1104
                                                                                  1118*
switch                          000323 automatic       char(32)                 packed unaligned dcl 65 set ref 350* 358* 361*
sys_info$max_seg_size           000050 external static fixed bin(35,0)          dcl 160 ref 330
temp_ptr                        000672 automatic       pointer                  dcl 77 set ref 329* 431* 437 548 548*
terminate_file_                 000110 constant        entry                    external dcl 188 ref 515 551 556 674 1078 1093
type                            000106 automatic       fixed bin(2,0)           dcl 53 set ref 407* 408 589* 595
unique_chars_                   000112 constant        entry                    external dcl 189 ref 350 610
unmake_msf_                     000142 constant        entry                    external dcl 201 ref 416
unspec                                                 builtin function         dcl 168 set ref 462*
version                   0(27) 001105 automatic       fixed bin(8,0)           level 3 packed packed unaligned dcl 89 set ref 473*
vfs_version_1                          constant        fixed bin(17,0)          initial dcl 1-67 ref 531
whoami                          000115 automatic       char(20)                 packed unaligned dcl 56 set ref 205* 212* 219* 226*
                                                                                  233* 244* 244* 269* 317* 334* 337* 350 361* 368*
                                                                                  378* 390* 403* 426* 431* 434* 516* 521* 533* 548*
                                                                                  558* 585* 591* 610 731* 780* 785* 790* 809* 827*
                                                                                  839* 850* 853* 876* 877* 901* 902* 928* 936* 944*
                                                                                  945* 976* 978* 1111*
word                                   based           char                     packed unaligned dcl 575 in procedure
                                                                                  "read_input_file" set ref 644 661*
word                                   parameter       char(256)                packed unaligned dcl 993 in procedure "output_word"
                                                                                  ref 991 1002 1009 1018 1033 1039
word_count                      000616 automatic       fixed bin(17,0)          dcl 75 set ref 478* 529* 821* 821 881* 881
word_desc                              parameter       bit(36)                  dcl 995 set ref 991 1007 1024
word_found                      001730 automatic       char(256)                packed unaligned dcl 917 set ref 924* 951* 951 951
word_len                               parameter       fixed bin(17,0)          dcl 994 in procedure "output_word" ref 991 1002 1016
                                                                                  1018 1019 1039
word_len                        001461 automatic       fixed bin(21,0)          dcl 574 in procedure "read_input_file" set ref 618*
                                                                                  644 645* 647 653* 654 656 656* 661 661 663* 666
word_ptr                        001462 automatic       pointer                  dcl 576 set ref 615* 618* 644 658* 661 663*
words                           000161 automatic       fixed bin(17,0)          dcl 58 set ref 260* 279* 279 314* 314 326 462 480

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 4-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 4-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 4-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 4-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 4-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 4-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 4-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 4-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 4-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 4-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 4-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 4-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 4-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 4-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 4-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 4-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 4-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 4-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 4-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
TERM_FILE_DELETE                       internal static bit(5)                   initial packed unaligned dcl 3-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial packed unaligned dcl 3-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial packed unaligned dcl 3-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial packed unaligned dcl 3-13
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 4-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
ak_info                                based           structure                level 1 unaligned dcl 2-6
ak_info_ptr                            automatic       pointer                  dcl 2-18
ak_key_len                             automatic       fixed bin(17,0)          dcl 2-19
blk_info                               based           structure                level 1 unaligned dcl 1-21
gk_info                                based           structure                level 1 unaligned dcl 2-41
gk_info_ptr                            automatic       pointer                  dcl 2-63
gk_key_len                             automatic       fixed bin(17,0)          dcl 2-64
rk_info                                based           structure                level 1 unaligned dcl 2-22
rk_info_ptr                            automatic       pointer                  dcl 2-37
rk_key_len                             automatic       fixed bin(17,0)          dcl 2-38
seq_info                               based           structure                level 1 unaligned dcl 1-11
terminate_file_switches                based           structure                level 1 packed packed unaligned dcl 3-4
uns_info                               based           structure                level 1 unaligned dcl 1-1
vbl_info                               based           structure                level 1 unaligned dcl 1-55

NAMES DECLARED BY EXPLICIT CONTEXT.
EOF                             004706 constant        label                    dcl 669 ref 592 636 650
add                             005062 constant        entry                    internal dcl 717 ref 703
add_dict_words                  000762 constant        entry                    external dcl 17
add_key                         005515 constant        label                    dcl 815 ref 735
adw                             000752 constant        entry                    external dcl 17
attach                          002127 constant        label                    dcl 358 ref 387
bad_if                          004147 constant        label                    dcl 591 ref 599 611 613 622 629 640
bad_of                          002663 constant        label                    dcl 426 ref 413 417 420 1079 1082 1085 1088 1094
                                                                                  1097
big_word                        005071 constant        label                    dcl 731 ref 764 798
cdw                             001062 constant        entry                    external dcl 223
check_of                        002425 constant        label                    dcl 398 ref 344
clean_up                        003570 constant        label                    dcl 540 ref 338 379 391 404 427 435 1112
cleaner                         003576 constant        entry                    internal dcl 543 ref 332 540
close_file                      004755 constant        entry                    internal dcl 681 ref 382 545 553 669
count_dict_words                001072 constant        entry                    external dcl 223
ddw                             001002 constant        entry                    external dcl 209
delete                          006052 constant        entry                    internal dcl 860 ref 705
delete_dict_words               001012 constant        entry                    external dcl 209
fdw                             001112 constant        entry                    external dcl 230
find                            006437 constant        entry                    internal dcl 915 ref 709
find_dict_words                 001122 constant        entry                    external dcl 230
get_count                       003464 constant        label                    dcl 531 set ref 365
get_out                         003263 constant        label                    dcl 506 ref 485
gk_setup                        003044 constant        label                    dcl 466 ref 460
join                            001140 constant        label                    dcl 239 ref 207 214 221 228
ldw                             001032 constant        entry                    external dcl 216
list                            006254 constant        entry                    internal dcl 887 ref 707
list_all                        006765 constant        entry                    internal dcl 961 ref 480
list_dict_words                 001042 constant        entry                    external dcl 216
noarg                           001160 constant        label                    dcl 243 ref 248 288 297 312 323 326
output                          007460 constant        entry                    internal dcl 1061 ref 1050 1054 1055 1058 1104
output_word                     007142 constant        entry                    internal dcl 991 ref 906 951 970
process_word                    005032 constant        entry                    internal dcl 698 ref 502 505 661
read_input_file                 004014 constant        entry                    internal dcl 572 ref 494
read_next                       004657 constant        label                    dcl 663 ref 647 654
usage                           001163 constant        label                    dcl 244 ref 277
word_not_found                  006161 constant        label                    dcl 872 in procedure "delete" ref 862
word_not_found                  006326 constant        label                    dcl 897 in procedure "list" ref 889

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10760       11124   10145       10770
Length     11544   10145       144         404     612           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
adw                                1663 external procedure  is an external procedure.  
on unit on line 332                  64 on unit               
cleaner                             104 internal procedure  is called by several nonquick procedures.  
read_input_file                         internal procedure  shares stack frame of external procedure adw.  
close_file                           72 internal procedure  is called by several nonquick procedures.  
process_word                            internal procedure  shares stack frame of external procedure adw.  
add                                     internal procedure  shares stack frame of external procedure adw.  
delete                                  internal procedure  shares stack frame of external procedure adw.  
list                                    internal procedure  shares stack frame of external procedure adw.  
find                                    internal procedure  shares stack frame of external procedure adw.  
list_all                                internal procedure  shares stack frame of external procedure adw.  
output_word                             internal procedure  shares stack frame of external procedure adw.  
output                              104 internal procedure  is called during a stack extension.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
adw                      000100 ring_brackets               adw
                         000103 bc                          adw
                         000104 max_seg_size                adw
                         000105 component                   adw
                         000106 type                        adw
                         000107 msf                         adw
                         000110 add_cmd                     adw
                         000111 delete_cmd                  adw
                         000112 list_cmd                    adw
                         000113 count_cmd                   adw
                         000114 find_cmd                    adw
                         000115 whoami                      adw
                         000122 arg_syntax                  adw
                         000160 nargs                       adw
                         000161 words                       adw
                         000162 argno                       adw
                         000163 pn_argno                    adw
                         000164 ap                          adw
                         000166 al                          adw
                         000167 code                        adw
                         000170 brief_opt                   adw
                         000171 force_opt                   adw
                         000172 raw_opt                     adw
                         000173 output_file_opt             adw
                         000174 input_file_opt              adw
                         000175 count_opt                   adw
                         000176 dictionary_opt              adw
                         000177 pname                       adw
                         000251 of_pname                    adw
                         000323 switch                      adw
                         000333 atd                         adw
                         000434 atd_len                     adw
                         000435 second_attach               adw
                         000436 iocb_ptr                    adw
                         000440 open_mode                   adw
                         000441 of_dname                    adw
                         000513 if_dname                    adw
                         000565 of_ename                    adw
                         000575 if_ename                    adw
                         000606 of_ptr                      adw
                         000610 if_ptr                      adw
                         000612 fcb_ptr                     adw
                         000614 of_len                      adw
                         000615 if_len                      adw
                         000616 word_count                  adw
                         000617 dict_path                   adw
                         000672 temp_ptr                    adw
                         000674 bad_dict_ptr                adw
                         000676 complained_once             adw
                         000677 add_key_info                adw
                         001002 delete_key_info             adw
                         001105 get_key_info                adw
                         001210 reassign_key_info           adw
                         001314 sh_info                     adw
                         001416 info                        adw
                         001437 fdw_control                 adw
                         001456 i                           read_input_file
                         001457 max_word_len                read_input_file
                         001460 NL_index                    read_input_file
                         001461 word_len                    read_input_file
                         001462 word_ptr                    read_input_file
                         001464 if_buffer                   read_input_file
                         001602 i                           add
                         001603 j                           add
                         001604 keystr                      add
                         001705 next_char                   add
                         001730 word_found                  find
                         002030 desc_found                  find
                         002031 baddy                       find
                         002042 i                           list_all
                         002052 i                           output_word
                         002053 i2                          output_word
                         002054 j                           output_word
                         002055 out_buf                     output_word
output                   000100 len                         output
                         000101 chars_that_fit              output

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_char_temp     realloc_char_temp   cat_realloc_chars   call_ext_out_desc   call_ext_out
call_int_this_desc  call_int_this       call_int_other_desc call_int_other      return_mac          tra_ext_1
enable_op           shorten_stack       ext_entry           int_entry           int_entry_desc      index_bs_1_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_$add_suffix com_err_                      cu_$arg_count                 cu_$arg_ptr
expand_pathname_              find_dict_word_               get_temp_segment_             hcs_$make_seg
hcs_$status_minf              initiate_file_                ioa_                          iox_$attach_name
iox_$close                    iox_$control                  iox_$destroy_iocb             iox_$detach_iocb
iox_$get_line                 iox_$open                     iox_$position                 iox_$put_chars
make_msf_                     msf_manager_$close            msf_manager_$get_ptr          msf_manager_$open
pathname_                     release_temp_segment_         terminate_file_               unique_chars_
unmake_msf_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$dirseg           error_table_$end_of_info      error_table_$fatal_error
error_table_$id_not_found     error_table_$key_duplication  error_table_$long_record      error_table_$no_key
error_table_$no_record        error_table_$noarg            error_table_$noentry
error_table_$recoverable_error                              error_table_$short_record     error_table_$wrong_no_of_args
error_table_$zero_length_seg  iox_$user_output              sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     55 000742        17 000751       204 000770       205 000772       206 000775       207 001000       209 001001
    211 001020       212 001022       213 001025       214 001030       216 001031       218 001050       219 001052
    220 001055       221 001060       223 001061       225 001100       226 001102       227 001105       228 001110
    230 001111       232 001130       233 001132       234 001135       239 001140       240 001147       243 001160
    244 001163       245 001221       247 001222       248 001223       253 001226       254 001235       256 001237
    257 001240       258 001241       259 001242       260 001244       261 001245       262 001255       263 001272
    266 001311       267 001343       269 001345       270 001371       272 001372       273 001374       274 001375
    276 001377       277 001402       279 001403       281 001405       283 001426       285 001444       287 001460
    288 001461       290 001464       291 001501       292 001506       293 001510       294 001511       296 001525
    297 001526       299 001531       300 001533       301 001534       303 001552       305 001572       307 001607
    309 001624       311 001632       312 001633       314 001636       315 001637       317 001640       318 001672
    321 001673       323 001675       326 001700       329 001713       330 001722       332 001726       334 001750
    335 001771       337 001773       338 002010       341 002011       344 002012       349 002014       350 002015
    351 002052       352 002105       354 002120       356 002125       358 002127       359 002171       361 002174
    362 002224       365 002225       368 002227       371 002260       372 002277       376 002311       378 002313
    379 002341       382 002342       384 002350       385 002363       386 002366       387 002370       390 002371
    391 002420       396 002421       398 002425       400 002427       401 002453       403 002455       404 002504
    407 002505       408 002544       412 002553       413 002556       416 002557       417 002612       419 002614
    420 002615       423 002620       424 002657       426 002663       427 002732       429 002733       431 002734
    432 002755       434 002757       435 003003       437 003004       440 003006       445 003007       447 003011
    448 003012       449 003014       450 003015       451 003016       453 003021       454 003022       455 003026
    457 003030       458 003031       460 003033       462 003034       466 003044       467 003046       468 003050
    469 003054       470 003060       471 003062       472 003064       473 003066       478 003070       480 003072
    482 003102       483 003111       485 003114       487 003117       488 003134       490 003150       492 003160
    493 003161       494 003176       495 003177       496 003200       498 003212       500 003216       501 003217
    502 003234       504 003247       505 003250       506 003263       512 003265       515 003271       516 003320
    518 003372       520 003373       521 003410       527 003436       529 003440       531 003464       532 003466
    533 003521       535 003550       540 003570       541 003574       543 003575       545 003603       548 003617
    551 003653       553 003702       556 003721       558 003750       561 003777       564 004013       572 004014
    579 004015       580 004016       582 004020       583 004050       585 004052       586 004105       589 004106
    590 004145       591 004147       592 004217       595 004220       598 004225       599 004230       601 004231
    602 004234       604 004235       605 004237       606 004271       607 004301       608 004325       610 004337
    611 004426       612 004431       613 004450       615 004452       616 004454       618 004456       619 004475
    621 004476       622 004533       625 004537       626 004542       628 004543       629 004546       632 004547
    635 004551       636 004552       640 004561       644 004566       645 004601       647 004604       649 004607
    650 004610       653 004613       654 004631       656 004632       658 004640       661 004644       663 004657
    666 004701       667 004705       669 004706       674 004723       675 004751       678 004753       681 004754
    686 004762       687 004767       688 005000       689 005013       690 005026       693 005031       698 005032
    703 005043       705 005050       707 005054       709 005060       957 005061       717 005062       725 005063
    727 005064       729 005066       731 005071       732 005124       734 005125       735 005136       738 005137
    739 005140       740 005142       742 005150       744 005160       746 005162       749 005167       751 005174
    752 005200       753 005202       754 005203       757 005205       758 005211       759 005230       762 005236
    764 005240       766 005243       767 005255       770 005257       772 005262       774 005270       776 005272
    778 005275       780 005277       781 005331       783 005332       785 005336       786 005370       788 005371
    790 005373       791 005425       793 005426       796 005431       798 005435       800 005440       801 005447
    804 005450       806 005452       809 005461       810 005514       815 005515       816 005521       818 005523
    819 005553       821 005555       822 005556       825 005557       827 005562       828 005614       834 005615
    835 005620       836 005622       837 005651       839 005653       840 005703       843 005704       846 005710
    848 005715       849 005717       850 005751       852 006003       853 006004       856 006051       860 006052
    862 006053       865 006056       866 006063       867 006116       870 006152       872 006154       876 006164
    877 006220       878 006251       881 006252       883 006253       887 006254       889 006255       892 006260
    893 006265       894 006267       895 006317       897 006321       901 006331       902 006365       903 006421
    906 006422       909 006436       915 006437       922 006440       924 006441       926 006514       928 006527
    929 006565       931 006567       934 006574       936 006576       937 006620       939 006622       941 006623
    944 006630       945 006663       947 006735       948 006737       951 006740       954 006764       961 006765
    965 006766       966 006770       967 006772       968 007022       970 007024       971 007040       972 007041
    974 007061       976 007062       978 007111       982 007141       991 007142      1002 007144      1006 007160
   1007 007162      1009 007172      1011 007177      1012 007203      1013 007204      1014 007205      1016 007206
   1018 007212      1019 007227      1022 007235      1024 007240      1025 007251      1027 007254      1028 007255
   1030 007257      1031 007263      1033 007265      1034 007277      1035 007301      1039 007312      1042 007321
   1044 007337      1045 007346      1047 007347      1050 007350      1052 007360      1054 007362      1055 007410
   1056 007441      1058 007442      1059 007456      1061 007457      1067 007473      1069 007477      1072 007506
   1073 007514      1075 007524      1078 007526      1079 007560      1081 007566      1082 007614      1084 007622
   1085 007650      1087 007656      1088 007704      1090 007712      1091 007715      1093 007716      1094 007750
   1096 007756      1097 010005      1099 010013      1102 010015      1104 010016      1106 010046      1109 010050
   1110 010064      1111 010067      1112 010113      1115 010116      1118 010117      1119 010132      1121 010133


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
