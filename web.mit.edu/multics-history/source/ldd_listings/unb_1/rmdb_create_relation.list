	COMPILATION LISTING OF SEGMENT rmdb_create_relation
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/09/86  1234.8 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /****^  HISTORY COMMENTS:
        8*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
        9*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       10*     This entry is being made to cover the change made on 85-05-06 by Thanh
       11*     Nguyen. (see mrds #136)
       12*  2) change(85-12-18,Spitzer), approve(85-12-18,MCR7311),
       13*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
       14*     Add code to use the database crossreference file. Update the
       15*     unreferenced_attribute list in db_model.
       16*  3) change(86-11-18,Blair), approve(86-11-18,PBF7311), audit(86-12-05,Dupuis),
       17*     install(86-12-09,MR12.0-1237):
       18*     Change to use mrds_data_$relation_blocking_factor when creating new
       19*     relations.
       20*                                                   END HISTORY COMMENTS */
       21 
       22 rmdb_create_relation: proc (I_rmdb_ctl_ptr, I_rmdb_create_rel_info_ptr, I_called_from_request_level, O_err_msg, O_err_code);
       23 
       24 /*                          BEGIN_DESCRIPTION
       25*
       26*   The purpose of  this procedure is to provide the internal interface for the
       27*   restructuring  create_relation.   It is expected that the validation of the
       28*   user as a DBA and the quiescing of the database has already been done prior
       29*   to calling this procedure.
       30*
       31*   If successful it  will create the relation data file, create the file_model
       32*   segment and link the new relation into the data_model.
       33*
       34*   The new  relation  name  and attribute  info is  provided  as  input in the
       35*   rmdb_create_rel_info structure.  The  relation  name can  not  exist in the
       36*   database.   Only attributes  that already  exist in the  data_model  can be
       37*   used in the relation definition.
       38*
       39*   Temporary  space is created and  cleaned  up in the  directory specified by
       40*   rmdb_create_rel_info.temp_directory_path.  This space is used to create the
       41*   keyed sequential file for attribute name that  exists in the db_model.
       42*
       43*   If an error occurs during the creation of the new relation all segments and
       44*   files created prior to the error will be deleted.
       45*
       46*                               END_DESCRIPTION
       47*
       48*   HISTORY:
       49*   82-03-23   Originally written by R. Lackey
       50*
       51*   82-06-25  Roger Lackey : added %include access_mode_values
       52*   and changed make_seg call to use RW_ACCESS_BIN
       53*
       54*   Also converted undo request to use -brief instead of -force
       55*
       56*   82-07-01  Roger Lackey : Modified the calls to mu_db_inconsistent to use
       57*   mdbm_util_$inconsistent_* for binding.
       58*
       59*   82-09-22 D. Woodka : Modified for DMS conversion to call relation_manager
       60*   create_relation, create_index, and close.
       61*
       62*   83-01-11 R. Harvey : Fixed create_index code so that one call is made per
       63*   index to be created.
       64*
       65*   83-02-04 Mike Kubicar : Added calls to transaction processing routines.
       66*
       67*   83-02-14 Davids: modified to use the new db_type_flags in the db_model
       68*   structure instead of the old numeric db_type.
       69*
       70*   83-02-22 Harvey: Changed calling sequence to $create_relation for attribute
       71*   names.
       72*
       73*   83-02-24 Davids: Modified to set the protected, no_concurrency and
       74*   no_rollback elements of the file_create_info structure from the
       75*   transactions_needed, concurrency_on, and rollback_on elements of the
       76*   db_model structure.
       77*
       78*   83-05-24 Davids: Added code to change the saved_res_verion so that the
       79*   saved resultant will not get incorrectly used in an opening.
       80*
       81*   84-08-22 Pierret: Changed file_create_info structure to use version
       82*   FILE_CREATE_INFO_VERSION_2 and to set the new 
       83*   file_create_info.ring_brackets (*) to 0, meaning use default value.
       84**/
       85 
       86 /*           PARAMETERS            */
       87 
       88 	dcl     I_rmdb_create_rel_info_ptr ptr parameter; /* Pointer to the rmdb_create_rel_info structure */
       89 	dcl     I_rmdb_ctl_ptr	 ptr parameter;	/* Pointer to the rmdb_ctl_info structure */
       90 	dcl     I_called_from_request_level bit (1);	/* True if rmdb_create_rel was called from the request level,
       91*                                                               false if from rmdb_create_and_pop_rel */
       92 	dcl     O_err_msg		 char (*) parameter;/* Error message text */
       93 	dcl     O_err_code		 fixed bin (35) parameter; /* Error code */
       94 
       95 /* rmdb_create_relation: proc (I_rmdb_ctl_ptr, I_rmdb_create_rel_info_ptr, I_called_from_request_level, O_err_msg, O_err_code); */
       96 
       97 /*      Init parameters          */
       98 
       99 	rmdb_create_rel_info_ptr = I_rmdb_create_rel_info_ptr;
      100 	rmdb_ctl_ptr = I_rmdb_ctl_ptr;
      101 	called_from_request_level = I_called_from_request_level;
      102 	O_err_msg = "";
      103 	O_err_code = 0;
      104 
      105 /*     Init   for cleanup                   */
      106 
      107 	temp_file_iocb_ptr = rmdb_ctl.crossref_file_info.iocb_ptr;
      108 	file_model_ptr, temp_seg_ptr = null;
      109 	must_delete_relation = "0"b;
      110 	db_path = rmdb_create_rel_info.db_path;
      111 	temp_dir_path = rmdb_create_rel_info.temp_directory_path;
      112 	dbm_ptr = rmdb_create_rel_info.db_model_ptr;
      113 
      114 	if db_model.db_type_flags.transactions_needed & called_from_request_level then do;
      115 		mstxn_transactions_needed = "1"b;
      116 		call transaction_manager_$get_current_txn_id (mstxn_txn_id,
      117 		     mstxn_code);
      118 		if mstxn_code = 0 then do;
      119 			mstxn_txn_id = "0"b;	/* So that we don't try to commit the transaction */
      120 			call error (error_table_$action_not_performed,
      121 			     "Relations may not be created while a transaction is " ||
      122 			     "in progress.  Commit or abort the transaction and try " ||
      123 			     "again.");
      124 		     end;
      125 	     end;
      126 	else mstxn_transactions_needed = "0"b;
      127 	mstxn_txn_id = "0"b;			/* transaction_manager_ doesn't guarantee 0 after previous call */
      128 
      129 	fm_ptr = null;
      130 	on cleanup call tidy_up;			/* Establish a cleanup handler */
      131 
      132 	if rmdb_create_rel_info.version ^= RMDB_CREATE_REL_INFO_VERSION_1 then
      133 	     call error (error_table_$unimplemented_version,
      134 		"For rmdb_create_rel_info.version");
      135 
      136 	if db_model.num_rels + 1 > mrds_data_$max_relations then /* Can only have so many */
      137 	     call error (mrds_error_$max_rels, rmdb_create_rel_info.relation_name);
      138 
      139 /* Validate the relation name supplied */
      140 
      141 	rel_name = rtrim (rmdb_create_rel_info.relation_name);
      142 
      143 	first_char = substr (rel_name, 1, 1);		/* Get first char of rel_name */
      144 
      145 	if first_char = "_" then
      146 	     call error (mrds_error_$inv_rel_name_first_char, "^/" || rel_name ||
      147 		"^/Relation names cannot begin with an underscore.");
      148 
      149 	if first_char = "-" then
      150 	     call error (mrds_error_$inv_rel_name_first_char, "^/" || rel_name ||
      151 		"^/Relation names cannot begin with a hyphen.");
      152 
      153 	if verify (first_char, "0123456789") = 0 then
      154 	     call error (mrds_error_$inv_rel_name_first_char, "^/" || rel_name ||
      155 		"^/Relation names cannot begin with a numeric.");
      156 
      157 
      158 	s = verify (rel_name, mrds_data_$valid_rel_and_attr_name_chars);
      159 	if s ^= 0 then
      160 	     call error (mrds_error_$bad_rel_name, "^/" || rel_name ||
      161 		"^/First bad character is:  " || substr (rel_name, s, 1));
      162 
      163 	if rel_name = "db_model" then call error (mrds_error_$rst_reserved_name,
      164 		"^/" || rel_name ||
      165 		"^/The name ""db_model"" is a reserved name for MRDS and cannot be used as a relation name.");
      166 
      167 	call check_supplied_attr_list;		/* Internal procedure */
      168 
      169 /* See if a relation by this name already exists in db */
      170 
      171 	call initiate_file_ (db_path, rel_name || ".m", R_ACCESS, fm_ptr, (0), code);
      172 
      173 	if fm_ptr ^= null then do;
      174 	     call terminate_file_ (fm_ptr, 0, TERM_FILE_TERM, (0));
      175 	     call error (mrds_error_$dup_rel, "^/" || rel_name);
      176 	     end;
      177 
      178 	must_delete_relation = "1"b;			/* In case of an error */
      179 
      180 /* Changed the version on the saved resultant so it doesn't get used
      181*   incorrectly and mark database as inconsistent and set undo string.
      182*   This is done at this point in the procedure because until now, nothing
      183*   has been added to the db that would need to be removed in case of an error.
      184*   */
      185 
      186 	rmdb_ctl_ptr -> rmdb_ctl.saved_res_version_ptr -> based_char8 = "RESTRUCT";
      187 	call mdbm_util_$inconsistent_set (dbm_ptr, "create_relation",
      188 	     "Creating relation " || rel_name, "delete_relation " || rtrim (rel_name) || " -brief");
      189 
      190 /* Create file_model segment */
      191 
      192 	call initiate_file_$create (db_path, rel_name || ".m", RW_ACCESS, file_model_ptr, ("0"b), (0), code);
      193 	if code ^= 0 then call error (code, pathname_ (db_path, (rel_name)));
      194 
      195 	call rmdb_init_file_model (dbm_ptr, file_model_ptr, err_msg, code); /* External proc
      196*						   That inits file_model structure and rel_info structure */
      197 	if code ^= 0 then call error (code, err_msg);
      198 
      199 	call build_db_attr_list;			/* Internal proc  creates a list of all unique attribute names */
      200 
      201 
      202 /* Find last file_info in db_model so we can link in the new file_info */
      203 
      204 	do fi_ptr = ptr (dbm_ptr, db_model.file_ptr)
      205 	     repeat ptr (dbm_ptr, file_info.fwd_ptr)
      206 	     while (rel (fi_ptr) ^= NULL_OFFSET);
      207 
      208 	     last_fi_ptr = fi_ptr;
      209 	end;
      210 
      211 	on area begin;				/* In case there is not enough room to allocate file_info */
      212 		O_err_msg = "Area in model is not large enough to add the relation "
      213 		     || rel_name || "^/Relation will not be added.";
      214 		O_err_code = error_table_$area_too_small;
      215 		call tidy_up;
      216 		goto exit;
      217 	     end;
      218 
      219 	allocate file_info in (dbm_area) set (fi_ptr);	/* New file_info */
      220 	file_model_ptr -> file_model.fi_ptr = rel(fi_ptr);/* Save the ptr in case we have to back out */
      221 
      222 	revert area;
      223 
      224 	file_info.file_name = rel_name;
      225 	file_info.file_id = "000000000000000000000000000000000001"b;
      226 	file_info.fwd_ptr = NULL_OFFSET;
      227 
      228 /* Start of critical code that links new relation in to database
      229*   Errors that occur prior to this will cause the data_file and file_model to
      230*   be deleted and leave that database consistent. */
      231 
      232 	quit_intercept_flag = "0"b;
      233 
      234 	on quit quit_intercept_flag = "1"b;		/* hold off any QUITs til finished updating db_model */
      235 
      236 	call add_supplied_attrs;			/* Internal proc */
      237 
      238  /* Add the relation name to the xref file. */
      239 
      240 	call mdbm_util_$xref_create_record (temp_file_iocb_ptr, RELATION_KEY_HEAD, rmdb_create_rel_info.relation_name, rel( fi_ptr), err_msg, code);
      241 	if code ^= 0
      242 	then call error (code, err_msg);
      243 
      244  /* Link new file_info into list */
      245 	if db_model.file_ptr = NULL_OFFSET then
      246 	     db_model.file_ptr = rel (fi_ptr);
      247 	else last_fi_ptr -> file_info.fwd_ptr = rel (fi_ptr);
      248 
      249 	db_model.num_unblk_files = db_model.num_unblk_files + 1; /* Just added new file */
      250 	db_model.num_rels = db_model.num_rels + 1;	/* Just added new relation */
      251 
      252 
      253 /* Start a transaction */
      254 
      255 	on cleanup
      256 	     begin;
      257 		call tidy_up;
      258 		call mstxn_cleanup;
      259 	     end;
      260 	on any_other call mstxn_any_other;
  1     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the changes made on 85-05-06 and
  1     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
  1    10*     was removed because not all modules need the dbcb, and the
  1    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
  1    12*     list #136).
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 /*
  1    17*                    BEGIN_DESCRIPTION
  1    18*
  1    19*   A generalized routine accessed by all MRDS modules (with the temporary 
  1    20*   (perhaps) exception of restructuring modules) that must start transactions 
  1    21*   if none are present.  The intent is that it be executed as inline code.
  1    22*   The variable mstxn_transactions_needed must be set prior to entering this
  1    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
  1    24*   will suffice.  Included are procedures called mstxn_cleanup and 
  1    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
  1    26*   handlers in the program.  Such handlers should be established just prior to
  1    27*   the inclusion of this code and disabled just following the inclusion of
  1    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
  1    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
  1    30*   include file does the same, because this code might not have been entered 
  1    31*   yet when the handler is invoked.  Directly following this include file the 
  1    32*   contents of mstxn_code should be examined.  If zero, then either the 
  1    33*   transaction was successfully started or no transaction was required.  If the
  1    34*   mrds_finish_transaction code is referenced in general error handling 
  1    35*   situations where the possibility exists that the code in this include file 
  1    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
  1    37*   the beginning of the program.
  1    38*
  1    39*                    END_DESCRIPTION
  1    40*
  1    41*   Written 82-09-28 by Paul W. Benjamin.
  1    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
  1    43*   Modified 83-01-07 by PWB to not reference the dbcb.
  1    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
  1    45*		 any_other handler in situations where the module did
  1    46*		 not start the transaction.
  1    47*   Modified 83-05-05 by PWB to abandon when abort fails.
  1    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
  1    49*		 and abort.
  1    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
  1    51*		 transaction_bj_full conditions.
  1    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
  1    53*		 and to handle transaction_lock_timeout_.
  1    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
  1    55*                     dbcb.user_started_transaction flag.
  1    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
  1    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
  1    58*                     directory >ldd>include and >exl>mrd>i
  1    59**/
  1    60 
  1    61 dcl continue_to_signal_ entry (fixed bin(35));
  1    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
  1    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
  1    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
  1    65 dcl mstxn_code fixed bin (35);
  1    66 dcl mstxn_retries fixed;
  1    67 dcl mstxn_temp_code fixed bin (35);
  1    68 dcl mstxn_transactions_needed bit (1) aligned;
  1    69 dcl user_started_transaction bit (1) aligned;
  1    70 dcl mstxn_txn_id bit (36) aligned;
  1    71 dcl user_transaction_id bit (36) aligned;
  1    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
  1    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
  1    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
  1    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
  1    76 dcl transaction_manager_$handle_conditions entry ();
  1    77 dcl 1 mstxn_condition_info like condition_info;
  1    78 
  2     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*Designed by Matthew C. Pierret, 01/26/82.
  2     6*Coded by Jeffrey D. Ives, 04/30/82.
  2     7*Modified:
  2     8*10/18/82 by Steve Herbst: Names changed.
  2     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  2    10**/
  2    11 
  2    12 dcl (LOWEST_MODE init (1),
  2    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  2    14 
  2    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  2    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  2    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  2    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  2    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  2    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  2    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  2    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  2    23 
  2    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    79 

  1    80 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
  1    81 
  1    82 
  1    83 	mstxn_code = 0;
  1    84 	mstxn_txn_id = "0"b;
  1    85 	
  1    86 	if ^mstxn_transactions_needed			/* only need transactions */
  1    87 	     then goto mstxn_exit;			/* for protected page files */
  1    88 	mstxn_retries = 0;
  1    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
  1    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
  1    91 	     then do;				
  1    92 	     user_started_transaction = "1"b;
  1    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
  1    95 	     goto mstxn_exit;	
  1    96 	end;
  1    97 
  1    98 	user_started_transaction = "0"b;
  1    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
  1   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1   101 
  1   102 mstxn_cleanup:
  1   103 proc;
  1   104 
  1   105 /*  This procedure MUST be called by a cleanup handler. */
  1   106 
  1   107           if mstxn_txn_id ^= "0"b
  1   108           then do;
  1   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
  1   110 	     if mstxn_temp_code ^= 0
  1   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
  1   112 	end;
  1   113 	
  1   114      end mstxn_cleanup;
  1   115 
  1   116 mstxn_any_other:
  1   117 proc;
  1   118 
  1   119 /*  This procedure MUST be called by an any_other handler. */
  1   120 
  1   121           if mstxn_txn_id ^= "0"b
  1   122           then do;
  1   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
  1   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
  1   125 		then do;
  1   126 		mftxn_code = dm_error_$lock_deadlock;
  1   127 		goto mftxn_check_code;
  1   128 	     end;
  1   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
  1   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
  1   131 		then do;
  1   132 		mftxn_code = dm_error_$bj_journal_full;
  1   133 		goto mftxn_check_code;
  1   134 	     end;
  1   135 	     else call transaction_manager_$handle_conditions;
  1   136 	end;
  1   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
  1   138      end mstxn_any_other;
  1   139      
  1   140 mstxn_exit:
  1   141      
  1   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
      261 
      262 	if mstxn_code ^= 0
      263 	then call error (mstxn_code,
      264 		"Could not start a transaction, while creating relation " ||
      265 		rtrim (rel_name) || ".");
      266 
      267 /* Create and init relations data file */
      268 
      269 	call create_relation_data_file;		/* Internal proc */
      270 
      271 	must_delete_relation = "0"b;			/* So tidy_up won't delete it */
      272 
      273 /* Add the history entry to the db_model */
      274 
      275 	call rmdb_add_rmdb_history (dbm_ptr, RMDB_REL_TYPE, (rel_name),
      276 	     RMDB_ADD_REL_OP, "", long_err_msg, code);
      277 
      278 	revert quit;
      279 
      280 	if quit_intercept_flag then signal quit;	/* Now signal the quit that was intecepted */
      281 
      282 	if code ^= 0 then call error (code, long_err_msg);/* Error code from rmdb_add_rmdb_history */
      283 
      284 	call adjust_bit_count_ ((db_path), rel_name || ".m", "1"b, bcnt, code);
      285 	if code ^= 0 then call error (code, pathname_ (db_path, rel_name || ".m"));
      286 
      287 	call adjust_bit_count_ ((db_path), "db_model", "1"b, bcnt, code);
      288 	if code ^= 0 then call error (code, pathname_ (db_path, "db_model"));
      289 
      290 	call tidy_up;				/* Release temp file and undo openings and
      291*						   set database as consistent */
      292 
      293 exit:
      294 	mftxn_code = O_err_code;
  4     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
  4     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*                    BEGIN_DESCRIPTION
  4    15*
  4    16*   A generalized routine accessed by all MRDS modules that begin and commit 
  4    17*   transactions.  The intent is that it be executed as inline code. It is 
  4    18*   assumed that mrds_start_transaction was executed previously in the 
  4    19*   procedure.  Prior to this include file the program should assign the value 
  4    20*   of its local error code to mftxn_code.  The program utilizing this
  4    21*   include file must supply a function labeled should_rollback that returns
  4    22*   bit (1).  This routine should examine the error code mftxn_code and whether
  4    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
  4    24*   means rollback.  This procedure may choose to simply return "0"b as it 
  4    25*   appears that MRDS will generally NOT rollback transactions.  This routine
  4    26*   does rollback and restart if the before journal is full but only attempts it
  4    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
  4    28*   where any data that was saved prior to the transaction is restored.  A 
  4    29*   procedure consisting solely of a return statement can be supplied if 
  4    30*   necessary.  After execution of this include file, mftxn_code must be
  4    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
  4    32*   then the commit has failed.  Otherwise it will be unchanged.
  4    33*
  4    34*                    END_DESCRIPTION
  4    35*
  4    36*   Written 82-09-30 by Paul W. Benjamin.
  4    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
  4    38*                     error code only when the transaction is in an error state.
  4    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
  4    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
  4    41*		 fails, and to abort rather than rollback when bj is full.
  4    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
  4    43*		 and rollback.
  4    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
  4    45*		 to by the mstxn_any_other procedure.
  4    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
  4    47*                     the user already started his own transaction.
  4    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
  4    49*                     the directory >ldd>include and >exl>mrd>i.
  4    50**/
  4    51 
  4    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
  4    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
  4    54 dcl mftxn_code fixed bin (35);
  4    55 dcl mftxn_temp_code fixed bin (35);
  4    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
  4    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
  4    58 	
  4    59 
  4    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
  4    61 	     then do;
  4    62 	     mftxn_code = 0;
  4    63 	     goto mftxn_exit;
  4    64 	end;
  4    65 mftxn_check_code:
  4    66 	if mftxn_code = 0
  4    67 	     then do;
  4    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
  4    69 	     if mftxn_code ^= 0
  4    70 		then do;
  4    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    72 		if mftxn_temp_code ^= 0
  4    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    74 	     end;
  4    75 	end;
  4    76 	else do;
  4    77 	     call restore_significant_data;
  4    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
  4    79 		& mstxn_retries < 1		
  4    80 		then do;
  4    81 		     mstxn_retries = mstxn_retries + 1;
  4    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    83 		     if mftxn_temp_code ^= 0
  4    84 			then do;
  4    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    86 			if mftxn_temp_code ^= 0
  4    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    88 		     end;
  4    89 		     else do;
  4    90 			mstxn_code = 0;
  4    91 			goto mstxn_exit;		/* go back and try again */
  4    92 		     end;
  4    93 		end;
  4    94 	     else if should_rollback ()		/* let the program decide */
  4    95 		then do;
  4    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    97 		if mftxn_temp_code ^= 0
  4    98 		     then do;
  4    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   100 		     if mftxn_temp_code ^= 0
  4   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   102 		end;
  4   103 		else do;
  4   104 		     mstxn_code = 0;
  4   105 		     goto mstxn_exit;		/* go back and try again */
  4   106 		end;
  4   107 	     end;
  4   108 	     else do;
  4   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   110 		if mftxn_temp_code ^= 0
  4   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   112 	     end;
  4   113 	end;
  4   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
  4   115 mftxn_exit:
  4   116      
  4   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
      295 
      296 	if mftxn_code ^= 0 then do;
      297 		O_err_code = mftxn_code;
      298 		O_err_msg = "Could not commit or abort the transaction, while "
      299 		     || "creating relation " || rtrim (rel_name) || ".";
      300 	     end;
      301 	return;
      302 
      303 /* * * * * * * * * * * * *   check_supplied_attr_list    * * * * * * * * * * */
      304 
      305 check_supplied_attr_list: proc;
      306 
      307 /* Checks attribute names supplied for this relation against themselves
      308*   for duplication.  It also sees if there is a primary key attribute supplied,
      309*   and check for valid attribute names.
      310**/
      311 
      312 	primary_key_found = "0"b;
      313 
      314 	do x = 1 to rmdb_create_rel_info.num_attrs;
      315 
      316 	     if rmdb_create_rel_info.attrs (x).primary_key then primary_key_found = "1"b;
      317 
      318 	     do j = x+1 to rmdb_create_rel_info.num_attrs;
      319 
      320 		if x ^= j & /* If not itself  */
      321 		     rmdb_create_rel_info.attrs (x).name = rmdb_create_rel_info.attrs (j).name then
      322 		     call error (mrds_error_$rst_name_duplicate, "^/" ||
      323 			rmdb_create_rel_info.attrs (x).name);
      324 	     end;
      325 
      326 	     attr_name = rtrim (rmdb_create_rel_info.attrs (x).name);
      327 	     first_char = substr (attr_name, 1, 1);	/* Get first char of attr_name */
      328 
      329 	     if first_char = "_" then
      330 		call error (mrds_error_$inv_attr_name_first_char,
      331 		     "^/" || attr_name ||
      332 		     "^/Attribute names cannot begin with an underscore.");
      333 
      334 	     if first_char = "-" then
      335 		call error (mrds_error_$inv_attr_name_first_char,
      336 		     "^/" || attr_name ||
      337 		     "^/Attribute names cannot begin with a hyphen.");
      338 
      339 	     if verify (first_char, "0123456789") = 0 then
      340 		call error (mrds_error_$inv_attr_name_first_char,
      341 		     "^/" || attr_name ||
      342 		     "^/Attribute names cannot begin with a numeric.");
      343 
      344 	     s = verify (attr_name, mrds_data_$valid_rel_and_attr_name_chars);
      345 	     if s ^= 0 then
      346 		call error (mrds_error_$bad_attr_name, "^/" ||
      347 		     attr_name ||
      348 		     "^/First bad character is:  " || substr (attr_name, s, 1));
      349 
      350 	end;
      351 
      352 	if ^primary_key_found then
      353 	     call error (mrds_error_$no_primary_key, rmdb_create_rel_info.relation_name);
      354 
      355      end check_supplied_attr_list;
      356 
      357 /*  * * * * * * * * * * *  build_db_attr_list  * * * * * * * * * * * * * *   */
      358 
      359 
      360 build_db_attr_list: proc;
      361 
      362 /* This internal subroutine calls the database crossreference package to create
      363*   the crossreference file if it does not already exist.  */
      364 
      365 	if temp_file_iocb_ptr ^= null
      366 	then return;
      367 
      368 	call mdbm_util_$xref_build (temp_dir_path, db_path, dbm_ptr, rmdb_ctl.crossref_file_info.name,
      369 	     rmdb_ctl.crossref_file_info.iocb_ptr, err_msg, code);
      370 	if code ^= 0 then call error (code, err_msg);
      371 
      372 	temp_file_iocb_ptr = rmdb_ctl.crossref_file_info.iocb_ptr;
      373 	return;
      374 
      375      end build_db_attr_list;
      376 
      377 /*  * * * * * * * * * *    add_supplied_attrs    * * * * * * * * * * *  */
      378 
      379 
      380 
      381 add_supplied_attrs: proc;
      382 
      383 /* This procedure checks to see if the supplied attributes are defined in the
      384*   database by looking each name up in the attribute list created by
      385*   build_db_attr_list. If the attribute is valid the appropiate attr_info is
      386*   added to the file_model.  After all the attributes are processed, we have
      387*   to adjust alignment for the varying attributes.*/
      388 
      389 dcl  WORD fixed bin internal static options (constant) init (36);
      390 dcl  amount_to_pad fixed bin;
      391 dcl  prev_ua_ptr ptr;
      392 dcl  this_ua_ptr ptr;
      393 
      394 	crossref_info_record_ptr = addr (record_buffer);
      395 	do i = 1 to rmdb_create_rel_info.num_attrs;	/* Check each attr name */
      396 
      397 /* Read the first 8 bytes (2 words) of the crossreferece record. This will
      398*   contain the domain_info offset and the count of relations this attribute
      399*   is used in. If the attribute is unreferenced, delete the attr_info in the
      400*   db_model for this one. */
      401 
      402 	     call mdbm_util_$xref_find_record (temp_file_iocb_ptr, ATTRIBUTE_KEY_HEAD,
      403 		rmdb_create_rel_info.attrs (i).name, crossref_info_record_ptr,
      404 		8, err_msg, code);
      405 	     if code ^= 0
      406 	     then if code = error_table_$long_record
      407 		then ;				/* ignore this error */
      408 	          else if code = error_table_$no_record
      409 		     then call error (mrds_error_$undef_attr,
      410 			          "^/" || rmdb_create_rel_info.attrs (i).name);
      411 		     else call error (code, err_msg);
      412 
      413 	     di_ptr = ptr (dbm_ptr, crossref_info_record.offset);
      414 
      415 /* Add the attr_info to the rel_info */
      416 	     call rmdb_build_attr_info (dbm_ptr, addr (rmdb_create_rel_info.attrs (i)),
      417 		file_model_ptr, di_ptr, err_msg, code);
      418 	     if code ^= 0 then call error (code, err_msg);
      419 
      420 /* Add this relation to the attribute crossreference list */
      421 	     call mdbm_util_$xref_reference (temp_file_iocb_ptr, ATTRIBUTE_KEY_HEAD,
      422 		rmdb_create_rel_info.attrs (i).name, rmdb_create_rel_info.relation_name,
      423 		null, 0, err_msg, code);
      424 	     if code ^= 0 then call error (code, err_msg);
      425 
      426 /* Mark that the domain is used, in case this is a generated attribute for a
      427*   domain. */
      428 	     domain_info.unreferenced = "0"b;
      429 
      430 /* if it was an unreferenced_attribute, delete it from the db_model */
      431 	     if crossref_info_record.count = 0
      432 	     then do;
      433 		prev_ua_ptr, this_ua_ptr = null;
      434 		do ua_ptr = ptr (dbm_ptr, db_model.unreferenced_attribute_ptr)
      435 		     repeat ptr (dbm_ptr, unreferenced_attribute.fwd_thread)
      436 		     while (rel (ua_ptr) ^= NULL_OFFSET & this_ua_ptr = null);
      437 
      438 		     if unreferenced_attribute.name = rmdb_create_rel_info.attrs (i).name
      439 		     then this_ua_ptr = ua_ptr;
      440 		     else prev_ua_ptr = ua_ptr;
      441 		     end;				/* do ua_ptr */
      442 
      443 /* When we get here, if this_ua_ptr is nonnull, it will point to a matching
      444*   unreferenced_attribute in the db_model and is the one that we are going to
      445*   free. prev_ua_ptr will point to the previous one on the list or be null. If
      446*   it is null, then we are freeing the first one in the list and must set the
      447*   head of the list in the db_model. Otherwise, we change the offset of the
      448*   previous unreferenced_attribute fwd_thread to point to the next one in the
      449*   list. This operation only unchains it from the linked list. */
      450 
      451 		if this_ua_ptr ^= null
      452 		then do;
      453 		     if prev_ua_ptr = null
      454 		     then db_model.unreferenced_attribute_ptr = this_ua_ptr -> unreferenced_attribute.fwd_thread;
      455 		     else prev_ua_ptr -> unreferenced_attribute.fwd_thread = this_ua_ptr -> unreferenced_attribute.fwd_thread;
      456 
      457 		     free this_ua_ptr -> unreferenced_attribute in (dbm_area);
      458 		     end;
      459 		end;
      460 	end;					/* do i */
      461           
      462 /* Here is where we adjust alignment for varying length attributes. */
      463           ri_ptr = ptr (file_model_ptr, file_model_ptr -> file_model.rel_ptr);
      464           if rel_info.nvar_atts = 0 then;
      465 	else do;
      466 	     if mod (rel_info.var_offset-1, WORD) = 0 then
      467 		amount_to_pad = 0;
      468 	     else amount_to_pad = WORD - mod (rel_info.var_offset -1, WORD);
      469 
      470 	     rel_info.var_offset = rel_info.var_offset + amount_to_pad;
      471 	     rel_info.max_data_len = rel_info.max_data_len + amount_to_pad;
      472 	     end;
      473 
      474      return;
      475      end add_supplied_attrs;
      476 
      477 /*  * * * * * * * * * * *   create_relation_data_file   * * * * * * * * *    */
      478 
      479 create_relation_data_file: proc;
      480 
      481 	file_model_name = rel_name || ".m";
      482 	call initiate_file_ (db_path, file_model_name, R_ACCESS, fm_ptr, (0), code);
      483 	if fm_ptr = null then call error (code, " The file model," || rtrim (file_model_name) || "could not be initiated.");
      484 
      485 	ri_ptr = ptr (fm_ptr, file_model.rel_ptr);	/* relation info ptr */
      486 
      487 /* set up working area */
      488 	caller_name = "rmdb_create_relation";
      489 	call mdbm_util_$get_temp_segment_path (temp_dir_path, caller_name, temp_seg_ptr, code);
      490 	if code ^= 0 then call error (code, "getting temp segment.");
      491 
      492 	work_area_ptr = temp_seg_ptr;
      493 	wa = empty ();
      494 
      495 /* initialize for calls to relation manager */
      496 
      497 	tva_number_of_vector_slots = 0;
      498 	tva_number_of_dimensions = rel_info.num_attr;
      499 	tva_maximum_dimension_name_length = 32;
      500 	allocate typed_vector_array in (wa);
      501 
      502 	il_number_of_ids = rel_info.num_attr;
      503 	allocate id_list in (wa);
      504 	id_list.number_of_ids = 0;
      505 	id_list.version = ID_LIST_VERSION_1;
      506 
      507 	typed_vector_array.version = TYPED_VECTOR_ARRAY_VERSION_2;
      508 
      509 	ai_ptr = ptr (fm_ptr, rel_info.attr_ptr);	/* get attribute info  */
      510 	do i = 1 to tva_number_of_dimensions;
      511 
      512 	     if attr_info.key_attr then do;		/* set up the primary key index */
      513 		     id_list.number_of_ids = id_list.number_of_ids + 1;
      514 		     id_list.id (id_list.number_of_ids) = attr_info.defn_order;
      515 		end;
      516 	     di_ptr = ptr (dbm_ptr, attr_info.domain_ptr);/* set up descriptor list for create relation */
      517 	     typed_vector_array.dimension_table (i).name = attr_info.name;
      518 	     typed_vector_array.dimension_table (i).descriptor_ptr = addr (domain_info.db_desc);
      519 	     ai_ptr = ptr (fm_ptr, attr_info.fwd_thread);
      520 
      521 	end;
      522 	allocate rel_creation_info in (wa);
      523 	allocate file_create_info in (wa);
      524 
      525 /* initialize values for create_relation */
      526 
      527 	rel_creation_info.version = REL_CREATION_INFO_VERSION_2;
      528 	rel_creation_info.esm_info_ptr = null;
      529 	rel_creation_info.cism_info_ptr = null;
      530 	rel_creation_info.file_create_info_ptr = file_create_info_ptr;
      531 	file_create_info.version = FILE_CREATE_INFO_VERSION_2;
      532 	file_create_info.ci_size_in_bytes = 4096;
      533 	file_create_info.blocking_factor = mrds_data_$relation_blocking_factor;
      534 	file_create_info.flags.protected = db_model.db_type_flags.transactions_needed;
      535 	file_create_info.flags.no_concurrency = ^db_model.db_type_flags.concurrency_on;
      536 	file_create_info.flags.no_rollback = ^db_model.db_type_flags.rollback_on;
      537 	file_create_info.flags.mbz_1 = "0"b;
      538           file_create_info.ring_brackets (*) = 0;
      539 	file_create_info.mbz_2 = 0;
      540           file_create_info.mbz_3 = "0"b;
      541 
      542 /* initialize values for create_index */
      543 	style = 1;
      544 	relation_index_flags_ptr = addr (flag_list);
      545 	relation_index_flags.relation_must_be_empty = "0"b;
      546 	relation_index_flags.index_is_clustering = "0"b;
      547 	relation_index_flags.index_is_unique = "1"b;	/* for primary key */
      548 
      549 	create_rel_name = rtrim (rel_name);
      550 
      551 
      552 	call rmdb_ctl.relmgr_entries.create_relation (db_path, create_rel_name,
      553 	     rel_creation_info_ptr, typed_vector_array_ptr,
      554 	     rel_opening_id, rel_info.id, code);
      555 
      556 	if code ^= 0 then call error (code, "While creating relation " || rel_name);
      557 
      558 
      559 /* create the primary index for the relation */
      560 
      561 	call rmdb_ctl.relmgr_entries.create_index (rel_opening_id,
      562 	     id_list_ptr, flag_list, style, rel_info.primary_key_index_id, code);
      563 
      564 	if code ^= 0 then
      565 	     call error (code, "while creating the primary index for" || rel_name);
      566 
      567 
      568 
      569 /* create the secondary indexes for the relation */
      570 
      571 	relation_index_flags.index_is_unique = "0"b;	/* index need not be unique for secondary index */
      572 
      573 	id_list.number_of_ids = 1;			/* secondary indices involve only one attribute */
      574 
      575 	ai_ptr = ptr (fm_ptr, rel_info.attr_ptr);
      576 	do i = 1 to rel_info.num_attr;
      577 	     if attr_info.index_attr
      578 	     then do;
      579 		     id_list.id (1) = attr_info.defn_order;
      580 		     call rmdb_ctl.relmgr_entries.create_index (rel_opening_id,
      581 			id_list_ptr, flag_list, style, attr_info.index_id, code);
      582 		     if code ^= 0 then
      583 			call error (code, " while creating secondary indices for " || rel_name);
      584 		end;
      585 
      586 	     ai_ptr = ptr (fm_ptr, attr_info.fwd_thread);
      587 
      588 	end;
      589 
      590 	call rmdb_ctl.relmgr_entries.close (rel_opening_id, code);
      591 	if code ^= 0 then
      592 	     call error (code, " while closing the relation " || rel_name);
      593 
      594 
      595 
      596      end create_relation_data_file;
      597 
      598 /*  * * * * * * * * * * * * * *      error     * * * * * * * * * * * * * *   */
      599 
      600 
      601 
      602 error: proc (err_code, err_message);			/* Error procedure for rmdb_create_relation.pl1 */
      603 
      604 	dcl     err_code		 fixed bin (35);
      605 	dcl     err_message		 char (*);
      606 
      607 
      608 	O_err_code = err_code;
      609 	O_err_msg = err_message;
      610 	call tidy_up;
      611 	goto exit;
      612 
      613      end error;
      614 
      615 
      616 
      617 
      618 
      619 /* * * * * * * * * * * * * * * *   tidy_up  * * * * * * * * * * * * * * *  */
      620 
      621 tidy_up: proc;
      622 
      623 	if must_delete_relation then do;		/* Unlink relation from db_model
      624*						   and delete file_model and relation_data_file */
      625 
      626 
      627 		delete_rel_info.version = RMDB_DELETE_REL_INFO_VERSION_1;
      628 		delete_rel_info.absolute_db_path = db_path;
      629 		delete_rel_info.db_model_ptr = rmdb_create_rel_info.db_model_ptr;
      630 		delete_rel_info.relation_name = rel_name;
      631 		delete_rel_info.brief = "1"b;
      632 		delete_rel_info.mbz = "0"b;
      633 
      634 		call rmdb_delete_relation$cleanup (rmdb_ctl_ptr, addr (delete_rel_info), err_msg, code);
      635 		fm_ptr = null;
      636 		call mdbm_util_$xref_destroy (rmdb_ctl.crossref_file_info.iocb_ptr, rmdb_ctl.temp_dir_path,
      637 		     rmdb_ctl.crossref_file_info.name, (""), (0));
      638 		end;
      639 
      640 	if code = 0 then call mdbm_util_$inconsistent_reset (dbm_ptr); /* Make db consistent */
      641 
      642 	if temp_seg_ptr ^= null then call mdbm_util_$free_temp_segment (caller_name, temp_seg_ptr, (0));
      643 
      644 	if fm_ptr ^= null then call terminate_file_ (fm_ptr, 0, TERM_FILE_TERM, (0));
      645 
      646      end tidy_up;
      647 
      648 /***********
      649**
      650**   These routines are used by the transaction processing include files.
      651**   Restore_significant_data is called to reinitialize variables in case
      652**   of a rollback.  In this module, restore data must add a history section
      653**   note that the relation created has been deleted.  This is just a
      654**   stopgap measure until add history is smart enough to be able to delete
      655**   history entries.  Should_rollback determines whether a transaction should
      656**   be rolled back or aborted on error.  Currently, it is always aborted.
      657**
      658***********/
      659 
      660 
      661 restore_significant_data:
      662      proc;
      663 
      664 	dcl     add_history_code	 fixed bin (35);
      665 	dcl     add_history_err_msg	 char (500);
      666 
      667 	call rmdb_add_rmdb_history (dbm_ptr, RMDB_REL_TYPE, (rel_name),
      668 	     RMDB_DEL_REL_OP, "", add_history_err_msg, add_history_code);
      669 	must_delete_relation = "1"b;
      670      end restore_significant_data;
      671 
      672 
      673 
      674 should_rollback:
      675      proc returns (bit (1));
      676 	return ("0"b);
      677      end should_rollback;
      678 
      679 	dcl     addr		 builtin;
      680 	dcl     adjust_bit_count_	 entry (char (168) aligned, char (32) aligned, bit (1) aligned, fixed bin (35), fixed bin (35));
      681 	dcl     any_other		 condition;
      682 	dcl     area		 condition;
      683 	dcl     attr_name		 char (32) varying;
      684 	dcl     based_char8		 char (8) based;
      685 	dcl     bcnt		 fixed bin (35);
      686 	dcl     called_from_request_level bit (1);
      687 	dcl     caller_name		 char (20);
      688 	dcl     cleanup		 condition;
      689 	dcl     create_rel_name	 char (32);
      690 	dcl     code		 fixed bin (35);
      691 	dcl     db_path		 char (168);
      692 	dcl     empty		 builtin;
      693 	dcl     error_table_$action_not_performed fixed bin (35) ext static;
      694 	dcl     error_table_$area_too_small fixed bin (35) ext static;
      695 	dcl     error_table_$long_record fixed bin(35) ext static;
      696 	dcl     error_table_$no_record fixed bin (35) ext static;
      697 	dcl     error_table_$unimplemented_version fixed bin (35) ext static;
      698 	dcl     err_msg		 char (256);
      699 	dcl     file_model_name	 char (32);
      700 	dcl     file_model_ptr	 ptr;
      701 	dcl     first_char		 char (1);
      702 	dcl     fixed		 builtin;
      703 	dcl     flag_list		 bit (36) aligned;
      704 	dcl     mdbm_util_$get_temp_segment_path entry (char (*), char (*), ptr, fixed bin (35));
      705           dcl     mdbm_util_$xref_create_record entry (ptr, char (*), char (*), bit (18), char (*), fixed bin (35));
      706 	dcl     mdbm_util_$xref_destroy entry (ptr, char (*), char (*), char (*), fixed bin (35));
      707 	dcl     initiate_file_	 entry (char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35));
      708 	dcl     initiate_file_$create	 entry (char(*), char(*), bit(*), ptr, bit(1) aligned, fixed bin(24), fixed bin(35));
      709 	dcl     i			 fixed bin;
      710 	dcl     j			 fixed bin;
      711 	dcl     last_fi_ptr		 ptr;
      712 	dcl     long_err_msg	 char (500);
      713 	dcl     mrds_data_$max_relations ext fixed bin (35);
      714           dcl     mrds_data_$relation_blocking_factor fixed bin (17) external static;
      715 	dcl     mrds_data_$valid_rel_and_attr_name_chars char (128) varying ext;
      716 	dcl     mrds_error_$bad_attr_name fixed bin (35) ext static;
      717 	dcl     mrds_error_$bad_rel_name fixed bin (35) ext static;
      718 	dcl     mrds_error_$dup_rel	 fixed bin (35) ext static;
      719 	dcl     mrds_error_$inv_attr_name_first_char fixed bin (35) ext static;
      720 	dcl     mrds_error_$inv_rel_name_first_char fixed bin (35) ext static;
      721 	dcl     mrds_error_$max_rels	 fixed bin (35) ext static;
      722 	dcl     mrds_error_$no_primary_key fixed bin (35) ext static;
      723 	dcl     mrds_error_$rst_name_duplicate fixed bin (35) ext static;
      724 	dcl     mrds_error_$rst_reserved_name fixed bin (35) ext static;
      725 	dcl     mrds_error_$undef_attr fixed bin (35) ext static;
      726 	dcl     must_delete_relation	 bit (1);
      727 	dcl     mdbm_util_$free_temp_segment entry (char(*), ptr, fixed bin(35));
      728 	dcl     mdbm_util_$inconsistent_reset entry (ptr);
      729 	dcl     mdbm_util_$inconsistent_set entry (ptr, char (*), char (*), char (*));
      730 	dcl     mdbm_util_$xref_build	 entry (char(*), char(*), ptr, char(*), ptr, char(*), fixed bin(35));
      731 	dcl     mdbm_util_$xref_find_record entry (ptr, char(*), char(*), ptr, fixed bin(21), char(*), fixed bin(35));
      732 	dcl     mdbm_util_$xref_reference entry (ptr, char(*), char(*), char(*), ptr, fixed bin(21), char(*), fixed bin(35));
      733           dcl     mod                    builtin;
      734 	dcl     null		 builtin;
      735 	dcl     NULL_OFFSET		 int static bit (18) unal init ((18)"1"b) options (constant);
      736 	dcl     pathname_		 entry (char(*), char(*)) returns(char(168));
      737 	dcl     primary_key_found	 bit (1);
      738 	dcl     ptr		 builtin;
      739 	dcl     quit		 condition;
      740 	dcl     quit_intercept_flag	 bit (1);
      741 	dcl     record_buffer	 (2) fixed bin (35);
      742 	dcl     rel		 builtin;
      743 	dcl     rel_opening_id	 bit (36) aligned;
      744 	dcl     rel_name		 char (32) varying;
      745 	dcl     rmdb_add_rmdb_history	 entry (ptr, fixed bin, char (32), fixed bin, char (32), char (500), fixed bin (35));
      746 	dcl     rmdb_build_attr_info	 entry (ptr, ptr, ptr, ptr, char (*), fixed bin (35));
      747 	dcl     rmdb_delete_relation$cleanup entry (ptr, ptr, char (*), fixed bin (35));
      748 	dcl     rmdb_init_file_model	 entry (ptr, ptr, char (*), fixed bin (35));
      749 	dcl     rtrim		 builtin;
      750 	dcl     s			 fixed bin;
      751 	dcl     style		 fixed bin (17);
      752 	dcl     substr		 builtin;
      753 	dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
      754 	dcl     temp_dir_path	 char (168);
      755 	dcl     temp_file_iocb_ptr	 ptr;
      756 	dcl     temp_seg_ptr	 ptr;
      757 	dcl     terminate_file_	 entry (ptr, fixed bin(24), bit(*), fixed bin(35));
      758 	dcl     verify		 builtin;
      759 	dcl     wa		 area (sys_info$max_seg_size) based (work_area_ptr);
      760 	dcl     work_area_ptr	 ptr;
      761 	dcl     x			 fixed bin;
      762 
      763 	dcl     1 delete_rel_info	 aligned
      764 				 like rmdb_delete_rel_info;
      765 
      766 
  5     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  5     2*
  5     3*   Values for the "access mode" argument so often used in hardcore
  5     4*   James R. Davis 26 Jan 81  MCR 4844
  5     5*   Added constants for SM access 4/28/82 Jay Pattin
  5     6*   Added text strings 03/19/85 Chris Jones
  5     7**/
  5     8 
  5     9 
  5    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  5    11 dcl	(
  5    12 	N_ACCESS		   init ("000"b),
  5    13 	R_ACCESS		   init ("100"b),
  5    14 	E_ACCESS		   init ("010"b),
  5    15 	W_ACCESS		   init ("001"b),
  5    16 	RE_ACCESS		   init ("110"b),
  5    17 	REW_ACCESS	   init ("111"b),
  5    18 	RW_ACCESS		   init ("101"b),
  5    19 	S_ACCESS		   init ("100"b),
  5    20 	M_ACCESS		   init ("010"b),
  5    21 	A_ACCESS		   init ("001"b),
  5    22 	SA_ACCESS		   init ("101"b),
  5    23 	SM_ACCESS		   init ("110"b),
  5    24 	SMA_ACCESS	   init ("111"b)
  5    25 	)		   bit (3) internal static options (constant);
  5    26 
  5    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  5    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  5    29 
  5    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  5    31 			   static options (constant);
  5    32 
  5    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  5    34 			   static options (constant);
  5    35 
  5    36 dcl	(
  5    37 	N_ACCESS_BIN	   init (00000b),
  5    38 	R_ACCESS_BIN	   init (01000b),
  5    39 	E_ACCESS_BIN	   init (00100b),
  5    40 	W_ACCESS_BIN	   init (00010b),
  5    41 	RW_ACCESS_BIN	   init (01010b),
  5    42 	RE_ACCESS_BIN	   init (01100b),
  5    43 	REW_ACCESS_BIN	   init (01110b),
  5    44 	S_ACCESS_BIN	   init (01000b),
  5    45 	M_ACCESS_BIN	   init (00010b),
  5    46 	A_ACCESS_BIN	   init (00001b),
  5    47 	SA_ACCESS_BIN	   init (01001b),
  5    48 	SM_ACCESS_BIN	   init (01010b),
  5    49 	SMA_ACCESS_BIN	   init (01011b)
  5    50 	)		   fixed bin (5) internal static options (constant);
  5    51 
  5    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      767 
      768 
  6     1 /* BEGIN INCLUDE FILE: dm_file_create_info.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*     This include file contains the declaration of the file_create_info
  6     5*     structure.  This structure is used to specify to file_manager_
  6     6*     attributes a file is to have.
  6     7**/
  6     8 
  6     9 /* HISTORY:
  6    10*Written by Jeffery D. Ives, 09/16/82.
  6    11*  (Original concept by Lindsey L. Spratt.)
  6    12*Modified:
  6    13*06/15/84 by Matthew Pierret:  Added ring_brackets. Changed to a char (8)
  6    14*            version.
  6    15*11/07/84 by Matthew Pierret:  Extended mbz_3 to by one word to cover the
  6    16*            gap caused by the double-word alignment of mbz_2.
  6    17**/
  6    18 
  6    19 /* format: style2,ind3 */
  6    20 
  6    21      dcl	   1 file_create_info     aligned based (file_create_info_ptr),
  6    22 	     2 version	      char (8) aligned,
  6    23 	     2 ci_size_in_bytes   fixed bin (35) init (4096),
  6    24 						/* control interval physical size, must be 4096	*/
  6    25 	     2 blocking_factor    fixed bin init (255),	/* # of cis in each msf seg, must be 64 or 255	*/
  6    26 	     2 flags	      unal,
  6    27 	       3 protected	      bit (1) unal init ("1"b),
  6    28 						/* protected against inconsistency		*/
  6    29 	       3 no_concurrency   bit (1) unal init ("0"b),
  6    30 						/* don't protect against concurrent access	*/
  6    31 	       3 no_rollback      bit (1) unal init ("0"b),
  6    32 						/* don't protect against system failure		*/
  6    33 	       3 mbz_1	      bit (15) unal init ("0"b),
  6    34 						/* must be zero for future compatability	*/
  6    35 	     2 ring_brackets      (2) fixed bin (3) unal init (0, 0),
  6    36 						/* write bracket is first element, read bracket is second */
  6    37 	     2 mbz_3	      bit (46) unal init ("0"b),
  6    38 						/* must be zero for future compatability */
  6    39 	     2 mbz_2	      (30) fixed bin (71);	/* must be zero for future compatability	*/
  6    40 
  6    41      dcl	   file_create_info_ptr   ptr;
  6    42 
  6    43      dcl	   FILE_CREATE_INFO_VERSION_2
  6    44 			      char (8) aligned static options (constant) init ("FileCr 2");
  6    45      dcl	   (
  6    46 	   FCI_WRITE_BRACKET_IDX  init (1),
  6    47 	   FCI_READ_BRACKET_IDX   init (2)
  6    48 	   )		      internal static options (constant);
  6    49 
  6    50 /* ************ END OF INCLUDE FILE: dm_file_create_info.incl.pl1 ********** */
      769 
      770 
  7     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION
  7     4*        The id_list structure is used to identify attributes, fields and
  7     5*   dimensions by various modules of the Data Management System.
  7     6**/
  7     7 
  7     8 /* HISTORY:
  7     9*Written by Matthew Pierret, '82.
  7    10*Modified:
  7    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
  7    12*            (constant)' and to initialize automatic variables.
  7    13**/
  7    14 
  7    15 /* format: style2,ind3 */
  7    16      dcl	   1 id_list	      aligned based (id_list_ptr),
  7    17 	     2 version	      fixed bin (35),
  7    18 	     2 number_of_ids      fixed bin (17),
  7    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
  7    20 
  7    21      dcl	   id_list_ptr	      ptr init (null);
  7    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
  7    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
  7    24 
  7    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
      771 
      772 
  8     1 /* BEGIN INCLUDE FILE - dm_rel_creation_info.incl.pl1 */
  8     2 
  8     3 /* format: style1 */
  8     4      dcl	   1 rel_creation_info    aligned based (rel_creation_info_ptr),
  8     5 	     2 version	      fixed bin (35),
  8     6 	     2 file_create_info_ptr ptr,
  8     7 	     2 esm_info_ptr	      ptr,
  8     8 	     2 cism_info_ptr      ptr;
  8     9 
  8    10      dcl	   rel_creation_info_ptr  ptr;
  8    11      dcl	   REL_CREATION_INFO_VERSION_2 fixed bin (35) init (2);
  8    12 
  8    13 /* END INCLUDE FILE - dm_rel_creation_info.incl.pl1 */
      773 
      774 
  9     1 /*  BEGIN INCLUDE FILE - dm_relation_index_flags.incl.pl1 */
  9     2 
  9     3 /* DESCRIPTION:
  9     4*
  9     5*	This structure is used to control the creation of an index by the 
  9     6*     relation_manager_.
  9     7**/
  9     8 
  9     9 /* HISTORY:
  9    10*
  9    11*Written by Lindsey Spratt, 09/20/83.
  9    12*Modified:
  9    13**/
  9    14 
  9    15 /* format: style2,ind3 */
  9    16      dcl	   1 relation_index_flags based (relation_index_flags_ptr) aligned,
  9    17 	     2 relation_must_be_empty
  9    18 			      bit (1) unal,
  9    19 	     2 index_is_clustering
  9    20 			      bit (1) unal,
  9    21 	     2 index_is_unique    bit (1) unal,
  9    22 	     2 pad	      bit (33) unal;
  9    23 
  9    24      dcl	   relation_index_flags_ptr
  9    25 			      ptr init (null);
  9    26 
  9    27 /*  END INCLUDE FILE - dm_relation_index_flags.incl.pl1 */
      775 
      776 
 10     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
 10     2 
 10     3 
 10     4 /****^  HISTORY COMMENTS:
 10     5*  1) change(79-02-01,Gray), approve(), audit(), install():
 10     6*     modified to save space occupied by model
 10     7*  2) change(80-11-03,Gray), approve(), audit(), install():
 10     8*     to add mdbm_secured bit in db_model
 10     9*  3) change(82-04-09,Davids), approve(), audit(), install():
 10    10*     collapsed the following into an unused_offset array:
 10    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
 10    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
 10    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
 10    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
 10    15*       unused_1
 10    16*     Also changed the name of unused_2 to restructuring_history_offset
 10    17*     and changed the comment on the changer structure to indicate
 10    18*     that it will contain on database creation information.
 10    19*  4) change(82-04-14,Davids), approve(), audit(), install():
 10    20*     used one of the unused_offsets to point to a message which indicates
 10    21*     why the db is inconsistent. The offset will be null when the db is created
 10    22*     and set the first time the message is used. this is so it will be
 10    23*     consistent with existing data bases. Also added the message structure.
 10    24*  5) change(82-04-28,Davids), approve(), audit(), install():
 10    25*     added the undo_request element to the message structure
 10    26*  6) change(82-05-04,Davids), approve(), audit(), install():
 10    27*     changed unused_offset (12) to last_restructruring_history_offset and
 10    28*     changed restructuring_history_offset to first_restructuring_history_offset
 10    29*  7) change(82-08-19,Davids), approve(), audit(), install():
 10    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
 10    31*     1 => vfile database and 2 => page_file database. Up to this point all
 10    32*     database types were equal to 1.
 10    33*  8) change(83-02-14,Davids), approve(), audit(), install():
 10    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
 10    35*     flags. This will allow information about transactions and dm_file
 10    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
 10    37*     change is compatable with all datamodels created by the released version
 10    38*     of mrds.
 10    39*  9) change(83-02-15,Davids), approve(), audit(), install():
 10    40*     added the rollback_on flag to the db_type_flags since it appears that you
 10    41*     can have a dmfile database that requires transactions but does not have any
 10    42*     journalizing. Also switched the order of the transactions_needed and
 10    43*     concurrency_on flags - this makes the change compatable with existing
 10    44*     dmfile databases except when displaying the model since concurrency_on and
 10    45*     rollback_on will be off in the model even though the dmfile relations had
 10    46*     them on during creation.
 10    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
 10    48*      Removed ctl_file_path_ptr.
 10    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
 10    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 10    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
 10    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
 10    53*      in the flag word for rmdb copying.
 10    54*                                                   END HISTORY COMMENTS */
 10    55 
 10    56 
 10    57 /* this include file contains the structures that go into the make up
 10    58*   of the "db_model" segment in the model for the database.
 10    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
 10    60*
 10    61*   the db_model structure goes at the base of the segment, and contains items unique to
 10    62*   the whole databse. in addition, it has an area of size to fill the
 10    63*   rest of a segment, that holds the lists of files and domains in the database.
 10    64*   these lists are singly forward linked lists. all "pointers" in the database model
 10    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
 10    66*   since actual pointers are process dependent on segment number.
 10    67*   the remaining structures are first a path_entry one to save pathnames in,
 10    68*   and the stack_item and constent structures, used to save a boolean
 10    69*   expression in polish form, with the stack represented by a linked list.
 10    70*   the final structure is one for identifying the status of version information */
 10    71 
 10    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
 10    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
 10    74 	     2 db_type_flags      unal,
 10    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
 10    76 	       3 unused	      (13) bit (1) unal,
 10    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
 10    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
 10    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
 10    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
 10    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
 10    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
 10    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
 10    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
 10    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
 10    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
 10    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
 10    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
 10    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
 10    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
 10    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
 10    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
 10    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
 10    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
 10    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
 10    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
 10    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
 10    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
 10    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
 10   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
 10   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
 10   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
 10   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
 10   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
 10   105 
 10   106      dcl	   dbm_ptr	      ptr;
 10   107 
 10   108 /* the files in the database each have a file_info containing
 10   109*   their name, the file_model for each file is found by initiating the
 10   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
 10   111*   the file_info list is a singly linked list in definition order */
 10   112 
 10   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
 10   114 	     2 file_name	      char (30),		/* name of file */
 10   115 	     2 file_id	      bit (36),		/* id number of file */
 10   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
 10   117 	     2 unused	      unal bit (18);	/* for future expansion */
 10   118 
 10   119      dcl	   fi_ptr		      ptr;
 10   120 
 10   121 /* each domain used in the database will have a domain info saved in the db_model
 10   122*   segment. it describes the domain of the given name, and it's options.
 10   123*   the domain_info's form a singly linked list in definition order */
 10   124 
 10   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
 10   126 	     2 name	      char (32),		/* name of domain */
 10   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
 10   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
 10   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
 10   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
 10   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
 10   132 	     2 reserved	      bit (31) unal,
 10   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
 10   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
 10   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
 10   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
 10   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
 10   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
 10   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
 10   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
 10   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
 10   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
 10   143 	     2 str_err_path_ptr   unal bit (18),
 10   144 	     2 str_after_path_ptr unal bit (18),
 10   145 	     2 get_before_path_ptr unal bit (18),
 10   146 	     2 get_err_path_ptr   unal bit (18),
 10   147 	     2 get_after_path_ptr unal bit (18),
 10   148 	     2 mod_before_path_ptr unal bit (18),
 10   149 	     2 mod_err_path_ptr   unal bit (18),
 10   150 	     2 mod_after_path_ptr unal bit (18),
 10   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
 10   152 	     2 unused_2	      unal bit (18),
 10   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
 10   154 
 10   155      dcl	   di_ptr		      ptr;
 10   156 
 10   157 /* information necessary for attributes that are not used in any relation */
 10   158 
 10   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
 10   160 	     2 name char (32),			/* name of attribute */
 10   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
 10   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
 10   163 	     2 unused (2) bit (18) unal;
 10   164 
 10   165      dcl     ua_ptr ptr;
 10   166 
 10   167 
 10   168 /* space saving pathname$entryname structure, to be allocated
 10   169*   only when a path$entry has to be saved, else only a bit(18)
 10   170*   offset takes up space in the main model structure */
 10   171 
 10   172      declare 1 path_entry	      based (path_entry_ptr),
 10   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
 10   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
 10   175 	     2 reserved	      unal bit (36);	/* for future use */
 10   176 
 10   177      declare path_entry_ptr	      ptr;
 10   178 
 10   179 
 10   180 
 10   181 
 10   182 
 10   183 /* declarations for model of postfix stack holding the check option boolean expression
 10   184*   the following encoding values indicate the corresponding type of stack element
 10   185*
 10   186*   1  =
 10   187*   2  ^=
 10   188*   3  >
 10   189*   4  <
 10   190*   5  >=
 10   191*   6  <=
 10   192*
 10   193*   10  and
 10   194*   20  or
 10   195*   30  not
 10   196*
 10   197*   40  - (minus)
 10   198*
 10   199*   50  domain variable(same name as domain)
 10   200*
 10   201*   60  constant(number, bit string, or character string)
 10   202*
 10   203**/
 10   204 
 10   205 
 10   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
 10   207 	     2 next	      bit (18),		/* link to next in list */
 10   208 	     2 type	      fixed binary,		/* code for this element type */
 10   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
 10   210*						   if this is a constant element type */
 10   211 
 10   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
 10   213 
 10   214 
 10   215 
 10   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
 10   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
 10   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
 10   219 
 10   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
 10   221 
 10   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
 10   223 
 10   224 /* version structure, giving status of source for CMDB/RMDB,
 10   225*   status of model, and status of resultant */
 10   226 
 10   227 /* version number is in form MM.N.Y
 10   228*   where MM is the major version number, N is the minor version alteration,
 10   229*   and Y is the lastest modification to that alteration,
 10   230*   where M and N represent numbers 0-9, and Y is a letter */
 10   231 
 10   232      declare 1 version_status	      unal based (version_status_ptr),
 10   233 	     2 cmdb_rmdb,
 10   234 	       3 major	      fixed bin,
 10   235 	       3 minor	      fixed bin,
 10   236 	       3 modification     char (4),
 10   237 	     2 model,
 10   238 	       3 major	      fixed bin,
 10   239 	       3 minor	      fixed bin,
 10   240 	       3 modification     char (4),
 10   241 	     2 resultant,
 10   242 	       3 major	      fixed bin,
 10   243 	       3 minor	      fixed bin,
 10   244 	       3 modification     char (4);
 10   245 
 10   246      declare version_status_ptr     ptr;
 10   247 
 10   248 
 10   249 /* maintains information only about the db creation */
 10   250 
 10   251      declare 1 changer	      unal based (changer_ptr),
 10   252 	     2 id		      char (32),
 10   253 	     2 time	      fixed bin (71),
 10   254 	     2 next	      bit (18);		/* to next in the singly linked list */
 10   255 
 10   256      declare changer_ptr	      ptr;
 10   257 
 10   258 
 10   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
 10   260 	     02 len	      fixed bin,		/* length of the message */
 10   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
 10   262 	     02 name	      char (32),		/* name of thing that set the message */
 10   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
 10   264*                                                               that caused the database to become inconsistent */
 10   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
 10   266 
 10   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
 10   268 
 10   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
 10   270 
 10   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
 10   272 
 10   273 
      777 
      778 
 11     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
 11     2 
 11     3 
 11     4 /****^  HISTORY COMMENTS:
 11     5*  1) change(79-02-01,JGray), approve(), audit(), install():
 11     6*     modified to save space occupied by model
 11     7*  2) change(82-05-19,Davids), approve(), audit(), install():
 11     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
 11     9*     the number of secondary indices in the relation - it was always zero.
 11    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
 11    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
 11    12*     DMS conversion.
 11    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
 11    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
 11    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
 11    16*     for relation manager changes.
 11    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
 11    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 11    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
 11    20*     <rel> files are good (for rmdb)
 11    21*                                                   END HISTORY COMMENTS */
 11    22 
 11    23 
 11    24 /* each file in the database will have a model segment with the name
 11    25*   file_name.m (i.e. the files name plus a suffix of ".m")
 11    26*   the file_model structure is allocated at the base of the segment for a given file.
 11    27*   it contains an area with which all other structures in this include file are allocated.
 11    28*   these structures contain the information about which relations, foreign keys,
 11    29*   and attributes are members of this file. all lists are singly linked lists in
 11    30*   definition order. pointers to these structures are obtained by using the "pointer"
 11    31*   builtin function with arguments of the segment base pointer, and the
 11    32*   offset (bit (18)) relative to that pointer that is actually stored in
 11    33*   the file model itself. this is because pointer segment numbers are
 11    34*   per process dependent. the major lists pointed to by the file_model structure
 11    35*   are the list of relations in this file(each with a contained attribute list),
 11    36*   and the list of foreign keys whose parent relation resides in this file
 11    37*   (along with a participating attribute sublist, and the child relation list,
 11    38*   if they are also in this file) */
 11    39 
 11    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
 11    41     2 temporary bit (1) unal,				/* on if file not part of db. */
 11    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
 11    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
 11    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
 11    45     2 reserved bit (32) unal,				/* reserved for future flags */
 11    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
 11    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
 11    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
 11    49     2 pad_1 fixed bin (35),				/* for future use */
 11    50     2 pad_2 fixed bin (35),
 11    51     2 ratd_len fixed bin (21),			/* length of above */
 11    52     2 mratd_len fixed bin (21),			/* length of above */
 11    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
 11    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
 11    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
 11    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
 11    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
 11    58     2 block_size unal fixed bin,			/* no. pages in block */
 11    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
 11    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
 11    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
 11    62     2 num_rels unal fixed bin,			/* number of relations in file */
 11    63     2 num_links unal fixed bin,			/* number of links in file */
 11    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
 11    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
 11    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
 11    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
 11    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
 11    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
 11    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
 11    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
 11    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
 11    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
 11    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
 11    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
 11    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
 11    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
 11    78     2 open_eu_err_path_ptr unal bit (18),
 11    79     2 open_eu_after_path_ptr unal bit (18),
 11    80     2 open_er_before_path_ptr unal bit (18),
 11    81     2 open_er_err_path_ptr unal bit (18),
 11    82     2 open_er_after_path_ptr unal bit (18),
 11    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
 11    84     2 open_neu_err_path_ptr unal bit (18),
 11    85     2 open_neu_after_path_ptr unal bit (18),
 11    86     2 open_ner_before_path_ptr unal bit (18),
 11    87     2 open_ner_err_path_ptr unal bit (18),
 11    88     2 open_ner_after_path_ptr unal bit (18),
 11    89     2 open_pu_before_path_ptr unal bit (18),
 11    90     2 open_pu_err_path_ptr unal bit (18),
 11    91     2 open_pu_after_path_ptr unal bit (18),
 11    92     2 open_pr_before_path_ptr unal bit (18),
 11    93     2 open_pr_err_path_ptr unal bit (18),
 11    94     2 open_pr_after_path_ptr unal bit (18),
 11    95     2 open_cu_before_path_ptr unal bit (18),
 11    96     2 open_cu_err_path_ptr unal bit (18),
 11    97     2 open_cu_after_path_ptr unal bit (18),
 11    98     2 open_cr_before_path_ptr unal bit (18),
 11    99     2 open_cr_err_path_ptr unal bit (18),
 11   100     2 open_cr_after_path_ptr unal bit (18),
 11   101     2 close_before_path_ptr unal bit (18),
 11   102     2 close_err_path_ptr unal bit (18),
 11   103     2 close_after_path_ptr unal bit (18),
 11   104     2 unused_1 unal bit (18),				/* for future expansion */
 11   105     2 unused_2 unal bit (18),
 11   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
 11   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
 11   108 dcl  fm_ptr ptr;
 11   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
 11   110 dcl  atd_ptr ptr;
 11   111 dcl  atd_len fixed bin;
 11   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
 11   113     2 ncomponents fixed bin,
 11   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
 11   115 dcl  cna_ptr ptr;
 11   116 dcl  ncomp_init fixed bin;
 11   117 
 11   118 /* a rel_info structure contains information describing a relation.
 11   119*   a relation may only occur in one file, thus there is one rel_info
 11   120*   per relation per database, each stored in the file_model area for
 11   121*   the file that contains it. the list of rel_info's in this file
 11   122*   form a singly linked list in definition order.
 11   123*   the rel_info itself points to a list of the attributes it contains,
 11   124*   and to any parent_link or child_link info's that involve it in a foreign key */
 11   125 
 11   126 dcl 1 rel_info aligned based (ri_ptr),
 11   127     2 name char (32),				/* relation name */
 11   128     2 id  bit (36) aligned,				/* relation id number */
 11   129     2 hashed bit (1) unal,				/* on if hashed */
 11   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
 11   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
 11   132     2 system bit (1) unal,				/* on if dont care how stored */
 11   133     2 indexed bit (1) unal,				/* on if secondary index */
 11   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
 11   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
 11   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
 11   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
 11   138     2 reserved bit (27) unal,				/* for future flags */
 11   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
 11   140     2 num_links_child unal fixed bin,			/* no. links in which child */
 11   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
 11   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
 11   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
 11   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
 11   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
 11   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
 11   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
 11   148     2 unused_3 unal fixed bin,			/* element that was never used */
 11   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
 11   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
 11   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
 11   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
 11   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
 11   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
 11   155     2 attr_ptr unal bit (18),				/* to attr. info */
 11   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
 11   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
 11   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
 11   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
 11   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
 11   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
 11   162     2 link_err_path_ptr unal bit (18),
 11   163     2 link_after_path_ptr unal bit (18),
 11   164     2 unlk_before_path_ptr unal bit (18),
 11   165     2 unlk_err_path_ptr unal bit (18),
 11   166     2 unlk_after_path_ptr unal bit (18),
 11   167     2 str_before_path_ptr unal bit (18),
 11   168     2 str_err_path_ptr unal bit (18),
 11   169     2 str_after_path_ptr unal bit (18),
 11   170     2 del_before_path_ptr unal bit (18),
 11   171     2 del_err_path_ptr unal bit (18),
 11   172     2 del_after_path_ptr unal bit (18),
 11   173     2 mod_before_path_ptr unal bit (18),
 11   174     2 mod_err_path_ptr unal bit (18),
 11   175     2 mod_after_path_ptr unal bit (18),
 11   176     2 find_before_path_ptr unal bit (18),
 11   177     2 find_err_path_ptr unal bit (18),
 11   178     2 find_after_path_ptr unal bit (18),
 11   179     2 retr_before_path_ptr unal bit (18),
 11   180     2 retr_err_path_ptr unal bit (18),
 11   181     2 retr_after_path_ptr unal bit (18),
 11   182     2 unused_1 unal bit (18),				/* for future expansion */
 11   183     2 unused_2 unal bit (18),
 11   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
 11   185 dcl  ri_ptr ptr;
 11   186 
 11   187 /* a attr_info structure contains information about an attribute in a given relation.
 11   188*   since attributes may appear in more than one relation, each occurence of an attribute
 11   189*   means that an attr_info for it will be put in that relations sublist of attributes.
 11   190*   the list is singly linked in definition order. the attr_info describes
 11   191*   the data it represents, and how that data is used during a database search. */
 11   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
 11   193     2 name char (32),				/* name of attribute */
 11   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
 11   195     2 index_attr bit (1) unal,			/* on if a secondary index */
 11   196     2 link_attr bit (1) unal,				/* on if participates in link */
 11   197     2 reserved bit (33) unal,
 11   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
 11   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
 11   200     2 key_order unal fixed bin,			/* relative posit. in key */
 11   201     2 bit_offset fixed bin (35),			/* position in tuple */
 11   202     2 bit_length fixed bin (35),			/* length if fixed */
 11   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
 11   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
 11   205     2 domain_ptr unal bit (18),			/* to domain info */
 11   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
 11   207     2 fwd_thread unal bit (18),			/* to next in list */
 11   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
 11   209 dcl  ai_ptr ptr;
 11   210 
 11   211 /* a parent_link_info structure is the carrier of foreign key definition info.
 11   212*   each time a foreign key definition indicates a relation as it's parent,
 11   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
 11   214*   a relation can be parent and/or child in any number of foreign keys.
 11   215*   the parent_link_info structure describes the foreign key, and also points
 11   216*   to a list of the attributes that participate in this foreign key.
 11   217*   (this could be from 1 up to all attributes in the relation)
 11   218*   the attr_list structures are in a singly linked list in definition order
 11   219*   for this purpose. also pointed to is a list of child_link_info's
 11   220*   that describe the child relations in this foreign key. since foreign keys
 11   221*   may span files, not all related child_link_info's have to be in this file's
 11   222*   model area. */
 11   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
 11   224     2 name char (32),				/* name of link */
 11   225     2 singular bit (1) unal,				/* on if system owned link */
 11   226     2 temp bit (1) unal,				/* on if temp. order */
 11   227     2 first bit (1) unal,				/* insertion indicators */
 11   228     2 last bit (1) unal,
 11   229     2 next bit (1) unal,
 11   230     2 prior bit (1) unal,
 11   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
 11   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
 11   233     2 dup_first bit (1) unal,				/* duplicates first */
 11   234     2 dup_last bit (1) unal,				/* duplicates last */
 11   235     2 indexed bit (1) unal,				/* locate parent via index */
 11   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
 11   237     2 thread_36 bit (1) unal,				/* thread size indicators */
 11   238     2 thread_27 bit (1) unal,
 11   239     2 thread_18 bit (1) unal,
 11   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
 11   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
 11   242     2 reserved bit (19) unal,				/* reserved for future flags */
 11   243     2 index_id aligned bit (8),			/* id of index if indexed */
 11   244     2 thread_index unal fixed bin,			/* index to threads in parent */
 11   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
 11   246     2 n_children unal fixed bin,			/* no. children in link */
 11   247     2 child_fn char (30),				/* file name for first child in list */
 11   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
 11   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
 11   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
 11   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
 11   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
 11   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
 11   254     2 sort_err_path_ptr unal bit (18),
 11   255     2 sort_after_path_ptr unal bit (18),
 11   256     2 srch_before_path_ptr unal bit (18),
 11   257     2 srch_err_path_ptr unal bit (18),
 11   258     2 srch_after_path_ptr unal bit (18),
 11   259     2 link_before_path_ptr unal bit (18),
 11   260     2 link_err_path_ptr unal bit (18),
 11   261     2 link_after_path_ptr unal bit (18),
 11   262     2 unlk_before_path_ptr unal bit (18),
 11   263     2 unlk_err_path_ptr unal bit (18),
 11   264     2 unlk_after_path_ptr unal bit (18),
 11   265     2 unused_1 unal bit (18),				/* for future expansion */
 11   266     2 unused_2 unal bit (18),
 11   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
 11   268 dcl  pli_ptr ptr;
 11   269 
 11   270 /* a child_link_info structure is the counter part of a parent_link_info
 11   271*   for foreign key child relations. each time a relation is defined to be
 11   272*   a child in a foreign key, it's list of child_link_infos will be added to.
 11   273*   this list is singly linked in foreign key definition order.
 11   274*   the child_link_info points to a list of participating attributes from the
 11   275*   child relation by means of a singly linked list of attr_list structures
 11   276*   in definition order. the number of attributes in the parent attr_list
 11   277*   and the child attr_list lists are the same with corresponding attr_list
 11   278*   attributes having the same domain. all child_link_infos in this file
 11   279*   are on a seperately linked list. this may not include all
 11   280*   child_link_infos for foreign keys whose parent relation resides in this file,
 11   281*   since foreign keys may span files, and the child_link_info will
 11   282*   reside in the file containing it's associated relation_info. */
 11   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
 11   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
 11   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
 11   286     2 fixed bit (1) unal,				/* on if membership fixed */
 11   287     2 optional bit (1) unal,				/* on if membership optional */
 11   288     2 auto bit (1) unal,				/* on if insertion automatic */
 11   289     2 manual bit (1) unal,				/* on if insertion manual */
 11   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
 11   291     2 range_sel bit (1) unal,				/* on if range type selection */
 11   292     2 key_dup_first bit (1) unal,			/* sort key flags */
 11   293     2 key_dup_last bit (1) unal,
 11   294     2 key_null bit (1) unal,				/* on if null allowed */
 11   295     2 sel_system bit (1) unal,			/* selection criteria flags */
 11   296     2 sel_current bit (1) unal,
 11   297     2 sel_key bit (1) unal,
 11   298     2 sel_proc bit (1) unal,
 11   299     2 no_null bit (1) unal,				/* if null key values not allowed */
 11   300     2 reserved bit (21) unal,
 11   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
 11   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
 11   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
 11   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
 11   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
 11   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
 11   307     2 parent_fn char (30),				/* file name for parent info */
 11   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
 11   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
 11   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
 11   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
 11   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
 11   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
 11   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
 11   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
 11   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
 11   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
 11   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
 11   319     2 link_err_path_ptr unal bit (18),
 11   320     2 link_after_path_ptr unal bit (18),
 11   321     2 unlk_before_path_ptr unal bit (18),
 11   322     2 unlk_err_path_ptr unal bit (18),
 11   323     2 unlk_after_path_ptr unal bit (18),
 11   324     2 srch_before_path_ptr unal bit (18),
 11   325     2 srch_err_path_ptr unal bit (18),
 11   326     2 srch_after_path_ptr unal bit (18),
 11   327     2 unused_1 unal bit (18),				/* for future expansion */
 11   328     2 unused_2 unal bit (18) ;
 11   329 dcl  cli_ptr ptr;
 11   330 
 11   331 /* the attr_list structure is associated with the parent_link_info
 11   332*   and child_link_info structures to represent by means of a singly linked list
 11   333*   the participating attributes from relations in a foreign key.
 11   334*   the parent_link_info has a list for the parent relation,
 11   335*   and the child_link_info has a list for the child relation.
 11   336*   the participating attributes are a subset(not necessary proper) of
 11   337*   those attributes contained in a relation definition.
 11   338*   there are equal numbers of attr_list structures in the parent and
 11   339*   child lists of the same foreign key. the corresponding attributes in these
 11   340*   lists must have the same domain. */
 11   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
 11   342     2 attr_fn char (30),				/* file name for attr. */
 11   343     2 attr_ptr unal bit (18),				/* to attr info block */
 11   344     2 fwd_thread unal bit (18);			/* to next in list */
 11   345 dcl  al_ptr ptr;
 11   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
 11   347     2 ascend bit (1) unal,				/* ascending order */
 11   348     2 descend bit (1) unal,				/* descending order */
 11   349     2 reserved bit (34) unal,
 11   350     2 attr_ptr unal bit (18),				/* to attr info */
 11   351     2 fwd_thread unal bit (18);			/* to next in list */
 11   352 dcl  sk_ptr ptr;
 11   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
 11   354     2 attr_ptr unal bit (18),				/* to attr info */
 11   355     2 fwd_thread unal bit (18);			/* to next in list */
 11   356 dcl  dp_ptr ptr;
 11   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
 11   358     2 link_fn char (30),				/* file name for thru link */
 11   359     2 link_ptr unal bit (18),				/* to parent link info */
 11   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
 11   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
 11   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
 11   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
 11   364     2 fwd_thread unal bit (18);			/* to next in chain */
 11   365 dcl  sc_ptr ptr;
 11   366 
 11   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
 11   368 
 11   369 
      779 
      780 
 12     1 /* BEGIN mdbm_rs_info.incl.pl1 -- jaw, 6/15/78 (from mda, 6/15/77) */
 12     2 
 12     3 dcl 1 rs_info aligned,
 12     4     2 version fixed init (2),				/* must be set to 1 or 2 (Input) */
 12     5     2 flags aligned,
 12     6       3 lock_sw bit (1) unal,				/* Input -- if ="1"b  try to lock record */
 12     7       3 unlock_sw bit (1) unal,			/* Input -- if ="1"b try to unlock record */
 12     8       3 create_sw bit (1) unal,			/* Input--if set creat new record */
 12     9       3 locate_sw bit (1) unal,			/* Input--if set causes current rec to be
 12    10*						   located outside the index by descrip, or created without key */
 12    11       3 inc_ref_count bit (1) unal,			/* Input--bump reference count of record, if stationary */
 12    12       3 dec_ref_count bit (1) unal,			/* Input--decrement ref count if this flag set and
 12    13*						   record stationary */
 12    14       3 locate_pos_sw bit (1) unal,			/* Input--if set the record_length is taken
 12    15*						   as an input arg. spec. the abs. logical record position
 12    16*						   \	  to which both current and next will be set */
 12    17       3 mbz1 bit (29) unal,				/* must be set to "0"b, reserved for future use */
 12    18     2 record_length fixed (21),			/* length in bytes, Input if create_sw set */
 12    19     2 max_rec_len fixed (21),				/* max length of contained record
 12    20*						   Input if create_sw is set--overrides min_block_size */
 12    21     2 record_ptr ptr,				/* points to first byte of record--will be word aligned */
 12    22     2 descriptor fixed (35),				/* Input if locate_sw set and create_sw="0"b */
 12    23     2 ref_count fixed (34),				/* Output--should match number of keys on this record--
 12    24*						   = -1 if non-stationary record */
 12    25     2 time_last_modified fixed (71),			/* Output */
 12    26     2 modifier fixed (35),				/* Output--also Input when locking */
 12    27     2 block_ptr ptr unal,				/* Output */
 12    28     2 mbz2 (2) fixed init (0, 0);
 12    29 
 12    30 /* END mdbm_rs_info.incl.pl1 */
 12    31 
      781 
      782 
 13     1 /* BEGIN - mrds_rmdb_ctl.incl.pl1 */
 13     2 
 13     3 
 13     4 
 13     5 /****^  HISTORY COMMENTS:
 13     6*  1) change(82-03-26,Davids), approve(), audit(), install():
 13     7*     created
 13     8*  2) change(82-05-26,Davids), approve(), audit(), install():
 13     9*     added db_model_ptr
 13    10*  3) change(82-06-09,Harvey), approve(), audit(), install():
 13    11*     deleted ssu_ routines ptr storage
 13    12*  4) change(82-08-20,Davids), approve(), audit(), install():
 13    13*     added the relmgr like reference and included the rmdb_relmgr_entries
 13    14*     include file
 13    15*  5) change(83-05-24,Davids), approve(), audit(), install():
 13    16*     added the saved_res_version_ptr element
 13    17*  6) change(84-10-23,Benjamin), approve(), audit(), install():
 13    18*     added flags (just database_readied_by_rmdb for now).
 13    19*  7) change(85-11-08,Spitzer), approve(85-11-08,MCR7311),
 13    20*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 13    21*     added crossref_file_info.
 13    22*                                                   END HISTORY COMMENTS */
 13    23 
 13    24 
 13    25 dcl 01 rmdb_ctl based (rmdb_ctl_ptr),
 13    26     02 version fixed bin,
 13    27     02 rmdb_version char (16) varying,
 13    28     02 absolute_db_path char (168),
 13    29     02 temp_dir_path char (168),
 13    30     02 work_area_ptr ptr,
 13    31     02 db_model_ptr ptr,
 13    32     02 saved_res_version_ptr ptr,
 13    33     02 crossref_file_info,
 13    34        03 iocb_ptr ptr,
 13    35        03 name char (32),
 13    36     02 relmgr_entries like rmdb_relmgr_entries,
 13    37     02 flags,
 13    38        03 database_readied_by_rmdb bit (1) unal,
 13    39        03 unused bit (35) unal;
 13    40     	
 13    41 dcl  RMDB_CTL_VERSION_1 fixed bin init (1) internal static options (constant);
 13    42 
 13    43 dcl  rmdb_ctl_ptr ptr;
 13    44 
 13    45 
 14     1 /*  START OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 14     2 
 14     3 
 14     4 /****^  HISTORY COMMENTS:
 14     5*  1) change(82-08-20,Davids), approve(), audit(), install():
 14     6*     written
 14     7*  2) change(86-01-28,Spitzer), approve(86-01-28,MCR7311),
 14     8*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
 14     9*     add get_tuples_by_spec, put_tuple, put_tuples, create_cursor entry points.
 14    10*  3) change(86-08-21,Blair), approve(86-08-21,MCR7311),
 14    11*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
 14    12*     Back out the entries get_tuples_by_spec and put_tuples since they aren't
 14    13*     sufficiently well tested to be reliable.  Replace with get_tuple_id and
 14    14*     get_tuple_by_id.
 14    15*                                                   END HISTORY COMMENTS */
 14    16 
 14    17 
 14    18 dcl 01 rmdb_relmgr_entries based (rmdb_relmgr_entries_ptr),
 14    19      02 create_relation entry (char (*), char (*), ptr, ptr, bit (36) aligned,
 14    20 	bit (36) aligned, fixed bin (35)),
 14    21      02 delete_relation entry (char (*), char (*), fixed bin (35)),
 14    22      02 open entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
 14    23      02 close entry (bit (36) aligned, fixed bin (35)),
 14    24      02 create_index entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17),
 14    25 	bit (36) aligned, fixed bin (35)),
 14    26      02 delete_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35)),
 14    27      02 put_tuple entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
 14    28      02 get_tuple_id entry (ptr, ptr, ptr, ptr, fixed bin (35)),
 14    29      02 get_tuple_by_id entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
 14    30      02 create_cursor entry (bit (36) aligned, ptr, ptr, fixed bin (35));
 14    31 
 14    32 dcl rmdb_relmgr_entries_ptr ptr;
 14    33 
 14    34 /*  END OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 13    46 
 13    47 
 13    48 
 13    49 /* END - mrds_rmdb_ctl.incl.pl1 */
      783 
      784 
 15     1 /* BEGIN INCLUDE         rmdb_create_rel_info.incl.pl1                  */
 15     2 
 15     3 /* Contains relation name and all attributes that are associated with the
 15     4*   relation being created.  Attributes which are to be indexed are flagged. */
 15     5 
 15     6 /* HISTORY:
 15     7*   Created 82-03-22 by R. Lackey
 15     8**/
 15     9 
 15    10 
 15    11 dcl 1 rmdb_create_rel_info aligned based (rmdb_create_rel_info_ptr),
 15    12     2 version fixed bin,				/* Version number of this structure */
 15    13     2 db_path char (168),				/* Absolute pathname of database */
 15    14     2 temp_directory_path char (168),			/* Absolute pathname of directory to be used for temp space */
 15    15     2 db_model_ptr ptr,				/* Pointer to db_model */
 15    16     2 relation_name char (32) unal,			/* Name of relation being created */
 15    17     2 num_attrs fixed bin,				/* Number of attributes
 15    18*						   for this relation */
 15    19     2 attrs (rmdb_create_rel_info_alloc			/* Attribute info */
 15    20      refer (rmdb_create_rel_info.num_attrs)) aligned
 15    21      like attr_def_info;
 15    22 
 15    23 
 15    24 dcl 1 attr_def_info based (adi_ptr),			/* Attribute definition info */
 15    25     2 name char (32) unal,				/* Attribute name */
 15    26     2 primary_key bit (1) unal,			/* Primary key attribute */
 15    27     2 indexed bit (1) unal,				/* On => attribute is to be indexed */
 15    28     2 mbz bit (34) unal;				/* For future reference */
 15    29 
 15    30 dcl  adi_ptr pointer;				/* Pointer to attr_def_info structure */
 15    31 dcl  rmdb_create_rel_info_ptr pointer;			/* Based structure pointer */
 15    32 dcl  rmdb_create_rel_info_alloc fixed bin;		/* Allocation size of attribute info for structure */
 15    33 dcl  RMDB_CREATE_REL_INFO_VERSION_1 int static options (constant) init (1);
 15    34 
 15    35 
 15    36 dcl 1 rmdb_ix_attrs aligned based (rmdb_ix_attrs_ptr),	/* List of names of attributes to be indexed */
 15    37     2 version fixed bin,
 15    38     2 relation_name char (32),			/* Name of the relation */
 15    39     2 num_used fixed bin,
 15    40     2 an (rmdb_ix_attrs_alloc refer (rmdb_ix_attrs.num_used)) char (32);
 15    41 
 15    42 dcl  rmdb_ix_attrs_alloc fixed bin;
 15    43 dcl  rmdb_ix_attrs_ptr ptr;
 15    44 dcl  RMDB_IX_ATTRS_VERSION_1 int static options (constant) init (1);
 15    45 
 15    46 dcl 1 rmdb_sel_val_info aligned based (rmdb_sel_val_info_ptr), /* Selection value info */
 15    47     2 version fixed bin,
 15    48     2 sv_num fixed bin,				/* Number of select values */
 15    49     2 data_list_ptr ptr,				/* Pointer to list of ptrs to sv data */
 15    50     2 desc_list_ptr ptr;				/* Pointer to list of ptrs to sv descriptors */
 15    51 
 15    52 dcl  rmdb_sel_val_info_ptr ptr;
 15    53 dcl  RMDB_SEL_VAL_INFO_VERSION_1 int static options (constant) init (1);
 15    54 
 15    55 /* END INCLUDE           rmdb_create_rel_info.incl.pl1                  */
      785 
      786 
 16     1 /*  START OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 16     2 
 16     3 /****^  HISTORY COMMENTS:
 16     4*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
 16     5*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
 16     6*     written.
 16     7*                                                   END HISTORY COMMENTS */
 16     8 
 16     9 /*DESCRIPTION
 16    10*  The following structures are the definition of the records with the keyed
 16    11*  vfile that is built during restructuring. This file serves as a crossreference
 16    12*  of unique attributes and domains used within the specified MRDS database. Each
 16    13*  object is a char (33); the first byte is set to an unprintable character so we
 16    14*  can use the index builtin to find a specific object.
 16    15**/
 16    16 
 16    17 dcl crossref_info_record_ptr ptr;
 16    18 dcl crossref_info_record_count fixed bin (21);
 16    19 dcl 1 crossref_info_record based (crossref_info_record_ptr),
 16    20      2 offset bit (18) unal,
 16    21      2 pad bit (18) unal,
 16    22      2 count fixed bin (21),
 16    23      2 entry (crossref_info_record_count refer (crossref_info_record.count)) unaligned,
 16    24       3 object_head char (1),
 16    25       3 object char (32);
 16    26 
 16    27 dcl crossref_info_record_objects char (33*crossref_info_record.count)
 16    28 			   based (addr (crossref_info_record.entry(1)));
 16    29 dcl OBJECT_HEAD char (1) int static options (constant) init (" ");
 16    30 
 16    31 dcl ATTRIBUTE_KEY_HEAD char (10) int static options (constant) init ("attribute:");
 16    32 dcl DOMAIN_KEY_HEAD char (7) int static options (constant) init ("domain:");
 16    33 dcl RELATION_KEY_HEAD char (9) int static options (constant) init ("relation:");
 16    34 
 16    35 /*DESCRIPTION
 16    36*  The following structures are used to contain sufficient crossreference
 16    37*  information for the delete_attribute and delete_domain requests. These
 16    38*  requests require a more complete view of a crossreference tree, associating
 16    39*  domains, attributes and relations in 2 directions.
 16    40**/
 16    41 
 16    42 dcl domain_list_ptr ptr;
 16    43 dcl domain_list_count fixed bin;
 16    44 dcl domain_list_names char (33*domain_list.count) based (addr (domain_list.name(1)));
 16    45 dcl 1 domain_list based (domain_list_ptr),
 16    46      2 count fixed bin,				/* number of domains in the list */
 16    47      2 name (domain_list_count refer (domain_list.count))
 16    48 	  char (33) unaligned,			/* name of this domain */
 16    49      2 attribute_list_ptr (domain_list_count refer (domain_list.count))
 16    50 		      ptr;			/* -> attribute_list structure */
 16    51 
 16    52 dcl attribute_list_ptr ptr;
 16    53 dcl attribute_list_count fixed bin;
 16    54 dcl attribute_list_names char (33*attribute_list.count) based (addr (attribute_list.name(1)));
 16    55 dcl 1 attribute_list based (attribute_list_ptr),
 16    56      2 count fixed bin,				/* number of attributes in the list */
 16    57      2 name (attribute_list_count refer (attribute_list.count))
 16    58 	  char (33) unaligned,			/* name of this attribute */
 16    59      2 domain_info_ptr (attribute_list_count refer (attribute_list.count))
 16    60 		   bit (18) unal,			/* offset in db_model of the domain_info structure for this attribute */
 16    61      2 attribute_ptr (attribute_list_count refer (attribute_list.count))
 16    62 		 ptr;				/* -> attribute structure */
 16    63 
 16    64 dcl relation_list_ptr ptr;
 16    65 dcl relation_list_count fixed bin;
 16    66 dcl relation_list_names char (33*relation_list.count) based (addr (relation_list.name (1)));
 16    67 dcl 1 relation_list based (relation_list_ptr),
 16    68      2 count fixed bin,				/* number of relations that are to be touched in this operation */
 16    69      2 name (relation_list_count refer (relation_list.count))
 16    70 	  char (33) unaligned,			/* name of this relation */
 16    71      2 relation_ptr (relation_list_count refer (relation_list.count))
 16    72 		ptr;				/* -> relation structure */
 16    73 
 16    74 dcl relation_ptr ptr;
 16    75 dcl relation_attribute_count fixed bin;
 16    76 dcl relation_attribute_names char (33*relation.attribute_count) based (addr (relation.attribute_names (1)));
 16    77 dcl 1 relation based (relation_ptr),
 16    78      2 name char (32),				/* name of the relation */
 16    79      2 file_model_ptr ptr,				/* -> relation.m segment */
 16    80      2 copy_file_model_ptr ptr,
 16    81      2 attribute_count fixed bin,			/* number of attributes defined for this relation */
 16    82      2 mbz fixed bin (35),
 16    83      2 attribute (relation_attribute_count refer (relation.attribute_count)),
 16    84       3 flags aligned,
 16    85         4 delete bit (1) unaligned,			/* ON: delete this attribute */
 16    86         4 new bit (1) unaligned,			/* ON: this attribute is added to the relation */
 16    87         4 part_of_key bit (1) unaligned,                    /* ON: this attribute is part of the primary key */
 16    88         4 to_be_deleted bit (1) unaligned,
 16    89         4 pad bit (32) unaligned,
 16    90       3 domain_info_ptr bit (18) aligned,		/* -> db_model domain_info structure */
 16    91       3 attribute_info_ptr ptr,			/* -> file_model attribute_info structure */
 16    92       3 value_ptr ptr,				/* if flags.new, this -> the value of the column to be stored */
 16    93 						/*   it must be of the correct data type as specified by the domain */
 16    94      2 attribute_names (relation_attribute_count refer (relation.attribute_count))
 16    95 		   char (33) unaligned;
 16    96 
 16    97 dcl attribute_ptr ptr;
 16    98 dcl attribute_count fixed bin;
 16    99 dcl 1 attribute based (attribute_ptr),
 16   100      2 count fixed bin,				/* number of relations this attribute is used in */
 16   101      2 relation_idx (attribute_count refer (attribute.count))
 16   102 		fixed bin;			/* index into list of relation names */
 16   103 
 16   104 /*  END OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      787 
      788 
 17     1 /*  BEGIN INCLUDE         rmdb_delete_rel_info.incl.pl1	     */
 17     2 
 17     3 /* Contains name of relation to be deleted
 17     4*   dtabase_pathname
 17     5*   and arugment flags  like -force
 17     6**/
 17     7 
 17     8 /* HISTORY
 17     9*   82-04-30  Created  by Roger Lackey
 17    10*
 17    11*   82-06-25  Roger Lackey: Changed force bit to brief
 17    12**/
 17    13 
 17    14 
 17    15 dcl 1 rmdb_delete_rel_info aligned based (rmdb_delete_rel_info_ptr),
 17    16     2 version fixed bin,
 17    17     2 absolute_db_path char (168),			/* Absolute database pathname */
 17    18     2 db_model_ptr ptr,				/* Pointer to db_model */
 17    19     2 relation_name char (32),			/* Name of relation to be deleted */
 17    20     2 brief bit (1) unal,				/* On => Brief option */
 17    21     2 mbz bit (35) unal init ("0"b);			/* For future use */
 17    22 
 17    23 dcl  rmdb_delete_rel_info_ptr ptr;
 17    24 dcl  RMDB_DELETE_REL_INFO_VERSION_1 fixed bin int static options (constant) init (1);
 17    25 
 17    26 /*  END  INCLUDE         rmdb_delete_rel_info.incl.pl1	     */
      789 
      790 
 18     1 /* BEGIN INCLUDE FILE rmdb_history_entry.incl.pl1 -- nsd, 82-04-09 */
 18     2 
 18     3 
 18     4 
 18     5 /****^  HISTORY COMMENTS:
 18     6*  1) change(75-01-01,WhoKnows), approve(), audit(), install():
 18     7*     Written.
 18     8*  2) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
 18     9*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 18    10*     Added RMDB_ADD_(ATTR DMN)_OP, RMDB_RN_(ATTR DMN REL)_OP.
 18    11*                                                   END HISTORY COMMENTS */
 18    12 
 18    13 
 18    14 /*
 18    15*   This include file contains the rmdb_history_entry structure which
 18    16*   is  used for maintaining a history of the databases restructuring
 18    17*   events. It also contains a set of constants used in  loading  the
 18    18*   structure.
 18    19*
 18    20*   The restructuring history is applied against the  database  as  a
 18    21*   whole  instead of against each structure in the db_model and file
 18    22*   models which was the approach originally  implemented  but  never
 18    23*   really  used  (except  to  record the database creation). This is
 18    24*   because 1 database restructuring event, i.e. adding a  new  index
 18    25*   to a relation will change several of the structures in the model.
 18    26*
 18    27*   For a detailed explaination of the use of this structure and  the
 18    28*   constants see the rmdb_add_rmdb_event module.
 18    29**/
 18    30 
 18    31 dcl 01 rmdb_history_entry aligned based (rmdb_history_entry_ptr),
 18    32     02 user_id char (32),				/* person_id.project_id.tag */
 18    33     02 date_time_restructured fixed bin (71),
 18    34     02 type_of_object_restructured fixed bin,		/* taken from constants below */
 18    35     02 object_name char (32),
 18    36     02 operation fixed bin,				/* taken from constants below */
 18    37     02 secondary_object_name char (32),			/* i.e. name of attr just indexed in a restructured relation */
 18    38     02 offset_to_next_entry bit (18) unal,
 18    39     02 offset_to_previous_entry bit (18) unal;
 18    40 	
 18    41 
 18    42 dcl  rmdb_history_entry_ptr ptr;
 18    43 
 18    44 
 18    45 dcl  RMDB_DOMAIN_TYPE init (1) fixed bin internal static options (constant);
 18    46 dcl  RMDB_ATTR_TYPE init (2) fixed bin internal static options (constant);
 18    47 dcl  RMDB_REL_TYPE init (3) fixed bin internal static options (constant);
 18    48 
 18    49 
 18    50 dcl  RMDB_ADD_REL_OP init (1) fixed bin internal static options (constant);
 18    51 dcl  RMDB_DEL_REL_OP init (2) fixed bin internal static options (constant);
 18    52 dcl  RMDB_ADD_IDX_OP init (3) fixed bin internal static options (constant);
 18    53 dcl  RMDB_DEL_IDX_OP init (4) fixed bin internal static options (constant);
 18    54 dcl  RMDB_ADD_ATTR_OP init (5) fixed bin int static options (constant);
 18    55 dcl  RMDB_DEL_ATTR_OP init (6) fixed bin int static options (constant);
 18    56 dcl  RMDB_ADD_DMN_OP init (7) fixed bin int static options (constant);
 18    57 dcl  RMDB_DEL_DMN_OP init (8) fixed bin int static options (constant);
 18    58 dcl  RMDB_RN_ATTR_OP init (9) fixed bin int static options (constant);
 18    59 dcl  RMDB_RN_DMN_OP init (10) fixed bin int static options (constant);
 18    60 dcl  RMDB_RN_REL_OP init (11) fixed bin int static options (constant);
 18    61 
 18    62 /* END INCLUDE FILE rmdb_history_entry.incl.pl1 */
      791 
      792 
 19     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
 19     2 /* format: style2,^inddcls,idind32 */
 19     3 
 19     4 declare 1 terminate_file_switches	based,
 19     5 	2 truncate		bit (1) unaligned,
 19     6 	2 set_bc			bit (1) unaligned,
 19     7 	2 terminate		bit (1) unaligned,
 19     8 	2 force_write		bit (1) unaligned,
 19     9 	2 delete			bit (1) unaligned;
 19    10 
 19    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
 19    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
 19    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
 19    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
 19    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
 19    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
 19    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
 19    18 
 19    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      793 
      794 
 20     1 /* ***********************************************************
 20     2*   *                                                         *
 20     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
 20     4*   *                                                         *
 20     5*   *********************************************************** */
 20     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
 20     7 
 20     8 /* Written by Lindsey Spratt, 03/04/82.
 20     9*Modified:
 20    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
 20    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
 20    12*	  the print_vector value (char varying), ptr to the typed_vector
 20    13*	  value location, and a code. cv_to_print now takes ptr to the
 20    14*	  descriptor, ptr to the typed_vector value, the print_vector value
 20    15*	  (char(*) varying), the maximum allowed length for the print_vector
 20    16*	  value, a temp_seg to put the value in if its to big to fit into
 20    17*	  the print_vector, and a code.
 20    18**/
 20    19 
 20    20 /* format: style2,ind3 */
 20    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
 20    22 	     2 version	      fixed bin (35),
 20    23 	     2 number_of_dimensions
 20    24 			      fixed bin (17),
 20    25 	     2 number_of_vectors  fixed bin (17),
 20    26 	     2 number_of_vector_slots
 20    27 			      fixed bin (17),
 20    28 	     2 maximum_dimension_name_length
 20    29 			      fixed bin (17),
 20    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
 20    31 	       3 name	      char (tva_maximum_dimension_name_length
 20    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
 20    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
 20    34 						/* temp_seg_ptr, max_length_for_print_value, */
 20    35 						/* print_value, code) */
 20    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
 20    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
 20    38 						/* print_value_ptr, typed_value_ptr, code) */
 20    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
 20    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
 20    41 			      pointer;
 20    42 
 20    43      dcl	   typed_vector_array_ptr ptr;
 20    44      dcl	   tva_number_of_vector_slots
 20    45 			      fixed bin;
 20    46      dcl	   tva_number_of_dimensions
 20    47 			      fixed bin;
 20    48      dcl	   tva_maximum_dimension_name_length
 20    49 			      fixed bin;
 20    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
 20    51 			      fixed bin (35) int static options (constant) init (2);
 20    52 
 20    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
      795 
      796 
      797      end rmdb_create_relation;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/09/86  1234.8  rmdb_create_relation.pl1          >spec>install>1237>rmdb_create_relation.pl1
261          1    02/05/86  1416.4  mrds_start_transaction.incl.pl1   >ldd>include>mrds_start_transaction.incl.pl1
1-79         2    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
1-81         3    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
295          4    02/05/86  1416.4  mrds_finish_transaction.incl.pl1  >ldd>include>mrds_finish_transaction.incl.pl1
767          5    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
769          6    01/07/85  0901.1  dm_file_create_info.incl.pl1      >ldd>include>dm_file_create_info.incl.pl1
771          7    10/14/83  1609.1  dm_id_list.incl.pl1               >ldd>include>dm_id_list.incl.pl1
773          8    10/14/83  1609.1  dm_rel_creation_info.incl.pl1     >ldd>include>dm_rel_creation_info.incl.pl1
775          9    10/14/83  1609.1  dm_relation_index_flags.incl.pl1  >ldd>include>dm_relation_index_flags.incl.pl1
777         10    10/17/86  1404.3  mdbm_db_model.incl.pl1            >ldd>include>mdbm_db_model.incl.pl1
779         11    10/17/86  1404.5  mdbm_file_model.incl.pl1          >ldd>include>mdbm_file_model.incl.pl1
781         12    10/14/83  1609.0  mdbm_rs_info.incl.pl1             >ldd>include>mdbm_rs_info.incl.pl1
783         13    10/17/86  1404.4  mrds_rmdb_ctl.incl.pl1            >ldd>include>mrds_rmdb_ctl.incl.pl1
13-46       14    10/17/86  1404.6  rmdb_relmgr_entries.incl.pl1      >ldd>include>rmdb_relmgr_entries.incl.pl1
785         15    10/14/83  1609.0  rmdb_create_rel_info.incl.pl1     >ldd>include>rmdb_create_rel_info.incl.pl1
787         16    10/17/86  1404.6  rmdb_crossref_info.incl.pl1       >ldd>include>rmdb_crossref_info.incl.pl1
789         17    10/14/83  1609.0  rmdb_delete_rel_info.incl.pl1     >ldd>include>rmdb_delete_rel_info.incl.pl1
791         18    10/17/86  1404.4  rmdb_history_entry.incl.pl1       >ldd>include>rmdb_history_entry.incl.pl1
793         19    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
795         20    10/14/83  1609.1  vu_typed_vector_array.incl.pl1    >ldd>include>vu_typed_vector_array.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTRIBUTE_KEY_HEAD              000004 constant        char(10)                 initial unaligned dcl 16-31 set ref 402* 421*
FILE_CREATE_INFO_VERSION_2      000010 constant        char(8)                  initial dcl 6-43 ref 531
ID_LIST_VERSION_1                      constant        fixed bin(17,0)          initial dcl 7-23 ref 505
I_called_from_request_level            parameter       bit(1)                   unaligned dcl 90 ref 22 101
I_rmdb_create_rel_info_ptr             parameter       pointer                  dcl 88 ref 22 99
I_rmdb_ctl_ptr                         parameter       pointer                  dcl 89 ref 22 100
NULL_OFFSET                            constant        bit(18)                  initial unaligned dcl 735 ref 204 226 245 434
O_err_code                             parameter       fixed bin(35,0)          dcl 93 set ref 22 103* 214* 293 297* 608*
O_err_msg                              parameter       char                     unaligned dcl 92 set ref 22 102* 212* 298* 609*
RELATION_KEY_HEAD               000001 constant        char(9)                  initial unaligned dcl 16-33 set ref 240*
REL_CREATION_INFO_VERSION_2     001022 automatic       fixed bin(35,0)          initial dcl 8-11 set ref 8-11* 527
RMDB_ADD_REL_OP                 000047 constant        fixed bin(17,0)          initial dcl 18-50 set ref 275*
RMDB_CREATE_REL_INFO_VERSION_1         constant        fixed bin(17,0)          initial dcl 15-33 ref 132
RMDB_DELETE_REL_INFO_VERSION_1         constant        fixed bin(17,0)          initial dcl 17-24 ref 627
RMDB_DEL_REL_OP                 000050 constant        fixed bin(17,0)          initial dcl 18-51 set ref 667*
RMDB_REL_TYPE                   000045 constant        fixed bin(17,0)          initial dcl 18-47 set ref 275* 667*
RW_ACCESS                       000012 constant        bit(3)                   initial unaligned dcl 5-11 set ref 192*
R_ACCESS                        000037 constant        bit(3)                   initial unaligned dcl 5-11 set ref 171* 482*
TERM_FILE_TERM                  000000 constant        bit(3)                   initial unaligned dcl 19-14 set ref 174* 644*
TM_NORMAL_MODE                  000047 constant        fixed bin(17,0)          initial dcl 2-15 set ref 1-99*
TYPED_VECTOR_ARRAY_VERSION_2           constant        fixed bin(35,0)          initial dcl 20-50 ref 507
WORD                            006314 constant        fixed bin(17,0)          initial dcl 389 ref 466 468 468
absolute_db_path          1     000722 automatic       char(168)                level 2 dcl 763 set ref 628*
add_history_code                001174 automatic       fixed bin(35,0)          dcl 664 set ref 667*
add_history_err_msg             001175 automatic       char(500)                unaligned dcl 665 set ref 667*
addr                                                   builtin function         dcl 679 ref 1-123 1-123 394 416 416 518 544 634 634
adjust_bit_count_               000040 constant        entry                    external dcl 680 ref 284 287
ai_ptr                          001042 automatic       pointer                  dcl 11-209 set ref 509* 512 514 516 517 519* 519
                                                                                  575* 577 579 580 586* 586
amount_to_pad                   001124 automatic       fixed bin(17,0)          dcl 390 set ref 466* 468* 470 471
any_other                       000144 stack reference condition                dcl 681 ref 260
area                            000152 stack reference condition                dcl 682 ref 211 222
attr_def_info                          based           structure                level 1 packed unaligned dcl 15-24
attr_info                              based           structure                level 1 dcl 11-192
attr_name                       000160 automatic       varying char(32)         dcl 683 set ref 326* 327 329 334 339 344 345 345
attr_ptr                 24(18)        based           bit(18)                  level 2 packed unaligned dcl 11-126 ref 509 575
attrs                   141            based           structure                array level 2 dcl 15-11 set ref 416 416
based_char8                            based           char(8)                  unaligned dcl 684 set ref 186*
bcnt                            000171 automatic       fixed bin(35,0)          dcl 685 set ref 284* 287*
blocking_factor           3            based           fixed bin(17,0)          initial level 2 dcl 6-21 set ref 523* 533*
brief                    66     000722 automatic       bit(1)                   level 2 packed unaligned dcl 763 set ref 631*
called_from_request_level       000172 automatic       bit(1)                   unaligned dcl 686 set ref 101* 114
caller_name                     000173 automatic       char(20)                 unaligned dcl 687 set ref 488* 489* 642*
ci_size_in_bytes          2            based           fixed bin(35,0)          initial level 2 dcl 6-21 set ref 523* 532*
cism_info_ptr             6            based           pointer                  level 2 dcl 8-4 set ref 529*
cleanup                         000200 stack reference condition                dcl 688 ref 130 255
close                   166            based           entry variable           level 3 dcl 13-25 ref 590
code                            000216 automatic       fixed bin(35,0)          dcl 690 set ref 171* 192* 193 193* 195* 197 197*
                                                                                  240* 241 241* 275* 282 282* 284* 285 285* 287* 288
                                                                                  288* 368* 370 370* 402* 405 405 408 411* 416* 418
                                                                                  418* 421* 424 424* 482* 483* 489* 490 490* 552*
                                                                                  556 556* 561* 564 564* 580* 582 582* 590* 591 591*
                                                                                  634* 640
concurrency_on            0(33)        based           bit(1)                   level 3 packed unaligned dcl 10-72 ref 535
condition_info                         based           structure                level 1 dcl 3-14
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 1-77 set ref 1-124 1-129 1-129
continue_to_signal_             000010 constant        entry                    external dcl 1-61 ref 1-137
count                     1            based           fixed bin(21,0)          level 2 dcl 16-19 ref 431
create_index            172            based           entry variable           level 3 dcl 13-25 ref 561 580
create_rel_name                 000206 automatic       char(32)                 unaligned dcl 689 set ref 549* 552*
create_relation         152            based           entry variable           level 3 dcl 13-25 ref 552
crossref_file_info      140            based           structure                level 2 unaligned dcl 13-25
crossref_info_record                   based           structure                level 1 unaligned dcl 16-19
crossref_info_record_ptr        001066 automatic       pointer                  dcl 16-17 set ref 394* 402* 413 431
db_desc                  11            based           bit(36)                  level 2 dcl 10-125 set ref 518
db_model                               based           structure                level 1 dcl 10-72
db_model_ptr            126            based           pointer                  level 2 in structure "rmdb_create_rel_info"
                                                                                  dcl 15-11 in procedure "rmdb_create_relation" ref
                                                                                  112 629
db_model_ptr             54     000722 automatic       pointer                  level 2 in structure "delete_rel_info" dcl 763
                                                                                  in procedure "rmdb_create_relation" set ref 629*
db_path                         000217 automatic       char(168)                unaligned dcl 691 in procedure
                                                                                  "rmdb_create_relation" set ref 110* 171* 192* 193*
                                                                                  193* 284 285* 285* 287 288* 288* 368* 482* 552*
                                                                                  628
db_path                   1            based           char(168)                level 2 in structure "rmdb_create_rel_info"
                                                                                  dcl 15-11 in procedure "rmdb_create_relation" ref
                                                                                  110
db_type_flags             0(18)        based           structure                level 2 packed unaligned dcl 10-72
dbm_area                 34            based           area                     level 2 dcl 10-72 ref 219 457
dbm_ptr                         001026 automatic       pointer                  dcl 10-106 set ref 112* 114 136 187* 195* 204 204
                                                                                  209 219 245 245 249 249 250 250 275* 368* 413 416*
                                                                                  434 434 441 453 457 516 534 535 536 640* 667*
defn_order               12            based           fixed bin(17,0)          level 2 packed unaligned dcl 11-192 ref 514 579
delete_rel_info                 000722 automatic       structure                level 1 dcl 763 set ref 634 634
descriptor_ptr                         based           pointer                  array level 3 dcl 20-21 set ref 518*
di_ptr                          001032 automatic       pointer                  dcl 10-155 set ref 413* 416* 428 516* 518
dimension_table           6            based           structure                array level 2 dcl 20-21
dm_error_$bj_journal_full       000030 external static fixed bin(35,0)          dcl 4-52 ref 1-132
dm_error_$lock_deadlock         000032 external static fixed bin(35,0)          dcl 4-53 ref 4-78 1-126
dm_error_$no_current_transaction
                                000012 external static fixed bin(35,0)          dcl 1-62 ref 1-90
domain_info                            based           structure                level 1 dcl 10-125
domain_ptr               17            based           bit(18)                  level 2 packed unaligned dcl 11-192 ref 516
empty                                                  builtin function         dcl 692 ref 493
err_code                               parameter       fixed bin(35,0)          dcl 604 ref 602 608
err_message                            parameter       char                     unaligned dcl 605 ref 602 609
err_msg                         000271 automatic       char(256)                unaligned dcl 698 set ref 195* 197* 240* 241* 368*
                                                                                  370* 402* 411* 416* 418* 421* 424* 634*
error_table_$action_not_performed
                                000042 external static fixed bin(35,0)          dcl 693 set ref 120*
error_table_$area_too_small     000044 external static fixed bin(35,0)          dcl 694 ref 214
error_table_$long_record        000046 external static fixed bin(35,0)          dcl 695 ref 405
error_table_$no_record          000050 external static fixed bin(35,0)          dcl 696 ref 408
error_table_$unimplemented_version
                                000052 external static fixed bin(35,0)          dcl 697 set ref 132*
esm_info_ptr              4            based           pointer                  level 2 dcl 8-4 set ref 528*
fi_ptr                   22(27)        based           bit(18)                  level 2 in structure "file_model" packed unaligned
                                                                                  dcl 11-40 in procedure "rmdb_create_relation" set
                                                                                  ref 220*
fi_ptr                          001030 automatic       pointer                  dcl 10-119 in procedure "rmdb_create_relation" set
                                                                                  ref 204* 204* 208* 209 219* 220 224 225 226 240
                                                                                  240 245 247
file_create_info                       based           structure                level 1 dcl 6-21 set ref 523
file_create_info_ptr      2            based           pointer                  level 2 in structure "rel_creation_info" dcl 8-4
                                                                                  in procedure "rmdb_create_relation" set ref 530*
file_create_info_ptr            001012 automatic       pointer                  dcl 6-41 in procedure "rmdb_create_relation" set ref
                                                                                  523* 530 531 532 533 534 535 536 537 538 539 540
file_id                  10            based           bit(36)                  level 2 dcl 10-113 set ref 225*
file_info                              based           structure                level 1 dcl 10-113 set ref 219
file_model                             based           structure                level 1 dcl 11-40
file_model_name                 000371 automatic       char(32)                 unaligned dcl 699 set ref 481* 482* 483
file_model_ptr                  000402 automatic       pointer                  dcl 700 set ref 108* 192* 195* 220 416* 463 463
file_name                              based           char(30)                 level 2 dcl 10-113 set ref 224*
file_ptr                 22            based           bit(18)                  level 2 packed unaligned dcl 10-72 set ref 204 245
                                                                                  245*
find_condition_info_            000014 constant        entry                    external dcl 1-64 ref 1-123
first_char                      000404 automatic       char(1)                  unaligned dcl 701 set ref 143* 145 149 153 327* 329
                                                                                  334 339
flag_list                       000405 automatic       bit(36)                  dcl 703 set ref 544 561* 580*
flags                     4            based           structure                level 2 packed unaligned dcl 6-21
fm_ptr                          001036 automatic       pointer                  dcl 11-108 set ref 129* 171* 173 174* 482* 483 485
                                                                                  485 509 519 575 586 635* 644 644*
fwd_ptr                  11            based           bit(18)                  level 2 packed unaligned dcl 10-113 set ref 209 226*
                                                                                  247*
fwd_thread               20            based           bit(18)                  level 2 in structure "attr_info" packed unaligned
                                                                                  dcl 11-192 in procedure "rmdb_create_relation" ref
                                                                                  519 586
fwd_thread               10(18)        based           bit(18)                  level 2 in structure "unreferenced_attribute" packed
                                                                                  unaligned dcl 10-159 in procedure
                                                                                  "rmdb_create_relation" set ref 441 453 455* 455
i                               000406 automatic       fixed bin(17,0)          dcl 709 set ref 395* 402 408 416 416 421 438* 510*
                                                                                  517 518* 576*
id                        2            based           fixed bin(17,0)          array level 2 in structure "id_list" dcl 7-16
                                                                                  in procedure "rmdb_create_relation" set ref 514*
                                                                                  579*
id                       10            based           bit(36)                  level 2 in structure "rel_info" dcl 11-126
                                                                                  in procedure "rmdb_create_relation" set ref 552*
id_list                                based           structure                level 1 dcl 7-16 set ref 503
id_list_ptr                     001014 automatic       pointer                  initial dcl 7-21 set ref 7-21* 503* 504 505 513 513
                                                                                  514 514 561* 573 579 580*
il_number_of_ids                001016 automatic       fixed bin(17,0)          initial dcl 7-22 set ref 7-22* 502* 503 503
index_attr               10(01)        based           bit(1)                   level 2 packed unaligned dcl 11-192 ref 577
index_id                 11            based           bit(36)                  level 2 dcl 11-192 set ref 580*
index_is_clustering       0(01)        based           bit(1)                   level 2 packed unaligned dcl 9-16 set ref 546*
index_is_unique           0(02)        based           bit(1)                   level 2 packed unaligned dcl 9-16 set ref 547* 571*
initiate_file_                  000062 constant        entry                    external dcl 707 ref 171 482
initiate_file_$create           000064 constant        entry                    external dcl 708 ref 192
iocb_ptr                140            based           pointer                  level 3 dcl 13-25 set ref 107 368* 372 636*
j                               000407 automatic       fixed bin(17,0)          dcl 710 set ref 318* 320 320*
key_attr                 10            based           bit(1)                   level 2 packed unaligned dcl 11-192 ref 512
last_fi_ptr                     000410 automatic       pointer                  dcl 711 set ref 208* 247
long_err_msg                    000412 automatic       char(500)                unaligned dcl 712 set ref 275* 282*
max_data_len             17            based           fixed bin(35,0)          level 2 dcl 11-126 set ref 471* 471
maximum_dimension_name_length
                          4            based           fixed bin(17,0)          level 2 dcl 20-21 set ref 500* 517 517 517 518 518
                                                                                  518
mbz                      66(01) 000722 automatic       bit(35)                  initial level 2 packed unaligned dcl 763 set ref
                                                                                  632* 763*
mbz2                     14     001044 automatic       fixed bin(17,0)          initial array level 2 dcl 12-3 set ref 12-3* 12-3*
mbz_1                     4(03)        based           bit(15)                  initial level 3 packed unaligned dcl 6-21 set ref
                                                                                  523* 537*
mbz_2                     6            based           fixed bin(71,0)          array level 2 dcl 6-21 set ref 539*
mbz_3                     4(26)        based           bit(46)                  initial level 2 packed unaligned dcl 6-21 set ref
                                                                                  523* 540*
mdbm_util_$free_temp_segment    000120 constant        entry                    external dcl 727 ref 642
mdbm_util_$get_temp_segment_path
                                000054 constant        entry                    external dcl 704 ref 489
mdbm_util_$inconsistent_reset   000122 constant        entry                    external dcl 728 ref 640
mdbm_util_$inconsistent_set     000124 constant        entry                    external dcl 729 ref 187
mdbm_util_$xref_build           000126 constant        entry                    external dcl 730 ref 368
mdbm_util_$xref_create_record   000056 constant        entry                    external dcl 705 ref 240
mdbm_util_$xref_destroy         000060 constant        entry                    external dcl 706 ref 636
mdbm_util_$xref_find_record     000130 constant        entry                    external dcl 731 ref 402
mdbm_util_$xref_reference       000132 constant        entry                    external dcl 732 ref 421
mftxn_code                      000142 automatic       fixed bin(35,0)          dcl 4-54 set ref 293* 4-62* 4-65 4-68* 4-69 4-78
                                                                                  4-115 297 1-126* 1-132*
mftxn_temp_code                 000143 automatic       fixed bin(35,0)          dcl 4-55 set ref 4-71* 4-72 4-72* 4-82* 4-83 4-85*
                                                                                  4-86 4-86* 4-96* 4-97 4-99* 4-100 4-100* 4-109*
                                                                                  4-110 4-110*
mod                                                    builtin function         dcl 733 ref 466 468
mrds_data_$max_relations        000066 external static fixed bin(35,0)          dcl 713 ref 136
mrds_data_$relation_blocking_factor
                                000070 external static fixed bin(17,0)          dcl 714 ref 533
mrds_data_$valid_rel_and_attr_name_chars
                                000072 external static varying char(128)        dcl 715 ref 158 344
mrds_error_$bad_attr_name       000074 external static fixed bin(35,0)          dcl 716 set ref 345*
mrds_error_$bad_rel_name        000076 external static fixed bin(35,0)          dcl 717 set ref 159*
mrds_error_$dup_rel             000100 external static fixed bin(35,0)          dcl 718 set ref 175*
mrds_error_$inv_attr_name_first_char
                                000102 external static fixed bin(35,0)          dcl 719 set ref 329* 334* 339*
mrds_error_$inv_rel_name_first_char
                                000104 external static fixed bin(35,0)          dcl 720 set ref 145* 149* 153*
mrds_error_$max_rels            000106 external static fixed bin(35,0)          dcl 721 set ref 136*
mrds_error_$no_primary_key      000110 external static fixed bin(35,0)          dcl 722 set ref 352*
mrds_error_$rst_name_duplicate  000112 external static fixed bin(35,0)          dcl 723 set ref 320*
mrds_error_$rst_reserved_name   000114 external static fixed bin(35,0)          dcl 724 set ref 163*
mrds_error_$undef_attr          000116 external static fixed bin(35,0)          dcl 725 set ref 408*
mstxn_code                      000100 automatic       fixed bin(35,0)          dcl 1-65 set ref 116* 118 1-83* 1-89* 1-90 1-99*
                                                                                  1-140 1-140* 4-90* 4-104* 1-137*
mstxn_condition_info            000110 automatic       structure                level 1 unaligned dcl 1-77 set ref 1-123 1-123
mstxn_retries                   000101 automatic       fixed bin(17,0)          dcl 1-66 set ref 1-88* 4-78 4-81* 4-81
mstxn_temp_code                 000102 automatic       fixed bin(35,0)          dcl 1-67 set ref 1-109* 1-110 1-110* 1-123*
mstxn_transactions_needed       000103 automatic       bit(1)                   dcl 1-68 set ref 115* 126* 1-86
mstxn_txn_id                    000105 automatic       bit(36)                  dcl 1-70 set ref 116* 119* 127* 1-84* 1-89* 1-93
                                                                                  1-94* 1-99* 1-100 4-60 4-68* 4-71* 4-72* 4-82*
                                                                                  4-85* 4-86* 4-96* 4-99* 4-100* 4-109* 4-110*
                                                                                  4-114* 1-107 1-109* 1-110* 1-121
must_delete_relation            000607 automatic       bit(1)                   unaligned dcl 726 set ref 109* 178* 271* 623 669*
name                    142            based           char(32)                 level 3 in structure "rmdb_ctl" packed unaligned
                                                                                  dcl 13-25 in procedure "rmdb_create_relation" set
                                                                                  ref 368* 636*
name                      6            based           varying char             array level 3 in structure "typed_vector_array"
                                                                                  dcl 20-21 in procedure "rmdb_create_relation" set
                                                                                  ref 517*
name                                   based           char(32)                 level 2 in structure "unreferenced_attribute"
                                                                                  dcl 10-159 in procedure "rmdb_create_relation" ref
                                                                                  438
name                                   based           char(32)                 level 2 in structure "attr_info" dcl 11-192
                                                                                  in procedure "rmdb_create_relation" ref 517
name                    141            based           char(32)                 array level 3 in structure "rmdb_create_rel_info"
                                                                                  packed unaligned dcl 15-11 in procedure
                                                                                  "rmdb_create_relation" set ref 320 320 320 326
                                                                                  402* 408 421* 438
no_concurrency            4(01)        based           bit(1)                   initial level 3 packed unaligned dcl 6-21 set ref
                                                                                  523* 535*
no_rollback               4(02)        based           bit(1)                   initial level 3 packed unaligned dcl 6-21 set ref
                                                                                  523* 536*
null                                                   builtin function         dcl 734 ref 108 129 173 7-21 9-24 1-123 1-123 365
                                                                                  421 421 433 434 451 453 483 528 529 635 642 644
num_attr                 12            based           fixed bin(17,0)          level 2 packed unaligned dcl 11-126 ref 498 502 576
num_attrs               140            based           fixed bin(17,0)          level 2 dcl 15-11 ref 314 318 395
num_rels                 14            based           fixed bin(17,0)          level 2 packed unaligned dcl 10-72 set ref 136 250*
                                                                                  250
num_unblk_files          13(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 10-72 set ref 249* 249
number_of_dimensions      1            based           fixed bin(17,0)          level 2 dcl 20-21 set ref 500*
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 7-16 set ref 503* 504* 513* 513 514 573*
number_of_vector_slots
                          3            based           fixed bin(17,0)          level 2 dcl 20-21 set ref 500*
nvar_atts                14(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 11-126 ref 464
offset                                 based           bit(18)                  level 2 packed unaligned dcl 16-19 ref 413
pathname_                       000134 constant        entry                    external dcl 736 ref 193 193 285 285 288 288
prev_ua_ptr                     001126 automatic       pointer                  dcl 391 set ref 433* 440* 453 455
primary_key             151            based           bit(1)                   array level 3 packed unaligned dcl 15-11 set ref 316
primary_key_found               000610 automatic       bit(1)                   unaligned dcl 737 set ref 312* 316* 352
primary_key_index_id     25            based           bit(36)                  level 2 dcl 11-126 set ref 561*
protected                 4            based           bit(1)                   initial level 3 packed unaligned dcl 6-21 set ref
                                                                                  523* 534*
ptr                                                    builtin function         dcl 738 ref 204 209 413 434 441 463 485 509 516 519
                                                                                  575 586
quit                            000612 stack reference condition                dcl 739 ref 234 278 280
quit_intercept_flag             000620 automatic       bit(1)                   unaligned dcl 740 set ref 232* 234* 280
record_buffer                   000622 automatic       fixed bin(35,0)          array dcl 741 set ref 394
rel                                                    builtin function         dcl 742 ref 204 220 240 240 245 247 434
rel_creation_info                      based           structure                level 1 dcl 8-4 set ref 522
rel_creation_info_ptr           001020 automatic       pointer                  dcl 8-10 set ref 522* 527 528 529 530 552*
rel_info                               based           structure                level 1 dcl 11-126
rel_name                        000625 automatic       varying char(32)         dcl 744 set ref 141* 143 145 149 153 158 159 159 163
                                                                                  163 171 175 187 187 192 193 193 224 1-140 212 275
                                                                                  284 285 285 298 481 549 556 564 582 591 630 667
rel_opening_id                  000624 automatic       bit(36)                  dcl 743 set ref 552* 561* 580* 590*
rel_ptr                  20(27)        based           bit(18)                  level 2 packed unaligned dcl 11-40 ref 463 485
relation_index_flags                   based           structure                level 1 dcl 9-16
relation_index_flags_ptr        001024 automatic       pointer                  initial dcl 9-24 set ref 9-24* 544* 545 546 547 571
relation_must_be_empty                 based           bit(1)                   level 2 packed unaligned dcl 9-16 set ref 545*
relation_name           130            based           char(32)                 level 2 in structure "rmdb_create_rel_info" packed
                                                                                  unaligned dcl 15-11 in procedure
                                                                                  "rmdb_create_relation" set ref 136* 141 240* 352*
                                                                                  421*
relation_name            56     000722 automatic       char(32)                 level 2 in structure "delete_rel_info" dcl 763
                                                                                  in procedure "rmdb_create_relation" set ref 630*
relmgr_entries          152            based           structure                level 2 unaligned dcl 13-25
ri_ptr                          001040 automatic       pointer                  dcl 11-185 set ref 463* 464 466 468 470 470 471 471
                                                                                  485* 498 502 509 552 561 575 576
ring_brackets             4(18)        based           fixed bin(3,0)           initial array level 2 packed unaligned dcl 6-21 set
                                                                                  ref 523* 523* 538*
rmdb_add_rmdb_history           000136 constant        entry                    external dcl 745 ref 275 667
rmdb_build_attr_info            000140 constant        entry                    external dcl 746 ref 416
rmdb_create_rel_info                   based           structure                level 1 dcl 15-11
rmdb_create_rel_info_ptr        001064 automatic       pointer                  dcl 15-31 set ref 99* 110 111 112 132 136 141 240
                                                                                  314 316 318 320 320 320 326 352 395 402 408 416
                                                                                  416 421 421 438 629
rmdb_ctl                               based           structure                level 1 unaligned dcl 13-25
rmdb_ctl_ptr                    001062 automatic       pointer                  dcl 13-43 set ref 100* 107 186 368 368 372 552 561
                                                                                  580 590 634* 636 636 636
rmdb_delete_rel_info                   based           structure                level 1 dcl 17-15
rmdb_delete_relation$cleanup    000142 constant        entry                    external dcl 747 ref 634
rmdb_init_file_model            000144 constant        entry                    external dcl 748 ref 195
rmdb_relmgr_entries                    based           structure                level 1 unaligned dcl 14-18
rollback_on               0(32)        based           bit(1)                   level 3 packed unaligned dcl 10-72 ref 536
rs_info                         001044 automatic       structure                level 1 dcl 12-3
rtrim                                                  builtin function         dcl 749 ref 141 187 1-140 298 326 483 549
s                               000636 automatic       fixed bin(17,0)          dcl 750 set ref 158* 159 159 344* 345 345
saved_res_version_ptr
                        136            based           pointer                  level 2 dcl 13-25 ref 186
style                           000637 automatic       fixed bin(17,0)          dcl 751 set ref 543* 561* 580*
substr                                                 builtin function         dcl 752 ref 143 159 327 345
sys_info$max_seg_size           000146 external static fixed bin(35,0)          dcl 753 ref 493
temp_dir_path                   000640 automatic       char(168)                unaligned dcl 754 in procedure
                                                                                  "rmdb_create_relation" set ref 111* 368* 489*
temp_dir_path            60            based           char(168)                level 2 in structure "rmdb_ctl" packed unaligned
                                                                                  dcl 13-25 in procedure "rmdb_create_relation" set
                                                                                  ref 636*
temp_directory_path      53            based           char(168)                level 2 dcl 15-11 ref 111
temp_file_iocb_ptr              000712 automatic       pointer                  dcl 755 set ref 107* 240* 365 372* 402* 421*
temp_seg_ptr                    000714 automatic       pointer                  dcl 756 set ref 108* 489* 492 642 642*
terminate_file_                 000150 constant        entry                    external dcl 757 ref 174 644
this_ua_ptr                     001130 automatic       pointer                  dcl 392 set ref 433* 434 438* 451 453 455 457
transaction_manager_$abandon_txn
                                000016 constant        entry                    external dcl 1-72 ref 4-72 4-86 4-100 4-110 1-110
transaction_manager_$abort_txn  000020 constant        entry                    external dcl 1-73 ref 4-71 4-85 4-99 4-109 1-109
transaction_manager_$begin_txn  000022 constant        entry                    external dcl 1-74 ref 1-99
transaction_manager_$commit_txn 000034 constant        entry                    external dcl 4-56 ref 4-68
transaction_manager_$get_current_txn_id
                                000024 constant        entry                    external dcl 1-75 ref 116 1-89
transaction_manager_$handle_conditions
                                000026 constant        entry                    external dcl 1-76 ref 1-135
transaction_manager_$rollback_txn
                                000036 constant        entry                    external dcl 4-57 ref 4-82 4-96
transactions_needed       0(34)        based           bit(1)                   level 3 packed unaligned dcl 10-72 ref 114 534
tva_maximum_dimension_name_length
                                001074 automatic       fixed bin(17,0)          dcl 20-48 set ref 499* 500 500
tva_number_of_dimensions        001073 automatic       fixed bin(17,0)          dcl 20-46 set ref 498* 500 500 510
tva_number_of_vector_slots      001072 automatic       fixed bin(17,0)          dcl 20-44 set ref 497* 500 500
typed_vector_array                     based           structure                level 1 dcl 20-21 set ref 500
typed_vector_array_ptr          001070 automatic       pointer                  dcl 20-43 set ref 500* 507 517 518 552*
ua_ptr                          001034 automatic       pointer                  dcl 10-165 set ref 434* 434* 438 438 440* 441
unreferenced             10(04)        based           bit(1)                   level 2 packed unaligned dcl 10-125 set ref 428*
unreferenced_attribute                 based           structure                level 1 dcl 10-159 set ref 457
unreferenced_attribute_ptr
                         23            based           bit(18)                  level 2 packed unaligned dcl 10-72 set ref 434 453*
user_started_transaction        000104 automatic       bit(1)                   dcl 1-69 set ref 1-92* 1-98* 4-60
user_transaction_id             000106 automatic       bit(36)                  dcl 1-71 set ref 1-93* 1-100*
var_offset               22            based           fixed bin(35,0)          level 2 dcl 11-126 set ref 466 468 470* 470
verify                                                 builtin function         dcl 758 ref 153 158 339 344
version                         001044 automatic       fixed bin(17,0)          initial level 2 in structure "rs_info" dcl 12-3
                                                                                  in procedure "rmdb_create_relation" set ref 12-3*
version                                based           fixed bin(35,0)          level 2 in structure "typed_vector_array" dcl 20-21
                                                                                  in procedure "rmdb_create_relation" set ref 507*
version                                based           fixed bin(35,0)          level 2 in structure "id_list" dcl 7-16 in procedure
                                                                                  "rmdb_create_relation" set ref 505*
version                                based           char(8)                  level 2 in structure "file_create_info" dcl 6-21
                                                                                  in procedure "rmdb_create_relation" set ref 531*
version                                based           fixed bin(35,0)          level 2 in structure "rel_creation_info" dcl 8-4
                                                                                  in procedure "rmdb_create_relation" set ref 527*
version                                based           fixed bin(17,0)          level 2 in structure "rmdb_create_rel_info"
                                                                                  dcl 15-11 in procedure "rmdb_create_relation" ref
                                                                                  132
version                         000722 automatic       fixed bin(17,0)          level 2 in structure "delete_rel_info" dcl 763
                                                                                  in procedure "rmdb_create_relation" set ref 627*
wa                                     based           area                     dcl 759 set ref 493* 500 503 522 523
work_area_ptr                   000716 automatic       pointer                  dcl 760 set ref 492* 493 500 503 522 523
x                               000720 automatic       fixed bin(17,0)          dcl 761 set ref 314* 316 318 320 320 320 326*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-33
DOMAIN_KEY_HEAD                        internal static char(7)                  initial unaligned dcl 16-32
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
FCI_READ_BRACKET_IDX                   internal static fixed bin(17,0)          initial dcl 6-45
FCI_WRITE_BRACKET_IDX                  internal static fixed bin(17,0)          initial dcl 6-45
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 2-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 2-12
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
OBJECT_HEAD                            internal static char(1)                  initial unaligned dcl 16-29
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
RMDB_ADD_ATTR_OP                       internal static fixed bin(17,0)          initial dcl 18-54
RMDB_ADD_DMN_OP                        internal static fixed bin(17,0)          initial dcl 18-56
RMDB_ADD_IDX_OP                        internal static fixed bin(17,0)          initial dcl 18-52
RMDB_ATTR_TYPE                         internal static fixed bin(17,0)          initial dcl 18-46
RMDB_CTL_VERSION_1                     internal static fixed bin(17,0)          initial dcl 13-41
RMDB_DEL_ATTR_OP                       internal static fixed bin(17,0)          initial dcl 18-55
RMDB_DEL_DMN_OP                        internal static fixed bin(17,0)          initial dcl 18-57
RMDB_DEL_IDX_OP                        internal static fixed bin(17,0)          initial dcl 18-53
RMDB_DOMAIN_TYPE                       internal static fixed bin(17,0)          initial dcl 18-45
RMDB_IX_ATTRS_VERSION_1                internal static fixed bin(17,0)          initial dcl 15-44
RMDB_RN_ATTR_OP                        internal static fixed bin(17,0)          initial dcl 18-58
RMDB_RN_DMN_OP                         internal static fixed bin(17,0)          initial dcl 18-59
RMDB_RN_REL_OP                         internal static fixed bin(17,0)          initial dcl 18-60
RMDB_SEL_VAL_INFO_VERSION_1            internal static fixed bin(17,0)          initial dcl 15-53
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
TERM_FILE_BC                           internal static bit(2)                   initial unaligned dcl 19-12
TERM_FILE_DELETE                       internal static bit(5)                   initial unaligned dcl 19-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 19-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial unaligned dcl 19-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial unaligned dcl 19-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial unaligned dcl 19-15
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 2-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 2-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 2-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 2-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 2-20
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
adi_ptr                                automatic       pointer                  dcl 15-30
al_ptr                                 automatic       pointer                  dcl 11-345
alloc_length                           internal static fixed bin(35,0)          dcl 10-222
atd                                    based           char                     unaligned dcl 11-109
atd_len                                automatic       fixed bin(17,0)          dcl 11-111
atd_ptr                                automatic       pointer                  dcl 11-110
attr_list                              based           structure                level 1 dcl 11-341
attribute                              based           structure                level 1 unaligned dcl 16-99
attribute_count                        automatic       fixed bin(17,0)          dcl 16-98
attribute_list                         based           structure                level 1 unaligned dcl 16-55
attribute_list_count                   automatic       fixed bin(17,0)          dcl 16-53
attribute_list_names                   based           char                     unaligned dcl 16-54
attribute_list_ptr                     automatic       pointer                  dcl 16-52
attribute_ptr                          automatic       pointer                  dcl 16-97
changer                                based           structure                level 1 packed unaligned dcl 10-251
changer_ptr                            automatic       pointer                  dcl 10-256
child_link_info                        based           structure                level 1 dcl 11-283
cli_ptr                                automatic       pointer                  dcl 11-329
cna_ptr                                automatic       pointer                  dcl 11-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 11-112
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
constant                               based           structure                level 1 unaligned dcl 10-216
constant_ptr                           automatic       pointer                  dcl 10-220
crossref_info_record_count             automatic       fixed bin(21,0)          dcl 16-18
crossref_info_record_objects           based           char                     unaligned dcl 16-27
domain_list                            based           structure                level 1 unaligned dcl 16-45
domain_list_count                      automatic       fixed bin(17,0)          dcl 16-43
domain_list_names                      based           char                     unaligned dcl 16-44
domain_list_ptr                        automatic       pointer                  dcl 16-42
dp_ptr                                 automatic       pointer                  dcl 11-356
dup_prev                               based           structure                level 1 dcl 11-353
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 1-63
fixed                                                  builtin function         dcl 702
message_str                            based           structure                level 1 packed unaligned dcl 10-259
message_str_len                        automatic       fixed bin(17,0)          dcl 10-269
message_str_ptr                        automatic       pointer                  dcl 10-267
ncomp_init                             automatic       fixed bin(17,0)          dcl 11-116
parent_link_info                       based           structure                level 1 dcl 11-223
path_entry                             based           structure                level 1 packed unaligned dcl 10-172
path_entry_ptr                         automatic       pointer                  dcl 10-177
pli_ptr                                automatic       pointer                  dcl 11-268
relation                               based           structure                level 1 unaligned dcl 16-77
relation_attribute_count               automatic       fixed bin(17,0)          dcl 16-75
relation_attribute_names               based           char                     unaligned dcl 16-76
relation_list                          based           structure                level 1 unaligned dcl 16-67
relation_list_count                    automatic       fixed bin(17,0)          dcl 16-65
relation_list_names                    based           char                     unaligned dcl 16-66
relation_list_ptr                      automatic       pointer                  dcl 16-64
relation_ptr                           automatic       pointer                  dcl 16-74
rmdb_create_rel_info_alloc             automatic       fixed bin(17,0)          dcl 15-32
rmdb_delete_rel_info_ptr               automatic       pointer                  dcl 17-23
rmdb_history_entry                     based           structure                level 1 dcl 18-31
rmdb_history_entry_ptr                 automatic       pointer                  dcl 18-42
rmdb_ix_attrs                          based           structure                level 1 dcl 15-36
rmdb_ix_attrs_alloc                    automatic       fixed bin(17,0)          dcl 15-42
rmdb_ix_attrs_ptr                      automatic       pointer                  dcl 15-43
rmdb_relmgr_entries_ptr                automatic       pointer                  dcl 14-32
rmdb_sel_val_info                      based           structure                level 1 dcl 15-46
rmdb_sel_val_info_ptr                  automatic       pointer                  dcl 15-52
sc_ptr                                 automatic       pointer                  dcl 11-365
select_chain                           based           structure                level 1 dcl 11-357
sk_ptr                                 automatic       pointer                  dcl 11-352
sort_key                               based           structure                level 1 dcl 11-346
stack_item                             based           structure                level 1 unaligned dcl 10-206
stack_item_ptr                         automatic       pointer                  dcl 10-212
terminate_file_switches                based           structure                level 1 packed unaligned dcl 19-4
version_status                         based           structure                level 1 packed unaligned dcl 10-232
version_status_ptr                     automatic       pointer                  dcl 10-246

NAMES DECLARED BY EXPLICIT CONTEXT.
add_supplied_attrs              004123 constant        entry                    internal dcl 381 ref 236
build_db_attr_list              004033 constant        entry                    internal dcl 360 ref 199
check_supplied_attr_list        003376 constant        entry                    internal dcl 305 ref 167
create_relation_data_file       004602 constant        entry                    internal dcl 479 ref 269
error                           005761 constant        entry                    internal dcl 602 ref 120 132 136 145 149 153 159 163
                                                                                  175 193 197 241 1-140 282 285 288 320 329 334 339
                                                                                  345 352 370 408 411 418 424 483 490 556 564 582
                                                                                  591
exit                            002745 constant        label                    dcl 293 set ref 216 611
mftxn_check_code                002757 constant        label                    dcl 4-65 ref 1-127 1-133
mftxn_exit                      003177 constant        label                    dcl 4-115 ref 4-63
mstxn_any_other                 003301 constant        entry                    internal dcl 1-116 ref 260
mstxn_cleanup                   003247 constant        entry                    internal dcl 1-102 ref 258
mstxn_exit                      002374 constant        label                    dcl 1-140 ref 1-86 1-95 4-91 4-105
restore_significant_data        006233 constant        entry                    internal dcl 661 ref 4-77
rmdb_create_relation            000524 constant        entry                    external dcl 22
should_rollback                 006271 constant        entry                    internal dcl 674 ref 4-94
tidy_up                         006022 constant        entry                    internal dcl 621 ref 130 215 257 290 610

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7234        7406    6321        7244
Length     10354    6321       152         731     712           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rmdb_create_relation               1146 external procedure  is an external procedure.  
on unit on line 130                  64 on unit               
on unit on line 211                  66 on unit               
on unit on line 234                  64 on unit               
on unit on line 255                  76 on unit               
on unit on line 260                  82 on unit               
mstxn_cleanup                           internal procedure  shares stack frame of on unit on line 255.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 260.  
check_supplied_attr_list                internal procedure  shares stack frame of external procedure rmdb_create_relation.  
build_db_attr_list                      internal procedure  shares stack frame of external procedure rmdb_create_relation.  
add_supplied_attrs                      internal procedure  shares stack frame of external procedure rmdb_create_relation.  
create_relation_data_file               internal procedure  shares stack frame of external procedure rmdb_create_relation.  
error                                65 internal procedure  is called during a stack extension.  
tidy_up                             108 internal procedure  is called by several nonquick procedures.  
restore_significant_data                internal procedure  shares stack frame of external procedure rmdb_create_relation.  
should_rollback                         internal procedure  shares stack frame of external procedure rmdb_create_relation.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rmdb_create_relation     000100 mstxn_code                  rmdb_create_relation
                         000101 mstxn_retries               rmdb_create_relation
                         000102 mstxn_temp_code             rmdb_create_relation
                         000103 mstxn_transactions_needed   rmdb_create_relation
                         000104 user_started_transaction    rmdb_create_relation
                         000105 mstxn_txn_id                rmdb_create_relation
                         000106 user_transaction_id         rmdb_create_relation
                         000110 mstxn_condition_info        rmdb_create_relation
                         000142 mftxn_code                  rmdb_create_relation
                         000143 mftxn_temp_code             rmdb_create_relation
                         000160 attr_name                   rmdb_create_relation
                         000171 bcnt                        rmdb_create_relation
                         000172 called_from_request_level   rmdb_create_relation
                         000173 caller_name                 rmdb_create_relation
                         000206 create_rel_name             rmdb_create_relation
                         000216 code                        rmdb_create_relation
                         000217 db_path                     rmdb_create_relation
                         000271 err_msg                     rmdb_create_relation
                         000371 file_model_name             rmdb_create_relation
                         000402 file_model_ptr              rmdb_create_relation
                         000404 first_char                  rmdb_create_relation
                         000405 flag_list                   rmdb_create_relation
                         000406 i                           rmdb_create_relation
                         000407 j                           rmdb_create_relation
                         000410 last_fi_ptr                 rmdb_create_relation
                         000412 long_err_msg                rmdb_create_relation
                         000607 must_delete_relation        rmdb_create_relation
                         000610 primary_key_found           rmdb_create_relation
                         000620 quit_intercept_flag         rmdb_create_relation
                         000622 record_buffer               rmdb_create_relation
                         000624 rel_opening_id              rmdb_create_relation
                         000625 rel_name                    rmdb_create_relation
                         000636 s                           rmdb_create_relation
                         000637 style                       rmdb_create_relation
                         000640 temp_dir_path               rmdb_create_relation
                         000712 temp_file_iocb_ptr          rmdb_create_relation
                         000714 temp_seg_ptr                rmdb_create_relation
                         000716 work_area_ptr               rmdb_create_relation
                         000720 x                           rmdb_create_relation
                         000722 delete_rel_info             rmdb_create_relation
                         001012 file_create_info_ptr        rmdb_create_relation
                         001014 id_list_ptr                 rmdb_create_relation
                         001016 il_number_of_ids            rmdb_create_relation
                         001020 rel_creation_info_ptr       rmdb_create_relation
                         001022 REL_CREATION_INFO_VERSION_2 rmdb_create_relation
                         001024 relation_index_flags_ptr    rmdb_create_relation
                         001026 dbm_ptr                     rmdb_create_relation
                         001030 fi_ptr                      rmdb_create_relation
                         001032 di_ptr                      rmdb_create_relation
                         001034 ua_ptr                      rmdb_create_relation
                         001036 fm_ptr                      rmdb_create_relation
                         001040 ri_ptr                      rmdb_create_relation
                         001042 ai_ptr                      rmdb_create_relation
                         001044 rs_info                     rmdb_create_relation
                         001062 rmdb_ctl_ptr                rmdb_create_relation
                         001064 rmdb_create_rel_info_ptr    rmdb_create_relation
                         001066 crossref_info_record_ptr    rmdb_create_relation
                         001070 typed_vector_array_ptr      rmdb_create_relation
                         001072 tva_number_of_vector_slots  rmdb_create_relation
                         001073 tva_number_of_dimensions    rmdb_create_relation
                         001074 tva_maximum_dimension_name_length
                                                            rmdb_create_relation
                         001124 amount_to_pad               add_supplied_attrs
                         001126 prev_ua_ptr                 add_supplied_attrs
                         001130 this_ua_ptr                 add_supplied_attrs
                         001174 add_history_code            restore_significant_data
                         001175 add_history_err_msg         restore_significant_data

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ent_var        call_ext_out_desc   call_ext_out
call_int_this_desc  call_int_this       call_int_other      return_mac          tra_ext_1           mdfx3
signal_op           enable_op           shorten_stack       ext_entry_desc      int_entry           int_entry_desc
verify_eis          op_alloc_           op_freen_           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
adjust_bit_count_             continue_to_signal_           find_condition_info_          initiate_file_
initiate_file_$create         mdbm_util_$free_temp_segment  mdbm_util_$get_temp_segment_path
mdbm_util_$inconsistent_reset mdbm_util_$inconsistent_set   mdbm_util_$xref_build         mdbm_util_$xref_create_record
mdbm_util_$xref_destroy       mdbm_util_$xref_find_record   mdbm_util_$xref_reference     pathname_
rmdb_add_rmdb_history         rmdb_build_attr_info          rmdb_delete_relation$cleanup  rmdb_init_file_model
terminate_file_               transaction_manager_$abandon_txn
transaction_manager_$abort_txn                              transaction_manager_$begin_txn
transaction_manager_$commit_txn                             transaction_manager_$get_current_txn_id
transaction_manager_$handle_conditions                      transaction_manager_$rollback_txn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$lock_deadlock       dm_error_$no_current_transaction
error_table_$action_not_performed                           error_table_$area_too_small   error_table_$long_record
error_table_$no_record        error_table_$unimplemented_version                          mrds_data_$max_relations
mrds_data_$relation_blocking_factor                         mrds_data_$valid_rel_and_attr_name_chars
mrds_error_$bad_attr_name     mrds_error_$bad_rel_name      mrds_error_$dup_rel
mrds_error_$inv_attr_name_first_char                        mrds_error_$inv_rel_name_first_char
mrds_error_$max_rels          mrds_error_$no_primary_key    mrds_error_$rst_name_duplicate
mrds_error_$rst_reserved_name mrds_error_$undef_attr        sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     22 000517       763 000537    7   21 000541    7   22 000543    8   11 000545    9   24 000547   12    3 000551
     99 000562       100 000566       101 000571       102 000576       103 000603       107 000604       108 000606
    109 000611       110 000612       111 000616       112 000621       114 000623       115 000630       116 000632
    118 000642       119 000644       120 000645       125 000665       126 000666       127 000667       129 000670
    130 000672       132 000714       136 000737       141 000763       143 001004       145 001007       149 001053
    153 001121       158 001174       159 001205       163 001260       167 001330       171 001332       173 001406
    174 001413       175 001442       176 001474       178 001475       186 001477       187 001504       192 001611
    193 001674       195 001743       197 001770       199 002006       204 002007       208 002021       209 002023
    211 002031       212 002045       214 002077       215 002102       216 002107       219 002112       220 002120
    222 002125       224 002126       225 002132       226 002134       232 002136       234 002137       236 002157
    240 002160       241 002220       245 002236       247 002246       249 002251       250 002256       255 002263
    257 002277       258 002304       259 002305       260 002306    1   83 002324    1   84 002325    1   86 002326
 1   88 002330    1   89 002331    1   90 002342    1   92 002346    1   93 002350    1   94 002352    1   95 002353
 1   98 002354    1   99 002355    1  100 002372    1  140 002374       269 002451       271 002453       275 002454
    278 002506       280 002507       282 002514       284 002532       285 002574       287 002651       288 002701
    290 002741       293 002745    4   60 002750    4   62 002755    4   63 002756    4   65 002757    4   68 002761
 4   69 002772    4   71 002774    4   72 003005    4   75 003020    4   77 003021    4   78 003022    4   81 003031
 4   82 003032    4   83 003045    4   85 003047    4   86 003060    4   88 003073    4   90 003074    4   91 003075
 4   93 003076    4   94 003077    4   96 003104    4   97 003120    4   99 003122    4  100 003133    4  102 003146
 4  104 003147    4  105 003150    4  107 003151    4  109 003152    4  110 003163    4  114 003176    4  115 003177
    297 003201       298 003203       300 003245       301 003246    1  102 003247    1  107 003250    1  109 003253
 1  110 003264    1  114 003300    1  116 003301    1  121 003302    1  123 003305    1  124 003324    1  126 003332
 1  127 003335    1  129 003340    1  132 003352    1  133 003355    1  135 003360    1  136 003365    1  137 003366
 1  138 003375       305 003376       312 003377       314 003400       316 003411       318 003420       320 003431
    324 003475       326 003477       327 003533       329 003536       334 003602       339 003650       344 003723
    345 003734       350 004007       352 004012       355 004032       360 004033       365 004034       368 004041
    370 004101       372 004117       373 004122       381 004123       394 004124       395 004126       402 004137
    405 004207       408 004215       411 004246       413 004262       416 004267       418 004326       421 004344
    424 004420       428 004436       431 004441       433 004444       434 004447       438 004465       440 004500
    441 004501       451 004507       453 004513       455 004525       457 004531       460 004533       463 004535
    464 004545       466 004552       468 004565       470 004570       471 004575       474 004601       479 004602
    481 004603       482 004621       483 004660       485 004736       488 004747       489 004752       490 004777
    492 005020       493 005022       497 005026       498 005027       499 005033       500 005035       502 005070
    503 005074       504 005104       505 005105       507 005107       509 005111       510 005117       512 005127
    513 005133       514 005135       516 005141       517 005146       518 005177       519 005210       521 005215
    522 005217       523 005224       527 005265       528 005267       529 005272       530 005274       531 005276
    532 005301       533 005303       534 005306       535 005313       536 005323       537 005333       538 005335
    539 005352       540 005366       543 005371       544 005373       545 005375       546 005377       547 005401
    549 005403       552 005420       556 005460       561 005513       564 005536       571 005571       573 005574
    575 005577       576 005605       577 005615       579 005621       580 005625       582 005646       584 005701
    586 005702       588 005710       590 005712       591 005723       596 005756       602 005760       608 005774
    609 006001       610 006011       611 006016       621 006021       623 006027       627 006032       628 006034
    629 006037       630 006042       631 006046       632 006050       634 006052       635 006077       636 006102
    640 006135       642 006147       644 006176       646 006232       661 006233       667 006234       669 006266
    670 006270       674 006271       676 006273


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
