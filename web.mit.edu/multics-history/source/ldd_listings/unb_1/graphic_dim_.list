	COMPILATION LISTING OF SEGMENT graphic_dim_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/18/82  1637.0 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 /* format: style1,^inddcls,ifthenstmt,ifthendo,ifthen,indcomtxt,dclind5 */
       19 graphic_dim_: proc; return;
       20 
       21 /* This routine is a graphic device interface module.
       22*   It handles both dynamic and static devices.		*/
       23 
       24 /* Written on July 1, 1973 by C. D. Tavares
       25*   Modified 08/79 by CDT to use get_temp_segments_
       26*   Modified 04/25/80 by CDT to replace random signals with calls to sub_err_.
       27*   Modified 08/26/80 by CDT to fix bug leaving user in rawo if GSP close entry
       28*   did any output.  The fix was wrong, by the way, but fixed on 11/18/80.
       29*   Last modified 11/18/80 by CDT-- totally rewritten, and two-pass MSGC parsing
       30*   with blocked, interleaved output implemented.
       31**/
       32 
       33 
       34 /* STATIC */
       35 
       36 dcl  1 static_stuff	        static,
       37        2 sys_area_p	        pointer initial (null),
       38        2 first_dsb_ptr      pointer initial (null),
       39        2 stack_p	        pointer initial (null),
       40        2 stack_size	        fixed bin initial (0),
       41        2 max_string_size    fixed bin (21) fixed bin initial (0),
       42        2 noecho_mode        char (40)
       43 		        initial ("^echoplex,^tabecho,^crecho,^lfecho,rawi"),
       44        2 rawo_mode	        char (12) initial ("rawo."),
       45        2 rawi_mode	        char (16) initial ("^can,^esc,^erkl");
       46 
       47 /* we use ^can,^esc,^erkl instead of rawi because ttydim doesn't always wait
       48*   for newlines in rawi mode also because ARPANET software doesn't honor
       49*   rawi. */
       50 
       51 
       52 /* BASED */
       53 
       54 dcl  1 switch_data_block    based (sdb_ptr),
       55        2 target_switch_ptr  pointer,
       56        2 graphic	        bit (1),
       57        2 device_state_block_ptr
       58 		        pointer,
       59        2 from_switch        char (32),
       60        2 n_buffers	        fixed bin,
       61        2 output_buffer_ptr  pointer,
       62        2 expansion_buffer_ptr
       63 		        pointer,
       64        2 node_table_ptr     pointer,
       65        2 n_nodes_in_list    fixed bin,
       66        2 status_buffer      char (100),
       67        2 attach_description char (128) varying,
       68        2 open_description   char (64) varying,
       69        2 atd_len_no_gdt     fixed bin;
       70 
       71 dcl  1 device_state_block   based (cur_dsb_ptr),
       72        2 in_rawo_mode       bit (1),
       73        2 gdt_ptr	        pointer,
       74        2 gdt_name	        char (32),
       75        2 gdt_proc	        entry (fixed bin, char (*), char (*),
       76 		        fixed bin (21), pointer, fixed bin (35)) variable,
       77        2 gdt_opened	        bit (1),
       78        2 dynamic	        bit (1),
       79        2 gdt_message_size   fixed bin (21),
       80        2 reference_count    fixed bin,
       81        2 switch_name        char (32),
       82        2 target_ptr	        pointer,
       83        2 old_output_modes   char (512) initial (""),
       84        2 old_input_modes    char (512) initial (""),
       85        2 gdt_data_ptr       pointer,
       86        2 next_dsb_ptr       pointer;
       87 
       88 dcl  based_buffer_ptrs      (switch_data_block.n_buffers) pointer
       89 		        based (addr (switch_data_block.output_buffer_ptr)),
       90      char_array	        (static_stuff.max_string_size)
       91 		        char (1) unaligned based,
       92      output_buffer	        char (max_string_size)
       93 		        based (switch_data_block.output_buffer_ptr),
       94      sys_area	        area based (sys_area_p);
       95 
       96 
       97 /* ENTRIES */
       98 
       99 dcl  com_err_	        ext entry options (variable),
      100      expand_pathname_       ext entry
      101 		        (char (*), char (*), char (*), fixed bin (35)),
      102      find_command_$fc_no_message
      103 		        ext entry
      104 		        (pointer, fixed bin, pointer, fixed bin (35)),
      105      get_system_free_area_  ext entry returns (pointer),
      106      get_temp_segments_     ext entry
      107 		        (char (*), pointer dimension (*), fixed bin (35)),
      108      graphic_compiler_$expand_string
      109 		        entry
      110 		        (char (*), fixed bin (21), ptr, fixed bin (21),
      111 		        fixed bin (35)),
      112      graphic_element_length_
      113 		        entry
      114 		        (char (*), fixed bin (21)) returns (fixed bin),
      115      graphic_terminal_status_$decode
      116 		        ext entry (char (*), fixed bin (35)),
      117      hcs_$make_entry        ext entry
      118 		        (ptr, char (*), char (*), entry, fixed bin (35)),
      119      ioa_$rsnnl	        ext entry options (variable),
      120      ipc_$mask_ev_calls     ext entry (fixed bin (35)),
      121      ipc_$unmask_ev_calls   ext entry (fixed bin (35)),
      122      release_temp_segments_ ext entry
      123 		        (char (*), pointer dimension (*), fixed bin (35)),
      124      sub_err_	        ext entry options (variable);
      125 
      126 /* EXTERNAL STATIC */
      127 
      128 dcl  (error_table_$bad_index,
      129      error_table_$badopt,
      130      error_table_$invalid_mode,
      131      error_table_$long_record,
      132      error_table_$negative_nelem,
      133      error_table_$noarg,
      134      error_table_$not_attached,
      135      error_table_$not_detached,
      136      error_table_$unimplemented_version)
      137 		        fixed bin (35) external static;
      138 
      139 dcl  (graphic_error_table_$gdt_missing,
      140      graphic_error_table_$impossible_effector_length,
      141      graphic_error_table_$incomplete_structure,
      142      graphic_error_table_$invalid_node_no,
      143      graphic_error_table_$node_not_active,
      144      graphic_error_table_$nongraphic_switch,
      145      graphic_error_table_$not_a_gdt,
      146      graphic_error_table_$recursive_structure,
      147      graphic_error_table_$too_many_node_ends,
      148      graphic_error_table_$unimplemented_effector,
      149      graphic_error_table_$unrecognized_effector)
      150 		        fixed bin (35) external static;
      151 
      152 dcl  sys_info$max_seg_size  fixed bin (35) external static;
      153 
      154 /* CONDITIONS */
      155 
      156 dcl  cleanup	        condition;
      157 
      158 /* BUILTINS */
      159 
      160 dcl  (addr, before, binary, dim, hbound, index, length, max, min, null,
      161      rank, rtrim, string, substr, unspec)
      162 		        builtin;
      163 
  1     1 /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  1     2 
  1     3 /* Written 05/04/78 by C. D. Tavares */
  1     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  1     5 
  1     6 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  1     7      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  1     8      iox_$close entry (pointer, fixed bin (35)),
  1     9      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  1    10      iox_$delete_record entry (pointer, fixed bin (35)),
  1    11      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  1    12      iox_$detach_iocb entry (pointer, fixed bin (35)),
  1    13      iox_$err_not_attached entry options (variable),
  1    14      iox_$err_not_closed entry options (variable),
  1    15      iox_$err_no_operation entry options (variable),
  1    16      iox_$err_not_open entry options (variable),
  1    17      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  1    18      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  1    19      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    20      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    21      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  1    22      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  1    23      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  1    24      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  1    25      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  1    26      iox_$propagate entry (pointer),
  1    27      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    28      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  1    29      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  1    30      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    31      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    32      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  1    33      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)) ;
  1    34 
  1    35 dcl (iox_$user_output,
  1    36      iox_$user_input,
  1    37      iox_$user_io,
  1    38      iox_$error_output) external static pointer;
  1    39 
  1    40 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
      164 
      165 
  2     1 
  2     2      dcl	   1 iocb		      aligned based (iocb_ptr),
  2     3 						/* I/O control block. */
  2     4 	     2 iocb_version	      fixed init (1),	/* Version number of structure. */
  2     5 	     2 name	      char (32),		/* I/O name of this block. */
  2     6 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  2     7 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  2     8 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  2     9 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  2    10 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  2    11 	     2 reserved	      bit (72),		/* Reserved for future use. */
  2    12 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  2    13 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  2    14 						/* open(p,mode,not_used,s) */
  2    15 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  2    16 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    17 						/* get_line(p,bufptr,buflen,actlen,s) */
  2    18 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    19 						/* get_chars(p,bufptr,buflen,actlen,s) */
  2    20 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  2    21 						/* put_chars(p,bufptr,buflen,s) */
  2    22 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  2    23 						/* modes(p,newmode,oldmode,s) */
  2    24 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  2    25 						/* position(p,u1,u2,s) */
  2    26 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  2    27 						/* control(p,order,infptr,s) */
  2    28 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    29 						/* read_record(p,bufptr,buflen,actlen,s) */
  2    30 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  2    31 						/* write_record(p,bufptr,buflen,s) */
  2    32 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  2    33 						/* rewrite_record(p,bufptr,buflen,s) */
  2    34 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  2    35 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  2    36 						/* seek_key(p,key,len,s) */
  2    37 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  2    38 						/* read_key(p,key,len,s) */
  2    39 	     2 read_length	      entry (ptr, fixed (21), fixed (35));
  2    40 						/* read_length(p,len,s) */
  2    41 
      166 
      167 
  3     1 /* Begin include file ..... iox_modes.incl.pl1 */
  3     2 
  3     3 /* Written by C. D. Tavares, 03/17/75 */
  3     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  3     5 
  3     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  3     7     ("stream_input", "stream_output", "stream_input_output",
  3     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  3     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  3    10      "direct_input", "direct_output", "direct_update");
  3    11 
  3    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  3    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  3    14 
  3    15 dcl (Stream_input initial (1),
  3    16      Stream_output initial (2),
  3    17      Stream_input_output initial (3),
  3    18      Sequential_input initial (4),
  3    19      Sequential_output initial (5),
  3    20      Sequential_input_output initial (6),
  3    21      Sequential_update initial (7),
  3    22      Keyed_sequential_input initial (8),
  3    23      Keyed_sequential_output initial (9),
  3    24      Keyed_sequential_update initial (10),
  3    25      Direct_input initial (11),
  3    26      Direct_output initial (12),
  3    27      Direct_update initial (13)) fixed bin int static options (constant);
  3    28 
  3    29 /* End include file ..... iox_modes.incl.pl1 */
      168 
      169 
  4     1 /* -------- BEGIN include file graphic_device_table.incl.pl1 ----------- */
  4     2 
  4     3 dcl  gdt_version_2 fixed bin static initial (2);
  4     4 
  4     5 dcl  gdt_pointer pointer;
  4     6 
  4     7 dcl 1 graphic_device_table aligned based (gdt_pointer),
  4     8      2 device_data aligned,
  4     9       3 version_number fixed bin,
  4    10       3 terminal_name char (32) aligned,
  4    11       3 terminal_type char (4) aligned,
  4    12       3 charsizes (3) float bin,
  4    13       3 message_size fixed bin (35) aligned,
  4    14       3 points_per_inch float bin (63),
  4    15       3 pad (10) fixed bin aligned,
  4    16     2 effector_data (32 : 70) aligned,
  4    17       3 force_alignment aligned,
  4    18         4 (expand, call, ignore, error, flush) bit (1) unaligned;
  4    19 
  4    20 dcl (Reference initial (37),
  4    21      Process_input initial (64),
  4    22      Prepare_for_graphics initial (65),
  4    23      Prepare_for_text initial (66),
  4    24      Expansion initial (67),
  4    25      Open initial (68),
  4    26      Close initial (69),
  4    27      Modes initial (70)) fixed bin static options (constant);
  4    28 
  4    29 /* --------- END include file graphic_device_table.incl.pl1 ------------ */
      170 
      171 
  5     1 /* -------- BEGIN include file graphic_code_dcl.incl.pl1 ---------- */
  5     2 
  5     3 /* The following structure maintains a nonobvious positional relationship
  5     4*  with respect to the LSM block types as defined by the graphic compiler.
  5     5*  It therefore has an intimiate and delicate relationship with certain tables
  5     6*  defined in graphic_comp_specs.incl.pl1. */
  5     7 
  5     8 dcl 1 Graphic_Code_Structure aligned static options (constant),
  5     9     2 Dynamic_and_structural_effectors aligned,
  5    10       3 (Pause_char initial ("$"),
  5    11          Reference_char initial ("%"),
  5    12          Increment_char initial ("&"),
  5    13          Alter_char initial ("'"),
  5    14          Node_begin_char initial ("("),
  5    15          Node_end_char initial (")"),
  5    16          Control_char initial ("*"),
  5    17          Display_char initial ("+"),
  5    18          Query_char initial (","),
  5    19          Erase_char initial ("-"),
  5    20          Synchronize_char initial ("."),
  5    21          Delete_char initial ("/")) char (1) unaligned,
  5    22     2 Graphic_effectors aligned,
  5    23       3 (Setposition_char initial ("0"),
  5    24          Setpoint_char initial ("1"),
  5    25          Vector_char initial ("2"),
  5    26          Shift_char initial ("3"),
  5    27          Point_char initial ("4")) char (1) unaligned,
  5    28       3 Illegal_pad char (3) unaligned initial ((3)"U"),
  5    29     2 Mapping_effectors aligned,
  5    30       3 (Scaling_char initial ("5"),
  5    31          Rotation_char initial ("6"),
  5    32          Clipping_char initial ("7")) char (1) unaligned,
  5    33       3 Illegal_pad char (5) unaligned initial ((5)"U"),
  5    34     2 Mode_effectors aligned,
  5    35       3 (Intensity_char initial ("8"),
  5    36          Linetype_char initial ("9"),
  5    37          Sensitivity_char initial (";"),
  5    38          Blinking_char initial (":"),
  5    39          Color_char initial ("<")) char (1) unaligned,
  5    40       3 Illegal_pad char (3) unaligned initial ((3)"U"),
  5    41     2 Special_effectors aligned,
  5    42       3 (Symbol_char initial ("="),
  5    43          Text_char initial (">"),
  5    44          Datablock_char initial ("?")) char (1) unaligned,
  5    45       3 Illegal_pad char (9) unaligned initial ((9)"U");
  5    46 
  5    47 dcl 1 Graphic_Defaults aligned static options (constant),
  5    48     2 Mode_defaults aligned,
  5    49       3 Intensity_default fixed bin initial (7),
  5    50       3 Linetype_default fixed bin initial (0),
  5    51       3 Blinking_default fixed bin initial (0),
  5    52       3 Sensitivity_default fixed bin initial (0),
  5    53       3 Color_default (3) fixed bin initial ((3)16),
  5    54     2 Mapping_defaults aligned,
  5    55       3 Scaling_default (3) float bin initial ((3)1e0),
  5    56       3 Rotation_default (3) fixed bin initial ((3)0),
  5    57       3 Clipping_default (3, 2) fixed bin initial ((3) (-2048, 2048)),
  5    58     2 Identity_matrix (3, 3) float bin initial (1e0, (3)0e0, 1e0, (3)0e0, 1e0);
  5    59 
  5    60 dcl  Graphic_Element_Lengths (32 : 63) aligned static options (constant) initial
  5    61      ((4)-1,									/* not used */
  5    62      1,	/* pause */	4,	/* reference */	9,	/* increment */	9,	/* alter */
  5    63      5,	/* node begin */	1,	/* node end */	4,	/* control */	4,	/* display */
  5    64      3,	/* query */	1,	/* erase */	1,	/* synchronize */	4,	/* delete */
  5    65      10,	/* setposition */	10,	/* setpoint */	10, 	/* vector */	10,	/* shift */
  5    66      10,	/* point */	10,	/* scaling */	7,	/* rotation */	13,	/* clipping */
  5    67      2,	/* intensity */	2,	/* line type */	2,	/* blinking */	2,	/* sensitivity */
  5    68      4, 	/* color */	0,	/* symbol */	0,	/* text */	0	/* data */);
  5    69 
  5    70 dcl  zero_node_id char (3) static initial ("@@@") options (constant);
  5    71 
  5    72 dcl  request_for_status char (1) static aligned initial ("") options (constant);
  5    73 
  5    74 dcl (List_char initial ("@"),
  5    75      Array_char initial ("A")) char (1) aligned static options (constant);
  5    76 
  5    77 /* --------- END include file graphic_code_dcl.incl.pl1 ----------- */
      172 
      173 
  6     1 /* Begin include file ..... io_call_info.incl.pl1 */
  6     2 
  6     3 /* This include file defines the info_structure used by an I/O module to perform an "io_call" order
  6     4*   on behalf of the io_call command. */
  6     5 /* Coded April 1976 by Larry Johnson */
  6     6 /* Changed June 1977 by Larry Johnson for "io_call_af" order */
  6     7 
  6     8      dcl	   io_call_infop	      ptr;
  6     9 
  6    10      dcl	   1 io_call_info	      aligned based (io_call_infop),
  6    11 	     2 version	      fixed bin,
  6    12 	     2 caller_name	      char (32),		/* Caller name for error messages */
  6    13 	     2 order_name	      char (32),		/* Actual name of the order to be performed */
  6    14 	     2 report	      entry variable options (variable),
  6    15 						/* Entry to ioa_ like procedure to report results */
  6    16 	     2 error	      entry variable options (variable),
  6    17 						/* Entry to com_err_ like procedure to report results */
  6    18 	     2 af_returnp	      ptr,		/* Pointer to return string if "io_call_af"  order */
  6    19 	     2 af_returnl	      fixed bin,		/* Length of string */
  6    20 	     2 fill	      (5) bit (36) aligned,
  6    21 	     2 nargs	      fixed bin,		/* Number of additional command arguments provided */
  6    22 	     2 max_arglen	      fixed bin,		/* Length of longest argument (used to define array) */
  6    23 	     2 args	      (0 refer (io_call_info.nargs)) char (0 refer (io_call_info.max_arglen)) varying;
  6    24 
  6    25      dcl	   io_call_af_ret	      char (io_call_info.af_returnl) based (io_call_info.af_returnp) varying;
  6    26 						/* Return string for active function */
  6    27 
  6    28 /* End include file ..... io_call_info.incl.pl1 */
      174 
      175 
      176 graphic_dim_attach: entry (iocb_ptr, option_array, com_err_sw, code);
      177 
      178 /* PARAMETERS */
      179 
      180 dcl  (iocb_ptr	        pointer,
      181      option_array	        (*) char (*) varying,
      182      com_err_sw	        bit (1) aligned,
      183      code		        fixed bin (35)) parameter;
      184 
      185 /* AUTOMATIC */
      186 
      187 dcl  cur_dsb_ptr	        pointer,
      188      found	        bit (1),
      189      gdt_name_copy	        char (168),
      190      output_buffer_outdx    fixed bin (21),
      191      sdb_ptr	        pointer,
      192      tp		        pointer;
      193 
      194 
      195 	sdb_ptr, cur_dsb_ptr = null;
      196 
      197 	if iocb.attach_descrip_ptr ^= null then		/* switch in use */
      198 	     call attach_error (error_table_$not_detached);
      199 
      200 	if static_stuff.sys_area_p = null then do;	/* initialize it */
      201 		static_stuff.sys_area_p = get_system_free_area_ ();
      202 		static_stuff.max_string_size = sys_info$max_seg_size * 4;
      203 	     end;
      204 
      205 	allocate switch_data_block in (sys_area) set (sdb_ptr);
      206 
      207 /* Locate the switch which we will be talking to for this attachment. */
      208 
      209 	call iox_$find_iocb ((option_array (1)),
      210 	     switch_data_block.target_switch_ptr, code);
      211 	if code ^= 0 then call attach_error (code);
      212 
      213 /* Try to find the device state block, if any, already associated with our
      214*   target switch. */
      215 
      216 	do tp = static_stuff.first_dsb_ptr repeat (tp -> next_dsb_ptr)
      217 	     while (tp ^= null & cur_dsb_ptr = null);
      218 
      219 	     if tp -> device_state_block.switch_name = option_array (1) then
      220 		cur_dsb_ptr = tp;
      221 	end;
      222 
      223 /* If we have found an existing dsb, then use it. */
      224 
      225 	if cur_dsb_ptr ^= null then do;
      226 		device_state_block.target_ptr =
      227 		     switch_data_block.target_switch_ptr;
      228 		device_state_block.reference_count =
      229 		     device_state_block.reference_count + 1;
      230 	     end;
      231 
      232 /* If no dsb for this target switch, create one. */
      233 
      234 	else do;
      235 		allocate device_state_block in (sys_area);
      236 
      237 		device_state_block.switch_name = option_array (1);
      238 		device_state_block.gdt_ptr,
      239 		     device_state_block.gdt_data_ptr,
      240 		     device_state_block.next_dsb_ptr = null;
      241 		device_state_block.gdt_name = "";
      242 		device_state_block.gdt_proc = not_setup;
      243 		device_state_block.gdt_opened,
      244 		     device_state_block.dynamic,
      245 		     device_state_block.in_rawo_mode = ""b;
      246 		device_state_block.gdt_message_size =
      247 		     static_stuff.max_string_size;
      248 		device_state_block.reference_count = 1;
      249 
      250 		if static_stuff.first_dsb_ptr = null then
      251 		     static_stuff.first_dsb_ptr = cur_dsb_ptr;
      252 		else tp -> device_state_block.next_dsb_ptr = cur_dsb_ptr;
      253 	     end;
      254 
      255 	switch_data_block.device_state_block_ptr = cur_dsb_ptr;
      256 
      257 	switch_data_block.from_switch = iocb.name;
      258 	switch_data_block.output_buffer_ptr,
      259 	     switch_data_block.expansion_buffer_ptr,
      260 	     switch_data_block.node_table_ptr = null;
      261 	switch_data_block.n_nodes_in_list = 0;
      262 	switch_data_block.status_buffer = "";
      263 
      264 	if hbound (option_array, 1) < 2 then
      265 	     switch_data_block.graphic = ""b;
      266 	else if option_array (2) = "graphic" then
      267 	     switch_data_block.graphic = "1"b;
      268 	else if option_array (2) = "^graphic" then
      269 	     switch_data_block.graphic = ""b;
      270 	else call attach_error (error_table_$badopt);
      271 
      272 	if switch_data_block.graphic then switch_data_block.n_buffers = 2;
      273 	else switch_data_block.n_buffers = 1;
      274 
      275 	call get_temp_segments_
      276 	     (temp_seg_name ("graphic_dim_", switch_data_block.from_switch),
      277 	     based_buffer_ptrs, code);
      278 	if code ^= 0 then call attach_error (code);
      279 
      280 	switch_data_block.attach_description =
      281 	     "graphic_dim_ " || option_array (1);
      282 	if switch_data_block.graphic then
      283 	     attach_description = attach_description || " graphic";
      284 	switch_data_block.atd_len_no_gdt =
      285 	     length (switch_data_block.attach_description);
      286 
      287 	if hbound (option_array, 1) > 2 then do;
      288 		gdt_name_copy = option_array (3);
      289 		call associate_gdt (gdt_name_copy, code);
      290 		if code ^= 0 then call attach_error (code);
      291 	     end;
      292 
      293 	iocb.attach_descrip_ptr = addr (attach_description);
      294 	iocb.attach_data_ptr = sdb_ptr;
      295 
      296 	iocb.open = graphic_dim_open;
      297 	iocb.detach_iocb = graphic_dim_detach;
      298 
      299 	code = 0;
      300 
      301 	call iox_$propagate (iocb_ptr);
      302 
      303 	return;



      304 
      305 attach_error: proc (code);
      306 
      307 dcl  code		        fixed bin (35) parameter;
      308 
      309 	if com_err_sw then call com_err_ (code, "graphic_dim_", "");
      310 
      311 	if sdb_ptr ^= null then do;
      312 		if cur_dsb_ptr ^= null then
      313 		     if device_state_block.reference_count = 1 then
      314 			call free_dsb (cur_dsb_ptr);
      315 		if switch_data_block.output_buffer_ptr ^= null then
      316 		     call release_temp_segments_
      317 			(temp_seg_name ("graphic_dim_",
      318 			switch_data_block.from_switch),
      319 			based_buffer_ptrs, 0);
      320 		free switch_data_block in (sys_area);
      321 	     end;
      322 	goto attach_error_return;
      323      end attach_error;
      324 
      325 attach_error_return:
      326 	return;



      327 
      328 temp_seg_name: proc (prefix, suffix) returns (char (32));
      329 
      330 dcl  (prefix, suffix)       char (*) parameter,
      331      char32	        char (32) varying;
      332 
      333 	char32 = prefix;
      334 	char32 = char32 || " ";
      335 	char32 = char32 || suffix;
      336 	return (char32);
      337      end temp_seg_name;



      338 
      339 free_dsb: proc (dsb_ptr);
      340 
      341 /* PARAMETERS */
      342 
      343 dcl  dsb_ptr	        pointer parameter;
      344 
      345 /* AUTOMATIC */
      346 
      347 dcl  found	        bit (1),
      348      prev_tp	        pointer,
      349      tp		        pointer;
      350 
      351 
      352 	found = ""b;				/* begin to search for block */
      353 
      354 /* is this dsb first one on the chain? */
      355 
      356 	if dsb_ptr = static_stuff.first_dsb_ptr then do;
      357 		found = "1"b;
      358 		prev_tp = null;
      359 	     end;
      360 
      361 /* otherwise, chain down blocks until this dsb found */
      362 
      363 	do tp = static_stuff.first_dsb_ptr
      364 	     repeat (tp -> device_state_block.next_dsb_ptr)
      365 	     while (tp ^= null & ^found);
      366 	     prev_tp = tp;
      367 	     if tp -> device_state_block.next_dsb_ptr = dsb_ptr then
      368 		found = "1"b;
      369 	end;
      370 
      371 	if ^found then
      372 	     call sub_err_ (error_table_$bad_index, "graphic_dim_", "s",
      373 		null, 0,
      374 		"Cannot find chain predecessor to DSB for ^a.",
      375 		device_state_block.switch_name);	/* stop cold */
      376 
      377 /* rechain the chain around this block */
      378 
      379 	tp = prev_tp;
      380 
      381 	if tp = null then
      382 	     static_stuff.first_dsb_ptr = dsb_ptr -> next_dsb_ptr;
      383 	else tp -> next_dsb_ptr = dsb_ptr -> next_dsb_ptr;
      384 
      385 
      386 	free dsb_ptr -> device_state_block in (sys_area); /* wham. */
      387 
      388 	return;
      389 
      390      end free_dsb;



      391 
      392 associate_gdt: proc (table_name, code);
      393 
      394 /* PARAMETERS */
      395 
      396 dcl  (table_name	        char (*),
      397      code		        fixed bin (35)) parameter;
      398 
      399 /* AUTOMATIC */
      400 
      401 dcl  gdt_entrypoint_name    char (168),
      402      gdt_ptr	        pointer;
      403 
      404 /* BASED */
      405 
      406 dcl  1 gdt	        like graphic_device_table aligned based (gdt_ptr);
      407 
      408 
      409 	if ^switch_data_block.graphic then do;
      410 		code = graphic_error_table_$nongraphic_switch;
      411 		return;
      412 	     end;
      413 
      414 /* Find the GDT to be used.  Get a pointer to the start of the table. */
      415 
      416 	gdt_entrypoint_name = before (table_name, " ") || "$table_start";
      417 
      418 	call find_command_$fc_no_message (addr (gdt_entrypoint_name),
      419 	     length (gdt_entrypoint_name), gdt_ptr, code);
      420 	if code ^= 0 then return;
      421 
      422 	if gdt.version_number ^= gdt_version_2 then
      423 	     if gdt.version_number ^= 1 then do;
      424 		     code = error_table_$unimplemented_version;
      425 		     return;
      426 		end;
      427 
      428 /* version 1 OK-- differs only in existence of "modes" call */
      429 
      430 	if gdt.terminal_type ^= "dyna" then
      431 	     if gdt.terminal_type ^= "stat" then do;	/* must be one! */
      432 		     code = graphic_error_table_$not_a_gdt;
      433 		     return;
      434 		end;
      435 
      436 	device_state_block.gdt_ptr = gdt_ptr;
      437 
      438 	device_state_block.dynamic = (gdt.terminal_type = "dyna");
      439 	device_state_block.gdt_message_size = gdt.message_size;
      440 	call expand_pathname_
      441 	     (table_name, "", device_state_block.gdt_name, 0);
      442 
      443 	switch_data_block.attach_description =
      444 	     substr (switch_data_block.attach_description, 1,
      445 	     switch_data_block.atd_len_no_gdt)
      446 	     || " " || device_state_block.gdt_name;
      447 
      448 	call hcs_$make_entry (gdt_ptr, (device_state_block.gdt_name),
      449 	     "gdt_proc", device_state_block.gdt_proc, code);
      450 	if code ^= 0 then return;
      451 
      452 /* open the GDT now, unless this switch is not yet opened itself. */
      453 
      454 	if iocb.open_descrip_ptr ^= null then
      455 	     call try_to_open_gdt (gdt_ptr, code);
      456 
      457 	return;
      458 
      459      end associate_gdt;



      460 
      461 try_to_open_gdt: proc (gdt_ptr, code);
      462 
      463 /* PARAMETERS */
      464 
      465 dcl  (gdt_ptr	        pointer,
      466      code		        fixed bin (35)) parameter;
      467 
      468 /* BASED */
      469 
      470 dcl  1 gdt	        like graphic_device_table aligned based (gdt_ptr);
      471 
      472 
      473 	if ^device_state_block.gdt_opened then
      474 	     if gdt.effector_data (Open).call then do;
      475 		     call gdt_caller
      476 			(Open, device_state_block.switch_name, code);
      477 		     if code ^= 0 then return;
      478 
      479 		     call force_out_buffer ("1"b, code);
      480 		     if code ^= 0 then return;
      481 		end;
      482 
      483 	device_state_block.gdt_opened = "1"b;
      484 	return;
      485 
      486      end try_to_open_gdt;
      487 
      488 not_setup: entry (a_effnum, a_instring, a_obuffer, a_nchars, a_statptr, code);
      489 
      490 /* This entry exists for the sole purpose of returning an error code.  It is
      491*   called only by mistake when somebody tries to call an entry in the GSP at
      492*   a time when no GDT is yet been associated with the I/O switch. */
      493 
      494 /* PARAMETERS */
      495 
      496 dcl  (a_effnum	        fixed bin,
      497      a_instring	        char (*),
      498      a_obuffer	        char (*),
      499      a_nchars	        fixed bin (21),
      500      a_statptr	        pointer) parameter;
      501 
      502 	code = graphic_error_table_$gdt_missing;
      503 	return;





      504 
      505 no_entry: entry (a_effnum, a_instring, a_obuffer, a_nchars, a_statptr, code);
      506 
      507 /* This entry exists because the graphic_dim_ occasionally tries to "call" an
      508*   operator which has not been given the "call" attribute in the gdt.  (This
      509*   is the default entry that compile_gdt places in the GDT if no call is
      510*   specified.)  Yes, this is dirty.  However, graphic_dim_ only tries to call
      511*   the Prepare_for_graphics and Prepare_for_text entries without actually
      512*   checking if they are callable.  These really should have either the "call"
      513*   or the "ignore"attribute on - others make no sense.  */
      514 
      515 	code = 0;
      516 	return;
      517 
      518 graphic_dim_open: entry (iocb_ptr, open_mode, ignore, code);
      519 
      520 /* PARAMETERS */
      521 
      522 dcl  (open_mode	        fixed bin,
      523      ignore	        bit (1)) parameter;
      524 
      525 	call setup;
      526 
      527 	if (open_mode ^= Stream_input)
      528 	     & (open_mode ^= Stream_output)
      529 	     & (open_mode ^= Stream_input_output) then do;
      530 		code = error_table_$invalid_mode;
      531 		return;
      532 	     end;
      533 
      534 	if open_mode ^= Stream_input then
      535 	     actual_iocb_ptr -> iocb.put_chars = graphic_dim_write;
      536 
      537 	if open_mode ^= Stream_output then do;
      538 		actual_iocb_ptr -> iocb.get_line = graphic_dim_get_line;
      539 		if ^switch_data_block.graphic then
      540 		     actual_iocb_ptr -> get_chars = graphic_dim_get_chars;
      541 	     end;
      542 
      543 	actual_iocb_ptr -> iocb.modes = graphic_dim_changemode;
      544 	actual_iocb_ptr -> iocb.control = graphic_dim_order;
      545 	actual_iocb_ptr -> iocb.close = graphic_dim_close;
      546 
      547 	switch_data_block.open_description = iox_modes (open_mode);
      548 	iocb.open_descrip_ptr = addr (open_description);
      549 
      550 	call iox_$propagate (actual_iocb_ptr);
      551 
      552 	if switch_data_block.graphic then
      553 	     call try_to_open_gdt
      554 		(switch_data_block.device_state_block_ptr ->
      555 		device_state_block.gdt_ptr, code);
      556 
      557 	return;



      558 
      559 setup: proc;
      560 
      561 	sdb_ptr = actual_iocb_ptr -> iocb.attach_data_ptr;
      562 	cur_dsb_ptr = switch_data_block.device_state_block_ptr;
      563 	gdt_pointer = device_state_block.gdt_ptr;
      564 	output_buffer_outdx = 0;
      565 	code = 0;
      566 
      567 	return;
      568 
      569      end setup;
      570 
      571 graphic_dim_close: entry (iocb_ptr, code);
      572 
      573 	call setup;
      574 
      575 	if switch_data_block.graphic then do;
      576 
      577 		if device_state_block.gdt_opened then do;
      578 			if device_state_block.in_rawo_mode then do;
      579 				call get_to_text_mode (code);
      580 				if code ^= 0 then return;
      581 			     end;
      582 			if graphic_device_table.effector_data (Close).call
      583 			then do;
      584 				call gdt_caller (Close,
      585 				     device_state_block.switch_name, code);
      586 				if code ^= 0 then return;
      587 
      588 				call force_out_buffer ("1"b, code);
      589 				if code ^= 0 then return;
      590 
      591 				device_state_block.gdt_opened = ""b;
      592 			     end;
      593 		     end;
      594 	     end;
      595 
      596 	actual_iocb_ptr -> iocb.open_descrip_ptr = null;
      597 
      598 	actual_iocb_ptr -> iocb.detach_iocb = graphic_dim_detach;
      599 	actual_iocb_ptr -> iocb.open = graphic_dim_open;
      600 	actual_iocb_ptr -> iocb.control = iox_$err_no_operation;
      601 
      602 	call iox_$propagate (actual_iocb_ptr);
      603 
      604 	code = 0;
      605 
      606 	return;
      607 
      608 graphic_dim_detach: entry (iocb_ptr, code);
      609 
      610 	call setup;
      611 
      612 	call release_temp_segments_
      613 	     (temp_seg_name ("graphic_dim_", switch_data_block.from_switch),
      614 	     based_buffer_ptrs, code);
      615 	if code ^= 0 then return;
      616 
      617 	device_state_block.reference_count =
      618 	     device_state_block.reference_count - 1;
      619 
      620 	if device_state_block.reference_count = 0 then
      621 	     call free_dsb (cur_dsb_ptr);
      622 
      623 	free switch_data_block in (sys_area);
      624 
      625 	iocb.attach_descrip_ptr = null;
      626 
      627 	call iox_$propagate (iocb_ptr);
      628 
      629 	return;
      630 
      631 graphic_dim_order: entry (iocb_ptr, request_arg, data_ptr, code);
      632 
      633 /* PARAMETERS */
      634 
      635 dcl  (request_arg	        char (*),
      636      data_ptr	        pointer) parameter;
      637 
      638 /* AUTOMATIC */
      639 
      640 dcl  active_fn	        bit (1),
      641      command_level	        bit (1),
      642      request	        char (168),
      643      table_name	        char (168);
      644 
      645 /* BASED */
      646 
      647 dcl  1 device_info	        aligned based (data_ptr),
      648        2 gdt_name	        char (32) aligned,
      649        2 info_gdt_ptr       pointer,
      650        2 device_data        like graphic_device_table.device_data aligned;
      651 
      652 dcl  based_char_168	        char (168) based (data_ptr);
      653 
      654 
      655 	call setup;
      656 
      657 	if request_arg = "io_call" then do;
      658 		io_call_infop = data_ptr;
      659 		request = io_call_info.order_name;
      660 		command_level = "1"b;
      661 		active_fn = (request_arg = "io_call_af");
      662 		if io_call_info.version ^= 1 then do;
      663 			code = error_table_$unimplemented_version;
      664 			request = "io_call_info structure";
      665 		     end;
      666 	     end;
      667 
      668 	else do;
      669 		request = request_arg;
      670 		command_level, active_fn = ""b;
      671 	     end;
      672 
      673 	if request = "set_table" then do;
      674 		if command_level then
      675 		     if io_call_info.nargs < 1 then do;
      676 			     code = 0;
      677 			     call io_call_info.error (error_table_$noarg,
      678 				io_call_info.caller_name,
      679 				"Need name of GDT.");
      680 			     return;
      681 			end;
      682 		     else table_name = io_call_info.args (1);
      683 		else table_name = data_ptr -> based_char_168;
      684 
      685 		call associate_gdt (table_name, code);
      686 
      687 /* if woopsed, at least make the error message pretty. */
      688 		if code ^= 0 then request = table_name;
      689 	     end;
      690 
      691 	else if request = "get_sdb" then do;
      692 		if ^command_level then data_ptr = addr (switch_data_block);
      693 		else if active_fn then
      694 		     call ioa_$rsnnl ("^p", io_call_af_ret, 0,
      695 			addr (switch_data_block));
      696 		else call io_call_info.report ("^p",
      697 			addr (switch_data_block));
      698 	     end;
      699 
      700 	else if request = "device_info" then do;
      701 
      702 		if ^switch_data_block.graphic then
      703 		     code = graphic_error_table_$nongraphic_switch;
      704 
      705 		else if command_level then
      706 		     if active_fn then
      707 			io_call_af_ret = device_state_block.gdt_name;
      708 		     else call io_call_info.report ("
      709 GDT: ^a (^p) for ^a (^a)^/Character height: ^f, width: ^f, spacing: ^f
      710 Message size: ^d chars^/Points per inch: ^f",
      711 			     device_state_block.gdt_name,
      712 			     device_state_block.gdt_ptr,
      713 			     graphic_device_table.terminal_name,
      714 			     graphic_device_table.terminal_type,
      715 			     graphic_device_table.charsizes (*),
      716 			     graphic_device_table.message_size,
      717 			     graphic_device_table.points_per_inch);
      718 
      719 		else do;
      720 			device_info.gdt_name =
      721 			     device_state_block.gdt_name;
      722 			device_info.info_gdt_ptr =
      723 			     device_state_block.gdt_ptr;
      724 			unspec (device_info.device_data) =
      725 			     unspec (graphic_device_table.device_data);
      726 		     end;
      727 	     end;
      728 
      729 	else if request = "debug" then
      730 	     rawi_mode, rawo_mode, noecho_mode = "";
      731 
      732 	else if request = "nodebug" then do;
      733 		rawi_mode = "^can,^esc,^erkl";
      734 		rawo_mode = "rawo.";
      735 		noecho_mode = "^echoplex,^tabecho,^crecho,^lfecho,rawi";
      736 	     end;
      737 
      738 /* If we don't recognize the control order, pass it downstream and hope. */
      739 
      740 	else call iox_$control
      741 		(switch_data_block.target_switch_ptr, request_arg,
      742 		data_ptr, code);
      743 
      744 	if code ^= 0 then
      745 	     if command_level then do;
      746 		     call io_call_info.error (code,
      747 			io_call_info.caller_name, request);
      748 		     code = 0;
      749 		end;
      750 
      751 	return;
      752 
      753 graphic_dim_changemode: entry (iocb_ptr, new_modes, old_modes, code);
      754 
      755 /* PARAMETERS */
      756 
      757 dcl  (new_modes	        char (*),
      758      old_modes	        char (*)) parameter;
      759 
      760 /* AUTOMATIC */
      761 
      762 dcl  (i, j)	        fixed bin,
      763      new_modes_len	        fixed bin,
      764      (old_sw_modes, old_gdt_modes)
      765 		        char (512),
      766      single_mode	        char (32);
      767 
      768 	call setup;
      769 
      770 	if device_state_block.in_rawo_mode then do;
      771 		call get_to_text_mode (code);
      772 		if code ^= 0 then return;
      773 	     end;
      774 
      775 /* If the GSP keeps modes, obtain their current state. */
      776 
      777 	if switch_data_block.graphic then do;
      778 		call gdt_caller (Modes, "", code);
      779 		if code ^= 0 then return;
      780 
      781 		old_gdt_modes =
      782 		     substr (output_buffer, 1, output_buffer_outdx);
      783 		output_buffer_outdx = 0;
      784 	     end;
      785 
      786 	else old_gdt_modes = "";
      787 
      788 /* Now get the modes from "downstream". */
      789 
      790 	call iox_$modes (switch_data_block.target_switch_ptr, "",
      791 	     old_sw_modes, code);
      792 
      793 	if code ^= 0 then
      794 	     old_modes = old_gdt_modes;
      795 	else if old_gdt_modes = "" then
      796 	     old_modes = old_sw_modes;
      797 	else call ioa_$rsnnl ("^a,^a", old_modes, 0,
      798 		rtrim (old_sw_modes, " ."), old_gdt_modes);
      799 
      800 /* Try simple case - see if ttydim accepts all of these new modes */
      801 
      802 	call iox_$modes (switch_data_block.target_switch_ptr, new_modes,
      803 	     old_sw_modes, code);
      804 	if code ^= 0 then do;
      805 
      806 /* Since the ttydim rejected the modes, if the switch is nongraphic or the GDT
      807*   doesn't know or care about modes, we must give up. */
      808 
      809 		if ^switch_data_block.graphic then return;
      810 		if graphic_device_table.version_number < gdt_version_2 then
      811 		     return;
      812 		if ^graphic_device_table.effector_data (Modes).call then
      813 		     return;
      814 
      815 /* We have to break apart the new_modes string and feed each bite to the
      816*   ttydim_ and to the GDT to see if it is swallowed.  If both chuck up the same
      817*   token, we can the whole modes operation and return a bad code. */
      818 
      819 		i = 1;
      820 		new_modes_len = length (rtrim (new_modes));
      821 		code = 0;
      822 
      823 		do while (i < new_modes_len);
      824 		     j = index (substr (new_modes, i), ",");
      825 		     if j = 0 then
      826 			j = length (substr (new_modes, i)) + 1;
      827 		     single_mode =
      828 			rtrim (substr (new_modes, i, j - 1), ". ");
      829 		     i = i + j;
      830 
      831 		     call iox_$modes (switch_data_block.target_switch_ptr,
      832 			single_mode, "", code);
      833 
      834 		     if code ^= 0 then do;
      835 
      836 /* ttydim upchucked it, try it on GDT */
      837 
      838 			     call gdt_caller (Modes, single_mode, code);
      839 			     output_buffer_outdx = 0;
      840 			     if code ^= 0 then do;
      841 
      842 /* Both the ttydim and the GSP rejected it.  Reset everything and punt. */
      843 
      844 				     call iox_$modes
      845 					(switch_data_block.target_switch_ptr,
      846 					new_modes, old_sw_modes,
      847 					code);
      848 				     call gdt_caller (Modes,
      849 					old_gdt_modes, 0);
      850 				     return;
      851 				end;
      852 			end;
      853 		end;
      854 	     end;
      855 
      856 	return;
      857 
      858 graphic_dim_get_chars: entry (iocb_ptr, io_buffer_ptr, io_buffer_len,
      859 	n_chars_read, code);
      860 
      861 /* PARAMETERS */
      862 
      863 dcl  (io_buffer_ptr	        pointer,
      864      io_buffer_len	        fixed bin (21),
      865      n_chars_read	        fixed bin (21)) parameter;
      866 
      867 
      868 
      869 	call setup;
      870 
      871 /* Simple read of text from one switch to another.  This entry is not reachable
      872*   from graphic swithes. */
      873 
      874 	if in_rawo_mode then do;
      875 		call get_to_text_mode (code);
      876 		if code ^= 0 then return;
      877 	     end;
      878 
      879 	call iox_$get_chars (target_switch_ptr, io_buffer_ptr,
      880 	     io_buffer_len, n_chars_read, code);
      881 	return;
      882 
      883 graphic_dim_get_line: entry (iocb_ptr, io_buffer_ptr, io_buffer_len,
      884 	n_chars_read, code);
      885 
      886 /* BASED */
      887 
      888 dcl  io_buffer	        char (io_buffer_len) based (io_buffer_ptr);
      889 
      890 
      891 	call setup;
      892 
      893 	if ^switch_data_block.graphic then do;
      894 
      895 /* Simple read of text from one switch to another-- just pass it on. */
      896 
      897 		if in_rawo_mode then do;
      898 			call get_to_text_mode (code);
      899 			if code ^= 0 then return;
      900 		     end;
      901 
      902 		call iox_$get_line (target_switch_ptr, io_buffer_ptr,
      903 		     io_buffer_len, n_chars_read, code);
      904 		return;
      905 	     end;
      906 
      907 /* If we get here, we are doing a graphic read (graphic input). */
      908 
      909 	n_chars_read = 0;
      910 
      911 	if io_buffer_len < 0 then do;
      912 		code = error_table_$negative_nelem;
      913 		return;
      914 	     end;
      915 
      916 	if io_buffer_len = 0 then return;
      917 
      918 	if graphic_device_table.effector_data (Process_input).ignore then
      919 	     return;
      920 
      921 	if graphic_device_table.effector_data (Process_input).error then do;
      922 		code = graphic_error_table_$unimplemented_effector;
      923 		return;
      924 	     end;
      925 
      926 	device_state_block.old_input_modes = "";
      927 
      928 	on cleanup call reset_input;
      929 
      930 	call ipc_$mask_ev_calls (0);
      931 
      932 	call iox_$modes (switch_data_block.target_switch_ptr,
      933 	     static_stuff.rawi_mode, device_state_block.old_input_modes,
      934 	     code);
      935 
      936 /* This call is made separately because the ARPANET rejects it */
      937 
      938 	call iox_$modes (switch_data_block.target_switch_ptr, noecho_mode,
      939 	     "", code);
      940 
      941 /* If the GSP wants to handle the input, let it handle everything including
      942*   the read (who knows what weird multi-line formats non-intelligent devices
      943*   might use?!) */
      944 
      945 	if graphic_device_table.effector_data (Process_input).call then do;
      946 		call gdt_caller (Process_input,
      947 		     device_state_block.switch_name, code);
      948 		call reset_input;
      949 		if code ^= 0 then return;
      950 
      951 		if output_buffer_outdx <= io_buffer_len then
      952 		     n_chars_read = output_buffer_outdx;
      953 		else do;
      954 			code = error_table_$long_record;
      955 			n_chars_read = io_buffer_len;
      956 		     end;
      957 
      958 		substr (io_buffer, 1, n_chars_read) =
      959 		     substr (output_buffer, 1, n_chars_read);
      960 
      961 	     end;
      962 
      963 /* Otherwise, assume the virtual terminal, and expect real MSGC from it. */
      964 
      965 	else do;
      966 		call iox_$get_line (switch_data_block.target_switch_ptr,
      967 		     io_buffer_ptr, io_buffer_len, n_chars_read, code);
      968 		call reset_input;
      969 	     end;
      970 
      971 	return;



      972 
      973 reset_input: proc;
      974 
      975 	call iox_$modes (switch_data_block.target_switch_ptr,
      976 	     device_state_block.old_input_modes, "", 0);
      977 
      978 	return;
      979 
      980      end reset_input;
      981 
      982 graphic_dim_write: entry (iocb_ptr, io_buffer_ptr, io_buffer_len, code);
      983 
      984 /* AUTOMATIC */
      985 
      986 dcl  n_chars_out	        fixed bin (21),
      987      new_nodes_idx	        fixed bin,
      988      new_top_idx	        fixed bin;
      989 
      990 /* BASED */
      991 
      992 dcl  expansion_buffer       char (max_string_size)
      993 		        based (switch_data_block.expansion_buffer_ptr);
      994 
      995 
      996 	call setup;
      997 
      998 	if io_buffer_len < 0 then do;
      999 		code = error_table_$negative_nelem;
     1000 		return;
     1001 	     end;
     1002 
     1003 	if io_buffer_len = 0 then return;
     1004 
     1005 
     1006 	if ^switch_data_block.graphic then do;
     1007 
     1008 /* This is a simple write call over a non-graphic switch. */
     1009 
     1010 		if device_state_block.in_rawo_mode then do;
     1011 			call get_to_text_mode (code);
     1012 			if code ^= 0 then return;
     1013 		     end;
     1014 
     1015 		substr (output_buffer, output_buffer_outdx + 1,
     1016 		     io_buffer_len) = io_buffer;
     1017 		output_buffer_outdx = output_buffer_outdx + io_buffer_len;
     1018 
     1019 		call force_out_buffer (""b, code);
     1020 		return;
     1021 	     end;




     1022 
     1023 
     1024 /* If we're here, this is a graphic write over a graphic switch */
     1025 /* First, parse, track, and otherwise massage whatever it is we have to
     1026*   write to the terminal. */
     1027 
     1028 
     1029 	call preexpand_graphic_code (io_buffer, expansion_buffer,
     1030 	     n_chars_out, new_nodes_idx, new_top_idx, code);
     1031 
     1032 /* Mark the limits of the nodes that we're sure are good in terminal memory.
     1033*   Note that we are not sure of the ones we just added or changed until we
     1034*   actually put them out to the terminal and it accepts them as OK. */
     1035 
     1036 	switch_data_block.n_nodes_in_list = new_nodes_idx - 1;
     1037 
     1038 	if code ^= 0 then return;
     1039 
     1040 /* The string seems fine.  Plow it out there. */
     1041 /* Mask event-calls, to prevent damn send_message from blurting in rawmode */
     1042 
     1043 	on cleanup call ipc_$unmask_ev_calls (0);
     1044 
     1045 	call ipc_$mask_ev_calls (code);
     1046 	if code ^= 0 then return;
     1047 
     1048 	call translate_and_output_graphic_code (expansion_buffer,
     1049 	     n_chars_out, code);
     1050 
     1051 	call ipc_$unmask_ev_calls (0);
     1052 
     1053 	return;
     1054 
     1055 /* format: ind3 */
     1056 preexpand_graphic_code: proc (instring, outstring, n_chars_out,
     1057       first_node_this_call, node_list_top, code);
     1058 
     1059 /* PARAMETERS */
     1060 
     1061 dcl  (instring	        char (*),
     1062      outstring	        char (*),
     1063      n_chars_out	        fixed bin (21),
     1064      first_node_this_call   fixed bin,
     1065      node_list_top	        fixed bin,
     1066      code		        fixed bin (35)) parameter;
     1067 
     1068 /* AUTOMATIC */
     1069 
     1070 dcl  already_there	        bit (1),
     1071      based_string_length    fixed bin (21),
     1072      based_string_ptr       pointer,
     1073      cur_level	        fixed bin,
     1074      dynamic	        bit (1),
     1075      effector_char	        char (1),
     1076      effector_length        fixed bin (21),
     1077      expanded_indx	        fixed bin (21),
     1078      expanded_effector_len  fixed bin (21),
     1079      gdt_ptr	        pointer,
     1080      i		        fixed bin (21),
     1081      indx		        fixed bin (21),
     1082      instring_length        fixed bin (21),
     1083      list_level	        fixed bin,
     1084      new_node_list_size     fixed bin,
     1085      node_list_ptr	        pointer,
     1086      node_uid	        char (3),
     1087      number_output	        fixed bin (21),
     1088      number_used	        fixed bin (21),
     1089      outdx	        fixed bin (21),
     1090      save_outdx	        fixed bin (21),
     1091      save_indx	        fixed bin (21),
     1092      temp_p	        pointer,
     1093      validate_this_node     bit (1),
     1094      zero_ok	        bit (1);
     1095 
     1096 dcl  1 effector_data_copy   like graphic_device_table.effector_data aligned;
     1097 
     1098 /* BASED AND DEFINED */
     1099 
     1100 dcl  1 stack	        based (static_stuff.stack_p),
     1101        2 stack_size	        fixed bin,
     1102        2 frames	        (static_stuff.stack_size refer (stack.stack_size)),
     1103          3 list_indx        fixed bin (21),
     1104          3 list_outdx       fixed bin (21),
     1105          3 first_owned_node fixed bin;
     1106 
     1107 dcl  1 static_node_table    aligned based (node_table_ptr),
     1108        2 node_list_size     fixed bin,
     1109        2 node_list	        (new_node_list_size
     1110 		        refer (static_node_table.node_list_size)) char (3);
     1111 
     1112 dcl  based_string	        char (based_string_length)
     1113 		        based (based_string_ptr),
     1114      based_string_array     (based_string_length) char (1) unaligned
     1115 		        based (based_string_ptr);
     1116 
     1117 dcl  outstring_char	        (length (outstring)) char (1) unaligned
     1118 		        defined (outstring);
     1119 
     1120 
     1121       node_table_ptr = switch_data_block.node_table_ptr;
     1122       gdt_ptr = device_state_block.gdt_ptr;
     1123       gdt_pointer = null;				/* for debugging */
     1124 
     1125       dynamic = device_state_block.dynamic;
     1126       instring_length = length (instring);
     1127       node_list_top = switch_data_block.n_nodes_in_list;
     1128       first_node_this_call = node_list_top + 1;
     1129       n_chars_out, outdx, list_level = 0;
     1130 
     1131       call ipc_$unmask_ev_calls (0);
     1132 
     1133 /* Scan the string.  Do pre-expansion and track levels and multiple node
     1134*   references.  Do everything before calling the GSP for code conversion. */
     1135 
     1136       do indx = 1 repeat (indx) while (indx <= instring_length);
     1137 
     1138          save_indx = indx;
     1139          save_outdx = outdx;
     1140 
     1141          call get_effector_info (addr (instring), indx, effector_char,
     1142 	  effector_length, effector_data_copy);


     1143 
     1144 
     1145 /* Check for special action characters */
     1146 
     1147          if effector_char = Node_begin_char then do;
     1148 
     1149 	     node_uid = substr (instring, save_indx + 2, 3);
     1150 
     1151 /* Check to see if we have run out of stack.  If so, grow it. */
     1152 
     1153 	     if list_level + 1 > static_stuff.stack_size then do;
     1154 		 static_stuff.stack_size = static_stuff.stack_size + 50;
     1155 		 temp_p = static_stuff.stack_p;
     1156 
     1157 		 allocate stack in (sys_area) set (static_stuff.stack_p);
     1158 
     1159 		 if temp_p ^= null then do;
     1160 
     1161 /* Copy old stack into new stack */
     1162 		       unspec (stack.frames) =
     1163 			unspec (temp_p -> stack.frames);
     1164 
     1165 		       free temp_p -> stack in (sys_area);
     1166 		    end;
     1167 	        end;
     1168 
     1169 	     list_level = list_level + 1;		/* bump stack */
     1170 
     1171 /* If we are communicating with an intelligent, dynamic terminal, we must
     1172*   keep a list of nodes which are resident in the terminal memory.  We use
     1173*   this list to optimize the sending of shared graphic objects by replacing
     1174*   them with Reference effectors.  Note that we only do this if the referenced
     1175*   object was sent over in the same structure we are processing at the
     1176*   moment (i.e., in the same write call)-- otherwise, we assume the user is
     1177*   resending it to redefine it. */
     1178 
     1179 	     if ^dynamic then
     1180 		already_there = ""b;
     1181 	     else do;
     1182 		 call add_node (node_uid, first_node_this_call,
     1183 		    node_list_top, already_there, code);
     1184 		 if code ^= 0 then return;
     1185 	        end;
     1186 
     1187 	     if already_there then do;
     1188 
     1189 		 if list_level = 1 then do;
     1190 		       code = graphic_error_table_$recursive_structure;
     1191 		       return;
     1192 		    end;
     1193 
     1194 		 else do;
     1195 		       substr (outstring, save_outdx + 1, 1)
     1196 			= Reference_char;
     1197 		       substr (outstring, save_outdx + 2, 3) = node_uid;
     1198 		       outdx = save_outdx + 4;
     1199 		    end;
     1200 
     1201 		 cur_level = list_level;
     1202 
     1203 /* Now scan the input string to throw away all the contents of the item that
     1204*   was just replaced by the Reference. */
     1205 
     1206 		 do i = indx + effector_length
     1207 		    repeat (i + effector_length)
     1208 		    while (list_level >= cur_level);
     1209 
     1210 		    if i > instring_length then do;
     1211 			code = graphic_error_table_$incomplete_structure;
     1212 			return;
     1213 		       end;
     1214 
     1215 		    effector_char = substr (instring, i, 1);
     1216 		    if effector_char = Node_begin_char then
     1217 		         list_level = list_level + 1;
     1218 		    else if effector_char = Node_end_char then
     1219 		         list_level = list_level - 1;
     1220 		    effector_length =
     1221 		       compute_effector_length (addr (instring), i, code);
     1222 		    if code ^= 0 then return;
     1223 		 end;
     1224 
     1225 		 effector_char = Reference_char;
     1226 		 indx = i;
     1227 		 unspec (effector_data_copy) =
     1228 		    unspec (gdt_ptr ->
     1229 		    graphic_device_table.effector_data (Reference));
     1230 		 effector_data_copy.expand = ""b;
     1231 	        end;
     1232 
     1233 	     else do;
     1234 		 stack (list_level).list_indx = save_indx;
     1235 		 stack (list_level).list_outdx = save_outdx;
     1236 		 stack (list_level).first_owned_node = node_list_top;
     1237 	        end;
     1238 	  end;
     1239 
     1240          else if effector_char = Node_end_char then do;
     1241 	     list_level = list_level - 1;
     1242 
     1243 	     if list_level < 0 then do;
     1244 		 code = graphic_error_table_$too_many_node_ends;
     1245 		 return;
     1246 	        end;
     1247 	  end;
     1248 
     1249          else if dynamic then do;
     1250 
     1251 /* If this is one of the dynamic effectors listed below, check to see what
     1252*   effect it will have on the nodes stored in the terminal. */
     1253 
     1254 	     validate_this_node = "1"b;
     1255 
     1256 	     if (effector_char = Increment_char
     1257 	        | effector_char = Alter_char
     1258 	        | effector_char = Control_char
     1259 	        | effector_char = Display_char) then
     1260 		zero_ok = ""b;
     1261 	     else if effector_char = Delete_char then zero_ok = "1"b;
     1262 	     else validate_this_node = ""b;
     1263 
     1264 	     if validate_this_node then
     1265 		if ^validate_node (node_uid, node_list_top, zero_ok)
     1266 		then do;
     1267 		      code = graphic_error_table_$node_not_active;
     1268 		      return;
     1269 		   end;
     1270 
     1271 	     if effector_char = Delete_char then do;
     1272 		 if node_uid = zero_node_id then do;
     1273 		       first_node_this_call = 1;
     1274 		       node_list_top = 0;
     1275 		    end;
     1276 
     1277 		 else do;
     1278 		       do i = 1 to node_list_top
     1279 			while (static_node_table.node_list (i)
     1280 			^= node_uid);
     1281 		       end;
     1282 
     1283 		       if i > node_list_top then do;
     1284 			   code = graphic_error_table_$node_not_active;
     1285 			   return;
     1286 			end;
     1287 
     1288 		       if i < first_node_this_call then
     1289 			  first_node_this_call =
     1290 			     first_node_this_call - 1;
     1291 		       node_list_top = node_list_top - 1;
     1292 
     1293 		       do i = i to node_list_top;
     1294 			static_node_table.node_list (i) =
     1295 			   static_node_table.node_list (i + 1);
     1296 		       end;
     1297 		    end;
     1298 	        end;
     1299 	  end;


     1300 
     1301 
     1302 /* Now do expansion and error checks as specified for this effector in the
     1303*   GDT. */
     1304 
     1305          if effector_char = Node_end_char then
     1306 	    effector_data_copy.expand = "0"b;
     1307 
     1308          if effector_data_copy.expand then do;
     1309 
     1310 /* we have hit an effector which the terminal cannot handle in a stacked
     1311*   fashion.  We expand the list containing it (taking care to account for the
     1312*   effector's own list level if it has one). */
     1313 
     1314 	     if effector_char ^= Node_begin_char then
     1315 		list_level = max (list_level - 1, 1);
     1316 
     1317 	     i = stack (list_level).list_indx;
     1318 	     outdx = stack (list_level).list_outdx;
     1319 	     node_list_top = stack (list_level).first_owned_node;
     1320 
     1321 	     based_string_length = instring_length - i + 1;
     1322 	     based_string_ptr =
     1323 	        addr (addr (instring) -> based_string_array (i));
     1324 
     1325 	     call graphic_compiler_$expand_string (based_string, number_used,
     1326 	        addr (outstring_char (outdx + 1)), number_output, code);
     1327 
     1328 	     if code ^= 0 then return;
     1329 
     1330 /* Scan the expanded string for error-producing effectors. We know that
     1331*   this array will contain no unique ID's for us to keep track of, nor will it
     1332*   contain dynamic effectors that would make us update our node list. */
     1333 
     1334 	     do expanded_indx = outdx + 1
     1335 	        repeat (expanded_indx + expanded_effector_len)
     1336 	        while (expanded_indx <= outdx + number_output);
     1337 
     1338 	        call get_effector_info (addr (outstring), expanded_indx, "",
     1339 		 expanded_effector_len, effector_data_copy);
     1340 
     1341 	        if effector_data_copy.error then do;
     1342 		    code = graphic_error_table_$unimplemented_effector;
     1343 		    return;
     1344 		 end;
     1345 	     end;
     1346 
     1347 	     indx = stack (list_level).list_indx + number_used;
     1348 	     outdx = outdx + number_output;
     1349 	     list_level = list_level - 1;
     1350 	  end;
     1351 
     1352          else if effector_data_copy.error then do;
     1353 	     code = graphic_error_table_$unimplemented_effector;
     1354 	     return;
     1355 	  end;
     1356 
     1357 /* Or if there's no processing to do, just copy it into the output buffer. */
     1358 
     1359          else if effector_char ^= Reference_char then do;
     1360 	     substr (outstring, outdx + 1, effector_length) =
     1361 	        substr (instring, indx, effector_length);
     1362 	     indx = indx + effector_length;
     1363 	     outdx = outdx + effector_length;
     1364 
     1365 	  end;
     1366       end;
     1367 
     1368       if list_level > 0 then do;
     1369 	  code = graphic_error_table_$incomplete_structure;
     1370 	  return;
     1371          end;
     1372 
     1373       n_chars_out = outdx;
     1374       code = 0;
     1375 
     1376       return;
     1377 
     1378 /* format: revert */
     1379 add_node: proc (node_uid, first_node_this_call, node_list_top, already_there,
     1380 	code);
     1381 
     1382 /* This routine keeps track of the resident node list. */
     1383 
     1384 /* PARAMETERS */
     1385 
     1386 dcl  (node_uid	        char (3),
     1387      first_node_this_call   fixed bin,
     1388      node_list_top	        fixed bin,
     1389      already_there	        bit (1),
     1390      code		        fixed bin (35)) parameter;
     1391 
     1392 /* AUTOMATIC */
     1393 
     1394 dcl  i		        fixed bin;
     1395 
     1396 
     1397 	code = 0;
     1398 
     1399 	if node_table_ptr = null then call grow_node_table (100);
     1400 
     1401 	do i = 1 to node_list_top
     1402 	     while (static_node_table.node_list (i) ^= node_uid);
     1403 	end;
     1404 
     1405 	if i > node_list_top then do;
     1406 		if node_uid = zero_node_id then do;
     1407 			code = graphic_error_table_$invalid_node_no;
     1408 
     1409 			call sub_err_ (code, "graphic_dim_",
     1410 			     "h", null, 0,
     1411 			     "Internal error while accounting for nodes in terminal memory.
     1412 Please report this occurrence to system maintenance personnel.");
     1413 			return;
     1414 		     end;
     1415 
     1416 		if i > dim (static_node_table.node_list, 1) then
     1417 		     call grow_node_table (i + 99);
     1418 
     1419 		static_node_table.node_list (i) = node_uid; /* add it */
     1420 		node_list_top = node_list_top + 1;
     1421 		already_there = ""b;		/* but is now! */
     1422 	     end;
     1423 
     1424 	else if i < first_node_this_call then do;
     1425 
     1426 /* This node is in the terminal memory, but was put there during graphic
     1427*   output previous to this call-- assume user is redefining. */
     1428 
     1429 		static_node_table.node_list (node_list_top + 1) =
     1430 		     static_node_table.node_list (i);
     1431 
     1432 		do i = i to node_list_top;
     1433 		     static_node_table.node_list (i) =
     1434 			static_node_table.node_list (i + 1);
     1435 		end;
     1436 
     1437 		first_node_this_call = first_node_this_call - 1;
     1438 		already_there = ""b;
     1439 	     end;
     1440 
     1441 	else already_there = "1"b;
     1442 
     1443 	return;
     1444 
     1445      end add_node;
     1446 
     1447 validate_node: proc (node_uid, node_list_top, zero_ok) returns (bit (1));
     1448 
     1449 /* PARAMETERS */
     1450 
     1451 dcl  (node_uid	        char (3),
     1452      node_list_top	        fixed bin,
     1453      zero_ok	        bit (1)) parameter;
     1454 
     1455 /* AUTOMATIC */
     1456 
     1457 dcl  i		        fixed bin;
     1458 
     1459 	do i = 1 to node_list_top
     1460 	     while (static_node_table.node_list (i) ^= node_uid);
     1461 	end;
     1462 
     1463 	if i <= node_list_top then return ("1"b);	/* it's there */
     1464 	if ((node_uid = zero_node_id) & zero_ok) then return ("1"b);
     1465 	return (""b);				/* punt */
     1466 
     1467      end validate_node;
     1468 
     1469 grow_node_table: proc (new_table_size);
     1470 
     1471 dcl  new_table_size	        fixed bin;
     1472 
     1473 dcl  i		        fixed bin,
     1474      temp_ptr	        pointer;
     1475 
     1476 
     1477 	temp_ptr = node_table_ptr;
     1478 	new_node_list_size = new_table_size;
     1479 
     1480 	allocate static_node_table in (sys_area) set (node_table_ptr);
     1481 
     1482 	if temp_ptr ^= null then do;
     1483 		unspec (static_node_table.node_list) =
     1484 		     unspec (temp_ptr -> static_node_table.node_list);
     1485 
     1486 		free temp_ptr -> static_node_table in (sys_area);
     1487 	     end;
     1488 
     1489 	return;
     1490 
     1491      end grow_node_table;
     1492    end preexpand_graphic_code;
     1493 
     1494 get_effector_info: proc (str_ptr, idx, eff_char, eff_len, eff_data);
     1495 
     1496 /* PARAMETERS */
     1497 
     1498 dcl  (str_ptr	        pointer,
     1499      idx		        fixed bin (21),
     1500      eff_char	        char (1),
     1501      eff_len	        fixed bin (21),
     1502      1 eff_data	        like graphic_device_table.effector_data aligned)
     1503 		        parameter;
     1504 
     1505 /* BASED */
     1506 
     1507 dcl  str		        char (sys_info$max_seg_size) based (str_ptr);
     1508 
     1509 /* This misdeclaration is unfortunate, but it keeps get_effector_info
     1510*   from needing descriptors which is a great efficiency consideration */
     1511 
     1512 
     1513 	eff_char = substr (str, idx, 1);
     1514 	eff_len = compute_effector_length (str_ptr, idx, code);
     1515 	if code ^= 0 then return;
     1516 
     1517 	unspec (eff_data) = unspec (gdt_ptr ->
     1518 	     graphic_device_table.effector_data (rank (eff_char)));
     1519 	return;
     1520 
     1521      end get_effector_info;



     1522 
     1523 compute_effector_length: proc (str_ptr, idx, code) returns (fixed bin (21));
     1524 
     1525 /* PARAMETER */
     1526 
     1527 dcl  (str_ptr	        pointer,
     1528      idx		        fixed bin (21),
     1529      code		        fixed bin (35)) parameter;
     1530 
     1531 /* AUTOMATIC */
     1532 
     1533 dcl  effector_rank	        fixed bin,
     1534      effector_length        fixed bin (21);
     1535 
     1536 /* BASED */
     1537 
     1538 dcl  str		        char (sys_info$max_seg_size) based (str_ptr);
     1539 
     1540 /* See comment in get_effector_info about such misdeclarations. */
     1541 
     1542 
     1543 	code = 0;
     1544 
     1545 	effector_rank = rank (substr (str, idx, 1));
     1546 
     1547 	if effector_rank < 32 then goto unrecognized;
     1548 	if effector_rank > 63 then do;
     1549 unrecognized:	code = graphic_error_table_$unrecognized_effector;
     1550 		return (0);
     1551 	     end;
     1552 
     1553 	effector_length = Graphic_Element_Lengths (effector_rank);
     1554 
     1555 /* length = 0 is a special case for a variable-length effector */
     1556 
     1557 	if effector_length = 0 then
     1558 	     effector_length = graphic_element_length_ (str, idx);
     1559 
     1560 	if effector_length <= 0 then do;
     1561 		code = graphic_error_table_$impossible_effector_length;
     1562 		return (0);
     1563 	     end;
     1564 
     1565 	return (effector_length);
     1566      end compute_effector_length;
     1567 
     1568 translate_and_output_graphic_code: proc (instring, instring_len, code);
     1569 
     1570 /* PARAMETERS */
     1571 
     1572 dcl  (instring	        char (*),
     1573      instring_len	        fixed bin (21),
     1574      code		        fixed bin (35)) parameter;
     1575 
     1576 /* AUTOMATIC */
     1577 
     1578 dcl  1 effector_data_copy   like graphic_device_table.effector_data
     1579 		        aligned automatic;
     1580 
     1581 dcl  effector_char	        char (1),
     1582      indx		        fixed bin (21),
     1583      effector_length        fixed bin (21),
     1584      based_effector_ptr     pointer;
     1585 
     1586 /* BASED */
     1587 
     1588 dcl  based_string_array     (max_string_size) based char (1) unaligned,
     1589      based_effector	        char (effector_length) based (based_effector_ptr);
     1590 
     1591 
     1592 	code = 0;
     1593 
     1594 /* At this point, the expanded and massaged graphics code is in
     1595*   expansion_buffer.  Now we simply gallop down the string, calling the GSP
     1596*   entries if appropriate and generally putting out scads and scads of
     1597*   terminal-dependent graphics code. */
     1598 
     1599 
     1600 	if ^device_state_block.in_rawo_mode then do;
     1601 		call set_modes_rawo;
     1602 
     1603 		call gdt_caller (Prepare_for_graphics,
     1604 		     (device_state_block.switch_name), code);
     1605 		if code ^= 0 then return;
     1606 	     end;
     1607 
     1608 
     1609 	do indx = 1 repeat (indx + effector_length)
     1610 	     while (indx <= instring_len);
     1611 
     1612 	     call get_effector_info (addr (expansion_buffer), indx,
     1613 		effector_char, effector_length, effector_data_copy);
     1614 
     1615 	     if effector_data_copy.flush then do;
     1616 		     call force_out_buffer ("1"b, code);
     1617 		     if code ^= 0 then return;
     1618 		end;
     1619 
     1620 	     if effector_data_copy.ignore then ;	/* skip it */
     1621 
     1622 	     else if effector_data_copy.call then do;
     1623 
     1624 /* The GSP wants to get its hands on this one and translate it. */
     1625 
     1626 		     based_effector_ptr = addr (addr (instring) ->
     1627 			based_string_array (indx));
     1628 
     1629 		     call gdt_caller (rank (effector_char), based_effector,
     1630 			code);
     1631 		     if code ^= 0 then return;
     1632 		end;
     1633 
     1634 	     else do;
     1635 		     substr (output_buffer, output_buffer_outdx + 1,
     1636 			effector_length) = based_effector; /* pass it on */
     1637 		     output_buffer_outdx =
     1638 			output_buffer_outdx + effector_length;
     1639 		end;
     1640 	end;
     1641 
     1642 	call force_out_buffer ("1"b, code);
     1643 
     1644 	return;
     1645 
     1646      end translate_and_output_graphic_code;
     1647 
     1648 gdt_caller: proc (effector_no, effector, code);
     1649 
     1650 /* PARAMETERS */
     1651 
     1652 dcl  (effector_no	        fixed bin,
     1653      effector	        char (*),
     1654      code		        fixed bin (35)) parameter;
     1655 
     1656 /* AUTOMATIC */
     1657 
     1658 dcl  number_output	        fixed bin (21),
     1659      part_output_len        fixed bin (21),
     1660      part_output_ptr        pointer;
     1661 
     1662 /* BASED */
     1663 
     1664 dcl  part_output_buffer     char (part_output_len) based (part_output_ptr);
     1665 
     1666 
     1667 	part_output_ptr = addr (switch_data_block.output_buffer_ptr ->
     1668 	     char_array (output_buffer_outdx + 1));
     1669 	part_output_len =
     1670 	     length (substr (output_buffer, output_buffer_outdx + 1));
     1671 	number_output, code = 0;
     1672 
     1673 	call device_state_block.gdt_proc (effector_no, effector,
     1674 	     part_output_buffer, number_output,
     1675 	     device_state_block.gdt_data_ptr, code);
     1676 
     1677 /* check for the obsolete error code convention from before GSP error codes. */
     1678 
     1679 	if number_output < 0 then code = -number_output;
     1680 
     1681 	if code ^= 0 then return;
     1682 
     1683 	output_buffer_outdx = output_buffer_outdx + number_output;
     1684 	call try_buffered_output ("1"b, code);
     1685 
     1686 	return;
     1687 
     1688      end gdt_caller;
     1689 
     1690 try_buffered_output: proc (graphical, code);
     1691 
     1692 /* This routine writes the contents of the output buffer to the terminal if
     1693*   the message size in the GDT has been attained. */
     1694 
     1695 /* PARAMETERS */
     1696 
     1697 dcl  (graphical	        bit (1),
     1698      code		        fixed bin (35)) parameter;
     1699 
     1700 
     1701 	code = 0;
     1702 
     1703 /* If we have reached the message_size threshhold, do output. */
     1704 
     1705 	if output_buffer_outdx
     1706 	     >= device_state_block.gdt_message_size then
     1707 	     call force_out_buffer (graphical, code);
     1708 
     1709 	return;
     1710 
     1711      end try_buffered_output;


     1712 
     1713 force_out_buffer: proc (graphical, code);
     1714 
     1715 /* This routine pumps the output buffer out to the terminal.  It also performs
     1716*   the status requests and interpretations from intelligent graphics
     1717*   terminals.  */
     1718 
     1719 /* PARAMETERS */
     1720 
     1721 dcl  (graphical	        bit (1),
     1722      code		        fixed bin (35)) parameter;
     1723 
     1724 /* AUTOMATIC */
     1725 
     1726 dcl  buffer_ptr	        pointer,
     1727      dynamic	        bit (1),
     1728      message_size	        fixed bin (21),
     1729      my_io_buffer_len       fixed bin (21),
     1730      n_chars_read	        fixed bin (21);
     1731 
     1732 	code = 0;
     1733 
     1734 	if output_buffer_outdx = 0 then return;
     1735 
     1736 /* get into proper mode-- raw or not-- depending on output type. */
     1737 
     1738 	if (graphical & ^device_state_block.in_rawo_mode) then
     1739 	     call set_modes_rawo;
     1740 
     1741 	else if (^graphical & device_state_block.in_rawo_mode) then
     1742 	     call set_modes_not_rawo;
     1743 
     1744 	if graphical then do;
     1745 		message_size = device_state_block.gdt_message_size;
     1746 		dynamic = device_state_block.dynamic;
     1747 	     end;
     1748 	else do;
     1749 		message_size = static_stuff.max_string_size;
     1750 		dynamic = ""b;
     1751 	     end;
     1752 
     1753 	on cleanup call cleanerup (0);
     1754 
     1755 /* If we are talking to an intelligent terminal, activate the ACK strategy. */
     1756 
     1757 	if dynamic then do;
     1758 		call iox_$modes (switch_data_block.target_switch_ptr,
     1759 		     rawi_mode, device_state_block.old_input_modes, code);
     1760 
     1761 /* The following call is made separately because the ARPANET rejects it. */
     1762 
     1763 		call iox_$modes (switch_data_block.target_switch_ptr,
     1764 		     noecho_mode, "", code);
     1765 
     1766 /* We can't handle any typeahead that may be waiting now, so flush it. */
     1767 
     1768 		call iox_$control (switch_data_block.target_switch_ptr,
     1769 		     "resetread", null, code);
     1770 	     end;
     1771 
     1772 	buffer_ptr = switch_data_block.output_buffer_ptr;
     1773 
     1774 
     1775 	do while (output_buffer_outdx > 0);
     1776 
     1777 	     my_io_buffer_len = min (output_buffer_outdx, message_size);
     1778 	     call iox_$put_chars (switch_data_block.target_switch_ptr,
     1779 		buffer_ptr, my_io_buffer_len, code);
     1780 	     if code ^= 0 then goto error_return;
     1781 
     1782 	     output_buffer_outdx = output_buffer_outdx - my_io_buffer_len;
     1783 	     buffer_ptr =
     1784 		addr (buffer_ptr -> char_array (my_io_buffer_len + 1));
     1785 
     1786 /* If doing graphics to an intelligent terminal, get an ACK from it now. */
     1787 
     1788 	     if dynamic then do;
     1789 		     call iox_$put_chars
     1790 			(switch_data_block.target_switch_ptr,
     1791 			addr (request_for_status),
     1792 			length (request_for_status), code);
     1793 		     if code ^= 0 then goto error_return;
     1794 
     1795 		     call iox_$get_line
     1796 			(switch_data_block.target_switch_ptr,
     1797 			addr (switch_data_block.status_buffer),
     1798 			length (switch_data_block.status_buffer),
     1799 			n_chars_read, code);
     1800 		     if code ^= 0 then goto error_return;
     1801 
     1802 		     call graphic_terminal_status_$decode
     1803 			(substr (switch_data_block.status_buffer, 1,
     1804 			n_chars_read), code);
     1805 		     if code ^= 0 then goto error_return;
     1806 		end;
     1807 	end;
     1808 
     1809 	call cleanerup (code);
     1810 
     1811 	output_buffer_outdx = 0;
     1812 	return;
     1813 
     1814 error_return:
     1815 	call cleanerup (0);
     1816 	return;



     1817 
     1818 cleanerup: proc (code);
     1819 
     1820 dcl  code		        fixed bin (35) parameter;
     1821 
     1822 	if dynamic then
     1823 	     call iox_$modes (switch_data_block.target_switch_ptr,
     1824 		device_state_block.old_input_modes, "", code);
     1825 	device_state_block.old_input_modes = "";
     1826 
     1827 	return;
     1828      end cleanerup;
     1829      end force_out_buffer;



     1830 
     1831 set_modes_rawo: proc;
     1832 
     1833 	call iox_$modes (switch_data_block.target_switch_ptr,
     1834 	     rawo_mode, device_state_block.old_output_modes, code);
     1835 	device_state_block.in_rawo_mode = "1"b;
     1836 
     1837 	return;
     1838 
     1839      end set_modes_rawo;



     1840 
     1841 set_modes_not_rawo: proc;
     1842 
     1843 	call iox_$modes (switch_data_block.target_switch_ptr,
     1844 	     device_state_block.old_output_modes, "", 0);
     1845 
     1846 	device_state_block.old_output_modes = "";
     1847 	device_state_block.in_rawo_mode = ""b;
     1848 
     1849 	return;
     1850 
     1851      end set_modes_not_rawo;
     1852 
     1853 get_to_text_mode: proc (code);
     1854 
     1855 /* PARAMETERS */
     1856 
     1857 dcl  code		        fixed bin (35) parameter;
     1858 
     1859 
     1860 	call gdt_caller (Prepare_for_text, (device_state_block.switch_name),
     1861 	     code);
     1862 	if code ^= 0 then return;
     1863 
     1864 	call force_out_buffer ("1"b, code);
     1865 	if code ^= 0 then return;
     1866 
     1867 	call set_modes_not_rawo;
     1868 
     1869 	return;
     1870 
     1871      end get_to_text_mode;
     1872 
     1873      end graphic_dim_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/18/82  1625.4  graphic_dim_.pl1                  >dumps>old>recomp>graphic_dim_.pl1
164          1    07/22/80  1335.1  iox_dcls.incl.pl1                 >ldd>include>iox_dcls.incl.pl1
166          2    07/02/81  1905.0  iocbv.incl.pl1                    >ldd>include>iocbv.incl.pl1
168          3    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
170          4    03/27/82  0439.2  graphic_device_table.incl.pl1     >ldd>include>graphic_device_table.incl.pl1
172          5    03/27/82  0439.2  graphic_code_dcl.incl.pl1         >ldd>include>graphic_code_dcl.incl.pl1
174          6    07/19/79  1547.1  io_call_info.incl.pl1             >ldd>include>io_call_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Alter_char                0(27) 000000 constant        char(1)                  initial level 3 packed unaligned dcl 5-8 ref 1256
Close                           000057 constant        fixed bin(17,0)          initial dcl 4-20 set ref 582 584*
Control_char              1(18) 000000 constant        char(1)                  initial level 3 packed unaligned dcl 5-8 ref 1256
Delete_char               2(27) 000000 constant        char(1)                  initial level 3 packed unaligned dcl 5-8 ref 1261
                                                                                  1271
Display_char              1(27) 000000 constant        char(1)                  initial level 3 packed unaligned dcl 5-8 ref 1256
Dynamic_and_structural_effectors
                                000000 constant        structure                level 2 dcl 5-8
Graphic_Code_Structure          000000 constant        structure                level 1 dcl 5-8
Graphic_Element_Lengths         000016 constant        fixed bin(17,0)          initial array dcl 5-60 ref 1553
Increment_char            0(18) 000000 constant        char(1)                  initial level 3 packed unaligned dcl 5-8 ref 1256
Modes                           000056 constant        fixed bin(17,0)          initial dcl 4-20 set ref 778* 812 838* 848*
Node_begin_char           1     000000 constant        char(1)                  initial level 3 packed unaligned dcl 5-8 ref 1147
                                                                                  1216 1314
Node_end_char             1(09) 000000 constant        char(1)                  initial level 3 packed unaligned dcl 5-8 ref 1218
                                                                                  1240 1305
Open                            000060 constant        fixed bin(17,0)          initial dcl 4-20 set ref 473 475*
Prepare_for_graphics            000062 constant        fixed bin(17,0)          initial dcl 4-20 set ref 1603*
Prepare_for_text                000061 constant        fixed bin(17,0)          initial dcl 4-20 set ref 1860*
Process_input                   000063 constant        fixed bin(17,0)          initial dcl 4-20 set ref 918 921 945 946*
Reference                              constant        fixed bin(17,0)          initial dcl 4-20 ref 1227
Reference_char            0(09) 000000 constant        char(1)                  initial level 3 packed unaligned dcl 5-8 ref 1195
                                                                                  1225 1359
Stream_input                           constant        fixed bin(17,0)          initial dcl 3-15 ref 527 534
Stream_input_output                    constant        fixed bin(17,0)          initial dcl 3-15 ref 527
Stream_output                          constant        fixed bin(17,0)          initial dcl 3-15 ref 527 537
a_effnum                               parameter       fixed bin(17,0)          dcl 496 ref 488 505
a_instring                             parameter       char                     unaligned dcl 496 ref 488 505
a_nchars                               parameter       fixed bin(21,0)          dcl 496 ref 488 505
a_obuffer                              parameter       char                     unaligned dcl 496 ref 488 505
a_statptr                              parameter       pointer                  dcl 496 ref 488 505
active_fn                       000174 automatic       bit(1)                   unaligned dcl 640 set ref 661* 670* 693 705
actual_iocb_ptr          12            based           pointer                  level 2 dcl 2-2 set ref 534 538 539 543 544 545 550*
                                                                                  561 596 598 599 600 602*
addr                                                   builtin function         dcl 160 ref 275 293 315 418 418 548 612 692 693 693
                                                                                  696 696 1141 1141 1220 1220 1322 1322 1325 1325
                                                                                  1338 1338 1612 1612 1626 1626 1667 1783 1789 1789
                                                                                  1795 1795
af_returnl               34            based           fixed bin(17,0)          level 2 dcl 6-10 ref 693 705
af_returnp               32            based           pointer                  level 2 dcl 6-10 ref 693 705
already_there                          parameter       bit(1)                   unaligned dcl 1386 in procedure "add_node" set ref
                                                                                  1379 1421* 1438* 1441*
already_there                   001110 automatic       bit(1)                   unaligned dcl 1070 in procedure
                                                                                  "preexpand_graphic_code" set ref 1179* 1182* 1187
args                     44            based           varying char             array level 2 dcl 6-10 ref 682
atd_len_no_gdt          142            based           fixed bin(17,0)          level 2 dcl 54 set ref 284* 443
attach_data_ptr          16            based           pointer                  level 2 dcl 2-2 set ref 294* 561
attach_descrip_ptr       14            based           pointer                  level 2 dcl 2-2 set ref 197 293* 625*
attach_description       60            based           varying char(128)        level 2 dcl 54 set ref 280* 282* 282 284 293 443*
                                                                                  443
based_buffer_ptrs                      based           pointer                  array dcl 88 set ref 275* 315* 612*
based_char_168                         based           char(168)                unaligned dcl 652 ref 683
based_effector                         based           char                     unaligned dcl 1588 set ref 1629* 1635
based_effector_ptr              001232 automatic       pointer                  dcl 1581 set ref 1626* 1629 1635
based_string                           based           char                     unaligned dcl 1112 set ref 1325*
based_string_array                     based           char(1)                  array unaligned dcl 1112 in procedure
                                                                                  "preexpand_graphic_code" set ref 1322
based_string_array                     based           char(1)                  array unaligned dcl 1588 in procedure
                                                                                  "translate_and_output_graphic_code" set ref 1626
based_string_length             001111 automatic       fixed bin(21,0)          dcl 1070 set ref 1321* 1325 1325
based_string_ptr                001112 automatic       pointer                  dcl 1070 set ref 1322* 1325
before                                                 builtin function         dcl 160 ref 416
buffer_ptr                      000100 automatic       pointer                  dcl 1726 set ref 1772* 1778* 1783* 1783
call                     32(01)        based           bit(1)                   array level 4 in structure "graphic_device_table"
                                                                                  packed unaligned dcl 4-7 in procedure
                                                                                  "graphic_dim_" ref 582 812 945
call                      0(01) 001226 automatic       bit(1)                   level 3 in structure "effector_data_copy" packed
                                                                                  unaligned dcl 1578 in procedure
                                                                                  "translate_and_output_graphic_code" set ref 1622
call                     32(01)        based           bit(1)                   array level 4 in structure "gdt" packed unaligned
                                                                                  dcl 470 in procedure "try_to_open_gdt" ref 473
caller_name               1            based           char(32)                 level 2 dcl 6-10 set ref 677* 746*
char32                          000756 automatic       varying char(32)         dcl 330 set ref 333* 334* 334 335* 335 336
char_array                             based           char(1)                  array unaligned dcl 88 set ref 1667 1783
charsizes                12            based           float bin(27)            array level 3 dcl 4-7 set ref 708*
cleanup                         000100 stack reference condition                dcl 156 ref 928 1043 1753
close                    36            based           entry variable           level 2 dcl 2-2 set ref 545*
code                                   parameter       fixed bin(35,0)          dcl 1857 in procedure "get_to_text_mode" set ref
                                                                                  1853 1860* 1862 1864* 1865
code                                   parameter       fixed bin(35,0)          dcl 1572 in procedure
                                                                                  "translate_and_output_graphic_code" set ref 1568
                                                                                  1592* 1603* 1605 1616* 1617 1629* 1631 1642*
code                                   parameter       fixed bin(35,0)          dcl 396 in procedure "associate_gdt" set ref 392
                                                                                  410* 418* 420 424* 432* 448* 450 454*
code                                   parameter       fixed bin(35,0)          dcl 307 in procedure "attach_error" set ref 305 309*
code                                   parameter       fixed bin(35,0)          dcl 180 in procedure "graphic_dim_" set ref 176 209*
                                                                                  211 211* 275* 278 278* 289* 290 290* 299* 488 502*
                                                                                  505 515* 518 530* 552* 565* 571 579* 580 584* 586
                                                                                  588* 589 604* 608 612* 615 631 663* 676* 685* 688
                                                                                  702* 740* 744 746* 748* 753 771* 772 778* 779 790*
                                                                                  793 802* 804 821* 831* 834 838* 840 844* 858 875*
                                                                                  876 879* 883 898* 899 902* 912* 922* 932* 938*
                                                                                  946* 949 954* 966* 982 999* 1011* 1012 1019* 1029*
                                                                                  1038 1045* 1046 1048* 1514* 1515 1833*
code                                   parameter       fixed bin(35,0)          dcl 1820 in procedure "cleanerup" set ref 1818 1822*
code                                   parameter       fixed bin(35,0)          dcl 1061 in procedure "preexpand_graphic_code" set
                                                                                  ref 1056 1182* 1184 1190* 1211* 1220* 1222 1244*
                                                                                  1267* 1284* 1325* 1328 1342* 1353* 1369* 1374*
code                                   parameter       fixed bin(35,0)          dcl 465 in procedure "try_to_open_gdt" set ref 461
                                                                                  475* 477 479* 480
code                                   parameter       fixed bin(35,0)          dcl 1697 in procedure "try_buffered_output" set ref
                                                                                  1690 1701* 1705*
code                                   parameter       fixed bin(35,0)          dcl 1652 in procedure "gdt_caller" set ref 1648
                                                                                  1671* 1673* 1679* 1681 1684*
code                                   parameter       fixed bin(35,0)          dcl 1386 in procedure "add_node" set ref 1379 1397*
                                                                                  1407* 1409*
code                                   parameter       fixed bin(35,0)          dcl 1721 in procedure "force_out_buffer" set ref
                                                                                  1713 1732* 1758* 1763* 1768* 1778* 1780 1789* 1793
                                                                                  1795* 1800 1802* 1805 1809*
code                                   parameter       fixed bin(35,0)          dcl 1527 in procedure "compute_effector_length" set
                                                                                  ref 1523 1543* 1549* 1561*
com_err_                        000042 constant        entry                    external dcl 99 ref 309
com_err_sw                             parameter       bit(1)                   dcl 180 ref 176 309
command_level                   000175 automatic       bit(1)                   unaligned dcl 640 set ref 660* 670* 674 692 705 744
control                  66            based           entry variable           level 2 dcl 2-2 set ref 544* 600*
cur_dsb_ptr                     000112 automatic       pointer                  dcl 187 set ref 195* 216 219* 225 226 228 228 235*
                                                                                  237 238 238 238 241 242 243 243 243 246 248 250
                                                                                  252 255 312 312 312* 371 436 438 439 440 443 448
                                                                                  448 473 475 483 562* 563 577 578 584 591 617 617
                                                                                  620 620* 705 708 708 720 722 770 874 897 926 932
                                                                                  946 975 1010 1122 1125 1517 1600 1603 1673 1673
                                                                                  1705 1738 1741 1745 1746 1758 1822 1825 1833 1835
                                                                                  1843 1846 1847 1860
cur_level                       001114 automatic       fixed bin(17,0)          dcl 1070 set ref 1201* 1206
data_ptr                               parameter       pointer                  dcl 635 set ref 631 658 683 692* 720 722 724 740*
detach_iocb              26            based           entry variable           level 2 dcl 2-2 set ref 297* 598*
device_data                            based           structure                level 2 in structure "gdt" dcl 406 in procedure
                                                                                  "associate_gdt"
device_data                            based           structure                level 2 in structure "gdt" dcl 470 in procedure
                                                                                  "try_to_open_gdt"
device_data              12            based           structure                level 2 in structure "device_info" dcl 647
                                                                                  in procedure "graphic_dim_" set ref 724*
device_data                            based           structure                level 2 in structure "graphic_device_table" dcl 4-7
                                                                                  in procedure "graphic_dim_" set ref 724
device_info                            based           structure                level 1 dcl 647
device_state_block                     based           structure                level 1 unaligned dcl 71 set ref 235 386
device_state_block_ptr
                          4            based           pointer                  level 2 dcl 54 set ref 255* 552 562
dim                                                    builtin function         dcl 160 ref 1416
dsb_ptr                                parameter       pointer                  dcl 343 ref 339 356 367 381 383 386
dynamic                  20(01)        based           bit(1)                   level 2 in structure "device_state_block" packed
                                                                                  unaligned dcl 71 in procedure "graphic_dim_" set
                                                                                  ref 243* 438* 1125 1746
dynamic                         001115 automatic       bit(1)                   unaligned dcl 1070 in procedure
                                                                                  "preexpand_graphic_code" set ref 1125* 1179 1249
dynamic                         000102 automatic       bit(1)                   unaligned dcl 1726 in procedure "force_out_buffer"
                                                                                  set ref 1746* 1750* 1757 1788 1822
eff_char                               parameter       char(1)                  unaligned dcl 1498 set ref 1494 1513* 1517
eff_data                               parameter       structure                level 1 dcl 1498 set ref 1494 1517*
eff_len                                parameter       fixed bin(21,0)          dcl 1498 set ref 1494 1514*
effector                               parameter       char                     unaligned dcl 1652 set ref 1648 1673*
effector_char                   001116 automatic       char(1)                  unaligned dcl 1070 in procedure
                                                                                  "preexpand_graphic_code" set ref 1141* 1147 1215*
                                                                                  1216 1218 1225* 1240 1256 1256 1256 1256 1261 1271
                                                                                  1305 1314 1359
effector_char                   001227 automatic       char(1)                  unaligned dcl 1581 in procedure
                                                                                  "translate_and_output_graphic_code" set ref 1612*
                                                                                  1629 1629
effector_data            32            based           structure                array level 2 in structure "graphic_device_table"
                                                                                  dcl 4-7 in procedure "graphic_dim_" ref 1227 1517
effector_data            32            based           structure                array level 2 in structure "gdt" dcl 470
                                                                                  in procedure "try_to_open_gdt"
effector_data            32            based           structure                array level 2 in structure "gdt" dcl 406
                                                                                  in procedure "associate_gdt"
effector_data_copy              001144 automatic       structure                level 1 dcl 1096 in procedure
                                                                                  "preexpand_graphic_code" set ref 1141* 1227* 1338*
effector_data_copy              001226 automatic       structure                level 1 dcl 1578 in procedure
                                                                                  "translate_and_output_graphic_code" set ref 1612*
effector_length                 001231 automatic       fixed bin(21,0)          dcl 1581 in procedure
                                                                                  "translate_and_output_graphic_code" set ref 1612*
                                                                                  1629 1629 1635 1635 1637 1640
effector_length                 001217 automatic       fixed bin(21,0)          dcl 1533 in procedure "compute_effector_length" set
                                                                                  ref 1553* 1557 1557* 1560 1565
effector_length                 001117 automatic       fixed bin(21,0)          dcl 1070 in procedure "preexpand_graphic_code" set
                                                                                  ref 1141* 1206 1220* 1223 1360 1360 1362 1363
effector_no                            parameter       fixed bin(17,0)          dcl 1652 set ref 1648 1673*
effector_rank                   001216 automatic       fixed bin(17,0)          dcl 1533 set ref 1545* 1547 1548 1553
error                    26            based           entry variable           level 2 in structure "io_call_info" dcl 6-10
                                                                                  in procedure "graphic_dim_" ref 677 746
error                    32(03)        based           bit(1)                   array level 4 in structure "graphic_device_table"
                                                                                  packed unaligned dcl 4-7 in procedure
                                                                                  "graphic_dim_" ref 921
error                     0(03) 001144 automatic       bit(1)                   level 3 in structure "effector_data_copy" packed
                                                                                  unaligned dcl 1096 in procedure
                                                                                  "preexpand_graphic_code" set ref 1341 1352
error_table_$bad_index          000076 external static fixed bin(35,0)          dcl 128 set ref 371*
error_table_$badopt             000100 external static fixed bin(35,0)          dcl 128 set ref 270*
error_table_$invalid_mode       000102 external static fixed bin(35,0)          dcl 128 ref 530
error_table_$long_record        000104 external static fixed bin(35,0)          dcl 128 ref 954
error_table_$negative_nelem     000106 external static fixed bin(35,0)          dcl 128 ref 912 999
error_table_$noarg              000110 external static fixed bin(35,0)          dcl 128 set ref 677*
error_table_$not_detached       000112 external static fixed bin(35,0)          dcl 128 set ref 197*
error_table_$unimplemented_version
                                000114 external static fixed bin(35,0)          dcl 128 ref 424 663
expand                          001144 automatic       bit(1)                   level 3 packed unaligned dcl 1096 set ref 1230*
                                                                                  1305* 1308
expand_pathname_                000044 constant        entry                    external dcl 99 ref 440
expanded_effector_len           001121 automatic       fixed bin(21,0)          dcl 1070 set ref 1338* 1345
expanded_indx                   001120 automatic       fixed bin(21,0)          dcl 1070 set ref 1334* 1334* 1338* 1345
expansion_buffer                       based           char                     unaligned dcl 992 set ref 1029* 1048* 1612 1612
expansion_buffer_ptr     22            based           pointer                  level 2 dcl 54 set ref 258* 1029 1048 1612 1612
find_command_$fc_no_message     000046 constant        entry                    external dcl 99 ref 418
first_dsb_ptr             2     000010 internal static pointer                  initial level 2 dcl 36 set ref 216 250 250* 356 363
                                                                                  381*
first_node_this_call                   parameter       fixed bin(17,0)          dcl 1061 in procedure "preexpand_graphic_code" set
                                                                                  ref 1056 1128* 1182* 1273* 1288 1288* 1288
first_node_this_call                   parameter       fixed bin(17,0)          dcl 1386 in procedure "add_node" set ref 1379 1424
                                                                                  1437* 1437
first_owned_node          3            based           fixed bin(17,0)          array level 3 dcl 1100 set ref 1236* 1319
flush                     0(04) 001226 automatic       bit(1)                   level 3 packed unaligned dcl 1578 set ref 1615
force_alignment                 001144 automatic       structure                level 2 in structure "effector_data_copy" dcl 1096
                                                                                  in procedure "preexpand_graphic_code"
force_alignment                 001226 automatic       structure                level 2 in structure "effector_data_copy" dcl 1578
                                                                                  in procedure "translate_and_output_graphic_code"
force_alignment          32            based           structure                array level 3 in structure "gdt" dcl 470
                                                                                  in procedure "try_to_open_gdt"
force_alignment          32            based           structure                array level 3 in structure "graphic_device_table"
                                                                                  dcl 4-7 in procedure "graphic_dim_"
found                           000776 automatic       bit(1)                   unaligned dcl 347 set ref 352* 357* 363 367* 371
frames                    1            based           structure                array level 2 unaligned dcl 1100 set ref 1162* 1162
from_switch               6            based           char(32)                 level 2 packed unaligned dcl 54 set ref 257* 275*
                                                                                  275* 315* 315* 612* 612*
gdt                                    based           structure                level 1 dcl 470 in procedure "try_to_open_gdt"
gdt                                    based           structure                level 1 dcl 406 in procedure "associate_gdt"
gdt_data_ptr            436            based           pointer                  level 2 dcl 71 set ref 238* 1673*
gdt_entrypoint_name             001012 automatic       char(168)                unaligned dcl 401 set ref 416* 418 418 418 418
gdt_message_size         21            based           fixed bin(21,0)          level 2 dcl 71 set ref 246* 439* 1705 1745
gdt_name                  4            based           char(32)                 level 2 in structure "device_state_block" packed
                                                                                  unaligned dcl 71 in procedure "graphic_dim_" set
                                                                                  ref 241* 440* 443 448 705 708* 720
gdt_name                               based           char(32)                 level 2 in structure "device_info" dcl 647
                                                                                  in procedure "graphic_dim_" set ref 720*
gdt_name_copy                   000114 automatic       char(168)                unaligned dcl 187 set ref 288* 289*
gdt_opened               20            based           bit(1)                   level 2 packed unaligned dcl 71 set ref 243* 473
                                                                                  483* 577 591*
gdt_pointer                     000106 automatic       pointer                  dcl 4-5 set ref 563* 582 708 708 708 708 708 724 810
                                                                                  812 918 921 945 1123*
gdt_proc                 14            based           entry variable           level 2 dcl 71 set ref 242* 448* 1673
gdt_ptr                   2            based           pointer                  level 2 in structure "device_state_block" dcl 71
                                                                                  in procedure "graphic_dim_" set ref 238* 436* 552*
                                                                                  563 708* 722 1122 1517
gdt_ptr                         001122 automatic       pointer                  dcl 1070 in procedure "preexpand_graphic_code" set
                                                                                  ref 1122* 1227
gdt_ptr                                parameter       pointer                  dcl 465 in procedure "try_to_open_gdt" ref 461 473
gdt_ptr                         001064 automatic       pointer                  dcl 401 in procedure "associate_gdt" set ref 418*
                                                                                  422 422 430 430 436 438 439 448* 454*
gdt_version_2                          constant        fixed bin(17,0)          initial dcl 4-3 ref 422 810
get_chars                46            based           entry variable           level 2 dcl 2-2 set ref 539*
get_line                 42            based           entry variable           level 2 dcl 2-2 set ref 538*
get_system_free_area_           000050 constant        entry                    external dcl 99 ref 201
get_temp_segments_              000052 constant        entry                    external dcl 99 ref 275
graphic                   2            based           bit(1)                   level 2 packed unaligned dcl 54 set ref 264* 266*
                                                                                  268* 272 282 409 539 552 575 702 777 809 893 1006
graphic_compiler_$expand_string 000054 constant        entry                    external dcl 99 ref 1325
graphic_device_table                   based           structure                level 1 dcl 4-7
graphic_element_length_         000056 constant        entry                    external dcl 99 ref 1557
graphic_error_table_$gdt_missing
                                000116 external static fixed bin(35,0)          dcl 139 ref 502
graphic_error_table_$impossible_effector_length
                                000120 external static fixed bin(35,0)          dcl 139 ref 1561
graphic_error_table_$incomplete_structure
                                000122 external static fixed bin(35,0)          dcl 139 ref 1211 1369
graphic_error_table_$invalid_node_no
                                000124 external static fixed bin(35,0)          dcl 139 ref 1407
graphic_error_table_$node_not_active
                                000126 external static fixed bin(35,0)          dcl 139 ref 1267 1284
graphic_error_table_$nongraphic_switch
                                000130 external static fixed bin(35,0)          dcl 139 ref 410 702
graphic_error_table_$not_a_gdt  000132 external static fixed bin(35,0)          dcl 139 ref 432
graphic_error_table_$recursive_structure
                                000134 external static fixed bin(35,0)          dcl 139 ref 1190
graphic_error_table_$too_many_node_ends
                                000136 external static fixed bin(35,0)          dcl 139 ref 1244
graphic_error_table_$unimplemented_effector
                                000140 external static fixed bin(35,0)          dcl 139 ref 922 1342 1353
graphic_error_table_$unrecognized_effector
                                000142 external static fixed bin(35,0)          dcl 139 ref 1549
graphic_terminal_status_$decode 000060 constant        entry                    external dcl 99 ref 1802
graphical                              parameter       bit(1)                   unaligned dcl 1721 in procedure "force_out_buffer"
                                                                                  ref 1713 1738 1741 1744
graphical                              parameter       bit(1)                   unaligned dcl 1697 in procedure
                                                                                  "try_buffered_output" set ref 1690 1705*
hbound                                                 builtin function         dcl 160 ref 264 287
hcs_$make_entry                 000062 constant        entry                    external dcl 99 ref 448
i                               001170 automatic       fixed bin(17,0)          dcl 1457 in procedure "validate_node" set ref 1459*
                                                                                  1459* 1463
i                               000322 automatic       fixed bin(17,0)          dcl 762 in procedure "graphic_dim_" set ref 819* 823
                                                                                  824 825 827 829* 829
i                               001156 automatic       fixed bin(17,0)          dcl 1394 in procedure "add_node" set ref 1401* 1401*
                                                                                  1405 1416 1416 1419 1424 1429 1432* 1432* 1433
                                                                                  1433*
i                               001124 automatic       fixed bin(21,0)          dcl 1070 in procedure "preexpand_graphic_code" set
                                                                                  ref 1206* 1210 1215 1220* 1223* 1226 1278* 1278*
                                                                                  1283 1288 1293* 1293* 1294 1294* 1317* 1321 1322
idx                                    parameter       fixed bin(21,0)          dcl 1498 in procedure "get_effector_info" set ref
                                                                                  1494 1513 1514*
idx                                    parameter       fixed bin(21,0)          dcl 1527 in procedure "compute_effector_length" set
                                                                                  ref 1523 1545 1557*
ignore                   32(02)        based           bit(1)                   array level 4 in structure "graphic_device_table"
                                                                                  packed unaligned dcl 4-7 in procedure
                                                                                  "graphic_dim_" ref 918
ignore                                 parameter       bit(1)                   unaligned dcl 522 in procedure "graphic_dim_" ref
                                                                                  518
ignore                    0(02) 001226 automatic       bit(1)                   level 3 in structure "effector_data_copy" packed
                                                                                  unaligned dcl 1578 in procedure
                                                                                  "translate_and_output_graphic_code" set ref 1620
in_rawo_mode                           based           bit(1)                   level 2 packed unaligned dcl 71 set ref 243* 578 770
                                                                                  874 897 1010 1600 1738 1741 1835* 1847*
index                                                  builtin function         dcl 160 ref 824
indx                            001125 automatic       fixed bin(21,0)          dcl 1070 in procedure "preexpand_graphic_code" set
                                                                                  ref 1136* 1136* 1138 1141* 1206 1226* 1347* 1360
                                                                                  1362* 1362* 1366
indx                            001230 automatic       fixed bin(21,0)          dcl 1581 in procedure
                                                                                  "translate_and_output_graphic_code" set ref 1609*
                                                                                  1609* 1612* 1626* 1640
info_gdt_ptr             10            based           pointer                  level 2 dcl 647 set ref 722*
instring                               parameter       char                     unaligned dcl 1572 in procedure
                                                                                  "translate_and_output_graphic_code" set ref 1568
                                                                                  1626
instring                               parameter       char                     unaligned dcl 1061 in procedure
                                                                                  "preexpand_graphic_code" set ref 1056 1126 1141
                                                                                  1141 1149 1215 1220 1220 1322 1360
instring_len                           parameter       fixed bin(21,0)          dcl 1572 ref 1568 1609
instring_length                 001126 automatic       fixed bin(21,0)          dcl 1070 set ref 1126* 1136 1210 1321
io_buffer                              based           char                     unaligned dcl 888 set ref 958* 1015 1029*
io_buffer_len                          parameter       fixed bin(21,0)          dcl 863 set ref 858 879* 883 902* 911 916 951 955
                                                                                  958 966* 982 998 1003 1015 1015 1017 1029 1029
io_buffer_ptr                          parameter       pointer                  dcl 863 set ref 858 879* 883 902* 958 966* 982 1015
                                                                                  1029
io_call_af_ret                         based           varying char             dcl 6-25 set ref 693* 705*
io_call_info                           based           structure                level 1 dcl 6-10
io_call_infop                   000110 automatic       pointer                  dcl 6-8 set ref 658* 659 662 674 677 677 682 693 693
                                                                                  696 705 705 708 746 746
ioa_$rsnnl                      000064 constant        entry                    external dcl 99 ref 693 797
iocb                                   based           structure                level 1 dcl 2-2
iocb_ptr                               parameter       pointer                  dcl 180 set ref 176 197 257 293 294 296 297 301* 454
                                                                                  518 534 538 539 543 544 545 548 550 561 571 596
                                                                                  598 599 600 602 608 625 627* 631 753 858 883 982
iox_$control                    000146 constant        entry                    external dcl 1-6 ref 740 1768
iox_$err_no_operation           000150 constant        entry                    external dcl 1-6 ref 600
iox_$find_iocb                  000152 constant        entry                    external dcl 1-6 ref 209
iox_$get_chars                  000154 constant        entry                    external dcl 1-6 ref 879
iox_$get_line                   000156 constant        entry                    external dcl 1-6 ref 902 966 1795
iox_$modes                      000160 constant        entry                    external dcl 1-6 ref 790 802 831 844 932 938 975
                                                                                  1758 1763 1822 1833 1843
iox_$propagate                  000162 constant        entry                    external dcl 1-6 ref 301 550 602 627
iox_$put_chars                  000164 constant        entry                    external dcl 1-6 ref 1778 1789
iox_modes                       000064 constant        char(24)                 initial array dcl 3-6 ref 547
ipc_$mask_ev_calls              000066 constant        entry                    external dcl 99 ref 930 1045
ipc_$unmask_ev_calls            000070 constant        entry                    external dcl 99 ref 1043 1051 1131
j                               000323 automatic       fixed bin(17,0)          dcl 762 set ref 824* 825 825* 827 829
length                                                 builtin function         dcl 160 ref 284 418 418 820 825 1117 1126 1669 1789
                                                                                  1789 1795 1795
list_indx                 1            based           fixed bin(21,0)          array level 3 dcl 1100 set ref 1234* 1317 1347
list_level                      001127 automatic       fixed bin(17,0)          dcl 1070 set ref 1129* 1153 1169* 1169 1189 1201
                                                                                  1206 1216* 1216 1218* 1218 1234 1235 1236 1241*
                                                                                  1241 1243 1314* 1314 1317 1318 1319 1347 1349*
                                                                                  1349 1368
list_outdx                2            based           fixed bin(21,0)          array level 3 dcl 1100 set ref 1235* 1318
max                                                    builtin function         dcl 160 ref 1314
max_arglen               43            based           fixed bin(17,0)          level 2 dcl 6-10 ref 682 682
max_string_size           7     000010 internal static fixed bin(21,0)          initial level 2 dcl 36 set ref 202* 246 781 958 1015
                                                                                  1029 1029 1048 1048 1612 1612 1635 1669 1749
message_size             15            based           fixed bin(35,0)          level 3 in structure "gdt" dcl 406 in procedure
                                                                                  "associate_gdt" ref 439
message_size                    000103 automatic       fixed bin(21,0)          dcl 1726 in procedure "force_out_buffer" set ref
                                                                                  1745* 1749* 1777
message_size             15            based           fixed bin(35,0)          level 3 in structure "graphic_device_table" dcl 4-7
                                                                                  in procedure "graphic_dim_" set ref 708*
min                                                    builtin function         dcl 160 ref 1777
modes                    56            based           entry variable           level 2 dcl 2-2 set ref 543*
my_io_buffer_len                000104 automatic       fixed bin(21,0)          dcl 1726 set ref 1777* 1778* 1782 1783
n_buffers                16            based           fixed bin(17,0)          level 2 dcl 54 set ref 272* 273* 275 315 612
n_chars_out                            parameter       fixed bin(21,0)          dcl 1061 in procedure "preexpand_graphic_code" set
                                                                                  ref 1056 1129* 1373*
n_chars_out                     000735 automatic       fixed bin(21,0)          dcl 986 in procedure "graphic_dim_" set ref 1029*
                                                                                  1048*
n_chars_read                    000105 automatic       fixed bin(21,0)          dcl 1726 in procedure "force_out_buffer" set ref
                                                                                  1795* 1802 1802
n_chars_read                           parameter       fixed bin(21,0)          dcl 863 in procedure "graphic_dim_" set ref 858 879*
                                                                                  883 902* 909* 951* 955* 958 958 966*
n_nodes_in_list          26            based           fixed bin(17,0)          level 2 dcl 54 set ref 261* 1036* 1127
name                      1            based           char(32)                 level 2 dcl 2-2 ref 257
nargs                    42            based           fixed bin(17,0)          level 2 dcl 6-10 ref 674
new_modes                              parameter       char                     unaligned dcl 757 set ref 753 802* 820 824 825 827
                                                                                  844*
new_modes_len                   000324 automatic       fixed bin(17,0)          dcl 762 set ref 820* 823
new_node_list_size              001130 automatic       fixed bin(17,0)          dcl 1070 set ref 1478* 1480 1480
new_nodes_idx                   000736 automatic       fixed bin(17,0)          dcl 986 set ref 1029* 1036
new_table_size                         parameter       fixed bin(17,0)          dcl 1471 ref 1469 1478
new_top_idx                     000737 automatic       fixed bin(17,0)          dcl 986 set ref 1029*
next_dsb_ptr            440            based           pointer                  level 2 dcl 71 set ref 221 238* 252* 367 369 381
                                                                                  383* 383
node_list                 1            based           char(3)                  array level 2 dcl 1107 set ref 1278 1294* 1294 1401
                                                                                  1416 1419* 1429* 1429 1433* 1433 1459 1483* 1483
node_list_size                         based           fixed bin(17,0)          level 2 dcl 1107 set ref 1416 1480* 1483 1483 1486
node_list_top                          parameter       fixed bin(17,0)          dcl 1061 in procedure "preexpand_graphic_code" set
                                                                                  ref 1056 1127* 1128 1182* 1236 1264* 1274* 1278
                                                                                  1283 1291* 1291 1293 1319*
node_list_top                          parameter       fixed bin(17,0)          dcl 1451 in procedure "validate_node" ref 1447 1459
                                                                                  1463
node_list_top                          parameter       fixed bin(17,0)          dcl 1386 in procedure "add_node" set ref 1379 1401
                                                                                  1405 1420* 1420 1429 1432
node_table_ptr           24            based           pointer                  level 2 dcl 54 set ref 258* 1121* 1121 1278 1294
                                                                                  1294 1399 1401 1416 1419 1429 1429 1433 1433 1459
                                                                                  1477 1480* 1483
node_uid                               parameter       char(3)                  unaligned dcl 1451 in procedure "validate_node" ref
                                                                                  1447 1459 1464
node_uid                        001131 automatic       char(3)                  unaligned dcl 1070 in procedure
                                                                                  "preexpand_graphic_code" set ref 1149* 1182* 1197
                                                                                  1264* 1272 1278
node_uid                               parameter       char(3)                  unaligned dcl 1386 in procedure "add_node" ref 1379
                                                                                  1401 1406 1419
noecho_mode              10     000010 internal static char(40)                 initial level 2 packed unaligned dcl 36 set ref 729*
                                                                                  735* 938* 1763*
null                                                   builtin function         dcl 160 ref 195 197 200 216 216 225 238 250 258 311
                                                                                  312 315 358 363 371 371 381 454 596 625 1123 1159
                                                                                  1399 1409 1409 1482 1768 1768
number_output                   001132 automatic       fixed bin(21,0)          dcl 1070 in procedure "preexpand_graphic_code" set
                                                                                  ref 1325* 1334 1348
number_output                   001242 automatic       fixed bin(21,0)          dcl 1658 in procedure "gdt_caller" set ref 1671*
                                                                                  1673* 1679 1679 1683
number_used                     001133 automatic       fixed bin(21,0)          dcl 1070 set ref 1325* 1347
old_gdt_modes                   000525 automatic       char(512)                unaligned dcl 762 set ref 781* 786* 793 795 797*
                                                                                  848*
old_input_modes         236            based           char(512)                initial level 2 packed unaligned dcl 71 set ref 235*
                                                                                  926* 932* 975* 1758* 1822* 1825*
old_modes                              parameter       char                     unaligned dcl 757 set ref 753 793* 795* 797*
old_output_modes         36            based           char(512)                initial level 2 packed unaligned dcl 71 set ref 235*
                                                                                  1833* 1843* 1846*
old_sw_modes                    000325 automatic       char(512)                unaligned dcl 762 set ref 790* 795 797 797 802* 844*
open                     32            based           entry variable           level 2 dcl 2-2 set ref 296* 599*
open_descrip_ptr         20            based           pointer                  level 2 dcl 2-2 set ref 454 548* 596*
open_description        121            based           varying char(64)         level 2 dcl 54 set ref 547* 548
open_mode                              parameter       fixed bin(17,0)          dcl 522 ref 518 527 527 527 534 537 547
option_array                           parameter       varying char             array dcl 180 ref 176 209 219 237 264 266 268 280
                                                                                  287 288
order_name               11            based           char(32)                 level 2 dcl 6-10 ref 659
outdx                           001134 automatic       fixed bin(21,0)          dcl 1070 set ref 1129* 1139 1198* 1318* 1325 1325
                                                                                  1334 1334 1348* 1348 1360 1363* 1363 1373
output_buffer                          based           char                     unaligned dcl 88 set ref 781 958 1015* 1635* 1669
output_buffer_outdx             000166 automatic       fixed bin(21,0)          dcl 187 set ref 564* 781 783* 839* 951 951 1015
                                                                                  1017* 1017 1635 1637* 1637 1667 1669 1683* 1683
                                                                                  1705 1734 1775 1777 1782* 1782 1811*
output_buffer_ptr        20            based           pointer                  level 2 dcl 54 set ref 258* 275 315 315 612 781 958
                                                                                  1015 1635 1667 1669 1772
outstring                              parameter       char                     unaligned dcl 1061 set ref 1056 1117 1195* 1197*
                                                                                  1325 1325 1325 1325 1338 1338 1360*
outstring_char                         defined         char(1)                  array unaligned dcl 1117 set ref 1325 1325
part_output_buffer                     based           char                     unaligned dcl 1664 set ref 1673*
part_output_len                 001243 automatic       fixed bin(21,0)          dcl 1658 set ref 1669* 1673 1673
part_output_ptr                 001244 automatic       pointer                  dcl 1658 set ref 1667* 1673
points_per_inch          16            based           float bin(63)            level 3 dcl 4-7 set ref 708*
prefix                                 parameter       char                     unaligned dcl 330 ref 328 333
prev_tp                         001000 automatic       pointer                  dcl 347 set ref 358* 366* 379
put_chars                52            based           entry variable           level 2 dcl 2-2 set ref 534*
rank                                                   builtin function         dcl 160 ref 1517 1545 1629 1629
rawi_mode                25     000010 internal static char(16)                 initial level 2 packed unaligned dcl 36 set ref 729*
                                                                                  733* 932* 1758*
rawo_mode                22     000010 internal static char(12)                 initial level 2 packed unaligned dcl 36 set ref 729*
                                                                                  734* 1833*
reference_count          22            based           fixed bin(17,0)          level 2 dcl 71 set ref 228* 228 248* 312 617* 617
                                                                                  620
release_temp_segments_          000072 constant        entry                    external dcl 99 ref 315 612
report                   22            based           entry variable           level 2 dcl 6-10 ref 696 708
request                         000176 automatic       char(168)                unaligned dcl 640 set ref 659* 664* 669* 673 688*
                                                                                  691 700 729 732 746*
request_arg                            parameter       char                     unaligned dcl 635 set ref 631 657 661 669 740*
request_for_status              000014 constant        char(1)                  initial dcl 5-72 set ref 1789 1789 1789 1789
rtrim                                                  builtin function         dcl 160 ref 797 797 820 827
save_indx                       001136 automatic       fixed bin(21,0)          dcl 1070 set ref 1138* 1149 1234
save_outdx                      001135 automatic       fixed bin(21,0)          dcl 1070 set ref 1139* 1195 1197 1198 1235
sdb_ptr                         000170 automatic       pointer                  dcl 187 set ref 195* 205* 209 226 255 257 258 258
                                                                                  258 261 262 264 266 268 272 272 273 275 275 275
                                                                                  275 280 282 282 282 284 284 293 294 311 315 315
                                                                                  315 315 315 320 409 443 443 443 539 547 548 552
                                                                                  552 561* 562 575 612 612 612 612 623 692 693 693
                                                                                  696 696 702 740 777 781 790 802 809 831 844 879
                                                                                  893 902 932 938 958 966 975 1006 1015 1029 1036
                                                                                  1048 1121 1121 1127 1278 1294 1294 1399 1401 1416
                                                                                  1419 1429 1429 1433 1433 1459 1477 1480 1483 1612
                                                                                  1612 1635 1667 1669 1758 1763 1768 1772 1778 1789
                                                                                  1795 1795 1795 1795 1795 1802 1802 1822 1833 1843
single_mode                     000725 automatic       char(32)                 unaligned dcl 762 set ref 827* 831* 838*
stack                                  based           structure                level 1 unaligned dcl 1100 set ref 1157 1165
stack_p                   4     000010 internal static pointer                  initial level 2 dcl 36 set ref 1155 1157* 1162 1234
                                                                                  1235 1236 1317 1318 1319 1347
stack_size                6     000010 internal static fixed bin(17,0)          initial level 2 in structure "static_stuff" dcl 36
                                                                                  in procedure "graphic_dim_" set ref 1153 1154*
                                                                                  1154 1157 1157
stack_size                             based           fixed bin(17,0)          level 2 in structure "stack" dcl 1100 in procedure
                                                                                  "preexpand_graphic_code" set ref 1157* 1162 1162
                                                                                  1165
static_node_table                      based           structure                level 1 dcl 1107 set ref 1480 1486
static_stuff                    000010 internal static structure                level 1 unaligned dcl 36
status_buffer            27            based           char(100)                level 2 packed unaligned dcl 54 set ref 262* 1795
                                                                                  1795 1795 1795 1802 1802
str                                    based           char                     unaligned dcl 1507 in procedure "get_effector_info"
                                                                                  ref 1513
str                                    based           char                     unaligned dcl 1538 in procedure
                                                                                  "compute_effector_length" set ref 1545 1557*
str_ptr                                parameter       pointer                  dcl 1527 in procedure "compute_effector_length" ref
                                                                                  1523 1545 1557
str_ptr                                parameter       pointer                  dcl 1498 in procedure "get_effector_info" set ref
                                                                                  1494 1513 1514*
sub_err_                        000074 constant        entry                    external dcl 99 ref 371 1409
substr                                                 builtin function         dcl 160 set ref 443 781 824 825 827 958* 958 1015*
                                                                                  1149 1195* 1197* 1215 1360* 1360 1513 1545 1635*
                                                                                  1669 1802 1802
suffix                                 parameter       char                     unaligned dcl 330 ref 328 335
switch_data_block                      based           structure                level 1 unaligned dcl 54 set ref 205 320 623 692 693
                                                                                  693 696 696
switch_name              23            based           char(32)                 level 2 packed unaligned dcl 71 set ref 219 237*
                                                                                  371* 475* 584* 946* 1603 1860
sys_area                               based           area(1024)               dcl 88 ref 205 235 320 386 623 1157 1165 1480 1486
sys_area_p                      000010 internal static pointer                  initial level 2 dcl 36 set ref 200 201* 205 235 320
                                                                                  386 623 1157 1165 1480 1486
sys_info$max_seg_size           000144 external static fixed bin(35,0)          dcl 152 ref 202 1513 1545 1557 1557
table_name                      000250 automatic       char(168)                unaligned dcl 640 in procedure "graphic_dim_" set
                                                                                  ref 682* 683* 685* 688
table_name                             parameter       char                     unaligned dcl 396 in procedure "associate_gdt" set
                                                                                  ref 392 416 440*
target_ptr               34            based           pointer                  level 2 dcl 71 set ref 226*
target_switch_ptr                      based           pointer                  level 2 dcl 54 set ref 209* 226 740* 790* 802* 831*
                                                                                  844* 879* 902* 932* 938* 966* 975* 1758* 1763*
                                                                                  1768* 1778* 1789* 1795* 1822* 1833* 1843*
temp_p                          001140 automatic       pointer                  dcl 1070 set ref 1155* 1159 1162 1165
temp_ptr                        001200 automatic       pointer                  dcl 1473 set ref 1477* 1482 1483 1486
terminal_name             1            based           char(32)                 level 3 dcl 4-7 set ref 708*
terminal_type            11            based           char(4)                  level 3 in structure "gdt" dcl 406 in procedure
                                                                                  "associate_gdt" ref 430 430 438
terminal_type            11            based           char(4)                  level 3 in structure "graphic_device_table" dcl 4-7
                                                                                  in procedure "graphic_dim_" set ref 708*
tp                              001002 automatic       pointer                  dcl 347 in procedure "free_dsb" set ref 363* 363*
                                                                                  366 367* 369 379* 381 383
tp                              000172 automatic       pointer                  dcl 187 in procedure "graphic_dim_" set ref 216*
                                                                                  216* 219 219* 221 252
unspec                                                 builtin function         dcl 160 set ref 724* 724 1162* 1162 1227* 1227 1483*
                                                                                  1483 1517* 1517
validate_this_node              001142 automatic       bit(1)                   unaligned dcl 1070 set ref 1254* 1262* 1264
version                                based           fixed bin(17,0)          level 2 dcl 6-10 ref 662
version_number                         based           fixed bin(17,0)          level 3 in structure "graphic_device_table" dcl 4-7
                                                                                  in procedure "graphic_dim_" ref 810
version_number                         based           fixed bin(17,0)          level 3 in structure "gdt" dcl 406 in procedure
                                                                                  "associate_gdt" ref 422 422
zero_node_id                    000015 constant        char(3)                  initial unaligned dcl 5-70 ref 1272 1406 1464
zero_ok                                parameter       bit(1)                   unaligned dcl 1451 in procedure "validate_node" ref
                                                                                  1447 1464
zero_ok                         001143 automatic       bit(1)                   unaligned dcl 1070 in procedure
                                                                                  "preexpand_graphic_code" set ref 1256* 1261* 1264*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Array_char                             internal static char(1)                  initial dcl 5-74
Direct_input                           internal static fixed bin(17,0)          initial dcl 3-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 3-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 3-15
Expansion                              internal static fixed bin(17,0)          initial dcl 4-20
Graphic_Defaults                       internal static structure                level 1 dcl 5-47
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 3-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 3-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 3-15
List_char                              internal static char(1)                  initial dcl 5-74
Sequential_input                       internal static fixed bin(17,0)          initial dcl 3-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 3-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 3-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 3-15
binary                                                 builtin function         dcl 160
error_table_$not_attached              external static fixed bin(35,0)          dcl 128
found                                  automatic       bit(1)                   unaligned dcl 187
i                                      automatic       fixed bin(17,0)          dcl 1473
iox_$attach_name                000000 constant        entry                    external dcl 1-6
iox_$attach_ptr                 000000 constant        entry                    external dcl 1-6
iox_$close                      000000 constant        entry                    external dcl 1-6
iox_$delete_record              000000 constant        entry                    external dcl 1-6
iox_$destroy_iocb               000000 constant        entry                    external dcl 1-6
iox_$detach_iocb                000000 constant        entry                    external dcl 1-6
iox_$err_not_attached           000000 constant        entry                    external dcl 1-6
iox_$err_not_closed             000000 constant        entry                    external dcl 1-6
iox_$err_not_open               000000 constant        entry                    external dcl 1-6
iox_$error_output                      external static pointer                  dcl 1-35
iox_$find_iocb_n                000000 constant        entry                    external dcl 1-6
iox_$look_iocb                  000000 constant        entry                    external dcl 1-6
iox_$move_attach                000000 constant        entry                    external dcl 1-6
iox_$open                       000000 constant        entry                    external dcl 1-6
iox_$position                   000000 constant        entry                    external dcl 1-6
iox_$read_key                   000000 constant        entry                    external dcl 1-6
iox_$read_length                000000 constant        entry                    external dcl 1-6
iox_$read_record                000000 constant        entry                    external dcl 1-6
iox_$rewrite_record             000000 constant        entry                    external dcl 1-6
iox_$seek_key                   000000 constant        entry                    external dcl 1-6
iox_$user_input                        external static pointer                  dcl 1-35
iox_$user_io                           external static pointer                  dcl 1-35
iox_$user_output                       external static pointer                  dcl 1-35
iox_$write_record               000000 constant        entry                    external dcl 1-6
node_list_ptr                          automatic       pointer                  dcl 1070
short_iox_modes                        internal static char(4)                  initial array dcl 3-12
string                                                 builtin function         dcl 160

NAMES DECLARED BY EXPLICIT CONTEXT.
add_node                        006253 constant        entry                    internal dcl 1379 ref 1182
associate_gdt                   004523 constant        entry                    internal dcl 392 ref 289 685
attach_error                    004131 constant        entry                    internal dcl 305 ref 197 211 270 278 290
attach_error_return             001352 constant        label                    dcl 325 ref 322
cleanerup                       007744 constant        entry                    internal dcl 1818 ref 1753 1809 1814
compute_effector_length         006661 constant        entry                    internal dcl 1523 ref 1220 1514
error_return                    007733 constant        label                    dcl 1814 ref 1780 1793 1800 1805
force_out_buffer                007317 constant        entry                    internal dcl 1713 ref 479 588 1019 1616 1642 1705
                                                                                  1864
free_dsb                        004352 constant        entry                    internal dcl 339 ref 312 620
gdt_caller                      007162 constant        entry                    internal dcl 1648 ref 475 584 778 838 848 946 1603
                                                                                  1629 1860
get_effector_info               006615 constant        entry                    internal dcl 1494 ref 1141 1338 1612
get_to_text_mode                010116 constant        entry                    internal dcl 1853 ref 579 771 875 898 1011
graphic_dim_                    000504 constant        entry                    external dcl 19
graphic_dim_attach              000517 constant        entry                    external dcl 176
graphic_dim_changemode          002615 constant        entry                    external dcl 753 ref 543
graphic_dim_close               001606 constant        entry                    external dcl 571 ref 545
graphic_dim_detach              001745 constant        entry                    external dcl 608 ref 297 598
graphic_dim_get_chars           003315 constant        entry                    external dcl 858 ref 539
graphic_dim_get_line            003363 constant        entry                    external dcl 883 ref 538
graphic_dim_open                001444 constant        entry                    external dcl 518 ref 296 599
graphic_dim_order               002072 constant        entry                    external dcl 631 ref 544
graphic_dim_write               003702 constant        entry                    external dcl 982 ref 534
grow_node_table                 006551 constant        entry                    internal dcl 1469 ref 1399 1416
no_entry                        001412 constant        entry                    external dcl 505
not_setup                       001361 constant        entry                    external dcl 488 ref 242
preexpand_graphic_code          005162 constant        entry                    internal dcl 1056 ref 1029
reset_input                     005125 constant        entry                    internal dcl 973 ref 928 948 968
set_modes_not_rawo              010053 constant        entry                    internal dcl 1841 ref 1741 1867
set_modes_rawo                  010013 constant        entry                    internal dcl 1831 ref 1601 1738
setup                           005106 constant        entry                    internal dcl 559 ref 525 573 610 655 768 869 891 996
temp_seg_name                   004272 constant        entry                    internal dcl 328 ref 275 275 315 315 612 612
translate_and_output_graphic_code
                                006751 constant        entry                    internal dcl 1568 ref 1048
try_buffered_output             007275 constant        entry                    internal dcl 1690 ref 1684
try_to_open_gdt                 005023 constant        entry                    internal dcl 461 ref 454 552
unrecognized                    006700 constant        label                    dcl 1549 ref 1547
validate_node                   006472 constant        entry                    internal dcl 1447 ref 1264

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11452       11640   10477       11462
Length     12326   10477       166         452     753          32

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
graphic_dim_                       1231 external procedure  is an external procedure.  
attach_error                            internal procedure  shares stack frame of external procedure graphic_dim_.  
temp_seg_name                           internal procedure  shares stack frame of external procedure graphic_dim_.  
free_dsb                                internal procedure  shares stack frame of external procedure graphic_dim_.  
associate_gdt                           internal procedure  shares stack frame of external procedure graphic_dim_.  
try_to_open_gdt                         internal procedure  shares stack frame of external procedure graphic_dim_.  
setup                                   internal procedure  shares stack frame of external procedure graphic_dim_.  
on unit on line 928                  64 on unit               
reset_input                          84 internal procedure  is called by several nonquick procedures.  
on unit on line 1043                 70 on unit               
preexpand_graphic_code                  internal procedure  shares stack frame of external procedure graphic_dim_.  
add_node                                internal procedure  shares stack frame of external procedure graphic_dim_.  
validate_node                           internal procedure  shares stack frame of external procedure graphic_dim_.  
grow_node_table                         internal procedure  shares stack frame of external procedure graphic_dim_.  
get_effector_info                       internal procedure  shares stack frame of external procedure graphic_dim_.  
compute_effector_length                 internal procedure  shares stack frame of external procedure graphic_dim_.  
translate_and_output_graphic_code
                                        internal procedure  shares stack frame of external procedure graphic_dim_.  
gdt_caller                              internal procedure  shares stack frame of external procedure graphic_dim_.  
try_buffered_output                     internal procedure  shares stack frame of external procedure graphic_dim_.  
force_out_buffer                    116 internal procedure  enables or reverts conditions.  
on unit on line 1753                 72 on unit               
cleanerup                            84 internal procedure  is called by several nonquick procedures.  
set_modes_rawo                       82 internal procedure  is called by several nonquick procedures.  
set_modes_not_rawo                   84 internal procedure  is called by several nonquick procedures.  
get_to_text_mode                        internal procedure  shares stack frame of external procedure graphic_dim_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 static_stuff                graphic_dim_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
force_out_buffer         000100 buffer_ptr                  force_out_buffer
                         000102 dynamic                     force_out_buffer
                         000103 message_size                force_out_buffer
                         000104 my_io_buffer_len            force_out_buffer
                         000105 n_chars_read                force_out_buffer
graphic_dim_             000106 gdt_pointer                 graphic_dim_
                         000110 io_call_infop               graphic_dim_
                         000112 cur_dsb_ptr                 graphic_dim_
                         000114 gdt_name_copy               graphic_dim_
                         000166 output_buffer_outdx         graphic_dim_
                         000170 sdb_ptr                     graphic_dim_
                         000172 tp                          graphic_dim_
                         000174 active_fn                   graphic_dim_
                         000175 command_level               graphic_dim_
                         000176 request                     graphic_dim_
                         000250 table_name                  graphic_dim_
                         000322 i                           graphic_dim_
                         000323 j                           graphic_dim_
                         000324 new_modes_len               graphic_dim_
                         000325 old_sw_modes                graphic_dim_
                         000525 old_gdt_modes               graphic_dim_
                         000725 single_mode                 graphic_dim_
                         000735 n_chars_out                 graphic_dim_
                         000736 new_nodes_idx               graphic_dim_
                         000737 new_top_idx                 graphic_dim_
                         000756 char32                      temp_seg_name
                         000776 found                       free_dsb
                         001000 prev_tp                     free_dsb
                         001002 tp                          free_dsb
                         001012 gdt_entrypoint_name         associate_gdt
                         001064 gdt_ptr                     associate_gdt
                         001110 already_there               preexpand_graphic_code
                         001111 based_string_length         preexpand_graphic_code
                         001112 based_string_ptr            preexpand_graphic_code
                         001114 cur_level                   preexpand_graphic_code
                         001115 dynamic                     preexpand_graphic_code
                         001116 effector_char               preexpand_graphic_code
                         001117 effector_length             preexpand_graphic_code
                         001120 expanded_indx               preexpand_graphic_code
                         001121 expanded_effector_len       preexpand_graphic_code
                         001122 gdt_ptr                     preexpand_graphic_code
                         001124 i                           preexpand_graphic_code
                         001125 indx                        preexpand_graphic_code
                         001126 instring_length             preexpand_graphic_code
                         001127 list_level                  preexpand_graphic_code
                         001130 new_node_list_size          preexpand_graphic_code
                         001131 node_uid                    preexpand_graphic_code
                         001132 number_output               preexpand_graphic_code
                         001133 number_used                 preexpand_graphic_code
                         001134 outdx                       preexpand_graphic_code
                         001135 save_outdx                  preexpand_graphic_code
                         001136 save_indx                   preexpand_graphic_code
                         001140 temp_p                      preexpand_graphic_code
                         001142 validate_this_node          preexpand_graphic_code
                         001143 zero_ok                     preexpand_graphic_code
                         001144 effector_data_copy          preexpand_graphic_code
                         001156 i                           add_node
                         001170 i                           validate_node
                         001200 temp_ptr                    grow_node_table
                         001216 effector_rank               compute_effector_length
                         001217 effector_length             compute_effector_length
                         001226 effector_data_copy          translate_and_output_graphic_code
                         001227 effector_char               translate_and_output_graphic_code
                         001230 indx                        translate_and_output_graphic_code
                         001231 effector_length             translate_and_output_graphic_code
                         001232 based_effector_ptr          translate_and_output_graphic_code
                         001242 number_output               gdt_caller
                         001243 part_output_len             gdt_caller
                         001244 part_output_ptr             gdt_caller

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_cs            cat_realloc_cs      call_var_desc       call_ext_out_desc   call_ext_out
call_int_this       call_int_other      return              enable              shorten_stack       ext_entry
ext_entry_desc      int_entry           alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      expand_pathname_              find_command_$fc_no_message   get_system_free_area_
get_temp_segments_            graphic_compiler_$expand_string                             graphic_element_length_
graphic_terminal_status_$decode                             hcs_$make_entry               ioa_$rsnnl
iox_$control                  iox_$err_no_operation         iox_$find_iocb                iox_$get_chars
iox_$get_line                 iox_$modes                    iox_$propagate                iox_$put_chars
ipc_$mask_ev_calls            ipc_$unmask_ev_calls          release_temp_segments_        sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_index        error_table_$badopt           error_table_$invalid_mode     error_table_$long_record
error_table_$negative_nelem   error_table_$noarg            error_table_$not_detached
error_table_$unimplemented_version                          graphic_error_table_$gdt_missing
graphic_error_table_$impossible_effector_length             graphic_error_table_$incomplete_structure
graphic_error_table_$invalid_node_no                        graphic_error_table_$node_not_active
graphic_error_table_$nongraphic_switch                      graphic_error_table_$not_a_gdt
graphic_error_table_$recursive_structure                    graphic_error_table_$too_many_node_ends
graphic_error_table_$unimplemented_effector                 graphic_error_table_$unrecognized_effector
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     19 000503        19 000511       176 000512       195 000535       197 000540       200 000556       201 000563
    202 000571       205 000575       209 000603       211 000647       216 000660       219 000673       221 000713
    225 000716       226 000722       228 000726       230 000727       235 000730       237 000744       238 000761
    241 000765       242 000770       243 000775       246 001002       248 001005       250 001007       252 001015
    255 001017       257 001022       258 001030       261 001034       262 001035       264 001040       266 001047
    268 001067       270 001076       272 001105       273 001113       275 001115       278 001173       280 001203
    282 001240       284 001255       287 001257       288 001263       289 001273       290 001307       293 001317
    294 001325       296 001330       297 001336       299 001341       301 001342       303 001351       325 001352
    488 001353       502 001404       503 001407       505 001410       515 001435       516 001436       518 001437
    525 001454       527 001455       530 001465       531 001470       534 001471       537 001502       538 001505
    539 001514       543 001523       544 001532       545 001535       547 001540       548 001552       550 001554
    552 001565       557 001601       571 001602       573 001616       575 001617       577 001622       578 001626
    579 001630       580 001636       582 001640       584 001645       586 001666       588 001670       589 001702
    591 001704       596 001707       598 001715       599 001724       600 001727       602 001733       604 001741
    606 001742       608 001743       610 001755       612 001756       615 002035       617 002037       620 002042
    623 002046       625 002050       627 002055       629 002064       631 002065       655 002110       657 002111
    658 002120       659 002123       660 002126       661 002130       662 002136       663 002141       664 002144
    666 002147       669 002150       670 002153       673 002155       674 002161       676 002167       677 002170
    680 002217       682 002220       683 002225       685 002232       688 002246       689 002253       691 002254
    692 002260       693 002265       696 002327       698 002350       700 002351       702 002355       705 002364
    708 002404       720 002457       722 002465       724 002467       727 002475       729 002476       732 002515
    733 002521       734 002525       735 002530       736 002533       740 002534       744 002561       746 002565
    748 002606       751 002607       753 002610       768 002640       770 002641       771 002643       772 002651
    777 002653       778 002656       779 002676       781 002700       783 002706       784 002707       786 002710
    790 002713       793 002740       795 002751       797 002764       802 003042       804 003072       809 003074
    810 003077       812 003103       819 003110       820 003112       821 003127       823 003130       824 003133
    825 003154       827 003160       829 003176       831 003200       834 003225       838 003227       839 003247
    840 003250       844 003252       848 003301       850 003305       853 003306       856 003307       858 003310
    869 003325       874 003326       875 003330       876 003336       879 003340       881 003360       883 003361
    891 003373       893 003374       897 003377       898 003401       899 003407       902 003411       904 003431
    909 003432       911 003434       912 003436       913 003441       916 003442       918 003443       921 003450
    922 003453       923 003456       926 003457       928 003463       930 003505       932 003515       938 003543
    945 003570       946 003575       948 003616       949 003622       951 003624       954 003632       955 003635
    958 003637       961 003647       966 003650       968 003670       971 003674       982 003675       996 003712
    998 003713       999 003716      1000 003721      1003 003722      1006 003723      1010 003726      1011 003730
   1012 003736      1015 003740      1017 003752      1019 003753      1020 003765      1029 003766      1036 004030
   1038 004034      1043 004036      1045 004062      1046 004071      1048 004073      1051 004120      1053 004130
    305 004131       309 004133       311 004165       312 004171       315 004203       320 004267       322 004271
    328 004272       333 004310       334 004322       335 004331       336 004344       339 004352       352 004354
    356 004355       357 004362       358 004364       363 004366       366 004400       367 004402       369 004411
    371 004414       379 004475       381 004477       383 004512       386 004520       388 004522       392 004523
    409 004534       410 004537       411 004543       416 004544       418 004570       420 004612       422 004616
    424 004623       425 004626       430 004627       432 004635       433 004640       436 004641       438 004643
    439 004652       440 004654       443 004703       448 004737       450 004777       454 005003       457 005022
    461 005023       473 005025       475 005037       477 005060       479 005064       480 005076       483 005102
    484 005105       559 005106       561 005107       562 005115       563 005117       564 005121       565 005122
    567 005123       973 005124       975 005132       978 005161      1056 005162      1117 005200      1121 005205
   1122 005211      1123 005214      1125 005216      1126 005223      1127 005225      1128 005230      1129 005232
   1131 005235      1136 005245      1138 005252      1139 005253      1141 005255      1147 005262      1149 005271
   1153 005300      1154 005305      1155 005307      1157 005311      1159 005324      1162 005330      1165 005345
   1169 005351      1179 005352      1182 005356      1184 005375      1187 005401      1189 005404      1190 005407
   1191 005413      1195 005414      1197 005422      1198 005425      1201 005430      1206 005432      1210 005440
   1211 005443      1212 005447      1215 005450      1216 005455      1218 005466      1220 005500      1222 005516
   1223 005522      1225 005525      1226 005530      1227 005532      1230 005536      1231 005540      1234 005541
   1235 005550      1236 005552      1238 005555      1240 005556      1241 005566      1243 005570      1244 005572
   1245 005576      1247 005577      1249 005600      1254 005602      1256 005604      1261 005644      1262 005656
   1264 005657      1267 005701      1268 005705      1271 005706      1272 005715      1273 005721      1274 005724
   1275 005725      1278 005726      1281 005747      1283 005751      1284 005755      1285 005760      1288 005761
   1291 005765      1293 005767      1294 005776      1296 006004      1305 006006      1308 006020      1314 006023
   1317 006040      1318 006047      1319 006051      1321 006054      1322 006060      1325 006067      1328 006124
   1334 006130      1338 006137      1341 006146      1342 006151      1343 006155      1345 006156      1347 006161
   1348 006170      1349 006172      1350 006174      1352 006175      1353 006200      1354 006204      1359 006205
   1360 006215      1362 006231      1363 006233      1366 006234      1368 006237      1369 006241      1370 006245
   1373 006246      1374 006251      1376 006252      1379 006253      1397 006255      1399 006256      1401 006267
   1403 006307      1405 006311      1406 006314      1407 006321      1409 006324      1413 006375      1416 006376
   1419 006407      1420 006420      1421 006421      1422 006425      1424 006426      1429 006430      1432 006436
   1433 006445      1435 006453      1437 006455      1438 006460      1439 006464      1441 006465      1443 006471
   1447 006472      1459 006474      1461 006513      1463 006515      1464 006525      1465 006544      1469 006551
   1477 006553      1478 006556      1480 006560      1482 006572      1483 006576      1486 006610      1489 006614
   1494 006615      1513 006617      1514 006626      1515 006643      1517 006646      1519 006660      1523 006661
   1543 006663      1545 006664      1547 006674      1548 006676      1549 006700      1550 006703      1553 006705
   1557 006707      1560 006737      1561 006740      1562 006744      1565 006746      1568 006751      1592 006762
   1600 006764      1601 006766      1603 006772      1605 007017      1609 007023      1612 007031      1615 007036
   1616 007041      1617 007054      1620 007060      1622 007064      1626 007067      1629 007077      1631 007125
   1632 007131      1635 007132      1637 007142      1640 007144      1642 007147      1644 007161      1648 007162
   1667 007173      1669 007200      1671 007204      1673 007207      1679 007247      1681 007254      1683 007260
   1684 007262      1686 007274      1690 007275      1701 007277      1705 007300      1709 007315      1713 007316
   1732 007324      1734 007326      1738 007331      1741 007347      1744 007360      1745 007366      1746 007372
   1747 007376      1749 007377      1750 007402      1753 007403      1757 007430      1758 007432      1763 007462
   1768 007511      1772 007545      1775 007551      1777 007554      1778 007560      1780 007576      1782 007601
   1783 007604      1788 007610      1789 007612      1793 007633      1795 007636      1800 007663      1802 007666
   1805 007714      1807 007720      1809 007721      1811 007730      1812 007732      1814 007733      1816 007742
   1818 007743      1822 007751      1825 010003      1827 010011      1831 010012      1833 010020      1835 010046
   1837 010051      1841 010052      1843 010060      1846 010107      1847 010114      1849 010115      1853 010116
   1860 010120      1862 010145      1864 010151      1865 010163      1867 010167      1869 010173


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
