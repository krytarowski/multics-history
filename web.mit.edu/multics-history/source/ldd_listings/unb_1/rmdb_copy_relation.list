	COMPILATION LISTING OF SEGMENT rmdb_copy_relation
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 12/07/87  1319.8 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: ^inddcls,^indattr,indnoniterend,^indnoniterdo,indend,tree,^case,insnl,comcol61,dclind5,declareind5,delnl */
       10 
       11 /*DESCRIPTION
       12*  This subroutine creates a file_model and data relation from the description
       13*  of an already present relation and a list of attributes to be deleted from
       14*  or added to that relation. (Note: the add is not implemented yet, it should
       15*  only be used by the restructure_relation operation of rmdb. */
       16 
       17 /****^  HISTORY COMMENTS:
       18*  1) change(86-01-27,Spitzer), approve(86-01-27,MCR7311),
       19*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
       20*     written
       21*  2) change(86-11-18,Blair), approve(86-11-18,PBF7311), audit(86-12-05,Dupuis),
       22*     install(86-12-09,MR12.0-1237):
       23*     Rework code so that the new relation (the one without the deleted domains)
       24*     is created correctly.  Be sure to close it before we start putting tuples
       25*     into it so that it will be up to date with index ids and all the
       26*     information we collect and put into the model *after* the relation is
       27*     first created and opened.
       28*  3) change(87-11-03,Blair), approve(87-11-03,MCR7792), audit(87-11-30,Dupuis),
       29*     install(87-12-07,MR12.2-1008):
       30*     Initialize mstxn_txn_id to 0 so that we won't get caught in the cleaner by
       31*     trying to delete a txn that doesn't exist.
       32*                                                   END HISTORY COMMENTS */
       33 
       34 rmdb_copy_relation:
       35      proc (Idbm_ptr, Idb_path, Itemp_dir_path, Irmdb_relmgr_entries_ptr, Irelation_ptr, Oerror_message, Ocode);
       36 
       37 	dbm_ptr = Idbm_ptr;
       38 	db_path = Idb_path;
       39 	temp_dir_path = Itemp_dir_path;
       40 	rmdb_relmgr_entries_ptr = Irmdb_relmgr_entries_ptr;
       41 	relation_ptr = Irelation_ptr;
       42 
       43 	fm_ptr = relation.file_model_ptr;
       44 
       45 	delete_model_sw, delete_relation_sw = "0"b;
       46 	control_area_ptr, new_file_model_ptr = null;
       47 	new_file_info_ptr, last_file_info_ptr = null;
       48 	new_relation_id, old_relation_id = "0"b;
       49 	mstxn_txn_id = "0"b;
       50 
       51 	on cleanup call cleaner;
       52 	
       53 	create_relation_name = unique_chars_ ("0"b);
       54 	create_model_name = rtrim (create_relation_name) || ".m";
       55 
       56 	call make_area (control_area_ptr);
       57 
       58 /* Mark in file_model segment that the relation copy and file_model code are
       59*   not current. */
       60 	file_model.file_model_copy_good = "0"b;
       61 	file_model.relation_copy_good = "0"b;
       62 
       63 	call copy_file_model;			/* create and copy the file model information */
       64 	call transaction_in_progress;
       65 	if mstxn_transactions_needed
       66 	then do;
       67 	     on cleanup
       68 		begin;
       69 		call mstxn_cleanup;
       70 		call cleaner;
       71 		end;
       72 	     on any_other call mstxn_any_other;
  1     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the changes made on 85-05-06 and
  1     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
  1    10*     was removed because not all modules need the dbcb, and the
  1    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
  1    12*     list #136).
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 /*
  1    17*                    BEGIN_DESCRIPTION
  1    18*
  1    19*   A generalized routine accessed by all MRDS modules (with the temporary 
  1    20*   (perhaps) exception of restructuring modules) that must start transactions 
  1    21*   if none are present.  The intent is that it be executed as inline code.
  1    22*   The variable mstxn_transactions_needed must be set prior to entering this
  1    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
  1    24*   will suffice.  Included are procedures called mstxn_cleanup and 
  1    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
  1    26*   handlers in the program.  Such handlers should be established just prior to
  1    27*   the inclusion of this code and disabled just following the inclusion of
  1    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
  1    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
  1    30*   include file does the same, because this code might not have been entered 
  1    31*   yet when the handler is invoked.  Directly following this include file the 
  1    32*   contents of mstxn_code should be examined.  If zero, then either the 
  1    33*   transaction was successfully started or no transaction was required.  If the
  1    34*   mrds_finish_transaction code is referenced in general error handling 
  1    35*   situations where the possibility exists that the code in this include file 
  1    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
  1    37*   the beginning of the program.
  1    38*
  1    39*                    END_DESCRIPTION
  1    40*
  1    41*   Written 82-09-28 by Paul W. Benjamin.
  1    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
  1    43*   Modified 83-01-07 by PWB to not reference the dbcb.
  1    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
  1    45*		 any_other handler in situations where the module did
  1    46*		 not start the transaction.
  1    47*   Modified 83-05-05 by PWB to abandon when abort fails.
  1    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
  1    49*		 and abort.
  1    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
  1    51*		 transaction_bj_full conditions.
  1    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
  1    53*		 and to handle transaction_lock_timeout_.
  1    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
  1    55*                     dbcb.user_started_transaction flag.
  1    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
  1    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
  1    58*                     directory >ldd>include and >exl>mrd>i
  1    59**/
  1    60 
  1    61 dcl continue_to_signal_ entry (fixed bin(35));
  1    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
  1    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
  1    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
  1    65 dcl mstxn_code fixed bin (35);
  1    66 dcl mstxn_retries fixed;
  1    67 dcl mstxn_temp_code fixed bin (35);
  1    68 dcl mstxn_transactions_needed bit (1) aligned;
  1    69 dcl user_started_transaction bit (1) aligned;
  1    70 dcl mstxn_txn_id bit (36) aligned;
  1    71 dcl user_transaction_id bit (36) aligned;
  1    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
  1    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
  1    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
  1    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
  1    76 dcl transaction_manager_$handle_conditions entry ();
  1    77 dcl 1 mstxn_condition_info like condition_info;
  1    78 
  2     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*Designed by Matthew C. Pierret, 01/26/82.
  2     6*Coded by Jeffrey D. Ives, 04/30/82.
  2     7*Modified:
  2     8*10/18/82 by Steve Herbst: Names changed.
  2     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  2    10**/
  2    11 
  2    12 dcl (LOWEST_MODE init (1),
  2    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  2    14 
  2    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  2    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  2    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  2    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  2    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  2    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  2    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  2    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  2    23 
  2    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    79 

  1    80 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
  1    81 
  1    82 
  1    83 	mstxn_code = 0;
  1    84 	mstxn_txn_id = "0"b;
  1    85 	
  1    86 	if ^mstxn_transactions_needed			/* only need transactions */
  1    87 	     then goto mstxn_exit;			/* for protected page files */
  1    88 	mstxn_retries = 0;
  1    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
  1    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
  1    91 	     then do;				
  1    92 	     user_started_transaction = "1"b;
  1    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
  1    95 	     goto mstxn_exit;	
  1    96 	end;
  1    97 
  1    98 	user_started_transaction = "0"b;
  1    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
  1   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1   101 
  1   102 mstxn_cleanup:
  1   103 proc;
  1   104 
  1   105 /*  This procedure MUST be called by a cleanup handler. */
  1   106 
  1   107           if mstxn_txn_id ^= "0"b
  1   108           then do;
  1   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
  1   110 	     if mstxn_temp_code ^= 0
  1   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
  1   112 	end;
  1   113 	
  1   114      end mstxn_cleanup;
  1   115 
  1   116 mstxn_any_other:
  1   117 proc;
  1   118 
  1   119 /*  This procedure MUST be called by an any_other handler. */
  1   120 
  1   121           if mstxn_txn_id ^= "0"b
  1   122           then do;
  1   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
  1   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
  1   125 		then do;
  1   126 		mftxn_code = dm_error_$lock_deadlock;
  1   127 		goto mftxn_check_code;
  1   128 	     end;
  1   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
  1   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
  1   131 		then do;
  1   132 		mftxn_code = dm_error_$bj_journal_full;
  1   133 		goto mftxn_check_code;
  1   134 	     end;
  1   135 	     else call transaction_manager_$handle_conditions;
  1   136 	end;
  1   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
  1   138      end mstxn_any_other;
  1   139      
  1   140 mstxn_exit:
  1   141      
  1   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
       73 
       74                if mstxn_code ^= 0
       75                then call error (mstxn_code, "Could not start a transaction.");
       76                end;
       77 
       78 	call create_relation;			/* create the empty data relation */
       79 	call copy_data;				/* copy the data from the old relation to the new */
       80 	if mstxn_transactions_needed 
       81 	then do;
       82 	     mftxn_code = 0;
  4     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
  4     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*                    BEGIN_DESCRIPTION
  4    15*
  4    16*   A generalized routine accessed by all MRDS modules that begin and commit 
  4    17*   transactions.  The intent is that it be executed as inline code. It is 
  4    18*   assumed that mrds_start_transaction was executed previously in the 
  4    19*   procedure.  Prior to this include file the program should assign the value 
  4    20*   of its local error code to mftxn_code.  The program utilizing this
  4    21*   include file must supply a function labeled should_rollback that returns
  4    22*   bit (1).  This routine should examine the error code mftxn_code and whether
  4    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
  4    24*   means rollback.  This procedure may choose to simply return "0"b as it 
  4    25*   appears that MRDS will generally NOT rollback transactions.  This routine
  4    26*   does rollback and restart if the before journal is full but only attempts it
  4    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
  4    28*   where any data that was saved prior to the transaction is restored.  A 
  4    29*   procedure consisting solely of a return statement can be supplied if 
  4    30*   necessary.  After execution of this include file, mftxn_code must be
  4    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
  4    32*   then the commit has failed.  Otherwise it will be unchanged.
  4    33*
  4    34*                    END_DESCRIPTION
  4    35*
  4    36*   Written 82-09-30 by Paul W. Benjamin.
  4    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
  4    38*                     error code only when the transaction is in an error state.
  4    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
  4    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
  4    41*		 fails, and to abort rather than rollback when bj is full.
  4    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
  4    43*		 and rollback.
  4    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
  4    45*		 to by the mstxn_any_other procedure.
  4    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
  4    47*                     the user already started his own transaction.
  4    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
  4    49*                     the directory >ldd>include and >exl>mrd>i.
  4    50**/
  4    51 
  4    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
  4    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
  4    54 dcl mftxn_code fixed bin (35);
  4    55 dcl mftxn_temp_code fixed bin (35);
  4    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
  4    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
  4    58 	
  4    59 
  4    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
  4    61 	     then do;
  4    62 	     mftxn_code = 0;
  4    63 	     goto mftxn_exit;
  4    64 	end;
  4    65 mftxn_check_code:
  4    66 	if mftxn_code = 0
  4    67 	     then do;
  4    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
  4    69 	     if mftxn_code ^= 0
  4    70 		then do;
  4    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    72 		if mftxn_temp_code ^= 0
  4    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    74 	     end;
  4    75 	end;
  4    76 	else do;
  4    77 	     call restore_significant_data;
  4    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
  4    79 		& mstxn_retries < 1		
  4    80 		then do;
  4    81 		     mstxn_retries = mstxn_retries + 1;
  4    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    83 		     if mftxn_temp_code ^= 0
  4    84 			then do;
  4    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    86 			if mftxn_temp_code ^= 0
  4    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    88 		     end;
  4    89 		     else do;
  4    90 			mstxn_code = 0;
  4    91 			goto mstxn_exit;		/* go back and try again */
  4    92 		     end;
  4    93 		end;
  4    94 	     else if should_rollback ()		/* let the program decide */
  4    95 		then do;
  4    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    97 		if mftxn_temp_code ^= 0
  4    98 		     then do;
  4    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   100 		     if mftxn_temp_code ^= 0
  4   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   102 		end;
  4   103 		else do;
  4   104 		     mstxn_code = 0;
  4   105 		     goto mstxn_exit;		/* go back and try again */
  4   106 		end;
  4   107 	     end;
  4   108 	     else do;
  4   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   110 		if mftxn_temp_code ^= 0
  4   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   112 	     end;
  4   113 	end;
  4   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
  4   115 mftxn_exit:
  4   116      
  4   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
       83 
       84                end;
       85 
       86 /* At this point we have esentially created the new relation. Mark the delete
       87*   switches so that the cleanup handler doesn't get rid of them. Now we must
       88*   copy the new model on the old, and the new data relation onto the old. If
       89*   either the system or process crash now, we can recover by attempting this
       90*   operation multiple times (rmdb_salvage_db does this when attempting the
       91*   undo request). */
       92 	delete_relation_sw, delete_model_sw = "0"b;
       93 	new_file_model_ptr -> file_model.relation_copy_good = "1"b;
       94 	new_file_model_ptr -> file_model.file_model_copy_good = "1"b;
       95 
       96 	call error (0, "");
       97 
       98 /*DESCRIPTION
       99*  Create a non-freeing, non-zeroing extensible area to allocate structures in.
      100*  When we return and finish using these structures, we will simply throw away
      101*  the area. This subroutine is also used to reinitialize the area to empty so
      102*  that we may reuse it for other purposes. */
      103 
      104 make_area:
      105      proc (area_ptr);
      106 
      107 dcl  area_ptr ptr parameter;
      108 
      109 	if area_ptr = null
      110 	then do;
      111 	     call mdbm_util_$get_temp_segment_path (temp_dir_path, myname, area_ptr, code);
      112 	     if code ^= 0
      113 	     then call error (code, "Cannot get a temp segment in the temp dir.");
      114 
      115 	     unspec (ai) = "0"b;
      116 	     ai.version = area_info_version_1;
      117 	     ai.extend = "1"b;
      118 	     ai.dont_free = "0"b;
      119 	     ai.no_freeing = "0"b;
      120 	     ai.owner = myname;
      121 	     ai.size = sys_info$max_seg_size;
      122 	     ai.areap = area_ptr;
      123 	     end;
      124 	else call release_area_ (area_ptr);
      125 
      126 	call define_area_ (addr (ai), code);
      127 	if code ^= 0
      128 	then call error (code, "Defining an area.");
      129 
      130 	return;
      131      end make_area;
      132 
      133 /*DESCRIPTION
      134*  Create the new relation from the description of the old minus the attributes
      135*  that are to be deleted. */
      136 
      137 create_relation:
      138      proc;
      139 
      140 dcl  cr_loop fixed bin;
      141 
      142 /* initialize for calls to relation manager */
      143 	tva_number_of_vector_slots = 0;
      144 	tva_number_of_dimensions = rel_info.num_attr;
      145 	tva_maximum_dimension_name_length = 32;
      146 	allocate typed_vector_array in (control_area) set (typed_vector_array_ptr);
      147 
      148 	typed_vector_array.version = TYPED_VECTOR_ARRAY_VERSION_2;
      149 	typed_vector_array.number_of_dimensions = 0;
      150 
      151 	il_number_of_ids = rel_info.num_attr;
      152 	allocate id_list in (control_area) set (id_list_ptr);
      153 	id_list.number_of_ids = 0;
      154 	id_list.version = ID_LIST_VERSION_1;
      155 
      156 /* Set up the list of descriptors for the create relation operation. */
      157 	ai_ptr = ptr (new_file_model_ptr, rel_info.attr_ptr);
      158 	do cr_loop= 1 to tva_number_of_dimensions;
      159 	          
      160 	          if attr_info.key_attr then do;
      161 		     id_list.number_of_ids = id_list.number_of_ids + 1;
      162 		     id_list.id (id_list.number_of_ids) = attr_info.defn_order;
      163 		     end;
      164 		di_ptr = ptr (dbm_ptr, attr_info.domain_ptr);
      165 		typed_vector_array.number_of_dimensions = typed_vector_array.number_of_dimensions + 1;
      166 		typed_vector_array.dimension_table (typed_vector_array.number_of_dimensions).name = attr_info.name;
      167 		typed_vector_array.dimension_table (typed_vector_array.number_of_dimensions).descriptor_ptr =
      168 		     addr (domain_info.db_desc);
      169 		ai_ptr = ptr (new_file_model_ptr, attr_info.fwd_thread);
      170 	end;
      171 
      172 	if id_list.number_of_ids = 0
      173 	then call error (mrds_error_$no_primary_key, "For relation " || relation.name);
      174 	
      175 	allocate rel_creation_info in (control_area) set (rel_creation_info_ptr);
      176 	allocate file_create_info in (control_area) set (file_create_info_ptr);
      177 
      178 /* Initialize values for the create relation operation. */
      179 	rel_creation_info.version = REL_CREATION_INFO_VERSION_2;
      180 	rel_creation_info.esm_info_ptr = null;
      181 	rel_creation_info.cism_info_ptr = null;
      182 	rel_creation_info.file_create_info_ptr = file_create_info_ptr;
      183 	file_create_info.version = FILE_CREATE_INFO_VERSION_2;
      184 	file_create_info.ci_size_in_bytes = 4096;
      185 	file_create_info.blocking_factor = mrds_data_$relation_blocking_factor;
      186 	file_create_info.flags.protected = db_model.db_type_flags.transactions_needed;
      187 	file_create_info.flags.no_concurrency = ^db_model.db_type_flags.concurrency_on;
      188 	file_create_info.flags.no_rollback = ^db_model.db_type_flags.rollback_on;
      189 	file_create_info.flags.mbz_1 = "0"b;
      190 	file_create_info.ring_brackets (*) = 0;
      191 	file_create_info.mbz_2 = 0;
      192 	file_create_info.mbz_3 = "0"b;
      193 
      194 	call rmdb_relmgr_entries
      195 	     .
      196 	     create_relation (db_path, create_relation_name, rel_creation_info_ptr, typed_vector_array_ptr,
      197 	     new_relation_id, rel_info.id, code);
      198 	if code ^= 0
      199 	then call error (code, "While creating relation " || create_relation_name);
      200 
      201 	delete_relation_sw = "1"b;
      202 
      203 /* initialize values for create_index */
      204 	style = 1;
      205 	relation_index_flags_ptr = addr (flag_list);
      206 	flag_list = "0"b;
      207 	relation_index_flags.index_is_unique = "1"b;	/* for primary key */
      208 
      209 /* create the primary index for the relation */
      210 	call rmdb_relmgr_entries
      211 	     .create_index (new_relation_id, id_list_ptr, flag_list, style, rel_info.primary_key_index_id, code);
      212 	if code ^= 0
      213 	then call error (code, "While creating the primary index for" || create_relation_name);
      214 
      215 /* create the secondary indexes for the relation */
      216 	relation_index_flags.index_is_unique = "0"b;	/* index need not be unique for secondary index */
      217 	id_list.number_of_ids = 1;			/* secondary indices involve only one attribute */
      218 
      219 	ai_ptr = ptr (new_file_model_ptr, rel_info.attr_ptr);
      220 	do cr_loop = 1 to rel_info.num_attr;
      221 		if attr_info.index_attr
      222 		then do;
      223 		     id_list.id (1) = attr_info.defn_order;
      224 		     call rmdb_relmgr_entries
      225 			.create_index (new_relation_id, id_list_ptr, flag_list, style, attr_info.index_id, code);
      226 		     if code ^= 0
      227 		     then call error (code, "While creating secondary indices for " || create_relation_name);
      228 		     end;
      229 		ai_ptr = ptr (new_file_model_ptr, attr_info.fwd_thread);
      230 	     end;					/* do relation_idx */
      231 
      232 	return;
      233      end create_relation;
      234 
      235 /*DESCRIPTION
      236*  This subroutine copies the data from the relation MSF/DMF to a new file 
      237*  without the attributes that are to be deleted. */
      238 
      239 copy_data:
      240      proc;
      241 
      242 dcl  based_bit36a bit (36) aligned based;
      243 dcl  descriptor bit (36) aligned;
      244 dcl  loop fixed bin (35);
      245 dcl  new_cursor_ptr ptr;
      246 dcl  old_cursor_ptr ptr;
      247 dcl  tuple_bit_length fixed bin (35);
      248 
      249 /* Open the relation that contains the data to copy from. */
      250           call rmdb_relmgr_entries.close (new_relation_id,(0));
      251 	call rmdb_relmgr_entries.open (db_path, create_relation_name, new_relation_id, code);
      252 	
      253 	call rmdb_relmgr_entries.open (db_path, relation.name, old_relation_id, code);
      254 	if code ^= 0
      255 	then call error (code, "Unable to open data relation " || relation.name);
      256 
      257 /* Create cursors for both the from and to relations. These cursors are
      258*   allocated in an area that is to be released, so there is no need to clean up
      259*   and get rid of them. */
      260 	call rmdb_relmgr_entries.create_cursor (old_relation_id, control_area_ptr, old_cursor_ptr, code);
      261 	if code ^= 0
      262 	then call error (code, "Unable to create a cursor for relation " || relation.name);
      263 
      264 	call rmdb_relmgr_entries.create_cursor (new_relation_id, control_area_ptr, new_cursor_ptr, code);
      265 	if code ^= 0
      266 	then call error (code, "Unable to create a cursor for copy of relation " || relation.name);
      267 
      268 /* Create the select structure */
      269 	rss_number_of_and_groups = 0;
      270 	rss_maximum_number_of_constraints = 0;
      271 	allocate relation_search_specification in (control_area) set (relation_search_specification_ptr);
      272 
      273 	relation_search_specification.head.version = SPECIFICATION_VERSION_4;
      274 	relation_search_specification.head.type = ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE;
      275 
      276 	relation_search_specification.head.pad = "0"b;
      277 	relation_search_specification.head.subset_specification_ptr = null;
      278 
      279 	unspec(relation_search_specification.flags) = "0"b;
      280 
      281 	relation_search_specification.range.type = LOW_RANGE_TYPE;
      282 						/* all tuples */
      283 	relation_search_specification.range.size = mrds_data_$max_tids_returned_per_call;
      284 
      285 /* Populate the retrieval id list (the list of attributes to retrieve from the
      286*   old relation). Since we are omitting attributes, we only need to retrieve the
      287*   ones we are actually going to store. While we are building the id_list,
      288*   calculate the maximum size (in bits) of the tuple. */
      289 	il_number_of_ids = relation.attribute_count;
      290 	allocate id_list in (control_area) set (id_list_ptr);
      291 	id_list.version = ID_LIST_VERSION_1;
      292 	id_list.number_of_ids = 0;
      293 
      294 	tuple_bit_length = 0;
      295 	do loop = 1 to relation.attribute_count;
      296 	     if ^relation.attribute (loop).flags.delete
      297 	     then do;
      298 		id_list.number_of_ids = id_list.number_of_ids + 1;
      299 		id_list.id (id_list.number_of_ids) = loop;
      300 
      301 		di_ptr = ptr (dbm_ptr, relation.attribute (loop).domain_info_ptr);
      302 		descriptor = domain_info.db_desc;
      303 		if domain_info.db_desc_is_ptr
      304 		then descriptor = ptr (dbm_ptr, descriptor) -> based_bit36a;
      305 
      306 		tuple_bit_length = tuple_bit_length + mdbm_util_$get_data_bit_length (descriptor);
      307 		end;
      308 	     end;					/* do loop */
      309 
      310 	simple_typed_vector_ptr, element_id_list_ptr = null;
      311 
      312 /* create an element_id_list for the call to get_tuple_ids */
      313 	eil_number_of_elements = mrds_data_$max_tids_returned_per_call;
      314 	allocate element_id_list in (control_area) set (element_id_list_ptr);
      315 	element_id_list.version = ELEMENT_ID_LIST_VERSION_1;
      316 	
      317 /* Read all the data from the old relation data file and store it into the new
      318*   one. If we get a dup_store error, then deleting one or more of the attributes
      319*   would cause the primary key to be non-unique and is not allowed. */
      320 	code = 0;
      321 	do while (code = 0);     
      322 
      323 	     element_id_list.number_of_elements = 0;
      324 	     element_id_list.id (*) = "0"b;
      325 
      326 	     call rmdb_relmgr_entries
      327 		.
      328 		get_tuple_id (old_cursor_ptr, relation_search_specification_ptr, control_area_ptr,
      329 		element_id_list_ptr, code);
      330 
      331 	     if code = 0 & element_id_list.number_of_elements > 0
      332 		then do loop = 1 repeat loop + 1 while (loop <= element_id_list.number_of_elements & code = 0);
      333 		
      334 /* let the relmgr create the simple_typed vector and fill the value_ptrs and 
      335*   then we'll use the same one after the first time */
      336 
      337 		     if mstxn_transactions_needed
      338 		     then	call manage_transaction;
      339 
      340 			call rmdb_relmgr_entries
      341 			.
      342 			get_tuple_by_id (old_cursor_ptr, element_id_list.id (loop), id_list_ptr, control_area_ptr, simple_typed_vector_ptr, code);
      343 
      344 			if code = 0
      345 			then call rmdb_relmgr_entries.put_tuple (new_cursor_ptr, simple_typed_vector_ptr, element_id_list.id (loop), code);
      346 			if mstxn_transactions_needed
      347 		          then call manage_transaction;
      348 
      349 	     end;                  /* loop through all tuples in element_id_list */
      350 	     
      351 
      352 	     if code = 0
      353 	     then relation_search_specification.head.type = RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE;     
      354 
      355 	     end;              /* all tuples in the relation have been copied */
      356 
      357 	if code ^= dm_error_$no_tuple
      358 	then if code = dm_error_$key_duplication
      359 	     then call error (code,
      360 		     "Deleting key attributes from relation " || rtrim (relation.name)
      361 		     || " would cause primary keys to be non-unique.");
      362 	     else call error (code, "Deleting attributes from relation " || relation.name);
      363 	code = 0;
      364 
      365 /* Close both data files. */
      366 	call rmdb_relmgr_entries.close (new_relation_id, (0));
      367 	call rmdb_relmgr_entries.close (old_relation_id, (0));
      368 
      369 	new_relation_id, old_relation_id = "0"b;
      370 
      371 /* Mark in the file_model that the data relation is usable. */
      372 	file_model.relation_copy_good = "1"b;
      373 
      374 	return;
      375      end copy_data;
      376 
      377 /*DESCRIPTION
      378*  This subroutine creates an empty file_model segment, and populates it with
      379*  the attributes that are not deleted from the old file_model segment. */
      380 
      381 copy_file_model:
      382      proc;
      383 
      384 dcl  1 adi like attr_def_info;
      385 dcl  add_name char (32);
      386 dcl  amount_to_pad fixed bin;
      387 dcl  WORD fixed bin internal static options (constant) init (36);
      388      
      389 	call initiate_file_$create (db_path, create_model_name, RW_ACCESS, new_file_model_ptr, ("0"b), (0), code);
      390 	if code ^= 0
      391 	then call error (code, "While creating the file_model copy for relation " || relation.name);
      392 	
      393 	delete_model_sw = "1"b;			/* the model copy must be cleaned up if we abort */
      394 
      395 /* Add a name of <relation>.k to <unique>.m. This is the only indicator of what
      396*   the name of the relation is. The salvager is going to need this to complete
      397*   the copy operation. */
      398 	add_name = rtrim (relation.name) || ".k";
      399 	call hcs_$chname_file (db_path, create_model_name, "", add_name, code);
      400 	if code ^= 0
      401 	then do;
      402 	     if code = error_table_$namedup
      403 	     then do;
      404 		call hcs_$chname_file (db_path, add_name, add_name, "", (0));
      405 		call hcs_$chname_file (db_path, create_model_name, "", add_name, code);
      406 		end;
      407 	     if code ^= 0
      408 	     then call error (code, "Adding a name on model " || create_model_name);
      409 	     end;
      410 
      411 	new_file_model_ptr -> like_file_model = init_file_model;
      412 	new_file_model_ptr -> file_model.fm_area = empty ();
      413 	new_file_model_ptr -> file_model.changer_ptr = db_model.changer_ptr;
      414 	
      415 	allocate rel_info in (new_file_model_ptr -> file_model.fm_area) set (ri_ptr);
      416 
      417 	new_file_model_ptr -> file_model.rel_ptr = rel (ri_ptr);
      418 
      419 	rel_info = init_rel_info; 
      420 	rel_info.name = relation.name;
      421 	rel_info.changer_ptr = db_model.changer_ptr;
      422 		
      423 /* Create all the attr_info structures in the new file_model segment */
      424 	do relation_idx = 1 to relation.attribute_count;
      425 	     if ^relation.attribute (relation_idx).flags.delete
      426 	     then do;
      427 		ai_ptr = relation.attribute (relation_idx).attribute_info_ptr;
      428 		di_ptr = ptr (dbm_ptr, relation.attribute (relation_idx).domain_info_ptr);
      429 		adi.name = attr_info.name;
      430 		adi.primary_key = attr_info.key_attr;
      431 		adi.indexed = attr_info.index_attr;
      432 		adi.mbz = "0"b;
      433 
      434 		call rmdb_build_attr_info (dbm_ptr, addr (adi), new_file_model_ptr, di_ptr, error_message, code);
      435 		if code ^= 0
      436 		then call error (code, error_message);
      437 
      438 		end;
      439 	     end;					/* do relation_idx */
      440 
      441 /* we've built all the attr infos, but we still need to align varying data */
      442           if rel_info.nvar_atts = 0 then;
      443 	else do;
      444 	     if mod (rel_info.var_offset-1, WORD) = 0 then
      445 		amount_to_pad = 0;
      446 	     else amount_to_pad = WORD - mod (rel_info.var_offset -1, WORD);
      447 
      448 	     rel_info.var_offset = rel_info.var_offset + amount_to_pad;
      449 	     rel_info.max_data_len = rel_info.max_data_len + amount_to_pad;
      450 	     end;
      451 
      452 	call adjust_bit_count_ (db_path, create_model_name, "0"b, new_model_bit_count, (0));
      453 
      454 /* Mark the fact that the file_model describing the new relation is ok to use. */
      455 	file_model.file_model_copy_good = "1"b;
      456 
      457 /* Create a file_info structure and add it to the end of the list of file_infos
      458*   in db_model (if we are operating on a MSF). We don't really want to do this
      459*   because we only have to undo it later, but vfile_relmgr_ requires that
      460*   all these structures be there. */
      461 
      462 	     do fi_ptr = ptr (dbm_ptr, db_model.file_ptr) repeat ptr (dbm_ptr, file_info.fwd_ptr)
      463 		while (rel (fi_ptr) ^= NULL_OFFSET);
      464 		last_file_info_ptr = fi_ptr;
      465 		end;
      466 
      467 	     allocate file_info in (dbm_area) set (new_file_info_ptr);
      468 	     relation.copy_file_model_ptr = new_file_info_ptr;
      469 	     new_file_info_ptr -> file_info.file_name = create_relation_name;
      470 	     new_file_info_ptr -> file_info.file_id = "000000000000000000000000000000000001"b;
      471 	     new_file_info_ptr -> file_info.fwd_ptr = NULL_OFFSET;
      472 	     new_file_model_ptr -> file_model.fi_ptr = rel (fi_ptr);
      473 	     
      474 	     if last_file_info_ptr = null
      475 	     then db_model.file_ptr = rel (new_file_info_ptr);
      476 	     else last_file_info_ptr -> file_info.fwd_ptr = rel (new_file_info_ptr);
      477 
      478 	return;
      479      end copy_file_model;
      480 
      481 /*DESCRIPTION
      482*  This subroutine ensures that no transaction is in progress, and sets a flag
      483*  bit for use later. */
      484 
      485 transaction_in_progress:
      486      proc;
      487 
      488 	if db_model.db_type_flags.transactions_needed
      489 	then do;
      490 	     mstxn_transactions_needed = "1"b;
      491 	     call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
      492 	     if mstxn_code = 0
      493 	     then do;
      494 		mstxn_txn_id = "0"b;
      495 		call error (error_table_$action_not_performed,
      496 		     "A transaction is in progress. Commit or abort the transaction and try the operation again.");
      497 		end;
      498 	     end;
      499 	else mstxn_transactions_needed = "0"b;
      500 
      501 	return;
      502      end transaction_in_progress;
      503 
      504 /*DESCRIPTION
      505*     This routine takes care of starting and stopping new transactions as needed.
      506**/
      507 
      508 manage_transaction:
      509      proc ();
      510      
      511           call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
      512 	if mftxn_code ^= 0
      513 	then do;
      514 	     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
      515 	     if mftxn_temp_code ^= 0
      516 	     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
      517 	     call error (mftxn_temp_code, "Unable to finish a transaction.");
      518 	     end;
      519 	
      520 	mstxn_txn_id = "0"b;
      521           call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
      522 	if mstxn_code ^= 0
      523 	then call error (mstxn_code, "Could not start a transaction.");
      524 
      525 	return;
      526 
      527      end manage_transaction;
      528 
      529 /*DESCRIPTION
      530*  Error handler and cleanup handler. This is the only way to exit these
      531*  subroutines.
      532**/
      533 
      534 error:
      535      proc (code, msg);
      536 
      537 dcl  code fixed bin (35) parameter;
      538 dcl  msg char (*) parameter;
      539 
      540 	Ocode = code;
      541 	if code = 0
      542 	then Oerror_message = "";
      543 	else Oerror_message = msg;
      544 	goto RETURN_TO_CALLER;
      545      end error;
      546 
      547 RETURN_TO_CALLER:
      548 	call cleaner;
      549 	return;
      550 
      551 cleaner:
      552      proc;
      553 
      554 dcl  id bit (36) aligned;
      555 dcl  p ptr;
      556 
      557 	do p = control_area_ptr;
      558 	     if p ^= null
      559 	     then do;
      560 		call release_area_ (p);
      561 		call mdbm_util_$free_temp_segment (myname, p, (0));
      562 		end;
      563 	     end;
      564 	do id = new_relation_id, old_relation_id;
      565 	     if id ^= "0"b
      566 	     then call rmdb_relmgr_entries.close (id, (0));
      567 	     end;
      568 
      569 	if mstxn_txn_id ^= "0"b
      570 	then do;
      571 	     call transaction_manager_$abort_txn (mstxn_txn_id, code);
      572 	     if code ^= 0
      573 	     then call transaction_manager_$abandon_txn (mstxn_txn_id, (0));
      574 	     end;
      575 
      576 	return;
      577      end cleaner;
      578 
      579 restore_significant_data:
      580      proc;
      581 	return;
      582      end restore_significant_data;
      583 
      584 should_rollback:
      585      proc returns (bit (1) aligned);
      586 	return ("0"b);
      587      end should_rollback;
      588 
  5     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  5     2*
  5     3*   Values for the "access mode" argument so often used in hardcore
  5     4*   James R. Davis 26 Jan 81  MCR 4844
  5     5*   Added constants for SM access 4/28/82 Jay Pattin
  5     6*   Added text strings 03/19/85 Chris Jones
  5     7**/
  5     8 
  5     9 
  5    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  5    11 dcl	(
  5    12 	N_ACCESS		   init ("000"b),
  5    13 	R_ACCESS		   init ("100"b),
  5    14 	E_ACCESS		   init ("010"b),
  5    15 	W_ACCESS		   init ("001"b),
  5    16 	RE_ACCESS		   init ("110"b),
  5    17 	REW_ACCESS	   init ("111"b),
  5    18 	RW_ACCESS		   init ("101"b),
  5    19 	S_ACCESS		   init ("100"b),
  5    20 	M_ACCESS		   init ("010"b),
  5    21 	A_ACCESS		   init ("001"b),
  5    22 	SA_ACCESS		   init ("101"b),
  5    23 	SM_ACCESS		   init ("110"b),
  5    24 	SMA_ACCESS	   init ("111"b)
  5    25 	)		   bit (3) internal static options (constant);
  5    26 
  5    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  5    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  5    29 
  5    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  5    31 			   static options (constant);
  5    32 
  5    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  5    34 			   static options (constant);
  5    35 
  5    36 dcl	(
  5    37 	N_ACCESS_BIN	   init (00000b),
  5    38 	R_ACCESS_BIN	   init (01000b),
  5    39 	E_ACCESS_BIN	   init (00100b),
  5    40 	W_ACCESS_BIN	   init (00010b),
  5    41 	RW_ACCESS_BIN	   init (01010b),
  5    42 	RE_ACCESS_BIN	   init (01100b),
  5    43 	REW_ACCESS_BIN	   init (01110b),
  5    44 	S_ACCESS_BIN	   init (01000b),
  5    45 	M_ACCESS_BIN	   init (00010b),
  5    46 	A_ACCESS_BIN	   init (00001b),
  5    47 	SA_ACCESS_BIN	   init (01001b),
  5    48 	SM_ACCESS_BIN	   init (01010b),
  5    49 	SMA_ACCESS_BIN	   init (01011b)
  5    50 	)		   fixed bin (5) internal static options (constant);
  5    51 
  5    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      589 
      590 
  6     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  6     2 
  6     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  6     4 
  6     5 dcl  area_infop ptr;
  6     6 
  6     7 dcl 1 area_info aligned based (area_infop),
  6     8     2 version fixed bin,				/* version number for this structure is 1 */
  6     9     2 control aligned like area_control,		/* control bits for the area */
  6    10     2 owner char (32) unal,				/* creator of the area */
  6    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  6    12     2 size fixed bin (18),				/* size of the area in words */
  6    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  6    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  6    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  6    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  6    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  6    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  6    19 
  6    20 dcl 1 area_control aligned based,
  6    21     2 extend bit (1) unal,				/* says area is extensible */
  6    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  6    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  6    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  6    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  6    26     2 system bit (1) unal,				/* says area is managed by system */
  6    27     2 pad bit (30) unal;
  6    28 
  6    29 /* END INCLUDE FILE area_info.incl.pl1 */
      591 
      592 
  7     1 /* BEGIN INCLUDE FILE  - dm_element_id_list.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*          The element_id_list structure contains an array of element 
  7     5*     identifiers.  These identifiers are used as tuple, record or 
  7     6*     element identifiers.  This structure is used across the relation_manager_,
  7     7*     record_manager_ and index_manager_ interfaces.  At some time the 
  7     8*     version should be changed to be char(8)aligned, when such a conversion
  7     9*     can be coordinated with the other structures used at these interfaces.
  7    10**/
  7    11 
  7    12 /* HISTORY:
  7    13*Written by Matthew Pierret, 06/06/82.
  7    14*Modified:
  7    15*12/16/82 by Roger Lackey:  Changed number_of_elements to fixed bin (35).
  7    16*            Did not change version.
  7    17*02/11/85 by Matthew Pierret:  Added DESCRIPTION, Written by.
  7    18**/
  7    19 
  7    20 /* format: style2,ind3 */
  7    21      dcl	   1 element_id_list      aligned based (element_id_list_ptr),
  7    22 	     2 version	      fixed bin (35),
  7    23 	     2 number_of_elements fixed bin (35),
  7    24 	     2 id		      (eil_number_of_elements refer (element_id_list.number_of_elements)) bit (36) aligned;
  7    25 
  7    26      dcl	   element_id_list_ptr    ptr;
  7    27      dcl	   eil_number_of_elements fixed bin (35);
  7    28      dcl	   ELEMENT_ID_LIST_VERSION_1
  7    29 			      init (1) fixed bin (35);
  7    30 
  7    31 
  7    32 /* END INCLUDE FILE  - dm_element_id_list.incl.pl1 */
      593 
      594 
  8     1 /* BEGIN INCLUDE FILE: dm_file_create_info.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*     This include file contains the declaration of the file_create_info
  8     5*     structure.  This structure is used to specify to file_manager_
  8     6*     attributes a file is to have.
  8     7**/
  8     8 
  8     9 /* HISTORY:
  8    10*Written by Jeffery D. Ives, 09/16/82.
  8    11*  (Original concept by Lindsey L. Spratt.)
  8    12*Modified:
  8    13*06/15/84 by Matthew Pierret:  Added ring_brackets. Changed to a char (8)
  8    14*            version.
  8    15*11/07/84 by Matthew Pierret:  Extended mbz_3 to by one word to cover the
  8    16*            gap caused by the double-word alignment of mbz_2.
  8    17**/
  8    18 
  8    19 /* format: style2,ind3 */
  8    20 
  8    21      dcl	   1 file_create_info     aligned based (file_create_info_ptr),
  8    22 	     2 version	      char (8) aligned,
  8    23 	     2 ci_size_in_bytes   fixed bin (35) init (4096),
  8    24 						/* control interval physical size, must be 4096	*/
  8    25 	     2 blocking_factor    fixed bin init (255),	/* # of cis in each msf seg, must be 64 or 255	*/
  8    26 	     2 flags	      unal,
  8    27 	       3 protected	      bit (1) unal init ("1"b),
  8    28 						/* protected against inconsistency		*/
  8    29 	       3 no_concurrency   bit (1) unal init ("0"b),
  8    30 						/* don't protect against concurrent access	*/
  8    31 	       3 no_rollback      bit (1) unal init ("0"b),
  8    32 						/* don't protect against system failure		*/
  8    33 	       3 mbz_1	      bit (15) unal init ("0"b),
  8    34 						/* must be zero for future compatability	*/
  8    35 	     2 ring_brackets      (2) fixed bin (3) unal init (0, 0),
  8    36 						/* write bracket is first element, read bracket is second */
  8    37 	     2 mbz_3	      bit (46) unal init ("0"b),
  8    38 						/* must be zero for future compatability */
  8    39 	     2 mbz_2	      (30) fixed bin (71);	/* must be zero for future compatability	*/
  8    40 
  8    41      dcl	   file_create_info_ptr   ptr;
  8    42 
  8    43      dcl	   FILE_CREATE_INFO_VERSION_2
  8    44 			      char (8) aligned static options (constant) init ("FileCr 2");
  8    45      dcl	   (
  8    46 	   FCI_WRITE_BRACKET_IDX  init (1),
  8    47 	   FCI_READ_BRACKET_IDX   init (2)
  8    48 	   )		      internal static options (constant);
  8    49 
  8    50 /* ************ END OF INCLUDE FILE: dm_file_create_info.incl.pl1 ********** */
      595 
      596 
  9     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
  9     2 
  9     3 /* DESCRIPTION
  9     4*        The id_list structure is used to identify attributes, fields and
  9     5*   dimensions by various modules of the Data Management System.
  9     6**/
  9     7 
  9     8 /* HISTORY:
  9     9*Written by Matthew Pierret, '82.
  9    10*Modified:
  9    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
  9    12*            (constant)' and to initialize automatic variables.
  9    13**/
  9    14 
  9    15 /* format: style2,ind3 */
  9    16      dcl	   1 id_list	      aligned based (id_list_ptr),
  9    17 	     2 version	      fixed bin (35),
  9    18 	     2 number_of_ids      fixed bin (17),
  9    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
  9    20 
  9    21      dcl	   id_list_ptr	      ptr init (null);
  9    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
  9    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
  9    24 
  9    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
      597 
      598 
 10     1 /* BEGIN INCLUDE FILE dm_range_constants.incl.pl1. */
 10     2 
 10     3 /* HISTORY:
 10     4*Written by Matthew Pierret, 05/27/83.
 10     5*Modified:
 10     6**/
 10     7 
 10     8      dcl	   (
 10     9 	   ALL_RANGE_TYPE	      init (1),
 10    10 	   LOW_RANGE_TYPE	      init (2),
 10    11 	   HIGH_RANGE_TYPE	      init (3)
 10    12 	   )		      fixed bin internal static options (constant);
 10    13 
 10    14 
 10    15 /* END INCLUDE FILE dm_range_constants.incl.pl1. */
      599 
      600 
 11     1 /* BEGIN INCLUDE FILE - dm_rel_creation_info.incl.pl1 */
 11     2 
 11     3 /* format: style1 */
 11     4      dcl	   1 rel_creation_info    aligned based (rel_creation_info_ptr),
 11     5 	     2 version	      fixed bin (35),
 11     6 	     2 file_create_info_ptr ptr,
 11     7 	     2 esm_info_ptr	      ptr,
 11     8 	     2 cism_info_ptr      ptr;
 11     9 
 11    10      dcl	   rel_creation_info_ptr  ptr;
 11    11      dcl	   REL_CREATION_INFO_VERSION_2 fixed bin (35) init (2);
 11    12 
 11    13 /* END INCLUDE FILE - dm_rel_creation_info.incl.pl1 */
      601 
      602 
 12     1 /*  BEGIN INCLUDE FILE - dm_relation_index_flags.incl.pl1 */
 12     2 
 12     3 /* DESCRIPTION:
 12     4*
 12     5*	This structure is used to control the creation of an index by the 
 12     6*     relation_manager_.
 12     7**/
 12     8 
 12     9 /* HISTORY:
 12    10*
 12    11*Written by Lindsey Spratt, 09/20/83.
 12    12*Modified:
 12    13**/
 12    14 
 12    15 /* format: style2,ind3 */
 12    16      dcl	   1 relation_index_flags based (relation_index_flags_ptr) aligned,
 12    17 	     2 relation_must_be_empty
 12    18 			      bit (1) unal,
 12    19 	     2 index_is_clustering
 12    20 			      bit (1) unal,
 12    21 	     2 index_is_unique    bit (1) unal,
 12    22 	     2 pad	      bit (33) unal;
 12    23 
 12    24      dcl	   relation_index_flags_ptr
 12    25 			      ptr init (null);
 12    26 
 12    27 /*  END INCLUDE FILE - dm_relation_index_flags.incl.pl1 */
      603 
      604 
 13     1 /* BEGIN INCLUDE FILE dm_relation_spec.incl.pl1 */
 13     2 
 13     3 /* HISTORY:
 13     4*Written by Matthew Pierret, 05/10/83.
 13     5*Modified:
 13     6**/
 13     7 
 13     8 /* format: style2,ind3 */
 13     9      dcl	   1 relation_search_specification
 13    10 			      aligned based (relation_search_specification_ptr),
 13    11 	     2 head	      like specification_head,
 13    12 	     2 maximum_number_of_constraints
 13    13 			      fixed bin (17) unal,
 13    14 	     2 number_of_and_groups
 13    15 			      fixed bin (17) unal,
 13    16 	     2 flags	      unal,
 13    17 	       3 return_unique_tuples
 13    18 			      bit (1) unal,
 13    19 	       3 mbz	      bit (35) unal,
 13    20 	     2 range,
 13    21 	       3 type	      fixed bin (17),
 13    22 	       3 size	      fixed bin (17),
 13    23 	     2 and_group	      (rss_number_of_and_groups refer (relation_search_specification.number_of_and_groups)),
 13    24 	       3 search_collection_id
 13    25 			      bit (36) aligned,
 13    26 	       3 flags	      unal,
 13    27 	         4 collection_id_supplied
 13    28 			      bit (1) unal,
 13    29 	         4 mbz	      bit (17) unal,
 13    30 	       3 number_of_constraints
 13    31 			      fixed bin (17) unal,
 13    32 	       3 constraint	      (rss_maximum_number_of_constraints
 13    33 			      refer (relation_search_specification.maximum_number_of_constraints)),
 13    34 	         4 field_id	      fixed bin (17) unal,
 13    35 	         4 operator_code  fixed bin (17) unal,
 13    36 	         4 value_field_id fixed bin (17) unal,
 13    37 	         4 mbz	      bit (18) unal,
 13    38 	         4 value_ptr      ptr;
 13    39 
 13    40 
 13    41      dcl	   1 relation_numeric_specification
 13    42 			      aligned based (relation_numeric_specification_ptr),
 13    43 	     2 head	      like specification_head,
 13    44 	     2 collection_id      bit (36) aligned,
 13    45 	     2 range_size	      fixed bin (35),
 13    46 	     2 position_number    fixed bin (17) unal,
 13    47 	     2 pad	      bit (18) unal;
 13    48 
 13    49 
 13    50      dcl	   (relation_search_specification_ptr, relation_numeric_specification_ptr)
 13    51 			      ptr init (null);
 13    52      dcl	   (rss_number_of_and_groups, rss_maximum_number_of_constraints)
 13    53 			      fixed bin (17) init (0);
 13    54 
 13    55 
 13    56 
 13    57 /* END INCLUDE FILE dm_relation_spec.incl.pl1 */
      605 
      606 
 14     1 /* BEGIN INCLUDE FILE dm_specification_head.incl.pl1 */
 14     2 
 14     3 /* HISTORY:
 14     4*Written by Matthew Pierret, 05/11/83. (Extracted from dm_specification.incl.pl1)
 14     5*Modified:
 14     6*05/20/83 by Matthew Pierret: Changed to use version 4.
 14     7**/
 14     8 
 14     9 /* format: style2,ind3 */
 14    10      dcl	   1 specification_head   based (specification_head_ptr),
 14    11 	     2 version	      fixed bin (35),
 14    12 	     2 type	      fixed bin (17) unal,
 14    13 	     2 pad	      bit (18) unal,
 14    14 	     2 subset_specification_ptr
 14    15 			      ptr;
 14    16 
 14    17 
 14    18      dcl	   specification_head_ptr ptr;
 14    19      dcl	   SPECIFICATION_VERSION_4
 14    20 			      init (4) fixed bin (35) internal static options (constant);
 14    21 
 14    22      dcl	   (
 14    23 	   SEARCH_SPECIFICATION_TYPE
 14    24 			      init (1),
 14    25 	   ABSOLUTE_SEARCH_SPECIFICATION_TYPE
 14    26 			      init (1),
 14    27 	   NUMERIC_SPECIFICATION_TYPE
 14    28 			      init (2),
 14    29 	   ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
 14    30 			      init (2),
 14    31 	   RELATIVE_SEARCH_SPECIFICATION_TYPE
 14    32 			      init (3),
 14    33 	   RELATIVE_NUMERIC_SPECIFICATION_TYPE
 14    34 			      init (4),
 14    35 	   ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
 14    36 			      init (5),
 14    37 	   RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
 14    38 			      init (6),
 14    39 	   ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
 14    40 			      init (7),
 14    41 	   RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
 14    42 			      init (8)
 14    43 	   )		      fixed bin (17) internal static options (constant);
 14    44 
 14    45 
 14    46 /* END INCLUDE FILE dm_specification_head.incl.pl1 */
      607 
      608 
 15     1 /* ***********************************************************
 15     2*   *                                                         *
 15     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
 15     4*   *                                                         *
 15     5*   *********************************************************** */
 15     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
 15     7 
 15     8 /* Written by Lindsey Spratt, 04/02/82.
 15     9*Modified:
 15    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
 15    11*	  unaligned.  Changed the type number of the simple_typed_vector to
 15    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
 15    13*	  type.
 15    14**/
 15    15 
 15    16 /* format: style2,ind3 */
 15    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
 15    18 	     2 type	      fixed bin (17) unal,
 15    19 	     2 number_of_dimensions
 15    20 			      fixed bin (17) unal,
 15    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
 15    22 	       3 value_ptr	      ptr unaligned;
 15    23 
 15    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
 15    25 	     2 type	      fixed bin (17) unal,
 15    26 	     2 number_of_dimensions
 15    27 			      fixed bin (17) unal,
 15    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
 15    29 	       3 identifier	      fixed bin (17) unal,
 15    30 	       3 pad	      bit (18) unal,
 15    31 	       3 value_ptr	      ptr unal;
 15    32 
 15    33      dcl	   simple_typed_vector_ptr
 15    34 			      ptr;
 15    35      dcl	   stv_number_of_dimensions
 15    36 			      fixed bin (17);
 15    37 
 15    38      dcl	   general_typed_vector_ptr
 15    39 			      ptr;
 15    40      dcl	   gtv_number_of_dimensions
 15    41 			      fixed bin (17);
 15    42 
 15    43      dcl	   (
 15    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
 15    45 			      init (1),		/* value_ptr was aligned. */
 15    46 	   GENERAL_TYPED_VECTOR_TYPE
 15    47 			      init (2),
 15    48 	   SIMPLE_TYPED_VECTOR_TYPE
 15    49 			      init (3)
 15    50 	   )		      fixed bin (17) internal static options (constant);
 15    51 
 15    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      609 
      610 
 16     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
 16     2 
 16     3 
 16     4 /****^  HISTORY COMMENTS:
 16     5*  1) change(79-02-01,Gray), approve(), audit(), install():
 16     6*     modified to save space occupied by model
 16     7*  2) change(80-11-03,Gray), approve(), audit(), install():
 16     8*     to add mdbm_secured bit in db_model
 16     9*  3) change(82-04-09,Davids), approve(), audit(), install():
 16    10*     collapsed the following into an unused_offset array:
 16    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
 16    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
 16    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
 16    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
 16    15*       unused_1
 16    16*     Also changed the name of unused_2 to restructuring_history_offset
 16    17*     and changed the comment on the changer structure to indicate
 16    18*     that it will contain on database creation information.
 16    19*  4) change(82-04-14,Davids), approve(), audit(), install():
 16    20*     used one of the unused_offsets to point to a message which indicates
 16    21*     why the db is inconsistent. The offset will be null when the db is created
 16    22*     and set the first time the message is used. this is so it will be
 16    23*     consistent with existing data bases. Also added the message structure.
 16    24*  5) change(82-04-28,Davids), approve(), audit(), install():
 16    25*     added the undo_request element to the message structure
 16    26*  6) change(82-05-04,Davids), approve(), audit(), install():
 16    27*     changed unused_offset (12) to last_restructruring_history_offset and
 16    28*     changed restructuring_history_offset to first_restructuring_history_offset
 16    29*  7) change(82-08-19,Davids), approve(), audit(), install():
 16    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
 16    31*     1 => vfile database and 2 => page_file database. Up to this point all
 16    32*     database types were equal to 1.
 16    33*  8) change(83-02-14,Davids), approve(), audit(), install():
 16    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
 16    35*     flags. This will allow information about transactions and dm_file
 16    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
 16    37*     change is compatable with all datamodels created by the released version
 16    38*     of mrds.
 16    39*  9) change(83-02-15,Davids), approve(), audit(), install():
 16    40*     added the rollback_on flag to the db_type_flags since it appears that you
 16    41*     can have a dmfile database that requires transactions but does not have any
 16    42*     journalizing. Also switched the order of the transactions_needed and
 16    43*     concurrency_on flags - this makes the change compatable with existing
 16    44*     dmfile databases except when displaying the model since concurrency_on and
 16    45*     rollback_on will be off in the model even though the dmfile relations had
 16    46*     them on during creation.
 16    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
 16    48*      Removed ctl_file_path_ptr.
 16    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
 16    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 16    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
 16    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
 16    53*      in the flag word for rmdb copying.
 16    54*                                                   END HISTORY COMMENTS */
 16    55 
 16    56 
 16    57 /* this include file contains the structures that go into the make up
 16    58*   of the "db_model" segment in the model for the database.
 16    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
 16    60*
 16    61*   the db_model structure goes at the base of the segment, and contains items unique to
 16    62*   the whole databse. in addition, it has an area of size to fill the
 16    63*   rest of a segment, that holds the lists of files and domains in the database.
 16    64*   these lists are singly forward linked lists. all "pointers" in the database model
 16    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
 16    66*   since actual pointers are process dependent on segment number.
 16    67*   the remaining structures are first a path_entry one to save pathnames in,
 16    68*   and the stack_item and constent structures, used to save a boolean
 16    69*   expression in polish form, with the stack represented by a linked list.
 16    70*   the final structure is one for identifying the status of version information */
 16    71 
 16    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
 16    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
 16    74 	     2 db_type_flags      unal,
 16    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
 16    76 	       3 unused	      (13) bit (1) unal,
 16    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
 16    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
 16    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
 16    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
 16    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
 16    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
 16    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
 16    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
 16    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
 16    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
 16    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
 16    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
 16    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
 16    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
 16    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
 16    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
 16    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
 16    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
 16    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
 16    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
 16    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
 16    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
 16    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
 16   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
 16   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
 16   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
 16   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
 16   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
 16   105 
 16   106      dcl	   dbm_ptr	      ptr;
 16   107 
 16   108 /* the files in the database each have a file_info containing
 16   109*   their name, the file_model for each file is found by initiating the
 16   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
 16   111*   the file_info list is a singly linked list in definition order */
 16   112 
 16   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
 16   114 	     2 file_name	      char (30),		/* name of file */
 16   115 	     2 file_id	      bit (36),		/* id number of file */
 16   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
 16   117 	     2 unused	      unal bit (18);	/* for future expansion */
 16   118 
 16   119      dcl	   fi_ptr		      ptr;
 16   120 
 16   121 /* each domain used in the database will have a domain info saved in the db_model
 16   122*   segment. it describes the domain of the given name, and it's options.
 16   123*   the domain_info's form a singly linked list in definition order */
 16   124 
 16   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
 16   126 	     2 name	      char (32),		/* name of domain */
 16   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
 16   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
 16   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
 16   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
 16   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
 16   132 	     2 reserved	      bit (31) unal,
 16   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
 16   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
 16   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
 16   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
 16   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
 16   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
 16   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
 16   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
 16   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
 16   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
 16   143 	     2 str_err_path_ptr   unal bit (18),
 16   144 	     2 str_after_path_ptr unal bit (18),
 16   145 	     2 get_before_path_ptr unal bit (18),
 16   146 	     2 get_err_path_ptr   unal bit (18),
 16   147 	     2 get_after_path_ptr unal bit (18),
 16   148 	     2 mod_before_path_ptr unal bit (18),
 16   149 	     2 mod_err_path_ptr   unal bit (18),
 16   150 	     2 mod_after_path_ptr unal bit (18),
 16   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
 16   152 	     2 unused_2	      unal bit (18),
 16   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
 16   154 
 16   155      dcl	   di_ptr		      ptr;
 16   156 
 16   157 /* information necessary for attributes that are not used in any relation */
 16   158 
 16   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
 16   160 	     2 name char (32),			/* name of attribute */
 16   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
 16   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
 16   163 	     2 unused (2) bit (18) unal;
 16   164 
 16   165      dcl     ua_ptr ptr;
 16   166 
 16   167 
 16   168 /* space saving pathname$entryname structure, to be allocated
 16   169*   only when a path$entry has to be saved, else only a bit(18)
 16   170*   offset takes up space in the main model structure */
 16   171 
 16   172      declare 1 path_entry	      based (path_entry_ptr),
 16   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
 16   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
 16   175 	     2 reserved	      unal bit (36);	/* for future use */
 16   176 
 16   177      declare path_entry_ptr	      ptr;
 16   178 
 16   179 
 16   180 
 16   181 
 16   182 
 16   183 /* declarations for model of postfix stack holding the check option boolean expression
 16   184*   the following encoding values indicate the corresponding type of stack element
 16   185*
 16   186*   1  =
 16   187*   2  ^=
 16   188*   3  >
 16   189*   4  <
 16   190*   5  >=
 16   191*   6  <=
 16   192*
 16   193*   10  and
 16   194*   20  or
 16   195*   30  not
 16   196*
 16   197*   40  - (minus)
 16   198*
 16   199*   50  domain variable(same name as domain)
 16   200*
 16   201*   60  constant(number, bit string, or character string)
 16   202*
 16   203**/
 16   204 
 16   205 
 16   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
 16   207 	     2 next	      bit (18),		/* link to next in list */
 16   208 	     2 type	      fixed binary,		/* code for this element type */
 16   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
 16   210*						   if this is a constant element type */
 16   211 
 16   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
 16   213 
 16   214 
 16   215 
 16   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
 16   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
 16   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
 16   219 
 16   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
 16   221 
 16   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
 16   223 
 16   224 /* version structure, giving status of source for CMDB/RMDB,
 16   225*   status of model, and status of resultant */
 16   226 
 16   227 /* version number is in form MM.N.Y
 16   228*   where MM is the major version number, N is the minor version alteration,
 16   229*   and Y is the lastest modification to that alteration,
 16   230*   where M and N represent numbers 0-9, and Y is a letter */
 16   231 
 16   232      declare 1 version_status	      unal based (version_status_ptr),
 16   233 	     2 cmdb_rmdb,
 16   234 	       3 major	      fixed bin,
 16   235 	       3 minor	      fixed bin,
 16   236 	       3 modification     char (4),
 16   237 	     2 model,
 16   238 	       3 major	      fixed bin,
 16   239 	       3 minor	      fixed bin,
 16   240 	       3 modification     char (4),
 16   241 	     2 resultant,
 16   242 	       3 major	      fixed bin,
 16   243 	       3 minor	      fixed bin,
 16   244 	       3 modification     char (4);
 16   245 
 16   246      declare version_status_ptr     ptr;
 16   247 
 16   248 
 16   249 /* maintains information only about the db creation */
 16   250 
 16   251      declare 1 changer	      unal based (changer_ptr),
 16   252 	     2 id		      char (32),
 16   253 	     2 time	      fixed bin (71),
 16   254 	     2 next	      bit (18);		/* to next in the singly linked list */
 16   255 
 16   256      declare changer_ptr	      ptr;
 16   257 
 16   258 
 16   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
 16   260 	     02 len	      fixed bin,		/* length of the message */
 16   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
 16   262 	     02 name	      char (32),		/* name of thing that set the message */
 16   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
 16   264*                                                               that caused the database to become inconsistent */
 16   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
 16   266 
 16   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
 16   268 
 16   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
 16   270 
 16   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
 16   272 
 16   273 
      611 
      612 
 17     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
 17     2 
 17     3 
 17     4 /****^  HISTORY COMMENTS:
 17     5*  1) change(79-02-01,JGray), approve(), audit(), install():
 17     6*     modified to save space occupied by model
 17     7*  2) change(82-05-19,Davids), approve(), audit(), install():
 17     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
 17     9*     the number of secondary indices in the relation - it was always zero.
 17    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
 17    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
 17    12*     DMS conversion.
 17    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
 17    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
 17    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
 17    16*     for relation manager changes.
 17    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
 17    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 17    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
 17    20*     <rel> files are good (for rmdb)
 17    21*                                                   END HISTORY COMMENTS */
 17    22 
 17    23 
 17    24 /* each file in the database will have a model segment with the name
 17    25*   file_name.m (i.e. the files name plus a suffix of ".m")
 17    26*   the file_model structure is allocated at the base of the segment for a given file.
 17    27*   it contains an area with which all other structures in this include file are allocated.
 17    28*   these structures contain the information about which relations, foreign keys,
 17    29*   and attributes are members of this file. all lists are singly linked lists in
 17    30*   definition order. pointers to these structures are obtained by using the "pointer"
 17    31*   builtin function with arguments of the segment base pointer, and the
 17    32*   offset (bit (18)) relative to that pointer that is actually stored in
 17    33*   the file model itself. this is because pointer segment numbers are
 17    34*   per process dependent. the major lists pointed to by the file_model structure
 17    35*   are the list of relations in this file(each with a contained attribute list),
 17    36*   and the list of foreign keys whose parent relation resides in this file
 17    37*   (along with a participating attribute sublist, and the child relation list,
 17    38*   if they are also in this file) */
 17    39 
 17    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
 17    41     2 temporary bit (1) unal,				/* on if file not part of db. */
 17    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
 17    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
 17    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
 17    45     2 reserved bit (32) unal,				/* reserved for future flags */
 17    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
 17    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
 17    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
 17    49     2 pad_1 fixed bin (35),				/* for future use */
 17    50     2 pad_2 fixed bin (35),
 17    51     2 ratd_len fixed bin (21),			/* length of above */
 17    52     2 mratd_len fixed bin (21),			/* length of above */
 17    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
 17    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
 17    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
 17    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
 17    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
 17    58     2 block_size unal fixed bin,			/* no. pages in block */
 17    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
 17    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
 17    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
 17    62     2 num_rels unal fixed bin,			/* number of relations in file */
 17    63     2 num_links unal fixed bin,			/* number of links in file */
 17    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
 17    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
 17    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
 17    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
 17    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
 17    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
 17    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
 17    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
 17    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
 17    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
 17    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
 17    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
 17    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
 17    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
 17    78     2 open_eu_err_path_ptr unal bit (18),
 17    79     2 open_eu_after_path_ptr unal bit (18),
 17    80     2 open_er_before_path_ptr unal bit (18),
 17    81     2 open_er_err_path_ptr unal bit (18),
 17    82     2 open_er_after_path_ptr unal bit (18),
 17    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
 17    84     2 open_neu_err_path_ptr unal bit (18),
 17    85     2 open_neu_after_path_ptr unal bit (18),
 17    86     2 open_ner_before_path_ptr unal bit (18),
 17    87     2 open_ner_err_path_ptr unal bit (18),
 17    88     2 open_ner_after_path_ptr unal bit (18),
 17    89     2 open_pu_before_path_ptr unal bit (18),
 17    90     2 open_pu_err_path_ptr unal bit (18),
 17    91     2 open_pu_after_path_ptr unal bit (18),
 17    92     2 open_pr_before_path_ptr unal bit (18),
 17    93     2 open_pr_err_path_ptr unal bit (18),
 17    94     2 open_pr_after_path_ptr unal bit (18),
 17    95     2 open_cu_before_path_ptr unal bit (18),
 17    96     2 open_cu_err_path_ptr unal bit (18),
 17    97     2 open_cu_after_path_ptr unal bit (18),
 17    98     2 open_cr_before_path_ptr unal bit (18),
 17    99     2 open_cr_err_path_ptr unal bit (18),
 17   100     2 open_cr_after_path_ptr unal bit (18),
 17   101     2 close_before_path_ptr unal bit (18),
 17   102     2 close_err_path_ptr unal bit (18),
 17   103     2 close_after_path_ptr unal bit (18),
 17   104     2 unused_1 unal bit (18),				/* for future expansion */
 17   105     2 unused_2 unal bit (18),
 17   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
 17   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
 17   108 dcl  fm_ptr ptr;
 17   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
 17   110 dcl  atd_ptr ptr;
 17   111 dcl  atd_len fixed bin;
 17   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
 17   113     2 ncomponents fixed bin,
 17   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
 17   115 dcl  cna_ptr ptr;
 17   116 dcl  ncomp_init fixed bin;
 17   117 
 17   118 /* a rel_info structure contains information describing a relation.
 17   119*   a relation may only occur in one file, thus there is one rel_info
 17   120*   per relation per database, each stored in the file_model area for
 17   121*   the file that contains it. the list of rel_info's in this file
 17   122*   form a singly linked list in definition order.
 17   123*   the rel_info itself points to a list of the attributes it contains,
 17   124*   and to any parent_link or child_link info's that involve it in a foreign key */
 17   125 
 17   126 dcl 1 rel_info aligned based (ri_ptr),
 17   127     2 name char (32),				/* relation name */
 17   128     2 id  bit (36) aligned,				/* relation id number */
 17   129     2 hashed bit (1) unal,				/* on if hashed */
 17   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
 17   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
 17   132     2 system bit (1) unal,				/* on if dont care how stored */
 17   133     2 indexed bit (1) unal,				/* on if secondary index */
 17   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
 17   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
 17   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
 17   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
 17   138     2 reserved bit (27) unal,				/* for future flags */
 17   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
 17   140     2 num_links_child unal fixed bin,			/* no. links in which child */
 17   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
 17   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
 17   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
 17   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
 17   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
 17   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
 17   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
 17   148     2 unused_3 unal fixed bin,			/* element that was never used */
 17   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
 17   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
 17   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
 17   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
 17   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
 17   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
 17   155     2 attr_ptr unal bit (18),				/* to attr. info */
 17   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
 17   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
 17   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
 17   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
 17   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
 17   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
 17   162     2 link_err_path_ptr unal bit (18),
 17   163     2 link_after_path_ptr unal bit (18),
 17   164     2 unlk_before_path_ptr unal bit (18),
 17   165     2 unlk_err_path_ptr unal bit (18),
 17   166     2 unlk_after_path_ptr unal bit (18),
 17   167     2 str_before_path_ptr unal bit (18),
 17   168     2 str_err_path_ptr unal bit (18),
 17   169     2 str_after_path_ptr unal bit (18),
 17   170     2 del_before_path_ptr unal bit (18),
 17   171     2 del_err_path_ptr unal bit (18),
 17   172     2 del_after_path_ptr unal bit (18),
 17   173     2 mod_before_path_ptr unal bit (18),
 17   174     2 mod_err_path_ptr unal bit (18),
 17   175     2 mod_after_path_ptr unal bit (18),
 17   176     2 find_before_path_ptr unal bit (18),
 17   177     2 find_err_path_ptr unal bit (18),
 17   178     2 find_after_path_ptr unal bit (18),
 17   179     2 retr_before_path_ptr unal bit (18),
 17   180     2 retr_err_path_ptr unal bit (18),
 17   181     2 retr_after_path_ptr unal bit (18),
 17   182     2 unused_1 unal bit (18),				/* for future expansion */
 17   183     2 unused_2 unal bit (18),
 17   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
 17   185 dcl  ri_ptr ptr;
 17   186 
 17   187 /* a attr_info structure contains information about an attribute in a given relation.
 17   188*   since attributes may appear in more than one relation, each occurence of an attribute
 17   189*   means that an attr_info for it will be put in that relations sublist of attributes.
 17   190*   the list is singly linked in definition order. the attr_info describes
 17   191*   the data it represents, and how that data is used during a database search. */
 17   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
 17   193     2 name char (32),				/* name of attribute */
 17   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
 17   195     2 index_attr bit (1) unal,			/* on if a secondary index */
 17   196     2 link_attr bit (1) unal,				/* on if participates in link */
 17   197     2 reserved bit (33) unal,
 17   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
 17   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
 17   200     2 key_order unal fixed bin,			/* relative posit. in key */
 17   201     2 bit_offset fixed bin (35),			/* position in tuple */
 17   202     2 bit_length fixed bin (35),			/* length if fixed */
 17   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
 17   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
 17   205     2 domain_ptr unal bit (18),			/* to domain info */
 17   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
 17   207     2 fwd_thread unal bit (18),			/* to next in list */
 17   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
 17   209 dcl  ai_ptr ptr;
 17   210 
 17   211 /* a parent_link_info structure is the carrier of foreign key definition info.
 17   212*   each time a foreign key definition indicates a relation as it's parent,
 17   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
 17   214*   a relation can be parent and/or child in any number of foreign keys.
 17   215*   the parent_link_info structure describes the foreign key, and also points
 17   216*   to a list of the attributes that participate in this foreign key.
 17   217*   (this could be from 1 up to all attributes in the relation)
 17   218*   the attr_list structures are in a singly linked list in definition order
 17   219*   for this purpose. also pointed to is a list of child_link_info's
 17   220*   that describe the child relations in this foreign key. since foreign keys
 17   221*   may span files, not all related child_link_info's have to be in this file's
 17   222*   model area. */
 17   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
 17   224     2 name char (32),				/* name of link */
 17   225     2 singular bit (1) unal,				/* on if system owned link */
 17   226     2 temp bit (1) unal,				/* on if temp. order */
 17   227     2 first bit (1) unal,				/* insertion indicators */
 17   228     2 last bit (1) unal,
 17   229     2 next bit (1) unal,
 17   230     2 prior bit (1) unal,
 17   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
 17   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
 17   233     2 dup_first bit (1) unal,				/* duplicates first */
 17   234     2 dup_last bit (1) unal,				/* duplicates last */
 17   235     2 indexed bit (1) unal,				/* locate parent via index */
 17   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
 17   237     2 thread_36 bit (1) unal,				/* thread size indicators */
 17   238     2 thread_27 bit (1) unal,
 17   239     2 thread_18 bit (1) unal,
 17   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
 17   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
 17   242     2 reserved bit (19) unal,				/* reserved for future flags */
 17   243     2 index_id aligned bit (8),			/* id of index if indexed */
 17   244     2 thread_index unal fixed bin,			/* index to threads in parent */
 17   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
 17   246     2 n_children unal fixed bin,			/* no. children in link */
 17   247     2 child_fn char (30),				/* file name for first child in list */
 17   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
 17   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
 17   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
 17   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
 17   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
 17   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
 17   254     2 sort_err_path_ptr unal bit (18),
 17   255     2 sort_after_path_ptr unal bit (18),
 17   256     2 srch_before_path_ptr unal bit (18),
 17   257     2 srch_err_path_ptr unal bit (18),
 17   258     2 srch_after_path_ptr unal bit (18),
 17   259     2 link_before_path_ptr unal bit (18),
 17   260     2 link_err_path_ptr unal bit (18),
 17   261     2 link_after_path_ptr unal bit (18),
 17   262     2 unlk_before_path_ptr unal bit (18),
 17   263     2 unlk_err_path_ptr unal bit (18),
 17   264     2 unlk_after_path_ptr unal bit (18),
 17   265     2 unused_1 unal bit (18),				/* for future expansion */
 17   266     2 unused_2 unal bit (18),
 17   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
 17   268 dcl  pli_ptr ptr;
 17   269 
 17   270 /* a child_link_info structure is the counter part of a parent_link_info
 17   271*   for foreign key child relations. each time a relation is defined to be
 17   272*   a child in a foreign key, it's list of child_link_infos will be added to.
 17   273*   this list is singly linked in foreign key definition order.
 17   274*   the child_link_info points to a list of participating attributes from the
 17   275*   child relation by means of a singly linked list of attr_list structures
 17   276*   in definition order. the number of attributes in the parent attr_list
 17   277*   and the child attr_list lists are the same with corresponding attr_list
 17   278*   attributes having the same domain. all child_link_infos in this file
 17   279*   are on a seperately linked list. this may not include all
 17   280*   child_link_infos for foreign keys whose parent relation resides in this file,
 17   281*   since foreign keys may span files, and the child_link_info will
 17   282*   reside in the file containing it's associated relation_info. */
 17   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
 17   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
 17   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
 17   286     2 fixed bit (1) unal,				/* on if membership fixed */
 17   287     2 optional bit (1) unal,				/* on if membership optional */
 17   288     2 auto bit (1) unal,				/* on if insertion automatic */
 17   289     2 manual bit (1) unal,				/* on if insertion manual */
 17   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
 17   291     2 range_sel bit (1) unal,				/* on if range type selection */
 17   292     2 key_dup_first bit (1) unal,			/* sort key flags */
 17   293     2 key_dup_last bit (1) unal,
 17   294     2 key_null bit (1) unal,				/* on if null allowed */
 17   295     2 sel_system bit (1) unal,			/* selection criteria flags */
 17   296     2 sel_current bit (1) unal,
 17   297     2 sel_key bit (1) unal,
 17   298     2 sel_proc bit (1) unal,
 17   299     2 no_null bit (1) unal,				/* if null key values not allowed */
 17   300     2 reserved bit (21) unal,
 17   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
 17   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
 17   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
 17   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
 17   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
 17   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
 17   307     2 parent_fn char (30),				/* file name for parent info */
 17   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
 17   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
 17   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
 17   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
 17   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
 17   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
 17   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
 17   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
 17   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
 17   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
 17   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
 17   319     2 link_err_path_ptr unal bit (18),
 17   320     2 link_after_path_ptr unal bit (18),
 17   321     2 unlk_before_path_ptr unal bit (18),
 17   322     2 unlk_err_path_ptr unal bit (18),
 17   323     2 unlk_after_path_ptr unal bit (18),
 17   324     2 srch_before_path_ptr unal bit (18),
 17   325     2 srch_err_path_ptr unal bit (18),
 17   326     2 srch_after_path_ptr unal bit (18),
 17   327     2 unused_1 unal bit (18),				/* for future expansion */
 17   328     2 unused_2 unal bit (18) ;
 17   329 dcl  cli_ptr ptr;
 17   330 
 17   331 /* the attr_list structure is associated with the parent_link_info
 17   332*   and child_link_info structures to represent by means of a singly linked list
 17   333*   the participating attributes from relations in a foreign key.
 17   334*   the parent_link_info has a list for the parent relation,
 17   335*   and the child_link_info has a list for the child relation.
 17   336*   the participating attributes are a subset(not necessary proper) of
 17   337*   those attributes contained in a relation definition.
 17   338*   there are equal numbers of attr_list structures in the parent and
 17   339*   child lists of the same foreign key. the corresponding attributes in these
 17   340*   lists must have the same domain. */
 17   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
 17   342     2 attr_fn char (30),				/* file name for attr. */
 17   343     2 attr_ptr unal bit (18),				/* to attr info block */
 17   344     2 fwd_thread unal bit (18);			/* to next in list */
 17   345 dcl  al_ptr ptr;
 17   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
 17   347     2 ascend bit (1) unal,				/* ascending order */
 17   348     2 descend bit (1) unal,				/* descending order */
 17   349     2 reserved bit (34) unal,
 17   350     2 attr_ptr unal bit (18),				/* to attr info */
 17   351     2 fwd_thread unal bit (18);			/* to next in list */
 17   352 dcl  sk_ptr ptr;
 17   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
 17   354     2 attr_ptr unal bit (18),				/* to attr info */
 17   355     2 fwd_thread unal bit (18);			/* to next in list */
 17   356 dcl  dp_ptr ptr;
 17   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
 17   358     2 link_fn char (30),				/* file name for thru link */
 17   359     2 link_ptr unal bit (18),				/* to parent link info */
 17   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
 17   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
 17   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
 17   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
 17   364     2 fwd_thread unal bit (18);			/* to next in chain */
 17   365 dcl  sc_ptr ptr;
 17   366 
 17   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
 17   368 
 17   369 
      613 
      614 
 18     1 /* BEGIN INCLUDE FILE mdbm_file_model_init.incl.pl1 -- rbh 6/22/82 */
 18     2 
 18     3 
 18     4 
 18     5 /****^  HISTORY COMMENTS:
 18     6*  1) change(82-10-12,DWoodka), approve(), audit(), install():
 18     7*     Modified for DMS conversion - added primary_key_index_id to init_rel_info,
 18     8*     and changed init_rel_info.id to be bit (36) instead of bit (12). Deleted
 18     9*     child_link_ptr and parent_link_ptr, no longer needed.
 18    10*  2) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
 18    11*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
 18    12*     added (file_model relation)_copy_good fields for rmdb.
 18    13*                                                   END HISTORY COMMENTS */
 18    14 
 18    15 
 18    16 /* From mdbm_file_model.incl.pl1 */
 18    17 
 18    18 dcl 1 init_file_model aligned internal static options (constant), /* base of segment */
 18    19     2 temporary bit (1) unal init ("0"b),	/* on if file not part of db. */
 18    20     2 procedures_present bit (1) unal init ("0"b), /* on => ids procedures present */
 18    21     2 file_model_copy_good bit (1) unaligned init ("0"b),	/* on => <rel>.m file is the good copy */
 18    22     2 relation_copy_good bit (1) unaligned init ("0"b),	/* on => <rel> file is the good copy */
 18    23     2 reserved bit (32) unal init ("0"b),	/* reserved for future flags */
 18    24     2 max_tuples fixed bin (35) init (0),		/* not used */
 18    25     2 num_blocks fixed bin (35) init (0),		/* not used */
 18    26     2 num_buckets fixed bin (35) init (0),		/* not used */
 18    27     2 pad_1 fixed bin (35) init (0),			/* for future use */
 18    28     2 pad_2 fixed bin (35) init (0),
 18    29 
 18    30     2 ratd_len fixed bin (21) init (0),			/* useless garbage */
 18    31     2 mratd_len fixed bin (21) init (0),		/* useless garbage */
 18    32     2 uatd_len fixed bin (21) init (0),			/* useless garbage */
 18    33     2 latd_len fixed bin (21) init (0),			/* useless garbage */
 18    34     2 sratd_len fixed bin (21) init (0),		/* useless garbage */
 18    35     2 suatd_len fixed bin (21) init (0),		/* useless garbage */
 18    36     2 file_type unal fixed bin init (1),		/* 1 */
 18    37     2 block_size unal fixed bin init (0),		/* not used */
 18    38     2 block_factor unal fixed bin init (0),		/* not used */
 18    39     2 bucket_density unal fixed bin init (0),		/* not used */
 18    40     2 tuple_id_len unal fixed bin init (36),		/* always 36? */
 18    41     2 num_rels unal fixed bin init (1),			/* always 1 */
 18    42     2 num_links unal fixed bin init (0),		/* not used */
 18    43     2 num_children unal fixed bin init (0),		/* not used */
 18    44     2 default_rbs (3) unal fixed bin (8) init (4,4,4),	/* file ring brackets when not MDBM-secured */
 18    45     2 rel_ptr unal bit (18) init ((18)"1"b),	/* to first of list of rel_infos */
 18    46     2 link_ptr unal bit (18) init ((18)"1"b), /* always null */
 18    47     2 children_ptr unal bit (18) init ((18)"1"b),  /* always null */
 18    48     2 cno_array_ptr unal bit (18) init ((18)"1"b), /* always null */
 18    49     2 fi_ptr unal bit (18) init ((18)"1"b),	/* offset to file_info in db_model */
 18    50     2 suatd_ptr unal bit (18) init ((18)"1"b),		/* garbage */
 18    51     2 sratd_ptr unal bit (18) init ((18)"1"b),		/* garbage */
 18    52     2 latd_ptr unal bit (18) init ((18)"1"b),		/* garbage */
 18    53     2 uatd_ptr unal bit (18) init ((18)"1"b),		/* garbage */
 18    54     2 mratd_ptr unal bit (18) init ((18)"1"b),		/* garbage */
 18    55     2 ratd_ptr unal bit (18) init ((18)"1"b),		/* garbage */
 18    56     2 ptr_pad unal bit (9) init ((9)"1"b),		/* align to half-word value */
 18    57     2 unused_ptr_space unal bit (18) dimension (28) init ((28)(18)"1"b),   /* free ptr space */
 18    58     2 ptr_pad2 unal bit (9) init ((9)"1"b),		/* align to byte */
 18    59     2 changer_ptr unal bit (18) init ((18)"1"b);		/* pointer to changer_id, changer_time structure */
 18    60 
 18    61 
 18    62 dcl 1 like_file_model aligned based (fm_ptr) like init_file_model;	/* base of segment */
 18    63 
 18    64 
 18    65 dcl 1 init_rel_info aligned internal static options (constant),
 18    66     2 name char (32) init (""),			/* relation name */
 18    67     2 id aligned bit (36) init ("000000000000000000000000000000000001"b),		/* relation id number */
 18    68     2 hashed bit (1) unal init ("0"b),		/* on if hashed */
 18    69     2 duplicates bit (1) unal init ("0"b),	/* on if allow dup. hash fields */
 18    70     2 via_link bit (1) unal init ("0"b),	/* on if to be stored by parent */
 18    71     2 system bit (1) unal init ("0"b),		/* on if dont care how stored */
 18    72     2 indexed bit (1) unal init ("0"b),		/* on if secondary index */
 18    73     2 mrds_update bit (1) unal init ("1"b),	/* on if updateable by MRDS */
 18    74     2 mrds_retrieve bit (1) unal init ("1"b),	/* on if retrievable by MRDS */
 18    75     2 virtual bit (1) unal init ("0"b),		/* if virtual relation, mapped on IDS records */
 18    76     2 procedures_present bit (1) unal init ("0"b),/* on => ids type procedures present */
 18    77     2 reserved bit (27) unal init ("0"b),	/* for future flags */
 18    78     2 num_attr unal fixed bin init (0),			/* number of attributes (all levels) defined */
 18    79     2 num_links_child unal fixed bin init (0),		/* no. links in which child */
 18    80     2 num_links_par unal fixed bin init (0),		/* no. links_in which parent */
 18    81     2 max_attr_index_id unal fixed bin init (0),		/* max index id used by attr in this rel or PLI */
 18    82     2 num_key_attrs unal fixed bin init (0),		/* number of attributes in primary key for this rel */
 18    83     2 nvar_atts unal fixed bin init (0),		/* no. varying len. attributes */
 18    84     2 n36_thds unal fixed bin init (0),			/* no. of 36-bit threads */
 18    85     2 n27_thds unal fixed bin init (0),			/* no of 27-bit threads */
 18    86     2 n18_thds unal fixed bin init (0),			/* no of 18-bit threads */
 18    87     2 unused_3 unal fixed bin init (0),			/* element that was never used */
 18    88     2 max_data_len fixed bin (35) init (0),		/* max length of data portion of tuple */
 18    89     2 avg_data_len fixed bin (35) init (0),		/* average length of tuple data portion */
 18    90     2 max_key_len fixed bin (35) init (0),		/* max key length if not hashed */
 18    91     2 var_offset fixed bin (35) init (1),		/* position of first varying attr. */
 18    92     2 max_tuples fixed bin (35) init (0),		/* max no. tuples if blocked file */
 18    93     2 fwd_thread unal bit (18) init ((18)"1"b),    /* offset to next rel. in file */
 18    94     2 attr_ptr unal bit (18) init ((18)"1"b), /* to attr. info */
 18    95     2 primary_key_index_id bit (36) aligned init ("000000000000000000000000000000000001"b), 
 18    96     2 clink_ptr unal bit (18) init ((18)"1"b),/* offset to child info of link determining location */
 18    97     2 map_ptr unal bit (18) init ((18)"1"b),	/* pointer to mapping info if virtual rel. */
 18    98     2 sec_ind_ptr unal bit (18) init ((18)"1"b),   /* ptr to list of sec. ind. infos, init. not used */
 18    99     2 locator_proc_path_ptr unal bit (18) init ((18)"1"b),   /* proc to determ. location */
 18   100     2 link_before_path_ptr unal bit (18) init ((18)"1"b),    /* op. proc. paths and entries */
 18   101     2 link_err_path_ptr unal bit (18) init ((18)"1"b),
 18   102     2 link_after_path_ptr unal bit (18) init ((18)"1"b),
 18   103     2 unlk_before_path_ptr unal bit (18) init ((18)"1"b),
 18   104     2 unlk_err_path_ptr unal bit (18) init ((18)"1"b),
 18   105     2 unlk_after_path_ptr unal bit (18) init ((18)"1"b),
 18   106     2 str_before_path_ptr unal bit (18) init ((18)"1"b),
 18   107     2 str_err_path_ptr unal bit (18) init ((18)"1"b),
 18   108     2 str_after_path_ptr unal bit (18) init ((18)"1"b),
 18   109     2 del_before_path_ptr unal bit (18) init ((18)"1"b),
 18   110     2 del_err_path_ptr unal bit (18) init ((18)"1"b),
 18   111     2 del_after_path_ptr unal bit (18) init ((18)"1"b),
 18   112     2 mod_before_path_ptr unal bit (18) init ((18)"1"b),
 18   113     2 mod_err_path_ptr unal bit (18) init ((18)"1"b),
 18   114     2 mod_after_path_ptr unal bit (18) init ((18)"1"b),
 18   115     2 find_before_path_ptr unal bit (18) init ((18)"1"b),
 18   116     2 find_err_path_ptr unal bit (18) init ((18)"1"b),
 18   117     2 find_after_path_ptr unal bit (18) init ((18)"1"b),
 18   118     2 retr_before_path_ptr unal bit (18) init ((18)"1"b),
 18   119     2 retr_err_path_ptr unal bit (18) init ((18)"1"b),
 18   120     2 retr_after_path_ptr unal bit (18) init ((18)"1"b),
 18   121     2 unused_1 unal bit (18) init ((18)"1"b), /* for future expansion */
 18   122     2 unused_2 unal bit (18) init ((18)"1"b),
 18   123     2 changer_ptr unal bit (18) init ((18)"1"b);   /* pointer to changer_id, changer_time structure */
 18   124 
 18   125 
 18   126 /* END INCLUDE FILE mdbm_file_model_init.incl.pl1 */
 18   127 
 18   128 
      615 
      616 
 19     1 /* BEGIN INCLUDE         rmdb_create_rel_info.incl.pl1                  */
 19     2 
 19     3 /* Contains relation name and all attributes that are associated with the
 19     4*   relation being created.  Attributes which are to be indexed are flagged. */
 19     5 
 19     6 /* HISTORY:
 19     7*   Created 82-03-22 by R. Lackey
 19     8**/
 19     9 
 19    10 
 19    11 dcl 1 rmdb_create_rel_info aligned based (rmdb_create_rel_info_ptr),
 19    12     2 version fixed bin,				/* Version number of this structure */
 19    13     2 db_path char (168),				/* Absolute pathname of database */
 19    14     2 temp_directory_path char (168),			/* Absolute pathname of directory to be used for temp space */
 19    15     2 db_model_ptr ptr,				/* Pointer to db_model */
 19    16     2 relation_name char (32) unal,			/* Name of relation being created */
 19    17     2 num_attrs fixed bin,				/* Number of attributes
 19    18*						   for this relation */
 19    19     2 attrs (rmdb_create_rel_info_alloc			/* Attribute info */
 19    20      refer (rmdb_create_rel_info.num_attrs)) aligned
 19    21      like attr_def_info;
 19    22 
 19    23 
 19    24 dcl 1 attr_def_info based (adi_ptr),			/* Attribute definition info */
 19    25     2 name char (32) unal,				/* Attribute name */
 19    26     2 primary_key bit (1) unal,			/* Primary key attribute */
 19    27     2 indexed bit (1) unal,				/* On => attribute is to be indexed */
 19    28     2 mbz bit (34) unal;				/* For future reference */
 19    29 
 19    30 dcl  adi_ptr pointer;				/* Pointer to attr_def_info structure */
 19    31 dcl  rmdb_create_rel_info_ptr pointer;			/* Based structure pointer */
 19    32 dcl  rmdb_create_rel_info_alloc fixed bin;		/* Allocation size of attribute info for structure */
 19    33 dcl  RMDB_CREATE_REL_INFO_VERSION_1 int static options (constant) init (1);
 19    34 
 19    35 
 19    36 dcl 1 rmdb_ix_attrs aligned based (rmdb_ix_attrs_ptr),	/* List of names of attributes to be indexed */
 19    37     2 version fixed bin,
 19    38     2 relation_name char (32),			/* Name of the relation */
 19    39     2 num_used fixed bin,
 19    40     2 an (rmdb_ix_attrs_alloc refer (rmdb_ix_attrs.num_used)) char (32);
 19    41 
 19    42 dcl  rmdb_ix_attrs_alloc fixed bin;
 19    43 dcl  rmdb_ix_attrs_ptr ptr;
 19    44 dcl  RMDB_IX_ATTRS_VERSION_1 int static options (constant) init (1);
 19    45 
 19    46 dcl 1 rmdb_sel_val_info aligned based (rmdb_sel_val_info_ptr), /* Selection value info */
 19    47     2 version fixed bin,
 19    48     2 sv_num fixed bin,				/* Number of select values */
 19    49     2 data_list_ptr ptr,				/* Pointer to list of ptrs to sv data */
 19    50     2 desc_list_ptr ptr;				/* Pointer to list of ptrs to sv descriptors */
 19    51 
 19    52 dcl  rmdb_sel_val_info_ptr ptr;
 19    53 dcl  RMDB_SEL_VAL_INFO_VERSION_1 int static options (constant) init (1);
 19    54 
 19    55 /* END INCLUDE           rmdb_create_rel_info.incl.pl1                  */
      617 
      618 
 20     1 /*  START OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 20     2 
 20     3 /****^  HISTORY COMMENTS:
 20     4*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
 20     5*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
 20     6*     written.
 20     7*                                                   END HISTORY COMMENTS */
 20     8 
 20     9 /*DESCRIPTION
 20    10*  The following structures are the definition of the records with the keyed
 20    11*  vfile that is built during restructuring. This file serves as a crossreference
 20    12*  of unique attributes and domains used within the specified MRDS database. Each
 20    13*  object is a char (33); the first byte is set to an unprintable character so we
 20    14*  can use the index builtin to find a specific object.
 20    15**/
 20    16 
 20    17 dcl crossref_info_record_ptr ptr;
 20    18 dcl crossref_info_record_count fixed bin (21);
 20    19 dcl 1 crossref_info_record based (crossref_info_record_ptr),
 20    20      2 offset bit (18) unal,
 20    21      2 pad bit (18) unal,
 20    22      2 count fixed bin (21),
 20    23      2 entry (crossref_info_record_count refer (crossref_info_record.count)) unaligned,
 20    24       3 object_head char (1),
 20    25       3 object char (32);
 20    26 
 20    27 dcl crossref_info_record_objects char (33*crossref_info_record.count)
 20    28 			   based (addr (crossref_info_record.entry(1)));
 20    29 dcl OBJECT_HEAD char (1) int static options (constant) init (" ");
 20    30 
 20    31 dcl ATTRIBUTE_KEY_HEAD char (10) int static options (constant) init ("attribute:");
 20    32 dcl DOMAIN_KEY_HEAD char (7) int static options (constant) init ("domain:");
 20    33 dcl RELATION_KEY_HEAD char (9) int static options (constant) init ("relation:");
 20    34 
 20    35 /*DESCRIPTION
 20    36*  The following structures are used to contain sufficient crossreference
 20    37*  information for the delete_attribute and delete_domain requests. These
 20    38*  requests require a more complete view of a crossreference tree, associating
 20    39*  domains, attributes and relations in 2 directions.
 20    40**/
 20    41 
 20    42 dcl domain_list_ptr ptr;
 20    43 dcl domain_list_count fixed bin;
 20    44 dcl domain_list_names char (33*domain_list.count) based (addr (domain_list.name(1)));
 20    45 dcl 1 domain_list based (domain_list_ptr),
 20    46      2 count fixed bin,				/* number of domains in the list */
 20    47      2 name (domain_list_count refer (domain_list.count))
 20    48 	  char (33) unaligned,			/* name of this domain */
 20    49      2 attribute_list_ptr (domain_list_count refer (domain_list.count))
 20    50 		      ptr;			/* -> attribute_list structure */
 20    51 
 20    52 dcl attribute_list_ptr ptr;
 20    53 dcl attribute_list_count fixed bin;
 20    54 dcl attribute_list_names char (33*attribute_list.count) based (addr (attribute_list.name(1)));
 20    55 dcl 1 attribute_list based (attribute_list_ptr),
 20    56      2 count fixed bin,				/* number of attributes in the list */
 20    57      2 name (attribute_list_count refer (attribute_list.count))
 20    58 	  char (33) unaligned,			/* name of this attribute */
 20    59      2 domain_info_ptr (attribute_list_count refer (attribute_list.count))
 20    60 		   bit (18) unal,			/* offset in db_model of the domain_info structure for this attribute */
 20    61      2 attribute_ptr (attribute_list_count refer (attribute_list.count))
 20    62 		 ptr;				/* -> attribute structure */
 20    63 
 20    64 dcl relation_list_ptr ptr;
 20    65 dcl relation_list_count fixed bin;
 20    66 dcl relation_list_names char (33*relation_list.count) based (addr (relation_list.name (1)));
 20    67 dcl 1 relation_list based (relation_list_ptr),
 20    68      2 count fixed bin,				/* number of relations that are to be touched in this operation */
 20    69      2 name (relation_list_count refer (relation_list.count))
 20    70 	  char (33) unaligned,			/* name of this relation */
 20    71      2 relation_ptr (relation_list_count refer (relation_list.count))
 20    72 		ptr;				/* -> relation structure */
 20    73 
 20    74 dcl relation_ptr ptr;
 20    75 dcl relation_attribute_count fixed bin;
 20    76 dcl relation_attribute_names char (33*relation.attribute_count) based (addr (relation.attribute_names (1)));
 20    77 dcl 1 relation based (relation_ptr),
 20    78      2 name char (32),				/* name of the relation */
 20    79      2 file_model_ptr ptr,				/* -> relation.m segment */
 20    80      2 copy_file_model_ptr ptr,
 20    81      2 attribute_count fixed bin,			/* number of attributes defined for this relation */
 20    82      2 mbz fixed bin (35),
 20    83      2 attribute (relation_attribute_count refer (relation.attribute_count)),
 20    84       3 flags aligned,
 20    85         4 delete bit (1) unaligned,			/* ON: delete this attribute */
 20    86         4 new bit (1) unaligned,			/* ON: this attribute is added to the relation */
 20    87         4 part_of_key bit (1) unaligned,                    /* ON: this attribute is part of the primary key */
 20    88         4 to_be_deleted bit (1) unaligned,
 20    89         4 pad bit (32) unaligned,
 20    90       3 domain_info_ptr bit (18) aligned,		/* -> db_model domain_info structure */
 20    91       3 attribute_info_ptr ptr,			/* -> file_model attribute_info structure */
 20    92       3 value_ptr ptr,				/* if flags.new, this -> the value of the column to be stored */
 20    93 						/*   it must be of the correct data type as specified by the domain */
 20    94      2 attribute_names (relation_attribute_count refer (relation.attribute_count))
 20    95 		   char (33) unaligned;
 20    96 
 20    97 dcl attribute_ptr ptr;
 20    98 dcl attribute_count fixed bin;
 20    99 dcl 1 attribute based (attribute_ptr),
 20   100      2 count fixed bin,				/* number of relations this attribute is used in */
 20   101      2 relation_idx (attribute_count refer (attribute.count))
 20   102 		fixed bin;			/* index into list of relation names */
 20   103 
 20   104 /*  END OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      619 
      620 
 21     1 /*  START OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 21     2 
 21     3 
 21     4 /****^  HISTORY COMMENTS:
 21     5*  1) change(82-08-20,Davids), approve(), audit(), install():
 21     6*     written
 21     7*  2) change(86-01-28,Spitzer), approve(86-01-28,MCR7311),
 21     8*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
 21     9*     add get_tuples_by_spec, put_tuple, put_tuples, create_cursor entry points.
 21    10*  3) change(86-08-21,Blair), approve(86-08-21,MCR7311),
 21    11*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
 21    12*     Back out the entries get_tuples_by_spec and put_tuples since they aren't
 21    13*     sufficiently well tested to be reliable.  Replace with get_tuple_id and
 21    14*     get_tuple_by_id.
 21    15*                                                   END HISTORY COMMENTS */
 21    16 
 21    17 
 21    18 dcl 01 rmdb_relmgr_entries based (rmdb_relmgr_entries_ptr),
 21    19      02 create_relation entry (char (*), char (*), ptr, ptr, bit (36) aligned,
 21    20 	bit (36) aligned, fixed bin (35)),
 21    21      02 delete_relation entry (char (*), char (*), fixed bin (35)),
 21    22      02 open entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
 21    23      02 close entry (bit (36) aligned, fixed bin (35)),
 21    24      02 create_index entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17),
 21    25 	bit (36) aligned, fixed bin (35)),
 21    26      02 delete_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35)),
 21    27      02 put_tuple entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
 21    28      02 get_tuple_id entry (ptr, ptr, ptr, ptr, fixed bin (35)),
 21    29      02 get_tuple_by_id entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
 21    30      02 create_cursor entry (bit (36) aligned, ptr, ptr, fixed bin (35));
 21    31 
 21    32 dcl rmdb_relmgr_entries_ptr ptr;
 21    33 
 21    34 /*  END OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      621 
      622 
 22     1 /* ***********************************************************
 22     2*   *                                                         *
 22     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
 22     4*   *                                                         *
 22     5*   *********************************************************** */
 22     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
 22     7 
 22     8 /* Written by Lindsey Spratt, 03/04/82.
 22     9*Modified:
 22    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
 22    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
 22    12*	  the print_vector value (char varying), ptr to the typed_vector
 22    13*	  value location, and a code. cv_to_print now takes ptr to the
 22    14*	  descriptor, ptr to the typed_vector value, the print_vector value
 22    15*	  (char(*) varying), the maximum allowed length for the print_vector
 22    16*	  value, a temp_seg to put the value in if its to big to fit into
 22    17*	  the print_vector, and a code.
 22    18**/
 22    19 
 22    20 /* format: style2,ind3 */
 22    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
 22    22 	     2 version	      fixed bin (35),
 22    23 	     2 number_of_dimensions
 22    24 			      fixed bin (17),
 22    25 	     2 number_of_vectors  fixed bin (17),
 22    26 	     2 number_of_vector_slots
 22    27 			      fixed bin (17),
 22    28 	     2 maximum_dimension_name_length
 22    29 			      fixed bin (17),
 22    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
 22    31 	       3 name	      char (tva_maximum_dimension_name_length
 22    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
 22    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
 22    34 						/* temp_seg_ptr, max_length_for_print_value, */
 22    35 						/* print_value, code) */
 22    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
 22    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
 22    38 						/* print_value_ptr, typed_value_ptr, code) */
 22    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
 22    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
 22    41 			      pointer;
 22    42 
 22    43      dcl	   typed_vector_array_ptr ptr;
 22    44      dcl	   tva_number_of_vector_slots
 22    45 			      fixed bin;
 22    46      dcl	   tva_number_of_dimensions
 22    47 			      fixed bin;
 22    48      dcl	   tva_maximum_dimension_name_length
 22    49 			      fixed bin;
 22    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
 22    51 			      fixed bin (35) int static options (constant) init (2);
 22    52 
 22    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
      623 
      624 
      625 dcl  addr builtin;
      626 dcl  adjust_bit_count_ entry (char (168), char (32), bit (1) aligned, fixed bin (35), fixed bin (35));
      627 dcl  1 ai aligned like area_info;
      628 dcl  any_other condition;
      629 dcl  cleanup condition;
      630 dcl  code fixed bin (35);
      631 dcl  control_area area (sys_info$max_seg_size) based (control_area_ptr);
      632 dcl  control_area_ptr ptr;
      633 dcl  create_model_name char (32);
      634 dcl  create_relation_name char (30);
      635 dcl  db_path char (168);
      636 dcl  define_area_ entry (ptr, fixed bin (35));
      637 dcl  delete_model_sw bit (1) aligned;
      638 dcl  delete_relation_sw bit (1) aligned;
      639 dcl  dm_error_$key_duplication fixed bin (35) ext static;
      640 dcl  dm_error_$no_tuple fixed bin (35) ext static;
      641 dcl  empty builtin;
      642 dcl  error_message char (500);
      643 dcl  error_table_$action_not_performed fixed bin (35) ext static;
      644 dcl  error_table_$namedup fixed bin(35) ext static;
      645 dcl  fixed builtin;
      646 dcl  flag_list bit (36) aligned;
      647 dcl  hcs_$chname_file entry (char (*), char (*), char (*), char (*), fixed bin (35));
      648 dcl  Idb_path char (*) parameter;
      649 dcl  Idbm_ptr ptr parameter;
      650 dcl  initiate_file_$create entry (char (*), char (*), bit (*), ptr, bit (1) aligned, fixed bin (24), fixed bin (35));
      651 dcl  Irelation_ptr ptr parameter;
      652 dcl  Irmdb_relmgr_entries_ptr ptr parameter;
      653 dcl  Itemp_dir_path char (*) parameter;
      654 dcl  last_file_info_ptr ptr;
      655 dcl  mdbm_util_$get_data_bit_length entry (bit (36) aligned) returns (fixed bin (35));
      656 dcl  mdbm_util_$get_temp_segment_path entry (char (*), char (*), ptr, fixed bin (35));
      657 dcl  mdbm_util_$free_temp_segment entry (char (*), ptr, fixed bin (35));
      658 dcl  mod builtin;
      659 dcl  mrds_data_$max_tids_returned_per_call external static fixed bin (35);
      660 dcl  mrds_data_$relation_blocking_factor external static fixed bin (17);
      661 dcl  mrds_error_$no_primary_key fixed bin (35) ext static;
      662 dcl  myname char (32) int static options (constant) init ("rmdb_copy_relation");
      663 dcl  new_file_info_ptr ptr;
      664 dcl  new_file_model_ptr ptr;
      665 dcl  new_model_bit_count fixed bin (35);
      666 dcl  new_relation_id bit (36) aligned;
      667 dcl  null builtin;
      668 dcl  NULL_OFFSET bit (18) unaligned int static options (constant) init ((18)"1"b);
      669 dcl  Ocode fixed bin (35) parameter;
      670 dcl  Oerror_message char (*) parameter;
      671 dcl  old_relation_id bit (36) aligned;
      672 dcl  ptr builtin;
      673 dcl  rel builtin;
      674 dcl  relation_idx fixed bin;
      675 dcl  release_area_ entry (ptr);
      676 dcl  rmdb_build_attr_info entry (ptr, ptr, ptr, ptr, char (*), fixed bin (35));
      677 dcl  rtrim builtin;
      678 dcl  style fixed bin;
      679 dcl  sys_info$max_seg_size fixed bin (35) ext static;
      680 dcl  temp_dir_path char (168);
      681 dcl  unique_chars_ entry (bit (*)) returns (char (15));
      682 dcl  unspec builtin;
      683 
      684      end rmdb_copy_relation;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/07/87  1319.8  rmdb_copy_relation.pl1            >spec>install>MR12.2-1008>rmdb_copy_relation.pl1
73           1    02/05/86  1416.4  mrds_start_transaction.incl.pl1   >ldd>include>mrds_start_transaction.incl.pl1
1-79         2    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
1-81         3    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
83           4    02/05/86  1416.4  mrds_finish_transaction.incl.pl1  >ldd>include>mrds_finish_transaction.incl.pl1
589          5    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
591          6    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
593          7    03/06/85  1031.5  dm_element_id_list.incl.pl1       >ldd>include>dm_element_id_list.incl.pl1
595          8    01/07/85  0901.1  dm_file_create_info.incl.pl1      >ldd>include>dm_file_create_info.incl.pl1
597          9    10/14/83  1609.1  dm_id_list.incl.pl1               >ldd>include>dm_id_list.incl.pl1
599         10    10/14/83  1609.1  dm_range_constants.incl.pl1       >ldd>include>dm_range_constants.incl.pl1
601         11    10/14/83  1609.1  dm_rel_creation_info.incl.pl1     >ldd>include>dm_rel_creation_info.incl.pl1
603         12    10/14/83  1609.1  dm_relation_index_flags.incl.pl1  >ldd>include>dm_relation_index_flags.incl.pl1
605         13    10/14/83  1609.1  dm_relation_spec.incl.pl1         >ldd>include>dm_relation_spec.incl.pl1
607         14    10/14/83  1609.1  dm_specification_head.incl.pl1    >ldd>include>dm_specification_head.incl.pl1
609         15    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
611         16    10/17/86  1404.3  mdbm_db_model.incl.pl1            >ldd>include>mdbm_db_model.incl.pl1
613         17    10/17/86  1404.5  mdbm_file_model.incl.pl1          >ldd>include>mdbm_file_model.incl.pl1
615         18    10/17/86  1404.5  mdbm_file_model_init.incl.pl1     >ldd>include>mdbm_file_model_init.incl.pl1
617         19    10/14/83  1609.0  rmdb_create_rel_info.incl.pl1     >ldd>include>rmdb_create_rel_info.incl.pl1
619         20    10/17/86  1404.6  rmdb_crossref_info.incl.pl1       >ldd>include>rmdb_crossref_info.incl.pl1
621         21    10/17/86  1404.6  rmdb_relmgr_entries.incl.pl1      >ldd>include>rmdb_relmgr_entries.incl.pl1
623         22    10/14/83  1609.1  vu_typed_vector_array.incl.pl1    >ldd>include>vu_typed_vector_array.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       constant        fixed bin(17,0)          initial dcl 14-22 ref 274
ELEMENT_ID_LIST_VERSION_1       000147 automatic       fixed bin(35,0)          initial dcl 7-28 set ref 7-28* 315
FILE_CREATE_INFO_VERSION_2      000122 constant        char(8)                  initial dcl 8-43 ref 183
ID_LIST_VERSION_1                      constant        fixed bin(17,0)          initial dcl 9-23 ref 154 291
Idb_path                               parameter       char                     unaligned dcl 648 ref 34 38
Idbm_ptr                               parameter       pointer                  dcl 649 ref 34 37
Irelation_ptr                          parameter       pointer                  dcl 651 ref 34 41
Irmdb_relmgr_entries_ptr               parameter       pointer                  dcl 652 ref 34 40
Itemp_dir_path                         parameter       char                     unaligned dcl 653 ref 34 39
LOW_RANGE_TYPE                         constant        fixed bin(17,0)          initial dcl 10-8 ref 281
NULL_OFFSET                            constant        bit(18)                  initial unaligned dcl 668 ref 462 471
Ocode                                  parameter       fixed bin(35,0)          dcl 669 set ref 34 540*
Oerror_message                         parameter       char                     unaligned dcl 670 set ref 34 541* 543*
RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       constant        fixed bin(17,0)          initial dcl 14-22 ref 352
REL_CREATION_INFO_VERSION_2     000160 automatic       fixed bin(35,0)          initial dcl 11-11 set ref 11-11* 179
RW_ACCESS                       000124 constant        bit(3)                   initial unaligned dcl 5-11 set ref 389*
SPECIFICATION_VERSION_4                constant        fixed bin(35,0)          initial dcl 14-19 ref 273
TM_NORMAL_MODE                  000160 constant        fixed bin(17,0)          initial dcl 2-15 set ref 1-99* 521*
TYPED_VECTOR_ARRAY_VERSION_2           constant        fixed bin(35,0)          initial dcl 22-50 ref 148
WORD                            004614 constant        fixed bin(17,0)          initial dcl 387 ref 444 446 446
add_name                        000747 automatic       char(32)                 unaligned dcl 385 set ref 398* 399* 404* 404* 405*
addr                                                   builtin function         dcl 625 ref 1-123 1-123 126 126 167 205 412 434 434
adi                             000736 automatic       structure                level 1 packed unaligned dcl 384 set ref 434 434
adjust_bit_count_               000040 constant        entry                    external dcl 626 ref 452
ai                              000222 automatic       structure                level 1 dcl 627 set ref 115* 126 126
ai_ptr                          000206 automatic       pointer                  dcl 17-209 set ref 157* 160 162 164 166 169* 169
                                                                                  219* 221 223 224 229* 229 427* 429 430 431
amount_to_pad                   000757 automatic       fixed bin(17,0)          dcl 386 set ref 444* 446* 448 449
any_other                       000246 stack reference condition                dcl 628 ref 72
area_control                           based           structure                level 1 dcl 6-20
area_info                              based           structure                level 1 dcl 6-7
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 6-3 ref 116
area_ptr                               parameter       pointer                  dcl 107 set ref 104 109 111* 122 124*
areap                    16     000222 automatic       pointer                  level 2 dcl 627 set ref 122*
attr_def_info                          based           structure                level 1 packed unaligned dcl 19-24
attr_info                              based           structure                level 1 dcl 17-192
attr_ptr                 24(18)        based           bit(18)                  level 2 packed unaligned dcl 17-126 set ref 157 219
attribute                16            based           structure                array level 2 unaligned dcl 20-77
attribute_count          14            based           fixed bin(17,0)          level 2 dcl 20-77 ref 289 295 424
attribute_info_ptr       20            based           pointer                  array level 3 dcl 20-77 ref 427
based_bit36a                           based           bit(36)                  dcl 242 ref 303
blocking_factor           3            based           fixed bin(17,0)          initial level 2 dcl 8-21 set ref 176* 185*
changer_ptr              32(18)        based           bit(18)                  level 2 in structure "db_model" packed unaligned
                                                                                  dcl 16-72 in procedure "rmdb_copy_relation" ref
                                                                                  413 421
changer_ptr              44(27)        based           bit(18)                  level 2 in structure "file_model" packed unaligned
                                                                                  dcl 17-40 in procedure "rmdb_copy_relation" set
                                                                                  ref 413*
changer_ptr              43(18)        based           bit(18)                  level 2 in structure "rel_info" packed unaligned
                                                                                  dcl 17-126 in procedure "rmdb_copy_relation" set
                                                                                  ref 421*
ci_size_in_bytes          2            based           fixed bin(35,0)          initial level 2 dcl 8-21 set ref 176* 184*
cism_info_ptr             6            based           pointer                  level 2 dcl 11-4 set ref 181*
cleanup                         000254 stack reference condition                dcl 629 ref 51 67
close                    14            based           entry variable           level 2 dcl 21-18 ref 250 366 367 565
code                            000262 automatic       fixed bin(35,0)          dcl 630 in procedure "rmdb_copy_relation" set ref
                                                                                  111* 112 112* 126* 127 127* 194* 198 198* 210* 212
                                                                                  212* 224* 226 226* 251* 253* 254 254* 260* 261
                                                                                  261* 264* 265 265* 320* 321 326* 331 331 340* 344
                                                                                  344* 352 357 357 357* 362* 363* 389* 390 390* 399*
                                                                                  400 402 405* 407 407* 434* 435 435* 571* 572
code                                   parameter       fixed bin(35,0)          dcl 537 in procedure "error" ref 534 540 541
concurrency_on            0(33)        based           bit(1)                   level 3 packed unaligned dcl 16-72 ref 187
condition_info                         based           structure                level 1 dcl 3-14
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 1-77 set ref 1-124 1-129 1-129
continue_to_signal_             000010 constant        entry                    external dcl 1-61 ref 1-137
control                   1     000222 automatic       structure                level 2 dcl 627
control_area                           based           area                     dcl 631 ref 146 152 175 176 271 290 314
control_area_ptr                000264 automatic       pointer                  dcl 632 set ref 46* 56* 146 152 175 176 260* 264*
                                                                                  271 290 314 326* 340* 557
copy_file_model_ptr      12            based           pointer                  level 2 dcl 20-77 set ref 468*
cr_loop                         000662 automatic       fixed bin(17,0)          dcl 140 set ref 158* 220*
create_cursor            44            based           entry variable           level 2 dcl 21-18 ref 260 264
create_index             20            based           entry variable           level 2 dcl 21-18 ref 210 224
create_model_name               000266 automatic       char(32)                 unaligned dcl 633 set ref 54* 389* 399* 405* 407
                                                                                  452*
create_relation                        based           entry variable           level 2 dcl 21-18 ref 194
create_relation_name            000276 automatic       char(30)                 unaligned dcl 634 set ref 53* 54 194* 198 212 226
                                                                                  251* 469
db_desc                  11            based           bit(36)                  level 2 dcl 16-125 set ref 167 302
db_desc_is_ptr           10            based           bit(1)                   level 2 packed unaligned dcl 16-125 ref 303
db_model                               based           structure                level 1 dcl 16-72
db_path                         000306 automatic       char(168)                unaligned dcl 635 set ref 38* 194* 251* 253* 389*
                                                                                  399* 404* 405* 452*
db_type_flags             0(18)        based           structure                level 2 packed unaligned dcl 16-72
dbm_area                 34            based           area                     level 2 dcl 16-72 ref 467
dbm_ptr                         000174 automatic       pointer                  dcl 16-106 set ref 37* 164 186 187 188 301 303 413
                                                                                  421 428 434* 462 462 465 467 474 488
define_area_                    000042 constant        entry                    external dcl 636 ref 126
defn_order               12            based           fixed bin(17,0)          level 2 packed unaligned dcl 17-192 ref 162 223
delete                   16            based           bit(1)                   array level 4 packed unaligned dcl 20-77 ref 296 425
delete_model_sw                 000360 automatic       bit(1)                   dcl 637 set ref 45* 92* 393*
delete_relation_sw              000361 automatic       bit(1)                   dcl 638 set ref 45* 92* 201*
descriptor                      000716 automatic       bit(36)                  dcl 243 set ref 302* 303* 303 306*
descriptor_ptr                         based           pointer                  array level 3 dcl 22-21 set ref 167*
di_ptr                          000200 automatic       pointer                  dcl 16-155 set ref 164* 167 301* 302 303 428* 434*
dimension_table           6            based           structure                array level 2 dcl 22-21
dm_error_$bj_journal_full       000030 external static fixed bin(35,0)          dcl 4-52 ref 1-132
dm_error_$key_duplication       000044 external static fixed bin(35,0)          dcl 639 ref 357
dm_error_$lock_deadlock         000032 external static fixed bin(35,0)          dcl 4-53 ref 4-78 1-126
dm_error_$no_current_transaction
                                000012 external static fixed bin(35,0)          dcl 1-62 ref 1-90
dm_error_$no_tuple              000046 external static fixed bin(35,0)          dcl 640 ref 357
domain_info                            based           structure                level 1 dcl 16-125
domain_info_ptr          17            based           bit(18)                  array level 3 dcl 20-77 ref 301 428
domain_ptr               17            based           bit(18)                  level 2 packed unaligned dcl 17-192 ref 164
dont_free                 1(03) 000222 automatic       bit(1)                   level 3 packed unaligned dcl 627 set ref 118*
eil_number_of_elements          000146 automatic       fixed bin(35,0)          dcl 7-27 set ref 313* 314 314
element_id_list                        based           structure                level 1 dcl 7-21 set ref 314
element_id_list_ptr             000144 automatic       pointer                  dcl 7-26 set ref 310* 314* 315 323 324 326* 331 331
                                                                                  340 344
empty                                                  builtin function         dcl 641 ref 412
error_message                   000362 automatic       char(500)                unaligned dcl 642 set ref 434* 435*
error_table_$action_not_performed
                                000050 external static fixed bin(35,0)          dcl 643 set ref 495*
error_table_$namedup            000052 external static fixed bin(35,0)          dcl 644 ref 402
esm_info_ptr              4            based           pointer                  level 2 dcl 11-4 set ref 180*
extend                    1     000222 automatic       bit(1)                   level 3 packed unaligned dcl 627 set ref 117*
fi_ptr                   22(27)        based           bit(18)                  level 2 in structure "file_model" packed unaligned
                                                                                  dcl 17-40 in procedure "rmdb_copy_relation" set
                                                                                  ref 472*
fi_ptr                          000176 automatic       pointer                  dcl 16-119 in procedure "rmdb_copy_relation" set ref
                                                                                  462* 462* 464* 465 472
file_create_info                       based           structure                level 1 dcl 8-21 set ref 176
file_create_info_ptr            000150 automatic       pointer                  dcl 8-41 in procedure "rmdb_copy_relation" set ref
                                                                                  176* 182 183 184 185 186 187 188 189 190 191 192
file_create_info_ptr      2            based           pointer                  level 2 in structure "rel_creation_info" dcl 11-4
                                                                                  in procedure "rmdb_copy_relation" set ref 182*
file_id                  10            based           bit(36)                  level 2 dcl 16-113 set ref 470*
file_info                              based           structure                level 1 dcl 16-113 set ref 467
file_model                             based           structure                level 1 dcl 17-40
file_model_copy_good      0(02)        based           bit(1)                   level 2 packed unaligned dcl 17-40 set ref 60* 94*
                                                                                  455*
file_model_ptr           10            based           pointer                  level 2 dcl 20-77 ref 43
file_name                              based           char(30)                 level 2 dcl 16-113 set ref 469*
file_ptr                 22            based           bit(18)                  level 2 packed unaligned dcl 16-72 set ref 462 474*
find_condition_info_            000014 constant        entry                    external dcl 1-64 ref 1-123
fixed                                                  builtin function         dcl 645 ref 412
flag_list                       000557 automatic       bit(36)                  dcl 646 set ref 205 206* 210* 224*
flags                    16            based           structure                array level 3 in structure "relation" dcl 20-77
                                                                                  in procedure "rmdb_copy_relation"
flags                     5            based           structure                level 2 in structure "relation_search_specification"
                                                                                  packed unaligned dcl 13-9 in procedure
                                                                                  "rmdb_copy_relation" set ref 279*
flags                     4            based           structure                level 2 in structure "file_create_info" packed
                                                                                  unaligned dcl 8-21 in procedure
                                                                                  "rmdb_copy_relation"
fm_area                  46            based           area                     level 2 dcl 17-40 set ref 412* 412 415
fm_ptr                          000202 automatic       pointer                  dcl 17-108 set ref 43* 60 61 372 412 455
fwd_ptr                  11            based           bit(18)                  level 2 packed unaligned dcl 16-113 set ref 465 471*
                                                                                  476*
fwd_thread               20            based           bit(18)                  level 2 packed unaligned dcl 17-192 ref 169 229
get_tuple_by_id          40            based           entry variable           level 2 dcl 21-18 ref 340
get_tuple_id             34            based           entry variable           level 2 dcl 21-18 ref 326
hcs_$chname_file                000054 constant        entry                    external dcl 647 ref 399 404 405
head                                   based           structure                level 2 dcl 13-9
id                       10            based           bit(36)                  level 2 in structure "rel_info" dcl 17-126
                                                                                  in procedure "rmdb_copy_relation" set ref 194*
id                              000100 automatic       bit(36)                  dcl 554 in procedure "cleaner" set ref 564* 565 565*
id                        2            based           bit(36)                  array level 2 in structure "element_id_list"
                                                                                  dcl 7-21 in procedure "rmdb_copy_relation" set ref
                                                                                  324* 340* 344*
id                        2            based           fixed bin(17,0)          array level 2 in structure "id_list" dcl 9-16
                                                                                  in procedure "rmdb_copy_relation" set ref 162*
                                                                                  223* 299*
id_list                                based           structure                level 1 dcl 9-16 set ref 152 290
id_list_ptr                     000152 automatic       pointer                  initial dcl 9-21 set ref 9-21* 152* 153 154 161 161
                                                                                  162 162 172 210* 217 223 224* 290* 291 292 298 298
                                                                                  299 299 340*
il_number_of_ids                000154 automatic       fixed bin(17,0)          initial dcl 9-22 set ref 9-22* 151* 152 152 289* 290
                                                                                  290
index_attr               10(01)        based           bit(1)                   level 2 packed unaligned dcl 17-192 ref 221 431
index_id                 11            based           bit(36)                  level 2 dcl 17-192 set ref 224*
index_is_unique           0(02)        based           bit(1)                   level 2 packed unaligned dcl 12-16 set ref 207* 216*
indexed                  10(01) 000736 automatic       bit(1)                   level 2 packed unaligned dcl 384 set ref 431*
init_file_model                 000000 constant        structure                level 1 dcl 18-18 ref 411
init_rel_info                   000046 constant        structure                level 1 dcl 18-65 ref 419
initiate_file_$create           000056 constant        entry                    external dcl 650 ref 389
key_attr                 10            based           bit(1)                   level 2 packed unaligned dcl 17-192 ref 160 430
last_file_info_ptr              000560 automatic       pointer                  dcl 654 set ref 47* 464* 474 476
like_file_model                        based           structure                level 1 dcl 18-62 set ref 411*
loop                            000717 automatic       fixed bin(35,0)          dcl 244 set ref 295* 296 299 301* 331* 331* 340 344*
                                                                                  349
max_data_len             17            based           fixed bin(35,0)          level 2 dcl 17-126 set ref 449* 449
maximum_dimension_name_length
                          4            based           fixed bin(17,0)          level 2 dcl 22-21 set ref 146* 166 166 166 167 167
                                                                                  167
maximum_number_of_constraints
                          4            based           fixed bin(17,0)          level 2 packed unaligned dcl 13-9 set ref 271*
mbz                      10(02) 000736 automatic       bit(34)                  level 2 packed unaligned dcl 384 set ref 432*
mbz_1                     4(03)        based           bit(15)                  initial level 3 packed unaligned dcl 8-21 set ref
                                                                                  176* 189*
mbz_2                     6            based           fixed bin(71,0)          array level 2 dcl 8-21 set ref 191*
mbz_3                     4(26)        based           bit(46)                  initial level 2 packed unaligned dcl 8-21 set ref
                                                                                  176* 192*
mdbm_util_$free_temp_segment    000064 constant        entry                    external dcl 657 ref 561
mdbm_util_$get_data_bit_length  000060 constant        entry                    external dcl 655 ref 306
mdbm_util_$get_temp_segment_path
                                000062 constant        entry                    external dcl 656 ref 111
mftxn_code                      000142 automatic       fixed bin(35,0)          dcl 4-54 set ref 82* 4-62* 4-65 4-68* 4-69 4-78
                                                                                  1-126* 1-132* 511* 512
mftxn_temp_code                 000143 automatic       fixed bin(35,0)          dcl 4-55 set ref 4-71* 4-72 4-72* 4-82* 4-83 4-85*
                                                                                  4-86 4-86* 4-96* 4-97 4-99* 4-100 4-100* 4-109*
                                                                                  4-110 4-110* 514* 515 515* 517*
mod                                                    builtin function         dcl 658 ref 444 446
mrds_data_$max_tids_returned_per_call
                                000066 external static fixed bin(35,0)          dcl 659 ref 283 313
mrds_data_$relation_blocking_factor
                                000070 external static fixed bin(17,0)          dcl 660 ref 185
mrds_error_$no_primary_key      000072 external static fixed bin(35,0)          dcl 661 set ref 172*
msg                                    parameter       char                     unaligned dcl 538 ref 534 543
mstxn_code                      000100 automatic       fixed bin(35,0)          dcl 1-65 set ref 1-83* 1-89* 1-90 1-99* 1-140 1-140*
                                                                                  4-90* 4-104* 1-137* 491* 492 521* 522 522*
mstxn_condition_info            000110 automatic       structure                level 1 unaligned dcl 1-77 set ref 1-123 1-123
mstxn_retries                   000101 automatic       fixed bin(17,0)          dcl 1-66 set ref 1-88* 4-78 4-81* 4-81
mstxn_temp_code                 000102 automatic       fixed bin(35,0)          dcl 1-67 set ref 1-109* 1-110 1-110* 1-123*
mstxn_transactions_needed       000103 automatic       bit(1)                   dcl 1-68 set ref 65 1-86 80 337 346 490* 499*
mstxn_txn_id                    000105 automatic       bit(36)                  dcl 1-70 set ref 49* 1-84* 1-89* 1-93 1-94* 1-99*
                                                                                  1-100 4-60 4-68* 4-71* 4-72* 4-82* 4-85* 4-86*
                                                                                  4-96* 4-99* 4-100* 4-109* 4-110* 4-114* 1-107
                                                                                  1-109* 1-110* 1-121 491* 494* 511* 514* 515* 520*
                                                                                  521* 569 571* 572*
myname                          000112 constant        char(32)                 initial unaligned dcl 662 set ref 111* 120 561*
name                      6            based           varying char             array level 3 in structure "typed_vector_array"
                                                                                  dcl 22-21 in procedure "rmdb_copy_relation" set
                                                                                  ref 166*
name                                   based           char(32)                 level 2 in structure "relation" packed unaligned
                                                                                  dcl 20-77 in procedure "rmdb_copy_relation" set
                                                                                  ref 172 253* 254 261 265 357 362 390 398 420
name                                   based           char(32)                 level 2 in structure "rel_info" dcl 17-126
                                                                                  in procedure "rmdb_copy_relation" set ref 420*
name                            000736 automatic       char(32)                 level 2 in structure "adi" packed unaligned dcl 384
                                                                                  in procedure "copy_file_model" set ref 429*
name                                   based           char(32)                 level 2 in structure "attr_info" dcl 17-192
                                                                                  in procedure "rmdb_copy_relation" ref 166 429
new_cursor_ptr                  000720 automatic       pointer                  dcl 245 set ref 264* 344*
new_file_info_ptr               000562 automatic       pointer                  dcl 663 set ref 47* 467* 468 469 470 471 474 476
new_file_model_ptr              000564 automatic       pointer                  dcl 664 set ref 46* 93 94 157 169 219 229 389* 411
                                                                                  412 413 415 417 434* 472
new_model_bit_count             000566 automatic       fixed bin(35,0)          dcl 665 set ref 452*
new_relation_id                 000567 automatic       bit(36)                  dcl 666 set ref 48* 194* 210* 224* 250* 251* 264*
                                                                                  366* 369* 564
no_concurrency            4(01)        based           bit(1)                   initial level 3 packed unaligned dcl 8-21 set ref
                                                                                  176* 187*
no_freeing                1(04) 000222 automatic       bit(1)                   level 3 packed unaligned dcl 627 set ref 119*
no_rollback               4(02)        based           bit(1)                   initial level 3 packed unaligned dcl 8-21 set ref
                                                                                  176* 188*
null                                                   builtin function         dcl 667 ref 46 47 9-21 12-24 13-50 13-50 1-123 1-123
                                                                                  109 180 181 277 310 474 558
num_attr                 12            based           fixed bin(17,0)          level 2 packed unaligned dcl 17-126 set ref 144 151
                                                                                  220
number_of_and_groups      4(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 13-9 set ref 271*
number_of_dimensions      1            based           fixed bin(17,0)          level 2 dcl 22-21 set ref 146* 149* 165* 165 166 167
number_of_elements        1            based           fixed bin(35,0)          level 2 dcl 7-21 set ref 314* 323* 324 331 331
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 9-16 set ref 152* 153* 161* 161 162 172
                                                                                  217* 290* 292* 298* 298 299
number_of_vector_slots
                          3            based           fixed bin(17,0)          level 2 dcl 22-21 set ref 146*
nvar_atts                14(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 17-126 set ref 442
old_cursor_ptr                  000722 automatic       pointer                  dcl 246 set ref 260* 326* 340*
old_relation_id                 000570 automatic       bit(36)                  dcl 671 set ref 48* 253* 260* 367* 369* 564
open                     10            based           entry variable           level 2 dcl 21-18 ref 251 253
owner                     2     000222 automatic       char(32)                 level 2 packed unaligned dcl 627 set ref 120*
p                               000102 automatic       pointer                  dcl 555 set ref 557* 558 560* 561*
pad                       1(18)        based           bit(18)                  level 3 packed unaligned dcl 13-9 set ref 276*
primary_key              10     000736 automatic       bit(1)                   level 2 packed unaligned dcl 384 set ref 430*
primary_key_index_id     25            based           bit(36)                  level 2 dcl 17-126 set ref 210*
protected                 4            based           bit(1)                   initial level 3 packed unaligned dcl 8-21 set ref
                                                                                  176* 186*
ptr                                                    builtin function         dcl 672 ref 157 164 169 219 229 301 303 428 462 465
put_tuple                30            based           entry variable           level 2 dcl 21-18 ref 344
range                     6            based           structure                level 2 dcl 13-9
rel                                                    builtin function         dcl 673 ref 412 417 462 472 474 476
rel_creation_info                      based           structure                level 1 dcl 11-4 set ref 175
rel_creation_info_ptr           000156 automatic       pointer                  dcl 11-10 set ref 175* 179 180 181 182 194*
rel_info                               based           structure                level 1 dcl 17-126 set ref 415 419*
rel_ptr                  20(27)        based           bit(18)                  level 2 packed unaligned dcl 17-40 set ref 417*
relation                               based           structure                level 1 unaligned dcl 20-77
relation_copy_good        0(03)        based           bit(1)                   level 2 packed unaligned dcl 17-40 set ref 61* 93*
                                                                                  372*
relation_idx                    000571 automatic       fixed bin(17,0)          dcl 674 set ref 424* 425 427 428*
relation_index_flags                   based           structure                level 1 dcl 12-16
relation_index_flags_ptr        000162 automatic       pointer                  initial dcl 12-24 set ref 12-24* 205* 207 216
relation_numeric_specification_ptr
                                000166 automatic       pointer                  initial dcl 13-50 set ref 13-50*
relation_ptr                    000210 automatic       pointer                  dcl 20-74 set ref 41* 43 172 253 254 261 265 289 295
                                                                                  296 301 357 362 390 398 420 424 425 427 428 468
relation_search_specification          based           structure                level 1 dcl 13-9 set ref 271
relation_search_specification_ptr
                                000164 automatic       pointer                  initial dcl 13-50 set ref 13-50* 271* 273 274 276
                                                                                  277 279 281 283 326* 352
release_area_                   000074 constant        entry                    external dcl 675 ref 124 560
ri_ptr                          000204 automatic       pointer                  dcl 17-185 set ref 144 151 157 194 210 219 220 415*
                                                                                  417 419 420 421 442 444 446 448 448 449 449
ring_brackets             4(18)        based           fixed bin(3,0)           initial array level 2 packed unaligned dcl 8-21 set
                                                                                  ref 176* 176* 190*
rmdb_build_attr_info            000076 constant        entry                    external dcl 676 ref 434
rmdb_relmgr_entries                    based           structure                level 1 unaligned dcl 21-18
rmdb_relmgr_entries_ptr         000212 automatic       pointer                  dcl 21-32 set ref 40* 194 210 224 250 251 253 260
                                                                                  264 326 340 344 366 367 565
rollback_on               0(32)        based           bit(1)                   level 3 packed unaligned dcl 16-72 ref 188
rss_maximum_number_of_constraints
                                000171 automatic       fixed bin(17,0)          initial dcl 13-52 set ref 13-52* 270* 271 271
rss_number_of_and_groups        000170 automatic       fixed bin(17,0)          initial dcl 13-52 set ref 13-52* 269* 271 271
rtrim                                                  builtin function         dcl 677 ref 54 357 398
simple_typed_vector_ptr         000172 automatic       pointer                  dcl 15-33 set ref 310* 340* 344*
size                      7            based           fixed bin(17,0)          level 3 in structure "relation_search_specification"
                                                                                  dcl 13-9 in procedure "rmdb_copy_relation" set ref
                                                                                  283*
size                     13     000222 automatic       fixed bin(18,0)          level 2 in structure "ai" dcl 627 in procedure
                                                                                  "rmdb_copy_relation" set ref 121*
specification_head                     based           structure                level 1 unaligned dcl 14-10
style                           000572 automatic       fixed bin(17,0)          dcl 678 set ref 204* 210* 224*
subset_specification_ptr
                          2            based           pointer                  level 3 dcl 13-9 set ref 277*
sys_info$max_seg_size           000100 external static fixed bin(35,0)          dcl 679 ref 121 412
temp_dir_path                   000573 automatic       char(168)                unaligned dcl 680 set ref 39* 111*
transaction_manager_$abandon_txn
                                000016 constant        entry                    external dcl 1-72 ref 4-72 4-86 4-100 4-110 1-110
                                                                                  515 572
transaction_manager_$abort_txn  000020 constant        entry                    external dcl 1-73 ref 4-71 4-85 4-99 4-109 1-109 514
                                                                                  571
transaction_manager_$begin_txn  000022 constant        entry                    external dcl 1-74 ref 1-99 521
transaction_manager_$commit_txn 000034 constant        entry                    external dcl 4-56 ref 4-68 511
transaction_manager_$get_current_txn_id
                                000024 constant        entry                    external dcl 1-75 ref 1-89 491
transaction_manager_$handle_conditions
                                000026 constant        entry                    external dcl 1-76 ref 1-135
transaction_manager_$rollback_txn
                                000036 constant        entry                    external dcl 4-57 ref 4-82 4-96
transactions_needed       0(34)        based           bit(1)                   level 3 packed unaligned dcl 16-72 ref 186 488
tuple_bit_length                000724 automatic       fixed bin(35,0)          dcl 247 set ref 294* 306* 306
tva_maximum_dimension_name_length
                                000220 automatic       fixed bin(17,0)          dcl 22-48 set ref 145* 146 146
tva_number_of_dimensions        000217 automatic       fixed bin(17,0)          dcl 22-46 set ref 144* 146 146 158
tva_number_of_vector_slots      000216 automatic       fixed bin(17,0)          dcl 22-44 set ref 143* 146 146
type                      6            based           fixed bin(17,0)          level 3 in structure "relation_search_specification"
                                                                                  dcl 13-9 in procedure "rmdb_copy_relation" set ref
                                                                                  281*
type                      1            based           fixed bin(17,0)          level 3 in structure "relation_search_specification"
                                                                                  packed unaligned dcl 13-9 in procedure
                                                                                  "rmdb_copy_relation" set ref 274* 352*
typed_vector_array                     based           structure                level 1 dcl 22-21 set ref 146
typed_vector_array_ptr          000214 automatic       pointer                  dcl 22-43 set ref 146* 148 149 165 165 166 166 167
                                                                                  167 194*
unique_chars_                   000102 constant        entry                    external dcl 681 ref 53
unspec                                                 builtin function         dcl 682 set ref 115* 279*
user_started_transaction        000104 automatic       bit(1)                   dcl 1-69 set ref 1-92* 1-98* 4-60
user_transaction_id             000106 automatic       bit(36)                  dcl 1-71 set ref 1-93* 1-100*
var_offset               22            based           fixed bin(35,0)          level 2 dcl 17-126 set ref 444 446 448* 448
version                                based           fixed bin(35,0)          level 2 in structure "typed_vector_array" dcl 22-21
                                                                                  in procedure "rmdb_copy_relation" set ref 148*
version                                based           fixed bin(35,0)          level 3 in structure "relation_search_specification"
                                                                                  dcl 13-9 in procedure "rmdb_copy_relation" set ref
                                                                                  273*
version                                based           fixed bin(35,0)          level 2 in structure "id_list" dcl 9-16 in procedure
                                                                                  "rmdb_copy_relation" set ref 154* 291*
version                                based           char(8)                  level 2 in structure "file_create_info" dcl 8-21
                                                                                  in procedure "rmdb_copy_relation" set ref 183*
version                         000222 automatic       fixed bin(17,0)          level 2 in structure "ai" dcl 627 in procedure
                                                                                  "rmdb_copy_relation" set ref 116*
version                                based           fixed bin(35,0)          level 2 in structure "element_id_list" dcl 7-21
                                                                                  in procedure "rmdb_copy_relation" set ref 315*
version                                based           fixed bin(35,0)          level 2 in structure "rel_creation_info" dcl 11-4
                                                                                  in procedure "rmdb_copy_relation" set ref 179*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 14-22
ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 14-22
ABSOLUTE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 14-22
ALL_RANGE_TYPE                         internal static fixed bin(17,0)          initial dcl 10-8
ATTRIBUTE_KEY_HEAD                     internal static char(10)                 initial unaligned dcl 20-31
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-33
DOMAIN_KEY_HEAD                        internal static char(7)                  initial unaligned dcl 20-32
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
FCI_READ_BRACKET_IDX                   internal static fixed bin(17,0)          initial dcl 8-45
FCI_WRITE_BRACKET_IDX                  internal static fixed bin(17,0)          initial dcl 8-45
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 15-43
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 2-12
HIGH_RANGE_TYPE                        internal static fixed bin(17,0)          initial dcl 10-8
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 2-12
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
NUMERIC_SPECIFICATION_TYPE             internal static fixed bin(17,0)          initial dcl 14-22
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
OBJECT_HEAD                            internal static char(1)                  initial unaligned dcl 20-29
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 15-43
RELATION_KEY_HEAD                      internal static char(9)                  initial unaligned dcl 20-33
RELATIVE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 14-22
RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 14-22
RELATIVE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 14-22
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
RMDB_CREATE_REL_INFO_VERSION_1         internal static fixed bin(17,0)          initial dcl 19-33
RMDB_IX_ATTRS_VERSION_1                internal static fixed bin(17,0)          initial dcl 19-44
RMDB_SEL_VAL_INFO_VERSION_1            internal static fixed bin(17,0)          initial dcl 19-53
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
R_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
SEARCH_SPECIFICATION_TYPE              internal static fixed bin(17,0)          initial dcl 14-22
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-30
SIMPLE_TYPED_VECTOR_TYPE               internal static fixed bin(17,0)          initial dcl 15-43
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 2-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 2-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 2-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 2-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 2-20
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
adi_ptr                                automatic       pointer                  dcl 19-30
al_ptr                                 automatic       pointer                  dcl 17-345
alloc_length                           internal static fixed bin(35,0)          dcl 16-222
area_infop                             automatic       pointer                  dcl 6-5
atd                                    based           char                     unaligned dcl 17-109
atd_len                                automatic       fixed bin(17,0)          dcl 17-111
atd_ptr                                automatic       pointer                  dcl 17-110
attr_list                              based           structure                level 1 dcl 17-341
attribute                              based           structure                level 1 unaligned dcl 20-99
attribute_count                        automatic       fixed bin(17,0)          dcl 20-98
attribute_list                         based           structure                level 1 unaligned dcl 20-55
attribute_list_count                   automatic       fixed bin(17,0)          dcl 20-53
attribute_list_names                   based           char                     unaligned dcl 20-54
attribute_list_ptr                     automatic       pointer                  dcl 20-52
attribute_ptr                          automatic       pointer                  dcl 20-97
changer                                based           structure                level 1 packed unaligned dcl 16-251
changer_ptr                            automatic       pointer                  dcl 16-256
child_link_info                        based           structure                level 1 dcl 17-283
cli_ptr                                automatic       pointer                  dcl 17-329
cna_ptr                                automatic       pointer                  dcl 17-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 17-112
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
constant                               based           structure                level 1 unaligned dcl 16-216
constant_ptr                           automatic       pointer                  dcl 16-220
crossref_info_record                   based           structure                level 1 unaligned dcl 20-19
crossref_info_record_count             automatic       fixed bin(21,0)          dcl 20-18
crossref_info_record_objects           based           char                     unaligned dcl 20-27
crossref_info_record_ptr               automatic       pointer                  dcl 20-17
domain_list                            based           structure                level 1 unaligned dcl 20-45
domain_list_count                      automatic       fixed bin(17,0)          dcl 20-43
domain_list_names                      based           char                     unaligned dcl 20-44
domain_list_ptr                        automatic       pointer                  dcl 20-42
dp_ptr                                 automatic       pointer                  dcl 17-356
dup_prev                               based           structure                level 1 dcl 17-353
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 1-63
general_typed_vector                   based           structure                level 1 packed unaligned dcl 15-24
general_typed_vector_ptr               automatic       pointer                  dcl 15-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 15-40
message_str                            based           structure                level 1 packed unaligned dcl 16-259
message_str_len                        automatic       fixed bin(17,0)          dcl 16-269
message_str_ptr                        automatic       pointer                  dcl 16-267
ncomp_init                             automatic       fixed bin(17,0)          dcl 17-116
parent_link_info                       based           structure                level 1 dcl 17-223
path_entry                             based           structure                level 1 packed unaligned dcl 16-172
path_entry_ptr                         automatic       pointer                  dcl 16-177
pli_ptr                                automatic       pointer                  dcl 17-268
relation_attribute_count               automatic       fixed bin(17,0)          dcl 20-75
relation_attribute_names               based           char                     unaligned dcl 20-76
relation_list                          based           structure                level 1 unaligned dcl 20-67
relation_list_count                    automatic       fixed bin(17,0)          dcl 20-65
relation_list_names                    based           char                     unaligned dcl 20-66
relation_list_ptr                      automatic       pointer                  dcl 20-64
relation_numeric_specification         based           structure                level 1 dcl 13-41
rmdb_create_rel_info                   based           structure                level 1 dcl 19-11
rmdb_create_rel_info_alloc             automatic       fixed bin(17,0)          dcl 19-32
rmdb_create_rel_info_ptr               automatic       pointer                  dcl 19-31
rmdb_ix_attrs                          based           structure                level 1 dcl 19-36
rmdb_ix_attrs_alloc                    automatic       fixed bin(17,0)          dcl 19-42
rmdb_ix_attrs_ptr                      automatic       pointer                  dcl 19-43
rmdb_sel_val_info                      based           structure                level 1 dcl 19-46
rmdb_sel_val_info_ptr                  automatic       pointer                  dcl 19-52
sc_ptr                                 automatic       pointer                  dcl 17-365
select_chain                           based           structure                level 1 dcl 17-357
simple_typed_vector                    based           structure                level 1 packed unaligned dcl 15-17
sk_ptr                                 automatic       pointer                  dcl 17-352
sort_key                               based           structure                level 1 dcl 17-346
specification_head_ptr                 automatic       pointer                  dcl 14-18
stack_item                             based           structure                level 1 unaligned dcl 16-206
stack_item_ptr                         automatic       pointer                  dcl 16-212
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 15-35
ua_ptr                                 automatic       pointer                  dcl 16-165
unreferenced_attribute                 based           structure                level 1 dcl 16-159
version_status                         based           structure                level 1 packed unaligned dcl 16-232
version_status_ptr                     automatic       pointer                  dcl 16-246

NAMES DECLARED BY EXPLICIT CONTEXT.
RETURN_TO_CALLER                001307 constant        label                    dcl 547 ref 544
cleaner                         004437 constant        entry                    internal dcl 551 ref 51 70 547
copy_data                       002463 constant        entry                    internal dcl 239 ref 79
copy_file_model                 003370 constant        entry                    internal dcl 381 ref 63
create_relation                 001612 constant        entry                    internal dcl 137 ref 78
error                           004373 constant        entry                    internal dcl 534 ref 1-140 96 112 127 172 198 212
                                                                                  226 254 261 265 357 362 390 407 435 495 517 522
make_area                       001443 constant        entry                    internal dcl 104 ref 56
manage_transaction              004252 constant        entry                    internal dcl 508 ref 337 346
mftxn_check_code                001044 constant        label                    dcl 4-65 ref 1-127 1-133
mftxn_exit                      001264 constant        label                    dcl 4-115 ref 4-63
mstxn_any_other                 001346 constant        entry                    internal dcl 1-116 ref 72
mstxn_cleanup                   001314 constant        entry                    internal dcl 1-102 ref 69
mstxn_exit                      001007 constant        label                    dcl 1-140 ref 1-86 1-95 4-91 4-105
restore_significant_data        004566 constant        entry                    internal dcl 579 ref 4-77
rmdb_copy_relation              000465 constant        entry                    external dcl 34
should_rollback                 004570 constant        entry                    internal dcl 584 ref 4-94
transaction_in_progress         004205 constant        entry                    internal dcl 485 ref 64

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5300        5404    4620        5310
Length      6346    4620       104         726     457           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rmdb_copy_relation                  811 external procedure  is an external procedure.  
on unit on line 51                   64 on unit               
on unit on line 67                   76 on unit               
on unit on line 72                   82 on unit               
mstxn_cleanup                           internal procedure  shares stack frame of on unit on line 67.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 72.  
make_area                               internal procedure  shares stack frame of external procedure rmdb_copy_relation.  
create_relation                         internal procedure  shares stack frame of external procedure rmdb_copy_relation.  
copy_data                               internal procedure  shares stack frame of external procedure rmdb_copy_relation.  
copy_file_model                         internal procedure  shares stack frame of external procedure rmdb_copy_relation.  
transaction_in_progress                 internal procedure  shares stack frame of external procedure rmdb_copy_relation.  
manage_transaction                      internal procedure  shares stack frame of external procedure rmdb_copy_relation.  
error                                65 internal procedure  is called during a stack extension.  
cleaner                              90 internal procedure  is called by several nonquick procedures.  
restore_significant_data                internal procedure  shares stack frame of external procedure rmdb_copy_relation.  
should_rollback                         internal procedure  shares stack frame of external procedure rmdb_copy_relation.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cleaner                  000100 id                          cleaner
                         000102 p                           cleaner
rmdb_copy_relation       000100 mstxn_code                  rmdb_copy_relation
                         000101 mstxn_retries               rmdb_copy_relation
                         000102 mstxn_temp_code             rmdb_copy_relation
                         000103 mstxn_transactions_needed   rmdb_copy_relation
                         000104 user_started_transaction    rmdb_copy_relation
                         000105 mstxn_txn_id                rmdb_copy_relation
                         000106 user_transaction_id         rmdb_copy_relation
                         000110 mstxn_condition_info        rmdb_copy_relation
                         000142 mftxn_code                  rmdb_copy_relation
                         000143 mftxn_temp_code             rmdb_copy_relation
                         000144 element_id_list_ptr         rmdb_copy_relation
                         000146 eil_number_of_elements      rmdb_copy_relation
                         000147 ELEMENT_ID_LIST_VERSION_1   rmdb_copy_relation
                         000150 file_create_info_ptr        rmdb_copy_relation
                         000152 id_list_ptr                 rmdb_copy_relation
                         000154 il_number_of_ids            rmdb_copy_relation
                         000156 rel_creation_info_ptr       rmdb_copy_relation
                         000160 REL_CREATION_INFO_VERSION_2 rmdb_copy_relation
                         000162 relation_index_flags_ptr    rmdb_copy_relation
                         000164 relation_search_specification_ptr
                                                            rmdb_copy_relation
                         000166 relation_numeric_specification_ptr
                                                            rmdb_copy_relation
                         000170 rss_number_of_and_groups    rmdb_copy_relation
                         000171 rss_maximum_number_of_constraints
                                                            rmdb_copy_relation
                         000172 simple_typed_vector_ptr     rmdb_copy_relation
                         000174 dbm_ptr                     rmdb_copy_relation
                         000176 fi_ptr                      rmdb_copy_relation
                         000200 di_ptr                      rmdb_copy_relation
                         000202 fm_ptr                      rmdb_copy_relation
                         000204 ri_ptr                      rmdb_copy_relation
                         000206 ai_ptr                      rmdb_copy_relation
                         000210 relation_ptr                rmdb_copy_relation
                         000212 rmdb_relmgr_entries_ptr     rmdb_copy_relation
                         000214 typed_vector_array_ptr      rmdb_copy_relation
                         000216 tva_number_of_vector_slots  rmdb_copy_relation
                         000217 tva_number_of_dimensions    rmdb_copy_relation
                         000220 tva_maximum_dimension_name_length
                                                            rmdb_copy_relation
                         000222 ai                          rmdb_copy_relation
                         000262 code                        rmdb_copy_relation
                         000264 control_area_ptr            rmdb_copy_relation
                         000266 create_model_name           rmdb_copy_relation
                         000276 create_relation_name        rmdb_copy_relation
                         000306 db_path                     rmdb_copy_relation
                         000360 delete_model_sw             rmdb_copy_relation
                         000361 delete_relation_sw          rmdb_copy_relation
                         000362 error_message               rmdb_copy_relation
                         000557 flag_list                   rmdb_copy_relation
                         000560 last_file_info_ptr          rmdb_copy_relation
                         000562 new_file_info_ptr           rmdb_copy_relation
                         000564 new_file_model_ptr          rmdb_copy_relation
                         000566 new_model_bit_count         rmdb_copy_relation
                         000567 new_relation_id             rmdb_copy_relation
                         000570 old_relation_id             rmdb_copy_relation
                         000571 relation_idx                rmdb_copy_relation
                         000572 style                       rmdb_copy_relation
                         000573 temp_dir_path               rmdb_copy_relation
                         000662 cr_loop                     create_relation
                         000716 descriptor                  copy_data
                         000717 loop                        copy_data
                         000720 new_cursor_ptr              copy_data
                         000722 old_cursor_ptr              copy_data
                         000724 tuple_bit_length            copy_data
                         000736 adi                         copy_file_model
                         000747 add_name                    copy_file_model
                         000757 amount_to_pad               copy_file_model

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ent_var        call_ext_out_desc   call_ext_out
call_int_this_desc  call_int_this       call_int_other      return_mac          tra_ext_1           mdfx3
enable_op           shorten_stack       ext_entry_desc      int_entry           int_entry_desc      op_alloc_
op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
adjust_bit_count_             continue_to_signal_           define_area_                  find_condition_info_
hcs_$chname_file              initiate_file_$create         mdbm_util_$free_temp_segment
mdbm_util_$get_data_bit_length                              mdbm_util_$get_temp_segment_path
release_area_                 rmdb_build_attr_info          transaction_manager_$abandon_txn
transaction_manager_$abort_txn                              transaction_manager_$begin_txn
transaction_manager_$commit_txn                             transaction_manager_$get_current_txn_id
transaction_manager_$handle_conditions                      transaction_manager_$rollback_txn
unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$key_duplication     dm_error_$lock_deadlock
dm_error_$no_current_transaction                            dm_error_$no_tuple
error_table_$action_not_performed                           error_table_$namedup
mrds_data_$max_tids_returned_per_call                       mrds_data_$relation_blocking_factor
mrds_error_$no_primary_key    sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     34 000457    7   28 000512    9   21 000514    9   22 000516   11   11 000520   12   24 000522   13   50 000524
13   52 000526        37 000530        38 000534        39 000541        40 000546        41 000551        43 000554
     45 000556        46 000560        47 000563        48 000566        49 000570        51 000571        53 000613
     54 000635        56 000663        60 000666        61 000670        63 000672        64 000673        65 000674
     67 000676        69 000712        70 000713        71 000720        72 000721    1   83 000737    1   84 000740
 1   86 000741    1   88 000743    1   89 000744    1   90 000755    1   92 000761    1   93 000763    1   94 000765
 1   95 000766    1   98 000767    1   99 000770    1  100 001005    1  140 001007        78 001030        79 001031
     80 001032        82 001034    4   60 001035    4   62 001042    4   63 001043    4   65 001044    4   68 001046
 4   69 001057    4   71 001061    4   72 001072    4   75 001105    4   77 001106    4   78 001107    4   81 001116
 4   82 001117    4   83 001132    4   85 001134    4   86 001145    4   88 001160    4   90 001161    4   91 001162
 4   93 001163    4   94 001164    4   96 001171    4   97 001205    4   99 001207    4  100 001220    4  102 001233
 4  104 001234    4  105 001235    4  107 001236    4  109 001237    4  110 001250    4  114 001263        92 001264
     93 001266        94 001270        96 001272       547 001307       549 001313    1  102 001314    1  107 001315
 1  109 001320    1  110 001331    1  114 001345    1  116 001346    1  121 001347    1  123 001352    1  124 001371
 1  126 001377    1  127 001402    1  129 001405    1  132 001417    1  133 001422    1  135 001425    1  136 001432
 1  137 001433    1  138 001442       104 001443       109 001445       111 001451       112 001477       115 001520
    116 001523       117 001525       118 001527       119 001531       120 001533       121 001536       122 001541
    123 001545       124 001546       126 001555       127 001570       130 001611       137 001612       143 001613
    144 001614       145 001620       146 001622       148 001655       149 001657       151 001660       152 001664
    153 001674       154 001675       157 001677       158 001705       160 001715       161 001721       162 001723
    164 001727       165 001734       166 001736       167 001766       169 001777       170 002004       172 002006
    175 002035       176 002042       179 002103       180 002105       181 002110       182 002112       183 002114
    184 002117       185 002121       186 002124       187 002131       188 002141       189 002151       190 002153
    191 002170       192 002204       194 002207       198 002246       201 002272       204 002274       205 002276
    206 002300       207 002301       210 002303       212 002325       216 002351       217 002353       219 002356
    220 002364       221 002375       223 002401       224 002405       226 002426       229 002452       230 002460
    232 002462       239 002463       250 002464       251 002476       253 002523       254 002550       260 002575
    261 002612       264 002637       265 002654       269 002701       270 002702       271 002703       273 002725
    274 002727       276 002731       277 002733       279 002735       281 002737       283 002741       289 002744
    290 002747       291 002757       292 002761       294 002762       295 002763       296 002773       298 003001
    299 003003       301 003006       302 003013       303 003015       306 003025       308 003042       310 003047
    313 003052       314 003055       315 003066       320 003070       321 003071       323 003074       324 003076
    326 003107       331 003126       337 003144       340 003147       344 003172       346 003213       349 003216
    352 003223       355 003230       357 003231       362 003312       363 003336       366 003337       367 003351
    369 003363       372 003365       374 003367       381 003370       389 003371       390 003435       393 003462
    398 003464       399 003513       400 003544       402 003546       404 003551       405 003600       407 003630
    411 003654       412 003660       413 003675       415 003703       417 003711       419 003716       420 003721
    421 003725       424 003730       425 003737       427 003744       428 003746       429 003752       430 003755
    431 003761       432 003765       434 003767       435 004023       439 004041       442 004043       444 004051
    446 004064       448 004067       449 004073       452 004077       455 004121       462 004123       464 004135
    465 004137       467 004145       468 004153       469 004155       470 004160       471 004162       472 004164
    474 004171       476 004201       478 004204       485 004205       488 004206       490 004211       491 004213
    492 004224       494 004226       495 004227       498 004247       499 004250       501 004251       508 004252
    511 004253       512 004264       514 004266       515 004277       517 004312       520 004331       521 004332
    522 004350       525 004371       534 004372       540 004406       541 004413       543 004423       544 004433
    551 004436       557 004444       558 004447       560 004453       561 004461       564 004503       565 004510
    567 004525       569 004534       571 004537       572 004550       576 004565       579 004566       581 004567
    584 004570       586 004572


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
