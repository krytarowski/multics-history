	COMPILATION LISTING OF SEGMENT sort_convert_internal
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/11/82  1230.0 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 /* Modified on 03/20/82 by FCH, [1], number of input files = 10, sort_merge_subroutine$noexit <- sort_$noexit */
       11 
       12 sort_convert_internal:  proc(source_parameters, internal_parameters, p_area, keys_ptr, io_exits_ptr, exits_ptr,
       13 			bit_count, seg_length, convert_int_code);
       14 /*   Convert Sort/Merge Description from source form to internal form.   */
       15 
       16 /*   PARAMETERS   */
       17 
       18 /*   EXTERNAL ENTRIES   */
       19 dcl  convert_status_code_  entry(fixed bin(35), char(8) aligned, char(100) aligned);
       20 dcl  cv_dec_check_ entry(char(*), fixed bin(35)) returns(fixed bin(35));
       21 dcl  ioa_$ioa_stream  entry  options(variable);
       22 dcl  find_command_ entry(ptr, fixed bin, ptr, fixed bin(35));
       23 dcl  find_command_code fixed bin(35);
       24 dcl  lex_string_$init_lex_delims  entry(char(*), char(*), char(*), char(*), char(*),
       25 		bit(*), char(*) varying aligned, char(*) varying aligned,
       26 		char(*) varying aligned, char(*) varying aligned);
       27 dcl  lex_string_$lex  entry(ptr, fixed bin(21), fixed bin(21), ptr, bit(*),
       28 		char(*), char(*), char(*), char(*), char(*),
       29 		char(*) varying aligned, char(*) varying aligned,
       30 		char(*) varying aligned, char(*) varying aligned,
       31 		ptr, ptr, fixed bin(35));
       32 
       33 /*1*/dcl  sort_$noexit entry external;
       34 
       35 /*   EXTERNAL STATIC   */
       36 
  1     1 dcl 1 sort_ext$acl(1) ext,
  1     2    2 x_user_id char(32),
  1     3    2 x_modes bit(36),
  1     4    2 x_pad bit(36),
  1     5    2 x_acl_code fixed bin(35);
  1     6 dcl 1 acl(1)
  1     7 	 defined(sort_ext$acl),
  1     8    2 user_id char(32),
  1     9    2 modes bit(36),
  1    10    2 pad bit(36),
  1    11    2 acl_code fixed bin(35);
  1    12 dcl sort_ext$b(0: 31) fixed bin(30) ext;		/*  keys - bit offset (usually) for sort_comp  */
  1    13 dcl b(0: 31) fixed bin(30)
  1    14 	 defined (sort_ext$b);
  1    15 dcl sort_ext$compares_counter fixed bin(34) ext;		/*  compares executed, excluding sequence checker  */
  1    16 dcl compares_counter fixed bin(34)
  1    17 	 defined(sort_ext$compares_counter);
  1    18 dcl sort_ext$compare_sw fixed bin(1) ext;		/*  1 = user compare exit specified  */
  1    19 dcl compare_sw fixed bin(1)
  1    20 	 defined (sort_ext$compare_sw);
  1    21 dcl sort_ext$curr_input_file_attach char(256) ext;	/*  attach description, current input file (Sort)  */
  1    22 dcl curr_input_file_attach char(256)
  1    23 	 defined(sort_ext$curr_input_file_attach);
  1    24 dcl sort_ext$curr_input_file_name char(256) ext;		/*  pathname, current input file (Sort)  */
  1    25 dcl curr_input_file_name char(256)
  1    26 	 defined (sort_ext$curr_input_file_name);
  1    27 dcl sort_ext$curr_input_file_num fixed bin(17) ext;	/*  number for current input file (Sort)  */
  1    28 dcl curr_input_file_num fixed bin(17)
  1    29 	 defined (sort_ext$curr_input_file_num);
  1    30 dcl sort_ext$curr_output_file_attach char(256) ext;	/*  attach description, output file  */
  1    31 dcl curr_output_file_attach char(256)
  1    32 	 defined(sort_ext$curr_output_file_attach);
  1    33 dcl sort_ext$curr_output_file_name char(256) ext;		/*  pathname, output file  */
  1    34 dcl curr_output_file_name char(256)
  1    35 	 defined (sort_ext$curr_output_file_name);
  1    36 dcl sort_ext$debug_sw bit(1) ext;			/*  1 = -debug argument specified  */
  1    37 dcl debug_sw bit(1)
  1    38 	 defined(sort_ext$debug_sw);
  1    39 dcl sort_ext$disaster2 fixed bin(17) ext;		/*  0 = first call to sort_return or merge_return  */
  1    40 dcl disaster2 fixed bin(17)
  1    41 	 defined (sort_ext$disaster2);
  1    42 dcl sort_ext$dt(0: 31) fixed bin(30) ext;		/*  keys - datatype for sort_comp  */
  1    43 dcl dt(0: 31) fixed bin(30)
  1    44 	 defined (sort_ext$dt);
  1    45 dcl sort_ext$input_driver_is_sort bit(1) ext;		/*  1 = Sort reads input files, 0 = input_file exit  */
  1    46 dcl input_driver_is_sort bit(1)
  1    47 	 defined(sort_ext$input_driver_is_sort);
  1    48 dcl sort_ext$input_file_exit_sw bit(1) ext;		/*  1 = user input_file exit specified  */
  1    49 dcl input_file_exit_sw bit(1)
  1    50 	 defined(sort_ext$input_file_exit_sw);
  1    51 dcl sort_ext$input_file_max fixed bin(17) ext;		/*  number of input files specified [init(10)]  */
  1    52 		/*  must also change  merge_return:  merge_read_count  &  input_file_len  */
  1    53 dcl input_file_max fixed bin(17)
  1    54 	 defined(sort_ext$input_file_max);
  1    55 dcl sort_ext$input_record_exit_sw fixed bin(1) ext;	/*  1 = user input_record exit specified  */
  1    56 dcl input_record_exit_sw fixed bin(1)
  1    57 	 defined(sort_ext$input_record_exit_sw);
  1    58 dcl sort_ext$input_rec_deleted fixed bin(30) ext;		/*  number of records deleted at input_record exit  */
  1    59 dcl input_rec_deleted fixed bin(30)
  1    60 	 defined(sort_ext$input_rec_deleted);
  1    61 dcl sort_ext$input_rec_inserted fixed bin(30) ext;	/*  number of records inserted _record exit  */
  1    62 dcl input_rec_inserted fixed bin(30)
  1    63 	 defined(sort_ext$input_rec_inserted);
  1    64 dcl sort_ext$in_buff_ptr ptr ext;			/*  buffer for an input record (Sort or Merge reading)  */
  1    65 dcl in_buff_ptr ptr
  1    66 	 defined (sort_ext$in_buff_ptr);
  1    67 dcl sort_ext$leng(0: 31) fixed bin(30) ext;		/*  keys - length or precision for sort_comp  */
  1    68 dcl leng(0: 31) fixed bin(30)
  1    69 	 defined (sort_ext$leng);
  1    70 dcl sort_ext$max1 fixed bin(30) ext;			/*  limits size of unsorted string SS (sort_release)  */
  1    71 dcl max1 fixed bin(30)
  1    72 	 defined (sort_ext$max1);
  1    73 dcl sort_ext$max2 fixed bin(30) ext;			/*  limits size of unsorted string SS (sort_release)  */
  1    74 dcl max2 fixed bin(30)
  1    75 	 defined (sort_ext$max2);
  1    76 dcl sort_ext$max3 fixed bin(30) ext;			/*  maximum number of records per string SS  */
  1    77 dcl max3 fixed bin(30)
  1    78 	 defined (sort_ext$max3);
  1    79 dcl sort_ext$max4 fixed bin(30) ext;			/*  maximum merge order allowed (sort_presort)  */
  1    80 dcl max4 fixed bin(30)
  1    81 	 defined (sort_ext$max4);
  1    82 dcl sort_ext$max_rec_length fixed bin(30) ext;		/*  maximum record length permitted by Sort or Merge;  */
  1    83 						/*  slightly less than sys_info$max_seg_size  */
  1    84 dcl max_rec_length fixed bin(30)
  1    85 	 defined (sort_ext$max_rec_length);
  1    86 dcl sort_ext$merge_compares fixed bin(34) ext;		/*  number of compares in merge  */
  1    87 dcl merge_compares fixed bin(34)
  1    88 	 defined(sort_ext$merge_compares);
  1    89 dcl sort_ext$merge_in_iocb_ptrs(10) ptr ext;		/*  iox_ iocb's for Merge input files  */
  1    90 dcl merge_in_iocb_ptrs(10) ptr
  1    91 	 defined(sort_ext$merge_in_iocb_ptrs);
  1    92 dcl sort_ext$merge_input_file_attaches(10) char(256) ext;	/*  attach descriptions, Merge input files  */
  1    93 dcl merge_input_file_attaches(10) char(256)
  1    94 	 defined(sort_ext$merge_input_file_attaches);
  1    95 dcl sort_ext$merge_input_file_names(10) char(256) ext;	/*  pathnames, Merge input files  */
  1    96 dcl merge_input_file_names(10) char(256)
  1    97 	 defined(sort_ext$merge_input_file_names);
  1    98 dcl sort_ext$mii fixed bin(17) ext;			/*  merge order for Sort [init(0)]  */
  1    99 dcl mii fixed bin(17)
  1   100 	 defined (sort_ext$mii);
  1   101 dcl sort_ext$min_rec_length fixed bin(30) ext;		/*  record length required to include all key fields  */
  1   102 dcl min_rec_length fixed bin(30)
  1   103 	 defined (sort_ext$min_rec_length);
  1   104 dcl sort_ext$mip (1000) fixed bin(30) ext;		/*  number of records in each string MS for merge  */
  1   105 dcl mip (1000) fixed bin(30)
  1   106 	 defined (sort_ext$mip);
  1   107 dcl sort_ext$msp (1000) ptr ext;			/*  sorted strings MS(1:mii) to be merged  */
  1   108 dcl msp (1000) ptr
  1   109 	 defined (sort_ext$msp);
  1   110 dcl sort_ext$no_of_keys fixed bin(30) ext;		/*  number of keys specified  */
  1   111 dcl no_of_keys fixed bin(30)
  1   112 	 defined(sort_ext$no_of_keys);
  1   113 dcl sort_ext$old_input_file_num fixed bin(17) ext;	/*  used for identifying files with bad key data  */
  1   114 dcl old_input_file_num fixed bin(17)			/*       (illegal_procedure handler in sort_presort)  */
  1   115 	 defined(sort_ext$old_input_file_num);
  1   116 dcl sort_ext$output_driver_is_sort bit(1) ext;		/*  1 = Sort or Merge writes output file;  */
  1   117 dcl output_driver_is_sort bit(1)			/*  0 = output_file exit  */
  1   118 	 defined(sort_ext$output_driver_is_sort);
  1   119 dcl sort_ext$output_file_exit_sw bit(1) ext;		/*  1 = user output_file exit specified  */
  1   120 dcl output_file_exit_sw bit(1)
  1   121 	 defined(sort_ext$output_file_exit_sw);
  1   122 dcl sort_ext$output_rec_deleted fixed bin(30) ext;	/*  number of records deleted at output_record exit  */
  1   123 dcl output_rec_deleted fixed bin(30)
  1   124 	 defined(sort_ext$output_rec_deleted);
  1   125 dcl sort_ext$output_rec_inserted fixed bin(30) ext;	/*  number of record inserted at output_record exit  */
  1   126 dcl output_rec_inserted fixed bin(30)
  1   127 	 defined(sort_ext$output_rec_inserted);
  1   128 dcl sort_ext$output_record_exit_sw fixed bin(1) ext;	/*  1 = user output_record exit specified  */
  1   129 dcl output_record_exit_sw fixed bin(1)
  1   130 	 defined(sort_ext$output_record_exit_sw);
  1   131 dcl sort_ext$presort_compares fixed bin(34) ext;		/*  number of compares in presort  */
  1   132 dcl presort_compares fixed bin(34)
  1   133 	 defined(sort_ext$presort_compares);
  1   134 dcl 1 sort_ext$pu(5) ext,
  1   135    2 x_n fixed bin,					/*  [init((5) 1)]  */
  1   136    2 x_rcpu fixed bin(71);
  1   137 dcl 1 pu(5)
  1   138 	 defined(sort_ext$pu),
  1   139    2 n fixed bin,
  1   140    2 rcpu fixed bin(71);
  1   141 dcl sort_ext$read_count fixed bin(30) ext;		/*  number of records read by Sort (or by Merge)  */
  1   142 dcl read_count fixed bin(30)
  1   143 	 defined (sort_ext$read_count);
  1   144 dcl sort_ext$rec_ptr_a ptr ext;			/*  buffer for output_record exit and sequence checker  */
  1   145 dcl rec_ptr_a ptr
  1   146 	 defined(sort_ext$rec_ptr_a);
  1   147 dcl sort_ext$rec_ptr_b ptr ext;			/*  buffer for output_record exit and sequence checker  */
  1   148 dcl rec_ptr_b ptr
  1   149 	 defined(sort_ext$rec_ptr_b);
  1   150 dcl sort_ext$release_count fixed bin(30) ext;		/*  number of records released to Sort (Merge)  */
  1   151 dcl release_count fixed bin(30)
  1   152 	 defined (sort_ext$release_count);
  1   153 dcl sort_ext$report_sw bit(2) ext;			/*  00 = print summary report, 01 = suppress  */
  1   154 dcl report_sw bit(2)
  1   155 	 defined (sort_ext$report_sw);
  1   156 dcl sort_ext$return_count fixed bin(30) ext;		/*  number of records returned from Sort (Merge)  */
  1   157 dcl return_count fixed bin(30)
  1   158 	 defined (sort_ext$return_count);
  1   159 dcl sort_ext$rev(0: 31) fixed bin(1) ext;		/*  keys - descending indicator for sort_comp  */
  1   160 dcl rev(0: 31) fixed bin(1)
  1   161 	 defined (sort_ext$rev);
  1   162 dcl sort_ext$sii fixed bin(30) ext;			/*  number of records, current string (sort_release)  */
  1   163 dcl sii fixed bin(30)
  1   164 	 defined (sort_ext$sii);
  1   165 dcl sort_ext$sip ptr ext;				/*  SI - tree of indices (subscripts) for records  */
  1   166 dcl sip ptr					/*       being sorted or merged  */
  1   167 	 defined (sort_ext$sip);
  1   168 dcl sort_ext$sort_compare_exit variable			/*  entry point, user compare exit procedure  */
  1   169 	 entry(ptr, ptr) returns(fixed bin(1)) ext;
  1   170 dcl sort_ext$sort_desc_pn  char(168) ext;		/*  pathname, Sort (Merge) Description segment  */
  1   171 dcl sort_desc_pn char(168)
  1   172 	 defined(sort_ext$sort_desc_pn);
  1   173 dcl sort_ext$sort_input_record_exit variable		/*  entry point, user input_record exit procedure  */
  1   174 	 entry(ptr, fixed bin(21), fixed bin, bit(1)) ext;
  1   175 dcl sort_input_record_exit variable
  1   176 	entry(ptr, fixed bin(21), fixed bin, bit(1))
  1   177 	 defined(sort_ext$sort_input_record_exit);
  1   178 dcl sort_ext$sort_output_record_exit variable		/*  entry point, user output_record exit procedure  */
  1   179 	entry(ptr, fixed bin(21), ptr, fixed bin(21), fixed bin, fixed bin(1), bit(1), bit(1), bit(1)) ext;
  1   180 dcl sort_output_record_exit variable
  1   181 	entry(ptr, fixed bin(21), ptr, fixed bin(21), fixed bin, fixed bin(1), bit(1), bit(1), bit(1))
  1   182 	defined(sort_ext$sort_output_record_exit);
  1   183 dcl sort_ext$srp ptr ext;				/*  SR - position and length of each record  */
  1   184 dcl srp ptr					/*       in SS string for presort  */
  1   185 	 defined (sort_ext$srp);
  1   186 dcl sort_ext$ssi fixed bin(30) ext;			/*  char offset in SS of current record (sort_release)  */
  1   187 dcl ssi fixed bin(30)
  1   188 	 defined (sort_ext$ssi);
  1   189 dcl sort_ext$ssp ptr ext;				/*  SS - unsorted string during presort  */
  1   190 dcl ssp ptr
  1   191 	 defined (sort_ext$ssp);
  1   192 dcl sort_ext$state fixed bin(17) ext;			/*  state variable controlling sequence of calls to  */
  1   193 dcl state fixed bin(17)				/*    the various stages of the Sort (Merge) [init(0)]  */
  1   194 	 defined (sort_ext$state);
  1   195 dcl sort_ext$terminate_print_sw bit(1) ext;		/*  0 = command prints (sort_merge_print_report)  */
  1   196 dcl terminate_print_sw bit(1)				/*  1 = subroutine prints (sort_merge_terminate)  */
  1   197 	 defined (sort_ext$terminate_print_sw);
  1   198 dcl 1 sort_ext$time_info(5) ext,			/*  used for -time information  */
  1   199    2 x_etime fixed bin(71),
  1   200    2 x_vtime fixed bin(71),
  1   201    2 x_pf fixed bin,
  1   202    2 x_pd_f fixed bin;
  1   203 dcl 1 time_info(5)
  1   204 	 defined(sort_ext$time_info),
  1   205    2 etime fixed bin(71),
  1   206    2 vtime fixed bin(71),
  1   207    2 pf fixed bin,
  1   208    2 pd_f fixed bin;
  1   209 dcl sort_ext$time_sw bit(1) ext;			/*  1 = -time argument specified  */
  1   210 dcl time_sw bit(1)
  1   211 	 defined(sort_ext$time_sw);
  1   212 dcl sort_ext$user_out_sw char(32) ext;			/*  I/O switch for summary report, diagnostics:  */
  1   213 dcl user_out_sw char(32)				/*       "user_output", "" = suppress, other = user switch  */
  1   214 	 defined(sort_ext$user_out_sw);
  1   215 dcl sort_ext$unique_prefix char(16) ext;		/*  unique to each invocation, for temporary names  */
  1   216 dcl unique_prefix char(16)
  1   217 	 defined (sort_ext$unique_prefix); /* -4- */ 
  1   218 dcl sort_ext$w(0: 31) fixed bin(30) ext;		/*  keys - word (sometimes char) offset for sort_comp  */
  1   219 dcl w(0: 31) fixed bin(30)
  1   220 	 defined (sort_ext$w);
  1   221 dcl sort_ext$wf_dir_name char(168) aligned ext;		/*  -td directory pathname argument  */
  1   222 dcl wf_dir_name char(168) aligned
  1   223 	 defined(sort_ext$wf_dir_name);
  1   224 dcl sort_ext$wf_full_name char(168) ext;		/*  absolute -td directory pathname  */
  1   225 dcl wf_full_name char(168)
  1   226 	 defined (sort_ext$wf_full_name); /* -42- */ 
  1   227 dcl sort_ext$whoami char(6) ext;			/*  "sort", "merge", "sort_", "merge_" called  */
  1   228 dcl whoami char(6)
  1   229 	 defined (sort_ext$whoami); /* -2- */ 
  1   230 dcl sort_ext$write_count fixed bin(30) ext;		/*  number of records written by Sort (Merge)  */
  1   231 dcl write_count fixed bin(30)
  1   232 	 defined (sort_ext$write_count);
       37 
       38 
       39 dcl  sys_info$max_seg_size fixed bin(35) external static;
       40 dcl (error_table_$no_stmt_delim,
       41      error_table_$unbalanced_quotes) fixed bin(35) external static;
       42 
       43 /*   INTERNAL STATIC  (must be constants only)     */
       44 dcl  nl char(1) internal static init("
       45 ");
       46 dcl  tb char(1) internal static init("	");		/*   tab   */
       47 
       48 dcl (quote_open char(1) init(""""),
       49      quote_close char(1) init(""""),
       50      comment_open char(2) init("/*"),
       51      comment_close char(2) init("*/"),
       52      statement_delim char(1) init(";"),
       53      s_init bit(2) init("10"b)	/*   suppress quoting delims, return statement delims   */
       54      ) internal static;
       55 dcl (l_ignored_input fixed bin(21) init(0),
       56      s_lex bit(3) init("100"b)	/*   yes statement descriptors,
       57*				     no  comment descriptors,
       58*				     no  retain doubled quote_closes    */
       59      ) internal static;
       60 
       61 /*   The following 4 declarations are synchronized with each other;
       62*     if one is modified then the others must be modified consistently.   */
       63 dcl keywords(22) char(16) internal static init(
       64 	"keys", "key",
       65 	"exits", "exit",
       66 	"char", "character",
       67 	"bit",
       68 	"bin", "binary",
       69 	"fixed",
       70 	"dec", "decimal",
       71 	"float",
       72 	"flbin",
       73 	"fldec",
       74 	"dsc", "descending",
       75 	"input_file",
       76 	"output_file",
       77 	"compare",		/*   Currently element 20   */
       78 	"input_record",
       79 	"output_record" );
       80 
       81 /*    exit_words must be defined on the element of keywords which contains the exit name "compare".   */
       82 dcl exit_words(keyword_codes.compare : exit_max) char(16) defined(keywords(20));
       83 
       84 dcl 1 keyword_codes internal static,
       85       2 (
       86 	keys(2) init((2)1),
       87 	exits(2) init((2)2),
       88 	char(2) init((2)100),
       89 	bit     init(101),
       90 	bina(2)     init((2)102),
       91 	fixed   init(103),
       92 	decim(2)     init((2)104),
       93 	float   init(105),
       94 	flbin   init(106),
       95 	fldec   init(107),
       96 	dsc(2)      init((2)200),
       97 	input_file   init(300),
       98 	output_file  init(301),
       99 	compare init(302),
      100 	input_record init(303),
      101 	output_record init(304) ) fixed bin(17);
      102 
      103 dcl  codes_array(22) fixed bin(17) based(addr(keyword_codes));
      104 
      105 dcl (st_min init(1),
      106      st_max init(3),
      107      dt_min init(100),
      108      dt_max init(107),
      109      exit_min init(300),
      110      exit_max init(304) ) fixed bin(17) internal static;
      111 
      112 /*   The following 3 declarations are synchronized with each other;
      113*     if one is modified then all must be modifed consistently.   */
      114 dcl  internal_datatypes(0:10) char(8) internal static init(
      115 	"illegal",
      116 	"char",
      117 	"bit",
      118 	(2)(1)"bin",
      119 	(2)(1)"flbin",
      120 	(2)(1)"dec",
      121 	(2)(1)"fldec");
      122 
      123 dcl  legal_datatype_bits(0:10) bit(8) init(	/*   Change to internal static when
      124*					     compiler correctly initializes last element.   */
      125 	"00000000"b,
      126 	"10000000"b,
      127 	"01000000"b,
      128 	"00100000"b, "00110000"b,
      129 	"00100100"b, "00000010"b,
      130 	"00001000"b, "00011000"b,
      131 	"00001100"b, "00000001"b);
      132 
      133 dcl (on init("1"b),
      134      off init("0"b) ) bit(1) internal static;
      135 
      136 /*   PARAMETERS, AUTOMATIC, AND BASED   */
      137 
  2     1 	/*  START OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
  2     2 	
  2     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     4 	/*							*/
  2     5 	/* Name:  lex_descriptors_.incl.pl1				*/
  2     6 	/*							*/
  2     7 	/*      This include segment defines the structure of the token	*/
  2     8 	/* descriptor, statement descriptor, and comment descriptor created	*/
  2     9 	/* by the lex_string_ program.				*/
  2    10 	/*							*/
  2    11 	/* Status:						*/
  2    12 	/*							*/
  2    13 	/* 0) Created:  Dec, 1973 by G. C. Dixon			*/
  2    14 	/*							*/
  2    15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2    16 	
  2    17 	
  2    18 	
  2    19 	
  2    20      dcl	
  2    21 	1 comment			aligned based (Pcomment),
  2    22 						/* descriptor for a comment.			*/
  2    23 	  2 group1		unaligned,
  2    24 	    3 version		fixed bin(17),	/* comment descriptor version.		*/
  2    25 	    3 size		fixed bin(17),	/* comment descriptor size (in words).		*/
  2    26 	  2 Pnext			ptr unal,		/* ptr to next comment descriptor.		*/
  2    27 	  2 Plast			ptr unal,		/* ptr to last comment descriptor.		*/
  2    28 	  2 Pvalue		ptr unal,		/* ptr to comment.				*/
  2    29 	  2 Lvalue		fixed bin(18),	/* length of comment.			*/
  2    30 	  2 group2		unaligned,
  2    31 	    3 line_no		fixed bin(17),	/* line no of line containing comment.		*/
  2    32 	    3 S,					/* switches:				*/
  2    33 	      4 before_stmt		bit(1),		/* comment is before 1st token of stmt.		*/
  2    34 	      4 contiguous		bit(1),		/* no tokens between this and last comment.	*/
  2    35 	      4 pad		bit(16),
  2    36 	comment_value		char(comment.Lvalue) based (comment.Pvalue),
  2    37 						/* body of comment.				*/
  2    38 	Pcomment			ptr;		/* ptr to comment descriptor.			*/
  2    39 	
  2    40      dcl	
  2    41 	1 stmt			aligned based (Pstmt),
  2    42 						/* descriptor for a statement.		*/
  2    43 	  2 group1		unaligned,
  2    44 	    3 version		fixed bin(17),	/* statement descriptor version.		*/
  2    45 	    3 size		fixed bin(17),	/* statement descriptor size (in words).	*/
  2    46 	  2 Pnext			ptr unal,		/* ptr to next statement descriptor.		*/
  2    47 	  2 Plast			ptr unal,		/* ptr to last statement descriptor.		*/
  2    48 	  2 Pvalue		ptr unal,		/* ptr to statement.			*/
  2    49 	  2 Lvalue		fixed bin(18),	/* length of statement.			*/
  2    50 	  2 Pfirst_token		ptr unal,		/* ptr to 1st token of statement.		*/
  2    51 	  2 Plast_token		ptr unal,		/* ptr to last token of statement.		*/
  2    52 	  2 Pcomments		ptr unal,		/* ptr to comments in statement.		*/
  2    53 	  2 Puser			ptr unal,		/* user-defined ptr.			*/
  2    54 	  2 group2		unaligned,
  2    55 	    3 Ntokens		fixed bin(17),	/* number of tokens in statement.		*/
  2    56 	    3 line_no		fixed bin(17),	/* line no of line on which statement begins.	*/
  2    57 	    3 Istmt_in_line		fixed bin(17),	/* number of stmts in line containing this stmt.	*/
  2    58 						/* (the number includes this stmt.)		*/
  2    59 	    3 semant_type		fixed bin(17),	/* semantic type of the statement.		*/
  2    60 	    3 S,					/* switches:				*/
  2    61 	      4 error_in_stmt	bit(1),		/* stmt contains a syntactic error.		*/
  2    62 	      4 output_in_err_msg	bit(1),		/* stmt has been output in previous error message.*/
  2    63 	      4 pad		bit(34),
  2    64 	stmt_value		char(stmt.Lvalue) based (stmt.Pvalue),
  2    65 						/* text of the statement.			*/
  2    66 	Pstmt			ptr;		/* ptr to a stmt descriptor. 			*/
  2    67 	
  2    68      dcl	
  2    69 	1 token			aligned based (Ptoken),
  2    70 						/* descriptor for a token.			*/
  2    71 	  2 group1		unaligned,
  2    72 	    3 version		fixed bin(17),	/* token descriptor version.			*/
  2    73 	    3 size		fixed bin(17),	/* token descriptor size (in words).		*/
  2    74 	  2 Pnext			ptr unal,		/* ptr to next token descriptor.		*/
  2    75 	  2 Plast			ptr unal,		/* ptr to last token descriptor.		*/
  2    76 	  2 Pvalue		ptr unal,		/* ptr to token.				*/
  2    77 	  2 Lvalue		fixed bin(18),	/* length of token.				*/
  2    78 	  2 Pstmt			ptr unal,		/* ptr to descriptor of stmt containing token.	*/
  2    79 	  2 Psemant		ptr unal,		/* ptr to descriptor(s) of token's semantic value.*/
  2    80 	  2 group2		unaligned,
  2    81 	    3 Itoken_in_stmt	fixed bin(17),	/* position of token within its statement.	*/
  2    82 	    3 line_no		fixed bin(17),	/* line number of the line containing the token.	*/
  2    83 	    3 Nvalue		fixed bin(35),	/* numeric value of decimal-integer tokens.	*/
  2    84 	    3 S,					/* switches:				*/
  2    85 	      4 end_of_stmt		bit(1),		/* token is an end-of-stmt token.		*/
  2    86 	      4 quoted_string	bit(1),		/* token is a quoted string.			*/
  2    87 	      4 quotes_in_string	bit(1),		/* on if quote-close delimiters appear in quoted	*/
  2    88 						/* string (as doubled quotes on input.)		*/
  2    89 	      4 quotes_doubled	bit(1),		/* on if quotes in the string are doubled after	*/
  2    90 						/* string has been lexed into a token.		*/
  2    91 	      4 pad2		bit(32),
  2    92 	token_value		char(token.Lvalue) based (token.Pvalue),
  2    93 						/* value of the token.			*/
  2    94 	Ptoken			ptr;		/* ptr to a token descriptor.			*/
  2    95 
  2    96 	/*  END OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
      138 
      139 
      140 dcl (ignored_break_chars char(4) varying aligned,	/*   , space tab newline   */
      141      break_chars char(8) varying aligned,	/*   , space tab newline : ; ( )   */
      142      lex_delims char(128) varying aligned,
      143      lex_control_chars char(128) varying aligned,
      144      p_input ptr,
      145      l_input fixed bin(21),
      146      p_first_statement_desc ptr,
      147      p_first_token_desc ptr,
      148      lex_code fixed bin(35) );
      149 
      150 dcl  len_max(0:10) fixed bin(24) init(
      151 	4095,   /*  illegal  */
      152 	4095,   /*  char  */	/*   set dynamically; see references to word_offset_max   */
      153 	4095,   /*  bit   */	/*   set dynamically; see references to word_offset_max   */
      154 	  71,   /*  fxbin  */
      155 	  71,   /*  fxbin  */
      156 	  63,   /*  flbin  */
      157 	  63,   /*  flbin  */
      158 	  59,   /*  fxdec  */
      159 	  59,   /*  fxdec  */
      160 	  59,   /*  fldec  */
      161 	  59    /*  fldec  */
      162        );
      163 
      164 dcl statement_counts(st_min: st_max) fixed bin(17);
      165 dcl  datatype_bits bit(dt_max - dt_min + 1),
      166      legal_datatype_index fixed bin(17);
      167 
      168 dcl  exit_count_array(exit_min: exit_max) fixed bin(17);
      169 dcl  user_name_array(exit_min: exit_max) char(168);
      170 
      171 dcl  exit_pairs_count fixed bin(17);
      172 
  3     1 /* BEGIN INCLUDE FILE ... sort_merge_pars.incl.pl1 */
  3     2 
  3     3 /*	input_file_max = maximum number of input files for sort-merge */
  3     4 
  3     5 
  3     6 	dcl 1 attach_array(0:10 /*input_file_max*/),
  3     7 	    2 count fixed bin(17),
  3     8 	    2 desc char(168);
  3     9 
  3    10 	dcl input_file(10 /*input_file_max*/) char(256);
  3    11 
  3    12 /* END INCLUDE FILE ... sort_merge_pars.incl.pl1 */
      173 
      174 
      175 
      176 
      177 /*   For deleted attach statement:
      178*dcl 1 attach_array_init internal static,
      179*      2 count fixed bin(17) init(0),
      180*      2 desc char(168) init("");
      181*
      182*dcl error fixed bin(35);
      183*dcl  curr_switchname char(8);
      184*dcl  curr_attach_index fixed bin(17);
      185*dcl  curr_attach_len fixed bin(17);
      186*dcl  in_attach_max fixed bin(17);		*/
      187 
      188 dcl (source_parameters ptr,
      189      internal_parameters ptr,
      190      p_area ptr,
      191      keys_ptr	ptr,
      192      io_exits_ptr	ptr,
      193      exits_ptr	ptr,
      194 /*     attaches_ptr   ptr,   */
      195      bit_count fixed bin(24),
      196      seg_length fixed bin(24),
      197      convert_int_code fixed bin(35) ) parameter;
      198 dcl  atom_ptr ptr,
      199      atom_len fixed bin;
      200 
      201 dcl  atom char(atom_len) based(atom_ptr);
      202 dcl  cv_err fixed bin(35);
      203 dcl  integer fixed bin(35);
      204 dcl  atom_code fixed bin(17);
      205 
  4     1 /*   Sort Description, internal format.   	*/
  4     2 
  4     3 dcl 1 keys  based(work_ptr),
  4     4       2 version fixed bin init(1),
  4     5       2 number fixed bin,
  4     6       2 key_desc(0 refer(keys.number)),
  4     7         3 datatype char(8),
  4     8         3 len fixed bin(24),
  4     9         3 word_offset fixed bin(18),
  4    10         3 bit_offset fixed bin(6),
  4    11         3 rv     char(3),
  4    12       2 dummy fixed bin(71);
  4    13 
  4    14 dcl 1 io_exits  based(work_ptr),
  4    15       2 version fixed bin init(1),
  4    16       2 input_file_exit entry,
  4    17       2 output_file_exit entry,
  4    18       2 dummy fixed bin(71);
  4    19 
  4    20 dcl 1 exits  based(work_ptr),
  4    21       2 version fixed bin init(1),
  4    22       2 compare_exit entry,
  4    23       2 input_record_exit entry,
  4    24       2 output_record_exit entry,
  4    25       2 dummy fixed bin(71);
  4    26 
      206 
      207 
      208 dcl 1 dummy_exits based(work_ptr),
      209       2 version fixed bin,
      210       2 exits_array(keyword_codes.compare : exit_max) entry,
      211       2 dummy fixed bin(71);
      212 
      213 dcl  exit_code fixed bin(17);
      214 dcl  work_ptr ptr;
      215 dcl  word_offset_max fixed bin(30);
      216 
      217 dcl  shortinfo char(8) aligned,
      218      longinfo char(100) aligned;
      219 
      220 /*   Start.   */
      221      convert_int_code = 0;
      222      word_offset_max = sys_info$max_seg_size - 100;
      223      /*   The literal subscripts below must be monitored if len_max is changed.   */
      224      len_max(1) = word_offset_max * 4;		/*   for char strings  */		
      225      len_max(2) = word_offset_max * 36;		/*   for bit strings   */
      226      work_ptr = internal_parameters;
      227      ignored_break_chars = ", "||tb||nl;
      228      break_chars = ", :;()"||tb||nl;
      229      call lex_string_$init_lex_delims(quote_open, quote_close, comment_open, comment_close,
      230 		statement_delim, s_init, break_chars, ignored_break_chars,
      231 		lex_delims, lex_control_chars);
      232      p_input = source_parameters;
      233      l_input = bin(bit_count, 35)/9;
      234      call lex_string_$lex(p_input, l_input, l_ignored_input, p_area, s_lex,
      235 		quote_open, quote_close, comment_open, comment_close,
      236 		statement_delim, break_chars, ignored_break_chars,
      237 		lex_delims, lex_control_chars,
      238 		p_first_statement_desc, p_first_token_desc, lex_code);
      239      /*   If no tokens, then p_first_token_desc = null().   */
      240      if lex_code ^= 0 then do;
      241 	if lex_code = error_table_$unbalanced_quotes | lex_code = error_table_$no_stmt_delim then do;
      242 	     convert_int_code = 1;
      243 	     call convert_status_code_(lex_code, shortinfo, longinfo);
      244 	     if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw,
      245 		"^a:  ^a  ^a Description pathname ^a", whoami, longinfo, caps(whoami), sort_desc_pn);
      246 	     end;
      247 	end;
      248      Ptoken = p_first_token_desc;
      249      call syntax;			/*   Process source form of S.D.   */
      250 exit:     return;     /*  to sort_ or merge_   */
      251 
      252 convert_datatype:  entry(keys_ptr_par, current_key, typecode);
      253 dcl (keys_ptr_par ptr,
      254      current_key fixed bin(17),
      255      typecode fixed bin(17) ) parameter;
      256 dcl  j fixed bin(17);
      257      typecode = 0;
      258      work_ptr = keys_ptr_par;
      259      do j = 0 to hbound(internal_datatypes, 1);
      260 	if keys.datatype(current_key) = internal_datatypes(j) then do;
      261 	     typecode = j;
      262 	     return;
      263  	     end;
      264 	end;   /*   of do   */
      265      return;
      266 
      267 /*   The implementation of the state diagram
      268*     for the source form of the Sort/Merge Description follows
      269*     (consult the PLM for further information).   */
      270 
      271 syntax:  proc;
      272 enter_state:
      273      call enter_action;
      274 new_statement_state:
      275      call scan;
      276      if atom_code = keyword_codes.keys(1) then go to keys_state;
      277      if atom_code = keyword_codes.exits(1) then go to exits_state;
      278 /*     if atom_code = keyword_codes.attach then go to attach_state;  */
      279      if atom = ";" then go to new_statement_state;
      280      else go to err_1_state;
      281 keys_state:
      282      call keys_action;
      283      call scan;     
      284      if atom = ":" then call scan;
      285      go to expect_dtw_state;
      286 expect_dtw_state:  /*  expect data type word   */
      287      if atom_code >= dt_min & atom_code <= dt_max then go to dtw_state;
      288      if atom = ";" then go to end_of_statement_state;
      289      else go to err_6_state;
      290 datatype_word_state:  dtw_state:
      291      call datatype_word_action;
      292      call scan;
      293      if atom_code >= dt_min & atom_code <= dt_max then go to datatype_word_state;
      294      else go to datatype_state;
      295 datatype_state:  dt_state:
      296      call datatype_action;
      297      if atom = "(" then go to left_par_size_state;
      298      else go to err_8_state;
      299 left_par_size_state:
      300      call scan;
      301      integer = cv_dec_check_(atom, cv_err);
      302      if cv_err = 0 then go to size_state;
      303      if atom = ")" then go to right_par_size_state;
      304      else go to err_9_state;
      305 size_state:
      306      call size_action;
      307      call scan;
      308      if atom = ")" then go to right_par_size_state;
      309      else go to err_10_state;
      310 right_par_size_state:
      311      call scan;
      312      integer = cv_dec_check_(atom, cv_err);
      313      if cv_err = 0 then go to w_state;
      314      else go to err_11_state;
      315 w_state:
      316      call w_action;
      317      call scan;
      318      if atom = "(" then go to left_par_off_state;
      319      call no_bit_offset_action;	/*   No (, therefore aligned   */
      320      if atom_code = dsc(1) then go to rv_state;
      321      go to expect_dtw_state;
      322 left_par_off_state:
      323      call scan;
      324      integer = cv_dec_check_(atom, cv_err);
      325      if cv_err = 0 then go to b_state;
      326      if atom = ")" then go to right_par_off_state;
      327      else go to err_13_state;
      328 b_state:
      329      call b_action;
      330      call scan;
      331      if atom = ")" then go to right_par_off_state;
      332      else go to err_14_state;
      333 right_par_off_state:
      334      call scan;
      335      if atom_code = dsc(1) then go to rv_state;
      336      go to expect_dtw_state;
      337 rv_state:
      338      call rv_action;
      339      call scan;
      340      go to expect_dtw_state;
      341 exits_state:
      342      call exits_action;
      343      call scan;
      344      if atom = ":" then call scan;
      345      go to expect_exit_name_state;
      346 expect_exit_name_state:
      347      if atom_code >= exit_min & atom_code <= exit_max then go to exit_name_state;
      348      if atom = ";" then go to end_of_statement_state;
      349      else go to err_4_state;
      350 exit_name_state:
      351      call exit_name_action;
      352      call scan;
      353      if atom ^= ";" then go to user_name_state;
      354      else go to err_5_state;
      355 user_name_state:
      356      call user_name_action;
      357      call scan;
      358      go to expect_exit_name_state;
      359 /*  attach_state:
      360*     call attach_action;
      361*     call scan;
      362*     if atom = ":" then call scan;
      363*     if atom = ";" then go to err_15_state;
      364*     go to switchname_state;
      365*switchname_state:
      366*     call switchname_action(error);
      367*     if error ^= 0 then go to scan_statement_state;
      368*     call scan;
      369*     if atom = ";" then go to err_16_state;
      370*     go to module_name_state;
      371*module_name_state:
      372*     call modulename_action(error);
      373*     if error ^= 0 then go to scan_statement_state;
      374*     call scan;
      375*     if atom = ";" then go to end_of_statement_state;
      376*     go to attach_desc_word_state;
      377*attach_desc_word_state:
      378*     call attach_desc_word_action(error);
      379*     if error ^= 0 then go to scan_statement_state;
      380*     call scan;
      381*     if atom = ";" then go to end_of_statement_state;
      382*     go to attach_desc_word_state;  */
      383 end_of_statement_state:
      384 /*   Do not scan.   */
      385      go to new_statement_state;
      386 end_file_state:
      387      call end_file_action;
      388      return;     /*  from syntax proc   */
      389 
      390 err_1_state:
      391      convert_int_code = 1;
      392      if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw,
      393 		"^a:  Unrecognized statement keyword ""^a"".  Rest of statement ignored.",
      394 		whoami, atom);
      395      go to scan_statement_state;
      396 err_4_state:
      397      convert_int_code = 1;
      398      if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw, 
      399 		"^a:  Unrecognized exit name ""^a"" for presumed ^d"||
      400 		ordinal(exit_pairs_count + 1)||" exit description.  Word ignored.",
      401 		whoami, atom, exit_pairs_count + 1);
      402      call scan;
      403      go to expect_exit_name_state;
      404 err_5_state:
      405      convert_int_code = 1;
      406      if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw, 
      407 		"^a:  Missing user exit procedure name for ^d"||
      408 		ordinal(exit_pairs_count)||" exit description.", whoami, exit_pairs_count);
      409      call user_name_action;
      410      go to end_of_statement_state;
      411 err_6_state:
      412      convert_int_code = 1;
      413      if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw, 
      414 		"^a:  Unrecognized data type ""^a"" for presumed key ^d.",
      415 		whoami, atom, keys.number + 1);
      416      go to scan_key_state;
      417 err_8_state:
      418      convert_int_code = 1;
      419      if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw,
      420 	"^a:  Invalid word ""^a"" following data type for key ^d.  Should be ( for (length) or (precision).",
      421 		whoami, atom, keys.number);
      422      go to scan_key_state;
      423 err_9_state:
      424      convert_int_code = 1;
      425      if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw, 
      426 		"^a:  Invalid length or precision ""^a"" for key ^d.",
      427 		whoami, atom, keys.number);
      428      go to scan_key_state;
      429 err_10_state:
      430      convert_int_code = 1;
      431    if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw,
      432 		"^a:  Invalid word ""^a"" following length or precision for key ^d.  Should be ).",
      433 		whoami, atom, keys.number);
      434      go to scan_key_state;
      435 err_11_state:
      436      convert_int_code = 1;
      437      if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw,
      438 		"^a:  Invalid word ""^a"" following length or precision for key ^d.  Should be word offset.",
      439 		 whoami, atom, keys.number);
      440      go to scan_key_state;
      441 err_13_state:
      442      convert_int_code = 1;
      443      if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw, 
      444 		"^a:  Invalid bit offset ""^a"" for key ^d.",
      445 		whoami, atom, keys.number);
      446      go to scan_key_state;
      447 err_14_state:
      448      convert_int_code = 1;
      449      if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw, 
      450 		"^a:  Invalid word ""^a"" following bit offset for key ^d.  Should be ).",
      451 		 whoami, atom, keys.number);
      452      go to scan_key_state;
      453 /*  err_15_state:
      454*     convert_int_code = 1;
      455*     if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw, 
      456*		"^a:  Attach statement ^d is empty.",
      457*		whoami, statement_counts(keyword_codes.attach));
      458*     go to scan_statement_state;
      459*err_16_state:
      460*     convert_int_code = 1;
      461*     if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw, 
      462*		"^a:  Attach statement ^d has no I/O module name.  Rest of statement ignored.",
      463*		whoami, statement_counts(keyword_codes.attach));
      464*     go to scan_statement_state;  */
      465 scan_statement_state:
      466      if atom = ";" then go to end_of_statement_state;
      467      call scan;
      468      go to scan_statement_state;
      469 scan_key_state:
      470      if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw, 
      471 		"^vxWill resume processing with next valid data type word.",
      472 		length(before(whoami, " ")) + 3);
      473 scan_key_loop:
      474      if atom = ";" then go to end_of_statement_state;
      475      call scan;
      476      if atom_code >= dt_min & atom_code <= dt_max then go to dtw_state;
      477      else go to scan_key_loop;
      478 
      479 
      480 scan:  proc;				/*   Get next atom:   */
      481      if Ptoken = null() then go to end_file_state;	/*   End of S.D.   */
      482      atom_code = 0;
      483      atom_len = token.Lvalue;
      484      atom_ptr = token.Pvalue;
      485      call look_up_keyword;		/*   Get code corresponding to "atom".   */
      486      Ptoken = token.Pnext;
      487 end scan;
      488 
      489 
      490 end syntax;
      491 
      492 
      493 look_up_keyword:  proc;
      494 dcl  index fixed bin(17);
      495 
      496      do index = lbound(keywords, 1) to hbound(keywords, 1);
      497 	if atom = keywords(index) then
      498 	     do;
      499 	     atom_code = codes_array(index);
      500 	     go to end_lookup;
      501 	     end;
      502      end;
      503 end_lookup:
      504 end look_up_keyword;
      505 
      506 
      507 enter_action:  proc;			/*   Initialize variables.   */
      508      statement_counts = 0;
      509      exit_count_array = 0;
      510      exit_pairs_count = 0;
      511      keys_ptr,
      512      io_exits_ptr,
      513      exits_ptr = null();
      514 /*     attaches_ptr = null();
      515*     attach_array = attach_array_init;
      516*     in_attach_max = 0;  */
      517 end enter_action;
      518 
      519 
      520 keys_action:  proc;
      521      datatype_bits = "0"b;
      522      keys.version = 1;
      523      statement_counts(atom_code) = statement_counts(atom_code) + 1;
      524      keys.number = 0;
      525 end keys_action;
      526 
      527 
      528 datatype_word_action:  proc;
      529      substr(datatype_bits, atom_code - dt_min + 1, 1) = "1"b;
      530 end datatype_word_action;
      531 
      532 datatype_action:  proc;
      533 dcl  i fixed bin(17);
      534      keys.number = keys.number + 1;		/*   Add 1 to number of keys in keys substructure.   */
      535      legal_datatype_index = 0;
      536      do i = 1 to hbound(legal_datatype_bits, 1);	/*   Check for valid combination of data type words.   */
      537 	if datatype_bits = legal_datatype_bits(i) then legal_datatype_index = i;
      538 					/*   Hold index indicating data type.   */
      539 	end;
      540      keys.datatype(keys.number) = internal_datatypes(legal_datatype_index);
      541 					/*   Set data type for current key.   */
      542      keys.word_offset(keys.number) = 0;
      543      keys.bit_offset(keys.number) = 0;		/*   Set default for bit offset to 0.   */
      544      keys.rv(keys.number) = "";		/*   Set default for "descending" to off.   */
      545      if legal_datatype_index = 0 then
      546 	call datatype_err_action;
      547      datatype_bits = "0"b;
      548 end datatype_action;
      549 
      550 
      551 datatype_err_action:  proc;
      552      convert_int_code = 1;
      553      if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw, 
      554 		"^a:  Inconsistent datatype attributes for key ^d.",
      555 		whoami, keys.number);
      556 end datatype_err_action;
      557 
      558 
      559 w_action:  proc;
      560      if integer >= word_offset_max then
      561 	do;
      562 	convert_int_code = 1;
      563 	if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw, 
      564 		"^a:  Word offset of ^a too large for key ^d.",
      565 		whoami, atom, keys.number);
      566 	end;
      567      keys.word_offset(keys.number) = integer;	/*   Set word offset for current key.   */
      568 end w_action;
      569 
      570 
      571 no_bit_offset_action:  proc;
      572      /*   Adjust precision of aligned binary if appropriate.   */
      573      if keys.len(keys.number) < 0 then return;
      574      if keys.datatype(keys.number) = "bin" then do;
      575 	if keys.len(keys.number) <= 35 then keys.len(keys.number) = 35;
      576 	else if keys.len(keys.number) <= 71 & mod(keys.word_offset(keys.number), 2) = 0
      577 		then keys.len(keys.number) = 71;
      578 	end;
      579      else if keys.datatype(keys.number)   = "flbin" then do;
      580 	if keys.len(keys.number) <= 27 then keys.len(keys.number) = 27;
      581 	else if keys.len(keys.number) <= 63 & mod(keys.word_offset(keys.number), 2) = 0
      582 		then keys.len(keys.number) = 63;
      583 	end;
      584 end no_bit_offset_action;
      585 
      586 
      587 b_action:  proc;
      588      if integer > 35 then
      589 	do;
      590 	if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw, 
      591 		"^a:  Bit offset of ^a too large for key ^d.",
      592 		whoami, atom, keys.number);
      593 	convert_int_code = 1;
      594 	end;
      595      keys.bit_offset(keys.number) = integer;	/*   Set bit offset for current key.   */
      596 end b_action;
      597 
      598 
      599 size_action:  proc;
      600 dcl  temp fixed bin(24);
      601      if integer > len_max(legal_datatype_index) then
      602 	do;
      603 	convert_int_code = 1;
      604 	temp = len_max(legal_datatype_index);
      605 	if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw,
      606 		"^a:  Length ^a too large for ^a data type of key ^d.  Must not be greater than ^d.",
      607 		whoami, atom, keys.datatype(keys.number), keys.number, temp);
      608 	end;
      609      keys.len(keys.number) = integer;		/*   Set "size" for current key.   */
      610 end size_action;
      611 
      612 
      613 rv_action:  proc;
      614      keys.rv(keys.number) = "dsc";		/*   Srt rv for current key in keys structure.   */
      615 end rv_action;
      616 
      617 
      618 exits_action:  proc;
      619      statement_counts(atom_code) = statement_counts(atom_code) + 1;
      620 end exits_action;
      621 
      622 
      623 exit_name_action:  proc;
      624      exit_pairs_count = exit_pairs_count + 1;
      625      exit_code = atom_code;		/*   Hold exit code.   */
      626 end exit_name_action;
      627 
      628 
      629 user_name_action:  proc;
      630      exit_count_array(exit_code) = exit_count_array(exit_code) + 1;	/*   Increment count for proper exit name.   */
      631      user_name_array(exit_code) = atom;		/*   Get user name.   */
      632 end user_name_action;
      633 
      634 
      635   /*  attach_action:  proc;
      636*     statement_counts(atom_code) = statement_counts(atom_code) + 1;
      637*end attach_action;
      638*
      639*
      640*switchname_action:  proc(error);
      641*dcl  error fixed bin(35) parameter;
      642*     error = 0;
      643*     curr_switchname = atom;
      644*     if substr(atom, 1, 3) = "in_" then do;
      645*	curr_attach_index = cv_dec_check_(substr(atom, 4), error);
      646*	if error ^= 0 | curr_attach_index < 1 | curr_attach_index > input_file_max then do;
      647*	     convert_int_code = 1;
      648*	     error = 1;
      649*	     if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw,
      650*			"^a:  Invalid input file switchname ^a  Rest of statement ignored.",
      651*			whoami, curr_switchname);
      652*	     return;
      653*	     end;
      654*	else in_attach_max = max(in_attach_max, curr_attach_index);
      655*	end;
      656*     else if atom = "out_1" then curr_attach_index = 0;
      657*     else do;
      658*	error = 1;
      659*	convert_int_code = 1;
      660*	if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw, 
      661*		"^a:  Invalid switchname ^a  Rest of statement ignored.",
      662*			whoami, curr_switchname);
      663*	return;
      664*	end;
      665*     attach_array.count(curr_attach_index) = attach_array.count(curr_attach_index) + 1;
      666*end switchname_action;
      667*
      668*
      669*modulename_action:  proc(error);
      670*dcl  error fixed bin(35) parameter;
      671*     error = 0;
      672*     curr_attach_len = atom_len + 1;
      673*     if curr_attach_len > length(attach_array.desc(0)) then do;
      674*	error = 1;
      675*	convert_int_code = 1;
      676*	if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw,
      677*		"^a:  I/O module name for switchname ^a longer than ^d characters.  Rest of statement ignored.",
      678*		whoami, curr_switchname, length(attach_array.desc(0)));
      679*	end;
      680*     else substr(attach_array.desc(curr_attach_index), 1) = atom ||" ";
      681*end modulename_action;
      682*
      683*
      684*attach_desc_word_action:  proc(error);
      685*dcl  error fixed bin(35) parameter;
      686*     error = 0;
      687*     if curr_attach_len + atom_len > length(attach_array.desc(0)) then do;
      688*	error = 1;
      689*	convert_int_code = 1;
      690*	if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw,
      691*	     "^a:  Attach description for switchname ^a longer than ^d characters.  Rest of statement ignored.",
      692*	     whoami, curr_switchname, length(attach_array.desc(0)));
      693*	return;
      694*	end;
      695*     substr(attach_array.desc(curr_attach_index), curr_attach_len + 1) = atom||" ";
      696*     curr_attach_len = curr_attach_len + atom_len + 1;
      697*end attach_desc_word_action;  */
      698 
      699 
      700 
      701 
      702 end_file_action:  proc;			/*   End of source S.D. encountered;
      703*	Construct structures in order, and set keys_ptr, io_exits_ptr, and exits_ptr.   */
      704      call construct_keys;
      705      call construct_io_exits;
      706      call construct_exits;
      707 /*     call construct_attaches;   */
      708      call construct_end;
      709 end end_file_action;
      710 
      711 
      712 construct_keys:  proc;			/*   Complete keys substructure:   */
      713      if statement_counts(keyword_codes.keys(1)) = 0 | keys.number = 0 then return;
      714      if statement_counts(keyword_codes.keys(1)) > 1 then
      715 	do;
      716 	if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw,
      717 		"^a:  Keys statement specified ^d times.",
      718 		whoami, statement_counts(keyword_codes.keys(1)));
      719 	convert_int_code = 1;
      720 	end;
      721      keys_ptr = work_ptr;
      722      work_ptr = addr(keys.dummy);	/*   Move pointer.   */
      723 end construct_keys;
      724 
      725 
      726 construct_io_exits:  proc;			/*   Construct io_exits substructure:   */
      727      input_file_exit_sw,
      728      output_file_exit_sw = off;
      729      if statement_counts(keyword_codes.exits(1)) = 0 then return;	/*   Does not move pointer.   */
      730      if exit_count_array(keyword_codes.input_file) = 0 & exit_count_array(keyword_codes.output_file) = 0 then return;
      731 					/*   Does not move pointer.   */
      732      io_exits.version = 1;
      733      if exit_count_array(keyword_codes.input_file) > 1 then
      734 	do;
      735 	convert_int_code = 1;
      736 	if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw,
      737 		"^a:  Input_file exit specified ^d times.",
      738 		whoami, exit_count_array(keyword_codes.input_file));
      739 	end;
      740      if exit_count_array(keyword_codes.output_file) > 1 then
      741 	do;
      742 	convert_int_code = 1;
      743 	if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw,
      744 		"^a:  Output_file exit specified ^d times.",
      745 		whoami, exit_count_array(keyword_codes.output_file));
      746 	end;
      747      if exit_count_array(keyword_codes.input_file) > 0 then do;
      748 	/*   Construct entry variable for input_file exit.   */
      749 	input_file_exit_sw = on;
      750 	call construct_entry_variable(addr(io_exits.input_file_exit),
      751 		user_name_array(keyword_codes.input_file), "input_file");
      752 	end;
      753 /*1*/     else io_exits.input_file_exit = sort_$noexit;
      754      if exit_count_array(keyword_codes.output_file) > 0 then do;
      755 	/*   Construct entry variable for output_file exit.   */
      756 	output_file_exit_sw = on;
      757 	call construct_entry_variable(addr(io_exits.output_file_exit),
      758 		user_name_array(keyword_codes.output_file), "output_file");
      759 	end;
      760 /*1*/     else io_exits.output_file_exit = sort_$noexit;
      761      io_exits_ptr = work_ptr;
      762      work_ptr = addr(io_exits.dummy);		/*   move pointer.   */
      763 end construct_io_exits;
      764 
      765 
      766 construct_entry_variable:  proc(p, name, exit_name);
      767      /*   Construct entry variable for user exit procedure:   */
      768 dcl (p ptr,
      769      name char(*),
      770      exit_name char(*) ) parameter;
      771 dcl 1 entry_variable based(p),
      772       2 p1 ptr,
      773       2 p2 ptr;
      774 dcl  ev  entry based(p);
      775 
      776      call find_command_(addr(name), length(name), p1, find_command_code);	/*   Process like a command name.   */
      777      p2 = null();
      778      if find_command_code ^= 0 then
      779 	do;
      780 	convert_int_code = 1;
      781 	if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw,
      782 		"^vxInitializing entry variable for user-supplied ^a exit procedure.",
      783 		length(before(whoami, " ")) + 3, exit_name);
      784 /*1*/	ev = sort_$noexit;
      785 	end;
      786 end construct_entry_variable;
      787 
      788 
      789 construct_exits: proc;			/*   Construct exits substructure:   */
      790 dcl  index fixed bin(17),
      791      sum fixed bin(35);
      792      if statement_counts(keyword_codes.exits(1)) = 0 then return;   	/*   Do not move pointer.   */
      793      sum = 0;
      794      do index = keyword_codes.compare to exit_max;
      795 	sum = sum + exit_count_array(index);
      796 	end;
      797      if sum = 0 then return;		/*   Without moving pointer.   */
      798      exits.version = 1;
      799 /*   Test multiple occurrences & construct entry variable for each exit.     */
      800      do index = keyword_codes.compare to exit_max;
      801 	if exit_count_array(index) > 1 then do;
      802 	     convert_int_code = 1;
      803 	     if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw,
      804 		"^a:  ^a exit specified ^d times.",
      805 		whoami, exit_words(index), exit_count_array(index));
      806 	     end;
      807 	if exit_count_array(index) > 0 then do;
      808 	     call construct_entry_variable(addr(exits_array(index)), user_name_array(index), exit_words(index));
      809 	     end;
      810 /*1*/	else exits_array(index) = sort_$noexit;
      811 	end;   /*   of do index   */
      812      exits_ptr = work_ptr;
      813      work_ptr = addr(exits.dummy);		/*   Move pointer.   */
      814 end construct_exits;
      815 
      816 
      817 /*   construct_attaches:  proc;
      818*dcl  i fixed bin(17),
      819*     sum fixed bin(35);
      820*     if statement_counts(keyword_codes.attach) = 0 then return;
      821*     sum = 0;
      822*     do i = lbound(attach_array, 1) to hbound(attach_array, 1);
      823*	sum = sum + attach_array.count(i);
      824*	end;
      825*     if sum = 0 then return;
      826*     attaches.version = 1;
      827*     attaches.number = in_attach_max;
      828*     do i = 1 to in_attach_max;
      829*	if attach_array.count(i) > 1 then do;
      830*	     convert_int_code = 1;
      831*	     if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw,
      832*		"^a:  Attach statement for switchname in_^d specified ^d times.",
      833*		whoami, i, attach_array.count(i));
      834*	     end;
      835*	if attach_array.count(i) > 0 then attaches.in_desc(i) = attach_array.desc(i);
      836*	else attaches.in_desc(i) = "";
      837*	end;
      838*     if attach_array.count(0) > 1 then do;
      839*	convert_int_code = 1;
      840*	if user_out_sw ^= "" then call ioa_$ioa_stream(user_out_sw,
      841*		"^a:  Attach statement for switchname out_1 specified ^d times.",
      842*		whoami, attach_array.count(0));
      843*	end;
      844*     if attach_array.count(0) > 0 then attaches.out_desc = attach_array.desc(0);
      845*     else attaches.out_desc = "";
      846*     attaches_ptr = work_ptr;
      847*     work_ptr = addr(attaches.dummy);
      848*end construct_attaches;   */
      849 
      850 
      851 construct_end:  proc;
      852      seg_length = bin(rel(work_ptr), 24);
      853 end construct_end;
      854 
      855 
      856 ordinal:  proc(number) returns(char(2));	/*   Create an ordinal suffix (st, nd, rd, th, etc.):   */
      857 dcl  number fixed bin(17),
      858      residue fixed bin(17);
      859      residue = mod(number, 100);
      860      if residue >= 11 & residue <= 19 then return("th");
      861      residue = mod(residue, 10);
      862      if residue = 1 then return("st");
      863      if residue = 2 then return("nd");
      864      if residue = 3 then return("rd");
      865      else return("th");
      866 end ordinal;
      867 
      868 
      869 caps:  proc(whoami)  returns(char(5));
      870 dcl  whoami char(*) parameter;
      871      if whoami = "sort" then return("Sort");
      872      else return("Merge");
      873 end caps;
      874 
      875 end sort_convert_internal;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/82  1024.7  sort_convert_internal.pl1         >spec>on>11/11/82>sort_convert_internal.pl1
37           1    12/20/77  1614.2  sort_ext.incl.pl1                 >ldd>include>sort_ext.incl.pl1
138          2    04/18/75  1242.4  lex_descriptors_.incl.pl1         >ldd>include>lex_descriptors_.incl.pl1
173          3    11/11/82  1226.7  sort_merge_pars.incl.pl1          >spec>on>11/11/82>sort_merge_pars.incl.pl1
206          4    04/26/76  1500.0  sort_sd.incl.pl1                  >ldd>include>sort_sd.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Lvalue                    4            based           fixed bin(18,0)          level 2 dcl 2-68 ref 483
Pnext                     1            based           pointer                  level 2 packed unaligned dcl 2-68 ref 486
Ptoken                          000104 automatic       pointer                  dcl 2-68 set ref 248* 481 483 484 486* 486
Pvalue                    3            based           pointer                  level 2 packed unaligned dcl 2-68 ref 484
atom                                   based           char                     unaligned dcl 201 set ref 279 284 288 297 301* 303
                                                                                  308 312* 318 324* 326 331 344 348 353 392* 398*
                                                                                  413* 419* 425* 431* 437* 443* 449* 465 473 497
                                                                                  563* 590* 605* 631
atom_code                       000251 automatic       fixed bin(17,0)          dcl 204 set ref 276 277 286 286 293 293 320 335 346
                                                                                  346 476 476 482* 499* 523 523 529 619 619 625
atom_len                        000246 automatic       fixed bin(17,0)          dcl 198 set ref 279 284 288 297 301 301 303 308 312
                                                                                  312 318 324 324 326 331 344 348 353 392 392 398
                                                                                  398 413 413 419 419 425 425 431 431 437 437 443
                                                                                  443 449 449 465 473 483* 497 563 563 590 590 605
                                                                                  605 631
atom_ptr                        000244 automatic       pointer                  dcl 198 set ref 279 284 288 297 301 303 308 312 318
                                                                                  324 326 331 344 348 353 392 398 413 419 425 431
                                                                                  437 443 449 465 473 484* 497 563 590 605 631
bit_count                              parameter       fixed bin(24,0)          dcl 188 ref 12 233
bit_offset                6            based           fixed bin(6,0)           array level 3 dcl 4-3 set ref 543* 595*
break_chars                     000110 automatic       varying char(8)          dcl 140 set ref 228* 229* 234*
codes_array                            based           fixed bin(17,0)          array dcl 103 ref 499
comment_close                   000013 internal static char(2)                  initial unaligned dcl 48 set ref 229* 234*
comment_open                    000012 internal static char(2)                  initial unaligned dcl 48 set ref 229* 234*
compare                  23     000150 internal static fixed bin(17,0)          initial level 2 dcl 84 set ref 82 794 800 808 808
                                                                                  810
convert_int_code                       parameter       fixed bin(35,0)          dcl 188 set ref 12 221* 242* 390* 396* 404* 411*
                                                                                  417* 423* 429* 435* 441* 447* 552* 562* 593* 603*
                                                                                  719* 735* 742* 780* 802*
convert_status_code_            000176 constant        entry                    external dcl 19 ref 243
current_key                            parameter       fixed bin(17,0)          dcl 253 ref 252 260
cv_dec_check_                   000200 constant        entry                    external dcl 20 ref 301 312 324
cv_err                          000247 automatic       fixed bin(35,0)          dcl 202 set ref 301* 302 312* 313 324* 325
datatype                  2            based           char(8)                  array level 3 packed unaligned dcl 4-3 set ref 260
                                                                                  540* 574 579 605*
datatype_bits                   000242 automatic       bit                      unaligned dcl 165 set ref 521* 529* 537 547*
dsc                      17     000150 internal static fixed bin(17,0)          initial array level 2 dcl 84 set ref 320 335
dt_max                                 constant        fixed bin(17,0)          initial dcl 105 ref 165 286 293 476
dt_min                                 constant        fixed bin(17,0)          initial dcl 105 ref 165 286 293 476 529
dummy                    12            based           fixed bin(71,0)          level 2 in structure "io_exits" dcl 4-14
                                                                                  in procedure "sort_convert_internal" set ref 762
dummy                    16            based           fixed bin(71,0)          level 2 in structure "exits" dcl 4-20 in procedure
                                                                                  "sort_convert_internal" set ref 813
dummy                                  based           fixed bin(71,0)          level 2 in structure "keys" dcl 4-3 in procedure
                                                                                  "sort_convert_internal" set ref 722
dummy_exits                            based           structure                level 1 unaligned dcl 208
entry_variable                         based           structure                level 1 unaligned dcl 771
error_table_$no_stmt_delim      000230 external static fixed bin(35,0)          dcl 40 ref 241
error_table_$unbalanced_quotes  000232 external static fixed bin(35,0)          dcl 40 ref 241
ev                                     based           entry variable           dcl 774 set ref 784*
exit_code                       000252 automatic       fixed bin(17,0)          dcl 213 set ref 625* 630 630 631
exit_count_array                000243 automatic       fixed bin(17,0)          array dcl 168 set ref 509* 630* 630 730 730 733 736*
                                                                                  740 743* 747 754 795 801 803* 807
exit_max                               constant        fixed bin(17,0)          initial dcl 105 ref 82 168 169 346 794 800
exit_min                               constant        fixed bin(17,0)          initial dcl 105 ref 168 169 346
exit_name                              parameter       char                     unaligned dcl 768 set ref 766 781*
exit_pairs_count                000243 automatic       fixed bin(17,0)          dcl 171 set ref 398 398 406* 406* 510* 624* 624
exit_words                             defined         char(16)                 array unaligned dcl 82 set ref 803* 808*
exits                                  based           structure                level 1 unaligned dcl 4-20 in procedure
                                                                                  "sort_convert_internal"
exits                     2     000150 internal static fixed bin(17,0)          initial array level 2 in structure "keyword_codes"
                                                                                  dcl 84 in procedure "sort_convert_internal" set
                                                                                  ref 277 729 792
exits_array               2            based           entry variable           array level 2 dcl 208 set ref 808 808 810*
exits_ptr                              parameter       pointer                  dcl 188 set ref 12 511* 812*
find_command_                   000204 constant        entry                    external dcl 22 ref 776
find_command_code               000100 automatic       fixed bin(35,0)          dcl 23 set ref 776* 778
i                               000430 automatic       fixed bin(17,0)          dcl 533 set ref 536* 537 537*
ignored_break_chars             000106 automatic       varying char(4)          dcl 140 set ref 227* 229* 234*
index                           000374 automatic       fixed bin(17,0)          dcl 494 in procedure "look_up_keyword" set ref 496*
                                                                                  497 499*
index                           000560 automatic       fixed bin(17,0)          dcl 790 in procedure "construct_exits" set ref 794*
                                                                                  795* 800* 801 803 803 807 808 808 808 808 810*
input_file               21     000150 internal static fixed bin(17,0)          initial level 2 dcl 84 set ref 730 733 736 747 750
input_file_exit           2            based           entry variable           level 2 dcl 4-14 set ref 750 750 753*
input_file_exit_sw                     defined         bit(1)                   unaligned dcl 1-49 set ref 727* 749*
integer                         000250 automatic       fixed bin(35,0)          dcl 203 set ref 301* 312* 324* 560 567 588 595 601
                                                                                  609
internal_datatypes              000000 constant        char(8)                  initial array unaligned dcl 114 ref 259 260 540
internal_parameters                    parameter       pointer                  dcl 188 ref 12 226
io_exits                               based           structure                level 1 unaligned dcl 4-14
io_exits_ptr                           parameter       pointer                  dcl 188 set ref 12 511* 761*
ioa_$ioa_stream                 000202 constant        entry                    external dcl 21 ref 244 392 398 406 413 419 425 431
                                                                                  437 443 449 469 553 563 590 605 716 736 743 781
                                                                                  803
j                               000313 automatic       fixed bin(17,0)          dcl 256 set ref 259* 260 261*
key_desc                  2            based           structure                array level 2 unaligned dcl 4-3
keys                                   based           structure                level 1 unaligned dcl 4-3 in procedure
                                                                                  "sort_convert_internal"
keys                            000150 internal static fixed bin(17,0)          initial array level 2 in structure "keyword_codes"
                                                                                  dcl 84 in procedure "sort_convert_internal" set
                                                                                  ref 276 713 714 716
keys_ptr                               parameter       pointer                  dcl 188 set ref 12 511* 721*
keys_ptr_par                           parameter       pointer                  dcl 253 ref 252 258
keyword_codes                   000150 internal static structure                level 1 unaligned dcl 84 set ref 499
keywords                        000020 internal static char(16)                 initial array unaligned dcl 63 ref 496 496 497 803
                                                                                  803 808 808
l_ignored_input                 000016 internal static fixed bin(21,0)          initial dcl 55 set ref 234*
l_input                         000220 automatic       fixed bin(21,0)          dcl 140 set ref 233* 234*
legal_datatype_bits             000101 automatic       bit(8)                   initial array unaligned dcl 123 set ref 123* 123*
                                                                                  123* 123* 123* 123* 123* 123* 123* 123* 123* 536
                                                                                  537
legal_datatype_index            000242 automatic       fixed bin(17,0)          dcl 165 set ref 535* 537* 540 545 601 604
len                       4            based           fixed bin(24,0)          array level 3 dcl 4-3 set ref 573 575 575* 576 576*
                                                                                  580 580* 581 581* 609*
len_max                         000227 automatic       fixed bin(24,0)          initial array dcl 150 set ref 150* 150* 150* 150*
                                                                                  150* 150* 150* 150* 150* 150* 150* 224* 225* 601
                                                                                  604
lex_code                        000226 automatic       fixed bin(35,0)          dcl 140 set ref 234* 240 241 241 243*
lex_control_chars               000154 automatic       varying char(128)        dcl 140 set ref 229* 234*
lex_delims                      000113 automatic       varying char(128)        dcl 140 set ref 229* 234*
lex_string_$init_lex_delims     000206 constant        entry                    external dcl 24 ref 229
lex_string_$lex                 000210 constant        entry                    external dcl 27 ref 234
longinfo                        000262 automatic       char(100)                dcl 217 set ref 243* 244*
name                                   parameter       char                     unaligned dcl 768 set ref 766 776 776 776 776
nl                                     constant        char(1)                  initial unaligned dcl 44 ref 227 228
number                    1            based           fixed bin(17,0)          level 2 in structure "keys" dcl 4-3 in procedure
                                                                                  "sort_convert_internal" set ref 413 419* 425* 431*
                                                                                  437* 443* 449* 524* 534* 534 540 542 543 544 553*
                                                                                  563* 567 573 574 575 575 576 576 576 579 580 580
                                                                                  581 581 581 590* 595 605 605* 609 614 713 722
number                                 parameter       fixed bin(17,0)          dcl 857 in procedure "ordinal" ref 856 859
off                                    constant        bit(1)                   initial unaligned dcl 133 ref 727
on                                     constant        bit(1)                   initial unaligned dcl 133 ref 749 756
output_file              22     000150 internal static fixed bin(17,0)          initial level 2 dcl 84 set ref 730 740 743 754 757
output_file_exit          6            based           entry variable           level 2 dcl 4-14 set ref 757 757 760*
output_file_exit_sw                    defined         bit(1)                   unaligned dcl 1-120 set ref 727* 756*
p                                      parameter       pointer                  dcl 768 ref 766 776 777 784
p1                                     based           pointer                  level 2 dcl 771 set ref 776*
p2                        2            based           pointer                  level 2 dcl 771 set ref 777*
p_area                                 parameter       pointer                  dcl 188 set ref 12 234*
p_first_statement_desc          000222 automatic       pointer                  dcl 140 set ref 234*
p_first_token_desc              000224 automatic       pointer                  dcl 140 set ref 234* 248
p_input                         000216 automatic       pointer                  dcl 140 set ref 232* 234*
quote_close                     000011 internal static char(1)                  initial unaligned dcl 48 set ref 229* 234*
quote_open                      000010 internal static char(1)                  initial unaligned dcl 48 set ref 229* 234*
residue                         000600 automatic       fixed bin(17,0)          dcl 857 set ref 859* 860 860 861* 861 862 863 864
rv                        7            based           char(3)                  array level 3 packed unaligned dcl 4-3 set ref 544*
                                                                                  614*
s_init                          000015 internal static bit(2)                   initial unaligned dcl 48 set ref 229*
s_lex                           000017 internal static bit(3)                   initial unaligned dcl 55 set ref 234*
seg_length                             parameter       fixed bin(24,0)          dcl 188 set ref 12 852*
shortinfo                       000260 automatic       char(8)                  dcl 217 set ref 243*
sort_$noexit                    000212 constant        entry                    external dcl 33 ref 753 760 784 810
sort_desc_pn                           defined         char(168)                unaligned dcl 1-171 set ref 244*
sort_ext$input_file_exit_sw     000214 external static bit(1)                   unaligned dcl 1-48 set ref 727* 727 749* 749
sort_ext$output_file_exit_sw    000216 external static bit(1)                   unaligned dcl 1-119 set ref 727* 727 756* 756
sort_ext$sort_desc_pn           000220 external static char(168)                unaligned dcl 1-170 ref 244 244
sort_ext$user_out_sw            000222 external static char(32)                 unaligned dcl 1-212 ref 244 244 244 244 392 392 392
                                                                                  392 398 398 398 398 406 406 406 406 413 413 413
                                                                                  413 419 419 419 419 425 425 425 425 431 431 431
                                                                                  431 437 437 437 437 443 443 443 443 449 449 449
                                                                                  449 469 469 469 469 553 553 553 553 563 563 563
                                                                                  563 590 590 590 590 605 605 605 605 716 716 716
                                                                                  716 736 736 736 736 743 743 743 743 781 781 781
                                                                                  781 803 803 803 803
sort_ext$whoami                 000224 external static char(6)                  unaligned dcl 1-227 ref 244 244 244 244 244 244 392
                                                                                  392 398 398 406 406 413 413 419 419 425 425 431
                                                                                  431 437 437 443 443 449 449 469 469 553 553 563
                                                                                  563 590 590 605 605 716 716 736 736 743 743 781
                                                                                  781 803 803
source_parameters                      parameter       pointer                  dcl 188 ref 12 232
st_max                                 constant        fixed bin(17,0)          initial dcl 105 ref 164
st_min                                 constant        fixed bin(17,0)          initial dcl 105 ref 164
statement_counts                000242 automatic       fixed bin(17,0)          array dcl 164 set ref 508* 523* 523 619* 619 713 714
                                                                                  716* 729 792
statement_delim                 000014 internal static char(1)                  initial unaligned dcl 48 set ref 229* 234*
sum                             000561 automatic       fixed bin(35,0)          dcl 790 set ref 793* 795* 795 797
sys_info$max_seg_size           000226 external static fixed bin(35,0)          dcl 39 ref 222
tb                                     constant        char(1)                  initial unaligned dcl 46 ref 227 228
temp                            000470 automatic       fixed bin(24,0)          dcl 600 set ref 604* 605*
token                                  based           structure                level 1 dcl 2-68
typecode                               parameter       fixed bin(17,0)          dcl 253 set ref 252 257* 261*
user_name_array                 000243 automatic       char(168)                array unaligned dcl 169 set ref 631* 750* 757* 808*
user_out_sw                            defined         char(32)                 unaligned dcl 1-213 set ref 244 244* 392 392* 398
                                                                                  398* 406 406* 413 413* 419 419* 425 425* 431 431*
                                                                                  437 437* 443 443* 449 449* 469 469* 553 553* 563
                                                                                  563* 590 590* 605 605* 716 716* 736 736* 743 743*
                                                                                  781 781* 803 803*
version                                based           fixed bin(17,0)          initial level 2 in structure "exits" dcl 4-20
                                                                                  in procedure "sort_convert_internal" set ref 798*
version                                based           fixed bin(17,0)          initial level 2 in structure "io_exits" dcl 4-14
                                                                                  in procedure "sort_convert_internal" set ref 732*
version                                based           fixed bin(17,0)          initial level 2 in structure "keys" dcl 4-3
                                                                                  in procedure "sort_convert_internal" set ref 522*
whoami                                 defined         char(6)                  unaligned dcl 1-228 in procedure
                                                                                  "sort_convert_internal" set ref 244* 244* 244*
                                                                                  392* 398* 406* 413* 419* 425* 431* 437* 443* 449*
                                                                                  469 553* 563* 590* 605* 716* 736* 743* 781 803*
whoami                                 parameter       char                     unaligned dcl 870 in procedure "caps" ref 869 871
word_offset               5            based           fixed bin(18,0)          array level 3 dcl 4-3 set ref 542* 567* 576 581
word_offset_max                 000256 automatic       fixed bin(30,0)          dcl 215 set ref 222* 224 225 560
work_ptr                        000254 automatic       pointer                  dcl 214 set ref 226* 258* 260 413 419 425 431 437
                                                                                  443 449 522 524 534 534 540 540 542 542 543 543
                                                                                  544 544 553 563 567 567 573 573 574 574 575 575
                                                                                  575 575 576 576 576 576 576 576 579 579 580 580
                                                                                  580 580 581 581 581 581 581 581 590 595 595 605
                                                                                  605 605 609 609 614 614 713 721 722* 722 732 750
                                                                                  750 753 757 757 760 761 762* 762 798 808 808 810
                                                                                  812 813* 813 852

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Pcomment                               automatic       pointer                  dcl 2-20
Pstmt                                  automatic       pointer                  dcl 2-40
acl                                    defined         structure                array level 1 unaligned dcl 1-6
attach_array                           automatic       structure                array level 1 unaligned dcl 3-6
b                                      defined         fixed bin(30,0)          array dcl 1-13
comment                                based           structure                level 1 dcl 2-20
comment_value                          based           char                     unaligned dcl 2-20
compare_sw                             defined         fixed bin(1,0)           dcl 1-19
compares_counter                       defined         fixed bin(34,0)          dcl 1-16
curr_input_file_attach                 defined         char(256)                unaligned dcl 1-22
curr_input_file_name                   defined         char(256)                unaligned dcl 1-25
curr_input_file_num                    defined         fixed bin(17,0)          dcl 1-28
curr_output_file_attach                defined         char(256)                unaligned dcl 1-31
curr_output_file_name                  defined         char(256)                unaligned dcl 1-34
debug_sw                               defined         bit(1)                   unaligned dcl 1-37
disaster2                              defined         fixed bin(17,0)          dcl 1-40
dt                                     defined         fixed bin(30,0)          array dcl 1-43
in_buff_ptr                            defined         pointer                  dcl 1-65
input_driver_is_sort                   defined         bit(1)                   unaligned dcl 1-46
input_file                             automatic       char(256)                array unaligned dcl 3-10
input_file_max                         defined         fixed bin(17,0)          dcl 1-53
input_rec_deleted                      defined         fixed bin(30,0)          dcl 1-59
input_rec_inserted                     defined         fixed bin(30,0)          dcl 1-62
input_record_exit_sw                   defined         fixed bin(1,0)           dcl 1-56
leng                                   defined         fixed bin(30,0)          array dcl 1-68
max1                                   defined         fixed bin(30,0)          dcl 1-71
max2                                   defined         fixed bin(30,0)          dcl 1-74
max3                                   defined         fixed bin(30,0)          dcl 1-77
max4                                   defined         fixed bin(30,0)          dcl 1-80
max_rec_length                         defined         fixed bin(30,0)          dcl 1-84
merge_compares                         defined         fixed bin(34,0)          dcl 1-87
merge_in_iocb_ptrs                     defined         pointer                  array dcl 1-90
merge_input_file_attaches              defined         char(256)                array unaligned dcl 1-93
merge_input_file_names                 defined         char(256)                array unaligned dcl 1-96
mii                                    defined         fixed bin(17,0)          dcl 1-99
min_rec_length                         defined         fixed bin(30,0)          dcl 1-102
mip                                    defined         fixed bin(30,0)          array dcl 1-105
msp                                    defined         pointer                  array dcl 1-108
no_of_keys                             defined         fixed bin(30,0)          dcl 1-111
old_input_file_num                     defined         fixed bin(17,0)          dcl 1-114
output_driver_is_sort                  defined         bit(1)                   unaligned dcl 1-117
output_rec_deleted                     defined         fixed bin(30,0)          dcl 1-123
output_rec_inserted                    defined         fixed bin(30,0)          dcl 1-126
output_record_exit_sw                  defined         fixed bin(1,0)           dcl 1-129
presort_compares                       defined         fixed bin(34,0)          dcl 1-132
pu                                     defined         structure                array level 1 unaligned dcl 1-137
read_count                             defined         fixed bin(30,0)          dcl 1-142
rec_ptr_a                              defined         pointer                  dcl 1-145
rec_ptr_b                              defined         pointer                  dcl 1-148
release_count                          defined         fixed bin(30,0)          dcl 1-151
report_sw                              defined         bit(2)                   unaligned dcl 1-154
return_count                           defined         fixed bin(30,0)          dcl 1-157
rev                                    defined         fixed bin(1,0)           array dcl 1-160
sii                                    defined         fixed bin(30,0)          dcl 1-163
sip                                    defined         pointer                  dcl 1-166
sort_ext$acl                           external static structure                array level 1 unaligned dcl 1-1
sort_ext$b                             external static fixed bin(30,0)          array dcl 1-12
sort_ext$compare_sw                    external static fixed bin(1,0)           dcl 1-18
sort_ext$compares_counter              external static fixed bin(34,0)          dcl 1-15
sort_ext$curr_input_file_attach        external static char(256)                unaligned dcl 1-21
sort_ext$curr_input_file_name          external static char(256)                unaligned dcl 1-24
sort_ext$curr_input_file_num           external static fixed bin(17,0)          dcl 1-27
sort_ext$curr_output_file_attach       external static char(256)                unaligned dcl 1-30
sort_ext$curr_output_file_name         external static char(256)                unaligned dcl 1-33
sort_ext$debug_sw                      external static bit(1)                   unaligned dcl 1-36
sort_ext$disaster2                     external static fixed bin(17,0)          dcl 1-39
sort_ext$dt                            external static fixed bin(30,0)          array dcl 1-42
sort_ext$in_buff_ptr                   external static pointer                  dcl 1-64
sort_ext$input_driver_is_sort          external static bit(1)                   unaligned dcl 1-45
sort_ext$input_file_max                external static fixed bin(17,0)          dcl 1-51
sort_ext$input_rec_deleted             external static fixed bin(30,0)          dcl 1-58
sort_ext$input_rec_inserted            external static fixed bin(30,0)          dcl 1-61
sort_ext$input_record_exit_sw          external static fixed bin(1,0)           dcl 1-55
sort_ext$leng                          external static fixed bin(30,0)          array dcl 1-67
sort_ext$max1                          external static fixed bin(30,0)          dcl 1-70
sort_ext$max2                          external static fixed bin(30,0)          dcl 1-73
sort_ext$max3                          external static fixed bin(30,0)          dcl 1-76
sort_ext$max4                          external static fixed bin(30,0)          dcl 1-79
sort_ext$max_rec_length                external static fixed bin(30,0)          dcl 1-82
sort_ext$merge_compares                external static fixed bin(34,0)          dcl 1-86
sort_ext$merge_in_iocb_ptrs            external static pointer                  array dcl 1-89
sort_ext$merge_input_file_attaches     external static char(256)                array unaligned dcl 1-92
sort_ext$merge_input_file_names        external static char(256)                array unaligned dcl 1-95
sort_ext$mii                           external static fixed bin(17,0)          dcl 1-98
sort_ext$min_rec_length                external static fixed bin(30,0)          dcl 1-101
sort_ext$mip                           external static fixed bin(30,0)          array dcl 1-104
sort_ext$msp                           external static pointer                  array dcl 1-107
sort_ext$no_of_keys                    external static fixed bin(30,0)          dcl 1-110
sort_ext$old_input_file_num            external static fixed bin(17,0)          dcl 1-113
sort_ext$output_driver_is_sort         external static bit(1)                   unaligned dcl 1-116
sort_ext$output_rec_deleted            external static fixed bin(30,0)          dcl 1-122
sort_ext$output_rec_inserted           external static fixed bin(30,0)          dcl 1-125
sort_ext$output_record_exit_sw         external static fixed bin(1,0)           dcl 1-128
sort_ext$presort_compares              external static fixed bin(34,0)          dcl 1-131
sort_ext$pu                            external static structure                array level 1 unaligned dcl 1-134
sort_ext$read_count                    external static fixed bin(30,0)          dcl 1-141
sort_ext$rec_ptr_a                     external static pointer                  dcl 1-144
sort_ext$rec_ptr_b                     external static pointer                  dcl 1-147
sort_ext$release_count                 external static fixed bin(30,0)          dcl 1-150
sort_ext$report_sw                     external static bit(2)                   unaligned dcl 1-153
sort_ext$return_count                  external static fixed bin(30,0)          dcl 1-156
sort_ext$rev                           external static fixed bin(1,0)           array dcl 1-159
sort_ext$sii                           external static fixed bin(30,0)          dcl 1-162
sort_ext$sip                           external static pointer                  dcl 1-165
sort_ext$sort_compare_exit             external static entry variable           dcl 1-168
sort_ext$sort_input_record_exit        external static entry variable           dcl 1-173
sort_ext$sort_output_record_exit       external static entry variable           dcl 1-178
sort_ext$srp                           external static pointer                  dcl 1-183
sort_ext$ssi                           external static fixed bin(30,0)          dcl 1-186
sort_ext$ssp                           external static pointer                  dcl 1-189
sort_ext$state                         external static fixed bin(17,0)          dcl 1-192
sort_ext$terminate_print_sw            external static bit(1)                   unaligned dcl 1-195
sort_ext$time_info                     external static structure                array level 1 unaligned dcl 1-198
sort_ext$time_sw                       external static bit(1)                   unaligned dcl 1-209
sort_ext$unique_prefix                 external static char(16)                 unaligned dcl 1-215
sort_ext$w                             external static fixed bin(30,0)          array dcl 1-218
sort_ext$wf_dir_name                   external static char(168)                dcl 1-221
sort_ext$wf_full_name                  external static char(168)                unaligned dcl 1-224
sort_ext$write_count                   external static fixed bin(30,0)          dcl 1-230
sort_input_record_exit                 defined         entry variable           dcl 1-175
sort_output_record_exit                defined         entry variable           dcl 1-180
srp                                    defined         pointer                  dcl 1-184
ssi                                    defined         fixed bin(30,0)          dcl 1-187
ssp                                    defined         pointer                  dcl 1-190
state                                  defined         fixed bin(17,0)          dcl 1-193
stmt                                   based           structure                level 1 dcl 2-40
stmt_value                             based           char                     unaligned dcl 2-40
terminate_print_sw                     defined         bit(1)                   unaligned dcl 1-196
time_info                              defined         structure                array level 1 unaligned dcl 1-203
time_sw                                defined         bit(1)                   unaligned dcl 1-210
token_value                            based           char                     unaligned dcl 2-68
unique_prefix                          defined         char(16)                 unaligned dcl 1-216
w                                      defined         fixed bin(30,0)          array dcl 1-219
wf_dir_name                            defined         char(168)                dcl 1-222
wf_full_name                           defined         char(168)                unaligned dcl 1-225
write_count                            defined         fixed bin(30,0)          dcl 1-231

NAMES DECLARED BY EXPLICIT CONTEXT.
b_action                        003455 constant        entry                    internal dcl 587 ref 328
b_state                         001754 constant        label                    dcl 328 ref 325
caps                            004757 constant        entry                    internal dcl 869 ref 244 244
construct_end                   004667 constant        entry                    internal dcl 851 ref 708
construct_entry_variable        004311 constant        entry                    internal dcl 766 ref 750 757 808
construct_exits                 004443 constant        entry                    internal dcl 789 ref 706
construct_io_exits              004004 constant        entry                    internal dcl 726 ref 705
construct_keys                  003713 constant        entry                    internal dcl 712 ref 704
convert_datatype                001453 constant        entry                    external dcl 252
datatype_action                 003165 constant        entry                    internal dcl 532 ref 295
datatype_err_action             003243 constant        entry                    internal dcl 551 ref 545
datatype_state                  001574 constant        label                    dcl 295 ref 294
datatype_word_action            003155 constant        entry                    internal dcl 528 ref 290
datatype_word_state             001564 constant        label                    dcl 290 ref 293
dt_state                        001574 constant        label                    dcl 295
dtw_state                       001564 constant        label                    dcl 290 ref 286 476
end_file_action                 003705 constant        entry                    internal dcl 702 ref 386
end_file_state                  002041 constant        label                    dcl 386 set ref 481
end_lookup                      003062 constant        label                    dcl 503 ref 500
end_of_statement_state          002040 constant        label                    dcl 383 ref 288 348 410 465 473
enter_action                    003063 constant        entry                    internal dcl 507 ref 272
enter_state                     001517 constant        label                    dcl 272
err_10_state                    002463 constant        label                    dcl 429 set ref 309
err_11_state                    002534 constant        label                    dcl 435 set ref 314
err_13_state                    002605 constant        label                    dcl 441 ref 327
err_14_state                    002656 constant        label                    dcl 447 ref 332
err_1_state                     002043 constant        label                    dcl 390 set ref 280
err_4_state                     002106 constant        label                    dcl 396 ref 349
err_5_state                     002204 constant        label                    dcl 404 ref 354
err_6_state                     002265 constant        label                    dcl 411 set ref 289
err_8_state                     002341 constant        label                    dcl 417 set ref 298
err_9_state                     002412 constant        label                    dcl 423 ref 304
exit                            001446 constant        label                    dcl 250
exit_name_action                003657 constant        entry                    internal dcl 623 ref 350
exit_name_state                 002024 constant        label                    dcl 350 ref 346
exits_action                    003652 constant        entry                    internal dcl 618 ref 341
exits_state                     001776 constant        label                    dcl 341 ref 277
expect_dtw_state                001550 constant        label                    dcl 286 ref 285 321 336 340
expect_exit_name_state          002010 constant        label                    dcl 346 ref 345 358 403
keys_action                     003135 constant        entry                    internal dcl 520 ref 281
keys_state                      001536 constant        label                    dcl 281 ref 276
left_par_off_state              001717 constant        label                    dcl 322 ref 318
left_par_size_state             001604 constant        label                    dcl 299 ref 297
look_up_keyword                 003035 constant        entry                    internal dcl 493 ref 485
new_statement_state             001520 constant        label                    dcl 274 ref 279 383
no_bit_offset_action            003371 constant        entry                    internal dcl 571 ref 319
ordinal                         004676 constant        entry                    internal dcl 856 ref 398 406
right_par_off_state             001765 constant        label                    dcl 333 ref 326 331
right_par_size_state            001652 constant        label                    dcl 310 ref 303 308
rv_action                       003642 constant        entry                    internal dcl 613 ref 337
rv_state                        001773 constant        label                    dcl 337 ref 320 335
scan                            003015 constant        entry                    internal dcl 480 ref 274 283 284 292 299 307 310 317
                                                                                  322 330 333 339 343 344 352 357 402 467 475
scan_key_loop                   003000 constant        label                    dcl 473 ref 477
scan_key_state                  002737 constant        label                    dcl 469 ref 416 422 428 434 440 446 452
scan_statement_state            002727 constant        label                    dcl 465 ref 395 468
size_action                     003540 constant        entry                    internal dcl 599 ref 305
size_state                      001641 constant        label                    dcl 305 ref 302
sort_convert_internal           001075 constant        entry                    external dcl 12
syntax                          001516 constant        entry                    internal dcl 271 ref 249
user_name_action                003664 constant        entry                    internal dcl 629 ref 355 409
user_name_state                 002035 constant        label                    dcl 355 set ref 353
w_action                        003306 constant        entry                    internal dcl 559 ref 315
w_state                         001701 constant        label                    dcl 315 ref 313

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 499 722 750 750 757 757 762 776 776 808 808 813
before                                                 builtin function         ref 469 781
bin                                                    builtin function         ref 233 852
hbound                                                 builtin function         ref 259 496 536
lbound                                                 builtin function         ref 496
length                                                 builtin function         ref 469 776 776 781
mod                                                    builtin function         ref 576 581 859 861
null                                                   builtin function         ref 481 511 777
rel                                                    builtin function         ref 852
substr                                                 builtin function         ref 529

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5304        5540    5056        5314
Length      6122    5056       234         345     225         166

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
sort_convert_internal               962 external procedure  is an external procedure.  
syntax                                  internal procedure  shares stack frame of external procedure sort_convert_internal.  
scan                                    internal procedure  shares stack frame of external procedure sort_convert_internal.  
look_up_keyword                         internal procedure  shares stack frame of external procedure sort_convert_internal.  
enter_action                            internal procedure  shares stack frame of external procedure sort_convert_internal.  
keys_action                             internal procedure  shares stack frame of external procedure sort_convert_internal.  
datatype_word_action                    internal procedure  shares stack frame of external procedure sort_convert_internal.  
datatype_action                         internal procedure  shares stack frame of external procedure sort_convert_internal.  
datatype_err_action                     internal procedure  shares stack frame of external procedure sort_convert_internal.  
w_action                                internal procedure  shares stack frame of external procedure sort_convert_internal.  
no_bit_offset_action                    internal procedure  shares stack frame of external procedure sort_convert_internal.  
b_action                                internal procedure  shares stack frame of external procedure sort_convert_internal.  
size_action                             internal procedure  shares stack frame of external procedure sort_convert_internal.  
rv_action                               internal procedure  shares stack frame of external procedure sort_convert_internal.  
exits_action                            internal procedure  shares stack frame of external procedure sort_convert_internal.  
exit_name_action                        internal procedure  shares stack frame of external procedure sort_convert_internal.  
user_name_action                        internal procedure  shares stack frame of external procedure sort_convert_internal.  
end_file_action                         internal procedure  shares stack frame of external procedure sort_convert_internal.  
construct_keys                          internal procedure  shares stack frame of external procedure sort_convert_internal.  
construct_io_exits                      internal procedure  shares stack frame of external procedure sort_convert_internal.  
construct_entry_variable                internal procedure  shares stack frame of external procedure sort_convert_internal.  
construct_exits                         internal procedure  shares stack frame of external procedure sort_convert_internal.  
construct_end                           internal procedure  shares stack frame of external procedure sort_convert_internal.  
ordinal                                 internal procedure  shares stack frame of external procedure sort_convert_internal.  
caps                                    internal procedure  shares stack frame of external procedure sort_convert_internal.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 quote_open                  sort_convert_internal
000011 quote_close                 sort_convert_internal
000012 comment_open                sort_convert_internal
000013 comment_close               sort_convert_internal
000014 statement_delim             sort_convert_internal
000015 s_init                      sort_convert_internal
000016 l_ignored_input             sort_convert_internal
000017 s_lex                       sort_convert_internal
000020 keywords                    sort_convert_internal
000150 keyword_codes               sort_convert_internal

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
sort_convert_internal    000100 find_command_code           sort_convert_internal
                         000101 legal_datatype_bits         sort_convert_internal
                         000104 Ptoken                      sort_convert_internal
                         000106 ignored_break_chars         sort_convert_internal
                         000110 break_chars                 sort_convert_internal
                         000113 lex_delims                  sort_convert_internal
                         000154 lex_control_chars           sort_convert_internal
                         000216 p_input                     sort_convert_internal
                         000220 l_input                     sort_convert_internal
                         000222 p_first_statement_desc      sort_convert_internal
                         000224 p_first_token_desc          sort_convert_internal
                         000226 lex_code                    sort_convert_internal
                         000227 len_max                     sort_convert_internal
                         000242 datatype_bits               sort_convert_internal
                         000242 statement_counts            sort_convert_internal
                         000242 legal_datatype_index        sort_convert_internal
                         000243 exit_pairs_count            sort_convert_internal
                         000243 user_name_array             sort_convert_internal
                         000243 exit_count_array            sort_convert_internal
                         000244 atom_ptr                    sort_convert_internal
                         000246 atom_len                    sort_convert_internal
                         000247 cv_err                      sort_convert_internal
                         000250 integer                     sort_convert_internal
                         000251 atom_code                   sort_convert_internal
                         000252 exit_code                   sort_convert_internal
                         000254 work_ptr                    sort_convert_internal
                         000256 word_offset_max             sort_convert_internal
                         000260 shortinfo                   sort_convert_internal
                         000262 longinfo                    sort_convert_internal
                         000313 j                           sort_convert_internal
                         000374 index                       look_up_keyword
                         000430 i                           datatype_action
                         000470 temp                        size_action
                         000560 index                       construct_exits
                         000561 sum                         construct_exits
                         000600 residue                     ordinal

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        return              alloc_auto_adj      mod_fx1
shorten_stack       ext_entry           trunc_fx2           divide_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
convert_status_code_          cv_dec_check_                 find_command_                 ioa_$ioa_stream
lex_string_$init_lex_delims   lex_string_$lex               sort_$noexit

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$no_stmt_delim    error_table_$unbalanced_quotes                              sort_ext$input_file_exit_sw
sort_ext$output_file_exit_sw  sort_ext$sort_desc_pn         sort_ext$user_out_sw          sort_ext$whoami
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     82 000621       123 000626       150 000732       164 001001       165 001015       168 001024       169 001040
    716 001055       736 001057       750 001060       803 001062        12 001066       221 001103       222 001105
    224 001114       225 001116       226 001121       227 001124       228 001134       229 001151       232 001221
    233 001225       234 001234       240 001335       241 001337       242 001344       243 001347       244 001361
    248 001443       249 001445       250 001446       252 001447       257 001461       258 001463       259 001466
    260 001472       261 001510       262 001512       264 001513       265 001515       271 001516       272 001517
    274 001520       276 001521       277 001525       279 001527       280 001535       281 001536       283 001537
    284 001540       285 001547       286 001550       288 001555       289 001563       290 001564       292 001565
    293 001566       294 001573       295 001574       297 001575       298 001603       299 001604       301 001605
    302 001630       303 001632       304 001640       305 001641       307 001642       308 001643       309 001651
    310 001652       312 001653       313 001676       314 001700       315 001701       317 001702       318 001703
    319 001711       320 001712       321 001716       322 001717       324 001720       325 001743       326 001745
    327 001753       328 001754       330 001755       331 001756       332 001764       333 001765       335 001766
    336 001772       337 001773       339 001774       340 001775       341 001776       343 001777       344 002000
    345 002007       346 002010       348 002015       349 002023       350 002024       352 002025       353 002026
    354 002034       355 002035       357 002036       358 002037       383 002040       386 002041       388 002042
    390 002043       392 002046       395 002105       396 002106       398 002111       402 002201       403 002203
    404 002204       406 002207       409 002262       410 002264       411 002265       413 002270       416 002340
    417 002341       419 002344       422 002411       423 002412       425 002415       428 002462       429 002463
    431 002466       434 002533       435 002534       437 002537       440 002604       441 002605       443 002610
    446 002655       447 002656       449 002661       452 002726       465 002727       467 002735       468 002736
    469 002737       473 003000       475 003006       476 003007       477 003014       480 003015       481 003016
    482 003022       483 003023       484 003026       485 003030       486 003031       487 003034       493 003035
    496 003036       497 003043       499 003054       500 003057       502 003060       503 003062       507 003063
    508 003064       509 003105       510 003126       511 003127       517 003134       520 003135       521 003136
    522 003145       523 003147       524 003152       525 003154       528 003155       529 003156       530 003164
    532 003165       534 003166       535 003170       536 003171       537 003176       539 003207       540 003211
    542 003223       543 003224       544 003225       545 003230       547 003233       548 003242       551 003243
    552 003244       553 003247       556 003305       559 003306       560 003307       562 003312       563 003315
    567 003362       568 003370       571 003371       573 003372       574 003401       575 003411       576 003417
    578 003427       579 003430       580 003436       581 003444       584 003454       587 003455       588 003456
    590 003461       593 003526       595 003531       596 003537       599 003540       601 003541       603 003545
    604 003550       605 003552       609 003633       610 003641       613 003642       614 003643       615 003651
    618 003652       619 003653       620 003656       623 003657       624 003660       625 003661       626 003663
    629 003664       630 003665       631 003670       632 003704       702 003705       704 003706       705 003707
    706 003710       708 003711       709 003712       712 003713       713 003714       714 003726       716 003732
    719 003766       721 003771       722 003774       723 004003       726 004004       727 004005       729 004017
    730 004024       732 004035       733 004037       735 004045       736 004050       740 004105       742 004114
    743 004117       747 004154       749 004161       750 004163       752 004222       753 004223       754 004230
    756 004235       757 004237       759 004275       760 004276       761 004303       762 004306       763 004310
    766 004311       776 004327       777 004352       778 004357       780 004361       781 004364       784 004432
    786 004442       789 004443       792 004444       793 004452       794 004453       795 004462       796 004470
    797 004472       798 004475       800 004477       801 004507       802 004514       803 004517       807 004567
    808 004572       809 004641       810 004642       811 004657       812 004661       813 004664       814 004666
    851 004667       852 004670       853 004675       856 004676       859 004700       860 004704       861 004716
    862 004721       863 004731       864 004741       865 004751       869 004757       871 004770       872 005003


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
