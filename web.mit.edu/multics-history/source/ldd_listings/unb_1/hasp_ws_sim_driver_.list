	COMPILATION LISTING OF SEGMENT hasp_ws_sim_driver_
	Compiled by: Multics PL/I Compiler, Release 32e, of September 22, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 10/03/89  0954.2 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /* IO Daemon Driver Module - designed to run as a HASP workstation for one of the devices associated with the station.
       15*   The possible devices are:
       16*
       17*   READER - send jobs to the host as if this pgm is a card reader.
       18*   PRINTER - receive print files from the host.
       19*   PUNCH - receive punch files (card decks) from the host.
       20*
       21*   The device to be run by the process is specified in the minor_args with the dev= key as follows:
       22*   "reader_out" => READER device, "printer_in" => PRINTER device, "punch_in" => PUNCH device.
       23*
       24*   The process can only run one of the possible HASP devices.  There must be a separate process for each active device.
       25**/
       26 
       27 /* format: style4 */
       28 
       29 /* Created by J. C. Whitmore, Feb. 1980. */
       30 /* Modified: September 1980 by G. Palter to make auto_queue the default, eliminate ident= minor_args keyword and ident
       31*   command, and add request_type= minor_args keyword and request_type command */
       32 /* Modified: 30 September 1981 by G. Palter to use proper maximum length for the request type name (24 characters) */
       33 /* Modified: 24 November 1981 by G. Palter to implement the auto_receive parameter */
       34 /* Modified: February 23, 1985 by C. Marker to use version 5 message segments */
       35 
       36 
       37 /****^  HISTORY COMMENTS:
       38*  1) change(87-05-10,Gilcrease), approve(87-05-13,MCR7686),
       39*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
       40*     Update to version 4 dprint_msg.
       41*  2) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
       42*     audit(88-10-21,Wallman), install(88-10-28,MR12.2-1199):
       43*     Upgraded to version 5 iod tables.
       44*  3) change(88-08-25,Farley), approve(88-08-19,MCR7911),
       45*     audit(88-10-18,Wallman), install(88-10-28,MR12.2-1199):
       46*     Updated to allow for version 5 dprint_msg.
       47*  4) change(89-06-15,Brunelle), approve(89-09-18,MCR8129),
       48*     audit(89-09-29,Beattie), install(89-10-03,MR12.3-1083):
       49*     Correct generation of major/minor_args_ptr when using offset into the I/O
       50*     daemon tables string area.
       51*                                                   END HISTORY COMMENTS */
       52 
       53 
       54 hasp_ws_sim_driver_:
       55      procedure ();
       56 
       57 	return;					/* not an entry */
       58 
       59 
       60 /* Parameters */
       61 
       62 dcl  a_argp ptr parameter;
       63 dcl  a_source fixed bin parameter;			/* 1 = master console, 2 = slave */
       64 dcl  a_state fixed bin parameter;			/* 0 = not quite ready to handle a request */
       65 						/* 1 = drivers are ready */
       66 						/* 2 = command entered after a quit */
       67 dcl  a_stream char (*) parameter;
       68 dcl  a_banner_type fixed bin parameter;			/* type of banner to be written  */
       69 						/* 1 = heading banner            */
       70 						/* 2 = tail banner               */
       71 						/* 3 = error message             */
       72 
       73 dcl  a_data_ptr ptr parameter;			/* pointer to output request data or  */
       74 						/* to char(256) varying string error msg */
       75 
       76 dcl  a_code fixed bin (35) parameter;			/* error code */
       77 
       78 
       79 /* Other declarations */
       80 
       81 dcl  age fixed bin;
       82 dcl  argp ptr;
       83 dcl  banner_type fixed bin;
       84 dcl  code fixed bin (35);
       85 dcl  date_string char (24);
       86 dcl  device_type char (32);
       87 dcl  element_size fixed bin;
       88 dcl  format_code fixed bin;
       89 dcl  generic_type character (32);
       90 dcl  ignore fixed bin (35);
       91 dcl  last fixed bin;
       92 dcl  local_request_type character (24);
       93 dcl  iocbp ptr;
       94 dcl  major_args char (major_args_length) based (major_args_ptr);
       95 dcl  major_args_ptr ptr;
       96 dcl  major_args_length fixed bin;
       97 dcl  major_args_name char (256) varying;
       98 dcl  minor_args char (minor_args_length) based (minor_args_ptr);
       99 dcl  minor_args_ptr ptr;
      100 dcl  minor_args_length fixed bin;
      101 dcl  minor_args_name char (256) varying;
      102 dcl  omode char (256);
      103 dcl  p ptr;
      104 dcl  p2 ptr;
      105 dcl  save_code fixed bin (35);
      106 dcl  source fixed bin;
      107 dcl  state fixed bin;
      108 dcl  value fixed bin;
      109 dcl  value_string character (256) varying;
      110 
      111 dcl  1 term_info aligned like terminal_info;
      112 
      113 dcl  1 hangup_info aligned,				/* structure used to set hangup_info proc */
      114        2 entry entry,
      115        2 data_ptr ptr,
      116        2 priority fixed bin;
      117 
      118 dcl  1 read_info aligned,
      119        2 read_ev_chan fixed bin (71),
      120        2 input_ready bit (1) unal;
      121 
      122 dcl  1 ev_chan_list aligned based,
      123        2 number fixed bin,
      124        2 channel (12) fixed bin (71);
      125 
      126 dcl  1 static_receive_data aligned int static like receive_file_data;
      127 dcl  static_default_request_type character (32) internal static initial (""); /* request type specified in iod_tables */
      128 
      129 dcl  sys_dir char (168) based;
      130 
      131 dcl  1 arg_list aligned based (argp),			/* parse_command_ structure */
      132        2 max_tokens fixed bin,			/* space allocated, do not change */
      133        2 n_tokens fixed bin,				/* number of tokens from command line (including cmd) */
      134        2 command char (64) var,			/* the first token is the command */
      135        2 arg (n_tokens - 1) char (64) var;		/* the other tokens are args to the command */
      136 
      137 dcl  add_char_offset_ entry (ptr, fixed bin (21)) returns (ptr) reducible;
      138 dcl  continue_to_signal_ entry (fixed bin (35));
      139 dcl  expand_pathname_$component entry (char (*), char (*), char (*), char (*), fixed bin (35));
      140 dcl  iod_info_$generic_type entry (character (*), character (32), fixed binary (35));
      141 dcl  initiate_file_$component entry (char (*), char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
      142 dcl  iodd_msg_ entry options (variable);
      143 dcl  iodd_parse_$args entry (char (*) var, char (*)) returns (char (256) var);
      144 dcl  iodd_hangup_$iodd_hangup_ entry;
      145 dcl  set_iod_val entry (char (*), char (*));
      146 dcl  iox_$attach_ioname entry (char (*), ptr, char (*), fixed bin (35));
      147 dcl  iox_$open entry (ptr, fixed bin, bit (36), fixed bin (35));
      148 dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
      149 dcl  iox_$modes entry (ptr, char (*), char (*), fixed bin (35));
      150 dcl  iox_$close entry (ptr, fixed bin (35));
      151 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
      152 dcl  date_time_ entry (fixed bin (71), char (*));
      153 dcl  iodd_listen_ entry (ptr);
      154 dcl  output_request_ entry (char (*), fixed bin, ptr, entry, fixed bin (35));
      155 dcl  output_request_$set_single_copy entry ();
      156 dcl  output_request_$error_during_request entry (char (*));
      157 dcl  pool_manager_$init entry (char (*), fixed bin, bit (36) aligned, fixed bin (35));
      158 dcl  pool_manager_$clean_pool entry (char (*), fixed bin, fixed bin, fixed bin (35));
      159 dcl  receive_file_ entry (char (*), ptr, char (*), ptr, fixed bin (35));
      160 dcl  timer_manager_$sleep entry (fixed bin (71), bit (2) aligned);
      161 
      162 dcl  space char (1) int static options (constant) init (" ");
      163 dcl  master fixed bin int static options (constant) init (1);
      164 dcl  slave fixed bin int static options (constant) init (2);
      165 dcl  both fixed bin int static options (constant) init (0); /* master and slave for iodd_msg_ */
      166 dcl  log fixed bin int static options (constant) init (0);
      167 dcl  normal fixed bin int static options (constant) init (1);
      168 dcl  error fixed bin int static options (constant) init (2);
      169 
      170 dcl  punch_rmcc_mode fixed bin int static options (constant) init (3);
      171 
      172 dcl  initial_punch_rate fixed bin int static options (constant) init (500); /* same for the punch */
      173 
      174 dcl  head_banner fixed bin int static options (constant) init (1);
      175 
      176 dcl  default_request_types (2) character (32) static options (constant) /* default for dprinting received files */
      177 	initial ("printer", "punch");
      178 
      179 dcl  myname char (19) int static init ("hasp_ws_sim_driver_") options (constant);
      180 
      181 dcl  time fixed bin (71) int static init (10);
      182 dcl  pool_dir char (168) int static init ("");
      183 dcl  station char (32) int static;
      184 
      185 dcl  1 static_sw_info aligned int static like sw_info;	/* allocate a copy of this structure */
      186 
      187 dcl  (addr, character, clock, convert, divide, length, ltrim, null, rtrim) builtin;
      188 
      189 dcl  (cleanup, command_level, re_init, no_coord, daemon_new_device, daemon_logout, daemon_slave_logout, conversion)
      190 	condition;
      191 
      192 dcl  (error_table_$action_not_performed, error_table_$bigarg, error_table_$fatal_error, error_table_$io_no_permission,
      193      error_table_$undefined_order_request, error_table_$ionmat, error_table_$not_detached, error_table_$not_closed)
      194 	fixed binary (35) external;
      195 
      196 /**/
      197 
      198 /* Initialize the driver */
      199 
      200 init:
      201      entry (a_argp);
      202 
      203 	stat_p = a_argp;				/* put the arg into static for easy reference */
      204 	station = "Undefined!";			/* clear station name for any messages */
      205 	text_strings_ptr = iodd_static.text_strings_ptr;	/* get ptr to i/o daemon table text area */
      206 
      207 	if iodd_static.attach_type ^= ATTACH_TYPE_TTY then do; /* this driver expects a tty channel */
      208 	     call iodd_msg_ (error, master, error_table_$fatal_error, myname,
      209 		"The HASP workstation simulator driver requires a line: statement in iod_tables.");
      210 	     return;				/* quit now */
      211 	end;
      212 
      213 	if iodd_static.assigned_devices > 1 then do;	/* remember, we can only use one device per process */
      214 	     call iodd_msg_ (error, master, error_table_$fatal_error, myname,
      215 		"The HASP workstation simulator driver only supports one minor device per process.");
      216 	     return;
      217 	end;
      218 
      219 	iodd_static.dev_io_stream,
      220 	     iodd_static.dev_in_stream = "Undefined_stream!"; /* we don't use these in this proc */
      221 
      222 	on daemon_logout call drop_device;
      223 	on daemon_slave_logout go to logout_slave;
      224 	on daemon_new_device call drop_device;
      225 	on no_coord call drop_device;
      226 	on cleanup call detach_device;
      227 
      228 /* locate major args for this device in the i/o daemon tables text area */
      229 	major_args_ptr = add_char_offset_ (addr (text_strings.chars), iodd_static.major_args.first_char - 1);
      230 	major_args_length = iodd_static.major_args.total_chars;
      231 
      232 /* see if user wants major args to be found in a segment */
      233 	major_args_name = iodd_parse_$args ("indirect=", major_args);
      234 	if major_args_name ^= "" then do;		/* yes, grab that segment */
      235 	     call initiate_the_file (major_args_name, major_args_ptr, major_args_length, "major_args", code);
      236 	     if code ^= 0 then
      237 		go to clean_out;
      238 	end;
      239 
      240 	station = iodd_parse_$args ("station=", major_args);	/* station in major must be defined */
      241 	if station = "" then do;			/* station not defined */
      242 	     call iodd_msg_ (error, master, error_table_$fatal_error, myname,
      243 		"No station specified in major args.");
      244 	     go to clean_out;
      245 	end;
      246 
      247 	static_receive_data.version = receive_file_data_version_1;
      248 	static_receive_data.flags = "0"b;		/* clear the default operating modes */
      249 	static_receive_data.testing = iodd_static.test_entry; /* copy the testing bit */
      250 	static_receive_data.request_type = "Undefined!";
      251 	static_receive_data.device_type = 0;		/* illegal value */
      252 	term_info.version = terminal_info_version;	/* set version number once for all possible calls */
      253 	term_info.baud_rate = 0;			/* initialize to no-op just in case */
      254 
      255 	p = iodd_static.driver_ptr;			/* this was set by iodd_ */
      256 
      257 	p -> driver_status.dev_out_iocbp = null ();
      258 	p -> driver_status.dev_ctl_ptr = null ();
      259 
      260 	p -> driver_status.bit_rate_est = 0;		/* no output rate defined yet */
      261 	p -> driver_status.defer_time_limit = 0;	/* make operator specify */
      262 	p -> driver_status.dev_out_stream = "null_stream";
      263 
      264 /* locate minor args for this minor device in the i/o daemon tables text area */
      265 	minor_args_ptr = add_char_offset_ (addr (text_strings.chars), p -> driver_status.minor_args.first_char -1);
      266 	minor_args_length = p -> driver_status.minor_args.total_chars;
      267 
      268 /* see if user wants minor args to be found in a segment */
      269 	minor_args_name = iodd_parse_$args ("indirect=", minor_args);
      270 	if minor_args_name ^= "" then do;		/* yes, grab that segment */
      271 	     call initiate_the_file (minor_args_name, minor_args_ptr, minor_args_length,
      272 		"minor_args", code);
      273 	     if code ^= 0 then
      274 		go to clean_out;
      275 	end;
      276 
      277 	device_type = iodd_parse_$args ("dev=", minor_args);	/* copy for easy reference */
      278 
      279 	if device_type = "reader_out" then do;
      280 	     p -> driver_status.attached = "1"b;	/* we will get requests from coord for this one */
      281 	     call iodd_msg_ (normal, both, 0, "", "^/Initializing reader output device: ^a", p -> driver_status.device_id);
      282 
      283 	     p -> driver_status.generic_type = "punch";	/* we expect user dpunch functions for this one */
      284 
      285 	     call minor_attach (device_type);
      286 
      287 	     p -> driver_status.elem_size = 9;		/* in this driver, this is just a place holder */
      288 	     p -> driver_status.message_type = 2;	/* type of dprint msg expected */
      289 	     p -> driver_status.ready = "1"b;		/* mark as ready to save operator cmd */
      290 
      291 	     call iox_$control (p -> driver_status.dev_out_iocbp, "terminal_info", addr (term_info), code);
      292 	     if code = 0
      293 	     then p -> driver_status.bit_rate_est = term_info.baud_rate;
      294 	     else p -> driver_status.bit_rate_est = initial_punch_rate;
      295 
      296 	     if p -> driver_status.rqti_ptr ^= null then
      297 		call iodd_msg_ (normal, master, 0, myname, "This driver cannot decode an rqti seg.");
      298 	end;
      299 	else if device_type = "printer_in" | device_type = "punch_in" then do;
      300 	     p -> driver_status.attached = "0"b;	/* it is never attached as far as coord knows */
      301 
      302 	     call iodd_msg_ (normal, both, 0, "", "^/Initializing ^[printer^;punch^] input device: ^a",
      303 		(device_type = "printer_in"), p -> driver_status.device_id);
      304 
      305 	     p -> driver_status.generic_type = device_type;
      306 
      307 	     call minor_attach (device_type);
      308 
      309 	     call iox_$control (p -> driver_status.dev_in_iocbp, "read_status", addr (read_info), code);
      310 	     if code ^= 0 then go to clean_out;
      311 
      312 	     sw_info_p = addr (static_sw_info);		/* init the local switch info for receive_file_ */
      313 	     sw_info.version = sw_info_version_1;
      314 	     sw_info.iocbp (1) = iodd_static.master_in;
      315 	     sw_info.ev_chan (1) = iodd_static.chan_list_ptr -> ev_chan_list.channel (1);
      316 	     last = 2;				/* default to 2 channels: master & device */
      317 	     if iodd_static.slave.active then do;	/* 3 channels if there is a slave */
      318 		sw_info.iocbp (last) = iodd_static.slave_in; /* put the salve after the master */
      319 		sw_info.ev_chan (last) = iodd_static.slave_ev_chan; /* for lower priority */
      320 		last = last + 1;			/* bump index of where the last iocbp will go */
      321 	     end;
      322 	     sw_info.iocbp (last) = p -> driver_status.dev_in_iocbp; /* put the device in the last place */
      323 	     sw_info.ev_chan (last) = read_info.read_ev_chan;
      324 	     sw_info.wait_list.n_channels = last;	/* set the list count to the index */
      325 	     sw_info.n_iocb_ptrs = last;		/* also here */
      326 
      327 	     value_string = iodd_parse_$args ("auto_queue=", minor_args);
      328 	     if (value_string = "") | (value_string = "yes") then /* defaults to auto_queue if not given */
      329 		static_receive_data.no_ident, static_receive_data.auto_queue = "1"b;
      330 	     else if (value_string = "no") then
      331 		static_receive_data.no_ident, static_receive_data.auto_queue = "0"b;
      332 	     else do;				/* bad value for the keyword */
      333 		call iodd_msg_ (normal, master, 0, myname,
      334 		     "Invalid ""auto_queue="" argument ""^a"" for minor device ^a.",
      335 		     value_string, p -> driver_status.device_id);
      336 		go to clean_out;
      337 	     end;
      338 
      339 	     if device_type = "printer_in" then		/* set device_type before checking for request types */
      340 		static_receive_data.device_type = printer_input_device;
      341 	     else static_receive_data.device_type = punch_input_device;
      342 
      343 	     value_string = iodd_parse_$args ("request_type=", minor_args);
      344 	     if (value_string = "") then		/* not specified: try rqt keyword */
      345 		value_string = iodd_parse_$args ("rqt=", minor_args);
      346 
      347 	     if (value_string = "") then		/* use default request type */
      348 		static_default_request_type,
      349 		     static_receive_data.request_type = default_request_types (static_receive_data.device_type);
      350 
      351 	     else do;				/* request type was specified */
      352 		if length (value_string) > length (local_request_type) then do;
      353 		     call iodd_msg_ (normal, master, error_table_$bigarg, myname,
      354 			"For minor device ^a: request type name must be less than ^d characters long; not ""^a"".",
      355 			p -> driver_status.device_id, (length (local_request_type) + 1), value_string);
      356 		     go to clean_out;
      357 		end;
      358 		local_request_type = value_string;
      359 		call iod_info_$generic_type (local_request_type, generic_type, code);
      360 		if code ^= 0 then do;
      361 		     call iodd_msg_ (normal, master, code, myname, """^a"" for minor device ^a.",
      362 			local_request_type, p -> driver_status.device_id);
      363 		     go to clean_out;
      364 		end;
      365 		if ((static_receive_data.device_type = printer_input_device) & (generic_type ^= "printer")) |
      366 		     ((static_receive_data.device_type = punch_input_device) & (generic_type ^= "punch"))
      367 		then do;				/* wrong type of request type for this driver */
      368 		     call iodd_msg_ (normal, master, 0, myname,
      369 			"For minor device ^a: request type ""^a"" must be of generic type ^[printer^;punch^]; not ""^a"".",
      370 			p -> driver_status.device_id, local_request_type,
      371 			static_receive_data.device_type, generic_type);
      372 		     go to clean_out;
      373 		end;
      374 		static_default_request_type,
      375 		     static_receive_data.request_type = local_request_type;
      376 	     end;
      377 
      378 	     if iodd_static.test_entry then		/* use a dummy pool root under pool_dir for test */
      379 		pool_dir = rtrim (iodd_static.sys_dir_ptr -> sys_dir) || ">card_pool"; /* the test pool root */
      380 	     else pool_dir = "System_Card_Pool";	/* otherwise use the one coded in */
      381 
      382 	     call pool_manager_$init (pool_dir, 10, "1000"b, code); /* use 10 pages of quota initially */
      383 						/* and set s *.*.* on initial acl of access class pool */
      384 	     if code ^= 0 then do;			/* oops! */
      385 		call iodd_msg_ (normal, master, code, myname, "Unable to initialize card pool.");
      386 		go to clean_out;
      387 	     end;
      388 	end;
      389 	else do;					/* someone slipped in a zinger */
      390 	     call iodd_msg_ (normal, master, 0, myname, "Invalid ""dev="" arg ""^a"" for minor device ^a.",
      391 		device_type, p -> driver_status.device_id);
      392 	     go to clean_out;
      393 	end;
      394 
      395 	call set_iod_val ("station_id", rtrim (station));
      396 
      397 	iodd_static.admin_ec_name = rtrim (station) || "_admin.ec";
      398 
      399 	iodd_static.slave_hold = "1"b;		/* we override the rqti on auto_go */
      400 
      401 
      402 	call date_time_ (clock (), date_string);	/* get set for ready message */
      403 	call iodd_msg_ (normal, both, 0, "", "^/^a driver on channel ^a ready at ^16a^/",
      404 	     iodd_static.major_device, iodd_static.attach_name, date_string);
      405 
      406 	if (device_type = "printer_in") | (device_type = "punch_in")
      407 	then do;					/* check for auto_receive */
      408 	     value_string = iodd_parse_$args ("auto_receive=", minor_args);
      409 	     if (value_string = "yes")
      410 	     then do;
      411 		call iodd_msg_ (normal, source, 0, "", "Waiting for file input.");
      412 		on command_level goto abort_auto_receive; /* grab control after record quota overflow */
      413 		call receive_file_ (pool_dir, addr (static_sw_info), station, addr (static_receive_data), code);
      414 		if code ^= 0 then call iodd_msg_ (normal, source, myname, code, "From receive_file_ ");
      415 abort_auto_receive:
      416 	     end;					/* and go to command level afterwards */
      417 	     else if (value_string = "no")
      418 	     then ;				/* nothing special need be done here */
      419 	     else do;
      420 		call iodd_msg_ (normal, master, 0, myname,
      421 		     "Invalid ""auto_receive="" value ""^a"" for minor device ^a.",
      422 		     value_string, p -> driver_status.device_id);
      423 		go to clean_out;
      424 	     end;
      425 	end;
      426 	else do;					/* don't accept auto_receive for readers */
      427 	     if iodd_parse_$args ("auto_receive=", minor_args) ^= ""
      428 	     then do;
      429 		call iodd_msg_ (normal, master, 0, myname,
      430 		     "auto_receive parameter may not be specified for the reader_in minor device ^a.",
      431 		     p -> driver_status.device_id);
      432 		go to clean_out;
      433 	     end;
      434 	end;
      435 
      436 	call iodd_listen_ (stat_p);
      437 
      438 
      439 clean_out:
      440 
      441 /*  This is only for error recovery during initialization.  The listener will never return here. */
      442 
      443 	call drop_device;
      444 
      445 	return;
      446 
      447 logout_slave:					/* logout the slave device but not the process */
      448 
      449 	iodd_static.re_init_in_progress = "1"b;		/* we do this by re-initializing the driver */
      450 
      451 	call date_time_ (clock (), date_string);	/* get set for message */
      452 	iodd_static.slave.log_msg = "1"b;		/* send to log and slave */
      453 	call iodd_msg_ (log, both, 0, "", "Logout for station: ^a at ^a", station, date_string);
      454 
      455 	call iox_$control (iodd_static.slave_out, "runout", null, code);
      456 
      457 	call iox_$control (iodd_static.slave_out, "end_write_mode", null, code);
      458 
      459 	call drop_device;
      460 
      461 	call iodd_msg_ (normal, master, 0, "", "Driver starting re-initialization.");
      462 
      463 	go to iodd_static.re_init_label;		/* this will do everything */
      464 
      465 /* Issue a hangup to the device before detaching */
      466 
      467 drop_device:
      468      procedure ();
      469 
      470 dcl  send_hangup bit (1);
      471 dcl  p ptr;
      472 
      473 	send_hangup = "1"b;				/* tell close_and_detach proc to send hangup */
      474 	go to device_common;
      475 
      476 detach_device:
      477      entry ();
      478 
      479           send_hangup = "0"b;				/* tell close_and_detach proc to not send hangup */
      480 device_common:
      481 	p = iodd_static.driver_ptr;
      482 
      483 	call close_and_detach (p -> driver_status.dev_out_iocbp, send_hangup);
      484 
      485 	call continue_to_signal_ ((0));		/* in case this is called from a handler */
      486 
      487 	return;
      488 
      489      end drop_device;
      490 
      491 /* This entry is called by iodd_listen_ when a request has been received from the coordinator for the remote device.  Here
      492*   we just check to be sure that we can understand the request format and the requested punch data format.  Then the
      493*   request is passed on to output_request_ which actually handles processing of the request */
      494 
      495 request:
      496      entry ();
      497 
      498 	p = iodd_static.driver_ptr;			/* find the current driver */
      499 	p2 = addr (p -> driver_status.descriptor);	/* find the request descriptor */
      500 	dmp = addr (p -> driver_status.message);	/* get ptr to message */
      501 
      502 	if dmp -> queue_msg_hdr.hdr_version ^= queue_msg_hdr_version_1 then do; /* trouble */
      503 	     call iodd_msg_ (log, both, 0, "", "Invalid message header.  Cannot read request ^d.^d.",
      504 		p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q);
      505 	     p2 -> request_descriptor.keep_in_queue = "1"b; /* save for conversion later */
      506 	     go to be_nice;
      507 	end;
      508 	if dmp -> queue_msg_hdr.message_type ^= p -> driver_status.message_type then do;
      509 	     call iodd_msg_ (log, both, 0, "",		/* log the error */
      510 		"Incorrect message type.^/Request ^d.^d for ^a (segment ^a) not processed.",
      511 		p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q,
      512 		p2 -> request_descriptor.mseg_message_info_copy.sender_id,
      513 		dmp -> queue_msg_hdr.ename);
      514 	     p2 -> request_descriptor.cancelled = "1"b;	/* we don't want this one again */
      515 be_nice:	     p2 -> request_descriptor.dont_delete = "1"b; /* save the user's data */
      516 	     p2 -> request_descriptor.finished = "1"b;	/* mark it done */
      517 	     return;				/* it wasn't for us after all */
      518 	end;
      519 	if dprint_msg.version ^= dprint_msg_version_5	/* Current version */
      520 	& dprint_msg.version ^= dprint_msg_version_4	/* Previous version */
      521 	& dprint_msg.version ^= dprint_msg_version_3	/* Previous version */
      522 	then do;					/* other trouble? */
      523 	     call iodd_msg_ (log, both, 0, "",
      524 		"Wrong message version found.^/Request ^d.^d for ^a (segment ^a) not processed",
      525 		p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q,
      526 		p2 -> request_descriptor.mseg_message_info_copy.sender_id,
      527 		dmp -> queue_msg_hdr.ename);
      528 	     p2 -> request_descriptor.keep_in_queue = "1"b;
      529 	     go to be_nice;
      530 	end;
      531 	if dprint_msg.version < dprint_msg_version_4 then /* Disallow line numbers before version 4 */
      532 	     dprint_msg.control.line_nbrs = "0"b;
      533 
      534 	format_code = dprint_msg.output_module;		/* get the user defined format */
      535 
      536 	if format_code = punch_rmcc_mode then do;	/* for character output */
      537 	     element_size = 9;			/* for output_request_ */
      538 	end;
      539 	else do;					/* be sure it is defined */
      540 	     call iodd_msg_ (log, both, 0, "",
      541 		"Illegal output format in user request.^/Request ^d.^d for ^a (segment ^a) not processed",
      542 		p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q,
      543 		p2 -> request_descriptor.mseg_message_info_copy.sender_id,
      544 		dmp -> queue_msg_hdr.ename);
      545 	     p2 -> request_descriptor.cancelled = "1"b;	/* we don't want this one again */
      546 	     go to be_nice;
      547 	end;
      548 
      549 	iodd_static.quit_during_request = "0"b;		/* start clean */
      550 
      551 	on cleanup begin;
      552 	     call iox_$control (p -> driver_status.dev_out_iocbp, "end_write_mode", null, (0));
      553 	end;
      554 
      555 	call output_request_ ((p -> driver_status.dev_out_stream), element_size, stat_p, print_banner, code);
      556 	if code ^= 0 then do;
      557 	     iodd_static.slave_hold = "1"b;		/* on errors go to command level for guidance */
      558 	     if code = error_table_$io_no_permission then do; /* in case of hangup... */
      559 		call iodd_msg_ (error, master, code, myname,
      560 		     "Device in inconsistent state or hungup.  Must re-initialize.");
      561 		signal re_init;
      562 	     end;
      563 	end;
      564 
      565 	call iox_$control (p -> driver_status.dev_out_iocbp, "end_write_mode", null, code);
      566 	if code = 0 then do;			/* we were able to release the line */
      567 	     call timer_manager_$sleep (time, "11"b);	/* sleep a few seconds */
      568 						/* so remote device can send if needed */
      569 	end;
      570 	else if code = error_table_$undefined_order_request then do; /* this is ok also */
      571 	     if iodd_static.test_entry then		/* be able to set a reasonable pace */
      572 		if time > 1 then call timer_manager_$sleep (time, "11"b); /* simulate device */
      573 	end;
      574 	else do;					/* this is a real error */
      575 	     call iodd_msg_ (error, master, code, myname, "From ""end_write_mode"" control");
      576 	     iodd_static.slave_hold = "1"b;
      577 	end;
      578 
      579 	if iodd_static.slave.active then		/* flush any messages */
      580 	     call iox_$control (iodd_static.slave_out, "runout", null, code);
      581 
      582 	return;
      583 
      584 /* For this driver, this entry is almost a no-op:  we do not send banners around our reader output to the host */
      585 
      586 print_banner:
      587      entry (a_stream, a_banner_type, a_data_ptr, a_code);
      588 
      589 	banner_type = a_banner_type;
      590 	a_code, code = 0;
      591 
      592 	p = iodd_static.driver_ptr;			/* save driver_ptr in short name variable */
      593 	p2 = addr (p -> driver_status.descriptor);	/* get descriptor ptr just in case */
      594 
      595 	if banner_type = head_banner then do;		/* reset the accounting data for each request copy */
      596 	     call iox_$control (p -> driver_status.dev_out_iocbp, "reset", null, code);
      597 	end;
      598 
      599 
      600 	a_code = code;
      601 	if code ^= 0 then
      602 	     p2 -> request_descriptor.keep_in_queue = "1"b; /* defer the request */
      603 
      604 	return;
      605 
      606 /* Process a driver command */
      607 
      608 command:
      609      entry (a_source, a_state, a_argp, a_code);
      610 
      611 	argp = a_argp;				/* define the arg_list structure which contains "command" */
      612 	source = a_source;
      613 	state = a_state;
      614 
      615 	on conversion begin;			/* handler for conversion errors */
      616 	     call iodd_msg_ (normal, source, 0, "", "Argument conversion error. Try again.");
      617 	     go to cmd_error;
      618 	end;
      619 
      620 	save_code = a_code;				/* save the called value */
      621 	a_code, code = 0;				/* say we handled it for now */
      622 
      623 	if command = "help" then do;
      624 	     call iodd_msg_ (normal, source, 0, "", "^/** Commands for the HASP workstation simulator driver **^/");
      625 	     if static_receive_data.device_type ^= 0 then do; /* an input device (printer or punch) */
      626 		call iodd_msg_ (normal, source, 0, "", "receive");
      627 		call iodd_msg_ (normal, source, 0, "", "auto_queue  yes | no");
      628 		call iodd_msg_ (normal, source, 0, "", "request_type  rqt_name");
      629 		call iodd_msg_ (normal, source, 0, "", "clean_pool  <days allowed to remain>");
      630 	     end;
      631 	     else do;				/* output device (reader) */
      632 		call iodd_msg_ (normal, source, 0, "", "pause_time [<delay_time_between_requests>]");
      633 		call iodd_msg_ (normal, source, 0, "", "single");
      634 	     end;
      635 	     go to end_cmd;
      636 	end;
      637 
      638 
      639 	if command = "pause_time" | command = "pausetime" then do;
      640 	     if static_receive_data.device_type ^= 0 then do; /* only valid for output devices */
      641 		call iodd_msg_ (normal, source, 0, "", "Invalid command for this type of device.");
      642 		go to cmd_error;
      643 	     end;
      644 	     if arg_list.n_tokens > 1 then do;
      645 		value = convert (value, arg_list.arg (1));
      646 		if value < 0 | value > 30 then do;
      647 		     call iodd_msg_ (normal, source, 0, "", "pause_time range: 0 to 30 seconds ");
      648 		     go to cmd_error;
      649 		end;
      650 		time = value;
      651 		go to end_cmd;
      652 	     end;
      653 	     else do;
      654 		time = 10;			/* return to the default */
      655 		go to end_cmd;
      656 	     end;
      657 	end;
      658 
      659 
      660 	if command = "single" then do;		/* make a single copy of the current request */
      661 	     if static_receive_data.device_type ^= 0 then do; /* only valid for output devices */
      662 		call iodd_msg_ (normal, source, 0, "", "Invalid command for this type of device.");
      663 		go to cmd_error;
      664 	     end;
      665 	     if iodd_static.request_in_progress then do;
      666 		iocbp = iodd_static.driver_ptr -> driver_status.dev_out_iocbp;
      667 		call iox_$modes (iocbp, "single", omode, ignore); /* set single mode */
      668 		call output_request_$set_single_copy ();
      669 	     end;
      670 	     else call iodd_msg_ (normal, source, 0, "", "No current request.");
      671 	     go to end_cmd;
      672 	end;
      673 
      674 
      675 	if command = "receive" then do;
      676 	     if static_receive_data.device_type = 0 then do; /* only valid for input devices */
      677 		call iodd_msg_ (normal, source, 0, "", "Invalid command for this type of device.");
      678 		go to cmd_error;
      679 	     end;
      680 
      681 	     call iodd_msg_ (normal, source, 0, "", "Waiting for file input.");
      682 
      683 	     on command_level goto abort_read;		/* grab control after record quota overflow */
      684 
      685 	     call receive_file_ (pool_dir, addr (static_sw_info), station, addr (static_receive_data), code);
      686 	     if code ^= 0 then call iodd_msg_ (normal, source, myname, code, "From receive_file_ ");
      687 
      688 	     go to end_cmd;
      689 
      690 abort_read:    call iodd_msg_ (normal, source, 0, "", "Use the ""clean_pool"" command and retry card input.");
      691 	     go to cmd_error;
      692 	end;
      693 
      694 
      695 	if command = "auto_queue" | command = "autoqueue" then do;
      696 	     if static_receive_data.device_type = 0 then do; /* wrong driver type */
      697 		call iodd_msg_ (normal, source, 0, "", "Invalid command for this type of device.");
      698 		go to cmd_error;
      699 	     end;
      700 
      701 	     if arg_list.n_tokens < 2 then do;		/* must define what he wants */
      702 		call iodd_msg_ (normal, source, 0, "", "Argument yes or no must be given.");
      703 		go to cmd_error;
      704 	     end;
      705 
      706 	     if arg_list.arg (1) = "yes" then
      707 		static_receive_data.no_ident,		/* don't look for ++IDENT */
      708 		     static_receive_data.auto_queue = "1"b; /* queue request to print/punch file */
      709 	     else if arg_list.arg (1) = "no" then
      710 		static_receive_data.no_ident,		/* look gor ++IDENT */
      711 		     static_receive_data.auto_queue = "0"b; /* don't queue request to print/punch file */
      712 	     else do;
      713 		call iodd_msg_ (normal, source, 0, "", "Argument must be either yes or no.");
      714 		go to cmd_error;
      715 	     end;
      716 	     go to end_cmd;
      717 	end;
      718 
      719 
      720 	if command = "request_type" | command = "requesttype" | command = "rqt" then do;
      721 	     if static_receive_data.device_type = 0 then do; /* wrong type of driver (input only) */
      722 		call iodd_msg_ (normal, source, 0, "", "Invalid command for this type of device.");
      723 		go to cmd_error;
      724 	     end;
      725 
      726 	     if arg_list.n_tokens < 2 then do;		/* default to the type specified in iod_tables */
      727 		static_receive_data.request_type = static_default_request_type;
      728 		go to end_cmd;
      729 	     end;
      730 
      731 	     if length (arg_list.arg (1)) > length (local_request_type) then do;
      732 		call iodd_msg_ (normal, source, error_table_$bigarg, myname,
      733 		     "Request type name must be less than ^d characters long; not ""^a"".",
      734 		     (length (local_request_type) + 1), arg_list.arg (1));
      735 		go to cmd_error;
      736 	     end;
      737 
      738 	     local_request_type = arg_list.arg (1);	/* get the request type */
      739 	     call iod_info_$generic_type (local_request_type, generic_type, code);
      740 	     if code ^= 0 then do;
      741 		call iodd_msg_ (normal, source, code, myname, "^a", local_request_type);
      742 		go to cmd_error;
      743 	     end;
      744 
      745 	     if ((static_receive_data.device_type = printer_input_device) & (generic_type ^= "printer")) |
      746 		((static_receive_data.device_type = punch_input_device) & (generic_type ^= "punch"))
      747 	     then do;				/* wrong type of request type for this driver */
      748 		call iodd_msg_ (normal, source, 0, "",
      749 		     "Request type ""^a"" must be of generic type ^[printer^;punch^]; not ""^a"".",
      750 		     local_request_type, static_receive_data.device_type, generic_type);
      751 		go to cmd_error;
      752 	     end;
      753 
      754 	     static_receive_data.request_type = local_request_type;
      755 	     go to end_cmd;
      756 	end;
      757 
      758 
      759 	if command = "clean_pool" | command = "cleanpool" then do; /* garbage collect the card pool */
      760 	     if static_receive_data.device_type = 0 then do; /* only valid for input devices */
      761 		call iodd_msg_ (normal, source, 0, "", "Invalid command for this type of device.");
      762 		go to cmd_error;
      763 	     end;
      764 	     if source = slave then do;
      765 		call iodd_msg_ (normal, source, 0, "", "The clean_pool command is restricted to the master terminal.");
      766 		go to cmd_error;
      767 	     end;
      768 	     if arg_list.n_tokens < 2 then do;		/* we must have an age arg */
      769 		call iodd_msg_ (normal, source, 0, "", "Argument missing: days allowed to remain in the pool.");
      770 		go to cmd_error;
      771 	     end;
      772 	     age = convert (age, arg_list.arg (1));	/* convert to binary */
      773 	     if age < 1 then do;			/* be sure the value is right */
      774 		call iodd_msg_ (normal, source, 0, "", "Invalid argument: ^a", arg_list.arg (1));
      775 		go to cmd_error;
      776 	     end;
      777 
      778 	     call pool_manager_$clean_pool (pool_dir, age, 10, code); /* let pool_manager_ do the work */
      779 	     if code ^= 0 then
      780 		call iodd_msg_ (normal, source, code, myname, "Unable to clean up pool storage.");
      781 	     go to end_cmd;
      782 	end;
      783 
      784 
      785 /* When control passes here, the command is unknown: just return and let iodd_command_processor_ handle it */
      786 
      787 	a_code = save_code;
      788 	return;
      789 
      790 end_cmd:
      791 
      792 	a_code = code;				/* pass back any defined errors */
      793 	return;
      794 
      795 cmd_error:
      796 
      797 	a_code = error_table_$action_not_performed;	/* cause a resetread */
      798 	return;
      799 
      800 default_handler: entry (condition_info_ptr);
      801 
      802 dcl  condition char (32);				/* fixed string for the call */
      803 
      804 	condition = condition_info.condition_name;	/* this will indent funny */
      805 	if iodd_static.request_in_progress then
      806 	     call output_request_$error_during_request (condition); /* take it away */
      807 
      808 	return;					/* output_request_ should not return, but.... */
      809 
      810 close_and_detach: proc (a_iocbp, send_hangup);
      811 
      812 dcl  a_iocbp ptr;
      813 dcl  send_hangup bit (1);
      814 dcl  code fixed bin (35);				/* local error code */
      815 
      816 	if a_iocbp = null then return;
      817 
      818 	if send_hangup then call iox_$control (a_iocbp, "hangup", null, code);
      819 
      820 	call iox_$close (a_iocbp, code);
      821 	call iox_$detach_iocb (a_iocbp, code);
      822 
      823 	a_iocbp = null;
      824 
      825 	return;
      826 
      827      end close_and_detach;
      828 
      829 minor_attach: procedure (Device);
      830 
      831 dcl  Device char (*) parameter;
      832 dcl  desc char (256) varying;
      833 dcl  io_module char (32) var;
      834 dcl  dev_opt char (32) var;
      835 dcl  mode fixed bin;
      836 
      837 	if Device = "reader_out" then do;		/* for this one we are simulating a reader to the host */
      838 	     io_module = "remote_punch_";		/* use the special feature of the punch io module */
      839 	     dev_opt = "reader_simulator";		/* by the special -device option */
      840 	     mode = Stream_output;			/* open mode is for stream output */
      841 	end;
      842 	else do;					/* otherwise, we are receiving print/punch files */
      843 	     io_module = "remote_input_";		/* so use the other type io module */
      844 	     dev_opt = rtrim (Device);		/* this will be printer_in or punch_in, don't care which */
      845 	     mode = Stream_input;			/* open mode is for stream input */
      846 	end;
      847 
      848 	desc = io_module || " -tty " || rtrim (iodd_static.attach_name); /* build the attach description */
      849 	desc = desc || space || iodd_parse_$args ("desc=", major_args);
      850 	desc = desc || space || iodd_parse_$args ("desc=", minor_args);
      851 
      852 	desc = desc || " -device " || dev_opt;		/* be sure this is last */
      853 
      854 	p -> driver_status.dev_out_stream = get_switch_name (Device);
      855 
      856 	call iox_$attach_ioname ((p -> driver_status.dev_out_stream), p -> driver_status.dev_out_iocbp,
      857 	     (desc), code);
      858 	if code ^= 0 & code ^= error_table_$not_detached & code ^= error_table_$ionmat then goto attach_error;
      859 
      860 	call iox_$open (p -> driver_status.dev_out_iocbp, mode, ""b, code);
      861 	if code ^= 0 & code ^= error_table_$not_closed then do;
      862 attach_error:  call iodd_msg_ (error, master, code, myname,
      863 		"Attaching minor device:  ^a^/Attach desc:  ^a.", p -> driver_status.device_id, desc);
      864 	     goto clean_out;
      865 	end;
      866 
      867 	p -> driver_status.dev_in_iocbp = p -> driver_status.dev_out_iocbp; /* make them the same */
      868 
      869 	call set_hangup_proc (p -> driver_status.dev_out_iocbp);
      870 
      871      end minor_attach;
      872 
      873 
      874 
      875 get_switch_name: procedure (Device) returns (character (32));
      876 
      877 declare  index fixed bin internal static init (0);
      878 declare  Device char (*);
      879 
      880 	index = index + 1;
      881 	if index > 999 then index = 1;		/* keep it reasonable */
      882 	return (Device || "_" || ltrim (character (index)));
      883 
      884      end get_switch_name;
      885 
      886 set_hangup_proc: proc (iocbp);
      887 
      888 dcl  iocbp ptr;
      889 
      890 /* this internal proc will set the device hangup procedure for the specified switch */
      891 
      892 	hangup_info.entry = iodd_hangup_$iodd_hangup_;
      893 	hangup_info.data_ptr = stat_p;
      894 	hangup_info.priority = 1;
      895 
      896 	call iox_$control (iocbp, "hangup_proc", addr (hangup_info), code);
      897 	if code ^= 0 then do;
      898 	     call iodd_msg_ (error, master, code, myname, "Fatal error.  Unable to set hangup proc.");
      899 	     goto clean_out;
      900 	end;
      901 
      902 	return;
      903 
      904      end set_hangup_proc;
      905 
      906 
      907 initiate_the_file:
      908      proc (pathname_string, args_ptr, args_length, message, code);
      909 
      910 dcl  pathname_string char (256) varying;
      911 dcl  args_ptr ptr;
      912 dcl  args_length fixed bin;
      913 dcl  message char (*);
      914 dcl  code fixed bin (35);
      915 
      916 dcl  dirname char (168);
      917 dcl  entname char (32);
      918 dcl  compname char (32);
      919 dcl  args_bc fixed bin (24);
      920 
      921 	call expand_pathname_$component ((pathname_string), dirname, entname, compname, code);
      922 	if code ^= 0 then
      923 	     return;
      924 	call initiate_file_$component (dirname, entname, compname, R_ACCESS, args_ptr, args_bc, code);
      925 	if code ^= 0 then
      926 	     return;
      927 	args_length = divide (args_bc + 8, 9, 17, 0);
      928 
      929      end initiate_the_file;
      930  /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      930 
      931  /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  2     2 
  2     3 /* Structure for find_condition_info_.
  2     4*
  2     5*   Written 1-Mar-79 by M. N. Davidoff.
  2     6**/
  2     7 
  2     8 /* automatic */
  2     9 
  2    10      declare condition_info_ptr     pointer;
  2    11 
  2    12 /* based */
  2    13 
  2    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  2    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  2    16 	     2 version	      fixed binary,		/* Must be 1 */
  2    17 	     2 condition_name     char (32) varying,	/* name of condition */
  2    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  2    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  2    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  2    21 	     2 flags	      unaligned,
  2    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  2    23 	       3 pad1	      bit (35),
  2    24 	     2 pad2	      bit (36),
  2    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  2    26 	     2 pad3	      (4) bit (36);
  2    27 
  2    28 /* internal static */
  2    29 
  2    30      declare condition_info_version_1
  2    31 			      fixed binary internal static options (constant) initial (1);
  2    32 
  2    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
      931 
      932  /* BEGIN INCLUDE FILE ... dprint_msg.incl.pl1 */
  3     2 /* Modified: November 1983 by C. Marker Added no_separator. */
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(87-05-10,Gilcrease), approve(87-05-13,MCR7686),
  3     6*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
  3     7*     Add line_nbrs bit for line-numbered printouts, version 4.
  3     8*  2) change(88-02-05,Farley), approve(88-02-05,PBF7686), audit(88-02-05,GWMay),
  3     9*     install(88-02-05,MR12.2-1022):
  3    10*     Corrected alignment of line_nbrs, was aligned s/b unaligned..
  3    11*  3) change(88-08-23,Farley), approve(88-09-16,MCR7911),
  3    12*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  3    13*     Increased size of forms field to 64 characters (was only 24), which
  3    14*     updates the version to 5.
  3    15*                                                   END HISTORY COMMENTS */
  3    16 
  3    17 
  3    18 dcl  dmp ptr;					/* ptr to message */
  3    19 
  3    20 dcl 1 dprint_msg based (dmp) aligned,			/* structure of a IO daemon print or punch request */
  3    21     2 header like queue_msg_hdr,			/* header for all standard queue messages */
  3    22     2 version fixed bin,				/* version of the dprint_msg used */
  3    23     2 copies fixed bin,				/* number of copies user requested */
  3    24     2 bit_count fixed bin (35),			/* the bitcount of the segment at request time */
  3    25     2 output_module fixed bin,			/* 1=print, 2=7punch, 3= mcc, 4=raw */
  3    26     2 control,					/* control flags. */
  3    27       3 nep bit (1) unal,				/* TRUE if printing over perforations */
  3    28       3 single bit (1) unal,				/* TRUE if ignore FF and VT */
  3    29       3 non_edited bit (1) unal,			/* TRUE if printing in non-edited mode */
  3    30       3 truncate bit (1) unal,			/* TRUE if truncating lines at line length */
  3    31       3 esc bit (1) unal,				/* TRUE if text escapes are to be processed */
  3    32       3 center_top_label bit (1) unal,			/* TRUE if top label to be centered */
  3    33       3 center_bottom_label bit (1) unal,		/* TRUE if bottom label to be centered */
  3    34       3 no_separator bit(1) unal,                           /* TRUE if the inner head a tail sheets of multiple copies are to be suppressed. */
  3    35       3 line_nbrs bit (1) unal,			/* TRUE if line numbers wanted */
  3    36       3 padding bit (27) unal,
  3    37     2 lmargin fixed bin,				/* indent from the left */
  3    38     2 line_lth fixed bin,				/* logical line length */
  3    39     2 page_lth fixed bin,				/* logical page length */
  3    40     2 heading_lth fixed bin,				/* number of chars in heading */
  3    41     2 top_label_lth fixed bin,			/* number of chars in the top label */
  3    42     2 bottom_label_lth fixed bin,			/* number of chars in bottom label */
  3    43     2 chan_stop_path_lth fixed bin,			/* number of chars in channel stop pathname */
  3    44     2 forms_name_lth fixed bin,			/* number of chars in forms name */
  3    45     2 future_fb_values (7) fixed bin,			/* make future versions possible */
  3    46     2 forms char (24),				/* name of special forms, or blank */
  3    47     2 destination char (24),				/* routing for output */
  3    48     2 heading char (head_max_lth refer (dprint_msg.heading_lth)), /* heading on page 1 */
  3    49     2 top_label char (label_max_lth refer (dprint_msg.top_label_lth)), /* top page heading for each page */
  3    50     2 bottom_label char (label_max_lth refer (dprint_msg.bottom_label_lth)), /* bottom page heading */
  3    51     2 chan_stop_path char (path_max_lth refer (dprint_msg.chan_stop_path_lth)), /* path of rqti seg with channel stops */
  3    52     2 forms_name char (forms_max_lth refer (dprint_msg.forms_name_lth)); /* forms name string */
  3    53 
  3    54 
  3    55 dcl  (
  3    56      head_max_lth init (64),				/* allocation size for heading */
  3    57      label_max_lth init (136),			/* allocation size for label fields */
  3    58      path_max_lth init (168),				/* allocation size for pathname fields */
  3    59      forms_max_lth init (64)				/* allocation size for forms name string */
  3    60      ) fixed bin int static options (constant);
  3    61 
  3    62 dcl  (
  3    63      dprint_msg_version_3 init (3),
  3    64      dprint_msg_version_4 init (4),
  3    65      dprint_msg_version_5 init (5)			/* current version */
  3    66      ) fixed bin int static options (constant);
  3    67 
  3    68 /* END INCLUDE FILE ... dprint_msg.incl.pl1 */
      932 
      933  /* BEGIN INCLUDE FILE ... driver_ptr_list.incl.pl1   */
  4     2 
  4     3 /* This is a list of pointers to the driver status segments used by this process */
  4     4 
  4     5 
  4     6 
  4     7 dcl list_ptr pointer;		/* should be set to iodd_static.driver_list_ptr */
  4     8 
  4     9 dcl 1 driver_ptr_list based(list_ptr),
  4    10        2 number fixed bin,		/* number of pointer entries */
  4    11        2 list_pad fixed bin,		/* pad to even word boundry */
  4    12        2 stat_seg(0 refer(driver_ptr_list.number)),
  4    13           3 stat_segp ptr;		/* pointer to driver status seg(i) */
  4    14 
  4    15 
  4    16 /* END INCLUDE FILE ... driver_ptr_list.incl.pl1  */
      933 
      934  /* BEGIN INCLUDE FILE...driver_status.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  5     7*     Ancient History
  5     8*     Coded by Robert S. Coren August 1973
  5     9*     Modified by J. Whitmore to structure data for the Access Isolation Mechanism
  5    10*     Modified by J. C. Whitmore, 5/78, for IO Daemon extensions
  5    11*     Modified by J. C. Whitmore, 8/79, to add the generic_type variable
  5    12*  2) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
  5    13*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  5    14*     Upgraded for version 5 iod tables.  Changed the minor_args ftom string to
  5    15*     text_offset. Changed acct_ptr to acct_entry.  Added have_accounting bit
  5    16*     to denote accounting ^= nothing.
  5    17*                                                   END HISTORY COMMENTS */
  5    18 
  5    19 
  5    20 /* status data for a logical device driver */
  5    21 
  5    22 /* format: style4 */
  5    23 
  5    24 dcl  driver_status_ptr ptr;
  5    25 dcl  1 driver_status aligned based (driver_status_ptr),
  5    26        2 req_type_label char (32),			/* string to describe the request type */
  5    27        2 dev_name_label char (32),			/* string to describe the device */
  5    28        2 device_id char (32),				/* minor device name used by this logical driver */
  5    29        2 device_class_id char (32),			/* device class name used by this logical driver */
  5    30        2 coord_chan fixed bin (71),			/* ipc event channel for signals to coord. */
  5    31        2 driver_chan fixed bin (71),			/* ipc event channel for signals from coord. */
  5    32        2 last_wake_time fixed bin (71),			/* time last wakeup sent to coord */
  5    33        2 request_pending bit (36),			/* locking word for communication with coord */
  5    34 						/* 0 = ready for a request  */
  5    35 						/* driver pid = don't bug me */
  5    36 						/* coord  pid = got a request */
  5    37        2 status_flags,
  5    38          3 attached bit (1) unal,			/* minor device is attached for i/o */
  5    39          3 busy bit (1) unal,				/* driver doing request..tell coord when done */
  5    40          3 ready bit (1) unal,			/* driver is ready to handle requests */
  5    41          3 acknowledge bit (1) unal,			/* coordinator must reply to all wakeups */
  5    42          3 have_accounting bit (1) unal,		/* ON if accounting ^= nothing */
  5    43          3 pad bit (31) unal,
  5    44        2 list_index fixed bin,			/* index of this driver in the driver ptr list */
  5    45        2 dev_index fixed bin,				/* index in iod_device_tab of this minor device */
  5    46        2 maj_index fixed bin,				/* index in iod_device_tab of the corresponding major device */
  5    47        2 dev_class_index fixed bin,			/* index of device_class entry */
  5    48        2 minor_args unaligned like text_offset,		/* descriptive string for this minor device */
  5    49        2 min_banner bit (72) aligned,			/* min banner access class for marking output */
  5    50        2 acct_entry entry (char (*), char (*), ptr, fixed bin (35)) variable, /* entry variable to accounting procedure */
  5    51 						/* for this logical driver */
  5    52        2 rqti_ptr ptr,				/* pointer to the request type info seg */
  5    53        2 dev_out_iocbp ptr,				/* iocb pointer for dev_out_stream */
  5    54        2 dev_in_iocbp ptr,				/* iocb pointer for dev_in_stream */
  5    55        2 dev_out_stream char (32),			/* output stream for minor device */
  5    56        2 dev_in_stream char (32),			/* input stream for minor device */
  5    57        2 elem_size fixed bin,				/* element size for the stream */
  5    58        2 message_type fixed bin,			/* expected format of user request */
  5    59        2 form_wait_time fixed bin (71),			/* average time needed to write ctl term msg */
  5    60        2 forms_validation_ptr ptr,			/* forms validation data */
  5    61        2 dev_ptr1 ptr,				/* another one */
  5    62        2 dev_fb1 fixed bin,				/* a spare fixed bin variable for the driver */
  5    63        2 dev_fb2 fixed bin,				/* and another */
  5    64        2 dev_fb3 fixed bin,				/* and another */
  5    65        2 dev_fb4 fixed bin,				/* and the last spare fixed bin */
  5    66        2 dev_fb71 fixed bin (71),			/* a spare fixed bin  71  variable */
  5    67        2 dev_ctl_ptr ptr,				/* pointer to control structure for this device */
  5    68        2 bit_rate_est fixed bin (35),			/* output rate estimate - bits per second */
  5    69        2 defer_time_limit fixed bin (35),		/* max time allowed for a request - in seconds (0 = no limit) */
  5    70        2 generic_type char (32),			/* generic type of this minor device */
  5    71        2 status_pad (2) fixed bin (35),			/* save some room for later */
  5    72        2 descriptor like request_descriptor,		/* copy of request descriptor */
  5    73        2 desc_pad (13) fixed bin,
  5    74        2 message fixed bin;				/* place-holder for copy of request message */
  5    75 
  5    76 
  5    77 /* END INCLUDE FILE...driver_status.incl.pl1 */
      934 
      935  /* BEGIN INCLUDE FILE - find_input_sw_info.incl.pl1 */
  6     2 
  6     3 /* this is the structure to be used with the find_input_switch_ subroutine */
  6     4 
  6     5 dcl  sw_info_p ptr;					/* automatic pointer for the based structure */
  6     6 
  6     7 dcl 1 sw_info aligned based (sw_info_p),
  6     8     2 version fixed bin,				/* version of this structure */
  6     9     2 n_iocb_ptrs fixed bin,				/* number of active switches in iocbp array */
  6    10     2 iocbp (10) ptr,				/* array of iocb ptrs we are using */
  6    11     2 wait_list,					/* wait list for blocking on read events */
  6    12 						/* there is one entry for each active iocbp */
  6    13       3 n_channels fixed bin,				/* must equal n_iocb_ptrs, must be even word aligned */
  6    14       3 pad fixed bin,				/* breakage */
  6    15       3 ev_chan (10) fixed bin (71);			/* one event channel for each active iocbp */
  6    16 
  6    17 dcl  sw_info_version_1 fixed bin int static options (constant) init (1);
  6    18 
  6    19 /* END INCLUDE FILE - find_input_sw_info.incl.pl1 */
      935 
      936  /* BEGIN INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
  7     2 
  7     3 
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  7     7*     Ancient History
  7     8*     Created by J. Stern, 1/20/75
  7     9*     Modified by J. C. Whitmore April 1978 for enhancements
  7    10*     Modified by J. C. Whitmore, 10/78, for version 3 iod_tables format.
  7    11*     Modified by E. N. Kittlitz, 6/81, for version 4 iod_tables with expanded
  7    12*     q_group_tab
  7    13*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  7    14*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  7    15*     Change version number to reflect changes in q_group_tab and
  7    16*     iod_device_tab for laser printer support.  Added font tables.
  7    17*                                                   END HISTORY COMMENTS */
  7    18 
  7    19 
  7    20 /* format: style4 */
  7    21 
  7    22 dcl  ithp ptr;					/* ptr to io daemon dables and it's header */
  7    23 dcl  1 iod_tables_hdr aligned based (ithp),		/* header of data segment compiled by iod_table_compiler */
  7    24        2 version char (8),				/* version of this structure */
  7    25        2 date_time_compiled fixed bin (71),
  7    26        2 grace_time fixed bin (71),			/* grace time before deleting finished segment */
  7    27        2 max_queues fixed bin (17),			/* default number of priority queues per queue group */
  7    28        2 line_tab_offset fixed bin (18),		/* offset of line id table */
  7    29        2 device_tab_offset fixed bin (18),		/* offset of device table */
  7    30        2 minor_device_tab_offset fixed bin (18),		/* offset of minor device table */
  7    31        2 dev_class_tab_offset fixed bin (18),		/* offset of device class table */
  7    32        2 q_group_tab_offset fixed bin (18),		/* offset of queue group table */
  7    33        2 forms_info_tab_offset fixed bin (18),		/* offset of forms info tables */
  7    34        2 text_strings_offset fixed bin (18),
  7    35        2 start_of_tables fixed bin;			/* beginning of above tables, MUST start on even word boundry */
  7    36 
  7    37 /* Defines common text block to store virtually all text in the I/O daemon tables */
  7    38 dcl  text_strings_ptr ptr;
  7    39 dcl  1 text_strings aligned based (text_strings_ptr),
  7    40        2 length fixed bin,
  7    41        2 chars char (1 refer (text_strings.length)) unaligned;
  7    42 
  7    43 /* this defines text offsets used to locate i/o daemon tables strings in
  7    44*   the text_strings structure */
  7    45 dcl  1 text_offset based,
  7    46        2 first_char fixed bin (18) unsigned unaligned,
  7    47        2 total_chars fixed bin (18) unsigned unaligned;
  7    48 
  7    49 dcl  IODT_VERSION_5 char (8) int static options (constant) init ("IODT0005"); /* current version number */
  7    50 
  7    51 
  7    52 /* END INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
      936 
      937  /* BEGIN INCLUDE FILE ... iod_constants.incl.pl1 */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(88-08-31,Brunelle), approve(88-08-31,MCR7911),
  8     6*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  8     7*     Created.
  8     8*                                                   END HISTORY COMMENTS */
  8     9 
  8    10 /* This file contains constants used by the I/O Daemon software in various tables */
  8    11 
  8    12 /* format: style4 */
  8    13 
  8    14 /* literals for use with idte.attach_type & iodd_static.attach_type */
  8    15 dcl  (ATTACH_TYPE_IOM init (1),
  8    16      ATTACH_TYPE_TTY init (2),
  8    17      ATTACH_TYPE_DIAL init (3),
  8    18      ATTACH_TYPE_VARIABLE_LINE init (4)) fixed bin int static options (constant);
  8    19 
  8    20 /* literals for use with idte.ctl_attach_type & iodd_static.ctl_attach_type */
  8    21 dcl  (CTL_ATTACH_TYPE_TTY init (1),
  8    22      CTL_ATTACH_TYPE_DIAL init (2),
  8    23      CTL_ATTACH_TYPE_MC init (3)) fixed bin int static options (constant);
  8    24 
  8    25 /* literals for use with idte.paper_type & iodd_static.paper_type */
  8    26 dcl  (PAPER_TYPE_DEFAULT init (-1),
  8    27      PAPER_TYPE_SINGLE init (1),
  8    28      PAPER_TYPE_CONTINUOUS init (2)) fixed bin int static options (constant);
  8    29 
  8    30 /* END INCLUDE FILE ... iod_constants.incl.pl1 */
      937 
      938  /* BEGIN INCLUDE FILE...iodd_static.incl.pl1 */
  9     2 
  9     3 
  9     4 /****^  HISTORY COMMENTS:
  9     5*  1) change(85-02-14,Homan), approve(87-04-06,MCR7656),
  9     6*     audit(87-06-13,Beattie), install(87-08-06,MR12.1-1068):
  9     7*     Add support for logout_on_hangup option.
  9     8*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  9     9*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  9    10*     Add head/tail_sheet entry variables and paper_type variable.
  9    11*                                                   END HISTORY COMMENTS */
  9    12 
  9    13 /* format: style4 */
  9    14 
  9    15 dcl  stat_p int static ptr;
  9    16 
  9    17 dcl  1 iodd_static based (stat_p) aligned,
  9    18 
  9    19 /*    The first part is set only once for a device driver */
  9    20 
  9    21        2 ithp ptr,					/* pointer to iod tables header */
  9    22        2 ltp ptr,					/* pointer to line table */
  9    23        2 idtp ptr,					/* pointer to device tab */
  9    24        2 mdtp ptr,					/* pointer to minor device table */
  9    25        2 qgtp ptr,					/* pointer to q_group table */
  9    26        2 dev_class_ptr ptr,				/* pointer to device class table */
  9    27        2 text_strings_ptr ptr,			/* pointer to iod tables text strings */
  9    28        2 driver_list_ptr ptr,				/* pointer to list of driver status seg pointers */
  9    29        2 chan_list_ptr ptr,				/* pointer to list of event channels for blocking */
  9    30        2 sys_dir_ptr ptr,				/* ptr to 168 char string defining sys_dir */
  9    31        2 coord_proc_id bit (36),			/* process id of coordinator for wakeups */
  9    32        2 driver_proc_id bit (36),			/* process id of driver for locking */
  9    33        2 re_init_label label,				/* where to go after "re_init" or "slave_logout" */
  9    34        2 no_coord_label label,			/* where to go for a no_coord condition */
  9    35        2 log_stream char (32),			/* stream name used for log output */
  9    36        2 master_input char (32),			/* master console input stream for commands */
  9    37        2 master_output char (32),			/* master console output stream for messages */
  9    38        2 master_out ptr,				/* master output iocbp */
  9    39        2 master_in ptr,				/* master input iocbp */
  9    40        2 log_iocbp ptr,				/* log output iocbp */
  9    41        2 error_io ptr,				/* error i/o iocbp */
  9    42        2 dev_io_stream char (32),			/* stream used to attach the major device */
  9    43        2 dev_in_stream char (32),			/* input stream if different from dev_io_stream */
  9    44        2 dev_out_stream char (32),			/* output stream if different from dev_io_stream */
  9    45        2 device_dim char (32),			/* dim which drives the major device */
  9    46        2 attach_name char (32),			/* channel or dial id for attaching major device */
  9    47        2 attach_type fixed bin,			/* what previous is: 1 = iom, 2 = tty, 3 = dial, 4 = variable line */
  9    48        2 dev_dial_id char (8),			/* non null if device is to be dialed to driver */
  9    49        2 line_tab_idx fixed bin,			/* for attach type 4, this is the entry index, else 0 */
  9    50        2 dial_ev_chan fixed bin (71),			/* IPC chan for dial control */
  9    51        2 major_device char (32),			/* name of the major device */
  9    52        2 major_args unaligned like text_offset,		/* descriptive string for the major device */
  9    53        2 coord_cmd_chan fixed bin (71),			/* IPC chan to send commands to coord through coord_comm.ms */
  9    54        2 cmd_ack_chan fixed bin (71),			/* IPC chan for coord to return command status code */
  9    55        2 timer_chan fixed bin (71),			/* IPC chan for unblocking if nothing happens */
  9    56        2 io_daemon_version char (8),			/* current version number of the io daemon driver */
  9    57        2 extra_static (8) fixed bin (35),		/* unused space - non_dynamic */
  9    58        2 dummy_ptr ptr,				/* a dummy pointer for the driver module */
  9    59 
  9    60 /*    driver module entrypoints are defined by the following entry variables */
  9    61 
  9    62        2 driver_init entry variable options (variable),
  9    63        2 driver_request entry variable options (variable),
  9    64        2 driver_command entry variable options (variable),
  9    65        2 driver_default_handler entry variable options (variable),
  9    66 
  9    67 /*    entrypoints for head/tail_sheet_ entries */
  9    68        2 print_head_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  9    69        2 print_head_separator entry (ptr, ptr, char (*), fixed bin (35)) variable,
  9    70        2 print_tail_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  9    71 
  9    72        2 paper_type fixed bin,			/* type of paper being used */
  9    73 						/* 1 = single sheet */
  9    74 						/* 2 = continuous forms */
  9    75 
  9    76 /*   The remainder of the data may be dynamic during the device driver's existence */
  9    77 
  9    78        2 extra_dynamic (14) fixed bin (35),		/* unused space - dynamic */
  9    79        2 auto_logout_interval fixed bin,		/* minutes to wait for inactivity logout */
  9    80        2 requests_til_cmd fixed bin,			/* number of requests to go before returning to cmd level */
  9    81        2 assigned_devices fixed bin,			/* number of minor devices assigned to major device */
  9    82        2 current_devices fixed bin,			/* number of devices currently active in process */
  9    83        2 output_device char (32),			/* name of minor device currently in use */
  9    84        2 wakeup_time fixed bin (71),			/* time interval between timer wakeups */
  9    85        2 auto_start_delay fixed bin (71),		/* time to wait before performing an auto-start after quit */
  9    86        2 driver_ptr ptr,				/* pointer to driver status seg currently in use */
  9    87        2 segptr ptr,				/* ptr to current user segment being processed */
  9    88        2 flags,					/* control flags */
  9    89          3 initialized bit (1) unal,			/* all driver data bases are initialized */
  9    90          3 test_entry bit (1) unal,			/* driver test entry was called */
  9    91          3 request_in_progress bit (1) unal,		/* driver executing a request */
  9    92          3 recursion_flag bit (1) unal,			/* recursive unclaimed signal */
  9    93          3 no_coord_flag bit (1) unal,			/* process is ready to accept a no_coord signal */
  9    94          3 logout_pending bit (1) unal,			/* logout after all pending requests are done */
  9    95          3 master_hold bit (1) unal,			/* master_hold at command level */
  9    96          3 slave_hold bit (1) unal,			/* slave hold at command level */
  9    97          3 step bit (1) unal,				/* run in step mode */
  9    98          3 quit_during_request bit (1) unal,		/* a quit occured, don't wait for wakeup */
  9    99          3 runout_requests bit (1) unal,		/* hold after all pending requests are done */
  9   100          3 re_init_in_progress bit (1) unal,		/* driver processing a re_init signal */
  9   101          3 quit_signaled bit (1) unal,			/* set to "1"b by quit handler for anyone who is curious */
  9   102          3 auto_logout_pending bit (1) unal,		/* inactivity limit exceeded, logout after next wakeup */
  9   103          3 logout_on_hangup bit (1) unal,		/* logout instead of reinit if set */
  9   104          3 pad bit (21) unal,				/* unused space */
  9   105        2 slave,					/* slave control device data (ctl term or remote reader) */
  9   106          3 slave_input char (32),			/* slave input stream name */
  9   107          3 slave_output char (32),			/* slave output stream name */
  9   108          3 slave_pad fixed bin,			/* allocation breakage */
  9   109          3 slave_in ptr,				/* slave input iocbp */
  9   110          3 slave_out ptr,				/* slave output iocbp */
  9   111          3 slave_ev_chan fixed bin (71),		/* event channel the slave device blocks on */
  9   112          3 active bit (1) unal,			/* on if there is a slave */
  9   113          3 accept_input bit (1) unal,			/* on if commands may come from the slave */
  9   114          3 allow_quits bit (1) unal,			/* on if we allow slave to send quits */
  9   115          3 print_errors bit (1) unal,			/* on if errors will be sent to the slave */
  9   116          3 log_msg bit (1) unal,			/* on if log messages are to be sent to the slave */
  9   117          3 priv1 bit (1) unal,			/* driver_module defined slave privileges */
  9   118          3 priv2 bit (1) unal,
  9   119          3 priv3 bit (1) unal,
  9   120          3 echo_cmd bit (1) unal,			/* on if each slave cmd should be written back */
  9   121          3 slave_bit_pad bit (27) unal,			/* unused space */
  9   122        2 ctl_term,					/* control terminal data */
  9   123          3 ctl_attach_name char (32),			/* dial id, tty chan, or mrd_ device */
  9   124          3 ctl_attach_type fixed bin,			/* attach name meaning: 1=line, 2=dial, 3=mrd_source */
  9   125          3 ctl_pad fixed bin,				/* allocation breakage */
  9   126          3 ctl_dial_chan fixed bin (71),		/* ipc event channel for dial comm */
  9   127          3 ctl_input char (32),			/* ctl input stream name */
  9   128          3 ctl_output char (32),			/* ctl output stream name */
  9   129          3 ctl_io char (32),				/* ctl i/o stream name */
  9   130          3 ctl_dev_dim char (32),			/* ctl_io attached with this dim */
  9   131          3 ctl_ev_chan fixed bin (71),			/* IPC event chan ctl term blocks on */
  9   132          3 ctl_device char (32),			/* ctl terminal device name */
  9   133          3 form_type char (16),			/* format type if printing forms */
  9   134          3 attached bit (1) unal,			/* ctl term attached to process */
  9   135          3 forms bit (1) unal,			/* on if printing forms */
  9   136          3 pad bit (34) unal,
  9   137        2 admin_ec_name char (32),			/* name of the ec to use with the "x" command */
  9   138        2 expansion_space (100) fixed bin;		/* reserved space...use at your own risk */
  9   139 
  9   140 /* END INCLUDE FILE ... iodd_static.incl.pl1 */
      938 
      939  /* Begin include file ..... iox_modes.incl.pl1 */
 10     2 
 10     3 /* Written by C. D. Tavares, 03/17/75 */
 10     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
 10     5 
 10     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
 10     7     ("stream_input", "stream_output", "stream_input_output",
 10     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
 10     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
 10    10      "direct_input", "direct_output", "direct_update");
 10    11 
 10    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
 10    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
 10    14 
 10    15 dcl (Stream_input initial (1),
 10    16      Stream_output initial (2),
 10    17      Stream_input_output initial (3),
 10    18      Sequential_input initial (4),
 10    19      Sequential_output initial (5),
 10    20      Sequential_input_output initial (6),
 10    21      Sequential_update initial (7),
 10    22      Keyed_sequential_input initial (8),
 10    23      Keyed_sequential_output initial (9),
 10    24      Keyed_sequential_update initial (10),
 10    25      Direct_input initial (11),
 10    26      Direct_output initial (12),
 10    27      Direct_update initial (13)) fixed bin int static options (constant);
 10    28 
 10    29 /* End include file ..... iox_modes.incl.pl1 */
      939 
      940  /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
 11     2 /* format: style3,idind30 */
 11     3 
 11     4 /* structure returned when message is read from a message segment */
 11     5 
 11     6 
 11     7 dcl	mseg_message_info_ptr	pointer;
 11     8 
 11     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
 11    10 	  2 version		char (8) aligned,
 11    11 	  2 message_code		fixed bin,
 11    12 	  2 control_flags		unaligned,
 11    13 	    3 own			bit (1),
 11    14 	    3 delete		bit (1),
 11    15 	    3 pad			bit (34),
 11    16 	  2 ms_ptr		ptr,		/* pointer to message */
 11    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
 11    18 	  2 ms_id			bit (72),		/* unique ID of message */
 11    19 						/* input in some cases */
 11    20 	  2 ms_access_class		bit (72),		/* message access class */
 11    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
 11    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
 11    23 	  2 sender_level		fixed bin,	/* validation level of sender */
 11    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
 11    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
 11    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
 11    27 
 11    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
 11    29 
 11    30 declare	(
 11    31 	MSEG_READ_FIRST		init (1),
 11    32 	MSEG_READ_LAST		init (2),
 11    33 	MSEG_READ_SPECIFIED		init (3),
 11    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
 11    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
 11    36 	fixed bin int static options (constant);
 11    37 
 11    38 declare  (MSEG_READ_OWN		init ("1"b),
 11    39 	MSEG_READ_DELETE		init ("01"b)
 11    40 	)			bit (36) aligned internal static options (constant);
 11    41 
 11    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
      940 
      941  /* BEGIN INCLUDE FILE ... output_request_data.incl.pl1 */
 12     2 
 12     3 /* Modified by R. McDonald May 1980 to include page charges (UNCA) */
 12     4 /* Modified by C. Marker October 1983 added no_separator */
 12     5 
 12     6 
 12     7 /****^  HISTORY COMMENTS:
 12     8*  1) change(87-05-10,Gilcrease), approve(87-05-13,MCR7686),
 12     9*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
 12    10*     Add the line_nbrs bit for line-numbered output.
 12    11*  2) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
 12    12*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
 12    13*     Added single_sheet bit to denote if continuous paper.
 12    14*                                                   END HISTORY COMMENTS */
 12    15 
 12    16 
 12    17      dcl	   1 ordata	      based (ordatap) aligned,
 12    18 	     2 dpmp	      ptr,		/* Ptr to dprint_msg */
 12    19 	     2 requestor	      char (32),		/* Person.Proj.tag requesting */
 12    20 	     2 full_path	      char (168),		/* source of the output */
 12    21 	     2 queue	      fixed bin,		/* Queue requested. */
 12    22 	     2 copies	      fixed bin,		/* Copies requested. */
 12    23 	     2 copy_no	      fixed bin,		/* Number this copy */
 12    24 	     2 request_no	      fixed bin (35),	/* Number request assigned by coord */
 12    25 	     2 restart_no	      fixed bin (35),	/* old number of restarted request (0 = not restarted) */
 12    26 	     2 request_type	      char (32),		/* Name of device class wanted. */
 12    27 	     2 access_class_string char (280),		/* Access class - size limit for two printer lines */
 12    28 	     2 punsw	      fixed bin,		/* 0 = print, 1= punch */
 12    29 	     2 delete	      fixed bin,		/* 1= delete, 0= don't */
 12    30 	     2 device_name	      char (32),		/* Name of physical device used */
 12    31 	     2 output_mode	      char (128),		/* user's mode string for ios_$changemode */
 12    32 	     2 time_start_request fixed bin (71),	/* Clock time when picked request */
 12    33 	     2 date_time_start_request char (24),	/* .. in chars too */
 12    34 	     2 line_count	      fixed bin (24),	/* Line count returned by DIM */
 12    35 	     2 page_count	      fixed bin,		/* Page count returned by DIM */
 12    36 	     2 cpu_time	      fixed bin (71),	/* Total CPU usage while printing */
 12    37 	     2 real_time	      fixed bin (71),	/* Total realtime while printing */
 12    38 	     2 page_waits	      fixed bin,		/* Total page-waits while printing */
 12    39 	     2 pre_pages	      fixed bin,		/* Total pre-pages (???) .. */
 12    40 	     2 bit_count	      fixed bin (24),	/* Number of bits transmitted. */
 12    41 	     2 charge	      float bin,		/* What the thing cost. */
 12    42 	     2 control_flags,
 12    43 	       3 continued	      bit (1) unal,		/* request started by one driver and given to another */
 12    44 	       3 restarted	      bit (1) unal,		/* request is restarted */
 12    45 	       3 separator	      bit (1) unal,		/* used to determine necessity of a separator page  */
 12    46 	       3 notify	      bit (1) unal,		/* if should confirm to user */
 12    47 	       3 saved	      bit (1) unal,		/* request was suspended by operator, we'll save it */
 12    48 	       3 priority_request bit (1) unal,		/* operator said run now!! */
 12    49 	       3 no_separator     bit (1) unal,		/* suppress inner head and tail sheets when printing multiple copies */
 12    50 	       3 line_nbrs	      bit (1) unal,		/* if line-numbered output requested */
 12    51 	       3 single_sheet     bit (1) unal,		/* ON if single_sheet output */
 12    52 	       3 padding	      bit (27) unal,	/* not used */
 12    53 	     2 contd_no	      fixed bin (35),	/* old number of continued request (0 = not continued) */
 12    54 	     2 total_charge	      float bin,		/* total charge for all copies */
 12    55 	     2 price_per_n_lines  float bin,		/* line price rate used to compute charge */
 12    56 	     2 n_lines_for_price  fixed bin,		/* number of lines price is based on */
 12    57 	     2 charge_queue	      fixed bin,		/* base charge rate on this queue */
 12    58 	     2 price_per_n_pages  float bin,		/* page charge rate used to compute charge */
 12    59 	     2 n_pages_for_price  fixed bin,		/* number of pages price is based on */
 12    60 	     2 rs_number	      fixed bin (9) unsigned unaligned, /* rate_structure number used */
 12    61 	     2 rs_unavailable     bit (1) unaligned,	/* 1=>couldn't read SAT */
 12    62 	     2 no_accounting      bit (1) unaligned,	/* 1=>accounting:nothing in iod_tables */
 12    63 	     2 pad_bits	      bit (25) unaligned,
 12    64 	     2 line_nbr	      fixed bin (35),	/* current line number */
 12    65 	     2 pad_space	      (6) fixed bin (35);	/* save some room to grow */
 12    66 
 12    67      dcl	   ordatap	      ptr;		/* Ptr to above structure */
 12    68 
 12    69      dcl	   1 REQUEST	      like ordata aligned;	/* If wanted, a place to put the above thing */
 12    70 
 12    71 /* END INCLUDE FILE ... output_request_data.incl.pl1 */
      941 
      942  /* BEGIN INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
 13     2 
 13     3 /* This is the message header used for standard system queue messages, namely:
 13     4*   IO daemon requests, absentee requests, retrieval requests.
 13     5**/
 13     6 
 13     7 /* Written by Jerry Whitmore, Spring 1978.
 13     8*   Modified by T. Casey, November 1978, to add values for state.
 13     9*   Modified by R. Kovalcik, June 1982, defer_until_process_terminataion
 13    10**/
 13    11 
 13    12 dcl 1 queue_msg_hdr based aligned,			/* standard header for all system queue messages */
 13    13     2 msg_time fixed bin (71),			/* date and time of request */
 13    14     2 hdr_version fixed bin,				/* version of this declaration */
 13    15     2 dirname char (168),				/* directory name */
 13    16     2 ename char (32),				/* entry name of file requested */
 13    17     2 message_type fixed bin,				/* message format descriptor   */
 13    18 						/* 0 = absentee request        */
 13    19 						/* 1 = print request           */
 13    20 						/* 2 = punch request           */
 13    21 						/* 3 = tape request            */
 13    22 						/* 4 = retrieval request       */
 13    23     2 bit_flags,
 13    24       3 delete_sw bit (1) unal,			/* delete file when done */
 13    25       3 notify bit (1) unal,				/* user wants to be notified */
 13    26       3 defer_until_process_termination bit (1) unal,	/* don't process request until process terminates */
 13    27       3 padding bit (33) unal,
 13    28     2 state fixed bin,				/* stage of processing after being queued:
 13    29*						   0 = initial unprocessed state, 1 = deferred,
 13    30*						   2 = in state transition, 3 = eligible, 4 = running,
 13    31*                                                               5 = bumped, 6 = deferred_until_process_termination */
 13    32     2 orig_queue fixed bin,				/* queue the request was submitted to */
 13    33     2 std_length fixed bin,				/* length of std msg for this type */
 13    34     2 dupt_lock bit (36) aligned,			/* lock word for defer until process termination */
 13    35     2 hdr_pad (3) fixed bin;
 13    36 
 13    37 dcl  queue_msg_hdr_version_1 fixed bin int static options (constant) init (1); /* current version of the header */
 13    38 
 13    39 /* Values for queue_msg_hdr.state */
 13    40 
 13    41 dcl  STATE_UNPROCESSED fixed bin int static options (constant) init (0);
 13    42 dcl  STATE_DEFERRED fixed bin int static options (constant) init (1);
 13    43 dcl  STATE_TRANSITION fixed bin int static options (constant) init (2);
 13    44 dcl  STATE_ELIGIBLE fixed bin int static options (constant) init (3);
 13    45 dcl  STATE_RUNNING fixed bin int static options (constant) init (4);
 13    46 dcl  STATE_BUMPED fixed bin int static options (constant) init (5);
 13    47 dcl  STATE_DUPT fixed bin int static options (constant) init (6);
 13    48 
 13    49 /* END INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
      942 
      943  /* BEGIN INCLUDE FILE  -  receive_file_data.incl.pl1	*/
 14     2 
 14     3 /* This include file defines the structure which is part of the interface to the receive_file_.pl1 procedure. */
 14     4 
 14     5 dcl  receive_file_data_ptr ptr;
 14     6 
 14     7 dcl 1 receive_file_data aligned based (receive_file_data_ptr),	/* data for receive_file_ default file_data */
 14     8     2 version fixed bin,
 14     9     2 flags,
 14    10       3 testing bit (1) unal,				/* TRUE when in test mode */
 14    11       3 no_ident bit (1) unal,			/* TRUE when no ++IDENT record is required */
 14    12       3 auto_queue bit (1) unal,			/* TRUE when file is to be dp -dl by driver */
 14    13     2 device_type fixed bin,				/* code for input device type (see below) */
 14    14     2 request_type char (32);				/* default request type for auto_queue */
 14    15 
 14    16 dcl  receive_file_data_version_1 fixed bin int static options (constant) init (1);
 14    17 
 14    18 dcl  printer_input_device fixed bin int static options (constant) init (1);
 14    19 dcl  punch_input_device fixed bin int static options (constant) init (2);
 14    20 
 14    21 
 14    22 /* END INCLUDE FILE  -  receive_file_data.incl.pl1		*/
 14    23 
      943 
      944  /* BEGIN INCLUDE FILE...request_descriptor.incl.pl1 */
 15     2 
 15     3 /* Descriptor associated with an I/O daemon request */
 15     4 /* Coded August 1973 by Robert S. Coren */
 15     5 /* Modified by J. C. Whitmore, 5/78, to extend driver_data to 7 words */
 15     6 /* Modified by C. Marker, 2/23/85, changed to use mseg_message_info */
 15     7 
 15     8 dcl  1 request_descriptor based aligned,
 15     9 	2 mseg_message_info_copy like mseg_message_info,
 15    10 	2 seq_id fixed bin(35),	/* sequential number assigned by coordinator */
 15    11 	2 q fixed bin,		/* priority queue in which request was submitted */
 15    12 	2 contd_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of continued request */
 15    13 	2 prev_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of restarted request */
 15    14 	2 dev_class_index fixed bin,	/* index of device_class entry */
 15    15 	2 spare_fb fixed bin (17) unal, /* save half a word for later */
 15    16 	2 charge_q fixed bin (17) unal, /* priority to use for charging */
 15    17 	2 time_done fixed bin(71),	/* clock time when request was completed */
 15    18 	2 prev_done fixed bin(18),	/* descriptor threaded ahead of this one in saved list */
 15    19 	2 next_done fixed bin(18),	/*      "        "     behind    "        "       "      */
 15    20 	2 driver_data bit(252),	/* driver maintained data */
 15    21 	2 flags,
 15    22 	   (3 continued,		/* unfinished by one driver and given to another */
 15    23 	    3 finished,
 15    24 	    3 restarted,
 15    25 	    3 cancelled,
 15    26 	    3 dont_delete,
 15    27 	    3 saved,		/* not to be freed */
 15    28 	    3 keep_in_queue,	/* keep request in queue */
 15    29 	    3 series_restart,	/* this request is part of restarted series */
 15    30 	    3 priority_request) bit (1) unal, /* this request was given extra priority */
 15    31 	    3 pad bit(27) unal,
 15    32 	2 next_pending fixed bin(18);	/* thread to next pending descriptor */
 15    33 
 15    34 /* END INCLUDE FILE...request_descriptor.incl.pl1 */
      944 
      945  /*  BEGIN INCLUDE FiLE ... terminal_info.incl.pl1 */
 16     2 
 16     3 /* Created 5/25/77 by J. Stern */
 16     4 
 16     5 
 16     6 dcl 1 terminal_info aligned based (terminal_info_ptr),	/* info structure for terminal_info order */
 16     7       2 version fixed bin,				/* version number of this sturcture */
 16     8       2 id char (4) unaligned,			/* terminal id from answerback */
 16     9       2 term_type char (32) unaligned,			/* terminal type name */
 16    10       2 line_type fixed bin,				/* line type number */
 16    11       2 baud_rate fixed bin,
 16    12       2 reserved (4) fixed bin;			/* reserved for future use */
 16    13 
 16    14 
 16    15 dcl  terminal_info_ptr ptr;
 16    16 dcl  terminal_info_version fixed bin int static options (constant) init (1); /* current version */
 16    17 
 16    18 
 16    19 /* END INCLUDE FILE ... terminal_info.incl.pl1 */
      945 
      946 
      947      end hasp_ws_sim_driver_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/03/89  0954.2  hasp_ws_sim_driver_.pl1           >spec>install>1083>hasp_ws_sim_driver_.pl1
930          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
931          2    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
932          3    11/09/88  0759.7  dprint_msg.incl.pl1               >ldd>include>dprint_msg.incl.pl1
933          4    08/29/75  1310.5  driver_ptr_list.incl.pl1          >ldd>include>driver_ptr_list.incl.pl1
934          5    11/09/88  0759.7  driver_status.incl.pl1            >ldd>include>driver_status.incl.pl1
935          6    10/30/80  1648.7  find_input_sw_info.incl.pl1       >ldd>include>find_input_sw_info.incl.pl1
936          7    11/09/88  0759.7  iod_tables_hdr.incl.pl1           >ldd>include>iod_tables_hdr.incl.pl1
937          8    11/09/88  0759.7  iod_constants.incl.pl1            >ldd>include>iod_constants.incl.pl1
938          9    11/09/88  0759.7  iodd_static.incl.pl1              >ldd>include>iodd_static.incl.pl1
939         10    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
940         11    01/10/85  2002.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
941         12    11/09/88  0759.7  output_request_data.incl.pl1      >ldd>include>output_request_data.incl.pl1
942         13    08/31/82  1636.3  queue_msg_hdr.incl.pl1            >ldd>include>queue_msg_hdr.incl.pl1
943         14    10/30/80  1648.7  receive_file_data.incl.pl1        >ldd>include>receive_file_data.incl.pl1
944         15    03/15/85  0953.1  request_descriptor.incl.pl1       >ldd>include>request_descriptor.incl.pl1
945         16    06/29/77  1624.0  terminal_info.incl.pl1            >ldd>include>terminal_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTACH_TYPE_TTY                        constant        fixed bin(17,0)          initial dcl 8-15 ref 207
Device                                 parameter       char                     packed unaligned dcl 831 in procedure "minor_attach"
                                                                                  set ref 829 837 844 854*
Device                                 parameter       char                     packed unaligned dcl 878 in procedure
                                                                                  "get_switch_name" ref 875 882
R_ACCESS                        000123 constant        bit(3)                   initial packed unaligned dcl 1-11 set ref 924*
Stream_input                           constant        fixed bin(17,0)          initial dcl 10-15 ref 845
Stream_output                          constant        fixed bin(17,0)          initial dcl 10-15 ref 840
a_argp                                 parameter       pointer                  dcl 62 ref 200 203 608 611
a_banner_type                          parameter       fixed bin(17,0)          dcl 68 ref 586 589
a_code                                 parameter       fixed bin(35,0)          dcl 76 set ref 586 590* 600* 608 620 621* 787* 790*
                                                                                  795*
a_data_ptr                             parameter       pointer                  dcl 73 ref 586
a_iocbp                                parameter       pointer                  dcl 812 set ref 810 816 818* 820* 821* 823*
a_source                               parameter       fixed bin(17,0)          dcl 63 ref 608 612
a_state                                parameter       fixed bin(17,0)          dcl 64 ref 608 613
a_stream                               parameter       char                     packed unaligned dcl 67 ref 586
active                  342            based           bit(1)                   level 3 packed packed unaligned dcl 9-17 ref 317 579
add_char_offset_                000200 constant        entry                    external dcl 137 ref 229 265
addr                                                   builtin function         dcl 187 ref 229 229 265 265 291 291 309 309 312 413
                                                                                  413 413 413 499 500 593 685 685 685 685 896 896
admin_ec_name           437            based           char(32)                 level 2 dcl 9-17 set ref 397*
age                             000100 automatic       fixed bin(17,0)          dcl 81 set ref 772* 772 773 778*
arg                      23            based           varying char(64)         array level 2 dcl 131 set ref 645 706 709 731 732*
                                                                                  738 772 774*
arg_list                               based           structure                level 1 dcl 131
argp                            000102 automatic       pointer                  dcl 82 set ref 611* 623 639 639 644 645 660 675 695
                                                                                  695 701 706 709 720 720 720 726 731 732 738 759
                                                                                  759 768 772 774
args_bc                         001174 automatic       fixed bin(24,0)          dcl 919 set ref 924* 927
args_length                            parameter       fixed bin(17,0)          dcl 912 set ref 907 927*
args_ptr                               parameter       pointer                  dcl 911 set ref 907 924*
assigned_devices        265            based           fixed bin(17,0)          level 2 dcl 9-17 ref 213
attach_name             136            based           char(32)                 level 2 dcl 9-17 set ref 403* 848
attach_type             146            based           fixed bin(17,0)          level 2 dcl 9-17 ref 207
attached                 47            based           bit(1)                   level 3 packed packed unaligned dcl 5-25 set ref
                                                                                  280* 300*
auto_queue                1(02) 000010 internal static bit(1)                   level 3 packed packed unaligned dcl 126 set ref 328*
                                                                                  330* 706* 709*
banner_type                     000104 automatic       fixed bin(17,0)          dcl 83 set ref 589* 595
baud_rate                13     000571 automatic       fixed bin(17,0)          level 2 dcl 111 set ref 253* 292
bit_rate_est            132            based           fixed bin(35,0)          level 2 dcl 5-25 set ref 260* 292* 294*
both                            000130 constant        fixed bin(17,0)          initial dcl 165 set ref 281* 302* 403* 453* 503*
                                                                                  509* 523* 540*
cancelled                53(03)        based           bit(1)                   level 3 packed packed unaligned dcl 15-8 set ref
                                                                                  514* 545*
chan_list_ptr            20            based           pointer                  level 2 dcl 9-17 ref 315
channel                   2            based           fixed bin(71,0)          array level 2 dcl 122 ref 315
character                                              builtin function         dcl 187 ref 882
chars                     1            based           char                     level 2 packed packed unaligned dcl 7-39 set ref 229
                                                                                  229 265 265
cleanup                         000626 stack reference condition                dcl 189 ref 226 551
clock                                                  builtin function         dcl 187 ref 402 402 451 451
code                            000112 automatic       fixed bin(35,0)          dcl 814 in procedure "close_and_detach" set ref 818*
                                                                                  820* 821*
code                                   parameter       fixed bin(35,0)          dcl 914 in procedure "initiate_the_file" set ref 907
                                                                                  921* 922 924* 925
code                            000105 automatic       fixed bin(35,0)          dcl 84 in procedure "hasp_ws_sim_driver_" set ref
                                                                                  235* 236 271* 273 291* 292 309* 310 359* 360 361*
                                                                                  382* 384 385* 413* 414 414* 455* 457* 555* 556 558
                                                                                  559* 565* 566 570 575* 579* 590* 596* 600 601 621*
                                                                                  685* 686 686* 739* 740 741* 778* 779 779* 790 856*
                                                                                  858 858 858 860* 861 861 862* 896* 897 898*
command                   2            based           varying char(64)         level 2 dcl 131 ref 623 639 639 660 675 695 695 720
                                                                                  720 720 759 759
command_level                   000634 stack reference condition                dcl 189 ref 412 683
compname                        001164 automatic       char(32)                 packed unaligned dcl 918 set ref 921* 924*
condition                       000706 automatic       char(32)                 packed unaligned dcl 802 set ref 804* 805*
condition_info                         based           structure                level 1 dcl 2-14
condition_info_ptr                     parameter       pointer                  dcl 2-10 ref 800 804
condition_name            3            based           varying char(32)         level 2 dcl 2-14 ref 804
continue_to_signal_             000202 constant        entry                    external dcl 138 ref 485
control                 102            based           structure                level 2 dcl 3-20
conversion                      000700 stack reference condition                dcl 189 ref 615
convert                                                builtin function         dcl 187 ref 645 772
daemon_logout                   000664 stack reference condition                dcl 189 ref 222
daemon_new_device               000656 stack reference condition                dcl 189 ref 224
daemon_slave_logout             000672 stack reference condition                dcl 189 ref 223
data_ptr                  4     000612 automatic       pointer                  level 2 dcl 113 set ref 893*
date_string                     000106 automatic       char(24)                 packed unaligned dcl 85 set ref 402* 403* 451* 453*
date_time_                      000236 constant        entry                    external dcl 152 ref 402 451
default_request_types           000005 constant        char(32)                 initial array packed unaligned dcl 176 ref 347
defer_time_limit        133            based           fixed bin(35,0)          level 2 dcl 5-25 set ref 261*
desc                            000734 automatic       varying char(256)        dcl 832 set ref 848* 849* 849 850* 850 852* 852 856
                                                                                  862*
descriptor              146            based           structure                level 2 dcl 5-25 set ref 499 593
dev_ctl_ptr             130            based           pointer                  level 2 dcl 5-25 set ref 258*
dev_in_iocbp             70            based           pointer                  level 2 dcl 5-25 set ref 309* 322 867*
dev_in_stream           106            based           char(32)                 level 2 dcl 9-17 set ref 219*
dev_io_stream            76            based           char(32)                 level 2 dcl 9-17 set ref 219*
dev_opt                         001046 automatic       varying char(32)         dcl 834 set ref 839* 844* 852
dev_out_iocbp            66            based           pointer                  level 2 dcl 5-25 set ref 257* 291* 483* 552* 565*
                                                                                  596* 666 856* 860* 867 869*
dev_out_stream           72            based           char(32)                 level 2 dcl 5-25 set ref 262* 555 854* 856
device_id                20            based           char(32)                 level 2 dcl 5-25 set ref 281* 302* 333* 353* 361*
                                                                                  368* 390* 420* 429* 862*
device_type               2     000010 internal static fixed bin(17,0)          level 2 in structure "static_receive_data" dcl 126
                                                                                  in procedure "hasp_ws_sim_driver_" set ref 251*
                                                                                  339* 341* 347 365 365 368* 625 640 661 676 696 721
                                                                                  745 745 748* 760
device_type                     000114 automatic       char(32)                 packed unaligned dcl 86 in procedure
                                                                                  "hasp_ws_sim_driver_" set ref 277* 279 285* 299
                                                                                  299 302 305 307* 339 390* 406 406
dirname                         001102 automatic       char(168)                packed unaligned dcl 916 set ref 921* 924*
divide                                                 builtin function         dcl 187 ref 927
dmp                             000716 automatic       pointer                  dcl 3-18 set ref 500* 502 508 509 519 519 519 523
                                                                                  531 531 534 540
dont_delete              53(04)        based           bit(1)                   level 3 packed packed unaligned dcl 15-8 set ref
                                                                                  515*
dprint_msg                             based           structure                level 1 dcl 3-20
dprint_msg_version_3                   constant        fixed bin(17,0)          initial dcl 3-62 ref 519
dprint_msg_version_4                   constant        fixed bin(17,0)          initial dcl 3-62 ref 519 531
dprint_msg_version_5                   constant        fixed bin(17,0)          initial dcl 3-62 ref 519
driver_ptr              304            based           pointer                  level 2 dcl 9-17 ref 255 480 498 592 666
driver_status                          based           structure                level 1 dcl 5-25
elem_size               112            based           fixed bin(17,0)          level 2 dcl 5-25 set ref 287*
element_size                    000124 automatic       fixed bin(17,0)          dcl 87 set ref 537* 555*
ename                    55            based           char(32)                 level 2 dcl 13-12 set ref 509* 523* 540*
entname                         001154 automatic       char(32)                 packed unaligned dcl 917 set ref 921* 924*
entry                           000612 automatic       entry variable           level 2 dcl 113 set ref 892*
error                           000143 constant        fixed bin(17,0)          initial dcl 168 set ref 208* 214* 242* 559* 575*
                                                                                  862* 898*
error_table_$action_not_performed
                                000260 external static fixed bin(35,0)          dcl 192 ref 795
error_table_$bigarg             000262 external static fixed bin(35,0)          dcl 192 set ref 353* 732*
error_table_$fatal_error        000264 external static fixed bin(35,0)          dcl 192 set ref 208* 214* 242*
error_table_$io_no_permission   000266 external static fixed bin(35,0)          dcl 192 ref 558
error_table_$ionmat             000272 external static fixed bin(35,0)          dcl 192 ref 858
error_table_$not_closed         000276 external static fixed bin(35,0)          dcl 192 ref 861
error_table_$not_detached       000274 external static fixed bin(35,0)          dcl 192 ref 858
error_table_$undefined_order_request
                                000270 external static fixed bin(35,0)          dcl 192 ref 570
ev_chan                  30            based           fixed bin(71,0)          array level 3 dcl 6-7 set ref 315* 319* 323*
ev_chan_list                           based           structure                level 1 dcl 122
expand_pathname_$component      000204 constant        entry                    external dcl 139 ref 921
finished                 53(01)        based           bit(1)                   level 3 packed packed unaligned dcl 15-8 set ref
                                                                                  516*
first_char              164            based           fixed bin(18,0)          level 3 in structure "iodd_static" packed packed
                                                                                  unsigned unaligned dcl 9-17 in procedure
                                                                                  "hasp_ws_sim_driver_" ref 229
first_char               54            based           fixed bin(18,0)          level 3 in structure "driver_status" packed packed
                                                                                  unsigned unaligned dcl 5-25 in procedure
                                                                                  "hasp_ws_sim_driver_" ref 265
flags                   310            based           structure                level 2 in structure "iodd_static" dcl 9-17
                                                                                  in procedure "hasp_ws_sim_driver_"
flags                    53            based           structure                level 2 in structure "request_descriptor" dcl 15-8
                                                                                  in procedure "hasp_ws_sim_driver_"
flags                     1     000010 internal static structure                level 2 in structure "static_receive_data" dcl 126
                                                                                  in procedure "hasp_ws_sim_driver_" set ref 248*
format_code                     000125 automatic       fixed bin(17,0)          dcl 88 set ref 534* 536
generic_type                    000126 automatic       char(32)                 packed unaligned dcl 89 in procedure
                                                                                  "hasp_ws_sim_driver_" set ref 359* 365 365 368*
                                                                                  739* 745 745 748*
generic_type            134            based           char(32)                 level 2 in structure "driver_status" dcl 5-25
                                                                                  in procedure "hasp_ws_sim_driver_" set ref 283*
                                                                                  305*
hangup_info                     000612 automatic       structure                level 1 dcl 113 set ref 896 896
hdr_version               2            based           fixed bin(17,0)          level 2 dcl 13-12 ref 502
head_banner                            constant        fixed bin(17,0)          initial dcl 174 ref 595
ignore                          000136 automatic       fixed bin(35,0)          dcl 90 set ref 667*
index                           000176 internal static fixed bin(17,0)          initial dcl 877 set ref 880* 880 881 881* 882
initial_punch_rate                     constant        fixed bin(17,0)          initial dcl 172 ref 294
initiate_file_$component        000210 constant        entry                    external dcl 141 ref 924
io_module                       001035 automatic       varying char(32)         dcl 833 set ref 838* 843* 848
iocbp                     2            based           pointer                  array level 2 in structure "sw_info" dcl 6-7
                                                                                  in procedure "hasp_ws_sim_driver_" set ref 314*
                                                                                  318* 322*
iocbp                           000146 automatic       pointer                  dcl 93 in procedure "hasp_ws_sim_driver_" set ref
                                                                                  666* 667*
iocbp                                  parameter       pointer                  dcl 888 in procedure "set_hangup_proc" set ref 886
                                                                                  896*
iod_info_$generic_type          000206 constant        entry                    external dcl 140 ref 359 739
iodd_hangup_$iodd_hangup_       000216 constant        entry                    external dcl 144 ref 892
iodd_listen_                    000240 constant        entry                    external dcl 153 ref 436
iodd_msg_                       000212 constant        entry                    external dcl 142 ref 208 214 242 281 296 302 333 353
                                                                                  361 368 385 390 403 411 414 420 429 453 461 503
                                                                                  509 523 540 559 575 616 624 626 627 628 629 632
                                                                                  633 641 647 662 670 677 681 686 690 697 702 713
                                                                                  722 732 741 748 761 765 769 774 779 862 898
iodd_parse_$args                000214 constant        entry                    external dcl 143 ref 233 240 269 277 327 343 344 408
                                                                                  427 849 850
iodd_static                            based           structure                level 1 dcl 9-17
iox_$attach_ioname              000222 constant        entry                    external dcl 146 ref 856
iox_$close                      000232 constant        entry                    external dcl 150 ref 820
iox_$control                    000226 constant        entry                    external dcl 148 ref 291 309 455 457 552 565 579 596
                                                                                  818 896
iox_$detach_iocb                000234 constant        entry                    external dcl 151 ref 821
iox_$modes                      000230 constant        entry                    external dcl 149 ref 667
iox_$open                       000224 constant        entry                    external dcl 147 ref 860
keep_in_queue            53(06)        based           bit(1)                   level 3 packed packed unaligned dcl 15-8 set ref
                                                                                  505* 528* 601*
last                            000137 automatic       fixed bin(17,0)          dcl 91 set ref 316* 318 319 320* 320 322 323 324 325
length                                                 builtin function         dcl 187 in procedure "hasp_ws_sim_driver_" ref 352
                                                                                  352 353 731 731 732
length                                 based           fixed bin(17,0)          level 2 in structure "text_strings" dcl 7-39
                                                                                  in procedure "hasp_ws_sim_driver_" ref 229 229 265
                                                                                  265
line_nbrs               102(08)        based           bit(1)                   level 3 packed packed unaligned dcl 3-20 set ref
                                                                                  531*
local_request_type              000140 automatic       char(24)                 packed unaligned dcl 92 set ref 352 353 358* 359*
                                                                                  361* 368* 374 731 732 738* 739* 741* 748* 754
log                             000130 constant        fixed bin(17,0)          initial dcl 166 set ref 453* 503* 509* 523* 540*
log_msg                 342(04)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 set ref
                                                                                  452*
ltrim                                                  builtin function         dcl 187 ref 882
major_args                             based           char                     packed unaligned dcl 94 in procedure
                                                                                  "hasp_ws_sim_driver_" set ref 233* 240* 849*
major_args              164            based           structure                level 2 in structure "iodd_static" packed packed
                                                                                  unaligned dcl 9-17 in procedure
                                                                                  "hasp_ws_sim_driver_"
major_args_length               000152 automatic       fixed bin(17,0)          dcl 96 set ref 230* 233 233 235* 240 240 849 849
major_args_name                 000153 automatic       varying char(256)        dcl 97 set ref 233* 234 235*
major_args_ptr                  000150 automatic       pointer                  dcl 95 set ref 229* 233 235* 240 849
major_device            154            based           char(32)                 level 2 dcl 9-17 set ref 403*
master                          000144 constant        fixed bin(17,0)          initial dcl 163 set ref 208* 214* 242* 296* 333*
                                                                                  353* 361* 368* 385* 390* 420* 429* 461* 559* 575*
                                                                                  862* 898*
master_in                70            based           pointer                  level 2 dcl 9-17 ref 314
message                 240            based           fixed bin(17,0)          level 2 in structure "driver_status" dcl 5-25
                                                                                  in procedure "hasp_ws_sim_driver_" set ref 500
message                                parameter       char                     packed unaligned dcl 913 in procedure
                                                                                  "initiate_the_file" ref 907
message_type            113            based           fixed bin(17,0)          level 2 in structure "driver_status" dcl 5-25
                                                                                  in procedure "hasp_ws_sim_driver_" set ref 288*
                                                                                  508
message_type             65            based           fixed bin(17,0)          level 2 in structure "queue_msg_hdr" dcl 13-12
                                                                                  in procedure "hasp_ws_sim_driver_" ref 508
minor_args               54            based           structure                level 2 in structure "driver_status" packed packed
                                                                                  unaligned dcl 5-25 in procedure
                                                                                  "hasp_ws_sim_driver_"
minor_args                             based           char                     packed unaligned dcl 98 in procedure
                                                                                  "hasp_ws_sim_driver_" set ref 269* 277* 327* 343*
                                                                                  344* 408* 427* 850*
minor_args_length               000256 automatic       fixed bin(17,0)          dcl 100 set ref 266* 269 269 271* 277 277 327 327
                                                                                  343 343 344 344 408 408 427 427 850 850
minor_args_name                 000257 automatic       varying char(256)        dcl 101 set ref 269* 270 271*
minor_args_ptr                  000254 automatic       pointer                  dcl 99 set ref 265* 269 271* 277 327 343 344 408 427
                                                                                  850
mode                            001057 automatic       fixed bin(17,0)          dcl 835 set ref 840* 845* 860*
mseg_message_info                      based           structure                level 1 dcl 11-9
mseg_message_info_copy                 based           structure                level 2 dcl 15-8
myname                          000000 constant        char(19)                 initial packed unaligned dcl 179 set ref 208* 214*
                                                                                  242* 296* 333* 353* 361* 368* 385* 390* 414* 420*
                                                                                  429* 559* 575* 686* 732* 741* 779* 862* 898*
n_channels               26            based           fixed bin(17,0)          level 3 dcl 6-7 set ref 324*
n_iocb_ptrs               1            based           fixed bin(17,0)          level 2 dcl 6-7 set ref 325*
n_tokens                  1            based           fixed bin(17,0)          level 2 dcl 131 ref 644 701 726 768
no_coord                        000650 stack reference condition                dcl 189 ref 225
no_ident                  1(01) 000010 internal static bit(1)                   level 3 packed packed unaligned dcl 126 set ref 328*
                                                                                  330* 706* 709*
normal                          000144 constant        fixed bin(17,0)          initial dcl 167 set ref 281* 296* 302* 333* 353*
                                                                                  361* 368* 385* 390* 403* 411* 414* 420* 429* 461*
                                                                                  616* 624* 626* 627* 628* 629* 632* 633* 641* 647*
                                                                                  662* 670* 677* 681* 686* 690* 697* 702* 713* 722*
                                                                                  732* 741* 748* 761* 765* 769* 774* 779*
null                                                   builtin function         dcl 187 ref 257 258 296 455 455 457 457 552 552 565
                                                                                  565 579 579 596 596 816 818 818 823
omode                           000360 automatic       char(256)                packed unaligned dcl 102 set ref 667*
ordata                                 based           structure                level 1 dcl 12-17
output_module           101            based           fixed bin(17,0)          level 2 dcl 3-20 ref 534
output_request_                 000242 constant        entry                    external dcl 154 ref 555
output_request_$error_during_request
                                000246 constant        entry                    external dcl 156 ref 805
output_request_$set_single_copy 000244 constant        entry                    external dcl 155 ref 668
p                               000102 automatic       pointer                  dcl 471 in procedure "drop_device" set ref 480* 483
p                               000460 automatic       pointer                  dcl 103 in procedure "hasp_ws_sim_driver_" set ref
                                                                                  255* 257 258 260 261 262 265 266 280 281 283 287
                                                                                  288 289 291 292 294 296 300 302 305 309 322 333
                                                                                  353 361 368 390 420 429 498* 499 500 508 552 555
                                                                                  565 592* 593 596 854 856 856 860 862 867 867 869
p2                              000462 automatic       pointer                  dcl 104 set ref 499* 503 503 505 509 509 509 514 515
                                                                                  516 523 523 523 528 540 540 540 545 593* 601
pathname_string                        parameter       varying char(256)        dcl 910 ref 907 921
pool_dir                        000036 internal static char(168)                initial packed unaligned dcl 182 set ref 378* 380*
                                                                                  382* 413* 685* 778*
pool_manager_$clean_pool        000252 constant        entry                    external dcl 158 ref 778
pool_manager_$init              000250 constant        entry                    external dcl 157 ref 382
printer_input_device                   constant        fixed bin(17,0)          initial dcl 14-18 ref 339 365 745
priority                  6     000612 automatic       fixed bin(17,0)          level 2 dcl 113 set ref 894*
punch_input_device                     constant        fixed bin(17,0)          initial dcl 14-19 ref 341 365 745
punch_rmcc_mode                        constant        fixed bin(17,0)          initial dcl 170 ref 536
q                        33            based           fixed bin(17,0)          level 2 dcl 15-8 set ref 503* 509* 523* 540*
queue_msg_hdr                          based           structure                level 1 dcl 13-12
queue_msg_hdr_version_1                constant        fixed bin(17,0)          initial dcl 13-37 ref 502
quit_during_request     310(09)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 set ref
                                                                                  549*
re_init                         000642 stack reference condition                dcl 189 ref 561
re_init_in_progress     310(11)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 set ref
                                                                                  447*
re_init_label            26            based           label variable           level 2 dcl 9-17 ref 463
read_ev_chan                    000622 automatic       fixed bin(71,0)          level 2 dcl 118 set ref 323
read_info                       000622 automatic       structure                level 1 dcl 118 set ref 309 309
ready                    47(02)        based           bit(1)                   level 3 packed packed unaligned dcl 5-25 set ref
                                                                                  289*
receive_file_                   000254 constant        entry                    external dcl 159 ref 413 685
receive_file_data                      based           structure                level 1 dcl 14-7
receive_file_data_version_1            constant        fixed bin(17,0)          initial dcl 14-16 ref 247
request_descriptor                     based           structure                level 1 dcl 15-8
request_in_progress     310(02)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 ref 665 805
request_type              3     000010 internal static char(32)                 level 2 dcl 126 set ref 250* 347* 374* 727* 754*
rqti_ptr                 64            based           pointer                  level 2 dcl 5-25 ref 296
rtrim                                                  builtin function         dcl 187 ref 378 395 395 397 844 848
save_code                       000464 automatic       fixed bin(35,0)          dcl 105 set ref 620* 787
send_hangup                     000100 automatic       bit(1)                   packed unaligned dcl 470 in procedure "drop_device"
                                                                                  set ref 473* 479* 483*
send_hangup                            parameter       bit(1)                   packed unaligned dcl 813 in procedure
                                                                                  "close_and_detach" ref 810 818
sender_id                13            based           char(32)                 level 3 packed packed unaligned dcl 15-8 set ref
                                                                                  509* 523* 540*
seq_id                   32            based           fixed bin(35,0)          level 2 dcl 15-8 set ref 503* 509* 523* 540*
set_iod_val                     000220 constant        entry                    external dcl 145 ref 395
slave                   312            based           structure                level 2 in structure "iodd_static" dcl 9-17
                                                                                  in procedure "hasp_ws_sim_driver_"
slave                                  constant        fixed bin(17,0)          initial dcl 164 in procedure "hasp_ws_sim_driver_"
                                                                                  ref 764
slave_ev_chan           340            based           fixed bin(71,0)          level 3 dcl 9-17 ref 319
slave_hold              310(07)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 set ref
                                                                                  399* 557* 576*
slave_in                334            based           pointer                  level 3 dcl 9-17 ref 318
slave_out               336            based           pointer                  level 3 dcl 9-17 set ref 455* 457* 579*
source                          000465 automatic       fixed bin(17,0)          dcl 106 set ref 411* 414* 612* 616* 624* 626* 627*
                                                                                  628* 629* 632* 633* 641* 647* 662* 670* 677* 681*
                                                                                  686* 690* 697* 702* 713* 722* 732* 741* 748* 761*
                                                                                  764 765* 769* 774* 779*
space                           011462 constant        char(1)                  initial packed unaligned dcl 162 ref 849 850
stat_p                          000174 internal static pointer                  dcl 9-15 set ref 203* 205 207 213 219 219 229 230
                                                                                  249 255 314 315 317 318 319 378 378 397 399 403
                                                                                  403 436* 447 452 455 457 463 480 498 549 555* 557
                                                                                  571 576 579 579 592 665 666 805 848 893
state                           000466 automatic       fixed bin(17,0)          dcl 107 set ref 613*
static_default_request_type     000023 internal static char(32)                 initial packed unaligned dcl 127 set ref 347* 374*
                                                                                  727
static_receive_data             000010 internal static structure                level 1 dcl 126 set ref 413 413 685 685
static_sw_info                  000120 internal static structure                level 1 dcl 185 set ref 312 413 413 685 685
station                         000110 internal static char(32)                 packed unaligned dcl 183 set ref 204* 240* 241 395
                                                                                  395 397 413* 453* 685*
status_flags             47            based           structure                level 2 dcl 5-25
sw_info                                based           structure                level 1 dcl 6-7
sw_info_p                       000720 automatic       pointer                  dcl 6-5 set ref 312* 313 314 315 318 319 322 323 324
                                                                                  325
sw_info_version_1                      constant        fixed bin(17,0)          initial dcl 6-17 ref 313
sys_dir                                based           char(168)                packed unaligned dcl 129 ref 378
sys_dir_ptr              22            based           pointer                  level 2 dcl 9-17 ref 378
term_info                       000571 automatic       structure                level 1 dcl 111 set ref 291 291
terminal_info                          based           structure                level 1 dcl 16-6
terminal_info_version                  constant        fixed bin(17,0)          initial dcl 16-16 ref 252
test_entry              310(01)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 ref 249 378
                                                                                  571
testing                   1     000010 internal static bit(1)                   level 3 packed packed unaligned dcl 126 set ref 249*
text_offset                            based           structure                level 1 packed packed unaligned dcl 7-45
text_strings                           based           structure                level 1 dcl 7-39
text_strings_ptr         14            based           pointer                  level 2 in structure "iodd_static" dcl 9-17
                                                                                  in procedure "hasp_ws_sim_driver_" ref 205
text_strings_ptr                000722 automatic       pointer                  dcl 7-38 in procedure "hasp_ws_sim_driver_" set ref
                                                                                  205* 229 229 265 265
time                            000034 internal static fixed bin(71,0)          initial dcl 181 set ref 567* 571 571* 650* 654*
timer_manager_$sleep            000256 constant        entry                    external dcl 160 ref 567 571
total_chars             164(18)        based           fixed bin(18,0)          level 3 in structure "iodd_static" packed packed
                                                                                  unsigned unaligned dcl 9-17 in procedure
                                                                                  "hasp_ws_sim_driver_" ref 230
total_chars              54(18)        based           fixed bin(18,0)          level 3 in structure "driver_status" packed packed
                                                                                  unsigned unaligned dcl 5-25 in procedure
                                                                                  "hasp_ws_sim_driver_" ref 266
value                           000467 automatic       fixed bin(17,0)          dcl 108 set ref 645* 645 646 646 650
value_string                    000470 automatic       varying char(256)        dcl 109 set ref 327* 328 328 330 333* 343* 344 344*
                                                                                  347 352 353* 358 408* 409 417 420*
version                  76            based           fixed bin(17,0)          level 2 in structure "dprint_msg" dcl 3-20
                                                                                  in procedure "hasp_ws_sim_driver_" ref 519 519 519
                                                                                  531
version                         000010 internal static fixed bin(17,0)          level 2 in structure "static_receive_data" dcl 126
                                                                                  in procedure "hasp_ws_sim_driver_" set ref 247*
version                                based           fixed bin(17,0)          level 2 in structure "sw_info" dcl 6-7 in procedure
                                                                                  "hasp_ws_sim_driver_" set ref 313*
version                         000571 automatic       fixed bin(17,0)          level 2 in structure "term_info" dcl 111
                                                                                  in procedure "hasp_ws_sim_driver_" set ref 252*
wait_list                26            based           structure                level 2 dcl 6-7

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ATTACH_TYPE_DIAL                       internal static fixed bin(17,0)          initial dcl 8-15
ATTACH_TYPE_IOM                        internal static fixed bin(17,0)          initial dcl 8-15
ATTACH_TYPE_VARIABLE_LINE              internal static fixed bin(17,0)          initial dcl 8-15
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
CTL_ATTACH_TYPE_DIAL                   internal static fixed bin(17,0)          initial dcl 8-21
CTL_ATTACH_TYPE_MC                     internal static fixed bin(17,0)          initial dcl 8-21
CTL_ATTACH_TYPE_TTY                    internal static fixed bin(17,0)          initial dcl 8-21
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
Direct_input                           internal static fixed bin(17,0)          initial dcl 10-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 10-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 10-15
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
IODT_VERSION_5                         internal static char(8)                  initial packed unaligned dcl 7-49
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 10-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 10-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 10-15
MSEG_MESSAGE_INFO_V1                   internal static char(8)                  initial dcl 11-28
MSEG_READ_AFTER_SPECIFIED              internal static fixed bin(17,0)          initial dcl 11-30
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 11-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 11-38
MSEG_READ_FIRST                        internal static fixed bin(17,0)          initial dcl 11-30
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 11-30
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 11-38
MSEG_READ_SPECIFIED                    internal static fixed bin(17,0)          initial dcl 11-30
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
PAPER_TYPE_CONTINUOUS                  internal static fixed bin(17,0)          initial dcl 8-26
PAPER_TYPE_DEFAULT                     internal static fixed bin(17,0)          initial dcl 8-26
PAPER_TYPE_SINGLE                      internal static fixed bin(17,0)          initial dcl 8-26
REQUEST                                automatic       structure                level 1 dcl 12-69
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
STATE_BUMPED                           internal static fixed bin(17,0)          initial dcl 13-46
STATE_DEFERRED                         internal static fixed bin(17,0)          initial dcl 13-42
STATE_DUPT                             internal static fixed bin(17,0)          initial dcl 13-47
STATE_ELIGIBLE                         internal static fixed bin(17,0)          initial dcl 13-44
STATE_RUNNING                          internal static fixed bin(17,0)          initial dcl 13-45
STATE_TRANSITION                       internal static fixed bin(17,0)          initial dcl 13-43
STATE_UNPROCESSED                      internal static fixed bin(17,0)          initial dcl 13-41
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
Sequential_input                       internal static fixed bin(17,0)          initial dcl 10-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 10-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 10-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 10-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 10-15
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 2-30
driver_ptr_list                        based           structure                level 1 unaligned dcl 4-9
driver_status_ptr                      automatic       pointer                  dcl 5-24
forms_max_lth                          internal static fixed bin(17,0)          initial dcl 3-55
head_max_lth                           internal static fixed bin(17,0)          initial dcl 3-55
iod_tables_hdr                         based           structure                level 1 dcl 7-23
iox_modes                              internal static char(24)                 initial array dcl 10-6
ithp                                   automatic       pointer                  dcl 7-22
label_max_lth                          internal static fixed bin(17,0)          initial dcl 3-55
list_ptr                               automatic       pointer                  dcl 4-7
mseg_message_info_ptr                  automatic       pointer                  dcl 11-7
ordatap                                automatic       pointer                  dcl 12-67
path_max_lth                           internal static fixed bin(17,0)          initial dcl 3-55
receive_file_data_ptr                  automatic       pointer                  dcl 14-5
short_iox_modes                        internal static char(4)                  initial array dcl 10-12
terminal_info_ptr                      automatic       pointer                  dcl 16-15

NAMES DECLARED BY EXPLICIT CONTEXT.
abort_auto_receive              004223 constant        label                    dcl 415 ref 412
abort_read                      006775 constant        label                    dcl 690 ref 683
attach_error                    010752 constant        label                    dcl 862 ref 858
be_nice                         005006 constant        label                    dcl 515 ref 506 529 546
clean_out                       004410 constant        label                    dcl 439 ref 236 244 273 310 336 356 363 372 386 392
                                                                                  423 432 864 899
close_and_detach                010172 constant        entry                    internal dcl 810 ref 483
cmd_error                       010063 constant        label                    dcl 795 ref 617 642 648 663 678 691 698 703 714 723
                                                                                  735 742 751 762 766 770 775
command                         005647 constant        entry                    external dcl 608
default_handler                 010072 constant        entry                    external dcl 800
detach_device                   010136 constant        entry                    internal dcl 476 ref 226
device_common                   010145 constant        label                    dcl 480 set ref 474
drop_device                     010125 constant        entry                    internal dcl 467 ref 222 224 225 439 459
end_cmd                         010057 constant        label                    dcl 790 set ref 635 651 655 671 688 716 728 755 781
get_switch_name                 011031 constant        entry                    internal dcl 875 ref 854
hasp_ws_sim_driver_             001445 constant        entry                    external dcl 54
init                            001456 constant        entry                    external dcl 200
initiate_the_file               011235 constant        entry                    internal dcl 907 ref 235 271
logout_slave                    004415 constant        label                    dcl 447 ref 223
minor_attach                    010266 constant        entry                    internal dcl 829 ref 285 307
print_banner                    005553 constant        entry                    external dcl 586 ref 555 555
request                         004640 constant        entry                    external dcl 495
set_hangup_proc                 011131 constant        entry                    internal dcl 886 ref 869

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     12232       12532   11465       12242
Length     13466   11465       300         720     545         170

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
hasp_ws_sim_driver_                1174 external procedure  is an external procedure.  
on unit on line 222                  64 on unit               
on unit on line 223                  64 on unit               
on unit on line 224                  64 on unit               
on unit on line 225                  64 on unit               
on unit on line 226                  64 on unit               
on unit on line 412                  64 on unit               
drop_device                         106 internal procedure  is called by several nonquick procedures.  
on unit on line 551                  90 on unit               
on unit on line 615                  98 on unit               
on unit on line 683                  64 on unit               
close_and_detach                        internal procedure  shares stack frame of internal procedure drop_device.  
minor_attach                            internal procedure  shares stack frame of external procedure hasp_ws_sim_driver_.  
get_switch_name                         internal procedure  shares stack frame of external procedure hasp_ws_sim_driver_.  
set_hangup_proc                         internal procedure  shares stack frame of external procedure hasp_ws_sim_driver_.  
initiate_the_file                       internal procedure  shares stack frame of external procedure hasp_ws_sim_driver_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 static_receive_data         hasp_ws_sim_driver_
000023 static_default_request_type hasp_ws_sim_driver_
000034 time                        hasp_ws_sim_driver_
000036 pool_dir                    hasp_ws_sim_driver_
000110 station                     hasp_ws_sim_driver_
000120 static_sw_info              hasp_ws_sim_driver_
000174 stat_p                      hasp_ws_sim_driver_
000176 index                       get_switch_name

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
drop_device              000100 send_hangup                 drop_device
                         000102 p                           drop_device
                         000112 code                        close_and_detach
hasp_ws_sim_driver_      000100 age                         hasp_ws_sim_driver_
                         000102 argp                        hasp_ws_sim_driver_
                         000104 banner_type                 hasp_ws_sim_driver_
                         000105 code                        hasp_ws_sim_driver_
                         000106 date_string                 hasp_ws_sim_driver_
                         000114 device_type                 hasp_ws_sim_driver_
                         000124 element_size                hasp_ws_sim_driver_
                         000125 format_code                 hasp_ws_sim_driver_
                         000126 generic_type                hasp_ws_sim_driver_
                         000136 ignore                      hasp_ws_sim_driver_
                         000137 last                        hasp_ws_sim_driver_
                         000140 local_request_type          hasp_ws_sim_driver_
                         000146 iocbp                       hasp_ws_sim_driver_
                         000150 major_args_ptr              hasp_ws_sim_driver_
                         000152 major_args_length           hasp_ws_sim_driver_
                         000153 major_args_name             hasp_ws_sim_driver_
                         000254 minor_args_ptr              hasp_ws_sim_driver_
                         000256 minor_args_length           hasp_ws_sim_driver_
                         000257 minor_args_name             hasp_ws_sim_driver_
                         000360 omode                       hasp_ws_sim_driver_
                         000460 p                           hasp_ws_sim_driver_
                         000462 p2                          hasp_ws_sim_driver_
                         000464 save_code                   hasp_ws_sim_driver_
                         000465 source                      hasp_ws_sim_driver_
                         000466 state                       hasp_ws_sim_driver_
                         000467 value                       hasp_ws_sim_driver_
                         000470 value_string                hasp_ws_sim_driver_
                         000571 term_info                   hasp_ws_sim_driver_
                         000612 hangup_info                 hasp_ws_sim_driver_
                         000622 read_info                   hasp_ws_sim_driver_
                         000706 condition                   hasp_ws_sim_driver_
                         000716 dmp                         hasp_ws_sim_driver_
                         000720 sw_info_p                   hasp_ws_sim_driver_
                         000722 text_strings_ptr            hasp_ws_sim_driver_
                         000734 desc                        minor_attach
                         001035 io_module                   minor_attach
                         001046 dev_opt                     minor_attach
                         001057 mode                        minor_attach
                         001102 dirname                     initiate_the_file
                         001154 entname                     initiate_the_file
                         001164 compname                    initiate_the_file
                         001174 args_bc                     initiate_the_file

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return_mac          tra_ext_1           tra_ext_2           signal_op           enable_op
shorten_stack       ext_entry           ext_entry_desc      int_entry           any_to_any_truncate_clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
add_char_offset_              continue_to_signal_           date_time_                    expand_pathname_$component
initiate_file_$component      iod_info_$generic_type        iodd_hangup_$iodd_hangup_     iodd_listen_
iodd_msg_                     iodd_parse_$args              iox_$attach_ioname            iox_$close
iox_$control                  iox_$detach_iocb              iox_$modes                    iox_$open
output_request_               output_request_$error_during_request
output_request_$set_single_copy                             pool_manager_$clean_pool      pool_manager_$init
receive_file_                 set_iod_val                   timer_manager_$sleep

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$bigarg           error_table_$fatal_error
error_table_$io_no_permission error_table_$ionmat           error_table_$not_closed       error_table_$not_detached
error_table_$undefined_order_request




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     54 001444        57 001452       200 001453       203 001466       204 001472       205 001475       207 001477
    208 001502       210 001534       213 001535       214 001540       216 001572       219 001573       222 001601
    223 001623       224 001642       225 001664       226 001706       229 001730       230 001753       233 001760
    234 002007       235 002014       236 002023       240 002025       241 002063       242 002067       244 002121
    247 002122       248 002124       249 002132       250 002140       251 002143       252 002144       253 002146
    255 002147       257 002151       258 002153       260 002154       261 002155       262 002156       265 002161
    266 002202       269 002206       270 002236       271 002243       273 002252       277 002254       279 002310
    280 002314       281 002317       283 002357       285 002363       287 002366       288 002371       289 002373
    291 002375       292 002427       294 002435       296 002440       298 002500       299 002501       300 002511
    302 002514       305 002565       307 002571       309 002574       310 002630       312 002632       313 002635
    314 002637       315 002642       316 002646       317 002650       318 002653       319 002656       320 002662
    322 002663       323 002670       324 002673       325 002675       327 002676       328 002726       330 002746
    333 002761       336 003026       339 003027       341 003036       343 003040       344 003070       347 003125
    352 003150       353 003153       356 003225       358 003226       359 003232       360 003253       361 003255
    363 003321       365 003322       368 003340       372 003413       374 003414       378 003430       380 003464
    382 003470       384 003520       385 003522       386 003555       388 003556       390 003557       392 003624
    395 003625       397 003666       399 003717       402 003722       403 003741       406 004011       408 004021
    409 004052       411 004057       412 004113       413 004132       414 004166       415 004223       417 004224
    420 004232       423 004277       425 004300       427 004301       429 004337       432 004400       436 004401
    439 004410       445 004414       447 004415       451 004421       452 004440       453 004444       455 004507
    457 004540       459 004573       461 004577       463 004633       495 004637       498 004645       499 004651
    500 004653       502 004655       503 004660       505 004722       506 004725       508 004726       509 004731
    514 005003       515 005006       516 005011       517 005013       519 005014       523 005023       528 005075
    529 005100       531 005101       534 005105       536 005107       537 005111       538 005113       540 005114
    545 005166       546 005171       549 005172       551 005175       552 005211       553 005245       555 005246
    556 005307       557 005311       558 005315       559 005317       561 005351       565 005354       566 005407
    567 005411       569 005424       570 005425       571 005430       573 005452       575 005453       576 005505
    579 005511       582 005545       586 005546       589 005566       590 005571       592 005573       593 005577
    595 005601       596 005603       600 005632       601 005635       604 005641       608 005642       611 005657
    612 005662       613 005665       615 005667       616 005703       617 005737       620 005742       621 005745
    623 005747       624 005755       625 006011       626 006014       627 006046       628 006105       629 006141
    630 006175       632 006176       633 006231       635 006264       639 006265       640 006277       641 006302
    642 006335       644 006336       645 006341       646 006351       647 006355       648 006411       650 006412
    651 006416       654 006417       655 006421       660 006422       661 006427       662 006432       663 006465
    665 006466       666 006472       667 006475       668 006523       669 006530       670 006531       671 006564
    675 006565       676 006572       677 006575       678 006630       681 006631       683 006664       685 006703
    686 006737       688 006774       690 006775       691 007031       695 007032       696 007044       697 007047
    698 007102       701 007103       702 007106       703 007141       706 007142       709 007154       713 007166
    714 007221       716 007222       720 007223       721 007242       722 007245       723 007300       726 007301
    727 007304       728 007307       731 007310       732 007313       735 007361       738 007362       739 007366
    740 007406       741 007410       742 007446       745 007447       748 007465       751 007533       754 007534
    755 007537       759 007540       760 007552       761 007555       762 007610       764 007611       765 007614
    766 007647       768 007650       769 007653       770 007706       772 007707       773 007717       774 007722
    775 007770       778 007771       779 010017       781 010054       787 010055       788 010056       790 010057
    793 010062       795 010063       798 010067       800 010070       804 010077       805 010106       808 010123
    467 010124       473 010132       474 010134       476 010135       479 010143       480 010145       483 010151
    485 010161       487 010171       810 010172       816 010174       818 010201       820 010236       821 010250
    823 010262       825 010265       829 010266       837 010277       838 010305       839 010312       840 010317
    841 010321       843 010322       844 010327       845 010350       848 010352       849 010422       850 010507
    852 010575       854 010632       856 010655       858 010715       860 010725       861 010745       862 010752
    864 011015       867 011016       869 011022       871 011030       875 011031       880 011042       881 011044
    882 011051       886 011131       892 011133       893 011140       894 011142       896 011144       897 011176
    898 011200       899 011233       902 011234       907 011235       921 011246       922 011310       924 011315
    925 011355       927 011361       929 011365


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
