	COMPILATION LISTING OF SEGMENT fortran_storage_manager_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/20/86  1156.6 mst Thu
	    Options: optimize list

        1 /****^  ******************************************
        2*        *                                        *
        3*        * Copyright, (C) Honeywell Limited, 1983 *
        4*        *                                        *
        5*        ****************************************** */
        6 
        7 
        8 
        9 /****^  HISTORY COMMENTS:
       10*  1) change(86-08-20,DGHowe), approve(86-08-20,MCR7391),
       11*     audit(86-08-01,Schroth), install(86-11-20,MR12.0-1222):
       12*     removed unrequired declarations.
       13*                                                   END HISTORY COMMENTS */
       14 
       15 
       16 /* format: style3,^delnl,linecom */
       17 fortran_storage_manager_:
       18 fsm_:
       19      proc options (support);
       20 
       21 /*  Author:  H. Hoover,  University of Calgary,  82-08-12.                   */
       22 /*                                                                           */
       23 /*  Modified:                                                                */
       24 /*     84-10-10 by MM - 442:  Set 256K switch once per process.  Do not set  */
       25 /*        it prior to creating a segment.			       */
       26 /*     83-07-10 by TO:  Set 256K switch prior to creating a 256K segment     */
       27 /*     83-06-16 by TO:  Use condition_info_header, have options (support).   */
       28 /*     83-02-15 by TO:  Create get_vla_segnos entry to return information to */
       29 /*	run_ as to the segment numbers created for storage.	       */
       30 /*     83-01-19 by TO:  Allow storage directory per-ring.                    */
       31 /*     83-01-19 by TO:  Set maximum length of segments from                  */
       32 /*        pl1_operators_$VLA_words_per_seg_ for general runtime use.         */
       33 /*     83-01-19 by TO:  Set safety switch for fsm_dir, fsm_info and fsm_segs.*/
       34 /*     82-10-14 by HH:  Allow storage to be allocated from anywhere in the   */
       35 /*        storage heirarchy (rather than just the process directory) and     */
       36 /*        allow multiple processes to share the same pool of free segments.  */
       37 
       38 /*  Function:  to allocate, free and list storage in connection with large   */
       39 /*     and very large 'fortran' arrays.                                      */
       40 
       41 /*  Error processing:                                                        */
       42 /*                                                                           */
       43 /*  The entry points in this procedure do not return a status code if an     */
       44 /*  error occurs.  Instead, the condition 'fortran_storage_manager_error' is */
       45 /*  signalled with a description of what the error is.  If the user chooses  */
       46 /*  to restart, we assume he has done something to fix the problem and we    */
       47 /*  retry the operation that detected the error.  If the problem is not      */
       48 /*  fixed, we again signal the condition 'fortran_storage_manager_error'.    */
       49 /*  This continues ad nauseum until either the user fixes the problem or     */
       50 /*  gives up and releases.					       */
       51 
       52 dcl	get_lock_id_	entry returns (bit (36) aligned);
       53 
       54 dcl	False		bit (1) static options (constant) init ("0"b),
       55 	True		bit (1) static options (constant) init ("1"b),
       56 	fsm_dir_name_master char (8) static options (constant) init ("fsm_dir_"),
       57 	fsm_info_name	char (13) static options (constant) init ("fsm_info.fsm_");
       58      
       59 
       60 dcl	01 fsm_info	aligned based (fsm_info_ptr),
       61 	  02 lock		bit (36),			/*  Lock word.  */
       62 	  02 seg_cnt	fixed bin,		/*  Total number of allocated and free segments.  */
       63 	  02 seg		(fsm_info.seg_cnt),
       64 	    03 owning_process
       65 			bit (36),			/*  Lock ID for owning process.  ""b => Free.  */
       66 	    03 owner	ptr unal,			/*  Pointer to owner of this segment.  */
       67 	    03 first_seg_in_group
       68 			fixed bin,		/*  Index of first seg in this group.  */
       69 	    03 next_seg_in_group
       70 			fixed bin,		/*  Index of next seg in this group.  */
       71 	    03 seg_num	fixed bin;		/*  Number under which segment is initiated.  */
       72 
       73 dcl	fsm_dir_path	char (168) static init (""),
       74 	fsm_info_path	char (168) static init (""),
       75 	fsm_info_ptr	ptr static init (null),
       76 	fsm_info_ptr_valid	bit (1) static init ("0"b);
       77 
       78 dcl	me		ptr init (codeptr (fsm_)),
       79 	my_process	bit (36) aligned init (get_lock_id_ ());
       80 
       81 
       82 	return;					/*  Just ignore calls to the main entry point.  */
       83 
       84 alloc:
       85      entry (num_segs_desired, owner, first_seg_ptr);
       86 
       87 /*  Function:  to allocate a specified number of segments with consecutive   */
       88 /*     segment numbers.  The segments are created as needed.                 */
       89 
       90 /*  Arguments:                                                               */
       91 /*                                                                           */
       92 /*  num_segs_desired  (Input)                                                */
       93 /*     is the number of segments to be allocated.                            */
       94 /*                                                                           */
       95 /*  owner  (Input)                                                           */
       96 /*     is the address of a location which is considered to own the segments  */
       97 /*     to be allocated.  It is used to identify the segments which are to be */
       98 /*     deallocated by a call to the 'free' routine.                          */
       99 /*                                                                           */
      100 /*  first_seg_ptr  (Output)                                                  */
      101 /*     is the address of the base of the first segment allocated.  (The      */
      102 /*     addresses of the other segments are obtained by incrementing the      */
      103 /*     segment number portion of the address of the first segment.)  The     */
      104 /*     value 'null' is returned if 'num_segs_desired' is less than 1 or if   */
      105 /*     'owner' is 'null' or the 'fortran_storage_manager_' entry point.      */
      106 
      107 /*  Error handling:                                                          */
      108 /*                                                                           */
      109 /* If an error occurs during allocation, the 'fortran_storage_manager_error' */
      110 /*   condition is signalled.  If the user does not handle the condition, the */
      111 /*   system  will  display a diagnostic describing the error that caused the */
      112 /*   condition  to  be  signalled  and  establish  a new command level.  The */
      113 /*   'start'  command will cause the code that failed to be retried.  If the */
      114 /*  problem which caused the failure has been fixed, allocation will proceed */
      115 /*   as  though  the  error  had  never  occurred;  otherwise, the condition */
      116 /*  'fortran_storage_manager_error' will be signalled again.	       */
      117 /*                                                                           */
      118 /*  There is one error that can occur which the user need only restart the   */
      119 /*  allocation in order to correct:  'The segment number is in use.'  This   */
      120 /*  should only occur if the user suspends the allocation process with a     */
      121 /*  'quit' signal, does something that requires a new segment to be made     */
      122 /*  known, then restarts the allocation.  If the new segment is made known   */
      123 /*  under a segment number that was to be used for one of the segments being */
      124 /*  allocated, the above error occurs.  Restarting after such an error will  */
      125 /*  cause a new set of sequential segment numbers to be chosen.              */
      126 
      127 dcl	num_segs_desired	fixed bin,
      128 	owner		ptr,
      129 	first_seg_ptr	ptr;
      130 
      131 dcl	hcs_$initiate	entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35)),
      132 	hcs_$terminate_file entry (char (*), char (*), fixed bin (1), fixed bin (35)),
      133 	pathname_		entry (char (*), char (*)) returns (char (168));
      134 
      135 /* builtins */
      136 
      137 dcl       (addr, addrel, baseno, baseptr, before, bin, char, codeptr,
      138 	fixed, hbound, index, lbound, length, ltrim, ptr, rel, rtrim,
      139 	size, substr, sum, unspec, verify, null)		builtin;
      140 
      141 dcl	cleanup		condition;
      142 
      143 dcl	first_seg_in_group	fixed bin,
      144 	first_seg_num	fixed bin,
      145 	prev_seg_in_group	fixed bin,
      146 	seg_idx		fixed bin,
      147 	seg_num		fixed bin,
      148 	status		fixed bin (35),
      149 	try_again		bit (1);
      150 
      151 
      152 /*  Verify that the input arguments are valid.  */
      153 
      154 	first_seg_ptr = null;
      155 	if num_segs_desired <= 0 | owner = null | owner = me
      156 	then return;
      157 
      158 	on cleanup call release_fsm_info;
      159 	call appropriate_fsm_info;
      160 
      161 /*  Allocate the requested segments, specifying this object segment as the   */
      162 /*  owner, so that if we have to do a clean up, we will know which segments  */
      163 /*  we must deallocate.                                                      */
      164 
      165 	try_again = True;
      166 	do while (try_again);
      167 	     try_again = False;
      168 	     call pick_first_seg_num (num_segs_desired, first_seg_num);
      169 	     do seg_num = first_seg_num to first_seg_num + num_segs_desired - 1 while (^try_again);
      170 		call pick_seg (seg_idx);
      171 		if seg_num = first_seg_num
      172 		then first_seg_in_group = seg_idx;
      173 		else fsm_info.seg (prev_seg_in_group).next_seg_in_group = seg_idx;
      174 		fsm_info.seg (seg_idx).owning_process = my_process;
      175 		fsm_info.seg (seg_idx).owner = me;
      176 		fsm_info.seg (seg_idx).first_seg_in_group = first_seg_in_group;
      177 		fsm_info.seg (seg_idx).next_seg_in_group = 0;
      178 		fsm_info.seg (seg_idx).seg_num = seg_num;
      179 		call hcs_$initiate (fsm_dir_path, seg_name (seg_idx), "", 1, 0, baseptr (seg_num), status);
      180 		if status ^= 0
      181 		then do;
      182 			call signal_fsm_error (status,
      183 			     "(Trying to initiate " || pathname_ (fsm_dir_path, seg_name (seg_idx))
      184 			     || " as segment "
      185 			     || octal_representation (seg_num) || ")");
      186 			do seg_idx = first_seg_in_group repeat fsm_info.seg (seg_idx).next_seg_in_group
      187 			     while (seg_idx ^= 0);
      188 			     call hcs_$terminate_file (fsm_dir_path, seg_name (seg_idx), 0, status);
      189 			end;
      190 			try_again = True;
      191 		     end;
      192 		prev_seg_in_group = seg_idx;
      193 	     end;
      194 	end;
      195 
      196 /*  Transfer ownership of the allocated segments to the caller.  */
      197 
      198 	do seg_idx = 1 to fsm_info.seg_cnt;
      199 	     if fsm_info.seg (seg_idx).owning_process = my_process & fsm_info.seg (seg_idx).owner = me
      200 	     then fsm_info.seg (seg_idx).owner = owner;
      201 	end;
      202 	first_seg_ptr = baseptr (first_seg_num);
      203 	call release_fsm_info;
      204 	return;
      205 
      206 free:
      207      entry (owner);
      208 
      209 /*  Function:  to free all segments previously allocated to a specified      */
      210 /*     owner.                                                                */
      211 
      212 /*  Arguments:                                                               */
      213 /*                                                                            */
      214 /*  owner  (Input)                                                           */
      215 /*     is the address of the location that was specified (at allocation) to  */
      216 /*     be the owner of the segments that are now desired to be deallocated.  */
      217 /*     If there are no allocated segments with the specified owner, the      */
      218 /*     routine just returns, without comment.                                */
      219 
      220 dcl	hcs_$truncate_file	entry (char (*), char (*), fixed bin (19), fixed bin (35));
      221 
      222 	on cleanup call release_fsm_info;
      223 	call appropriate_fsm_info;
      224 
      225 	do seg_idx = 1 to fsm_info.seg_cnt;
      226 	     if fsm_info.seg (seg_idx).owning_process = my_process & fsm_info.seg (seg_idx).owner = owner
      227 	     then do;
      228 		     call hcs_$terminate_file (fsm_dir_path, seg_name (seg_idx), 0, status);
      229 		     call hcs_$truncate_file (fsm_dir_path, seg_name (seg_idx), 0, status);
      230 		     unspec (fsm_info.seg (seg_idx)) = ""b;
      231 		end;
      232 	end;
      233 	call release_fsm_info;
      234 	return;
      235 
      236 get_owner:
      237      entry (seg_ptr, owner);
      238 
      239 /*  Function:  to return the owner of a specified managed segment.  If the   */
      240 /*     specified segment is free or is not one of those managed by 'fsm_',   */
      241 /*     'null' is returned.                                                   */
      242 
      243 /*  Arguments:                                                               */
      244 /*                                                                           */
      245 /*  seg_ptr  (Input)                                                         */
      246 /*     is a pointer to any location in the segment whose owner is desired.   */
      247 
      248 dcl	seg_ptr		ptr;
      249 
      250 	on cleanup call release_fsm_info;
      251 	call appropriate_fsm_info;
      252 	do seg_idx = 1 to fsm_info.seg_cnt
      253 	     while (fsm_info.seg (seg_idx).owning_process ^= my_process
      254 	     | fsm_info.seg (seg_idx).seg_num ^= bin (baseno (seg_ptr)));
      255 	end;
      256 	if seg_idx <= fsm_info.seg_cnt
      257 	then owner = fsm_info.seg (seg_idx).owner;
      258 	else owner = null;
      259 	call release_fsm_info;
      260 	return;
      261 
      262 get_vla_segnos:
      263      entry (segment_map_bits);
      264 
      265 /*  Function:  to return a bit array with bits set for each segment created  */
      266 /*     by fortran_storage_manager_ in this process.		       */
      267 
      268 /*  Arguments:                                                               */
      269 /*                                                                           */
      270 /*  segment_map_bits (Input/Output)                                          */
      271 /*     is an array (*) of bits which is passed in.  This routine will set    */
      272 /*     bits corresponding to the segment numbers of external storage segments*/
      273 
      274 dcl	segment_map_bits	(*) bit (1);
      275 
      276 	on cleanup call release_fsm_info;
      277 	call appropriate_fsm_info;
      278 
      279 /*   Scan the groups of segments allocated to this process.                  */
      280 
      281 	do seg_idx = 1 to fsm_info.seg_cnt;
      282 	     if fsm_info.owning_process (seg_idx) = my_process
      283 	     then segment_map_bits (seg_idx) = "1"b;
      284 	end;
      285 	call release_fsm_info;
      286 	return;
      287 
      288 list_fortran_storage:
      289 lfs:
      290      entry;
      291 
      292 /*  Function:  to list (on the 'user_output' switch) the segments which are  */
      293 /*     currently allocated to this process.                                  */
      294 
      295 dcl	ioa_		entry options (variable);
      296 
      297 dcl	group_cnt		fixed bin;
      298 
      299 
      300 	on cleanup call release_fsm_info;
      301 	call appropriate_fsm_info;
      302 
      303 /*  Count the number of groups of segments that are allocated to this        */
      304 /*  process.                                                                 */
      305 
      306 	group_cnt = 0;
      307 	do seg_idx = 1 to fsm_info.seg_cnt;
      308 	     if fsm_info.owning_process (seg_idx) = my_process & fsm_info.first_seg_in_group (seg_idx) = seg_idx
      309 	     then group_cnt = group_cnt + 1;
      310 	end;
      311 
      312 /*  If there are any segments allocated to this process, list them by owner  */
      313 /*  and group.                                                               */
      314 
      315 	if group_cnt = 0
      316 	then call ioa_ ("No segments in ^a allocated to this process.", fsm_dir_path);
      317 	else do;
      318 		call ioa_ ("Segments in ^a allocated to this process:", fsm_dir_path);
      319 		call list_groups (group_cnt, my_process);
      320 	     end;
      321 	call release_fsm_info;
      322 	return;
      323 
      324 appropriate_fsm_info:
      325      proc;
      326 
      327 /*  Function:  to find and lock for this process 'fsm_info'.  'fsm_info' and */
      328 /*     its containing directory will be created if necessary.                */
      329 
      330 /*  Global arguments:                                                        */
      331 /*                                                                           */
      332 /*  fsm_dir_name_master  (Input)                                             */
      333 /*     is the name of the directory where the segment on which 'fsm_info' is */
      334 /*     based resides. (Ring number will be added later to create the dir.)   */
      335 /*                                                                           */
      336 /*  fsm_dir_path  (Output)                                                   */
      337 /*     is the absolute pathname of the directory where the segment on which  */
      338 /*     'fsm_info' is based resides.                                          */
      339 /*                                                                           */
      340 /*  fsm_info_name  (Input)                                                   */
      341 /*     is the name of the segment on which 'fsm_info' is based.              */
      342 /*                                                                           */
      343 /*  fsm_info_ptr  (Output)                                                   */
      344 /*     is the address of the base of the segment on which 'fsm_info' is      */
      345 /*     based.                                                                */
      346 
      347 dcl	error_table_$bad_segment
      348 			fixed bin (35) ext,
      349 	error_table_$invalid_lock_reset
      350 			fixed bin (35) ext,
      351 	error_table_$moderr fixed bin (35) ext,
      352 	error_table_$noentry
      353 			fixed bin (35) ext,
      354 	error_table_$notadir
      355 			fixed bin (35) ext,
      356 	error_table_$nomatch
      357 			fixed bin (35) ext;
      358 
      359 dcl	cu_$level_get	entry returns (fixed bin (3)),
      360 	get_group_id_$tag_star
      361 			entry returns (char (32)),
      362 	get_system_free_area_
      363 			entry returns (ptr),
      364 	hcs_$add_acl_entries
      365 			entry (char (*), char (*), ptr, fixed bin, fixed bin (35)),
      366 	hcs_$append_branchx
      367 			entry (char (*), char (*), fixed bin (5), (3) fixed bin (6), char (*), fixed bin (1),
      368 			fixed bin (1),
      369 			fixed bin (24), fixed bin (35)),
      370 	hcs_$make_seg	entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35)),
      371 	hcs_$set_safety_sw	entry (char (*), char (*), bit (1), fixed bin (35)),
      372 	hcs_$set_256K_switch
      373 			entry (bit (2) aligned, bit (2) aligned, fixed bin (35)),
      374 	hcs_$star_	entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr, fixed bin (35)),
      375 	hcs_$status_minf	entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35)),
      376 	pl1_operators_$VLA_words_per_seg_
      377 			fixed bin (19) external,
      378 	set_lock_$lock	entry (bit (36) aligned, fixed bin, fixed bin (35)),
      379 	sys_info$max_seg_size
      380 			fixed bin (35) ext;
      381 
      382 dcl	cleanup		condition;
      383 
      384 dcl	Chase_links	fixed bin (1) static options (constant) init (1),
      385 	Max_wait_time	fixed bin static options (constant) init (120);
      386 
      387 dcl	01 acl		aligned,
      388 	  02 access_name	char (32),
      389 	  02 modes	bit (36),
      390 	  02 xmodes	bit (36),
      391 	  02 status	fixed bin (35);
      392 
      393 dcl	bit_count		fixed bin (24),
      394 	fsm_dir_dir_path	char (168),
      395 	fsm_dir_name	char (32),
      396 	i		fixed bin,
      397 	max_seg_idx	fixed bin,
      398 	primary_name	char (32),
      399 	seg_cnt		fixed bin,
      400 	seg_idx		fixed bin,
      401 	status		fixed bin (35),
      402 	system_free_area_ptr
      403 			ptr init (null),
      404 	type		fixed bin (2);
      405 
      406 
      407 dcl	system_free_area	area based (system_free_area_ptr);
      408 
      409 dcl	get_ring_		entry () returns (fixed bin (3));
      410 
      411 
      412 /*  If  the  flag 'fsm_info_ptr_valid' is false, we must find 'fsm_info' and */
      413 /*   store the address of its base in 'fsm_info_ptr'.  If 'fsm_info' doesn't */
      414 /*  exist, we must create it (and possibly its containing directory).  If we */
      415 /*   are  unable  to  do this, we signal the 'fortran_storage_manager_error' */
      416 /*   condition  with a description of the problem.  If the user restarts us, */
      417 /*   we  assume  he  has  done  something to correct the problem, and we try */
      418 /*  again.						       */
      419 
      420 	if ^fsm_info_ptr_valid
      421 	then do;
      422 		if pl1_operators_$VLA_words_per_seg_ > sys_info$max_seg_size
      423 		then do;
      424 			call hcs_$set_256K_switch ("11"b, (""b), status);
      425 			if status ^= 0
      426 			then call signal_fsm_error (status, "Cannot set 256K switch");
      427 		     end;
      428 		fsm_info_ptr = null;
      429 		fsm_dir_name = fsm_dir_name_master || ltrim (char (get_ring_ ()));
      430 		do while (fsm_info_ptr = null);
      431 		     call get_fsm_dir_dir_path (fsm_dir_dir_path);
      432 		     fsm_dir_path = pathname_ (fsm_dir_dir_path, fsm_dir_name);
      433 		     fsm_info_path = pathname_ (fsm_dir_path, fsm_info_name);
      434 		     call hcs_$status_minf (fsm_dir_dir_path, fsm_dir_name, Chase_links, type, bit_count, status);
      435 		     if status = 0
      436 		     then if type = star_DIRECTORY & bit_count = 0
      437 			then do;			/*  Find 'fsm_info', creating it if necessary.  */
      438 				call hcs_$make_seg (fsm_dir_path, fsm_info_name, "", RW_ACCESS_BIN, fsm_info_ptr,
      439 				     status);
      440 				if status = error_table_$moderr
      441 				then do;		/*  Segment exists, but we don't have access. */
      442 					acl.access_name = get_group_id_$tag_star ();
      443 					acl.modes = RW_ACCESS;
      444 					acl.xmodes = ""b;
      445 					call hcs_$add_acl_entries (fsm_dir_path, fsm_info_name, addr (acl), 1,
      446 					     status);
      447 					if status = 0
      448 					then call hcs_$initiate (fsm_dir_path, fsm_info_name, "", 0, 0,
      449 						fsm_info_ptr, status);
      450 				     end;
      451 				if fsm_info_ptr = null
      452 				then call signal_fsm_error (status, fsm_info_path);
      453 			     end;
      454 			else call signal_fsm_error (error_table_$notadir, fsm_dir_path);
      455 		     else if status = error_table_$noentry
      456 		     then do;			/*  Create 'fsm_dir' and 'fsm_info'.  */
      457 			     call hcs_$append_branchx (fsm_dir_dir_path, fsm_dir_name, SMA_ACCESS_BIN,
      458 				cu_$level_get (),
      459 				get_group_id_$tag_star (), 1, 0, 0, status);
      460 			     if status = 0
      461 			     then do;		/*  Create 'fsm_info'.  */
      462 				     call hcs_$set_safety_sw (fsm_dir_dir_path, fsm_dir_name, "1"b, status);
      463 				     call hcs_$make_seg (fsm_dir_path, fsm_info_name, "", RW_ACCESS_BIN,
      464 					fsm_info_ptr, status);
      465 				     if fsm_info_ptr = null
      466 				     then call signal_fsm_error (status, fsm_info_path);
      467 				     call hcs_$set_safety_sw (fsm_dir_dir_path, fsm_info_name, "1"b, status);
      468 				end;
      469 			     else call signal_fsm_error (status, fsm_dir_path);
      470 			end;
      471 		     else call signal_fsm_error (status, fsm_dir_path);
      472 		end;
      473 	     end;
      474 
      475 /*  We  now have a pointer to 'fsm_info'.  However, we cannot use 'fsm_info' */
      476 /*  until we lock it so that we are safe from some other process altering it */
      477 /*   while  we use it.  If some other process is currently using it, we must */
      478 /*   wait  for that process to unlock it.  If that process doesn't unlock it */
      479 /*   in  a  reasonable  time,  we signal the 'fortran_storage_manager_error' */
      480 /*   condition, indicating that this has occurred.  If the user restarts us, */
      481 /*  we try again.						       */
      482 
      483 	status = 1;
      484 	do while (status ^= 0);
      485 	     call set_lock_$lock (fsm_info.lock, Max_wait_time, status);
      486 	     if status = error_table_$invalid_lock_reset
      487 	     then status = 0;
      488 	     else if status ^= 0
      489 	     then call signal_fsm_error (status, fsm_info_path);
      490 	end;
      491 
      492 /*  We now have 'fsm_info' all to ourselves.  However, it may not be valid.  */
      493 /*  It is fairly expensive to check for validity, so we only do it the first */
      494 /*  time we access 'fsm_info'.  This is reasonable, since serious problems   */
      495 /*  with the information in 'fsm_info' are rare and will be diagnosed later  */
      496 /*  anyway.                                                                  */
      497 /*                                                                           */
      498 /*  There are two ways in which 'fsm_info' could be invalid.  First, it may  */
      499 /*  not be consistent in that it knows about more or fewer managed segments  */
      500 /*  than actually exist in the directory.  Second, it may be out of date in  */
      501 /*  that it has some segments allocated to processes that no longer exist.   */
      502 /*                                                                           */
      503 /*  It  is  easy  to  tell if 'fsm_info' is inconsistent: We need only count */
      504 /*   number  of  managed segments (i.e.  segments whose first component is a */
      505 /*   positive  integer  and  whose  second component is 'fsm_') and find the */
      506 /*   managed  segment whose first component is numerically largest.  We have */
      507 /*   consistency if and only if both these numbers equal 'fsm_info.seg_cnt'. */
      508 /*   If  'fsm_info'  is  inconsistent,  the  'fortran_storage_manager_error' */
      509 /*   condition  is  signalled  with  a description of the problem.  The user */
      510 /*  probably cannot do anything about this, but if he chooses to restart, we */
      511 /*  repeat the validity test.					       */
      512 /*                                                                           */
      513 /*  If 'fsm_info' is found to be consistent, we examine all allocated        */
      514 /*  segments and free any found to be allocated to nonexistent processes.    */
      515 
      516 	do while (^fsm_info_ptr_valid);
      517 	     system_free_area_ptr = get_system_free_area_ ();
      518 	     star_entry_ptr, star_names_ptr = null;
      519 	     on cleanup
      520 		begin;				/*  Free anything that was allocated.  */
      521 		     if star_names_ptr ^= null
      522 		     then free star_names in (system_free_area);
      523 		     if star_entry_ptr ^= null
      524 		     then free star_entries in (system_free_area);
      525 		end;
      526 	     call hcs_$star_ (fsm_dir_path, "*.fsm_", star_BRANCHES_ONLY, system_free_area_ptr, star_entry_count,
      527 		star_entry_ptr, star_names_ptr, status);
      528 	     if status ^= 0 & status ^= error_table_$nomatch
      529 	     then call signal_fsm_error (status, fsm_info_path);
      530 	     else do;				/*  Check validity of 'fsm_info_'.  */
      531 		     seg_cnt, max_seg_idx = 0;
      532 		     do i = 1 to star_entry_count;
      533 			primary_name = star_names (star_entries (i).nindex);
      534 			if verify (before (primary_name, "."), "0123456789") = 0
      535 			     & substr (primary_name, 1, 1) ^= "0"
      536 			then do;			/*  This is a managed segment.  */
      537 				seg_cnt = seg_cnt + 1;
      538 				seg_idx = bin (before (primary_name, "."));
      539 				if seg_idx > max_seg_idx
      540 				then max_seg_idx = seg_idx;
      541 			     end;
      542 		     end;
      543 		     if star_names_ptr ^= null
      544 		     then free star_names in (system_free_area);
      545 		     if star_entry_ptr ^= null
      546 		     then free star_entries in (system_free_area);
      547 		     if max_seg_idx ^= seg_cnt | seg_cnt ^= fsm_info.seg_cnt
      548 		     then call signal_fsm_error (error_table_$bad_segment, fsm_info_path);
      549 		     else do;			/*  'fsm_info' is consistent.  */
      550 			     do seg_idx = 1 to fsm_info.seg_cnt;
      551 				if fsm_info.seg (seg_idx).owning_process ^= ""b
      552 				then do;
      553 					call set_lock_$lock ((fsm_info.seg (seg_idx).owning_process), 0, status)
      554 					     ;
      555 					if status = error_table_$invalid_lock_reset
      556 					then do;	/*  The owner is dead.  */
      557 						call hcs_$truncate_file (fsm_dir_path, seg_name (seg_idx), 0,
      558 						     status);
      559 						unspec (fsm_info.seg (seg_idx)) = ""b;
      560 					     end;
      561 				     end;
      562 			     end;
      563 			     fsm_info_ptr_valid = True;
      564 			end;
      565 		end;
      566 	end;
      567 	return;
      568 
      569 
  1     1 /* BEGIN INCLUDE FILE . . . star_structures.incl.pl1 */
  1     2 
  1     3 /* This include file contains structures for the hcs_$star_,
  1     4*   hcs_$star_list_ and hcs_$star_dir_list_ entry points.
  1     5*
  1     6*   Written 23 October 1978 by Monte Davidoff.
  1     7*   Modified January 1979 by Michael R. Jordan to use unsigned and different pointers for different structures.
  1     8*   Modified June 1981 by C. Hornig to count link pathnames more efficiently.
  1     9**/
  1    10 
  1    11 /* automatic */
  1    12 
  1    13 declare  star_branch_count fixed binary;		/* hcs_$star_list_, hcs_$star_dir_list_: matching branch count */
  1    14 declare  star_entry_count fixed binary;			/* hcs_$star_: number of matching entries */
  1    15 declare  star_entry_ptr pointer;			/* hcs_$star_: pointer to array of entry information */
  1    16 declare  star_list_branch_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to array of info */
  1    17 declare  star_link_count fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: matching link count */
  1    18 declare  star_linkx fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: index into star_links */
  1    19 declare  star_names_ptr pointer;			/* hcs_$star_: pointer to array of entry names */
  1    20 declare  star_list_names_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to entry names */
  1    21 declare  star_select_sw fixed binary (3);		/* hcs_$star_list_, hcs_$star_dir_list_: what info to return */
  1    22 
  1    23 /* based */
  1    24 
  1    25 /* hcs_$star_ entry structure */
  1    26 
  1    27 declare 1 star_entries (star_entry_count) aligned based (star_entry_ptr),
  1    28         2 type fixed binary (2) unsigned unaligned,
  1    29 						/* storage system type */
  1    30         2 nnames fixed binary (16) unsigned unaligned,
  1    31 						/* number of names of entry that match star_name */
  1    32         2 nindex fixed binary (18) unsigned unaligned;
  1    33 						/* index of first name in star_names */
  1    34 
  1    35 /* hcs_$star_ name structure */
  1    36 
  1    37 declare  star_names (sum (star_entries (*).nnames)) char (32) based (star_names_ptr);
  1    38 
  1    39 /* hcs_$star_list_ branch structure */
  1    40 
  1    41 declare 1 star_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  1    42         2 type fixed binary (2) unsigned unaligned,
  1    43 						/* storage system type */
  1    44         2 nnames fixed binary (16) unsigned unaligned,
  1    45 						/* number of names of entry that match star_name */
  1    46         2 nindex fixed binary (18) unsigned unaligned,
  1    47 						/* index of first name in star_list_names */
  1    48         2 dtcm bit (36) unaligned,			/* date-time contents of branch were last modified */
  1    49         2 dtu bit (36) unaligned,			/* date-time branch was last used */
  1    50         2 mode bit (5) unaligned,			/* user's access mode to the branch */
  1    51         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
  1    52         2 master_dir bit (1) unaligned,			/* is branch a master directory */
  1    53         2 pad bit (7) unaligned,
  1    54         2 records fixed binary (18) unsigned unaligned;
  1    55 						/* records used by branch */
  1    56 
  1    57 /* hcs_$star_dir_list_ branch structure */
  1    58 
  1    59 declare 1 star_dir_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  1    60         2 type fixed binary (2) unsigned unaligned,
  1    61 						/* storage system type */
  1    62         2 nnames fixed binary (16) unsigned unaligned,
  1    63 						/* number of names of entry that match star_name */
  1    64         2 nindex fixed binary (18) unsigned unaligned,
  1    65 						/* index of first name in star_list_names */
  1    66         2 dtem bit (36) unaligned,			/* date-time directory entry of branch was last modified */
  1    67         2 pad bit (36) unaligned,
  1    68         2 mode bit (5) unaligned,			/* user's access mode to the branch */
  1    69         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
  1    70         2 master_dir bit (1) unaligned,			/* is branch a master directory */
  1    71         2 bit_count fixed binary (24) unaligned;
  1    72 						/* bit count of the branch */
  1    73 
  1    74 /* hcs_$star_list_ and hcs_$star_dir_list_ link structure */
  1    75 
  1    76 declare 1 star_links (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  1    77         2 type fixed binary (2) unsigned unaligned,
  1    78 						/* storage system type */
  1    79         2 nnames fixed binary (16) unsigned unaligned,
  1    80 						/* number of names of entry that match star_name */
  1    81         2 nindex fixed binary (18) unsigned unaligned,
  1    82 						/* index of first name in star_list_names */
  1    83         2 dtem bit (36) unaligned,			/* date-time link was last modified */
  1    84         2 dtd bit (36) unaligned,			/* date-time the link was last dumped */
  1    85         2 pathname_len fixed binary (18) unsigned unaligned,
  1    86 						/* length of the pathname of the link */
  1    87         2 pathname_index fixed binary (18) unsigned unaligned;
  1    88 						/* index of start of pathname in star_list_names */
  1    89 
  1    90 /* hcs_$star_list_ and hcs_$star_dir_list_ name array */
  1    91 
  1    92 declare  star_list_names char (32) based (star_list_names_ptr)
  1    93 	dimension (star_links (star_branch_count + star_link_count).nindex
  1    94 	 + star_links (star_branch_count + star_link_count).nnames
  1    95 	 + divide (star_links (star_branch_count + star_link_count).pathname_len + 31, 32, 17, 0)
  1    96 	   * binary (
  1    97 	     (star_links (star_branch_count + star_link_count).type = star_LINK)
  1    98 	     & (star_select_sw >= star_LINKS_ONLY_WITH_LINK_PATHS), 1));
  1    99 
  1   100 /* hcs_$star_list_ and hcs_$star_dir_list_ link pathname */
  1   101 
  1   102 declare  star_link_pathname char (star_links (star_linkx).pathname_len)
  1   103          based (addr (star_list_names (star_links (star_linkx).pathname_index)));
  1   104 
  1   105 /* internal static */
  1   106 
  1   107 /* star_select_sw values */
  1   108 
  1   109 declare  star_LINKS_ONLY fixed binary (2) internal static options (constant) initial (1);
  1   110 declare  star_BRANCHES_ONLY fixed binary (2) internal static options (constant) initial (2);
  1   111 declare  star_ALL_ENTRIES fixed binary (2) internal static options (constant) initial (3);
  1   112 declare  star_LINKS_ONLY_WITH_LINK_PATHS
  1   113          fixed binary (3) internal static options (constant) initial (5);
  1   114 declare  star_ALL_ENTRIES_WITH_LINK_PATHS
  1   115          fixed binary (3) internal static options (constant) initial (7);
  1   116 
  1   117 /* storage system types */
  1   118 
  1   119 declare  star_LINK fixed binary (2) unsigned internal static options (constant) initial (0);
  1   120 declare  star_SEGMENT fixed binary (2) unsigned internal static options (constant) initial (1);
  1   121 declare  star_DIRECTORY fixed binary (2) unsigned internal static options (constant) initial (2);
  1   122 
  1   123 /* END INCLUDE FILE . . . star_structures.incl.pl1 */
      570 
      571      end appropriate_fsm_info;
      572 
      573 description_of_location:
      574      proc (location) returns (char (256) varying) recursive;
      575 
      576 /*  Function:  to return a meaningful description of the location addressed  */
      577 /*     by a pointer variable.  If the segment number of the location is not  */
      578 /*     valid, the description is just the ASCII representation of a pointer  */
      579 /*     and a comment indicating the segment number is invalid.  Otherwise,   */
      580 /*     the segment number portion is replaced by the pathname of the segment */
      581 /*     and the offset potion is dropped if it is zero, or replaced by the    */
      582 /*     entry name if the location is an entry point.  If the location is in  */
      583 /*     an active stack frame or an external variable, the description will   */
      584 /*     include a comment indicating that.                                    */
      585 
      586 /*  Arguments:                                                               */
      587 /*                                                                           */
      588 /*  location  (Input)                                                        */
      589 /*     contains the address of the location whose description is desired.    */
      590 
      591 dcl	location		ptr;
      592 
      593 dcl	get_entry_name_	entry (ptr, char (*), fixed bin (18), char (8) aligned, fixed bin (35)),
      594 	get_pdir_		entry returns (char (168)),
      595 	hcs_$fs_get_path_name
      596 			entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
      597 
      598 dcl	null		builtin,
      599 	stackbaseptr	builtin,
      600 	stackframeptr	builtin;
      601 
      602 dcl	False		bit (1) static options (constant) init ("0"b),
      603 	True		bit (1) static options (constant) init ("1"b);
      604 
      605 dcl	bit_offset	char (4) varying,
      606 	checking_external_variables
      607 			bit (1),
      608 	description	char (256) varying,
      609 	dir_name		char (168),
      610 	dir_name_len	fixed bin,
      611 	entry_name	char (32),
      612 	hash_table_idx	fixed bin,
      613 	language		char (8) aligned,
      614 	seg_name		char (32),
      615 	seg_num		fixed bin (18),
      616 	status		fixed bin (35),
      617 	vnp		ptr,
      618 	vthp		ptr,
      619 	word_offset	char (8) varying;
      620 
      621 
      622 	if location = null
      623 	then return ("null");
      624 
      625 /*  Create character representations of the word and bit offsets.  */
      626 
      627 	if substr (unspec (location), 58, 6) = ""b	/*  Unfortunately, there is no builtin to get the bit offset.  */
      628 	then bit_offset = "";
      629 	else do;
      630 		bit_offset = "(";
      631 		bit_offset = bit_offset || ltrim (char (fixed (substr (unspec (location), 58, 6))));
      632 		bit_offset = bit_offset || ")";
      633 	     end;
      634 	if rel (location) = ""b & bit_offset = ""
      635 	then word_offset = "";
      636 	else do;
      637 		word_offset = "|";
      638 		word_offset = word_offset || octal_representation (fixed (rel (location)));
      639 	     end;
      640 
      641 /*  Generate a meaningful description of the location, if possible.  */
      642 
      643 	call hcs_$fs_get_path_name (location, dir_name, dir_name_len, seg_name, status);
      644 	if status ^= 0
      645 	then do;					/*  Can't do much as the segment number is invalid.  */
      646 		description = octal_representation (fixed (baseno (location)));
      647 		description = description || word_offset;
      648 		description = description || bit_offset;
      649 		description = description || " (Segment number invalid)";
      650 	     end;
      651 	else do;					/*  We can at least give a pathname instead of a segment number.  */
      652 		if dir_name = ">"
      653 		then description = "";
      654 		else if dir_name = get_pdir_ ()
      655 		then description = "[pd]";
      656 		else description = substr (dir_name, 1, dir_name_len);
      657 		description = description || ">";
      658 		description = description || rtrim (seg_name);
      659 		call get_entry_name_ (location, entry_name, seg_num, language, status);
      660 		if status = 0
      661 		then do;				/*  Give the entry name instead of a word and bit offset.  */
      662 			description = description || "$";
      663 			description = description || rtrim (entry_name);
      664 		     end;
      665 		else do;				/*  Give the word and bit offset, if nonzero.  */
      666 			description = description || word_offset;
      667 			description = description || bit_offset;
      668 		     end;
      669 		if ptr (location, 0) = stackbaseptr
      670 		then do;				/*  See if it's in an active stack frame.  */
      671 			sp = stackframeptr;
      672 			do while (rel (sp) > rel (location) & stack_frame.prev_sp ^= null);
      673 			     sp = stack_frame.prev_sp;
      674 			end;
      675 			if rel (sp) <= rel (location) & rel (stack_frame.next_sp) > rel (location)
      676 			then do;			/*  Indicate who owns the stack frame.  */
      677 				description = description || " (stack_frame";
      678 				if location ^= sp
      679 				then do;
      680 					description = description || "|";
      681 					description =
      682 					     description
      683 					     ||
      684 					     octal_representation (fixed (rel (location)) - fixed (rel (sp)));
      685 					description = description || bit_offset;
      686 				     end;
      687 				description = description || " of ";
      688 				description = description || description_of_location (stack_frame.entry_ptr);
      689 				description = description || ")";
      690 			     end;
      691 		     end;
      692 		else if index (seg_name, ".area.linker") > 0
      693 		then do;				/*  See if the location is in an external variable.  */
      694 			sb = stackbaseptr;
      695 			vthp = stack_header.sys_link_info_ptr;
      696 			if vthp ^= null
      697 			then do;
      698 				checking_external_variables = True;
      699 				do hash_table_idx = lbound (vthp -> variable_table_header.hash_table, 1)
      700 				     to hbound (vthp -> variable_table_header.hash_table, 1)
      701 				     while (checking_external_variables);
      702 				     do vnp = vthp -> variable_table_header.hash_table (hash_table_idx)
      703 					repeat vnp -> variable_node.forward_thread
      704 					while (vnp ^= null & checking_external_variables);
      705 					if baseno (vnp -> variable_node.vbl_ptr) = baseno (location)
      706 					then if rel (vnp -> variable_node.vbl_ptr) <= rel (location)
      707 						&
      708 						rel (
      709 						addrel (vnp -> variable_node.vbl_ptr,
      710 						vnp -> variable_node.vbl_size))
      711 						> rel (location)
      712 					     then do;
      713 						/*  Indicate the name of the external variable.  */
      714 						     checking_external_variables = False;
      715 						     description = description || " (External Variable ";
      716 						     description = description || vnp -> variable_node.name;
      717 						     if vnp -> variable_node.vbl_ptr ^= location
      718 						     then do;
      719 							     description = description || "|";
      720 							     description =
      721 								description
      722 								||
      723 								octal_representation (
      724 								fixed (rel (location))
      725 								-
      726 								fixed (rel (vnp -> variable_node.vbl_ptr))
      727 								);
      728 							     description = description || bit_offset;
      729 							end;
      730 						     description = description || ")";
      731 						end;
      732 				     end;
      733 				end;
      734 			     end;
      735 		     end;
      736 	     end;
      737 	return (description);
      738 
      739 
  2     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  2     2 
  2     3 /* format: off */
  2     4 
  2     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  2     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  2     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  2     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  2     9 
  2    10 
  2    11 /****^  HISTORY COMMENTS:
  2    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  2    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  2    14*     Modified to add constants for the translator_id field in the stack_frame
  2    15*     structure.
  2    16*                                                   END HISTORY COMMENTS */
  2    17 
  2    18 
  2    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  2    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  2    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  2    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  2    23 
  2    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  2    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  2    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  2    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  2    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  2    29 
  2    30 
  2    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  2    32 
  2    33 dcl  stack_frame_min_length fixed bin static init(48);
  2    34 
  2    35 
  2    36 dcl 1 stack_frame based(sp) aligned,
  2    37     2 pointer_registers(0 : 7) ptr,
  2    38     2 prev_sp pointer,
  2    39     2 next_sp pointer,
  2    40     2 return_ptr pointer,
  2    41     2 entry_ptr pointer,
  2    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  2    43     2 arg_ptr pointer,
  2    44     2 static_ptr ptr unaligned,
  2    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  2    46     2 on_unit_relp1 bit(18) unaligned,
  2    47     2 on_unit_relp2 bit(18) unaligned,
  2    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  2    49*						   0 => PL/I version II
  2    50*						   1 => ALM
  2    51*						   2 => PL/I version I   
  2    52*						   3 => signal caller frame
  2    53*						   4 => signaller frame */
  2    54     2 operator_return_offset bit(18) unaligned,
  2    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  2    56     2 a bit(36),					/* accumulator */
  2    57     2 q bit(36),					/* q-register */
  2    58     2 e bit(36),					/* exponent */
  2    59     2 timer bit(27) unaligned,				/* timer */
  2    60     2 pad bit(6) unaligned,
  2    61     2 ring_alarm_reg bit(3) unaligned;
  2    62 
  2    63 
  2    64 dcl 1 stack_frame_flags based(sp) aligned,
  2    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  2    66     2 xx0 bit(22) unal,
  2    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  2    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  2    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  2    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  2    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  2    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  2    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  2    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  2    75     2 xx0a bit(6) unal,
  2    76     2 xx1 fixed bin,
  2    77     2 xx2 fixed bin,
  2    78     2 xx3 bit(25) unal,
  2    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  2    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  2    81     2 xx3a bit(9) unaligned,
  2    82     2 xx4(9) bit(72) aligned,
  2    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  2    84*						*  operator puts a pointer to the base of
  2    85*						*  the calling procedure here. (text base ptr)  */
  2    86     2 xx5 bit(72) aligned,
  2    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  2    88 
  2    89 /* format: on */
  2    90 
  2    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      740 
  3     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  3     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  3     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  3     4 /*	Modified April 1983 by C. Hornig for tasking */
  3     5 
  3     6 /****^  HISTORY COMMENTS:
  3     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  3     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  3     9*     added the heap_header_ptr definition.
  3    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  3    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  3    12*     Modified to support control point management.  These changes were actually
  3    13*     made in February 1985 by G. Palter.
  3    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  3    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  3    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  3    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  3    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  3    19*     (ITS pair).
  3    20*                                                   END HISTORY COMMENTS */
  3    21 
  3    22 /* format: style2 */
  3    23 
  3    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  3    25 
  3    26      dcl	   1 stack_header	      based (sb) aligned,
  3    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  3    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  3    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  3    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  3    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  3    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  3    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  3    34 	     2 pad4	      bit (2) unal,
  3    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  3    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  3    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  3    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  3    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  3    40 	     2 null_ptr	      ptr,		/*  (16)  */
  3    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  3    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  3    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  3    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  3    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  3    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  3    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  3    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  3    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  3    50 	     2 return_no_pop_op_ptr
  3    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  3    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  3    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  3    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  3    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  3    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  3    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  3    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  3    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  3    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  3    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  3    62 	     2 trace,
  3    63 	       3 frames,
  3    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  3    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  3    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  3    67 	     2 pad2	      bit (36),		/*  (61) */
  3    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  3    69 
  3    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  3    71 
  3    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  3    73 						/* (551) octal */
  3    74 
  3    75 
  3    76 /*	The following constants are offsets within this transfer vector table.  */
  3    77 
  3    78      dcl	   (
  3    79 	   call_offset	      fixed bin init (271),
  3    80 	   push_offset	      fixed bin init (272),
  3    81 	   return_offset	      fixed bin init (273),
  3    82 	   return_no_pop_offset   fixed bin init (274),
  3    83 	   entry_offset	      fixed bin init (275)
  3    84 	   )		      internal static;
  3    85 
  3    86 
  3    87 
  3    88 
  3    89 
  3    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  3    91*	move the whole stack header should use this overlay.
  3    92**/
  3    93 
  3    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  3    95 
  3    96 
  3    97 
  3    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      741 
  4     1 /* BEGIN INCLUDE FILE ... system_link_names.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396), audit(86-11-12,Zwick),
  4     6*     install(86-11-20,MR12.0-1222):
  4     7*     added the declaration of the heap_header.
  4     8*  2) change(86-10-20,DGHowe), approve(86-10-20,MCR7420), audit(86-11-12,Zwick),
  4     9*     install(86-11-20,MR12.0-1222):
  4    10*     add the seg ptr to the variable node structure.
  4    11*                                                   END HISTORY COMMENTS */
  4    12 
  4    13 
  4    14 /* created by M. Weaver 7/28/76 */
  4    15 /* Modified: 82-11-19 by T. Oke to add LIST_TEMPLATE_INIT. */
  4    16 /* Modified 02/11/83 by M. Weaver to add have_vla_variables flag */
  4    17 
  4    18 
  4    19 dcl 1 variable_table_header aligned based,	/* header for name table */
  4    20      2 hash_table (0:63) ptr unaligned,		/* hash table for variable nodes */
  4    21      2 total_search_time fixed bin (71),	/* total time to search for variables */
  4    22      2 total_allocation_time fixed bin (71),	/* total time spent allocating and initializing nodes and variables */
  4    23      2 number_of_searches fixed bin,		/* number of times names were looked up */
  4    24      2 number_of_variables fixed bin (35),	/* number of variables allocated by the linker, incl deletions */
  4    25      2 flags unaligned,
  4    26         3 have_vla_variables bit (1) unaligned,	/* on if some variables are > sys_info$max_seg_size */
  4    27         3 pad bit (11) unaligned,
  4    28      2 cur_num_of_variables fixed bin (24) unal,	/* current number of variables allocated */
  4    29      2 number_of_steps fixed bin,		/* total number of nodes looked at */
  4    30      2 total_allocated_size fixed bin (35);	/* current amount of storage in user area */
  4    31 
  4    32 
  4    33 dcl 1 variable_node aligned based,		/* individual variable information */
  4    34      2 forward_thread ptr unaligned,		/* thread to next node off same hash bucket */
  4    35      2 vbl_size fixed bin (24) unsigned unaligned, /* length in words of variable */
  4    36      2 init_type fixed bin (11) unaligned,	/* 0=not init; 3=init template; 4=area 5=list_template*/
  4    37      2 time_allocated fixed bin (71),		/* time when variable was allocated */
  4    38      2 vbl_ptr ptr,				/* pointer to variable's storage */
  4    39      2 init_ptr ptr,			/* pointer to original init info in object seg */
  4    40      2 name_size fixed bin(21) aligned,		/* length of name in characters */
  4    41      2 name char (nchars refer (variable_node.name_size)), /* name of variable */
  4    42      2 seg_ptr  pointer;
  4    43 
  4    44 /* variable_node.seg_ptr
  4    45*   Is a pointer to the segment containing the initialization information
  4    46*   for this variable. It is used as a segment base pointer for external
  4    47*   pointer initialization via list_init_.
  4    48*
  4    49*   The init_ptr can not be used as a reference to the defining segment
  4    50*   due to the possibility of set_fortran_common being used to initialize
  4    51*   the external variables. sfc will generate an initialization information
  4    52*   structure if multiple intialization sizes are found in the specified 
  4    53*   segments. sfc stores the address of this structure in the init_ptr field.
  4    54*   This is one reason why sfc does not perform external pointer 
  4    55*   initialization.
  4    56*
  4    57*   The seg_ptr is set to point at the segment used to define the 
  4    58*   initialization information. term_ sets this field to null on termination
  4    59*   due to the possiblity of executing a different segment which defines
  4    60*   initialization information. In this way the seg_ptr field will either
  4    61*   be valid or null.
  4    62**/
  4    63 
  4    64 dcl 1 heap_header based,
  4    65      2 version            char(8),                /* specifies the verison of the header */
  4    66      2 heap_name_list_ptr pointer,		/* points to the variable_table_header for this heap */
  4    67      2 previous_heap_ptr  pointer,		/* points to the previous heap or is null */
  4    68      2 area_ptr	      pointer,		/* points to the heap area */
  4    69      2 execution_level    fixed bin (17);	/* specifies the execution level this header deals with */
  4    70 
  4    71 dcl heap_header_version_1 char(8) static options (constant)
  4    72 			    init ("Heap_v01");
  4    73 	
  4    74 
  4    75 /* END INCLUDE FILE ... system_link_names.incl.pl1 */
      742 
      743      end description_of_location;
      744 
      745 get_fsm_dir_dir_path:
      746      proc (fsm_dir_dir_path);
      747 
      748 /*  Function:  to return the pathname of the directory which will contain    */
      749 /*     the directory of segments managed by 'fsm_'.  This pathname is        */
      750 /*     obtained from the variable 'fsm_dir_dir_path' in the user's per-      */
      751 /*     process value segment or default permanent value segment (with the    */
      752 /*     value in the perprocess value segment taking precedent if it is       */
      753 /*     defined differently in the two value segments).  If neither of these  */
      754 /*     value segments define the variable, or if the value is "", then the   */
      755 /*     pathname of the process directory is returned.  If the defined value  */
      756 /*     is not an absolute pathname (i.e. does not start with ">"), the       */
      757 /*     condition 'fortran_storage_manager_error' is signalled with a         */
      758 /*     description of the problem. If this occurs, the user should fixed the */
      759 /*     value segment and restart.  				       */
      760 
      761 /*  Arguments:                                                               */
      762 /*                                                                           */
      763 /*  fsm_dir_dir_path  (Output)                                               */
      764 /*     is the absolute pathname of the directory which will contain the      */
      765 /*     directory of segments managed by 'fsm_'.                              */
      766 
      767 dcl	fsm_dir_dir_path	char (*);
      768 
      769 dcl	error_table_$not_abs_path
      770 			fixed bin (35) ext;
      771 
      772 dcl	get_pdir_		entry returns (char (168)),
      773 	value_$get	entry (ptr, bit (36) aligned, char (*), char (*), fixed bin (35));
      774 
      775 dcl	status		fixed bin (35);
      776 
      777 
      778 	fsm_dir_dir_path = "";
      779 	do while (fsm_dir_dir_path = "");
      780 	     call value_$get (null, "11"b, "fsm_dir_dir_path", fsm_dir_dir_path, status);
      781 	     if fsm_dir_dir_path = ""
      782 	     then fsm_dir_dir_path = get_pdir_ ();
      783 	     else if substr (fsm_dir_dir_path, 1, 1) ^= ">"
      784 	     then do;
      785 		     call signal_fsm_error (error_table_$not_abs_path,
      786 			"Value segment specifies 'fsm_dir_dir_path' = " || fsm_dir_dir_path);
      787 		     fsm_dir_dir_path = "";
      788 		end;
      789 	end;
      790      end get_fsm_dir_dir_path;
      791 
      792 list_groups:
      793      proc (max_group_cnt, desired_process);
      794 
      795 /*  Function: to list (on the 'user_output' switch) the groups of segments   */
      796 /*     which are allocated to a specified process.  The groups are listed by */
      797 /*     owner.                                                                */
      798 
      799 /*  Arguments:                                                               */
      800 /*                                                                           */
      801 /*  max_group_cnt  (Input)                                                   */
      802 /*     is the maximum number of groups to be listed.  If there are more      */
      803 /*     groups than this, the excess are ignored without comment.             */
      804 /*                                                                           */
      805 /*  desired_process  (Input)                                                 */
      806 /*     is the ID of the process whose groups are to be listed.               */
      807 /*                                                                           */
      808 
      809 dcl	max_group_cnt	fixed bin,
      810 	desired_process	bit (36) aligned;
      811 
      812 dcl	get_line_length_$stream
      813 			entry (char (*), fixed bin (35)) returns (fixed bin),
      814 	ioa_$nnl		entry options (variable);
      815 
      816 dcl	01 expected_group	aligned like group;
      817 
      818 dcl	01 group		(max_group_cnt) aligned,
      819 	  02 owner	ptr unaligned,
      820 	  02 first_seg_in_group
      821 			fixed bin;
      822 
      823 dcl	expected_group_idx	fixed bin,
      824 	group_cnt		fixed bin,
      825 	group_idx		fixed bin,
      826 	line_len		fixed bin,
      827 	max_line_len	fixed bin,
      828 	name		char (32) varying,
      829 	prev_group_owner	ptr unaligned,
      830 	seg_idx		fixed bin,
      831 	status		fixed bin (35),
      832 	trial_group_idx	fixed bin;
      833 
      834 /*  Store in 'group' the owner and number of the first segment of each group */
      835 /*  allocated to this process.                                               */
      836 
      837 	group_cnt = 0;
      838 	do seg_idx = 1 to fsm_info.seg_cnt while (group_cnt < max_group_cnt);
      839 	     if fsm_info.seg (seg_idx).owning_process = desired_process
      840 		& fsm_info.seg (seg_idx).first_seg_in_group = seg_idx
      841 	     then do;
      842 		     group_cnt = group_cnt + 1;
      843 		     group (group_cnt).owner = fsm_info.owner (seg_idx);
      844 		     group (group_cnt).first_seg_in_group = fsm_info.first_seg_in_group (seg_idx);
      845 		end;
      846 	end;
      847 
      848 /*  Sort groups into ascending order of owner and number of first segment in */
      849 /*  the group.                                                               */
      850 
      851 	do group_idx = 1 to group_cnt - 1;
      852 	     expected_group = group (group_idx);
      853 	     expected_group_idx = group_idx;
      854 	     do trial_group_idx = group_idx + 1 to group_cnt;
      855 		if unspec (group (trial_group_idx)) < unspec (expected_group)
      856 		then do;
      857 			expected_group = group (trial_group_idx);
      858 			expected_group_idx = trial_group_idx;
      859 		     end;
      860 	     end;
      861 	     if group_idx ^= expected_group_idx
      862 	     then do;
      863 		     group (expected_group_idx) = group (group_idx);
      864 		     group (group_idx) = expected_group;
      865 		end;
      866 	end;
      867 
      868 /*  List the groups.  */
      869 
      870 	max_line_len = get_line_length_$stream ("user_output", status);
      871 	unspec (prev_group_owner) = ""b;		/*  Start with an impossible owner.  */
      872 	do group_idx = 1 to group_cnt;
      873 	     if group (group_idx).owner ^= prev_group_owner
      874 	     then do;				/*  Describe new owner.  */
      875 		     prev_group_owner = group (group_idx).owner;
      876 		     call ioa_$nnl ("^/^a owns:^/", description_of_location ((prev_group_owner)));
      877 		end;
      878 	     call ioa_$nnl ("^4x");
      879 	     line_len = 4;
      880 	     do seg_idx = group (group_idx).first_seg_in_group repeat fsm_info.next_seg_in_group (seg_idx)
      881 		while (seg_idx ^= 0);
      882 		name = rtrim (seg_name (seg_idx));
      883 		if line_len + 1 + length (name) <= max_line_len
      884 		then do;
      885 			line_len = line_len + 1 + length (name);
      886 			call ioa_$nnl (" ^a", name);
      887 		     end;
      888 		else do;
      889 			line_len = 10 + length (name);
      890 			call ioa_$nnl ("^/^-^a", name);
      891 		     end;
      892 	     end;
      893 	     call ioa_$nnl ("^/");
      894 	end;
      895 
      896      end list_groups;
      897 
      898 octal_representation:
      899      proc (value) returns (char (12) varying);
      900 
      901 /*  Function:  to return the octal representation of an integer value.       */
      902 
      903 /*  Arguments:                                                               */
      904 /*                                                                           */
      905 /*  value  (Input)                                                           */
      906 /*     is the integer value whose octal representation is desired.           */
      907 
      908 dcl	value		fixed bin;
      909 
      910 dcl	cv_bin_$oct	entry (fixed bin, char (12) aligned);
      911 
      912 dcl	string		char (12) aligned;
      913 
      914 	call cv_bin_$oct (value, string);
      915 	return (ltrim (string));
      916      end octal_representation;
      917 
      918 pick_first_seg_num:
      919      proc (num_segs_desired, first_seg_num);
      920 
      921 /*  Function:  to find a set of a specified size of free, consecutive        */
      922 /*     segment numbers and return the first segment number of the set.       */
      923 
      924 /*  Arguments:                                                               */
      925 /*                                                                           */
      926 /*  num_segs_desired  (Input)                                                */
      927 /*     is the number of consecutive segment numbers needed.                  */
      928 /*                                                                           */
      929 /*  first_seg_num  (Output)                                                  */
      930 /*     is the first segment number of the chosen set of consecutive segment  */
      931 /*     numbers.                                                              */
      932 
      933 dcl	num_segs_desired	fixed bin,
      934 	first_seg_num	fixed bin;
      935 
      936 dcl	hcs_$high_low_seg_count
      937 			entry (fixed bin, fixed bin);
      938 
      939 dcl	best_hole_size	fixed bin,
      940 	best_hole_start	fixed bin,
      941 	cur_hole_size	fixed bin,
      942 	found_highest_seg_num_in_use
      943 			bit (1),
      944 	high_seg_num	fixed bin,
      945 	high_seg_num_minus_low_seg_num
      946 			fixed bin,
      947 	low_seg_num	fixed bin,
      948 	seg_num		fixed bin;
      949 
      950 /*  Find the lowest segment number allowed to be used and the highest that   */
      951 /*  is currently in use.                                                     */
      952 
      953 	call hcs_$high_low_seg_count (high_seg_num_minus_low_seg_num, low_seg_num);
      954 	high_seg_num = high_seg_num_minus_low_seg_num + low_seg_num;
      955 	low_seg_num = low_seg_num + 8;		/*  First 8 reserved for stacks.  */
      956 	found_highest_seg_num_in_use = False;
      957 	do while (^found_highest_seg_num_in_use);
      958 	     if seg_num_free (high_seg_num)
      959 	     then high_seg_num = high_seg_num - 1;
      960 	     else found_highest_seg_num_in_use = True;
      961 	end;
      962 
      963 /*  Search from the lowest segment number allowed to be used to the highest  */
      964 /*  in use for the smallest set of consecutive segment numbers that is at    */
      965 /*  least as big as needed.                                                  */
      966 
      967 	best_hole_size, cur_hole_size = 0;
      968 	do seg_num = low_seg_num to high_seg_num while (best_hole_size ^= num_segs_desired);
      969 	     if seg_num_free (seg_num)
      970 	     then cur_hole_size = cur_hole_size + 1;
      971 	     else do;
      972 		     if cur_hole_size >= num_segs_desired
      973 		     then if best_hole_size = 0 | best_hole_size > cur_hole_size
      974 			then do;			/*  Latest hole is best fit so far.  */
      975 				best_hole_size = cur_hole_size;
      976 				best_hole_start = seg_num - best_hole_size;
      977 			     end;
      978 		     cur_hole_size = 0;
      979 		end;
      980 	end;
      981 
      982 /*  If we found a hole large enough, choose the first segment number in it   */
      983 /*  as the start of the desired set; otherwise, start the set immediately    */
      984 /*  following the highest segment number currently in use.                   */
      985 
      986 	if best_hole_size < num_segs_desired
      987 	then first_seg_num = high_seg_num + 1;
      988 	else first_seg_num = best_hole_start;
      989      end pick_first_seg_num;
      990 
      991 pick_seg:
      992      proc (seg_idx);
      993 
      994 /*  Function:  to choose a free segment to be allocated.  If there are none, */
      995 /*     one is created.                                                       */
      996 
      997 /*  Arguments:                                                               */
      998 /*                                                                           */
      999 /*  seg_idx  (Output)                                                        */
     1000 /*     is the index of the element in 'fsm_info.seg' which corresponds to    */
     1001 /*     the segment which has been chosen.                                    */
     1002 
     1003 dcl	seg_idx		fixed bin;
     1004 
     1005 dcl	get_group_id_	entry returns (char (32)),
     1006 	hcs_$append_branch	entry (char (*), char (*), fixed bin (5), fixed bin (35)),
     1007 	hcs_$replace_acl	entry (char (*), char (*), ptr, fixed bin, bit (1), fixed bin (35)),
     1008 	hcs_$set_max_length entry (char (*), char (*), fixed bin (19), fixed bin (35)),
     1009 	hcs_$set_safety_sw	entry (char (*), char (*), bit (1), fixed bin (35)),
     1010 
     1011 	pl1_operators_$VLA_words_per_seg_
     1012 			fixed bin (19) external;
     1013 
     1014 dcl	01 acl		aligned,
     1015 	  02 access_name	char (32),
     1016 	  02 modes	bit (36),
     1017 	  02 xmodes	bit (36),
     1018 	  02 status	fixed bin (35);
     1019 
     1020 dcl	status		fixed bin (35);
     1021 
     1022 	do seg_idx = 1 to fsm_info.seg_cnt while (fsm_info.seg (seg_idx).owning_process ^= ""b);
     1023 	end;
     1024 	if seg_idx <= fsm_info.seg_cnt
     1025 	then do;					/*  Reuse free segment.  */
     1026 		acl.access_name = get_group_id_ ();
     1027 		acl.modes = RW_ACCESS;
     1028 		acl.xmodes = ""b;
     1029 		status = 1;
     1030 		do while (status ^= 0);
     1031 		     call hcs_$replace_acl (fsm_dir_path, seg_name (seg_idx), addr (acl), 1, "0"b, status);
     1032 		     if status ^= 0
     1033 		     then call signal_fsm_error (status, pathname_ (fsm_dir_path, seg_name (seg_idx)));
     1034 		end;
     1035 	     end;
     1036 	else do while (seg_idx > fsm_info.seg_cnt);	/*  Create a segment.  */
     1037 		call hcs_$append_branch (fsm_dir_path, seg_name (seg_idx), RW_ACCESS_BIN, status);
     1038 		if status = 0
     1039 		then do;
     1040 			fsm_info.seg_cnt = seg_idx;
     1041 			fsm_info.seg (seg_idx).owner = null;
     1042 			call hcs_$set_max_length (fsm_dir_path, seg_name (seg_idx),
     1043 			     pl1_operators_$VLA_words_per_seg_, status);
     1044 			if status ^= 0
     1045 			then call signal_fsm_error (status, pathname_ (fsm_dir_path, seg_name (seg_idx)));
     1046 
     1047 			call hcs_$set_safety_sw (fsm_dir_path, seg_name (seg_idx), "1"b, status);
     1048 		     end;
     1049 		else call signal_fsm_error (status, pathname_ (fsm_dir_path, seg_name (seg_idx)));
     1050 	     end;
     1051      end pick_seg;
     1052 
     1053 release_fsm_info:
     1054      proc;
     1055 
     1056 /*  Function:  to free any segments that have been allocated to 'fsm_', then */
     1057 /*     to unlock 'fsm_info' so it can be used by other processes.            */
     1058 
     1059 dcl	hcs_$terminate_file entry (char (*), char (*), fixed bin (1), fixed bin (35)),
     1060 	set_lock_$unlock	entry (bit (36) aligned, fixed bin (35));
     1061 
     1062 dcl	seg_idx		fixed bin,
     1063 	status		fixed bin (35);
     1064 
     1065 
     1066 /*  This routine may be called in response to a 'cleanup' condition before   */
     1067 /*  'fsm_info' has been locked for this process, or possibly even found.     */
     1068 /*  Thus, we must be careful to check for these possibilities.               */
     1069 
     1070 	if fsm_info_ptr ^= null
     1071 	then if fsm_info.lock = my_process
     1072 	     then do;				/*  'fsm_info' is locked for this process.  */
     1073 		     do seg_idx = 1 to fsm_info.seg_cnt;
     1074 			if fsm_info.seg (seg_idx).owning_process = my_process & fsm_info.seg (seg_idx).owner = me
     1075 			then do;
     1076 				call hcs_$terminate_file (fsm_dir_path, seg_name (seg_idx), 0, status);
     1077 				unspec (fsm_info.seg (seg_idx)) = ""b;
     1078 			     end;
     1079 		     end;
     1080 		     status = 1;
     1081 		     do while (status ^= 0);
     1082 			call set_lock_$unlock (fsm_info.lock, status);
     1083 			if status ^= 0
     1084 			then call signal_fsm_error (status, "Trying to unlock 'fsm_info'.");
     1085 		     end;
     1086 		end;
     1087      end release_fsm_info;
     1088 
     1089 seg_name:
     1090      proc (seg_idx) returns (char (32));
     1091 
     1092 /*  Function:  to return the name of the segment associated with a specified */
     1093 /*     element of 'fsm_info.seg'.  The name is 'N.fsm_', where 'N' is the    */
     1094 /*     decimal representation of the index of the specified element.         */
     1095 
     1096 /*  Arguments:                                                               */
     1097 /*                                                                           */
     1098 /*  seg_idx  (Input)                                                         */
     1099 /*     is the index of the element of 'fsm_info.seg' with which the segment  */
     1100 /*     is associated.                                                        */
     1101 
     1102 dcl	seg_idx		fixed bin;
     1103 
     1104 	return (ltrim (char (seg_idx)) || ".fsm_");
     1105      end seg_name;
     1106 
     1107 seg_num_free:
     1108      proc (seg_num) returns (bit (1));
     1109 
     1110 /*  Function:  to indicate whether a given segment number is currently in    */
     1111 /*     use.  (Since there is no system function to do this, we fake it by    */
     1112 /*     asking for the unique-id of the segment corresponding to the segment  */
     1113 /*     number.  If the return code is 'error_table_$invalidsegno', then the  */
     1114 /*     segment number is free.)                                              */
     1115 
     1116 /*  Arguments:                                                               */
     1117 /*                                                                           */
     1118 /*  seg_num  (Input)                                                         */
     1119 /*     is the segment number to be tested.                                   */
     1120 
     1121 dcl	seg_num		fixed bin;
     1122 
     1123 dcl	error_table_$invalidsegno
     1124 			fixed bin (35) ext;
     1125 
     1126 dcl	hcs_$get_uid_seg	entry (ptr, bit (36) aligned, fixed bin (35));
     1127 
     1128 dcl	status		fixed bin (35),
     1129 	uid		bit (36) aligned;
     1130 
     1131 	call hcs_$get_uid_seg (baseptr (seg_num), uid, status);
     1132 	if status = error_table_$invalidsegno
     1133 	then return (True);
     1134 	else return (False);
     1135      end seg_num_free;
     1136 
     1137 signal_fsm_error:
     1138      proc (status, details);
     1139 
     1140 /*  Function:  to signal the restartable condition                          */
     1141 /*          'fortran_storage_manager_error'.              		      */
     1142 
     1143 /*  Arguments:                                                               */
     1144 /*                                                                           */
     1145 /*  status  (Input)                                                          */
     1146 /*     is a standard system status code describing why the condition is      */
     1147 /*     being signalled.                                                      */
     1148 /*                                                                           */
     1149 /*  details  (Input)                                                         */
     1150 /*     is supplementary information regarding why the condition is being     */
     1151 /*     signalled.                                                            */
     1152 
     1153 dcl	status		fixed bin (35),
     1154 	details		char (*);
     1155 
     1156 dcl	signal_		entry options (variable);
     1157 
  5     1 /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
  5     2 /* format: style2 */
  5     3 
  5     4      declare condition_info_header_ptr
  5     5 			      pointer;
  5     6      declare 1 condition_info_header
  5     7 			      aligned based (condition_info_header_ptr),
  5     8 	     2 length	      fixed bin,		/* length in words of this structure */
  5     9 	     2 version	      fixed bin,		/* version number of this structure */
  5    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
  5    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
  5    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
  5    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
  5    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
  5    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
  5    16 	       3 pad	      bit (32) unaligned,
  5    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
  5    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
  5    19 
  5    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
     1158 
     1159 
     1160 dcl	01 condition_info	aligned like condition_info_header;
     1161 
     1162 	condition_info.length = size (condition_info);
     1163 	condition_info.version = 1;
     1164 	unspec (condition_info.action_flags) = ""b;
     1165 	condition_info.info_string = rtrim (details);
     1166 	condition_info.status_code = status;
     1167 	call signal_ ("fortran_storage_manager_error", null, addr (condition_info));
     1168      end signal_fsm_error;
     1169 
  6     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  6     2*
  6     3*   Values for the "access mode" argument so often used in hardcore
  6     4*   James R. Davis 26 Jan 81  MCR 4844
  6     5*   Added constants for SM access 4/28/82 Jay Pattin
  6     6*   Added text strings 03/19/85 Chris Jones
  6     7**/
  6     8 
  6     9 
  6    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  6    11 dcl	(
  6    12 	N_ACCESS		   init ("000"b),
  6    13 	R_ACCESS		   init ("100"b),
  6    14 	E_ACCESS		   init ("010"b),
  6    15 	W_ACCESS		   init ("001"b),
  6    16 	RE_ACCESS		   init ("110"b),
  6    17 	REW_ACCESS	   init ("111"b),
  6    18 	RW_ACCESS		   init ("101"b),
  6    19 	S_ACCESS		   init ("100"b),
  6    20 	M_ACCESS		   init ("010"b),
  6    21 	A_ACCESS		   init ("001"b),
  6    22 	SA_ACCESS		   init ("101"b),
  6    23 	SM_ACCESS		   init ("110"b),
  6    24 	SMA_ACCESS	   init ("111"b)
  6    25 	)		   bit (3) internal static options (constant);
  6    26 
  6    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  6    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  6    29 
  6    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  6    31 			   static options (constant);
  6    32 
  6    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  6    34 			   static options (constant);
  6    35 
  6    36 dcl	(
  6    37 	N_ACCESS_BIN	   init (00000b),
  6    38 	R_ACCESS_BIN	   init (01000b),
  6    39 	E_ACCESS_BIN	   init (00100b),
  6    40 	W_ACCESS_BIN	   init (00010b),
  6    41 	RW_ACCESS_BIN	   init (01010b),
  6    42 	RE_ACCESS_BIN	   init (01100b),
  6    43 	REW_ACCESS_BIN	   init (01110b),
  6    44 	S_ACCESS_BIN	   init (01000b),
  6    45 	M_ACCESS_BIN	   init (00010b),
  6    46 	A_ACCESS_BIN	   init (00001b),
  6    47 	SA_ACCESS_BIN	   init (01001b),
  6    48 	SM_ACCESS_BIN	   init (01010b),
  6    49 	SMA_ACCESS_BIN	   init (01011b)
  6    50 	)		   fixed bin (5) internal static options (constant);
  6    51 
  6    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
     1170 
     1171      end fortran_storage_manager_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/20/86  1142.5  fortran_storage_manager_.pl1      >special_ldd>install>MR12.0-1222>fortran_storage_manager_.pl1
570          1    06/10/82  1045.5  star_structures.incl.pl1          >ldd>include>star_structures.incl.pl1
740          2    11/07/86  1550.3  stack_frame.incl.pl1              >ldd>include>stack_frame.incl.pl1
741          3    11/07/86  1550.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
742          4    11/20/86  1035.4  system_link_names.incl.pl1        >special_ldd>install>MR12.0-1222>system_link_names.incl.pl1
1158         5    03/24/82  1347.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
1170         6    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Chase_links                     000062 constant        fixed bin(1,0)           initial dcl 384 set ref 434*
False                                  constant        bit(1)                   initial unaligned dcl 54 in procedure "fsm_" ref 167
                                                                                  956 1134
False                                  constant        bit(1)                   initial unaligned dcl 602 in procedure
                                                                                  "description_of_location" ref 714
Max_wait_time                   000000 constant        fixed bin(17,0)          initial dcl 384 set ref 485*
RW_ACCESS                              constant        bit(3)                   initial unaligned dcl 6-11 ref 443 1027
RW_ACCESS_BIN                   000014 constant        fixed bin(5,0)           initial dcl 6-36 set ref 438* 463* 1037*
SMA_ACCESS_BIN                  000001 constant        fixed bin(5,0)           initial dcl 6-36 set ref 457*
True                                   constant        bit(1)                   initial unaligned dcl 54 in procedure "fsm_" ref 165
                                                                                  190 563 960 1132
True                                   constant        bit(1)                   initial unaligned dcl 602 in procedure
                                                                                  "description_of_location" ref 698
access_name                     000106 automatic       char(32)                 level 2 in structure "acl" dcl 387 in procedure
                                                                                  "appropriate_fsm_info" set ref 442*
access_name                     000160 automatic       char(32)                 level 2 in structure "acl" dcl 1014 in procedure
                                                                                  "pick_seg" set ref 1026*
acl                             000160 automatic       structure                level 1 dcl 1014 in procedure "pick_seg" set ref
                                                                                  1031 1031
acl                             000106 automatic       structure                level 1 dcl 387 in procedure "appropriate_fsm_info"
                                                                                  set ref 445 445
addr                                                   builtin function         dcl 137 ref 445 445 1031 1031 1167 1167
addrel                                                 builtin function         dcl 137 ref 705
baseno                                                 builtin function         dcl 137 ref 252 646 646 705 705
baseptr                                                builtin function         dcl 137 ref 179 179 202 1131 1131
before                                                 builtin function         dcl 137 ref 534 538
best_hole_size                  000140 automatic       fixed bin(17,0)          dcl 939 set ref 967* 968 972 972 975* 976 986
best_hole_start                 000141 automatic       fixed bin(17,0)          dcl 939 set ref 976* 988
bin                                                    builtin function         dcl 137 ref 252 538
bit_count                       000121 automatic       fixed bin(24,0)          dcl 393 set ref 434* 435
bit_offset                      000100 automatic       varying char(4)          dcl 605 set ref 627* 630* 631* 631 632* 632 634 648
                                                                                  667 685 728
char                                                   builtin function         dcl 137 ref 429 631 1104
checking_external_variables     000102 automatic       bit(1)                   unaligned dcl 605 set ref 698* 699 702 714*
cleanup                         000100 stack reference condition                dcl 382 in procedure "appropriate_fsm_info" ref 519
cleanup                         000104 stack reference condition                dcl 141 in procedure "fsm_" ref 158 222 250 276 300
codeptr                                                builtin function         dcl 137 ref 78
condition_info                  000100 automatic       structure                level 1 dcl 1160 set ref 1162 1167 1167
condition_info_header                  based           structure                level 1 dcl 5-6
cu_$level_get                   000170 constant        entry                    external dcl 359 ref 457 457
cur_hole_size                   000142 automatic       fixed bin(17,0)          dcl 939 set ref 967* 969* 969 972 972 975 978*
cv_bin_$oct                     000244 constant        entry                    external dcl 910 ref 914
description                     000103 automatic       varying char(256)        dcl 605 set ref 646* 647* 647 648* 648 649* 649 652*
                                                                                  654* 656* 657* 657 658* 658 662* 662 663* 663 666*
                                                                                  666 667* 667 677* 677 680* 680 681* 681 685* 685
                                                                                  687* 687 688* 688 689* 689 715* 715 716* 716 719*
                                                                                  719 720* 720 728* 728 730* 730 737
desired_process                        parameter       bit(36)                  dcl 809 ref 792 839
details                                parameter       char                     unaligned dcl 1153 ref 1137 1165
dir_name                        000204 automatic       char(168)                unaligned dcl 605 set ref 643* 652 654 656
dir_name_len                    000256 automatic       fixed bin(17,0)          dcl 605 set ref 643* 656
entry_name                      000257 automatic       char(32)                 unaligned dcl 605 set ref 659* 663
entry_ptr                26            based           pointer                  level 2 dcl 2-36 set ref 688*
error_table_$bad_segment        000154 external static fixed bin(35,0)          dcl 347 set ref 547*
error_table_$invalid_lock_reset 000156 external static fixed bin(35,0)          dcl 347 ref 486 555
error_table_$invalidsegno       000270 external static fixed bin(35,0)          dcl 1123 ref 1132
error_table_$moderr             000160 external static fixed bin(35,0)          dcl 347 ref 440
error_table_$noentry            000162 external static fixed bin(35,0)          dcl 347 ref 455
error_table_$nomatch            000166 external static fixed bin(35,0)          dcl 347 ref 528
error_table_$not_abs_path       000232 external static fixed bin(35,0)          dcl 769 set ref 785*
error_table_$notadir            000164 external static fixed bin(35,0)          dcl 347 set ref 454*
expected_group                  000100 automatic       structure                level 1 dcl 816 set ref 852* 855 857* 864
expected_group_idx              000102 automatic       fixed bin(17,0)          dcl 823 set ref 853* 858* 861 863
first_seg_in_group              000112 automatic       fixed bin(17,0)          dcl 143 in procedure "fsm_" set ref 171* 176 186
first_seg_in_group        4            based           fixed bin(17,0)          array level 3 in structure "fsm_info" dcl 60
                                                                                  in procedure "fsm_" set ref 176* 308 839 844
first_seg_in_group        1     000102 automatic       fixed bin(17,0)          array level 2 in structure "group" dcl 818
                                                                                  in procedure "list_groups" set ref 844* 880
first_seg_num                   000113 automatic       fixed bin(17,0)          dcl 143 in procedure "fsm_" set ref 168* 169 169 171
                                                                                  202
first_seg_num                          parameter       fixed bin(17,0)          dcl 933 in procedure "pick_first_seg_num" set ref
                                                                                  918 986* 988*
first_seg_ptr                          parameter       pointer                  dcl 127 set ref 84 154* 202*
fixed                                                  builtin function         dcl 137 ref 631 638 638 646 646 681 681 720 720
forward_thread                         based           pointer                  level 2 packed unaligned dcl 4-33 ref 732
found_highest_seg_num_in_use    000143 automatic       bit(1)                   unaligned dcl 939 set ref 956* 957 960*
fsm_dir_dir_path                000122 automatic       char(168)                unaligned dcl 393 in procedure
                                                                                  "appropriate_fsm_info" set ref 431* 432* 434* 457*
                                                                                  462* 467*
fsm_dir_dir_path                       parameter       char                     unaligned dcl 767 in procedure
                                                                                  "get_fsm_dir_dir_path" set ref 745 778* 779 780*
                                                                                  781 781* 783 785 787*
fsm_dir_name                    000174 automatic       char(32)                 unaligned dcl 393 set ref 429* 432* 434* 457* 462*
fsm_dir_name_master             000006 constant        char(8)                  initial unaligned dcl 54 ref 429
fsm_dir_path                    000010 internal static char(168)                initial unaligned dcl 73 set ref 179* 182* 188* 228*
                                                                                  229* 315* 318* 432* 433* 438* 445* 447* 454* 463*
                                                                                  469* 471* 526* 557* 1031* 1032* 1032* 1037* 1042*
                                                                                  1044* 1044* 1047* 1049* 1049* 1076*
fsm_info                               based           structure                level 1 dcl 60
fsm_info_name                   000002 constant        char(13)                 initial unaligned dcl 54 set ref 433* 438* 445* 447*
                                                                                  463* 467*
fsm_info_path                   000062 internal static char(168)                initial unaligned dcl 73 set ref 433* 451* 465* 488*
                                                                                  528* 547*
fsm_info_ptr                    000134 internal static pointer                  initial dcl 73 set ref 173 174 175 176 177 178 189
                                                                                  198 199 199 199 225 226 226 230 252 252 252 256
                                                                                  256 281 282 307 308 308 428* 430 438* 447* 451
                                                                                  463* 465 485 547 550 551 553 559 838 839 839 843
                                                                                  844 892 1022 1022 1024 1036 1040 1041 1070 1070
                                                                                  1073 1074 1074 1077 1082
fsm_info_ptr_valid              000136 internal static bit(1)                   initial unaligned dcl 73 set ref 420 516 563*
get_entry_name_                 000224 constant        entry                    external dcl 593 ref 659
get_group_id_                   000250 constant        entry                    external dcl 1005 ref 1026
get_group_id_$tag_star          000172 constant        entry                    external dcl 359 ref 442 457 457
get_line_length_$stream         000240 constant        entry                    external dcl 812 ref 870
get_lock_id_                    000140 constant        entry                    external dcl 52 ref 78
get_pdir_                       000234 constant        entry                    external dcl 772 in procedure "get_fsm_dir_dir_path"
                                                                                  ref 781
get_pdir_                       000226 constant        entry                    external dcl 593 in procedure
                                                                                  "description_of_location" ref 654
get_ring_                       000222 constant        entry                    external dcl 409 ref 429
get_system_free_area_           000174 constant        entry                    external dcl 359 ref 517
group                           000102 automatic       structure                array level 1 dcl 818 set ref 852 855 857 863* 863
                                                                                  864*
group_cnt                       000103 automatic       fixed bin(17,0)          dcl 823 in procedure "list_groups" set ref 837* 838
                                                                                  842* 842 843 844 851 854 872
group_cnt                       000121 automatic       fixed bin(17,0)          dcl 297 in procedure "fsm_" set ref 306* 308* 308
                                                                                  315 319*
group_idx                       000104 automatic       fixed bin(17,0)          dcl 823 set ref 851* 852 853 854 861 863 864* 872*
                                                                                  873 875 880*
hash_table                             based           pointer                  array level 2 packed unaligned dcl 4-19 ref 699 699
                                                                                  702
hash_table_idx                  000267 automatic       fixed bin(17,0)          dcl 605 set ref 699* 702*
hbound                                                 builtin function         dcl 137 ref 699
hcs_$add_acl_entries            000176 constant        entry                    external dcl 359 ref 445
hcs_$append_branch              000252 constant        entry                    external dcl 1005 ref 1037
hcs_$append_branchx             000200 constant        entry                    external dcl 359 ref 457
hcs_$fs_get_path_name           000230 constant        entry                    external dcl 593 ref 643
hcs_$get_uid_seg                000272 constant        entry                    external dcl 1126 ref 1131
hcs_$high_low_seg_count         000246 constant        entry                    external dcl 936 ref 953
hcs_$initiate                   000142 constant        entry                    external dcl 131 ref 179 447
hcs_$make_seg                   000202 constant        entry                    external dcl 359 ref 438 463
hcs_$replace_acl                000254 constant        entry                    external dcl 1005 ref 1031
hcs_$set_256K_switch            000206 constant        entry                    external dcl 359 ref 424
hcs_$set_max_length             000256 constant        entry                    external dcl 1005 ref 1042
hcs_$set_safety_sw              000204 constant        entry                    external dcl 359 in procedure "appropriate_fsm_info"
                                                                                  ref 462 467
hcs_$set_safety_sw              000260 constant        entry                    external dcl 1005 in procedure "pick_seg" ref 1047
hcs_$star_                      000210 constant        entry                    external dcl 359 ref 526
hcs_$status_minf                000212 constant        entry                    external dcl 359 ref 434
hcs_$terminate_file             000144 constant        entry                    external dcl 131 in procedure "fsm_" ref 188 228
hcs_$terminate_file             000264 constant        entry                    external dcl 1059 in procedure "release_fsm_info"
                                                                                  ref 1076
hcs_$truncate_file              000150 constant        entry                    external dcl 220 ref 229 557
high_seg_num                    000144 automatic       fixed bin(17,0)          dcl 939 set ref 954* 958* 958* 958 968 986
high_seg_num_minus_low_seg_num  000145 automatic       fixed bin(17,0)          dcl 939 set ref 953* 954
i                               000204 automatic       fixed bin(17,0)          dcl 393 set ref 532* 533*
index                                                  builtin function         dcl 137 ref 692
ioa_                            000152 constant        entry                    external dcl 295 ref 315 318
ioa_$nnl                        000242 constant        entry                    external dcl 812 ref 876 878 886 890 893
language                        000270 automatic       char(8)                  dcl 605 set ref 659*
lbound                                                 builtin function         dcl 137 ref 699
length                                                 builtin function         dcl 137 ref 883 885 889
line_len                        000105 automatic       fixed bin(17,0)          dcl 823 set ref 879* 883 885* 885 889*
location                               parameter       pointer                  dcl 591 set ref 573 622 627 631 634 638 638 643* 646
                                                                                  646 659* 669 672 675 675 678 681 705 705 705 717
                                                                                  720
lock                                   based           bit(36)                  level 2 dcl 60 set ref 485* 1070 1082*
low_seg_num                     000146 automatic       fixed bin(17,0)          dcl 939 set ref 953* 954 955* 955 968
ltrim                                                  builtin function         dcl 137 ref 429 631 915 1104
max_group_cnt                          parameter       fixed bin(17,0)          dcl 809 ref 792 818 838
max_line_len                    000106 automatic       fixed bin(17,0)          dcl 823 set ref 870* 883
max_seg_idx                     000205 automatic       fixed bin(17,0)          dcl 393 set ref 531* 539 539* 547
me                              000100 automatic       pointer                  initial dcl 78 set ref 78* 155 175 199 1074
modes                    10     000106 automatic       bit(36)                  level 2 in structure "acl" dcl 387 in procedure
                                                                                  "appropriate_fsm_info" set ref 443*
modes                    10     000160 automatic       bit(36)                  level 2 in structure "acl" dcl 1014 in procedure
                                                                                  "pick_seg" set ref 1027*
my_process                      000102 automatic       bit(36)                  initial dcl 78 set ref 78* 174 199 226 252 282 308
                                                                                  319* 1070 1074
name                     11            based           char                     level 2 in structure "variable_node" dcl 4-33
                                                                                  in procedure "description_of_location" ref 716
name                            000107 automatic       varying char(32)         dcl 823 in procedure "list_groups" set ref 882* 883
                                                                                  885 886* 889 890*
name_size                10            based           fixed bin(21,0)          level 2 dcl 4-33 ref 716
next_seg_in_group         5            based           fixed bin(17,0)          array level 3 dcl 60 set ref 173* 177* 189 892
next_sp                  22            based           pointer                  level 2 dcl 2-36 ref 675
nindex                    0(18)        based           fixed bin(18,0)          array level 2 packed unsigned unaligned dcl 1-27 ref
                                                                                  533
nnames                    0(02)        based           fixed bin(16,0)          array level 2 packed unsigned unaligned dcl 1-27 ref
                                                                                  521 543
null                                                   builtin function         dcl 137 in procedure "fsm_" ref 154 155 258 393 428
                                                                                  430 451 465 518 521 523 543 545 780 780 1041 1070
                                                                                  1167 1167
null                                                   builtin function         dcl 598 in procedure "description_of_location" ref
                                                                                  622 672 696 702
num_segs_desired                       parameter       fixed bin(17,0)          dcl 127 in procedure "fsm_" set ref 84 155 168* 169
num_segs_desired                       parameter       fixed bin(17,0)          dcl 933 in procedure "pick_first_seg_num" ref 918
                                                                                  968 972 986
owner                           000102 automatic       pointer                  array level 2 in structure "group" packed unaligned
                                                                                  dcl 818 in procedure "list_groups" set ref 843*
                                                                                  873 875
owner                                  parameter       pointer                  dcl 127 in procedure "fsm_" set ref 84 155 155 199
                                                                                  206 226 236 256* 258*
owner                     3            based           pointer                  array level 3 in structure "fsm_info" packed
                                                                                  unaligned dcl 60 in procedure "fsm_" set ref 175*
                                                                                  199 199* 226 256 843 1041* 1074
owning_process            2            based           bit(36)                  array level 3 dcl 60 set ref 174* 199 226 252 282
                                                                                  308 551 553 839 1022 1074
pathname_                       000146 constant        entry                    external dcl 131 ref 182 432 433 1032 1032 1044 1044
                                                                                  1049 1049
pl1_operators_$VLA_words_per_seg_
                                000262 external static fixed bin(19,0)          dcl 1005 in procedure "pick_seg" set ref 1042*
pl1_operators_$VLA_words_per_seg_
                                000214 external static fixed bin(19,0)          dcl 359 in procedure "appropriate_fsm_info" ref 422
prev_group_owner                000120 automatic       pointer                  unaligned dcl 823 set ref 871* 873 875* 876
prev_seg_in_group               000114 automatic       fixed bin(17,0)          dcl 143 set ref 173 192*
prev_sp                  20            based           pointer                  level 2 dcl 2-36 ref 672 673
primary_name                    000206 automatic       char(32)                 unaligned dcl 393 set ref 533* 534 534 538
ptr                                                    builtin function         dcl 137 ref 669
rel                                                    builtin function         dcl 137 ref 634 638 638 672 672 675 675 675 675 681
                                                                                  681 705 705 705 705 720 720
rtrim                                                  builtin function         dcl 137 ref 658 663 882 1165
sb                              000316 automatic       pointer                  dcl 3-24 set ref 694* 695
seg                       2            based           structure                array level 2 dcl 60 set ref 230* 559* 1077*
seg_cnt                         000216 automatic       fixed bin(17,0)          dcl 393 in procedure "appropriate_fsm_info" set ref
                                                                                  531* 537* 537 547 547
seg_cnt                   1            based           fixed bin(17,0)          level 2 in structure "fsm_info" dcl 60 in procedure
                                                                                  "fsm_" set ref 198 225 252 256 281 307 547 550 838
                                                                                  1022 1024 1036 1040* 1073
seg_idx                                parameter       fixed bin(17,0)          dcl 1003 in procedure "pick_seg" set ref 991 1022*
                                                                                  1022* 1024 1031* 1031* 1032* 1032* 1032* 1032*
                                                                                  1036 1037* 1037* 1040 1041 1042* 1042* 1044* 1044*
                                                                                  1044* 1044* 1047* 1047* 1049* 1049* 1049* 1049*
seg_idx                         000121 automatic       fixed bin(17,0)          dcl 823 in procedure "list_groups" set ref 838* 839
                                                                                  839 839 843 844* 880* 880* 882* 892
seg_idx                         000217 automatic       fixed bin(17,0)          dcl 393 in procedure "appropriate_fsm_info" set ref
                                                                                  538* 539 539 550* 551 553 557* 557* 559*
seg_idx                         000100 automatic       fixed bin(17,0)          dcl 1062 in procedure "release_fsm_info" set ref
                                                                                  1073* 1074 1074 1076* 1076* 1077*
seg_idx                                parameter       fixed bin(17,0)          dcl 1102 in procedure "seg_name" ref 1089 1104
seg_idx                         000115 automatic       fixed bin(17,0)          dcl 143 in procedure "fsm_" set ref 170* 171 173 174
                                                                                  175 176 177 178 179* 179* 182* 182* 186* 186* 188*
                                                                                  188* 189 192 198* 199 199 199* 225* 226 226 228*
                                                                                  228* 229* 229* 230* 252* 252 252* 256 256 281* 282
                                                                                  282* 307* 308 308 308*
seg_name                        000272 automatic       char(32)                 unaligned dcl 605 set ref 643* 658 692
seg_num                   6            based           fixed bin(17,0)          array level 3 in structure "fsm_info" dcl 60
                                                                                  in procedure "fsm_" set ref 178* 252
seg_num                         000302 automatic       fixed bin(18,0)          dcl 605 in procedure "description_of_location" set
                                                                                  ref 659*
seg_num                                parameter       fixed bin(17,0)          dcl 1121 in procedure "seg_num_free" ref 1107 1131
                                                                                  1131
seg_num                         000147 automatic       fixed bin(17,0)          dcl 939 in procedure "pick_first_seg_num" set ref
                                                                                  968* 969* 976*
seg_num                         000116 automatic       fixed bin(17,0)          dcl 143 in procedure "fsm_" set ref 169* 171 178 179
                                                                                  179 182*
seg_ptr                                parameter       pointer                  dcl 248 ref 236 252
segment_map_bits                       parameter       bit(1)                   array unaligned dcl 274 set ref 262 282*
set_lock_$lock                  000216 constant        entry                    external dcl 359 ref 485 553
set_lock_$unlock                000266 constant        entry                    external dcl 1059 ref 1082
signal_                         000274 constant        entry                    external dcl 1156 ref 1167
size                                                   builtin function         dcl 137 ref 1162
sp                              000314 automatic       pointer                  dcl 2-31 set ref 671* 672 672 673* 673 675 675 678
                                                                                  681 688
stack_frame                            based           structure                level 1 dcl 2-36
stack_header                           based           structure                level 1 dcl 3-26
stackbaseptr                                           builtin function         dcl 598 ref 669 694
stackframeptr                                          builtin function         dcl 598 ref 671
star_BRANCHES_ONLY              000060 constant        fixed bin(2,0)           initial dcl 1-110 set ref 526*
star_DIRECTORY                         constant        fixed bin(2,0)           initial unsigned dcl 1-121 ref 435
star_entries                           based           structure                array level 1 dcl 1-27 ref 523 545
star_entry_count                000225 automatic       fixed bin(17,0)          dcl 1-14 set ref 521 523 526* 532 543 545
star_entry_ptr                  000226 automatic       pointer                  dcl 1-15 set ref 518* 521 523 523 526* 533 543 545
                                                                                  545
star_names                             based           char(32)                 array unaligned dcl 1-37 ref 521 533 543
star_names_ptr                  000230 automatic       pointer                  dcl 1-19 set ref 518* 521 521 526* 533 543 543
status                          000122 automatic       fixed bin(35,0)          dcl 823 in procedure "list_groups" set ref 870*
status                          000220 automatic       fixed bin(35,0)          dcl 393 in procedure "appropriate_fsm_info" set ref
                                                                                  424* 425 425* 434* 435 438* 440 445* 447 447* 451*
                                                                                  455 457* 460 462* 463* 465* 467* 469* 471* 483*
                                                                                  484 485* 486 486* 488 488* 526* 528 528 528* 553*
                                                                                  555 557*
status                          000173 automatic       fixed bin(35,0)          dcl 1020 in procedure "pick_seg" set ref 1029* 1030
                                                                                  1031* 1032 1032* 1037* 1038 1042* 1044 1044* 1047*
                                                                                  1049*
status                                 parameter       fixed bin(35,0)          dcl 1153 in procedure "signal_fsm_error" ref 1137
                                                                                  1166
status                          000117 automatic       fixed bin(35,0)          dcl 143 in procedure "fsm_" set ref 179* 180 182*
                                                                                  188* 228* 229*
status                          000303 automatic       fixed bin(35,0)          dcl 605 in procedure "description_of_location" set
                                                                                  ref 643* 644 659* 660
status                          000250 automatic       fixed bin(35,0)          dcl 775 in procedure "get_fsm_dir_dir_path" set ref
                                                                                  780*
status                          000204 automatic       fixed bin(35,0)          dcl 1128 in procedure "seg_num_free" set ref 1131*
                                                                                  1132
status                          000101 automatic       fixed bin(35,0)          dcl 1062 in procedure "release_fsm_info" set ref
                                                                                  1076* 1080* 1081 1082* 1083 1083*
string                          000100 automatic       char(12)                 dcl 912 set ref 914* 915
substr                                                 builtin function         dcl 137 ref 534 627 631 656 783
sum                                                    builtin function         dcl 137 ref 521 543
sys_info$max_seg_size           000220 external static fixed bin(35,0)          dcl 359 ref 422
sys_link_info_ptr        60            based           pointer                  level 2 dcl 3-26 ref 695
system_free_area                       based           area(1024)               dcl 407 ref 521 523 543 545
system_free_area_ptr            000222 automatic       pointer                  initial dcl 393 set ref 393* 517* 521 523 526* 543
                                                                                  545
trial_group_idx                 000123 automatic       fixed bin(17,0)          dcl 823 set ref 854* 855 857 858*
try_again                       000120 automatic       bit(1)                   unaligned dcl 143 set ref 165* 166 167* 169 190*
type                            000224 automatic       fixed bin(2,0)           dcl 393 set ref 434* 435
uid                             000205 automatic       bit(36)                  dcl 1128 set ref 1131*
unspec                                                 builtin function         dcl 137 set ref 230* 559* 627 631 855 855 871* 1077*
                                                                                  1164*
value                                  parameter       fixed bin(17,0)          dcl 908 set ref 898 914*
value_$get                      000236 constant        entry                    external dcl 772 ref 780
variable_node                          based           structure                level 1 dcl 4-33
variable_table_header                  based           structure                level 1 dcl 4-19
vbl_ptr                   4            based           pointer                  level 2 dcl 4-33 ref 705 705 705 717 720
vbl_size                  1            based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 4-33 ref 705
verify                                                 builtin function         dcl 137 ref 534
vnp                             000304 automatic       pointer                  dcl 605 set ref 702* 702* 705 705 705 705 716 717
                                                                                  720* 732
vthp                            000306 automatic       pointer                  dcl 605 set ref 695* 696 699 699 702
word_offset                     000310 automatic       varying char(8)          dcl 605 set ref 634* 637* 638* 638 647 666
xmodes                   11     000106 automatic       bit(36)                  level 2 in structure "acl" dcl 387 in procedure
                                                                                  "appropriate_fsm_info" set ref 444*
xmodes                   11     000160 automatic       bit(36)                  level 2 in structure "acl" dcl 1014 in procedure
                                                                                  "pick_seg" set ref 1028*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 6-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 6-33
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 6-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 6-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 6-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
RETURN_PTR_MASK                        internal static bit(72)                  initial unaligned dcl 2-19
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 6-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 6-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 6-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 6-36
R_ACCESS                               internal static bit(3)                   initial unaligned dcl 6-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 6-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 6-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 6-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 6-11
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 6-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 6-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 6-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial unaligned dcl 2-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial unaligned dcl 2-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial unaligned dcl 2-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial unaligned dcl 2-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial unaligned dcl 2-27
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 6-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
call_offset                            internal static fixed bin(17,0)          initial dcl 3-78
condition_info_header_ptr              automatic       pointer                  dcl 5-4
entry_offset                           internal static fixed bin(17,0)          initial dcl 3-78
heap_header                            based           structure                level 1 unaligned dcl 4-64
heap_header_version_1                  internal static char(8)                  initial unaligned dcl 4-71
push_offset                            internal static fixed bin(17,0)          initial dcl 3-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 3-78
return_offset                          internal static fixed bin(17,0)          initial dcl 3-78
stack_frame_flags                      based           structure                level 1 dcl 2-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 2-33
stack_header_overlay                   based           fixed bin(17,0)          array dcl 3-94
star_ALL_ENTRIES                       internal static fixed bin(2,0)           initial dcl 1-111
star_ALL_ENTRIES_WITH_LINK_PATHS       internal static fixed bin(3,0)           initial dcl 1-114
star_LINK                              internal static fixed bin(2,0)           initial unsigned dcl 1-119
star_LINKS_ONLY                        internal static fixed bin(2,0)           initial dcl 1-109
star_LINKS_ONLY_WITH_LINK_PATHS        internal static fixed bin(3,0)           initial dcl 1-112
star_SEGMENT                           internal static fixed bin(2,0)           initial unsigned dcl 1-120
star_branch_count                      automatic       fixed bin(17,0)          dcl 1-13
star_dir_list_branch                   based           structure                array level 1 dcl 1-59
star_link_count                        automatic       fixed bin(17,0)          dcl 1-17
star_link_pathname                     based           char                     unaligned dcl 1-102
star_links                             based           structure                array level 1 dcl 1-76
star_linkx                             automatic       fixed bin(17,0)          dcl 1-18
star_list_branch                       based           structure                array level 1 dcl 1-41
star_list_branch_ptr                   automatic       pointer                  dcl 1-16
star_list_names                        based           char(32)                 array unaligned dcl 1-92
star_list_names_ptr                    automatic       pointer                  dcl 1-20
star_select_sw                         automatic       fixed bin(3,0)           dcl 1-21
tv_offset                              internal static fixed bin(17,0)          initial dcl 3-72

NAMES DECLARED BY EXPLICIT CONTEXT.
alloc                           000311 constant        entry                    external dcl 84
appropriate_fsm_info            001613 constant        entry                    internal dcl 324 ref 159 223 251 277 301
description_of_location         003331 constant        entry                    internal dcl 573 ref 688 876
fortran_storage_manager_        000275 constant        entry                    external dcl 17
free                            001003 constant        entry                    external dcl 206
fsm_                            000264 constant        entry                    external dcl 17 ref 78
get_fsm_dir_dir_path            004457 constant        entry                    internal dcl 745 ref 431
get_owner                       001207 constant        entry                    external dcl 236
get_vla_segnos                  001331 constant        entry                    external dcl 262
lfs                             001434 constant        entry                    external dcl 288
list_fortran_storage            001445 constant        entry                    external dcl 288
list_groups                     004647 constant        entry                    internal dcl 792 ref 319
octal_representation            005301 constant        entry                    internal dcl 898 ref 182 638 646 681 720
pick_first_seg_num              005344 constant        entry                    internal dcl 918 ref 168
pick_seg                        005463 constant        entry                    internal dcl 991 ref 170
release_fsm_info                006156 constant        entry                    internal dcl 1053 ref 158 203 222 233 250 259 276
                                                                                  285 300 321
seg_name                        006334 constant        entry                    internal dcl 1089 ref 179 179 182 182 188 188 228
                                                                                  228 229 229 557 557 882 1031 1031 1032 1032 1032
                                                                                  1032 1037 1037 1042 1042 1044 1044 1044 1044 1047
                                                                                  1047 1049 1049 1049 1049 1076 1076
seg_num_free                    006406 constant        entry                    internal dcl 1107 ref 958 969
signal_fsm_error                006450 constant        entry                    internal dcl 1137 ref 182 425 451 454 465 469 471
                                                                                  488 528 547 785 1032 1044 1049 1083

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7726       10224    7010        7736
Length     10754    7010       276         513     715         130

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
fsm_                                342 external procedure  is an external procedure.  
on unit on line 158                  64 on unit               
on unit on line 222                  64 on unit               
on unit on line 250                  64 on unit               
on unit on line 276                  64 on unit               
on unit on line 300                  64 on unit               
appropriate_fsm_info                533 internal procedure  enables or reverts conditions.  
on unit on line 519                  64 on unit               
description_of_location             367 internal procedure  calls itself recursively.  
get_fsm_dir_dir_path                    internal procedure  shares stack frame of internal procedure appropriate_fsm_info.  
list_groups                         179 internal procedure  uses auto adjustable storage.  
octal_representation                 74 internal procedure  is called by several nonquick procedures.  
pick_first_seg_num                      internal procedure  shares stack frame of external procedure fsm_.  
pick_seg                                internal procedure  shares stack frame of external procedure fsm_.  
release_fsm_info                    102 internal procedure  is called by several nonquick procedures.  
seg_name                             72 internal procedure  is called by several nonquick procedures.  
seg_num_free                            internal procedure  shares stack frame of external procedure fsm_.  
signal_fsm_error                    162 internal procedure  is called during a stack extension.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 fsm_dir_path                fsm_
000062 fsm_info_path               fsm_
000134 fsm_info_ptr                fsm_
000136 fsm_info_ptr_valid          fsm_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
appropriate_fsm_info     000106 acl                         appropriate_fsm_info
                         000121 bit_count                   appropriate_fsm_info
                         000122 fsm_dir_dir_path            appropriate_fsm_info
                         000174 fsm_dir_name                appropriate_fsm_info
                         000204 i                           appropriate_fsm_info
                         000205 max_seg_idx                 appropriate_fsm_info
                         000206 primary_name                appropriate_fsm_info
                         000216 seg_cnt                     appropriate_fsm_info
                         000217 seg_idx                     appropriate_fsm_info
                         000220 status                      appropriate_fsm_info
                         000222 system_free_area_ptr        appropriate_fsm_info
                         000224 type                        appropriate_fsm_info
                         000225 star_entry_count            appropriate_fsm_info
                         000226 star_entry_ptr              appropriate_fsm_info
                         000230 star_names_ptr              appropriate_fsm_info
                         000250 status                      get_fsm_dir_dir_path
description_of_location  000100 bit_offset                  description_of_location
                         000102 checking_external_variables description_of_location
                         000103 description                 description_of_location
                         000204 dir_name                    description_of_location
                         000256 dir_name_len                description_of_location
                         000257 entry_name                  description_of_location
                         000267 hash_table_idx              description_of_location
                         000270 language                    description_of_location
                         000272 seg_name                    description_of_location
                         000302 seg_num                     description_of_location
                         000303 status                      description_of_location
                         000304 vnp                         description_of_location
                         000306 vthp                        description_of_location
                         000310 word_offset                 description_of_location
                         000314 sp                          description_of_location
                         000316 sb                          description_of_location
fsm_                     000100 me                          fsm_
                         000102 my_process                  fsm_
                         000112 first_seg_in_group          fsm_
                         000113 first_seg_num               fsm_
                         000114 prev_seg_in_group           fsm_
                         000115 seg_idx                     fsm_
                         000116 seg_num                     fsm_
                         000117 status                      fsm_
                         000120 try_again                   fsm_
                         000121 group_cnt                   fsm_
                         000140 best_hole_size              pick_first_seg_num
                         000141 best_hole_start             pick_first_seg_num
                         000142 cur_hole_size               pick_first_seg_num
                         000143 found_highest_seg_num_in_use
                                                            pick_first_seg_num
                         000144 high_seg_num                pick_first_seg_num
                         000145 high_seg_num_minus_low_seg_num
                                                            pick_first_seg_num
                         000146 low_seg_num                 pick_first_seg_num
                         000147 seg_num                     pick_first_seg_num
                         000160 acl                         pick_seg
                         000173 status                      pick_seg
                         000204 status                      seg_num_free
                         000205 uid                         seg_num_free
list_groups              000100 expected_group              list_groups
                         000102 group                       list_groups
                         000102 expected_group_idx          list_groups
                         000103 group_cnt                   list_groups
                         000104 group_idx                   list_groups
                         000105 line_len                    list_groups
                         000106 max_line_len                list_groups
                         000107 name                        list_groups
                         000120 prev_group_owner            list_groups
                         000121 seg_idx                     list_groups
                         000122 status                      list_groups
                         000123 trial_group_idx             list_groups
octal_representation     000100 string                      octal_representation
release_fsm_info         000100 seg_idx                     release_fsm_info
                         000101 status                      release_fsm_info
signal_fsm_error         000100 condition_info              signal_fsm_error

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     unpk_to_pk          cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other_desc call_int_other      return_mac          alloc_auto_adj      mpfx2
enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry           int_entry_desc
set_chars_eis       index_chars_eis     any_to_any_truncate_set_support         op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$level_get                 cv_bin_$oct                   get_entry_name_               get_group_id_
get_group_id_$tag_star        get_line_length_$stream       get_lock_id_                  get_pdir_
get_pdir_                     get_ring_                     get_system_free_area_         hcs_$add_acl_entries
hcs_$append_branch            hcs_$append_branchx           hcs_$fs_get_path_name         hcs_$get_uid_seg
hcs_$high_low_seg_count       hcs_$initiate                 hcs_$make_seg                 hcs_$replace_acl
hcs_$set_256K_switch          hcs_$set_max_length           hcs_$set_safety_sw            hcs_$set_safety_sw
hcs_$star_                    hcs_$status_minf              hcs_$terminate_file           hcs_$terminate_file
hcs_$truncate_file            ioa_                          ioa_$nnl                      pathname_
set_lock_$lock                set_lock_$unlock              signal_                       value_$get

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_segment      error_table_$invalid_lock_reset                             error_table_$invalidsegno
error_table_$moderr           error_table_$noentry          error_table_$nomatch          error_table_$not_abs_path
error_table_$notadir          pl1_operators_$VLA_words_per_seg_
pl1_operators_$VLA_words_per_seg_                           sys_info$max_seg_size


CONSTANTS
006546  aa  403 040 022 146	 f
006547  aa  040 321 000 000	 

006550  aa     007777000001

006552  aa     000004000000
006553  aa     000000000000
006554  aa     600000000041
006555  aa     000147000000
006556  aa     600000000041
006557  aa     000356000000

006560  aa     000004000000
006561  aa     000000000000
006562  aa     600000000041
006563  aa     000144000000
006564  aa     600000000041
006565  aa     000356000000

006566  aa  403 040 022 140	 `
006567  aa  146 040 321 000	f 

006570  aa  777 777 777 777	
006571  aa  777 777 777 777	
006572  aa  777 777 777 777	
006573  aa  777 777 777 777	
006574  aa  777 777 777 777	
006575  aa  777 777 777 777	
006576  aa  777 777 777 777	
006577  aa  777 777 777 777	
006600  aa  777 777 777 777	
006601  aa  777 777 777 777	
006602  aa  777 777 777 777	
006603  aa  777 777 777 777	
006604  aa  000 000 000 000	    
006605  aa  000 000 000 000	    
006606  aa  000 000 777 777	  
006607  aa  777 777 777 777	
006610  aa  777 777 777 777	
006611  aa  777 777 777 777	
006612  aa  777 777 777 777	
006613  aa  777 777 777 777	
006614  aa  777 777 777 777	
006615  aa  777 777 777 777	
006616  aa  777 777 777 777	
006617  aa  777 777 777 777	
006620  aa  777 777 777 777	
006621  aa  777 777 777 777	
006622  aa  777 777 777 777	
006623  aa  777 777 777 777	
006624  aa  777 777 777 777	
006625  aa  777 777 777 777	
006626  aa  777 777 777 777	
006627  aa  777 777 777 777	
006630  aa  777 777 777 777	
006631  aa  777 777 777 777	
006632  aa  777 777 777 777	
006633  aa  777 777 777 777	
006634  aa  777 777 777 777	
006635  aa  777 777 777 777	
006636  aa  777 777 777 777	
006637  aa  777 777 777 777	
006640  aa  777 777 777 777	
006641  aa  777 777 777 777	
006642  aa  777 777 777 777	
006643  aa  777 777 777 777	
006644  aa  777 777 777 777	
006645  aa  777 777 777 777	
006646  aa  777 777 777 777	
006647  aa  777 777 777 777	
006650  aa  777 777 777 777	
006651  aa  777 777 777 777	
006652  aa  777 777 777 777	
006653  aa  777 777 777 777	
006654  aa  777 777 777 777	
006655  aa  777 777 777 777	
006656  aa  777 777 777 777	
006657  aa  777 777 777 777	
006660  aa  777 777 777 777	
006661  aa  777 777 777 777	
006662  aa  777 777 777 777	
006663  aa  777 777 777 777	
006664  aa  777 777 777 777	
006665  aa  777 777 777 777	
006666  aa  777 777 777 777	
006667  aa  777 777 777 777	
006670  aa  777 777 777 777	
006671  aa  777 777 777 777	
006672  aa  777 777 777 777	
006673  aa  777 777 777 777	
006674  aa  777 777 777 777	
006675  aa  777 777 777 777	
006676  aa  777 777 777 777	
006677  aa  777 777 777 777	
006700  aa  777 777 777 777	
006701  aa  777 777 777 777	
006702  aa  777 777 777 777	
006703  aa  777 777 777 777	
006704  aa  777 777 777 777	
006705  aa  777 777 777 777	
006706  aa  777 777 777 777	
006707  aa  777 777 777 777	
006710  aa  777 777 777 777	
006711  aa  777 777 777 777	
006712  aa  777 777 777 777	
006713  aa  777 777 777 777	
006714  aa  777 777 777 777	
006715  aa  777 777 777 777	
006716  aa  777 777 777 777	
006717  aa  777 777 777 777	
006720  aa  777 777 777 777	
006721  aa  777 777 777 777	
006722  aa  777 777 777 777	
006723  aa  777 777 777 777	
006724  aa  777 777 777 777	
006725  aa  777 777 777 777	
006726  aa  777 777 777 777	
006727  aa  777 777 777 777	
006730  aa  777 777 777 777	
006731  aa  777 777 777 777	
006732  aa  777 777 777 777	
006733  aa  777 777 777 777	
006734  aa  777 777 777 777	
006735  aa  777 777 777 777	
006736  aa  777 777 777 777	
006737  aa  777 777 777 777	
006740  aa  777 777 777 777	
006741  aa  777 777 777 777	
006742  aa  777 777 777 777	
006743  aa  777 777 777 777	
006744  aa  777 777 777 777	
006745  aa  777 777 777 777	
006746  aa  777 777 777 777	
006747  aa  777 777 777 777	
006750  aa  777 777 777 777	
006751  aa  777 777 777 777	
006752  aa  777 777 777 777	
006753  aa  777 777 777 777	
006754  aa  777 777 777 777	
006755  aa  777 777 777 777	
006756  aa  777 777 777 777	
006757  aa  777 777 777 777	
006760  aa  777 777 777 777	
006761  aa  777 777 777 777	
006762  aa  777 777 777 777	
006763  aa  777 777 777 777	
006764  aa  777 777 777 777	
006765  aa  777 777 777 777	
006766  aa  777 777 777 777	
006767  aa  777 777 777 777	

006770  aa     000002000000
006771  aa     000002000000
006772  aa     600000000041
006773  aa     000122000000
006774  ta     000055000000
006775  aa     000000000000

006776  aa  403 040 022 141	 a
006777  aa  040 321 000 000	 

007000  aa     000002000000
007001  aa     000000000000
007002  aa     600000000041
007003  aa     000115000000

000000  aa     000000000170

000001  aa     000000000013

000002  aa  146 163 155 137	fsm_
000003  aa  151 156 146 157	info
000004  aa  056 146 163 155	.fsm
000005  aa  137 000 000 000	_

000006  aa  146 163 155 137	fsm_
000007  aa  144 151 162 137	dir_


000010  aa     524000000035

000011  aa     524000000034

000012  aa     524000000250

000013  aa     524000000002

000014  aa     000000000012

000015  aa     530000000040

000016  aa  040 136 141 000	 ^a

000017  aa     524000000003

000020  aa  136 064 170 000	^4x

000021  aa     524000000014

000022  aa     524000000013

000023  aa     524000000020

000024  aa     526077777777

000025  aa  040 157 146 040	 of 

007004  aa  044 000 000 000	$

000026  aa     524000000010

000027  aa     404000000022

000030  aa  133 160 144 135	[pd]

007005  aa  076 000 000 000	>

007006  aa  174 000 000 000	|

000031  aa  156 165 154 154	null

000032  aa     524000000006

000033  aa     514000000001

000034  aa     404000000005

000035  aa     404000000030

000036  aa     526000000015

000037  aa     524000000026

000040  aa     404000000003

000041  aa     524000000051

000042  aa     524000000054

000043  aa     404000000023

007007  aa  051 000 000 000	)

000044  aa     404000000043

000045  aa     404000000002

000046  aa     404000000001

000047  aa     524000000000

000050  aa     524000000040

000051  aa     516000000001

000052  aa     526000000040

000053  aa     530000000014

000054  aa     530000000400

000055  aa     526000000250

000056  aa     464000000000

000057  aa     404000000021

000060  aa     000000000002

000061  aa     514000000044

000062  aa     000000000001

000064  aa  056 146 163 155	.fsm
000065  aa  137 000 000 000	_

000066  aa  136 057 136 055	^/^-
000067  aa  136 141 000 000	^a

000070  aa     000000000000
000071  aa     000000000000

000072  aa  052 056 146 163	*.fs
000073  aa  155 137 000 000	m_

000074  aa     077777000043
000075  aa     000001000000

000076  aa  143 154 145 141	clea
000077  aa  156 165 160 000	nup

000100  aa  136 057 136 141	^/^a
000101  aa  040 157 167 156	 own
000102  aa  163 072 136 057	s:^/

000103  aa  165 163 145 162	user
000104  aa  137 157 165 164	_out
000105  aa  160 165 164 000	put

000106  aa  056 141 162 145	.are
000107  aa  141 056 154 151	a.li
000110  aa  156 153 145 162	nker

000111  aa  060 061 062 063	0123
000112  aa  064 065 066 067	4567
000113  aa  070 071 000 000	89

000114  aa  040 141 163 040	 as 
000115  aa  163 145 147 155	segm
000116  aa  145 156 164 040	ent 

000117  aa  146 163 155 137	fsm_
000120  aa  144 151 162 137	dir_
000121  aa  144 151 162 137	dir_
000122  aa  160 141 164 150	path

000123  aa  040 050 163 164	 (st
000124  aa  141 143 153 137	ack_
000125  aa  146 162 141 155	fram
000126  aa  145 000 000 000	e

000127  aa     404100000006
000130  aa     000000000001
000131  aa     000000000003
000132  aa     000000000001

000133  aa     516100000001
000134  aa     400000000000
000135  aa     400000000000
000136  aa     400000000000

000137  aa  040 050 105 170	 (Ex
000140  aa  164 145 162 156	tern
000141  aa  141 154 040 126	al V
000142  aa  141 162 151 141	aria
000143  aa  142 154 145 040	ble 

000144  aa  050 124 162 171	(Try
000145  aa  151 156 147 040	ing 
000146  aa  164 157 040 151	to i
000147  aa  156 151 164 151	niti
000150  aa  141 164 145 040	ate 

000151  aa  103 141 156 156	Cann
000152  aa  157 164 040 163	ot s
000153  aa  145 164 040 062	et 2
000154  aa  065 066 113 040	56K 
000155  aa  163 167 151 164	swit
000156  aa  143 150 000 000	ch

000157  aa  124 162 171 151	Tryi
000160  aa  156 147 040 164	ng t
000161  aa  157 040 165 156	o un
000162  aa  154 157 143 153	lock
000163  aa  040 047 146 163	 'fs
000164  aa  155 137 151 156	m_in
000165  aa  146 157 047 056	fo'.

000166  aa  040 050 123 145	 (Se
000167  aa  147 155 145 156	gmen
000170  aa  164 040 156 165	t nu
000171  aa  155 142 145 162	mber
000172  aa  040 151 156 166	 inv
000173  aa  141 154 151 144	alid
000174  aa  051 000 000 000	)

000175  aa  146 157 162 164	fort
000176  aa  162 141 156 137	ran_
000177  aa  163 164 157 162	stor
000200  aa  141 147 145 137	age_
000201  aa  155 141 156 141	mana
000202  aa  147 145 162 137	ger_
000203  aa  145 162 162 157	erro
000204  aa  162 000 000 000	r

000205  aa  123 145 147 155	Segm
000206  aa  145 156 164 163	ents
000207  aa  040 151 156 040	 in 
000210  aa  136 141 040 141	^a a
000211  aa  154 154 157 143	lloc
000212  aa  141 164 145 144	ated
000213  aa  040 164 157 040	 to 
000214  aa  164 150 151 163	this
000215  aa  040 160 162 157	 pro
000216  aa  143 145 163 163	cess
000217  aa  072 000 000 000	:

000220  aa  116 157 040 163	No s
000221  aa  145 147 155 145	egme
000222  aa  156 164 163 040	nts 
000223  aa  151 156 040 136	in ^
000224  aa  141 040 141 154	a al
000225  aa  154 157 143 141	loca
000226  aa  164 145 144 040	ted 
000227  aa  164 157 040 164	to t
000230  aa  150 151 163 040	his 
000231  aa  160 162 157 143	proc
000232  aa  145 163 163 056	ess.

000233  aa  126 141 154 165	Valu
000234  aa  145 040 163 145	e se
000235  aa  147 155 145 156	gmen
000236  aa  164 040 163 160	t sp
000237  aa  145 143 151 146	ecif
000240  aa  151 145 163 040	ies 
000241  aa  047 146 163 155	'fsm
000242  aa  137 144 151 162	_dir
000243  aa  137 144 151 162	_dir
000244  aa  137 160 141 164	_pat
000245  aa  150 047 040 075	h' =
000246  aa  040 000 000 000	 

BEGIN PROCEDURE fsm_
PROLOGUE SEQUENCE
000247  aa  6 00206 4401 00	sxl0 	pr6|134
						STATEMENT 1 ON LINE 78
000250  aa   000014 3520 04	epp2 	12,ic		000264 = 000540627000
000251  aa  6 00100 2521 00	spri2	pr6|64		me
000252  aa  6 00102 3521 00	epp2 	pr6|66		my_process
000253  aa  6 00212 2521 00	spri2	pr6|138
000254  aa  6 00210 6211 00	eax1 	pr6|136
000255  aa   004000 4310 07	fld  	2048,dl
000256  aa  6 00044 3701 20	epp4 	pr6|36,*
000257  la  4 00140 3521 20	epp2 	pr4|96,*		get_lock_id_
000260  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000261  aa  6 00206 7201 00	lxl0 	pr6|134
000262  aa   000000 7100 10	tra  	0,0
MAIN SEQUENCE
ENTRY TO fsm_                                               STATEMENT 1 ON LINE 17
fortran_storage_manager_:
fsm_:
     proc options (support);

000263  da     000507200000
000264  aa   000540 6270 00	eax7 	352
000265  aa  7 00034 3521 20	epp2 	pr7|28,*
000266  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000267  aa     000000000000
000270  aa     000000000000
000271  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
000272  aa   777755 7000 04	tsx0 	-19,ic		000247
000273  aa   000011 7100 04	tra  	9,ic		000304
ENTRY TO fortran_storage_manager_                           STATEMENT 1 ON LINE 17
fortran_storage_manager_:
fsm_:
     proc options (support);

000274  da     000512200000
000275  aa   000540 6270 00	eax7 	352
000276  aa  7 00034 3521 20	epp2 	pr7|28,*
000277  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000300  aa     000000000000
000301  aa     000000000000
000302  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
000303  aa   777744 7000 04	tsx0 	-28,ic		000247
						STATEMENT 1 ON LINE 82
	return;

000304  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO alloc                                              STATEMENT 1 ON LINE 84
alloc:
     entry (num_segs_desired, owner, first_seg_ptr);

000305  at     000003000057
000306  tt     000056000056
000307  ta     000305000000
000310  da     000517300000
000311  aa   000540 6270 00	eax7 	352
000312  aa  7 00034 3521 20	epp2 	pr7|28,*
000313  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000314  aa     000006000000
000315  aa     000000000000
000316  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
000317  aa  6 00032 3735 20	epp7 	pr6|26,*
000320  aa  7 00004 3715 20	epp5 	pr7|4,*
000321  aa  6 00122 6515 00	spri5	pr6|82
000322  aa   777725 7000 04	tsx0 	-43,ic		000247
						STATEMENT 1 ON LINE 154
	first_seg_ptr = null;

000323  aa   777551 2370 04	ldaq 	-151,ic		000074 = 077777000043 000001000000
000324  aa  6 00032 3735 20	epp7 	pr6|26,*
000325  aa  7 00006 7571 20	staq 	pr7|6,*		first_seg_ptr
						STATEMENT 1 ON LINE 155
	if num_segs_desired <= 0 | owner = null | owner = me
	then return;

000326  aa  7 00002 2361 20	ldq  	pr7|2,*		num_segs_desired
000327  aa  0 00631 6045 00	tmoz 	pr0|409		return_mac
000330  aa  6 00122 2371 20	ldaq 	pr6|82,*		owner
000331  aa   777543 6770 04	eraq 	-157,ic		000074 = 077777000043 000001000000
000332  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000333  aa  0 00631 6001 00	tze  	pr0|409		return_mac
000334  aa  6 00122 2371 20	ldaq 	pr6|82,*		owner
000335  aa  6 00100 6771 00	eraq 	pr6|64		me
000336  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000337  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 158
	on cleanup call release_fsm_info;

000340  aa   000007 7260 07	lxl6 	7,dl
000341  aa   777535 3520 04	epp2 	-163,ic		000076 = 143154145141
000342  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
000343  aa   000004 7100 04	tra  	4,ic		000347
000344  aa     000104000000
000345  aa   000016 7100 04	tra  	14,ic		000363
BEGIN CONDITION cleanup.1
ENTRY TO cleanup.1                                          STATEMENT 1 ON LINE 158
	on cleanup call release_fsm_info;

000346  da     000525200000
000347  aa   000100 6270 00	eax7 	64
000350  aa  7 00034 3521 20	epp2 	pr7|28,*
000351  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000352  aa     000000000000
000353  aa     000000000000
000354  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
000355  aa   000001 7270 07	lxl7 	1,dl
000356  aa  6 00056 6211 00	eax1 	pr6|46
000357  aa   000000 4310 07	fld  	0,dl
000360  aa   005576 3520 04	epp2 	2942,ic		006156 = 000160627000
000361  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
000362  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.1
						STATEMENT 1 ON LINE 159
	call appropriate_fsm_info;

000363  aa  6 00056 6211 00	eax1 	pr6|46
000364  aa   000000 4310 07	fld  	0,dl
000365  aa   001226 3520 04	epp2 	662,ic		001613 = 001040627000
000366  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 165
	try_again = True;

000367  aa   400000 2350 03	lda  	131072,du
000370  aa  6 00120 7551 00	sta  	pr6|80		try_again
						STATEMENT 1 ON LINE 166
	do while (try_again);

000371  aa   000000 0110 03	nop  	0,du
000372  aa  6 00120 2351 00	lda  	pr6|80		try_again
000373  aa   000340 6000 04	tze  	224,ic		000733
						STATEMENT 1 ON LINE 167
	     try_again = False;

000374  aa  6 00120 4501 00	stz  	pr6|80		try_again
						STATEMENT 1 ON LINE 168
	     call pick_first_seg_num (num_segs_desired, first_seg_num);

000375  aa  6 00032 3735 20	epp7 	pr6|26,*
000376  aa  7 00002 3521 20	epp2 	pr7|2,*		num_segs_desired
000377  aa  6 00216 2521 00	spri2	pr6|142
000400  aa  6 00113 3521 00	epp2 	pr6|75		first_seg_num
000401  aa  6 00220 2521 00	spri2	pr6|144
000402  aa  6 00214 3521 00	epp2 	pr6|140
000403  aa   010000 4310 07	fld  	4096,dl
000404  aa  2 00000 7571 00	staq 	pr2|0
000405  aa   004737 6700 04	tsp4 	2527,ic		005344
						STATEMENT 1 ON LINE 169
	     do seg_num = first_seg_num to first_seg_num + num_segs_desired - 1 while (^try_again);

000406  aa  6 00113 2361 00	ldq  	pr6|75		first_seg_num
000407  aa  6 00032 3735 20	epp7 	pr6|26,*
000410  aa  7 00002 0761 20	adq  	pr7|2,*		num_segs_desired
000411  aa   000001 1760 07	sbq  	1,dl
000412  aa  6 00124 7561 00	stq  	pr6|84
000413  aa  6 00113 2361 00	ldq  	pr6|75		first_seg_num
000414  aa  6 00116 7561 00	stq  	pr6|78		seg_num
000415  aa   000000 0110 03	nop  	0,du
000416  aa  6 00116 2361 00	ldq  	pr6|78		seg_num
000417  aa  6 00124 1161 00	cmpq 	pr6|84
000420  aa   777752 6054 04	tpnz 	-22,ic		000372
000421  aa  6 00120 2351 00	lda  	pr6|80		try_again
000422  aa   777750 6010 04	tnz  	-24,ic		000372
						STATEMENT 1 ON LINE 170
		call pick_seg (seg_idx);

000423  aa   006355 3520 04	epp2 	3309,ic		007000 = 000002000000
000424  aa   005037 6700 04	tsp4 	2591,ic		005463
						STATEMENT 1 ON LINE 171
		if seg_num = first_seg_num
		then first_seg_in_group = seg_idx;

000425  aa  6 00116 2361 00	ldq  	pr6|78		seg_num
000426  aa  6 00113 1161 00	cmpq 	pr6|75		first_seg_num
000427  aa   000004 6010 04	tnz  	4,ic		000433
000430  aa  6 00115 2361 00	ldq  	pr6|77		seg_idx
000431  aa  6 00112 7561 00	stq  	pr6|74		first_seg_in_group
000432  aa   000007 7100 04	tra  	7,ic		000441
						STATEMENT 1 ON LINE 173
		else fsm_info.seg (prev_seg_in_group).next_seg_in_group = seg_idx;

000433  aa  6 00114 2361 00	ldq  	pr6|76		prev_seg_in_group
000434  aa   000005 4020 07	mpy  	5,dl
000435  aa   000000 6270 06	eax7 	0,ql
000436  aa  6 00115 2361 00	ldq  	pr6|77		seg_idx
000437  aa  6 00044 3701 20	epp4 	pr6|36,*
000440  ia  4 00134 7561 77	stq  	pr4|92,*7		fsm_info.next_seg_in_group
						STATEMENT 1 ON LINE 174
		fsm_info.seg (seg_idx).owning_process = my_process;

000441  aa   000005 4020 07	mpy  	5,dl
000442  aa  6 00102 2351 00	lda  	pr6|66		my_process
000443  aa  6 00044 3701 20	epp4 	pr6|36,*
000444  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
000445  aa  7 77775 7551 06	sta  	pr7|-3,ql		fsm_info.owning_process
						STATEMENT 1 ON LINE 175
		fsm_info.seg (seg_idx).owner = me;

000446  aa  6 00100 3715 20	epp5 	pr6|64,*		me
000447  aa  7 77776 5451 06	sprp5	pr7|-2,ql		fsm_info.owner
						STATEMENT 1 ON LINE 176
		fsm_info.seg (seg_idx).first_seg_in_group = first_seg_in_group;

000450  aa   000000 6270 06	eax7 	0,ql
000451  aa  6 00112 2361 00	ldq  	pr6|74		first_seg_in_group
000452  aa  7 77777 7561 17	stq  	pr7|-1,7		fsm_info.first_seg_in_group
						STATEMENT 1 ON LINE 177
		fsm_info.seg (seg_idx).next_seg_in_group = 0;

000453  aa  7 00000 4501 17	stz  	pr7|0,7		fsm_info.next_seg_in_group
						STATEMENT 1 ON LINE 178
		fsm_info.seg (seg_idx).seg_num = seg_num;

000454  aa  6 00116 2361 00	ldq  	pr6|78		seg_num
000455  aa  7 00001 7561 17	stq  	pr7|1,7		fsm_info.seg_num
						STATEMENT 1 ON LINE 179
		call hcs_$initiate (fsm_dir_path, seg_name (seg_idx), "", 1, 0, baseptr (seg_num), status);

000456  aa  6 00115 3521 00	epp2 	pr6|77		seg_idx
000457  aa  6 00226 2521 00	spri2	pr6|150
000460  aa  6 00214 3521 00	epp2 	pr6|140
000461  aa  6 00230 2521 00	spri2	pr6|152
000462  aa  6 00224 6211 00	eax1 	pr6|148
000463  aa   010000 4310 07	fld  	4096,dl
000464  aa   005650 3520 04	epp2 	2984,ic		006334 = 000120627000
000465  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
000466  aa   000001 2360 07	ldq  	1,dl
000467  aa  6 00234 7561 00	stq  	pr6|156
000470  aa  6 00235 4501 00	stz  	pr6|157
000471  aa  6 00116 2361 00	ldq  	pr6|78		seg_num
000472  aa  6 00000 3525 00	epbp2	pr6|0
000473  aa   000000 3130 06	easp2	0,ql
000474  aa  6 00236 2521 00	spri2	pr6|158
000475  aa  6 00044 3701 20	epp4 	pr6|36,*
000476  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
000477  aa  6 00242 2521 00	spri2	pr6|162
000500  aa  6 00214 3521 00	epp2 	pr6|140
000501  aa  6 00244 2521 00	spri2	pr6|164
000502  aa  6 00207 3521 00	epp2 	pr6|135
000503  aa  6 00246 2521 00	spri2	pr6|166
000504  aa  6 00234 3521 00	epp2 	pr6|156
000505  aa  6 00250 2521 00	spri2	pr6|168
000506  aa  6 00235 3521 00	epp2 	pr6|157
000507  aa  6 00252 2521 00	spri2	pr6|170
000510  aa  6 00236 3521 00	epp2 	pr6|158
000511  aa  6 00254 2521 00	spri2	pr6|172
000512  aa  6 00117 3521 00	epp2 	pr6|79		status
000513  aa  6 00256 2521 00	spri2	pr6|174
000514  aa   777341 3520 04	epp2 	-287,ic		000055 = 526000000250
000515  aa  6 00260 2521 00	spri2	pr6|176
000516  aa   777332 3520 04	epp2 	-294,ic		000050 = 524000000040
000517  aa  6 00262 2521 00	spri2	pr6|178
000520  aa   777327 3520 04	epp2 	-297,ic		000047 = 524000000000
000521  aa  6 00264 2521 00	spri2	pr6|180
000522  aa   777324 3520 04	epp2 	-300,ic		000046 = 404000000001
000523  aa  6 00266 2521 00	spri2	pr6|182
000524  aa   777321 3520 04	epp2 	-303,ic		000045 = 404000000002
000525  aa  6 00270 2521 00	spri2	pr6|184
000526  aa   777330 3520 04	epp2 	-296,ic		000056 = 464000000000
000527  aa  6 00272 2521 00	spri2	pr6|186
000530  aa   777314 3520 04	epp2 	-308,ic		000044 = 404000000043
000531  aa  6 00274 2521 00	spri2	pr6|188
000532  aa  6 00240 6211 00	eax1 	pr6|160
000533  aa   034000 4310 07	fld  	14336,dl
000534  la  4 00142 3521 20	epp2 	pr4|98,*		hcs_$initiate
000535  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 180
		if status ^= 0
		then do;

000536  aa  6 00117 2361 00	ldq  	pr6|79		status
000537  aa   000167 6000 04	tze  	119,ic		000726
						STATEMENT 1 ON LINE 182
			call signal_fsm_error (status,
			     "(Trying to initiate " || pathname_ (fsm_dir_path, seg_name (seg_idx))
			     || " as segment "
			     || octal_representation (seg_num) || ")");

000540  aa  6 00116 3521 00	epp2 	pr6|78		seg_num
000541  aa  6 00226 2521 00	spri2	pr6|150
000542  aa  6 00211 3521 00	epp2 	pr6|137
000543  aa  6 00230 2521 00	spri2	pr6|152
000544  aa  6 00224 6211 00	eax1 	pr6|148
000545  aa   010000 4310 07	fld  	4096,dl
000546  aa   004533 3520 04	epp2 	2395,ic		005301 = 000120627000
000547  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
000550  aa   000310 2360 07	ldq  	200,dl
000551  aa  6 00210 0761 00	adq  	pr6|136
000552  aa  6 00234 7561 00	stq  	pr6|156
000553  aa   000001 0760 07	adq  	1,dl
000554  aa  6 00207 7561 00	stq  	pr6|135
000555  aa   524000 2760 03	orq  	174080,du
000556  aa  6 00235 7561 00	stq  	pr6|157
000557  aa  6 00115 3521 00	epp2 	pr6|77		seg_idx
000560  aa  6 00226 2521 00	spri2	pr6|150
000561  aa  6 00214 3521 00	epp2 	pr6|140
000562  aa  6 00230 2521 00	spri2	pr6|152
000563  aa  6 00224 6211 00	eax1 	pr6|148
000564  aa   010000 4310 07	fld  	4096,dl
000565  aa   005547 3520 04	epp2 	2919,ic		006334 = 000120627000
000566  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
000567  aa  6 00044 3701 20	epp4 	pr6|36,*
000570  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
000571  aa  6 00242 2521 00	spri2	pr6|162
000572  aa  6 00214 3521 00	epp2 	pr6|140
000573  aa  6 00244 2521 00	spri2	pr6|164
000574  aa  6 00276 3521 00	epp2 	pr6|190
000575  aa  6 00246 2521 00	spri2	pr6|166
000576  aa   777257 3520 04	epp2 	-337,ic		000055 = 526000000250
000577  aa  6 00250 2521 00	spri2	pr6|168
000600  aa  6 00254 2521 00	spri2	pr6|172
000601  aa   777247 3520 04	epp2 	-345,ic		000050 = 524000000040
000602  aa  6 00252 2521 00	spri2	pr6|170
000603  aa  6 00240 6211 00	eax1 	pr6|160
000604  aa   014000 4310 07	fld  	6144,dl
000605  la  4 00146 3521 20	epp2 	pr4|102,*		pathname_
000606  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
000607  aa   000274 2360 07	ldq  	188,dl
000610  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
000611  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000612  aa   777333 00 0024	desc9a	-293,20		000144 = 050124162171
000613  aa  2 00000 00 0024	desc9a	pr2|0,20
000614  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
000615  aa  6 00276 00 0250	desc9a	pr6|190,168
000616  aa  2 00005 00 0250	desc9a	pr2|5,168
000617  aa   000310 2360 07	ldq  	200,dl
000620  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
000621  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000622  aa   777273 00 0014	desc9a	-325,12		000114 = 040141163040
000623  aa  2 00057 00 0014	desc9a	pr2|47,12
000624  aa  6 00234 2361 00	ldq  	pr6|156
000625  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
000626  aa  6 00210 7271 00	lxl7 	pr6|136
000627  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000630  aa  6 00211 00 0017	desc9a	pr6|137,x7
000631  aa  2 00062 00 0017	desc9a	pr2|50,x7
000632  aa  6 00207 2361 00	ldq  	pr6|135
000633  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
000634  aa  6 00234 2351 00	lda  	pr6|156
000635  aa  040 105 100 404	mlr  	(ic),(pr,al),fill(040)
000636  aa   006152 00 0001	desc9a	3178,1		007007 = 051000000000
000637  aa  2 00000 00 0001	desc9a	pr2|0,1
000640  aa  6 00244 2521 00	spri2	pr6|164
000641  aa  6 00117 3521 00	epp2 	pr6|79		status
000642  aa  6 00242 2521 00	spri2	pr6|162
000643  aa   777201 3520 04	epp2 	-383,ic		000044 = 404000000043
000644  aa  6 00250 2521 00	spri2	pr6|168
000645  aa  6 00235 3521 00	epp2 	pr6|157
000646  aa  6 00252 2521 00	spri2	pr6|170
000647  aa  6 00240 6211 00	eax1 	pr6|160
000650  aa   010000 4310 07	fld  	4096,dl
000651  aa   005577 3520 04	epp2 	2943,ic		006450 = 000260627000
000652  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 186
			do seg_idx = first_seg_in_group repeat fsm_info.seg (seg_idx).next_seg_in_group
			     while (seg_idx ^= 0);

000653  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000654  aa  6 00112 2361 00	ldq  	pr6|74		first_seg_in_group
000655  aa  6 00115 7561 00	stq  	pr6|77		seg_idx
000656  aa  6 00115 2361 00	ldq  	pr6|77		seg_idx
000657  aa   000045 6000 04	tze  	37,ic		000724
						STATEMENT 1 ON LINE 188
			     call hcs_$terminate_file (fsm_dir_path, seg_name (seg_idx), 0, status);

000660  aa  6 00115 3521 00	epp2 	pr6|77		seg_idx
000661  aa  6 00216 2521 00	spri2	pr6|142
000662  aa  6 00224 3521 00	epp2 	pr6|148
000663  aa  6 00220 2521 00	spri2	pr6|144
000664  aa  6 00214 6211 00	eax1 	pr6|140
000665  aa   010000 4310 07	fld  	4096,dl
000666  aa   005446 3520 04	epp2 	2854,ic		006334 = 000120627000
000667  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
000670  aa  6 00235 4501 00	stz  	pr6|157
000671  aa  6 00044 3701 20	epp4 	pr6|36,*
000672  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
000673  aa  6 00242 2521 00	spri2	pr6|162
000674  aa  6 00224 3521 00	epp2 	pr6|148
000675  aa  6 00244 2521 00	spri2	pr6|164
000676  aa  6 00235 3521 00	epp2 	pr6|157
000677  aa  6 00246 2521 00	spri2	pr6|166
000700  aa  6 00117 3521 00	epp2 	pr6|79		status
000701  aa  6 00250 2521 00	spri2	pr6|168
000702  aa   777153 3520 04	epp2 	-405,ic		000055 = 526000000250
000703  aa  6 00252 2521 00	spri2	pr6|170
000704  aa   777144 3520 04	epp2 	-412,ic		000050 = 524000000040
000705  aa  6 00254 2521 00	spri2	pr6|172
000706  aa   777140 3520 04	epp2 	-416,ic		000046 = 404000000001
000707  aa  6 00256 2521 00	spri2	pr6|174
000710  aa   777134 3520 04	epp2 	-420,ic		000044 = 404000000043
000711  aa  6 00260 2521 00	spri2	pr6|176
000712  aa  6 00240 6211 00	eax1 	pr6|160
000713  aa   020000 4310 07	fld  	8192,dl
000714  la  4 00144 3521 20	epp2 	pr4|100,*		hcs_$terminate_file
000715  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 189
			end;

000716  aa  6 00115 2361 00	ldq  	pr6|77		seg_idx
000717  aa   000005 4020 07	mpy  	5,dl
000720  aa  6 00044 3701 20	epp4 	pr6|36,*
000721  ia  4 00134 2361 66	ldq  	pr4|92,*ql	fsm_info.next_seg_in_group
000722  aa  6 00115 7561 00	stq  	pr6|77		seg_idx
000723  aa   777733 7100 04	tra  	-37,ic		000656
						STATEMENT 1 ON LINE 190
			try_again = True;

000724  aa   400000 2350 03	lda  	131072,du
000725  aa  6 00120 7551 00	sta  	pr6|80		try_again
						STATEMENT 1 ON LINE 191
		     end;

						STATEMENT 1 ON LINE 192
		prev_seg_in_group = seg_idx;

000726  aa  6 00115 2361 00	ldq  	pr6|77		seg_idx
000727  aa  6 00114 7561 00	stq  	pr6|76		prev_seg_in_group
						STATEMENT 1 ON LINE 193
	     end;

000730  aa  6 00116 0541 00	aos  	pr6|78		seg_num
000731  aa   777465 7100 04	tra  	-203,ic		000416
						STATEMENT 1 ON LINE 194
	end;

000732  aa   777440 7100 04	tra  	-224,ic		000372
						STATEMENT 1 ON LINE 198
	do seg_idx = 1 to fsm_info.seg_cnt;

000733  aa  6 00044 3701 20	epp4 	pr6|36,*
000734  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
000735  aa  7 00001 2361 00	ldq  	pr7|1		fsm_info.seg_cnt
000736  aa  6 00125 7561 00	stq  	pr6|85
000737  aa   000001 2360 07	ldq  	1,dl
000740  aa  6 00115 7561 00	stq  	pr6|77		seg_idx
000741  aa   000000 0110 03	nop  	0,du
000742  aa  6 00115 2361 00	ldq  	pr6|77		seg_idx
000743  aa  6 00125 1161 00	cmpq 	pr6|85
000744  aa   000022 6054 04	tpnz 	18,ic		000766
						STATEMENT 1 ON LINE 199
	     if fsm_info.seg (seg_idx).owning_process = my_process & fsm_info.seg (seg_idx).owner = me
	     then fsm_info.seg (seg_idx).owner = owner;

000745  aa   000005 4020 07	mpy  	5,dl
000746  aa  6 00044 3701 20	epp4 	pr6|36,*
000747  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
000750  aa  7 77775 2351 06	lda  	pr7|-3,ql		fsm_info.owning_process
000751  aa  6 00102 1151 00	cmpa 	pr6|66		my_process
000752  aa  6 00235 7561 00	stq  	pr6|157
000753  aa   000011 6010 04	tnz  	9,ic		000764
000754  aa  6 00100 2371 00	ldaq 	pr6|64		me
000755  aa  0 00560 7001 00	tsx0 	pr0|368		unpk_to_pk
000756  aa  6 00235 7271 00	lxl7 	pr6|157
000757  aa  7 77776 1161 17	cmpq 	pr7|-2,7		fsm_info.owner
000760  aa   000004 6010 04	tnz  	4,ic		000764
000761  aa  6 00122 3715 20	epp5 	pr6|82,*		owner
000762  aa  5 00000 3715 20	epp5 	pr5|0,*		owner
000763  aa  7 77776 5451 17	sprp5	pr7|-2,7		fsm_info.owner
						STATEMENT 1 ON LINE 201
	end;

000764  aa  6 00115 0541 00	aos  	pr6|77		seg_idx
000765  aa   777755 7100 04	tra  	-19,ic		000742
						STATEMENT 1 ON LINE 202
	first_seg_ptr = baseptr (first_seg_num);

000766  aa  6 00113 2361 00	ldq  	pr6|75		first_seg_num
000767  aa  6 00000 3525 00	epbp2	pr6|0
000770  aa   000000 3130 06	easp2	0,ql
000771  aa  6 00032 3735 20	epp7 	pr6|26,*
000772  aa  7 00006 2521 20	spri2	pr7|6,*		first_seg_ptr
						STATEMENT 1 ON LINE 203
	call release_fsm_info;

000773  aa  6 00056 6211 00	eax1 	pr6|46
000774  aa   000000 4310 07	fld  	0,dl
000775  aa   005161 3520 04	epp2 	2673,ic		006156 = 000160627000
000776  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 204
	return;

000777  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO free                                               STATEMENT 1 ON LINE 206
free:
     entry (owner);

001000  at     000001000056
001001  ta     001000000000
001002  da     000532300000
001003  aa   000540 6270 00	eax7 	352
001004  aa  7 00034 3521 20	epp2 	pr7|28,*
001005  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001006  aa     000002000000
001007  aa     000000000000
001010  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
001011  aa  6 00032 3735 20	epp7 	pr6|26,*
001012  aa  7 00002 3715 20	epp5 	pr7|2,*
001013  aa  6 00122 6515 00	spri5	pr6|82
001014  aa   777233 7000 04	tsx0 	-357,ic		000247
						STATEMENT 1 ON LINE 222
	on cleanup call release_fsm_info;

001015  aa   000007 7260 07	lxl6 	7,dl
001016  aa   777060 3520 04	epp2 	-464,ic		000076 = 143154145141
001017  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
001020  aa   000004 7100 04	tra  	4,ic		001024
001021  aa     000104000000
001022  aa   000016 7100 04	tra  	14,ic		001040
BEGIN CONDITION cleanup.2
ENTRY TO cleanup.2                                          STATEMENT 1 ON LINE 222
	on cleanup call release_fsm_info;

001023  da     000540200000
001024  aa   000100 6270 00	eax7 	64
001025  aa  7 00034 3521 20	epp2 	pr7|28,*
001026  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001027  aa     000000000000
001030  aa     000000000000
001031  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
001032  aa   000001 7270 07	lxl7 	1,dl
001033  aa  6 00056 6211 00	eax1 	pr6|46
001034  aa   000000 4310 07	fld  	0,dl
001035  aa   005121 3520 04	epp2 	2641,ic		006156 = 000160627000
001036  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
001037  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.2
						STATEMENT 1 ON LINE 223
	call appropriate_fsm_info;

001040  aa  6 00056 6211 00	eax1 	pr6|46
001041  aa   000000 4310 07	fld  	0,dl
001042  aa   000551 3520 04	epp2 	361,ic		001613 = 001040627000
001043  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 225
	do seg_idx = 1 to fsm_info.seg_cnt;

001044  aa  6 00044 3701 20	epp4 	pr6|36,*
001045  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
001046  aa  7 00001 2361 00	ldq  	pr7|1		fsm_info.seg_cnt
001047  aa  6 00126 7561 00	stq  	pr6|86
001050  aa   000001 2360 07	ldq  	1,dl
001051  aa  6 00115 7561 00	stq  	pr6|77		seg_idx
001052  aa  6 00115 2361 00	ldq  	pr6|77		seg_idx
001053  aa  6 00126 1161 00	cmpq 	pr6|86
001054  aa   000122 6054 04	tpnz 	82,ic		001176
						STATEMENT 1 ON LINE 226
	     if fsm_info.seg (seg_idx).owning_process = my_process & fsm_info.seg (seg_idx).owner = owner
	     then do;

001055  aa   000005 4020 07	mpy  	5,dl
001056  aa  6 00044 3701 20	epp4 	pr6|36,*
001057  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
001060  aa  7 77775 2351 06	lda  	pr7|-3,ql		fsm_info.owning_process
001061  aa  6 00102 1151 00	cmpa 	pr6|66		my_process
001062  aa   000112 6010 04	tnz  	74,ic		001174
001063  aa   000000 6270 06	eax7 	0,ql
001064  aa  6 00122 2371 20	ldaq 	pr6|82,*		owner
001065  aa  0 00560 7001 00	tsx0 	pr0|368		unpk_to_pk
001066  aa  7 77776 1161 17	cmpq 	pr7|-2,7		fsm_info.owner
001067  aa   000105 6010 04	tnz  	69,ic		001174
						STATEMENT 1 ON LINE 228
		     call hcs_$terminate_file (fsm_dir_path, seg_name (seg_idx), 0, status);

001070  aa  6 00115 3521 00	epp2 	pr6|77		seg_idx
001071  aa  6 00226 2521 00	spri2	pr6|150
001072  aa  6 00214 3521 00	epp2 	pr6|140
001073  aa  6 00230 2521 00	spri2	pr6|152
001074  aa  6 00224 6211 00	eax1 	pr6|148
001075  aa   010000 4310 07	fld  	4096,dl
001076  aa   005236 3520 04	epp2 	2718,ic		006334 = 000120627000
001077  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
001100  aa  6 00235 4501 00	stz  	pr6|157
001101  aa  6 00044 3701 20	epp4 	pr6|36,*
001102  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
001103  aa  6 00242 2521 00	spri2	pr6|162
001104  aa  6 00214 3521 00	epp2 	pr6|140
001105  aa  6 00244 2521 00	spri2	pr6|164
001106  aa  6 00235 3521 00	epp2 	pr6|157
001107  aa  6 00246 2521 00	spri2	pr6|166
001110  aa  6 00117 3521 00	epp2 	pr6|79		status
001111  aa  6 00250 2521 00	spri2	pr6|168
001112  aa   776743 3520 04	epp2 	-541,ic		000055 = 526000000250
001113  aa  6 00252 2521 00	spri2	pr6|170
001114  aa   776734 3520 04	epp2 	-548,ic		000050 = 524000000040
001115  aa  6 00254 2521 00	spri2	pr6|172
001116  aa   776730 3520 04	epp2 	-552,ic		000046 = 404000000001
001117  aa  6 00256 2521 00	spri2	pr6|174
001120  aa   776724 3520 04	epp2 	-556,ic		000044 = 404000000043
001121  aa  6 00260 2521 00	spri2	pr6|176
001122  aa  6 00240 6211 00	eax1 	pr6|160
001123  aa   020000 4310 07	fld  	8192,dl
001124  la  4 00144 3521 20	epp2 	pr4|100,*		hcs_$terminate_file
001125  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 229
		     call hcs_$truncate_file (fsm_dir_path, seg_name (seg_idx), 0, status);

001126  aa  6 00115 3521 00	epp2 	pr6|77		seg_idx
001127  aa  6 00216 2521 00	spri2	pr6|142
001130  aa  6 00224 3521 00	epp2 	pr6|148
001131  aa  6 00220 2521 00	spri2	pr6|144
001132  aa  6 00214 6211 00	eax1 	pr6|140
001133  aa   010000 4310 07	fld  	4096,dl
001134  aa   005200 3520 04	epp2 	2688,ic		006334 = 000120627000
001135  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
001136  aa  6 00235 4501 00	stz  	pr6|157
001137  aa  6 00044 3701 20	epp4 	pr6|36,*
001140  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
001141  aa  6 00242 2521 00	spri2	pr6|162
001142  aa  6 00224 3521 00	epp2 	pr6|148
001143  aa  6 00244 2521 00	spri2	pr6|164
001144  aa  6 00235 3521 00	epp2 	pr6|157
001145  aa  6 00246 2521 00	spri2	pr6|166
001146  aa  6 00117 3521 00	epp2 	pr6|79		status
001147  aa  6 00250 2521 00	spri2	pr6|168
001150  aa   776705 3520 04	epp2 	-571,ic		000055 = 526000000250
001151  aa  6 00252 2521 00	spri2	pr6|170
001152  aa   776676 3520 04	epp2 	-578,ic		000050 = 524000000040
001153  aa  6 00254 2521 00	spri2	pr6|172
001154  aa   776667 3520 04	epp2 	-585,ic		000043 = 404000000023
001155  aa  6 00256 2521 00	spri2	pr6|174
001156  aa   776666 3520 04	epp2 	-586,ic		000044 = 404000000043
001157  aa  6 00260 2521 00	spri2	pr6|176
001160  aa  6 00240 6211 00	eax1 	pr6|160
001161  aa   020000 4310 07	fld  	8192,dl
001162  la  4 00150 3521 20	epp2 	pr4|104,*		hcs_$truncate_file
001163  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 230
		     unspec (fsm_info.seg (seg_idx)) = ""b;

001164  aa  6 00115 2361 00	ldq  	pr6|77		seg_idx
001165  aa   000005 4020 07	mpy  	5,dl
001166  aa  6 00044 3701 20	epp4 	pr6|36,*
001167  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
001170  aa  7 77775 3735 06	epp7 	pr7|-3,ql
001171  aa  000 100 100 400	mlr  	(),(pr),fill(000)
001172  aa   000000 00 0000	desc9a	0,0
001173  aa  7 00000 00 0024	desc9a	pr7|0,20
						STATEMENT 1 ON LINE 231
		end;

						STATEMENT 1 ON LINE 232
	end;

001174  aa  6 00115 0541 00	aos  	pr6|77		seg_idx
001175  aa   777655 7100 04	tra  	-83,ic		001052
						STATEMENT 1 ON LINE 233
	call release_fsm_info;

001176  aa  6 00056 6211 00	eax1 	pr6|46
001177  aa   000000 4310 07	fld  	0,dl
001200  aa   004756 3520 04	epp2 	2542,ic		006156 = 000160627000
001201  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 234
	return;

001202  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO get_owner                                          STATEMENT 1 ON LINE 236
get_owner:
     entry (seg_ptr, owner);

001203  at     000002000056
001204  ta     000056000000
001205  ta     001203000000
001206  da     000546300000
001207  aa   000540 6270 00	eax7 	352
001210  aa  7 00034 3521 20	epp2 	pr7|28,*
001211  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001212  aa     000004000000
001213  aa     000000000000
001214  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
001215  aa  6 00032 3735 20	epp7 	pr6|26,*
001216  aa  7 00004 3715 20	epp5 	pr7|4,*
001217  aa  6 00122 6515 00	spri5	pr6|82
001220  aa   777027 7000 04	tsx0 	-489,ic		000247
						STATEMENT 1 ON LINE 250
	on cleanup call release_fsm_info;

001221  aa   000007 7260 07	lxl6 	7,dl
001222  aa   776654 3520 04	epp2 	-596,ic		000076 = 143154145141
001223  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
001224  aa   000004 7100 04	tra  	4,ic		001230
001225  aa     000104000000
001226  aa   000016 7100 04	tra  	14,ic		001244
BEGIN CONDITION cleanup.3
ENTRY TO cleanup.3                                          STATEMENT 1 ON LINE 250
	on cleanup call release_fsm_info;

001227  da     000554200000
001230  aa   000100 6270 00	eax7 	64
001231  aa  7 00034 3521 20	epp2 	pr7|28,*
001232  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001233  aa     000000000000
001234  aa     000000000000
001235  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
001236  aa   000001 7270 07	lxl7 	1,dl
001237  aa  6 00056 6211 00	eax1 	pr6|46
001240  aa   000000 4310 07	fld  	0,dl
001241  aa   004715 3520 04	epp2 	2509,ic		006156 = 000160627000
001242  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
001243  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.3
						STATEMENT 1 ON LINE 251
	call appropriate_fsm_info;

001244  aa  6 00056 6211 00	eax1 	pr6|46
001245  aa   000000 4310 07	fld  	0,dl
001246  aa   000345 3520 04	epp2 	229,ic		001613 = 001040627000
001247  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 252
	do seg_idx = 1 to fsm_info.seg_cnt
	     while (fsm_info.seg (seg_idx).owning_process ^= my_process
	     | fsm_info.seg (seg_idx).seg_num ^= bin (baseno (seg_ptr)));

001250  aa  6 00044 3701 20	epp4 	pr6|36,*
001251  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
001252  aa  7 00001 2361 00	ldq  	pr7|1		fsm_info.seg_cnt
001253  aa  6 00127 7561 00	stq  	pr6|87
001254  aa   000001 2360 07	ldq  	1,dl
001255  aa  6 00115 7561 00	stq  	pr6|77		seg_idx
001256  aa  6 00115 2361 00	ldq  	pr6|77		seg_idx
001257  aa  6 00127 1161 00	cmpq 	pr6|87
001260  aa   000026 6054 04	tpnz 	22,ic		001306
001261  aa   000005 4020 07	mpy  	5,dl
001262  aa  6 00044 3701 20	epp4 	pr6|36,*
001263  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
001264  aa  7 77775 2351 06	lda  	pr7|-3,ql		fsm_info.owning_process
001265  aa  6 00102 1151 00	cmpa 	pr6|66		my_process
001266  aa  6 00235 7561 00	stq  	pr6|157
001267  aa   000015 6010 04	tnz  	13,ic		001304
001270  aa  6 00032 3715 20	epp5 	pr6|26,*
001271  aa  5 00002 3535 20	epp3 	pr5|2,*		seg_ptr
001272  aa  3 00000 3535 20	epp3 	pr3|0,*		seg_ptr
001273  aa  3 00000 2131 00	epaq 	pr3|0		seg_ptr
001274  aa   077777 3750 03	ana  	32767,du
001275  aa   000066 7730 00	lrl  	54
001276  aa  6 00236 7571 00	staq 	pr6|158
001277  aa  6 00235 7271 00	lxl7 	pr6|157
001300  aa  7 00001 2351 17	lda  	pr7|1,7		fsm_info.seg_num
001301  aa   000044 7330 00	lrs  	36
001302  aa  6 00236 1171 00	cmpaq	pr6|158
001303  aa   000003 6000 04	tze  	3,ic		001306
						STATEMENT 1 ON LINE 255
	end;

001304  aa  6 00115 0541 00	aos  	pr6|77		seg_idx
001305  aa   777751 7100 04	tra  	-23,ic		001256
						STATEMENT 1 ON LINE 256
	if seg_idx <= fsm_info.seg_cnt
	then owner = fsm_info.seg (seg_idx).owner;

001306  aa  6 00115 2361 00	ldq  	pr6|77		seg_idx
001307  aa  6 00044 3701 20	epp4 	pr6|36,*
001310  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
001311  aa  7 00001 1161 00	cmpq 	pr7|1		fsm_info.seg_cnt
001312  aa   000005 6054 04	tpnz 	5,ic		001317
001313  aa   000005 4020 07	mpy  	5,dl
001314  aa  7 77776 7651 06	lprp5	pr7|-2,ql		fsm_info.owner
001315  aa  6 00122 6515 20	spri5	pr6|82,*		owner
001316  aa   000003 7100 04	tra  	3,ic		001321
						STATEMENT 1 ON LINE 258
	else owner = null;

001317  aa   776555 2370 04	ldaq 	-659,ic		000074 = 077777000043 000001000000
001320  aa  6 00122 7571 20	staq 	pr6|82,*		owner
						STATEMENT 1 ON LINE 259
	call release_fsm_info;

001321  aa  6 00056 6211 00	eax1 	pr6|46
001322  aa   000000 4310 07	fld  	0,dl
001323  aa   004633 3520 04	epp2 	2459,ic		006156 = 000160627000
001324  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 260
	return;

001325  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO get_vla_segnos                                     STATEMENT 1 ON LINE 262
get_vla_segnos:
     entry (segment_map_bits);

001326  at     000001000133
001327  ta     001326000000
001330  da     000563300000
001331  aa   000540 6270 00	eax7 	352
001332  aa  7 00034 3521 20	epp2 	pr7|28,*
001333  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
001334  aa     000002000000
001335  aa     000000000000
001336  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
001337  aa   776710 7000 04	tsx0 	-568,ic		000247
						STATEMENT 1 ON LINE 276
	on cleanup call release_fsm_info;

001340  aa   000007 7260 07	lxl6 	7,dl
001341  aa   776535 3520 04	epp2 	-675,ic		000076 = 143154145141
001342  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
001343  aa   000004 7100 04	tra  	4,ic		001347
001344  aa     000104000000
001345  aa   000016 7100 04	tra  	14,ic		001363
BEGIN CONDITION cleanup.4
ENTRY TO cleanup.4                                          STATEMENT 1 ON LINE 276
	on cleanup call release_fsm_info;

001346  da     000571200000
001347  aa   000100 6270 00	eax7 	64
001350  aa  7 00034 3521 20	epp2 	pr7|28,*
001351  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001352  aa     000000000000
001353  aa     000000000000
001354  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
001355  aa   000001 7270 07	lxl7 	1,dl
001356  aa  6 00056 6211 00	eax1 	pr6|46
001357  aa   000000 4310 07	fld  	0,dl
001360  aa   004576 3520 04	epp2 	2430,ic		006156 = 000160627000
001361  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
001362  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.4
						STATEMENT 1 ON LINE 277
	call appropriate_fsm_info;

001363  aa  6 00056 6211 00	eax1 	pr6|46
001364  aa   000000 4310 07	fld  	0,dl
001365  aa   000226 3520 04	epp2 	150,ic		001613 = 001040627000
001366  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 281
	do seg_idx = 1 to fsm_info.seg_cnt;

001367  aa  6 00044 3701 20	epp4 	pr6|36,*
001370  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
001371  aa  7 00001 2361 00	ldq  	pr7|1		fsm_info.seg_cnt
001372  aa  6 00130 7561 00	stq  	pr6|88
001373  aa   000001 2360 07	ldq  	1,dl
001374  aa  6 00115 7561 00	stq  	pr6|77		seg_idx
001375  aa   000000 0110 03	nop  	0,du
001376  aa  6 00115 2361 00	ldq  	pr6|77		seg_idx
001377  aa  6 00130 1161 00	cmpq 	pr6|88
001400  aa   000026 6054 04	tpnz 	22,ic		001426
						STATEMENT 1 ON LINE 282
	     if fsm_info.owning_process (seg_idx) = my_process
	     then segment_map_bits (seg_idx) = "1"b;

001401  aa   000005 4020 07	mpy  	5,dl
001402  aa  6 00044 3701 20	epp4 	pr6|36,*
001403  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
001404  aa  7 77775 2351 06	lda  	pr7|-3,ql		fsm_info.owning_process
001405  aa  6 00102 1151 00	cmpa 	pr6|66		my_process
001406  aa   000016 6010 04	tnz  	14,ic		001424
001407  aa  6 00042 3715 20	epp5 	pr6|34,*
001410  aa  5 00000 3535 20	epp3 	pr5|0,*
001411  aa  3 00003 2361 00	ldq  	pr3|3
001412  aa  3 00001 4021 00	mpy  	pr3|1
001413  aa  6 00235 7561 00	stq  	pr6|157
001414  aa  3 00003 2361 00	ldq  	pr3|3
001415  aa  6 00115 4021 00	mpy  	pr6|77		seg_idx
001416  aa  6 00235 1761 00	sbq  	pr6|157
001417  aa  6 00032 3515 20	epp1 	pr6|26,*
001420  aa  1 00002 3535 20	epp3 	pr1|2,*
001421  aa  403 106 060 400	csl  	(),(pr,ql),fill(1),bool(move)
001422  aa   000000 00 0000	descb	0,0
001423  aa  3 00000 00 0001	descb	pr3|0,1		segment_map_bits
						STATEMENT 1 ON LINE 284
	end;

001424  aa  6 00115 0541 00	aos  	pr6|77		seg_idx
001425  aa   777751 7100 04	tra  	-23,ic		001376
						STATEMENT 1 ON LINE 285
	call release_fsm_info;

001426  aa  6 00056 6211 00	eax1 	pr6|46
001427  aa   000000 4310 07	fld  	0,dl
001430  aa   004526 3520 04	epp2 	2390,ic		006156 = 000160627000
001431  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 286
	return;

001432  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO lfs                                                STATEMENT 1 ON LINE 288
list_fortran_storage:
lfs:
     entry;

001433  da     000575200000
001434  aa   000540 6270 00	eax7 	352
001435  aa  7 00034 3521 20	epp2 	pr7|28,*
001436  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001437  aa     000000000000
001440  aa     000000000000
001441  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
001442  aa   776605 7000 04	tsx0 	-635,ic		000247
001443  aa   000011 7100 04	tra  	9,ic		001454
ENTRY TO list_fortran_storage                               STATEMENT 1 ON LINE 288
list_fortran_storage:
lfs:
     entry;

001444  da     000606200000
001445  aa   000540 6270 00	eax7 	352
001446  aa  7 00034 3521 20	epp2 	pr7|28,*
001447  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001450  aa     000000000000
001451  aa     000000000000
001452  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
001453  aa   776574 7000 04	tsx0 	-644,ic		000247
						STATEMENT 1 ON LINE 300
	on cleanup call release_fsm_info;

001454  aa   000007 7260 07	lxl6 	7,dl
001455  aa   776421 3520 04	epp2 	-751,ic		000076 = 143154145141
001456  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
001457  aa   000004 7100 04	tra  	4,ic		001463
001460  aa     000104000000
001461  aa   000016 7100 04	tra  	14,ic		001477
BEGIN CONDITION cleanup.5
ENTRY TO cleanup.5                                          STATEMENT 1 ON LINE 300
	on cleanup call release_fsm_info;

001462  da     000614200000
001463  aa   000100 6270 00	eax7 	64
001464  aa  7 00034 3521 20	epp2 	pr7|28,*
001465  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001466  aa     000000000000
001467  aa     000000000000
001470  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
001471  aa   000001 7270 07	lxl7 	1,dl
001472  aa  6 00056 6211 00	eax1 	pr6|46
001473  aa   000000 4310 07	fld  	0,dl
001474  aa   004462 3520 04	epp2 	2354,ic		006156 = 000160627000
001475  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
001476  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.5
						STATEMENT 1 ON LINE 301
	call appropriate_fsm_info;

001477  aa  6 00056 6211 00	eax1 	pr6|46
001500  aa   000000 4310 07	fld  	0,dl
001501  aa   000112 3520 04	epp2 	74,ic		001613 = 001040627000
001502  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 306
	group_cnt = 0;

001503  aa  6 00121 4501 00	stz  	pr6|81		group_cnt
						STATEMENT 1 ON LINE 307
	do seg_idx = 1 to fsm_info.seg_cnt;

001504  aa  6 00044 3701 20	epp4 	pr6|36,*
001505  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
001506  aa  7 00001 2361 00	ldq  	pr7|1		fsm_info.seg_cnt
001507  aa  6 00131 7561 00	stq  	pr6|89
001510  aa   000001 2360 07	ldq  	1,dl
001511  aa  6 00115 7561 00	stq  	pr6|77		seg_idx
001512  aa  6 00115 2361 00	ldq  	pr6|77		seg_idx
001513  aa  6 00131 1161 00	cmpq 	pr6|89
001514  aa   000016 6054 04	tpnz 	14,ic		001532
						STATEMENT 1 ON LINE 308
	     if fsm_info.owning_process (seg_idx) = my_process & fsm_info.first_seg_in_group (seg_idx) = seg_idx
	     then group_cnt = group_cnt + 1;

001515  aa   000005 4020 07	mpy  	5,dl
001516  aa  6 00044 3701 20	epp4 	pr6|36,*
001517  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
001520  aa  7 77775 2351 06	lda  	pr7|-3,ql		fsm_info.owning_process
001521  aa  6 00102 1151 00	cmpa 	pr6|66		my_process
001522  aa  6 00235 7561 00	stq  	pr6|157
001523  aa   000005 6010 04	tnz  	5,ic		001530
001524  aa  7 77777 2361 06	ldq  	pr7|-1,ql		fsm_info.first_seg_in_group
001525  aa  6 00115 1161 00	cmpq 	pr6|77		seg_idx
001526  aa   000002 6010 04	tnz  	2,ic		001530
001527  aa  6 00121 0541 00	aos  	pr6|81		group_cnt
						STATEMENT 1 ON LINE 310
	end;

001530  aa  6 00115 0541 00	aos  	pr6|77		seg_idx
001531  aa   777761 7100 04	tra  	-15,ic		001512
						STATEMENT 1 ON LINE 315
	if group_cnt = 0
	then call ioa_ ("No segments in ^a allocated to this process.", fsm_dir_path);

001532  aa  6 00121 2361 00	ldq  	pr6|81		group_cnt
001533  aa   000022 6010 04	tnz  	18,ic		001555
001534  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001535  aa   776464 00 0054	desc9a	-716,44		000220 = 116157040163
001536  aa  6 00240 00 0054	desc9a	pr6|160,44
001537  aa  6 00240 3521 00	epp2 	pr6|160
001540  aa  6 00300 2521 00	spri2	pr6|192
001541  aa  6 00044 3701 20	epp4 	pr6|36,*
001542  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
001543  aa  6 00302 2521 00	spri2	pr6|194
001544  aa   776276 3520 04	epp2 	-834,ic		000042 = 524000000054
001545  aa  6 00304 2521 00	spri2	pr6|196
001546  aa   776307 3520 04	epp2 	-825,ic		000055 = 526000000250
001547  aa  6 00306 2521 00	spri2	pr6|198
001550  aa  6 00276 6211 00	eax1 	pr6|190
001551  aa   010000 4310 07	fld  	4096,dl
001552  la  4 00152 3521 20	epp2 	pr4|106,*		ioa_
001553  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
001554  aa   000031 7100 04	tra  	25,ic		001605
						STATEMENT 1 ON LINE 317
	else do;

						STATEMENT 1 ON LINE 318
		call ioa_ ("Segments in ^a allocated to this process:", fsm_dir_path);

001555  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001556  aa   776430 00 0054	desc9a	-744,44		000205 = 123145147155
001557  aa  6 00240 00 0054	desc9a	pr6|160,44
001560  aa  6 00240 3521 00	epp2 	pr6|160
001561  aa  6 00300 2521 00	spri2	pr6|192
001562  aa  6 00044 3701 20	epp4 	pr6|36,*
001563  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
001564  aa  6 00302 2521 00	spri2	pr6|194
001565  aa   776254 3520 04	epp2 	-852,ic		000041 = 524000000051
001566  aa  6 00304 2521 00	spri2	pr6|196
001567  aa   776266 3520 04	epp2 	-842,ic		000055 = 526000000250
001570  aa  6 00306 2521 00	spri2	pr6|198
001571  aa  6 00276 6211 00	eax1 	pr6|190
001572  aa   010000 4310 07	fld  	4096,dl
001573  la  4 00152 3521 20	epp2 	pr4|106,*		ioa_
001574  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 319
		call list_groups (group_cnt, my_process);

001575  aa  6 00121 3521 00	epp2 	pr6|81		group_cnt
001576  aa  6 00216 2521 00	spri2	pr6|142
001577  aa  6 00102 3521 00	epp2 	pr6|66		my_process
001600  aa  6 00220 2521 00	spri2	pr6|144
001601  aa  6 00214 6211 00	eax1 	pr6|140
001602  aa   010000 4310 07	fld  	4096,dl
001603  aa   003044 3520 04	epp2 	1572,ic		004647 = 000300627000
001604  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 320
	     end;

						STATEMENT 1 ON LINE 321
	call release_fsm_info;

001605  aa  6 00056 6211 00	eax1 	pr6|46
001606  aa   000000 4310 07	fld  	0,dl
001607  aa   004347 3520 04	epp2 	2279,ic		006156 = 000160627000
001610  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 322
	return;

001611  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1171
     end fortran_storage_manager_;

BEGIN PROCEDURE appropriate_fsm_info
ENTRY TO appropriate_fsm_info                               STATEMENT 1 ON LINE 324
appropriate_fsm_info:
     proc;

001612  da     000625200000
001613  aa   001040 6270 00	eax7 	544
001614  aa  7 00034 3521 20	epp2 	pr7|28,*
001615  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001616  aa     000000000000
001617  aa     000000000000
001620  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
						STATEMENT 1 ON LINE 393
001621  aa   776253 2370 04	ldaq 	-853,ic		000074 = 077777000043 000001000000
001622  aa  6 00222 7571 00	staq 	pr6|146		system_free_area_ptr
						STATEMENT 1 ON LINE 420
	if ^fsm_info_ptr_valid
	then do;

001623  ia  4 00136 2351 00	lda  	pr4|94		fsm_info_ptr_valid
001624  aa   000757 6010 04	tnz  	495,ic		002603
						STATEMENT 1 ON LINE 422
		if pl1_operators_$VLA_words_per_seg_ > sys_info$max_seg_size
		then do;

001625  la  4 00214 2361 20	ldq  	pr4|140,*		pl1_operators_$VLA_words_per_seg_
001626  la  4 00220 1161 20	cmpq 	pr4|144,*		sys_info$max_seg_size
001627  aa   000041 6044 04	tmoz 	33,ic		001670
						STATEMENT 1 ON LINE 424
			call hcs_$set_256K_switch ("11"b, (""b), status);

001630  aa   600000 2350 03	lda  	196608,du
001631  aa  6 00251 7551 00	sta  	pr6|169
001632  aa   000000 2350 07	lda  	0,dl
001633  aa  6 00252 7551 00	sta  	pr6|170
001634  aa  6 00251 3521 00	epp2 	pr6|169
001635  aa  6 00256 2521 00	spri2	pr6|174
001636  aa  6 00252 3521 00	epp2 	pr6|170
001637  aa  6 00260 2521 00	spri2	pr6|176
001640  aa  6 00220 3521 00	epp2 	pr6|144		status
001641  aa  6 00262 2521 00	spri2	pr6|178
001642  aa  6 00254 6211 00	eax1 	pr6|172
001643  aa   014000 4310 07	fld  	6144,dl
001644  la  4 00206 3521 20	epp2 	pr4|134,*		hcs_$set_256K_switch
001645  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 425
			if status ^= 0
			then call signal_fsm_error (status, "Cannot set 256K switch");

001646  aa  6 00220 2361 00	ldq  	pr6|144		status
001647  aa   000021 6000 04	tze  	17,ic		001670
001650  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001651  aa   776301 00 0030	desc9a	-831,24		000151 = 103141156156
001652  aa  6 00254 00 0030	desc9a	pr6|172,24
001653  aa  6 00220 3521 00	epp2 	pr6|144		status
001654  aa  6 00266 2521 00	spri2	pr6|182
001655  aa  6 00254 3521 00	epp2 	pr6|172
001656  aa  6 00270 2521 00	spri2	pr6|184
001657  aa   776165 3520 04	epp2 	-907,ic		000044 = 404000000043
001660  aa  6 00274 2521 00	spri2	pr6|188
001661  aa   776156 3520 04	epp2 	-914,ic		000037 = 524000000026
001662  aa  6 00276 2521 00	spri2	pr6|190
001663  aa   000001 7270 07	lxl7 	1,dl
001664  aa  6 00264 6211 00	eax1 	pr6|180
001665  aa   010000 4310 07	fld  	4096,dl
001666  aa   004562 3520 04	epp2 	2418,ic		006450 = 000260627000
001667  aa  0 00626 7001 00	tsx0 	pr0|406		call_int_other_desc
						STATEMENT 1 ON LINE 427
		     end;

						STATEMENT 1 ON LINE 428
		fsm_info_ptr = null;

001670  aa   776204 2370 04	ldaq 	-892,ic		000074 = 077777000043 000001000000
001671  aa  6 00044 3701 20	epp4 	pr6|36,*
001672  ia  4 00134 7571 00	staq 	pr4|92		fsm_info_ptr
						STATEMENT 1 ON LINE 429
		fsm_dir_name = fsm_dir_name_master || ltrim (char (get_ring_ ()));

001673  aa  6 00252 3521 00	epp2 	pr6|170
001674  aa  6 00256 2521 00	spri2	pr6|174
001675  aa  6 00254 6211 00	eax1 	pr6|172
001676  aa   004000 4310 07	fld  	2048,dl
001677  la  4 00222 3521 20	epp2 	pr4|146,*		get_ring_
001700  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
001701  aa  000 100 301 500	btd  	(pr),(pr)
001702  aa  6 00252 00 0004	desc9a	pr6|170,4
001703  aa  6 00251 01 0003	desc9ls	pr6|169,3,0
001704  aa  6 00301 4501 00	stz  	pr6|193
001705  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
001706  aa  6 00251 01 0003	desc9ls	pr6|169,3,0
001707  aa   005071 00 0006	desc9a	2617,6		006776 = 403040022141
001710  aa  6 00300 00 0005	desc9a	pr6|192,5
001711  aa  000 000 164 500	tct  	(pr)
001712  aa  6 00300 00 0005	desc9a	pr6|192,5
001713  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
001714  aa  6 00056 0001 00	arg  	pr6|46
001715  aa  6 00056 2361 00	ldq  	pr6|46
001716  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
001717  aa  6 00251 7561 00	stq  	pr6|169
001720  aa   000005 2360 07	ldq  	5,dl
001721  aa  6 00251 1761 00	sbq  	pr6|169
001722  aa  6 00252 7561 00	stq  	pr6|170
001723  aa   000010 0760 07	adq  	8,dl
001724  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
001725  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
001726  aa   776061 00 0010	desc9a	-975,8		000006 = 146163155137
001727  aa  2 00000 00 0010	desc9a	pr2|0,8
001730  aa  6 00251 2351 00	lda  	pr6|169
001731  aa  6 00253 7561 00	stq  	pr6|171
001732  aa  6 00252 2361 00	ldq  	pr6|170
001733  aa  040 140 100 545	mlr  	(pr,rl,al),(pr,rl),fill(040)
001734  aa  6 00300 00 0006	desc9a	pr6|192,ql
001735  aa  2 00002 00 0006	desc9a	pr2|2,ql
001736  aa  6 00253 2351 00	lda  	pr6|171
001737  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
001740  aa  2 00000 00 0005	desc9a	pr2|0,al
001741  aa  6 00174 00 0040	desc9a	pr6|124,32	fsm_dir_name
						STATEMENT 1 ON LINE 430
		do while (fsm_info_ptr = null);

001742  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
001743  aa   000000 0110 03	nop  	0,du
001744  aa  6 00044 3701 20	epp4 	pr6|36,*
001745  ia  4 00134 2371 00	ldaq 	pr4|92		fsm_info_ptr
001746  aa   776126 6770 04	eraq 	-938,ic		000074 = 077777000043 000001000000
001747  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001750  aa   000633 6010 04	tnz  	411,ic		002603
						STATEMENT 1 ON LINE 431
		     call get_fsm_dir_dir_path (fsm_dir_dir_path);

001751  aa   005017 3520 04	epp2 	2575,ic		006770 = 000002000000
001752  aa  2 00000 2351 00	lda  	pr2|0
001753  aa   002504 6700 04	tsp4 	1348,ic		004457
						STATEMENT 1 ON LINE 432
		     fsm_dir_path = pathname_ (fsm_dir_dir_path, fsm_dir_name);

001754  aa  6 00122 3521 00	epp2 	pr6|82		fsm_dir_dir_path
001755  aa  6 00304 2521 00	spri2	pr6|196
001756  aa  6 00174 3521 00	epp2 	pr6|124		fsm_dir_name
001757  aa  6 00306 2521 00	spri2	pr6|198
001760  aa  6 00044 3701 20	epp4 	pr6|36,*
001761  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
001762  aa  6 00310 2521 00	spri2	pr6|200
001763  aa   776072 3520 04	epp2 	-966,ic		000055 = 526000000250
001764  aa  6 00312 2521 00	spri2	pr6|202
001765  aa  6 00316 2521 00	spri2	pr6|206
001766  aa   776064 3520 04	epp2 	-972,ic		000052 = 526000000040
001767  aa  6 00314 2521 00	spri2	pr6|204
001770  aa  6 00302 6211 00	eax1 	pr6|194
001771  aa   014000 4310 07	fld  	6144,dl
001772  la  4 00146 3521 20	epp2 	pr4|102,*		pathname_
001773  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 433
		     fsm_info_path = pathname_ (fsm_dir_path, fsm_info_name);

001774  aa  6 00044 3701 20	epp4 	pr6|36,*
001775  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
001776  aa  6 00304 2521 00	spri2	pr6|196
001777  aa   776003 3520 04	epp2 	-1021,ic		000002 = 146163155137
002000  aa  6 00306 2521 00	spri2	pr6|198
002001  ia  4 00062 3521 00	epp2 	pr4|50		fsm_info_path
002002  aa  6 00310 2521 00	spri2	pr6|200
002003  aa   776052 3520 04	epp2 	-982,ic		000055 = 526000000250
002004  aa  6 00312 2521 00	spri2	pr6|202
002005  aa  6 00316 2521 00	spri2	pr6|206
002006  aa   776030 3520 04	epp2 	-1000,ic		000036 = 526000000015
002007  aa  6 00314 2521 00	spri2	pr6|204
002010  aa  6 00302 6211 00	eax1 	pr6|194
002011  aa   014000 4310 07	fld  	6144,dl
002012  la  4 00146 3521 20	epp2 	pr4|102,*		pathname_
002013  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 434
		     call hcs_$status_minf (fsm_dir_dir_path, fsm_dir_name, Chase_links, type, bit_count, status);

002014  aa  6 00122 3521 00	epp2 	pr6|82		fsm_dir_dir_path
002015  aa  6 00322 2521 00	spri2	pr6|210
002016  aa  6 00174 3521 00	epp2 	pr6|124		fsm_dir_name
002017  aa  6 00324 2521 00	spri2	pr6|212
002020  aa   776042 3520 04	epp2 	-990,ic		000062 = 000000000001
002021  aa  6 00326 2521 00	spri2	pr6|214
002022  aa  6 00224 3521 00	epp2 	pr6|148		type
002023  aa  6 00330 2521 00	spri2	pr6|216
002024  aa  6 00121 3521 00	epp2 	pr6|81		bit_count
002025  aa  6 00332 2521 00	spri2	pr6|218
002026  aa  6 00220 3521 00	epp2 	pr6|144		status
002027  aa  6 00334 2521 00	spri2	pr6|220
002030  aa   776025 3520 04	epp2 	-1003,ic		000055 = 526000000250
002031  aa  6 00336 2521 00	spri2	pr6|222
002032  aa   776020 3520 04	epp2 	-1008,ic		000052 = 526000000040
002033  aa  6 00340 2521 00	spri2	pr6|224
002034  aa   776012 3520 04	epp2 	-1014,ic		000046 = 404000000001
002035  aa  6 00342 2521 00	spri2	pr6|226
002036  aa   776007 3520 04	epp2 	-1017,ic		000045 = 404000000002
002037  aa  6 00344 2521 00	spri2	pr6|228
002040  aa   775775 3520 04	epp2 	-1027,ic		000035 = 404000000030
002041  aa  6 00346 2521 00	spri2	pr6|230
002042  aa   776002 3520 04	epp2 	-1022,ic		000044 = 404000000043
002043  aa  6 00350 2521 00	spri2	pr6|232
002044  aa  6 00320 6211 00	eax1 	pr6|208
002045  aa   030000 4310 07	fld  	12288,dl
002046  aa  6 00044 3701 20	epp4 	pr6|36,*
002047  la  4 00212 3521 20	epp2 	pr4|138,*		hcs_$status_minf
002050  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 435
		     if status = 0
		     then if type = star_DIRECTORY & bit_count = 0
			then do;

002051  aa  6 00220 2361 00	ldq  	pr6|144		status
002052  aa   000227 6010 04	tnz  	151,ic		002301
002053  aa  6 00224 2361 00	ldq  	pr6|148		type
002054  aa   000002 1160 07	cmpq 	2,dl
002055  aa   000205 6010 04	tnz  	133,ic		002262
002056  aa  6 00121 2361 00	ldq  	pr6|81		bit_count
002057  aa   000203 6010 04	tnz  	131,ic		002262
						STATEMENT 1 ON LINE 438
				call hcs_$make_seg (fsm_dir_path, fsm_info_name, "", RW_ACCESS_BIN, fsm_info_ptr,
				     status);

002060  aa  6 00044 3701 20	epp4 	pr6|36,*
002061  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
002062  aa  6 00322 2521 00	spri2	pr6|210
002063  aa   775717 3520 04	epp2 	-1073,ic		000002 = 146163155137
002064  aa  6 00324 2521 00	spri2	pr6|212
002065  aa  6 00253 3521 00	epp2 	pr6|171
002066  aa  6 00326 2521 00	spri2	pr6|214
002067  aa   775725 3520 04	epp2 	-1067,ic		000014 = 000000000012
002070  aa  6 00330 2521 00	spri2	pr6|216
002071  ia  4 00134 3521 00	epp2 	pr4|92		fsm_info_ptr
002072  aa  6 00332 2521 00	spri2	pr6|218
002073  aa  6 00220 3521 00	epp2 	pr6|144		status
002074  aa  6 00334 2521 00	spri2	pr6|220
002075  aa   775760 3520 04	epp2 	-1040,ic		000055 = 526000000250
002076  aa  6 00336 2521 00	spri2	pr6|222
002077  aa   775737 3520 04	epp2 	-1057,ic		000036 = 526000000015
002100  aa  6 00340 2521 00	spri2	pr6|224
002101  aa   775746 3520 04	epp2 	-1050,ic		000047 = 524000000000
002102  aa  6 00342 2521 00	spri2	pr6|226
002103  aa   775731 3520 04	epp2 	-1063,ic		000034 = 404000000005
002104  aa  6 00344 2521 00	spri2	pr6|228
002105  aa   775751 3520 04	epp2 	-1047,ic		000056 = 464000000000
002106  aa  6 00346 2521 00	spri2	pr6|230
002107  aa   775735 3520 04	epp2 	-1059,ic		000044 = 404000000043
002110  aa  6 00350 2521 00	spri2	pr6|232
002111  aa  6 00320 6211 00	eax1 	pr6|208
002112  aa   030000 4310 07	fld  	12288,dl
002113  la  4 00202 3521 20	epp2 	pr4|130,*		hcs_$make_seg
002114  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 440
				if status = error_table_$moderr
				then do;

002115  aa  6 00220 2361 00	ldq  	pr6|144		status
002116  aa  6 00044 3701 20	epp4 	pr6|36,*
002117  la  4 00160 1161 20	cmpq 	pr4|112,*		error_table_$moderr
002120  aa   000117 6010 04	tnz  	79,ic		002237
						STATEMENT 1 ON LINE 442
					acl.access_name = get_group_id_$tag_star ();

002121  aa  6 00254 3521 00	epp2 	pr6|172
002122  aa  6 00266 2521 00	spri2	pr6|182
002123  aa  6 00264 6211 00	eax1 	pr6|180
002124  aa   004000 4310 07	fld  	2048,dl
002125  la  4 00172 3521 20	epp2 	pr4|122,*		get_group_id_$tag_star
002126  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
002127  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002130  aa  6 00254 00 0040	desc9a	pr6|172,32
002131  aa  6 00106 00 0040	desc9a	pr6|70,32		acl.access_name
						STATEMENT 1 ON LINE 443
					acl.modes = RW_ACCESS;

002132  aa   500000 2350 03	lda  	163840,du
002133  aa  6 00116 7551 00	sta  	pr6|78		acl.modes
						STATEMENT 1 ON LINE 444
					acl.xmodes = ""b;

002134  aa  6 00117 4501 00	stz  	pr6|79		acl.xmodes
						STATEMENT 1 ON LINE 445
					call hcs_$add_acl_entries (fsm_dir_path, fsm_info_name, addr (acl), 1,
					     status);

002135  aa  6 00106 3735 00	epp7 	pr6|70		acl
002136  aa  6 00300 6535 00	spri7	pr6|192
002137  aa   000001 2360 07	ldq  	1,dl
002140  aa  6 00253 7561 00	stq  	pr6|171
002141  aa  6 00044 3701 20	epp4 	pr6|36,*
002142  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
002143  aa  6 00322 2521 00	spri2	pr6|210
002144  aa   775636 3520 04	epp2 	-1122,ic		000002 = 146163155137
002145  aa  6 00324 2521 00	spri2	pr6|212
002146  aa  6 00300 3521 00	epp2 	pr6|192
002147  aa  6 00326 2521 00	spri2	pr6|214
002150  aa  6 00253 3521 00	epp2 	pr6|171
002151  aa  6 00330 2521 00	spri2	pr6|216
002152  aa  6 00220 3521 00	epp2 	pr6|144		status
002153  aa  6 00332 2521 00	spri2	pr6|218
002154  aa   775701 3520 04	epp2 	-1087,ic		000055 = 526000000250
002155  aa  6 00334 2521 00	spri2	pr6|220
002156  aa   775660 3520 04	epp2 	-1104,ic		000036 = 526000000015
002157  aa  6 00336 2521 00	spri2	pr6|222
002160  aa   775676 3520 04	epp2 	-1090,ic		000056 = 464000000000
002161  aa  6 00340 2521 00	spri2	pr6|224
002162  aa   775675 3520 04	epp2 	-1091,ic		000057 = 404000000021
002163  aa  6 00342 2521 00	spri2	pr6|226
002164  aa   775660 3520 04	epp2 	-1104,ic		000044 = 404000000043
002165  aa  6 00344 2521 00	spri2	pr6|228
002166  aa  6 00320 6211 00	eax1 	pr6|208
002167  aa   024000 4310 07	fld  	10240,dl
002170  la  4 00176 3521 20	epp2 	pr4|126,*		hcs_$add_acl_entries
002171  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 447
					if status = 0
					then call hcs_$initiate (fsm_dir_path, fsm_info_name, "", 0, 0,
						fsm_info_ptr, status);

002172  aa  6 00220 2361 00	ldq  	pr6|144		status
002173  aa   000044 6010 04	tnz  	36,ic		002237
002174  aa  6 00251 4501 00	stz  	pr6|169
002175  aa  6 00252 4501 00	stz  	pr6|170
002176  aa  6 00044 3701 20	epp4 	pr6|36,*
002177  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
002200  aa  6 00354 2521 00	spri2	pr6|236
002201  aa   775601 3520 04	epp2 	-1151,ic		000002 = 146163155137
002202  aa  6 00356 2521 00	spri2	pr6|238
002203  aa  6 00253 3521 00	epp2 	pr6|171
002204  aa  6 00360 2521 00	spri2	pr6|240
002205  aa  6 00251 3521 00	epp2 	pr6|169
002206  aa  6 00362 2521 00	spri2	pr6|242
002207  aa  6 00252 3521 00	epp2 	pr6|170
002210  aa  6 00364 2521 00	spri2	pr6|244
002211  ia  4 00134 3521 00	epp2 	pr4|92		fsm_info_ptr
002212  aa  6 00366 2521 00	spri2	pr6|246
002213  aa  6 00220 3521 00	epp2 	pr6|144		status
002214  aa  6 00370 2521 00	spri2	pr6|248
002215  aa   775640 3520 04	epp2 	-1120,ic		000055 = 526000000250
002216  aa  6 00372 2521 00	spri2	pr6|250
002217  aa   775617 3520 04	epp2 	-1137,ic		000036 = 526000000015
002220  aa  6 00374 2521 00	spri2	pr6|252
002221  aa   775626 3520 04	epp2 	-1130,ic		000047 = 524000000000
002222  aa  6 00376 2521 00	spri2	pr6|254
002223  aa   775623 3520 04	epp2 	-1133,ic		000046 = 404000000001
002224  aa  6 00400 2521 00	spri2	pr6|256
002225  aa   775620 3520 04	epp2 	-1136,ic		000045 = 404000000002
002226  aa  6 00402 2521 00	spri2	pr6|258
002227  aa   775627 3520 04	epp2 	-1129,ic		000056 = 464000000000
002230  aa  6 00404 2521 00	spri2	pr6|260
002231  aa   775613 3520 04	epp2 	-1141,ic		000044 = 404000000043
002232  aa  6 00406 2521 00	spri2	pr6|262
002233  aa  6 00352 6211 00	eax1 	pr6|234
002234  aa   034000 4310 07	fld  	14336,dl
002235  la  4 00142 3521 20	epp2 	pr4|98,*		hcs_$initiate
002236  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 450
				     end;

						STATEMENT 1 ON LINE 451
				if fsm_info_ptr = null
				then call signal_fsm_error (status, fsm_info_path);

002237  aa  6 00044 3701 20	epp4 	pr6|36,*
002240  ia  4 00134 2371 00	ldaq 	pr4|92		fsm_info_ptr
002241  aa   775633 6770 04	eraq 	-1125,ic		000074 = 077777000043 000001000000
002242  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002243  aa   777501 6010 04	tnz  	-191,ic		001744
002244  aa  6 00220 3521 00	epp2 	pr6|144		status
002245  aa  6 00266 2521 00	spri2	pr6|182
002246  ia  4 00062 3521 00	epp2 	pr4|50		fsm_info_path
002247  aa  6 00270 2521 00	spri2	pr6|184
002250  aa   775574 3520 04	epp2 	-1156,ic		000044 = 404000000043
002251  aa  6 00274 2521 00	spri2	pr6|188
002252  aa   775603 3520 04	epp2 	-1149,ic		000055 = 526000000250
002253  aa  6 00276 2521 00	spri2	pr6|190
002254  aa   000001 7270 07	lxl7 	1,dl
002255  aa  6 00264 6211 00	eax1 	pr6|180
002256  aa   010000 4310 07	fld  	4096,dl
002257  aa   004171 3520 04	epp2 	2169,ic		006450 = 000260627000
002260  aa  0 00626 7001 00	tsx0 	pr0|406		call_int_other_desc
						STATEMENT 1 ON LINE 453
			     end;

002261  aa   777463 7100 04	tra  	-205,ic		001744
						STATEMENT 1 ON LINE 454
			else call signal_fsm_error (error_table_$notadir, fsm_dir_path);

002262  aa  6 00044 3701 20	epp4 	pr6|36,*
002263  la  4 00164 3521 20	epp2 	pr4|116,*		error_table_$notadir
002264  aa  6 00266 2521 00	spri2	pr6|182
002265  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
002266  aa  6 00270 2521 00	spri2	pr6|184
002267  aa   775555 3520 04	epp2 	-1171,ic		000044 = 404000000043
002270  aa  6 00274 2521 00	spri2	pr6|188
002271  aa   775564 3520 04	epp2 	-1164,ic		000055 = 526000000250
002272  aa  6 00276 2521 00	spri2	pr6|190
002273  aa   000001 7270 07	lxl7 	1,dl
002274  aa  6 00264 6211 00	eax1 	pr6|180
002275  aa   010000 4310 07	fld  	4096,dl
002276  aa   004152 3520 04	epp2 	2154,ic		006450 = 000260627000
002277  aa  0 00626 7001 00	tsx0 	pr0|406		call_int_other_desc
002300  aa   777444 7100 04	tra  	-220,ic		001744
						STATEMENT 1 ON LINE 455
		     else if status = error_table_$noentry
		     then do;

002301  aa  6 00044 3701 20	epp4 	pr6|36,*
002302  la  4 00162 1161 20	cmpq 	pr4|114,*		error_table_$noentry
002303  aa   000262 6010 04	tnz  	178,ic		002565
						STATEMENT 1 ON LINE 457
			     call hcs_$append_branchx (fsm_dir_dir_path, fsm_dir_name, SMA_ACCESS_BIN,
				cu_$level_get (),
				get_group_id_$tag_star (), 1, 0, 0, status);

002304  aa  6 00252 3521 00	epp2 	pr6|170
002305  aa  6 00256 2521 00	spri2	pr6|174
002306  aa  6 00254 6211 00	eax1 	pr6|172
002307  aa   004000 4310 07	fld  	2048,dl
002310  la  4 00170 3521 20	epp2 	pr4|120,*		cu_$level_get
002311  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
002312  aa   000001 2360 07	ldq  	1,dl
002313  aa  6 00232 7561 00	stq  	pr6|154
002314  aa  6 00252 2361 00	ldq  	pr6|170
002315  aa  6 00232 7271 00	lxl7 	pr6|154
002316  aa  6 00253 7561 17	stq  	pr6|171,7
002317  aa  6 00232 2361 00	ldq  	pr6|154
002320  aa  6 00232 0541 00	aos  	pr6|154
002321  aa   000003 1160 07	cmpq 	3,dl
002322  aa   777772 6040 04	tmi  	-6,ic		002314
002323  aa  6 00264 3521 00	epp2 	pr6|180
002324  aa  6 00304 2521 00	spri2	pr6|196
002325  aa  6 00302 6211 00	eax1 	pr6|194
002326  aa   004000 4310 07	fld  	2048,dl
002327  aa  6 00044 3701 20	epp4 	pr6|36,*
002330  la  4 00172 3521 20	epp2 	pr4|122,*		get_group_id_$tag_star
002331  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
002332  aa   000001 2360 07	ldq  	1,dl
002333  aa  6 00252 7561 00	stq  	pr6|170
002334  aa  6 00251 4501 00	stz  	pr6|169
002335  aa  6 00253 4501 00	stz  	pr6|171
002336  aa  6 00122 3521 00	epp2 	pr6|82		fsm_dir_dir_path
002337  aa  6 00412 2521 00	spri2	pr6|266
002340  aa  6 00174 3521 00	epp2 	pr6|124		fsm_dir_name
002341  aa  6 00414 2521 00	spri2	pr6|268
002342  aa   775437 3520 04	epp2 	-1249,ic		000001 = 000000000013
002343  aa  6 00416 2521 00	spri2	pr6|270
002344  aa  6 00254 3521 00	epp2 	pr6|172
002345  aa  6 00420 2521 00	spri2	pr6|272
002346  aa  6 00264 3521 00	epp2 	pr6|180
002347  aa  6 00422 2521 00	spri2	pr6|274
002350  aa  6 00252 3521 00	epp2 	pr6|170
002351  aa  6 00424 2521 00	spri2	pr6|276
002352  aa  6 00251 3521 00	epp2 	pr6|169
002353  aa  6 00426 2521 00	spri2	pr6|278
002354  aa  6 00253 3521 00	epp2 	pr6|171
002355  aa  6 00430 2521 00	spri2	pr6|280
002356  aa  6 00220 3521 00	epp2 	pr6|144		status
002357  aa  6 00432 2521 00	spri2	pr6|282
002360  aa   775475 3520 04	epp2 	-1219,ic		000055 = 526000000250
002361  aa  6 00434 2521 00	spri2	pr6|284
002362  aa   775470 3520 04	epp2 	-1224,ic		000052 = 526000000040
002363  aa  6 00436 2521 00	spri2	pr6|286
002364  aa   775450 3520 04	epp2 	-1240,ic		000034 = 404000000005
002365  aa  6 00440 2521 00	spri2	pr6|288
002366  aa   775541 3520 04	epp2 	-1183,ic		000127 = 404100000006
002367  aa  6 00442 2521 00	spri2	pr6|290
002370  aa   775460 3520 04	epp2 	-1232,ic		000050 = 524000000040
002371  aa  6 00444 2521 00	spri2	pr6|292
002372  aa   775454 3520 04	epp2 	-1236,ic		000046 = 404000000001
002373  aa  6 00446 2521 00	spri2	pr6|294
002374  aa  6 00450 2521 00	spri2	pr6|296
002375  aa   775440 3520 04	epp2 	-1248,ic		000035 = 404000000030
002376  aa  6 00452 2521 00	spri2	pr6|298
002377  aa   775445 3520 04	epp2 	-1243,ic		000044 = 404000000043
002400  aa  6 00454 2521 00	spri2	pr6|300
002401  aa  6 00410 6211 00	eax1 	pr6|264
002402  aa   044000 4310 07	fld  	18432,dl
002403  aa  6 00044 3701 20	epp4 	pr6|36,*
002404  la  4 00200 3521 20	epp2 	pr4|128,*		hcs_$append_branchx
002405  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 460
			     if status = 0
			     then do;

002406  aa  6 00220 2361 00	ldq  	pr6|144		status
002407  aa   000137 6010 04	tnz  	95,ic		002546
						STATEMENT 1 ON LINE 462
				     call hcs_$set_safety_sw (fsm_dir_dir_path, fsm_dir_name, "1"b, status);

002410  aa   400000 2350 03	lda  	131072,du
002411  aa  6 00253 7551 00	sta  	pr6|171
002412  aa  6 00122 3521 00	epp2 	pr6|82		fsm_dir_dir_path
002413  aa  6 00322 2521 00	spri2	pr6|210
002414  aa  6 00174 3521 00	epp2 	pr6|124		fsm_dir_name
002415  aa  6 00324 2521 00	spri2	pr6|212
002416  aa  6 00253 3521 00	epp2 	pr6|171
002417  aa  6 00326 2521 00	spri2	pr6|214
002420  aa  6 00220 3521 00	epp2 	pr6|144		status
002421  aa  6 00330 2521 00	spri2	pr6|216
002422  aa   775433 3520 04	epp2 	-1253,ic		000055 = 526000000250
002423  aa  6 00332 2521 00	spri2	pr6|218
002424  aa   775426 3520 04	epp2 	-1258,ic		000052 = 526000000040
002425  aa  6 00334 2521 00	spri2	pr6|220
002426  aa   775405 3520 04	epp2 	-1275,ic		000033 = 514000000001
002427  aa  6 00336 2521 00	spri2	pr6|222
002430  aa   775414 3520 04	epp2 	-1268,ic		000044 = 404000000043
002431  aa  6 00340 2521 00	spri2	pr6|224
002432  aa  6 00320 6211 00	eax1 	pr6|208
002433  aa   020000 4310 07	fld  	8192,dl
002434  aa  6 00044 3701 20	epp4 	pr6|36,*
002435  la  4 00204 3521 20	epp2 	pr4|132,*		hcs_$set_safety_sw
002436  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 463
				     call hcs_$make_seg (fsm_dir_path, fsm_info_name, "", RW_ACCESS_BIN,
					fsm_info_ptr, status);

002437  aa  6 00044 3701 20	epp4 	pr6|36,*
002440  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
002441  aa  6 00322 2521 00	spri2	pr6|210
002442  aa   775340 3520 04	epp2 	-1312,ic		000002 = 146163155137
002443  aa  6 00324 2521 00	spri2	pr6|212
002444  aa  6 00253 3521 00	epp2 	pr6|171
002445  aa  6 00326 2521 00	spri2	pr6|214
002446  aa   775346 3520 04	epp2 	-1306,ic		000014 = 000000000012
002447  aa  6 00330 2521 00	spri2	pr6|216
002450  ia  4 00134 3521 00	epp2 	pr4|92		fsm_info_ptr
002451  aa  6 00332 2521 00	spri2	pr6|218
002452  aa  6 00220 3521 00	epp2 	pr6|144		status
002453  aa  6 00334 2521 00	spri2	pr6|220
002454  aa   775401 3520 04	epp2 	-1279,ic		000055 = 526000000250
002455  aa  6 00336 2521 00	spri2	pr6|222
002456  aa   775360 3520 04	epp2 	-1296,ic		000036 = 526000000015
002457  aa  6 00340 2521 00	spri2	pr6|224
002460  aa   775367 3520 04	epp2 	-1289,ic		000047 = 524000000000
002461  aa  6 00342 2521 00	spri2	pr6|226
002462  aa   775352 3520 04	epp2 	-1302,ic		000034 = 404000000005
002463  aa  6 00344 2521 00	spri2	pr6|228
002464  aa   775372 3520 04	epp2 	-1286,ic		000056 = 464000000000
002465  aa  6 00346 2521 00	spri2	pr6|230
002466  aa   775356 3520 04	epp2 	-1298,ic		000044 = 404000000043
002467  aa  6 00350 2521 00	spri2	pr6|232
002470  aa  6 00320 6211 00	eax1 	pr6|208
002471  aa   030000 4310 07	fld  	12288,dl
002472  la  4 00202 3521 20	epp2 	pr4|130,*		hcs_$make_seg
002473  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 465
				     if fsm_info_ptr = null
				     then call signal_fsm_error (status, fsm_info_path);

002474  aa  6 00044 3701 20	epp4 	pr6|36,*
002475  ia  4 00134 2371 00	ldaq 	pr4|92		fsm_info_ptr
002476  aa   775376 6770 04	eraq 	-1282,ic		000074 = 077777000043 000001000000
002477  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002500  aa   000016 6010 04	tnz  	14,ic		002516
002501  aa  6 00220 3521 00	epp2 	pr6|144		status
002502  aa  6 00266 2521 00	spri2	pr6|182
002503  ia  4 00062 3521 00	epp2 	pr4|50		fsm_info_path
002504  aa  6 00270 2521 00	spri2	pr6|184
002505  aa   775337 3520 04	epp2 	-1313,ic		000044 = 404000000043
002506  aa  6 00274 2521 00	spri2	pr6|188
002507  aa   775346 3520 04	epp2 	-1306,ic		000055 = 526000000250
002510  aa  6 00276 2521 00	spri2	pr6|190
002511  aa   000001 7270 07	lxl7 	1,dl
002512  aa  6 00264 6211 00	eax1 	pr6|180
002513  aa   010000 4310 07	fld  	4096,dl
002514  aa   003734 3520 04	epp2 	2012,ic		006450 = 000260627000
002515  aa  0 00626 7001 00	tsx0 	pr0|406		call_int_other_desc
						STATEMENT 1 ON LINE 467
				     call hcs_$set_safety_sw (fsm_dir_dir_path, fsm_info_name, "1"b, status);

002516  aa   400000 2350 03	lda  	131072,du
002517  aa  6 00253 7551 00	sta  	pr6|171
002520  aa  6 00122 3521 00	epp2 	pr6|82		fsm_dir_dir_path
002521  aa  6 00322 2521 00	spri2	pr6|210
002522  aa   775260 3520 04	epp2 	-1360,ic		000002 = 146163155137
002523  aa  6 00324 2521 00	spri2	pr6|212
002524  aa  6 00253 3521 00	epp2 	pr6|171
002525  aa  6 00326 2521 00	spri2	pr6|214
002526  aa  6 00220 3521 00	epp2 	pr6|144		status
002527  aa  6 00330 2521 00	spri2	pr6|216
002530  aa   775325 3520 04	epp2 	-1323,ic		000055 = 526000000250
002531  aa  6 00332 2521 00	spri2	pr6|218
002532  aa   775304 3520 04	epp2 	-1340,ic		000036 = 526000000015
002533  aa  6 00334 2521 00	spri2	pr6|220
002534  aa   775277 3520 04	epp2 	-1345,ic		000033 = 514000000001
002535  aa  6 00336 2521 00	spri2	pr6|222
002536  aa   775306 3520 04	epp2 	-1338,ic		000044 = 404000000043
002537  aa  6 00340 2521 00	spri2	pr6|224
002540  aa  6 00320 6211 00	eax1 	pr6|208
002541  aa   020000 4310 07	fld  	8192,dl
002542  aa  6 00044 3701 20	epp4 	pr6|36,*
002543  la  4 00204 3521 20	epp2 	pr4|132,*		hcs_$set_safety_sw
002544  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 468
				end;

002545  aa   777177 7100 04	tra  	-385,ic		001744
						STATEMENT 1 ON LINE 469
			     else call signal_fsm_error (status, fsm_dir_path);

002546  aa  6 00220 3521 00	epp2 	pr6|144		status
002547  aa  6 00266 2521 00	spri2	pr6|182
002550  aa  6 00044 3701 20	epp4 	pr6|36,*
002551  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
002552  aa  6 00270 2521 00	spri2	pr6|184
002553  aa   775271 3520 04	epp2 	-1351,ic		000044 = 404000000043
002554  aa  6 00274 2521 00	spri2	pr6|188
002555  aa   775300 3520 04	epp2 	-1344,ic		000055 = 526000000250
002556  aa  6 00276 2521 00	spri2	pr6|190
002557  aa   000001 7270 07	lxl7 	1,dl
002560  aa  6 00264 6211 00	eax1 	pr6|180
002561  aa   010000 4310 07	fld  	4096,dl
002562  aa   003666 3520 04	epp2 	1974,ic		006450 = 000260627000
002563  aa  0 00626 7001 00	tsx0 	pr0|406		call_int_other_desc
						STATEMENT 1 ON LINE 470
			end;

002564  aa   777160 7100 04	tra  	-400,ic		001744
						STATEMENT 1 ON LINE 471
		     else call signal_fsm_error (status, fsm_dir_path);

002565  aa  6 00220 3521 00	epp2 	pr6|144		status
002566  aa  6 00266 2521 00	spri2	pr6|182
002567  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
002570  aa  6 00270 2521 00	spri2	pr6|184
002571  aa   775253 3520 04	epp2 	-1365,ic		000044 = 404000000043
002572  aa  6 00274 2521 00	spri2	pr6|188
002573  aa   775262 3520 04	epp2 	-1358,ic		000055 = 526000000250
002574  aa  6 00276 2521 00	spri2	pr6|190
002575  aa   000001 7270 07	lxl7 	1,dl
002576  aa  6 00264 6211 00	eax1 	pr6|180
002577  aa   010000 4310 07	fld  	4096,dl
002600  aa   003650 3520 04	epp2 	1960,ic		006450 = 000260627000
002601  aa  0 00626 7001 00	tsx0 	pr0|406		call_int_other_desc
						STATEMENT 1 ON LINE 472
		end;

002602  aa   777142 7100 04	tra  	-414,ic		001744
						STATEMENT 1 ON LINE 473
	     end;

						STATEMENT 1 ON LINE 483
	status = 1;

002603  aa   000001 2360 07	ldq  	1,dl
002604  aa  6 00220 7561 00	stq  	pr6|144		status
						STATEMENT 1 ON LINE 484
	do while (status ^= 0);

002605  aa   000000 0110 03	nop  	0,du
002606  aa  6 00220 2361 00	ldq  	pr6|144		status
002607  aa   000042 6000 04	tze  	34,ic		002651
						STATEMENT 1 ON LINE 485
	     call set_lock_$lock (fsm_info.lock, Max_wait_time, status);

002610  aa  6 00044 3701 20	epp4 	pr6|36,*
002611  ia  4 00134 3521 20	epp2 	pr4|92,*		fsm_info.lock
002612  aa  6 00256 2521 00	spri2	pr6|174
002613  aa   775165 3520 04	epp2 	-1419,ic		000000 = 000000000170
002614  aa  6 00260 2521 00	spri2	pr6|176
002615  aa  6 00220 3521 00	epp2 	pr6|144		status
002616  aa  6 00262 2521 00	spri2	pr6|178
002617  aa  6 00254 6211 00	eax1 	pr6|172
002620  aa   014000 4310 07	fld  	6144,dl
002621  la  4 00216 3521 20	epp2 	pr4|142,*		set_lock_$lock
002622  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 486
	     if status = error_table_$invalid_lock_reset
	     then status = 0;

002623  aa  6 00220 2361 00	ldq  	pr6|144		status
002624  aa  6 00044 3701 20	epp4 	pr6|36,*
002625  la  4 00156 1161 20	cmpq 	pr4|110,*		error_table_$invalid_lock_reset
002626  aa   000003 6010 04	tnz  	3,ic		002631
002627  aa  6 00220 4501 00	stz  	pr6|144		status
002630  aa   777756 7100 04	tra  	-18,ic		002606
						STATEMENT 1 ON LINE 488
	     else if status ^= 0
	     then call signal_fsm_error (status, fsm_info_path);

002631  aa  6 00220 2361 00	ldq  	pr6|144		status
002632  aa   777754 6000 04	tze  	-20,ic		002606
002633  aa  6 00220 3521 00	epp2 	pr6|144		status
002634  aa  6 00266 2521 00	spri2	pr6|182
002635  ia  4 00062 3521 00	epp2 	pr4|50		fsm_info_path
002636  aa  6 00270 2521 00	spri2	pr6|184
002637  aa   775205 3520 04	epp2 	-1403,ic		000044 = 404000000043
002640  aa  6 00274 2521 00	spri2	pr6|188
002641  aa   775214 3520 04	epp2 	-1396,ic		000055 = 526000000250
002642  aa  6 00276 2521 00	spri2	pr6|190
002643  aa   000001 7270 07	lxl7 	1,dl
002644  aa  6 00264 6211 00	eax1 	pr6|180
002645  aa   010000 4310 07	fld  	4096,dl
002646  aa   003602 3520 04	epp2 	1922,ic		006450 = 000260627000
002647  aa  0 00626 7001 00	tsx0 	pr0|406		call_int_other_desc
						STATEMENT 1 ON LINE 490
	end;

002650  aa   777736 7100 04	tra  	-34,ic		002606
						STATEMENT 1 ON LINE 516
	do while (^fsm_info_ptr_valid);

002651  aa   000000 0110 03	nop  	0,du
002652  aa  6 00044 3701 20	epp4 	pr6|36,*
002653  ia  4 00136 2351 00	lda  	pr4|94		fsm_info_ptr_valid
002654  aa   000453 6010 04	tnz  	299,ic		003327
						STATEMENT 1 ON LINE 517
	     system_free_area_ptr = get_system_free_area_ ();

002655  aa  6 00222 3521 00	epp2 	pr6|146		system_free_area_ptr
002656  aa  6 00256 2521 00	spri2	pr6|174
002657  aa  6 00254 6211 00	eax1 	pr6|172
002660  aa   004000 4310 07	fld  	2048,dl
002661  la  4 00174 3521 20	epp2 	pr4|124,*		get_system_free_area_
002662  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 518
	     star_entry_ptr, star_names_ptr = null;

002663  aa   775211 3734 24	epp7 	-1399,ic*
002664  aa  6 00226 6535 00	spri7	pr6|150		star_entry_ptr
002665  aa  6 00230 6535 00	spri7	pr6|152		star_names_ptr
						STATEMENT 1 ON LINE 519
	     on cleanup
		begin;

002666  aa   000007 7260 07	lxl6 	7,dl
002667  aa   775207 3520 04	epp2 	-1401,ic		000076 = 143154145141
002670  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
002671  aa   000004 7100 04	tra  	4,ic		002675
002672  aa     000100000000
002673  aa   000054 7100 04	tra  	44,ic		002747
BEGIN CONDITION cleanup.6
ENTRY TO cleanup.6                                          STATEMENT 1 ON LINE 519
	     on cleanup
		begin;

002674  da     000633200000
002675  aa   000100 6270 00	eax7 	64
002676  aa  7 00034 3521 20	epp2 	pr7|28,*
002677  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
002700  aa     000000000000
002701  aa     000000000000
002702  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
						STATEMENT 1 ON LINE 521
		     if star_names_ptr ^= null
		     then free star_names in (system_free_area);

002703  aa  6 00040 3735 20	epp7 	pr6|32,*
002704  aa  7 00230 2371 00	ldaq 	pr7|152		star_names_ptr
002705  aa   775167 6770 04	eraq 	-1417,ic		000074 = 077777000043 000001000000
002706  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002707  aa   000030 6000 04	tze  	24,ic		002737
002710  aa   775160 2370 04	ldaq 	-1424,ic		000070 = 000000000000 000000000000
002711  aa  7 00240 7571 00	staq 	pr7|160
002712  aa   000001 2360 07	ldq  	1,dl
002713  aa  7 00232 7561 00	stq  	pr7|154
002714  aa  6 00040 3735 20	epp7 	pr6|32,*
002715  aa  7 00232 7271 00	lxl7 	pr7|154
002716  aa  7 00226 3715 20	epp5 	pr7|150,*		star_entry_ptr
002717  aa  5 77777 2351 17	lda  	pr5|-1,7		star_entries.nnames
002720  aa   000002 7350 00	als  	2
002721  aa   000070 7730 00	lrl  	56
002722  aa   000044 7770 00	llr  	36
002723  aa   000044 7330 00	lrs  	36
002724  aa  7 00240 0771 00	adaq 	pr7|160
002725  aa  7 00240 7571 00	staq 	pr7|160
002726  aa  7 00232 2361 00	ldq  	pr7|154
002727  aa  7 00232 0541 00	aos  	pr7|154
002730  aa  7 00225 1161 00	cmpq 	pr7|149		star_entry_count
002731  aa   777763 6040 04	tmi  	-13,ic		002714
002732  aa   000010 2360 07	ldq  	8,dl
002733  aa  7 00240 3521 00	epp2 	pr7|160
002734  aa  0 00671 7001 00	tsx0 	pr0|441		mpfx2
002735  aa  7 00230 3715 00	epp5 	pr7|152		star_names_ptr
002736  aa  0 01404 7001 00	tsx0 	pr0|772		op_freen_
						STATEMENT 1 ON LINE 523
		     if star_entry_ptr ^= null
		     then free star_entries in (system_free_area);

002737  aa  6 00040 3735 20	epp7 	pr6|32,*
002740  aa  7 00226 2371 00	ldaq 	pr7|150		star_entry_ptr
002741  aa   775133 6770 04	eraq 	-1445,ic		000074 = 077777000043 000001000000
002742  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002743  aa   000003 6000 04	tze  	3,ic		002746
002744  aa  7 00226 3715 00	epp5 	pr7|150		star_entry_ptr
002745  aa  0 01404 7001 00	tsx0 	pr0|772		op_freen_
						STATEMENT 1 ON LINE 525
		end;

002746  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.6
						STATEMENT 1 ON LINE 526
	     call hcs_$star_ (fsm_dir_path, "*.fsm_", star_BRANCHES_ONLY, system_free_area_ptr, star_entry_count,
		star_entry_ptr, star_names_ptr, status);

002747  aa   775123 2370 04	ldaq 	-1453,ic		000072 = 052056146163 155137000000
002750  aa  6 00300 7571 00	staq 	pr6|192
002751  aa  6 00044 3701 20	epp4 	pr6|36,*
002752  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
002753  aa  6 00412 2521 00	spri2	pr6|266
002754  aa  6 00300 3521 00	epp2 	pr6|192
002755  aa  6 00414 2521 00	spri2	pr6|268
002756  aa   775102 3520 04	epp2 	-1470,ic		000060 = 000000000002
002757  aa  6 00416 2521 00	spri2	pr6|270
002760  aa  6 00222 3521 00	epp2 	pr6|146		system_free_area_ptr
002761  aa  6 00420 2521 00	spri2	pr6|272
002762  aa  6 00225 3521 00	epp2 	pr6|149		star_entry_count
002763  aa  6 00422 2521 00	spri2	pr6|274
002764  aa  6 00226 3521 00	epp2 	pr6|150		star_entry_ptr
002765  aa  6 00424 2521 00	spri2	pr6|276
002766  aa  6 00230 3521 00	epp2 	pr6|152		star_names_ptr
002767  aa  6 00426 2521 00	spri2	pr6|278
002770  aa  6 00220 3521 00	epp2 	pr6|144		status
002771  aa  6 00430 2521 00	spri2	pr6|280
002772  aa   775063 3520 04	epp2 	-1485,ic		000055 = 526000000250
002773  aa  6 00432 2521 00	spri2	pr6|282
002774  aa   775036 3520 04	epp2 	-1506,ic		000032 = 524000000006
002775  aa  6 00434 2521 00	spri2	pr6|284
002776  aa   775047 3520 04	epp2 	-1497,ic		000045 = 404000000002
002777  aa  6 00436 2521 00	spri2	pr6|286
003000  aa   775056 3520 04	epp2 	-1490,ic		000056 = 464000000000
003001  aa  6 00440 2521 00	spri2	pr6|288
003002  aa  6 00444 2521 00	spri2	pr6|292
003003  aa  6 00446 2521 00	spri2	pr6|294
003004  aa   775053 3520 04	epp2 	-1493,ic		000057 = 404000000021
003005  aa  6 00442 2521 00	spri2	pr6|290
003006  aa   775036 3520 04	epp2 	-1506,ic		000044 = 404000000043
003007  aa  6 00450 2521 00	spri2	pr6|296
003010  aa  6 00410 6211 00	eax1 	pr6|264
003011  aa   040000 4310 07	fld  	16384,dl
003012  la  4 00210 3521 20	epp2 	pr4|136,*		hcs_$star_
003013  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 528
	     if status ^= 0 & status ^= error_table_$nomatch
	     then call signal_fsm_error (status, fsm_info_path);

003014  aa  6 00220 2361 00	ldq  	pr6|144		status
003015  aa   000022 6000 04	tze  	18,ic		003037
003016  aa  6 00044 3701 20	epp4 	pr6|36,*
003017  la  4 00166 1161 20	cmpq 	pr4|118,*		error_table_$nomatch
003020  aa   000017 6000 04	tze  	15,ic		003037
003021  aa  6 00220 3521 00	epp2 	pr6|144		status
003022  aa  6 00266 2521 00	spri2	pr6|182
003023  ia  4 00062 3521 00	epp2 	pr4|50		fsm_info_path
003024  aa  6 00270 2521 00	spri2	pr6|184
003025  aa   775017 3520 04	epp2 	-1521,ic		000044 = 404000000043
003026  aa  6 00274 2521 00	spri2	pr6|188
003027  aa   775026 3520 04	epp2 	-1514,ic		000055 = 526000000250
003030  aa  6 00276 2521 00	spri2	pr6|190
003031  aa   000001 7270 07	lxl7 	1,dl
003032  aa  6 00264 6211 00	eax1 	pr6|180
003033  aa   010000 4310 07	fld  	4096,dl
003034  aa   003414 3520 04	epp2 	1804,ic		006450 = 000260627000
003035  aa  0 00626 7001 00	tsx0 	pr0|406		call_int_other_desc
003036  aa   777614 7100 04	tra  	-116,ic		002652
						STATEMENT 1 ON LINE 530
	     else do;

						STATEMENT 1 ON LINE 531
		     seg_cnt, max_seg_idx = 0;

003037  aa  6 00216 4501 00	stz  	pr6|142		seg_cnt
003040  aa  6 00205 4501 00	stz  	pr6|133		max_seg_idx
						STATEMENT 1 ON LINE 532
		     do i = 1 to star_entry_count;

003041  aa  6 00225 2361 00	ldq  	pr6|149		star_entry_count
003042  aa  6 00233 7561 00	stq  	pr6|155
003043  aa   000001 2360 07	ldq  	1,dl
003044  aa  6 00204 7561 00	stq  	pr6|132		i
003045  aa   000000 0110 03	nop  	0,du
003046  aa  6 00204 2361 00	ldq  	pr6|132		i
003047  aa  6 00233 1161 00	cmpq 	pr6|155
003050  aa   000056 6054 04	tpnz 	46,ic		003126
						STATEMENT 1 ON LINE 533
			primary_name = star_names (star_entries (i).nindex);

003051  aa  6 00226 3735 20	epp7 	pr6|150,*		star_entry_ptr
003052  aa  7 77777 2361 06	ldq  	pr7|-1,ql		star_entries.nindex
003053  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
003054  aa   000003 7360 00	qls  	3
003055  aa  6 00230 3715 20	epp5 	pr6|152,*		star_names_ptr
003056  aa  5 77770 3715 06	epp5 	pr5|-8,ql		star_names
003057  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
003060  aa  5 00000 00 0040	desc9a	pr5|0,32		star_names
003061  aa  6 00206 00 0040	desc9a	pr6|134,32	primary_name
						STATEMENT 1 ON LINE 534
			if verify (before (primary_name, "."), "0123456789") = 0
			     & substr (primary_name, 1, 1) ^= "0"
			then do;

003062  aa  000 003 124 500	scm  	(pr),(du),mask(000)
003063  aa  6 00206 00 0040	desc9a	pr6|134,32	primary_name
003064  aa   056000 00 0001	desc9a	23552,1
003065  aa  6 00056 0001 00	arg  	pr6|46
003066  aa  6 00056 2361 00	ldq  	pr6|46
003067  aa  6 00253 7561 00	stq  	pr6|171
003070  aa  000 000 164 540	tct  	(pr,rl)
003071  aa  6 00206 00 0006	desc9a	pr6|134,ql	primary_name
003072  aa   003500 0000 04	arg  	1856,ic		006570 = 777777777777
003073  aa  6 00056 0001 00	arg  	pr6|46
003074  aa  6 00056 2361 00	ldq  	pr6|46
003075  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
003076  aa   000002 6070 04	ttf  	2,ic		003100
003077  aa   000001 3360 07	lcq  	1,dl
003100  aa   000001 0760 07	adq  	1,dl
003101  aa   000023 6010 04	tnz  	19,ic		003124
003102  aa  6 00206 2351 00	lda  	pr6|134		primary_name
003103  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
003104  aa   060000 1150 03	cmpa 	24576,du
003105  aa   000017 6000 04	tze  	15,ic		003124
						STATEMENT 1 ON LINE 537
				seg_cnt = seg_cnt + 1;

003106  aa  6 00216 0541 00	aos  	pr6|142		seg_cnt
						STATEMENT 1 ON LINE 538
				seg_idx = bin (before (primary_name, "."));

003107  aa  6 00206 3535 00	epp3 	pr6|134		primary_name
003110  aa  6 00253 2361 00	ldq  	pr6|171
003111  aa   000053 7270 07	lxl7 	43,dl
003112  aa  6 00300 3515 00	epp1 	pr6|192
003113  aa   000107 2350 07	lda  	71,dl
003114  aa   000004 7260 07	lxl6 	4,dl
003115  aa  6 00456 3715 00	epp5 	pr6|302
003116  aa  0 01257 7001 00	tsx0 	pr0|687		any_to_any_truncate_
003117  aa  6 00300 2371 00	ldaq 	pr6|192
003120  aa  6 00217 7561 00	stq  	pr6|143		seg_idx
						STATEMENT 1 ON LINE 539
				if seg_idx > max_seg_idx
				then max_seg_idx = seg_idx;

003121  aa  6 00205 1161 00	cmpq 	pr6|133		max_seg_idx
003122  aa   000002 6044 04	tmoz 	2,ic		003124
003123  aa  6 00205 7561 00	stq  	pr6|133		max_seg_idx
						STATEMENT 1 ON LINE 541
			     end;

						STATEMENT 1 ON LINE 542
		     end;

003124  aa  6 00204 0541 00	aos  	pr6|132		i
003125  aa   777721 7100 04	tra  	-47,ic		003046
						STATEMENT 1 ON LINE 543
		     if star_names_ptr ^= null
		     then free star_names in (system_free_area);

003126  aa  6 00230 2371 00	ldaq 	pr6|152		star_names_ptr
003127  aa   774745 6770 04	eraq 	-1563,ic		000074 = 077777000043 000001000000
003130  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003131  aa   000027 6000 04	tze  	23,ic		003160
003132  aa   774736 2370 04	ldaq 	-1570,ic		000070 = 000000000000 000000000000
003133  aa  6 00234 7571 00	staq 	pr6|156
003134  aa   000001 2360 07	ldq  	1,dl
003135  aa  6 00232 7561 00	stq  	pr6|154
003136  aa  6 00232 7271 00	lxl7 	pr6|154
003137  aa  6 00226 3735 20	epp7 	pr6|150,*		star_entry_ptr
003140  aa  7 77777 2351 17	lda  	pr7|-1,7		star_entries.nnames
003141  aa   000002 7350 00	als  	2
003142  aa   000070 7730 00	lrl  	56
003143  aa   000044 7770 00	llr  	36
003144  aa   000044 7330 00	lrs  	36
003145  aa  6 00234 0771 00	adaq 	pr6|156
003146  aa  6 00234 7571 00	staq 	pr6|156
003147  aa  6 00232 2361 00	ldq  	pr6|154
003150  aa  6 00232 0541 00	aos  	pr6|154
003151  aa  6 00225 1161 00	cmpq 	pr6|149		star_entry_count
003152  aa   777764 6040 04	tmi  	-12,ic		003136
003153  aa   000010 2360 07	ldq  	8,dl
003154  aa  6 00234 3521 00	epp2 	pr6|156
003155  aa  0 00671 7001 00	tsx0 	pr0|441		mpfx2
003156  aa  6 00230 3715 00	epp5 	pr6|152		star_names_ptr
003157  aa  0 01404 7001 00	tsx0 	pr0|772		op_freen_
						STATEMENT 1 ON LINE 545
		     if star_entry_ptr ^= null
		     then free star_entries in (system_free_area);

003160  aa  6 00226 2371 00	ldaq 	pr6|150		star_entry_ptr
003161  aa   774713 6770 04	eraq 	-1589,ic		000074 = 077777000043 000001000000
003162  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003163  aa   000003 6000 04	tze  	3,ic		003166
003164  aa  6 00226 3715 00	epp5 	pr6|150		star_entry_ptr
003165  aa  0 01404 7001 00	tsx0 	pr0|772		op_freen_
						STATEMENT 1 ON LINE 547
		     if max_seg_idx ^= seg_cnt | seg_cnt ^= fsm_info.seg_cnt
		     then call signal_fsm_error (error_table_$bad_segment, fsm_info_path);

003166  aa  6 00205 2361 00	ldq  	pr6|133		max_seg_idx
003167  aa  6 00216 1161 00	cmpq 	pr6|142		seg_cnt
003170  aa   000006 6010 04	tnz  	6,ic		003176
003171  aa  6 00216 2361 00	ldq  	pr6|142		seg_cnt
003172  aa  6 00044 3701 20	epp4 	pr6|36,*
003173  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
003174  aa  7 00001 1161 00	cmpq 	pr7|1		fsm_info.seg_cnt
003175  aa   000020 6000 04	tze  	16,ic		003215
003176  aa  6 00044 3701 20	epp4 	pr6|36,*
003177  la  4 00154 3521 20	epp2 	pr4|108,*		error_table_$bad_segment
003200  aa  6 00266 2521 00	spri2	pr6|182
003201  ia  4 00062 3521 00	epp2 	pr4|50		fsm_info_path
003202  aa  6 00270 2521 00	spri2	pr6|184
003203  aa   774641 3520 04	epp2 	-1631,ic		000044 = 404000000043
003204  aa  6 00274 2521 00	spri2	pr6|188
003205  aa   774650 3520 04	epp2 	-1624,ic		000055 = 526000000250
003206  aa  6 00276 2521 00	spri2	pr6|190
003207  aa   000001 7270 07	lxl7 	1,dl
003210  aa  6 00264 6211 00	eax1 	pr6|180
003211  aa   010000 4310 07	fld  	4096,dl
003212  aa   003236 3520 04	epp2 	1694,ic		006450 = 000260627000
003213  aa  0 00626 7001 00	tsx0 	pr0|406		call_int_other_desc
003214  aa   777436 7100 04	tra  	-226,ic		002652
						STATEMENT 1 ON LINE 549
		     else do;

						STATEMENT 1 ON LINE 550
			     do seg_idx = 1 to fsm_info.seg_cnt;

003215  aa  7 00001 2361 00	ldq  	pr7|1		fsm_info.seg_cnt
003216  aa  6 00236 7561 00	stq  	pr6|158
003217  aa   000001 2360 07	ldq  	1,dl
003220  aa  6 00217 7561 00	stq  	pr6|143		seg_idx
003221  aa   000000 0110 03	nop  	0,du
003222  aa  6 00217 2361 00	ldq  	pr6|143		seg_idx
003223  aa  6 00236 1161 00	cmpq 	pr6|158
003224  aa   000077 6054 04	tpnz 	63,ic		003323
						STATEMENT 1 ON LINE 551
				if fsm_info.seg (seg_idx).owning_process ^= ""b
				then do;

003225  aa   000005 4020 07	mpy  	5,dl
003226  aa  6 00044 3701 20	epp4 	pr6|36,*
003227  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
003230  aa  7 77775 2351 06	lda  	pr7|-3,ql		fsm_info.owning_process
003231  aa   000070 6000 04	tze  	56,ic		003321
						STATEMENT 1 ON LINE 553
					call set_lock_$lock ((fsm_info.seg (seg_idx).owning_process), 0, status)
					     ;

003232  aa  6 00253 7551 00	sta  	pr6|171
003233  aa  6 00251 4501 00	stz  	pr6|169
003234  aa  6 00253 3521 00	epp2 	pr6|171
003235  aa  6 00256 2521 00	spri2	pr6|174
003236  aa  6 00251 3521 00	epp2 	pr6|169
003237  aa  6 00260 2521 00	spri2	pr6|176
003240  aa  6 00220 3521 00	epp2 	pr6|144		status
003241  aa  6 00262 2521 00	spri2	pr6|178
003242  aa  6 00254 6211 00	eax1 	pr6|172
003243  aa   014000 4310 07	fld  	6144,dl
003244  la  4 00216 3521 20	epp2 	pr4|142,*		set_lock_$lock
003245  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 555
					if status = error_table_$invalid_lock_reset
					then do;

003246  aa  6 00220 2361 00	ldq  	pr6|144		status
003247  aa  6 00044 3701 20	epp4 	pr6|36,*
003250  la  4 00156 1161 20	cmpq 	pr4|110,*		error_table_$invalid_lock_reset
003251  aa   000050 6010 04	tnz  	40,ic		003321
						STATEMENT 1 ON LINE 557
						call hcs_$truncate_file (fsm_dir_path, seg_name (seg_idx), 0,
						     status);

003252  aa  6 00217 3521 00	epp2 	pr6|143		seg_idx
003253  aa  6 00266 2521 00	spri2	pr6|182
003254  aa  6 00254 3521 00	epp2 	pr6|172
003255  aa  6 00270 2521 00	spri2	pr6|184
003256  aa   000001 7270 07	lxl7 	1,dl
003257  aa  6 00264 6211 00	eax1 	pr6|180
003260  aa   010000 4310 07	fld  	4096,dl
003261  aa   003053 3520 04	epp2 	1579,ic		006334 = 000120627000
003262  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
003263  aa  6 00251 4501 00	stz  	pr6|169
003264  aa  6 00044 3701 20	epp4 	pr6|36,*
003265  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
003266  aa  6 00322 2521 00	spri2	pr6|210
003267  aa  6 00254 3521 00	epp2 	pr6|172
003270  aa  6 00324 2521 00	spri2	pr6|212
003271  aa  6 00251 3521 00	epp2 	pr6|169
003272  aa  6 00326 2521 00	spri2	pr6|214
003273  aa  6 00220 3521 00	epp2 	pr6|144		status
003274  aa  6 00330 2521 00	spri2	pr6|216
003275  aa   774560 3520 04	epp2 	-1680,ic		000055 = 526000000250
003276  aa  6 00332 2521 00	spri2	pr6|218
003277  aa   774551 3520 04	epp2 	-1687,ic		000050 = 524000000040
003300  aa  6 00334 2521 00	spri2	pr6|220
003301  aa   774542 3520 04	epp2 	-1694,ic		000043 = 404000000023
003302  aa  6 00336 2521 00	spri2	pr6|222
003303  aa   774541 3520 04	epp2 	-1695,ic		000044 = 404000000043
003304  aa  6 00340 2521 00	spri2	pr6|224
003305  aa  6 00320 6211 00	eax1 	pr6|208
003306  aa   020000 4310 07	fld  	8192,dl
003307  la  4 00150 3521 20	epp2 	pr4|104,*		hcs_$truncate_file
003310  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 559
						unspec (fsm_info.seg (seg_idx)) = ""b;

003311  aa  6 00217 2361 00	ldq  	pr6|143		seg_idx
003312  aa   000005 4020 07	mpy  	5,dl
003313  aa  6 00044 3701 20	epp4 	pr6|36,*
003314  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
003315  aa  7 77775 3735 06	epp7 	pr7|-3,ql
003316  aa  000 100 100 400	mlr  	(),(pr),fill(000)
003317  aa   000000 00 0000	desc9a	0,0
003320  aa  7 00000 00 0024	desc9a	pr7|0,20
						STATEMENT 1 ON LINE 560
					     end;

						STATEMENT 1 ON LINE 561
				     end;

						STATEMENT 1 ON LINE 562
			     end;

003321  aa  6 00217 0541 00	aos  	pr6|143		seg_idx
003322  aa   777700 7100 04	tra  	-64,ic		003222
						STATEMENT 1 ON LINE 563
			     fsm_info_ptr_valid = True;

003323  aa   400000 2350 03	lda  	131072,du
003324  aa  6 00044 3701 20	epp4 	pr6|36,*
003325  ia  4 00136 7551 00	sta  	pr4|94		fsm_info_ptr_valid
						STATEMENT 1 ON LINE 564
			end;

						STATEMENT 1 ON LINE 565
		end;

						STATEMENT 1 ON LINE 566
	end;

003326  aa   777324 7100 04	tra  	-300,ic		002652
						STATEMENT 1 ON LINE 567
	return;

003327  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 571
     end appropriate_fsm_info;

  END PROCEDURE appropriate_fsm_info
BEGIN PROCEDURE description_of_location
ENTRY TO description_of_location                            STATEMENT 1 ON LINE 573
description_of_location:
     proc (location) returns (char (256) varying) recursive;

003330  da     000644220000
003331  aa   000560 6270 00	eax7 	368
003332  aa  7 00034 3521 20	epp2 	pr7|28,*
003333  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
003334  aa     000004000000
003335  aa     000000000000
003336  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
						STATEMENT 1 ON LINE 622
	if location = null
	then return ("null");

003337  aa  6 00032 3735 20	epp7 	pr6|26,*
003340  aa  7 00002 2371 20	ldaq 	pr7|2,*		location
003341  aa   774533 6770 04	eraq 	-1701,ic		000074 = 077777000043 000001000000
003342  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003343  aa   000007 6010 04	tnz  	7,ic		003352
003344  aa   774465 2350 04	lda  	-1739,ic		000031 = 156165154154
003345  aa  7 00004 7551 20	sta  	pr7|4,*
003346  aa   000004 2360 07	ldq  	4,dl
003347  aa  7 00004 3715 20	epp5 	pr7|4,*
003350  aa  5 77777 7561 00	stq  	pr5|-1
003351  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 627
	if substr (unspec (location), 58, 6) = ""b	/*  Unfortunately, there is no builtin to get the bit offset.  */
	then bit_offset = "";

003352  aa  7 00002 3715 20	epp5 	pr7|2,*
003353  aa  5 00001 2351 00	lda  	pr5|1
003354  aa   000025 7350 00	als  	21
003355  aa  0 00014 3771 00	anaq 	pr0|12		= 770000000000 000000000000
003356  aa  6 00320 7551 00	sta  	pr6|208
003357  aa   000003 6010 04	tnz  	3,ic		003362
003360  aa  6 00100 4501 00	stz  	pr6|64		bit_offset
003361  aa   000053 7100 04	tra  	43,ic		003434
						STATEMENT 1 ON LINE 629
	else do;

						STATEMENT 1 ON LINE 630
		bit_offset = "(";

003362  aa   050000 2350 03	lda  	20480,du
003363  aa  6 00101 7551 00	sta  	pr6|65		bit_offset
003364  aa   000001 2360 07	ldq  	1,dl
003365  aa  6 00100 7561 00	stq  	pr6|64		bit_offset
						STATEMENT 1 ON LINE 631
		bit_offset = bit_offset || ltrim (char (fixed (substr (unspec (location), 58, 6))));

003366  aa  6 00320 2351 00	lda  	pr6|208
003367  aa   000102 7730 00	lrl  	66
003370  aa  6 00332 7571 00	staq 	pr6|218
003371  aa  000 100 301 500	btd  	(pr),(pr)
003372  aa  6 00332 00 0010	desc9a	pr6|218,8
003373  aa  6 00334 01 0030	desc9ls	pr6|220,24,0
003374  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
003375  aa  6 00334 01 0030	desc9ls	pr6|220,24,0
003376  aa   003172 00 0007	desc9a	1658,7		006566 = 403040022140
003377  aa  6 00322 00 0032	desc9a	pr6|210,26
003400  aa  000 000 164 500	tct  	(pr)
003401  aa  6 00322 00 0032	desc9a	pr6|210,26
003402  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
003403  aa  6 00056 0001 00	arg  	pr6|46
003404  aa  6 00056 2361 00	ldq  	pr6|46
003405  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
003406  aa  6 00320 7561 00	stq  	pr6|208
003407  aa   000032 2360 07	ldq  	26,dl
003410  aa  6 00320 1761 00	sbq  	pr6|208
003411  aa  6 00331 7561 00	stq  	pr6|217
003412  aa  6 00320 2351 00	lda  	pr6|208
003413  aa   000004 2360 07	ldq  	4,dl
003414  aa  6 00100 1761 00	sbq  	pr6|64		bit_offset
003415  aa  6 00331 1161 00	cmpq 	pr6|217
003416  aa   000002 6040 04	tmi  	2,ic		003420
003417  aa  6 00331 2361 00	ldq  	pr6|217
003420  aa  6 00100 7271 00	lxl7 	pr6|64		bit_offset
003421  aa  6 00100 0561 00	asq  	pr6|64		bit_offset
003422  aa  040 157 100 545	mlr  	(pr,rl,al),(pr,rl,x7),fill(040)
003423  aa  6 00322 00 0006	desc9a	pr6|210,ql
003424  aa  6 00101 00 0006	desc9a	pr6|65,ql		bit_offset
						STATEMENT 1 ON LINE 632
		bit_offset = bit_offset || ")";

003425  aa  6 00100 2361 00	ldq  	pr6|64		bit_offset
003426  aa   000004 1160 07	cmpq 	4,dl
003427  aa   000005 6050 04	tpl  	5,ic		003434
003430  aa  6 00100 0541 00	aos  	pr6|64		bit_offset
003431  aa  040 106 100 404	mlr  	(ic),(pr,ql),fill(040)
003432  aa   003356 00 0001	desc9a	1774,1		007007 = 051000000000
003433  aa  6 00101 00 0001	desc9a	pr6|65,1		bit_offset
						STATEMENT 1 ON LINE 633
	     end;

						STATEMENT 1 ON LINE 634
	if rel (location) = ""b & bit_offset = ""
	then word_offset = "";

003434  aa  7 00002 3535 20	epp3 	pr7|2,*		location
003435  aa  3 00000 3535 20	epp3 	pr3|0,*		location
003436  aa  3 00000 6351 00	eaa  	pr3|0		location
003437  aa  6 00320 7551 00	sta  	pr6|208
003440  aa   000010 6010 04	tnz  	8,ic		003450
003441  aa  6 00100 7271 00	lxl7 	pr6|64		bit_offset
003442  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
003443  aa  6 00101 00 0017	desc9a	pr6|65,x7		bit_offset
003444  aa   003342 00 0000	desc9a	1762,0		007004 = 044000000000
003445  aa   000003 6010 04	tnz  	3,ic		003450
003446  aa  6 00310 4501 00	stz  	pr6|200		word_offset
003447  aa   000033 7100 04	tra  	27,ic		003502
						STATEMENT 1 ON LINE 636
	else do;

						STATEMENT 1 ON LINE 637
		word_offset = "|";

003450  aa   174000 2350 03	lda  	63488,du
003451  aa  6 00311 7551 00	sta  	pr6|201		word_offset
003452  aa   000001 2360 07	ldq  	1,dl
003453  aa  6 00310 7561 00	stq  	pr6|200		word_offset
						STATEMENT 1 ON LINE 638
		word_offset = word_offset || octal_representation (fixed (rel (location)));

003454  aa  6 00320 2351 00	lda  	pr6|208
003455  aa   000066 7730 00	lrl  	54
003456  aa  6 00331 7561 00	stq  	pr6|217
003457  aa  6 00331 3521 00	epp2 	pr6|217
003460  aa  6 00344 2521 00	spri2	pr6|228
003461  aa  6 00335 3521 00	epp2 	pr6|221
003462  aa  6 00346 2521 00	spri2	pr6|230
003463  aa   000001 7270 07	lxl7 	1,dl
003464  aa  6 00342 6211 00	eax1 	pr6|226
003465  aa   010000 4310 07	fld  	4096,dl
003466  aa   001613 3520 04	epp2 	907,ic		005301 = 000120627000
003467  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
003470  aa   000010 2360 07	ldq  	8,dl
003471  aa  6 00310 1761 00	sbq  	pr6|200		word_offset
003472  aa  6 00334 1161 00	cmpq 	pr6|220
003473  aa   000002 6040 04	tmi  	2,ic		003475
003474  aa  6 00334 2361 00	ldq  	pr6|220
003475  aa  6 00310 7271 00	lxl7 	pr6|200		word_offset
003476  aa  6 00310 0561 00	asq  	pr6|200		word_offset
003477  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
003500  aa  6 00335 00 0006	desc9a	pr6|221,ql
003501  aa  6 00311 00 0006	desc9a	pr6|201,ql	word_offset
						STATEMENT 1 ON LINE 639
	     end;

						STATEMENT 1 ON LINE 643
	call hcs_$fs_get_path_name (location, dir_name, dir_name_len, seg_name, status);

003502  aa  6 00032 3735 20	epp7 	pr6|26,*
003503  aa  7 00002 3521 20	epp2 	pr7|2,*		location
003504  aa  6 00354 2521 00	spri2	pr6|236
003505  aa  6 00204 3521 00	epp2 	pr6|132		dir_name
003506  aa  6 00356 2521 00	spri2	pr6|238
003507  aa  6 00256 3521 00	epp2 	pr6|174		dir_name_len
003510  aa  6 00360 2521 00	spri2	pr6|240
003511  aa  6 00272 3521 00	epp2 	pr6|186		seg_name
003512  aa  6 00362 2521 00	spri2	pr6|242
003513  aa  6 00303 3521 00	epp2 	pr6|195		status
003514  aa  6 00364 2521 00	spri2	pr6|244
003515  aa   774341 3520 04	epp2 	-1823,ic		000056 = 464000000000
003516  aa  6 00366 2521 00	spri2	pr6|246
003517  aa   774336 3520 04	epp2 	-1826,ic		000055 = 526000000250
003520  aa  6 00370 2521 00	spri2	pr6|248
003521  aa   774336 3520 04	epp2 	-1826,ic		000057 = 404000000021
003522  aa  6 00372 2521 00	spri2	pr6|250
003523  aa   774327 3520 04	epp2 	-1833,ic		000052 = 526000000040
003524  aa  6 00374 2521 00	spri2	pr6|252
003525  aa   774317 3520 04	epp2 	-1841,ic		000044 = 404000000043
003526  aa  6 00376 2521 00	spri2	pr6|254
003527  aa  6 00352 6211 00	eax1 	pr6|234
003530  aa   024000 4310 07	fld  	10240,dl
003531  aa  6 00044 3701 20	epp4 	pr6|36,*
003532  la  4 00230 3521 20	epp2 	pr4|152,*		hcs_$fs_get_path_name
003533  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 644
	if status ^= 0
	then do;

003534  aa  6 00303 2361 00	ldq  	pr6|195		status
003535  aa   000065 6000 04	tze  	53,ic		003622
						STATEMENT 1 ON LINE 646
		description = octal_representation (fixed (baseno (location)));

003536  aa  6 00032 3735 20	epp7 	pr6|26,*
003537  aa  7 00002 3715 20	epp5 	pr7|2,*		location
003540  aa  5 00000 3715 20	epp5 	pr5|0,*		location
003541  aa  5 00000 2131 00	epaq 	pr5|0		location
003542  aa   077777 3750 03	ana  	32767,du
003543  aa   000066 7730 00	lrl  	54
003544  aa  6 00331 7561 00	stq  	pr6|217
003545  aa  6 00331 3521 00	epp2 	pr6|217
003546  aa  6 00344 2521 00	spri2	pr6|228
003547  aa  6 00335 3521 00	epp2 	pr6|221
003550  aa  6 00346 2521 00	spri2	pr6|230
003551  aa   000001 7270 07	lxl7 	1,dl
003552  aa  6 00342 6211 00	eax1 	pr6|226
003553  aa   010000 4310 07	fld  	4096,dl
003554  aa   001525 3520 04	epp2 	853,ic		005301 = 000120627000
003555  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
003556  aa  6 00334 2361 00	ldq  	pr6|220
003557  aa  6 00103 7561 00	stq  	pr6|67		description
003560  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
003561  aa  6 00335 00 0006	desc9a	pr6|221,ql
003562  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 647
		description = description || word_offset;

003563  aa   000400 2360 07	ldq  	256,dl
003564  aa  6 00103 1761 00	sbq  	pr6|67		description
003565  aa  6 00310 1161 00	cmpq 	pr6|200		word_offset
003566  aa   000002 6040 04	tmi  	2,ic		003570
003567  aa  6 00310 2361 00	ldq  	pr6|200		word_offset
003570  aa  6 00103 7271 00	lxl7 	pr6|67		description
003571  aa  6 00103 0561 00	asq  	pr6|67		description
003572  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
003573  aa  6 00311 00 0006	desc9a	pr6|201,ql	word_offset
003574  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 648
		description = description || bit_offset;

003575  aa   000400 2360 07	ldq  	256,dl
003576  aa  6 00103 1761 00	sbq  	pr6|67		description
003577  aa  6 00100 1161 00	cmpq 	pr6|64		bit_offset
003600  aa   000002 6040 04	tmi  	2,ic		003602
003601  aa  6 00100 2361 00	ldq  	pr6|64		bit_offset
003602  aa  6 00103 7271 00	lxl7 	pr6|67		description
003603  aa  6 00103 0561 00	asq  	pr6|67		description
003604  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
003605  aa  6 00101 00 0006	desc9a	pr6|65,ql		bit_offset
003606  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 649
		description = description || " (Segment number invalid)";

003607  aa   000400 2360 07	ldq  	256,dl
003610  aa  6 00103 1761 00	sbq  	pr6|67		description
003611  aa   000031 1160 07	cmpq 	25,dl
003612  aa   000002 6040 04	tmi  	2,ic		003614
003613  aa   000031 2360 07	ldq  	25,dl
003614  aa  6 00103 7271 00	lxl7 	pr6|67		description
003615  aa  6 00103 0561 00	asq  	pr6|67		description
003616  aa  040 157 100 444	mlr  	(rl,ic),(pr,rl,x7),fill(040)
003617  aa   774350 00 0006	desc9a	-1816,ql		000166 = 040050123145
003620  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 650
	     end;

003621  aa   000626 7100 04	tra  	406,ic		004447
						STATEMENT 1 ON LINE 651
	else do;

						STATEMENT 1 ON LINE 652
		if dir_name = ">"
		then description = "";

003622  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003623  aa  6 00204 00 0250	desc9a	pr6|132,168	dir_name
003624  aa   003163 00 0001	desc9a	1651,1		007005 = 076000000000
003625  aa   000003 6010 04	tnz  	3,ic		003630
003626  aa  6 00103 4501 00	stz  	pr6|67		description
003627  aa   000031 7100 04	tra  	25,ic		003660
						STATEMENT 1 ON LINE 654
		else if dir_name = get_pdir_ ()
		then description = "[pd]";

003630  aa  6 00400 3521 00	epp2 	pr6|256
003631  aa  6 00336 2521 00	spri2	pr6|222
003632  aa  6 00334 6211 00	eax1 	pr6|220
003633  aa   004000 4310 07	fld  	2048,dl
003634  aa  6 00044 3701 20	epp4 	pr6|36,*
003635  la  4 00226 3521 20	epp2 	pr4|150,*		get_pdir_
003636  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
003637  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
003640  aa  6 00204 00 0250	desc9a	pr6|132,168	dir_name
003641  aa  6 00400 00 0250	desc9a	pr6|256,168
003642  aa   000006 6010 04	tnz  	6,ic		003650
003643  aa   774165 2350 04	lda  	-1931,ic		000030 = 133160144135
003644  aa  6 00104 7551 00	sta  	pr6|68		description
003645  aa   000004 2360 07	ldq  	4,dl
003646  aa  6 00103 7561 00	stq  	pr6|67		description
003647  aa   000011 7100 04	tra  	9,ic		003660
						STATEMENT 1 ON LINE 656
		else description = substr (dir_name, 1, dir_name_len);

003650  aa  6 00256 2361 00	ldq  	pr6|174		dir_name_len
003651  aa   000400 1160 07	cmpq 	256,dl
003652  aa   000002 6040 04	tmi  	2,ic		003654
003653  aa   000400 2360 07	ldq  	256,dl
003654  aa  6 00103 7561 00	stq  	pr6|67		description
003655  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
003656  aa  6 00204 00 0006	desc9a	pr6|132,ql	dir_name
003657  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 657
		description = description || ">";

003660  aa  6 00103 2361 00	ldq  	pr6|67		description
003661  aa   000400 1160 07	cmpq 	256,dl
003662  aa   000005 6050 04	tpl  	5,ic		003667
003663  aa  6 00103 0541 00	aos  	pr6|67		description
003664  aa  040 106 100 404	mlr  	(ic),(pr,ql),fill(040)
003665  aa   003121 00 0001	desc9a	1617,1		007005 = 076000000000
003666  aa  6 00104 00 0001	desc9a	pr6|68,1		description
						STATEMENT 1 ON LINE 658
		description = description || rtrim (seg_name);

003667  aa  000 000 165 500	tctr 	(pr)
003670  aa  6 00272 00 0040	desc9a	pr6|186,32	seg_name
003671  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
003672  aa  6 00056 0001 00	arg  	pr6|46
003673  aa  6 00056 2361 00	ldq  	pr6|46
003674  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
003675  aa  6 00331 7561 00	stq  	pr6|217
003676  aa   000040 2360 07	ldq  	32,dl
003677  aa  6 00331 1761 00	sbq  	pr6|217
003700  aa  6 00331 7561 00	stq  	pr6|217
003701  aa   000400 2360 07	ldq  	256,dl
003702  aa  6 00103 1761 00	sbq  	pr6|67		description
003703  aa  6 00331 1161 00	cmpq 	pr6|217
003704  aa   000002 6040 04	tmi  	2,ic		003706
003705  aa  6 00331 2361 00	ldq  	pr6|217
003706  aa  6 00103 7271 00	lxl7 	pr6|67		description
003707  aa  6 00103 0561 00	asq  	pr6|67		description
003710  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
003711  aa  6 00272 00 0006	desc9a	pr6|186,ql	seg_name
003712  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 659
		call get_entry_name_ (location, entry_name, seg_num, language, status);

003713  aa  6 00032 3735 20	epp7 	pr6|26,*
003714  aa  7 00002 3521 20	epp2 	pr7|2,*		location
003715  aa  6 00354 2521 00	spri2	pr6|236
003716  aa  6 00257 3521 00	epp2 	pr6|175		entry_name
003717  aa  6 00356 2521 00	spri2	pr6|238
003720  aa  6 00302 3521 00	epp2 	pr6|194		seg_num
003721  aa  6 00360 2521 00	spri2	pr6|240
003722  aa  6 00270 3521 00	epp2 	pr6|184		language
003723  aa  6 00362 2521 00	spri2	pr6|242
003724  aa  6 00303 3521 00	epp2 	pr6|195		status
003725  aa  6 00364 2521 00	spri2	pr6|244
003726  aa   774130 3520 04	epp2 	-1960,ic		000056 = 464000000000
003727  aa  6 00366 2521 00	spri2	pr6|246
003730  aa   774122 3520 04	epp2 	-1966,ic		000052 = 526000000040
003731  aa  6 00370 2521 00	spri2	pr6|248
003732  aa   774075 3520 04	epp2 	-1987,ic		000027 = 404000000022
003733  aa  6 00372 2521 00	spri2	pr6|250
003734  aa   774072 3520 04	epp2 	-1990,ic		000026 = 524000000010
003735  aa  6 00374 2521 00	spri2	pr6|252
003736  aa   774106 3520 04	epp2 	-1978,ic		000044 = 404000000043
003737  aa  6 00376 2521 00	spri2	pr6|254
003740  aa  6 00352 6211 00	eax1 	pr6|234
003741  aa   024000 4310 07	fld  	10240,dl
003742  aa  6 00044 3701 20	epp4 	pr6|36,*
003743  la  4 00224 3521 20	epp2 	pr4|148,*		get_entry_name_
003744  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 660
		if status = 0
		then do;

003745  aa  6 00303 2361 00	ldq  	pr6|195		status
003746  aa   000035 6010 04	tnz  	29,ic		004003
						STATEMENT 1 ON LINE 662
			description = description || "$";

003747  aa  6 00103 2361 00	ldq  	pr6|67		description
003750  aa   000400 1160 07	cmpq 	256,dl
003751  aa   000005 6050 04	tpl  	5,ic		003756
003752  aa  6 00103 0541 00	aos  	pr6|67		description
003753  aa  040 106 100 404	mlr  	(ic),(pr,ql),fill(040)
003754  aa   003031 00 0001	desc9a	1561,1		007004 = 044000000000
003755  aa  6 00104 00 0001	desc9a	pr6|68,1		description
						STATEMENT 1 ON LINE 663
			description = description || rtrim (entry_name);

003756  aa  000 000 165 500	tctr 	(pr)
003757  aa  6 00257 00 0040	desc9a	pr6|175,32	entry_name
003760  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
003761  aa  6 00056 0001 00	arg  	pr6|46
003762  aa  6 00056 2361 00	ldq  	pr6|46
003763  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
003764  aa  6 00331 7561 00	stq  	pr6|217
003765  aa   000040 2360 07	ldq  	32,dl
003766  aa  6 00331 1761 00	sbq  	pr6|217
003767  aa  6 00331 7561 00	stq  	pr6|217
003770  aa   000400 2360 07	ldq  	256,dl
003771  aa  6 00103 1761 00	sbq  	pr6|67		description
003772  aa  6 00331 1161 00	cmpq 	pr6|217
003773  aa   000002 6040 04	tmi  	2,ic		003775
003774  aa  6 00331 2361 00	ldq  	pr6|217
003775  aa  6 00103 7271 00	lxl7 	pr6|67		description
003776  aa  6 00103 0561 00	asq  	pr6|67		description
003777  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
004000  aa  6 00257 00 0006	desc9a	pr6|175,ql	entry_name
004001  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 664
		     end;

004002  aa   000025 7100 04	tra  	21,ic		004027
						STATEMENT 1 ON LINE 665
		else do;

						STATEMENT 1 ON LINE 666
			description = description || word_offset;

004003  aa   000400 2360 07	ldq  	256,dl
004004  aa  6 00103 1761 00	sbq  	pr6|67		description
004005  aa  6 00310 1161 00	cmpq 	pr6|200		word_offset
004006  aa   000002 6040 04	tmi  	2,ic		004010
004007  aa  6 00310 2361 00	ldq  	pr6|200		word_offset
004010  aa  6 00103 7271 00	lxl7 	pr6|67		description
004011  aa  6 00103 0561 00	asq  	pr6|67		description
004012  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
004013  aa  6 00311 00 0006	desc9a	pr6|201,ql	word_offset
004014  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 667
			description = description || bit_offset;

004015  aa   000400 2360 07	ldq  	256,dl
004016  aa  6 00103 1761 00	sbq  	pr6|67		description
004017  aa  6 00100 1161 00	cmpq 	pr6|64		bit_offset
004020  aa   000002 6040 04	tmi  	2,ic		004022
004021  aa  6 00100 2361 00	ldq  	pr6|64		bit_offset
004022  aa  6 00103 7271 00	lxl7 	pr6|67		description
004023  aa  6 00103 0561 00	asq  	pr6|67		description
004024  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
004025  aa  6 00101 00 0006	desc9a	pr6|65,ql		bit_offset
004026  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 668
		     end;

						STATEMENT 1 ON LINE 669
		if ptr (location, 0) = stackbaseptr
		then do;

004027  aa  6 00000 3525 00	epbp2	pr6|0
004030  aa  6 00332 2521 00	spri2	pr6|218
004031  aa  6 00032 3735 20	epp7 	pr6|26,*
004032  aa  7 00002 3515 20	epp1 	pr7|2,*		location
004033  aa  1 00000 3511 20	epbp1	pr1|0,*		location
004034  aa  6 00452 2515 00	spri1	pr6|298
004035  aa  6 00452 2371 00	ldaq 	pr6|298
004036  aa  6 00332 6771 00	eraq 	pr6|218
004037  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004040  aa   000174 6010 04	tnz  	124,ic		004234
						STATEMENT 1 ON LINE 671
			sp = stackframeptr;

004041  aa  6 00314 6521 00	spri6	pr6|204		sp
						STATEMENT 1 ON LINE 672
			do while (rel (sp) > rel (location) & stack_frame.prev_sp ^= null);

004042  aa  6 00032 3735 20	epp7 	pr6|26,*
004043  aa  7 00002 3715 20	epp5 	pr7|2,*		location
004044  aa  5 00000 3715 20	epp5 	pr5|0,*		location
004045  aa  5 00000 6351 00	eaa  	pr5|0		location
004046  aa  6 00331 7551 00	sta  	pr6|217
004047  aa  6 00314 6351 20	eaa  	pr6|204,*		sp
004050  aa  6 00331 1151 00	cmpa 	pr6|217
004051  aa  6 00320 7551 00	sta  	pr6|208
004052  aa   000012 6020 04	tnc  	10,ic		004064
004053  aa   000011 6000 04	tze  	9,ic		004064
004054  aa  6 00314 3535 20	epp3 	pr6|204,*		sp
004055  aa  3 00020 2371 00	ldaq 	pr3|16		stack_frame.prev_sp
004056  aa   774016 6770 04	eraq 	-2034,ic		000074 = 077777000043 000001000000
004057  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004060  aa   000004 6000 04	tze  	4,ic		004064
						STATEMENT 1 ON LINE 673
			     sp = stack_frame.prev_sp;

004061  aa  3 00020 3515 20	epp1 	pr3|16,*		stack_frame.prev_sp
004062  aa  6 00314 2515 00	spri1	pr6|204		sp
						STATEMENT 1 ON LINE 674
			end;

004063  aa   777757 7100 04	tra  	-17,ic		004042
						STATEMENT 1 ON LINE 675
			if rel (sp) <= rel (location) & rel (stack_frame.next_sp) > rel (location)
			then do;

004064  aa  6 00320 2351 00	lda  	pr6|208
004065  aa  6 00331 1151 00	cmpa 	pr6|217
004066  aa   000002 6000 04	tze  	2,ic		004070
004067  aa   000360 6030 04	trc  	240,ic		004447
004070  aa  6 00314 3535 20	epp3 	pr6|204,*		sp
004071  aa  3 00022 6351 20	eaa  	pr3|18,*		stack_frame.next_sp
004072  aa  6 00331 1151 00	cmpa 	pr6|217
004073  aa   000354 6020 04	tnc  	236,ic		004447
004074  aa   000353 6000 04	tze  	235,ic		004447
						STATEMENT 1 ON LINE 677
				description = description || " (stack_frame";

004075  aa   000400 2360 07	ldq  	256,dl
004076  aa  6 00103 1761 00	sbq  	pr6|67		description
004077  aa   000015 1160 07	cmpq 	13,dl
004100  aa   000002 6040 04	tmi  	2,ic		004102
004101  aa   000015 2360 07	ldq  	13,dl
004102  aa  6 00103 7271 00	lxl7 	pr6|67		description
004103  aa  6 00103 0561 00	asq  	pr6|67		description
004104  aa  040 157 100 444	mlr  	(rl,ic),(pr,rl,x7),fill(040)
004105  aa   774017 00 0006	desc9a	-2033,ql		000123 = 040050163164
004106  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 678
				if location ^= sp
				then do;

004107  aa  7 00002 2371 20	ldaq 	pr7|2,*		location
004110  aa  6 00314 6771 00	eraq 	pr6|204		sp
004111  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004112  aa   000054 6000 04	tze  	44,ic		004166
						STATEMENT 1 ON LINE 680
					description = description || "|";

004113  aa  6 00103 2361 00	ldq  	pr6|67		description
004114  aa   000400 1160 07	cmpq 	256,dl
004115  aa   000005 6050 04	tpl  	5,ic		004122
004116  aa  6 00103 0541 00	aos  	pr6|67		description
004117  aa  040 106 100 404	mlr  	(ic),(pr,ql),fill(040)
004120  aa   002667 00 0001	desc9a	1463,1		007006 = 174000000000
004121  aa  6 00104 00 0001	desc9a	pr6|68,1		description
						STATEMENT 1 ON LINE 681
					description =
					     description
					     ||
					     octal_representation (fixed (rel (location)) - fixed (rel (sp)));

004122  aa  6 00320 2351 00	lda  	pr6|208
004123  aa   000066 7730 00	lrl  	54
004124  aa  6 00454 7571 00	staq 	pr6|300
004125  aa  6 00331 2351 00	lda  	pr6|217
004126  aa   000066 7730 00	lrl  	54
004127  aa  6 00454 1771 00	sbaq 	pr6|300
004130  aa  6 00321 7561 00	stq  	pr6|209
004131  aa  6 00321 3521 00	epp2 	pr6|209
004132  aa  6 00344 2521 00	spri2	pr6|228
004133  aa  6 00335 3521 00	epp2 	pr6|221
004134  aa  6 00346 2521 00	spri2	pr6|230
004135  aa   000001 7270 07	lxl7 	1,dl
004136  aa  6 00342 6211 00	eax1 	pr6|226
004137  aa   010000 4310 07	fld  	4096,dl
004140  aa   001141 3520 04	epp2 	609,ic		005301 = 000120627000
004141  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
004142  aa   000400 2360 07	ldq  	256,dl
004143  aa  6 00103 1761 00	sbq  	pr6|67		description
004144  aa  6 00334 1161 00	cmpq 	pr6|220
004145  aa   000002 6040 04	tmi  	2,ic		004147
004146  aa  6 00334 2361 00	ldq  	pr6|220
004147  aa  6 00103 7271 00	lxl7 	pr6|67		description
004150  aa  6 00103 0561 00	asq  	pr6|67		description
004151  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
004152  aa  6 00335 00 0006	desc9a	pr6|221,ql
004153  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 685
					description = description || bit_offset;

004154  aa   000400 2360 07	ldq  	256,dl
004155  aa  6 00103 1761 00	sbq  	pr6|67		description
004156  aa  6 00100 1161 00	cmpq 	pr6|64		bit_offset
004157  aa   000002 6040 04	tmi  	2,ic		004161
004160  aa  6 00100 2361 00	ldq  	pr6|64		bit_offset
004161  aa  6 00103 7271 00	lxl7 	pr6|67		description
004162  aa  6 00103 0561 00	asq  	pr6|67		description
004163  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
004164  aa  6 00101 00 0006	desc9a	pr6|65,ql		bit_offset
004165  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 686
				     end;

						STATEMENT 1 ON LINE 687
				description = description || " of ";

004166  aa   000400 2360 07	ldq  	256,dl
004167  aa  6 00103 1761 00	sbq  	pr6|67		description
004170  aa   000004 1160 07	cmpq 	4,dl
004171  aa   000002 6040 04	tmi  	2,ic		004173
004172  aa   000004 2360 07	ldq  	4,dl
004173  aa  6 00103 7271 00	lxl7 	pr6|67		description
004174  aa  6 00103 0561 00	asq  	pr6|67		description
004175  aa  040 157 100 444	mlr  	(rl,ic),(pr,rl,x7),fill(040)
004176  aa   773630 00 0006	desc9a	-2152,ql		000025 = 040157146040
004177  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 688
				description = description || description_of_location (stack_frame.entry_ptr);

004200  aa  6 00314 3735 20	epp7 	pr6|204,*		sp
004201  aa  7 00026 3521 00	epp2 	pr7|22		stack_frame.entry_ptr
004202  aa  6 00344 2521 00	spri2	pr6|228
004203  aa  6 00457 3521 00	epp2 	pr6|303
004204  aa  6 00346 2521 00	spri2	pr6|230
004205  aa   000001 7270 07	lxl7 	1,dl
004206  aa  6 00342 6211 00	eax1 	pr6|226
004207  aa   010000 4310 07	fld  	4096,dl
004210  aa   777121 3520 04	epp2 	-431,ic		003331 = 000560627000
004211  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
004212  aa   000400 2360 07	ldq  	256,dl
004213  aa  6 00103 1761 00	sbq  	pr6|67		description
004214  aa  6 00456 1161 00	cmpq 	pr6|302
004215  aa   000002 6040 04	tmi  	2,ic		004217
004216  aa  6 00456 2361 00	ldq  	pr6|302
004217  aa  6 00103 7271 00	lxl7 	pr6|67		description
004220  aa  6 00103 0561 00	asq  	pr6|67		description
004221  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
004222  aa  6 00457 00 0006	desc9a	pr6|303,ql
004223  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 689
				description = description || ")";

004224  aa  6 00103 2361 00	ldq  	pr6|67		description
004225  aa   000400 1160 07	cmpq 	256,dl
004226  aa   000005 6050 04	tpl  	5,ic		004233
004227  aa  6 00103 0541 00	aos  	pr6|67		description
004230  aa  040 106 100 404	mlr  	(ic),(pr,ql),fill(040)
004231  aa   002557 00 0001	desc9a	1391,1		007007 = 051000000000
004232  aa  6 00104 00 0001	desc9a	pr6|68,1		description
						STATEMENT 1 ON LINE 690
			     end;

						STATEMENT 1 ON LINE 691
		     end;

004233  aa   000214 7100 04	tra  	140,ic		004447
						STATEMENT 1 ON LINE 692
		else if index (seg_name, ".area.linker") > 0
		then do;

004234  aa   000040 2360 07	ldq  	32,dl
004235  aa  6 00272 3521 00	epp2 	pr6|186		seg_name
004236  aa  0 01227 7001 00	tsx0 	pr0|663		set_chars_eis
004237  aa   000014 2360 07	ldq  	12,dl
004240  aa   773646 3520 04	epp2 	-2138,ic		000106 = 056141162145
004241  aa  0 01231 7001 00	tsx0 	pr0|665		index_chars_eis
004242  aa   000205 6044 04	tmoz 	133,ic		004447
						STATEMENT 1 ON LINE 694
			sb = stackbaseptr;

004243  aa  6 00000 3531 00	epbp3	pr6|0
004244  aa  6 00316 2535 00	spri3	pr6|206		sb
						STATEMENT 1 ON LINE 695
			vthp = stack_header.sys_link_info_ptr;

004245  aa  3 00060 3715 20	epp5 	pr3|48,*		stack_header.sys_link_info_ptr
004246  aa  6 00306 6515 00	spri5	pr6|198		vthp
						STATEMENT 1 ON LINE 696
			if vthp ^= null
			then do;

004247  aa  6 00306 2371 00	ldaq 	pr6|198		vthp
004250  aa   773624 6770 04	eraq 	-2156,ic		000074 = 077777000043 000001000000
004251  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004252  aa   000175 6000 04	tze  	125,ic		004447
						STATEMENT 1 ON LINE 698
				checking_external_variables = True;

004253  aa   400000 2350 03	lda  	131072,du
004254  aa  6 00102 7551 00	sta  	pr6|66		checking_external_variables
						STATEMENT 1 ON LINE 699
				do hash_table_idx = lbound (vthp -> variable_table_header.hash_table, 1)
				     to hbound (vthp -> variable_table_header.hash_table, 1)
				     while (checking_external_variables);

004255  aa  6 00267 4501 00	stz  	pr6|183		hash_table_idx
004256  aa  6 00267 2361 00	ldq  	pr6|183		hash_table_idx
004257  aa   000077 1160 07	cmpq 	63,dl
004260  aa   000167 6054 04	tpnz 	119,ic		004447
004261  aa  6 00102 2351 00	lda  	pr6|66		checking_external_variables
004262  aa   000165 6000 04	tze  	117,ic		004447
						STATEMENT 1 ON LINE 702
				     do vnp = vthp -> variable_table_header.hash_table (hash_table_idx)
					repeat vnp -> variable_node.forward_thread
					while (vnp ^= null & checking_external_variables);

004263  aa  6 00306 7671 66	lprp7	pr6|198,*ql	variable_table_header.hash_table
004264  aa  6 00304 6535 00	spri7	pr6|196		vnp
004265  aa   000000 0110 03	nop  	0,du
004266  aa  6 00304 2371 00	ldaq 	pr6|196		vnp
004267  aa   773605 6770 04	eraq 	-2171,ic		000074 = 077777000043 000001000000
004270  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004271  aa   000154 6000 04	tze  	108,ic		004445
004272  aa  6 00102 2351 00	lda  	pr6|66		checking_external_variables
004273  aa   000152 6000 04	tze  	106,ic		004445
						STATEMENT 1 ON LINE 705
					if baseno (vnp -> variable_node.vbl_ptr) = baseno (location)
					then if rel (vnp -> variable_node.vbl_ptr) <= rel (location)
						&
						rel (
						addrel (vnp -> variable_node.vbl_ptr,
						vnp -> variable_node.vbl_size))
						> rel (location)
					     then do;

004274  aa  6 00032 3735 20	epp7 	pr6|26,*
004275  aa  7 00002 3715 20	epp5 	pr7|2,*		location
004276  aa  5 00000 3715 20	epp5 	pr5|0,*		location
004277  aa  5 00000 2131 00	epaq 	pr5|0		location
004300  aa   077777 3750 03	ana  	32767,du
004301  aa  6 00321 7551 00	sta  	pr6|209
004302  aa  6 00304 3535 20	epp3 	pr6|196,*		vnp
004303  aa  3 00004 2131 20	epaq 	pr3|4,*		variable_node.vbl_ptr
004304  aa   077777 3750 03	ana  	32767,du
004305  aa  6 00321 1151 00	cmpa 	pr6|209
004306  aa   000134 6010 04	tnz  	92,ic		004442
004307  aa  5 00000 6351 00	eaa  	pr5|0		location
004310  aa  6 00321 7551 00	sta  	pr6|209
004311  aa  3 00004 6351 20	eaa  	pr3|4,*		variable_node.vbl_ptr
004312  aa  6 00321 1151 00	cmpa 	pr6|209
004313  aa   000002 6000 04	tze  	2,ic		004315
004314  aa   000126 6030 04	trc  	86,ic		004442
004315  aa  6 00331 7551 00	sta  	pr6|217
004316  aa  3 00001 2351 00	lda  	pr3|1		variable_node.vbl_size
004317  aa   000060 7730 00	lrl  	48
004320  aa  3 00004 3521 66	epp2 	pr3|4,*ql		variable_node.vbl_ptr
004321  aa   000000 0520 03	adwp2	0,du
004322  aa  2 00000 6351 00	eaa  	pr2|0
004323  aa  6 00321 1151 00	cmpa 	pr6|209
004324  aa   000116 6020 04	tnc  	78,ic		004442
004325  aa   000115 6000 04	tze  	77,ic		004442
						STATEMENT 1 ON LINE 714
						     checking_external_variables = False;

004326  aa  6 00102 4501 00	stz  	pr6|66		checking_external_variables
						STATEMENT 1 ON LINE 715
						     description = description || " (External Variable ";

004327  aa   000400 2360 07	ldq  	256,dl
004330  aa  6 00103 1761 00	sbq  	pr6|67		description
004331  aa   000024 1160 07	cmpq 	20,dl
004332  aa   000002 6040 04	tmi  	2,ic		004334
004333  aa   000024 2360 07	ldq  	20,dl
004334  aa  6 00103 7271 00	lxl7 	pr6|67		description
004335  aa  6 00103 0561 00	asq  	pr6|67		description
004336  aa  040 157 100 444	mlr  	(rl,ic),(pr,rl,x7),fill(040)
004337  aa   773601 00 0006	desc9a	-2175,ql		000137 = 040050105170
004340  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 716
						     description = description || vnp -> variable_node.name;

004341  aa   000400 2360 07	ldq  	256,dl
004342  aa  6 00103 1761 00	sbq  	pr6|67		description
004343  aa  3 00010 1161 00	cmpq 	pr3|8		variable_node.name_size
004344  aa   000002 6040 04	tmi  	2,ic		004346
004345  aa  3 00010 2361 00	ldq  	pr3|8		variable_node.name_size
004346  aa  6 00103 7271 00	lxl7 	pr6|67		description
004347  aa  6 00103 0561 00	asq  	pr6|67		description
004350  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
004351  aa  3 00011 00 0006	desc9a	pr3|9,ql		variable_node.name
004352  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 717
						     if vnp -> variable_node.vbl_ptr ^= location
						     then do;

004353  aa  3 00004 2371 00	ldaq 	pr3|4		variable_node.vbl_ptr
004354  aa  7 00002 6771 20	eraq 	pr7|2,*		location
004355  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004356  aa   000055 6000 04	tze  	45,ic		004433
						STATEMENT 1 ON LINE 719
							     description = description || "|";

004357  aa  6 00103 2361 00	ldq  	pr6|67		description
004360  aa   000400 1160 07	cmpq 	256,dl
004361  aa   000005 6050 04	tpl  	5,ic		004366
004362  aa  6 00103 0541 00	aos  	pr6|67		description
004363  aa  040 106 100 404	mlr  	(ic),(pr,ql),fill(040)
004364  aa   002423 00 0001	desc9a	1299,1		007006 = 174000000000
004365  aa  6 00104 00 0001	desc9a	pr6|68,1		description
						STATEMENT 1 ON LINE 720
							     description =
								description
								||
								octal_representation (
								fixed (rel (location))
								-
								fixed (rel (vnp -> variable_node.vbl_ptr))
								);

004366  aa  6 00331 2351 00	lda  	pr6|217
004367  aa   000066 7730 00	lrl  	54
004370  aa  6 00454 7571 00	staq 	pr6|300
004371  aa  6 00321 2351 00	lda  	pr6|209
004372  aa   000066 7730 00	lrl  	54
004373  aa  6 00454 1771 00	sbaq 	pr6|300
004374  aa  6 00320 7561 00	stq  	pr6|208
004375  aa  6 00454 2521 00	spri2	pr6|300
004376  aa  6 00320 3521 00	epp2 	pr6|208
004377  aa  6 00344 2521 00	spri2	pr6|228
004400  aa  6 00335 3521 00	epp2 	pr6|221
004401  aa  6 00346 2521 00	spri2	pr6|230
004402  aa   000001 7270 07	lxl7 	1,dl
004403  aa  6 00342 6211 00	eax1 	pr6|226
004404  aa   010000 4310 07	fld  	4096,dl
004405  aa   000674 3520 04	epp2 	444,ic		005301 = 000120627000
004406  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
004407  aa   000400 2360 07	ldq  	256,dl
004410  aa  6 00103 1761 00	sbq  	pr6|67		description
004411  aa  6 00334 1161 00	cmpq 	pr6|220
004412  aa   000002 6040 04	tmi  	2,ic		004414
004413  aa  6 00334 2361 00	ldq  	pr6|220
004414  aa  6 00103 7271 00	lxl7 	pr6|67		description
004415  aa  6 00103 0561 00	asq  	pr6|67		description
004416  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
004417  aa  6 00335 00 0006	desc9a	pr6|221,ql
004420  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 728
							     description = description || bit_offset;

004421  aa   000400 2360 07	ldq  	256,dl
004422  aa  6 00103 1761 00	sbq  	pr6|67		description
004423  aa  6 00100 1161 00	cmpq 	pr6|64		bit_offset
004424  aa   000002 6040 04	tmi  	2,ic		004426
004425  aa  6 00100 2361 00	ldq  	pr6|64		bit_offset
004426  aa  6 00103 7271 00	lxl7 	pr6|67		description
004427  aa  6 00103 0561 00	asq  	pr6|67		description
004430  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
004431  aa  6 00101 00 0006	desc9a	pr6|65,ql		bit_offset
004432  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
						STATEMENT 1 ON LINE 729
							end;

						STATEMENT 1 ON LINE 730
						     description = description || ")";

004433  aa  6 00103 2361 00	ldq  	pr6|67		description
004434  aa   000400 1160 07	cmpq 	256,dl
004435  aa   000005 6050 04	tpl  	5,ic		004442
004436  aa  6 00103 0541 00	aos  	pr6|67		description
004437  aa  040 106 100 404	mlr  	(ic),(pr,ql),fill(040)
004440  aa   002350 00 0001	desc9a	1256,1		007007 = 051000000000
004441  aa  6 00104 00 0001	desc9a	pr6|68,1		description
						STATEMENT 1 ON LINE 731
						end;

						STATEMENT 1 ON LINE 732
				     end;

004442  aa  6 00304 7671 20	lprp7	pr6|196,*		variable_node.forward_thread
004443  aa  6 00304 6535 00	spri7	pr6|196		vnp
004444  aa   777622 7100 04	tra  	-110,ic		004266
						STATEMENT 1 ON LINE 733
				end;

004445  aa  6 00267 0541 00	aos  	pr6|183		hash_table_idx
004446  aa   777610 7100 04	tra  	-120,ic		004256
						STATEMENT 1 ON LINE 734
			     end;

						STATEMENT 1 ON LINE 735
		     end;

						STATEMENT 1 ON LINE 736
	     end;

						STATEMENT 1 ON LINE 737
	return (description);

004447  aa  6 00103 2361 00	ldq  	pr6|67		description
004450  aa  6 00032 3735 20	epp7 	pr6|26,*
004451  aa  7 00004 3715 20	epp5 	pr7|4,*
004452  aa  5 77777 7561 00	stq  	pr5|-1
004453  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
004454  aa  6 00104 00 0006	desc9a	pr6|68,ql		description
004455  aa  5 00000 00 0006	desc9a	pr5|0,ql
004456  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 743
     end description_of_location;

  END PROCEDURE description_of_location
BEGIN PROCEDURE get_fsm_dir_dir_path
ENTRY TO get_fsm_dir_dir_path                               STATEMENT 1 ON LINE 745
get_fsm_dir_dir_path:
     proc (fsm_dir_dir_path);

004457  aa  6 00242 6501 00	spri4	pr6|162
004460  aa  6 00244 2521 00	spri2	pr6|164
004461  aa  2 00002 3521 01	epp2 	pr2|2,au
004462  aa  6 00246 2521 00	spri2	pr6|166
004463  aa  2 00000 2361 20	ldq  	pr2|0,*
004464  aa   000002 6040 04	tmi  	2,ic		004466
004465  aa   777777 3760 07	anq  	262143,dl
004466  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
004467  aa  6 00714 7561 00	stq  	pr6|460
						STATEMENT 1 ON LINE 778
	fsm_dir_dir_path = "";

004470  aa  6 00244 3735 20	epp7 	pr6|164,*
004471  aa  7 00002 3715 20	epp5 	pr7|2,*
004472  aa  040 140 100 400	mlr  	(),(pr,rl),fill(040)
004473  aa   000000 00 0000	desc9a	0,0
004474  aa  5 00000 00 0006	desc9a	pr5|0,ql		fsm_dir_dir_path
						STATEMENT 1 ON LINE 779
	do while (fsm_dir_dir_path = "");

004475  aa   000000 0110 03	nop  	0,du
004476  aa  6 00244 3735 20	epp7 	pr6|164,*
004477  aa  7 00002 3715 20	epp5 	pr7|2,*
004500  aa  6 00714 2351 00	lda  	pr6|460
004501  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
004502  aa  5 00000 00 0005	desc9a	pr5|0,al		fsm_dir_dir_path
004503  aa   002303 00 0000	desc9a	1219,0		007004 = 044000000000
004504  aa   000141 6010 04	tnz  	97,ic		004645
						STATEMENT 1 ON LINE 780
	     call value_$get (null, "11"b, "fsm_dir_dir_path", fsm_dir_dir_path, status);

004505  aa   773367 3534 24	epp3 	-2313,ic*
004506  aa  6 00716 2535 00	spri3	pr6|462
004507  aa   600000 2350 03	lda  	196608,du
004510  aa  6 00715 7551 00	sta  	pr6|461
004511  aa   773406 2350 04	lda  	-2298,ic		000117 = 146163155137
004512  aa   773406 2360 04	ldq  	-2298,ic		000120 = 144151162137
004513  aa  6 00720 7571 00	staq 	pr6|464
004514  aa   773405 2350 04	lda  	-2299,ic		000121 = 144151162137
004515  aa   773405 2360 04	ldq  	-2299,ic		000122 = 160141164150
004516  aa  6 00722 7571 00	staq 	pr6|466
004517  aa  6 00716 3521 00	epp2 	pr6|462
004520  aa  6 00726 2521 00	spri2	pr6|470
004521  aa  6 00715 3521 00	epp2 	pr6|461
004522  aa  6 00730 2521 00	spri2	pr6|472
004523  aa  6 00720 3521 00	epp2 	pr6|464
004524  aa  6 00732 2521 00	spri2	pr6|474
004525  aa  7 00002 3521 20	epp2 	pr7|2,*		fsm_dir_dir_path
004526  aa  6 00734 2521 00	spri2	pr6|476
004527  aa  6 00250 3521 00	epp2 	pr6|168		status
004530  aa  6 00736 2521 00	spri2	pr6|478
004531  aa   773325 3520 04	epp2 	-2347,ic		000056 = 464000000000
004532  aa  6 00740 2521 00	spri2	pr6|480
004533  aa   773326 3520 04	epp2 	-2346,ic		000061 = 514000000044
004534  aa  6 00742 2521 00	spri2	pr6|482
004535  aa   773266 3520 04	epp2 	-2378,ic		000023 = 524000000020
004536  aa  6 00744 2521 00	spri2	pr6|484
004537  aa  6 00246 3515 20	epp1 	pr6|166,*
004540  aa  1 00000 3521 20	epp2 	pr1|0,*
004541  aa  6 00746 2521 00	spri2	pr6|486
004542  aa   773302 3520 04	epp2 	-2366,ic		000044 = 404000000043
004543  aa  6 00750 2521 00	spri2	pr6|488
004544  aa  6 00724 6211 00	eax1 	pr6|468
004545  aa   024000 4310 07	fld  	10240,dl
004546  aa  6 00044 3701 20	epp4 	pr6|36,*
004547  la  4 00236 3521 20	epp2 	pr4|158,*		value_$get
004550  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 781
	     if fsm_dir_dir_path = ""
	     then fsm_dir_dir_path = get_pdir_ ();

004551  aa  6 00244 3735 20	epp7 	pr6|164,*
004552  aa  7 00002 3715 20	epp5 	pr7|2,*
004553  aa  6 00714 2351 00	lda  	pr6|460
004554  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
004555  aa  5 00000 00 0005	desc9a	pr5|0,al		fsm_dir_dir_path
004556  aa   002230 00 0000	desc9a	1176,0		007004 = 044000000000
004557  aa   000017 6010 04	tnz  	15,ic		004576
004560  aa  6 00752 3521 00	epp2 	pr6|490
004561  aa  6 00722 2521 00	spri2	pr6|466
004562  aa  6 00720 6211 00	eax1 	pr6|464
004563  aa   004000 4310 07	fld  	2048,dl
004564  aa  6 00044 3701 20	epp4 	pr6|36,*
004565  la  4 00234 3521 20	epp2 	pr4|156,*		get_pdir_
004566  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
004567  aa  6 00244 3735 20	epp7 	pr6|164,*
004570  aa  7 00002 3715 20	epp5 	pr7|2,*
004571  aa  6 00714 2351 00	lda  	pr6|460
004572  aa  040 140 100 500	mlr  	(pr),(pr,rl),fill(040)
004573  aa  6 00752 00 0250	desc9a	pr6|490,168
004574  aa  5 00000 00 0005	desc9a	pr5|0,al		fsm_dir_dir_path
004575  aa   777701 7100 04	tra  	-63,ic		004476
						STATEMENT 1 ON LINE 783
	     else if substr (fsm_dir_dir_path, 1, 1) ^= ">"
	     then do;

004576  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
004577  aa  5 00000 00 0001	desc9a	pr5|0,1		fsm_dir_dir_path
004600  aa   002207 00 0001	desc9a	1159,1		007005 = 076000000000
004601  aa   777675 6000 04	tze  	-67,ic		004476
						STATEMENT 1 ON LINE 785
		     call signal_fsm_error (error_table_$not_abs_path,
			"Value segment specifies 'fsm_dir_dir_path' = " || fsm_dir_dir_path);

004602  aa   000055 2360 07	ldq  	45,dl
004603  aa  6 00714 0761 00	adq  	pr6|460
004604  aa  6 01024 7561 00	stq  	pr6|532
004605  aa   524000 2760 03	orq  	174080,du
004606  aa  6 00715 7561 00	stq  	pr6|461
004607  aa  6 01024 2361 00	ldq  	pr6|532
004610  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
004611  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
004612  aa   773422 00 0055	desc9a	-2286,45		000233 = 126141154165
004613  aa  2 00000 00 0055	desc9a	pr2|0,45
004614  aa  6 00714 2351 00	lda  	pr6|460
004615  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
004616  aa  5 00000 00 0005	desc9a	pr5|0,al		fsm_dir_dir_path
004617  aa  2 00013 20 0005	desc9a	pr2|11(1),al
004620  aa  6 00730 2521 00	spri2	pr6|472
004621  aa  6 00044 3701 20	epp4 	pr6|36,*
004622  la  4 00232 3521 20	epp2 	pr4|154,*		error_table_$not_abs_path
004623  aa  6 00726 2521 00	spri2	pr6|470
004624  aa   773220 3520 04	epp2 	-2416,ic		000044 = 404000000043
004625  aa  6 00734 2521 00	spri2	pr6|476
004626  aa  6 00715 3521 00	epp2 	pr6|461
004627  aa  6 00736 2521 00	spri2	pr6|478
004630  aa   000001 7270 07	lxl7 	1,dl
004631  aa  6 00724 6211 00	eax1 	pr6|468
004632  aa   010000 4310 07	fld  	4096,dl
004633  aa   001615 3520 04	epp2 	909,ic		006450 = 000260627000
004634  aa  0 00626 7001 00	tsx0 	pr0|406		call_int_other_desc
						STATEMENT 1 ON LINE 787
		     fsm_dir_dir_path = "";

004635  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
004636  aa  6 00244 3735 20	epp7 	pr6|164,*
004637  aa  7 00002 3715 20	epp5 	pr7|2,*
004640  aa  6 00714 2351 00	lda  	pr6|460
004641  aa  040 140 100 400	mlr  	(),(pr,rl),fill(040)
004642  aa   000000 00 0000	desc9a	0,0
004643  aa  5 00000 00 0005	desc9a	pr5|0,al		fsm_dir_dir_path
						STATEMENT 1 ON LINE 788
		end;

						STATEMENT 1 ON LINE 789
	end;

004644  aa   777632 7100 04	tra  	-102,ic		004476
						STATEMENT 1 ON LINE 790
     end get_fsm_dir_dir_path;

004645  aa  6 00242 6101 00	rtcd 	pr6|162
  END PROCEDURE get_fsm_dir_dir_path
BEGIN PROCEDURE list_groups
ENTRY TO list_groups                                        STATEMENT 1 ON LINE 792
list_groups:
     proc (max_group_cnt, desired_process);

004646  da     000652200000
004647  aa   000300 6270 00	eax7 	192
004650  aa  7 00034 3521 20	epp2 	pr7|28,*
004651  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
004652  aa     000004000000
004653  aa     000000000000
004654  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
						STATEMENT 1 ON LINE 818
004655  aa  6 00032 3735 20	epp7 	pr6|26,*
004656  aa  7 00002 2361 20	ldq  	pr7|2,*		max_group_cnt
004657  aa  6 00126 7561 00	stq  	pr6|86
004660  aa   000001 7360 00	qls  	1
004661  aa  0 00661 7001 00	tsx0 	pr0|433		alloc_auto_adj
004662  aa  6 00124 2521 00	spri2	pr6|84
						STATEMENT 1 ON LINE 837
	group_cnt = 0;

004663  aa  6 00103 4501 00	stz  	pr6|67		group_cnt
						STATEMENT 1 ON LINE 838
	do seg_idx = 1 to fsm_info.seg_cnt while (group_cnt < max_group_cnt);

004664  ia  4 00134 3715 20	epp5 	pr4|92,*		fsm_info_ptr
004665  aa  5 00001 2361 00	ldq  	pr5|1		fsm_info.seg_cnt
004666  aa  6 00127 7561 00	stq  	pr6|87
004667  aa   000001 2360 07	ldq  	1,dl
004670  aa  6 00121 7561 00	stq  	pr6|81		seg_idx
004671  aa   000000 0110 03	nop  	0,du
004672  aa  6 00121 2361 00	ldq  	pr6|81		seg_idx
004673  aa  6 00127 1161 00	cmpq 	pr6|87
004674  aa   000034 6054 04	tpnz 	28,ic		004730
004675  aa  6 00103 2361 00	ldq  	pr6|67		group_cnt
004676  aa  6 00032 3735 20	epp7 	pr6|26,*
004677  aa  7 00002 1161 20	cmpq 	pr7|2,*		max_group_cnt
004700  aa   000030 6050 04	tpl  	24,ic		004730
						STATEMENT 1 ON LINE 839
	     if fsm_info.seg (seg_idx).owning_process = desired_process
		& fsm_info.seg (seg_idx).first_seg_in_group = seg_idx
	     then do;

004701  aa  6 00121 2361 00	ldq  	pr6|81		seg_idx
004702  aa   000005 4020 07	mpy  	5,dl
004703  aa  6 00044 3701 20	epp4 	pr6|36,*
004704  ia  4 00134 3715 20	epp5 	pr4|92,*		fsm_info_ptr
004705  aa  5 77775 2351 06	lda  	pr5|-3,ql		fsm_info.owning_process
004706  aa  7 00004 1151 20	cmpa 	pr7|4,*		desired_process
004707  aa  6 00133 7561 00	stq  	pr6|91
004710  aa   000016 6010 04	tnz  	14,ic		004726
004711  aa  5 77777 2361 06	ldq  	pr5|-1,ql		fsm_info.first_seg_in_group
004712  aa  6 00121 1161 00	cmpq 	pr6|81		seg_idx
004713  aa   000013 6010 04	tnz  	11,ic		004726
						STATEMENT 1 ON LINE 842
		     group_cnt = group_cnt + 1;

004714  aa  6 00103 0541 00	aos  	pr6|67		group_cnt
						STATEMENT 1 ON LINE 843
		     group (group_cnt).owner = fsm_info.owner (seg_idx);

004715  aa  6 00103 2361 00	ldq  	pr6|67		group_cnt
004716  aa   000001 7360 00	qls  	1
004717  aa  6 00133 7271 00	lxl7 	pr6|91
004720  aa   000000 6260 06	eax6 	0,ql
004721  aa  5 77776 2361 17	ldq  	pr5|-2,7		fsm_info.owner
004722  aa  6 00124 3535 20	epp3 	pr6|84,*
004723  aa  3 77776 7561 16	stq  	pr3|-2,6		group.owner
						STATEMENT 1 ON LINE 844
		     group (group_cnt).first_seg_in_group = fsm_info.first_seg_in_group (seg_idx);

004724  aa  5 77777 2361 17	ldq  	pr5|-1,7		fsm_info.first_seg_in_group
004725  aa  3 77777 7561 16	stq  	pr3|-1,6		group.first_seg_in_group
						STATEMENT 1 ON LINE 845
		end;

						STATEMENT 1 ON LINE 846
	end;

004726  aa  6 00121 0541 00	aos  	pr6|81		seg_idx
004727  aa   777743 7100 04	tra  	-29,ic		004672
						STATEMENT 1 ON LINE 851
	do group_idx = 1 to group_cnt - 1;

004730  aa  6 00103 2361 00	ldq  	pr6|67		group_cnt
004731  aa   000001 1760 07	sbq  	1,dl
004732  aa  6 00130 7561 00	stq  	pr6|88
004733  aa   000001 2360 07	ldq  	1,dl
004734  aa  6 00104 7561 00	stq  	pr6|68		group_idx
004735  aa   000000 0110 03	nop  	0,du
004736  aa  6 00104 2361 00	ldq  	pr6|68		group_idx
004737  aa  6 00130 1161 00	cmpq 	pr6|88
004740  aa   000063 6054 04	tpnz 	51,ic		005023
						STATEMENT 1 ON LINE 852
	     expected_group = group (group_idx);

004741  aa   000001 7360 00	qls  	1
004742  aa   000000 6270 06	eax7 	0,ql
004743  aa  6 00124 3735 20	epp7 	pr6|84,*
004744  aa  7 77776 2351 17	lda  	pr7|-2,7		group
004745  aa  7 77777 2361 17	ldq  	pr7|-1,7		group
004746  aa  6 00100 7571 00	staq 	pr6|64		expected_group
						STATEMENT 1 ON LINE 853
	     expected_group_idx = group_idx;

004747  aa  6 00104 2361 00	ldq  	pr6|68		group_idx
004750  aa  6 00102 7561 00	stq  	pr6|66		expected_group_idx
						STATEMENT 1 ON LINE 854
	     do trial_group_idx = group_idx + 1 to group_cnt;

004751  aa  6 00103 2361 00	ldq  	pr6|67		group_cnt
004752  aa  6 00131 7561 00	stq  	pr6|89
004753  aa  6 00104 2361 00	ldq  	pr6|68		group_idx
004754  aa   000001 0760 07	adq  	1,dl
004755  aa  6 00123 7561 00	stq  	pr6|83		trial_group_idx
004756  aa  6 00123 2361 00	ldq  	pr6|83		trial_group_idx
004757  aa  6 00131 1161 00	cmpq 	pr6|89
004760  aa   000020 6054 04	tpnz 	16,ic		005000
						STATEMENT 1 ON LINE 855
		if unspec (group (trial_group_idx)) < unspec (expected_group)
		then do;

004761  aa   000001 7360 00	qls  	1
004762  aa  6 00124 3735 20	epp7 	pr6|84,*
004763  aa  6 00133 7561 00	stq  	pr6|91
004764  aa  7 77776 2351 06	lda  	pr7|-2,ql
004765  aa  7 77777 2361 06	ldq  	pr7|-1,ql
004766  aa  6 00100 1171 00	cmpaq	pr6|64
004767  aa   000007 6030 04	trc  	7,ic		004776
						STATEMENT 1 ON LINE 857
			expected_group = group (trial_group_idx);

004770  aa  6 00133 7271 00	lxl7 	pr6|91
004771  aa  7 77776 2351 17	lda  	pr7|-2,7		group
004772  aa  7 77777 2361 17	ldq  	pr7|-1,7		group
004773  aa  6 00100 7571 00	staq 	pr6|64		expected_group
						STATEMENT 1 ON LINE 858
			expected_group_idx = trial_group_idx;

004774  aa  6 00123 2361 00	ldq  	pr6|83		trial_group_idx
004775  aa  6 00102 7561 00	stq  	pr6|66		expected_group_idx
						STATEMENT 1 ON LINE 859
		     end;

						STATEMENT 1 ON LINE 860
	     end;

004776  aa  6 00123 0541 00	aos  	pr6|83		trial_group_idx
004777  aa   777757 7100 04	tra  	-17,ic		004756
						STATEMENT 1 ON LINE 861
	     if group_idx ^= expected_group_idx
	     then do;

005000  aa  6 00104 2361 00	ldq  	pr6|68		group_idx
005001  aa  6 00102 1161 00	cmpq 	pr6|66		expected_group_idx
005002  aa   000017 6000 04	tze  	15,ic		005021
						STATEMENT 1 ON LINE 863
		     group (expected_group_idx) = group (group_idx);

005003  aa  6 00102 2361 00	ldq  	pr6|66		expected_group_idx
005004  aa   000001 7360 00	qls  	1
005005  aa   000000 6270 06	eax7 	0,ql
005006  aa  6 00104 2361 00	ldq  	pr6|68		group_idx
005007  aa   000001 7360 00	qls  	1
005010  aa   000000 6260 06	eax6 	0,ql
005011  aa  6 00124 3735 20	epp7 	pr6|84,*
005012  aa  7 77776 2351 16	lda  	pr7|-2,6		group
005013  aa  7 77777 2361 16	ldq  	pr7|-1,6		group
005014  aa  7 77776 7551 17	sta  	pr7|-2,7		group
005015  aa  7 77777 7561 17	stq  	pr7|-1,7		group
						STATEMENT 1 ON LINE 864
		     group (group_idx) = expected_group;

005016  aa  6 00100 2371 00	ldaq 	pr6|64		expected_group
005017  aa  7 77776 7551 16	sta  	pr7|-2,6		group
005020  aa  7 77777 7561 16	stq  	pr7|-1,6		group
						STATEMENT 1 ON LINE 865
		end;

						STATEMENT 1 ON LINE 866
	end;

005021  aa  6 00104 0541 00	aos  	pr6|68		group_idx
005022  aa   777714 7100 04	tra  	-52,ic		004736
						STATEMENT 1 ON LINE 870
	max_line_len = get_line_length_$stream ("user_output", status);

005023  aa   773060 2350 04	lda  	-2512,ic		000103 = 165163145162
005024  aa   773060 2360 04	ldq  	-2512,ic		000104 = 137157165164
005025  aa  6 00136 7571 00	staq 	pr6|94
005026  aa   773057 2350 04	lda  	-2513,ic		000105 = 160165164000
005027  aa  6 00140 7551 00	sta  	pr6|96
005030  aa  6 00136 3521 00	epp2 	pr6|94
005031  aa  6 00144 2521 00	spri2	pr6|100
005032  aa  6 00122 3521 00	epp2 	pr6|82		status
005033  aa  6 00146 2521 00	spri2	pr6|102
005034  aa  6 00106 3521 00	epp2 	pr6|70		max_line_len
005035  aa  6 00150 2521 00	spri2	pr6|104
005036  aa   772764 3520 04	epp2 	-2572,ic		000022 = 524000000013
005037  aa  6 00152 2521 00	spri2	pr6|106
005040  aa   773004 3520 04	epp2 	-2556,ic		000044 = 404000000043
005041  aa  6 00154 2521 00	spri2	pr6|108
005042  aa   773015 3520 04	epp2 	-2547,ic		000057 = 404000000021
005043  aa  6 00156 2521 00	spri2	pr6|110
005044  aa  6 00142 6211 00	eax1 	pr6|98
005045  aa   014000 4310 07	fld  	6144,dl
005046  aa  6 00044 3701 20	epp4 	pr6|36,*
005047  la  4 00240 3521 20	epp2 	pr4|160,*		get_line_length_$stream
005050  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 871
	unspec (prev_group_owner) = ""b;

005051  aa  6 00120 4501 00	stz  	pr6|80
						STATEMENT 1 ON LINE 872
	do group_idx = 1 to group_cnt;

005052  aa  6 00103 2361 00	ldq  	pr6|67		group_cnt
005053  aa  6 00132 7561 00	stq  	pr6|90
005054  aa   000001 2360 07	ldq  	1,dl
005055  aa  6 00104 7561 00	stq  	pr6|68		group_idx
005056  aa  6 00104 2361 00	ldq  	pr6|68		group_idx
005057  aa  6 00132 1161 00	cmpq 	pr6|90
005060  aa   000217 6054 04	tpnz 	143,ic		005277
						STATEMENT 1 ON LINE 873
	     if group (group_idx).owner ^= prev_group_owner
	     then do;

005061  aa   000001 7360 00	qls  	1
005062  aa  6 00124 3735 20	epp7 	pr6|84,*
005063  aa  6 00141 7561 00	stq  	pr6|97
005064  aa  7 77776 2361 06	ldq  	pr7|-2,ql		group.owner
005065  aa  6 00120 1161 00	cmpq 	pr6|80		prev_group_owner
005066  aa   000036 6000 04	tze  	30,ic		005124
						STATEMENT 1 ON LINE 875
		     prev_group_owner = group (group_idx).owner;

005067  aa  6 00120 7561 00	stq  	pr6|80		prev_group_owner
						STATEMENT 1 ON LINE 876
		     call ioa_$nnl ("^/^a owns:^/", description_of_location ((prev_group_owner)));

005070  aa   773010 2370 04	ldaq 	-2552,ic		000100 = 136057136141 040157167156
005071  aa  6 00136 7571 00	staq 	pr6|94
005072  aa   773010 2350 04	lda  	-2552,ic		000102 = 163072136057
005073  aa  6 00140 7551 00	sta  	pr6|96
005074  aa  6 00120 7651 00	lprp5	pr6|80		prev_group_owner
005075  aa  6 00160 6515 00	spri5	pr6|112
005076  aa  6 00160 3521 00	epp2 	pr6|112
005077  aa  6 00144 2521 00	spri2	pr6|100
005100  aa  6 00163 3521 00	epp2 	pr6|115
005101  aa  6 00146 2521 00	spri2	pr6|102
005102  aa   000001 7270 07	lxl7 	1,dl
005103  aa  6 00142 6211 00	eax1 	pr6|98
005104  aa   010000 4310 07	fld  	4096,dl
005105  aa   776224 3520 04	epp2 	-876,ic		003331 = 000560627000
005106  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
005107  aa  6 00136 3521 00	epp2 	pr6|94
005110  aa  6 00144 2521 00	spri2	pr6|100
005111  aa  6 00163 3521 00	epp2 	pr6|115
005112  aa  6 00146 2521 00	spri2	pr6|102
005113  aa   772706 3520 04	epp2 	-2618,ic		000021 = 524000000014
005114  aa  6 00150 2521 00	spri2	pr6|104
005115  aa   772737 3520 04	epp2 	-2593,ic		000054 = 530000000400
005116  aa  6 00152 2521 00	spri2	pr6|106
005117  aa  6 00142 6211 00	eax1 	pr6|98
005120  aa   010000 4310 07	fld  	4096,dl
005121  aa  6 00044 3701 20	epp4 	pr6|36,*
005122  la  4 00242 3521 20	epp2 	pr4|162,*		ioa_$nnl
005123  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 877
		end;

						STATEMENT 1 ON LINE 878
	     call ioa_$nnl ("^4x");

005124  aa   772674 2350 04	lda  	-2628,ic		000020 = 136064170000
005125  aa  6 00141 7551 00	sta  	pr6|97
005126  aa  6 00141 3521 00	epp2 	pr6|97
005127  aa  6 00144 2521 00	spri2	pr6|100
005130  aa   772667 3520 04	epp2 	-2633,ic		000017 = 524000000003
005131  aa  6 00146 2521 00	spri2	pr6|102
005132  aa  6 00142 6211 00	eax1 	pr6|98
005133  aa   004000 4310 07	fld  	2048,dl
005134  aa  6 00044 3701 20	epp4 	pr6|36,*
005135  la  4 00242 3521 20	epp2 	pr4|162,*		ioa_$nnl
005136  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 879
	     line_len = 4;

005137  aa   000004 2360 07	ldq  	4,dl
005140  aa  6 00105 7561 00	stq  	pr6|69		line_len
						STATEMENT 1 ON LINE 880
	     do seg_idx = group (group_idx).first_seg_in_group repeat fsm_info.next_seg_in_group (seg_idx)
		while (seg_idx ^= 0);

005141  aa  6 00104 2361 00	ldq  	pr6|68		group_idx
005142  aa   000001 7360 00	qls  	1
005143  aa  6 00124 3735 20	epp7 	pr6|84,*
005144  aa  7 77777 2361 06	ldq  	pr7|-1,ql		group.first_seg_in_group
005145  aa  6 00121 7561 00	stq  	pr6|81		seg_idx
005146  aa  6 00121 2361 00	ldq  	pr6|81		seg_idx
005147  aa   000113 6000 04	tze  	75,ic		005262
						STATEMENT 1 ON LINE 882
		name = rtrim (seg_name (seg_idx));

005150  aa  6 00121 3521 00	epp2 	pr6|81		seg_idx
005151  aa  6 00164 2521 00	spri2	pr6|116
005152  aa  6 00142 3521 00	epp2 	pr6|98
005153  aa  6 00166 2521 00	spri2	pr6|118
005154  aa   000001 7270 07	lxl7 	1,dl
005155  aa  6 00162 6211 00	eax1 	pr6|114
005156  aa   010000 4310 07	fld  	4096,dl
005157  aa   001155 3520 04	epp2 	621,ic		006334 = 000120627000
005160  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
005161  aa  000 000 165 500	tctr 	(pr)
005162  aa  6 00142 00 0040	desc9a	pr6|98,32
005163  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
005164  aa  6 00056 0001 00	arg  	pr6|46
005165  aa  6 00056 2361 00	ldq  	pr6|46
005166  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
005167  aa  6 00141 7561 00	stq  	pr6|97
005170  aa   000040 2360 07	ldq  	32,dl
005171  aa  6 00141 1761 00	sbq  	pr6|97
005172  aa   000040 1160 07	cmpq 	32,dl
005173  aa   000002 6040 04	tmi  	2,ic		005175
005174  aa   000040 2360 07	ldq  	32,dl
005175  aa  6 00107 7561 00	stq  	pr6|71		name
005176  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
005177  aa  6 00142 00 0006	desc9a	pr6|98,ql
005200  aa  6 00110 00 0006	desc9a	pr6|72,ql		name
						STATEMENT 1 ON LINE 883
		if line_len + 1 + length (name) <= max_line_len
		then do;

005201  aa  6 00105 2361 00	ldq  	pr6|69		line_len
005202  aa   000001 0760 07	adq  	1,dl
005203  aa  6 00141 7561 00	stq  	pr6|97
005204  aa  6 00107 0761 00	adq  	pr6|71		name
005205  aa  6 00106 1161 00	cmpq 	pr6|70		max_line_len
005206  aa   000024 6054 04	tpnz 	20,ic		005232
						STATEMENT 1 ON LINE 885
			line_len = line_len + 1 + length (name);

005207  aa  6 00141 2361 00	ldq  	pr6|97
005210  aa  6 00107 0761 00	adq  	pr6|71		name
005211  aa  6 00105 7561 00	stq  	pr6|69		line_len
						STATEMENT 1 ON LINE 886
			call ioa_$nnl (" ^a", name);

005212  aa   772604 2350 04	lda  	-2684,ic		000016 = 040136141000
005213  aa  6 00141 7551 00	sta  	pr6|97
005214  aa  6 00141 3521 00	epp2 	pr6|97
005215  aa  6 00144 2521 00	spri2	pr6|100
005216  aa  6 00110 3521 00	epp2 	pr6|72		name
005217  aa  6 00146 2521 00	spri2	pr6|102
005220  aa   772577 3520 04	epp2 	-2689,ic		000017 = 524000000003
005221  aa  6 00150 2521 00	spri2	pr6|104
005222  aa   772573 3520 04	epp2 	-2693,ic		000015 = 530000000040
005223  aa  6 00152 2521 00	spri2	pr6|106
005224  aa  6 00142 6211 00	eax1 	pr6|98
005225  aa   010000 4310 07	fld  	4096,dl
005226  aa  6 00044 3701 20	epp4 	pr6|36,*
005227  la  4 00242 3521 20	epp2 	pr4|162,*		ioa_$nnl
005230  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 887
		     end;

005231  aa   000023 7100 04	tra  	19,ic		005254
						STATEMENT 1 ON LINE 888
		else do;

						STATEMENT 1 ON LINE 889
			line_len = 10 + length (name);

005232  aa   000012 2360 07	ldq  	10,dl
005233  aa  6 00107 0761 00	adq  	pr6|71		name
005234  aa  6 00105 7561 00	stq  	pr6|69		line_len
						STATEMENT 1 ON LINE 890
			call ioa_$nnl ("^/^-^a", name);

005235  aa   772631 2370 04	ldaq 	-2663,ic		000066 = 136057136055 136141000000
005236  aa  6 00160 7571 00	staq 	pr6|112
005237  aa  6 00160 3521 00	epp2 	pr6|112
005240  aa  6 00144 2521 00	spri2	pr6|100
005241  aa  6 00110 3521 00	epp2 	pr6|72		name
005242  aa  6 00146 2521 00	spri2	pr6|102
005243  aa   772567 3520 04	epp2 	-2697,ic		000032 = 524000000006
005244  aa  6 00150 2521 00	spri2	pr6|104
005245  aa   772550 3520 04	epp2 	-2712,ic		000015 = 530000000040
005246  aa  6 00152 2521 00	spri2	pr6|106
005247  aa  6 00142 6211 00	eax1 	pr6|98
005250  aa   010000 4310 07	fld  	4096,dl
005251  aa  6 00044 3701 20	epp4 	pr6|36,*
005252  la  4 00242 3521 20	epp2 	pr4|162,*		ioa_$nnl
005253  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 891
		     end;

						STATEMENT 1 ON LINE 892
	     end;

005254  aa  6 00121 2361 00	ldq  	pr6|81		seg_idx
005255  aa   000005 4020 07	mpy  	5,dl
005256  aa  6 00044 3701 20	epp4 	pr6|36,*
005257  ia  4 00134 2361 66	ldq  	pr4|92,*ql	fsm_info.next_seg_in_group
005260  aa  6 00121 7561 00	stq  	pr6|81		seg_idx
005261  aa   777665 7100 04	tra  	-75,ic		005146
						STATEMENT 1 ON LINE 893
	     call ioa_$nnl ("^/");

005262  aa   136057 2350 03	lda  	48175,du
005263  aa  6 00141 7551 00	sta  	pr6|97
005264  aa  6 00141 3521 00	epp2 	pr6|97
005265  aa  6 00144 2521 00	spri2	pr6|100
005266  aa   772525 3520 04	epp2 	-2731,ic		000013 = 524000000002
005267  aa  6 00146 2521 00	spri2	pr6|102
005270  aa  6 00142 6211 00	eax1 	pr6|98
005271  aa   004000 4310 07	fld  	2048,dl
005272  aa  6 00044 3701 20	epp4 	pr6|36,*
005273  la  4 00242 3521 20	epp2 	pr4|162,*		ioa_$nnl
005274  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 894
	end;

005275  aa  6 00104 0541 00	aos  	pr6|68		group_idx
005276  aa   777560 7100 04	tra  	-144,ic		005056
						STATEMENT 1 ON LINE 896
     end list_groups;

005277  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END PROCEDURE list_groups
BEGIN PROCEDURE octal_representation
ENTRY TO octal_representation                               STATEMENT 1 ON LINE 898
octal_representation:
     proc (value) returns (char (12) varying);

005300  da     000663220000
005301  aa   000120 6270 00	eax7 	80
005302  aa  7 00034 3521 20	epp2 	pr7|28,*
005303  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
005304  aa     000004000000
005305  aa     000000000000
005306  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
						STATEMENT 1 ON LINE 914
	call cv_bin_$oct (value, string);

005307  aa  6 00032 3735 20	epp7 	pr6|26,*
005310  aa  7 00002 3521 20	epp2 	pr7|2,*		value
005311  aa  6 00106 2521 00	spri2	pr6|70
005312  aa  6 00100 3521 00	epp2 	pr6|64		string
005313  aa  6 00110 2521 00	spri2	pr6|72
005314  aa  6 00104 6211 00	eax1 	pr6|68
005315  aa   010000 4310 07	fld  	4096,dl
005316  la  4 00244 3521 20	epp2 	pr4|164,*		cv_bin_$oct
005317  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 915
	return (ltrim (string));

005320  aa  000 000 164 500	tct  	(pr)
005321  aa  6 00100 00 0014	desc9a	pr6|64,12		string
005322  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
005323  aa  6 00056 0001 00	arg  	pr6|46
005324  aa  6 00056 2361 00	ldq  	pr6|46
005325  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
005326  aa  6 00103 7561 00	stq  	pr6|67
005327  aa   000014 2360 07	ldq  	12,dl
005330  aa  6 00103 1761 00	sbq  	pr6|67
005331  aa   000014 1160 07	cmpq 	12,dl
005332  aa   000002 6040 04	tmi  	2,ic		005334
005333  aa   000014 2360 07	ldq  	12,dl
005334  aa  6 00103 2351 00	lda  	pr6|67
005335  aa  6 00032 3735 20	epp7 	pr6|26,*
005336  aa  7 00004 3715 20	epp5 	pr7|4,*
005337  aa  5 77777 7561 00	stq  	pr5|-1
005340  aa  040 140 100 545	mlr  	(pr,rl,al),(pr,rl),fill(040)
005341  aa  6 00100 00 0006	desc9a	pr6|64,ql		string
005342  aa  5 00000 00 0006	desc9a	pr5|0,ql
005343  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 916
     end octal_representation;

  END PROCEDURE octal_representation
BEGIN PROCEDURE pick_first_seg_num
ENTRY TO pick_first_seg_num                                 STATEMENT 1 ON LINE 918
pick_first_seg_num:
     proc (num_segs_desired, first_seg_num);

005344  aa  6 00132 6501 00	spri4	pr6|90
005345  aa  6 00134 2521 00	spri2	pr6|92
						STATEMENT 1 ON LINE 953
	call hcs_$high_low_seg_count (high_seg_num_minus_low_seg_num, low_seg_num);

005346  aa  6 00145 3521 00	epp2 	pr6|101		high_seg_num_minus_low_seg_num
005347  aa  6 00352 2521 00	spri2	pr6|234
005350  aa  6 00146 3521 00	epp2 	pr6|102		low_seg_num
005351  aa  6 00354 2521 00	spri2	pr6|236
005352  aa  6 00350 6211 00	eax1 	pr6|232
005353  aa   010000 4310 07	fld  	4096,dl
005354  aa  6 00044 3701 20	epp4 	pr6|36,*
005355  la  4 00246 3521 20	epp2 	pr4|166,*		hcs_$high_low_seg_count
005356  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 954
	high_seg_num = high_seg_num_minus_low_seg_num + low_seg_num;

005357  aa  6 00145 2361 00	ldq  	pr6|101		high_seg_num_minus_low_seg_num
005360  aa  6 00146 0761 00	adq  	pr6|102		low_seg_num
005361  aa  6 00144 7561 00	stq  	pr6|100		high_seg_num
						STATEMENT 1 ON LINE 955
	low_seg_num = low_seg_num + 8;

005362  aa   000010 2360 07	ldq  	8,dl
005363  aa  6 00146 0561 00	asq  	pr6|102		low_seg_num
						STATEMENT 1 ON LINE 956
	found_highest_seg_num_in_use = False;

005364  aa  6 00143 4501 00	stz  	pr6|99		found_highest_seg_num_in_use
						STATEMENT 1 ON LINE 957
	do while (^found_highest_seg_num_in_use);

005365  aa   000000 0110 03	nop  	0,du
005366  aa  6 00143 2351 00	lda  	pr6|99		found_highest_seg_num_in_use
005367  aa   000014 6010 04	tnz  	12,ic		005403
						STATEMENT 1 ON LINE 958
	     if seg_num_free (high_seg_num)
	     then high_seg_num = high_seg_num - 1;

005370  aa   001170 3520 04	epp2 	632,ic		006560 = 000004000000
005371  aa   001015 6700 04	tsp4 	525,ic		006406
005372  aa  6 00356 2351 00	lda  	pr6|238
005373  aa   400000 3150 03	cana 	131072,du
005374  aa   000004 6000 04	tze  	4,ic		005400
005375  aa   000001 3360 07	lcq  	1,dl
005376  aa  6 00144 0561 00	asq  	pr6|100		high_seg_num
005377  aa   777767 7100 04	tra  	-9,ic		005366
						STATEMENT 1 ON LINE 960
	     else found_highest_seg_num_in_use = True;

005400  aa   400000 2350 03	lda  	131072,du
005401  aa  6 00143 7551 00	sta  	pr6|99		found_highest_seg_num_in_use
						STATEMENT 1 ON LINE 961
	end;

005402  aa   777764 7100 04	tra  	-12,ic		005366
						STATEMENT 1 ON LINE 967
	best_hole_size, cur_hole_size = 0;

005403  aa  6 00140 4501 00	stz  	pr6|96		best_hole_size
005404  aa  6 00142 4501 00	stz  	pr6|98		cur_hole_size
						STATEMENT 1 ON LINE 968
	do seg_num = low_seg_num to high_seg_num while (best_hole_size ^= num_segs_desired);

005405  aa  6 00144 2361 00	ldq  	pr6|100		high_seg_num
005406  aa  6 00150 7561 00	stq  	pr6|104
005407  aa  6 00146 2361 00	ldq  	pr6|102		low_seg_num
005410  aa  6 00147 7561 00	stq  	pr6|103		seg_num
005411  aa   000000 0110 03	nop  	0,du
005412  aa  6 00147 2361 00	ldq  	pr6|103		seg_num
005413  aa  6 00150 1161 00	cmpq 	pr6|104
005414  aa   000034 6054 04	tpnz 	28,ic		005450
005415  aa  6 00140 2361 00	ldq  	pr6|96		best_hole_size
005416  aa  6 00134 3735 20	epp7 	pr6|92,*
005417  aa  7 00002 1161 20	cmpq 	pr7|2,*		num_segs_desired
005420  aa   000030 6000 04	tze  	24,ic		005450
						STATEMENT 1 ON LINE 969
	     if seg_num_free (seg_num)
	     then cur_hole_size = cur_hole_size + 1;

005421  aa   001131 3520 04	epp2 	601,ic		006552 = 000004000000
005422  aa   000764 6700 04	tsp4 	500,ic		006406
005423  aa  6 00356 2351 00	lda  	pr6|238
005424  aa   400000 3150 03	cana 	131072,du
005425  aa   000003 6000 04	tze  	3,ic		005430
005426  aa  6 00142 0541 00	aos  	pr6|98		cur_hole_size
005427  aa   000017 7100 04	tra  	15,ic		005446
						STATEMENT 1 ON LINE 971
	     else do;

						STATEMENT 1 ON LINE 972
		     if cur_hole_size >= num_segs_desired
		     then if best_hole_size = 0 | best_hole_size > cur_hole_size
			then do;

005430  aa  6 00142 2361 00	ldq  	pr6|98		cur_hole_size
005431  aa  6 00134 3735 20	epp7 	pr6|92,*
005432  aa  7 00002 1161 20	cmpq 	pr7|2,*		num_segs_desired
005433  aa   000012 6040 04	tmi  	10,ic		005445
005434  aa  6 00140 2361 00	ldq  	pr6|96		best_hole_size
005435  aa   000003 6000 04	tze  	3,ic		005440
005436  aa  6 00142 1161 00	cmpq 	pr6|98		cur_hole_size
005437  aa   000006 6044 04	tmoz 	6,ic		005445
						STATEMENT 1 ON LINE 975
				best_hole_size = cur_hole_size;

005440  aa  6 00142 2361 00	ldq  	pr6|98		cur_hole_size
005441  aa  6 00140 7561 00	stq  	pr6|96		best_hole_size
						STATEMENT 1 ON LINE 976
				best_hole_start = seg_num - best_hole_size;

005442  aa  6 00147 2361 00	ldq  	pr6|103		seg_num
005443  aa  6 00140 1761 00	sbq  	pr6|96		best_hole_size
005444  aa  6 00141 7561 00	stq  	pr6|97		best_hole_start
						STATEMENT 1 ON LINE 977
			     end;

						STATEMENT 1 ON LINE 978
		     cur_hole_size = 0;

005445  aa  6 00142 4501 00	stz  	pr6|98		cur_hole_size
						STATEMENT 1 ON LINE 979
		end;

						STATEMENT 1 ON LINE 980
	end;

005446  aa  6 00147 0541 00	aos  	pr6|103		seg_num
005447  aa   777743 7100 04	tra  	-29,ic		005412
						STATEMENT 1 ON LINE 986
	if best_hole_size < num_segs_desired
	then first_seg_num = high_seg_num + 1;

005450  aa  6 00140 2361 00	ldq  	pr6|96		best_hole_size
005451  aa  6 00134 3735 20	epp7 	pr6|92,*
005452  aa  7 00002 1161 20	cmpq 	pr7|2,*		num_segs_desired
005453  aa   000005 6050 04	tpl  	5,ic		005460
005454  aa  6 00144 2361 00	ldq  	pr6|100		high_seg_num
005455  aa   000001 0760 07	adq  	1,dl
005456  aa  7 00004 7561 20	stq  	pr7|4,*		first_seg_num
005457  aa   000003 7100 04	tra  	3,ic		005462
						STATEMENT 1 ON LINE 988
	else first_seg_num = best_hole_start;

005460  aa  6 00141 2361 00	ldq  	pr6|97		best_hole_start
005461  aa  7 00004 7561 20	stq  	pr7|4,*		first_seg_num
						STATEMENT 1 ON LINE 989
     end pick_first_seg_num;

005462  aa  6 00132 6101 00	rtcd 	pr6|90
  END PROCEDURE pick_first_seg_num
BEGIN PROCEDURE pick_seg
ENTRY TO pick_seg                                           STATEMENT 1 ON LINE 991
pick_seg:
     proc (seg_idx);

005463  aa  6 00152 6501 00	spri4	pr6|106
005464  aa  6 00154 2521 00	spri2	pr6|108
						STATEMENT 1 ON LINE 1022
	do seg_idx = 1 to fsm_info.seg_cnt while (fsm_info.seg (seg_idx).owning_process ^= ""b);

005465  aa  6 00044 3701 20	epp4 	pr6|36,*
005466  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
005467  aa  7 00001 2361 00	ldq  	pr7|1		fsm_info.seg_cnt
005470  aa  6 00174 7561 00	stq  	pr6|124
005471  aa   000001 2360 07	ldq  	1,dl
005472  aa  2 00002 7561 20	stq  	pr2|2,*		seg_idx
005473  aa   000000 0110 03	nop  	0,du
005474  aa  6 00154 3735 20	epp7 	pr6|108,*
005475  aa  7 00002 2361 20	ldq  	pr7|2,*		seg_idx
005476  aa  6 00174 1161 00	cmpq 	pr6|124
005477  aa   000010 6054 04	tpnz 	8,ic		005507
005500  aa   000005 4020 07	mpy  	5,dl
005501  aa  6 00044 3701 20	epp4 	pr6|36,*
005502  ia  4 00134 3715 20	epp5 	pr4|92,*		fsm_info_ptr
005503  aa  5 77775 2351 06	lda  	pr5|-3,ql		fsm_info.owning_process
005504  aa   000003 6000 04	tze  	3,ic		005507
						STATEMENT 1 ON LINE 1023
	end;

005505  aa  7 00002 0541 20	aos  	pr7|2,*		seg_idx
005506  aa   777766 7100 04	tra  	-10,ic		005474
						STATEMENT 1 ON LINE 1024
	if seg_idx <= fsm_info.seg_cnt
	then do;

005507  aa  7 00002 2361 20	ldq  	pr7|2,*		seg_idx
005510  aa  6 00044 3701 20	epp4 	pr6|36,*
005511  ia  4 00134 3715 20	epp5 	pr4|92,*		fsm_info_ptr
005512  aa  5 00001 1161 00	cmpq 	pr5|1		fsm_info.seg_cnt
005513  aa   000146 6054 04	tpnz 	102,ic		005661
						STATEMENT 1 ON LINE 1026
		acl.access_name = get_group_id_ ();

005514  aa  6 00360 3521 00	epp2 	pr6|240
005515  aa  6 00372 2521 00	spri2	pr6|250
005516  aa  6 00370 6211 00	eax1 	pr6|248
005517  aa   004000 4310 07	fld  	2048,dl
005520  la  4 00250 3521 20	epp2 	pr4|168,*		get_group_id_
005521  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
005522  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
005523  aa  6 00360 00 0040	desc9a	pr6|240,32
005524  aa  6 00160 00 0040	desc9a	pr6|112,32	acl.access_name
						STATEMENT 1 ON LINE 1027
		acl.modes = RW_ACCESS;

005525  aa   500000 2350 03	lda  	163840,du
005526  aa  6 00170 7551 00	sta  	pr6|120		acl.modes
						STATEMENT 1 ON LINE 1028
		acl.xmodes = ""b;

005527  aa  6 00171 4501 00	stz  	pr6|121		acl.xmodes
						STATEMENT 1 ON LINE 1029
		status = 1;

005530  aa   000001 2360 07	ldq  	1,dl
005531  aa  6 00173 7561 00	stq  	pr6|123		status
						STATEMENT 1 ON LINE 1030
		do while (status ^= 0);

005532  aa  6 00173 2361 00	ldq  	pr6|123		status
005533  aa   000421 6000 04	tze  	273,ic		006154
						STATEMENT 1 ON LINE 1031
		     call hcs_$replace_acl (fsm_dir_path, seg_name (seg_idx), addr (acl), 1, "0"b, status);

005534  aa  6 00154 3735 20	epp7 	pr6|108,*
005535  aa  7 00002 3521 20	epp2 	pr7|2,*		seg_idx
005536  aa  6 00376 2521 00	spri2	pr6|254
005537  aa  6 00360 3521 00	epp2 	pr6|240
005540  aa  6 00400 2521 00	spri2	pr6|256
005541  aa  6 00374 6211 00	eax1 	pr6|252
005542  aa   010000 4310 07	fld  	4096,dl
005543  aa   000571 3520 04	epp2 	377,ic		006334 = 000120627000
005544  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
005545  aa  6 00160 3735 00	epp7 	pr6|112		acl
005546  aa  6 00404 6535 00	spri7	pr6|260
005547  aa   000001 2360 07	ldq  	1,dl
005550  aa  6 00357 7561 00	stq  	pr6|239
005551  aa   000000 2350 07	lda  	0,dl
005552  aa  6 00406 7551 00	sta  	pr6|262
005553  aa  6 00044 3701 20	epp4 	pr6|36,*
005554  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
005555  aa  6 00412 2521 00	spri2	pr6|266
005556  aa  6 00360 3521 00	epp2 	pr6|240
005557  aa  6 00414 2521 00	spri2	pr6|268
005560  aa  6 00404 3521 00	epp2 	pr6|260
005561  aa  6 00416 2521 00	spri2	pr6|270
005562  aa  6 00357 3521 00	epp2 	pr6|239
005563  aa  6 00420 2521 00	spri2	pr6|272
005564  aa  6 00406 3521 00	epp2 	pr6|262
005565  aa  6 00422 2521 00	spri2	pr6|274
005566  aa  6 00173 3521 00	epp2 	pr6|123		status
005567  aa  6 00424 2521 00	spri2	pr6|276
005570  aa   772265 3520 04	epp2 	-2891,ic		000055 = 526000000250
005571  aa  6 00426 2521 00	spri2	pr6|278
005572  aa   772256 3520 04	epp2 	-2898,ic		000050 = 524000000040
005573  aa  6 00430 2521 00	spri2	pr6|280
005574  aa   772262 3520 04	epp2 	-2894,ic		000056 = 464000000000
005575  aa  6 00432 2521 00	spri2	pr6|282
005576  aa   772261 3520 04	epp2 	-2895,ic		000057 = 404000000021
005577  aa  6 00434 2521 00	spri2	pr6|284
005600  aa   772233 3520 04	epp2 	-2917,ic		000033 = 514000000001
005601  aa  6 00436 2521 00	spri2	pr6|286
005602  aa   772242 3520 04	epp2 	-2910,ic		000044 = 404000000043
005603  aa  6 00440 2521 00	spri2	pr6|288
005604  aa  6 00410 6211 00	eax1 	pr6|264
005605  aa   030000 4310 07	fld  	12288,dl
005606  la  4 00254 3521 20	epp2 	pr4|172,*		hcs_$replace_acl
005607  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1032
		     if status ^= 0
		     then call signal_fsm_error (status, pathname_ (fsm_dir_path, seg_name (seg_idx)));

005610  aa  6 00173 2361 00	ldq  	pr6|123		status
005611  aa   777721 6000 04	tze  	-47,ic		005532
005612  aa  6 00154 3735 20	epp7 	pr6|108,*
005613  aa  7 00002 3521 20	epp2 	pr7|2,*		seg_idx
005614  aa  6 00362 2521 00	spri2	pr6|242
005615  aa  6 00374 3521 00	epp2 	pr6|252
005616  aa  6 00364 2521 00	spri2	pr6|244
005617  aa  6 00360 6211 00	eax1 	pr6|240
005620  aa   010000 4310 07	fld  	4096,dl
005621  aa   000513 3520 04	epp2 	331,ic		006334 = 000120627000
005622  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
005623  aa  6 00044 3701 20	epp4 	pr6|36,*
005624  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
005625  aa  6 00412 2521 00	spri2	pr6|266
005626  aa  6 00374 3521 00	epp2 	pr6|252
005627  aa  6 00414 2521 00	spri2	pr6|268
005630  aa  6 00442 3521 00	epp2 	pr6|290
005631  aa  6 00416 2521 00	spri2	pr6|270
005632  aa   772223 3520 04	epp2 	-2925,ic		000055 = 526000000250
005633  aa  6 00420 2521 00	spri2	pr6|272
005634  aa  6 00424 2521 00	spri2	pr6|276
005635  aa   772213 3520 04	epp2 	-2933,ic		000050 = 524000000040
005636  aa  6 00422 2521 00	spri2	pr6|274
005637  aa  6 00410 6211 00	eax1 	pr6|264
005640  aa   014000 4310 07	fld  	6144,dl
005641  la  4 00146 3521 20	epp2 	pr4|102,*		pathname_
005642  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
005643  aa  6 00173 3521 00	epp2 	pr6|123		status
005644  aa  6 00412 2521 00	spri2	pr6|266
005645  aa  6 00442 3521 00	epp2 	pr6|290
005646  aa  6 00414 2521 00	spri2	pr6|268
005647  aa   772175 3520 04	epp2 	-2947,ic		000044 = 404000000043
005650  aa  6 00420 2521 00	spri2	pr6|272
005651  aa   772141 3520 04	epp2 	-2975,ic		000012 = 524000000250
005652  aa  6 00422 2521 00	spri2	pr6|274
005653  aa  6 00410 6211 00	eax1 	pr6|264
005654  aa   010000 4310 07	fld  	4096,dl
005655  aa   000573 3520 04	epp2 	379,ic		006450 = 000260627000
005656  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1034
		end;

005657  aa   777653 7100 04	tra  	-85,ic		005532
						STATEMENT 1 ON LINE 1035
	     end;

005660  aa   000274 7100 04	tra  	188,ic		006154
						STATEMENT 1 ON LINE 1036
	else do while (seg_idx > fsm_info.seg_cnt);

005661  aa   000000 0110 03	nop  	0,du
005662  aa  6 00154 3735 20	epp7 	pr6|108,*
005663  aa  7 00002 2361 20	ldq  	pr7|2,*		seg_idx
005664  aa  6 00044 3701 20	epp4 	pr6|36,*
005665  ia  4 00134 3715 20	epp5 	pr4|92,*		fsm_info_ptr
005666  aa  5 00001 1161 00	cmpq 	pr5|1		fsm_info.seg_cnt
005667  aa   000265 6044 04	tmoz 	181,ic		006154
						STATEMENT 1 ON LINE 1037
		call hcs_$append_branch (fsm_dir_path, seg_name (seg_idx), RW_ACCESS_BIN, status);

005670  aa  7 00002 3521 20	epp2 	pr7|2,*		seg_idx
005671  aa  6 00376 2521 00	spri2	pr6|254
005672  aa  6 00360 3521 00	epp2 	pr6|240
005673  aa  6 00400 2521 00	spri2	pr6|256
005674  aa  6 00374 6211 00	eax1 	pr6|252
005675  aa   010000 4310 07	fld  	4096,dl
005676  aa   000436 3520 04	epp2 	286,ic		006334 = 000120627000
005677  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
005700  aa  6 00044 3701 20	epp4 	pr6|36,*
005701  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
005702  aa  6 00412 2521 00	spri2	pr6|266
005703  aa  6 00360 3521 00	epp2 	pr6|240
005704  aa  6 00414 2521 00	spri2	pr6|268
005705  aa   772107 3520 04	epp2 	-3001,ic		000014 = 000000000012
005706  aa  6 00416 2521 00	spri2	pr6|270
005707  aa  6 00173 3521 00	epp2 	pr6|123		status
005710  aa  6 00420 2521 00	spri2	pr6|272
005711  aa   772144 3520 04	epp2 	-2972,ic		000055 = 526000000250
005712  aa  6 00422 2521 00	spri2	pr6|274
005713  aa   772135 3520 04	epp2 	-2979,ic		000050 = 524000000040
005714  aa  6 00424 2521 00	spri2	pr6|276
005715  aa   772117 3520 04	epp2 	-2993,ic		000034 = 404000000005
005716  aa  6 00426 2521 00	spri2	pr6|278
005717  aa   772125 3520 04	epp2 	-2987,ic		000044 = 404000000043
005720  aa  6 00430 2521 00	spri2	pr6|280
005721  aa  6 00410 6211 00	eax1 	pr6|264
005722  aa   020000 4310 07	fld  	8192,dl
005723  la  4 00252 3521 20	epp2 	pr4|170,*		hcs_$append_branch
005724  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1038
		if status = 0
		then do;

005725  aa  6 00173 2361 00	ldq  	pr6|123		status
005726  aa   000160 6010 04	tnz  	112,ic		006106
						STATEMENT 1 ON LINE 1040
			fsm_info.seg_cnt = seg_idx;

005727  aa  6 00154 3735 20	epp7 	pr6|108,*
005730  aa  7 00002 2361 20	ldq  	pr7|2,*		seg_idx
005731  aa  6 00044 3701 20	epp4 	pr6|36,*
005732  ia  4 00134 3715 20	epp5 	pr4|92,*		fsm_info_ptr
005733  aa  5 00001 7561 00	stq  	pr5|1		fsm_info.seg_cnt
						STATEMENT 1 ON LINE 1041
			fsm_info.seg (seg_idx).owner = null;

005734  aa  7 00002 2361 20	ldq  	pr7|2,*		seg_idx
005735  aa   000005 4020 07	mpy  	5,dl
005736  aa   000000 6270 06	eax7 	0,ql
005737  aa   000611 2360 04	ldq  	393,ic		006550 = 007777000001
005740  aa  5 77776 7561 17	stq  	pr5|-2,7		fsm_info.owner
						STATEMENT 1 ON LINE 1042
			call hcs_$set_max_length (fsm_dir_path, seg_name (seg_idx),
			     pl1_operators_$VLA_words_per_seg_, status);

005741  aa  7 00002 3521 20	epp2 	pr7|2,*		seg_idx
005742  aa  6 00362 2521 00	spri2	pr6|242
005743  aa  6 00374 3521 00	epp2 	pr6|252
005744  aa  6 00364 2521 00	spri2	pr6|244
005745  aa  6 00360 6211 00	eax1 	pr6|240
005746  aa   010000 4310 07	fld  	4096,dl
005747  aa   000365 3520 04	epp2 	245,ic		006334 = 000120627000
005750  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
005751  aa  6 00044 3701 20	epp4 	pr6|36,*
005752  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
005753  aa  6 00412 2521 00	spri2	pr6|266
005754  aa  6 00374 3521 00	epp2 	pr6|252
005755  aa  6 00414 2521 00	spri2	pr6|268
005756  la  4 00262 3521 20	epp2 	pr4|178,*		pl1_operators_$VLA_words_per_seg_
005757  aa  6 00416 2521 00	spri2	pr6|270
005760  aa  6 00173 3521 00	epp2 	pr6|123		status
005761  aa  6 00420 2521 00	spri2	pr6|272
005762  aa   772073 3520 04	epp2 	-3013,ic		000055 = 526000000250
005763  aa  6 00422 2521 00	spri2	pr6|274
005764  aa   772064 3520 04	epp2 	-3020,ic		000050 = 524000000040
005765  aa  6 00424 2521 00	spri2	pr6|276
005766  aa   772055 3520 04	epp2 	-3027,ic		000043 = 404000000023
005767  aa  6 00426 2521 00	spri2	pr6|278
005770  aa   772054 3520 04	epp2 	-3028,ic		000044 = 404000000043
005771  aa  6 00430 2521 00	spri2	pr6|280
005772  aa  6 00410 6211 00	eax1 	pr6|264
005773  aa   020000 4310 07	fld  	8192,dl
005774  la  4 00256 3521 20	epp2 	pr4|174,*		hcs_$set_max_length
005775  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1044
			if status ^= 0
			then call signal_fsm_error (status, pathname_ (fsm_dir_path, seg_name (seg_idx)));

005776  aa  6 00173 2361 00	ldq  	pr6|123		status
005777  aa   000046 6000 04	tze  	38,ic		006045
006000  aa  6 00154 3735 20	epp7 	pr6|108,*
006001  aa  7 00002 3521 20	epp2 	pr7|2,*		seg_idx
006002  aa  6 00376 2521 00	spri2	pr6|254
006003  aa  6 00360 3521 00	epp2 	pr6|240
006004  aa  6 00400 2521 00	spri2	pr6|256
006005  aa  6 00374 6211 00	eax1 	pr6|252
006006  aa   010000 4310 07	fld  	4096,dl
006007  aa   000325 3520 04	epp2 	213,ic		006334 = 000120627000
006010  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
006011  aa  6 00044 3701 20	epp4 	pr6|36,*
006012  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
006013  aa  6 00412 2521 00	spri2	pr6|266
006014  aa  6 00360 3521 00	epp2 	pr6|240
006015  aa  6 00414 2521 00	spri2	pr6|268
006016  aa  6 00442 3521 00	epp2 	pr6|290
006017  aa  6 00416 2521 00	spri2	pr6|270
006020  aa   772035 3520 04	epp2 	-3043,ic		000055 = 526000000250
006021  aa  6 00420 2521 00	spri2	pr6|272
006022  aa  6 00424 2521 00	spri2	pr6|276
006023  aa   772025 3520 04	epp2 	-3051,ic		000050 = 524000000040
006024  aa  6 00422 2521 00	spri2	pr6|274
006025  aa  6 00410 6211 00	eax1 	pr6|264
006026  aa   014000 4310 07	fld  	6144,dl
006027  la  4 00146 3521 20	epp2 	pr4|102,*		pathname_
006030  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
006031  aa  6 00173 3521 00	epp2 	pr6|123		status
006032  aa  6 00412 2521 00	spri2	pr6|266
006033  aa  6 00442 3521 00	epp2 	pr6|290
006034  aa  6 00414 2521 00	spri2	pr6|268
006035  aa   772007 3520 04	epp2 	-3065,ic		000044 = 404000000043
006036  aa  6 00420 2521 00	spri2	pr6|272
006037  aa   771753 3520 04	epp2 	-3093,ic		000012 = 524000000250
006040  aa  6 00422 2521 00	spri2	pr6|274
006041  aa  6 00410 6211 00	eax1 	pr6|264
006042  aa   010000 4310 07	fld  	4096,dl
006043  aa   000405 3520 04	epp2 	261,ic		006450 = 000260627000
006044  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1047
			call hcs_$set_safety_sw (fsm_dir_path, seg_name (seg_idx), "1"b, status);

006045  aa  6 00154 3735 20	epp7 	pr6|108,*
006046  aa  7 00002 3521 20	epp2 	pr7|2,*		seg_idx
006047  aa  6 00362 2521 00	spri2	pr6|242
006050  aa  6 00374 3521 00	epp2 	pr6|252
006051  aa  6 00364 2521 00	spri2	pr6|244
006052  aa  6 00360 6211 00	eax1 	pr6|240
006053  aa   010000 4310 07	fld  	4096,dl
006054  aa   000260 3520 04	epp2 	176,ic		006334 = 000120627000
006055  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
006056  aa   400000 2350 03	lda  	131072,du
006057  aa  6 00406 7551 00	sta  	pr6|262
006060  aa  6 00044 3701 20	epp4 	pr6|36,*
006061  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
006062  aa  6 00412 2521 00	spri2	pr6|266
006063  aa  6 00374 3521 00	epp2 	pr6|252
006064  aa  6 00414 2521 00	spri2	pr6|268
006065  aa  6 00406 3521 00	epp2 	pr6|262
006066  aa  6 00416 2521 00	spri2	pr6|270
006067  aa  6 00173 3521 00	epp2 	pr6|123		status
006070  aa  6 00420 2521 00	spri2	pr6|272
006071  aa   771764 3520 04	epp2 	-3084,ic		000055 = 526000000250
006072  aa  6 00422 2521 00	spri2	pr6|274
006073  aa   771755 3520 04	epp2 	-3091,ic		000050 = 524000000040
006074  aa  6 00424 2521 00	spri2	pr6|276
006075  aa   771736 3520 04	epp2 	-3106,ic		000033 = 514000000001
006076  aa  6 00426 2521 00	spri2	pr6|278
006077  aa   771745 3520 04	epp2 	-3099,ic		000044 = 404000000043
006100  aa  6 00430 2521 00	spri2	pr6|280
006101  aa  6 00410 6211 00	eax1 	pr6|264
006102  aa   020000 4310 07	fld  	8192,dl
006103  la  4 00260 3521 20	epp2 	pr4|176,*		hcs_$set_safety_sw
006104  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1048
		     end;

006105  aa   777555 7100 04	tra  	-147,ic		005662
						STATEMENT 1 ON LINE 1049
		else call signal_fsm_error (status, pathname_ (fsm_dir_path, seg_name (seg_idx)));

006106  aa  6 00154 3735 20	epp7 	pr6|108,*
006107  aa  7 00002 3521 20	epp2 	pr7|2,*		seg_idx
006110  aa  6 00376 2521 00	spri2	pr6|254
006111  aa  6 00360 3521 00	epp2 	pr6|240
006112  aa  6 00400 2521 00	spri2	pr6|256
006113  aa  6 00374 6211 00	eax1 	pr6|252
006114  aa   010000 4310 07	fld  	4096,dl
006115  aa   000217 3520 04	epp2 	143,ic		006334 = 000120627000
006116  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
006117  aa  6 00044 3701 20	epp4 	pr6|36,*
006120  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
006121  aa  6 00412 2521 00	spri2	pr6|266
006122  aa  6 00360 3521 00	epp2 	pr6|240
006123  aa  6 00414 2521 00	spri2	pr6|268
006124  aa  6 00442 3521 00	epp2 	pr6|290
006125  aa  6 00416 2521 00	spri2	pr6|270
006126  aa   771727 3520 04	epp2 	-3113,ic		000055 = 526000000250
006127  aa  6 00420 2521 00	spri2	pr6|272
006130  aa  6 00424 2521 00	spri2	pr6|276
006131  aa   771717 3520 04	epp2 	-3121,ic		000050 = 524000000040
006132  aa  6 00422 2521 00	spri2	pr6|274
006133  aa  6 00410 6211 00	eax1 	pr6|264
006134  aa   014000 4310 07	fld  	6144,dl
006135  la  4 00146 3521 20	epp2 	pr4|102,*		pathname_
006136  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
006137  aa  6 00173 3521 00	epp2 	pr6|123		status
006140  aa  6 00412 2521 00	spri2	pr6|266
006141  aa  6 00442 3521 00	epp2 	pr6|290
006142  aa  6 00414 2521 00	spri2	pr6|268
006143  aa   771701 3520 04	epp2 	-3135,ic		000044 = 404000000043
006144  aa  6 00420 2521 00	spri2	pr6|272
006145  aa   771645 3520 04	epp2 	-3163,ic		000012 = 524000000250
006146  aa  6 00422 2521 00	spri2	pr6|274
006147  aa  6 00410 6211 00	eax1 	pr6|264
006150  aa   010000 4310 07	fld  	4096,dl
006151  aa   000277 3520 04	epp2 	191,ic		006450 = 000260627000
006152  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1050
	     end;

006153  aa   777507 7100 04	tra  	-185,ic		005662
						STATEMENT 1 ON LINE 1051
     end pick_seg;

006154  aa  6 00152 6101 00	rtcd 	pr6|106
  END PROCEDURE pick_seg
BEGIN PROCEDURE release_fsm_info
ENTRY TO release_fsm_info                                   STATEMENT 1 ON LINE 1053
release_fsm_info:
     proc;

006155  da     000673200000
006156  aa   000160 6270 00	eax7 	112
006157  aa  7 00034 3521 20	epp2 	pr7|28,*
006160  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
006161  aa     000000000000
006162  aa     000000000000
006163  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
						STATEMENT 1 ON LINE 1070
	if fsm_info_ptr ^= null
	then if fsm_info.lock = my_process
	     then do;

006164  ia  4 00134 2371 00	ldaq 	pr4|92		fsm_info_ptr
006165  aa   771707 6770 04	eraq 	-3129,ic		000074 = 077777000043 000001000000
006166  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
006167  aa   000143 6000 04	tze  	99,ic		006332
006170  ia  4 00134 2351 20	lda  	pr4|92,*		fsm_info.lock
006171  aa  6 00040 3735 20	epp7 	pr6|32,*
006172  aa  7 00102 1151 00	cmpa 	pr7|66		my_process
006173  aa   000137 6010 04	tnz  	95,ic		006332
						STATEMENT 1 ON LINE 1073
		     do seg_idx = 1 to fsm_info.seg_cnt;

006174  ia  4 00134 3715 20	epp5 	pr4|92,*		fsm_info_ptr
006175  aa  5 00001 2361 00	ldq  	pr5|1		fsm_info.seg_cnt
006176  aa  6 00102 7561 00	stq  	pr6|66
006177  aa   000001 2360 07	ldq  	1,dl
006200  aa  6 00100 7561 00	stq  	pr6|64		seg_idx
006201  aa   000000 0110 03	nop  	0,du
006202  aa  6 00100 2361 00	ldq  	pr6|64		seg_idx
006203  aa  6 00102 1161 00	cmpq 	pr6|66
006204  aa   000066 6054 04	tpnz 	54,ic		006272
						STATEMENT 1 ON LINE 1074
			if fsm_info.seg (seg_idx).owning_process = my_process & fsm_info.seg (seg_idx).owner = me
			then do;

006205  aa   000005 4020 07	mpy  	5,dl
006206  aa  6 00044 3701 20	epp4 	pr6|36,*
006207  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
006210  aa  7 77775 2351 06	lda  	pr7|-3,ql		fsm_info.owning_process
006211  aa  6 00040 3715 20	epp5 	pr6|32,*
006212  aa  5 00102 1151 00	cmpa 	pr5|66		my_process
006213  aa   000055 6010 04	tnz  	45,ic		006270
006214  aa   000000 6270 06	eax7 	0,ql
006215  aa  5 00100 2371 00	ldaq 	pr5|64		me
006216  aa  0 00560 7001 00	tsx0 	pr0|368		unpk_to_pk
006217  aa  7 77776 1161 17	cmpq 	pr7|-2,7		fsm_info.owner
006220  aa   000050 6010 04	tnz  	40,ic		006270
						STATEMENT 1 ON LINE 1076
				call hcs_$terminate_file (fsm_dir_path, seg_name (seg_idx), 0, status);

006221  aa  6 00100 3521 00	epp2 	pr6|64		seg_idx
006222  aa  6 00116 2521 00	spri2	pr6|78
006223  aa  6 00104 3521 00	epp2 	pr6|68
006224  aa  6 00120 2521 00	spri2	pr6|80
006225  aa   000001 7270 07	lxl7 	1,dl
006226  aa  6 00114 6211 00	eax1 	pr6|76
006227  aa   010000 4310 07	fld  	4096,dl
006230  aa   000104 3520 04	epp2 	68,ic		006334 = 000120627000
006231  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
006232  aa  6 00103 4501 00	stz  	pr6|67
006233  aa  6 00044 3701 20	epp4 	pr6|36,*
006234  ia  4 00010 3521 00	epp2 	pr4|8		fsm_dir_path
006235  aa  6 00126 2521 00	spri2	pr6|86
006236  aa  6 00104 3521 00	epp2 	pr6|68
006237  aa  6 00130 2521 00	spri2	pr6|88
006240  aa  6 00103 3521 00	epp2 	pr6|67
006241  aa  6 00132 2521 00	spri2	pr6|90
006242  aa  6 00101 3521 00	epp2 	pr6|65		status
006243  aa  6 00134 2521 00	spri2	pr6|92
006244  aa   771611 3520 04	epp2 	-3191,ic		000055 = 526000000250
006245  aa  6 00136 2521 00	spri2	pr6|94
006246  aa   771602 3520 04	epp2 	-3198,ic		000050 = 524000000040
006247  aa  6 00140 2521 00	spri2	pr6|96
006250  aa   771576 3520 04	epp2 	-3202,ic		000046 = 404000000001
006251  aa  6 00142 2521 00	spri2	pr6|98
006252  aa   771572 3520 04	epp2 	-3206,ic		000044 = 404000000043
006253  aa  6 00144 2521 00	spri2	pr6|100
006254  aa  6 00124 6211 00	eax1 	pr6|84
006255  aa   020000 4310 07	fld  	8192,dl
006256  la  4 00264 3521 20	epp2 	pr4|180,*		hcs_$terminate_file
006257  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1077
				unspec (fsm_info.seg (seg_idx)) = ""b;

006260  aa  6 00100 2361 00	ldq  	pr6|64		seg_idx
006261  aa   000005 4020 07	mpy  	5,dl
006262  aa  6 00044 3701 20	epp4 	pr6|36,*
006263  ia  4 00134 3735 20	epp7 	pr4|92,*		fsm_info_ptr
006264  aa  7 77775 3735 06	epp7 	pr7|-3,ql
006265  aa  000 100 100 400	mlr  	(),(pr),fill(000)
006266  aa   000000 00 0000	desc9a	0,0
006267  aa  7 00000 00 0024	desc9a	pr7|0,20
						STATEMENT 1 ON LINE 1078
			     end;

						STATEMENT 1 ON LINE 1079
		     end;

006270  aa  6 00100 0541 00	aos  	pr6|64		seg_idx
006271  aa   777711 7100 04	tra  	-55,ic		006202
						STATEMENT 1 ON LINE 1080
		     status = 1;

006272  aa   000001 2360 07	ldq  	1,dl
006273  aa  6 00101 7561 00	stq  	pr6|65		status
						STATEMENT 1 ON LINE 1081
		     do while (status ^= 0);

006274  aa  6 00101 2361 00	ldq  	pr6|65		status
006275  aa   000035 6000 04	tze  	29,ic		006332
						STATEMENT 1 ON LINE 1082
			call set_lock_$unlock (fsm_info.lock, status);

006276  aa  6 00044 3701 20	epp4 	pr6|36,*
006277  ia  4 00134 3521 20	epp2 	pr4|92,*		fsm_info.lock
006300  aa  6 00116 2521 00	spri2	pr6|78
006301  aa  6 00101 3521 00	epp2 	pr6|65		status
006302  aa  6 00120 2521 00	spri2	pr6|80
006303  aa  6 00114 6211 00	eax1 	pr6|76
006304  aa   010000 4310 07	fld  	4096,dl
006305  la  4 00266 3521 20	epp2 	pr4|182,*		set_lock_$unlock
006306  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1083
			if status ^= 0
			then call signal_fsm_error (status, "Trying to unlock 'fsm_info'.");

006307  aa  6 00101 2361 00	ldq  	pr6|65		status
006310  aa   777764 6000 04	tze  	-12,ic		006274
006311  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
006312  aa   771646 00 0034	desc9a	-3162,28		000157 = 124162171151
006313  aa  6 00104 00 0034	desc9a	pr6|68,28
006314  aa  6 00101 3521 00	epp2 	pr6|65		status
006315  aa  6 00126 2521 00	spri2	pr6|86
006316  aa  6 00104 3521 00	epp2 	pr6|68
006317  aa  6 00130 2521 00	spri2	pr6|88
006320  aa   771524 3520 04	epp2 	-3244,ic		000044 = 404000000043
006321  aa  6 00134 2521 00	spri2	pr6|92
006322  aa   771467 3520 04	epp2 	-3273,ic		000011 = 524000000034
006323  aa  6 00136 2521 00	spri2	pr6|94
006324  aa   000001 7270 07	lxl7 	1,dl
006325  aa  6 00124 6211 00	eax1 	pr6|84
006326  aa   010000 4310 07	fld  	4096,dl
006327  aa   000121 3520 04	epp2 	81,ic		006450 = 000260627000
006330  aa  0 00626 7001 00	tsx0 	pr0|406		call_int_other_desc
						STATEMENT 1 ON LINE 1085
		     end;

006331  aa   777743 7100 04	tra  	-29,ic		006274
						STATEMENT 1 ON LINE 1086
		end;

						STATEMENT 1 ON LINE 1087
     end release_fsm_info;

006332  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END PROCEDURE release_fsm_info
BEGIN PROCEDURE seg_name
ENTRY TO seg_name                                           STATEMENT 1 ON LINE 1089
seg_name:
     proc (seg_idx) returns (char (32));

006333  da     000701220000
006334  aa   000120 6270 00	eax7 	80
006335  aa  7 00034 3521 20	epp2 	pr7|28,*
006336  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
006337  aa     000004000000
006340  aa     000000000000
006341  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
						STATEMENT 1 ON LINE 1104
	return (ltrim (char (seg_idx)) || ".fsm_");

006342  aa  6 00032 3735 20	epp7 	pr6|26,*
006343  aa  7 00002 3715 20	epp5 	pr7|2,*
006344  aa  000 100 301 500	btd  	(pr),(pr)
006345  aa  5 00000 00 0004	desc9a	pr5|0,4		seg_idx
006346  aa  6 00104 01 0010	desc9ls	pr6|68,8,0
006347  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
006350  aa  6 00104 01 0010	desc9ls	pr6|68,8,0
006351  aa   000177 00 0006	desc9a	127,6		006546 = 403040022146
006352  aa  6 00100 00 0012	desc9a	pr6|64,10
006353  aa  000 000 164 500	tct  	(pr)
006354  aa  6 00100 00 0012	desc9a	pr6|64,10
006355  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
006356  aa  6 00056 0001 00	arg  	pr6|46
006357  aa  6 00056 2361 00	ldq  	pr6|46
006360  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
006361  aa  6 00103 7561 00	stq  	pr6|67
006362  aa   000012 2360 07	ldq  	10,dl
006363  aa  6 00103 1761 00	sbq  	pr6|67
006364  aa  6 00106 7561 00	stq  	pr6|70
006365  aa   000005 0760 07	adq  	5,dl
006366  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
006367  aa  6 00103 2351 00	lda  	pr6|67
006370  aa  6 00107 7561 00	stq  	pr6|71
006371  aa  6 00106 2361 00	ldq  	pr6|70
006372  aa  040 140 100 545	mlr  	(pr,rl,al),(pr,rl),fill(040)
006373  aa  6 00100 00 0006	desc9a	pr6|64,ql
006374  aa  2 00000 00 0006	desc9a	pr2|0,ql
006375  aa  040 106 100 404	mlr  	(ic),(pr,ql),fill(040)
006376  aa   771467 00 0005	desc9a	-3273,5		000064 = 056146163155
006377  aa  2 00000 00 0005	desc9a	pr2|0,5
006400  aa  7 00004 3535 20	epp3 	pr7|4,*
006401  aa  6 00107 2351 00	lda  	pr6|71
006402  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
006403  aa  2 00000 00 0005	desc9a	pr2|0,al
006404  aa  3 00000 00 0040	desc9a	pr3|0,32
006405  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1105
     end seg_name;

  END PROCEDURE seg_name
BEGIN PROCEDURE seg_num_free
ENTRY TO seg_num_free                                       STATEMENT 1 ON LINE 1107
seg_num_free:
     proc (seg_num) returns (bit (1));

006406  aa  6 00176 6501 00	spri4	pr6|126
006407  aa  6 00200 2521 00	spri2	pr6|128
						STATEMENT 1 ON LINE 1131
	call hcs_$get_uid_seg (baseptr (seg_num), uid, status);

006410  aa  2 00002 2361 20	ldq  	pr2|2,*		seg_num
006411  aa  6 00000 3511 00	epbp1	pr6|0
006412  aa   000000 3104 06	easp1	0,ql
006413  aa  6 00514 2515 00	spri1	pr6|332
006414  aa  6 00514 3521 00	epp2 	pr6|332
006415  aa  6 00520 2521 00	spri2	pr6|336
006416  aa  6 00205 3521 00	epp2 	pr6|133		uid
006417  aa  6 00522 2521 00	spri2	pr6|338
006420  aa  6 00204 3521 00	epp2 	pr6|132		status
006421  aa  6 00524 2521 00	spri2	pr6|340
006422  aa  6 00516 6211 00	eax1 	pr6|334
006423  aa   014000 4310 07	fld  	6144,dl
006424  aa  6 00044 3701 20	epp4 	pr6|36,*
006425  la  4 00272 3521 20	epp2 	pr4|186,*		hcs_$get_uid_seg
006426  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1132
	if status = error_table_$invalidsegno
	then return (True);

006427  aa  6 00204 2361 00	ldq  	pr6|132		status
006430  aa  6 00044 3701 20	epp4 	pr6|36,*
006431  la  4 00270 1161 20	cmpq 	pr4|184,*		error_table_$invalidsegno
006432  aa   000007 6010 04	tnz  	7,ic		006441
006433  aa  6 00200 3735 20	epp7 	pr6|128,*
006434  aa  7 00004 3715 20	epp5 	pr7|4,*
006435  aa  403 100 060 400	csl  	(),(pr),fill(1),bool(move)
006436  aa   000000 00 0000	descb	0,0
006437  aa  5 00000 00 0001	descb	pr5|0,1
006440  aa  6 00176 6101 00	rtcd 	pr6|126
						STATEMENT 1 ON LINE 1134
	else return (False);

006441  aa  6 00200 3735 20	epp7 	pr6|128,*
006442  aa  7 00004 3715 20	epp5 	pr7|4,*
006443  aa  003 100 060 400	csl  	(),(pr),fill(0),bool(move)
006444  aa   000000 00 0000	descb	0,0
006445  aa  5 00000 00 0001	descb	pr5|0,1
006446  aa  6 00176 6101 00	rtcd 	pr6|126
						STATEMENT 1 ON LINE 1135
     end seg_num_free;

  END PROCEDURE seg_num_free
BEGIN PROCEDURE signal_fsm_error
ENTRY TO signal_fsm_error                                   STATEMENT 1 ON LINE 1137
signal_fsm_error:
     proc (status, details);

006447  da     000711200000
006450  aa   000260 6270 00	eax7 	176
006451  aa  7 00034 3521 20	epp2 	pr7|28,*
006452  aa  2 01050 2721 00	tsp2 	pr2|552		int_entry_desc
006453  aa     000004000000
006454  aa     000000000000
006455  aa  0 01372 7001 00	tsx0 	pr0|762		set_support
006456  aa  6 00042 3735 20	epp7 	pr6|34,*
006457  aa  7 00002 2361 20	ldq  	pr7|2,*
006460  aa   000002 6040 04	tmi  	2,ic		006462
006461  aa   777777 3760 07	anq  	262143,dl
006462  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
006463  aa  6 00205 7561 00	stq  	pr6|133
						STATEMENT 1 ON LINE 1162
	condition_info.length = size (condition_info);

006464  aa   000105 2360 07	ldq  	69,dl
006465  aa  6 00100 7561 00	stq  	pr6|64		condition_info.length
						STATEMENT 1 ON LINE 1163
	condition_info.version = 1;

006466  aa   000001 2360 07	ldq  	1,dl
006467  aa  6 00101 7561 00	stq  	pr6|65		condition_info.version
						STATEMENT 1 ON LINE 1164
	unspec (condition_info.action_flags) = ""b;

006470  aa  6 00102 4501 00	stz  	pr6|66
						STATEMENT 1 ON LINE 1165
	condition_info.info_string = rtrim (details);

006471  aa  6 00032 3715 20	epp5 	pr6|26,*
006472  aa  5 00004 3535 20	epp3 	pr5|4,*
006473  aa  6 00205 2351 00	lda  	pr6|133
006474  aa  000 000 165 540	tctr 	(pr,rl)
006475  aa  3 00000 00 0005	desc9a	pr3|0,al		details
006476  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
006477  aa  6 00056 0001 00	arg  	pr6|46
006500  aa  6 00056 2361 00	ldq  	pr6|46
006501  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
006502  aa  6 00206 7561 00	stq  	pr6|134
006503  aa  6 00205 2361 00	ldq  	pr6|133
006504  aa  6 00206 1761 00	sbq  	pr6|134
006505  aa   000400 1160 07	cmpq 	256,dl
006506  aa   000002 6040 04	tmi  	2,ic		006510
006507  aa   000400 2360 07	ldq  	256,dl
006510  aa  6 00103 7561 00	stq  	pr6|67		condition_info.info_string
006511  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
006512  aa  3 00000 00 0006	desc9a	pr3|0,ql		details
006513  aa  6 00104 00 0006	desc9a	pr6|68,ql		condition_info.info_string
						STATEMENT 1 ON LINE 1166
	condition_info.status_code = status;

006514  aa  5 00002 2361 20	ldq  	pr5|2,*		status
006515  aa  6 00204 7561 00	stq  	pr6|132		condition_info.status_code
						STATEMENT 1 ON LINE 1167
	call signal_ ("fortran_storage_manager_error", null, addr (condition_info));

006516  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
006517  aa   771457 00 0040	desc9a	-3281,32		000175 = 146157162164
006520  aa  6 00210 00 0040	desc9a	pr6|136,32
006521  aa   771353 3514 24	epp1 	-3349,ic*
006522  aa  6 00220 2515 00	spri1	pr6|144
006523  aa  6 00100 3735 00	epp7 	pr6|64		condition_info
006524  aa  6 00222 6535 00	spri7	pr6|146
006525  aa  6 00210 3521 00	epp2 	pr6|136
006526  aa  6 00226 2521 00	spri2	pr6|150
006527  aa  6 00220 3521 00	epp2 	pr6|144
006530  aa  6 00230 2521 00	spri2	pr6|152
006531  aa  6 00222 3521 00	epp2 	pr6|146
006532  aa  6 00232 2521 00	spri2	pr6|154
006533  aa   771255 3520 04	epp2 	-3411,ic		000010 = 524000000035
006534  aa  6 00234 2521 00	spri2	pr6|156
006535  aa   771321 3520 04	epp2 	-3375,ic		000056 = 464000000000
006536  aa  6 00236 2521 00	spri2	pr6|158
006537  aa  6 00240 2521 00	spri2	pr6|160
006540  aa  6 00224 6211 00	eax1 	pr6|148
006541  aa   014000 4310 07	fld  	6144,dl
006542  la  4 00274 3521 20	epp2 	pr4|188,*		signal_
006543  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1168
     end signal_fsm_error;

006544  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END PROCEDURE signal_fsm_error
  END PROCEDURE fsm_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
