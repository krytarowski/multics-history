	COMPILATION LISTING OF SEGMENT find_dict_word_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 02/16/88  1412.4 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 find_dict_word_: proc (pm_word, pm_control, pm_word_found, pm_descrip, pm_dict_path, pm_err_p, pm_code);
       12 
       13 /* This procedure finds a specified word in the sequence of
       14*   dictionaries defined by the "dict" search list.
       15**/
       16 
       17 /* Coded 10/17/77 by J. Stern */
       18 /* Modified 07/07/81 by PWB to allow option of whether or not a bad dict in 
       19*		        search list will cause processing to halt, and 
       20*		        provide a mechanism to report those errors.
       21**/
       22 
       23 /* Parameters */
       24 
       25 dcl  pm_word char (*);
       26 dcl  pm_control bit (36) aligned;
       27 dcl  pm_word_found char (256);
       28 dcl  pm_descrip bit (36) aligned;
       29 dcl  pm_dict_path char (168);
       30 dcl  pm_err_p ptr;					/* input -> null = abort if invalid dict found */
       31 dcl  pm_code fixed bin (35);
       32 
       33 
       34 /* Automatic */
       35 
       36 dcl  aborting bit (1);
       37 dcl  ndict fixed bin;
       38 dcl  dictx fixed bin;
       39 dcl  prev_level fixed bin;
       40 dcl  forget_sw bit (1) aligned;
       41 dcl  dict_iocbps_p ptr;
       42 dcl  good_dicts_p ptr;
       43 dcl  switch char (32);
       44 dcl  atd char (256);
       45 dcl  word char (256) varying;
       46 dcl  info_ptr ptr;
       47 
       48 dcl 1 fdw_control aligned,
       49     2 exact_match bit (1) unal,
       50     2 mbz bit (35) unal;
       51 
       52 dcl 1 get_key_info aligned,
       53     2 flags like gk_header.flags,
       54     2 descrip bit (36) aligned,
       55     2 key_len fixed bin,
       56     2 key char (256);
       57 
       58 
       59 /* Based */
       60 
       61 dcl  current_sl_index fixed bin (71) based (sl_info.change_index_p);
       62 dcl  system_area area based (system_area_p);
       63 dcl  dict_iocbps (ndict) ptr based (dict_iocbps_p);
       64 dcl  good_dicts (ndict) bit (1) unal based (good_dicts_p);
       65 	       
       66 dcl 1 bad_dicts aligned based (pm_err_p),
       67       2 n fixed bin,
       68       2 entry (0 refer (bad_dicts.n)),
       69         3 ecode fixed bin (35),
       70         3 path char (168) unal;
       71 
       72 /* Static */
       73 
       74 dcl  system_area_p ptr int static init (null);
       75 dcl  level fixed bin int static init (0);
       76 dcl  have_dictionaries bit (1) aligned int static init ("0"b);
       77 dcl  static_sl_info_p ptr int static;
       78 dcl  static_dict_iocbps_p ptr int static;
       79 dcl  static_good_dicts_p ptr int static init (null);
       80 	       
       81 dcl  keyed_sequential_input fixed bin int static options (constant) init (8);
       82 dcl  capital_letters char (26) int static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
       83 dcl  small_letters char (26) int static options (constant) init ("abcdefghijklmnopqrstuvwxyz");
       84 
       85 dcl  error_table_$no_record fixed bin (35) ext static;
       86 dcl  error_table_$no_key fixed bin (35) ext static;
       87 dcl  error_table_$id_not_found fixed bin (35) ext static;
       88 dcl  error_table_$no_search_list fixed bin (35) ext static;
       89 dcl  error_table_$fatal_error	fixed bin(35) ext static;
       90 dcl  error_table_$recoverable_error fixed bin(35) ext static;
       91 
       92 dcl  search_list_defaults_$dict ext static;
       93 
       94 
       95 /* Conditions */
       96 
       97 dcl  cleanup condition;
       98 
       99 
      100 /* Builtins */
      101 
      102 dcl (null, rtrim, unspec, verify, search, translate, length, bit, bin, addr, substr, string) builtin;
      103 
      104 
      105 /* Entries */
      106 
      107 dcl  get_system_free_area_ entry (ptr);
      108 dcl  search_paths_$get entry (char (*), bit (36), char (*),
      109      ptr, ptr, fixed bin, ptr, fixed bin (35));
      110 dcl  unique_chars_ entry (bit (*)) returns (char (15));
      111 dcl  iox_$attach_name entry (char (*), ptr, char (*), entry, fixed bin (35));
      112 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
      113 dcl  iox_$close entry (ptr, fixed bin (35));
      114 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
      115 dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
      116 dcl  sub_err_ entry options (variable);
      117 
      118 /* include files */
      119 
      120 
  1     1 /* BEGIN INCLUDE FILE . . . sl_info.incl.pl1 */
  1     2 
  1     3      
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(87-11-16,Lippard), approve(87-12-21,MCR7822),
  1     7*     audit(88-02-09,Blair), install(88-02-16,MR12.2-1023):
  1     8*     Modified to add INITIATED_SEGS type.
  1     9*  2) change(87-11-19,Lippard), approve(87-12-21,MCR7822),
  1    10*     audit(88-02-09,Blair), install(88-02-16,MR12.2-1023):
  1    11*     Added uid to sl_info structure.
  1    12*                                                   END HISTORY COMMENTS */
  1    13 
  1    14 
  1    15 declare 1 sl_info	      aligned based (sl_info_p),
  1    16 	     2 version	      fixed binary,		/* Must be 1 */
  1    17 	     2 num_paths	      fixed binary,		/* Number of search paths */
  1    18 	     2 change_index_p     pointer,		/* Pointer to search list's update count */
  1    19 	     2 change_index	      fixed binary (71),	/* This search list's update count */
  1    20 	     2 pad1	      (6) bit (36),		/* Must be zero */
  1    21 	     2 paths	      (sl_info_num_paths refer (sl_info.num_paths)),
  1    22 	       3 type	      fixed binary,		/* Type of search path */
  1    23 	       3 code	      fixed binary (35),	/* Standard status code of search path */
  1    24 	       3 uid	      bit (36),		/* Unique ID */
  1    25 	       3 pathname	      char (168) unaligned;	/* Search pathname */
  1    26 
  1    27      declare sl_info_num_paths      fixed binary;
  1    28      declare sl_info_p	      pointer;
  1    29      declare sl_info_version_1      fixed binary internal static options (constant) initial (1);
  1    30 
  1    31 /* Keyword Types */
  1    32 
  1    33      declare ABSOLUTE_PATH	      fixed binary internal static options (constant) initial (0);
  1    34      declare UNEXPANDED_PATH	      fixed binary internal static options (constant) initial (1);
  1    35      declare REFERENCING_DIR	      fixed binary internal static options (constant) initial (3);
  1    36      declare WORKING_DIR	      fixed binary internal static options (constant) initial (4);
  1    37      declare PROCESS_DIR	      fixed binary internal static options (constant) initial (5);
  1    38      declare HOME_DIR	      fixed binary internal static options (constant) initial (6);
  1    39      declare INITIATED_SEGS	      fixed binary internal static options (constant) initial (7);
  1    40 
  1    41 /* END INCLUDE FILE . . . sl_info.incl.pl1 */
      121 
      122 
  2     1 /* ak_info -- include file for info structures used by the following vfile_
  2     2*   control orders: "add_key", "delete_key", "get_key", and "reassign_key".
  2     3*   Created by M. Asherman 3/23/76
  2     4*   Modified 5/13/77 to add separate gk_info structure */
  2     5 
  2     6      dcl	   1 ak_info	      based (ak_info_ptr),
  2     7 	     2 header	      like ak_header,
  2     8 	     2 key	      char (ak_key_len refer (ak_info.header.key_len));
  2     9 
  2    10      dcl	   1 ak_header	      based (ak_info_ptr),
  2    11 	     2 flags	      aligned,
  2    12 	       3 input_key	      bit (1) unal,		/* set if key is input arg */
  2    13 	       3 input_desc	      bit (1) unal,		/* set if descriptor is an input arg */
  2    14 	       3 mbz	      bit (34) unal,	/* not used for the present */
  2    15 	     2 descrip	      fixed (35),		/* record designator */
  2    16 	     2 key_len	      fixed;
  2    17 
  2    18      dcl	   ak_info_ptr	      ptr;
  2    19      dcl	   ak_key_len	      fixed;
  2    20 
  2    21 
  2    22      dcl	   1 rk_info	      based (rk_info_ptr),
  2    23 	     2 header	      like rk_header,
  2    24 	     2 key	      char (rk_key_len refer (rk_info.header.key_len));
  2    25 
  2    26      dcl	   1 rk_header	      based (rk_info_ptr),
  2    27 	     2 flags	      aligned,
  2    28 	       3 input_key	      bit (1) unal,		/* same as above */
  2    29 	       3 input_old_desc   bit (1) unal,		/* set if specified entry has initial descrip
  2    30*						   given by old_descrip */
  2    31 	       3 input_new_desc   bit (1) unal,		/* set if new val for descrip is input in this struc */
  2    32 	       3 mbz	      bit (33) unal,
  2    33 	     2 old_descrip	      fixed (35),		/* used if first flag is set */
  2    34 	     2 new_descrip	      fixed (35),		/* used only if second flag is set */
  2    35 	     2 key_len	      fixed;
  2    36 
  2    37      dcl	   rk_info_ptr	      ptr;
  2    38      dcl	   rk_key_len	      fixed;
  2    39 
  2    40 
  2    41      dcl	   1 gk_info	      based (gk_info_ptr),	/* structure for get_key order */
  2    42 	     2 header	      like gk_header,
  2    43 	     2 key	      char (gk_key_len refer (gk_info.header.key_len));
  2    44 						/* may be Input as well as Output */
  2    45 
  2    46      dcl	   1 gk_header	      based (gk_info_ptr),
  2    47 	     2 flags	      aligned,
  2    48 	       3 input_key	      bit (1) unal,		/* if set, use key in this structure */
  2    49 	       3 input_desc	      bit (1) unal,		/* if set, descriptor given in this structure */
  2    50 	       3 desc_code	      fixed (2) unal,	/* 0=any, 1=current -- applies when input_desc="0"b */
  2    51 	       3 position_specification
  2    52 			      unal,
  2    53 	         4 current	      bit (1) unal,		/* otherwise next */
  2    54 	         4 rel_type	      fixed (2) unal,	/* as in seek_head, if input_key = "1"b */
  2    55 	         4 head_size      fixed bin (9) unsigned unaligned,
  2    56 						/* size of head for initial seek */
  2    57 	       3 reset_pos	      bit (1) unal,		/* if set, final position unchanged by this operation */
  2    58 	       3 pad	      bit (8) unal,
  2    59 	       3 version	      fixed (8) unal,
  2    60 	     2 descrip	      fixed (35),		/* Output, except when input_desc="1"b */
  2    61 	     2 key_len	      fixed;		/* Input when input_key="1"b, also Output in all cases */
  2    62 
  2    63      dcl	   gk_info_ptr	      ptr;
  2    64      dcl	   gk_key_len	      fixed;
  2    65 
  2    66      dcl	   gk_info_version_0      internal static fixed options (constant) init (0);
  2    67 
  2    68 /* end ak_info.incl.pl1 */
      123 
      124 
      125 /* initialize */
      126 
      127 	pm_code = 0;
      128 	pm_dict_path = "";
      129 	aborting = (pm_err_p = null());
      130 	if ^aborting
      131 	     then bad_dicts.n = 0;
      132 	
      133 	if system_area_p = null
      134 	then call get_system_free_area_ (system_area_p);
      135 
      136 	forget_sw = "0"b;
      137 	prev_level = level;
      138 	on cleanup call cleaner;
      139 	level = level + 1;
      140 
      141 /* open dictionaries from search list if not already open */
      142 
      143 	if ^have_dictionaries
      144 	then do;
      145 	     if prev_level > 0
      146 	     then go to cant_do;
      147 
      148 	     sl_info_p, dict_iocbps_p = null;
      149 	     forget_sw = "1"b;
      150 	     call get_dictionaries;
      151 	     forget_sw = "0"b;
      152 	end;
      153 	else do;
      154 	     sl_info_p = static_sl_info_p;
      155 	     ndict = sl_info.num_paths;
      156 	     dict_iocbps_p = static_dict_iocbps_p;
      157 	     good_dicts_p = static_good_dicts_p;
      158 	     do dictx = 1 to ndict;
      159 		if ^(good_dicts (dictx))		/* if dict was flagged as bad */
      160 		     then do;			/* in last invocation */
      161 		     forget_sw = "1"b;
      162 		     call retry_bad_dict;		/* then see if it works now */
      163 		     forget_sw = "0"b;
      164 		end;
      165 	     end;
      166 	end;
      167 
      168 /* reopen dictionaries if search list has changed */
      169 
      170 	if current_sl_index ^= sl_info.change_index
      171 	then do;
      172 	     if prev_level > 0
      173 	     then go to cant_do;
      174 
      175 	     if ^aborting
      176 		then bad_dicts.n = 0;
      177 	     forget_sw = "1"b;
      178 	     call forget_dictionaries;
      179 	     call get_dictionaries;
      180 	     forget_sw = "0"b;
      181 	end;
      182 
      183 /* scan the dictionaries in order for the specified word */
      184 
      185 	if length (rtrim (pm_word)) > 256		/* max word size = 256 */
      186 	then go to not_found;
      187 	word = substr (pm_word, 1, length (rtrim (pm_word)));
      188 	unspec (fdw_control) = pm_control;
      189 
      190 	get_key_info.flags.input_key = "1"b;
      191 	get_key_info.input_desc = "0"b;
      192 	get_key_info.desc_code = 0;
      193 	get_key_info.rel_type = 0;
      194 	get_key_info.head_size = 256;
      195 	get_key_info.reset_pos = "0"b;
      196 	get_key_info.pad = ""b;
      197 	get_key_info.version = gk_info_version_0;
      198 
      199 	do dictx = 1 to ndict;
      200 	     pm_dict_path = sl_info.pathname (dictx);
      201 	     if word_found ()
      202 	     then go to finish;
      203 	end;
      204 
      205 	pm_dict_path = "";
      206 
      207 not_found: pm_code = error_table_$id_not_found;
      208 
      209 finish:	if pm_code = 0 & ^aborting
      210 	     then if bad_dicts.n ^= 0
      211 	     then pm_code = error_table_$recoverable_error;
      212 	call cleaner;
      213 	return;
      214 
      215 cant_do:	call sub_err_ (0, "find_dict_word_", "s", null, (0),
      216 	     "Cannot proceed without harm to prior activation. Please restart or release level ^d.", prev_level);
      217 	go to cant_do;				/* should never get here, but just in case */
      218 
      219 cleaner:	proc;					/* cleanup procedure */
      220 
      221 	     level = prev_level;
      222 	     if forget_sw
      223 	     then call forget_dictionaries;
      224 
      225 	end cleaner;
      226 
      227 /* This procedure opens the dictionaries defined in the "dict" search list. */
      228 
      229 get_dictionaries: proc;
      230 
      231 dcl  i fixed bin;
      232 
      233 
      234 	     call search_paths_$get ("dict", "111111"b, "", null, system_area_p,
      235 		sl_info_version_1, sl_info_p, pm_code);
      236 	     if pm_code ^= 0
      237 	     then go to finish;
      238 
      239 	     ndict = sl_info.num_paths;
      240 	     allocate dict_iocbps in (system_area);
      241 	     allocate good_dicts in (system_area);
      242 	     dict_iocbps (*) = null;
      243 	     good_dicts (*) = "0"b;
      244 	     
      245 	     do i = 1 to ndict;
      246 		pm_dict_path = sl_info.pathname (i);
      247 		switch = unique_chars_ (""b);		/* use unique I/O switch name */
      248 		atd = "vfile_ " || rtrim (sl_info.pathname (i)) || " -share"; /* build attach description */
      249 		call iox_$attach_name (switch, dict_iocbps (i), atd, find_dict_word_, pm_code);
      250 		if pm_code ^= 0
      251 		     then if aborting		/* abort if that's what he wants */
      252 		     then goto finish;
      253 		else call log_bad_dict (i);		/* or just record the bad one */
      254 		else do;
      255 		     call iox_$open (dict_iocbps (i), keyed_sequential_input, "0"b, pm_code);
      256 		     if pm_code ^= 0
      257 			then if aborting		/* same here */
      258 			then goto finish;
      259 		     else do;
      260 			call log_bad_dict (i);	/* and here */
      261 			call iox_$detach_iocb (dict_iocbps (i), pm_code);
      262 		     end;
      263 		     else good_dicts (i) = "1"b;	/* everybody's happy */
      264 		end;
      265 	     end;
      266 
      267 	     if (string (good_dicts) = "0"b)		/* he told us not to abort */
      268 		then do;				/* but ALL the dictionaries */
      269 		pm_code = error_table_$fatal_error;	/* are bad */
      270 		goto finish;			/* so abort anyway */
      271 	     end;
      272 	     	     
      273 	     pm_dict_path = "";
      274 
      275 	     static_sl_info_p = sl_info_p;
      276 	     static_dict_iocbps_p = dict_iocbps_p;
      277 	     static_good_dicts_p = good_dicts_p;
      278 	     have_dictionaries = "1"b;
      279 
      280 	end get_dictionaries;
      281 
      282 /* This procedure closes any previously opened dictionaries */
      283 
      284 forget_dictionaries: proc;
      285 
      286 dcl  i fixed bin;
      287 dcl  code fixed bin (35);
      288 
      289 
      290 	     have_dictionaries = "0"b;
      291 
      292 	     if dict_iocbps_p ^= null
      293 	     then do;
      294 		do i = 1 to ndict;
      295 		     if dict_iocbps (i) ^= null 
      296 		     then do;
      297 			call iox_$close (dict_iocbps (i), code);
      298 			call iox_$detach_iocb (dict_iocbps (i), code);
      299 			dict_iocbps (i) = null;
      300 		     end;
      301 		end;
      302 		free dict_iocbps in (system_area);
      303 		dict_iocbps_p = null;
      304 		free good_dicts in (system_area);
      305 		good_dicts_p = null;
      306 	     end;
      307 
      308 	     if sl_info_p ^= null
      309 	     then do;
      310 		free sl_info in (system_area);
      311 		sl_info_p = null;
      312 	     end;
      313 
      314 	end forget_dictionaries;
      315 
      316 /* This procedure attempts to open a dictionary that was previously flagged as
      317*   bad (probably non-existent).
      318**/
      319 
      320 retry_bad_dict:
      321 	proc;
      322 	
      323 		pm_dict_path = sl_info.pathname (dictx);
      324 		switch = unique_chars_ (""b);		/* use unique I/O switch name */
      325 		atd = "vfile_ " || rtrim (sl_info.pathname (dictx)) || " -share"; /* build attach description */
      326 		call iox_$attach_name (switch, dict_iocbps (dictx), atd, find_dict_word_, pm_code);
      327 		if pm_code = 0
      328 		     then do;
      329 		     call iox_$open (dict_iocbps (dictx), keyed_sequential_input, "0"b, pm_code);
      330 		     if pm_code = 0
      331 			then good_dicts (dictx) = "1"b;
      332 		     else do;
      333 			if aborting 
      334 			     then goto finish;
      335 			call log_bad_dict (dictx);
      336 			call iox_$detach_iocb (dict_iocbps (dictx), pm_code);
      337 		     end;
      338 		end;
      339 		else if aborting
      340 		     then goto finish;
      341 		else call log_bad_dict (dictx);
      342 							
      343 		pm_dict_path = "";
      344 
      345 	     end retry_bad_dict;
      346 
      347 /* This procedure puts the error code and associated pathname for a bad
      348*   dictionary in the structure bad_dicts so that the calling procedure
      349*   can report the errors. */
      350 
      351 log_bad_dict:  proc (which);
      352 
      353 dcl which fixed bin parameter;
      354 
      355 	     bad_dicts.n = bad_dicts.n + 1;
      356 	     bad_dicts.entry.ecode (bad_dicts.n) = pm_code;
      357 	     bad_dicts.entry.path (bad_dicts.n) = sl_info.pathname (which);
      358 	     pm_code = 0;
      359 
      360 	end log_bad_dict;
      361 
      362 /* This procedure finds the specified word in the current dictionary.
      363*   If the word does not exist and the exact_match option was not specified,
      364*   the word is checked for standard capitalization.  If standard capitalization
      365*   is found, then the dictionary is consulted again for decapitalized
      366*   forms of the same word.
      367**/
      368 
      369 word_found: proc returns (bit (1) aligned);
      370 
      371 	     if ^(good_dicts (dictx))			/* ignore bad dictionary */
      372 		then return ("0"b);
      373 
      374 	     get_key_info.key = word;
      375 	     if known_word ()
      376 	     then return ("1"b);
      377 
      378 	     if fdw_control.exact_match
      379 	     then return ("0"b);
      380 
      381 	     if verify (word, capital_letters) = 0
      382 	     then do;
      383 		if length (word) > 1
      384 		then do;
      385 		     substr (get_key_info.key, 2) = translate (substr (word, 2), small_letters, capital_letters);
      386 		     if known_word ()
      387 		     then return ("1"b);
      388 		end;
      389 check_no_cap:
      390 		get_key_info.key = translate (word, small_letters, capital_letters);
      391 		if known_word ()
      392 		then return ("1"b);
      393 	     end;
      394 	     else if length (word) > 1
      395 	     then if search (substr (word, 1, 1), capital_letters) = 1
      396 		& verify (substr (word, 2), small_letters) = 0
      397 		then go to check_no_cap;
      398 
      399 	     return ("0"b);
      400 
      401 	end word_found;
      402 
      403 /* This procedure determines whether or not a specified word is "known",
      404*   i.e., whether or not the word is defined in the current dictionary.
      405**/
      406 
      407 known_word: proc returns (bit (1) aligned);
      408 
      409 
      410 	     get_key_info.key_len = 256;
      411 	     call iox_$control (dict_iocbps (dictx), "get_key", addr (get_key_info), pm_code);
      412 	     if pm_code ^= 0
      413 	     then if pm_code = error_table_$no_record | pm_code = error_table_$no_key
      414 		then return ("0"b);
      415 		else go to finish;
      416 
      417 	     pm_word_found = get_key_info.key;
      418 	     pm_descrip = get_key_info.descrip;
      419 
      420 	     return ("1"b);
      421 
      422 	end known_word;
      423 
      424 
      425      end find_dict_word_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/16/88  1411.9  find_dict_word_.pl1               >spec>install>MR12.2-1023>find_dict_word_.pl1
121          1    02/16/88  1407.4  sl_info.incl.pl1                  >spec>install>MR12.2-1023>sl_info.incl.pl1
123          2    07/19/79  1547.0  ak_info.incl.pl1                  >ldd>include>ak_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
aborting                        000100 automatic       bit(1)                   unaligned dcl 36 set ref 129* 130 175 209 250 256
                                                                                  333 339
addr                                                   builtin function         dcl 102 ref 411 411
ak_header                              based           structure                level 1 unaligned dcl 2-10
atd                             000122 automatic       char(256)                unaligned dcl 44 set ref 248* 249* 325* 326*
bad_dicts                              based           structure                level 1 dcl 66
capital_letters                 000007 constant        char(26)                 initial unaligned dcl 82 ref 381 385 389 394
change_index              4            based           fixed bin(71,0)          level 2 dcl 1-15 ref 170
change_index_p            2            based           pointer                  level 2 dcl 1-15 ref 170
cleanup                         000430 stack reference condition                dcl 97 ref 138
code                            000101 automatic       fixed bin(35,0)          dcl 287 set ref 297* 298*
current_sl_index                       based           fixed bin(71,0)          dcl 61 ref 170
desc_code                 0(02) 000324 automatic       fixed bin(2,0)           level 3 packed unaligned dcl 52 set ref 192*
descrip                   1     000324 automatic       bit(36)                  level 2 dcl 52 set ref 418
dict_iocbps                            based           pointer                  array dcl 63 set ref 240 242* 249* 255* 261* 295
                                                                                  297* 298* 299* 302 326* 329* 336* 411*
dict_iocbps_p                   000106 automatic       pointer                  dcl 41 set ref 148* 156* 240* 242 249 255 261 276
                                                                                  292 295 297 298 299 302 303* 326 329 336 411
dictx                           000102 automatic       fixed bin(17,0)          dcl 38 set ref 158* 159* 199* 200* 323 325 326 329
                                                                                  330 335* 336 341* 371 411
ecode                     1            based           fixed bin(35,0)          array level 3 dcl 66 set ref 356*
entry                     1            based           structure                array level 2 dcl 66
error_table_$fatal_error        000030 external static fixed bin(35,0)          dcl 89 ref 269
error_table_$id_not_found       000026 external static fixed bin(35,0)          dcl 87 ref 207
error_table_$no_key             000024 external static fixed bin(35,0)          dcl 86 ref 412
error_table_$no_record          000022 external static fixed bin(35,0)          dcl 85 ref 412
error_table_$recoverable_error  000032 external static fixed bin(35,0)          dcl 90 ref 209
exact_match                     000323 automatic       bit(1)                   level 2 packed unaligned dcl 48 set ref 378
fdw_control                     000323 automatic       structure                level 1 dcl 48 set ref 188*
flags                           000324 automatic       structure                level 2 in structure "get_key_info" dcl 52
                                                                                  in procedure "find_dict_word_"
flags                                  based           structure                level 2 in structure "gk_header" dcl 2-46
                                                                                  in procedure "find_dict_word_"
flags                                  based           structure                level 3 in structure "gk_info" dcl 2-41 in procedure
                                                                                  "find_dict_word_"
forget_sw                       000104 automatic       bit(1)                   dcl 40 set ref 136* 149* 151* 161* 163* 177* 180*
                                                                                  222
get_key_info                    000324 automatic       structure                level 1 dcl 52 set ref 411 411
get_system_free_area_           000034 constant        entry                    external dcl 107 ref 133
gk_header                              based           structure                level 1 unaligned dcl 2-46
gk_info_version_0                      constant        fixed bin(17,0)          initial dcl 2-66 ref 197
good_dicts                             based           bit(1)                   array unaligned dcl 64 set ref 159 241 243* 263* 267
                                                                                  304 330* 371
good_dicts_p                    000110 automatic       pointer                  dcl 42 set ref 157* 159 241* 243 263 267 277 304
                                                                                  305* 330 371
have_dictionaries               000013 internal static bit(1)                   initial dcl 76 set ref 143 278* 290*
head_size                 0(09) 000324 automatic       fixed bin(9,0)           level 4 packed unsigned unaligned dcl 52 set ref
                                                                                  194*
i                               000100 automatic       fixed bin(17,0)          dcl 286 in procedure "forget_dictionaries" set ref
                                                                                  294* 295 297 298 299*
i                               000450 automatic       fixed bin(17,0)          dcl 231 in procedure "get_dictionaries" set ref 245*
                                                                                  246 248 249 253* 255 260* 261 263*
input_desc                0(01) 000324 automatic       bit(1)                   level 3 packed unaligned dcl 52 set ref 191*
input_key                       000324 automatic       bit(1)                   level 3 packed unaligned dcl 52 set ref 190*
iox_$attach_name                000042 constant        entry                    external dcl 111 ref 249 326
iox_$close                      000046 constant        entry                    external dcl 113 ref 297
iox_$control                    000052 constant        entry                    external dcl 115 ref 411
iox_$detach_iocb                000050 constant        entry                    external dcl 114 ref 261 298 336
iox_$open                       000044 constant        entry                    external dcl 112 ref 255 329
key                       3     000324 automatic       char(256)                level 2 dcl 52 set ref 374* 385* 389* 417
key_len                   2     000324 automatic       fixed bin(17,0)          level 2 dcl 52 set ref 410*
keyed_sequential_input          000016 constant        fixed bin(17,0)          initial dcl 81 set ref 255* 329*
length                                                 builtin function         dcl 102 ref 185 187 383 394
level                           000012 internal static fixed bin(17,0)          initial dcl 75 set ref 137 139* 139 221*
n                                      based           fixed bin(17,0)          level 2 dcl 66 set ref 130* 175* 209 355* 355 356
                                                                                  357
ndict                           000101 automatic       fixed bin(17,0)          dcl 37 set ref 155* 158 199 239* 240 241 242 243 245
                                                                                  267 294 302 304
null                                                   builtin function         dcl 102 ref 129 133 148 215 215 234 234 242 292 295
                                                                                  299 303 305 308 311
num_paths                 1            based           fixed bin(17,0)          level 2 dcl 1-15 ref 155 239 310
pad                       0(19) 000324 automatic       bit(8)                   level 3 packed unaligned dcl 52 set ref 196*
path                      2            based           char(168)                array level 3 packed unaligned dcl 66 set ref 357*
pathname                 17            based           char(168)                array level 3 packed unaligned dcl 1-15 ref 200 246
                                                                                  248 323 325 357
paths                    14            based           structure                array level 2 dcl 1-15
pm_code                                parameter       fixed bin(35,0)          dcl 31 set ref 11 127* 207* 209 209* 234* 236 249*
                                                                                  250 255* 256 261* 269* 326* 327 329* 330 336* 356
                                                                                  358* 411* 412 412 412
pm_control                             parameter       bit(36)                  dcl 26 ref 11 188
pm_descrip                             parameter       bit(36)                  dcl 28 set ref 11 418*
pm_dict_path                           parameter       char(168)                unaligned dcl 29 set ref 11 128* 200* 205* 246* 273*
                                                                                  323* 343*
pm_err_p                               parameter       pointer                  dcl 30 ref 11 129 130 175 209 355 355 356 356 357
                                                                                  357
pm_word                                parameter       char                     unaligned dcl 25 ref 11 185 187 187
pm_word_found                          parameter       char(256)                unaligned dcl 27 set ref 11 417*
position_specification
                          0(05) 000324 automatic       structure                level 3 packed unaligned dcl 52
prev_level                      000103 automatic       fixed bin(17,0)          dcl 39 set ref 137* 145 172 215* 221
rel_type                  0(06) 000324 automatic       fixed bin(2,0)           level 4 packed unaligned dcl 52 set ref 193*
reset_pos                 0(18) 000324 automatic       bit(1)                   level 3 packed unaligned dcl 52 set ref 195*
rk_header                              based           structure                level 1 unaligned dcl 2-26
rtrim                                                  builtin function         dcl 102 ref 185 187 248 325
search                                                 builtin function         dcl 102 ref 394
search_paths_$get               000036 constant        entry                    external dcl 108 ref 234
sl_info                                based           structure                level 1 dcl 1-15 ref 310
sl_info_p                       000436 automatic       pointer                  dcl 1-28 set ref 148* 154* 155 170 170 200 234* 239
                                                                                  246 248 275 308 310 311* 323 325 357
sl_info_version_1               000043 constant        fixed bin(17,0)          initial dcl 1-29 set ref 234*
small_letters                   000000 constant        char(26)                 initial unaligned dcl 83 ref 385 389 394
static_dict_iocbps_p            000016 internal static pointer                  dcl 78 set ref 156 276*
static_good_dicts_p             000020 internal static pointer                  initial dcl 79 set ref 157 277*
static_sl_info_p                000014 internal static pointer                  dcl 77 set ref 154 275*
string                                                 builtin function         dcl 102 ref 267
sub_err_                        000054 constant        entry                    external dcl 116 ref 215
substr                                                 builtin function         dcl 102 set ref 187 385* 385 394 394
switch                          000112 automatic       char(32)                 unaligned dcl 43 set ref 247* 249* 324* 326*
system_area                            based           area(1024)               dcl 62 ref 240 241 302 304 310
system_area_p                   000010 internal static pointer                  initial dcl 74 set ref 133 133* 234* 240 241 302 304
                                                                                  310
translate                                              builtin function         dcl 102 ref 385 389
unique_chars_                   000040 constant        entry                    external dcl 110 ref 247 324
unspec                                                 builtin function         dcl 102 set ref 188*
verify                                                 builtin function         dcl 102 ref 381 394
version                   0(27) 000324 automatic       fixed bin(8,0)           level 3 packed unaligned dcl 52 set ref 197*
which                                  parameter       fixed bin(17,0)          dcl 353 ref 351 357
word                            000222 automatic       varying char(256)        dcl 45 set ref 187* 374 381 383 385 389 394 394 394

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_PATH                          internal static fixed bin(17,0)          initial dcl 1-33
HOME_DIR                               internal static fixed bin(17,0)          initial dcl 1-38
INITIATED_SEGS                         internal static fixed bin(17,0)          initial dcl 1-39
PROCESS_DIR                            internal static fixed bin(17,0)          initial dcl 1-37
REFERENCING_DIR                        internal static fixed bin(17,0)          initial dcl 1-35
UNEXPANDED_PATH                        internal static fixed bin(17,0)          initial dcl 1-34
WORKING_DIR                            internal static fixed bin(17,0)          initial dcl 1-36
ak_info                                based           structure                level 1 unaligned dcl 2-6
ak_info_ptr                            automatic       pointer                  dcl 2-18
ak_key_len                             automatic       fixed bin(17,0)          dcl 2-19
bin                                                    builtin function         dcl 102
bit                                                    builtin function         dcl 102
error_table_$no_search_list            external static fixed bin(35,0)          dcl 88
gk_info                                based           structure                level 1 unaligned dcl 2-41
gk_info_ptr                            automatic       pointer                  dcl 2-63
gk_key_len                             automatic       fixed bin(17,0)          dcl 2-64
info_ptr                               automatic       pointer                  dcl 46
rk_info                                based           structure                level 1 unaligned dcl 2-22
rk_info_ptr                            automatic       pointer                  dcl 2-37
rk_key_len                             automatic       fixed bin(17,0)          dcl 2-38
search_list_defaults_$dict             external static fixed bin(17,0)          dcl 92
sl_info_num_paths                      automatic       fixed bin(17,0)          dcl 1-27

NAMES DECLARED BY EXPLICIT CONTEXT.
cant_do                         000432 constant        label                    dcl 215 ref 145 172 217
check_no_cap                    001700 constant        label                    dcl 389 ref 394
cleaner                         000511 constant        entry                    internal dcl 219 ref 138 212
find_dict_word_                 000115 constant        entry                    external dcl 11 ref 249 249 326 326
finish                          000412 constant        label                    dcl 209 ref 201 236 250 256 270 333 339 412
forget_dictionaries             001162 constant        entry                    internal dcl 284 ref 178 222
get_dictionaries                000531 constant        entry                    internal dcl 229 ref 150 179
known_word                      001760 constant        entry                    internal dcl 407 ref 375 386 391
log_bad_dict                    001554 constant        entry                    internal dcl 351 ref 253 260 335 341
not_found                       000407 constant        label                    dcl 207 ref 185
retry_bad_dict                  001310 constant        entry                    internal dcl 320 ref 162
word_found                      001602 constant        entry                    internal dcl 369 ref 201

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3106        3164    2677        3116
Length      3430    2677        56         227     207          12

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
find_dict_word_                     502 external procedure  is an external procedure.  
on unit on line 138                  64 on unit               
cleaner                              64 internal procedure  is called by several nonquick procedures.  
get_dictionaries                        internal procedure  shares stack frame of external procedure find_dict_word_.  
forget_dictionaries                  74 internal procedure  is called by several nonquick procedures.  
retry_bad_dict                          internal procedure  shares stack frame of external procedure find_dict_word_.  
log_bad_dict                            internal procedure  shares stack frame of external procedure find_dict_word_.  
word_found                              internal procedure  shares stack frame of external procedure find_dict_word_.  
known_word                              internal procedure  shares stack frame of external procedure find_dict_word_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 system_area_p               find_dict_word_
000012 level                       find_dict_word_
000013 have_dictionaries           find_dict_word_
000014 static_sl_info_p            find_dict_word_
000016 static_dict_iocbps_p        find_dict_word_
000020 static_good_dicts_p         find_dict_word_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
find_dict_word_          000100 aborting                    find_dict_word_
                         000101 ndict                       find_dict_word_
                         000102 dictx                       find_dict_word_
                         000103 prev_level                  find_dict_word_
                         000104 forget_sw                   find_dict_word_
                         000106 dict_iocbps_p               find_dict_word_
                         000110 good_dicts_p                find_dict_word_
                         000112 switch                      find_dict_word_
                         000122 atd                         find_dict_word_
                         000222 word                        find_dict_word_
                         000323 fdw_control                 find_dict_word_
                         000324 get_key_info                find_dict_word_
                         000436 sl_info_p                   find_dict_word_
                         000450 i                           get_dictionaries
forget_dictionaries      000100 i                           forget_dictionaries
                         000101 code                        forget_dictionaries

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return_mac          enable_op           shorten_stack       ext_entry_desc      int_entry
op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_system_free_area_         iox_$attach_name              iox_$close                    iox_$control
iox_$detach_iocb              iox_$open                     search_paths_$get             sub_err_
unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$fatal_error      error_table_$id_not_found     error_table_$no_key           error_table_$no_record
error_table_$recoverable_error




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000107       127 000130       128 000132       129 000136       130 000143       133 000146       136 000160
    137 000161       138 000164       139 000206       143 000210       145 000212       148 000214       149 000217
    150 000221       151 000222       152 000223       154 000224       155 000226       156 000231       157 000233
    158 000235       159 000243       161 000250       162 000252       163 000253       165 000254       170 000256
    172 000262       175 000264       177 000271       178 000273       179 000277       180 000300       185 000301
    187 000317       188 000326       190 000330       191 000332       192 000334       193 000340       194 000344
    195 000346       196 000350       197 000352       199 000354       200 000363       201 000373       203 000400
    205 000402       207 000407       209 000412       212 000425       213 000431       215 000432       217 000507
    219 000510       221 000516       222 000521       225 000530       229 000531       234 000532       236 000604
    239 000607       240 000612       241 000621       242 000631       243 000646       245 000661       246 000671
    247 000701       248 000721       249 000774       250 001042       253 001047       255 001052       256 001073
    260 001100       261 001102       262 001117       263 001120       265 001125       267 001127       269 001135
    270 001141       273 001142       275 001147       276 001152       277 001154       278 001156       280 001160
    284 001161       290 001167       292 001170       294 001175       295 001205       297 001215       298 001227
    299 001243       301 001250       302 001252       303 001257       304 001262       305 001267       308 001272
    310 001276       311 001304       314 001307       320 001310       323 001311       324 001322       325 001342
    326 001415       327 001462       329 001465       330 001507       333 001520       335 001522       336 001524
    338 001541       339 001542       341 001544       343 001546       345 001553       351 001554       355 001556
    356 001561       357 001567       358 001577       360 001601       369 001602       371 001604       374 001614
    375 001620       378 001631       381 001637       383 001652       385 001655       386 001666       389 001700
    391 001712       393 001724       394 001725       399 001755       407 001760       410 001762       411 001764
    412 002024       417 002037       418 002043       420 002045


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
