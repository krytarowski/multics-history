	COMPILATION LISTING OF SEGMENT comp_expr_eval_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/23/85  0951.9 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   * Copyright, (C) Honeywell Information Systems Inc., 1980 *
        6*   *                                                         *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 /* compose subroutine to evaluate expressions. */
       11 
       12 /* format: style2,ind2,ll79,dclind4,idind15,comcol41,linecom */
       13 
       14 comp_expr_eval_:
       15   proc (buffer, start, info_ptr, needtyp, restyp, reslog, resnum, resstr,
       16        res_attr, ercd);
       17 
       18 /* PARAMETERS */
       19 
       20     dcl buffer	   char (*) var;	/* IN buffer containing <expr> */
       21     dcl start	   fixed bin (21);	/* IN/OUT starting char of <expr> */
       22     dcl info_ptr	   ptr;		/* IN info structure for buffer */
       23     dcl needtyp	   fixed bin;	/* IN needed type LOG/NUM/STR */
       24     dcl restyp	   fixed bin;	/* OUT result type LOG/NUM/STR */
       25     dcl reslog	   bit (1);	/* OUT result value for LOG */
       26     dcl resnum	   fixed bin (31);	/* OUT result value for NUM */
       27     dcl resstr	   char (*) var;	/* OUT result value for STR */
       28     dcl res_attr	   bit (9);	/* OUT attributes of result value */
       29     dcl ercd	   fixed bin (35);	/* error code */
       30 
       31 /* This is an anotated debug output from this procedure.		       */
       32 /*			    "o >" push operator		       */
       33 /*    +-------------- action flag " v>" push operand onto operator	       */
       34 /*    |			    "<ov" pop operand and operator	       */
       35 /*    |			    "< v" pop operand (operator remains)	       */
       36 /*    |  +----------- depth in stack				       */
       37 /*    |  |  +-------- type of operation				       */
       38 /*    |  |  | +------ operator precedence, 1(low) 9(high)		       */
       39 /*    |  |  | | +---- operand  type (if present) Logical, Numeric, String    */
       40 /*    |  |  | | | +-- operand value (if present)			       */
       41 /*    |  |  | | | |						       */
       42 /*    |  |  | | | |						       */
       43 /*                  expr_eval: ""a"="b" "DE" & (4 * (1 - "4")) > 5 & 1+21"   */
       44 /*   o >  1 << 0	     : push begin-expr operator at depth 1 to initialize */
       45 /*    v>  1 << 0 S "a"   : next up is a string, this operand is pushed at    */
       46 /*		     :	depth 1				       */
       47 /*   o >  2 =  6	     : the "=" operator is next. since its precedence    */
       48 /*		     :	(6) is higher than that of "<<" (0), the "="   */
       49 /*		     :	is pushed at depth 2		       */
       50 /*    v>  2 =  6 S "bDE" : the pair of strings which follow are concatenated */
       51 /*		     :	and treated as a single operand which is       */
       52 /*		     :	pushed at depth 2			       */
       53 /*		     : next up is the "&" operator which has precedence  */
       54 /*		     : 	5 (which will be seen in a few lines). Since   */
       55 /*		     :	this is less than the 6 which is on top of     */
       56 /*		     :	the stack, the operation stacked must be done  */
       57 /*		     :    before the "&" can be pushed.		       */
       58 /*   <ov  2 =  6 S "bDE" :    Taking to operands in the order 1-2 and the    */
       59 /*   < v  1 << 0 S "a"   :	operator at 2, we can see that the stacked     */
       60 /*		     :    operation is: "a"="bDE"		       */
       61 /*    v>  1 << 0 L F     : The result of this is a logical FALSE (0) which   */
       62 /*		     :    gets pushed at depth 1 to become the operand   */
       63 /*		     :    at that level			       */
       64 /*   o >  2 &  5	     : Now, the precedence 5 is higher than the stacked  */
       65 /*		     :    precedence 0, so the "&" is pushed at depth 2  */
       66 /*   o >  3 (  1	     : Then comes a "(" operator. This has a tabular     */
       67 /*		     :    precedence of B, higher than any other. So it  */
       68 /*		     :    is pushed, but with the shown precedence of 1  */
       69 /*		     :    so that ANYTHING will push on top of it.       */
       70 /*    v>  3 (  1 N 4.    : The numeric "4" which is next is then pushed at   */
       71 /*		     :    depth 3				       */
       72 /*   o >  4 *  8	     : The "*" operator has a precedence of 8, higher    */
       73 /*		     :    than the stacked 1, so it is stacked.	       */
       74 /*   o >  5 (  1	     : This "(" is also stacked at the next level.       */
       75 /*    v>  5 (  1 N 1.    : The numeric operand "1" is stacked at depth 5     */
       76 /*   o >  6 -  7	     : The "-" operator is of higher precedence than the */
       77 /*		     :    stacked "(" so it gets stacked, too.	       */
       78 /*    v>  6 -  7 S "4"   : A string operand "4" is present next and is also  */
       79 /*		     :    stacked, at depth 6			       */
       80 /*		     : Next in the expression is a ")". This has a       */
       81 /*		     :    tabulated precedence of / (which is <0). Since */
       82 /*		     :    the stacked operator is higher, it must be     */
       83 /*		     :    performed at this time.		       */
       84 /*   <ov  6 -  7 N 4.    : The expression to be evaluated is made up of      */
       85 /*   < v  5 (  1 N 1.    :    operands 5-6 and operator 6. Note that operand */
       86 /*		     :    6 has been converted to numeric as is needed   */
       87 /*		     :    by the "-" operator. The expression is: 1-4    */
       88 /*    v>  5 (  1 N -3.   : The result, "-3", then replaces the expression in */
       89 /*		     :    the stack				       */
       90 /*   <ov  5 (  1 N -3.   : The "(" operator on top of the stack is of higher */
       91 /*   < v  4 *  8	     :    precedence than the ")" pending, so it is also */
       92 /*		     :    done. Operand 4 is null, but "(" only wants 1  */
       93 /*		     :    so this is just fine. The action is just to    */
       94 /*		     :    copy the operand 5.  The pending ")" operator  */
       95 /*		     :    gets used up in the process.		       */
       96 /*    v>  4 *  8 N -3.   : This result is pushed at depth 4		       */
       97 /*   <ov  4 *  8 N -3.   : Another ")" follows, so another evaluation must   */
       98 /*   < v  3 (  1 N 4.    :    get done. This time the expr indicated by the  */
       99 /*		     :    stack is: 4 * -3			       */
      100 /*    v>  3 (  1 N -12.  : The resulting "-12" gets stacked as depth 3       */
      101 /*   <ov  3 (  1 N -12.  : The evaluation continues with the "(" operator.   */
      102 /*   < v  2 &  5	     :    The "-12" is copied out and the ")" dropped    */
      103 /*    v>  2 &  5 N -12.  : AND it is pushed back as the value at depth 2     */
      104 /*   o >  3 >  6	     : The next operator, ">", is of higher precedence   */
      105 /*		     :    than the stacked "&" and so it gets stacked.   */
      106 /*    v>  3 >  6 N 5.    : The numeric "5" gets stacked at depth 3	       */
      107 /*   <ov  3 >  6 N 5.    : The "&" operator which follows causes an expr to  */
      108 /*   < v  2 &  5 N -12.  :    be evaluated. This is made up of operands 2-3  */
      109 /*		     :    and operator 3 and is: -12 > 5	       */
      110 /*    v>  2 &  5 L F     : The result, FALSE (0), is pushed back at depth 2  */
      111 /*   <ov  2 &  5 L F     : The "&" pending is not less than the "&" stacked. */
      112 /*   < v  1 << 0 L F     :    So another evaluation is done, made up of      */
      113 /*		     :    operands 1-2 and operator 2 are used. This is  */
      114 /*		     :    the expression: 0 & 0 (Both 0's are FALSE)     */
      115 /*    v>  1 << 0 L F     : This FALSE (0) result is put back into the stack  */
      116 /*   o >  2 &  5	     : Now the operator "&" can be pushed	       */
      117 /*    v>  2 &  5 N 1.    : The next numeric operand "1" gets pushed at depth */
      118 /*		     :    2				       */
      119 /*   o >  3 +  7	     : The "+" operator gets pushed because it is of     */
      120 /*		     :    higher precedence			       */
      121 /*    v>  3 +  7 N 21.   : The numeric "21" is also stacked, depth 3	       */
      122 /*   <ov  3 +  7 N 21.   : Finally the end-expression is reached. This has   */
      123 /*   < v  2 &  5 N 1.    :    lower precedence than all other entities and   */
      124 /*		     :    so the whole stack will be flushed. First      */
      125 /*		     :    1 + 21 is pulled from the stack and evaluated  */
      126 /*    v>  2 &  5 N 22.   : This result, "22" is pushed back.	       */
      127 /*   <ov  2 &  5 L T     : The expression TRUE (-1) & FALSE (0) is pulled    */
      128 /*   < v  1 << 0 L F     :    from the stack and evaluated. Note that before */
      129 /*		     :    operand 2 was used, it was converted from a    */
      130 /*		     :    numeric 22 into a logical TRUE (-1).	       */
      131 /*    v>  1 << 0 L F     : This result FALSE (0) is pushed back on the stack */
      132 /*      (expr_eval) L F  : The evaluation is now complete. The bottom of the */
      133 /*		     :    stack contains the result with expr_eval       */
      134 /*		     :    returns to the caller.		       */
      135 /*							       */
      136 
      137 /* LOCAL STORAGE */
      138 
      139     dcl (
      140         BoE	   init (37),	/* << begin expr     */
      141         DIGIT	   init (11),	/* all numeric digits */
      142         EoE	   init (38),	/* >> end expr */
      143         STRING	   init (13)	/* strings */
      144         )		   fixed bin static options (constant);
      145     dcl bufpos	   fixed bin (21);	/* buffer position */
      146     dcl debug	   bit (1);	/* local debug control */
      147     dcl depth	   fixed bin;	/* stack depth */
      148     dcl detail	   bit (1);	/* local debug control */
      149     dcl fb71	   fixed bin (71);	/* for multiplication */
      150     dcl 1 font_ref	   aligned like fntstk_entry;
      151     dcl 1 fun	   based (addr (FuncRes)),
      152 	2 len	   fixed bin (35),
      153 	2 chr	   (1020) char (1);
      154     dcl FuncRes	   char (1020) var; /* result during function work      */
      155 /****    dcl hscales	   (7) fixed bin (31) static options (constant)
      156*/****		   init (7200, 6000, 72000, 2834.65, 12000, 1000, 0);*/
      157     dcl (i, j, k)	   fixed bin;	/* working index */
      158     dcl max_width	   fixed bin (31);	/* millipoints		       */
      159     dcl msg	   char (64) var;	/* error messages */
      160 				/* keyword for numerics */
      161     dcl num_val_key	   char (12) var init ("");
      162 
      163     dcl 1 opstk	   (20),		/* operation stack */
      164 	2 e,			/* entry structure */
      165 	  3 typ	   fixed bin,	/* type of operation */
      166 	  3 prec	   char (1),	/* precedence thereof */
      167 	  3 log_val  bit (1),	/* logical value */
      168 	  3 num_val  fixed bin (31),	/* numeric value associated with */
      169 				/* operation, usually the value */
      170 				/* right after it in the stack */
      171 	  3 str_val,		/* points to string value */
      172 	    4 (ofst, len)
      173 		   fixed bin,	/* offset,length in strs */
      174 	  3 val_typ  fixed bin;	/* value type (types follow) -- */
      175 				/* not present */
      176     dcl NONE	   fixed bin int static init (0);
      177 				/* logical */
      178     dcl LOG	   fixed bin int static init (1);
      179 				/* numeric */
      180     dcl NUM	   fixed bin int static init (2);
      181 				/* string */
      182     dcl STR	   fixed bin int static init (3);
      183 				/* various opstk entries */
      184     dcl curop_ptr	   ptr;		/* the current operation */
      185     dcl 1 curop	   like opstk.e based (curop_ptr);
      186     dcl prvop_ptr	   ptr;		/* the previous operation */
      187     dcl 1 prvop	   like opstk.e based (prvop_ptr);
      188 
      189     dcl OFF	   bit (1) static options (constant) init ("0"b);
      190     dcl ON	   bit (1) static options (constant) init ("1"b);
      191     dcl op1	   char (3);	/* operands for error reporting      */
      192     dcl op2	   char (2);	/* operands for error reporting      */
      193     dcl opnd_need	   char (1);	/* number of operands needed */
      194     dcl op_typ	   fixed bin;	/* operator type		       */
      195     dcl oprec	   char (1);	/* working precedence	       */
      196     dcl ot	   fixed bin;	/* working operand type	       */
      197     dcl RtP	   fixed bin static options (constant) init (39);
      198 				/* )  right paren    */
      199     dcl scale	   (1) fixed bin (31) static options (constant)
      200 		   init (1000);
      201     dcl strs	   char (10000);	/* place to hold temporary strings   */
      202     dcl strse	   fixed bin;	/* first location in strs available  */
      203     dcl strsu	   fixed bin;	/* amount of strs actually in use    */
      204     dcl temp_log	   bit (1);	/* temporary logical value */
      205     dcl temp_num	   fixed bin (31);	/* temporary numeric value */
      206     dcl temp_str	   char (3000) var; /* temporary string value */
      207     dcl temp_typ	   fixed bin;	/* temporary value type */
      208 /****    dcl vscales	   (7) fixed bin (31) static options (constant)
      209*/****		   init (12000, 9000, 72000, 2834.65, 12000, 1000, 0);*/
      210     dcl width	   fixed bin (31);	/* millipoints */
      211 				/* for measuring */
      212     dcl 1 meas1	   aligned like text_entry.cur;
      213     dcl 1 meas2	   aligned like text_entry.cur;
      214 
      215     dcl (addr, bit, bool, convert, fixed, index, length, max, mod, null,
      216         search, substr, verify)
      217 		   builtin;
      218 
      219     dcl comp_error_table_$usage_error
      220 		   fixed bin (35) ext static;
      221 
      222 /* processing control data */
      223 
      224 /* The duplication of characters in proc_ctl.type is for the purpose of  */
      225 /* holding a place.  The "(==_", for example.  The 2nd = can never found by */
      226 /* index.However, the location in the string of the 2nd one, 17, represents */
      227 /* the "opcode" to match the "=" operator.			       */
      228 /*							       */
      229 /* The algorithm works in this fashion:				       */
      230 /* 0) push a begin-expression ("<<") on to the operator stack	       */
      231 /* 1) make sure the XOR operator is canonical if it is next up	       */
      232 /*    if no more data, generate end-expression (">>") token		       */
      233 /*    pick up the next char of input and index for it into proc_ctl.type.    */
      234 /*    If it is not found, go check for a builtin function.		       */
      235 /* 2) pick up from proc_ctl.prec the corresponding precedence	       */
      236 /* 3) if the precedence is "s", then skip the token		       */
      237 /*    if the precedence is 'x', then look for an '=' following.  This then   */
      238 /*      tells if "^=" "<=" ">=" is there instead of just "^" "<" ">".	       */
      239 /*      also checks for "^|"					       */
      240 /*    if the precedence is "y", then look for "<BSP>_" following.  This      */
      241 /*      differentiates "=<BSP>_" from "="			       */
      242 /* 4) If the token found is an operand or "(", then go push it on the stack  */
      243 /* 5) If the the precedence of the new token (operator) is higher than the   */
      244 /*    stacked one, push the operator on the stack.		       */
      245 /* 6) otherwise, process things off the stack until a point is reached where */
      246 /*    the new operator IS higher than what is on the stack.		       */
      247 /*    Each operator is checked to see if the needed number of operands is    */
      248 /*    present in the stack.					       */
      249 /*        A ">>" token will cause everything to be removed from the stack,   */
      250 /*    as will a ",".  If a ")" is encountered which does not have a matching */
      251 /*    "(" in the stack, this is not an error.  It is assumed that the caller */
      252 /*    recognized the leading "(", removed it, and expects to see the	       */
      253 /*    matching ")" upon return.  "abc"(1,2) is an example of when this       */
      254 /*    can happen.						       */
      255 /*							       */
      256 /* This is the precedence assigned by proc_ctl.prec:		       */
      257 /* /  ")","}", "," ">>" (end-expression)			       */
      258 /*        All four of these must flush out much from the stack.	       */
      259 /*        The ")" must find a matching "(" already in the stack.	       */
      260 /*        The ">>" will find a matching "<<" already in the stack.	       */
      261 /*        The other 2 must NOT find "(" in the stack.		       */
      262 /* 0  "<<" begin-expression					       */
      263 /* 1  (UNUSED, however, "(" is pushed as this value so ANYTHING will push on */
      264 /*        top of it.					       */
      265 /* 2  numeric value, any operator will push on top of it		       */
      266 /* 3  "|"							       */
      267 /* 4  "^|", "=<BSP>_"					       */
      268 /* 5  "&"
      269*   6  "=", "^=", "<", "<=", ">", ">="
      270*   7  "+", "-"
      271*   8  "*", "/", "\"
      272*   9  "^"
      273*   B  "(" This is so it will push on top of anything.  However, it gets pushed
      274*	as a "1" so that anything else will, in turn, push on top of it. */
      275 /**** format: off */
      276 dcl 1 proc_ctl	   int static options (constant),
      277 /* 		    000000000111.1111111222222222233333333334444 */
      278 /*		    123456789012.3456789012345678901234567890123 */
      279    (2 type       init ("0123456789.#""TF(==_^^^^<<<>>>+-*/\&|<>),} 	"),
      280     2 prec       init ("222222222222""  By64x964x66x6677888530////ss"),
      281     2 dspl_sfx   init ("         9  ""     =  =|  =  =       <>     "),
      282     2 ops_need   init ("            ""  1 22 122 22 2233222220      "))
      283 		   char (43);	/* this is an HT ----------^ */
      284 /**** format: on */
      285 
      286     restyp = NONE;
      287     res_attr = ""b;
      288     ercd = 0;
      289 
      290     debug = shared.bug_mode | db_sw;	/* set local debug control */
      291     detail = debug & dt_sw;
      292 
      293     if debug
      294     then
      295       do;
      296         call ioa_ ("expr_eval: (^d ^d) ^a ", start, length (buffer),
      297 	   comp_util_$display (buffer, 0, "0"b));
      298       end;
      299 
      300     depth = 0;			/* initialize the operation stack */
      301     opstk.num_val, opstk.typ, opstk.val_typ, temp_num = 0;
      302     opstk.prec = "";
      303     opstk.log_val, temp_log = OFF;
      304     opstk.str_val.ofst = 1;
      305     opstk.str_val.len = 0;
      306     strse = 1;			/* initialize strs area */
      307     strsu = 0;
      308 
      309     if start > length (buffer)	/* if no starting index */
      310     then goto return_;
      311 
      312     op_typ = BoE;			/* start by pushing begin-expression */
      313     oprec = substr (proc_ctl.prec, op_typ, 1);
      314     bufpos = start;
      315 
      316     if index (substr (buffer, start), "{") ^= 1
      317     then start = start - 1;		/* make sure first char gets used    */
      318 
      319 push_op_typ:
      320     depth = depth + 1;
      321     curop_ptr = addr (opstk.e (depth));
      322     if depth > 1
      323     then prvop_ptr = addr (opstk.e (depth - 1));
      324     curop.typ = op_typ;
      325     curop.prec = oprec;
      326     curop.val_typ = NONE;		/* show NO VALUE there */
      327     curop.num_val, curop.str_val.len = 0;
      328     curop.str_val.ofst = 1;
      329 
      330     if detail
      331     then call dumper ("o >", depth);
      332 
      333 parse_loop:
      334     bufpos, start = start + 1;
      335     if start > length (buffer)
      336     then op_typ = EoE;		/* end-of-expression */
      337 
      338     else
      339       do;				/**/
      340 				/* make sure XOR has canonical form */
      341         if length (buffer) - start + 1 >= 3
      342         then if index (substr (buffer, start), "_=") = 1
      343 	   then substr (buffer, start, 3) = "=_";
      344 				/* look up type of next char	       */
      345         op_typ = index (proc_ctl.type, substr (buffer, start, 1));
      346         if op_typ = 0		/* not a known type	       */
      347         then
      348 	do;			/* try known functions */
      349 
      350 /* Measure( <string-expression> ) */
      351 	  if index (substr (buffer, start), "Measure") = 1
      352 	  then
      353 	    do;
      354 	      bufpos, start = start + 7;
      355 				/* step over function name */
      356 				/* there must be an opening paren */
      357 	      if substr (buffer, start, 1) ^= "("
      358 	      then
      359 	        do;
      360 		call comp_report_$ctlstr (2, comp_error_table_$usage_error,
      361 		     info_ptr, buffer,
      362 		     "Missing left parenthesis for Measure");
      363 		goto err_return;
      364 	        end;
      365 	      start = start + 1;	/* step over the paren */
      366 				/* the string must be quoted */
      367 	      if substr (buffer, start, 1) ^= """"
      368 	      then
      369 	        do;
      370 		call comp_report_$ctlstr (2, comp_error_table_$usage_error,
      371 		     info_ptr, buffer, "Missing string value for Measure");
      372 		goto err_return;
      373 	        end;
      374 
      375 	      FuncRes =		/* extract the given string */
      376 		 comp_extr_str_ ("1"b, buffer, start, start, 0, info_ptr);
      377 	      if start = 0		/* something was wrong	       */
      378 	      then goto err_return;
      379 
      380 	      if length (FuncRes) = 0 /* for a null string */
      381 	      then temp_num = 0;
      382 
      383 	      else
      384 	        do;
      385 		font_ref =
      386 		     current_parms.fntstk
      387 		     .entry (current_parms.fntstk.index);
      388 		unspec (meas1) = "0"b;
      389 		call comp_measure_ (FuncRes, addr (font_ref), "0"b, "0"b,
      390 		     "0"b, page_parms.measure, addr (meas1), addr (meas2),
      391 		     info_ptr);
      392 		temp_num = meas1.width + meas1.avg;
      393 	        end;		/**/
      394 				/* there must also be a closing paren */
      395 	      if (substr (buffer, start, 1) ^= ")")
      396 	      then
      397 	        do;
      398 		call comp_report_ (2, 0,
      399 		     "Missing right parenthesis for Measure", info_ptr,
      400 		     buffer);
      401 		goto err_return;
      402 	        end;
      403 
      404 	      temp_typ = NUM;
      405 	      num_val_key = "hspace";
      406 	      res_attr = numeric_attr | hspace_attr;
      407 	      goto push_temp;
      408 	    end;			/**/
      409 
      410 /* Wordl( <string-expression> , <numeric-expression> ) */
      411 	  else if index (substr (buffer, start), "Wordl") = 1
      412 	  then
      413 	    do;			/* step over function name */
      414 	      bufpos, start = start + 5;
      415 				/* must start with a left paren */
      416 	      if substr (buffer, start, 1) ^= "("
      417 	      then
      418 	        do;
      419 		call comp_report_ (2, 0,
      420 		     "Missing left parenthesis for Wordl", info_ptr,
      421 		     buffer);
      422 		goto err_return;
      423 	        end;		/* step over the paren */
      424 	      start = start + 1;	/**/
      425 				/* must be a quoted string */
      426 	      if substr (buffer, start, 1) ^= """"
      427 	      then
      428 	        do;
      429 		call comp_report_ (2, 0, "Missing string value for Wordl",
      430 		     info_ptr, buffer);
      431 		goto err_return;
      432 	        end;
      433 
      434 	      FuncRes =
      435 		 comp_extr_str_ ("1"b, buffer, start, start, 0, info_ptr);
      436 	      if start = 0		/* something was wrong */
      437 	      then goto err_return;
      438 
      439 	      if substr (buffer, start, 1) ^= ","
      440 	      then
      441 	        do;
      442 syntax_error:
      443 		call comp_report_ (2, 0, "Missing comma in Wordl",
      444 		     info_ptr, buffer);
      445 		goto err_return;
      446 	        end;
      447 
      448 	      start = start + 1;	/* skip over the comma */
      449 	      call comp_expr_eval_ (buffer, start, info_ptr, NUM, 0, "0"b,
      450 		 temp_num, "", res_attr, ercd);
      451 	      if ercd ^= 0		/* something was wrong */
      452 	      then goto err_return;
      453 
      454 	      if temp_num <= 0
      455 	      then
      456 	        do;
      457 		call comp_report_ (2, 0, "Improper value for Wordl",
      458 		     info_ptr, buffer);
      459 		goto err_return;
      460 	        end;		/**/
      461 				/* if not horiz space, convert it */
      462 	      if (res_attr & hspace_attr) ^= hspace_attr
      463 	      then
      464 	        do;
      465 		if res_attr & unscaled_attr
      466 		then temp_num = 7200 * divide (temp_num, 1000, 31, 10);
      467 		else if res_attr & vspace_attr
      468 		then temp_num = 7200 * divide (temp_num, 12000, 31, 10);
      469 		else temp_num = 7200 * temp_num;
      470 	        end;
      471 
      472 	      if length (FuncRes) = 0 /* nothing to measure */
      473 	      then temp_num = 0;
      474 
      475 	      else
      476 	        do;
      477 		font_ref =
      478 		     current_parms.fntstk
      479 		     .entry (current_parms.fntstk.index);
      480 		unspec (meas1) = "0"b;
      481 		call comp_measure_ (FuncRes, addr (font_ref), "1"b, "0"b,
      482 		     "0"b, temp_num, addr (meas1), addr (meas2), info_ptr);
      483 		temp_num = 1000 * meas1.chrct;
      484 	        end;
      485 	      temp_typ = NUM;
      486 	      goto push_temp;	/* SUCCESS */
      487 	    end;
      488 
      489 	  else goto unk_func;	/* treat as a decimal */
      490 	end;
      491       end;			/**/
      492 				/* get corresponding precedence  */
      493     oprec = substr (proc_ctl.prec, op_typ, 1);
      494 
      495 /*      call			/* quantum level debugging */
      496 /*         ioa_ ("^-^i:^i ""^1a"" ^i (^1a)", start, length (buffer),
      497*/*         substr (buffer, start, 1), op_typ, oprec);*/
      498 
      499     if oprec = "s"			/* "skip" character */
      500     then goto parse_loop;
      501 
      502     if oprec = "x"			/* type "x", handles ^= <= >= */
      503     then
      504       do;
      505         if (substr (buffer, start + 1, 1) = "=")
      506         then
      507 	do;
      508 	  start = start + 1;
      509 	  op_typ = op_typ + 1;
      510 	end;
      511         else if index (substr (buffer, start), "^|") = 1
      512         then
      513 	do;
      514 	  start = start + 1;
      515 	  op_typ = op_typ + 2;
      516 	end;
      517         op_typ = op_typ + 1;
      518       end;
      519 
      520     else if oprec = "y"		/* type "y", handles EXOR      */
      521     then
      522       do;
      523         if index (substr (buffer, start), "=_") = 1
      524         then
      525 	do;
      526 	  start = start + 2;
      527 	  op_typ = op_typ + 2;
      528 	end;
      529         else op_typ = op_typ + 1;
      530       end;
      531 
      532 unk_func:
      533     if op_typ < DIGIT
      534     then
      535       do;
      536         if search (substr (buffer, start), "TF") = 1
      537         then op_typ = STRING;
      538         else op_typ = DIGIT;		/* any digit gets type DIGIT */
      539       end;			/**/
      540 				/* in case it changed      */
      541     oprec = substr (proc_ctl.prec, op_typ, 1);
      542 
      543 /*        call
      544*/*	ioa_ ("^8x@ ^a^a", substr (proc_ctl.type, op_typ, 1),
      545*/*	substr (proc_ctl.dspl_sfx, op_typ, 1)); */
      546 
      547     if op_typ < 17			/* these need special handling */
      548     then goto operand (op_typ);
      549 
      550 try_again:
      551     ot = curop.typ;			/* the stacked operand type	       */
      552     opnd_need = substr (proc_ctl.ops_need, ot, 1);
      553 				/* get operand counter	       */
      554 
      555     if (oprec > curop.prec)		/* if this has greater precedence    */
      556     then
      557       do;				/* then it goes in on top	       */
      558         if opnd_need = "2"		/* need 2 operands		       */
      559 	   & opstk.val_typ (depth - 1) = NONE
      560 				/*  but first one isnt there	       */
      561         then
      562 	do;
      563 	  msg = "1st operand missing. ";
      564 	  op2 = substr (proc_ctl.type, op_typ, 1)
      565 	       || substr (proc_ctl.dspl_sfx, op_typ, 1);
      566 	  goto prt_err2;
      567 	end;
      568         goto push_op_typ;
      569       end;
      570 
      571     if opnd_need = "1"		/* need 1 operand		       */
      572     then
      573       do;
      574         if (curop.val_typ = NONE)	/*   NOT THERE!		       */
      575         then
      576 	do;
      577 	  msg = "Operand missing. ";
      578 	  goto prt_err1;
      579 	end;
      580 
      581         if opstk.val_typ (depth - 1) ^= NONE
      582 				/* orphan operand in front	       */
      583         then
      584 	do;
      585 	  msg = "Used as binary operator. ";
      586 	  goto prt_err1;
      587 	end;
      588       end;
      589 
      590     else if opnd_need = "2"		/* need 2 operands		       */
      591     then
      592       do;
      593         if curop.val_typ = NONE
      594         then
      595 	do;
      596 	  msg = "2nd operand missing. ";
      597 check_for_unary_op:			/* wait a minute! is it unary?       */
      598 	  if (substr (proc_ctl.ops_need, op_typ, 1) = "3")
      599 				/* yes it is	       */
      600 	  then
      601 	    do;
      602 	      oprec = "9";		/* promote it and push it	       */
      603 	      goto push_op_typ;
      604 	    end;
      605 prt_err1:
      606 	  op2 = "";
      607 prt_err2:
      608 	  op1 = substr (proc_ctl.type, ot, 1)
      609 	       || substr (proc_ctl.dspl_sfx, ot, 1);
      610 prt_err:
      611 	  call comp_report_ (2, 0, msg || op1 || op2, info_ptr, buffer);
      612 	  goto err_return;
      613 	end;
      614 
      615         if opstk.val_typ (depth - 1) = NONE
      616         then
      617 	do;
      618 	  msg = "1st operand missing. ";
      619 	  goto prt_err1;
      620 	end;
      621       end;
      622 
      623     else if opnd_need = "3"		/* either 1 or 2 operands	       */
      624     then
      625       do;
      626         if curop.val_typ = NONE	/* if only 1 it must be AFTER	       */
      627         then
      628 	do;
      629 	  msg = "Missing operand. ";
      630 	  goto check_for_unary_op;
      631 	end;
      632       end;
      633 
      634     goto type (curop.typ);		/* we can actually do the operation  */
      635 
      636 operand (11):			/* decimal value		       */
      637     temp_num = comp_read_$number (buffer, scale, start, start, info_ptr, ercd);
      638     if ercd ^= 0
      639     then goto err_return;
      640 
      641     temp_typ = NUM;
      642     start = start - 1;		/* an increment will follow and it   */
      643 				/*  was left on first char not used  */
      644 push_temp:
      645     if (curop.val_typ ^= NONE)	/* 2 operands in a row	       */
      646     then
      647       do;
      648         op1, op2 = "";
      649         msg = "Operator missing. ";
      650         goto prt_err;
      651       end;
      652 
      653     if temp_typ = STR
      654     then call aloc_str (depth);
      655     else
      656       do;
      657         curop.num_val = temp_num;
      658         curop.log_val = temp_log;
      659       end;
      660 
      661     curop.val_typ = temp_typ;
      662 
      663     if detail
      664     then call dumper (" v>", depth);
      665     bufpos = start;
      666 
      667     if (op_typ > 15)		/* if an operator is still pending   */
      668     then goto try_again;
      669     goto parse_loop;
      670 
      671 operand (12):			/* octal value		       */
      672     temp_num = 0;
      673     j = 1;
      674     do i = start by 1 while (j ^< 0);
      675       start = start + 1;
      676       j = index ("01234567", substr (buffer, start, 1)) - 1;
      677       if (j >= 0)
      678       then temp_num = temp_num * 8 + j * 1000;
      679     end;
      680     temp_typ = NUM;
      681     goto push_temp;
      682 
      683 operand (13):			/* string value */
      684     if start > length (buffer)
      685     then
      686       do;
      687         msg = "String syntax error. ";
      688         op1, op2 = "";
      689         goto prt_err;
      690       end;
      691 
      692     temp_str = "";
      693     do while (start <= length (buffer) & substr (buffer, start, 1) = """");
      694       temp_str =
      695 	 temp_str
      696 	 || comp_extr_str_ ("0"b, buffer, start, start, 0, info_ptr);
      697       if start = 0
      698       then goto err_return;		/* something was wrong */
      699 
      700       if start < length (buffer)
      701       then start = start - 1 + verify (substr (buffer, start), " ");
      702     end;
      703 
      704     if start < length (buffer)	/* UNLESS its all used up...	       */
      705          | (start = length (buffer)) & (substr (buffer, start, 1) ^= """")
      706     then start = start - 1;		/* we must step back 1 because       */
      707 				/*  parse_loop is going to move      */
      708 				/*  ahead one		       */
      709     temp_typ = STR;
      710     goto push_temp;
      711 
      712 operand (16):			/* "(" is ALWAYS pushed	       */
      713     oprec = "1";			/* everyone allowed to push on top   */
      714     goto push_op_typ;		/* of this		       */
      715 
      716 operand (14):			/* T logic key */
      717     temp_log = ON;
      718     temp_typ = LOG;
      719     goto push_temp;
      720 
      721 operand (15):			/* F logic key */
      722     temp_log = OFF;
      723     temp_typ = LOG;
      724     goto push_temp;
      725 
      726 type (17):
      727 type (20):
      728 type (24):
      729 type (27):
      730     signal condition (prog_err);
      731     goto err_return;
      732     dcl prog_err	   condition;
      733 
      734 type (16):			/* "("			       */
      735     if (op_typ ^= RtP)		/* ")"			       */
      736     then
      737       do;
      738         msg = "Missing right parenthesis. ";
      739         ot = op_typ;
      740         goto prt_err1;
      741       end;
      742     temp_typ = curop.val_typ;		/**/
      743 				/* pull the result from stack	       */
      744     if temp_typ = LOG		/* logical value */
      745     then
      746       do;
      747         temp_log = curop.log_val;
      748 
      749 /*        op_typ = DIGIT;*/
      750       end;
      751 
      752     if temp_typ = NUM		/* numeric value */
      753     then
      754       do;
      755         temp_num = curop.num_val;
      756         op_typ = DIGIT;
      757       end;
      758 
      759     else				/* string value */
      760       do;
      761         temp_str = substr (strs, curop.str_val.ofst, curop.str_val.len);
      762         op_typ = STRING;
      763       end;
      764 
      765     goto pop_op;
      766 
      767 type (18):			/* "=" equal */
      768     call rel_vt (depth - 1, depth);
      769     temp_typ = LOG;
      770 
      771     if curop.val_typ = LOG
      772     then temp_log = (prvop.log_val = curop.log_val);
      773 
      774     else if curop.val_typ = NUM
      775     then temp_log = (prvop.num_val = curop.num_val);
      776 
      777     else temp_log =
      778 	    (substr (strs, prvop.str_val.ofst, prvop.str_val.len)
      779 	    = substr (strs, curop.str_val.ofst, curop.str_val.len));
      780 
      781 pop_op:
      782     if detail
      783     then
      784       do;
      785         call dumper ("<ov", depth);
      786         call dumper ("< v", depth - 1);
      787       end;
      788 
      789     call free_str (depth);
      790     depth = depth - 1;
      791     curop_ptr = addr (opstk.e (depth));
      792     if depth > 1
      793     then prvop_ptr = addr (opstk.e (depth - 1));
      794     call free_str (depth);
      795     curop.val_typ = NONE;		/* clean out old operand	       */
      796     goto push_temp;
      797 
      798 type (23):
      799 type (19):			/* XOR			       */
      800     call log_vt (depth - 1, depth);
      801     if (curop.val_typ ^= STR)
      802     then
      803       do;
      804         if (opstk.num_val (depth - 1) = 0) = (curop.num_val = 0)
      805         then temp_log = OFF;
      806         else temp_log = ON;
      807         temp_typ = LOG;
      808       end;
      809     else
      810       do;
      811         unspec (temp_str) =
      812 	   bool (
      813 	   unspec (
      814 	   substr (strs, opstk.str_val.ofst (depth - 1),
      815 	   opstk.str_val.len (depth - 1))),
      816 	   unspec (substr (strs, curop.str_val.ofst, curop.str_val.len)),
      817 	   "0110"b);
      818         temp_typ = STR;
      819       end;
      820     goto pop_op;
      821 
      822 type (21):			/* "^"			       */
      823     if (curop.val_typ ^= STR)
      824     then
      825       do;
      826         if (curop.num_val ^= 0)
      827         then temp_log = OFF;
      828         else temp_log = ON;
      829         temp_typ = LOG;
      830       end;
      831     else
      832       do;
      833         unspec (temp_str) =
      834 	   bool ("0"b,
      835 	   unspec (substr (strs, curop.str_val.ofst, curop.str_val.len)),
      836 	   "1010"b);
      837         temp_typ = STR;
      838       end;
      839     goto pop_op;
      840 
      841 type (22):			/* "^="			       */
      842     call rel_vt (depth - 1, depth);
      843     temp_log = OFF;
      844     temp_typ = LOG;
      845 
      846     if curop.val_typ = LOG
      847     then
      848       do;
      849         if prvop.log_val ^= curop.log_val
      850         then temp_log = ON;
      851       end;
      852 
      853     else if curop.val_typ = NUM
      854     then
      855       do;
      856         if prvop.num_val ^= curop.num_val
      857         then temp_log = ON;
      858       end;
      859 
      860     else
      861       do;
      862         if substr (strs, opstk.str_val.ofst (depth - 1),
      863 	   opstk.str_val.len (depth - 1))
      864 	   ^= substr (strs, curop.str_val.ofst, curop.str_val.len)
      865         then temp_log = ON;
      866       end;
      867 
      868     goto pop_op;
      869 
      870 type (25):			/* "<"			       */
      871     call rel_vt (depth - 1, depth);
      872     temp_log = OFF;
      873     temp_typ = LOG;
      874 
      875     if (curop.val_typ ^= STR)
      876     then
      877       do;
      878         if (opstk.num_val (depth - 1) < curop.num_val)
      879         then temp_log = ON;
      880       end;
      881     else
      882       do;
      883         if (substr (strs, opstk.str_val.ofst (depth - 1),
      884 	   opstk.str_val.len (depth - 1))
      885 	   < substr (strs, curop.str_val.ofst, curop.str_val.len))
      886         then temp_log = ON;
      887       end;
      888 
      889     goto pop_op;
      890 
      891 type (26):			/* "<="			       */
      892     call rel_vt (depth - 1, depth);
      893     temp_log = OFF;
      894     temp_typ = LOG;
      895 
      896     if (curop.val_typ ^= STR)
      897     then
      898       do;
      899         if (opstk.num_val (depth - 1) <= curop.num_val)
      900         then temp_log = ON;
      901       end;
      902     else
      903       do;
      904         if (substr (strs, opstk.str_val.ofst (depth - 1),
      905 	   opstk.str_val.len (depth - 1))
      906 	   <= substr (strs, curop.str_val.ofst, curop.str_val.len))
      907         then temp_log = ON;
      908       end;
      909 
      910     goto pop_op;
      911 
      912 type (28):			/* ">"			       */
      913     call rel_vt (depth - 1, depth);
      914     temp_log = OFF;
      915     temp_typ = LOG;
      916 
      917     if (curop.val_typ ^= STR)
      918     then
      919       do;
      920         if (opstk.num_val (depth - 1) > curop.num_val)
      921         then temp_log = ON;
      922       end;
      923     else
      924       do;
      925         if (substr (strs, opstk.str_val.ofst (depth - 1),
      926 	   opstk.str_val.len (depth - 1))
      927 	   > substr (strs, curop.str_val.ofst, curop.str_val.len))
      928         then temp_log = ON;
      929       end;
      930 
      931     goto pop_op;
      932 
      933 type (29):			/* ">="			       */
      934     call rel_vt (depth - 1, depth);
      935     temp_log = OFF;
      936     temp_typ = LOG;
      937 
      938     if (curop.val_typ ^= STR)
      939     then
      940       do;
      941         if (opstk.num_val (depth - 1) >= curop.num_val)
      942         then temp_log = ON;
      943       end;
      944     else
      945       do;
      946         if (substr (strs, opstk.str_val.ofst (depth - 1),
      947 	   opstk.str_val.len (depth - 1))
      948 	   >= substr (strs, curop.str_val.ofst, curop.str_val.len))
      949         then temp_log = ON;
      950       end;
      951 
      952     goto pop_op;
      953 
      954 type (30):			/* "+"			       */
      955     call force_vt (depth - 1, depth, NUM);
      956     if (opstk.val_typ (depth - 1) = NUM)/* binary flavor		       */
      957     then temp_num = opstk.num_val (depth - 1) + curop.num_val;
      958     else temp_num = curop.num_val;
      959     temp_typ = NUM;
      960     goto pop_op;
      961 
      962 type (31):			/* "-"			       */
      963     call force_vt (depth - 1, depth, NUM);
      964     if (opstk.val_typ (depth - 1) = NUM)/* binary flavor		       */
      965     then temp_num = opstk.num_val (depth - 1) - curop.num_val;
      966     else temp_num = -curop.num_val;
      967     temp_typ = NUM;
      968     goto pop_op;
      969 
      970 type (32):			/* "*"			       */
      971     call force_vt (depth - 1, depth, NUM);
      972     fb71 = opstk.num_val (depth - 1) * curop.num_val;
      973     temp_num = divide (fb71, 1000, 71, 10);
      974 				/*      temp_num = divide (opstk.num_val (depth - 1) * curop.num_val, 1000, 31, 10);*/
      975     temp_typ = NUM;
      976     goto pop_op;
      977 
      978 type (33):			/* "/"			       */
      979     call force_vt (depth - 1, depth, NUM);
      980     temp_num =
      981          divide (1000 * opstk.num_val (depth - 1), curop.num_val, 31, 10);
      982     temp_typ = NUM;
      983     goto pop_op;
      984 
      985 type (34):			/* "\"			       */
      986     call force_vt (depth - 1, depth, NUM);
      987     temp_num = mod (opstk.num_val (depth - 1), curop.num_val);
      988     temp_typ = NUM;
      989     goto pop_op;
      990 
      991 type (35):			/* "&" - AND */
      992     call log_vt (depth - 1, depth);
      993     temp_log = OFF;
      994     temp_typ = LOG;
      995 
      996     if curop.val_typ = LOG		/* logical values */
      997     then if prvop.log_val & curop.log_val
      998          then temp_log = ON;
      999          else ;
     1000 
     1001     else if curop.val_typ = NUM	/* numeric values */
     1002     then if prvop.num_val ^= 0 & curop.num_val ^= 0
     1003          then temp_log = ON;
     1004          else ;
     1005 
     1006     else				/* string values */
     1007       do;
     1008         unspec (temp_str) =
     1009 	   bool (
     1010 	   unspec (
     1011 	   substr (strs, opstk.str_val.ofst (depth - 1),
     1012 	   opstk.str_val.len (depth - 1))),
     1013 	   unspec (substr (strs, curop.str_val.ofst, curop.str_val.len)),
     1014 	   "0001"b);
     1015         temp_typ = STR;
     1016       end;
     1017 
     1018     goto pop_op;
     1019 
     1020 type (36):			/* "|" = OR */
     1021     call log_vt (depth - 1, depth);
     1022 
     1023     if curop.val_typ ^= STR		/* logicals or numerics */
     1024     then
     1025       do;
     1026         temp_typ = LOG;
     1027 
     1028         if curop.val_typ = LOG
     1029         then temp_log = prvop.log_val | curop.log_val;
     1030 
     1031         else if curop.val_typ = NUM
     1032         then if prvop.num_val ^= 0 | curop.num_val ^= 0
     1033 	   then temp_log = ON;
     1034 	   else temp_log = OFF;
     1035       end;
     1036 
     1037     else				/* strings */
     1038       do;
     1039         temp_typ = STR;
     1040         unspec (temp_str) =
     1041 	   bool (
     1042 	   unspec (
     1043 	   substr (strs, opstk.str_val.ofst (depth - 1),
     1044 	   opstk.str_val.len (depth - 1))),
     1045 	   unspec (substr (strs, curop.str_val.ofst, curop.str_val.len)),
     1046 	   "0111"b);
     1047       end;
     1048 
     1049     goto pop_op;
     1050 
     1051 type (37):			/* "<<"	got all the way back to    */
     1052     goto return_;			/*  begin-expression, time to stop   */
     1053 
     1054 err_return:
     1055     opstk.num_val (1) = 0;		/* force zero result */
     1056     opstk.val_typ (1) = NUM;
     1057     start = length (buffer) + 1;	/* indicate we've already squawked */
     1058     ercd = -1;
     1059 
     1060 return_:
     1061     restyp = opstk.val_typ (1);
     1062 
     1063     if restyp ^= needtyp & needtyp > 0
     1064     then
     1065       do;
     1066         call force_vt (1, 1, needtyp);
     1067         restyp = needtyp;
     1068       end;
     1069 
     1070     resnum = opstk.num_val (1);
     1071     reslog = opstk.log_val (1);
     1072 
     1073     if restyp = STR
     1074     then
     1075       do;
     1076         resstr = substr (strs, opstk.str_val.ofst (1), opstk.str_val.len (1));
     1077         res_attr = string_attr;
     1078       end;
     1079     else resstr = "";
     1080 
     1081     if restyp = LOG
     1082     then res_attr = flag_attr;
     1083 
     1084     else
     1085       do;
     1086         if res_attr = ""b
     1087         then
     1088 	do;
     1089 	  res_attr = numeric_attr | unscaled_attr;
     1090 	  num_val_key = "unscaled";
     1091 	end;
     1092         else num_val_key = "sclnum";
     1093       end;
     1094 
     1095     if debug
     1096     then call ioa_ ("^5x(expr_eval) ^[logical ^[T^;F^]^;"
     1097 	    || "^snumeric ^f ^a ^a^;^3sstring ""^a""^]", restyp, reslog,
     1098 	    resnum, num_val_key, comp_util_$display (resstr, 0, "0"b));
     1099     return;
     1100 
     1101     dcl dt_sw	   bit (1) static init ("0"b);
     1102 dtn:
     1103   entry;
     1104     dt_sw = "1"b;
     1105     return;
     1106 dtf:
     1107   entry;
     1108     dt_sw = "0"b;
     1109     return;
     1110 
     1111     dcl db_sw	   bit (1) static init ("0"b);
     1112 dbn:
     1113   entry;
     1114     db_sw = "1"b;
     1115     return;
     1116 dbf:
     1117   entry;
     1118     db_sw = "0"b;
     1119     return;
     1120 
     1121 aloc_str:
     1122   proc (which);
     1123 
     1124     dcl which	   fixed bin;
     1125 
     1126     if (length (strs) < strse + length (temp_str))
     1127     then
     1128       do;
     1129         call comp_report_ (2, 0, "String expression too large", info_ptr,
     1130 	   buffer);
     1131         goto err_return;
     1132       end;
     1133     substr (strs, strse, length (temp_str)) = temp_str;
     1134     opstk.str_val.ofst (which) = strse;
     1135     opstk.str_val.len (which) = length (temp_str);
     1136     strse = strse + length (temp_str);
     1137     strsu = strsu + length (temp_str);
     1138 
     1139   end aloc_str;




     1140 
     1141 free_str:
     1142   proc (which);
     1143 
     1144     dcl which	   fixed bin;
     1145 
     1146     if (opstk.val_typ (which) ^= STR)
     1147     then return;
     1148     strse = max (strse, opstk.str_val.ofst (which));
     1149 				/* just in case not      */
     1150 				/*  freed in reverse order	       */
     1151     strsu = strsu - opstk.str_val.len (which);
     1152 				/* account for unused space    */
     1153     if (strsu = 0)			/* if nothing in use, we can start   */
     1154     then strse = 1;			/*  over again.		       */
     1155 
     1156   end free_str;
     1157 
     1158 rel_vt:
     1159   proc (a1, a2);
     1160 
     1161     dcl (a1, a2)	   fixed bin;
     1162     dcl typ	   fixed bin;
     1163 
     1164     dcl res	   fixed bin;
     1165     dcl i		   fixed bin;
     1166     dcl vtyp	   (1:3) char (3) int static init ("LOG", "NUM", "STR");
     1167     dcl (vt1, vt2)	   fixed bin;
     1168 
     1169     if (opstk.val_typ (a1) = opstk.val_typ (a2))
     1170     then return;
     1171     res = max (opstk.val_typ (a1), opstk.val_typ (a2));
     1172     goto common;
     1173 
     1174 log_vt:
     1175   entry (a1, a2);
     1176 
     1177     vt1 = opstk.val_typ (a1);
     1178     vt2 = opstk.val_typ (a2);
     1179     if (vt1 = vt2)
     1180     then return;
     1181     if (vt1 = STR) | (vt2 = STR)
     1182     then
     1183       do;
     1184         call comp_report_ (2, 0,
     1185 	   vtyp (vt1) || "/" || vtyp (vt2)
     1186 	   || " conversion not defined in a logical context.", info_ptr,
     1187 	   buffer);
     1188         goto err_return;
     1189       end;
     1190     res = LOG;
     1191     goto common;
     1192 
     1193 force_vt:
     1194   entry (a1, a2, typ);		/* force two entries to be same type */
     1195 
     1196     res = typ;
     1197 
     1198 common:
     1199     do i = a1, a2;			/* for each of the entries */
     1200       if opstk.val_typ (i) ^= NONE	/* if it has a type */
     1201 	 & opstk.val_typ (i) ^= res	/* and its not the one we want */
     1202       then
     1203         do;			/* do the necssary conversion */
     1204 	goto rtn (3 * (opstk.val_typ (i) - 1) + (res - 1));
     1205 
     1206 rtn (3):				/* 2,1 NUM=>LOG */
     1207 	if opstk.num_val (i) ^= 0	/* if nonzero -- */
     1208 	then opstk.log_val (i) = ON;
     1209 	else opstk.log_val (i) = OFF;
     1210 	opstk.val_typ (i) = LOG;
     1211 	goto done_cv;
     1212 
     1213 rtn (2):				/* 1,3 LOG=>STR */
     1214 	if opstk.log_val (i)
     1215 	then temp_str = "T";
     1216 	else temp_str = "F";
     1217 	call aloc_str (i);
     1218 	goto done_cv;
     1219 
     1220 rtn (5):				/* 2,3 NUM=>STR */
     1221 	temp_str = comp_util_$num_display (addr (opstk.num_val (i)), 0);
     1222 	call aloc_str (i);
     1223 	goto done_cv;
     1224 
     1225 rtn (6):				/* 3,1 STR=>LOG */
     1226 	if opstk.str_val.len (i) > 0	/* if nonnull -- */
     1227 	then opstk.log_val (i) = ON;
     1228 	else opstk.log_val (i) = OFF;
     1229 	opstk.val_typ (i) = LOG;
     1230 	goto done_cv;
     1231 
     1232 rtn (7):				/* 3,2 STR=>NUM */
     1233 	temp_str =
     1234 	     substr (strs, opstk.str_val.ofst (i), opstk.str_val.len (i));
     1235 	opstk.num_val (i) =
     1236 	     comp_read_$number (temp_str, scale, 1, 0, info_ptr, 0);
     1237 	goto done_cv;
     1238 
     1239 rtn (1):				/* 1,2 LOG=>NUM */
     1240 	if opstk.log_val (i)
     1241 	then opstk.num_val (i) = -1;
     1242 	else opstk.num_val (i) = 0;
     1243 
     1244 rtn (0):				/* 1,1 LOG=>LOG */
     1245 rtn (4):				/* 2,2 NUM=>NUM */
     1246 rtn (8):				/* 3,3 STR=>STR */
     1247 done_cv:
     1248 	opstk.val_typ (i) = res;
     1249         end;
     1250     end;
     1251   end rel_vt;
     1252 
     1253 dumper:				/* display stack actions */
     1254   proc (action, which);
     1255 
     1256     dcl action	   char (3),	/* stack action wanted */
     1257         which	   fixed bin;	/* depth of stack box to display */
     1258 
     1259     dcl dmpstk_ptr	   ptr;		/* stack box to display */
     1260     dcl 1 dmpstk	   like opstk.e based (dmpstk_ptr);
     1261 
     1262     dmpstk_ptr = addr (opstk.e (which));/* stack info */
     1263     call ioa_$nnl ("  ^a ^2i ^1a^1a ^1a ", action, which,
     1264          substr (proc_ctl.type, dmpstk.typ, 1),
     1265          substr (proc_ctl.dspl_sfx, dmpstk.typ, 1), dmpstk.prec);
     1266 
     1267     if dmpstk.val_typ = LOG		/* logical values */
     1268     then call ioa_$nnl ("L ^[T^;F^]", dmpstk.log_val);
     1269 
     1270     else if dmpstk.val_typ = NUM	/* numeric values */
     1271     then call ioa_$nnl ("N ^f", dmpstk.num_val);
     1272 
     1273     else if dmpstk.val_typ = STR	/* string values */
     1274     then call ioa_$nnl ("S ""^a""",
     1275 	    substr (strs, dmpstk.str_val.ofst, dmpstk.str_val.len));
     1276 
     1277     if substr (action, 2, 1) = ">"
     1278     then call ioa_ (" at buffer (^d)", bufpos);
     1279     else call ioa_ ("");
     1280 
     1281   end dumper;
     1282 
  1     1 /* BEGIN INCLUDE FILE comp_entries.incl.pl1 */
  1     2 
  1     3 /* format: style2,ind2,ll79,dclind4,idind15,comcol41,linecom */
  1     4 
  1     5      dcl compose_severity_
  1     6 		    fixed bin (35) ext static;
  1     7      dcl comp_	    entry;
  1     8      dcl comp_art_	    entry (ptr, bit (1));
  1     9      dcl comp_block_ctls_
  1    10 		    entry (fixed bin);
  1    11      dcl comp_break_    entry (fixed bin, fixed bin);
  1    12      dcl comp_break_ctls_
  1    13 		    entry (fixed bin);
  1    14      dcl comp_ctls_	    entry (bit (1) aligned);
  1    15      dcl comp_eject_page_
  1    16 		    entry;
  1    17      dcl comp_expr_eval_
  1    18 		    entry (char (*) var, fixed bin (21), ptr, fixed bin,
  1    19 		    fixed bin, bit (1), fixed bin (31), char (*) var,
  1    20 		    bit (9), fixed bin (35));
  1    21      dcl comp_extr_str_ entry (bit (1), char (*) var, fixed bin (21),
  1    22 		    fixed bin (21), fixed bin (21), ptr)
  1    23 		    returns (char (*) var);
  1    24      dcl comp_fill_	    entry;
  1    25      dcl comp_font_	    entry (bit (1), char (*) var, char (8) aligned);
  1    26      dcl comp_format_ctls_
  1    27 		    entry (fixed bin);
  1    28      dcl comp_get_file_$find
  1    29 		    entry (char (*), ptr, char (*), bit (1), char (*) var,
  1    30 		    fixed bin (35));
  1    31      dcl comp_get_file_$open
  1    32 		    entry (ptr, bit (1), fixed bin (35));
  1    33      dcl comp_head_page_
  1    34 		    entry (fixed bin (31));
  1    35      dcl comp_hft_ctls_ entry (fixed bin);
  1    36      dcl comp_hft_ctls_$title
  1    37 		    entry (ptr, ptr, char (*) var, fixed bin (31));
  1    38      dcl comp_init_$one entry;
  1    39      dcl comp_init_$two entry;
  1    40      dcl comp_init_$three
  1    41 		    entry;
  1    42      dcl comp_insert_ctls_
  1    43 		    entry (fixed bin);
  1    44      dcl comp_make_page_
  1    45 		    entry (fixed bin, bit (1));
  1    46      dcl comp_make_page_$cleanup
  1    47 		    entry;
  1    48      dcl comp_measure_  entry (char (1020) var, ptr, bit (1), bit (1), bit (6),
  1    49 		    fixed bin (31), ptr, ptr, ptr);
  1    50      dcl comp_read_$name
  1    51 		    entry (char (*) var, fixed bin (21), fixed bin (21),
  1    52 		    ptr) returns (char (*) var);
  1    53      dcl comp_read_$number
  1    54 		    entry (char (*) var, (*) fixed bin (31),
  1    55 		    fixed bin (21), fixed bin (21), ptr, fixed bin (35))
  1    56 		    returns (fixed bin (31));
  1    57      dcl comp_read_$line
  1    58 		    entry (ptr, char (*) var, bit (1));
  1    59      dcl comp_report_   entry (fixed bin, fixed bin (35), char (*), ptr,
  1    60 		    char (*) var);
  1    61      dcl comp_report_$ctlstr
  1    62 		    entry options (variable);
  1    63 /****		 (sev, code, info, line, ctl_str, args... */
  1    64      dcl comp_report_$exact
  1    65 		    entry (char (*), ptr);
  1    66      dcl comp_space_    entry (fixed bin (31), ptr, bit (1), bit (1), bit (1),
  1    67 		    bit (1));
  1    68      dcl comp_tbl_ctls_ entry (fixed bin);
  1    69      dcl comp_title_block_
  1    70 		    entry (ptr);
  1    71      dcl comp_update_symbol_
  1    72 		    entry (bit (1), bit (1), bit (1), char (32),
  1    73 		    char (*) var);
  1    74      dcl comp_use_ref_  entry (char (*) var, bit (1), bit (1), ptr);
  1    75      dcl comp_util_$add_text
  1    76 		    entry (ptr, bit (1), bit (1), bit (1), bit (1), ptr);
  1    77      dcl comp_util_$display
  1    78 		    entry (char (*) var, fixed bin, bit (1))
  1    79 		    returns (char (*) var);
  1    80      dcl comp_util_$escape
  1    81 		    entry (char (*) var, ptr);
  1    82      dcl comp_util_$getblk
  1    83 		    entry (fixed bin, ptr, char (2), ptr, bit (1));
  1    84      dcl comp_util_$num_display
  1    85 		    entry (ptr, fixed bin) returns (char (256) var);
  1    86      dcl comp_util_$pageno
  1    87 		    entry (fixed bin, char (*) var);
  1    88      dcl comp_util_$pictures		/* emit pending pictures */
  1    89 		    entry		/**/
  1    90 		    (ptr);	/* current text block */
  1    91      dcl comp_util_$pop entry (char (32));
  1    92      dcl comp_util_$push
  1    93 		    entry (char (32));
  1    94      dcl comp_util_$relblk
  1    95 		    entry (fixed bin, ptr);
  1    96      dcl comp_util_$replace_text
  1    97 		    entry (ptr, bit (1), ptr, ptr);
  1    98      dcl comp_util_$search_tree
  1    99 		    entry (char (32), bit (1));
  1   100      dcl comp_util_$set_bin
  1   101 		    entry (fixed bin (31), char (32) var, fixed bin (31),
  1   102 		    fixed bin (31), fixed bin (31), (*) fixed bin (31),
  1   103 		    fixed bin (31));
  1   104      dcl comp_util_$set_net_page
  1   105 		    entry (bit (1));
  1   106      dcl comp_util_$translate
  1   107 		    entry (char (*) var) returns (char (*) var);
  1   108      dcl comp_write_block_
  1   109 		    entry (fixed bin);
  1   110      dcl comp_write_page_
  1   111 		    entry;
  1   112 
  1   113 /*	END INCLUDE FILE comp_entries.incl.pl1	*/
     1283 
  2     1 /*	BEGIN INCLUDE FILE comp_fntstk.incl.pl1	*/
  2     2 
  2     3 /* format: style2,ind2,ll79,dclind4,idind15,comcol41,linecom */
  2     4 
  2     5      dcl fntstk_eptr    ptr;		/* font stack entry structure */
  2     6      dcl 1 fntstk_entry aligned based (fntstk_eptr),
  2     7 	 2 bachelor   bit (1),	/* 1= has no members */
  2     8 	 2 devfnt	    fixed bin,	/* font in the device */
  2     9 	 2 fam_name   char (32),	/* family name */
  2    10 	 2 famndx	    fixed bin,	/* family index */
  2    11 	 2 fntptr	    ptr,		/* font table pointer */
  2    12 	 2 mem_name   char (32),	/* /member name (or null) */
  2    13 	 2 memndx	    fixed bin,	/* member index */
  2    14 	 2 memptr	    ptr,		/* member table pointer */
  2    15 	 2 name	    char (65) var,	/* font name */
  2    16 	 2 size	    fixed bin (31), /* requested point size */
  2    17 	 2 ps	    fixed bin (31), /* effective point size */
  2    18 	 2 fcs_str    char (8);	/* FCS string */
  2    19 
  2    20 /*	END INCLUDE FILE comp_fntstk.incl.pl1	*/
     1284 
  3     1 /*	BEGIN INCLUDE FILE comp_page.incl.pl1	*/
  3     2 
  3     3 /* format: style2,ind2,ll79,dclind4,idind15,comcol41,linecom */
  3     4 
  3     5      dcl max_image_lines
  3     6 		    fixed static options (constant) init (1000);
  3     7      dcl max_cols	    fixed static options (constant) init (20);
  3     8 
  3     9      dcl page_version   fixed bin static options (constant) init (5);
  3    10 				/* composed page structure */
  3    11      dcl 1 page	    aligned based (const.page_ptr),
  3    12 	 2 version    fixed bin,	/* version of this structure */
  3    13 	 2 parms	    aligned like page_parms,
  3    14 				/* page formatting parameters */
  3    15 	 2 hdr	    aligned like page_header,
  3    16 				/* page control stuff */
  3    17 	 2 image_ptr  ptr,		/* pointer to the madeup page image */
  3    18 	 2 column_ptr (0:20) ptr,	/* pointers to the column structures */
  3    19 	 2 col_image_ptr
  3    20 		    (-2:21) ptr;	/* pointers to column images  */
  3    21 				/* col -1 is for line numbers and */
  3    22 				/* left margin change bars; */
  3    23 				/* col -2 is for */
  3    24 				/* right margin change bars  */
  3    25 				/* and/or annotation * /
  3    26*				/* page control stuff */
  3    27      dcl 1 page_header  aligned based (const.page_header_ptr),
  3    28 	 2 sws,
  3    29 	   3 art	    bit (1) unal,	/* 1 = header/footer art */
  3    30 	   3 blankpage
  3    31 		    bit (1) unal,	/* 1 = intentional blank page */
  3    32 	   3 frontpage
  3    33 		    bit (1) unal,	/* 1 = odd page number */
  3    34 	   3 headed   bit (1) unal,	/* 1 = page header has been written */
  3    35 	   3 modified bit (1) unal,	/* 1 = page has been modified */
  3    36 	   3 overflow bit (1) unal,	/* OBSOLETE */
  3    37 	   3 MBZ	    bit (12) unal,
  3    38 	   3 dot_addltr
  3    39 		    char (1) unal,	/* dot page add letter, if any */
  3    40 	   3 pgc_select
  3    41 		    char (1) unal,	/* for selecting change pages */
  3    42 	 2 baldepth   fixed bin (31), /* page depth at balance point */
  3    43 	 2 balusd	    fixed bin (31), /* space used at balance point */
  3    44 	 2 col_count  fixed bin,	/* highest value of col_index for the page */
  3    45 	 2 col_index  fixed bin,	/* column index */
  3    46 	 2 depth	    fixed bin (31), /* current page depth */
  3    47 	 2 hdspc	    fixed bin (31), /* TOP white space */
  3    48 	 2 lmarg	    fixed bin (31), /* left margin for this page */
  3    49 	 2 net	    fixed bin (31), /* net usable space on the page */
  3    50 	 2 pageno	    char (32) var,	/* current page number */
  3    51 	 2 used	    fixed bin (31); /* space already used on the page */
  3    52 
  3    53      dcl page_image_version
  3    54 		    fixed bin (35) static options (constant) init (2);
  3    55 				/* structure passed to writers */
  3    56      dcl 1 page_image   aligned based (page.image_ptr),
  3    57 	 2 version    fixed bin (35), /* structure version no */
  3    58 	 2 count	    fixed bin,	/* count of page image lines */
  3    59 	 2 file_id    char (32) var,	/* compout identifier */
  3    60 	 2 func	    fixed bin,	/* function code; 0 = build, 
  3    61*				   1 = intialize, 2 = cleanup */
  3    62 	 2 text_ptr   ptr,		/* pointer to the text area */
  3    63 				/* the image lines */
  3    64 	 2 line	    (max_image_lines),
  3    65 	   3 sws,
  3    66 	     4 quad   bit (6) unal,	/* text set position flags */
  3    67 	     4 art    bit (1) unal,	/* 1 = artwork in the line */
  3    68 	     4 cbar   bit (1) unal,	/* 1= line has a cbar, dont erase */
  3    69 	     4 mrgtxt bit (1) unal,	/* line number or marginal note */
  3    70 	     4 white  bit (1) unal,	/* line is white */
  3    71 	     4 MBZ    bit (26) unal,
  3    72 	   3 depth    fixed bin (31), /* page depth for the text */
  3    73 	   3 gaps	    fixed bin,	/* number of WS gaps in the line */
  3    74 	   3 info	    like text_entry.info,
  3    75 				/* input file info */
  3    76 	   3 lead	    fixed bin (31), /* lead value if trailing WS */
  3    77 	   3 lfnt	    fixed bin,	/* font at the left margin */
  3    78 	   3 lmarg    fixed bin (31), /* text left margin position */
  3    79 	   3 lsize    fixed bin (31), /* pointsize at the left margin */
  3    80 	   3 net	    fixed bin (31), /* net width for filling */
  3    81 	   3 pos	    fixed bin (31), /* current horiz position */
  3    82 	   3 ptr	    ptr,		/* pointer to the text */
  3    83 	   3 rmarg    fixed bin (31), /* text right margin position */
  3    84 	   3 width    fixed bin (31); /* width of the text */
  3    85 				/* current page formatting parms */
  3    86      dcl 1 page_parms   aligned based (const.page_parms_ptr),
  3    87 	 2 init_page_depth
  3    88 		    fixed bin (31), /* initial page depth */
  3    89 	 2 length	    fixed bin (31), /* page length */
  3    90 	 2 lmarg,			/* page left margin */
  3    91 	   3 even	    fixed bin (31),
  3    92 	   3 odd	    fixed bin (31),
  3    93 	 2 margin,		/* margin values */
  3    94 	   3 top	    fixed bin (31),
  3    95 	   3 header   fixed bin (31),
  3    96 	   3 footer   fixed bin (31),
  3    97 	   3 bottom   fixed bin (31),
  3    98 	 2 measure    fixed bin (31), /* line space available for text */
  3    99 	 2 net,			/* net usable space on page */
  3   100 	   3 even	    fixed bin (31), /* even pages */
  3   101 	   3 odd	    fixed bin (31), /* odd pages */
  3   102 				/* arrays at the end */
  3   103 	 2 cols,			/* columns defined for the page */
  3   104 	   3 bal	    bit (1) unal,	/* column balancing control flag */
  3   105 	   3 MBZ	    bit (17) unal,
  3   106 	   3 count    fixed bin unal; /* the number of columns */
  3   107 				/* default page formatting parms */
  3   108      dcl 1 init_page_parms
  3   109 		    aligned like page_parms
  3   110 		    based (const.init_page_parms_ptr);
  3   111 
  3   112 /*	END INCLUDE FILE comp_page.incl.pl1	*/
     1285 
  4     1 /*	BEGIN INCLUDE FILE comp_shared.incl.pl1	*/
  4     2 
  4     3 /* format: style2,ind2,ll79,dclind4,idind15,comcol41,linecom */
  4     4 
  4     5      dcl shared_version fixed bin (35) static options (constant) init (17);
  4     6 
  4     7      dcl 1 shared	    aligned based (const.shared_ptr),
  4     8 	 2 version    fixed bin (35), /* version of this structure */
  4     9 	 2 chars,
  4    10 	 ( 3 sym_delim,		/* delimiter for symbols */
  4    11 	   3 ttl_delim,		/* delimiter for title parts */
  4    12 	   3 wrd_brkr		/* word break character */
  4    13 	   )	    char (1) unal,
  4    14 	   3 PAD	    char (1) unal,
  4    15 	 2 cbar_type  char (4) var,	/* change bar type */
  4    16 	 2 dot_add_letter		/* dot page add letter */
  4    17 		    char (1) var,
  4    18 	 2 EN_width   fixed bin (31), /* width of EN in current font */
  4    19 	 2 eqn_refct  fixed bin,	/* equation reference counter */
  4    20 	 2 footref_fcs		/* footnote ref FCS string */
  4    21 		    char (8) aligned,
  4    22 	 2 ftn_reset  char (8) var,	/* footnote reset mode */
  4    23 	 2 ftnrefct   fixed bin,	/* footnote ref counter */
  4    24 	 2 hyph_size  fixed bin (31), /* least word part size for hyphing */
  4    25 	 2 if_nest,		/* if/then/else logic control */
  4    26 	   3 ndx	    fixed bin,	/* depth of logic nest */
  4    27 	   3 e	    (25),		/* nest entries */
  4    28 				/* .if control switch */
  4    29 	     4 sw	    fixed bin,	/* 0=off, 1=(then), -1=(else) */
  4    30 	     4 info   aligned like text_entry.info,
  4    31 	     4 line   char (256) var, /* the control line */
  4    32 	 2 indctl,		/* indent ctls stack */
  4    33 	   3 ndx	    fixed bin,	/* current level */
  4    34 				/* switch bits */
  4    35 	   3 stk	    (0:35) bit (1) unal,
  4    36 	 2 input_dirname
  4    37 		    char (168) var, /* dir containing current input file */
  4    38 	 2 input_filename
  4    39 		    char (200) var, /* current input file name */
  4    40 	 2 lead	    fixed bin (31), /* current linespacing value */
  4    41 	 2 lit_count  fixed bin (35), /* count of literal lines */
  4    42 	 2 next_pagenmbr
  4    43 		    char (32) var,	/* next page number / */
  4    44 	 2 output_file
  4    45 		    char (32) var,	/* output file identifier */
  4    46 	 2 pagecount  fixed bin,	/* number of pages produced */
  4    47 	 2 pagenum,		/* page number structure */
  4    48 	   3 index    fixed bin,	/* level currently counting */
  4    49 	   (
  4    50 	   3 sep	    char (1) unal,	/* separator chars */
  4    51 	   3 nmbr	    fixed bin (31), /* the counters */
  4    52 	   3 mode			/* display modes */
  4    53 		    fixed bin (8) unal
  4    54 	   )	    dimension (20),
  4    55 	 2 parameter  char (254) var, /* command line parameter */
  4    56 	 2 param_pres bit (1),	/* passed parameter flag */
  4    57 	 2 pass_counter
  4    58 		    fixed bin,	/* pass counter */
  4    59 	 2 picture,		/* picture blocks */
  4    60 	   3 count    fixed bin,	/* number of them */
  4    61 	   3 space    fixed bin (31), /* total picture space */
  4    62 	   3 blk	    (10),		/* picture blocks */
  4    63 	     4 type   char (4),	/* type = page/col */
  4    64 	     4 place  char (4),	/* place = top/cen/bot */
  4    65 	     4 ptr    ptr,		/* pointer to block */
  4    66 	     4 size   fixed bin (31), /* size of the picture */
  4    67 	 2 ptrs,
  4    68 	 ( 3 aux_file_data_ptr,	/* -> auxiliary file data */
  4    69 	   3 blank_footer_ptr,	/* -> blank page footer */
  4    70 	   3 blank_header_ptr,	/* -> blank page header */
  4    71 	   3 blank_text_ptr,	/* -> blank page text */
  4    72 	   3 blkptr,		/* -> active text */
  4    73 	   3 colptr,		/* current column */
  4    74 	   3 compout_ptr,		/* iocb pointer for output */
  4    75 	   3 compx_ptr,		/* iocb pointer for compx file */
  4    76 	   3 ctb_ptr,		/* current line artwork table */
  4    77 	   3 epftrptr,		/* even page footer block */
  4    78 	   3 ephdrptr,		/* even page header block */
  4    79 	   3 fcb_ptr,		/* input file control block pointer */
  4    80 	   3 ftnblk_data_ptr,	/* footnote block data pointer */
  4    81 	   3 footnote_header_ptr,	/* footnote header "title" */
  4    82 	   3 graphic_page_ptr,	/* graphic output page */
  4    83 	   3 hit_data_ptr,		/* hit data pointer */
  4    84 	   3 htab_ptr,		/* horizontal tab tables */
  4    85 	   3 hwrd_data_ptr,		/* local hyphenation table */
  4    86 	   3 insert_ptr,		/* data entry for current input file */
  4    87 	   3 opftrptr,		/* odd page footer block */
  4    88 	   3 ophdrptr,		/* odd page header block */
  4    89 	   3 ptb_ptr,		/* previous line artwork table */
  4    90 	   3 spcl_blkptr,		/* "special" block pointer */
  4    91 	   3 tbldata_ptr,		/* table column data structure */
  4    92 	   3 tblkdata_ptr,		/* text block data array */
  4    93 	   3 text_header_ptr	/* empty text header structure */
  4    94 	   )	    ptr,
  4    95 	 2 scale,			/* space conversion scale factors */
  4    96 	   3 horz	    fixed bin (31), /* horizontal */
  4    97 	   3 vert	    fixed bin (31), /* vertical */
  4    98 	 2 source_filename
  4    99 		    char (200) var, /* current source file name */
  4   100 	 2 sws,			/* switch bits */
  4   101 	 ( 3 bug_mode,		/* debug mode */
  4   102 	   3 compout_not_headed,	/* compout is not headed */
  4   103 	   3 end_input,		/* EOF for current input file */
  4   104 	   3 end_output,		/* no more output is wanted */
  4   105 	   3 firstpass,		/* first pass over input */
  4   106 	   3 ftn_mode,		/* in footnote mode */
  4   107 	   3 hyph_mode,		/* hyphenating mode */
  4   108 	   3 inserting_hfc,		/* inserting hdr, ftr, or cap */
  4   109 	   3 literal_mode,		/* literal line mode flag */
  4   110 	   3 pageblock,		/* blocks belong to page */
  4   111 	   3 picture_mode,		/* building a picture */
  4   112 	   3 print_flag,		/* producing output */
  4   113 	   3 purge_ftns,		/* purging footnotes */
  4   114 	   3 suppress_footref,	/* suppress next footnote ref */
  4   115 	   3 table_mode		/* table mode */
  4   116 	   )	    bit (1) unal,
  4   117 	   3 MBZ	    bit (21) unal,
  4   118 	 2 trans,			/* trans table for .tr */
  4   119 	   3 in	    char (128) var, /* input chars */
  4   120 	   3 out	    char (128) var, /* output chars */
  4   121 	 2 widow_size fixed bin (31), /* widow size */
  4   122 	 2 widow_foot fixed bin (31); /* widow for footnotes */
  4   123 				/* to save shared data between files/passes */
  4   124      dcl 1 save_shared  aligned like shared based (const.save_shared_ptr);
  4   125 
  4   126      dcl dot_addltr_symb_index
  4   127 		    fixed bin static options (constant) init (12);
  4   128      dcl max_text_lines fixed bin static options (constant) init (1000);
  4   129      dcl mode_string    char (16) static options (constant)
  4   130 		    init ("arbihxocalaurlru");
  4   131 				/* value overlays */
  4   132      dcl flag_value	    bit (1) based;
  4   133      dcl num_value	    fixed bin (31) based;
  4   134 
  4   135 /*	END INCLUDE FILE comp_shared.incl.pl1	*/
     1286 
  5     1 /* 	BEGIN INCLUDE FILE comp_text.incl.pl1	 */
  5     2 
  5     3 /* format: style2,ind2,ll79,dclind4,idind15,comcol41,linecom */
  5     4 
  5     5      dcl 1 tblkdata			/* data for allocated text blocks */
  5     6 		    aligned based (shared.tblkdata_ptr),
  5     7 	 2 block,			/* block pool */
  5     8 	   3 count    fixed bin,
  5     9 	   3 ptr	    (500) ptr,	/* block pointers */
  5    10 				/* block state flags */
  5    11 	   3 free	    (500) bit (1) unal,
  5    12 	 2 line_area,		/* line area pool */
  5    13 	   3 count    fixed bin,
  5    14 	   3 ptr	    (500) ptr,	/* area pointers */
  5    15 				/* area state flags */
  5    16 	   3 free	    (500) bit (1) unal,
  5    17 	 2 text_area,		/* text area pool */
  5    18 	   3 count    fixed bin,
  5    19 	   3 ptr	    (500) ptr,	/* area pointers */
  5    20 				/* area state flags */
  5    21 	   3 free	    (500) bit (1) unal,
  5    22 	   3 string_area_count
  5    23 		    fixed bin;	/* line areas */
  5    24      dcl LINE_AREA_SIZE fixed bin static options (constant) init (24);
  5    25      dcl line_area_ptr  ptr init (null);
  5    26      dcl 1 line_area    aligned based (line_area_ptr),
  5    27 	 2 next	    ptr,		/* forward thread */
  5    28 	 2 prev	    ptr,		/* backward thread */
  5    29 	 2 count	    fixed bin,	/* number of lines allocated */
  5    30 	 2 ndx	    fixed bin,	/* index of current line */
  5    31 	 2 pndx	    fixed bin,	/* area pool index */
  5    32 	 2 linptr	    (LINE_AREA_SIZE) ptr;
  5    33 				/* text areas */
  5    34      dcl TEXT_AREA_SIZE fixed bin static options (constant) init (6);
  5    35      dcl text_area_ptr  ptr init (null);
  5    36      dcl 1 text_area    aligned based (text_area_ptr),
  5    37 	 2 next	    ptr,		/* forward thread */
  5    38 	 2 count	    fixed bin,	/* number of areas allocated */
  5    39 	 2 ndx	    fixed bin,	/* index of current strarea */
  5    40 	 2 pndx	    fixed bin,	/* area pool index */
  5    41 	 2 strareaptr (TEXT_AREA_SIZE) ptr;
  5    42 				/* text string area */
  5    43      dcl string_area    (256) fixed bin based;
  5    44      dcl txtstrptr	    ptr;		/* current text string */
  5    45      dcl txtstr	    char (1020) var based (txtstrptr);
  5    46 
  5    47      dcl TEXT_VERSION   fixed bin static options (constant) init (9);
  5    48 				/* general text block */
  5    49      dcl 1 text	    aligned based (shared.blkptr),
  5    50 	 2 version    fixed bin,	/* version of structure */
  5    51 	 2 blkndx	    fixed bin,	/* block data index */
  5    52 	 2 blktype    char (2),	/* block type code */
  5    53 				/* dynamic block control stuff */
  5    54 	 2 hdr	    aligned like text_header,
  5    55 				/* text read from input file */
  5    56 	 2 input	    aligned like text_entry,
  5    57 	 2 input_line char (1020) var,/* input buffer */
  5    58 	 2 line_area,
  5    59 	   3 first    ptr,		/* head of line area thread */
  5    60 	   3 cur	    ptr,		/* current line area */
  5    61 	 2 next_text  ptr,		/* next text string */
  5    62 				/* text formatting parameters */
  5    63 	 2 parms	    aligned like default_parms,
  5    64 	 2 text_area,
  5    65 	   3 first    ptr,		/* head of text area thread */
  5    66 	   3 cur	    ptr;		/* current text area */
  5    67 				/* an empty text block line */
  5    68      dcl 1 text_entry   aligned based (const.text_entry_ptr),
  5    69 	 2 sws,			/* unaligned switches, etc. */
  5    70 	   3 art	    bit (1) unal,	/* line has artwork */
  5    71 	   3 cbar,		/* change bar flags */
  5    72 	     4 add    bit (1) unal,	/* text addition flag */
  5    73 	     4 del    bit (1) unal,	/* text deletion flag */
  5    74 	     4 mod    bit (1) unal,	/* text modification flag */
  5    75 	   3 default  bit (1) unal,	/* 1 = default case as needed */
  5    76 	   3 DVctl    bit (1) unal,	/* 1 = line is a device ctl string */
  5    77 	   3 embedded bit (1) unal,	/* 1 = line has an embedded control */
  5    78 	   3 end_keep bit (1) unal,	/* 1= line ends a keep */
  5    79 	   3 fnt_chng bit (1) unal,	/* 1 = text is a font change string */
  5    80 	   3 footref  bit (1) unal,	/* 1 = line has a footnote reference */
  5    81 	   3 hanging  bit (1) unal,	/* 1 = a hanging undent */
  5    82 	   3 keep	    bit (1) unal,	/* 1 = unsplittable line */
  5    83 	   3 no_trim  bit (1) unal,	/* 1 = untrimmable white line */
  5    84 	   3 oflo	    bit (1) unal,	/* line causes overflow */
  5    85 	   3 punct    bit (1) unal,	/* 1 = line ends with punctuation */
  5    86 	   3 quad	    bit (6) unal,	/* text alignment flags */
  5    87 	   3 space_added		/* 1= line has added space */
  5    88 		    bit (1) unal,
  5    89 	   3 spcl,		/* special entry - not output text */
  5    90 	     4 file   bit (1) unal,	/* 1= output to special file */
  5    91 	     4 blk_splt		/* 1= action at block split time */
  5    92 		    bit (1) unal,
  5    93 	     4 page_mkup		/* 1= action at page makeup time */
  5    94 		    bit (1) unal,
  5    95 	   3 table    bit (1) unal,	/* 1= line is a table entry */
  5    96 	   3 tblspc   bit (1) unal,	/* 1= WS fill for table mode */
  5    97 	   3 title    bit (1) unal,	/* 1= line is a <title> */
  5    98 	   3 unspnct  bit (1) unal,	/* 1= underscore punctuation */
  5    99 	   3 unstop   bit (1) unal,	/* 1= line is/ends with UNSTOP */
  5   100 	   3 unstrt   bit (1) unal,	/* 1= line is/ends with UNSTART */
  5   101 	   3 unswrds  bit (1) unal,	/* 1= underscore words only */
  5   102 	   3 white    bit (1) unal,	/* 1= line is white space */
  5   103 	   3 und_prot bit (1) unal,	/* 1= undent is protected */
  5   104 	   3 MBZ	    bit (4) unal,
  5   105 	 2 art_start  fixed bin unal, /* start of art string in line */
  5   106 	 2 art_len    fixed bin unal, /* length of art string in line */
  5   107 	 2 cbar_level		/* change level for cbars */
  5   108 		    char (1) aligned,
  5   109 	 2 cur,			/* current scanning data for line */
  5   110 	   3 chrct    fixed bin,	/* count of chars scanned */
  5   111 	   3 gaps	    fixed bin,	/* gap count */
  5   112 	   3 width    fixed bin (31), /* width of font chars */
  5   113 	   3 min	    fixed bin (31), /* width of min spbnds */
  5   114 	   3 avg	    fixed bin (31), /* width of avg spbnds */
  5   115 	   3 max	    fixed bin (31), /* width of max spbnds */
  5   116 	   3 font	    like fntstk_entry,
  5   117 	 2 depth	    fixed bin (31), /* page depth for line */
  5   118 				/* font at start of line */
  5   119 	 2 font	    like fntstk_entry,
  5   120 	 2 index	    fixed bin (21), /* char index for line scanning */
  5   121 	 2 info,			/* stuff created during line input */
  5   122 	   3 fileno   fixed bin,	/* input file index */
  5   123 	   3 lineno   fixed bin,	/* input file line number */
  5   124 	   3 lineno0  fixed bin,	/* call_box0 line number */
  5   125 	 2 linespace  fixed bin (31), /* linespace value for the line */
  5   126 	 2 lmarg	    fixed bin (31), /* adjusted left margin position */
  5   127 	 2 mod_len    fixed bin,	/* length of modified text */
  5   128 	 2 mod_start  fixed bin,	/* index for start of modified text */
  5   129 	 2 net	    fixed bin (31), /* net line width for filling */
  5   130 	 2 ptr	    ptr,		/* pointer to the actual text */
  5   131 	 2 rmarg	    fixed bin (31), /* adjusted right margin position */
  5   132 	 2 spcl_iocbp ptr,		/* iocb ptr for spcl line */
  5   133 	 2 sym_delim  char (1) unal,	/* symbol delimiter for this line */
  5   134 	 2 tblcol	    fixed bin,	/* column for table entries */
  5   135 	 2 title_delim
  5   136 		    char (1) unal,	/* title delimiter if a <title> */
  5   137 	 2 title_index
  5   138 		    fixed bin,	/* <title> block index for line */
  5   139 	 2 width	    fixed bin (31), /* width of text */
  5   140 	 2 ftn,			/* footnote info for line */
  5   141 	   3 ct	    fixed bin,	/* number of footnote refs */
  5   142 	   3 used	    fixed bin (31), /* space used */
  5   143 	   3 e	    (40),		/* limit is arbitrary */
  5   144 	     4 blkndx fixed bin unal, /* block index of footnote - if this
  5   145*				   value is 0, then .frf was used */
  5   146 	     4 refno  fixed bin unal; /* reference number */
  5   147 
  5   148      dcl (
  5   149          quadi	    init ("40"b3),	/* set to the inside margin */
  5   150          quado	    init ("20"b3),	/* set to the outside margin */
  5   151          quadl	    init ("10"b3),	/* set left */
  5   152          quadc	    init ("04"b3),	/* set centered */
  5   153          quadr	    init ("02"b3),	/* set right */
  5   154          just	    init ("01"b3)	/* justified */
  5   155          )	    bit (6) static options (constant);
  5   156 				/* control line structure */
  5   157      dcl 1 ctl	    aligned like text_entry based (const.ctl_ptr);
  5   158      dcl ctl_line	    char (1020) var based (ctl.ptr);
  5   159 
  5   160      dcl txtlinptr	    ptr;		/* the current text line */
  5   161      dcl 1 txtlin	    aligned like text_entry based (txtlinptr);
  5   162 				/* empty text header structure */
  5   163      dcl 1 text_header  aligned based (const.text_header_ptr),
  5   164 	 2 sws,			/* control switches */
  5   165 	   3 art	    bit (1) unal,	/* block has artwork */
  5   166 	   3 dfrftn   bit (1) unal,	/* block is a deferred footnote */
  5   167 	   3 modified bit (1) unal,	/* block contains modified lines */
  5   168 	   3 no_trim  bit (1) unal,	/* 1 = dont trim WS block */
  5   169 	   3 oflo_ftn bit (1) unal,	/* overflow footnote */
  5   170 	   3 tblblk   bit (1) unal,	/* a table block */
  5   171 	   3 unref    bit (1) unal,	/* block is an unreffed footnote */
  5   172 	   3 white    bit (1) unal,	/* block is a white space block */
  5   173 	   3 picture  bit (1) unal,	/* picture block */
  5   174 	   3 orphan   bit (1) unal,	/* 1= footnote is an orphan */
  5   175 	   3 MBZ	    bit (26) unal,
  5   176 	 2 art_count  fixed bin unal, /* to count input art lines */
  5   177 	 2 blkptr	    ptr,		/* pointer to suspended block */
  5   178 	 2 cap_size   fixed bin unal, /* line count of text caption */
  5   179 	 2 cap_used   fixed bin (31), /* size of text caption */
  5   180 	 2 colno	    fixed bin unal, /* column owning the block */
  5   181 	 2 count	    fixed bin unal, /* line count for block */
  5   182 	 2 eqn_line_count
  5   183 		    fixed bin unal, /* counter for equation lines */
  5   184 	 2 first_text fixed bin unal, /* OBSOLETE */
  5   185 	 2 ftn,			/* footnotes */
  5   186 	   3 ct	    fixed bin,	/* count */
  5   187 	   3 usd	    fixed bin (31), /* space used */
  5   188 	   3 blkndx   (40) fixed bin, /* footnote block index values */
  5   189 	 2 head_size  fixed bin,	/* line count of text header */
  5   190 	 2 head_used  fixed bin (31), /* size of text header */
  5   191 	 2 index	    fixed bin unal, /* block index of next output line */
  5   192 	 2 keep_count fixed bin unal, /* to count input keep lines */
  5   193 	 2 last_line  fixed bin,	/* last text line in column */
  5   194 	 2 mx_ttl_ndx fixed bin,	/* max title index value in block */
  5   195 	 2 name	    char (32) var,	/* block name, if any */
  5   196 	 2 nofill_count		/* to count nofill lines */
  5   197 		    fixed bin,
  5   198 	 2 parms_ptr  ptr,		/* parms for suspended block */
  5   199 	 2 refer	    fixed bin,	/* inter-block reference */
  5   200 	 2 refer_index		/* OBSOLETE */
  5   201 		    fixed bin,	/* a reference */
  5   202 	 2 split	    fixed bin,	/* split point for balancing */
  5   203 	 2 trl_ws	    fixed bin (31), /* trailing WS */
  5   204 	 2 used	    fixed bin (31); /* page space used by a column/block */
  5   205 				/* text formatting parameters */
  5   206      dcl 1 text_parms   aligned like default_parms
  5   207 		    based (const.text_parms_ptr);
  5   208 
  5   209      dcl 1 current_parms
  5   210 		    aligned like default_parms
  5   211 		    based (const.current_parms_ptr);
  5   212 
  5   213      dcl 1 default_parms
  5   214 		    aligned based (const.default_parms_ptr),
  5   215 	 2 sws,			/* control switches */
  5   216 	   3 quad	    bit (6) unal,	/* text alignment mode */
  5   217 	   3 art	    bit (1) unal,	/* 1 = block countains artwork */
  5   218 	   3 cbar,		/* change bar flags */
  5   219 	     4 add    bit (1) unal,	/* text addition flag */
  5   220 	     4 del    bit (1) unal,	/* text deletion flag for next line */
  5   221 	     4 mod    bit (1) unal,	/* text modification flag */
  5   222 	   3 fill_mode
  5   223 		    bit (1) unal,	/* 1 = fill mode ON */
  5   224 	   3 footnote bit (1) unal,	/* block is a footnote */
  5   225 	   3 hfc	    bit (1) unal,	/* OBSOLETE */
  5   226 	   3 htab_mode
  5   227 		    bit (1) unal,	/* 1 = horizontal tab mode ON */
  5   228 	   3 keep	    bit (1) unal,	/* keep mode */
  5   229 	   3 page	    bit (1) unal,	/* block belongs to page, not text */
  5   230 	   3 title_mode
  5   231 		    bit (1) unal,	/* 0 = plain text, 1 = <title>s OK */
  5   232 	   3 MBZ	    bit (19) unal,
  5   233 	 2 ftrptr	    ptr,		/* text caption block */
  5   234 	 2 cbar_level		/* change level for cbars */
  5   235 		    char (1) aligned,
  5   236 	 2 hdrptr	    ptr,		/* text header block */
  5   237 	 2 left,			/* left margin data */
  5   238 	   3 indent   fixed bin (31),
  5   239 	   3 undent   fixed bin (31),
  5   240 	 2 linespace  fixed bin (31), /* line spacing value */
  5   241 	 2 measure    fixed bin (31), /* line space for text */
  5   242 				/* right margin data */
  5   243 	 2 right	    like default_parms.left,
  5   244 	 2 fntstk,		/* stack of last 20 font changes */
  5   245 	   3 index    fixed bin,	/* which one in use */
  5   246 				/* entry(0) is the default */
  5   247 	   3 entry    (0:19) like fntstk_entry;
  5   248 
  5   249      dcl hfcblk_ptr	    ptr;
  5   250      dcl 1 hfcblk	    aligned like text based (hfcblk_ptr);
  5   251 
  5   252 /*	END INCLUDE FILE comp_text.incl.pl1	*/
     1287 
  6     1 /*	BEGIN INDCLUDE FILE comp_varattrs.incl.pl1	*/
  6     2 
  6     3 /* Written - 4/82 - EJW
  6     4*
  6     5*   Defines constants for all variable attribute flag bits in compose */
  6     6 
  6     7 /* Modified - 5/83 - EJW - Changed binary_attr to unscaled_attr */
  6     8 
  6     9      dcl	   (numeric_attr	      init ("100000000"b),	/* binary numeric */
  6    10 	   counter_attr	      init ("010000000"b),	/* counter */
  6    11 	   string_attr	      init ("001000000"b),	/* string */
  6    12 	   flag_attr	      init ("00010000"b),	/* flag */
  6    13 	   unscaled_attr	      init ("000010000"b),	/* unscaled numeric */
  6    14 	   function_attr	      init ("000001000"b),	/* function value */
  6    15 	   hspace_attr	      init ("000000100"b),	/* horizontal millipoint value */
  6    16 	   vspace_attr	      init ("000000010"b),	/* vertical millipoint value */
  6    17 	   push_attr	      init ("000000001"b)) /* pushable variable */
  6    18 			      bit (9) unal static options (constant);
  6    19 
  6    20 /*	END INCLUDE FILE comp_varattrs.incl.pl1 	*/
     1288 
  7     1 /* BEGIN INCLUDE FILE compstat.incl.pl1 - external static data for compose
  7     2*
  7     3*   This storage is converted from external (as declared) to internal by the
  7     4*   binder and contains items that must be accessible to both the bound and
  7     5*   unbound program. */
  7     6 
  7     7 /* Written:  ??/??/7? - EJW
  7     8*   Modified: 10/18/84 - EJW - (First recorded change) Added current_parms_ptr
  7     9*			and removed the codes array; version 6.
  7    10**/
  7    11 
  7    12 /* format: style2,ind2,ll79,dclind4,idind15,comcol41,linecom */
  7    13 
  7    14      dcl 1 compstat$compconst
  7    15 		    aligned like const ext static;
  7    16 
  7    17      dcl const_version  fixed bin (35) static options (constant) init (6);
  7    18      dcl MAX_TREE_AREA_CT		/* entries in a tree area */
  7    19 		    fixed bin static options (constant) init (80);
  7    20      dcl MAX_TREE_AREAS		/* number of tree areas */
  7    21 		    fixed bin static options (constant) init (20);
  7    22 
  7    23      dcl 1 const	    aligned based (compstat$compconst.ptr),
  7    24 	 2 ptr	    ptr,		/* self pointer - MUST BE FIRST */
  7    25 	 2 version    fixed bin (35), /* structure version */
  7    26 	 2 art_symbols		/* string of art symbols */
  7    27 		    char (28) aligned,
  7    28 	 2 builtin_count		/* count of builtin variables */
  7    29 		    fixed bin,
  7    30 	 2 comp_dir   char (200),	/* dir in which compose lives */
  7    31 	 2 comp_version
  7    32 		    char (8) var,	/* compose version id */
  7    33 	 2 date_value char (8) var,	/* current date */
  7    34 	 2 dsm_name   char (32),	/* device support module name */
  7    35 	 2 dvt_name   char (32),	/* device table name */
  7    36 	 2 max_seg_chars
  7    37 		    fixed bin (35), /* char count in a max seg */
  7    38 	 2 null_str   char (1) var,	/* an empty string */
  7    39 	 2 ptrs,
  7    40 	 ( 3 call_stk_ptr,		/* -> insert call stack */
  7    41 	   3 colhdrptr,		/* empty column header structure */
  7    42 	   3 ctl_ptr,		/* input line structure */
  7    43 	   3 current_parms_ptr,	/* current formatting parms */
  7    44 	   3 default_parms_ptr,	/* default initial text parms */
  7    45 	   3 devptr,		/* -> comp_dvt structure */
  7    46 	   3 dvidptr,		/* -> comp_dvid structure       */
  7    47 	   3 errblk_ptr,		/* error message block pointer */
  7    48 	   3 footnote_parms_ptr,	/* footnote formatting parms */
  7    49 	   3 fnttbldata_ptr,	/* -> font table data */
  7    50 	   3 global_area_ptr,	/* per invocation storage */
  7    51 	   3 init_page_parms_ptr,	/* default initial page parms */
  7    52 	   3 insert_data_ptr,	/* insert file data block */
  7    53 	   3 local_area_ptr,	/* per file storage */
  7    54 	   3 loctbl_ptr,		/* for font copying */
  7    55 	   3 option_ptr,		/* program options block */
  7    56 	   3 outproc_ptr,		/* device writer for cleanup */
  7    57 	   3 page_ptr,		/* active page structure */
  7    58 	   3 page_header_ptr,	/* empty page header structure */
  7    59 	   3 page_parms_ptr,	/* page formatting parameter block */
  7    60 	   3 save_shared_ptr,	/* saved shared data */
  7    61 	   3 shared_ptr,		/* shared data structure */
  7    62 	   3 text_entry_ptr,	/* empty text entry structure */
  7    63 	   3 text_header_ptr,	/* empty text header structure */
  7    64 	   3 text_parms_ptr,	/* main body formatting parms */
  7    65 	   3 tree_ptr		/* symbol tree structure */
  7    66 	   )	    ptr,
  7    67 	 2 time_value char (6) var;	/* time at start */
  7    68 
  7    69 /* Other external */
  7    70      dcl (
  7    71          ioa_,
  7    72          ioa_$nnl
  7    73          )	    entry options (variable);
  7    74      dcl iox_$error_output
  7    75 		    ptr ext static, /* iocb pointer for error_output */
  7    76          iox_$user_input
  7    77 		    ptr ext static, /* iocb pointer for user_input */
  7    78          iox_$user_output
  7    79 		    ptr ext static; /* iocb pointer for user_output */
  7    80      dcl sys_info$max_seg_size
  7    81 		    fixed bin (18) ext static;
  7    82 
  7    83 /* END INCLUDE FILE compstat.incl.pl1 */
     1289 
     1290 
     1291   end comp_expr_eval_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/23/85  0909.1  comp_expr_eval_.pl1               >spec>online>comp>comp_expr_eval_.pl1
1283         1    03/01/85  1411.9  comp_entries.incl.pl1             >ldd>include>comp_entries.incl.pl1
1284         2    03/01/85  1412.0  comp_fntstk.incl.pl1              >ldd>include>comp_fntstk.incl.pl1
1285         3    04/23/85  0912.4  comp_page.incl.pl1                >spec>online>comp>comp_page.incl.pl1
1286         4    03/01/85  1412.0  comp_shared.incl.pl1              >ldd>include>comp_shared.incl.pl1
1287         5    04/23/85  0912.6  comp_text.incl.pl1                >spec>online>comp>comp_text.incl.pl1
1288         6    03/01/85  1412.0  comp_varattrs.incl.pl1            >ldd>include>comp_varattrs.incl.pl1
1289         7    03/01/85  1412.1  compstat.incl.pl1                 >ldd>include>compstat.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BoE                                    constant        fixed bin(17,0)          initial dcl 139 ref 312
DIGIT                                  constant        fixed bin(17,0)          initial dcl 139 ref 532 538 756
EoE                                    constant        fixed bin(17,0)          initial dcl 139 ref 335
FuncRes                         000166 automatic       varying char(1020)       dcl 154 set ref 375* 380 389* 434* 472 481*
LOG                                    constant        fixed bin(17,0)          initial dcl 178 ref 718 723 744 769 771 807 829 844
                                                                                  846 873 894 915 936 994 996 1026 1028 1081 1190
                                                                                  1210 1229 1267
NONE                                   constant        fixed bin(17,0)          initial dcl 176 ref 286 326 558 574 581 593 615 626
                                                                                  644 795 1200
NUM                             000010 internal static fixed bin(17,0)          initial dcl 180 set ref 404 449* 485 641 680 752 774
                                                                                  853 954* 956 959 962* 964 967 970* 975 978* 982
                                                                                  985* 988 1001 1031 1056 1270
OFF                                    constant        bit(1)                   initial unaligned dcl 189 ref 303 721 804 826 843
                                                                                  872 893 914 935 993 1034 1209 1228
ON                                     constant        bit(1)                   initial unaligned dcl 190 ref 716 806 828 849 856
                                                                                  862 878 883 899 904 920 925 941 946 996 1001 1031
                                                                                  1206 1225
RtP                                    constant        fixed bin(17,0)          initial dcl 197 ref 734
STR                                    constant        fixed bin(17,0)          initial dcl 182 ref 653 709 801 818 822 837 875 896
                                                                                  917 938 1015 1023 1039 1073 1146 1181 1181 1273
STRING                                 constant        fixed bin(17,0)          initial dcl 139 ref 536 762
a1                                     parameter       fixed bin(17,0)          dcl 1161 ref 1158 1169 1171 1174 1177 1193 1198
a2                                     parameter       fixed bin(17,0)          dcl 1161 ref 1158 1169 1171 1174 1178 1193 1198
action                                 parameter       char(3)                  unaligned dcl 1256 set ref 1253 1263* 1277
addr                                                   builtin function         dcl 215 ref 321 322 389 389 389 389 389 389 481 481
                                                                                  481 481 481 481 791 792 1220 1220 1262
avg                       4     007310 automatic       fixed bin(31,0)          level 2 dcl 212 set ref 392
bool                                                   builtin function         dcl 215 ref 811 833 1008 1040
buffer                                 parameter       varying char             dcl 20 set ref 14 296 296 296* 309 316 335 341 341
                                                                                  341* 345 351 357 360* 367 370* 375* 395 398* 411
                                                                                  416 419* 426 429* 434* 439 442* 449* 457* 505 511
                                                                                  523 536 610* 636* 676 683 693 693 694* 700 700 704
                                                                                  704 704 1057 1129* 1184*
bufpos                          000100 automatic       fixed bin(21,0)          dcl 145 set ref 314* 333* 354* 414* 665* 1277*
bug_mode               4113            based           bit(1)                   level 3 packed unaligned dcl 4-7 ref 290
chrct                           007310 automatic       fixed bin(17,0)          level 2 dcl 212 set ref 483
comp_error_table_$usage_error   000014 external static fixed bin(35,0)          dcl 219 set ref 360* 370*
comp_expr_eval_                 000016 constant        entry                    external dcl 1-17 ref 449
comp_extr_str_                  000020 constant        entry                    external dcl 1-21 ref 375 434 694
comp_measure_                   000022 constant        entry                    external dcl 1-48 ref 389 481
comp_read_$number               000024 constant        entry                    external dcl 1-53 ref 636 1235
comp_report_                    000026 constant        entry                    external dcl 1-59 ref 398 419 429 442 457 610 1129
                                                                                  1184
comp_report_$ctlstr             000030 constant        entry                    external dcl 1-61 ref 360 370
comp_util_$display              000032 constant        entry                    external dcl 1-77 ref 296 1095
comp_util_$num_display          000034 constant        entry                    external dcl 1-84 ref 1220
compstat$compconst              000036 external static structure                level 1 dcl 7-14
const                                  based           structure                level 1 dcl 7-23
cur                     126            based           structure                level 3 in structure "hfcblk" dcl 5-250 in procedure
                                                                                  "comp_expr_eval_"
cur                      10            based           structure                level 2 in structure "txtlin" dcl 5-161 in procedure
                                                                                  "comp_expr_eval_"
cur                     126            based           structure                level 3 in structure "text" dcl 5-49 in procedure
                                                                                  "comp_expr_eval_"
cur                      10            based           structure                level 2 in structure "ctl" dcl 5-157 in procedure
                                                                                  "comp_expr_eval_"
cur                      10            based           structure                level 2 in structure "text_entry" dcl 5-68
                                                                                  in procedure "comp_expr_eval_"
curop                                  based           structure                level 1 unaligned dcl 185
curop_ptr                       001006 automatic       pointer                  dcl 184 set ref 321* 324 325 326 327 327 328 550 555
                                                                                  574 593 626 634 644 657 658 661 742 747 755 761
                                                                                  761 771 771 774 774 777 777 791* 795 801 804 811
                                                                                  811 822 826 833 833 846 849 853 856 862 862 875
                                                                                  878 883 883 896 899 904 904 917 920 925 925 938
                                                                                  941 946 946 956 958 964 966 972 980 987 996 996
                                                                                  1001 1001 1008 1008 1023 1028 1028 1031 1031 1040
                                                                                  1040
current_parms                          based           structure                level 1 dcl 5-209
current_parms_ptr       134            based           pointer                  level 3 dcl 7-23 ref 385 385 477 477
db_sw                           000012 internal static bit(1)                   initial unaligned dcl 1111 set ref 290 1114* 1118*
debug                           000101 automatic       bit(1)                   unaligned dcl 146 set ref 290* 291 293 1095
default_parms                          based           structure                level 1 dcl 5-213
depth                           000102 automatic       fixed bin(17,0)          dcl 147 set ref 300* 319* 319 321 322 322 330* 558
                                                                                  581 615 653* 663* 767 767* 785* 786 789* 790* 790
                                                                                  791 792 792 794* 798 798* 804 811 811 841 841* 862
                                                                                  862 870 870* 878 883 883 891 891* 899 904 904 912
                                                                                  912* 920 925 925 933 933* 941 946 946 954 954* 956
                                                                                  956 962 962* 964 964 970 970* 972 978 978* 980 985
                                                                                  985* 987 991 991* 1008 1008 1020 1020* 1040 1040
detail                          000103 automatic       bit(1)                   unaligned dcl 148 set ref 291* 330 663 781
dmpstk                                 based           structure                level 1 unaligned dcl 1260
dmpstk_ptr                      007536 automatic       pointer                  dcl 1259 set ref 1262* 1263 1263 1263 1263 1263 1267
                                                                                  1267 1270 1270 1273 1273 1273 1273 1273
dspl_sfx                 25(18) 000000 constant        char(43)                 initial level 2 packed unaligned dcl 276 ref 564 607
                                                                                  1263 1263
dt_sw                           000011 internal static bit(1)                   initial unaligned dcl 1101 set ref 291 1104* 1108*
e                               000615 automatic       structure                array level 2 unaligned dcl 163 set ref 321 322 791
                                                                                  792 1262
entry                    22            based           structure                array level 3 dcl 5-209 ref 385 477
ercd                                   parameter       fixed bin(35,0)          dcl 29 set ref 14 288* 449* 451 636* 638 1058*
fb71                            000104 automatic       fixed bin(71,0)          dcl 149 set ref 972* 973
flag_attr                       006310 constant        bit(9)                   initial unaligned dcl 6-9 ref 1081
fntstk                   20            based           structure                level 2 dcl 5-209
fntstk_entry                           based           structure                level 1 dcl 2-6
font_ref                        000106 automatic       structure                level 1 dcl 150 set ref 385* 389 389 477* 481 481
hspace_attr                            constant        bit(9)                   initial unaligned dcl 6-9 ref 406 462 462
i                               000566 automatic       fixed bin(17,0)          dcl 157 in procedure "comp_expr_eval_" set ref 674*
i                               007523 automatic       fixed bin(17,0)          dcl 1165 in procedure "rel_vt" set ref 1198* 1200
                                                                                  1200 1204 1206 1206 1209 1210 1213 1217* 1220 1220
                                                                                  1222* 1225 1225 1228 1229 1232 1232 1235 1239 1239
                                                                                  1242 1244*
index                                                  builtin function         dcl 215 in procedure "comp_expr_eval_" ref 316 341
                                                                                  345 351 411 511 523 676
index                    20            based           fixed bin(17,0)          level 3 in structure "current_parms" dcl 5-209
                                                                                  in procedure "comp_expr_eval_" ref 385 477
info                    161            based           structure                level 2 in structure "text_entry" dcl 5-68
                                                                                  in procedure "comp_expr_eval_"
info                    161            based           structure                level 2 in structure "txtlin" dcl 5-161 in procedure
                                                                                  "comp_expr_eval_"
info                    277            based           structure                level 3 in structure "text" dcl 5-49 in procedure
                                                                                  "comp_expr_eval_"
info                    161            based           structure                level 2 in structure "ctl" dcl 5-157 in procedure
                                                                                  "comp_expr_eval_"
info                    277            based           structure                level 3 in structure "hfcblk" dcl 5-250 in procedure
                                                                                  "comp_expr_eval_"
info_ptr                               parameter       pointer                  dcl 22 set ref 14 360* 370* 375* 389* 398* 419* 429*
                                                                                  434* 442* 449* 457* 481* 610* 636* 694* 1129*
                                                                                  1184* 1235*
ioa_                            000040 constant        entry                    external dcl 7-70 ref 296 1095 1277 1279
ioa_$nnl                        000042 constant        entry                    external dcl 7-70 ref 1263 1267 1270 1273
j                               000567 automatic       fixed bin(17,0)          dcl 157 set ref 673* 674 676* 677 677
left                   1016            based           structure                level 3 in structure "hfcblk" dcl 5-250 in procedure
                                                                                  "comp_expr_eval_"
left                   1016            based           structure                level 3 in structure "text" dcl 5-49 in procedure
                                                                                  "comp_expr_eval_"
left                     12            based           structure                level 2 in structure "current_parms" dcl 5-209
                                                                                  in procedure "comp_expr_eval_"
left                     12            based           structure                level 2 in structure "default_parms" dcl 5-213
                                                                                  in procedure "comp_expr_eval_"
left                     12            based           structure                level 2 in structure "text_parms" dcl 5-206
                                                                                  in procedure "comp_expr_eval_"
len                       4            based           fixed bin(17,0)          level 3 in structure "curop" dcl 185 in procedure
                                                                                  "comp_expr_eval_" set ref 327* 761 777 811 833 862
                                                                                  883 904 925 946 1008 1040
len                       4            based           fixed bin(17,0)          level 3 in structure "prvop" dcl 187 in procedure
                                                                                  "comp_expr_eval_" ref 777
len                       4            based           fixed bin(17,0)          level 3 in structure "dmpstk" dcl 1260 in procedure
                                                                                  "dumper" ref 1273 1273
len                       4     000615 automatic       fixed bin(17,0)          array level 4 in structure "opstk" dcl 163
                                                                                  in procedure "comp_expr_eval_" set ref 305* 811
                                                                                  862 883 904 925 946 1008 1040 1076 1135* 1151 1225
                                                                                  1232
length                                                 builtin function         dcl 215 ref 296 296 309 335 341 380 472 683 693 700
                                                                                  704 704 1057 1126 1126 1133 1135 1136 1137
line_area_ptr                   007472 automatic       pointer                  initial dcl 5-25 set ref 5-25*
log_val                   1(09)        based           bit(1)                   level 2 in structure "curop" packed unaligned
                                                                                  dcl 185 in procedure "comp_expr_eval_" set ref
                                                                                  658* 747 771 849 996 1028
log_val                   1(09)        based           bit(1)                   level 2 in structure "dmpstk" packed unaligned
                                                                                  dcl 1260 in procedure "dumper" set ref 1267*
log_val                   1(09) 000615 automatic       bit(1)                   array level 3 in structure "opstk" packed unaligned
                                                                                  dcl 163 in procedure "comp_expr_eval_" set ref
                                                                                  303* 1071 1206* 1209* 1213 1225* 1228* 1239
log_val                   1(09)        based           bit(1)                   level 2 in structure "prvop" packed unaligned
                                                                                  dcl 187 in procedure "comp_expr_eval_" ref 771 849
                                                                                  996 1028
max                                                    builtin function         dcl 215 ref 1148 1171
meas1                           007310 automatic       structure                level 1 dcl 212 set ref 388* 389 389 480* 481 481
meas2                           007376 automatic       structure                level 1 dcl 213 set ref 389 389 481 481
measure                  10            based           fixed bin(31,0)          level 2 dcl 3-86 set ref 389*
mod                                                    builtin function         dcl 215 ref 987
msg                             000570 automatic       varying char(64)         dcl 159 set ref 563* 577* 585* 596* 610 618* 629*
                                                                                  649* 687* 738*
needtyp                                parameter       fixed bin(17,0)          dcl 23 set ref 14 1063 1063 1066* 1067
null                                                   builtin function         dcl 215 ref 5-25 5-35
num_val                   2     000615 automatic       fixed bin(31,0)          array level 3 in structure "opstk" dcl 163
                                                                                  in procedure "comp_expr_eval_" set ref 301* 804
                                                                                  878 899 920 941 956 964 972 980 987 1054* 1070
                                                                                  1206 1220 1220 1235* 1239* 1242*
num_val                   2            based           fixed bin(31,0)          level 2 in structure "dmpstk" dcl 1260 in procedure
                                                                                  "dumper" set ref 1270*
num_val                   2            based           fixed bin(31,0)          level 2 in structure "curop" dcl 185 in procedure
                                                                                  "comp_expr_eval_" set ref 327* 657* 755 774 804
                                                                                  826 856 878 899 920 941 956 958 964 966 972 980
                                                                                  987 1001 1031
num_val                   2            based           fixed bin(31,0)          level 2 in structure "prvop" dcl 187 in procedure
                                                                                  "comp_expr_eval_" ref 774 856 1001 1031
num_val_key                     000611 automatic       varying char(12)         initial dcl 161 set ref 161* 405* 1090* 1092* 1095*
numeric_attr                           constant        bit(9)                   initial unaligned dcl 6-9 ref 406 1089
ofst                      3            based           fixed bin(17,0)          level 3 in structure "curop" dcl 185 in procedure
                                                                                  "comp_expr_eval_" set ref 328* 761 777 811 833 862
                                                                                  883 904 925 946 1008 1040
ofst                      3            based           fixed bin(17,0)          level 3 in structure "dmpstk" dcl 1260 in procedure
                                                                                  "dumper" ref 1273 1273
ofst                      3     000615 automatic       fixed bin(17,0)          array level 4 in structure "opstk" dcl 163
                                                                                  in procedure "comp_expr_eval_" set ref 304* 811
                                                                                  862 883 904 925 946 1008 1040 1076 1134* 1148 1232
ofst                      3            based           fixed bin(17,0)          level 3 in structure "prvop" dcl 187 in procedure
                                                                                  "comp_expr_eval_" ref 777
op1                             001012 automatic       char(3)                  unaligned dcl 191 set ref 607* 610 648* 688*
op2                             001013 automatic       char(2)                  unaligned dcl 192 set ref 564* 605* 610 648* 688*
op_typ                          001015 automatic       fixed bin(17,0)          dcl 194 set ref 312* 313 324 335* 345* 346 493 509*
                                                                                  509 515* 515 517* 517 527* 527 529* 529 532 536*
                                                                                  538* 541 547 547 564 564 597 667 734 739 756* 762*
opnd_need                       001014 automatic       char(1)                  unaligned dcl 193 set ref 552* 558 571 590 623
oprec                           001016 automatic       char(1)                  unaligned dcl 195 set ref 313* 325 493* 499 502 520
                                                                                  541* 555 602* 712*
ops_need                 40(09) 000000 constant        char(43)                 initial level 2 packed unaligned dcl 276 ref 552 597
opstk                           000615 automatic       structure                array level 1 unaligned dcl 163
ot                              001017 automatic       fixed bin(17,0)          dcl 196 set ref 550* 552 607 607 739*
page_header                            based           structure                level 1 dcl 3-27
page_parms                             based           structure                level 1 dcl 3-86
page_parms_ptr          174            based           pointer                  level 3 dcl 7-23 ref 389
prec                      1            based           char(1)                  level 2 in structure "curop" packed unaligned
                                                                                  dcl 185 in procedure "comp_expr_eval_" set ref
                                                                                  325* 555
prec                      1     000615 automatic       char(1)                  array level 3 in structure "opstk" packed unaligned
                                                                                  dcl 163 in procedure "comp_expr_eval_" set ref
                                                                                  302*
prec                      1            based           char(1)                  level 2 in structure "dmpstk" packed unaligned
                                                                                  dcl 1260 in procedure "dumper" set ref 1263*
prec                     12(27) 000000 constant        char(43)                 initial level 2 in structure "proc_ctl" packed
                                                                                  unaligned dcl 276 in procedure "comp_expr_eval_"
                                                                                  ref 313 493 541
proc_ctl                        000000 constant        structure                level 1 packed unaligned dcl 276
prog_err                        007464 stack reference condition                dcl 732 ref 726
prvop                                  based           structure                level 1 unaligned dcl 187
prvop_ptr                       001010 automatic       pointer                  dcl 186 set ref 322* 771 774 777 777 792* 849 856
                                                                                  996 1001 1028 1031
ptr                             000036 external static pointer                  level 2 dcl 7-14 ref 290 385 385 389 477 477
ptrs                    126            based           structure                level 2 dcl 7-23
res                             007522 automatic       fixed bin(17,0)          dcl 1164 set ref 1171* 1190* 1196* 1200 1204 1244
res_attr                               parameter       bit(9)                   unaligned dcl 28 set ref 14 287* 406* 449* 462 465
                                                                                  467 1077* 1081* 1086 1089*
reslog                                 parameter       bit(1)                   unaligned dcl 25 set ref 14 1071* 1095*
resnum                                 parameter       fixed bin(31,0)          dcl 26 set ref 14 1070* 1095*
resstr                                 parameter       varying char             dcl 27 set ref 14 1076* 1079* 1095*
restyp                                 parameter       fixed bin(17,0)          dcl 24 set ref 14 286* 1060* 1063 1067* 1073 1081
                                                                                  1095*
scale                           000146 constant        fixed bin(31,0)          initial array dcl 199 set ref 636* 1235*
search                                                 builtin function         dcl 215 ref 536
shared                                 based           structure                level 1 dcl 4-7
shared_ptr              200            based           pointer                  level 3 dcl 7-23 ref 290
start                                  parameter       fixed bin(21,0)          dcl 21 set ref 14 296* 309 314 316 316* 316 333 333*
                                                                                  335 341 341 341 345 351 354 354* 357 365* 365 367
                                                                                  375* 375* 377 395 411 414 414* 416 424* 424 426
                                                                                  434* 434* 436 439 448* 448 449* 505 508* 508 511
                                                                                  514* 514 523 526* 526 536 636* 636* 642* 642 665
                                                                                  674 675* 675 676 683 693 693 694* 694* 697 700
                                                                                  700* 700 700 704 704 704 704* 704 1057*
str_val                   3            based           structure                level 2 in structure "prvop" unaligned dcl 187
                                                                                  in procedure "comp_expr_eval_"
str_val                   3     000615 automatic       structure                array level 3 in structure "opstk" unaligned dcl 163
                                                                                  in procedure "comp_expr_eval_"
str_val                   3            based           structure                level 2 in structure "curop" unaligned dcl 185
                                                                                  in procedure "comp_expr_eval_"
str_val                   3            based           structure                level 2 in structure "dmpstk" unaligned dcl 1260
                                                                                  in procedure "dumper"
string_attr                     006311 constant        bit(9)                   initial unaligned dcl 6-9 ref 1077
strs                            001020 automatic       char(10000)              unaligned dcl 201 set ref 761 777 777 811 811 833
                                                                                  862 862 883 883 904 904 925 925 946 946 1008 1008
                                                                                  1040 1040 1076 1126 1133* 1232 1273 1273
strse                           005724 automatic       fixed bin(17,0)          dcl 202 set ref 306* 1126 1133 1134 1136* 1136 1148*
                                                                                  1148 1153*
strsu                           005725 automatic       fixed bin(17,0)          dcl 203 set ref 307* 1137* 1137 1151* 1151 1153
substr                                                 builtin function         dcl 215 set ref 313 316 341 341* 345 351 357 367 395
                                                                                  411 416 426 439 493 505 511 523 536 541 552 564
                                                                                  564 597 607 607 676 693 700 704 761 777 777 811
                                                                                  811 833 862 862 883 883 904 904 925 925 946 946
                                                                                  1008 1008 1040 1040 1076 1133* 1232 1263 1263 1263
                                                                                  1263 1273 1273 1277
sws                    4113            based           structure                level 2 dcl 4-7
temp_log                        005726 automatic       bit(1)                   unaligned dcl 204 set ref 303* 658 716* 721* 747*
                                                                                  771* 774* 777* 804* 806* 826* 828* 843* 849* 856*
                                                                                  862* 872* 878* 883* 893* 899* 904* 914* 920* 925*
                                                                                  935* 941* 946* 993* 996* 1001* 1028* 1031* 1034*
temp_num                        005727 automatic       fixed bin(31,0)          dcl 205 set ref 301* 380* 392* 449* 454 465* 465
                                                                                  467* 467 469* 469 472* 481* 483* 636* 657 671*
                                                                                  677* 677 755* 956* 958* 964* 966* 973* 980* 987*
temp_str                        005730 automatic       varying char(3000)       dcl 206 set ref 692* 694* 694 761* 811* 833* 1008*
                                                                                  1040* 1126 1133 1133 1135 1136 1137 1213* 1216*
                                                                                  1220* 1232* 1235*
temp_typ                        007307 automatic       fixed bin(17,0)          dcl 207 set ref 404* 485* 641* 653 661 680* 709*
                                                                                  718* 723* 742* 744 752 769* 807* 818* 829* 837*
                                                                                  844* 873* 894* 915* 936* 959* 967* 975* 982* 988*
                                                                                  994* 1015* 1026* 1039*
text                                   based           structure                level 1 dcl 5-49
text_area_ptr                   007474 automatic       pointer                  initial dcl 5-35 set ref 5-35*
text_entry                             based           structure                level 1 dcl 5-68
text_header                            based           structure                level 1 dcl 5-163
typ                                    based           fixed bin(17,0)          level 2 in structure "dmpstk" dcl 1260 in procedure
                                                                                  "dumper" ref 1263 1263 1263 1263
typ                                    based           fixed bin(17,0)          level 2 in structure "curop" dcl 185 in procedure
                                                                                  "comp_expr_eval_" set ref 324* 550 634
typ                                    parameter       fixed bin(17,0)          dcl 1162 in procedure "rel_vt" ref 1193 1196
typ                             000615 automatic       fixed bin(17,0)          array level 3 in structure "opstk" dcl 163
                                                                                  in procedure "comp_expr_eval_" set ref 301*
type                            000000 constant        char(43)                 initial level 2 packed unaligned dcl 276 ref 345 564
                                                                                  607 1263 1263
unscaled_attr                          constant        bit(9)                   initial unaligned dcl 6-9 ref 465 1089
val_typ                   5            based           fixed bin(17,0)          level 2 in structure "dmpstk" dcl 1260 in procedure
                                                                                  "dumper" ref 1267 1270 1273
val_typ                   5     000615 automatic       fixed bin(17,0)          array level 3 in structure "opstk" dcl 163
                                                                                  in procedure "comp_expr_eval_" set ref 301* 558
                                                                                  581 615 956 964 1056* 1060 1146 1169 1169 1171
                                                                                  1171 1177 1178 1200 1200 1204 1210* 1229* 1244*
val_typ                   5            based           fixed bin(17,0)          level 2 in structure "curop" dcl 185 in procedure
                                                                                  "comp_expr_eval_" set ref 326* 574 593 626 644
                                                                                  661* 742 771 774 795* 801 822 846 853 875 896 917
                                                                                  938 996 1001 1023 1028 1031
verify                                                 builtin function         dcl 215 ref 700
vspace_attr                            constant        bit(9)                   initial unaligned dcl 6-9 ref 467
vt1                             007524 automatic       fixed bin(17,0)          dcl 1167 set ref 1177* 1179 1181 1184
vt2                             007525 automatic       fixed bin(17,0)          dcl 1167 set ref 1178* 1179 1181 1184
vtyp                            000120 constant        char(3)                  initial array unaligned dcl 1166 ref 1184 1184
which                                  parameter       fixed bin(17,0)          dcl 1256 in procedure "dumper" set ref 1253 1262
                                                                                  1263*
which                                  parameter       fixed bin(17,0)          dcl 1144 in procedure "free_str" ref 1141 1146 1148
                                                                                  1151
which                                  parameter       fixed bin(17,0)          dcl 1124 in procedure "aloc_str" ref 1121 1134 1135
width                     2     007310 automatic       fixed bin(31,0)          level 2 dcl 212 set ref 392

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
LINE_AREA_SIZE                         internal static fixed bin(17,0)          initial dcl 5-24
MAX_TREE_AREAS                         internal static fixed bin(17,0)          initial dcl 7-20
MAX_TREE_AREA_CT                       internal static fixed bin(17,0)          initial dcl 7-18
TEXT_AREA_SIZE                         internal static fixed bin(17,0)          initial dcl 5-34
TEXT_VERSION                           internal static fixed bin(17,0)          initial dcl 5-47
bit                                                    builtin function         dcl 215
comp_                           000000 constant        entry                    external dcl 1-7
comp_art_                       000000 constant        entry                    external dcl 1-8
comp_block_ctls_                000000 constant        entry                    external dcl 1-9
comp_break_                     000000 constant        entry                    external dcl 1-11
comp_break_ctls_                000000 constant        entry                    external dcl 1-12
comp_ctls_                      000000 constant        entry                    external dcl 1-14
comp_eject_page_                000000 constant        entry                    external dcl 1-15
comp_fill_                      000000 constant        entry                    external dcl 1-24
comp_font_                      000000 constant        entry                    external dcl 1-25
comp_format_ctls_               000000 constant        entry                    external dcl 1-26
comp_get_file_$find             000000 constant        entry                    external dcl 1-28
comp_get_file_$open             000000 constant        entry                    external dcl 1-31
comp_head_page_                 000000 constant        entry                    external dcl 1-33
comp_hft_ctls_                  000000 constant        entry                    external dcl 1-35
comp_hft_ctls_$title            000000 constant        entry                    external dcl 1-36
comp_init_$one                  000000 constant        entry                    external dcl 1-38
comp_init_$three                000000 constant        entry                    external dcl 1-40
comp_init_$two                  000000 constant        entry                    external dcl 1-39
comp_insert_ctls_               000000 constant        entry                    external dcl 1-42
comp_make_page_                 000000 constant        entry                    external dcl 1-44
comp_make_page_$cleanup         000000 constant        entry                    external dcl 1-46
comp_read_$line                 000000 constant        entry                    external dcl 1-57
comp_read_$name                 000000 constant        entry                    external dcl 1-50
comp_report_$exact              000000 constant        entry                    external dcl 1-64
comp_space_                     000000 constant        entry                    external dcl 1-66
comp_tbl_ctls_                  000000 constant        entry                    external dcl 1-68
comp_title_block_               000000 constant        entry                    external dcl 1-69
comp_update_symbol_             000000 constant        entry                    external dcl 1-71
comp_use_ref_                   000000 constant        entry                    external dcl 1-74
comp_util_$add_text             000000 constant        entry                    external dcl 1-75
comp_util_$escape               000000 constant        entry                    external dcl 1-80
comp_util_$getblk               000000 constant        entry                    external dcl 1-82
comp_util_$pageno               000000 constant        entry                    external dcl 1-86
comp_util_$pictures             000000 constant        entry                    external dcl 1-88
comp_util_$pop                  000000 constant        entry                    external dcl 1-91
comp_util_$push                 000000 constant        entry                    external dcl 1-92
comp_util_$relblk               000000 constant        entry                    external dcl 1-94
comp_util_$replace_text         000000 constant        entry                    external dcl 1-96
comp_util_$search_tree          000000 constant        entry                    external dcl 1-98
comp_util_$set_bin              000000 constant        entry                    external dcl 1-100
comp_util_$set_net_page         000000 constant        entry                    external dcl 1-104
comp_util_$translate            000000 constant        entry                    external dcl 1-106
comp_write_block_               000000 constant        entry                    external dcl 1-108
comp_write_page_                000000 constant        entry                    external dcl 1-110
compose_severity_                      external static fixed bin(35,0)          dcl 1-5
const_version                          internal static fixed bin(35,0)          initial dcl 7-17
convert                                                builtin function         dcl 215
counter_attr                           internal static bit(9)                   initial unaligned dcl 6-9
ctl                                    based           structure                level 1 dcl 5-157
ctl_line                               based           varying char(1020)       dcl 5-158
dot_addltr_symb_index                  internal static fixed bin(17,0)          initial dcl 4-126
fixed                                                  builtin function         dcl 215
flag_value                             based           bit(1)                   unaligned dcl 4-132
fntstk_eptr                            automatic       pointer                  dcl 2-5
fun                                    based           structure                level 1 unaligned dcl 151
function_attr                          internal static bit(9)                   initial unaligned dcl 6-9
hfcblk                                 based           structure                level 1 dcl 5-250
hfcblk_ptr                             automatic       pointer                  dcl 5-249
init_page_parms                        based           structure                level 1 dcl 3-108
iox_$error_output                      external static pointer                  dcl 7-74
iox_$user_input                        external static pointer                  dcl 7-74
iox_$user_output                       external static pointer                  dcl 7-74
just                                   internal static bit(6)                   initial unaligned dcl 5-148
k                                      automatic       fixed bin(17,0)          dcl 157
line_area                              based           structure                level 1 dcl 5-26
max_cols                               internal static fixed bin(17,0)          initial dcl 3-7
max_image_lines                        internal static fixed bin(17,0)          initial dcl 3-5
max_text_lines                         internal static fixed bin(17,0)          initial dcl 4-128
max_width                              automatic       fixed bin(31,0)          dcl 158
mode_string                            internal static char(16)                 initial unaligned dcl 4-129
num_value                              based           fixed bin(31,0)          dcl 4-133
page                                   based           structure                level 1 dcl 3-11
page_image                             based           structure                level 1 dcl 3-56
page_image_version                     internal static fixed bin(35,0)          initial dcl 3-53
page_version                           internal static fixed bin(17,0)          initial dcl 3-9
push_attr                              internal static bit(9)                   initial unaligned dcl 6-9
quadc                                  internal static bit(6)                   initial unaligned dcl 5-148
quadi                                  internal static bit(6)                   initial unaligned dcl 5-148
quadl                                  internal static bit(6)                   initial unaligned dcl 5-148
quado                                  internal static bit(6)                   initial unaligned dcl 5-148
quadr                                  internal static bit(6)                   initial unaligned dcl 5-148
save_shared                            based           structure                level 1 dcl 4-124
shared_version                         internal static fixed bin(35,0)          initial dcl 4-5
string_area                            based           fixed bin(17,0)          array dcl 5-43
sys_info$max_seg_size                  external static fixed bin(18,0)          dcl 7-80
tblkdata                               based           structure                level 1 dcl 5-5
text_area                              based           structure                level 1 dcl 5-36
text_parms                             based           structure                level 1 dcl 5-206
txtlin                                 based           structure                level 1 dcl 5-161
txtlinptr                              automatic       pointer                  dcl 5-160
txtstr                                 based           varying char(1020)       dcl 5-45
txtstrptr                              automatic       pointer                  dcl 5-44
width                                  automatic       fixed bin(31,0)          dcl 210

NAMES DECLARED BY EXPLICIT CONTEXT.
aloc_str                        005107 constant        entry                    internal dcl 1121 ref 653 1217 1222
check_for_unary_op              002525 constant        label                    dcl 597 ref 630
common                          005376 constant        label                    dcl 1198 ref 1172 1191
comp_expr_eval_                 000501 constant        entry                    external dcl 14
dbf                             005076 constant        entry                    external dcl 1116
dbn                             005063 constant        entry                    external dcl 1112
done_cv                         005602 constant        label                    dcl 1244 ref 1211 1218 1223 1230 1237
dtf                             005051 constant        entry                    external dcl 1106
dtn                             005036 constant        entry                    external dcl 1102
dumper                          005617 constant        entry                    internal dcl 1253 ref 330 663 785 786
err_return                      004607 constant        label                    dcl 1054 ref 363 372 377 401 422 431 436 445 451 459
                                                                                  612 638 697 731 1131 1188
force_vt                        005371 constant        entry                    internal dcl 1193 ref 954 962 970 978 985 1066
free_str                        005202 constant        entry                    internal dcl 1141 ref 789 794
log_vt                          005253 constant        entry                    internal dcl 1174 ref 798 991 1020
operand                         000053 constant        label                    array(11:16) dcl 636 ref 547
parse_loop                      001050 constant        label                    dcl 333 ref 499 669
pop_op                          003374 constant        label                    dcl 781 ref 765 820 839 868 889 910 931 952 960 968
                                                                                  976 983 989 1018 1049
prt_err                         002554 constant        label                    dcl 610 ref 650 689
prt_err1                        002535 constant        label                    dcl 605 ref 578 586 619 740
prt_err2                        002537 constant        label                    dcl 607 ref 566
push_op_typ                     001014 constant        label                    dcl 319 ref 568 603 714
push_temp                       002742 constant        label                    dcl 644 ref 407 486 681 710 719 724 796
rel_vt                          005230 constant        entry                    internal dcl 1158 ref 767 841 870 891 912 933
return_                         004622 constant        label                    dcl 1060 ref 309 1051
rtn                             000107 constant        label                    array(0:8) dcl 1206 ref 1204
syntax_error                    001745 constant        label                    dcl 442
try_again                       002422 constant        label                    dcl 550 ref 667
type                            000061 constant        label                    array(16:37) dcl 726 ref 634
unk_func                        002362 constant        label                    dcl 532 ref 411

NAMES DECLARED BY CONTEXT OR IMPLICATION.
divide                                                 builtin function         ref 465 467 973 980
unspec                                                 builtin function         set ref 388 480* 811* 811 811 833* 833 1008* 1008
                                                                                  1008 1040* 1040 1040

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6510        6554    6323        6520
Length      7144    6323        44         353     165           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
comp_expr_eval_                    4258 external procedure  is an external procedure.  
aloc_str                                internal procedure  shares stack frame of external procedure comp_expr_eval_.  
free_str                                internal procedure  shares stack frame of external procedure comp_expr_eval_.  
rel_vt                                  internal procedure  shares stack frame of external procedure comp_expr_eval_.  
dumper                                  internal procedure  shares stack frame of external procedure comp_expr_eval_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 NUM                         comp_expr_eval_
000011 dt_sw                       comp_expr_eval_
000012 db_sw                       comp_expr_eval_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
comp_expr_eval_          000100 bufpos                      comp_expr_eval_
                         000101 debug                       comp_expr_eval_
                         000102 depth                       comp_expr_eval_
                         000103 detail                      comp_expr_eval_
                         000104 fb71                        comp_expr_eval_
                         000106 font_ref                    comp_expr_eval_
                         000166 FuncRes                     comp_expr_eval_
                         000566 i                           comp_expr_eval_
                         000567 j                           comp_expr_eval_
                         000570 msg                         comp_expr_eval_
                         000611 num_val_key                 comp_expr_eval_
                         000615 opstk                       comp_expr_eval_
                         001006 curop_ptr                   comp_expr_eval_
                         001010 prvop_ptr                   comp_expr_eval_
                         001012 op1                         comp_expr_eval_
                         001013 op2                         comp_expr_eval_
                         001014 opnd_need                   comp_expr_eval_
                         001015 op_typ                      comp_expr_eval_
                         001016 oprec                       comp_expr_eval_
                         001017 ot                          comp_expr_eval_
                         001020 strs                        comp_expr_eval_
                         005724 strse                       comp_expr_eval_
                         005725 strsu                       comp_expr_eval_
                         005726 temp_log                    comp_expr_eval_
                         005727 temp_num                    comp_expr_eval_
                         005730 temp_str                    comp_expr_eval_
                         007307 temp_typ                    comp_expr_eval_
                         007310 meas1                       comp_expr_eval_
                         007376 meas2                       comp_expr_eval_
                         007472 line_area_ptr               comp_expr_eval_
                         007474 text_area_ptr               comp_expr_eval_
                         007522 res                         rel_vt
                         007523 i                           rel_vt
                         007524 vt1                         rel_vt
                         007525 vt2                         rel_vt
                         007536 dmpstk_ptr                  dumper

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_cs            alloc_bs            cat_realloc_cs      call_ext_out_desc   call_ext_out
return              mod_fx1             signal              shorten_stack       ext_entry           ext_entry_desc
trunc_fx1           trunc_fx2           set_cs_eis          index_cs_eis        divide_fx1          divide_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
comp_expr_eval_               comp_extr_str_                comp_measure_                 comp_read_$number
comp_report_                  comp_report_$ctlstr           comp_util_$display            comp_util_$num_display
ioa_                          ioa_$nnl

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
comp_error_table_$usage_error compstat$compconst




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    161 000463    5   25 000464    5   35 000466        14 000471       286 000522       287 000525       288 000531
    290 000532       291 000542       293 000544       296 000546       298 000630       300 000631       301 000632
    302 000670       303 000703       304 000725       305 000741       306 000753       307 000755       309 000756
    312 000763       313 000765       314 000771       316 000773       319 001014       321 001015       322 001021
    324 001030       325 001032       326 001034       327 001036       328 001040       330 001042       333 001050
    335 001055       341 001063       345 001113       346 001125       351 001126       354 001145       357 001151
    360 001155       363 001214       365 001215       367 001216       370 001223       372 001262       375 001263
    377 001340       380 001344       385 001350       388 001362       389 001365       392 001432       395 001435
    398 001444       401 001504       404 001505       405 001510       406 001514       407 001523       411 001524
    414 001537       416 001543       419 001547       422 001607       424 001610       426 001611       429 001616
    431 001656       434 001657       436 001734       439 001740       442 001745       445 002005       448 002006
    449 002007       451 002070       454 002073       457 002075       459 002135       462 002136       465 002146
    467 002161       469 002173       472 002175       477 002201       480 002213       481 002216       483 002260
    485 002263       486 002266       493 002267       499 002273       502 002276       505 002300       508 002305
    509 002306       510 002307       511 002310       514 002327       515 002330       517 002332       518 002333
    520 002334       523 002336       526 002355       527 002357       528 002360       529 002361       532 002362
    536 002365       538 002411       541 002413       547 002417       550 002422       552 002424       555 002430
    558 002435       563 002444       564 002451       566 002464       568 002465       571 002466       574 002471
    577 002473       578 002500       581 002501       585 002505       586 002512       588 002513       590 002514
    593 002516       596 002520       597 002525       602 002532       603 002534       605 002535       607 002537
    610 002554       612 002640       615 002642       618 002646       619 002653       621 002654       623 002655
    626 002657       629 002661       630 002666       634 002667       636 002671       638 002732       641 002735
    642 002740       644 002742       648 002745       649 002751       650 002756       653 002757       657 002765
    658 002767       661 002772       663 002775       665 003003       667 003006       669 003011       671 003012
    673 003013       674 003015       675 003022       676 003024       677 003036       679 003045       680 003047
    681 003052       683 003053       687 003056       688 003063       689 003067       692 003070       693 003071
    694 003106       697 003164       700 003170       702 003215       704 003216       709 003226       710 003230
    712 003231       714 003233       716 003234       718 003236       719 003240       721 003241       723 003242
    724 003244       726 003245       731 003250       734 003251       738 003254       739 003261       740 003263
    742 003264       744 003267       747 003271       752 003275       755 003301       756 003303       757 003305
    761 003306       762 003317       765 003321       767 003322       769 003327       771 003331       774 003350
    777 003362       781 003374       785 003376       786 003402       789 003411       790 003413       791 003415
    792 003421       794 003430       795 003432       796 003435       798 003436       801 003443       804 003447
    806 003462       807 003464       808 003466       811 003467       818 003542       820 003545       822 003546
    826 003552       828 003556       829 003560       830 003562       833 003563       837 003620       839 003623
    841 003624       843 003631       844 003632       846 003634       849 003637       851 003653       853 003654
    856 003660       858 003666       862 003667       868 003703       870 003704       872 003711       873 003712
    875 003714       878 003720       880 003727       883 003730       889 003744       891 003745       893 003752
    894 003753       896 003755       899 003761       901 003770       904 003771       910 004006       912 004007
    914 004014       915 004015       917 004017       920 004023       922 004032       925 004033       931 004050
    933 004051       935 004056       936 004057       938 004061       941 004065       943 004074       946 004075
    952 004111       954 004112       956 004130       958 004145       959 004150       960 004152       962 004153
    964 004171       966 004206       967 004211       968 004213       970 004214       972 004232       973 004240
    975 004246       976 004251       978 004252       980 004270       982 004304       983 004307       985 004310
    987 004326       988 004335       989 004340       991 004341       993 004346       994 004347       996 004351
    999 004365      1001 004366      1004 004401      1008 004402      1015 004455      1018 004460      1020 004461
   1023 004466      1026 004472      1028 004474      1031 004511      1034 004525      1035 004526      1039 004527
   1040 004531      1047 004604      1049 004605      1051 004606      1054 004607      1056 004610      1057 004613
   1058 004620      1060 004622      1063 004625      1066 004631      1067 004646      1070 004651      1071 004653
   1073 004657      1076 004662      1077 004674      1078 004700      1079 004701      1081 004703      1086 004713
   1089 004720      1090 004726      1091 004732      1092 004733      1095 004737      1099 005033      1102 005035
   1104 005044      1105 005047      1106 005050      1108 005057      1109 005061      1112 005062      1114 005071
   1115 005074      1116 005075      1118 005104      1119 005106      1121 005107      1126 005111      1129 005115
   1131 005156      1133 005157      1134 005165      1135 005172      1136 005177      1137 005200      1139 005201
   1141 005202      1146 005204      1148 005213      1151 005221      1153 005223      1156 005227      1158 005230
   1169 005232      1171 005246      1172 005252      1174 005253      1177 005255      1178 005262      1179 005266
   1181 005271      1184 005277      1188 005365      1190 005366      1191 005370      1193 005371      1196 005373
   1198 005376      1200 005403      1204 005412      1206 005423      1209 005430      1210 005432      1211 005434
   1213 005435      1216 005445      1217 005451      1218 005453      1220 005454      1222 005477      1223 005501
   1225 005502      1228 005507      1229 005511      1230 005513      1232 005514      1235 005525      1237 005572
   1239 005573      1242 005601      1244 005602      1250 005607      1251 005616      1253 005617      1262 005621
   1263 005625      1267 005676      1270 005726      1273 005750      1277 006000      1279 006033      1281 006044


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
