	COMPILATION LISTING OF SEGMENT mrds_rst_format_file
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1323.9 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(86-11-18,Blair), approve(86-11-18,PBF7311), audit(86-12-01,Dupuis),
       15*     install(86-12-09,MR12.0-1237):
       16*     Change to use mrds_data_$relation_blocking_factor when creating new
       17*     relations.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* HISTORY
       22*   Originally coded by Oris Friesen -- June 1978
       23*   Modified by Jim Gray - - October 1978, to correct calculate_size
       24*   Modified by Jim Gray - - November 1978, to correct handling of > 255 pages/blocked file
       25*   Modified by Jim Gray - - December 1978, to put module and error handling in mrds_rst format
       26*   Modified by Jim Gray - - March 1979, to correct bucket headers from 0 to 1 when bucket_density < 0
       27*
       28*   81-05-28 Jim Gray : removed blocked file code
       29*
       30*   82-09-07 D. Woodka : changed for DMS conversion to call relation_manager
       31*   create relation and create index.
       32*
       33*   82-12-07 R. Harvey : fixed bug with secondary index creation - too many
       34*   calls were previously being made. Also set protected bit in
       35*   file_create_info.
       36*
       37*   83-01-10 Mike Kubicar : added a common error handling routine, "error"
       38*   and returned on the first error.  Also added "code" parameter for returning
       39*   the error encountered.
       40*
       41*   83-02-17 R. Harvey : changed to support attribute naming in relation_manager
       42*   interface.
       43*
       44*   83-10-04 Paul Benjamin : changed hcs_$initiate calls to initiate_file_.
       45*   Changed "1"b to ON and "0"b to OFF.
       46*
       47*   84-08-21 Matthew Pierret : changed file_create_info to use version
       48*   FILE_CREATE_INFO_VERSION_2, added initialization of ring_brackets in
       49*   file_create_info to 0.
       50**/
       51 
       52 
       53 mrds_rst_format_file: procedure (rsc_ptr, input_file_name, code);
       54 
       55 /*
       56*                            BEGIN_DESCRIPTION
       57*   Given a single file name, this routine  creates a relation
       58*   for the database and the corresponding  indices  according
       59*   to the  file_model of the name file_name.m already defined
       60*   in the database.
       61*
       62*                            END_DESCRIPTION
       63**/
       64 
       65 /* PARAMETERS
       66*
       67*   rsc_ptr - - (input) pointer to the restructure control segment.
       68*
       69*   input_file_name - - (input) equivalent to file_info.file_name,
       70*   char(30) aligned, is the name of the data file. 
       71*
       72*   code - - (output) returned error code.
       73*
       74**/
       75 
       76 /* call metering if trace is on */
       77 
       78 	if rsc.trace_sw then
       79 	     call mrds_rst_meter (rsc_ptr, "mrds_rst_file_format",
       80 		"1"b /* input call */, input_file_name);
       81 
       82 
       83 	code = 0;
       84 
       85 /* initialize for calls to create_relation and create_index */
       86 
       87 	file_segment_name = rtrim (input_file_name);
       88 
       89 	call initiate_file_ (rsc.dbp, "db_model", RW_ACCESS, dbm_ptr, bit_count, error_code);
       90 	if error_code = error_table_$no_r_permission | error_code = error_table_$no_w_permission then do;
       91 		call mrds_dm_authorization$set_needed_access (rtrim (rsc.dbp),
       92 		     error_code);			/* fails if user is not a DBA */
       93 		if error_code ^= 0 then error_code = mrds_error_$no_model_access;
       94 		else call initiate_file_ (dbp, "db_model", RW_ACCESS, dbm_ptr, bit_count, error_code);
       95 	     end;
       96 
       97 	if dbm_ptr = null then call error (rsc_ptr, 4 /* severity */,
       98 		mrds_error_$no_database, " The database model could not be initiated.");
       99 
      100 	file_model_name = rtrim (file_segment_name) || ".m";
      101 	call initiate_file_ (rsc.dbp, file_model_name, RW_ACCESS, fm_ptr, bit_count, error_code);
      102 	if fm_ptr = null then call error (rsc_ptr, 4 /* severity */,
      103 		error_code, " The file model," || file_model_name || "could not be initiated.");
      104 
      105 	ri_ptr = ptr (fm_ptr, file_model.rel_ptr);	/* relation info ptr */
      106 
      107 	tva_number_of_vector_slots = 0;
      108 	tva_number_of_dimensions = rel_info.num_attr;
      109 	tva_maximum_dimension_name_length = 32;
      110 	allocate typed_vector_array in (rsc.wa);
      111 
      112 	il_number_of_ids = rel_info.num_attr;
      113 	allocate id_list in (rsc.wa);
      114 	id_list.number_of_ids = 0;
      115 	id_list.version = ID_LIST_VERSION_1;
      116 
      117 	typed_vector_array.version = TYPED_VECTOR_ARRAY_VERSION_2;
      118 	ai_ptr = ptr (fm_ptr, rel_info.attr_ptr);	/* get attribute info  */
      119 	do i = 1 to tva_number_of_dimensions;
      120 
      121 	     if attr_info.key_attr then do;		/* set up the primary key index */
      122 		     id_list.number_of_ids = id_list.number_of_ids + 1;
      123 		     id_list.id (id_list.number_of_ids) = attr_info.defn_order;
      124 		end;
      125 
      126 	     di_ptr = ptr (dbm_ptr, attr_info.domain_ptr);/* set up descriptor list for create relation */
      127 	     typed_vector_array.dimension_table (i).name = attr_info.name;
      128 	     typed_vector_array.dimension_table (i).descriptor_ptr = addr (domain_info.db_desc);
      129 	     ai_ptr = ptr (fm_ptr, attr_info.fwd_thread);
      130 
      131 	end;
      132 
      133 	allocate rel_creation_info in (rsc.wa);
      134 	allocate file_create_info in (rsc.wa);
      135 
      136 /* initialize values for create_relation */
      137 
      138 	rel_creation_info.version = REL_CREATION_INFO_VERSION_2;
      139 	rel_creation_info.file_create_info_ptr = addr (file_create_info);
      140 	esm_info_ptr = null;
      141 	cism_info_ptr = null;
      142 	file_create_info.version = FILE_CREATE_INFO_VERSION_2;
      143 	file_create_info.ci_size_in_bytes = 4096;
      144 	file_create_info.blocking_factor = mrds_data_$relation_blocking_factor;
      145 	file_create_info.flags.protected = rsc.db_relation_mode_flags.protection_on;
      146 	file_create_info.flags.no_concurrency = ^rsc.db_relation_mode_flags.concurrency_on;
      147 	file_create_info.flags.no_rollback = ^rsc.db_relation_mode_flags.rollback_on;
      148 	file_create_info.flags.mbz_1 = OFF;
      149           file_create_info.ring_brackets (*) = 0;
      150 	file_create_info.mbz_2 = 0;
      151           file_create_info.mbz_3 = OFF;
      152 
      153 /* initialize values for create_index */
      154 	style = 1;
      155 	relation_index_flags_ptr = addr (flag_list);
      156 	relation_index_flags.relation_must_be_empty = OFF;
      157 	relation_index_flags.index_is_clustering = OFF;
      158 	relation_index_flags.index_is_unique = ON;	/* for primary key */
      159 
      160 
      161 
      162 
      163 /* make call to relation manager */
      164 
      165 	if rsc.db_relation_mode_flags.dm_file_type then do; /* if this is a page_file database */
      166 
      167 		call relation_manager_$create_relation (rsc.dbp, file_segment_name,
      168 		     rel_creation_info_ptr, typed_vector_array_ptr,
      169 		     rel_opening_id, rel_info.id, error_code);
      170 		if error_code ^= 0 then
      171 		     call error (rsc_ptr, 4 /* severity */, error_code,
      172 			"while creating relation" || file_segment_name);
      173 
      174 /* create the primary index for the relation */
      175 
      176 		call relation_manager_$create_index (rel_opening_id,
      177 		     id_list_ptr, flag_list, style, rel_info.primary_key_index_id, error_code);
      178 
      179 		if error_code ^= 0 then
      180 		     call error (rsc_ptr, 4 /* severity */, error_code,
      181 			"while creating the primary index for" || file_segment_name);
      182 
      183 	     end;
      184 
      185 	else do;					/* if this is a vfile_ database */
      186 
      187 		call vfile_relmgr_$create_MRDS_relation (rsc.dbp, file_segment_name,
      188 		     rel_creation_info_ptr, typed_vector_array_ptr,
      189 		     rel_opening_id, rel_info.id, error_code);
      190 		if error_code ^= 0 then
      191 		     call error (rsc_ptr, 4 /* severity */, error_code,
      192 			"while creating relation" || file_segment_name);
      193 
      194 /* create the primary index for the relation */
      195 
      196 		call vfile_relmgr_$create_index (rel_opening_id,
      197 		     id_list_ptr, flag_list, style, rel_info.primary_key_index_id, error_code);
      198 		if error_code ^= 0 then
      199 		     call error (rsc_ptr, 4 /* severity */, error_code,
      200 			"while creating the primary index for" || file_segment_name);
      201 
      202 	     end;
      203 
      204 
      205 /* create the secondary indexes for the relation */
      206 
      207 	relation_index_flags.index_is_unique = OFF;	/* index need not be unique for secondary index */
      208 
      209 	id_list.number_of_ids = 1;			/* secondary indices involve only one attribute */
      210 
      211 	do ai_ptr = ptr (fm_ptr, rel_info.attr_ptr)
      212 	     repeat ptr (fm_ptr, attr_info.fwd_thread)
      213 	     while (rel (ai_ptr) ^= NULL_OFFSET);
      214 
      215 	     if attr_info.index_attr then do;
      216 		     id_list.id (1) = attr_info.defn_order;
      217 
      218 		     if rsc.db_relation_mode_flags.dm_file_type then do; /* if this is a page_file database */
      219 
      220 			     call relation_manager_$create_index (rel_opening_id,
      221 				id_list_ptr, flag_list, style, attr_info.index_id, error_code);
      222 
      223 			     if error_code ^= 0 then
      224 				call error (rsc_ptr, 4 /* severity */, error_code,
      225 				     " while creating secondary indices for " || file_segment_name);
      226 
      227 			end;
      228 
      229 		     else do;			/* if this is a vfile_ database */
      230 
      231 			     call vfile_relmgr_$create_index (rel_opening_id,
      232 				id_list_ptr, flag_list, style, attr_info.index_id, error_code);
      233 			     if error_code ^= 0 then
      234 				call error (rsc_ptr, 4 /* severity */, error_code,
      235 				     " while creating secondary indices for " || file_segment_name);
      236 
      237 			end;
      238 
      239 		end;				/* index_attr */
      240 
      241 	end;					/* do ai_ptr */
      242 
      243 /* close the relation */
      244 
      245 	if rsc.db_relation_mode_flags.dm_file_type
      246 	then call relation_manager_$close (rel_opening_id, error_code);
      247 	else call vfile_relmgr_$close (rel_opening_id, error_code);
      248 	if error_code ^= 0 then
      249 	     call error (rsc_ptr, 4 /* severity */, error_code,
      250 		" while closing relation " || file_segment_name);
      251 
      252 
      253 /* call metering if trace is on */
      254 
      255 EXIT:
      256 	if rsc.trace_sw then
      257 	     call mrds_rst_meter (rsc_ptr, "mrds_rst_file_format",
      258 		"0"b /* output call */, input_file_name);
      259 
      260 	return;
      261 
      262 /**********
      263**
      264**  This error routine provides a common action on error.  It will call
      265**  mrds_rst_error to display the error and then return.
      266**
      267***********/
      268 
      269 error:
      270      proc (err_rsc_ptr, err_severity, err_code, err_text);
      271 
      272 	dcl     err_rsc_ptr		 ptr;		/* Pointer to rsc common structure */
      273 	dcl     err_severity	 fixed bin;	/* Cmdb severity */
      274 	dcl     err_code		 fixed bin (35);	/* Standard error code */
      275 	dcl     err_text		 char (*);	/* Expanitory text for error */
      276 
      277 	code = err_code;				/* Set error code for return. Note, global parameter (Yuck) */
      278 	call mrds_rst_error (err_rsc_ptr, err_severity, err_code, err_text);
      279 	goto EXIT;
      280      end error;
      281 
      282 	dcl     bit_count		 fixed bin (24);	/* Required in calls to initiate_file_ */
      283 	dcl     code		 fixed bin (35);	/* Returned error code */
      284 	dcl     error_code		 fixed bin (35);	/* internal status return code */
      285 	dcl     error_table_$no_r_permission
      286 				 fixed bin (35) ext static;
      287 	dcl     error_table_$no_w_permission
      288 				 fixed bin (35) ext static;
      289 	dcl     file_model_name	 char (32);
      290 	dcl     flag_list		 bit (36) aligned;
      291 	dcl     i			 fixed bin;	/* index variable */
      292 	dcl     initiate_file_	 entry (char (*), char (*), bit (*), ptr, fixed bin (24),
      293 				 fixed bin (35));
      294 	dcl     (addr, null, fixed, rel, rtrim, ptr) builtin;
      295 	dcl     rel_opening_id	 bit (36) aligned;
      296 	dcl     style		 fixed bin (17);
      297 	dcl     sys_info$max_seg_size	 fixed bin (35) ext;
      298 
      299 	dcl     mrds_rst_meter	 entry (ptr, char (*), bit (1), char (*)); /* metering routine */
      300 	dcl     input_file_name	 char (*);	/* file name to be formatted */
      301 	dcl     file_segment_name	 char (32);	/* rtrim of input_file_name */
      302           dcl     mrds_data_$relation_blocking_factor fixed bin (17) external static;
      303 	dcl     mrds_dm_authorization$set_needed_access entry (char (*), fixed bin (35));
      304 	dcl     mrds_error_$no_database fixed bin (35) ext static;
      305 	dcl     mrds_error_$no_model_access fixed bin (35) ext static;
      306 	dcl     mrds_rst_error	 entry (ptr, fixed bin, fixed bin (35), char (*)); /* error output routine */
      307 	dcl     NULL_OFFSET		 int static bit (18) unal init ((18)"1"b) options (constant);
      308 	dcl     OFF		 bit (1) aligned internal static options (constant) init ("0"b);
      309 	dcl     ON		 bit (1) aligned internal static options (constant) init ("1"b);
      310 	dcl     relation_manager_$close entry (bit (36) aligned, fixed bin (35));
      311 	dcl     relation_manager_$create_index entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35));
      312 	dcl     relation_manager_$create_relation entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35));
      313 	dcl     vfile_relmgr_$close	 entry (bit (36) aligned, fixed bin (35));
      314 	dcl     vfile_relmgr_$create_MRDS_relation entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35));
      315 	dcl     vfile_relmgr_$create_index entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35));
      316 
  1     1 /* BEGIN INCLUDE FILE mrds_rst_rsc.incl.pl1		RDL  7/7/78	*/
  1     2 
  1     3 /* Modified 8/21/78 by RDL */
  1     4 
  1     5 /* Modified 9/11/78 	by RDL to add directive and stmt pointers */
  1     6 
  1     7 /* Modified 11/4/78		by RDL to add debug,trace,meter switches
  1     8*
  1     9*   Modified 3/29/79 by RDL to change s_seg_info_ptr to source_seg_ptr
  1    10*
  1    11*   Modified by Jim Gray - - Jan. 1980, to add flags to disallow blocked files, forieng keys, and restructuring.
  1    12*
  1    13*   Modified by Jim Gray - - Feb. 1980, to add command level flag for cmdb subroutine interface.
  1    14*
  1    15*   Modified by Jim Gray - - 80-11-06, to add bit for cmdb -secure option.
  1    16*
  1    17*   81-05-18 Jim Gray : added bit for max_attributes error message, so that
  1    18*   it would only be issued on first occurence.
  1    19*
  1    20*   82-08-19 Davids: added the db_type field.
  1    21*
  1    22*   83-02-18 Mike Kubicar : Removed the db_type field and added the 
  1    23*   db_relation_mode_flags substructure to define the modes applicable
  1    24*   to the database's relations.  Also removed assorted unsed fields
  1    25*   (names that included the word unused).
  1    26*
  1    27**/
  1    28 
  1    29 dcl 1 rsc based (rsc_ptr),				/* Restructuring control info */
  1    30     2 rsc_dir char (200),				/* pathname of directory containing rsc segment */
  1    31     2 dbp char (168),				/* Database absolute path */
  1    32     2 temp_dir char (168),				/* Path name of temp restrucuring directory */
  1    33     2 temp_dir_sw bit (1) unal,			/* On => temp dir has been created */
  1    34     2 db_quiesced_sw bit (1) unal,			/* On => database has been quiesced */
  1    35     2 o_db_open_sw bit (1) unal,			/* On => old database has been opened */
  1    36     2 n_db_open_sw bit (1) unal,			/* On => temp database is open */
  1    37     2 listing_seg_sw bit (1) unal,			/* On => listing segment has been created */
  1    38     2 skip_scanner_conversion bit (1) unal,		/* Skip conversion in scanner */
  1    39     2 cmdb_option bit (1) unal,			/* ON => this is a cmdb source, not restructuring */
  1    40     2 trace_sw bit (1) unal,				/* On -> trace mode in affect */
  1    41     2 debug_sw bit (1) unal,				/* On = debug mode (NOT IMPLEMENTED) */
  1    42     2 meter_sw bit (1) unal,				/* On = procedures call metering procedure */
  1    43     2 delete_db_sw bit (1) unal,			/* On = delete data base in cleanup */
  1    44     2 model_consistent_sw bit (1) unal,			/* On => Model is consistent */
  1    45     2 physical_started_sw bit (1) unal,			/* On => Physical restructuring started */
  1    46     2 physical_complete_sw bit (1) unal,		/* On => Physical restructuring completed */
  1    47     2 model_overflow bit (1) unal,			/* ON => model segment area condition occurred */
  1    48     2 max_files bit (1) unal,				/* ON => maximum number of files reached */
  1    49     2 allow_foreign_keys bit (1) unal,			/* on => allow foreign key statment */
  1    50     2 foreign_key_seen bit (1) unal,			/* on => foreign key definition in source */
  1    51     2 allow_blocked_files bit (1) unal,			/* on => allow file statement with blocked option */
  1    52     2 blocked_file_seen bit (1) unal,			/* on => blocked file definition in source */
  1    53     2 allow_restructuring bit (1) unal,			/* on => allow RMDB entry point */
  1    54     2 command_level bit (1) unal,			/* on => called from command unal, not subroutine level */
  1    55     2 secure bit (1) unal,				/* on => -secure option given for cmdb */
  1    56     2 max_attrs bit (1) unal,				/* on => max attrs/rel or max indexes/rel exceeded */
  1    57     2 db_relation_mode_flags,
  1    58       3 dm_file_type bit (1) unal,			/* on => relations are dm files */
  1    59       3 protection_on bit (1) unal,			/* on => relations need transactions */
  1    60       3 concurrency_on bit (1) unal,			/* on => concurrency control enabled */
  1    61       3 rollback_on bit (1) unal,			/* on => before journalling is enabled */
  1    62     2 severity_high fixed bin,			/* Highest severity level error encountered */
  1    63     2 phase fixed bin,				/* 000 = init
  1    64*						   100 = global list init
  1    65*						   200 = parse
  1    66*						   300 = physical init
  1    67*						   400 = physical */
  1    68     2 h_o_seg_info_ls_ptr ptr,			/* Pointer to head of old db seg_info list */
  1    69     2 h_n_seg_info_ls_ptr ptr,			/* Pointer to head of new db seg_info list */
  1    70     2 h_gfile_ptr ptr,				/* Pointer to head of global file list */
  1    71     2 h_gdom_ptr ptr,				/* Pointer to head of global domain list */
  1    72     2 h_gattr_ptr ptr,				/* Pointer to head of global attribute list */
  1    73     2 h_grel_ptr ptr,				/* Pointer to head of global relation list */
  1    74     2 h_glink_ptr ptr,				/* Pointer to head of global link list */
  1    75     2 o_dm_ptr ptr,					/* Pointer to old data model seg  (dm_model ) */
  1    76     2 n_dm_ptr ptr,					/* Pointer to temp data model seg */
  1    77     2 o_fn_hdr_ptr ptr,				/* Pointer to head of original file list (fn structure) */
  1    78     2 source_seg_ptr ptr,				/* Pointer to source_seg */
  1    79     2 listing_iocb_ptr ptr,				/* Pointer to listing segment iocb */
  1    80     2 directive_ptr ptr,				/* Pointer to directive type str in mrds_rst_semactics.incl.pl1 */
  1    81     2 stmt_ptr ptr,					/* Pointer to statement str in mrds_rst_sematics.incl.pl1 */
  1    82     2 trace_metering_iocb_ptr ptr,			/* Pointer to seg used by trace and metering */
  1    83     2 tree_node_area_ptr ptr,				/* pointer to working storage for tree nodes */
  1    84     2 tree_data,
  1    85       3 seg_info_area_ptr ptr,			/* seg info working storage area */
  1    86       3 gl_area_ptr ptr,				/* global list data work storage area */
  1    87       3 sl_area_ptr ptr,				/* sublist data work storage area */
  1    88     2 parse_info_area_ptr ptr,			/* parse interface work area storage */
  1    89     2 static_info_area_ptr ptr,			/* directive, stmt and other static work storage area */
  1    90     2 variable_length_area_ptr ptr,			/* varibale allocates work storage area */
  1    91     2 other_area_ptr ptr,				/* unspecified work area storage */
  1    92     2 wa area (sys_info$max_seg_size - fixed (rel (addr (rsc.wa))) + 1); /* Work area */
  1    93 
  1    94 dcl  rsc_ptr ptr;					/* Pointer to base of rsc segment */
  1    95 
  1    96 
  1    97 
  1    98 /* END INCLUDE FILE mrds_rst_rsc.incl.pl1				*/
  1    99 
      317 
      318 
  2     1 /* BEGIN INCLUDE FILE mrds_rst_struct_types.incl.pl1 - - Jim Gray 2/20/79 */
  2     2 
  2     3 /* these constants are used to identify structures to be allocated
  2     4*   to the general purpose allocation routines */
  2     5 
  2     6 /*  HISTORY:
  2     7*    82-06-28 Roger Lackey : Removed struct types 52, 53, 54, 55, 56, 57, 58
  2     8*    Type 25 is no longer used and is handled with special code so bounds of 
  2     9*    array could continue to work */
  2    10 
  2    11 /* PARSE INFO STRUCTURES */
  2    12 
  2    13 declare  DOMAIN fixed bin internal static options (constant) init (1) ;
  2    14 declare  ATTRIBUTE_DOMAIN fixed bin internal static options (constant) init (2) ;
  2    15 declare  RELATION fixed bin internal static options (constant) init (3) ;
  2    16 declare  ATTRIBUTE fixed bin internal static options (constant) init (4) ;
  2    17 declare  FILE fixed bin internal static options (constant) init (5) ;
  2    18 declare  ITEM fixed bin internal static options (constant) init (6) ;
  2    19 declare  LINK fixed bin internal static options (constant) init (7) ;
  2    20 declare  FOREIGN_KEY fixed bin internal static options (constant) init (8) ;
  2    21 declare  CHILDREN fixed bin internal static options (constant) init (9) ;
  2    22 declare  INDEX fixed bin internal static options (constant) init (10) ;
  2    23 declare  DELETE_NAME fixed bin internal static options (constant) init (11) ;
  2    24 declare  DOM_LIST fixed bin internal static options (constant) init (12) ; /* in link handler */
  2    25 
  2    26 /* SEMANTIC STRUCTURES */
  2    27 
  2    28 declare  DIRECTIVE fixed bin internal static options (constant) init (13) ;
  2    29 declare  STMT fixed bin internal static options (constant) init (14) ;
  2    30 
  2    31 
  2    32 /* PARSING STRUCTURES */
  2    33 
  2    34 declare  LEX_STACK fixed bin internal static options (constant) init (15) ;
  2    35 declare  P_STRUCT fixed bin internal static options (constant) init (16) ;
  2    36 declare  CUR_LEX_TOP fixed bin internal static options (constant) init (17) ;
  2    37 declare  FIXUP_TOKEN fixed bin internal static options (constant) init (50) ; /* scanner */
  2    38 declare  STRING_SOURCE fixed bin internal static options (constant) init (51) ; /* semantics */
  2    39 declare  TOKEN fixed bin internal static options (constant) init (18) ;
  2    40 declare  OUTPUT_TEXT fixed bin internal static options (constant) init (19) ;
  2    41 
  2    42 
  2    43 /* DB_MODEL STRUCTURES */
  2    44 
  2    45 declare  DB_MODEL fixed bin internal static options (constant) init (0) ;
  2    46 declare  FILE_INFO fixed bin internal static options (constant) init (1) ;
  2    47 declare  DOMAIN_INFO fixed bin internal static options (constant) init (2) ;
  2    48 declare  PATH_ENTRY fixed bin internal static options (constant) init (3) ;
  2    49 declare  STACK_ITEM fixed bin internal static options (constant) init (4) ;
  2    50 declare  CONSTANT fixed bin internal static options (constant) init (30) ;
  2    51 declare  VERSION_STATUS fixed bin internal static options (constant) init (5) ;
  2    52 declare  CHANGER fixed bin internal static options (constant) init (6) ;
  2    53 
  2    54 
  2    55 /* FILE_MODEL STRUCTURES */
  2    56 
  2    57 declare  FILE_MODEL fixed bin internal static options (constant) init (7) ;
  2    58 declare  REL_INFO fixed bin internal static options (constant) init (8) ;
  2    59 declare  ATTR_INFO fixed bin internal static options (constant) init (9) ;
  2    60 declare  PARENT_LINK_INFO fixed bin internal static options (constant) init (10) ;
  2    61 declare  CHILD_LINK_INFO fixed bin internal static options (constant) init (11) ;
  2    62 declare  ATTR_LIST fixed bin internal static options (constant) init (12) ;
  2    63 declare  ATD fixed bin internal static options (constant) init (31) ;
  2    64 declare  COMP_NO_ARRAY fixed bin internal static options (constant) init (32) ;
  2    65 declare  SORT_KEY fixed bin internal static options (constant) init (13) ;
  2    66 declare  DUP_PREV fixed bin internal static options (constant) init (14) ;
  2    67 declare  SELECT_CHAIN fixed bin internal static options (constant) init (15) ;
  2    68 
  2    69 
  2    70 /* GLOBAL LIST STRUCTURES */
  2    71 
  2    72 declare  GL fixed bin internal static options (constant) init (20) ;
  2    73 declare  SL fixed bin internal static options (constant) init (21) ;
  2    74 declare  SEGINFO fixed bin internal static options (constant) init (22) ;
  2    75 declare  LIST_OVRLY fixed bin internal static options (constant) init (26) ;
  2    76 declare  SAVED_CHILD_COUNT fixed bin internal static options (constant) init (24) ; /* in global list build */
  2    77 declare  NODE fixed bin internal static options (constant) init (23) ;
  2    78 
  2    79 
  2    80 /* DISPLAY STRUCTURES */
  2    81 
  2    82 declare  DISPLAY_INFO fixed bin internal static options (constant) init (25) ;
  2    83 
  2    84 /*   Remove because nolonger used 82-06-28        
  2    85*  NAME_LIST fixed bin internal static options (constant) init (52) ;
  2    86*  PAI_ARRAY fixed bin internal static options (constant) init (53) ;
  2    87*  PAR_LK_ATTR_INFO fixed bin internal static options (constant) init (54) ;
  2    88*  CAI_ARRAY fixed bin internal static options (constant) init (55) ;
  2    89*  CHILD_LK_ATTR_INFO fixed bin internal static options (constant) init (56) ;
  2    90*  NAME_TABLE fixed bin internal static options (constant) init (57) ;
  2    91*  ATTR_TABLE fixed bin internal static options (constant) init (58) ;
  2    92**/
  2    93 
  2    94 /* END INCULDE FILE mrds_rst_struct_types */
  2    95 
      319 
      320 
  3     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  3     6*     modified to save space occupied by model
  3     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  3     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  3     9*     the number of secondary indices in the relation - it was always zero.
  3    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  3    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  3    12*     DMS conversion.
  3    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  3    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  3    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  3    16*     for relation manager changes.
  3    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  3    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  3    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  3    20*     <rel> files are good (for rmdb)
  3    21*                                                   END HISTORY COMMENTS */
  3    22 
  3    23 
  3    24 /* each file in the database will have a model segment with the name
  3    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  3    26*   the file_model structure is allocated at the base of the segment for a given file.
  3    27*   it contains an area with which all other structures in this include file are allocated.
  3    28*   these structures contain the information about which relations, foreign keys,
  3    29*   and attributes are members of this file. all lists are singly linked lists in
  3    30*   definition order. pointers to these structures are obtained by using the "pointer"
  3    31*   builtin function with arguments of the segment base pointer, and the
  3    32*   offset (bit (18)) relative to that pointer that is actually stored in
  3    33*   the file model itself. this is because pointer segment numbers are
  3    34*   per process dependent. the major lists pointed to by the file_model structure
  3    35*   are the list of relations in this file(each with a contained attribute list),
  3    36*   and the list of foreign keys whose parent relation resides in this file
  3    37*   (along with a participating attribute sublist, and the child relation list,
  3    38*   if they are also in this file) */
  3    39 
  3    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  3    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  3    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  3    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  3    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  3    45     2 reserved bit (32) unal,				/* reserved for future flags */
  3    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  3    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  3    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  3    49     2 pad_1 fixed bin (35),				/* for future use */
  3    50     2 pad_2 fixed bin (35),
  3    51     2 ratd_len fixed bin (21),			/* length of above */
  3    52     2 mratd_len fixed bin (21),			/* length of above */
  3    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  3    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  3    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  3    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  3    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  3    58     2 block_size unal fixed bin,			/* no. pages in block */
  3    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  3    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  3    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  3    62     2 num_rels unal fixed bin,			/* number of relations in file */
  3    63     2 num_links unal fixed bin,			/* number of links in file */
  3    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  3    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  3    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  3    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  3    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  3    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  3    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  3    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  3    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  3    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  3    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  3    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  3    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  3    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  3    78     2 open_eu_err_path_ptr unal bit (18),
  3    79     2 open_eu_after_path_ptr unal bit (18),
  3    80     2 open_er_before_path_ptr unal bit (18),
  3    81     2 open_er_err_path_ptr unal bit (18),
  3    82     2 open_er_after_path_ptr unal bit (18),
  3    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  3    84     2 open_neu_err_path_ptr unal bit (18),
  3    85     2 open_neu_after_path_ptr unal bit (18),
  3    86     2 open_ner_before_path_ptr unal bit (18),
  3    87     2 open_ner_err_path_ptr unal bit (18),
  3    88     2 open_ner_after_path_ptr unal bit (18),
  3    89     2 open_pu_before_path_ptr unal bit (18),
  3    90     2 open_pu_err_path_ptr unal bit (18),
  3    91     2 open_pu_after_path_ptr unal bit (18),
  3    92     2 open_pr_before_path_ptr unal bit (18),
  3    93     2 open_pr_err_path_ptr unal bit (18),
  3    94     2 open_pr_after_path_ptr unal bit (18),
  3    95     2 open_cu_before_path_ptr unal bit (18),
  3    96     2 open_cu_err_path_ptr unal bit (18),
  3    97     2 open_cu_after_path_ptr unal bit (18),
  3    98     2 open_cr_before_path_ptr unal bit (18),
  3    99     2 open_cr_err_path_ptr unal bit (18),
  3   100     2 open_cr_after_path_ptr unal bit (18),
  3   101     2 close_before_path_ptr unal bit (18),
  3   102     2 close_err_path_ptr unal bit (18),
  3   103     2 close_after_path_ptr unal bit (18),
  3   104     2 unused_1 unal bit (18),				/* for future expansion */
  3   105     2 unused_2 unal bit (18),
  3   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  3   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  3   108 dcl  fm_ptr ptr;
  3   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  3   110 dcl  atd_ptr ptr;
  3   111 dcl  atd_len fixed bin;
  3   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  3   113     2 ncomponents fixed bin,
  3   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  3   115 dcl  cna_ptr ptr;
  3   116 dcl  ncomp_init fixed bin;
  3   117 
  3   118 /* a rel_info structure contains information describing a relation.
  3   119*   a relation may only occur in one file, thus there is one rel_info
  3   120*   per relation per database, each stored in the file_model area for
  3   121*   the file that contains it. the list of rel_info's in this file
  3   122*   form a singly linked list in definition order.
  3   123*   the rel_info itself points to a list of the attributes it contains,
  3   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  3   125 
  3   126 dcl 1 rel_info aligned based (ri_ptr),
  3   127     2 name char (32),				/* relation name */
  3   128     2 id  bit (36) aligned,				/* relation id number */
  3   129     2 hashed bit (1) unal,				/* on if hashed */
  3   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  3   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  3   132     2 system bit (1) unal,				/* on if dont care how stored */
  3   133     2 indexed bit (1) unal,				/* on if secondary index */
  3   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  3   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  3   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  3   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  3   138     2 reserved bit (27) unal,				/* for future flags */
  3   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  3   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  3   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  3   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  3   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  3   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  3   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  3   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  3   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  3   148     2 unused_3 unal fixed bin,			/* element that was never used */
  3   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  3   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  3   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  3   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  3   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  3   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  3   155     2 attr_ptr unal bit (18),				/* to attr. info */
  3   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  3   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  3   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  3   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  3   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  3   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  3   162     2 link_err_path_ptr unal bit (18),
  3   163     2 link_after_path_ptr unal bit (18),
  3   164     2 unlk_before_path_ptr unal bit (18),
  3   165     2 unlk_err_path_ptr unal bit (18),
  3   166     2 unlk_after_path_ptr unal bit (18),
  3   167     2 str_before_path_ptr unal bit (18),
  3   168     2 str_err_path_ptr unal bit (18),
  3   169     2 str_after_path_ptr unal bit (18),
  3   170     2 del_before_path_ptr unal bit (18),
  3   171     2 del_err_path_ptr unal bit (18),
  3   172     2 del_after_path_ptr unal bit (18),
  3   173     2 mod_before_path_ptr unal bit (18),
  3   174     2 mod_err_path_ptr unal bit (18),
  3   175     2 mod_after_path_ptr unal bit (18),
  3   176     2 find_before_path_ptr unal bit (18),
  3   177     2 find_err_path_ptr unal bit (18),
  3   178     2 find_after_path_ptr unal bit (18),
  3   179     2 retr_before_path_ptr unal bit (18),
  3   180     2 retr_err_path_ptr unal bit (18),
  3   181     2 retr_after_path_ptr unal bit (18),
  3   182     2 unused_1 unal bit (18),				/* for future expansion */
  3   183     2 unused_2 unal bit (18),
  3   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  3   185 dcl  ri_ptr ptr;
  3   186 
  3   187 /* a attr_info structure contains information about an attribute in a given relation.
  3   188*   since attributes may appear in more than one relation, each occurence of an attribute
  3   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  3   190*   the list is singly linked in definition order. the attr_info describes
  3   191*   the data it represents, and how that data is used during a database search. */
  3   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  3   193     2 name char (32),				/* name of attribute */
  3   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  3   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  3   196     2 link_attr bit (1) unal,				/* on if participates in link */
  3   197     2 reserved bit (33) unal,
  3   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  3   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  3   200     2 key_order unal fixed bin,			/* relative posit. in key */
  3   201     2 bit_offset fixed bin (35),			/* position in tuple */
  3   202     2 bit_length fixed bin (35),			/* length if fixed */
  3   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  3   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  3   205     2 domain_ptr unal bit (18),			/* to domain info */
  3   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  3   207     2 fwd_thread unal bit (18),			/* to next in list */
  3   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  3   209 dcl  ai_ptr ptr;
  3   210 
  3   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  3   212*   each time a foreign key definition indicates a relation as it's parent,
  3   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  3   214*   a relation can be parent and/or child in any number of foreign keys.
  3   215*   the parent_link_info structure describes the foreign key, and also points
  3   216*   to a list of the attributes that participate in this foreign key.
  3   217*   (this could be from 1 up to all attributes in the relation)
  3   218*   the attr_list structures are in a singly linked list in definition order
  3   219*   for this purpose. also pointed to is a list of child_link_info's
  3   220*   that describe the child relations in this foreign key. since foreign keys
  3   221*   may span files, not all related child_link_info's have to be in this file's
  3   222*   model area. */
  3   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  3   224     2 name char (32),				/* name of link */
  3   225     2 singular bit (1) unal,				/* on if system owned link */
  3   226     2 temp bit (1) unal,				/* on if temp. order */
  3   227     2 first bit (1) unal,				/* insertion indicators */
  3   228     2 last bit (1) unal,
  3   229     2 next bit (1) unal,
  3   230     2 prior bit (1) unal,
  3   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  3   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  3   233     2 dup_first bit (1) unal,				/* duplicates first */
  3   234     2 dup_last bit (1) unal,				/* duplicates last */
  3   235     2 indexed bit (1) unal,				/* locate parent via index */
  3   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  3   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  3   238     2 thread_27 bit (1) unal,
  3   239     2 thread_18 bit (1) unal,
  3   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  3   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  3   242     2 reserved bit (19) unal,				/* reserved for future flags */
  3   243     2 index_id aligned bit (8),			/* id of index if indexed */
  3   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  3   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  3   246     2 n_children unal fixed bin,			/* no. children in link */
  3   247     2 child_fn char (30),				/* file name for first child in list */
  3   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  3   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  3   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  3   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  3   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  3   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  3   254     2 sort_err_path_ptr unal bit (18),
  3   255     2 sort_after_path_ptr unal bit (18),
  3   256     2 srch_before_path_ptr unal bit (18),
  3   257     2 srch_err_path_ptr unal bit (18),
  3   258     2 srch_after_path_ptr unal bit (18),
  3   259     2 link_before_path_ptr unal bit (18),
  3   260     2 link_err_path_ptr unal bit (18),
  3   261     2 link_after_path_ptr unal bit (18),
  3   262     2 unlk_before_path_ptr unal bit (18),
  3   263     2 unlk_err_path_ptr unal bit (18),
  3   264     2 unlk_after_path_ptr unal bit (18),
  3   265     2 unused_1 unal bit (18),				/* for future expansion */
  3   266     2 unused_2 unal bit (18),
  3   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  3   268 dcl  pli_ptr ptr;
  3   269 
  3   270 /* a child_link_info structure is the counter part of a parent_link_info
  3   271*   for foreign key child relations. each time a relation is defined to be
  3   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  3   273*   this list is singly linked in foreign key definition order.
  3   274*   the child_link_info points to a list of participating attributes from the
  3   275*   child relation by means of a singly linked list of attr_list structures
  3   276*   in definition order. the number of attributes in the parent attr_list
  3   277*   and the child attr_list lists are the same with corresponding attr_list
  3   278*   attributes having the same domain. all child_link_infos in this file
  3   279*   are on a seperately linked list. this may not include all
  3   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  3   281*   since foreign keys may span files, and the child_link_info will
  3   282*   reside in the file containing it's associated relation_info. */
  3   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  3   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  3   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  3   286     2 fixed bit (1) unal,				/* on if membership fixed */
  3   287     2 optional bit (1) unal,				/* on if membership optional */
  3   288     2 auto bit (1) unal,				/* on if insertion automatic */
  3   289     2 manual bit (1) unal,				/* on if insertion manual */
  3   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  3   291     2 range_sel bit (1) unal,				/* on if range type selection */
  3   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  3   293     2 key_dup_last bit (1) unal,
  3   294     2 key_null bit (1) unal,				/* on if null allowed */
  3   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  3   296     2 sel_current bit (1) unal,
  3   297     2 sel_key bit (1) unal,
  3   298     2 sel_proc bit (1) unal,
  3   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  3   300     2 reserved bit (21) unal,
  3   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  3   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  3   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  3   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  3   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  3   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  3   307     2 parent_fn char (30),				/* file name for parent info */
  3   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  3   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  3   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  3   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  3   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  3   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  3   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  3   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  3   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  3   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  3   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  3   319     2 link_err_path_ptr unal bit (18),
  3   320     2 link_after_path_ptr unal bit (18),
  3   321     2 unlk_before_path_ptr unal bit (18),
  3   322     2 unlk_err_path_ptr unal bit (18),
  3   323     2 unlk_after_path_ptr unal bit (18),
  3   324     2 srch_before_path_ptr unal bit (18),
  3   325     2 srch_err_path_ptr unal bit (18),
  3   326     2 srch_after_path_ptr unal bit (18),
  3   327     2 unused_1 unal bit (18),				/* for future expansion */
  3   328     2 unused_2 unal bit (18) ;
  3   329 dcl  cli_ptr ptr;
  3   330 
  3   331 /* the attr_list structure is associated with the parent_link_info
  3   332*   and child_link_info structures to represent by means of a singly linked list
  3   333*   the participating attributes from relations in a foreign key.
  3   334*   the parent_link_info has a list for the parent relation,
  3   335*   and the child_link_info has a list for the child relation.
  3   336*   the participating attributes are a subset(not necessary proper) of
  3   337*   those attributes contained in a relation definition.
  3   338*   there are equal numbers of attr_list structures in the parent and
  3   339*   child lists of the same foreign key. the corresponding attributes in these
  3   340*   lists must have the same domain. */
  3   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  3   342     2 attr_fn char (30),				/* file name for attr. */
  3   343     2 attr_ptr unal bit (18),				/* to attr info block */
  3   344     2 fwd_thread unal bit (18);			/* to next in list */
  3   345 dcl  al_ptr ptr;
  3   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  3   347     2 ascend bit (1) unal,				/* ascending order */
  3   348     2 descend bit (1) unal,				/* descending order */
  3   349     2 reserved bit (34) unal,
  3   350     2 attr_ptr unal bit (18),				/* to attr info */
  3   351     2 fwd_thread unal bit (18);			/* to next in list */
  3   352 dcl  sk_ptr ptr;
  3   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  3   354     2 attr_ptr unal bit (18),				/* to attr info */
  3   355     2 fwd_thread unal bit (18);			/* to next in list */
  3   356 dcl  dp_ptr ptr;
  3   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  3   358     2 link_fn char (30),				/* file name for thru link */
  3   359     2 link_ptr unal bit (18),				/* to parent link info */
  3   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  3   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  3   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  3   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  3   364     2 fwd_thread unal bit (18);			/* to next in chain */
  3   365 dcl  sc_ptr ptr;
  3   366 
  3   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  3   368 
  3   369 
      321 
      322 
  4     1 /* BEGIN mdbm_rs_info.incl.pl1 -- jaw, 6/15/78 (from mda, 6/15/77) */
  4     2 
  4     3 dcl 1 rs_info aligned,
  4     4     2 version fixed init (2),				/* must be set to 1 or 2 (Input) */
  4     5     2 flags aligned,
  4     6       3 lock_sw bit (1) unal,				/* Input -- if ="1"b  try to lock record */
  4     7       3 unlock_sw bit (1) unal,			/* Input -- if ="1"b try to unlock record */
  4     8       3 create_sw bit (1) unal,			/* Input--if set creat new record */
  4     9       3 locate_sw bit (1) unal,			/* Input--if set causes current rec to be
  4    10*						   located outside the index by descrip, or created without key */
  4    11       3 inc_ref_count bit (1) unal,			/* Input--bump reference count of record, if stationary */
  4    12       3 dec_ref_count bit (1) unal,			/* Input--decrement ref count if this flag set and
  4    13*						   record stationary */
  4    14       3 locate_pos_sw bit (1) unal,			/* Input--if set the record_length is taken
  4    15*						   as an input arg. spec. the abs. logical record position
  4    16*						   \	  to which both current and next will be set */
  4    17       3 mbz1 bit (29) unal,				/* must be set to "0"b, reserved for future use */
  4    18     2 record_length fixed (21),			/* length in bytes, Input if create_sw set */
  4    19     2 max_rec_len fixed (21),				/* max length of contained record
  4    20*						   Input if create_sw is set--overrides min_block_size */
  4    21     2 record_ptr ptr,				/* points to first byte of record--will be word aligned */
  4    22     2 descriptor fixed (35),				/* Input if locate_sw set and create_sw="0"b */
  4    23     2 ref_count fixed (34),				/* Output--should match number of keys on this record--
  4    24*						   = -1 if non-stationary record */
  4    25     2 time_last_modified fixed (71),			/* Output */
  4    26     2 modifier fixed (35),				/* Output--also Input when locking */
  4    27     2 block_ptr ptr unal,				/* Output */
  4    28     2 mbz2 (2) fixed init (0, 0);
  4    29 
  4    30 /* END mdbm_rs_info.incl.pl1 */
  4    31 
      323 
      324 
  5     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  5     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  5     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  5     9*     Nguyen. The scopes_changed flag was added to make checking for this
  5    10*     more efficient (mrds error list #137).
  5    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  5    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  5    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  5    14*     care if multiple txns use the same selection_expression. (mrds #156)
  5    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  5    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  5    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  5    18*                                                   END HISTORY COMMENTS */
  5    19 
  5    20 
  5    21 /* WARNING
  5    22*          If the dbcb structure is changed then the mrds_data_
  5    23*          item saved_res_version MUST be incremented to invalidate all
  5    24*          existing saved resultants
  5    25**/
  5    26 
  5    27 /* HISTORY :
  5    28*
  5    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  5    30*   tid_list management
  5    31*
  5    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  5    33*   phony resultant in mu_database_index, without having the area dcl
  5    34*   included.
  5    35*
  5    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  5    37*   mrds_dsl_store
  5    38*
  5    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  5    40*   switches
  5    41*
  5    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  5    43*   expression,  so  that relation statistics can be updated relative
  5    44*   to number of selection expressions seem. Also  removed  init  for
  5    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  5    46*   mrds_dsl_init_res.
  5    47*
  5    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  5    49*
  5    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  5    51*   for the conversion to the relation manager.
  5    52*
  5    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  5    54*   substructures so that the entries and costs can change
  5    55*   depending on the type of database that is opened.
  5    56*
  5    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  5    58*   since modify uses a different vector type (general) than does store.
  5    59*
  5    60*   82-09-20 Davids: changed names of (store modify)_vector to
  5    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  5    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  5    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  5    64*   during the first call.
  5    65*
  5    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  5    67*   since it deals with the pointers to the cursors and not the cursors
  5    68*   themelves and added the element cursor_storage_area_ptr which points
  5    69*   to the area where the cursors are kept.
  5    70*
  5    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  5    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  5    73*   anything.
  5    74*
  5    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  5    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  5    77*   by mrds_dsl_define_temp_rel.
  5    78*
  5    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  5    80*   is needed by mu_store.
  5    81*
  5    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  5    83*   bin to float bin since the values are not integers.
  5    84*
  5    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  5    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  5    87*   added to the end of the structure to allow modules that don't use
  5    88*   the element to continue to reference the dbcb structure without recompiling.
  5    89*
  5    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  5    91*   are needed so that temp rels can be created with the same file attributes
  5    92*   as the permanent relations.
  5    93*
  5    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  5    95*   added the resultant_in_pdir bit.
  5    96*
  5    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  5    98*   added the res_already_made element.
  5    99*
  5   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  5   101*
  5   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  5   103*   one of the unused pointers.
  5   104*
  5   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  5   106*
  5   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  5   108*   leaving unused_ptrs(1).
  5   109*
  5   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  5   111*   unused_ptrs (1).
  5   112*
  5   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  5   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  5   115*   spare ptrs, entries and reserved storages for future enhancement, since
  5   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  5   117*
  5   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  5   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  5   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  5   121**/
  5   122 
  5   123 
  5   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  5   125*   that constitutes the non-secure portion of the resultant model that is
  5   126*   created during the opening of a database. it contains variables that
  5   127*   are used during the runtime access of the database, and an area
  5   128*   for evaluation of requests. it points to four other
  5   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  5   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  5   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  5   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  5   133*   used in the elimination of duplicate tuples during a retrieve.
  5   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  5   135*   that is used when the database is using the file scope mechanism
  5   136*   for concurrency control over file readying. the segment overlayed via
  5   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  5   138*   across database openings. the pointer to this dbcb structure is kept in a table
  5   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  5   140*   opening instances of resultant models. (see mu_database_index routine) */
  5   141 
  5   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  5   143 	     2 data	      like dbcb_data,
  5   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  5   145 
  5   146      dcl	   dbcb_ptr	      ptr;
  5   147 
  5   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  5   149*						   like references can avoid getting the area declaration */
  5   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  5   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  5   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  5   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  5   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  5   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  5   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  5   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  5   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  5   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  5   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  5   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  5   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  5   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  5   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  5   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  5   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  5   167*						   for eliminating duplicate tuples. */
  5   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  5   169*						   for eliminating duplicate tuples. */
  5   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  5   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  5   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  5   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  5   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  5   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  5   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  5   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  5   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  5   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  5   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  5   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  5   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  5   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  5   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  5   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  5   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  5   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  5   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  5   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  5   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  5   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  5   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  5   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  5   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  5   195 	     2 val_del	      bit (1) unal,		/* for delete */
  5   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  5   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  5   198*                                                                     not imply that the database is of type page_file */
  5   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  5   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  5   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  5   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  5   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  5   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  5   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  5   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  5   207*						   inside a sequence of -another selection expression. */
  5   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  5   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  5   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  5   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  5   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  5   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  5   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  5   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  5   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  5   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  5   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  5   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  5   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  5   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  5   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  5   223 	     2 relmgr_entries,			/* relation manager entries */
  5   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  5   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  5   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  5   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  5   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  5   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  5   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  5   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  5   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  5   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  5   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  5   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  5   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  5   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  5   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  5   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  5   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  5   241 	       3 reserved_entries (5) entry (),
  5   242 	     2 access_costs,			/* access costs for permute */
  5   243 	       3 total_primary_key_cost float bin,
  5   244 	       3 access_cost      float bin,
  5   245 	       3 access_overhead  float bin,
  5   246 	       3 us_access_cost   float bin,
  5   247 	       3 os_access_cost   float bin,
  5   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  5   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  5   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  5   251 
  5   252 /* END mrds_dbcb.incl.pl1 */
  5   253 
  5   254 
      325 
      326 
  6     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  6     6*     modified to save space occupied by model
  6     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  6     8*     to add mdbm_secured bit in db_model
  6     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  6    10*     collapsed the following into an unused_offset array:
  6    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  6    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  6    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  6    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  6    15*       unused_1
  6    16*     Also changed the name of unused_2 to restructuring_history_offset
  6    17*     and changed the comment on the changer structure to indicate
  6    18*     that it will contain on database creation information.
  6    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  6    20*     used one of the unused_offsets to point to a message which indicates
  6    21*     why the db is inconsistent. The offset will be null when the db is created
  6    22*     and set the first time the message is used. this is so it will be
  6    23*     consistent with existing data bases. Also added the message structure.
  6    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  6    25*     added the undo_request element to the message structure
  6    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  6    27*     changed unused_offset (12) to last_restructruring_history_offset and
  6    28*     changed restructuring_history_offset to first_restructuring_history_offset
  6    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  6    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  6    31*     1 => vfile database and 2 => page_file database. Up to this point all
  6    32*     database types were equal to 1.
  6    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  6    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  6    35*     flags. This will allow information about transactions and dm_file
  6    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  6    37*     change is compatable with all datamodels created by the released version
  6    38*     of mrds.
  6    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  6    40*     added the rollback_on flag to the db_type_flags since it appears that you
  6    41*     can have a dmfile database that requires transactions but does not have any
  6    42*     journalizing. Also switched the order of the transactions_needed and
  6    43*     concurrency_on flags - this makes the change compatable with existing
  6    44*     dmfile databases except when displaying the model since concurrency_on and
  6    45*     rollback_on will be off in the model even though the dmfile relations had
  6    46*     them on during creation.
  6    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  6    48*      Removed ctl_file_path_ptr.
  6    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  6    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  6    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  6    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  6    53*      in the flag word for rmdb copying.
  6    54*                                                   END HISTORY COMMENTS */
  6    55 
  6    56 
  6    57 /* this include file contains the structures that go into the make up
  6    58*   of the "db_model" segment in the model for the database.
  6    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  6    60*
  6    61*   the db_model structure goes at the base of the segment, and contains items unique to
  6    62*   the whole databse. in addition, it has an area of size to fill the
  6    63*   rest of a segment, that holds the lists of files and domains in the database.
  6    64*   these lists are singly forward linked lists. all "pointers" in the database model
  6    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  6    66*   since actual pointers are process dependent on segment number.
  6    67*   the remaining structures are first a path_entry one to save pathnames in,
  6    68*   and the stack_item and constent structures, used to save a boolean
  6    69*   expression in polish form, with the stack represented by a linked list.
  6    70*   the final structure is one for identifying the status of version information */
  6    71 
  6    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  6    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  6    74 	     2 db_type_flags      unal,
  6    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  6    76 	       3 unused	      (13) bit (1) unal,
  6    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  6    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  6    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  6    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  6    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  6    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  6    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  6    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  6    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  6    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  6    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  6    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  6    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  6    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  6    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  6    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  6    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  6    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  6    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  6    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  6    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  6    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  6    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  6   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  6   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  6   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  6   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  6   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  6   105 
  6   106      dcl	   dbm_ptr	      ptr;
  6   107 
  6   108 /* the files in the database each have a file_info containing
  6   109*   their name, the file_model for each file is found by initiating the
  6   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  6   111*   the file_info list is a singly linked list in definition order */
  6   112 
  6   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  6   114 	     2 file_name	      char (30),		/* name of file */
  6   115 	     2 file_id	      bit (36),		/* id number of file */
  6   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  6   117 	     2 unused	      unal bit (18);	/* for future expansion */
  6   118 
  6   119      dcl	   fi_ptr		      ptr;
  6   120 
  6   121 /* each domain used in the database will have a domain info saved in the db_model
  6   122*   segment. it describes the domain of the given name, and it's options.
  6   123*   the domain_info's form a singly linked list in definition order */
  6   124 
  6   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  6   126 	     2 name	      char (32),		/* name of domain */
  6   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  6   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  6   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  6   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  6   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  6   132 	     2 reserved	      bit (31) unal,
  6   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  6   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  6   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  6   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  6   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  6   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  6   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  6   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  6   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  6   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  6   143 	     2 str_err_path_ptr   unal bit (18),
  6   144 	     2 str_after_path_ptr unal bit (18),
  6   145 	     2 get_before_path_ptr unal bit (18),
  6   146 	     2 get_err_path_ptr   unal bit (18),
  6   147 	     2 get_after_path_ptr unal bit (18),
  6   148 	     2 mod_before_path_ptr unal bit (18),
  6   149 	     2 mod_err_path_ptr   unal bit (18),
  6   150 	     2 mod_after_path_ptr unal bit (18),
  6   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  6   152 	     2 unused_2	      unal bit (18),
  6   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  6   154 
  6   155      dcl	   di_ptr		      ptr;
  6   156 
  6   157 /* information necessary for attributes that are not used in any relation */
  6   158 
  6   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  6   160 	     2 name char (32),			/* name of attribute */
  6   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  6   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  6   163 	     2 unused (2) bit (18) unal;
  6   164 
  6   165      dcl     ua_ptr ptr;
  6   166 
  6   167 
  6   168 /* space saving pathname$entryname structure, to be allocated
  6   169*   only when a path$entry has to be saved, else only a bit(18)
  6   170*   offset takes up space in the main model structure */
  6   171 
  6   172      declare 1 path_entry	      based (path_entry_ptr),
  6   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  6   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  6   175 	     2 reserved	      unal bit (36);	/* for future use */
  6   176 
  6   177      declare path_entry_ptr	      ptr;
  6   178 
  6   179 
  6   180 
  6   181 
  6   182 
  6   183 /* declarations for model of postfix stack holding the check option boolean expression
  6   184*   the following encoding values indicate the corresponding type of stack element
  6   185*
  6   186*   1  =
  6   187*   2  ^=
  6   188*   3  >
  6   189*   4  <
  6   190*   5  >=
  6   191*   6  <=
  6   192*
  6   193*   10  and
  6   194*   20  or
  6   195*   30  not
  6   196*
  6   197*   40  - (minus)
  6   198*
  6   199*   50  domain variable(same name as domain)
  6   200*
  6   201*   60  constant(number, bit string, or character string)
  6   202*
  6   203**/
  6   204 
  6   205 
  6   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  6   207 	     2 next	      bit (18),		/* link to next in list */
  6   208 	     2 type	      fixed binary,		/* code for this element type */
  6   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  6   210*						   if this is a constant element type */
  6   211 
  6   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  6   213 
  6   214 
  6   215 
  6   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  6   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  6   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  6   219 
  6   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  6   221 
  6   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  6   223 
  6   224 /* version structure, giving status of source for CMDB/RMDB,
  6   225*   status of model, and status of resultant */
  6   226 
  6   227 /* version number is in form MM.N.Y
  6   228*   where MM is the major version number, N is the minor version alteration,
  6   229*   and Y is the lastest modification to that alteration,
  6   230*   where M and N represent numbers 0-9, and Y is a letter */
  6   231 
  6   232      declare 1 version_status	      unal based (version_status_ptr),
  6   233 	     2 cmdb_rmdb,
  6   234 	       3 major	      fixed bin,
  6   235 	       3 minor	      fixed bin,
  6   236 	       3 modification     char (4),
  6   237 	     2 model,
  6   238 	       3 major	      fixed bin,
  6   239 	       3 minor	      fixed bin,
  6   240 	       3 modification     char (4),
  6   241 	     2 resultant,
  6   242 	       3 major	      fixed bin,
  6   243 	       3 minor	      fixed bin,
  6   244 	       3 modification     char (4);
  6   245 
  6   246      declare version_status_ptr     ptr;
  6   247 
  6   248 
  6   249 /* maintains information only about the db creation */
  6   250 
  6   251      declare 1 changer	      unal based (changer_ptr),
  6   252 	     2 id		      char (32),
  6   253 	     2 time	      fixed bin (71),
  6   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  6   255 
  6   256      declare changer_ptr	      ptr;
  6   257 
  6   258 
  6   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  6   260 	     02 len	      fixed bin,		/* length of the message */
  6   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  6   262 	     02 name	      char (32),		/* name of thing that set the message */
  6   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  6   264*                                                               that caused the database to become inconsistent */
  6   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  6   266 
  6   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  6   268 
  6   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  6   270 
  6   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  6   272 
  6   273 
      327 
      328 
  7     1 /* BEGIN INCLUDE FILE - dm_rel_creation_info.incl.pl1 */
  7     2 
  7     3 /* format: style1 */
  7     4      dcl	   1 rel_creation_info    aligned based (rel_creation_info_ptr),
  7     5 	     2 version	      fixed bin (35),
  7     6 	     2 file_create_info_ptr ptr,
  7     7 	     2 esm_info_ptr	      ptr,
  7     8 	     2 cism_info_ptr      ptr;
  7     9 
  7    10      dcl	   rel_creation_info_ptr  ptr;
  7    11      dcl	   REL_CREATION_INFO_VERSION_2 fixed bin (35) init (2);
  7    12 
  7    13 /* END INCLUDE FILE - dm_rel_creation_info.incl.pl1 */
      329 
      330 
  8     1 /* BEGIN INCLUDE FILE: dm_file_create_info.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*     This include file contains the declaration of the file_create_info
  8     5*     structure.  This structure is used to specify to file_manager_
  8     6*     attributes a file is to have.
  8     7**/
  8     8 
  8     9 /* HISTORY:
  8    10*Written by Jeffery D. Ives, 09/16/82.
  8    11*  (Original concept by Lindsey L. Spratt.)
  8    12*Modified:
  8    13*06/15/84 by Matthew Pierret:  Added ring_brackets. Changed to a char (8)
  8    14*            version.
  8    15*11/07/84 by Matthew Pierret:  Extended mbz_3 to by one word to cover the
  8    16*            gap caused by the double-word alignment of mbz_2.
  8    17**/
  8    18 
  8    19 /* format: style2,ind3 */
  8    20 
  8    21      dcl	   1 file_create_info     aligned based (file_create_info_ptr),
  8    22 	     2 version	      char (8) aligned,
  8    23 	     2 ci_size_in_bytes   fixed bin (35) init (4096),
  8    24 						/* control interval physical size, must be 4096	*/
  8    25 	     2 blocking_factor    fixed bin init (255),	/* # of cis in each msf seg, must be 64 or 255	*/
  8    26 	     2 flags	      unal,
  8    27 	       3 protected	      bit (1) unal init ("1"b),
  8    28 						/* protected against inconsistency		*/
  8    29 	       3 no_concurrency   bit (1) unal init ("0"b),
  8    30 						/* don't protect against concurrent access	*/
  8    31 	       3 no_rollback      bit (1) unal init ("0"b),
  8    32 						/* don't protect against system failure		*/
  8    33 	       3 mbz_1	      bit (15) unal init ("0"b),
  8    34 						/* must be zero for future compatability	*/
  8    35 	     2 ring_brackets      (2) fixed bin (3) unal init (0, 0),
  8    36 						/* write bracket is first element, read bracket is second */
  8    37 	     2 mbz_3	      bit (46) unal init ("0"b),
  8    38 						/* must be zero for future compatability */
  8    39 	     2 mbz_2	      (30) fixed bin (71);	/* must be zero for future compatability	*/
  8    40 
  8    41      dcl	   file_create_info_ptr   ptr;
  8    42 
  8    43      dcl	   FILE_CREATE_INFO_VERSION_2
  8    44 			      char (8) aligned static options (constant) init ("FileCr 2");
  8    45      dcl	   (
  8    46 	   FCI_WRITE_BRACKET_IDX  init (1),
  8    47 	   FCI_READ_BRACKET_IDX   init (2)
  8    48 	   )		      internal static options (constant);
  8    49 
  8    50 /* ************ END OF INCLUDE FILE: dm_file_create_info.incl.pl1 ********** */
      331 
      332 
  9     1 /* ***********************************************************
  9     2*   *                                                         *
  9     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  9     4*   *                                                         *
  9     5*   *********************************************************** */
  9     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
  9     7 
  9     8 /* Written by Lindsey Spratt, 03/04/82.
  9     9*Modified:
  9    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
  9    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
  9    12*	  the print_vector value (char varying), ptr to the typed_vector
  9    13*	  value location, and a code. cv_to_print now takes ptr to the
  9    14*	  descriptor, ptr to the typed_vector value, the print_vector value
  9    15*	  (char(*) varying), the maximum allowed length for the print_vector
  9    16*	  value, a temp_seg to put the value in if its to big to fit into
  9    17*	  the print_vector, and a code.
  9    18**/
  9    19 
  9    20 /* format: style2,ind3 */
  9    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
  9    22 	     2 version	      fixed bin (35),
  9    23 	     2 number_of_dimensions
  9    24 			      fixed bin (17),
  9    25 	     2 number_of_vectors  fixed bin (17),
  9    26 	     2 number_of_vector_slots
  9    27 			      fixed bin (17),
  9    28 	     2 maximum_dimension_name_length
  9    29 			      fixed bin (17),
  9    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
  9    31 	       3 name	      char (tva_maximum_dimension_name_length
  9    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
  9    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
  9    34 						/* temp_seg_ptr, max_length_for_print_value, */
  9    35 						/* print_value, code) */
  9    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
  9    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
  9    38 						/* print_value_ptr, typed_value_ptr, code) */
  9    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  9    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
  9    41 			      pointer;
  9    42 
  9    43      dcl	   typed_vector_array_ptr ptr;
  9    44      dcl	   tva_number_of_vector_slots
  9    45 			      fixed bin;
  9    46      dcl	   tva_number_of_dimensions
  9    47 			      fixed bin;
  9    48      dcl	   tva_maximum_dimension_name_length
  9    49 			      fixed bin;
  9    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
  9    51 			      fixed bin (35) int static options (constant) init (2);
  9    52 
  9    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
      333 
      334 
 10     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
 10     2 
 10     3 /* DESCRIPTION
 10     4*        The id_list structure is used to identify attributes, fields and
 10     5*   dimensions by various modules of the Data Management System.
 10     6**/
 10     7 
 10     8 /* HISTORY:
 10     9*Written by Matthew Pierret, '82.
 10    10*Modified:
 10    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
 10    12*            (constant)' and to initialize automatic variables.
 10    13**/
 10    14 
 10    15 /* format: style2,ind3 */
 10    16      dcl	   1 id_list	      aligned based (id_list_ptr),
 10    17 	     2 version	      fixed bin (35),
 10    18 	     2 number_of_ids      fixed bin (17),
 10    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
 10    20 
 10    21      dcl	   id_list_ptr	      ptr init (null);
 10    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
 10    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
 10    24 
 10    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
      335 
      336 
 11     1 /*  BEGIN INCLUDE FILE - dm_relation_index_flags.incl.pl1 */
 11     2 
 11     3 /* DESCRIPTION:
 11     4*
 11     5*	This structure is used to control the creation of an index by the 
 11     6*     relation_manager_.
 11     7**/
 11     8 
 11     9 /* HISTORY:
 11    10*
 11    11*Written by Lindsey Spratt, 09/20/83.
 11    12*Modified:
 11    13**/
 11    14 
 11    15 /* format: style2,ind3 */
 11    16      dcl	   1 relation_index_flags based (relation_index_flags_ptr) aligned,
 11    17 	     2 relation_must_be_empty
 11    18 			      bit (1) unal,
 11    19 	     2 index_is_clustering
 11    20 			      bit (1) unal,
 11    21 	     2 index_is_unique    bit (1) unal,
 11    22 	     2 pad	      bit (33) unal;
 11    23 
 11    24      dcl	   relation_index_flags_ptr
 11    25 			      ptr init (null);
 11    26 
 11    27 /*  END INCLUDE FILE - dm_relation_index_flags.incl.pl1 */
      337 
      338 
 12     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
 12     2*
 12     3*   Values for the "access mode" argument so often used in hardcore
 12     4*   James R. Davis 26 Jan 81  MCR 4844
 12     5*   Added constants for SM access 4/28/82 Jay Pattin
 12     6*   Added text strings 03/19/85 Chris Jones
 12     7**/
 12     8 
 12     9 
 12    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
 12    11 dcl	(
 12    12 	N_ACCESS		   init ("000"b),
 12    13 	R_ACCESS		   init ("100"b),
 12    14 	E_ACCESS		   init ("010"b),
 12    15 	W_ACCESS		   init ("001"b),
 12    16 	RE_ACCESS		   init ("110"b),
 12    17 	REW_ACCESS	   init ("111"b),
 12    18 	RW_ACCESS		   init ("101"b),
 12    19 	S_ACCESS		   init ("100"b),
 12    20 	M_ACCESS		   init ("010"b),
 12    21 	A_ACCESS		   init ("001"b),
 12    22 	SA_ACCESS		   init ("101"b),
 12    23 	SM_ACCESS		   init ("110"b),
 12    24 	SMA_ACCESS	   init ("111"b)
 12    25 	)		   bit (3) internal static options (constant);
 12    26 
 12    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
 12    28*   2) divide (bin_value, 2) to come up with an index into the array. */
 12    29 
 12    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
 12    31 			   static options (constant);
 12    32 
 12    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
 12    34 			   static options (constant);
 12    35 
 12    36 dcl	(
 12    37 	N_ACCESS_BIN	   init (00000b),
 12    38 	R_ACCESS_BIN	   init (01000b),
 12    39 	E_ACCESS_BIN	   init (00100b),
 12    40 	W_ACCESS_BIN	   init (00010b),
 12    41 	RW_ACCESS_BIN	   init (01010b),
 12    42 	RE_ACCESS_BIN	   init (01100b),
 12    43 	REW_ACCESS_BIN	   init (01110b),
 12    44 	S_ACCESS_BIN	   init (01000b),
 12    45 	M_ACCESS_BIN	   init (00010b),
 12    46 	A_ACCESS_BIN	   init (00001b),
 12    47 	SA_ACCESS_BIN	   init (01001b),
 12    48 	SM_ACCESS_BIN	   init (01010b),
 12    49 	SMA_ACCESS_BIN	   init (01011b)
 12    50 	)		   fixed bin (5) internal static options (constant);
 12    51 
 12    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      339 
      340      end mrds_rst_format_file;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1315.0  mrds_rst_format_file.pl1          >special_ldd>install>MR12.2-1073>mrds_rst_format_file.pl1
317          1    10/14/83  1609.1  mrds_rst_rsc.incl.pl1             >ldd>include>mrds_rst_rsc.incl.pl1
319          2    10/14/83  1609.0  mrds_rst_struct_types.incl.pl1    >ldd>include>mrds_rst_struct_types.incl.pl1
321          3    10/17/86  1404.5  mdbm_file_model.incl.pl1          >ldd>include>mdbm_file_model.incl.pl1
323          4    10/14/83  1609.0  mdbm_rs_info.incl.pl1             >ldd>include>mdbm_rs_info.incl.pl1
325          5    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
327          6    10/17/86  1404.3  mdbm_db_model.incl.pl1            >ldd>include>mdbm_db_model.incl.pl1
329          7    10/14/83  1609.1  dm_rel_creation_info.incl.pl1     >ldd>include>dm_rel_creation_info.incl.pl1
331          8    01/07/85  0901.1  dm_file_create_info.incl.pl1      >ldd>include>dm_file_create_info.incl.pl1
333          9    10/14/83  1609.1  vu_typed_vector_array.incl.pl1    >ldd>include>vu_typed_vector_array.incl.pl1
335         10    10/14/83  1609.1  dm_id_list.incl.pl1               >ldd>include>dm_id_list.incl.pl1
337         11    10/14/83  1609.1  dm_relation_index_flags.incl.pl1  >ldd>include>dm_relation_index_flags.incl.pl1
339         12    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
FILE_CREATE_INFO_VERSION_2      000002 constant        char(8)                  initial dcl 8-43 ref 142
ID_LIST_VERSION_1                      constant        fixed bin(17,0)          initial dcl 10-23 ref 115
NULL_OFFSET                            constant        bit(18)                  initial packed unaligned dcl 307 ref 211
OFF                                    constant        bit(1)                   initial dcl 308 ref 148 151 156 157 207
ON                                     constant        bit(1)                   initial dcl 309 ref 158
REL_CREATION_INFO_VERSION_2     000160 automatic       fixed bin(35,0)          initial dcl 7-11 set ref 138 7-11*
RW_ACCESS                       000000 constant        bit(3)                   initial packed unaligned dcl 12-11 set ref 89* 94*
                                                                                  101*
TYPED_VECTOR_ARRAY_VERSION_2           constant        fixed bin(35,0)          initial dcl 9-50 ref 117
addr                                                   builtin function         dcl 294 ref 128 139 155
ai_ptr                          000132 automatic       pointer                  dcl 3-209 set ref 118* 121 123 126 127 129* 129 211*
                                                                                  211* 215 216 220 231* 241
attr_info                              based           structure                level 1 dcl 3-192
attr_ptr                 24(18)        based           bit(18)                  level 2 packed packed unaligned dcl 3-126 ref 118
                                                                                  211
bit_count                       000100 automatic       fixed bin(24,0)          dcl 282 set ref 89* 94* 101*
blocking_factor           3            based           fixed bin(17,0)          initial level 2 dcl 8-21 set ref 134* 144*
ci_size_in_bytes          2            based           fixed bin(35,0)          initial level 2 dcl 8-21 set ref 134* 143*
cism_info_ptr             6            based           pointer                  level 2 dcl 7-4 set ref 141*
code                                   parameter       fixed bin(35,0)          dcl 283 set ref 53 83* 277*
concurrency_on          206(26)        based           bit(1)                   level 3 packed packed unaligned dcl 1-29 ref 146
db_desc                  11            based           bit(36)                  level 2 dcl 6-125 set ref 128
db_relation_mode_flags
                        206(24)        based           structure                level 2 packed packed unaligned dcl 1-29
dbcb_data                              based           structure                level 1 unaligned dcl 5-148
dbm_ptr                         000152 automatic       pointer                  dcl 6-106 set ref 89* 94* 97 126
dbp                      62            based           char(168)                level 2 packed packed unaligned dcl 1-29 set ref 89*
                                                                                  91 91 94* 101* 167* 187*
defn_order               12            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-192 ref 123
                                                                                  216
descriptor_ptr                         based           pointer                  array level 3 dcl 9-21 set ref 128*
di_ptr                          000154 automatic       pointer                  dcl 6-155 set ref 126* 128
dimension_table           6            based           structure                array level 2 dcl 9-21
dm_file_type            206(24)        based           bit(1)                   level 3 packed packed unaligned dcl 1-29 ref 165 218
                                                                                  245
domain_info                            based           structure                level 1 dcl 6-125
domain_ptr               17            based           bit(18)                  level 2 packed packed unaligned dcl 3-192 ref 126
err_code                               parameter       fixed bin(35,0)          dcl 274 set ref 269 277 278*
err_rsc_ptr                            parameter       pointer                  dcl 272 set ref 269 278*
err_severity                           parameter       fixed bin(17,0)          dcl 273 set ref 269 278*
err_text                               parameter       char                     packed unaligned dcl 275 set ref 269 278*
error_code                      000101 automatic       fixed bin(35,0)          dcl 284 set ref 89* 90 90 91* 93 93* 94* 101* 102*
                                                                                  167* 170 170* 176* 179 179* 187* 190 190* 196* 198
                                                                                  198* 220* 223 223* 231* 233 233* 245* 247* 248
                                                                                  248*
error_table_$no_r_permission    000010 external static fixed bin(35,0)          dcl 285 ref 90
error_table_$no_w_permission    000012 external static fixed bin(35,0)          dcl 287 ref 90
esm_info_ptr              4            based           pointer                  level 2 dcl 7-4 set ref 140*
file_create_info                       based           structure                level 1 dcl 8-21 set ref 134 139
file_create_info_ptr            000162 automatic       pointer                  dcl 8-41 in procedure "mrds_rst_format_file" set ref
                                                                                  134* 139 142 143 144 145 146 147 148 149 150 151
file_create_info_ptr      2            based           pointer                  level 2 in structure "rel_creation_info" dcl 7-4
                                                                                  in procedure "mrds_rst_format_file" set ref 139*
file_model                             based           structure                level 1 dcl 3-40
file_model_name                 000102 automatic       char(32)                 packed unaligned dcl 289 set ref 100* 101* 102
file_segment_name               000116 automatic       char(32)                 packed unaligned dcl 301 set ref 87* 100 167* 170
                                                                                  179 187* 190 198 223 233 248
flag_list                       000112 automatic       bit(36)                  dcl 290 set ref 155 176* 196* 220* 231*
flags                     4            based           structure                level 2 packed packed unaligned dcl 8-21
fm_ptr                          000126 automatic       pointer                  dcl 3-108 set ref 101* 102 105 105 118 129 211 241
fwd_thread               20            based           bit(18)                  level 2 packed packed unaligned dcl 3-192 ref 129
                                                                                  241
i                               000113 automatic       fixed bin(17,0)          dcl 291 set ref 119* 127 128*
id                        2            based           fixed bin(17,0)          array level 2 in structure "id_list" dcl 10-16
                                                                                  in procedure "mrds_rst_format_file" set ref 123*
                                                                                  216*
id                       10            based           bit(36)                  level 2 in structure "rel_info" dcl 3-126
                                                                                  in procedure "mrds_rst_format_file" set ref 167*
                                                                                  187*
id_list                                based           structure                level 1 dcl 10-16 set ref 113
id_list_ptr                     000172 automatic       pointer                  initial dcl 10-21 set ref 113* 114 115 122 122 123
                                                                                  123 176* 196* 209 216 220* 231* 10-21*
il_number_of_ids                000174 automatic       fixed bin(17,0)          initial dcl 10-22 set ref 112* 113 113 10-22*
index_attr               10(01)        based           bit(1)                   level 2 packed packed unaligned dcl 3-192 ref 215
index_id                 11            based           bit(36)                  level 2 dcl 3-192 set ref 220* 231*
index_is_clustering       0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 11-16 set ref
                                                                                  157*
index_is_unique           0(02)        based           bit(1)                   level 2 packed packed unaligned dcl 11-16 set ref
                                                                                  158* 207*
initiate_file_                  000014 constant        entry                    external dcl 292 ref 89 94 101
input_file_name                        parameter       char                     packed unaligned dcl 300 set ref 53 78* 87 255*
key_attr                 10            based           bit(1)                   level 2 packed packed unaligned dcl 3-192 ref 121
maximum_dimension_name_length
                          4            based           fixed bin(17,0)          level 2 dcl 9-21 set ref 110* 127 127 127 128 128
                                                                                  128
mbz2                     14     000134 automatic       fixed bin(17,0)          initial array level 2 dcl 4-3 set ref 4-3* 4-3*
mbz_1                     4(03)        based           bit(15)                  initial level 3 packed packed unaligned dcl 8-21 set
                                                                                  ref 134* 148*
mbz_2                     6            based           fixed bin(71,0)          array level 2 dcl 8-21 set ref 150*
mbz_3                     4(26)        based           bit(46)                  initial level 2 packed packed unaligned dcl 8-21 set
                                                                                  ref 134* 151*
mrds_data_$relation_blocking_factor
                                000020 external static fixed bin(17,0)          dcl 302 ref 144
mrds_dm_authorization$set_needed_access
                                000022 constant        entry                    external dcl 303 ref 91
mrds_error_$no_database         000024 external static fixed bin(35,0)          dcl 304 set ref 97*
mrds_error_$no_model_access     000026 external static fixed bin(35,0)          dcl 305 ref 93
mrds_rst_error                  000030 constant        entry                    external dcl 306 ref 278
mrds_rst_meter                  000016 constant        entry                    external dcl 299 ref 78 255
name                      6            based           varying char             array level 3 in structure "typed_vector_array"
                                                                                  dcl 9-21 in procedure "mrds_rst_format_file" set
                                                                                  ref 127*
name                                   based           char(32)                 level 2 in structure "attr_info" dcl 3-192
                                                                                  in procedure "mrds_rst_format_file" ref 127
no_concurrency            4(01)        based           bit(1)                   initial level 3 packed packed unaligned dcl 8-21 set
                                                                                  ref 134* 146*
no_rollback               4(02)        based           bit(1)                   initial level 3 packed packed unaligned dcl 8-21 set
                                                                                  ref 134* 147*
null                                                   builtin function         dcl 294 ref 97 102 140 141 10-21 11-24
num_attr                 12            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-126 ref 108
                                                                                  112
number_of_dimensions      1            based           fixed bin(17,0)          level 2 dcl 9-21 set ref 110*
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 10-16 set ref 113* 114* 122* 122 123
                                                                                  209*
number_of_vector_slots
                          3            based           fixed bin(17,0)          level 2 dcl 9-21 set ref 110*
primary_key_index_id     25            based           bit(36)                  level 2 dcl 3-126 set ref 176* 196*
protected                 4            based           bit(1)                   initial level 3 packed packed unaligned dcl 8-21 set
                                                                                  ref 134* 145*
protection_on           206(25)        based           bit(1)                   level 3 packed packed unaligned dcl 1-29 ref 145
ptr                                                    builtin function         dcl 294 ref 105 118 126 129 211 241
rel                                                    builtin function         dcl 294 ref 211
rel_creation_info                      based           structure                level 1 dcl 7-4 set ref 133
rel_creation_info_ptr           000156 automatic       pointer                  dcl 7-10 set ref 133* 138 139 140 141 167* 187*
rel_info                               based           structure                level 1 dcl 3-126
rel_opening_id                  000114 automatic       bit(36)                  dcl 295 set ref 167* 176* 187* 196* 220* 231* 245*
                                                                                  247*
rel_ptr                  20(27)        based           bit(18)                  level 2 packed packed unaligned dcl 3-40 ref 105
relation_index_flags                   based           structure                level 1 dcl 11-16
relation_index_flags_ptr        000176 automatic       pointer                  initial dcl 11-24 set ref 155* 156 157 158 207
                                                                                  11-24*
relation_manager_$close         000032 constant        entry                    external dcl 310 ref 245
relation_manager_$create_index  000034 constant        entry                    external dcl 311 ref 176 220
relation_manager_$create_relation
                                000036 constant        entry                    external dcl 312 ref 167
relation_must_be_empty                 based           bit(1)                   level 2 packed packed unaligned dcl 11-16 set ref
                                                                                  156*
ri_ptr                          000130 automatic       pointer                  dcl 3-185 set ref 105* 108 112 118 167 176 187 196
                                                                                  211
ring_brackets             4(18)        based           fixed bin(3,0)           initial array level 2 packed packed unaligned
                                                                                  dcl 8-21 set ref 134* 134* 149*
rollback_on             206(27)        based           bit(1)                   level 3 packed packed unaligned dcl 1-29 ref 147
rs_info                         000134 automatic       structure                level 1 dcl 4-3
rsc                                    based           structure                level 1 unaligned dcl 1-29
rsc_ptr                                parameter       pointer                  dcl 1-94 set ref 53 78 78* 89 91 91 94 97* 101 102*
                                                                                  110 113 133 134 145 146 147 165 167 170* 179* 187
                                                                                  190* 198* 218 223* 233* 245 248* 255 255*
rtrim                                                  builtin function         dcl 294 ref 87 91 91 100
style                           000115 automatic       fixed bin(17,0)          dcl 296 set ref 154* 176* 196* 220* 231*
trace_sw                206(07)        based           bit(1)                   level 2 packed packed unaligned dcl 1-29 ref 78 255
tva_maximum_dimension_name_length
                                000170 automatic       fixed bin(17,0)          dcl 9-48 set ref 109* 110 110
tva_number_of_dimensions        000167 automatic       fixed bin(17,0)          dcl 9-46 set ref 108* 110 110 119
tva_number_of_vector_slots      000166 automatic       fixed bin(17,0)          dcl 9-44 set ref 107* 110 110
typed_vector_array                     based           structure                level 1 dcl 9-21 set ref 110
typed_vector_array_ptr          000164 automatic       pointer                  dcl 9-43 set ref 110* 117 127 128 167* 187*
version                                based           fixed bin(35,0)          level 2 in structure "id_list" dcl 10-16
                                                                                  in procedure "mrds_rst_format_file" set ref 115*
version                                based           char(8)                  level 2 in structure "file_create_info" dcl 8-21
                                                                                  in procedure "mrds_rst_format_file" set ref 142*
version                         000134 automatic       fixed bin(17,0)          initial level 2 in structure "rs_info" dcl 4-3
                                                                                  in procedure "mrds_rst_format_file" set ref 4-3*
version                                based           fixed bin(35,0)          level 2 in structure "rel_creation_info" dcl 7-4
                                                                                  in procedure "mrds_rst_format_file" set ref 138*
version                                based           fixed bin(35,0)          level 2 in structure "typed_vector_array" dcl 9-21
                                                                                  in procedure "mrds_rst_format_file" set ref 117*
vfile_relmgr_$close             000040 constant        entry                    external dcl 313 ref 247
vfile_relmgr_$create_MRDS_relation
                                000042 constant        entry                    external dcl 314 ref 187
vfile_relmgr_$create_index      000044 constant        entry                    external dcl 315 ref 196 231
wa                      270            based           area                     level 2 dcl 1-29 ref 110 113 133 134

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ATD                                    internal static fixed bin(17,0)          initial dcl 2-63
ATTRIBUTE                              internal static fixed bin(17,0)          initial dcl 2-16
ATTRIBUTE_DOMAIN                       internal static fixed bin(17,0)          initial dcl 2-14
ATTR_INFO                              internal static fixed bin(17,0)          initial dcl 2-59
ATTR_LIST                              internal static fixed bin(17,0)          initial dcl 2-62
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 12-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 12-36
CHANGER                                internal static fixed bin(17,0)          initial dcl 2-52
CHILDREN                               internal static fixed bin(17,0)          initial dcl 2-21
CHILD_LINK_INFO                        internal static fixed bin(17,0)          initial dcl 2-61
COMP_NO_ARRAY                          internal static fixed bin(17,0)          initial dcl 2-64
CONSTANT                               internal static fixed bin(17,0)          initial dcl 2-50
CUR_LEX_TOP                            internal static fixed bin(17,0)          initial dcl 2-36
DB_MODEL                               internal static fixed bin(17,0)          initial dcl 2-45
DELETE_NAME                            internal static fixed bin(17,0)          initial dcl 2-23
DIRECTIVE                              internal static fixed bin(17,0)          initial dcl 2-28
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 12-33
DISPLAY_INFO                           internal static fixed bin(17,0)          initial dcl 2-82
DOMAIN                                 internal static fixed bin(17,0)          initial dcl 2-13
DOMAIN_INFO                            internal static fixed bin(17,0)          initial dcl 2-47
DOM_LIST                               internal static fixed bin(17,0)          initial dcl 2-24
DUP_PREV                               internal static fixed bin(17,0)          initial dcl 2-66
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 12-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 12-36
FCI_READ_BRACKET_IDX                   internal static fixed bin(17,0)          initial dcl 8-45
FCI_WRITE_BRACKET_IDX                  internal static fixed bin(17,0)          initial dcl 8-45
FILE                                   internal static fixed bin(17,0)          initial dcl 2-17
FILE_INFO                              internal static fixed bin(17,0)          initial dcl 2-46
FILE_MODEL                             internal static fixed bin(17,0)          initial dcl 2-57
FIXUP_TOKEN                            internal static fixed bin(17,0)          initial dcl 2-37
FOREIGN_KEY                            internal static fixed bin(17,0)          initial dcl 2-20
GL                                     internal static fixed bin(17,0)          initial dcl 2-72
INDEX                                  internal static fixed bin(17,0)          initial dcl 2-22
ITEM                                   internal static fixed bin(17,0)          initial dcl 2-18
LEX_STACK                              internal static fixed bin(17,0)          initial dcl 2-34
LINK                                   internal static fixed bin(17,0)          initial dcl 2-19
LIST_OVRLY                             internal static fixed bin(17,0)          initial dcl 2-75
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 12-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 12-36
NODE                                   internal static fixed bin(17,0)          initial dcl 2-77
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 12-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 12-36
OUTPUT_TEXT                            internal static fixed bin(17,0)          initial dcl 2-40
PARENT_LINK_INFO                       internal static fixed bin(17,0)          initial dcl 2-60
PATH_ENTRY                             internal static fixed bin(17,0)          initial dcl 2-48
P_STRUCT                               internal static fixed bin(17,0)          initial dcl 2-35
RELATION                               internal static fixed bin(17,0)          initial dcl 2-15
REL_INFO                               internal static fixed bin(17,0)          initial dcl 2-58
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 12-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 12-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 12-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 12-36
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 12-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 12-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 12-36
SAVED_CHILD_COUNT                      internal static fixed bin(17,0)          initial dcl 2-76
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 12-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 12-36
SEGINFO                                internal static fixed bin(17,0)          initial dcl 2-74
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 12-30
SELECT_CHAIN                           internal static fixed bin(17,0)          initial dcl 2-67
SL                                     internal static fixed bin(17,0)          initial dcl 2-73
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 12-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 12-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 12-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 12-36
SORT_KEY                               internal static fixed bin(17,0)          initial dcl 2-65
STACK_ITEM                             internal static fixed bin(17,0)          initial dcl 2-49
STMT                                   internal static fixed bin(17,0)          initial dcl 2-29
STRING_SOURCE                          internal static fixed bin(17,0)          initial dcl 2-38
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 12-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 12-36
TOKEN                                  internal static fixed bin(17,0)          initial dcl 2-39
VERSION_STATUS                         internal static fixed bin(17,0)          initial dcl 2-51
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 12-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 12-36
al_ptr                                 automatic       pointer                  dcl 3-345
alloc_length                           internal static fixed bin(35,0)          dcl 6-222
atd                                    based           char                     packed unaligned dcl 3-109
atd_len                                automatic       fixed bin(17,0)          dcl 3-111
atd_ptr                                automatic       pointer                  dcl 3-110
attr_list                              based           structure                level 1 dcl 3-341
changer                                based           structure                level 1 packed packed unaligned dcl 6-251
changer_ptr                            automatic       pointer                  dcl 6-256
child_link_info                        based           structure                level 1 dcl 3-283
cli_ptr                                automatic       pointer                  dcl 3-329
cna_ptr                                automatic       pointer                  dcl 3-115
comp_no_array                          based           structure                level 1 packed packed unaligned dcl 3-112
constant                               based           structure                level 1 unaligned dcl 6-216
constant_ptr                           automatic       pointer                  dcl 6-220
db_model                               based           structure                level 1 dcl 6-72
dbcb                                   based           structure                level 1 dcl 5-142
dbcb_ptr                               automatic       pointer                  dcl 5-146
dp_ptr                                 automatic       pointer                  dcl 3-356
dup_prev                               based           structure                level 1 dcl 3-353
fi_ptr                                 automatic       pointer                  dcl 6-119
file_info                              based           structure                level 1 dcl 6-113
fixed                                                  builtin function         dcl 294
message_str                            based           structure                level 1 packed packed unaligned dcl 6-259
message_str_len                        automatic       fixed bin(17,0)          dcl 6-269
message_str_ptr                        automatic       pointer                  dcl 6-267
ncomp_init                             automatic       fixed bin(17,0)          dcl 3-116
parent_link_info                       based           structure                level 1 dcl 3-223
path_entry                             based           structure                level 1 packed packed unaligned dcl 6-172
path_entry_ptr                         automatic       pointer                  dcl 6-177
pli_ptr                                automatic       pointer                  dcl 3-268
sc_ptr                                 automatic       pointer                  dcl 3-365
select_chain                           based           structure                level 1 dcl 3-357
sk_ptr                                 automatic       pointer                  dcl 3-352
sort_key                               based           structure                level 1 dcl 3-346
stack_item                             based           structure                level 1 unaligned dcl 6-206
stack_item_ptr                         automatic       pointer                  dcl 6-212
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 297
ua_ptr                                 automatic       pointer                  dcl 6-165
unreferenced_attribute                 based           structure                level 1 dcl 6-159
version_status                         based           structure                level 1 packed packed unaligned dcl 6-232
version_status_ptr                     automatic       pointer                  dcl 6-246

NAMES DECLARED BY EXPLICIT CONTEXT.
EXIT                            002075 constant        label                    dcl 255 ref 279
error                           002142 constant        entry                    internal dcl 269 ref 97 102 170 179 190 198 223 233
                                                                                  248
mrds_rst_format_file            000133 constant        entry                    external dcl 53

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2444        2512    2217        2454
Length      3170    2217        46         442     224           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_rst_format_file                244 external procedure  is an external procedure.  
error                                   internal procedure  shares stack frame of external procedure mrds_rst_format_file.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_rst_format_file     000100 bit_count                   mrds_rst_format_file
                         000101 error_code                  mrds_rst_format_file
                         000102 file_model_name             mrds_rst_format_file
                         000112 flag_list                   mrds_rst_format_file
                         000113 i                           mrds_rst_format_file
                         000114 rel_opening_id              mrds_rst_format_file
                         000115 style                       mrds_rst_format_file
                         000116 file_segment_name           mrds_rst_format_file
                         000126 fm_ptr                      mrds_rst_format_file
                         000130 ri_ptr                      mrds_rst_format_file
                         000132 ai_ptr                      mrds_rst_format_file
                         000134 rs_info                     mrds_rst_format_file
                         000152 dbm_ptr                     mrds_rst_format_file
                         000154 di_ptr                      mrds_rst_format_file
                         000156 rel_creation_info_ptr       mrds_rst_format_file
                         000160 REL_CREATION_INFO_VERSION_2 mrds_rst_format_file
                         000162 file_create_info_ptr        mrds_rst_format_file
                         000164 typed_vector_array_ptr      mrds_rst_format_file
                         000166 tva_number_of_vector_slots  mrds_rst_format_file
                         000167 tva_number_of_dimensions    mrds_rst_format_file
                         000170 tva_maximum_dimension_name_length
                                                            mrds_rst_format_file
                         000172 id_list_ptr                 mrds_rst_format_file
                         000174 il_number_of_ids            mrds_rst_format_file
                         000176 relation_index_flags_ptr    mrds_rst_format_file

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          shorten_stack       ext_entry_desc
op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
initiate_file_                mrds_dm_authorization$set_needed_access                     mrds_rst_error
mrds_rst_meter                relation_manager_$close       relation_manager_$create_index
relation_manager_$create_relation                           vfile_relmgr_$close
vfile_relmgr_$create_MRDS_relation                          vfile_relmgr_$create_index

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$no_r_permission  error_table_$no_w_permission  mrds_data_$relation_blocking_factor
mrds_error_$no_database       mrds_error_$no_model_access




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     53 000127    4    3 000146    7   11 000157   10   21 000161   10   22 000163   11   24 000165        78 000167
     83 000231        87 000233        89 000251        90 000312        91 000320        93 000357        94 000366
     97 000430       100 000467       101 000515       102 000556       105 000627       107 000640       108 000641
    109 000644       110 000646       112 000704       113 000710       114 000723       115 000724       117 000726
    118 000730       119 000736       121 000745       122 000751       123 000753       126 000757       127 000764
    128 001015       129 001026       131 001033       133 001035       134 001045       138 001111       139 001113
    140 001116       141 001120       142 001121       143 001124       144 001126       145 001131       146 001141
    147 001151       148 001161       149 001163       150 001200       151 001214       154 001217       155 001221
    156 001223       157 001225       158 001227       165 001231       167 001237       170 001277       176 001336
    179 001360       183 001417       187 001420       190 001460       196 001517       198 001541       207 001600
    209 001602       211 001605       215 001617       216 001623       218 001627       220 001635       223 001656
    227 001715       231 001716       233 001737       241 001776       245 002005       247 002025       248 002036
    255 002075       260 002141       269 002142       277 002153       278 002157       279 002205


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
