	COMPILATION LISTING OF SEGMENT rmdb_delete_index
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/23/86  1012.0 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /****^  HISTORY COMMENTS:
        8*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
        9*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       10*     This entry is being made to cover the change made on 85-05-06 by Thanh
       11*     Nguyen. (see mrds #136)
       12*  2) change(86-10-21,Blair), approve(86-10-21,PBF7311), audit(86-10-23,Dupuis),
       13*     install(86-10-23,MR12.0-1199):
       14*     If the code from relmgr_entries.delete_index indicates that the index
       15*     doesn't exist, reset the code so that we can continue and delete the index
       16*     entry from the model.  This might happen if a create_index got rolled
       17*     back, but the model wasn't updated to reflect the rollback.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 rmdb_delete_index: proc (rdi_rmdb_ctl_ptr, rdi_db_abs_path, rdi_db_model_ptr, rdi_rel_name, rdi_attr_name, rdi_brief_flag,
       21 	rdi_error_message, rdi_code);
       22 
       23 /*
       24*                          BEGIN_DESCRIPTION
       25*   This module will change an indexed attribute in a relation into a
       26*   non-indexed attribute.
       27*
       28*   This process involves both updating the structures in  the  model
       29*   and deleting the old indices.
       30*
       31*   An  attempt  has  been  made   to   make   data   model   updates
       32*   uninterruptable by the user. To do this any quits signaled by the
       33*   user are delayed until the updates are complete.
       34*
       35*   It is not possible to recreate the deleted indices in  the  event
       36*   that  the  cleanup condition is signaled. Instead the database is
       37*   marked as inconsistent before the model is  updated  and  is  not
       38*   marked as consistent until the last tuple has been un-indexed.
       39*                          END_DESCRIPTION
       40*   NOTE:
       41*         Naming convention: because of the number of  internal  routines
       42*         and the need for descriptive names, variables declared  in  all
       43*         routines  (including the main entry) have prefixes that are the
       44*         initials  of  the  routine  name.  Global  variables   can   be
       45*         identified since they have a prefix different from that derived
       46*         from the routine name. Variables with the same name except  for
       47*         the  prefix mean the same thing. Variables without a prefix are
       48*         external to the module,  i.e.  entry  names,  external  static,
       49*         builtins,  conditions, etc. These variables are declared in the
       50*         main routine.
       51*   
       52*         In order to reduce the complexity of this module, none  of  the
       53*         internal  routines  have  an error code parameter. Instead they
       54*         set a global error code declared in the main routine, call  the
       55*         clean_up  routine,  and  perform  a non-local goto to leave the
       56*         module.
       57*   
       58*   Known Bugs:
       59*
       60*   Other Problems:
       61*
       62*
       63*
       64*
       65*                          HISTORY
       66*   82-05-20 Davids: Written
       67*
       68*   82-05-26 Davids: added rdi_db_model_ptr to the input parameters
       69*                    and removed code that initiated it.
       70*
       71*   82-06-10 Lackey: Changed RMDB_DEL_OP to RMDB_DEL_IDX_OP
       72*
       73*   82-06-23 Davids: changed all references of force to brief to
       74*                    reflect the control arg's name change.
       75*
       76*
       77*   82-07-01  Roger Lackey : Modified the calls to mu_db_inconsistent to use
       78*   mdbm_util_$inconsistent_* for binding.  
       79*
       80*   82-09-15  D. Woodka : Modified for DMS conversion. Replaced 
       81*   call to iox_$attach with a call to rmdb_relmgr_entries.open,
       82*   and calls to iox_$control (order delete_key) with a call to
       83*   rmdb_relmgr_entries.delete_index.
       84*
       85*   83-01-10 Davids: Modified to correct the sense of an if statement
       86*   that was causing relmgr_entries.delete_index not to be called.
       87*   Also added code dealing with transactions.
       88*
       89*   83-01-17 Davids: Code to report an error with finishing a transaction
       90*   and to correctly handle errors occuring in the clean_up procedure.
       91*
       92*   83-01-20 Davids: Removed declared but unused variables.
       93*
       94*   83-02-14 Davids: modified to use the new db_type_flags in the db_model
       95*   structure instead of the old numeric db_type.
       96*
       97*   83-05-24 Davids: Added code to set the version of the saved resultant to
       98*   RESTRUCT so that the saved resultant will not be used for an opening.
       99**/
      100 
      101 /* PARAMETERS */
      102 
      103 	dcl     rdi_db_abs_path	 char (168);	/* (input) absolute path to the database directory */
      104 	dcl     rdi_db_model_ptr	 ptr;		/* (input) pointer to the database model */
      105 	dcl     rdi_rel_name	 char (*);	/* (input) name of the relation to be restructured */
      106 	dcl     rdi_attr_name	 char (*);	/* (input) name of the attribute to be un-indexed */
      107 	dcl     rdi_brief_flag	 bit (1);		/* (input) true ==> caller used brief ctl_arg */
      108 	dcl     rdi_error_message	 char (500);	/* (output) text of message in the event of an error */
      109 	dcl     rdi_code		 fixed bin (35);	/* (output) standard error code */
      110 
      111 /* AUTOMATIC */
      112 
      113 	dcl     rdi_attr_ptr	 ptr;		/* pointer to attr_info structure */
      114 	dcl     rdi_file_model_ptr	 ptr;		/* pointer to the file model that contains the relation */
      115 	dcl     rdi_index_id	 bit (36) aligned;	/* actual bits that identify which attr an index refers to */
      116 	dcl     rdi_nsecs		 fixed bin;	/* number of secondary indices
      117*						   in the relation being restructured */
      118 	dcl     rdi_number_of_varying_attrs fixed bin;	/* number of varying attrs in the relation being indexed */
      119 	dcl     rdi_quit_signaled	 bit (1);		/* true if the break key was hit */
      120 	dcl     rdi_rel_id		 bit (36) aligned;	/* bits that identify the relation */
      121 	dcl     rdi_rel_opening_id	 bit (36) aligned;	/* relation opening identifier */
      122 	dcl     rdi_rel_ptr		 ptr;		/* pointer to the rel_info structure */
      123 	dcl     rdi_rmdb_ctl_ptr	 ptr;
      124 	dcl     01 rdi_seek_head_info,		/* used in iox_$seek_head */
      125 		02 relation_type	 fixed bin init (0),/* equality */
      126 		02 n		 fixed bin init (3),/* 3 characters */
      127 		02 search_key	 char (256) init ("");
      128 
      129 /* BUILTINS */
      130 
      131 	dcl     addr		 builtin;
      132 	dcl     fixed		 builtin;
      133 	dcl     length		 builtin;
      134 	dcl     null		 builtin;
      135 	dcl     pointer		 builtin;
      136 	dcl     rel		 builtin;
      137 	dcl     rtrim		 builtin;
      138 
      139 /* BASED */
      140 
      141 	dcl     rdi_based_char8	 char (8) based;	/* overlay on the saved_res_version value */
      142 
      143 /* CONDITIONS */
      144 
      145 	dcl     any_other		 condition;
      146 	dcl     cleanup		 condition;
      147 	dcl     quit		 condition;
      148 
      149 /* ENTRIES */
      150 
      151 	dcl     hcs_$initiate	 entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
      152 	dcl     ioa_$rs		 entry () options (variable);
      153 	dcl     mdbm_util_$inconsistent_reset entry (ptr);
      154 	dcl     mdbm_util_$inconsistent_set entry (ptr, char (*), char (*), char (*));
      155 	dcl     rmdb_add_rmdb_history	 entry (ptr, fixed bin, char (32), fixed bin, char (32), char (500), fixed bin (35));
      156 
      157 /* EXTERNAL STATIC */
      158 
      159 	dcl     dm_error_$collection_not_found fixed bin(35) ext static;
      160 	dcl     error_table_$action_not_performed fixed bin (35) ext static;
      161 	dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
      162 
      163 /* INCLUDES */
      164 
  1     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  1     6*     modified to save space occupied by model
  1     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  1     8*     to add mdbm_secured bit in db_model
  1     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  1    10*     collapsed the following into an unused_offset array:
  1    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  1    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  1    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  1    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  1    15*       unused_1
  1    16*     Also changed the name of unused_2 to restructuring_history_offset
  1    17*     and changed the comment on the changer structure to indicate
  1    18*     that it will contain on database creation information.
  1    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  1    20*     used one of the unused_offsets to point to a message which indicates
  1    21*     why the db is inconsistent. The offset will be null when the db is created
  1    22*     and set the first time the message is used. this is so it will be
  1    23*     consistent with existing data bases. Also added the message structure.
  1    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  1    25*     added the undo_request element to the message structure
  1    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  1    27*     changed unused_offset (12) to last_restructruring_history_offset and
  1    28*     changed restructuring_history_offset to first_restructuring_history_offset
  1    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  1    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  1    31*     1 => vfile database and 2 => page_file database. Up to this point all
  1    32*     database types were equal to 1.
  1    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  1    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  1    35*     flags. This will allow information about transactions and dm_file
  1    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  1    37*     change is compatable with all datamodels created by the released version
  1    38*     of mrds.
  1    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  1    40*     added the rollback_on flag to the db_type_flags since it appears that you
  1    41*     can have a dmfile database that requires transactions but does not have any
  1    42*     journalizing. Also switched the order of the transactions_needed and
  1    43*     concurrency_on flags - this makes the change compatable with existing
  1    44*     dmfile databases except when displaying the model since concurrency_on and
  1    45*     rollback_on will be off in the model even though the dmfile relations had
  1    46*     them on during creation.
  1    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  1    48*      Removed ctl_file_path_ptr.
  1    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  1    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  1    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  1    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  1    53*      in the flag word for rmdb copying.
  1    54*                                                   END HISTORY COMMENTS */
  1    55 
  1    56 
  1    57 /* this include file contains the structures that go into the make up
  1    58*   of the "db_model" segment in the model for the database.
  1    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  1    60*
  1    61*   the db_model structure goes at the base of the segment, and contains items unique to
  1    62*   the whole databse. in addition, it has an area of size to fill the
  1    63*   rest of a segment, that holds the lists of files and domains in the database.
  1    64*   these lists are singly forward linked lists. all "pointers" in the database model
  1    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  1    66*   since actual pointers are process dependent on segment number.
  1    67*   the remaining structures are first a path_entry one to save pathnames in,
  1    68*   and the stack_item and constent structures, used to save a boolean
  1    69*   expression in polish form, with the stack represented by a linked list.
  1    70*   the final structure is one for identifying the status of version information */
  1    71 
  1    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  1    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  1    74 	     2 db_type_flags      unal,
  1    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  1    76 	       3 unused	      (13) bit (1) unal,
  1    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  1    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  1    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  1    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  1    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  1    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  1    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  1    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  1    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  1    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  1    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  1    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  1    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  1    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  1    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  1    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  1    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  1    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  1    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  1    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  1    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  1    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  1    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  1   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  1   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  1   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  1   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  1   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  1   105 
  1   106      dcl	   dbm_ptr	      ptr;
  1   107 
  1   108 /* the files in the database each have a file_info containing
  1   109*   their name, the file_model for each file is found by initiating the
  1   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  1   111*   the file_info list is a singly linked list in definition order */
  1   112 
  1   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  1   114 	     2 file_name	      char (30),		/* name of file */
  1   115 	     2 file_id	      bit (36),		/* id number of file */
  1   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  1   117 	     2 unused	      unal bit (18);	/* for future expansion */
  1   118 
  1   119      dcl	   fi_ptr		      ptr;
  1   120 
  1   121 /* each domain used in the database will have a domain info saved in the db_model
  1   122*   segment. it describes the domain of the given name, and it's options.
  1   123*   the domain_info's form a singly linked list in definition order */
  1   124 
  1   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  1   126 	     2 name	      char (32),		/* name of domain */
  1   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  1   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  1   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  1   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  1   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  1   132 	     2 reserved	      bit (31) unal,
  1   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  1   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  1   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  1   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  1   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  1   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  1   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  1   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  1   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  1   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  1   143 	     2 str_err_path_ptr   unal bit (18),
  1   144 	     2 str_after_path_ptr unal bit (18),
  1   145 	     2 get_before_path_ptr unal bit (18),
  1   146 	     2 get_err_path_ptr   unal bit (18),
  1   147 	     2 get_after_path_ptr unal bit (18),
  1   148 	     2 mod_before_path_ptr unal bit (18),
  1   149 	     2 mod_err_path_ptr   unal bit (18),
  1   150 	     2 mod_after_path_ptr unal bit (18),
  1   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  1   152 	     2 unused_2	      unal bit (18),
  1   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  1   154 
  1   155      dcl	   di_ptr		      ptr;
  1   156 
  1   157 /* information necessary for attributes that are not used in any relation */
  1   158 
  1   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  1   160 	     2 name char (32),			/* name of attribute */
  1   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  1   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  1   163 	     2 unused (2) bit (18) unal;
  1   164 
  1   165      dcl     ua_ptr ptr;
  1   166 
  1   167 
  1   168 /* space saving pathname$entryname structure, to be allocated
  1   169*   only when a path$entry has to be saved, else only a bit(18)
  1   170*   offset takes up space in the main model structure */
  1   171 
  1   172      declare 1 path_entry	      based (path_entry_ptr),
  1   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  1   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  1   175 	     2 reserved	      unal bit (36);	/* for future use */
  1   176 
  1   177      declare path_entry_ptr	      ptr;
  1   178 
  1   179 
  1   180 
  1   181 
  1   182 
  1   183 /* declarations for model of postfix stack holding the check option boolean expression
  1   184*   the following encoding values indicate the corresponding type of stack element
  1   185*
  1   186*   1  =
  1   187*   2  ^=
  1   188*   3  >
  1   189*   4  <
  1   190*   5  >=
  1   191*   6  <=
  1   192*
  1   193*   10  and
  1   194*   20  or
  1   195*   30  not
  1   196*
  1   197*   40  - (minus)
  1   198*
  1   199*   50  domain variable(same name as domain)
  1   200*
  1   201*   60  constant(number, bit string, or character string)
  1   202*
  1   203**/
  1   204 
  1   205 
  1   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  1   207 	     2 next	      bit (18),		/* link to next in list */
  1   208 	     2 type	      fixed binary,		/* code for this element type */
  1   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  1   210*						   if this is a constant element type */
  1   211 
  1   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  1   213 
  1   214 
  1   215 
  1   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  1   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  1   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  1   219 
  1   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  1   221 
  1   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  1   223 
  1   224 /* version structure, giving status of source for CMDB/RMDB,
  1   225*   status of model, and status of resultant */
  1   226 
  1   227 /* version number is in form MM.N.Y
  1   228*   where MM is the major version number, N is the minor version alteration,
  1   229*   and Y is the lastest modification to that alteration,
  1   230*   where M and N represent numbers 0-9, and Y is a letter */
  1   231 
  1   232      declare 1 version_status	      unal based (version_status_ptr),
  1   233 	     2 cmdb_rmdb,
  1   234 	       3 major	      fixed bin,
  1   235 	       3 minor	      fixed bin,
  1   236 	       3 modification     char (4),
  1   237 	     2 model,
  1   238 	       3 major	      fixed bin,
  1   239 	       3 minor	      fixed bin,
  1   240 	       3 modification     char (4),
  1   241 	     2 resultant,
  1   242 	       3 major	      fixed bin,
  1   243 	       3 minor	      fixed bin,
  1   244 	       3 modification     char (4);
  1   245 
  1   246      declare version_status_ptr     ptr;
  1   247 
  1   248 
  1   249 /* maintains information only about the db creation */
  1   250 
  1   251      declare 1 changer	      unal based (changer_ptr),
  1   252 	     2 id		      char (32),
  1   253 	     2 time	      fixed bin (71),
  1   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  1   255 
  1   256      declare changer_ptr	      ptr;
  1   257 
  1   258 
  1   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  1   260 	     02 len	      fixed bin,		/* length of the message */
  1   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  1   262 	     02 name	      char (32),		/* name of thing that set the message */
  1   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  1   264*                                                               that caused the database to become inconsistent */
  1   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  1   266 
  1   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  1   268 
  1   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  1   270 
  1   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  1   272 
  1   273 
      165 
      166 
  2     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  2     6*     modified to save space occupied by model
  2     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  2     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  2     9*     the number of secondary indices in the relation - it was always zero.
  2    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  2    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  2    12*     DMS conversion.
  2    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  2    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  2    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  2    16*     for relation manager changes.
  2    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  2    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  2    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  2    20*     <rel> files are good (for rmdb)
  2    21*                                                   END HISTORY COMMENTS */
  2    22 
  2    23 
  2    24 /* each file in the database will have a model segment with the name
  2    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  2    26*   the file_model structure is allocated at the base of the segment for a given file.
  2    27*   it contains an area with which all other structures in this include file are allocated.
  2    28*   these structures contain the information about which relations, foreign keys,
  2    29*   and attributes are members of this file. all lists are singly linked lists in
  2    30*   definition order. pointers to these structures are obtained by using the "pointer"
  2    31*   builtin function with arguments of the segment base pointer, and the
  2    32*   offset (bit (18)) relative to that pointer that is actually stored in
  2    33*   the file model itself. this is because pointer segment numbers are
  2    34*   per process dependent. the major lists pointed to by the file_model structure
  2    35*   are the list of relations in this file(each with a contained attribute list),
  2    36*   and the list of foreign keys whose parent relation resides in this file
  2    37*   (along with a participating attribute sublist, and the child relation list,
  2    38*   if they are also in this file) */
  2    39 
  2    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  2    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  2    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  2    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  2    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  2    45     2 reserved bit (32) unal,				/* reserved for future flags */
  2    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  2    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  2    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  2    49     2 pad_1 fixed bin (35),				/* for future use */
  2    50     2 pad_2 fixed bin (35),
  2    51     2 ratd_len fixed bin (21),			/* length of above */
  2    52     2 mratd_len fixed bin (21),			/* length of above */
  2    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  2    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  2    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  2    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  2    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  2    58     2 block_size unal fixed bin,			/* no. pages in block */
  2    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  2    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  2    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  2    62     2 num_rels unal fixed bin,			/* number of relations in file */
  2    63     2 num_links unal fixed bin,			/* number of links in file */
  2    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  2    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  2    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  2    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  2    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  2    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  2    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  2    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  2    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  2    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  2    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  2    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  2    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  2    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  2    78     2 open_eu_err_path_ptr unal bit (18),
  2    79     2 open_eu_after_path_ptr unal bit (18),
  2    80     2 open_er_before_path_ptr unal bit (18),
  2    81     2 open_er_err_path_ptr unal bit (18),
  2    82     2 open_er_after_path_ptr unal bit (18),
  2    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  2    84     2 open_neu_err_path_ptr unal bit (18),
  2    85     2 open_neu_after_path_ptr unal bit (18),
  2    86     2 open_ner_before_path_ptr unal bit (18),
  2    87     2 open_ner_err_path_ptr unal bit (18),
  2    88     2 open_ner_after_path_ptr unal bit (18),
  2    89     2 open_pu_before_path_ptr unal bit (18),
  2    90     2 open_pu_err_path_ptr unal bit (18),
  2    91     2 open_pu_after_path_ptr unal bit (18),
  2    92     2 open_pr_before_path_ptr unal bit (18),
  2    93     2 open_pr_err_path_ptr unal bit (18),
  2    94     2 open_pr_after_path_ptr unal bit (18),
  2    95     2 open_cu_before_path_ptr unal bit (18),
  2    96     2 open_cu_err_path_ptr unal bit (18),
  2    97     2 open_cu_after_path_ptr unal bit (18),
  2    98     2 open_cr_before_path_ptr unal bit (18),
  2    99     2 open_cr_err_path_ptr unal bit (18),
  2   100     2 open_cr_after_path_ptr unal bit (18),
  2   101     2 close_before_path_ptr unal bit (18),
  2   102     2 close_err_path_ptr unal bit (18),
  2   103     2 close_after_path_ptr unal bit (18),
  2   104     2 unused_1 unal bit (18),				/* for future expansion */
  2   105     2 unused_2 unal bit (18),
  2   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  2   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  2   108 dcl  fm_ptr ptr;
  2   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  2   110 dcl  atd_ptr ptr;
  2   111 dcl  atd_len fixed bin;
  2   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  2   113     2 ncomponents fixed bin,
  2   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  2   115 dcl  cna_ptr ptr;
  2   116 dcl  ncomp_init fixed bin;
  2   117 
  2   118 /* a rel_info structure contains information describing a relation.
  2   119*   a relation may only occur in one file, thus there is one rel_info
  2   120*   per relation per database, each stored in the file_model area for
  2   121*   the file that contains it. the list of rel_info's in this file
  2   122*   form a singly linked list in definition order.
  2   123*   the rel_info itself points to a list of the attributes it contains,
  2   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  2   125 
  2   126 dcl 1 rel_info aligned based (ri_ptr),
  2   127     2 name char (32),				/* relation name */
  2   128     2 id  bit (36) aligned,				/* relation id number */
  2   129     2 hashed bit (1) unal,				/* on if hashed */
  2   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  2   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  2   132     2 system bit (1) unal,				/* on if dont care how stored */
  2   133     2 indexed bit (1) unal,				/* on if secondary index */
  2   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  2   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  2   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  2   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  2   138     2 reserved bit (27) unal,				/* for future flags */
  2   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  2   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  2   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  2   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  2   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  2   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  2   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  2   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  2   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  2   148     2 unused_3 unal fixed bin,			/* element that was never used */
  2   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  2   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  2   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  2   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  2   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  2   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  2   155     2 attr_ptr unal bit (18),				/* to attr. info */
  2   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  2   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  2   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  2   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  2   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  2   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  2   162     2 link_err_path_ptr unal bit (18),
  2   163     2 link_after_path_ptr unal bit (18),
  2   164     2 unlk_before_path_ptr unal bit (18),
  2   165     2 unlk_err_path_ptr unal bit (18),
  2   166     2 unlk_after_path_ptr unal bit (18),
  2   167     2 str_before_path_ptr unal bit (18),
  2   168     2 str_err_path_ptr unal bit (18),
  2   169     2 str_after_path_ptr unal bit (18),
  2   170     2 del_before_path_ptr unal bit (18),
  2   171     2 del_err_path_ptr unal bit (18),
  2   172     2 del_after_path_ptr unal bit (18),
  2   173     2 mod_before_path_ptr unal bit (18),
  2   174     2 mod_err_path_ptr unal bit (18),
  2   175     2 mod_after_path_ptr unal bit (18),
  2   176     2 find_before_path_ptr unal bit (18),
  2   177     2 find_err_path_ptr unal bit (18),
  2   178     2 find_after_path_ptr unal bit (18),
  2   179     2 retr_before_path_ptr unal bit (18),
  2   180     2 retr_err_path_ptr unal bit (18),
  2   181     2 retr_after_path_ptr unal bit (18),
  2   182     2 unused_1 unal bit (18),				/* for future expansion */
  2   183     2 unused_2 unal bit (18),
  2   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  2   185 dcl  ri_ptr ptr;
  2   186 
  2   187 /* a attr_info structure contains information about an attribute in a given relation.
  2   188*   since attributes may appear in more than one relation, each occurence of an attribute
  2   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  2   190*   the list is singly linked in definition order. the attr_info describes
  2   191*   the data it represents, and how that data is used during a database search. */
  2   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  2   193     2 name char (32),				/* name of attribute */
  2   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  2   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  2   196     2 link_attr bit (1) unal,				/* on if participates in link */
  2   197     2 reserved bit (33) unal,
  2   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  2   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  2   200     2 key_order unal fixed bin,			/* relative posit. in key */
  2   201     2 bit_offset fixed bin (35),			/* position in tuple */
  2   202     2 bit_length fixed bin (35),			/* length if fixed */
  2   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  2   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  2   205     2 domain_ptr unal bit (18),			/* to domain info */
  2   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  2   207     2 fwd_thread unal bit (18),			/* to next in list */
  2   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  2   209 dcl  ai_ptr ptr;
  2   210 
  2   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  2   212*   each time a foreign key definition indicates a relation as it's parent,
  2   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  2   214*   a relation can be parent and/or child in any number of foreign keys.
  2   215*   the parent_link_info structure describes the foreign key, and also points
  2   216*   to a list of the attributes that participate in this foreign key.
  2   217*   (this could be from 1 up to all attributes in the relation)
  2   218*   the attr_list structures are in a singly linked list in definition order
  2   219*   for this purpose. also pointed to is a list of child_link_info's
  2   220*   that describe the child relations in this foreign key. since foreign keys
  2   221*   may span files, not all related child_link_info's have to be in this file's
  2   222*   model area. */
  2   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  2   224     2 name char (32),				/* name of link */
  2   225     2 singular bit (1) unal,				/* on if system owned link */
  2   226     2 temp bit (1) unal,				/* on if temp. order */
  2   227     2 first bit (1) unal,				/* insertion indicators */
  2   228     2 last bit (1) unal,
  2   229     2 next bit (1) unal,
  2   230     2 prior bit (1) unal,
  2   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  2   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  2   233     2 dup_first bit (1) unal,				/* duplicates first */
  2   234     2 dup_last bit (1) unal,				/* duplicates last */
  2   235     2 indexed bit (1) unal,				/* locate parent via index */
  2   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  2   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  2   238     2 thread_27 bit (1) unal,
  2   239     2 thread_18 bit (1) unal,
  2   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  2   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  2   242     2 reserved bit (19) unal,				/* reserved for future flags */
  2   243     2 index_id aligned bit (8),			/* id of index if indexed */
  2   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  2   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  2   246     2 n_children unal fixed bin,			/* no. children in link */
  2   247     2 child_fn char (30),				/* file name for first child in list */
  2   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  2   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  2   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  2   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  2   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  2   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  2   254     2 sort_err_path_ptr unal bit (18),
  2   255     2 sort_after_path_ptr unal bit (18),
  2   256     2 srch_before_path_ptr unal bit (18),
  2   257     2 srch_err_path_ptr unal bit (18),
  2   258     2 srch_after_path_ptr unal bit (18),
  2   259     2 link_before_path_ptr unal bit (18),
  2   260     2 link_err_path_ptr unal bit (18),
  2   261     2 link_after_path_ptr unal bit (18),
  2   262     2 unlk_before_path_ptr unal bit (18),
  2   263     2 unlk_err_path_ptr unal bit (18),
  2   264     2 unlk_after_path_ptr unal bit (18),
  2   265     2 unused_1 unal bit (18),				/* for future expansion */
  2   266     2 unused_2 unal bit (18),
  2   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  2   268 dcl  pli_ptr ptr;
  2   269 
  2   270 /* a child_link_info structure is the counter part of a parent_link_info
  2   271*   for foreign key child relations. each time a relation is defined to be
  2   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  2   273*   this list is singly linked in foreign key definition order.
  2   274*   the child_link_info points to a list of participating attributes from the
  2   275*   child relation by means of a singly linked list of attr_list structures
  2   276*   in definition order. the number of attributes in the parent attr_list
  2   277*   and the child attr_list lists are the same with corresponding attr_list
  2   278*   attributes having the same domain. all child_link_infos in this file
  2   279*   are on a seperately linked list. this may not include all
  2   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  2   281*   since foreign keys may span files, and the child_link_info will
  2   282*   reside in the file containing it's associated relation_info. */
  2   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  2   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  2   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  2   286     2 fixed bit (1) unal,				/* on if membership fixed */
  2   287     2 optional bit (1) unal,				/* on if membership optional */
  2   288     2 auto bit (1) unal,				/* on if insertion automatic */
  2   289     2 manual bit (1) unal,				/* on if insertion manual */
  2   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  2   291     2 range_sel bit (1) unal,				/* on if range type selection */
  2   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  2   293     2 key_dup_last bit (1) unal,
  2   294     2 key_null bit (1) unal,				/* on if null allowed */
  2   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  2   296     2 sel_current bit (1) unal,
  2   297     2 sel_key bit (1) unal,
  2   298     2 sel_proc bit (1) unal,
  2   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  2   300     2 reserved bit (21) unal,
  2   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  2   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  2   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  2   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  2   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  2   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  2   307     2 parent_fn char (30),				/* file name for parent info */
  2   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  2   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  2   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  2   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  2   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  2   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  2   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  2   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  2   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  2   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  2   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  2   319     2 link_err_path_ptr unal bit (18),
  2   320     2 link_after_path_ptr unal bit (18),
  2   321     2 unlk_before_path_ptr unal bit (18),
  2   322     2 unlk_err_path_ptr unal bit (18),
  2   323     2 unlk_after_path_ptr unal bit (18),
  2   324     2 srch_before_path_ptr unal bit (18),
  2   325     2 srch_err_path_ptr unal bit (18),
  2   326     2 srch_after_path_ptr unal bit (18),
  2   327     2 unused_1 unal bit (18),				/* for future expansion */
  2   328     2 unused_2 unal bit (18) ;
  2   329 dcl  cli_ptr ptr;
  2   330 
  2   331 /* the attr_list structure is associated with the parent_link_info
  2   332*   and child_link_info structures to represent by means of a singly linked list
  2   333*   the participating attributes from relations in a foreign key.
  2   334*   the parent_link_info has a list for the parent relation,
  2   335*   and the child_link_info has a list for the child relation.
  2   336*   the participating attributes are a subset(not necessary proper) of
  2   337*   those attributes contained in a relation definition.
  2   338*   there are equal numbers of attr_list structures in the parent and
  2   339*   child lists of the same foreign key. the corresponding attributes in these
  2   340*   lists must have the same domain. */
  2   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  2   342     2 attr_fn char (30),				/* file name for attr. */
  2   343     2 attr_ptr unal bit (18),				/* to attr info block */
  2   344     2 fwd_thread unal bit (18);			/* to next in list */
  2   345 dcl  al_ptr ptr;
  2   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  2   347     2 ascend bit (1) unal,				/* ascending order */
  2   348     2 descend bit (1) unal,				/* descending order */
  2   349     2 reserved bit (34) unal,
  2   350     2 attr_ptr unal bit (18),				/* to attr info */
  2   351     2 fwd_thread unal bit (18);			/* to next in list */
  2   352 dcl  sk_ptr ptr;
  2   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  2   354     2 attr_ptr unal bit (18),				/* to attr info */
  2   355     2 fwd_thread unal bit (18);			/* to next in list */
  2   356 dcl  dp_ptr ptr;
  2   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  2   358     2 link_fn char (30),				/* file name for thru link */
  2   359     2 link_ptr unal bit (18),				/* to parent link info */
  2   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  2   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  2   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  2   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  2   364     2 fwd_thread unal bit (18);			/* to next in chain */
  2   365 dcl  sc_ptr ptr;
  2   366 
  2   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  2   368 
  2   369 
      167 
      168 
  3     1 /* BEGIN INCLUDE FILE rmdb_history_entry.incl.pl1 -- nsd, 82-04-09 */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(75-01-01,WhoKnows), approve(), audit(), install():
  3     7*     Written.
  3     8*  2) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
  3     9*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  3    10*     Added RMDB_ADD_(ATTR DMN)_OP, RMDB_RN_(ATTR DMN REL)_OP.
  3    11*                                                   END HISTORY COMMENTS */
  3    12 
  3    13 
  3    14 /*
  3    15*   This include file contains the rmdb_history_entry structure which
  3    16*   is  used for maintaining a history of the databases restructuring
  3    17*   events. It also contains a set of constants used in  loading  the
  3    18*   structure.
  3    19*
  3    20*   The restructuring history is applied against the  database  as  a
  3    21*   whole  instead of against each structure in the db_model and file
  3    22*   models which was the approach originally  implemented  but  never
  3    23*   really  used  (except  to  record the database creation). This is
  3    24*   because 1 database restructuring event, i.e. adding a  new  index
  3    25*   to a relation will change several of the structures in the model.
  3    26*
  3    27*   For a detailed explaination of the use of this structure and  the
  3    28*   constants see the rmdb_add_rmdb_event module.
  3    29**/
  3    30 
  3    31 dcl 01 rmdb_history_entry aligned based (rmdb_history_entry_ptr),
  3    32     02 user_id char (32),				/* person_id.project_id.tag */
  3    33     02 date_time_restructured fixed bin (71),
  3    34     02 type_of_object_restructured fixed bin,		/* taken from constants below */
  3    35     02 object_name char (32),
  3    36     02 operation fixed bin,				/* taken from constants below */
  3    37     02 secondary_object_name char (32),			/* i.e. name of attr just indexed in a restructured relation */
  3    38     02 offset_to_next_entry bit (18) unal,
  3    39     02 offset_to_previous_entry bit (18) unal;
  3    40 	
  3    41 
  3    42 dcl  rmdb_history_entry_ptr ptr;
  3    43 
  3    44 
  3    45 dcl  RMDB_DOMAIN_TYPE init (1) fixed bin internal static options (constant);
  3    46 dcl  RMDB_ATTR_TYPE init (2) fixed bin internal static options (constant);
  3    47 dcl  RMDB_REL_TYPE init (3) fixed bin internal static options (constant);
  3    48 
  3    49 
  3    50 dcl  RMDB_ADD_REL_OP init (1) fixed bin internal static options (constant);
  3    51 dcl  RMDB_DEL_REL_OP init (2) fixed bin internal static options (constant);
  3    52 dcl  RMDB_ADD_IDX_OP init (3) fixed bin internal static options (constant);
  3    53 dcl  RMDB_DEL_IDX_OP init (4) fixed bin internal static options (constant);
  3    54 dcl  RMDB_ADD_ATTR_OP init (5) fixed bin int static options (constant);
  3    55 dcl  RMDB_DEL_ATTR_OP init (6) fixed bin int static options (constant);
  3    56 dcl  RMDB_ADD_DMN_OP init (7) fixed bin int static options (constant);
  3    57 dcl  RMDB_DEL_DMN_OP init (8) fixed bin int static options (constant);
  3    58 dcl  RMDB_RN_ATTR_OP init (9) fixed bin int static options (constant);
  3    59 dcl  RMDB_RN_DMN_OP init (10) fixed bin int static options (constant);
  3    60 dcl  RMDB_RN_REL_OP init (11) fixed bin int static options (constant);
  3    61 
  3    62 /* END INCLUDE FILE rmdb_history_entry.incl.pl1 */
      169 
      170 
  4     1 /* BEGIN - mrds_rmdb_ctl.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(82-03-26,Davids), approve(), audit(), install():
  4     7*     created
  4     8*  2) change(82-05-26,Davids), approve(), audit(), install():
  4     9*     added db_model_ptr
  4    10*  3) change(82-06-09,Harvey), approve(), audit(), install():
  4    11*     deleted ssu_ routines ptr storage
  4    12*  4) change(82-08-20,Davids), approve(), audit(), install():
  4    13*     added the relmgr like reference and included the rmdb_relmgr_entries
  4    14*     include file
  4    15*  5) change(83-05-24,Davids), approve(), audit(), install():
  4    16*     added the saved_res_version_ptr element
  4    17*  6) change(84-10-23,Benjamin), approve(), audit(), install():
  4    18*     added flags (just database_readied_by_rmdb for now).
  4    19*  7) change(85-11-08,Spitzer), approve(85-11-08,MCR7311),
  4    20*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  4    21*     added crossref_file_info.
  4    22*                                                   END HISTORY COMMENTS */
  4    23 
  4    24 
  4    25 dcl 01 rmdb_ctl based (rmdb_ctl_ptr),
  4    26     02 version fixed bin,
  4    27     02 rmdb_version char (16) varying,
  4    28     02 absolute_db_path char (168),
  4    29     02 temp_dir_path char (168),
  4    30     02 work_area_ptr ptr,
  4    31     02 db_model_ptr ptr,
  4    32     02 saved_res_version_ptr ptr,
  4    33     02 crossref_file_info,
  4    34        03 iocb_ptr ptr,
  4    35        03 name char (32),
  4    36     02 relmgr_entries like rmdb_relmgr_entries,
  4    37     02 flags,
  4    38        03 database_readied_by_rmdb bit (1) unal,
  4    39        03 unused bit (35) unal;
  4    40     	
  4    41 dcl  RMDB_CTL_VERSION_1 fixed bin init (1) internal static options (constant);
  4    42 
  4    43 dcl  rmdb_ctl_ptr ptr;
  4    44 
  4    45 
  5     1 /*  START OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(82-08-20,Davids), approve(), audit(), install():
  5     6*     written
  5     7*  2) change(86-01-28,Spitzer), approve(86-01-28,MCR7311),
  5     8*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  5     9*     add get_tuples_by_spec, put_tuple, put_tuples, create_cursor entry points.
  5    10*  3) change(86-08-21,Blair), approve(86-08-21,MCR7311),
  5    11*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  5    12*     Back out the entries get_tuples_by_spec and put_tuples since they aren't
  5    13*     sufficiently well tested to be reliable.  Replace with get_tuple_id and
  5    14*     get_tuple_by_id.
  5    15*                                                   END HISTORY COMMENTS */
  5    16 
  5    17 
  5    18 dcl 01 rmdb_relmgr_entries based (rmdb_relmgr_entries_ptr),
  5    19      02 create_relation entry (char (*), char (*), ptr, ptr, bit (36) aligned,
  5    20 	bit (36) aligned, fixed bin (35)),
  5    21      02 delete_relation entry (char (*), char (*), fixed bin (35)),
  5    22      02 open entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  5    23      02 close entry (bit (36) aligned, fixed bin (35)),
  5    24      02 create_index entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17),
  5    25 	bit (36) aligned, fixed bin (35)),
  5    26      02 delete_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35)),
  5    27      02 put_tuple entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  5    28      02 get_tuple_id entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  5    29      02 get_tuple_by_id entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  5    30      02 create_cursor entry (bit (36) aligned, ptr, ptr, fixed bin (35));
  5    31 
  5    32 dcl rmdb_relmgr_entries_ptr ptr;
  5    33 
  5    34 /*  END OF:	rmdb_relmgr_entries.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4    46 
  4    47 
  4    48 
  4    49 /* END - mrds_rmdb_ctl.incl.pl1 */
      171 
      172 
      173 
      174 /*
      175*   Initialize variables which may be referenced before they are  set
      176*   somewhere else, i.e. they are referenced in the cleanup handler
      177**/
      178 
      179 
      180 	rdi_code = 0;
      181 	rdi_error_message = "";
      182 	rdi_quit_signaled = "0"b;
      183 	rdi_rel_opening_id = "0"b;
      184 	rmdb_ctl_ptr = rdi_rmdb_ctl_ptr;
      185 	mstxn_txn_id = "0"b;
      186 	mstxn_transactions_needed = "0"b;
      187 
      188 /*
      189*   If the database needs transactions and one is already in progress stop right now.
      190**/
      191 	if rdi_db_model_ptr -> db_model.db_type_flags.transactions_needed
      192 	then do;
      193 		mstxn_transactions_needed = "1"b;
      194 		call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
      195 		if mstxn_code ^= dm_error_$no_current_transaction
      196 		then do;
      197 			rdi_code = error_table_$action_not_performed;
      198 			rdi_error_message = "Indexes may not be deleted while a transaction is in proggress, " ||
      199 			     "commit or abort the current transaction and try again.";
      200 			goto exit_rmdb_delete_index;
      201 		     end;
      202 	     end;
      203 
      204 /*
      205*   Get pointers to the relation's file model, and extract  from  the
      206*   model the rel_id, index_id, and the rel_ptr and attr_ptr.
      207**/
      208 
      209 	call initiate_models (rdi_db_abs_path, rdi_rel_name, rdi_file_model_ptr);
      210 
      211 	call get_relation_data (rdi_file_model_ptr, rdi_rel_ptr, rdi_rel_id, rdi_number_of_varying_attrs);
      212 
      213 	call get_attribute_data (rdi_file_model_ptr, rdi_rel_ptr, rdi_rel_name, rdi_attr_name,
      214 	     rdi_attr_ptr, rdi_index_id, rdi_nsecs);
      215 
      216 
      217 
      218 
      219 	on cleanup call mstxn_cleanup;
      220 
      221 	on any_other call mstxn_any_other;
      222 
  6     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  6     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  6     8*     This entry is being made to cover the changes made on 85-05-06 and
  6     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
  6    10*     was removed because not all modules need the dbcb, and the
  6    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
  6    12*     list #136).
  6    13*                                                   END HISTORY COMMENTS */
  6    14 
  6    15 
  6    16 /*
  6    17*                    BEGIN_DESCRIPTION
  6    18*
  6    19*   A generalized routine accessed by all MRDS modules (with the temporary 
  6    20*   (perhaps) exception of restructuring modules) that must start transactions 
  6    21*   if none are present.  The intent is that it be executed as inline code.
  6    22*   The variable mstxn_transactions_needed must be set prior to entering this
  6    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
  6    24*   will suffice.  Included are procedures called mstxn_cleanup and 
  6    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
  6    26*   handlers in the program.  Such handlers should be established just prior to
  6    27*   the inclusion of this code and disabled just following the inclusion of
  6    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
  6    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
  6    30*   include file does the same, because this code might not have been entered 
  6    31*   yet when the handler is invoked.  Directly following this include file the 
  6    32*   contents of mstxn_code should be examined.  If zero, then either the 
  6    33*   transaction was successfully started or no transaction was required.  If the
  6    34*   mrds_finish_transaction code is referenced in general error handling 
  6    35*   situations where the possibility exists that the code in this include file 
  6    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
  6    37*   the beginning of the program.
  6    38*
  6    39*                    END_DESCRIPTION
  6    40*
  6    41*   Written 82-09-28 by Paul W. Benjamin.
  6    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
  6    43*   Modified 83-01-07 by PWB to not reference the dbcb.
  6    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
  6    45*		 any_other handler in situations where the module did
  6    46*		 not start the transaction.
  6    47*   Modified 83-05-05 by PWB to abandon when abort fails.
  6    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
  6    49*		 and abort.
  6    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
  6    51*		 transaction_bj_full conditions.
  6    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
  6    53*		 and to handle transaction_lock_timeout_.
  6    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
  6    55*                     dbcb.user_started_transaction flag.
  6    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
  6    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
  6    58*                     directory >ldd>include and >exl>mrd>i
  6    59**/
  6    60 
  6    61 dcl continue_to_signal_ entry (fixed bin(35));
  6    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
  6    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
  6    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
  6    65 dcl mstxn_code fixed bin (35);
  6    66 dcl mstxn_retries fixed;
  6    67 dcl mstxn_temp_code fixed bin (35);
  6    68 dcl mstxn_transactions_needed bit (1) aligned;
  6    69 dcl user_started_transaction bit (1) aligned;
  6    70 dcl mstxn_txn_id bit (36) aligned;
  6    71 dcl user_transaction_id bit (36) aligned;
  6    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
  6    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
  6    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
  6    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
  6    76 dcl transaction_manager_$handle_conditions entry ();
  6    77 dcl 1 mstxn_condition_info like condition_info;
  6    78 
  7     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 /* HISTORY:
  7     4*
  7     5*Designed by Matthew C. Pierret, 01/26/82.
  7     6*Coded by Jeffrey D. Ives, 04/30/82.
  7     7*Modified:
  7     8*10/18/82 by Steve Herbst: Names changed.
  7     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  7    10**/
  7    11 
  7    12 dcl (LOWEST_MODE init (1),
  7    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  7    14 
  7    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  7    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  7    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  7    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  7    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  7    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  7    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  7    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  7    23 
  7    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6    79 

  6    80 
  8     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  8     2 
  8     3 /* Structure for find_condition_info_.
  8     4*
  8     5*   Written 1-Mar-79 by M. N. Davidoff.
  8     6**/
  8     7 
  8     8 /* automatic */
  8     9 
  8    10      declare condition_info_ptr     pointer;
  8    11 
  8    12 /* based */
  8    13 
  8    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  8    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  8    16 	     2 version	      fixed binary,		/* Must be 1 */
  8    17 	     2 condition_name     char (32) varying,	/* name of condition */
  8    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  8    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  8    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  8    21 	     2 flags	      unaligned,
  8    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  8    23 	       3 pad1	      bit (35),
  8    24 	     2 pad2	      bit (36),
  8    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  8    26 	     2 pad3	      (4) bit (36);
  8    27 
  8    28 /* internal static */
  8    29 
  8    30      declare condition_info_version_1
  8    31 			      fixed binary internal static options (constant) initial (1);
  8    32 
  8    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
  6    81 
  6    82 
  6    83 	mstxn_code = 0;
  6    84 	mstxn_txn_id = "0"b;
  6    85 	
  6    86 	if ^mstxn_transactions_needed			/* only need transactions */
  6    87 	     then goto mstxn_exit;			/* for protected page files */
  6    88 	mstxn_retries = 0;
  6    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
  6    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
  6    91 	     then do;				
  6    92 	     user_started_transaction = "1"b;
  6    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  6    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
  6    95 	     goto mstxn_exit;	
  6    96 	end;
  6    97 
  6    98 	user_started_transaction = "0"b;
  6    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
  6   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  6   101 
  6   102 mstxn_cleanup:
  6   103 proc;
  6   104 
  6   105 /*  This procedure MUST be called by a cleanup handler. */
  6   106 
  6   107           if mstxn_txn_id ^= "0"b
  6   108           then do;
  6   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
  6   110 	     if mstxn_temp_code ^= 0
  6   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
  6   112 	end;
  6   113 	
  6   114      end mstxn_cleanup;
  6   115 
  6   116 mstxn_any_other:
  6   117 proc;
  6   118 
  6   119 /*  This procedure MUST be called by an any_other handler. */
  6   120 
  6   121           if mstxn_txn_id ^= "0"b
  6   122           then do;
  6   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
  6   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
  6   125 		then do;
  6   126 		mftxn_code = dm_error_$lock_deadlock;
  6   127 		goto mftxn_check_code;
  6   128 	     end;
  6   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
  6   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
  6   131 		then do;
  6   132 		mftxn_code = dm_error_$bj_journal_full;
  6   133 		goto mftxn_check_code;
  6   134 	     end;
  6   135 	     else call transaction_manager_$handle_conditions;
  6   136 	end;
  6   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
  6   138      end mstxn_any_other;
  6   139      
  6   140 mstxn_exit:
  6   141      
  6   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
      223 
      224 
      225 	if mstxn_code ^= 0
      226 	then do;
      227 		rdi_code = mstxn_code;
      228 		rdi_error_message = "Could not start a transaction";
      229 		goto exit_rmdb_delete_index;
      230 	     end;
      231 
      232 /*
      233*   Mark the database inconsistent, delay quit  handling  to  prevent
      234*   the database from being partially marked.
      235**/
      236 
      237 	on quit rdi_quit_signaled = "1"b;
      238 	rmdb_ctl_ptr -> rmdb_ctl.saved_res_version_ptr -> rdi_based_char8 = "RESTRUCT";
      239 	call mdbm_util_$inconsistent_set (rdi_db_model_ptr, "delete_index",
      240 	     "Deleting the index " || rtrim (rdi_attr_name) || " from relation " || rtrim (rdi_rel_name),
      241 	     "delete_index " || rtrim (rdi_rel_name) || " " || rtrim (rdi_attr_name) || " -brief");
      242 	revert quit;
      243 	if rdi_quit_signaled
      244 	then do;
      245 		rdi_quit_signaled = "0"b;
      246 		signal quit;
      247 	     end;
      248 
      249 	on cleanup begin;
      250 
      251 		call mstxn_cleanup;
      252 		call clean_up (""b, "1"b);
      253 	     end;
      254 
      255 /*
      256*   Do the actual index deletion.
      257*
      258*   quit handlers  are  not  needed  since  vfile  assures  that  any
      259*   operation started is completed.
      260**/
      261 
      262 	call rmdb_ctl.relmgr_entries.open (rdi_db_abs_path, rdi_rel_name, rdi_rel_opening_id, rdi_code);
      263 	if rdi_code ^= 0 then do;
      264 		rdi_error_message = "Error while opening the relation";
      265 		call restore_significant_data;
      266 		goto mftxn_exit;
      267 	     end;
      268 
      269 	call rmdb_ctl.relmgr_entries.delete_index (rdi_rel_opening_id, rdi_index_id, rdi_code);
      270 
      271 /* no index but still need to clean up the model */
      272 	if rdi_code = dm_error_$collection_not_found 
      273           then rdi_code = 0;
      274 
      275 	mftxn_code = rdi_code;
      276 
  9     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
  9     2 
  9     3 
  9     4 
  9     5 /****^  HISTORY COMMENTS:
  9     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  9     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  9     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
  9     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
  9    10*                                                   END HISTORY COMMENTS */
  9    11 
  9    12 
  9    13 /*
  9    14*                    BEGIN_DESCRIPTION
  9    15*
  9    16*   A generalized routine accessed by all MRDS modules that begin and commit 
  9    17*   transactions.  The intent is that it be executed as inline code. It is 
  9    18*   assumed that mrds_start_transaction was executed previously in the 
  9    19*   procedure.  Prior to this include file the program should assign the value 
  9    20*   of its local error code to mftxn_code.  The program utilizing this
  9    21*   include file must supply a function labeled should_rollback that returns
  9    22*   bit (1).  This routine should examine the error code mftxn_code and whether
  9    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
  9    24*   means rollback.  This procedure may choose to simply return "0"b as it 
  9    25*   appears that MRDS will generally NOT rollback transactions.  This routine
  9    26*   does rollback and restart if the before journal is full but only attempts it
  9    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
  9    28*   where any data that was saved prior to the transaction is restored.  A 
  9    29*   procedure consisting solely of a return statement can be supplied if 
  9    30*   necessary.  After execution of this include file, mftxn_code must be
  9    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
  9    32*   then the commit has failed.  Otherwise it will be unchanged.
  9    33*
  9    34*                    END_DESCRIPTION
  9    35*
  9    36*   Written 82-09-30 by Paul W. Benjamin.
  9    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
  9    38*                     error code only when the transaction is in an error state.
  9    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
  9    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
  9    41*		 fails, and to abort rather than rollback when bj is full.
  9    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
  9    43*		 and rollback.
  9    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
  9    45*		 to by the mstxn_any_other procedure.
  9    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
  9    47*                     the user already started his own transaction.
  9    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
  9    49*                     the directory >ldd>include and >exl>mrd>i.
  9    50**/
  9    51 
  9    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
  9    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
  9    54 dcl mftxn_code fixed bin (35);
  9    55 dcl mftxn_temp_code fixed bin (35);
  9    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
  9    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
  9    58 	
  9    59 
  9    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
  9    61 	     then do;
  9    62 	     mftxn_code = 0;
  9    63 	     goto mftxn_exit;
  9    64 	end;
  9    65 mftxn_check_code:
  9    66 	if mftxn_code = 0
  9    67 	     then do;
  9    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
  9    69 	     if mftxn_code ^= 0
  9    70 		then do;
  9    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  9    72 		if mftxn_temp_code ^= 0
  9    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  9    74 	     end;
  9    75 	end;
  9    76 	else do;
  9    77 	     call restore_significant_data;
  9    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
  9    79 		& mstxn_retries < 1		
  9    80 		then do;
  9    81 		     mstxn_retries = mstxn_retries + 1;
  9    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  9    83 		     if mftxn_temp_code ^= 0
  9    84 			then do;
  9    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  9    86 			if mftxn_temp_code ^= 0
  9    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  9    88 		     end;
  9    89 		     else do;
  9    90 			mstxn_code = 0;
  9    91 			goto mstxn_exit;		/* go back and try again */
  9    92 		     end;
  9    93 		end;
  9    94 	     else if should_rollback ()		/* let the program decide */
  9    95 		then do;
  9    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  9    97 		if mftxn_temp_code ^= 0
  9    98 		     then do;
  9    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  9   100 		     if mftxn_temp_code ^= 0
  9   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  9   102 		end;
  9   103 		else do;
  9   104 		     mstxn_code = 0;
  9   105 		     goto mstxn_exit;		/* go back and try again */
  9   106 		end;
  9   107 	     end;
  9   108 	     else do;
  9   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  9   110 		if mftxn_temp_code ^= 0
  9   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  9   112 	     end;
  9   113 	end;
  9   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
  9   115 mftxn_exit:
  9   116      
  9   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
      277 
      278 
      279 	if mftxn_code ^= 0
      280 	then do;
      281 		rdi_error_message = "Could not finish the transaction";
      282 		call clean_up ("0"b, "1"b);
      283 		goto exit_rmdb_delete_index;
      284 	     end;
      285 
      286 	if rdi_code ^= 0 then do;
      287 		rdi_error_message = "Error while deleting the index";
      288 		call clean_up ("0"b, "1"b);
      289 		goto exit_rmdb_delete_index;
      290 	     end;
      291 
      292 /*
      293*   Update the model to reflect  that  the  attribute  is  no  longer
      294*   indexed and mark the database as consistent.
      295**/
      296 	on quit rdi_quit_signaled = "1"b;
      297 	call update_model (rdi_db_model_ptr, rdi_rel_ptr, rdi_nsecs, rdi_attr_ptr);
      298 	call mdbm_util_$inconsistent_reset (rdi_db_model_ptr);
      299 	revert quit;
      300 	if rdi_quit_signaled
      301 	then do;
      302 		rdi_quit_signaled = "0"b;
      303 		signal quit;
      304 	     end;
      305 
      306 	call clean_up ("1"b, "0"b);
      307 
      308 exit_rmdb_delete_index:
      309 
      310 	return;
      311 
      312 should_rollback: proc () returns (bit (1));
      313 	return ("0"b);
      314      end should_rollback;
      315 
      316 
      317 
      318 
      319 
      320 restore_significant_data: proc;
      321 
      322 	dcl     rsd_code		 fixed bin (35);
      323 
      324 
      325 	rdi_error_message = rtrim (rdi_error_message) || " Backout has occured.";
      326 
      327 	if rdi_rel_opening_id ^= "0"b
      328 	then call rmdb_ctl.relmgr_entries.close (rdi_rel_opening_id, rsd_code);
      329 	rdi_rel_opening_id = "0"b;
      330 
      331 	return;
      332 
      333      end restore_significant_data;
      334 
      335 initiate_models: proc (im_db_abs_path, im_rel_name, im_file_model_ptr);
      336 
      337 /*
      338*   This routine initiates a pointer to the file_model  segment  that
      339*   contains the relation model. If the file model cannot be found it
      340*   indicates that the data base does not contain the relation.
      341**/
      342 
      343 /* PARAMETERS */
      344 
      345 	dcl     im_db_abs_path	 char (168);	/* (input) absolute path to the database directory */
      346 	dcl     im_rel_name		 char (*);	/* (input) name of the relation to be restructured */
      347 	dcl     im_file_model_ptr	 ptr;		/* (output) pointer to the file model
      348*						   .        that contains the relation */
      349 
      350 
      351 	call hcs_$initiate (im_db_abs_path, rtrim (im_rel_name) || ".m", "", 0, 0, im_file_model_ptr, rdi_code);
      352 	if im_file_model_ptr = null ()
      353 	then do;
      354 		call ioa_$rs ("^/The relation ^a does not exist in the data base.",
      355 		     rdi_error_message, length (rdi_error_message), im_rel_name);
      356 		goto exit_rmdb_delete_index;
      357 	     end;
      358 	else rdi_code = 0;
      359 
      360 	return;
      361 
      362      end initiate_models;
      363 
      364 get_relation_data: proc (grd_file_model_ptr, grd_rel_ptr, grd_rel_id, grd_number_of_varying_attrs);
      365 
      366 /*
      367*   This routine extracts information from the rel_info structure for
      368*   the relation that is to be restructured.
      369**/
      370 
      371 /* PARAMETERS */
      372 
      373 	dcl     grd_file_model_ptr	 ptr;		/* (input) pointer to the file model that contains the relation */
      374 	dcl     grd_rel_ptr		 ptr;		/* (output) pointer to the rel_info structure */
      375 	dcl     grd_rel_id		 bit (36) aligned;	/* (output) bits that identify the relation */
      376 	dcl     grd_number_of_varying_attrs fixed bin;	/* (output) number of varying attrs in
      377*						   .        the relation being indexed */
      378 
      379 	grd_rel_ptr = pointer (grd_file_model_ptr, grd_file_model_ptr -> file_model.rel_ptr);
      380 
      381 	grd_rel_id = grd_rel_ptr -> rel_info.id;
      382 
      383 	grd_number_of_varying_attrs = grd_rel_ptr -> rel_info.nvar_atts;
      384 
      385 	return;
      386 
      387      end get_relation_data;
      388 
      389 get_attribute_data: proc (gad_file_model_ptr, gad_rel_ptr, gad_rel_name,
      390 	gad_attr_name, gad_attr_ptr, gad_index_id, gad_nsecs);
      391 
      392 /*
      393*   This routine gets the information about  the  attribute  that  is
      394*   needed, i.e. its index_id and a pointer to its info structure. It
      395*   also counts the number of indexed attributes in the relation.
      396**/
      397 
      398 /* PARAMETERS */
      399 
      400 	dcl     gad_file_model_ptr	 ptr;		/* (input) pointer to the file model that contains the relation */
      401 	dcl     gad_rel_ptr		 ptr;		/* (input) pointer to the rel_info structure */
      402 	dcl     gad_rel_name	 char (*);	/* (input) name of the relation to be restructured */
      403 	dcl     gad_attr_name	 char (*);	/* (input) name of the attribute to be un-indexed */
      404 	dcl     gad_attr_ptr	 ptr;		/* (output) pointer to attr_info structure */
      405 	dcl     gad_index_id	 bit (36) aligned;	/* (output) actual bits that identify
      406*						   .        which attr an index refers to */
      407 	dcl     gad_nsecs		 fixed bin;	/* (output) number of secondary indices
      408*						   .        in the relation being restructured */
      409 
      410 /* AUTOMATIC */
      411 
      412 	dcl     gad_i		 fixed bin;	/* loop index */
      413 	dcl     gad_local_attr_ptr	 ptr;		/* pointer to attr_info structure */
      414 
      415 	gad_attr_ptr = null ();
      416 	gad_nsecs = 0;
      417 
      418 	gad_local_attr_ptr = pointer (gad_file_model_ptr, gad_rel_ptr -> rel_info.attr_ptr);
      419 	do gad_i = 1 to gad_rel_ptr -> rel_info.num_attr;
      420 	     if gad_local_attr_ptr -> attr_info.name = gad_attr_name
      421 	     then gad_attr_ptr = gad_local_attr_ptr;
      422 
      423 	     if gad_local_attr_ptr -> attr_info.index_attr
      424 	     then gad_nsecs = gad_nsecs + 1;
      425 
      426 	     gad_local_attr_ptr = pointer (gad_file_model_ptr, gad_local_attr_ptr -> attr_info.fwd_thread);
      427 	end;
      428 
      429 	if gad_attr_ptr = null ()
      430 	then do;
      431 		rdi_code = error_table_$action_not_performed;
      432 		call ioa_$rs ("^/Relation ^a does not contain an attribute named ^a",
      433 		     rdi_error_message, length (rdi_error_message), gad_rel_name, gad_attr_name);
      434 		goto exit_rmdb_delete_index;
      435 	     end;
      436 
      437 	if ^gad_attr_ptr -> attr_info.index_attr
      438 	then do;
      439 		if rdi_brief_flag
      440 		then goto exit_rmdb_delete_index;
      441 		else do;
      442 			rdi_code = error_table_$action_not_performed;
      443 			call ioa_$rs ("^/Attribute ^a in relation ^a is not a secondary index",
      444 			     rdi_error_message, length (rdi_error_message), gad_attr_name, gad_rel_name);
      445 			goto exit_rmdb_delete_index;
      446 		     end;
      447 	     end;
      448 
      449 	gad_index_id = gad_attr_ptr -> attr_info.index_id;
      450 
      451 	return;
      452 
      453      end get_attribute_data;
      454 
      455 update_model: proc (um_db_model_ptr, um_rel_ptr, um_nsecs, um_attr_ptr);
      456 
      457 /*
      458*   This procedure  updates  the  data  model  to  reflect  that  the
      459*   attribute  is  no  longer indexed, and if the last index is being
      460*   deleted that the relation is no longer indexed.
      461**/
      462 
      463 /* PARAMETERS */
      464 
      465 	dcl     um_db_model_ptr	 ptr;		/* (input) pointer to the database model */
      466 	dcl     um_rel_ptr		 ptr;		/* (input) pointer to the rel_info structure */
      467 	dcl     um_nsecs		 fixed bin;	/* (input) number of secondary indices
      468*						   .       in the relation being restructured */
      469 	dcl     um_attr_ptr		 ptr;		/* (input) pointer to attr_info structure */
      470 
      471 
      472 	if um_nsecs = 1
      473 	then um_rel_ptr -> rel_info.indexed = "0"b;
      474 
      475 	um_attr_ptr -> attr_info.index_attr = "0"b;
      476 	um_attr_ptr -> attr_info.index_id = "0"b;
      477 
      478 	call rmdb_add_rmdb_history (um_db_model_ptr, RMDB_REL_TYPE, (um_rel_ptr -> rel_info.name),
      479 	     RMDB_DEL_IDX_OP, (um_attr_ptr -> attr_info.name), rdi_error_message, rdi_code);
      480 	if rdi_code ^= 0
      481 	then do;
      482 		call clean_up ("0"b, "1"b);
      483 		goto exit_rmdb_delete_index;
      484 	     end;
      485 
      486 	return;
      487 
      488      end update_model;
      489 
      490 clean_up: proc (cu_set_code, cu_leave_db_inconsistent);
      491 
      492 /*
      493*   This procedure is called both during normal and error termination
      494*   and in the event that the cleanup condition is signaled.
      495*
      496**/
      497 
      498 
      499 /* PARAMETERS */
      500 
      501 	dcl     cu_set_code		 bit (1);		/* (input) true ==> if error occurs during cleanup, global error
      502*						   .       code will be set to error */
      503 	dcl     cu_leave_db_inconsistent bit (1);	/* (input) true ==> the dba will not be queried if indexing is
      504*						   .       to continue and the message giving directions for
      505*						   .       how to make the db consistent will be concatinated
      506*						   .       to the returned error message */
      507 
      508 /* AUTOMATIC */
      509 
      510 	dcl     cu_code		 fixed bin (35);	/* internal error code */
      511 
      512 
      513 
      514 	if cu_leave_db_inconsistent
      515 	then rdi_error_message = rtrim (rdi_error_message) ||
      516 		"^/The data base is being left in an inconsistent state," ||
      517 		"^/to make the database consistent use the delete_index request" ||
      518 		"^/to finish deleting the partially deleted index.";
      519 
      520 	if rdi_rel_opening_id ^= "0"b then
      521 	     call rmdb_ctl.relmgr_entries.close (rdi_rel_opening_id, cu_code);
      522 	if cu_set_code
      523 	then do;
      524 		if cu_code ^= 0
      525 		then do;
      526 			rdi_code = cu_code;
      527 			if rdi_code = 0
      528 			then rdi_error_message = "^/The relation could not be closed.";
      529 			else rdi_error_message = rtrim (rdi_error_message) ||
      530 				"^/The relation could not be closed.";
      531 		     end;
      532 	     end;
      533 	else do;
      534 		if cu_code ^= 0
      535 		then rdi_error_message = rtrim (rdi_error_message) ||
      536 			"^/The relation could not be closed.";
      537 	     end;
      538 
      539 	return;
      540 
      541      end clean_up;
      542 
      543      end rmdb_delete_index;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/23/86  1007.9  rmdb_delete_index.pl1             >spec>install>1199>rmdb_delete_index.pl1
165          1    10/17/86  1404.3  mdbm_db_model.incl.pl1            >ldd>include>mdbm_db_model.incl.pl1
167          2    10/17/86  1404.5  mdbm_file_model.incl.pl1          >ldd>include>mdbm_file_model.incl.pl1
169          3    10/17/86  1404.4  rmdb_history_entry.incl.pl1       >ldd>include>rmdb_history_entry.incl.pl1
171          4    10/17/86  1404.4  mrds_rmdb_ctl.incl.pl1            >ldd>include>mrds_rmdb_ctl.incl.pl1
4-46         5    10/17/86  1404.6  rmdb_relmgr_entries.incl.pl1      >ldd>include>rmdb_relmgr_entries.incl.pl1
223          6    02/05/86  1416.4  mrds_start_transaction.incl.pl1   >ldd>include>mrds_start_transaction.incl.pl1
6-79         7    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
6-81         8    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
277          9    02/05/86  1416.4  mrds_finish_transaction.incl.pl1  >ldd>include>mrds_finish_transaction.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
RMDB_DEL_IDX_OP                 000020 constant        fixed bin(17,0)          initial dcl 3-53 set ref 478*
RMDB_REL_TYPE                   000021 constant        fixed bin(17,0)          initial dcl 3-47 set ref 478*
TM_NORMAL_MODE                  000013 constant        fixed bin(17,0)          initial dcl 7-15 set ref 6-99*
addr                                                   builtin function         dcl 131 ref 6-123 6-123
any_other                       000216 stack reference condition                dcl 145 ref 221
attr_info                              based           structure                level 1 dcl 2-192
attr_ptr                 24(18)        based           bit(18)                  level 2 packed unaligned dcl 2-126 ref 418
cleanup                         000224 stack reference condition                dcl 146 ref 219 249
close                   166            based           entry variable           level 3 dcl 4-25 ref 327 520
condition_info                         based           structure                level 1 dcl 8-14
condition_name            3     000252 automatic       varying char(32)         level 2 dcl 6-77 set ref 6-124 6-129 6-129
continue_to_signal_             000026 constant        entry                    external dcl 6-61 ref 6-137
cu_code                         000100 automatic       fixed bin(35,0)          dcl 510 set ref 520* 524 526 534
cu_leave_db_inconsistent               parameter       bit(1)                   unaligned dcl 503 ref 490 514
cu_set_code                            parameter       bit(1)                   unaligned dcl 501 ref 490 522
db_model                               based           structure                level 1 dcl 1-72
db_type_flags             0(18)        based           structure                level 2 packed unaligned dcl 1-72
delete_index            176            based           entry variable           level 3 dcl 4-25 ref 269
dm_error_$bj_journal_full       000046 external static fixed bin(35,0)          dcl 9-52 ref 6-132
dm_error_$collection_not_found  000022 external static fixed bin(35,0)          dcl 159 ref 272
dm_error_$lock_deadlock         000050 external static fixed bin(35,0)          dcl 9-53 ref 9-78 6-126
dm_error_$no_current_transaction
                                000030 external static fixed bin(35,0)          dcl 6-62 ref 195 6-90
error_table_$action_not_performed
                                000024 external static fixed bin(35,0)          dcl 160 ref 197 431 442
file_model                             based           structure                level 1 dcl 2-40
find_condition_info_            000032 constant        entry                    external dcl 6-64 ref 6-123
fwd_thread               20            based           bit(18)                  level 2 packed unaligned dcl 2-192 ref 426
gad_attr_name                          parameter       char                     unaligned dcl 403 set ref 389 420 432* 443*
gad_attr_ptr                           parameter       pointer                  dcl 404 set ref 389 415* 420* 429 437 449
gad_file_model_ptr                     parameter       pointer                  dcl 400 ref 389 418 426
gad_i                           000346 automatic       fixed bin(17,0)          dcl 412 set ref 419*
gad_index_id                           parameter       bit(36)                  dcl 405 set ref 389 449*
gad_local_attr_ptr              000350 automatic       pointer                  dcl 413 set ref 418* 420 420 423 426* 426
gad_nsecs                              parameter       fixed bin(17,0)          dcl 407 set ref 389 416* 423* 423
gad_rel_name                           parameter       char                     unaligned dcl 402 set ref 389 432* 443*
gad_rel_ptr                            parameter       pointer                  dcl 401 ref 389 418 419
grd_file_model_ptr                     parameter       pointer                  dcl 373 ref 364 379 379
grd_number_of_varying_attrs            parameter       fixed bin(17,0)          dcl 376 set ref 364 383*
grd_rel_id                             parameter       bit(36)                  dcl 375 set ref 364 381*
grd_rel_ptr                            parameter       pointer                  dcl 374 set ref 364 379* 381 383
hcs_$initiate                   000010 constant        entry                    external dcl 151 ref 351
id                       10            based           bit(36)                  level 2 dcl 2-126 ref 381
im_db_abs_path                         parameter       char(168)                unaligned dcl 345 set ref 335 351*
im_file_model_ptr                      parameter       pointer                  dcl 347 set ref 335 351* 352
im_rel_name                            parameter       char                     unaligned dcl 346 set ref 335 351 354*
index_attr               10(01)        based           bit(1)                   level 2 packed unaligned dcl 2-192 set ref 423 437
                                                                                  475*
index_id                 11            based           bit(36)                  level 2 dcl 2-192 set ref 449 476*
indexed                  11(04)        based           bit(1)                   level 2 packed unaligned dcl 2-126 set ref 472*
ioa_$rs                         000012 constant        entry                    external dcl 152 ref 354 432 443
length                                                 builtin function         dcl 133 ref 354 354 432 432 443 443
mdbm_util_$inconsistent_reset   000014 constant        entry                    external dcl 153 ref 298
mdbm_util_$inconsistent_set     000016 constant        entry                    external dcl 154 ref 239
mftxn_code                      000304 automatic       fixed bin(35,0)          dcl 9-54 set ref 275* 9-62* 9-65 9-68* 9-69 9-78
                                                                                  9-115 6-126* 6-132*
mftxn_temp_code                 000305 automatic       fixed bin(35,0)          dcl 9-55 set ref 9-71* 9-72 9-72* 9-82* 9-83 9-85*
                                                                                  9-86 9-86* 9-96* 9-97 9-99* 9-100 9-100* 9-109*
                                                                                  9-110 9-110*
mstxn_code                      000242 automatic       fixed bin(35,0)          dcl 6-65 set ref 194* 195 6-83* 6-89* 6-90 6-99*
                                                                                  6-140 227 9-90* 9-104* 6-137*
mstxn_condition_info            000252 automatic       structure                level 1 unaligned dcl 6-77 set ref 6-123 6-123
mstxn_retries                   000243 automatic       fixed bin(17,0)          dcl 6-66 set ref 6-88* 9-78 9-81* 9-81
mstxn_temp_code                 000244 automatic       fixed bin(35,0)          dcl 6-67 set ref 6-109* 6-110 6-110* 6-123*
mstxn_transactions_needed       000245 automatic       bit(1)                   dcl 6-68 set ref 186* 193* 6-86
mstxn_txn_id                    000247 automatic       bit(36)                  dcl 6-70 set ref 185* 194* 6-84* 6-89* 6-93 6-94*
                                                                                  6-99* 6-100 9-60 9-68* 9-71* 9-72* 9-82* 9-85*
                                                                                  9-86* 9-96* 9-99* 9-100* 9-109* 9-110* 9-114*
                                                                                  6-107 6-109* 6-110* 6-121
n                         1     000114 automatic       fixed bin(17,0)          initial level 2 dcl 124 set ref 124*
name                                   based           char(32)                 level 2 in structure "attr_info" dcl 2-192
                                                                                  in procedure "rmdb_delete_index" ref 420 478
name                                   based           char(32)                 level 2 in structure "rel_info" dcl 2-126
                                                                                  in procedure "rmdb_delete_index" ref 478
null                                                   builtin function         dcl 134 ref 6-123 6-123 352 415 429
num_attr                 12            based           fixed bin(17,0)          level 2 packed unaligned dcl 2-126 ref 419
nvar_atts                14(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-126 ref 383
open                    162            based           entry variable           level 3 dcl 4-25 ref 262
pointer                                                builtin function         dcl 135 ref 379 418 426
quit                            000232 stack reference condition                dcl 147 ref 237 242 246 296 299 303
rdi_attr_name                          parameter       char                     unaligned dcl 106 set ref 20 213* 239 239
rdi_attr_ptr                    000100 automatic       pointer                  dcl 113 set ref 213* 297*
rdi_based_char8                        based           char(8)                  unaligned dcl 141 set ref 238*
rdi_brief_flag                         parameter       bit(1)                   unaligned dcl 107 ref 20 439
rdi_code                               parameter       fixed bin(35,0)          dcl 109 set ref 20 180* 197* 227* 262* 263 269* 272
                                                                                  272* 275 286 351* 358* 431* 442* 478* 480 526* 527
rdi_db_abs_path                        parameter       char(168)                unaligned dcl 103 set ref 20 209* 262*
rdi_db_model_ptr                       parameter       pointer                  dcl 104 set ref 20 191 239* 297* 298*
rdi_error_message                      parameter       char(500)                unaligned dcl 108 set ref 20 181* 198* 228* 264*
                                                                                  281* 287* 325* 325 354* 354 354 432* 432 432 443*
                                                                                  443 443 478* 514* 514 527* 529* 529 534* 534
rdi_file_model_ptr              000102 automatic       pointer                  dcl 114 set ref 209* 211* 213*
rdi_index_id                    000104 automatic       bit(36)                  dcl 115 set ref 213* 269*
rdi_nsecs                       000105 automatic       fixed bin(17,0)          dcl 116 set ref 213* 297*
rdi_number_of_varying_attrs     000106 automatic       fixed bin(17,0)          dcl 118 set ref 211*
rdi_quit_signaled               000107 automatic       bit(1)                   unaligned dcl 119 set ref 182* 237* 243 245* 296*
                                                                                  300 302*
rdi_rel_id                      000110 automatic       bit(36)                  dcl 120 set ref 211*
rdi_rel_name                           parameter       char                     unaligned dcl 105 set ref 20 209* 213* 239 239 262*
rdi_rel_opening_id              000111 automatic       bit(36)                  dcl 121 set ref 183* 262* 269* 327 327* 329* 520
                                                                                  520*
rdi_rel_ptr                     000112 automatic       pointer                  dcl 122 set ref 211* 213* 297*
rdi_rmdb_ctl_ptr                       parameter       pointer                  dcl 123 ref 20 184
rdi_seek_head_info              000114 automatic       structure                level 1 unaligned dcl 124
rel_info                               based           structure                level 1 dcl 2-126
rel_ptr                  20(27)        based           bit(18)                  level 2 packed unaligned dcl 2-40 ref 379
relation_type                   000114 automatic       fixed bin(17,0)          initial level 2 dcl 124 set ref 124*
relmgr_entries          152            based           structure                level 2 unaligned dcl 4-25
rmdb_add_rmdb_history           000020 constant        entry                    external dcl 155 ref 478
rmdb_ctl                               based           structure                level 1 unaligned dcl 4-25
rmdb_ctl_ptr                    000240 automatic       pointer                  dcl 4-43 set ref 184* 238 262 269 327 520
rmdb_relmgr_entries                    based           structure                level 1 unaligned dcl 5-18
rsd_code                        000322 automatic       fixed bin(35,0)          dcl 322 set ref 327*
rtrim                                                  builtin function         dcl 137 ref 239 239 239 239 325 351 514 529 534
saved_res_version_ptr
                        136            based           pointer                  level 2 dcl 4-25 ref 238
search_key                2     000114 automatic       char(256)                initial level 2 packed unaligned dcl 124 set ref
                                                                                  124*
transaction_manager_$abandon_txn
                                000034 constant        entry                    external dcl 6-72 ref 9-72 9-86 9-100 9-110 6-110
transaction_manager_$abort_txn  000036 constant        entry                    external dcl 6-73 ref 9-71 9-85 9-99 9-109 6-109
transaction_manager_$begin_txn  000040 constant        entry                    external dcl 6-74 ref 6-99
transaction_manager_$commit_txn 000052 constant        entry                    external dcl 9-56 ref 9-68
transaction_manager_$get_current_txn_id
                                000042 constant        entry                    external dcl 6-75 ref 194 6-89
transaction_manager_$handle_conditions
                                000044 constant        entry                    external dcl 6-76 ref 6-135
transaction_manager_$rollback_txn
                                000054 constant        entry                    external dcl 9-57 ref 9-82 9-96
transactions_needed       0(34)        based           bit(1)                   level 3 packed unaligned dcl 1-72 ref 191
um_attr_ptr                            parameter       pointer                  dcl 469 ref 455 475 476 478
um_db_model_ptr                        parameter       pointer                  dcl 465 set ref 455 478*
um_nsecs                               parameter       fixed bin(17,0)          dcl 467 ref 455 472
um_rel_ptr                             parameter       pointer                  dcl 466 ref 455 472 478
user_started_transaction        000246 automatic       bit(1)                   dcl 6-69 set ref 6-92* 6-98* 9-60
user_transaction_id             000250 automatic       bit(36)                  dcl 6-71 set ref 6-93* 6-100*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 7-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 7-12
RMDB_ADD_ATTR_OP                       internal static fixed bin(17,0)          initial dcl 3-54
RMDB_ADD_DMN_OP                        internal static fixed bin(17,0)          initial dcl 3-56
RMDB_ADD_IDX_OP                        internal static fixed bin(17,0)          initial dcl 3-52
RMDB_ADD_REL_OP                        internal static fixed bin(17,0)          initial dcl 3-50
RMDB_ATTR_TYPE                         internal static fixed bin(17,0)          initial dcl 3-46
RMDB_CTL_VERSION_1                     internal static fixed bin(17,0)          initial dcl 4-41
RMDB_DEL_ATTR_OP                       internal static fixed bin(17,0)          initial dcl 3-55
RMDB_DEL_DMN_OP                        internal static fixed bin(17,0)          initial dcl 3-57
RMDB_DEL_REL_OP                        internal static fixed bin(17,0)          initial dcl 3-51
RMDB_DOMAIN_TYPE                       internal static fixed bin(17,0)          initial dcl 3-45
RMDB_RN_ATTR_OP                        internal static fixed bin(17,0)          initial dcl 3-58
RMDB_RN_DMN_OP                         internal static fixed bin(17,0)          initial dcl 3-59
RMDB_RN_REL_OP                         internal static fixed bin(17,0)          initial dcl 3-60
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 7-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 7-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 7-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 7-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 7-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 7-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 7-20
ai_ptr                                 automatic       pointer                  dcl 2-209
al_ptr                                 automatic       pointer                  dcl 2-345
alloc_length                           internal static fixed bin(35,0)          dcl 1-222
atd                                    based           char                     unaligned dcl 2-109
atd_len                                automatic       fixed bin(17,0)          dcl 2-111
atd_ptr                                automatic       pointer                  dcl 2-110
attr_list                              based           structure                level 1 dcl 2-341
changer                                based           structure                level 1 packed unaligned dcl 1-251
changer_ptr                            automatic       pointer                  dcl 1-256
child_link_info                        based           structure                level 1 dcl 2-283
cli_ptr                                automatic       pointer                  dcl 2-329
cna_ptr                                automatic       pointer                  dcl 2-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 2-112
condition_info_ptr                     automatic       pointer                  dcl 8-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 8-30
constant                               based           structure                level 1 unaligned dcl 1-216
constant_ptr                           automatic       pointer                  dcl 1-220
dbm_ptr                                automatic       pointer                  dcl 1-106
di_ptr                                 automatic       pointer                  dcl 1-155
domain_info                            based           structure                level 1 dcl 1-125
dp_ptr                                 automatic       pointer                  dcl 2-356
dup_prev                               based           structure                level 1 dcl 2-353
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 6-63
fi_ptr                                 automatic       pointer                  dcl 1-119
file_info                              based           structure                level 1 dcl 1-113
fixed                                                  builtin function         dcl 132
fm_ptr                                 automatic       pointer                  dcl 2-108
message_str                            based           structure                level 1 packed unaligned dcl 1-259
message_str_len                        automatic       fixed bin(17,0)          dcl 1-269
message_str_ptr                        automatic       pointer                  dcl 1-267
ncomp_init                             automatic       fixed bin(17,0)          dcl 2-116
parent_link_info                       based           structure                level 1 dcl 2-223
path_entry                             based           structure                level 1 packed unaligned dcl 1-172
path_entry_ptr                         automatic       pointer                  dcl 1-177
pli_ptr                                automatic       pointer                  dcl 2-268
rel                                                    builtin function         dcl 136
ri_ptr                                 automatic       pointer                  dcl 2-185
rmdb_history_entry                     based           structure                level 1 dcl 3-31
rmdb_history_entry_ptr                 automatic       pointer                  dcl 3-42
rmdb_relmgr_entries_ptr                automatic       pointer                  dcl 5-32
sc_ptr                                 automatic       pointer                  dcl 2-365
select_chain                           based           structure                level 1 dcl 2-357
sk_ptr                                 automatic       pointer                  dcl 2-352
sort_key                               based           structure                level 1 dcl 2-346
stack_item                             based           structure                level 1 unaligned dcl 1-206
stack_item_ptr                         automatic       pointer                  dcl 1-212
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 161
ua_ptr                                 automatic       pointer                  dcl 1-165
unreferenced_attribute                 based           structure                level 1 dcl 1-159
version_status                         based           structure                level 1 packed unaligned dcl 1-232
version_status_ptr                     automatic       pointer                  dcl 1-246

NAMES DECLARED BY EXPLICIT CONTEXT.
clean_up                        002552 constant        entry                    internal dcl 490 ref 252 282 288 306 482
exit_rmdb_delete_index          001631 constant        label                    dcl 308 ref 200 229 283 289 356 434 439 445 483
get_attribute_data              002237 constant        entry                    internal dcl 389 ref 213
get_relation_data               002216 constant        entry                    internal dcl 364 ref 211
initiate_models                 002043 constant        entry                    internal dcl 335 ref 209
mftxn_check_code                001251 constant        label                    dcl 9-65 ref 6-127 6-133
mftxn_exit                      001471 constant        label                    dcl 9-115 ref 266 9-63
mstxn_any_other                 001670 constant        entry                    internal dcl 6-116 ref 221
mstxn_cleanup                   001633 constant        entry                    internal dcl 6-102 ref 219 251
mstxn_exit                      000641 constant        label                    dcl 6-140 ref 6-86 6-95 9-91 9-105
restore_significant_data        001774 constant        entry                    internal dcl 320 ref 265 9-77
rmdb_delete_index               000350 constant        entry                    external dcl 20
should_rollback                 001765 constant        entry                    internal dcl 312 ref 9-94
update_model                    002456 constant        entry                    internal dcl 455 ref 297

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3346        3424    3006        3356
Length      4046    3006        56         406     337           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rmdb_delete_index                   492 external procedure  is an external procedure.  
on unit on line 219                  64 on unit               
on unit on line 221                  82 on unit               
mstxn_cleanup                        70 internal procedure  is called by several nonquick procedures.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 221.  
on unit on line 237                  64 on unit               
on unit on line 249                  74 on unit               
on unit on line 296                  64 on unit               
should_rollback                         internal procedure  shares stack frame of external procedure rmdb_delete_index.  
restore_significant_data                internal procedure  shares stack frame of external procedure rmdb_delete_index.  
initiate_models                         internal procedure  shares stack frame of external procedure rmdb_delete_index.  
get_relation_data                       internal procedure  shares stack frame of external procedure rmdb_delete_index.  
get_attribute_data                      internal procedure  shares stack frame of external procedure rmdb_delete_index.  
update_model                            internal procedure  shares stack frame of external procedure rmdb_delete_index.  
clean_up                             76 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
clean_up                 000100 cu_code                     clean_up
rmdb_delete_index        000100 rdi_attr_ptr                rmdb_delete_index
                         000102 rdi_file_model_ptr          rmdb_delete_index
                         000104 rdi_index_id                rmdb_delete_index
                         000105 rdi_nsecs                   rmdb_delete_index
                         000106 rdi_number_of_varying_attrs rmdb_delete_index
                         000107 rdi_quit_signaled           rmdb_delete_index
                         000110 rdi_rel_id                  rmdb_delete_index
                         000111 rdi_rel_opening_id          rmdb_delete_index
                         000112 rdi_rel_ptr                 rmdb_delete_index
                         000114 rdi_seek_head_info          rmdb_delete_index
                         000240 rmdb_ctl_ptr                rmdb_delete_index
                         000242 mstxn_code                  rmdb_delete_index
                         000243 mstxn_retries               rmdb_delete_index
                         000244 mstxn_temp_code             rmdb_delete_index
                         000245 mstxn_transactions_needed   rmdb_delete_index
                         000246 user_started_transaction    rmdb_delete_index
                         000247 mstxn_txn_id                rmdb_delete_index
                         000250 user_transaction_id         rmdb_delete_index
                         000252 mstxn_condition_info        rmdb_delete_index
                         000304 mftxn_code                  rmdb_delete_index
                         000305 mftxn_temp_code             rmdb_delete_index
                         000322 rsd_code                    restore_significant_data
                         000346 gad_i                       get_attribute_data
                         000350 gad_local_attr_ptr          get_attribute_data

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ent_var        call_ext_out_desc   call_ext_out
call_int_this       call_int_other      return_mac          tra_ext_1           signal_op           enable_op
shorten_stack       ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           find_condition_info_          hcs_$initiate                 ioa_$rs
mdbm_util_$inconsistent_reset mdbm_util_$inconsistent_set   rmdb_add_rmdb_history
transaction_manager_$abandon_txn                            transaction_manager_$abort_txn
transaction_manager_$begin_txn                              transaction_manager_$commit_txn
transaction_manager_$get_current_txn_id                     transaction_manager_$handle_conditions
transaction_manager_$rollback_txn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$collection_not_found                              dm_error_$lock_deadlock
dm_error_$no_current_transaction                            error_table_$action_not_performed




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     20 000341       124 000370       180 000376       181 000400       182 000404       183 000405       184 000406
    185 000411       186 000412       191 000413       193 000417       194 000421       195 000431       197 000435
    198 000440       200 000444       209 000445       211 000467       213 000471       219 000531       221 000553
 6   83 000571    6   84 000572    6   86 000573    6   88 000575    6   89 000576    6   90 000607    6   92 000613
 6   93 000615    6   94 000617    6   95 000620    6   98 000621    6   99 000622    6  100 000637    6  140 000641
    227 000643       228 000645       229 000651       237 000652       238 000672       239 000677       242 001110
    243 001112       245 001114       246 001115       249 001120       251 001134       252 001141       253 001156
    262 001157       263 001206       264 001211       265 001215       266 001216       269 001217       272 001232
    275 001240    9   60 001242    9   62 001247    9   63 001250    9   65 001251    9   68 001253    9   69 001264
 9   71 001266    9   72 001277    9   75 001312    9   77 001313    9   78 001314    9   81 001323    9   82 001324
 9   83 001337    9   85 001341    9   86 001352    9   88 001365    9   90 001366    9   91 001367    9   93 001370
 9   94 001371    9   96 001376    9   97 001412    9   99 001414    9  100 001425    9  102 001440    9  104 001441
 9  105 001442    9  107 001443    9  109 001444    9  110 001455    9  114 001470    9  115 001471       281 001473
    282 001500       283 001514       286 001515       287 001520       288 001524       289 001540       296 001541
    297 001561       298 001576       299 001606       300 001607       302 001611       303 001612       306 001615
    308 001631    6  102 001632    6  107 001640    6  109 001643    6  110 001653    6  114 001667    6  116 001670
 6  121 001671    6  123 001674    6  124 001713    6  126 001721    6  127 001724    6  129 001727    6  132 001741
 6  133 001744    6  135 001747    6  136 001754    6  137 001755    6  138 001764       312 001765       313 001767
    320 001774       325 001775       327 002025       329 002041       331 002042       335 002043       351 002054
    352 002150       354 002156       356 002212       358 002213       360 002215       364 002216       379 002220
    381 002230       383 002232       385 002236       389 002237       415 002255       416 002260       418 002261
    419 002271       420 002301       423 002312       426 002316       427 002324       429 002326       431 002333
    432 002337       434 002375       437 002376       439 002403       442 002411       443 002414       445 002452
    449 002453       451 002455       455 002456       472 002460       475 002467       476 002473       478 002474
    480 002530       482 002533       483 002547       486 002550       490 002551       514 002557       520 002637
    522 002654       524 002662       526 002664       527 002667       529 002675       531 002724       532 002725
    534 002726       537 002761       539 002762


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
