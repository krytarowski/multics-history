	COMPILATION LISTING OF SEGMENT linus_thread_fn_list
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/20/86  1216.1 mst Thu
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 linus_thread_fn_list:
       19      proc (lcb_ptr, calc_entry, input_file_name, function_name, code);
       20 
       21 /* DESCRIPTION:
       22*
       23*   Procedure  to  fill  in a linus_set_fn_info block for a builtin or declared
       24*   set  function,  given  a pointer to the calc.  entry in the text portion of
       25*   the object segment.
       26*   
       27*   
       28*
       29*   HISTORY:
       30*
       31*   76-06-01 J. A. Weeldreyer: Initially written.
       32*
       33*   80-11-03  Rickie  E.   Brinegar:  changed  cent_ptr,  a  entry  pointer, to
       34*   calc_entry,  a  link snapped entry.  The purpose was to allow path names to
       35*   be  handled  and not use cv_ptr_, which does not set up appropriate linkage
       36*   information.
       37*   
       38**/
       39 
  1     1 /* BEGIN INCLUDE FILE linus_lcb.incl.pl1 -- jaw 8/30/77 */
  1     2    
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(86-04-23,Dupuis), approve(86-05-23,MCR7188), audit(86-07-23,GWMay),
  1     7*     install(86-07-29,MR12.0-1106):
  1     8*     Added general_work_area_ptr and renamed sfr_ptr to
  1     9*     force_retrieve_scope_ptr.
  1    10*                                                   END HISTORY COMMENTS */
  1    11 
  1    12 
  1    13 /* HISTORY:
  1    14*
  1    15*   78-09-29 J. C. C. Jagernauth: Modified for MR7.0.
  1    16*
  1    17*   81-05-11  Rickie E.  Brinegar: added security bit and andministrator bit as
  1    18*   a part of the attribute level control work.
  1    19*   
  1    20*   81-06-17  Rickie E.  Brinegar: deleted the sd_ptr as a part of removing the
  1    21*   scope_data  structure  from  LINUS.   LINUS now depends totally on MRDS for
  1    22*   scope information.
  1    23*   
  1    24*   81-11-11  Rickie  E.   Brinegar:  added the timing bit and three fields for
  1    25*   retaining  various  vcpu  times  to  be collected when in timing mode.  The
  1    26*   times  to  be collected are: LINUS parsing time, LINUS processing time, and
  1    27*   MRDS processing time.
  1    28*
  1    29*   82-01-15  DJ  Schimke:  Added the build_increment and build_start fields as
  1    30*   part of the line numbering implementation.  This allows for possible  later
  1    31*   LINUS control of the build defaults.
  1    32* 
  1    33*   82-03-01 Paul W. Benjamin: Removed linus_prompt_chars_ptr, as that 
  1    34*   information is now retained by ssu_.  Removed parse_timer as no longer
  1    35*   meaningful.  Added linus_version.  Added iteration bit.  Added 6 entry 
  1    36*   variables for ssu_ replaceable procedures.  Added actual_input_iocbp.
  1    37*
  1    38*   82-06-23 Al Dupuis: Added subsystem_control_info_ptr, 
  1    39*   subsystem_invocation_level, and selection_expression_identifier.
  1    40*
  1    41*   82-08-26 DJ Schimke: Added report_control_info_ptr, and
  1    42*   table_control_info_ptr. 
  1    43*
  1    44*   82-10-19 DJ Schimke: Added ssu_abort_line.
  1    45*
  1    46*   83-06-06 Bert Moberg: Added print_search_order (pso) and no_optimize (no_ot)
  1    47*
  1    48*   83-04-07 DJ Schimke: Added temp_seg_info_ptr.
  1    49*
  1    50*   83-08-26 Al Dupuis: Added query_temp_segment_ptr.
  1    51**/
  1    52     
  1    53 dcl 1 lcb aligned based (lcb_ptr),			/* LINUS control block */
  1    54     2 db_index fixed bin (35),			/* index of open data base, or 0 */
  1    55     2 rb_len fixed bin (21),				/* length of request buffer */
  1    56     2 lila_count fixed bin (35),			/* number of LILA text lines */
  1    57     2 lila_chars fixed bin (35),			/* number of LILA source test chars */
  1    58     2 trans_id fixed bin (35),			/* used by checkpoint and rollback facilities (MR7.0) */
  1    59     2 lila_fn char (32) unal,				/* entry name of lila data file */
  1    60     2 prompt_flag bit (1) unal,			/* on if in prompt mode */
  1    61     2 test_flag bit (1) unal,				/* on if in test mode */
  1    62     2 new_version bit (1) unal init (1),		/* on for new version data base (MR7.0) */
  1    63     2 secured_db bit (1) unal,                              /* on if the db is in a secure state */
  1    64     2 administrator bit (1) unal,                           /* on if the user is a db administrator */
  1    65     2 timing_mode bit (1) unal,                             /* on if timing is to be done */
  1    66     2 iteration bit (1) unal,				/* interpret parens as iteration sets */
  1    67     2 pso_flag bit (1) unal,				/* add print_search_order to select */
  1    68     2 no_ot_flag bit (1) unal,			/* add no_optimize to select */
  1    69     2 reserved bit (27) unal,
  1    70     2 liocb_ptr ptr,				/* iocb ptr for lila file */
  1    71     2 rb_ptr ptr,					/* ptr to request buffer */
  1    72     2 is_ptr ptr,					/* iocb ptr for currentinput stream switch */
  1    73     2 cal_ptr ptr,					/* ptr to current arg list for invoke (or null) */
  1    74     2 ttn_ptr ptr,					/* pointer to table info structure */
  1    75     2 force_retrieve_scope_info_ptr ptr,		/* structure pointer to force retrieve scope operation */
  1    76     2 lv_ptr ptr,					/* pointer linus variables */
  1    77     2 si_ptr ptr,					/* pointer to select_info structure */
  1    78     2 setfi_ptr ptr,				/* pointer to set function information */
  1    79     2 sclfi_ptr ptr,				/* pointer to user declared scalar fun. names */
  1    80     2 ivs_ptr ptr,					/* pointer to stack of invoke iocb pointers */
  1    81     2 lit_ptr ptr,					/* pointer to literal pool */
  1    82     2 lvv_ptr ptr,					/* pointer to linus variable alloc. pool  */
  1    83     2 rd_ptr ptr,					/* point to readied files mode information (MR7.0) */
  1    84     2 rt_ptr ptr,                                           /* point to table of relation names and their readied modes
  1    85*                                                               (MR7.0) */
  1    86     2 actual_input_iocbp ptr,				/* ptr to input while in macros */
  1    87     2 lila_promp_chars_ptr ptr,			/* pointer to the prompt characters for lila */
  1    88     2 linus_area_ptr ptr,				/* LINUS temporary segment pointer */
  1    89     2 lila_area_ptr ptr,				/* LILA temporary segment pointer */
  1    90     2 i_o_area_ptr ptr,				/* temporary segment pointer used by write, print, create_list */
  1    91     2 rel_array_ptr ptr,                                    /* ptr to array of names rslt info structure
  1    92*                                                               for current lila expression */
  1    93     2 unused_timer float bin (63),			/* future expansion */
  1    94     2 request_time float bin (63),                          /* How much request time was spent
  1    95*                                                                in LINUS. (-1 = user has just enabled 
  1    96*						    timing, do not report) */
  1    97     2 mrds_time float bin (63),                             /* How much time was spent in MRDS */
  1    98     2 build_increment fixed bin,			/* default increment for build mode */
  1    99     2 build_start fixed bin,				/* default start count for build mode */
  1   100     2 linus_version char (4),				/* current version of LINUS */
  1   101     2 subsystem_control_info_ptr ptr,                       /* the same ptr passed by ssu_ to each request procedure */
  1   102     2 subsystem_invocation_level fixed bin,                 /* identifies this invocation of LINUS */
  1   103     2 selection_expression_identifier fixed bin,            /* identifies the current processed selection expression */
  1   104     2 report_control_info_ptr ptr,			/* pointer to linus_report_control_info structure */
  1   105     2 table_control_info_ptr ptr,			/* pointer to linus_table control structure */
  1   106     2 temp_seg_info_ptr ptr,				/* pointer to linus_temp_seg_mgr control structure */
  1   107     2 query_temp_segment_ptr ptr,			/* points to temp seg used for manipulating query */
  1   108     2 general_work_area_ptr ptr,			/* a freeing area for general use */
  1   109     2 word_pad (6) bit (36) unal,
  1   110 						/* procedures that will be optionally */
  1   111 						/* replaced by the user.  Saved so they */
  1   112 						/* can be reinstated if desired. */
  1   113     2 ssu_abort_line entry options (variable),
  1   114     2 ssu_post_request_line variable entry (ptr),
  1   115     2 ssu_pre_request_line variable entry (ptr),
  1   116 
  1   117     2 curr_lit_offset fixed bin (35),			/* index of first free bit in lit. pool */
  1   118     2 curr_lv_val_offset fixed bin (35),		/* index of first free bit lv. val. pool */
  1   119     2 static_area area (sys_info$max_seg_size - fixed (rel (addr (lcb.static_area))) + 1);
  1   120 
  1   121 dcl  lcb_ptr ptr;
  1   122 
  1   123 /* END INCLUDE FILE linus_lcb.incl.pl1 */
       40 
       41 
  2     1 /* BEGIN INCLUDE FILE definition.incl.pl1 */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  2     7*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  2     8*     Modified to add indirect bit to definition flags.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 
  2    12 dcl	1 definition	aligned based,
  2    13 	2 forward		unal bit(18),	/* offset of next def */
  2    14 	2 backward	unal bit(18),	/* offset of previous def */
  2    15 	2 value		unal bit(18),
  2    16 	2 flags		unal,
  2    17 	  3 new		bit(1),
  2    18 	  3 ignore	bit(1),
  2    19 	  3 entry		bit(1),
  2    20 	  3 retain	bit(1),
  2    21 	  3 argcount	bit(1),
  2    22 	  3 descriptors	bit(1),
  2    23 	  3 indirect	bit(1),
  2    24 	  3 unused	bit(8),
  2    25 	2 class		unal bit(3),
  2    26 	2 symbol		unal bit(18),	/* offset of ACC for symbol */
  2    27 	2 segname		unal bit(18);	/* offset of segname def */
  2    28 
  2    29 /* END INCLUDE FILE definition.incl.pl1 */
       42 
       43 
  3     1 /* BEGIN INCLUDE FILE ... entry_sequence_info.incl.pl1 */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(86-04-16,GWMay), approve(86-04-16,MCR7373),
  3     7*     audit(86-04-29,LJAdams), install(86-05-01,MR12.0-1051):
  3     8*     reformatted.
  3     9*                                                   END HISTORY COMMENTS */
  3    10 
  3    11 
  3    12 /* coded 5/75 by M. Weaver */
  3    13 /* changed 5/79 by G. Dixon to include entry_desc_info */
  3    14 
  3    15        dcl  1 parm_desc_ptrs		aligned based,
  3    16 	    2 n_args		fixed bin(18) unsigned unaligned,
  3    17 	    2 descriptor_relp (num_descs refer(parm_desc_ptrs.n_args))
  3    18 				bit(18) unaligned;
  3    19 
  3    20        dcl  num_descs		fixed bin(18);
  3    21 
  3    22        dcl  1 entry_sequence		aligned based,
  3    23 	  2 word1,
  3    24 	    3 descr_relp_offset	bit(18) unaligned,	/* offset of parm_desc_ptrs structure */
  3    25 	    3 reserved		bit(18) unaligned,
  3    26 	  2 word2,		
  3    27 	    3 def_relp		bit(18) unaligned,  /* offset of entry's definition       */
  3    28 	    3 flags		unaligned like entry_desc_info.flags,
  3    29 	  2 code_sequence		bit(36) aligned;
  3    30 
  4     1 /* START OF:	entry_desc_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3 	
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(84-11-29,Ranzenbach), approve(86-03-12,MCR7144),
  4     7*     audit(86-03-12,GWMay), install(86-05-01,MR12.0-1051):
  4     8*     for version 2. This version allows the caller to specify a pointer to
  4     9*     the beginning of the offset and its bit count. This allows the
  4    10*     processing of archive components.
  4    11*     
  4    12*     NOTICE:
  4    13*        All applications which use this structure should be converted to
  4    14*        use version 2.  Version 1 can be retained by setting the version to
  4    15*        a value of 1. The constant entry_desc_info_version_1 has been
  4    16*        removed from the file.
  4    17*                                                   END HISTORY COMMENTS */
  4    18 
  4    19 
  4    20 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    21 	/* 									*/
  4    22 	/* Name:  entry_desc_info.incl.pl1						*/
  4    23 	/* 									*/
  4    24 	/* This include file is used by get_entry_arg_desc_$info, $text_only_info and their	*/
  4    25 	/* callers.  It declares the flag bits obtained from the entry sequence of a procedure	*/
  4    26 	/* entry point.								*/
  4    27 	/* 									*/
  4    28 	/* Status									*/
  4    29 	/* 									*/
  4    30 	/* 0)  Created in May, 1979  by  G. C. Dixon					*/
  4    31 	/*									*/
  4    32 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    33 
  4    34      dcl	1 entry_desc_info		aligned based(entry_desc_info_ptr),
  4    35 	  2 version		fixed bin,	/* version number of this structure (= 2)	*/
  4    36 	  2 flags,
  4    37 
  4    38 	   (3 basic_indicator,			/* on if this is a BASIC program.		*/
  4    39 	    3 revision_1,				/* on if program entry has stuff added after 5/75 */
  4    40 	    3 has_descriptors,			/* on if entry point had valid parm. descriptors	*/
  4    41 	    3 variable,				/* on if entry point takes undefined no. of args	*/
  4    42 	    3 function)				/* on if entry point is a function		*/
  4    43 				bit(1) unaligned,
  4    44 	    3 pad			bit(13) unaligned,
  4    45 				                    /* version 2 fields follow                        */
  4    46 	  2 object_ptr		ptr,		/* -> beginning of object segment... (INPUT)	*/
  4    47 	  2 bit_count		fixed bin (24);	/* bit count of object... (INPUT)		*/
  4    48 
  4    49      dcl	entry_desc_info_version_2	fixed bin int static options(constant) init(2),
  4    50 	entry_desc_info_ptr		ptr;
  4    51 
  4    52 /* END OF:	entry_desc_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3    31 
  3    32 	
  3    33 /* END INCLUDE FILE ... entry_sequence_info.incl.pl1 */
       44 
       45 
  5     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  5     2*coded February 8, 1972 by Michael J. Spier	*/
  5     3 /* modified May 26, 1972 by M. Weaver */
  5     4 /* modified 15 April, 1975 by M. Weaver */
  5     5 
  5     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  5     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  5     8 	2 textp pointer,			/* pointer to beginning of text section */
  5     9 	2 defp pointer,			/* pointer to beginning of definition section */
  5    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  5    11 	2 statp pointer,			/* pointer to beginning of static section */
  5    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  5    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  5    14 	2 tlng fixed bin,			/* length in words of text section */
  5    15 	2 dlng fixed bin,			/* length in words of definition section */
  5    16 	2 llng fixed bin,			/* length in words of linkage section */
  5    17 	2 ilng fixed bin,			/* length in words of static section */
  5    18 	2 slng fixed bin,			/* length in words of symbol section */
  5    19 	2 blng fixed bin,			/* length in words of break map */
  5    20 	2 format,				/* word containing bit flags about object type */
  5    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  5    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  5    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  5    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  5    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  5    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  5    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  5    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  5    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  5    30 	  3 pad bit(27) unaligned,
  5    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  5    32 	2 textlinkp pointer,		/* ptr to first link in text */
  5    33 
  5    34 	/* LIMIT OF BRIEF STRUCTURE */
  5    35 
  5    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  5    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  5    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  5    39 	2 cvers aligned,			/* generator version name in printable char string form */
  5    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  5    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  5    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  5    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  5    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  5    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  5    46 
  5    47 	/* LIMIT OF DISPLAY STRUCTURE */
  5    48 
  5    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  5    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  5    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  5    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  5    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  5    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  5    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  5    56 					/* currently not used by system */
  5    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  5    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  5    59 
  5    60 declare	object_info_version_2 fixed bin int static init(2);
  5    61 
  5    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
       46 
       47 
  6     1 /* BEGIN INCLUDE FILE linus_set_fn_info.incl.pl1 -- jaw 6/16/77 
  6     2*
  6     3*   81-10-26  Rickie E.  Brinegar: Changed the entry pointer to entry variables
  6     4*   and  added  bits to define whether or not the entry variables had been set.
  6     5*   Renamed the structure from set_fn_info to linus_set_fn_info and the pointer
  6     6*   that it was based on from setfi_ptr to linus_set_fn_info_ptr.
  6     7*
  6     8*   81-11-05 Rickie E.  Brinegar: Changed the entry pointers to entry variables
  6     9*   and  added bit switches to determine when the entries have or have not been
  6    10*   set.  Renamed the set_fn_info structure to linus_set_fn_info, the setfi_ptr
  6    11*   to      linus_set_fn_info_ptr,      and      nset_fn_info_init_args      to
  6    12*   initial_number_of_set_fn_info_args.
  6    13*      
  6    14**/
  6    15 
  6    16 dcl 1 linus_set_fn_info aligned based (linus_set_fn_info_ptr),
  6    17                                                           	/* set function info block */
  6    18     2 fwd_ptr ptr,					/* pointer too next function in list */
  6    19     2 name char (32),				/* name of function */
  6    20     2 assign_entry entry variable,			/* pointer to assign entry */
  6    21     2 calc_entry entry variable,			/* pointer to calc entry */
  6    22     2 info_entry entry variable,			/* pointer to info entry, if var. fun. */
  6    23     2 init_entry entry variable,			/* pointer to initialization entry */
  6    24     2 flags,
  6    25       3 assign_entry_set bit (1) unaligned,                 /* 0 => null, 1 => not null */
  6    26       3 calc_entry_set bit (1) unaligned,                   /* 0 => null, 1 => not null */
  6    27       3 info_entry_set bit (1) unaligned,                   /* 0 => null, 1 => not null */
  6    28       3 init_entry_set bit (1) unaligned,                   /* 0 => null, 1 => not null */
  6    29       3 pad_bits bit (32) unaligned,
  6    30     2 rslt_desc bit (36),				/* descriptor of result of fixed fun */
  6    31     2 nargs fixed bin,				/* no of input args of calc entry */
  6    32     2 arg_desc (initial_number_of_set_fn_info_args refer (linus_set_fn_info.nargs)) bit (36); /* descriptor
  6    33*                                                               for each input arg */
  6    34 
  6    35 dcl  linus_set_fn_info_ptr ptr;
  6    36 dcl  initial_number_of_set_fn_info_args fixed bin;
  6    37 
  6    38 /* END INCLUDE FILE linus_set_fn_info.incl.pl1 */
       48 
       49 
       50 	dcl     (
       51 	        b_ptr,				/* pointer to base of object */
       52 	        d_ptr,				/* ptr to definition block */
       53 	        e_ptr,				/* pointer to entry sequence */
       54 	        pd_ptr,				/* pointer to parameter descriptor offsets */
       55 	        s_ptr
       56 	        )			 ptr;		/* pointer to seg. definition block */
       57 
       58 	dcl     calc_entry		 entry variable;	/* Input: snapped calc entry in object */
       59 	dcl     i			 fixed bin;	/* internal index */
       60 
       61 	dcl     (
       62 	        code,				/* Output: status code */
       63 	        icode
       64 	        )			 fixed bin (35);	/* internal status code */
       65 
       66 	dcl     function_name	 char (32) var;
       67 	dcl     (file_name, input_file_name) char (168) varying; /* where to look for the function */
       68 	dcl     1 obj_info		 aligned like object_info; /* place for object information */
       69 	dcl     bc		 fixed bin (24);	/* bit count of object seg */
       70 	dcl     stype		 fixed bin (2);	/* type code of object seg */
       71 	dcl     1 acc		 aligned based,	/* template for acc string */
       72 		2 len		 fixed bin (8) unal,
       73 		2 string		 char (0 refer (acc.len)) unal;
       74 	dcl     bit36		 bit (36) based;	/* template for descriptor */
       75 
       76 	dcl     (
       77 	        linus_error_$cant_ref_fun,
       78 	        linus_error_$incons_fun,
       79 	        sys_info$max_seg_size
       80 	        )			 ext fixed bin (35);
       81 
       82 	dcl     cleanup		 condition;
       83 
       84 	dcl     (addr, addrel, codeptr, fixed, null, ptr, rel, string) builtin;
       85 
       86 	dcl     cv_entry_		 entry (char (*), ptr, fixed bin (35)) returns (entry);
       87 	dcl     hcs_$status_mins
       88 				 entry (ptr, fixed bin (2), fixed bin (24), fixed bin (35));
       89 	dcl     object_info_$brief	 entry (ptr, fixed bin (24), ptr, fixed bin (35));
       90 
       91 	linus_set_fn_info_ptr = null;			/* initiallize */
       92 
       93 	on cleanup call tidy_up;
       94 
       95 	file_name = input_file_name || "$";
       96 
       97 	b_ptr = ptr (codeptr (calc_entry), 0);		/* point to base of object */
       98 	call hcs_$status_mins (b_ptr, stype, bc, icode);	/* get bit count of object */
       99 	if icode ^= 0 then
      100 	     call error (linus_error_$cant_ref_fun);
      101 	call object_info_$brief (b_ptr, bc, addr (obj_info), icode);
      102 						/* get info on obj seg */
      103 	if icode ^= 0 then
      104 	     call error (linus_error_$cant_ref_fun);
      105 	e_ptr = addrel (codeptr (calc_entry), -2);	/* point to entry sequence */
      106 	if e_ptr -> entry_sequence.flags.has_descriptors then do;
      107 						/* if have args */
      108 		pd_ptr =
      109 		     addrel (obj_info.textp, e_ptr -> entry_sequence.descr_relp_offset);
      110 						/* point to parameter descriptors */
      111 		initial_number_of_set_fn_info_args =
      112 		     fixed (pd_ptr -> parm_desc_ptrs.n_args); /* no. input args */
      113 	     end;
      114 	else initial_number_of_set_fn_info_args = 0;
      115 	alloc linus_set_fn_info in (lcb.static_area);	/* alloc. an info block */
      116 	string (linus_set_fn_info.flags) = "0"b;	/* fill in the block */
      117 	linus_set_fn_info.fwd_ptr = lcb.setfi_ptr;
      118 	linus_set_fn_info.calc_entry = calc_entry;
      119 	linus_set_fn_info.calc_entry_set = "1"b;
      120 
      121 	d_ptr = addrel (obj_info.defp, e_ptr -> entry_sequence.def_relp);
      122 						/* point to def. block */
      123 	linus_set_fn_info.name = function_name;
      124 
      125 	s_ptr = addrel (obj_info.defp, d_ptr -> definition.segname);
      126 						/* point to def. block for seg. */
      127 
      128 	linus_set_fn_info.assign_entry =
      129 	     cv_entry_ (file_name || function_name || "_assign", null, icode);
      130 						/* set up assignment entry */
      131 	if icode ^= 0 then
      132 	     call error (icode);
      133 	linus_set_fn_info.assign_entry_set = "1"b;
      134 
      135 	if lcb.db_index ^= 0 & ^lcb.new_version then
      136 	     linus_set_fn_info.init_entry_set = "0"b;
      137 	else do;
      138 		linus_set_fn_info.init_entry =
      139 		     cv_entry_ (file_name || function_name || "_init", null, icode);
      140 						/* set up initial entry */
      141 		if icode ^= 0 then
      142 		     call error (icode);
      143 		linus_set_fn_info.init_entry_set = "1"b;
      144 
      145 	     end;
      146 
      147 	if e_ptr -> entry_sequence.flags.has_descriptors then do;
      148 						/* if fixed input */
      149 		linus_set_fn_info.info_entry_set = "0"b;/* no info entry in this case */
      150 		do i = 1 to linus_set_fn_info.nargs;	/* fill in input descriptors */
      151 		     linus_set_fn_info.arg_desc (i) =
      152 			addrel (obj_info.textp,
      153 			pd_ptr -> parm_desc_ptrs.descriptor_relp (i)) -> bit36;
      154 		end;
      155 		e_ptr = addrel (codeptr (linus_set_fn_info.assign_entry), -2);
      156 						/* entry seq. for assign ent. */
      157 		if e_ptr -> entry_sequence.flags.has_descriptors then
      158 		     /* get ptr to rslt descr. */
      159 		     pd_ptr =
      160 			addrel (obj_info.textp,
      161 			e_ptr -> entry_sequence.descr_relp_offset);
      162 		else call error (linus_error_$incons_fun);
      163 		linus_set_fn_info.rslt_desc =
      164 		     addrel (obj_info.textp,
      165 		     pd_ptr -> parm_desc_ptrs.descriptor_relp (1)) -> bit36;
      166 	     end;					/* if fixed args */
      167 
      168 	else do;					/* no descriptors, variable args */
      169 		linus_set_fn_info.rslt_desc = "0"b;
      170 		linus_set_fn_info.nargs = 0;
      171 		linus_set_fn_info.info_entry =
      172 		     cv_entry_ (file_name || function_name || "_info", null, icode);
      173 		if icode ^= 0 then
      174 		     call error (linus_error_$cant_ref_fun);
      175 		linus_set_fn_info.info_entry_set = "1"b;
      176 	     end;					/* if variable args */
      177 
      178 	lcb.setfi_ptr = linus_set_fn_info_ptr;		/* put block at head of list */
      179 	code = 0;
      180 exit:
      181 	return;
      182 
      183 error:
      184      proc (cd);
      185 
      186 /* error procedure */
      187 
      188 	dcl     cd		 fixed bin (35);
      189 
      190 	code = cd;
      191 	call tidy_up;
      192 	go to exit;
      193 
      194      end error;
      195 
      196 tidy_up:
      197      proc;
      198 
      199 /* Procedure to clean up our mess */
      200 
      201 	if setfi_ptr ^= null & setfi_ptr ^= lcb.setfi_ptr then
      202 	     free linus_set_fn_info;
      203 
      204      end tidy_up;
      205 
      206      end linus_thread_fn_list;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/20/86  1145.0  linus_thread_fn_list.pl1          >special_ldd>install>MR12.0-1222>linus_thread_fn_list.pl1
40           1    07/29/86  1148.4  linus_lcb.incl.pl1                >ldd>include>linus_lcb.incl.pl1
42           2    11/20/86  1035.2  definition.incl.pl1               >special_ldd>install>MR12.0-1222>definition.incl.pl1
44           3    05/01/86  0849.8  entry_sequence_info.incl.pl1      >ldd>include>entry_sequence_info.incl.pl1
3-31         4    05/01/86  0849.8  entry_desc_info.incl.pl1          >ldd>include>entry_desc_info.incl.pl1
46           5    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
48           6    11/23/82  1327.2  linus_set_fn_info.incl.pl1        >ldd>include>linus_set_fn_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 84 ref 101 101
addrel                                                 builtin function         dcl 84 ref 105 108 121 125 151 155 157 163
arg_desc                 35            based           bit(36)                  array level 2 dcl 6-16 set ref 151*
assign_entry             12            based           entry variable           level 2 dcl 6-16 set ref 128* 155
assign_entry_set         32            based           bit(1)                   level 3 packed unaligned dcl 6-16 set ref 133*
b_ptr                           000104 automatic       pointer                  dcl 50 set ref 97* 98* 101*
bc                              000262 automatic       fixed bin(24,0)          dcl 69 set ref 98* 101*
bit36                                  based           bit(36)                  unaligned dcl 74 ref 151 163
calc_entry               16            based           entry variable           level 2 in structure "linus_set_fn_info" dcl 6-16
                                                                                  in procedure "linus_thread_fn_list" set ref 118*
calc_entry                             parameter       entry variable           dcl 58 in procedure "linus_thread_fn_list" ref 18 97
                                                                                  105 118
calc_entry_set           32(01)        based           bit(1)                   level 3 packed unaligned dcl 6-16 set ref 119*
cd                                     parameter       fixed bin(35,0)          dcl 188 ref 183 190
cleanup                         000264 stack reference condition                dcl 82 ref 93
code                                   parameter       fixed bin(35,0)          dcl 61 set ref 18 179* 190*
codeptr                                                builtin function         dcl 84 ref 97 105 155
cv_entry_                       000014 constant        entry                    external dcl 86 ref 128 138 171
d_ptr                           000106 automatic       pointer                  dcl 50 set ref 121* 125
db_index                               based           fixed bin(35,0)          level 2 dcl 1-53 ref 135
def_relp                  1            based           bit(18)                  level 3 packed unaligned dcl 3-22 ref 121
definition                             based           structure                level 1 dcl 2-12
defp                      4     000174 automatic       pointer                  level 2 dcl 68 set ref 121 125
descr_relp_offset                      based           bit(18)                  level 3 packed unaligned dcl 3-22 ref 108 157
descriptor_relp           0(18)        based           bit(18)                  array level 2 packed unaligned dcl 3-15 ref 151 163
e_ptr                           000110 automatic       pointer                  dcl 50 set ref 105* 106 108 121 147 155* 157 157
entry_desc_info                        based           structure                level 1 dcl 4-34
entry_sequence                         based           structure                level 1 dcl 3-22
file_name                       000120 automatic       varying char(168)        dcl 67 set ref 95* 128 138 171
fixed                                                  builtin function         dcl 84 ref 111
flags                     1(18)        based           structure                level 3 in structure "entry_sequence" packed
                                                                                  unaligned dcl 3-22 in procedure
                                                                                  "linus_thread_fn_list"
flags                     1            based           structure                level 2 in structure "entry_desc_info" dcl 4-34
                                                                                  in procedure "linus_thread_fn_list"
flags                    32            based           structure                level 2 in structure "linus_set_fn_info" dcl 6-16
                                                                                  in procedure "linus_thread_fn_list" set ref 116*
function_name                          parameter       varying char(32)         dcl 66 ref 18 123 128 138 171
fwd_ptr                                based           pointer                  level 2 dcl 6-16 set ref 117*
has_descriptors           1(20)        based           bit(1)                   level 4 packed unaligned dcl 3-22 ref 106 147 157
hcs_$status_mins                000016 constant        entry                    external dcl 87 ref 98
i                               000116 automatic       fixed bin(17,0)          dcl 59 set ref 150* 151 151*
icode                           000117 automatic       fixed bin(35,0)          dcl 61 set ref 98* 99 101* 103 128* 131 131* 138*
                                                                                  141 141* 171* 173
info_entry               22            based           entry variable           level 2 dcl 6-16 set ref 171*
info_entry_set           32(02)        based           bit(1)                   level 3 packed unaligned dcl 6-16 set ref 149* 175*
init_entry               26            based           entry variable           level 2 dcl 6-16 set ref 138*
init_entry_set           32(03)        based           bit(1)                   level 3 packed unaligned dcl 6-16 set ref 135* 143*
initial_number_of_set_fn_info_args
                                000102 automatic       fixed bin(17,0)          dcl 6-36 set ref 111* 114* 115 115
input_file_name                        parameter       varying char(168)        dcl 67 ref 18 95
lcb                                    based           structure                level 1 dcl 1-53
lcb_ptr                                parameter       pointer                  dcl 1-121 ref 18 115 117 135 135 178 201 201 201
linus_error_$cant_ref_fun       000010 external static fixed bin(35,0)          dcl 76 set ref 99* 103* 173*
linus_error_$incons_fun         000012 external static fixed bin(35,0)          dcl 76 set ref 162*
linus_set_fn_info                      based           structure                level 1 dcl 6-16 set ref 115 201
linus_set_fn_info_ptr           000100 automatic       pointer                  dcl 6-35 set ref 91* 115* 116 117 118 119 123 128
                                                                                  133 135 138 143 149 150 151 155 163 169 170 171
                                                                                  175 178 201
n_args                                 based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 3-15 ref 111
name                      2            based           char(32)                 level 2 dcl 6-16 set ref 123*
nargs                    34            based           fixed bin(17,0)          level 2 dcl 6-16 set ref 115* 150 170* 201
new_version              15(02)        based           bit(1)                   initial level 2 packed unaligned dcl 1-53 ref 135
null                                                   builtin function         dcl 84 ref 91 128 128 138 138 171 171 201
obj_info                        000174 automatic       structure                level 1 dcl 68 set ref 101 101
object_info                            based           structure                level 1 dcl 5-6
object_info_$brief              000020 constant        entry                    external dcl 89 ref 101
parm_desc_ptrs                         based           structure                level 1 dcl 3-15
pd_ptr                          000112 automatic       pointer                  dcl 50 set ref 108* 111 151 157* 163
ptr                                                    builtin function         dcl 84 ref 97
rslt_desc                33            based           bit(36)                  level 2 dcl 6-16 set ref 163* 169*
s_ptr                           000114 automatic       pointer                  dcl 50 set ref 125*
segname                   2(18)        based           bit(18)                  level 2 packed unaligned dcl 2-12 ref 125
setfi_ptr                36            based           pointer                  level 2 dcl 1-53 set ref 117 178* 201 201 201
static_area             144            based           area                     level 2 dcl 1-53 ref 115
string                                                 builtin function         dcl 84 set ref 116*
stype                           000263 automatic       fixed bin(2,0)           dcl 70 set ref 98*
textp                     2     000174 automatic       pointer                  level 2 dcl 68 set ref 108 151 157 163
word1                                  based           structure                level 2 dcl 3-22
word2                     1            based           structure                level 2 dcl 3-22

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
acc                                    based           structure                level 1 dcl 71
entry_desc_info_ptr                    automatic       pointer                  dcl 4-49
entry_desc_info_version_2              internal static fixed bin(17,0)          initial dcl 4-49
num_descs                              automatic       fixed bin(18,0)          dcl 3-20
object_info_version_2                  internal static fixed bin(17,0)          initial dcl 5-60
rel                                                    builtin function         dcl 84
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 76

NAMES DECLARED BY EXPLICIT CONTEXT.
error                           000655 constant        entry                    internal dcl 183 ref 99 103 131 141 162 173
exit                            000654 constant        label                    dcl 180 ref 192
linus_thread_fn_list            000025 constant        entry                    external dcl 18
tidy_up                         000670 constant        entry                    internal dcl 196 ref 93 191

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1042        1064     727        1052
Length      1376     727        22         276     112           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
linus_thread_fn_list                236 external procedure  is an external procedure.  
on unit on line 93                   64 on unit               
error                                   internal procedure  shares stack frame of external procedure linus_thread_fn_list.  
tidy_up                              64 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
linus_thread_fn_list     000100 linus_set_fn_info_ptr       linus_thread_fn_list
                         000102 initial_number_of_set_fn_info_args
                                                            linus_thread_fn_list
                         000104 b_ptr                       linus_thread_fn_list
                         000106 d_ptr                       linus_thread_fn_list
                         000110 e_ptr                       linus_thread_fn_list
                         000112 pd_ptr                      linus_thread_fn_list
                         000114 s_ptr                       linus_thread_fn_list
                         000116 i                           linus_thread_fn_list
                         000117 icode                       linus_thread_fn_list
                         000120 file_name                   linus_thread_fn_list
                         000174 obj_info                    linus_thread_fn_list
                         000262 bc                          linus_thread_fn_list
                         000263 stype                       linus_thread_fn_list

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          enable_op           shorten_stack       ext_entry           int_entry           op_alloc_
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cv_entry_                     hcs_$status_mins              object_info_$brief

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
linus_error_$cant_ref_fun     linus_error_$incons_fun


CONSTANTS
000717  aa     677777777777

000720  aa     737777777777

000722  aa     000002000000
000723  aa     000000000000
000724  aa     600000000041
000725  aa     000117000000

000000  aa     524000000000

000726  aa  044 000 000 000	$

000001  aa     530000000250

000002  aa     530000000040

000003  aa     404000000043

000004  aa     500000000000

000005  aa     464000000000

000006  aa  137 151 156 146	_inf
000007  aa  157 000 000 000	o

000010  aa  137 151 156 151	_ini
000011  aa  164 000 000 000	t

000012  aa  137 141 163 163	_ass
000013  aa  151 147 156 000	ign

000014  aa     077777000043
000015  aa     000001000000

000016  aa  143 154 145 141	clea
000017  aa  156 165 160 000	nup

BEGIN PROCEDURE linus_thread_fn_list
ENTRY TO linus_thread_fn_list                               STATEMENT 1 ON LINE 18
linus_thread_fn_list:
     proc (lcb_ptr, calc_entry, input_file_name, function_name, code);

000020  at     000005000005
000021  tt     000004000001
000022  tt     000002000003
000023  ta     000020000000
000024  da     000073300000
000025  aa   000360 6270 00	eax7 	240
000026  aa  7 00034 3521 20	epp2 	pr7|28,*
000027  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000030  aa     000012000000
000031  aa     000000000000
						STATEMENT 1 ON LINE 91
	linus_set_fn_info_ptr = null;

000032  aa   777762 2370 04	ldaq 	-14,ic		000014 = 077777000043 000001000000
000033  aa  6 00100 7571 00	staq 	pr6|64		linus_set_fn_info_ptr
						STATEMENT 1 ON LINE 93
	on cleanup call tidy_up;

000034  aa   000007 7260 07	lxl6 	7,dl
000035  aa   777761 3520 04	epp2 	-15,ic		000016 = 143154145141
000036  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
000037  aa   000004 7100 04	tra  	4,ic		000043
000040  aa     000264000000
000041  aa   000015 7100 04	tra  	13,ic		000056
BEGIN CONDITION cleanup.1
ENTRY TO cleanup.1                                          STATEMENT 1 ON LINE 93
	on cleanup call tidy_up;

000042  da     000101200000
000043  aa   000100 6270 00	eax7 	64
000044  aa  7 00034 3521 20	epp2 	pr7|28,*
000045  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000046  aa     000000000000
000047  aa     000000000000
000050  aa   000001 7270 07	lxl7 	1,dl
000051  aa  6 00056 6211 00	eax1 	pr6|46
000052  aa   000000 4310 07	fld  	0,dl
000053  aa   000615 3520 04	epp2 	397,ic		000670 = 000100627000
000054  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
000055  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.1
						STATEMENT 1 ON LINE 95
	file_name = input_file_name || "$";

000056  aa  6 00032 3735 20	epp7 	pr6|26,*
000057  aa  7 00006 3715 20	epp5 	pr7|6,*
000060  aa  5 77777 2361 00	ldq  	pr5|-1		input_file_name
000061  aa   000001 0760 07	adq  	1,dl
000062  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
000063  aa  5 77777 7271 00	lxl7 	pr5|-1		input_file_name
000064  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000065  aa  5 00000 00 0017	desc9a	pr5|0,x7		input_file_name
000066  aa  2 00000 00 0017	desc9a	pr2|0,x7
000067  aa  5 77777 7271 00	lxl7 	pr5|-1		input_file_name
000070  aa  040 117 100 404	mlr  	(ic),(pr,x7),fill(040)
000071  aa   000636 00 0001	desc9a	414,1		000726 = 044000000000
000072  aa  2 00000 00 0001	desc9a	pr2|0,1
000073  aa   000250 1160 07	cmpq 	168,dl
000074  aa   000002 6040 04	tmi  	2,ic		000076
000075  aa   000250 2360 07	ldq  	168,dl
000076  aa  6 00120 7561 00	stq  	pr6|80		file_name
000077  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000100  aa  2 00000 00 0006	desc9a	pr2|0,ql
000101  aa  6 00121 00 0006	desc9a	pr6|81,ql		file_name
						STATEMENT 1 ON LINE 97
	b_ptr = ptr (codeptr (calc_entry), 0);

000102  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000103  aa  7 00004 3521 20	epp2 	pr7|4,*		calc_entry
000104  aa  2 00000 3521 20	epp2 	pr2|0,*		calc_entry
000105  aa  2 00000 3511 00	epbp1	pr2|0
000106  aa  6 00104 2515 00	spri1	pr6|68		b_ptr
						STATEMENT 1 ON LINE 98
	call hcs_$status_mins (b_ptr, stype, bc, icode);

000107  aa  6 00314 2521 00	spri2	pr6|204
000110  aa  6 00104 3521 00	epp2 	pr6|68		b_ptr
000111  aa  6 00304 2521 00	spri2	pr6|196
000112  aa  6 00263 3521 00	epp2 	pr6|179		stype
000113  aa  6 00306 2521 00	spri2	pr6|198
000114  aa  6 00262 3521 00	epp2 	pr6|178		bc
000115  aa  6 00310 2521 00	spri2	pr6|200
000116  aa  6 00117 3521 00	epp2 	pr6|79		icode
000117  aa  6 00312 2521 00	spri2	pr6|202
000120  aa  6 00302 6211 00	eax1 	pr6|194
000121  aa   020000 4310 07	fld  	8192,dl
000122  aa  6 00044 3701 20	epp4 	pr6|36,*
000123  la  4 00016 3521 20	epp2 	pr4|14,*		hcs_$status_mins
000124  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 99
	if icode ^= 0 then
	     call error (linus_error_$cant_ref_fun);

000125  aa  6 00117 2361 00	ldq  	pr6|79		icode
000126  aa   000010 6000 04	tze  	8,ic		000136
000127  aa  6 00044 3701 20	epp4 	pr6|36,*
000130  la  4 00010 3521 20	epp2 	pr4|8,*		linus_error_$cant_ref_fun
000131  aa  6 00304 2521 00	spri2	pr6|196
000132  aa  6 00302 3521 00	epp2 	pr6|194
000133  aa   004000 4310 07	fld  	2048,dl
000134  aa  2 00000 7571 00	staq 	pr2|0
000135  aa   000520 6700 04	tsp4 	336,ic		000655
						STATEMENT 1 ON LINE 101
	call object_info_$brief (b_ptr, bc, addr (obj_info), icode);

000136  aa  6 00174 3735 00	epp7 	pr6|124		obj_info
000137  aa  6 00316 6535 00	spri7	pr6|206
000140  aa  6 00104 3521 00	epp2 	pr6|68		b_ptr
000141  aa  6 00304 2521 00	spri2	pr6|196
000142  aa  6 00262 3521 00	epp2 	pr6|178		bc
000143  aa  6 00306 2521 00	spri2	pr6|198
000144  aa  6 00316 3521 00	epp2 	pr6|206
000145  aa  6 00310 2521 00	spri2	pr6|200
000146  aa  6 00117 3521 00	epp2 	pr6|79		icode
000147  aa  6 00312 2521 00	spri2	pr6|202
000150  aa  6 00302 6211 00	eax1 	pr6|194
000151  aa   020000 4310 07	fld  	8192,dl
000152  aa  6 00044 3701 20	epp4 	pr6|36,*
000153  la  4 00020 3521 20	epp2 	pr4|16,*		object_info_$brief
000154  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 103
	if icode ^= 0 then
	     call error (linus_error_$cant_ref_fun);

000155  aa  6 00117 2361 00	ldq  	pr6|79		icode
000156  aa   000010 6000 04	tze  	8,ic		000166
000157  aa  6 00044 3701 20	epp4 	pr6|36,*
000160  la  4 00010 3521 20	epp2 	pr4|8,*		linus_error_$cant_ref_fun
000161  aa  6 00304 2521 00	spri2	pr6|196
000162  aa  6 00302 3521 00	epp2 	pr6|194
000163  aa   004000 4310 07	fld  	2048,dl
000164  aa  2 00000 7571 00	staq 	pr2|0
000165  aa   000470 6700 04	tsp4 	312,ic		000655
						STATEMENT 1 ON LINE 105
	e_ptr = addrel (codeptr (calc_entry), -2);

000166  aa  6 00032 3735 20	epp7 	pr6|26,*
000167  aa  7 00004 3521 20	epp2 	pr7|4,*		calc_entry
000170  aa  2 00000 3521 20	epp2 	pr2|0,*		calc_entry
000171  aa  2 00000 3515 00	epp1 	pr2|0
000172  aa   777776 0510 03	adwp1	262142,du
000173  aa  6 00110 2515 00	spri1	pr6|72		e_ptr
						STATEMENT 1 ON LINE 106
	if e_ptr -> entry_sequence.flags.has_descriptors then do;

000174  aa  1 00001 2351 00	lda  	pr1|1		entry_sequence.has_descriptors
000175  aa   100000 3150 07	cana 	32768,dl
000176  aa  6 00316 2521 00	spri2	pr6|206
000177  aa   000012 6000 04	tze  	10,ic		000211
						STATEMENT 1 ON LINE 108
		pd_ptr =
		     addrel (obj_info.textp, e_ptr -> entry_sequence.descr_relp_offset);

000200  aa  1 00000 2351 00	lda  	pr1|0		entry_sequence.descr_relp_offset
000201  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000202  aa  6 00176 3535 61	epp3 	pr6|126,*au	obj_info.textp
000203  aa   000000 0530 03	adwp3	0,du
000204  aa  6 00112 2535 00	spri3	pr6|74		pd_ptr
						STATEMENT 1 ON LINE 111
		initial_number_of_set_fn_info_args =
		     fixed (pd_ptr -> parm_desc_ptrs.n_args);

000205  aa  3 00000 2351 00	lda  	pr3|0		parm_desc_ptrs.n_args
000206  aa   000066 7730 00	lrl  	54
000207  aa  6 00102 7561 00	stq  	pr6|66		initial_number_of_set_fn_info_args
						STATEMENT 1 ON LINE 113
	     end;

000210  aa   000002 7100 04	tra  	2,ic		000212
						STATEMENT 1 ON LINE 114
	else initial_number_of_set_fn_info_args = 0;

000211  aa  6 00102 4501 00	stz  	pr6|66		initial_number_of_set_fn_info_args
						STATEMENT 1 ON LINE 115
	alloc linus_set_fn_info in (lcb.static_area);

000212  aa  6 00102 2361 00	ldq  	pr6|66		initial_number_of_set_fn_info_args
000213  aa   000035 0760 07	adq  	29,dl
000214  aa  6 00032 3735 20	epp7 	pr6|26,*
000215  aa  7 00002 3715 20	epp5 	pr7|2,*		lcb_ptr
000216  aa  5 00000 3715 20	epp5 	pr5|0,*		lcb_ptr
000217  aa  5 00144 3521 00	epp2 	pr5|100		lcb.static_area
000220  aa  0 01402 7001 00	tsx0 	pr0|770		op_alloc_
000221  aa   777771 7100 04	tra  	-7,ic		000212
000222  aa  6 00100 2521 00	spri2	pr6|64		linus_set_fn_info_ptr
000223  aa  6 00102 2361 00	ldq  	pr6|66		initial_number_of_set_fn_info_args
000224  aa  2 00034 7561 00	stq  	pr2|28		linus_set_fn_info.nargs
						STATEMENT 1 ON LINE 116
	string (linus_set_fn_info.flags) = "0"b;

000225  aa  2 00032 4501 00	stz  	pr2|26
						STATEMENT 1 ON LINE 117
	linus_set_fn_info.fwd_ptr = lcb.setfi_ptr;

000226  aa  6 00032 3735 20	epp7 	pr6|26,*
000227  aa  7 00002 3715 20	epp5 	pr7|2,*		lcb_ptr
000230  aa  5 00000 3715 20	epp5 	pr5|0,*		lcb_ptr
000231  aa  5 00036 3535 20	epp3 	pr5|30,*		lcb.setfi_ptr
000232  aa  2 00000 2535 00	spri3	pr2|0		linus_set_fn_info.fwd_ptr
						STATEMENT 1 ON LINE 118
	linus_set_fn_info.calc_entry = calc_entry;

000233  aa  6 00100 3515 20	epp1 	pr6|64,*		linus_set_fn_info_ptr
000234  aa  7 00004 3535 20	epp3 	pr7|4,*
000235  aa  3 00000 3521 20	epp2 	pr3|0,*		calc_entry
000236  aa  1 00016 2521 00	spri2	pr1|14		linus_set_fn_info.calc_entry
000237  aa  3 00002 3521 20	epp2 	pr3|2,*		calc_entry
000240  aa  1 00020 2521 00	spri2	pr1|16		linus_set_fn_info.calc_entry
						STATEMENT 1 ON LINE 119
	linus_set_fn_info.calc_entry_set = "1"b;

000241  aa   200000 2350 03	lda  	65536,du
000242  aa  1 00032 2551 00	orsa 	pr1|26		linus_set_fn_info.calc_entry_set
						STATEMENT 1 ON LINE 121
	d_ptr = addrel (obj_info.defp, e_ptr -> entry_sequence.def_relp);

000243  aa  6 00110 3715 20	epp5 	pr6|72,*		e_ptr
000244  aa  5 00001 2351 00	lda  	pr5|1		entry_sequence.def_relp
000245  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000246  aa  6 00200 3521 61	epp2 	pr6|128,*au	obj_info.defp
000247  aa   000000 0520 03	adwp2	0,du
000250  aa  6 00106 2521 00	spri2	pr6|70		d_ptr
						STATEMENT 1 ON LINE 123
	linus_set_fn_info.name = function_name;

000251  aa  7 00010 3535 20	epp3 	pr7|8,*
000252  aa  3 77777 7271 00	lxl7 	pr3|-1		function_name
000253  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000254  aa  3 00000 00 0017	desc9a	pr3|0,x7		function_name
000255  aa  1 00002 00 0040	desc9a	pr1|2,32		linus_set_fn_info.name
						STATEMENT 1 ON LINE 125
	s_ptr = addrel (obj_info.defp, d_ptr -> definition.segname);

000256  aa  2 00002 2351 00	lda  	pr2|2		definition.segname
000257  aa   000022 7350 00	als  	18
000260  aa  6 00200 3521 61	epp2 	pr6|128,*au	obj_info.defp
000261  aa   000000 0520 03	adwp2	0,du
000262  aa  6 00114 2521 00	spri2	pr6|76		s_ptr
						STATEMENT 1 ON LINE 128
	linus_set_fn_info.assign_entry =
	     cv_entry_ (file_name || function_name || "_assign", null, icode);

000263  aa  6 00120 2361 00	ldq  	pr6|80		file_name
000264  aa  3 77777 0761 00	adq  	pr3|-1		function_name
000265  aa  6 00321 7561 00	stq  	pr6|209
000266  aa   000007 0760 07	adq  	7,dl
000267  aa  6 00322 7561 00	stq  	pr6|210
000270  aa   524000 2760 03	orq  	174080,du
000271  aa  6 00320 7561 00	stq  	pr6|208
000272  aa  6 00321 2361 00	ldq  	pr6|209
000273  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
000274  aa  6 00120 7271 00	lxl7 	pr6|80		file_name
000275  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000276  aa  6 00121 00 0017	desc9a	pr6|81,x7		file_name
000277  aa  2 00000 00 0017	desc9a	pr2|0,x7
000300  aa  6 00120 7271 00	lxl7 	pr6|80		file_name
000301  aa  3 77777 7261 00	lxl6 	pr3|-1		function_name
000302  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
000303  aa  3 00000 00 0016	desc9a	pr3|0,x6		function_name
000304  aa  2 00000 00 0016	desc9a	pr2|0,x6
000305  aa  6 00322 2361 00	ldq  	pr6|210
000306  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
000307  aa  6 00321 2351 00	lda  	pr6|209
000310  aa  040 105 100 404	mlr  	(ic),(pr,al),fill(040)
000311  aa   777502 00 0007	desc9a	-190,7		000012 = 137141163163
000312  aa  2 00000 00 0007	desc9a	pr2|0,7
000313  aa  6 00332 2521 00	spri2	pr6|218
000314  aa   777500 3714 24	epp5 	-192,ic*
000315  aa  6 00326 6515 00	spri5	pr6|214
000316  aa  6 00326 3521 00	epp2 	pr6|214
000317  aa  6 00334 2521 00	spri2	pr6|220
000320  aa  6 00117 3521 00	epp2 	pr6|79		icode
000321  aa  6 00336 2521 00	spri2	pr6|222
000322  aa  1 00012 3521 00	epp2 	pr1|10		linus_set_fn_info.assign_entry
000323  aa  6 00340 2521 00	spri2	pr6|224
000324  aa  6 00320 3521 00	epp2 	pr6|208
000325  aa  6 00342 2521 00	spri2	pr6|226
000326  aa   777457 3520 04	epp2 	-209,ic		000005 = 464000000000
000327  aa  6 00344 2521 00	spri2	pr6|228
000330  aa   777453 3520 04	epp2 	-213,ic		000003 = 404000000043
000331  aa  6 00346 2521 00	spri2	pr6|230
000332  aa   777452 3520 04	epp2 	-214,ic		000004 = 500000000000
000333  aa  6 00350 2521 00	spri2	pr6|232
000334  aa  6 00330 6211 00	eax1 	pr6|216
000335  aa   020000 4310 07	fld  	8192,dl
000336  aa  6 00044 3701 20	epp4 	pr6|36,*
000337  la  4 00014 3521 20	epp2 	pr4|12,*		cv_entry_
000340  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 131
	if icode ^= 0 then
	     call error (icode);

000341  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000342  aa  6 00117 2361 00	ldq  	pr6|79		icode
000343  aa   000003 6000 04	tze  	3,ic		000346
000344  aa   000356 3520 04	epp2 	238,ic		000722 = 000002000000
000345  aa   000310 6700 04	tsp4 	200,ic		000655
						STATEMENT 1 ON LINE 133
	linus_set_fn_info.assign_entry_set = "1"b;

000346  aa   400000 2350 03	lda  	131072,du
000347  aa  6 00100 3735 20	epp7 	pr6|64,*		linus_set_fn_info_ptr
000350  aa  7 00032 2551 00	orsa 	pr7|26		linus_set_fn_info.assign_entry_set
						STATEMENT 1 ON LINE 135
	if lcb.db_index ^= 0 & ^lcb.new_version then
	     linus_set_fn_info.init_entry_set = "0"b;

000351  aa  6 00032 3715 20	epp5 	pr6|26,*
000352  aa  5 00002 3535 20	epp3 	pr5|2,*		lcb_ptr
000353  aa  3 00000 2361 20	ldq  	pr3|0,*		lcb.db_index
000354  aa   000010 6000 04	tze  	8,ic		000364
000355  aa  3 00000 3515 20	epp1 	pr3|0,*		lcb_ptr
000356  aa  1 00015 2351 00	lda  	pr1|13		lcb.new_version
000357  aa   100000 3150 03	cana 	32768,du
000360  aa   000004 6010 04	tnz  	4,ic		000364
000361  aa   000337 2350 04	lda  	223,ic		000720 = 737777777777
000362  aa  7 00032 3551 00	ansa 	pr7|26		linus_set_fn_info.init_entry_set
000363  aa   000070 7100 04	tra  	56,ic		000453
						STATEMENT 1 ON LINE 137
	else do;

						STATEMENT 1 ON LINE 138
		linus_set_fn_info.init_entry =
		     cv_entry_ (file_name || function_name || "_init", null, icode);

000364  aa  6 00120 2361 00	ldq  	pr6|80		file_name
000365  aa  5 00010 3515 20	epp1 	pr5|8,*
000366  aa  1 77777 0761 00	adq  	pr1|-1		function_name
000367  aa  6 00322 7561 00	stq  	pr6|210
000370  aa   000005 0760 07	adq  	5,dl
000371  aa  6 00323 7561 00	stq  	pr6|211
000372  aa   524000 2760 03	orq  	174080,du
000373  aa  6 00320 7561 00	stq  	pr6|208
000374  aa  6 00322 2361 00	ldq  	pr6|210
000375  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
000376  aa  6 00120 7271 00	lxl7 	pr6|80		file_name
000377  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000400  aa  6 00121 00 0017	desc9a	pr6|81,x7		file_name
000401  aa  2 00000 00 0017	desc9a	pr2|0,x7
000402  aa  6 00120 7271 00	lxl7 	pr6|80		file_name
000403  aa  1 77777 7261 00	lxl6 	pr1|-1		function_name
000404  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
000405  aa  1 00000 00 0016	desc9a	pr1|0,x6		function_name
000406  aa  2 00000 00 0016	desc9a	pr2|0,x6
000407  aa  6 00323 2361 00	ldq  	pr6|211
000410  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
000411  aa  6 00322 2351 00	lda  	pr6|210
000412  aa  040 105 100 404	mlr  	(ic),(pr,al),fill(040)
000413  aa   777376 00 0005	desc9a	-258,5		000010 = 137151156151
000414  aa  2 00000 00 0005	desc9a	pr2|0,5
000415  aa  6 00332 2521 00	spri2	pr6|218
000416  aa   777376 3534 24	epp3 	-258,ic*
000417  aa  6 00324 2535 00	spri3	pr6|212
000420  aa  6 00324 3521 00	epp2 	pr6|212
000421  aa  6 00334 2521 00	spri2	pr6|220
000422  aa  6 00117 3521 00	epp2 	pr6|79		icode
000423  aa  6 00336 2521 00	spri2	pr6|222
000424  aa  7 00026 3521 00	epp2 	pr7|22		linus_set_fn_info.init_entry
000425  aa  6 00340 2521 00	spri2	pr6|224
000426  aa  6 00320 3521 00	epp2 	pr6|208
000427  aa  6 00342 2521 00	spri2	pr6|226
000430  aa   777355 3520 04	epp2 	-275,ic		000005 = 464000000000
000431  aa  6 00344 2521 00	spri2	pr6|228
000432  aa   777351 3520 04	epp2 	-279,ic		000003 = 404000000043
000433  aa  6 00346 2521 00	spri2	pr6|230
000434  aa   777350 3520 04	epp2 	-280,ic		000004 = 500000000000
000435  aa  6 00350 2521 00	spri2	pr6|232
000436  aa  6 00330 6211 00	eax1 	pr6|216
000437  aa   020000 4310 07	fld  	8192,dl
000440  aa  6 00044 3701 20	epp4 	pr6|36,*
000441  la  4 00014 3521 20	epp2 	pr4|12,*		cv_entry_
000442  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 141
		if icode ^= 0 then
		     call error (icode);

000443  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000444  aa  6 00117 2361 00	ldq  	pr6|79		icode
000445  aa   000003 6000 04	tze  	3,ic		000450
000446  aa   000254 3520 04	epp2 	172,ic		000722 = 000002000000
000447  aa   000206 6700 04	tsp4 	134,ic		000655
						STATEMENT 1 ON LINE 143
		linus_set_fn_info.init_entry_set = "1"b;

000450  aa   040000 2350 03	lda  	16384,du
000451  aa  6 00100 3735 20	epp7 	pr6|64,*		linus_set_fn_info_ptr
000452  aa  7 00032 2551 00	orsa 	pr7|26		linus_set_fn_info.init_entry_set
						STATEMENT 1 ON LINE 145
	     end;

						STATEMENT 1 ON LINE 147
	if e_ptr -> entry_sequence.flags.has_descriptors then do;

000453  aa  6 00110 3715 20	epp5 	pr6|72,*		e_ptr
000454  aa  5 00001 2351 00	lda  	pr5|1		entry_sequence.has_descriptors
000455  aa   100000 3150 07	cana 	32768,dl
000456  aa   000072 6000 04	tze  	58,ic		000550
						STATEMENT 1 ON LINE 149
		linus_set_fn_info.info_entry_set = "0"b;

000457  aa   000240 2350 04	lda  	160,ic		000717 = 677777777777
000460  aa  7 00032 3551 00	ansa 	pr7|26		linus_set_fn_info.info_entry_set
						STATEMENT 1 ON LINE 150
		do i = 1 to linus_set_fn_info.nargs;

000461  aa  7 00034 2361 00	ldq  	pr7|28		linus_set_fn_info.nargs
000462  aa  6 00272 7561 00	stq  	pr6|186
000463  aa   000001 2360 07	ldq  	1,dl
000464  aa  6 00116 7561 00	stq  	pr6|78		i
000465  aa   000000 0110 03	nop  	0,du
000466  aa  6 00116 2361 00	ldq  	pr6|78		i
000467  aa  6 00272 1161 00	cmpq 	pr6|186
000470  aa   000021 6054 04	tpnz 	17,ic		000511
						STATEMENT 1 ON LINE 151
		     linus_set_fn_info.arg_desc (i) =
			addrel (obj_info.textp,
			pd_ptr -> parm_desc_ptrs.descriptor_relp (i)) -> bit36;

000471  aa   000022 4020 07	mpy  	18,dl
000472  aa  6 00112 3735 20	epp7 	pr6|74,*		pd_ptr
000473  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
000474  aa  7 00000 00 0022	descb	pr7|0,18		parm_desc_ptrs.descriptor_relp
000475  aa  6 00056 00 0044	descb	pr6|46,36
000476  aa  6 00056 2351 00	lda  	pr6|46
000477  aa  6 00176 3521 61	epp2 	pr6|126,*au	obj_info.textp
000500  aa   000000 0520 03	adwp2	0,du
000501  aa  6 00116 7271 00	lxl7 	pr6|78		i
000502  aa  6 00100 3715 20	epp5 	pr6|64,*		linus_set_fn_info_ptr
000503  aa  5 00034 3715 17	epp5 	pr5|28,7		linus_set_fn_info.arg_desc
000504  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
000505  aa  2 00000 00 0044	descb	pr2|0,36		bit36
000506  aa  5 00000 00 0044	descb	pr5|0,36		linus_set_fn_info.arg_desc
						STATEMENT 1 ON LINE 154
		end;

000507  aa  6 00116 0541 00	aos  	pr6|78		i
000510  aa   777756 7100 04	tra  	-18,ic		000466
						STATEMENT 1 ON LINE 155
		e_ptr = addrel (codeptr (linus_set_fn_info.assign_entry), -2);

000511  aa  6 00100 3735 20	epp7 	pr6|64,*		linus_set_fn_info_ptr
000512  aa  7 00012 3521 20	epp2 	pr7|10,*		linus_set_fn_info.assign_entry
000513  aa  2 00000 3515 00	epp1 	pr2|0
000514  aa   777776 0510 03	adwp1	262142,du
000515  aa  6 00110 2515 00	spri1	pr6|72		e_ptr
						STATEMENT 1 ON LINE 157
		if e_ptr -> entry_sequence.flags.has_descriptors then
		     /* get ptr to rslt descr. */
		     pd_ptr =
			addrel (obj_info.textp,
			e_ptr -> entry_sequence.descr_relp_offset);

000516  aa  1 00001 2351 00	lda  	pr1|1		entry_sequence.has_descriptors
000517  aa   100000 3150 07	cana 	32768,dl
000520  aa  6 00324 2521 00	spri2	pr6|212
000521  aa   000007 6000 04	tze  	7,ic		000530
000522  aa  1 00000 2351 00	lda  	pr1|0		entry_sequence.descr_relp_offset
000523  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000524  aa  6 00176 3535 61	epp3 	pr6|126,*au	obj_info.textp
000525  aa   000000 0530 03	adwp3	0,du
000526  aa  6 00112 2535 00	spri3	pr6|74		pd_ptr
000527  aa   000010 7100 04	tra  	8,ic		000537
						STATEMENT 1 ON LINE 162
		else call error (linus_error_$incons_fun);

000530  aa  6 00044 3701 20	epp4 	pr6|36,*
000531  la  4 00012 3521 20	epp2 	pr4|10,*		linus_error_$incons_fun
000532  aa  6 00304 2521 00	spri2	pr6|196
000533  aa  6 00302 3521 00	epp2 	pr6|194
000534  aa   004000 4310 07	fld  	2048,dl
000535  aa  2 00000 7571 00	staq 	pr2|0
000536  aa   000117 6700 04	tsp4 	79,ic		000655
						STATEMENT 1 ON LINE 163
		linus_set_fn_info.rslt_desc =
		     addrel (obj_info.textp,
		     pd_ptr -> parm_desc_ptrs.descriptor_relp (1)) -> bit36;

000537  aa  6 00112 2351 20	lda  	pr6|74,*		parm_desc_ptrs.descriptor_relp
000540  aa   000022 7350 00	als  	18
000541  aa  6 00176 3521 61	epp2 	pr6|126,*au	obj_info.textp
000542  aa   000000 0520 03	adwp2	0,du
000543  aa  6 00100 3735 20	epp7 	pr6|64,*		linus_set_fn_info_ptr
000544  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
000545  aa  2 00000 00 0044	descb	pr2|0,36		bit36
000546  aa  7 00033 00 0044	descb	pr7|27,36		linus_set_fn_info.rslt_desc
						STATEMENT 1 ON LINE 166
	     end;

000547  aa   000100 7100 04	tra  	64,ic		000647
						STATEMENT 1 ON LINE 168
	else do;

						STATEMENT 1 ON LINE 169
		linus_set_fn_info.rslt_desc = "0"b;

000550  aa  7 00033 4501 00	stz  	pr7|27		linus_set_fn_info.rslt_desc
						STATEMENT 1 ON LINE 170
		linus_set_fn_info.nargs = 0;

000551  aa  7 00034 4501 00	stz  	pr7|28		linus_set_fn_info.nargs
						STATEMENT 1 ON LINE 171
		linus_set_fn_info.info_entry =
		     cv_entry_ (file_name || function_name || "_info", null, icode);

000552  aa  6 00120 2361 00	ldq  	pr6|80		file_name
000553  aa  6 00032 3535 20	epp3 	pr6|26,*
000554  aa  3 00010 3515 20	epp1 	pr3|8,*
000555  aa  1 77777 0761 00	adq  	pr1|-1		function_name
000556  aa  6 00323 7561 00	stq  	pr6|211
000557  aa   000005 0760 07	adq  	5,dl
000560  aa  6 00322 7561 00	stq  	pr6|210
000561  aa   524000 2760 03	orq  	174080,du
000562  aa  6 00320 7561 00	stq  	pr6|208
000563  aa  6 00323 2361 00	ldq  	pr6|211
000564  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
000565  aa  6 00120 7271 00	lxl7 	pr6|80		file_name
000566  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000567  aa  6 00121 00 0017	desc9a	pr6|81,x7		file_name
000570  aa  2 00000 00 0017	desc9a	pr2|0,x7
000571  aa  6 00120 7271 00	lxl7 	pr6|80		file_name
000572  aa  1 77777 7261 00	lxl6 	pr1|-1		function_name
000573  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
000574  aa  1 00000 00 0016	desc9a	pr1|0,x6		function_name
000575  aa  2 00000 00 0016	desc9a	pr2|0,x6
000576  aa  6 00322 2361 00	ldq  	pr6|210
000577  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
000600  aa  6 00323 2351 00	lda  	pr6|211
000601  aa  040 105 100 404	mlr  	(ic),(pr,al),fill(040)
000602  aa   777205 00 0005	desc9a	-379,5		000006 = 137151156146
000603  aa  2 00000 00 0005	desc9a	pr2|0,5
000604  aa  6 00332 2521 00	spri2	pr6|218
000605  aa   777207 3714 24	epp5 	-377,ic*
000606  aa  6 00352 6515 00	spri5	pr6|234
000607  aa  6 00352 3521 00	epp2 	pr6|234
000610  aa  6 00334 2521 00	spri2	pr6|220
000611  aa  6 00117 3521 00	epp2 	pr6|79		icode
000612  aa  6 00336 2521 00	spri2	pr6|222
000613  aa  7 00022 3521 00	epp2 	pr7|18		linus_set_fn_info.info_entry
000614  aa  6 00340 2521 00	spri2	pr6|224
000615  aa  6 00320 3521 00	epp2 	pr6|208
000616  aa  6 00342 2521 00	spri2	pr6|226
000617  aa   777166 3520 04	epp2 	-394,ic		000005 = 464000000000
000620  aa  6 00344 2521 00	spri2	pr6|228
000621  aa   777162 3520 04	epp2 	-398,ic		000003 = 404000000043
000622  aa  6 00346 2521 00	spri2	pr6|230
000623  aa   777161 3520 04	epp2 	-399,ic		000004 = 500000000000
000624  aa  6 00350 2521 00	spri2	pr6|232
000625  aa  6 00330 6211 00	eax1 	pr6|216
000626  aa   020000 4310 07	fld  	8192,dl
000627  aa  6 00044 3701 20	epp4 	pr6|36,*
000630  la  4 00014 3521 20	epp2 	pr4|12,*		cv_entry_
000631  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 173
		if icode ^= 0 then
		     call error (linus_error_$cant_ref_fun);

000632  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000633  aa  6 00117 2361 00	ldq  	pr6|79		icode
000634  aa   000010 6000 04	tze  	8,ic		000644
000635  aa  6 00044 3701 20	epp4 	pr6|36,*
000636  la  4 00010 3521 20	epp2 	pr4|8,*		linus_error_$cant_ref_fun
000637  aa  6 00304 2521 00	spri2	pr6|196
000640  aa  6 00302 3521 00	epp2 	pr6|194
000641  aa   004000 4310 07	fld  	2048,dl
000642  aa  2 00000 7571 00	staq 	pr2|0
000643  aa   000012 6700 04	tsp4 	10,ic		000655
						STATEMENT 1 ON LINE 175
		linus_set_fn_info.info_entry_set = "1"b;

000644  aa   100000 2350 03	lda  	32768,du
000645  aa  6 00100 3735 20	epp7 	pr6|64,*		linus_set_fn_info_ptr
000646  aa  7 00032 2551 00	orsa 	pr7|26		linus_set_fn_info.info_entry_set
						STATEMENT 1 ON LINE 176
	     end;

						STATEMENT 1 ON LINE 178
	lcb.setfi_ptr = linus_set_fn_info_ptr;

000647  aa  6 00032 3715 20	epp5 	pr6|26,*
000650  aa  5 00002 3535 20	epp3 	pr5|2,*		lcb_ptr
000651  aa  3 00000 3535 20	epp3 	pr3|0,*		lcb_ptr
000652  aa  3 00036 6535 00	spri7	pr3|30		lcb.setfi_ptr
						STATEMENT 1 ON LINE 179
	code = 0;

000653  aa  5 00012 4501 20	stz  	pr5|10,*		code
						STATEMENT 1 ON LINE 180
exit:
	return;

000654  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 206
     end linus_thread_fn_list;

BEGIN PROCEDURE error
ENTRY TO error                                              STATEMENT 1 ON LINE 183
error:
     proc (cd);

000655  aa  6 00274 6501 00	spri4	pr6|188
000656  aa  6 00276 2521 00	spri2	pr6|190
						STATEMENT 1 ON LINE 190
	code = cd;

000657  aa  2 00002 2361 20	ldq  	pr2|2,*		cd
000660  aa  6 00032 3735 20	epp7 	pr6|26,*
000661  aa  7 00012 7561 20	stq  	pr7|10,*		code
						STATEMENT 1 ON LINE 191
	call tidy_up;

000662  aa  6 00056 6211 00	eax1 	pr6|46
000663  aa   000000 4310 07	fld  	0,dl
000664  aa   000004 3520 04	epp2 	4,ic		000670 = 000100627000
000665  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 192
	go to exit;

000666  aa   777766 7100 04	tra  	-10,ic		000654
						STATEMENT 1 ON LINE 194
     end error;

  END PROCEDURE error
BEGIN PROCEDURE tidy_up
ENTRY TO tidy_up                                            STATEMENT 1 ON LINE 196
tidy_up:
     proc;

000667  da     000106200000
000670  aa   000100 6270 00	eax7 	64
000671  aa  7 00034 3521 20	epp2 	pr7|28,*
000672  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000673  aa     000000000000
000674  aa     000000000000
						STATEMENT 1 ON LINE 201
	if setfi_ptr ^= null & setfi_ptr ^= lcb.setfi_ptr then
	     free linus_set_fn_info;

000675  aa  6 00040 3735 20	epp7 	pr6|32,*
000676  aa  7 00032 3715 20	epp5 	pr7|26,*
000677  aa  5 00002 3535 20	epp3 	pr5|2,*		lcb_ptr
000700  aa  3 00000 3535 20	epp3 	pr3|0,*		lcb_ptr
000701  aa  3 00036 2371 00	ldaq 	pr3|30		lcb.setfi_ptr
000702  aa   777112 6770 04	eraq 	-438,ic		000014 = 077777000043 000001000000
000703  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000704  aa   000012 6000 04	tze  	10,ic		000716
000705  aa  3 00036 2371 00	ldaq 	pr3|30		lcb.setfi_ptr
000706  aa  3 00036 6771 00	eraq 	pr3|30		lcb.setfi_ptr
000707  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000710  aa   000006 6000 04	tze  	6,ic		000716
000711  aa  7 00100 3515 20	epp1 	pr7|64,*		linus_set_fn_info_ptr
000712  aa  1 00034 2361 00	ldq  	pr1|28		linus_set_fn_info.nargs
000713  aa   000035 0760 07	adq  	29,dl
000714  aa  7 00100 3715 00	epp5 	pr7|64		linus_set_fn_info_ptr
000715  aa  0 01404 7001 00	tsx0 	pr0|772		op_freen_
						STATEMENT 1 ON LINE 204
     end tidy_up;

000716  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END PROCEDURE tidy_up
  END PROCEDURE linus_thread_fn_list


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
