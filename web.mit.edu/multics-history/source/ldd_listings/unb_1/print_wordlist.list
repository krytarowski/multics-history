	COMPILATION LISTING OF SEGMENT print_wordlist
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/17/85  0943.5 mst Tue
	    Options: optimize map single_symbol_list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /****^  HISTORY COMMENTS:
        9*  1) change(85-09-13,Spitzer), approve(85-09-13,MCR6618),
       10*     audit(85-10-30,Blair), install(85-12-16,MR12.0-1001):
       11*     Allow to read/write
       12*     MSFs.
       13*                                                   END HISTORY COMMENTS */
       14 
       15 print_wordlist: pwl: proc;
       16 
       17 /* Coded 11/14/77 by J. Stern */
       18 /* Modified 10/06/83 by Charlie Spitzer. make -of use equal names. phx14967
       19*		 make empty wordlist not print error. phx13055
       20**/
       21 
       22 /* Automatic */
       23 
       24 dcl  component fixed bin;
       25 dcl  ring_brackets (3) fixed bin (6);
       26 dcl  max_seg_size fixed bin (24);
       27 dcl  msf bit (1) aligned;
       28 dcl  type fixed bin (2);
       29 dcl (seg_output, got_pname, first_time) bit (1) aligned init ("0"b);
       30 dcl  atd char (256) varying;
       31 dcl  argno fixed bin;
       32 dcl  ap ptr;
       33 dcl (input_ptr, output_ptr) ptr init (null);
       34 dcl  nargs fixed bin;
       35 dcl  al fixed bin;
       36 dcl  (fcb_ptr, temp_ptr) ptr;
       37 dcl  isaved fixed bin;
       38 dcl (cols, rows) fixed bin (21);
       39 dcl  max_cols fixed bin;
       40 dcl  last_col_rows fixed bin;
       41 dcl  code fixed bin (35);
       42 dcl (dname, of_dname) char (168);
       43 dcl (ename, of_ename) char (32);
       44 dcl  bc fixed bin (24);
       45 dcl (c, r, i) fixed bin (21);
       46 dcl (input_len, output_len) fixed bin (21);
       47 dcl  word_ptr ptr;
       48 dcl (word_len, real_len) fixed bin (21);
       49 dcl (nwords, words_per_page) fixed bin (21);
       50 dcl (end_of_col, ntabs, nspaces, line_position) fixed bin (21);
       51 dcl  col_width fixed bin (21);
       52 dcl (page_len, vert_margin, input_idx) fixed bin (21);
       53 dcl (system_area_ptr, words_ptr) ptr;
       54 dcl (first_word_row, word_index) fixed bin;
       55 		 
       56 
       57 /* Based */
       58 
       59 dcl  arg char (al) based (ap);
       60 dcl  input_cs char (input_len) based (input_ptr);
       61 dcl  output_cs char (output_len) based (temp_ptr);
       62 dcl  word char (word_len) based (word_ptr);
       63 dcl  words (words_per_page) char (col_width * 3) based (words_ptr);	/* holds words (possibly underlined) from file */
       64 dcl  system_area area based (system_area_ptr);
       65 
       66 
       67 /* Conditions */
       68 
       69 dcl  cleanup condition;
       70 
       71 
       72 /* Static */
       73 
       74 dcl  BS char (1) int static options (constant) init ("");
       75 dcl  NL char (1) int static options (constant) init ("
       76 ");
       77 dcl  HT char (1) int static options (constant) init ("	");
       78 dcl  NP char (1) int static options (constant) init ("");
       79 dcl  whoami char (32) int static options (constant) init ("print_wordlist");
       80 
       81 dcl (error_table_$badopt,
       82      error_table_$dirseg,
       83      error_table_$wrong_no_of_args,
       84      error_table_$noarg,
       85      error_table_$long_record,
       86      error_table_$short_record,
       87      error_table_$end_of_info) ext fixed bin (35);
       88 dcl  iox_$user_output ext ptr;
       89 dcl  sys_info$max_seg_size fixed bin(35) ext static;
       90 
       91 /* Builtins */
       92 
       93 dcl (addr, copy, divide, hbound, index, length, max, mod, null, rtrim, search, substr) builtin;
       94 
       95 
       96 /* Entries */
       97 
       98 dcl  cu_$arg_count entry (fixed bin);
       99 dcl  cu_$arg_ptr ext entry (fixed bin, ptr, fixed bin, fixed bin (35));
      100 dcl  com_err_ ext entry options (variable);
      101 dcl  get_system_free_area_ entry() returns(ptr);
      102 dcl  get_equal_name_ entry (char(*), char(*), char(32), fixed bin(35));
      103 dcl  expand_pathname_$add_suffix ext entry (char (*), char (*), char (*), char (*), fixed bin (35));
      104 dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
      105 dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
      106 dcl  iox_$attach_name entry (char(*), ptr, char(*), ptr, fixed bin(35));
      107 dcl  iox_$open entry (ptr, fixed bin, bit(1) aligned, fixed bin(35));
      108 dcl  iox_$close entry (ptr, fixed bin(35));
      109 dcl  iox_$detach_iocb entry (ptr, fixed bin(35));
      110 dcl  iox_$destroy_iocb entry (ptr, fixed bin(35));
      111 dcl  iox_$get_line entry (ptr, ptr, fixed bin(21), fixed bin(21), fixed bin(35));
      112 dcl  unique_chars_ entry (bit(*)) returns(char(15));
      113 dcl  cv_dec_check_ ext entry (char (*), fixed bin (35)) returns (fixed bin);
      114 dcl  get_line_length_$switch entry (ptr, fixed bin (35)) returns (fixed bin);
      115 dcl  get_temp_segment_ entry (char(*), ptr, fixed bin(35));
      116 dcl  release_temp_segment_ entry (char(*), ptr, fixed bin(35));
      117 dcl  hcs_$make_seg entry (char(*), char(*), char(*), fixed bin(5), ptr, fixed bin(35));
      118 dcl  hcs_$status_minf entry (char(*), char(*), fixed bin(1), fixed bin(2), fixed bin(24), fixed bin(35));
      119 dcl  initiate_file_ entry (char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35));
      120 dcl  terminate_file_ entry (ptr, fixed bin(24), bit(*), fixed bin(35));
      121 dcl  pathname_ entry (char(*), char(*)) returns(char(168));
      122 dcl  make_msf_ entry (char(*), char(*), (3) fixed bin(6), fixed bin(35));
      123 dcl  unmake_msf_ entry (char(*), char(*), bit(1), (3) fixed bin(6), fixed bin(35));
      124 dcl  msf_manager_$open entry (char(*), char(*), ptr, fixed bin(35));
      125 dcl  msf_manager_$close entry (ptr);
      126 dcl  msf_manager_$get_ptr entry (ptr, fixed bin, bit(1), ptr, fixed bin(24), fixed bin(35));
      127 
      128 
      129 /* examine arguments */
      130 
      131 	call cu_$arg_count (nargs);
      132 	if nargs = 0 then do;
      133 noarg:	     code = error_table_$noarg;
      134 usage:	     call com_err_ (code, whoami,
      135 		"^/Usage: print_wordlist path {-columns N} {-page_length N} {-vertical_margin N} {-output_file path}");
      136 	     return;
      137 	end;
      138 
      139 	cols, page_len, vert_margin = -1;
      140 	col_width = 20;
      141 	do argno = 1 to nargs;
      142 	     call cu_$arg_ptr (argno, ap, al, code);
      143 
      144 	     if index (arg, "-") ^= 1 then do;		/* not an option, must be pathname */
      145 		if got_pname then do;		/* already have pathname => error */
      146 		     code = error_table_$wrong_no_of_args;
      147 		     go to usage;
      148 		end;
      149 		call expand_pathname_$add_suffix (arg, "wl", dname, ename, code);
      150 		if code ^= 0 then do;
      151 bad_path:		     call com_err_ (code, whoami, arg);
      152 		     return;
      153 		end;
      154 		got_pname = "1"b;
      155 	     end;
      156 	     else if arg = "-cols" | arg = "-columns"
      157 	     then do;
      158 		call next_arg_num (cols);
      159 		if code ^= 0 | cols < 1 then do;
      160 		     call com_err_ (0, whoami, "Invalid column count.  ^a", arg);
      161 		     return;
      162 		end;
      163 	     end;
      164 	     else if arg = "-cw" | arg = "-column_width"
      165 	     then do;
      166 		call next_arg_num (col_width);
      167 		if code ^= 0 | col_width < 2
      168 		then do;
      169 		     call com_err_ (0, whoami, "Invalid column width.  ^a", arg);
      170 		     return;
      171 		end;
      172 	     end;
      173 	     else if arg = "-pl" | arg = "-page_length"
      174 	     then do;
      175 		call next_arg_num (page_len);
      176 		if code ^= 0 | page_len < 1
      177 		then do;
      178 		     call com_err_ (0, whoami, "Invalid page length.  ^a", arg);
      179 		     return;
      180 		end;
      181 	     end;
      182 	     else if arg = "-vm" | arg = "-vertical_margin"
      183 	     then do;
      184 		call next_arg_num (vert_margin);
      185 		if code ^= 0 | vert_margin < 0
      186 		then do;
      187 		     call com_err_ (0, whoami, "Invalid vertical margin.  ^a", arg);
      188 		     return;
      189 		end;
      190 	     end;
      191 	     else if arg = "-of" | arg = "-output_file"
      192 	     then do;
      193 		call next_arg;
      194 		call expand_pathname_ (arg, of_dname, of_ename, code);
      195 		if code ^= 0 then go to bad_path;
      196 		if search (rtrim (of_ename), "%=") ^= 0 then do;
      197 		     call get_equal_name_ (ename, (of_ename), of_ename, code);
      198 		     if code ^= 0 then go to bad_path;
      199 		     end;
      200 		seg_output = "1"b;
      201 	     end;
      202 	     else do;
      203 		call com_err_ (error_table_$badopt, whoami, arg);
      204 		return;
      205 	     end;
      206 	end;
      207 	if ^got_pname				/* no pathname given */
      208 	then go to noarg;
      209 
      210 	if page_len = -1
      211 	then if seg_output
      212 	     then page_len = 60;
      213 	     else page_len = 66;
      214 	if vert_margin = -1
      215 	then if seg_output
      216 	     then vert_margin = 0;
      217 	     else vert_margin = 3;
      218 
      219 	rows = page_len - 2 * vert_margin;
      220 	if rows < 1
      221 	then do;
      222 	     call com_err_ (0, whoami, "Page length of ^d too small for vertical margin of ^d.", page_len, vert_margin);
      223 	     return;
      224 	end;
      225 
      226 	if seg_output
      227 	then if cols = -1
      228 	     then cols = max (divide (136, col_width, 17, 0), 1); /* set default cols for seg output */
      229 	     else;
      230 	else do;					/* not seg output, check line length */
      231 	     i = get_line_length_$switch (iox_$user_output, code);
      232 	     max_cols = max (divide (i, col_width, 17, 0), 1);
      233 	     if code = 0
      234 	     then if cols > max_cols then do;
      235 		     call com_err_ (0, whoami, "Line length too small for specified number of columns.");
      236 		     return;
      237 		end;
      238 	     if cols = -1 then cols = max_cols;		/* set default for user_output */
      239 	end;
      240 
      241 /* open input segment */
      242 
      243 	fcb_ptr, temp_ptr, input_ptr, output_ptr, words_ptr = null;
      244 	system_area_ptr = get_system_free_area_ ();
      245 	component = 0;
      246 
      247 	on cleanup call cleaner;
      248 
      249 	call hcs_$status_minf (dname, ename, 1, type, bc, code);
      250 	if code ^= 0 then call input_seg_error;
      251 	if type = 2
      252 	then if bc = 0
      253 	     then do;
      254 		code = error_table_$dirseg;
      255 		call input_seg_error;
      256 		end;
      257 	     else msf = "1"b;
      258 	else msf = "0"b;
      259 
      260 	if msf then do;
      261 	     atd = "vfile_ " || rtrim (dname);
      262 	     atd = atd || ">";
      263 	     atd = atd || ename;
      264 	     call iox_$attach_name (unique_chars_ (""b)||".pwl", input_ptr, (atd), null, code);
      265 	     if code ^= 0 then call input_seg_error;
      266 	     call iox_$open (input_ptr, 1, "0"b, code);	/* open for input */
      267 	     if code ^= 0 then call input_seg_error;
      268 
      269 	     if seg_output then do;			/* make output seg */
      270 		atd = "vfile_ " || rtrim (of_dname);
      271 		atd = atd || ">";
      272 		atd = atd || of_ename;
      273 
      274 		call iox_$attach_name (unique_chars_ (""b)||".pwl", output_ptr, (atd), null, code);
      275 		if code ^= 0 then call output_seg_error;
      276 		call iox_$open (output_ptr, 2, "0"b, code);  /* open for output */
      277 		if code ^= 0 then call output_seg_error;
      278 		end;
      279 	     else output_ptr = null;
      280 	     end;
      281 	else do;
      282 	     call initiate_file_ (dname, ename, R_ACCESS, input_ptr, bc, code);
      283 	     if input_ptr = null then call input_seg_error;
      284 
      285 	     input_len = divide (bc+8, 9, 24, 0);	/* get character count */
      286 	     input_idx = 1;				/* character index */
      287 
      288 	     if seg_output then do;
      289 		call hcs_$make_seg (of_dname, of_ename, "", RW_ACCESS_BIN, output_ptr, code);
      290 		if output_ptr = null
      291 		then if code ^= error_table_$dirseg
      292 		     then call output_seg_error;
      293 		     else do;
      294 			call hcs_$status_minf (of_dname, of_ename, 1, type, bc, code);
      295 			if code ^= 0 then call output_seg_error;
      296 			if type = 2
      297 			then if bc = 0
      298 			     then do;
      299 				code = error_table_$dirseg;
      300 				call output_seg_error;
      301 				end;
      302 
      303 /* make a SSF from the MSF, but don't save any contents. */
      304 
      305 			call unmake_msf_ (of_dname, of_ename, "0"b, ring_brackets, code);
      306 			if code ^= 0 then call output_seg_error;
      307 
      308 			call initiate_file_ (of_dname, of_ename, RW_ACCESS, output_ptr, bc, code);
      309 			if code ^= 0 then call output_seg_error;
      310 			end;
      311 
      312 		if output_ptr = input_ptr then do;
      313 		     call com_err_ (0, whoami, "Input and output files are the same. ^a and ^a",
      314 			pathname_ (dname, ename), pathname_ (of_dname, of_ename));
      315 		     goto error;
      316 		     end;
      317 		temp_ptr = output_ptr;		/* build output segment directly in segment, not temp seg. */
      318 		end;
      319 	     end;
      320 
      321 	if temp_ptr = null then do;
      322 	     call get_temp_segment_ (whoami, temp_ptr, code);
      323 	     if code ^= 0
      324 	     then do;
      325 		call com_err_ (code, whoami, "Cannot get temporary segment.");
      326 		go to error;
      327 		end;
      328 	     end;
      329 
      330 	if output_ptr = null
      331 	then output_ptr = iox_$user_output;		/* writing to terminal */
      332 	output_len = 0;
      333 
      334 
      335 /* now build the output segment one page at a time */
      336 
      337 	first_time = "1"b;
      338 	words_per_page = rows * cols;
      339 	allocate words in (system_area) set (words_ptr);
      340 
      341 	max_seg_size = sys_info$max_seg_size * 4;
      342 
      343 	do while ("1"b);
      344 	     call fill_word_array (nwords);
      345 	     if nwords = 0
      346 	     then if first_time
      347 		then do;
      348 		     call com_err_ (0, whoami, "Wordlist empty. ^a", pathname_ (dname, ename));
      349 		     goto error;
      350 		     end;
      351 		else goto EOF;			/* end of file */
      352 	     else first_time = "0"b;
      353 
      354 	     if nwords < cols
      355 	     then do;
      356 		cols = nwords;
      357 		rows = 1;
      358 		end;
      359 
      360 	     word_index, first_word_row = 1;
      361 	     call output (copy (NL, vert_margin), vert_margin);
      362 
      363 	     if rows * cols > nwords
      364 	     then rows = divide (nwords + cols -1, cols, 17, 0); /* minimize length of last page */
      365 	     last_col_rows = rows - (rows * cols - nwords);
      366 
      367 	     do r = 1 to rows;
      368 		if r > 1
      369 		then call output (NL, 1);
      370 		if r = last_col_rows + 1
      371 		then cols = cols - 1;
      372 
      373 		do c = 1 to cols;
      374 		     if first_word_row > rows then goto EOP;
      375 		     word_ptr = addr (words (word_index));
      376 		     word_len = length (rtrim (words (word_index)));
      377 		     word_index = word_index + rows;
      378 		     if word_index > nwords
      379 		     then word_index, first_word_row = first_word_row + 1;
      380 
      381 		     i = index (word, BS);		/* check for backspace */
      382 		     if i ^= 0
      383 		     then do;
      384 			isaved = col_width - 2;
      385 			real_len = i - 2;
      386 			do i = i + 1 to word_len while (real_len <= col_width-1);
      387 			     if substr (word, i, 1) = BS
      388 			     then real_len = real_len - 1;
      389 			     else do;
      390 				real_len = real_len + 1;
      391 				if real_len = col_width - 2
      392 				then isaved = i;
      393 			     end;
      394 			end;
      395 			if real_len > col_width - 1
      396 			then word_len = isaved;
      397 		     end;
      398 		     else do;			/* no backspaces */
      399 			real_len = word_len;
      400 			if word_len > col_width - 1
      401 			then word_len = col_width - 2;
      402 		     end;
      403 
      404 		     call output (word, word_len);
      405 		     if real_len > col_width - 1
      406 		     then do;
      407 			real_len = col_width - 1;
      408 			call output ("*", 1);
      409 		     end;
      410 
      411 		     if c < cols
      412 		     then do;
      413 			end_of_col = c * col_width;
      414 			line_position = end_of_col - col_width + real_len;
      415 			ntabs = divide (end_of_col, 10, 17, 0) - divide (line_position, 10, 17, 0);
      416 			if ntabs > 0
      417 			then do;
      418 			     call output (copy (HT, ntabs), ntabs);
      419 			     line_position = line_position - mod (line_position, 10) + 10 * ntabs;
      420 			end;
      421 
      422 			nspaces = end_of_col - line_position;
      423 			if nspaces > 0
      424 			then call output (copy ("", nspaces), nspaces);
      425 		     end;
      426 		end;				/* do cols */
      427 next_row:						/* end of line */
      428 	     end;					/* do rows */
      429 
      430 EOP:
      431 	     if seg_output
      432 	     then if vert_margin = 0
      433 		then call output (NP, length (NP));
      434 	          else call output (copy (NL, vert_margin - length (NP))||NP, vert_margin);
      435 	     else do;
      436 		call output (copy (NL, vert_margin+1), vert_margin+1);
      437 		call iox_$put_chars (output_ptr, temp_ptr, output_len, code);
      438 		if code ^= 0
      439 		then call com_err_ (code, whoami, "Attempting to write on user_output switch.");
      440 		output_len = 0;			/* start at beginning of segment again */
      441 		end;
      442 
      443 	end;					/* do forever */
      444 
      445 EOF:						/* come here on end of input file */
      446 	if output_len > 0
      447 	then if msf
      448 	     then do;
      449 		call iox_$put_chars (output_ptr, temp_ptr, output_len, code);
      450 		if code ^= 0 then call com_err_ (code, whoami, "Attempting to write on user_output switch.");
      451 		end;
      452 	     else do;
      453 		call terminate_file_ (output_ptr, output_len * 9, TERM_FILE_TRUNC_BC_TERM, code);
      454 		if code ^= 0 then call com_err_ (code, whoami, "^a", pathname_ (dname, ename));
      455 		end;
      456 
      457 error:
      458 	call cleaner;
      459 	return;
      460 
      461 input_seg_error:
      462      proc;
      463 
      464 input_seg:
      465           call com_err_ (code, whoami, "^a", pathname_ (dname, ename));
      466 	go to error;
      467 
      468 output_seg_error:
      469      entry;
      470 
      471 	dname = of_dname;
      472 	ename = of_ename;
      473 	go to input_seg;
      474 
      475 	end input_seg_error;
      476 
      477 cleaner:	proc;					/* cleanup handler */
      478 
      479 	     if output_ptr = iox_$user_output | output_ptr = temp_ptr
      480 	     then output_ptr = null;
      481 
      482 	     if temp_ptr ^= null
      483 	     then if ^msf & seg_output
      484 		then ;
      485 		else call release_temp_segment_ (whoami, temp_ptr, (0));
      486 
      487 	     do input_ptr = input_ptr, output_ptr;
      488 		if input_ptr ^= null
      489 		then if msf then do;
      490 			call iox_$close (input_ptr, (0));
      491 			call iox_$detach_iocb (input_ptr, (0));
      492 			call iox_$destroy_iocb (input_ptr, (0));
      493 			end;
      494 		     else call terminate_file_ (input_ptr, 0, TERM_FILE_TERM, (0));
      495 		end;
      496 
      497 	if fcb_ptr ^= null
      498 	then call msf_manager_$close (fcb_ptr);
      499 
      500 	if words_ptr ^= null then free words in (system_area);
      501 	return;
      502 
      503 	end cleaner;
      504 
      505 
      506 
      507 next_arg:	proc;					/* gets next argument */
      508 
      509 
      510 	     argno = argno + 1;
      511 	     if argno > nargs
      512 	     then go to noarg;
      513 	     call cu_$arg_ptr (argno, ap, al, code);
      514 
      515 	end next_arg;
      516 
      517 
      518 
      519 next_arg_num: proc (num);				/* gets next argument, converts to fixed bin */
      520 
      521 dcl  num fixed bin (21);
      522 
      523 
      524 	     call next_arg;
      525 	     num = cv_dec_check_ (arg, code);
      526 
      527 	end next_arg_num;
      528 
      529 fill_word_array:
      530      proc (cnt);
      531 
      532 dcl  cnt fixed bin (21);
      533 dcl  nread fixed bin (21);
      534 
      535 	cnt = 1;
      536 	do while (cnt ^> hbound (words, 1));
      537 	     if msf then do;
      538 		call iox_$get_line (input_ptr, addr (words (cnt)), length (words (cnt)), nread, code);
      539 		if code ^= 0
      540 		then if code = error_table_$end_of_info
      541 		     then do;
      542 END_OF_INPUT:		cnt = cnt - 1;
      543 			return;
      544 			end;
      545 		     else if code = error_table_$long_record | code = error_table_$short_record
      546 			then ;			/* ok to get this one */
      547 		     else call input_seg_error;
      548 		else if nread = 1
      549 		     then goto read_next_word;	/* blank line */
      550 		else substr (words (cnt), nread) = "";	/* take out NL + leftover junk */
      551 		end;
      552 	     else do;
      553 		if input_idx > input_len then goto END_OF_INPUT;
      554 		word_len = index (substr (input_cs, input_idx), NL) -1;
      555 		if word_len = 0
      556 		then do;
      557 		     input_idx = input_idx + 1;
      558 		     goto read_next_word;		/* blank line */
      559 		     end;
      560 		if word_len = -1
      561 		then word_len = input_len - input_idx + 1;   /* final newline missing */
      562 		words (cnt) = substr (input_cs, input_idx, word_len);
      563 		input_idx = input_idx + word_len + 1;	/* bump character index over this word */
      564 		end;
      565 
      566 	     cnt = cnt + 1;
      567 read_next_word:
      568 	     end;
      569 
      570 	cnt = cnt - 1;
      571 	return;
      572 
      573 	end fill_word_array;
      574 
      575 output:
      576      proc (str, len) recursive;
      577 
      578 dcl  str char (*) parameter;				/* string to output */
      579 dcl  len fixed bin (21) parameter;			/* how long it is */
      580 dcl  chars_that_fit fixed bin (21);
      581 
      582 	if seg_output
      583 	then if msf
      584 	     then do;
      585 		call iox_$put_chars (output_ptr, addr (str), len, code);
      586 		if code ^= 0 then call output_seg_error;
      587 		return;
      588 		end;
      589 	     else if output_len + len + 1 > max_seg_size
      590 		then do;				/* output segment grows to an MSF */
      591 
      592 /* Fill end of segment with whatever fits from the input string */
      593 
      594 		     chars_that_fit = max_seg_size - output_len;
      595 		     substr (output_cs, output_len + 1, chars_that_fit) = str;
      596 
      597 		     if component = 0 then do;
      598 
      599 /* Terminate the output file, make it into an MSF, then open using
      600*   msf_manager_. Continue to use pointer I/O on each component which has to
      601*   be more efficient than using vfile_. */
      602 
      603 			call terminate_file_ (output_ptr, max_seg_size * 9, TERM_FILE_BC | TERM_FILE_TERM, code);
      604 			if code ^= 0 then call output_seg_error;
      605 
      606 			call make_msf_ (of_dname, of_ename, ring_brackets, code);
      607 			if code ^= 0 then call output_seg_error;
      608 
      609 			call msf_manager_$open (of_dname, of_ename, fcb_ptr, code);
      610 			if code ^= 0 then call output_seg_error;
      611 
      612 			call msf_manager_$get_ptr (fcb_ptr, 1, "1"b, output_ptr, bc, code);
      613 			if code ^= 0 then call output_seg_error;
      614 			component = 1;
      615 
      616 			temp_ptr = output_ptr;
      617 			end;
      618 		     else do;
      619 
      620 			call terminate_file_ (output_ptr, max_seg_size * 9, TERM_FILE_BC | TERM_FILE_TERM, code);
      621 			if code ^= 0 then call output_seg_error;
      622 
      623 			call msf_manager_$get_ptr (fcb_ptr, component+1, "1"b, output_ptr, bc, code);
      624 			if code ^= 0 then call output_seg_error;
      625 
      626 			component = component + 1;
      627 			temp_ptr = output_ptr;
      628 			end;
      629 
      630 		     output_len = 0;		/* empty output file */
      631 
      632 /* Put rest of input string at the head of the output buffer. Since the string
      633*   passed might not be len chars long, pad with spaces if the difference is
      634*   negative. */
      635 
      636 		     if len > chars_that_fit
      637 		     then call output (substr (str, chars_that_fit + 1), len - chars_that_fit);
      638 		     return;
      639 		     end;
      640 
      641 	substr (output_cs, output_len + 1, len) = str;
      642 	output_len = output_len + len;
      643 
      644 	return;
      645 	end output;
      646 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      647 
  2     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  2     2 /* format: style2,^inddcls,idind32 */
  2     3 
  2     4 declare 1 terminate_file_switches	based,
  2     5 	2 truncate		bit (1) unaligned,
  2     6 	2 set_bc			bit (1) unaligned,
  2     7 	2 terminate		bit (1) unaligned,
  2     8 	2 force_write		bit (1) unaligned,
  2     9 	2 delete			bit (1) unaligned;
  2    10 
  2    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  2    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  2    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  2    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  2    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  2    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  2    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  2    18 
  2    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      648 
      649 
      650      end print_wordlist;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/16/85  1652.5  print_wordlist.pl1                >spec>install>1001>print_wordlist.pl1
647          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
648          2    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

A_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
BS                              005460 constant        char(1)                  initial unaligned dcl 74 ref 381 387
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-33
END_OF_INPUT                    004416 constant        label                    dcl 542 ref 553
EOF                             003566 constant        label                    dcl 445 ref 345
EOP                             003407 constant        label                    dcl 430 ref 374
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
HT                                     constant        char(1)                  initial unaligned dcl 77 ref 418 418
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
NL                              000014 constant        char(1)                  initial unaligned dcl 75 set ref 361 361 368* 434
                                                                                  436 436 554
NP                              000013 constant        char(1)                  initial unaligned dcl 78 set ref 430* 430 430 434
                                                                                  434
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                       000002 constant        bit(3)                   initial unaligned dcl 1-11 set ref 308*
RW_ACCESS_BIN                   000020 constant        fixed bin(5,0)           initial dcl 1-36 set ref 289*
R_ACCESS                        000053 constant        bit(3)                   initial unaligned dcl 1-11 set ref 282*
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
TERM_FILE_BC                           constant        bit(2)                   initial unaligned dcl 2-12 ref 603 620
TERM_FILE_DELETE                       internal static bit(5)                   initial unaligned dcl 2-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 2-16
TERM_FILE_TERM                  000001 constant        bit(3)                   initial unaligned dcl 2-14 set ref 494* 603 620
TERM_FILE_TRUNC                        internal static bit(1)                   initial unaligned dcl 2-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial unaligned dcl 2-13
TERM_FILE_TRUNC_BC_TERM         000000 constant        bit(3)                   initial unaligned dcl 2-15 set ref 453*
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
addr                                                   builtin function         dcl 93 ref 375 538 538 585 585
al                              000223 automatic       fixed bin(17,0)          dcl 35 set ref 142* 144 149 149 151 151 156 156 160
                                                                                  160 164 164 169 169 173 173 178 178 182 182 187
                                                                                  187 191 191 194 194 203 203 513* 525 525
ap                              000214 automatic       pointer                  dcl 32 set ref 142* 144 149 151 156 156 160 164 164
                                                                                  169 173 173 178 182 182 187 191 191 194 203 513*
                                                                                  525
arg                                    based           char                     unaligned dcl 59 set ref 144 149* 151* 156 156 160*
                                                                                  164 164 169* 173 173 178* 182 182 187* 191 191
                                                                                  194* 203* 525*
argno                           000213 automatic       fixed bin(17,0)          dcl 31 set ref 141* 142* 510* 510 511 513*
atd                             000112 automatic       varying char(256)        dcl 30 set ref 261* 262* 262 263* 263 264 270* 271*
                                                                                  271 272* 272 274
bad_path                        000514 constant        label                    dcl 151 ref 195 198
bc                              000402 automatic       fixed bin(24,0)          dcl 44 set ref 249* 251 282* 285 294* 296 308* 612*
                                                                                  623*
c                               000403 automatic       fixed bin(21,0)          dcl 45 set ref 373* 411 413*
chars_that_fit                  000100 automatic       fixed bin(21,0)          dcl 580 set ref 594* 595 636 636 636 636
cleaner                         004044 constant        entry                    internal dcl 477 ref 247 457
cleanup                         000434 stack reference condition                dcl 69 ref 247
cnt                                    parameter       fixed bin(21,0)          dcl 532 set ref 529 535* 536 538 538 538 538 542*
                                                                                  542 550 562 566* 566 570* 570
code                            000235 automatic       fixed bin(35,0)          dcl 41 set ref 133* 134* 142* 146* 149* 150 151* 159
                                                                                  167 176 185 194* 195 197* 198 231* 233 249* 250
                                                                                  254* 264* 265 266* 267 274* 275 276* 277 282* 289*
                                                                                  290 294* 295 299* 305* 306 308* 309 322* 323 325*
                                                                                  437* 438 438* 449* 450 450* 453* 454 454* 464*
                                                                                  513* 525* 538* 539 539 545 545 585* 586 603* 604
                                                                                  606* 607 609* 610 612* 613 620* 621 623* 624
col_width                       000422 automatic       fixed bin(21,0)          dcl 51 set ref 140* 166* 167 226 232 339 339 375 375
                                                                                  375 376 376 376 384 386 391 395 400 400 405 407
                                                                                  413 414 500 500 536 538 538 538 538 538 538 538
                                                                                  538 538 538 538 538 550 550 550 562 562 562
cols                            000231 automatic       fixed bin(21,0)          dcl 38 set ref 139* 158* 159 226 226* 233 238 238*
                                                                                  338 354 356* 363 363 363 365 370* 370 373 411
com_err_                        000036 constant        entry                    external dcl 100 ref 134 151 160 169 178 187 203 222
                                                                                  235 313 325 348 438 450 454 464
component                       000100 automatic       fixed bin(17,0)          dcl 24 set ref 245* 597 614* 623 626* 626
copy                                                   builtin function         dcl 93 ref 361 361 418 418 423 423 434 436 436
cu_$arg_count                   000032 constant        entry                    external dcl 98 ref 131
cu_$arg_ptr                     000034 constant        entry                    external dcl 99 ref 142 513
cv_dec_check_                   000070 constant        entry                    external dcl 113 ref 525
divide                                                 builtin function         dcl 93 ref 226 232 285 363 415 415
dname                           000236 automatic       char(168)                unaligned dcl 42 set ref 149* 249* 261 282* 313*
                                                                                  313* 348* 348* 454* 454* 464* 464* 471*
ename                           000362 automatic       char(32)                 unaligned dcl 43 set ref 149* 197* 249* 263 282*
                                                                                  313* 313* 348* 348* 454* 454* 464* 464* 472*
end_of_col                      000416 automatic       fixed bin(21,0)          dcl 50 set ref 413* 414 415 422
error                           003736 constant        label                    dcl 457 ref 315 326 349 466
error_table_$badopt             000010 external static fixed bin(35,0)          dcl 81 set ref 203*
error_table_$dirseg             000012 external static fixed bin(35,0)          dcl 81 ref 254 290 299
error_table_$end_of_info        000024 external static fixed bin(35,0)          dcl 81 ref 539
error_table_$long_record        000020 external static fixed bin(35,0)          dcl 81 ref 545
error_table_$noarg              000016 external static fixed bin(35,0)          dcl 81 ref 133
error_table_$short_record       000022 external static fixed bin(35,0)          dcl 81 ref 545
error_table_$wrong_no_of_args   000014 external static fixed bin(35,0)          dcl 81 ref 146
expand_pathname_                000046 constant        entry                    external dcl 104 ref 194
expand_pathname_$add_suffix     000044 constant        entry                    external dcl 103 ref 149
fcb_ptr                         000224 automatic       pointer                  dcl 36 set ref 243* 497 497* 609* 612* 623*
fill_word_array                 004343 constant        entry                    internal dcl 529 ref 344
first_time                      000111 automatic       bit(1)                   initial dcl 29 set ref 29* 337* 345 352*
first_word_row                  000432 automatic       fixed bin(17,0)          dcl 54 set ref 360* 374 378 378*
get_equal_name_                 000042 constant        entry                    external dcl 102 ref 197
get_line_length_$switch         000072 constant        entry                    external dcl 114 ref 231
get_system_free_area_           000040 constant        entry                    external dcl 101 ref 244
get_temp_segment_               000074 constant        entry                    external dcl 115 ref 322
got_pname                       000110 automatic       bit(1)                   initial dcl 29 set ref 29* 145 154* 207
hbound                                                 builtin function         dcl 93 ref 536
hcs_$make_seg                   000100 constant        entry                    external dcl 117 ref 289
hcs_$status_minf                000102 constant        entry                    external dcl 118 ref 249 294
i                               000405 automatic       fixed bin(21,0)          dcl 45 set ref 231* 232 381* 382 385 386* 386* 387
                                                                                  391*
index                                                  builtin function         dcl 93 ref 144 381 554
initiate_file_                  000104 constant        entry                    external dcl 119 ref 282 308
input_cs                               based           char                     unaligned dcl 60 ref 554 562
input_idx                       000425 automatic       fixed bin(21,0)          dcl 52 set ref 286* 553 554 557* 557 560 562 563*
                                                                                  563
input_len                       000406 automatic       fixed bin(21,0)          dcl 46 set ref 285* 553 554 560 562
input_ptr                       000216 automatic       pointer                  initial dcl 33 set ref 33* 243* 264* 266* 282* 283
                                                                                  312 487* 487* 488 490* 491* 492* 494* 538* 554 562
input_seg                       003751 constant        label                    dcl 464 ref 473
input_seg_error                 003744 constant        entry                    internal dcl 461 ref 250 255 265 267 283 547
iox_$attach_name                000052 constant        entry                    external dcl 106 ref 264 274
iox_$close                      000056 constant        entry                    external dcl 108 ref 490
iox_$destroy_iocb               000062 constant        entry                    external dcl 110 ref 492
iox_$detach_iocb                000060 constant        entry                    external dcl 109 ref 491
iox_$get_line                   000064 constant        entry                    external dcl 111 ref 538
iox_$open                       000054 constant        entry                    external dcl 107 ref 266 276
iox_$put_chars                  000050 constant        entry                    external dcl 105 ref 437 449 585
iox_$user_output                000026 external static pointer                  dcl 88 set ref 231* 330 479
isaved                          000230 automatic       fixed bin(17,0)          dcl 37 set ref 384* 391* 395
last_col_rows                   000234 automatic       fixed bin(17,0)          dcl 40 set ref 365* 370
len                                    parameter       fixed bin(21,0)          dcl 579 set ref 575 585* 589 636 636 641 642
length                                                 builtin function         dcl 93 ref 376 430 430 434 538 538
line_position                   000421 automatic       fixed bin(21,0)          dcl 50 set ref 414* 415 419* 419 419 422
make_msf_                       000112 constant        entry                    external dcl 122 ref 606
max                                                    builtin function         dcl 93 ref 226 232
max_cols                        000233 automatic       fixed bin(17,0)          dcl 39 set ref 232* 233 238
max_seg_size                    000104 automatic       fixed bin(24,0)          dcl 26 set ref 341* 589 594 603 620
mod                                                    builtin function         dcl 93 ref 419
msf                             000105 automatic       bit(1)                   dcl 27 set ref 257* 258* 260 445 482 488 537 582
msf_manager_$close              000120 constant        entry                    external dcl 125 ref 497
msf_manager_$get_ptr            000122 constant        entry                    external dcl 126 ref 612 623
msf_manager_$open               000116 constant        entry                    external dcl 124 ref 609
nargs                           000222 automatic       fixed bin(17,0)          dcl 34 set ref 131* 132 141 511
next_arg                        004265 constant        entry                    internal dcl 507 ref 193 524
next_arg_num                    004310 constant        entry                    internal dcl 519 ref 158 166 175 184
next_row                        003405 constant        label                    dcl 427
noarg                           000347 constant        label                    dcl 133 set ref 207 511
nread                           000470 automatic       fixed bin(21,0)          dcl 533 set ref 538* 548 550
nspaces                         000420 automatic       fixed bin(21,0)          dcl 50 set ref 422* 423 423 423 423*
ntabs                           000417 automatic       fixed bin(21,0)          dcl 50 set ref 415* 416 418 418 418* 419
null                                                   builtin function         dcl 93 ref 33 33 243 264 264 274 274 279 283 290 321
                                                                                  330 479 482 488 497 500
num                                    parameter       fixed bin(21,0)          dcl 521 set ref 519 525*
nwords                          000414 automatic       fixed bin(21,0)          dcl 49 set ref 344* 345 354 356 363 363 365 378
of_dname                        000310 automatic       char(168)                unaligned dcl 42 set ref 194* 270 289* 294* 305*
                                                                                  308* 313* 313* 471 606* 609*
of_ename                        000372 automatic       char(32)                 unaligned dcl 43 set ref 194* 196 197 197* 272 289*
                                                                                  294* 305* 308* 313* 313* 472 606* 609*
output                          004553 constant        entry                    internal dcl 575 ref 361 368 404 408 418 423 430 434
                                                                                  436 636
output_cs                              based           char                     unaligned dcl 61 set ref 595* 641*
output_len                      000407 automatic       fixed bin(21,0)          dcl 46 set ref 332* 437* 440* 445 449* 453 589 594
                                                                                  595 595 630* 641 641 642* 642
output_ptr                      000220 automatic       pointer                  initial dcl 33 set ref 33* 243* 274* 276* 279* 289*
                                                                                  290 308* 312 317 330 330* 437* 449* 453* 479 479
                                                                                  479* 487 585* 603* 612* 616 620* 623* 627
output_seg_error                004026 constant        entry                    internal dcl 468 ref 275 277 290 295 300 306 309 586
                                                                                  604 607 610 613 621 624
page_len                        000423 automatic       fixed bin(21,0)          dcl 52 set ref 139* 175* 176 210 210* 213* 219 222*
pathname_                       000110 constant        entry                    external dcl 121 ref 313 313 313 313 348 348 454 454
                                                                                  464 464
print_wordlist                  000330 constant        entry                    external dcl 15
pwl                             000320 constant        entry                    external dcl 15
r                               000404 automatic       fixed bin(21,0)          dcl 45 set ref 367* 368 370*
read_next_word                  004546 constant        label                    dcl 567 ref 548 558
real_len                        000413 automatic       fixed bin(21,0)          dcl 48 set ref 385* 386 387* 387 390* 390 391 395
                                                                                  399* 405 407* 414
release_temp_segment_           000076 constant        entry                    external dcl 116 ref 485
ring_brackets                   000101 automatic       fixed bin(6,0)           array dcl 25 set ref 305* 606*
rows                            000232 automatic       fixed bin(21,0)          dcl 38 set ref 219* 220 338 357* 363 363* 365 365
                                                                                  367 374 377
rtrim                                                  builtin function         dcl 93 ref 196 261 270 376
search                                                 builtin function         dcl 93 ref 196
seg_output                      000107 automatic       bit(1)                   initial dcl 29 set ref 29* 200* 210 214 226 269 288
                                                                                  430 482 582
str                                    parameter       char                     unaligned dcl 578 set ref 575 585 585 595 636 636
                                                                                  641
substr                                                 builtin function         dcl 93 set ref 387 550* 554 562 595* 636 636 641*
sys_info$max_seg_size           000030 external static fixed bin(35,0)          dcl 89 ref 341
system_area                            based           area(1024)               dcl 64 ref 339 500
system_area_ptr                 000426 automatic       pointer                  dcl 53 set ref 244* 339 500
temp_ptr                        000226 automatic       pointer                  dcl 36 set ref 243* 317* 321 322* 437* 449* 479 482
                                                                                  485* 595 616* 627* 641
terminate_file_                 000106 constant        entry                    external dcl 120 ref 453 494 603 620
terminate_file_switches                based           structure                level 1 packed unaligned dcl 2-4
type                            000106 automatic       fixed bin(2,0)           dcl 28 set ref 249* 251 294* 296
unique_chars_                   000066 constant        entry                    external dcl 112 ref 264 274
unmake_msf_                     000114 constant        entry                    external dcl 123 ref 305
usage                           000352 constant        label                    dcl 134 ref 147
vert_margin                     000424 automatic       fixed bin(21,0)          dcl 52 set ref 139* 184* 185 214 214* 217* 219 222*
                                                                                  361 361 361* 430 434 434* 436 436 436
whoami                          000003 constant        char(32)                 initial unaligned dcl 79 set ref 134* 151* 160* 169*
                                                                                  178* 187* 203* 222* 235* 313* 322* 325* 348* 438*
                                                                                  450* 454* 464* 485*
word                                   based           char                     unaligned dcl 62 set ref 381 387 404*
word_index                      000433 automatic       fixed bin(17,0)          dcl 54 set ref 360* 375 376 377* 377 378 378*
word_len                        000412 automatic       fixed bin(21,0)          dcl 48 set ref 376* 381 386 387 395* 399 400 400*
                                                                                  404 404 404* 554* 555 560 560* 562 563
word_ptr                        000410 automatic       pointer                  dcl 47 set ref 375* 381 387 404
words                                  based           char                     array unaligned dcl 63 set ref 339 375 376 500 536
                                                                                  538 538 538 538 550* 562*
words_per_page                  000415 automatic       fixed bin(21,0)          dcl 49 set ref 338* 339 500 536
words_ptr                       000430 automatic       pointer                  dcl 53 set ref 243* 339* 375 376 500 500 536 538 538
                                                                                  538 538 550 562

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6152        6276    5463        6162
Length      6630    5463       124         315     467           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
pwl                                 517 external procedure  is an external procedure.  
on unit on line 247                  64 on unit               
input_seg_error                     140 internal procedure  is called by several nonquick procedures.  
cleaner                             100 internal procedure  is called by several nonquick procedures.  
next_arg                                internal procedure  shares stack frame of external procedure pwl.  
next_arg_num                            internal procedure  shares stack frame of external procedure pwl.  
fill_word_array                         internal procedure  shares stack frame of external procedure pwl.  
output                               99 internal procedure  is called during a stack extension.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
output                   000100 chars_that_fit              output
pwl                      000100 component                   pwl
                         000101 ring_brackets               pwl
                         000104 max_seg_size                pwl
                         000105 msf                         pwl
                         000106 type                        pwl
                         000107 seg_output                  pwl
                         000110 got_pname                   pwl
                         000111 first_time                  pwl
                         000112 atd                         pwl
                         000213 argno                       pwl
                         000214 ap                          pwl
                         000216 input_ptr                   pwl
                         000220 output_ptr                  pwl
                         000222 nargs                       pwl
                         000223 al                          pwl
                         000224 fcb_ptr                     pwl
                         000226 temp_ptr                    pwl
                         000230 isaved                      pwl
                         000231 cols                        pwl
                         000232 rows                        pwl
                         000233 max_cols                    pwl
                         000234 last_col_rows               pwl
                         000235 code                        pwl
                         000236 dname                       pwl
                         000310 of_dname                    pwl
                         000362 ename                       pwl
                         000372 of_ename                    pwl
                         000402 bc                          pwl
                         000403 c                           pwl
                         000404 r                           pwl
                         000405 i                           pwl
                         000406 input_len                   pwl
                         000407 output_len                  pwl
                         000410 word_ptr                    pwl
                         000412 word_len                    pwl
                         000413 real_len                    pwl
                         000414 nwords                      pwl
                         000415 words_per_page              pwl
                         000416 end_of_col                  pwl
                         000417 ntabs                       pwl
                         000420 nspaces                     pwl
                         000421 line_position               pwl
                         000422 col_width                   pwl
                         000423 page_len                    pwl
                         000424 vert_margin                 pwl
                         000425 input_idx                   pwl
                         000426 system_area_ptr             pwl
                         000430 words_ptr                   pwl
                         000432 first_word_row              pwl
                         000433 word_index                  pwl
                         000470 nread                       fill_word_array

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other_desc call_int_other      return              tra_ext             mod_fx1             enable
shorten_stack       ext_entry           int_entry           int_entry_desc      repeat              set_cs_eis
alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   cv_dec_check_
expand_pathname_              expand_pathname_$add_suffix   get_equal_name_               get_line_length_$switch
get_system_free_area_         get_temp_segment_             hcs_$make_seg                 hcs_$status_minf
initiate_file_                iox_$attach_name              iox_$close                    iox_$destroy_iocb
iox_$detach_iocb              iox_$get_line                 iox_$open                     iox_$put_chars
make_msf_                     msf_manager_$close            msf_manager_$get_ptr          msf_manager_$open
pathname_                     release_temp_segment_         terminate_file_               unique_chars_
unmake_msf_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$dirseg           error_table_$end_of_info      error_table_$long_record
error_table_$noarg            error_table_$short_record     error_table_$wrong_no_of_args iox_$user_output
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     29 000307        33 000312        15 000317       131 000336       132 000345       133 000347       134 000352
    136 000376       139 000377       140 000403       141 000405       142 000415       144 000432       145 000446
    146 000450       147 000453       149 000454       150 000512       151 000514       152 000540       154 000541
    155 000543       156 000544       158 000554       159 000556       160 000563       161 000617       163 000620
    164 000621       166 000631       167 000633       169 000640       170 000674       172 000675       173 000676
    175 000706       176 000710       178 000715       179 000751       181 000752       182 000753       184 000763
    185 000765       187 000771       188 001025       190 001026       191 001027       193 001037       194 001040
    195 001070       196 001072       197 001115       198 001144       200 001146       201 001150       203 001151
    204 001175       206 001176       207 001200       210 001202       213 001212       214 001214       217 001223
    219 001225       220 001233       222 001235       223 001271       226 001272       229 001305       231 001306
    232 001323       233 001330       235 001335       236 001362       238 001363       243 001370       244 001376
    245 001405       247 001406       249 001430       250 001467       251 001475       254 001502       255 001505
    256 001511       257 001512       258 001515       260 001516       261 001520       262 001552       263 001562
    264 001574       265 001661       266 001670       267 001711       269 001717       270 001721       271 001753
    272 001763       274 001775       275 002062       276 002071       277 002112       278 002120       279 002121
    280 002123       282 002124       283 002161       285 002171       286 002175       288 002177       289 002201
    290 002236       294 002253       295 002311       296 002317       299 002324       300 002327       305 002333
    306 002366       308 002374       309 002431       312 002437       313 002443       315 002537       317 002540
    321 002542       322 002546       323 002567       325 002571       326 002615       330 002616       332 002626
    337 002627       338 002631       339 002634       341 002645       343 002651       344 002652       345 002654
    348 002660       349 002734       352 002735       354 002736       356 002741       357 002742       360 002744
    361 002747       363 002772       365 003007       367 003017       368 003027       370 003047       373 003055
    374 003065       375 003070       376 003101       377 003121       378 003123       381 003132       382 003144
    384 003145       385 003150       386 003153       387 003165       390 003176       391 003177       394 003205
    395 003207       397 003215       399 003216       400 003220       404 003227       405 003246       407 003252
    408 003255       411 003275       413 003300       414 003302       415 003305       416 003313       418 003314
    419 003336       422 003352       423 003355       425 003402       426 003403       427 003405       430 003407
    434 003432       435 003467       436 003470       437 003520       438 003536       440 003564       443 003565
    445 003566       449 003572       450 003607       451 003635       453 003636       454 003665       457 003736
    459 003742       461 003743       464 003751       466 004022       468 004025       471 004033       472 004037
    473 004042       477 004043       479 004051       482 004064       485 004075       487 004116       488 004124
    490 004133       491 004145       492 004160       493 004173       494 004174       495 004223       497 004233
    500 004247       501 004264       507 004265       510 004266       511 004267       513 004272       515 004307
    519 004310       524 004312       525 004313       527 004342       529 004343       535 004345       536 004347
    537 004354       538 004356       539 004411       542 004416       543 004421       545 004422       547 004427
    548 004434       550 004437       551 004462       553 004463       554 004466       555 004504       557 004505
    558 004506       560 004507       562 004515       563 004541       566 004544       567 004546       570 004547
    571 004551       575 004552       582 004566       585 004573       586 004612       587 004622       589 004623
    594 004631       595 004634       597 004644       603 004646       604 004700       606 004710       607 004736
    609 004746       610 004774       612 005004       613 005032       614 005042       616 005045       617 005047
    620 005050       621 005102       623 005112       624 005141       626 005151       627 005153       630 005155
    636 005156       638 005215       641 005217       642 005231       644 005232


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
