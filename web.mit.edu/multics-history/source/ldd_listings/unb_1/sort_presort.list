	COMPILATION LISTING OF SEGMENT sort_presort
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/11/82  1308.7 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* ***************************************
        8*   *				 *
        9*   *				 *
       10*   * Copyright (c) 1975, 1976 by         *
       11*   * Honeywell Information Systems, Inc. *
       12*   *				 *
       13*   *				 *
       14*   *************************************** */
       15 sort_presort:			proc(ec);			/* Version 2. */
       16 
       17 			/*    EXTERNAL ENTRIES    */
       18 dcl  sub_err_ entry  options(variable);
       19 dcl	hcs_$make_seg  entry(char(*) aligned, char(*) aligned, char(*), fixed bin(5), ptr, fixed bin(35)),
       20 	ioa_$rsnnl entry options(variable);
       21 			/*    EXTERNAL STATIC    */
       22 
  1     1 dcl 1 sort_ext$acl(1) ext,
  1     2    2 x_user_id char(32),
  1     3    2 x_modes bit(36),
  1     4    2 x_pad bit(36),
  1     5    2 x_acl_code fixed bin(35);
  1     6 dcl 1 acl(1)
  1     7 	 defined(sort_ext$acl),
  1     8    2 user_id char(32),
  1     9    2 modes bit(36),
  1    10    2 pad bit(36),
  1    11    2 acl_code fixed bin(35);
  1    12 dcl sort_ext$b(0: 31) fixed bin(30) ext;		/*  keys - bit offset (usually) for sort_comp  */
  1    13 dcl b(0: 31) fixed bin(30)
  1    14 	 defined (sort_ext$b);
  1    15 dcl sort_ext$compares_counter fixed bin(34) ext;		/*  compares executed, excluding sequence checker  */
  1    16 dcl compares_counter fixed bin(34)
  1    17 	 defined(sort_ext$compares_counter);
  1    18 dcl sort_ext$compare_sw fixed bin(1) ext;		/*  1 = user compare exit specified  */
  1    19 dcl compare_sw fixed bin(1)
  1    20 	 defined (sort_ext$compare_sw);
  1    21 dcl sort_ext$curr_input_file_attach char(256) ext;	/*  attach description, current input file (Sort)  */
  1    22 dcl curr_input_file_attach char(256)
  1    23 	 defined(sort_ext$curr_input_file_attach);
  1    24 dcl sort_ext$curr_input_file_name char(256) ext;		/*  pathname, current input file (Sort)  */
  1    25 dcl curr_input_file_name char(256)
  1    26 	 defined (sort_ext$curr_input_file_name);
  1    27 dcl sort_ext$curr_input_file_num fixed bin(17) ext;	/*  number for current input file (Sort)  */
  1    28 dcl curr_input_file_num fixed bin(17)
  1    29 	 defined (sort_ext$curr_input_file_num);
  1    30 dcl sort_ext$curr_output_file_attach char(256) ext;	/*  attach description, output file  */
  1    31 dcl curr_output_file_attach char(256)
  1    32 	 defined(sort_ext$curr_output_file_attach);
  1    33 dcl sort_ext$curr_output_file_name char(256) ext;		/*  pathname, output file  */
  1    34 dcl curr_output_file_name char(256)
  1    35 	 defined (sort_ext$curr_output_file_name);
  1    36 dcl sort_ext$debug_sw bit(1) ext;			/*  1 = -debug argument specified  */
  1    37 dcl debug_sw bit(1)
  1    38 	 defined(sort_ext$debug_sw);
  1    39 dcl sort_ext$disaster2 fixed bin(17) ext;		/*  0 = first call to sort_return or merge_return  */
  1    40 dcl disaster2 fixed bin(17)
  1    41 	 defined (sort_ext$disaster2);
  1    42 dcl sort_ext$dt(0: 31) fixed bin(30) ext;		/*  keys - datatype for sort_comp  */
  1    43 dcl dt(0: 31) fixed bin(30)
  1    44 	 defined (sort_ext$dt);
  1    45 dcl sort_ext$input_driver_is_sort bit(1) ext;		/*  1 = Sort reads input files, 0 = input_file exit  */
  1    46 dcl input_driver_is_sort bit(1)
  1    47 	 defined(sort_ext$input_driver_is_sort);
  1    48 dcl sort_ext$input_file_exit_sw bit(1) ext;		/*  1 = user input_file exit specified  */
  1    49 dcl input_file_exit_sw bit(1)
  1    50 	 defined(sort_ext$input_file_exit_sw);
  1    51 dcl sort_ext$input_file_max fixed bin(17) ext;		/*  number of input files specified [init(10)]  */
  1    52 		/*  must also change  merge_return:  merge_read_count  &  input_file_len  */
  1    53 dcl input_file_max fixed bin(17)
  1    54 	 defined(sort_ext$input_file_max);
  1    55 dcl sort_ext$input_record_exit_sw fixed bin(1) ext;	/*  1 = user input_record exit specified  */
  1    56 dcl input_record_exit_sw fixed bin(1)
  1    57 	 defined(sort_ext$input_record_exit_sw);
  1    58 dcl sort_ext$input_rec_deleted fixed bin(30) ext;		/*  number of records deleted at input_record exit  */
  1    59 dcl input_rec_deleted fixed bin(30)
  1    60 	 defined(sort_ext$input_rec_deleted);
  1    61 dcl sort_ext$input_rec_inserted fixed bin(30) ext;	/*  number of records inserted _record exit  */
  1    62 dcl input_rec_inserted fixed bin(30)
  1    63 	 defined(sort_ext$input_rec_inserted);
  1    64 dcl sort_ext$in_buff_ptr ptr ext;			/*  buffer for an input record (Sort or Merge reading)  */
  1    65 dcl in_buff_ptr ptr
  1    66 	 defined (sort_ext$in_buff_ptr);
  1    67 dcl sort_ext$leng(0: 31) fixed bin(30) ext;		/*  keys - length or precision for sort_comp  */
  1    68 dcl leng(0: 31) fixed bin(30)
  1    69 	 defined (sort_ext$leng);
  1    70 dcl sort_ext$max1 fixed bin(30) ext;			/*  limits size of unsorted string SS (sort_release)  */
  1    71 dcl max1 fixed bin(30)
  1    72 	 defined (sort_ext$max1);
  1    73 dcl sort_ext$max2 fixed bin(30) ext;			/*  limits size of unsorted string SS (sort_release)  */
  1    74 dcl max2 fixed bin(30)
  1    75 	 defined (sort_ext$max2);
  1    76 dcl sort_ext$max3 fixed bin(30) ext;			/*  maximum number of records per string SS  */
  1    77 dcl max3 fixed bin(30)
  1    78 	 defined (sort_ext$max3);
  1    79 dcl sort_ext$max4 fixed bin(30) ext;			/*  maximum merge order allowed (sort_presort)  */
  1    80 dcl max4 fixed bin(30)
  1    81 	 defined (sort_ext$max4);
  1    82 dcl sort_ext$max_rec_length fixed bin(30) ext;		/*  maximum record length permitted by Sort or Merge;  */
  1    83 						/*  slightly less than sys_info$max_seg_size  */
  1    84 dcl max_rec_length fixed bin(30)
  1    85 	 defined (sort_ext$max_rec_length);
  1    86 dcl sort_ext$merge_compares fixed bin(34) ext;		/*  number of compares in merge  */
  1    87 dcl merge_compares fixed bin(34)
  1    88 	 defined(sort_ext$merge_compares);
  1    89 dcl sort_ext$merge_in_iocb_ptrs(10) ptr ext;		/*  iox_ iocb's for Merge input files  */
  1    90 dcl merge_in_iocb_ptrs(10) ptr
  1    91 	 defined(sort_ext$merge_in_iocb_ptrs);
  1    92 dcl sort_ext$merge_input_file_attaches(10) char(256) ext;	/*  attach descriptions, Merge input files  */
  1    93 dcl merge_input_file_attaches(10) char(256)
  1    94 	 defined(sort_ext$merge_input_file_attaches);
  1    95 dcl sort_ext$merge_input_file_names(10) char(256) ext;	/*  pathnames, Merge input files  */
  1    96 dcl merge_input_file_names(10) char(256)
  1    97 	 defined(sort_ext$merge_input_file_names);
  1    98 dcl sort_ext$mii fixed bin(17) ext;			/*  merge order for Sort [init(0)]  */
  1    99 dcl mii fixed bin(17)
  1   100 	 defined (sort_ext$mii);
  1   101 dcl sort_ext$min_rec_length fixed bin(30) ext;		/*  record length required to include all key fields  */
  1   102 dcl min_rec_length fixed bin(30)
  1   103 	 defined (sort_ext$min_rec_length);
  1   104 dcl sort_ext$mip (1000) fixed bin(30) ext;		/*  number of records in each string MS for merge  */
  1   105 dcl mip (1000) fixed bin(30)
  1   106 	 defined (sort_ext$mip);
  1   107 dcl sort_ext$msp (1000) ptr ext;			/*  sorted strings MS(1:mii) to be merged  */
  1   108 dcl msp (1000) ptr
  1   109 	 defined (sort_ext$msp);
  1   110 dcl sort_ext$no_of_keys fixed bin(30) ext;		/*  number of keys specified  */
  1   111 dcl no_of_keys fixed bin(30)
  1   112 	 defined(sort_ext$no_of_keys);
  1   113 dcl sort_ext$old_input_file_num fixed bin(17) ext;	/*  used for identifying files with bad key data  */
  1   114 dcl old_input_file_num fixed bin(17)			/*       (illegal_procedure handler in sort_presort)  */
  1   115 	 defined(sort_ext$old_input_file_num);
  1   116 dcl sort_ext$output_driver_is_sort bit(1) ext;		/*  1 = Sort or Merge writes output file;  */
  1   117 dcl output_driver_is_sort bit(1)			/*  0 = output_file exit  */
  1   118 	 defined(sort_ext$output_driver_is_sort);
  1   119 dcl sort_ext$output_file_exit_sw bit(1) ext;		/*  1 = user output_file exit specified  */
  1   120 dcl output_file_exit_sw bit(1)
  1   121 	 defined(sort_ext$output_file_exit_sw);
  1   122 dcl sort_ext$output_rec_deleted fixed bin(30) ext;	/*  number of records deleted at output_record exit  */
  1   123 dcl output_rec_deleted fixed bin(30)
  1   124 	 defined(sort_ext$output_rec_deleted);
  1   125 dcl sort_ext$output_rec_inserted fixed bin(30) ext;	/*  number of record inserted at output_record exit  */
  1   126 dcl output_rec_inserted fixed bin(30)
  1   127 	 defined(sort_ext$output_rec_inserted);
  1   128 dcl sort_ext$output_record_exit_sw fixed bin(1) ext;	/*  1 = user output_record exit specified  */
  1   129 dcl output_record_exit_sw fixed bin(1)
  1   130 	 defined(sort_ext$output_record_exit_sw);
  1   131 dcl sort_ext$presort_compares fixed bin(34) ext;		/*  number of compares in presort  */
  1   132 dcl presort_compares fixed bin(34)
  1   133 	 defined(sort_ext$presort_compares);
  1   134 dcl 1 sort_ext$pu(5) ext,
  1   135    2 x_n fixed bin,					/*  [init((5) 1)]  */
  1   136    2 x_rcpu fixed bin(71);
  1   137 dcl 1 pu(5)
  1   138 	 defined(sort_ext$pu),
  1   139    2 n fixed bin,
  1   140    2 rcpu fixed bin(71);
  1   141 dcl sort_ext$read_count fixed bin(30) ext;		/*  number of records read by Sort (or by Merge)  */
  1   142 dcl read_count fixed bin(30)
  1   143 	 defined (sort_ext$read_count);
  1   144 dcl sort_ext$rec_ptr_a ptr ext;			/*  buffer for output_record exit and sequence checker  */
  1   145 dcl rec_ptr_a ptr
  1   146 	 defined(sort_ext$rec_ptr_a);
  1   147 dcl sort_ext$rec_ptr_b ptr ext;			/*  buffer for output_record exit and sequence checker  */
  1   148 dcl rec_ptr_b ptr
  1   149 	 defined(sort_ext$rec_ptr_b);
  1   150 dcl sort_ext$release_count fixed bin(30) ext;		/*  number of records released to Sort (Merge)  */
  1   151 dcl release_count fixed bin(30)
  1   152 	 defined (sort_ext$release_count);
  1   153 dcl sort_ext$report_sw bit(2) ext;			/*  00 = print summary report, 01 = suppress  */
  1   154 dcl report_sw bit(2)
  1   155 	 defined (sort_ext$report_sw);
  1   156 dcl sort_ext$return_count fixed bin(30) ext;		/*  number of records returned from Sort (Merge)  */
  1   157 dcl return_count fixed bin(30)
  1   158 	 defined (sort_ext$return_count);
  1   159 dcl sort_ext$rev(0: 31) fixed bin(1) ext;		/*  keys - descending indicator for sort_comp  */
  1   160 dcl rev(0: 31) fixed bin(1)
  1   161 	 defined (sort_ext$rev);
  1   162 dcl sort_ext$sii fixed bin(30) ext;			/*  number of records, current string (sort_release)  */
  1   163 dcl sii fixed bin(30)
  1   164 	 defined (sort_ext$sii);
  1   165 dcl sort_ext$sip ptr ext;				/*  SI - tree of indices (subscripts) for records  */
  1   166 dcl sip ptr					/*       being sorted or merged  */
  1   167 	 defined (sort_ext$sip);
  1   168 dcl sort_ext$sort_compare_exit variable			/*  entry point, user compare exit procedure  */
  1   169 	 entry(ptr, ptr) returns(fixed bin(1)) ext;
  1   170 dcl sort_ext$sort_desc_pn  char(168) ext;		/*  pathname, Sort (Merge) Description segment  */
  1   171 dcl sort_desc_pn char(168)
  1   172 	 defined(sort_ext$sort_desc_pn);
  1   173 dcl sort_ext$sort_input_record_exit variable		/*  entry point, user input_record exit procedure  */
  1   174 	 entry(ptr, fixed bin(21), fixed bin, bit(1)) ext;
  1   175 dcl sort_input_record_exit variable
  1   176 	entry(ptr, fixed bin(21), fixed bin, bit(1))
  1   177 	 defined(sort_ext$sort_input_record_exit);
  1   178 dcl sort_ext$sort_output_record_exit variable		/*  entry point, user output_record exit procedure  */
  1   179 	entry(ptr, fixed bin(21), ptr, fixed bin(21), fixed bin, fixed bin(1), bit(1), bit(1), bit(1)) ext;
  1   180 dcl sort_output_record_exit variable
  1   181 	entry(ptr, fixed bin(21), ptr, fixed bin(21), fixed bin, fixed bin(1), bit(1), bit(1), bit(1))
  1   182 	defined(sort_ext$sort_output_record_exit);
  1   183 dcl sort_ext$srp ptr ext;				/*  SR - position and length of each record  */
  1   184 dcl srp ptr					/*       in SS string for presort  */
  1   185 	 defined (sort_ext$srp);
  1   186 dcl sort_ext$ssi fixed bin(30) ext;			/*  char offset in SS of current record (sort_release)  */
  1   187 dcl ssi fixed bin(30)
  1   188 	 defined (sort_ext$ssi);
  1   189 dcl sort_ext$ssp ptr ext;				/*  SS - unsorted string during presort  */
  1   190 dcl ssp ptr
  1   191 	 defined (sort_ext$ssp);
  1   192 dcl sort_ext$state fixed bin(17) ext;			/*  state variable controlling sequence of calls to  */
  1   193 dcl state fixed bin(17)				/*    the various stages of the Sort (Merge) [init(0)]  */
  1   194 	 defined (sort_ext$state);
  1   195 dcl sort_ext$terminate_print_sw bit(1) ext;		/*  0 = command prints (sort_merge_print_report)  */
  1   196 dcl terminate_print_sw bit(1)				/*  1 = subroutine prints (sort_merge_terminate)  */
  1   197 	 defined (sort_ext$terminate_print_sw);
  1   198 dcl 1 sort_ext$time_info(5) ext,			/*  used for -time information  */
  1   199    2 x_etime fixed bin(71),
  1   200    2 x_vtime fixed bin(71),
  1   201    2 x_pf fixed bin,
  1   202    2 x_pd_f fixed bin;
  1   203 dcl 1 time_info(5)
  1   204 	 defined(sort_ext$time_info),
  1   205    2 etime fixed bin(71),
  1   206    2 vtime fixed bin(71),
  1   207    2 pf fixed bin,
  1   208    2 pd_f fixed bin;
  1   209 dcl sort_ext$time_sw bit(1) ext;			/*  1 = -time argument specified  */
  1   210 dcl time_sw bit(1)
  1   211 	 defined(sort_ext$time_sw);
  1   212 dcl sort_ext$user_out_sw char(32) ext;			/*  I/O switch for summary report, diagnostics:  */
  1   213 dcl user_out_sw char(32)				/*       "user_output", "" = suppress, other = user switch  */
  1   214 	 defined(sort_ext$user_out_sw);
  1   215 dcl sort_ext$unique_prefix char(16) ext;		/*  unique to each invocation, for temporary names  */
  1   216 dcl unique_prefix char(16)
  1   217 	 defined (sort_ext$unique_prefix); /* -4- */ 
  1   218 dcl sort_ext$w(0: 31) fixed bin(30) ext;		/*  keys - word (sometimes char) offset for sort_comp  */
  1   219 dcl w(0: 31) fixed bin(30)
  1   220 	 defined (sort_ext$w);
  1   221 dcl sort_ext$wf_dir_name char(168) aligned ext;		/*  -td directory pathname argument  */
  1   222 dcl wf_dir_name char(168) aligned
  1   223 	 defined(sort_ext$wf_dir_name);
  1   224 dcl sort_ext$wf_full_name char(168) ext;		/*  absolute -td directory pathname  */
  1   225 dcl wf_full_name char(168)
  1   226 	 defined (sort_ext$wf_full_name); /* -42- */ 
  1   227 dcl sort_ext$whoami char(6) ext;			/*  "sort", "merge", "sort_", "merge_" called  */
  1   228 dcl whoami char(6)
  1   229 	 defined (sort_ext$whoami); /* -2- */ 
  1   230 dcl sort_ext$write_count fixed bin(30) ext;		/*  number of records written by Sort (Merge)  */
  1   231 dcl write_count fixed bin(30)
  1   232 	 defined (sort_ext$write_count);
       23 
       24 	dcl	error_table_$fatal_error fixed bin(35) external,
       25 		error_table_$improper_data_format fixed bin(35) ext;
       26 
       27 			/*  PARAMETERS,AUTOMATIC, & BASED  */
       28 	dcl	N char(8),
       29 		ms_name char(32) aligned,
       30 		shortinfo char(8) aligned,
       31 		longinfo char(100) aligned,
       32 		ioa_len fixed bin(17);
       33 dcl  hcs_code fixed bin(35);
       34 dcl  retval  fixed bin(35);
       35 	dcl	(ns init(1),
       36 		np init(0)) fixed bin(30),
       37 		s(0:36);
       38 	dcl 	i1 fixed bin(30);
       39 	dcl	sp ptr,
       40 		rp ptr;
  2     1 dcl	result fixed bin(1);		/*  result of compare procedure (Sort's or user's)  */
  2     2 
  2     3 dcl	I (255*1024) fixed bin(30) based,     /*  an array, which when based upon sip (presort)
  2     4*			    contain entries which are indexes to rows in R table */
  2     5 			    /*  when based upon mip (merge) each row contains the
  2     6*	 		    number of records in each merge string    */
  2     7 	1  R (85*1024) based,	/*   85 = 255/3   */
  2     8 	    2 pt fixed bin(30), 	    /* references the first character in the S string
  2     9*			    of each record		  	 */
  2    10 	    2 ln fixed bin(30);	    /*  references the  number of characters in each
  2    11*			    record of the S string	          */
  2    12 dcl	S char(255*4096) based,	    /*  string of presort records	*/
  2    13 	S1(255*4096) char(1) based;	    /*  used in adjusting pointers  */
  2    14 	dcl	ec fixed bin(35) parameter,
  2    15 		pt1 ptr,
  2    16 		pt2 ptr,
  2    17 		w_p ptr int static,
  2    18 		fb fixed bin(21) based(w_p);
       41 
       42 dcl  (t,n,v1,v2,l,x,j,y,lft,rit,i) fixed bin(30);
       43 dcl  sip_a  ptr,
       44      srp_a  ptr,
       45      ssp_a  ptr;
       46 dcl  compares_counter_a  fixed bin(34);
       47 
       48 start:	ec = 0;
       49      sip_a = sip;
       50      compares_counter_a = 0;
       51      srp_a = srp;
       52      ssp_a = ssp;
       53 
       54 on illegal_procedure call illegal_procedure_handler;
       55 
       56 	i=mii+1;	/* Count the merge strings. */
       57 	if i>max4 then do;
       58 	     call sub_err_(0, whoami, "c", null(), retval, "Maximum merge order of ^d exceeded.", max4);
       59 	     ec = error_table_$fatal_error;
       60 	     go to exit;
       61 	     end;
       62 	/* Create the next merge string  S segment. */
       63 	    call ioa_$rsnnl("^d",N,ioa_len,i);
       64 	     ms_name = unique_prefix||"sort_work.MS."||N;
       65 	   call hcs_$make_seg(wf_dir_name, ms_name, "", 8+2,  /*  rw  */ sp, hcs_code);
       66 	    if hcs_code ^= 0 then do;
       67 		ec = error_table_$fatal_error;
       68 		call sub_err_(hcs_code, whoami, "c", null(), retval, " ^a  Unable to create temporary segment ^a>^a",
       69 			longinfo, before(wf_dir_name, " "), ms_name);
       70 		go to exit;
       71 		end;
       72 	/*  if i = 1 then cmpe=cmp;    assign comparison procedure at the first call */
       73 
       74 	mii=i;             /*  set merege item index  */
       75 	mip(i) = sii;	/*  number of records in ith merge string  */
       76 	msp(i)=sp;	/* Pointer to "next" merge S string. */
       77 
       78 /*
       79*	calculate the lengths of
       80*	lists and their start pointers
       81*	in a linear set.
       82**/
       83 	/*   set up array of indices-each indicating beginning of next group of records to be  sorted  */
       84 	s(0) = 0;		/*   for case where sii = 1 and n will be = 0   */
       85 	t=0;
       86 	l=sii;		/*  number of records to  be  sorted  */
       87 	do n=1 by 1 while(l>1);
       88 	s(n)=t;  /* start of the next list  an array of indices-each index indicating start of next  list */
       89 	if substr(unspec(l),36,1) then do;
       90 		l=l+1;  /* make the length even. */
       91 		sip_a->I(t+l) = 0;		/*   clear second word of last pair if l is odd   */
       92 		end;
       93 	t=t+l;  /* accumulate the lengths. */
       94 	l = divide(l,2,24);  /*  next list is 1/2 the length of the present list  */
       95 	end;
       96 	n=n-1;
       97 
       98 		/*  below fills in I array(of indices into R) to reflect sorted records-performs presort*/
       99 	do i=2 to n;
      100 	lft=s(i-1); 
      101 	rit=s(i) ;
      102 	do j=1 by 2 to (rit - lft );
      103 	x=lft+j;
      104 	v1=sip_a->I(x);
      105 	v2=sip_a->I(x+1);
      106 	if v2>0 then do;
      107 		/*  below sets up pointers to records in S string  */
      108 	     pt2 = addr(ssp_a->S1(srp_a->R.pt(v2)));
      109 	     pt1 = addr(ssp_a->S1(srp_a->R.pt(v1)));
      110 	    call sort_comp;
      111 	    compares_counter_a=compares_counter_a+1;
      112 	    if result = 0 then	/*  records ranked  equal  */
      113 		do;
      114 		if v1 < v2
      115 		    then result = -1;     /*  rank records 1 first  */
      116 		    else result = 1;     /*  rank record 2 first  */
      117 		end;
      118 	if result>0 then v1=v2;
      119 	end;
      120 	rit=rit+1;
      121 	sip_a->I(rit)=v1;
      122 	end;
      123 	end;
      124 
      125 		/*  below sets up new,sorted merge string  */
      126 		/*  sets up new R table to reflect sorted records */
      127 	y=s(n)+1;
      128 	do i=1 to sii;		/*  gets last two winner records from previous sorts  */
      129 	v2=sip_a->I(y+1);
      130 	v1=sip_a->I(y);
      131 	if v1 ^= 0 then;
      132 	    else if v2 ^= 0 then;
      133 	else i = sii + 1;
      134 	do;
      135 	if v1=0 then v1=v2;
      136 	else
      137 	if v2>0 then do;
      138 		/*  below sets up pointers to records within S string  */
      139 	     pt2 = addr(ssp_a->S1(srp_a->R.pt(v2)));
      140 	     pt1 = addr(ssp_a->S1(srp_a->R.pt(v1)));
      141 	    call sort_comp;
      142 	    compares_counter_a=compares_counter_a+1;
      143 	    if result = 0 then	/*  records ranked  equal  */
      144 		do;
      145 		if v1 < v2
      146 		    then result = -1;     /*  rank records 1 first  */
      147 		    else result = 1;     /*  rank record 2 first  */
      148 		end;
      149 	if result>0 then v1=v2;
      150 	end;
      151 	/* Move the next sorted record to the merge  string. */
      152 	l=srp_a->R.ln(v1);	/*  length of winner record  */
      153 		/*  following will set up mechansim for double word  alignemnt  */
      154 	    ns = divide(ns + 4 -1 + 7,8,24)*8 +1;
      155 	w_p =  addr(substr(sp->S,ns,1));
      156 	w_p=ptr(w_p,fixed(rel(w_p),21)-1);  /*  move back 1 word to get lenght of record  */
      157 	fb =  l;    /*  set length  */
      158 	substr(sp->S, ns, l)= substr( ssp_a->S,  srp_a->R.pt(v1), l); /* move winner record into new S string-based on sp */
      159 	np=np+1;
      160 	ns=ns+l;
      161 	sip_a->I(v1)=0; /* delete the last winner. */
      162 		/*  below goes  through second pass of pre-sort  */
      163 	do j=2 to n;  /* get the next winner. */
      164 	lft=s(j-1);
      165 	if substr(unspec(v1),36,1) then v2=v1+1;  else v2=v1-1;
      166 	v2=sip_a->I(v2+lft);
      167 	x = divide((v1+1),2,24);
      168 	v1=sip_a->I(v1+lft);
      169 	if v1=0 then v1=v2;
      170 	else
      171 	if v2>0 then do;
      172 		/*  below sets up pointers to records within S string  */
      173 	     pt2 = addr(ssp_a->S1(srp_a->R.pt(v2)));
      174 	     pt1 = addr(ssp_a->S1(srp_a->R.pt(v1)));
      175 	    call sort_comp;
      176 	    compares_counter_a=compares_counter_a+1;
      177 	    if result = 0 then	/*  records ranked  equal  */
      178 		do;
      179 		if v1 < v2
      180 		    then result = -1;     /*  rank records 1 first  */
      181 		    else result = 1;     /*  rank record 2 first  */
      182 		end;
      183 	if result>0 then v1=v2;
      184 	end;
      185 	sip_a->I(x+s(j))=v1;
      186 	v1=x;
      187 	end;
      188 	end;
      189 	end;
      190 
      191 	old_input_file_num = curr_input_file_num;
      192 exit:
      193      compares_counter = compares_counter + compares_counter_a;
      194 	return;
      195 
  3     1 	sort_comp:  proc;
  3     2 		/*  sort's standard comparison routine		*/
  3     3 	dcl	b_str bit(32000) based,	/*  used for bit string data type  */
  3     4 		fb1(0:32000) fixed bin(35) based,	/*  used for bin, aligned, size = 36 bits-1 word  */
  3     5 		fb2(0:32000) fixed bin(71) based,	/*  used for bin, aligned, size = 72 bits-2 words  */
  3     6 		(work_1,work_2) fixed bin(71),/*  used for bin unaligned  */
  3     7 		flb1(0:32000) float bin(27) based,	/*  used for float bin, aligned, size = 36 bits-1 word  */
  3     8 		flb2(0:32000) float bin(63) based,	/*  used for float bin, aligned, size = 72 bits-2 words  */
  3     9 		(work_3,work_4) float bin(63) aligned,  /*  used for float bin,unaligned  */
  3    10 		(work_5,work_6) dec(59),	/*  used for decimal  */
  3    11 		(work_7,work_8) float dec(59);  /*  floating decimal-taking 61 bytes  */
  3    12 	dcl	dec_char char(61) based aligned,
  3    13 		dec_ptr1 ptr,
  3    14 		dec_ptr2 ptr;
  3    15 	dcl	dec_ptr3 ptr,
  3    16 		dec_ptr4 ptr;
  3    17 	    if compare_sw ^= 0 then
  3    18 		do;  /*  invoke user's compare routine  */
  3    19 		 result = sort_ext$sort_compare_exit(pt1,pt2);
  3    20 		 if result ^= 0 then go to con;
  3    21 		end;
  3    22 	    else do;
  3    23 	    do i1 = 0 to no_of_keys;
  3    24 	    go to lab(dt(i1));
  3    25   lab(1):		/*  data type = char  */
  3    26 	    if substr(pt1->S,b(i1),leng(i1))<
  3    27 	       substr(pt2->S,b(i1),leng(i1))
  3    28 		then result = -1;  /*  record 1 ranks first  */
  3    29 		else if substr(pt1->S,b(i1),leng(i1))>
  3    30 		        substr(pt2->S,b(i1),leng(i1))
  3    31 		  	   then result = 1;
  3    32 			   else go to next_key;
  3    33 		go to esc;
  3    34   lab(2):		/*  data type = bit  */
  3    35 	    if substr(pt1->b_str,b(i1),leng(i1)) <
  3    36 	       substr(pt2->b_str,b(i1),leng(i1))
  3    37 		then result = -1;
  3    38 		else if substr(pt1->b_str,b(i1),leng(i1)) >
  3    39 		        substr(pt2->b_str,b(i1),leng(i1))
  3    40 			   then result = 1;  /*  record 2 ranks first  */
  3    41 			   else go to next_key;
  3    42 		go to esc;
  3    43   lab(3):			/*  data type = binary-aligned-size= 1 word  */
  3    44 	    if pt1->fb1(w(i1)) <
  3    45 	       pt2->fb1(w(i1))
  3    46 		then result = -1;    /*  record 1 ranks first  */
  3    47 		else if pt1->fb1(w(i1))>
  3    48 		        pt2->fb1(w(i1))
  3    49 			then result = 1;  /*  record 2 ranks first  */
  3    50 			else go to next_key;
  3    51 		go to esc;
  3    52   lab(4):		/*  data type = binary-aligned-size = 2 words  */
  3    53 	    if pt1->fb2(w(i1)) <
  3    54 	       pt2->fb2(w(i1))
  3    55 		then result = -1;  /*  record 1 ranks first  */
  3    56 		else if pt1->fb2(w(i1)) >
  3    57 		        pt2->fb2(w(i1))
  3    58 			then result = 1;  /*  record 2 ranks first  */
  3    59 			else go to next_key;
  3    60 		go to esc;
  3    61   lab(5):		/*  data type = binary-unaligned: 1<= len <= 71  */
  3    62 	    work_1 = 0;
  3    63 	    work_2 = 0;		/*  0 out work areas  */
  3    64 	    substr(unspec(work_1),1,leng(i1)+1)=substr(pt1->b_str,b(i1),leng(i1)+1);
  3    65 		/*  move unaligned bit string into aligned work field  */
  3    66 	    substr(unspec(work_2),1,leng(i1)+1)=substr(pt2->b_str,b(i1),leng(i1)+1);
  3    67 	    if work_1 < work_2 then result = -1;  /*  record 1 ranks first  */
  3    68 			   else if work_1 > work_2 then result = 1;  /*  record 2 ranks first  */ 
  3    69 				else go to next_key;
  3    70 		go to esc;
  3    71   lab(6):		/*  data type = floating bin-aligned,size = 1 word  */
  3    72 	    if pt1->flb1(w(i1)) <
  3    73 	       pt2->flb1(w(i1))
  3    74 		then result = -1;  /*  record 1 ranks first  */
  3    75 		else if pt1->flb1(w(i1)) >
  3    76 		        pt2->flb1(w(i1))
  3    77 			then result = 1;  /*  record 2 ranks first  */
  3    78 			else go to next_key;
  3    79 		go to esc;
  3    80   lab(7):		/*  data type = floating bin - aligned, size = 2 words  */
  3    81 	    if pt1->flb2(w(i1)) <
  3    82 	       pt2->flb2(w(i1))
  3    83 		then result = -1;  /*  record 1 ranks first  */
  3    84 		else if pt1->flb2(w(i1)) >
  3    85 	 	        pt2->flb2(w(i1))
  3    86 			then result = 1;  /*  record 2 ranks first  */
  3    87 			else go to next_key;
  3    88 		go to esc;
  3    89   lab(8):		/*  data type = floating bin-unaligned  */
  3    90 	    work_3 = 0;
  3    91 	    work_4 = 0;  /*  0 out work areas  */
  3    92 	    substr(unspec(work_3),1,leng(i1)+9)=substr(pt1->b_str,b(i1),leng(i1)+9);
  3    93 	    substr(unspec(work_4),1,leng(i1)+9)=substr(pt2->b_str,b(i1),leng(i1)+9);
  3    94 		/*  move unaligned bit string into aligned work field  */
  3    95 	    if work_3 < work_4 then result = -1;  /*  recordnks first  */
  3    96 			   else if work_3 > work_4 then result = 1;  /*  record 2 ranks first  */
  3    97 				else go to next_key;
  3    98 		go to esc;
  3    99   lab(9):		/*  data type = decimal  */
  3   100 	    work_5 = 0;
  3   101 	     dec_ptr3 = addr(work_5);
  3   102 	    work_6 = 0;  /*  0 out work areas  */
  3   103 	     dec_ptr4 = addr(work_6);
  3   104 	    substr(dec_ptr3->dec_char,1,leng(i1)+1)=substr(pt1->S,b(i1),leng(i1)+1);
  3   105 	    substr(dec_ptr4->dec_char,1,leng(i1)+1)=substr(pt2->S,b(i1),leng(i1)+1);
  3   106 		/*  move decimal field into work field  */
  3   107 	    if work_5 < work_6 then result = -1;  /*  record 1 ranks first  */
  3   108 			   else if work_5 > work_6 then result = 1;  /*  record 2 ranks first  */
  3   109 					       else go to next_key;
  3   110 		go to esc;
  3   111   lab(10):		/*  data type = floating decimal  */
  3   112 	    work_7 = 0;
  3   113 	     dec_ptr1 = addr(work_7);
  3   114 	    work_8 = 0;  /*  0 out work areas  */
  3   115 	     dec_ptr2 = addr(work_8);
  3   116 	    substr(dec_ptr1->dec_char,1,leng(i1)+1)=substr(pt1->S,b(i1),leng(i1)+1);
  3   117 	    substr(dec_ptr2->dec_char,1,leng(i1)+1)=substr(pt2->S,b(i1),leng(i1)+1);
  3   118 		/*  move sign and digits into work areas  */
  3   119 	    substr(dec_ptr1->dec_char,61,1)=substr(pt1->S,leng(i1)+1+b(i1),1);
  3   120 	    substr(dec_ptr2->dec_char,61,1)=substr(pt2->S,leng(i1)+1+b(i1),1);
  3   121 		/*  move exponent portion into work field  */
  3   122 	    if work_7 < work_8 then result = -1;  /*  record 1 ranks first  */
  3   123 			   else if work_7 > work_8 then result = 1;  /*  record 2 ranks first  */
  3   124 					       else go to next_key;
  3   125 		go to esc;
  3   126   next_key: end;    /*  ends do loop  */
  3   127 	    result = 0;    /*  all keys equal  */
  3   128 	    return;
  3   129   esc:	    if rev(i1) ^= 0 then result = -result;  /*  reverse ranking  */
  3   130   con:  end;    /*  ends sort's comparison routine  */
  3   131 	end sort_comp;
      196 
      197 
      198 
      199 dcl  illegal_procedure condition;
      200 
      201 illegal_procedure_handler:  proc;
      202 dcl  key_part char(40),
      203      type char(10),
      204      file char(20),
      205      file_part char(168),
      206      len fixed bin(17);
      207      if compare_sw = 1 then key_part = "user compare exit procedure";
      208      else do;
      209 	if dt(i1) = 9 then type = "dec";
      210 	else if dt(i1) = 10 then type = "float dec";
      211 	else type = "unknown";
      212 	call ioa_$rsnnl("key ^d, ^a(^d) ^d(^d)", key_part, len,
      213 		i1 + 1, type, leng(i1), w(i1), mod(b(i1) - 1, 4)*9);
      214 	end;
      215      if input_driver_is_sort = "1"b then do;
      216 	if curr_input_file_attach = "" then do;
      217 	     file = "file name";
      218 	     file_part = curr_input_file_name;
      219 	     end;
      220 	else do;
      221 	     file = "attach description";
      222 	     file_part = curr_input_file_attach;
      223 	     end;
      224 	if old_input_file_num = curr_input_file_num then do;
      225 	     call sub_err_(error_table_$improper_data_format, whoami, "c", null(), retval,
      226 			" Please check ^a and/or input file ^d, ^a ^a",
      227 		     key_part, curr_input_file_num, file, file_part);
      228 	     end;
      229 	else do;
      230 	     call sub_err_(error_table_$improper_data_format, whoami, "c", null(), retval,
      231 			" Please check ^a and/or input files ^d to ^d.",
      232 			key_part, old_input_file_num, curr_input_file_num);
      233 	     end;
      234 	end;
      235      else do;          /*   user input_file exit procedure   */
      236 	call sub_err_(error_table_$improper_data_format, whoami, "c", null(), retval,
      237 			" Please check ^a and/or user input_file exit procedure.",
      238 		key_part);
      239 	end;
      240       ec = error_table_$fatal_error;
      241      go to exit;
      242 end illegal_procedure_handler;
      243 
      244 end	sort_presort;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/82  1029.7  sort_presort.pl1                  >spec>on>11/11/82>sort_presort.pl1
23           1    12/20/77  1614.2  sort_ext.incl.pl1                 >ldd>include>sort_ext.incl.pl1
41           2    04/26/76  1500.0  sort_common.incl.pl1              >ldd>include>sort_common.incl.pl1
196          3    04/26/76  1448.1  sort_comp.incl.pl1                >ldd>include>sort_comp.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
I                                      based           fixed bin(30,0)          array dcl 2-3 set ref 91* 104 105 121* 129 130 161*
                                                                                  166 168 185*
N                               000100 automatic       char(8)                  unaligned dcl 28 set ref 63* 64
R                                      based           structure                array level 1 unaligned dcl 2-3
S                                      based           char(1044480)            unaligned dcl 2-12 set ref 155 158* 158 3-25 3-25
                                                                                  3-29 3-29 3-104 3-105 3-116 3-117 3-119 3-120
S1                                     based           char(1)                  array unaligned dcl 2-12 set ref 108 109 139 140 173
                                                                                  174
b                                      defined         fixed bin(30,0)          array dcl 1-13 ref 3-25 3-25 3-29 3-29 3-34 3-34
                                                                                  3-38 3-38 3-64 3-66 3-92 3-93 3-104 3-105 3-116
                                                                                  3-117 3-119 3-120 212
b_str                                  based           bit(32000)               unaligned dcl 3-3 ref 3-34 3-34 3-38 3-38 3-64 3-66
                                                                                  3-92 3-93
compare_sw                             defined         fixed bin(1,0)           dcl 1-19 ref 3-17 207
compares_counter                       defined         fixed bin(34,0)          dcl 1-16 set ref 192* 192
compares_counter_a              000250 automatic       fixed bin(34,0)          dcl 46 set ref 50* 111* 111 142* 142 176* 176 192
curr_input_file_attach                 defined         char(256)                unaligned dcl 1-22 ref 216 222
curr_input_file_name                   defined         char(256)                unaligned dcl 1-25 ref 218
curr_input_file_num                    defined         fixed bin(17,0)          dcl 1-28 set ref 191 224 225* 230*
dec_char                               based           char(61)                 dcl 3-12 set ref 3-104* 3-105* 3-116* 3-117* 3-119*
                                                                                  3-120*
dec_ptr1                        000400 automatic       pointer                  dcl 3-12 set ref 3-113* 3-116 3-119
dec_ptr2                        000402 automatic       pointer                  dcl 3-12 set ref 3-115* 3-117 3-120
dec_ptr3                        000404 automatic       pointer                  dcl 3-15 set ref 3-101* 3-104
dec_ptr4                        000406 automatic       pointer                  dcl 3-15 set ref 3-103* 3-105
dt                                     defined         fixed bin(30,0)          array dcl 1-43 ref 3-24 209 210
ec                                     parameter       fixed bin(35,0)          dcl 2-14 set ref 15 48* 59* 67* 240*
error_table_$fatal_error        000102 external static fixed bin(35,0)          dcl 24 ref 59 67 240
error_table_$improper_data_format
                                000104 external static fixed bin(35,0)          dcl 24 set ref 225* 230* 236*
fb                                     based           fixed bin(21,0)          dcl 2-14 set ref 157*
fb1                                    based           fixed bin(35,0)          array dcl 3-3 ref 3-43 3-43 3-47 3-47
fb2                                    based           fixed bin(71,0)          array dcl 3-3 ref 3-52 3-52 3-56 3-56
file                            000123 automatic       char(20)                 unaligned dcl 202 set ref 217* 221* 225*
file_part                       000130 automatic       char(168)                unaligned dcl 202 set ref 218* 222* 225*
flb1                                   based           float bin(27)            array dcl 3-3 ref 3-71 3-71 3-75 3-75
flb2                                   based           float bin(63)            array dcl 3-3 ref 3-80 3-80 3-84 3-84
hcs_$make_seg                   000014 constant        entry                    external dcl 19 ref 65
hcs_code                        000144 automatic       fixed bin(35,0)          dcl 33 set ref 65* 66 68*
i                               000240 automatic       fixed bin(30,0)          dcl 42 set ref 56* 57 63* 74 75 76 99* 100 101* 128*
                                                                                  133*
i1                              000215 automatic       fixed bin(30,0)          dcl 38 set ref 3-23* 3-24 3-25 3-25 3-25 3-25 3-29
                                                                                  3-29 3-29 3-29 3-34 3-34 3-34 3-34 3-38 3-38 3-38
                                                                                  3-38 3-43 3-43 3-47 3-47 3-52 3-52 3-56 3-56 3-64
                                                                                  3-64 3-64 3-66 3-66 3-66 3-71 3-71 3-75 3-75 3-80
                                                                                  3-80 3-84 3-84 3-92 3-92 3-92 3-93 3-93 3-93 3-104
                                                                                  3-104 3-104 3-105 3-105 3-105 3-116 3-116 3-116
                                                                                  3-117 3-117 3-117 3-119 3-119 3-120 3-120* 3-129
                                                                                  209 210 212 212 212 212
illegal_procedure               000252 stack reference condition                dcl 199 ref 54
input_driver_is_sort                   defined         bit(1)                   unaligned dcl 1-46 ref 215
ioa_$rsnnl                      000016 constant        entry                    external dcl 19 ref 63 212
ioa_len                         000143 automatic       fixed bin(17,0)          dcl 28 set ref 63*
j                               000234 automatic       fixed bin(30,0)          dcl 42 set ref 102* 103* 163* 164 185*
key_part                        000106 automatic       char(40)                 unaligned dcl 202 set ref 207* 212* 225* 230* 236*
l                               000232 automatic       fixed bin(30,0)          dcl 42 set ref 86* 87 89 90* 90 91 93 94* 94 152*
                                                                                  157 158 158 160
len                             000202 automatic       fixed bin(17,0)          dcl 202 set ref 212*
leng                                   defined         fixed bin(30,0)          array dcl 1-68 set ref 3-25 3-25 3-29 3-29 3-34 3-34
                                                                                  3-38 3-38 3-64 3-64 3-66 3-66 3-92 3-92 3-93 3-93
                                                                                  3-104 3-104 3-105 3-105 3-116 3-116 3-117 3-117
                                                                                  3-119 3-120 212*
lft                             000236 automatic       fixed bin(30,0)          dcl 42 set ref 100* 102 103 164* 166 168
ln                        1            based           fixed bin(30,0)          array level 2 dcl 2-3 ref 152
longinfo                        000112 automatic       char(100)                dcl 28 set ref 68*
max4                                   defined         fixed bin(30,0)          dcl 1-80 set ref 57 58*
mii                                    defined         fixed bin(17,0)          dcl 1-99 set ref 56 74*
mip                                    defined         fixed bin(30,0)          array dcl 1-105 set ref 75*
ms_name                         000102 automatic       char(32)                 dcl 28 set ref 64* 65* 68*
msp                                    defined         pointer                  array dcl 1-108 set ref 76*
n                               000227 automatic       fixed bin(30,0)          dcl 42 set ref 87* 88* 96* 96 99 127 163
no_of_keys                             defined         fixed bin(30,0)          dcl 1-111 ref 3-23
np                              000147 automatic       fixed bin(30,0)          initial dcl 35 set ref 35* 159* 159
ns                              000146 automatic       fixed bin(30,0)          initial dcl 35 set ref 35* 154* 154 155 158 160* 160
old_input_file_num                     defined         fixed bin(17,0)          dcl 1-114 set ref 191* 224 230*
pt                                     based           fixed bin(30,0)          array level 2 dcl 2-3 ref 108 109 139 140 158 173
                                                                                  174
pt1                             000222 automatic       pointer                  dcl 2-14 set ref 109* 140* 174* 3-19* 3-25 3-29 3-34
                                                                                  3-38 3-43 3-47 3-52 3-56 3-64 3-71 3-75 3-80 3-84
                                                                                  3-92 3-104 3-116 3-119
pt2                             000224 automatic       pointer                  dcl 2-14 set ref 108* 139* 173* 3-19* 3-25 3-29 3-34
                                                                                  3-38 3-43 3-47 3-52 3-56 3-66 3-71 3-75 3-80 3-84
                                                                                  3-93 3-105 3-117 3-120
result                          000220 automatic       fixed bin(1,0)           dcl 2-1 set ref 112 114* 116* 118 143 145* 147* 149
                                                                                  177 179* 181* 183 3-19* 3-20 3-25* 3-29* 3-34*
                                                                                  3-38* 3-43* 3-47* 3-52* 3-56* 3-67* 3-68* 3-71*
                                                                                  3-75* 3-80* 3-84* 3-95* 3-96* 3-107* 3-108* 3-122*
                                                                                  3-123* 3-127* 3-129* 3-129
retval                          000145 automatic       fixed bin(35,0)          dcl 34 set ref 58* 68* 225* 230* 236*
rev                                    defined         fixed bin(1,0)           array dcl 1-160 ref 3-129
rit                             000237 automatic       fixed bin(30,0)          dcl 42 set ref 101* 102 120* 120 121
s                               000150 automatic       fixed bin(17,0)          array dcl 35 set ref 84* 88* 100 101 127 164 185
sii                                    defined         fixed bin(30,0)          dcl 1-163 ref 75 86 128 133
sip                                    defined         pointer                  dcl 1-166 ref 49
sip_a                           000242 automatic       pointer                  dcl 43 set ref 49* 91 104 105 121 129 130 161 166
                                                                                  168 185
sort_ext$b                      000020 external static fixed bin(30,0)          array dcl 1-12 ref 3-25 3-25 3-25 3-25 3-29 3-29
                                                                                  3-29 3-29 3-34 3-34 3-34 3-34 3-38 3-38 3-38 3-38
                                                                                  3-64 3-64 3-66 3-66 3-92 3-92 3-93 3-93 3-104
                                                                                  3-104 3-105 3-105 3-116 3-116 3-117 3-117 3-119
                                                                                  3-119 3-120 3-120 212 212
sort_ext$compare_sw             000024 external static fixed bin(1,0)           dcl 1-18 ref 3-17 3-17 207 207
sort_ext$compares_counter       000022 external static fixed bin(34,0)          dcl 1-15 set ref 192* 192 192 192
sort_ext$curr_input_file_attach 000026 external static char(256)                unaligned dcl 1-21 ref 216 216 222 222
sort_ext$curr_input_file_name   000030 external static char(256)                unaligned dcl 1-24 ref 218 218
sort_ext$curr_input_file_num    000032 external static fixed bin(17,0)          dcl 1-27 ref 191 191 224 224 225 225 230 230
sort_ext$dt                     000034 external static fixed bin(30,0)          array dcl 1-42 ref 3-24 3-24 209 209 210 210
sort_ext$input_driver_is_sort   000036 external static bit(1)                   unaligned dcl 1-45 ref 215 215
sort_ext$leng                   000040 external static fixed bin(30,0)          array dcl 1-67 ref 3-25 3-25 3-25 3-25 3-29 3-29
                                                                                  3-29 3-29 3-34 3-34 3-34 3-34 3-38 3-38 3-38 3-38
                                                                                  3-64 3-64 3-64 3-64 3-66 3-66 3-66 3-66 3-92 3-92
                                                                                  3-92 3-92 3-93 3-93 3-93 3-93 3-104 3-104 3-104
                                                                                  3-104 3-105 3-105 3-105 3-105 3-116 3-116 3-116
                                                                                  3-116 3-117 3-117 3-117 3-117 3-119 3-119 3-120
                                                                                  3-120 212 212
sort_ext$max4                   000042 external static fixed bin(30,0)          dcl 1-79 ref 57 57 58 58
sort_ext$mii                    000044 external static fixed bin(17,0)          dcl 1-98 set ref 56 56 74* 74
sort_ext$mip                    000046 external static fixed bin(30,0)          array dcl 1-104 set ref 75* 75
sort_ext$msp                    000050 external static pointer                  array dcl 1-107 set ref 76* 76
sort_ext$no_of_keys             000052 external static fixed bin(30,0)          dcl 1-110 ref 3-23 3-23
sort_ext$old_input_file_num     000054 external static fixed bin(17,0)          dcl 1-113 set ref 191* 191 224 224 230 230
sort_ext$rev                    000056 external static fixed bin(1,0)           array dcl 1-159 ref 3-129 3-129
sort_ext$sii                    000060 external static fixed bin(30,0)          dcl 1-162 ref 75 75 86 86 128 128 133 133
sort_ext$sip                    000062 external static pointer                  dcl 1-165 ref 49 49
sort_ext$sort_compare_exit      000064 external static entry variable           dcl 1-168 ref 3-19
sort_ext$srp                    000066 external static pointer                  dcl 1-183 ref 51 51
sort_ext$ssp                    000070 external static pointer                  dcl 1-189 ref 52 52
sort_ext$unique_prefix          000072 external static char(16)                 unaligned dcl 1-215 ref 64 64
sort_ext$w                      000074 external static fixed bin(30,0)          array dcl 1-218 ref 3-43 3-43 3-43 3-43 3-47 3-47
                                                                                  3-47 3-47 3-52 3-52 3-52 3-52 3-56 3-56 3-56 3-56
                                                                                  3-71 3-71 3-71 3-71 3-75 3-75 3-75 3-75 3-80 3-80
                                                                                  3-80 3-80 3-84 3-84 3-84 3-84 212 212
sort_ext$wf_dir_name            000076 external static char(168)                dcl 1-221 ref 65 65 68 68 68 68
sort_ext$whoami                 000100 external static char(6)                  unaligned dcl 1-227 ref 58 58 68 68 225 225 230 230
                                                                                  236 236
sp                              000216 automatic       pointer                  dcl 39 set ref 65* 76 155 158
srp                                    defined         pointer                  dcl 1-184 ref 51
srp_a                           000244 automatic       pointer                  dcl 43 set ref 51* 108 109 139 140 152 158 173 174
ssp                                    defined         pointer                  dcl 1-190 ref 52
ssp_a                           000246 automatic       pointer                  dcl 43 set ref 52* 108 109 139 140 158 173 174
sub_err_                        000012 constant        entry                    external dcl 18 ref 58 68 225 230 236
t                               000226 automatic       fixed bin(30,0)          dcl 42 set ref 85* 88 91 93* 93
type                            000120 automatic       char(10)                 unaligned dcl 202 set ref 209* 210* 211* 212*
unique_prefix                          defined         char(16)                 unaligned dcl 1-216 ref 64
v1                              000230 automatic       fixed bin(30,0)          dcl 42 set ref 104* 109 114 118* 121 130* 131 135
                                                                                  135* 140 145 149* 152 158 161 165 165 165 167 168*
                                                                                  168 169 169* 174 179 183* 185 186*
v2                              000231 automatic       fixed bin(30,0)          dcl 42 set ref 105* 106 108 114 118 129* 132 135 136
                                                                                  139 145 149 165* 165* 166* 166 169 170 173 179 183
w                                      defined         fixed bin(30,0)          array dcl 1-219 set ref 3-43 3-43 3-47 3-47 3-52
                                                                                  3-52 3-56 3-56 3-71 3-71 3-75 3-75 3-80 3-80 3-84
                                                                                  3-84 212*
w_p                             000010 internal static pointer                  dcl 2-14 set ref 155* 156* 156 156 157
wf_dir_name                            defined         char(168)                dcl 1-222 set ref 65* 68 68
whoami                                 defined         char(6)                  unaligned dcl 1-228 set ref 58* 68* 225* 230* 236*
work_1                          000272 automatic       fixed bin(71,0)          dcl 3-3 set ref 3-61* 3-64 3-67 3-68
work_2                          000274 automatic       fixed bin(71,0)          dcl 3-3 set ref 3-63* 3-66 3-67 3-68
work_3                          000276 automatic       float bin(63)            dcl 3-3 set ref 3-89* 3-92 3-95 3-96
work_4                          000300 automatic       float bin(63)            dcl 3-3 set ref 3-91* 3-93 3-95 3-96
work_5                          000302 automatic       fixed dec(59,0)          dcl 3-3 set ref 3-99* 3-101 3-107 3-108
work_6                          000321 automatic       fixed dec(59,0)          dcl 3-3 set ref 3-102* 3-103 3-107 3-108
work_7                          000340 automatic       float dec(59)            dcl 3-3 set ref 3-111* 3-113 3-122 3-123
work_8                          000360 automatic       float dec(59)            dcl 3-3 set ref 3-114* 3-115 3-122 3-123
x                               000233 automatic       fixed bin(30,0)          dcl 42 set ref 103* 104 105 167* 185 186
y                               000235 automatic       fixed bin(30,0)          dcl 42 set ref 127* 129 130

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
acl                                    defined         structure                array level 1 unaligned dcl 1-6
curr_output_file_attach                defined         char(256)                unaligned dcl 1-31
curr_output_file_name                  defined         char(256)                unaligned dcl 1-34
debug_sw                               defined         bit(1)                   unaligned dcl 1-37
disaster2                              defined         fixed bin(17,0)          dcl 1-40
in_buff_ptr                            defined         pointer                  dcl 1-65
input_file_exit_sw                     defined         bit(1)                   unaligned dcl 1-49
input_file_max                         defined         fixed bin(17,0)          dcl 1-53
input_rec_deleted                      defined         fixed bin(30,0)          dcl 1-59
input_rec_inserted                     defined         fixed bin(30,0)          dcl 1-62
input_record_exit_sw                   defined         fixed bin(1,0)           dcl 1-56
max1                                   defined         fixed bin(30,0)          dcl 1-71
max2                                   defined         fixed bin(30,0)          dcl 1-74
max3                                   defined         fixed bin(30,0)          dcl 1-77
max_rec_length                         defined         fixed bin(30,0)          dcl 1-84
merge_compares                         defined         fixed bin(34,0)          dcl 1-87
merge_in_iocb_ptrs                     defined         pointer                  array dcl 1-90
merge_input_file_attaches              defined         char(256)                array unaligned dcl 1-93
merge_input_file_names                 defined         char(256)                array unaligned dcl 1-96
min_rec_length                         defined         fixed bin(30,0)          dcl 1-102
output_driver_is_sort                  defined         bit(1)                   unaligned dcl 1-117
output_file_exit_sw                    defined         bit(1)                   unaligned dcl 1-120
output_rec_deleted                     defined         fixed bin(30,0)          dcl 1-123
output_rec_inserted                    defined         fixed bin(30,0)          dcl 1-126
output_record_exit_sw                  defined         fixed bin(1,0)           dcl 1-129
presort_compares                       defined         fixed bin(34,0)          dcl 1-132
pu                                     defined         structure                array level 1 unaligned dcl 1-137
read_count                             defined         fixed bin(30,0)          dcl 1-142
rec_ptr_a                              defined         pointer                  dcl 1-145
rec_ptr_b                              defined         pointer                  dcl 1-148
release_count                          defined         fixed bin(30,0)          dcl 1-151
report_sw                              defined         bit(2)                   unaligned dcl 1-154
return_count                           defined         fixed bin(30,0)          dcl 1-157
rp                                     automatic       pointer                  dcl 39
shortinfo                              automatic       char(8)                  dcl 28
sort_desc_pn                           defined         char(168)                unaligned dcl 1-171
sort_ext$acl                           external static structure                array level 1 unaligned dcl 1-1
sort_ext$curr_output_file_attach       external static char(256)                unaligned dcl 1-30
sort_ext$curr_output_file_name         external static char(256)                unaligned dcl 1-33
sort_ext$debug_sw                      external static bit(1)                   unaligned dcl 1-36
sort_ext$disaster2                     external static fixed bin(17,0)          dcl 1-39
sort_ext$in_buff_ptr                   external static pointer                  dcl 1-64
sort_ext$input_file_exit_sw            external static bit(1)                   unaligned dcl 1-48
sort_ext$input_file_max                external static fixed bin(17,0)          dcl 1-51
sort_ext$input_rec_deleted             external static fixed bin(30,0)          dcl 1-58
sort_ext$input_rec_inserted            external static fixed bin(30,0)          dcl 1-61
sort_ext$input_record_exit_sw          external static fixed bin(1,0)           dcl 1-55
sort_ext$max1                          external static fixed bin(30,0)          dcl 1-70
sort_ext$max2                          external static fixed bin(30,0)          dcl 1-73
sort_ext$max3                          external static fixed bin(30,0)          dcl 1-76
sort_ext$max_rec_length                external static fixed bin(30,0)          dcl 1-82
sort_ext$merge_compares                external static fixed bin(34,0)          dcl 1-86
sort_ext$merge_in_iocb_ptrs            external static pointer                  array dcl 1-89
sort_ext$merge_input_file_attaches     external static char(256)                array unaligned dcl 1-92
sort_ext$merge_input_file_names        external static char(256)                array unaligned dcl 1-95
sort_ext$min_rec_length                external static fixed bin(30,0)          dcl 1-101
sort_ext$output_driver_is_sort         external static bit(1)                   unaligned dcl 1-116
sort_ext$output_file_exit_sw           external static bit(1)                   unaligned dcl 1-119
sort_ext$output_rec_deleted            external static fixed bin(30,0)          dcl 1-122
sort_ext$output_rec_inserted           external static fixed bin(30,0)          dcl 1-125
sort_ext$output_record_exit_sw         external static fixed bin(1,0)           dcl 1-128
sort_ext$presort_compares              external static fixed bin(34,0)          dcl 1-131
sort_ext$pu                            external static structure                array level 1 unaligned dcl 1-134
sort_ext$read_count                    external static fixed bin(30,0)          dcl 1-141
sort_ext$rec_ptr_a                     external static pointer                  dcl 1-144
sort_ext$rec_ptr_b                     external static pointer                  dcl 1-147
sort_ext$release_count                 external static fixed bin(30,0)          dcl 1-150
sort_ext$report_sw                     external static bit(2)                   unaligned dcl 1-153
sort_ext$return_count                  external static fixed bin(30,0)          dcl 1-156
sort_ext$sort_desc_pn                  external static char(168)                unaligned dcl 1-170
sort_ext$sort_input_record_exit        external static entry variable           dcl 1-173
sort_ext$sort_output_record_exit       external static entry variable           dcl 1-178
sort_ext$ssi                           external static fixed bin(30,0)          dcl 1-186
sort_ext$state                         external static fixed bin(17,0)          dcl 1-192
sort_ext$terminate_print_sw            external static bit(1)                   unaligned dcl 1-195
sort_ext$time_info                     external static structure                array level 1 unaligned dcl 1-198
sort_ext$time_sw                       external static bit(1)                   unaligned dcl 1-209
sort_ext$user_out_sw                   external static char(32)                 unaligned dcl 1-212
sort_ext$wf_full_name                  external static char(168)                unaligned dcl 1-224
sort_ext$write_count                   external static fixed bin(30,0)          dcl 1-230
sort_input_record_exit                 defined         entry variable           dcl 1-175
sort_output_record_exit                defined         entry variable           dcl 1-180
ssi                                    defined         fixed bin(30,0)          dcl 1-187
state                                  defined         fixed bin(17,0)          dcl 1-193
terminate_print_sw                     defined         bit(1)                   unaligned dcl 1-196
time_info                              defined         structure                array level 1 unaligned dcl 1-203
time_sw                                defined         bit(1)                   unaligned dcl 1-210
user_out_sw                            defined         char(32)                 unaligned dcl 1-213
wf_full_name                           defined         char(168)                unaligned dcl 1-225
write_count                            defined         fixed bin(30,0)          dcl 1-231

NAMES DECLARED BY EXPLICIT CONTEXT.
con                             001615 constant        label                    dcl 3-130 ref 3-20
esc                             001610 constant        label                    dcl 3-129 ref 3-33 3-42 3-51 3-60 3-70 3-79 3-88
                                                                                  3-98 3-110 3-125
exit                            001223 constant        label                    dcl 192 ref 60 70 241
illegal_procedure_handler       001616 constant        entry                    internal dcl 201 ref 54
lab                             000000 constant        label                    array(10) dcl 3-25 ref 3-24
next_key                        001604 constant        label                    dcl 3-126 ref 3-29 3-38 3-47 3-56 3-68 3-75 3-84
                                                                                  3-96 3-108 3-123
sort_comp                       001227 constant        entry                    internal dcl 3-1 ref 110 141 175
sort_presort                    000214 constant        entry                    external dcl 15
start                           000224 constant        label                    dcl 48

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 108 109 139 140 155 173 174 3-101 3-103 3-113
                                                                                  3-115
before                                                 builtin function         ref 68 68
divide                                                 builtin function         ref 94 154 167
fixed                                                  builtin function         ref 156
mod                                                    builtin function         ref 212
null                                                   builtin function         ref 58 58 68 68 225 225 230 230 236 236
ptr                                                    builtin function         ref 156
rel                                                    builtin function         ref 156
substr                                                 builtin function         set ref 89 155 158* 158 165 3-25 3-25 3-29 3-29 3-34
                                                                                  3-34 3-38 3-38 3-64* 3-64 3-66* 3-66 3-92* 3-92
                                                                                  3-93* 3-93 3-104* 3-104 3-105* 3-105 3-116* 3-116
                                                                                  3-117* 3-117 3-119* 3-119 3-120* 3-120
unspec                                                 builtin function         ref 89 165 3-64 3-66 3-92 3-93

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2542        2650    2212        2552
Length      3156    2212       106         272     327           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
sort_presort                        361 external procedure  is an external procedure.  
on unit on line 54                  218 on unit               
sort_comp                               internal procedure  shares stack frame of external procedure sort_presort.  
illegal_procedure_handler               internal procedure  shares stack frame of on unit on line 54.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 w_p                         sort_presort

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
on unit on line 54       000106 key_part                    illegal_procedure_handler
                         000120 type                        illegal_procedure_handler
                         000123 file                        illegal_procedure_handler
                         000130 file_part                   illegal_procedure_handler
                         000202 len                         illegal_procedure_handler
sort_presort             000100 N                           sort_presort
                         000102 ms_name                     sort_presort
                         000112 longinfo                    sort_presort
                         000143 ioa_len                     sort_presort
                         000144 hcs_code                    sort_presort
                         000145 retval                      sort_presort
                         000146 ns                          sort_presort
                         000147 np                          sort_presort
                         000150 s                           sort_presort
                         000215 i1                          sort_presort
                         000216 sp                          sort_presort
                         000220 result                      sort_presort
                         000222 pt1                         sort_presort
                         000224 pt2                         sort_presort
                         000226 t                           sort_presort
                         000227 n                           sort_presort
                         000230 v1                          sort_presort
                         000231 v2                          sort_presort
                         000232 l                           sort_presort
                         000233 x                           sort_presort
                         000234 j                           sort_presort
                         000235 y                           sort_presort
                         000236 lft                         sort_presort
                         000237 rit                         sort_presort
                         000240 i                           sort_presort
                         000242 sip_a                       sort_presort
                         000244 srp_a                       sort_presort
                         000246 ssp_a                       sort_presort
                         000250 compares_counter_a          sort_presort
                         000272 work_1                      sort_comp
                         000274 work_2                      sort_comp
                         000276 work_3                      sort_comp
                         000300 work_4                      sort_comp
                         000302 work_5                      sort_comp
                         000321 work_6                      sort_comp
                         000340 work_7                      sort_comp
                         000360 work_8                      sort_comp
                         000400 dec_ptr1                    sort_comp
                         000402 dec_ptr2                    sort_comp
                         000404 dec_ptr3                    sort_comp
                         000406 dec_ptr4                    sort_comp

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_var            call_ext_out_desc   return              tra_ext
mod_fx1             enable              shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
hcs_$make_seg                 ioa_$rsnnl                    sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$fatal_error      error_table_$improper_data_format                           sort_ext$b
sort_ext$compare_sw           sort_ext$compares_counter     sort_ext$curr_input_file_attach
sort_ext$curr_input_file_name sort_ext$curr_input_file_num  sort_ext$dt                   sort_ext$input_driver_is_sort
sort_ext$leng                 sort_ext$max4                 sort_ext$mii                  sort_ext$mip
sort_ext$msp                  sort_ext$no_of_keys           sort_ext$old_input_file_num   sort_ext$rev
sort_ext$sii                  sort_ext$sip                  sort_ext$sort_compare_exit    sort_ext$srp
sort_ext$ssp                  sort_ext$unique_prefix        sort_ext$w                    sort_ext$wf_dir_name
sort_ext$whoami




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     15 000211        35 000221        48 000224        49 000226        50 000231        51 000232        52 000235
     54 000240        56 000256        57 000262        58 000264        59 000334        60 000340        63 000341
     64 000367        65 000411        66 000450        67 000452        68 000456        70 000552        74 000554
     75 000557        76 000563        84 000570        85 000571        86 000572        87 000574        88 000601
     89 000604        90 000607        91 000610        93 000613        94 000615        95 000617        96 000621
     99 000623       100 000632       101 000634       102 000637       103 000646       104 000650       105 000653
    106 000656       108 000657       109 000667       110 000676       111 000677       112 000700       114 000702
    116 000710       118 000712       120 000715       121 000716       122 000722       123 000725       127 000727
    128 000733       129 000743       130 000746       131 000751       132 000753       133 000756       135 000762
    136 000767       139 000771       140 001001       141 001010       142 001011       143 001012       145 001014
    147 001022       149 001024       152 001027       154 001035       155 001043       156 001051       157 001056
    158 001060       159 001072       160 001073       161 001075       163 001100       164 001107       165 001111
    165 001120       166 001123       167 001127       168 001133       169 001137       170 001143       173 001145
    174 001155       175 001164       176 001165       177 001166       179 001170       181 001176       183 001200
    185 001203       186 001212       187 001214       189 001216       191 001220       192 001223       194 001226
 3    1 001227    3   17 001230    3   19 001233    3   20 001245    3   21 001247    3   23 001250    3   24 001256
 3   25 001261    3   29 001274    3   33 001300    3   34 001301    3   38 001314    3   42 001320    3   43 001321
 3   47 001330    3   51 001333    3   52 001334    3   56 001346    3   60 001351    3   61 001352    3   63 001354
 3   64 001355    3   66 001365    3   67 001371    3   68 001377    3   70 001402    3   71 001403    3   75 001412
 3   79 001415    3   80 001416    3   84 001430    3   88 001433    3   89 001434    3   91 001436    3   92 001437
 3   93 001447    3   95 001453    3   96 001461    3   98 001464    3   99 001465    3  101 001470    3  102 001472
 3  103 001475    3  104 001477    3  105 001512    3  107 001516    3  108 001525    3  110 001530    3  111 001531
 3  113 001534    3  114 001536    3  115 001541    3  116 001543    3  117 001556    3  119 001562    3  120 001566
 3  122 001571    3  123 001600    3  125 001603    3  126 001604    3  127 001606    3  128 001607    3  129 001610
 3  131 001615       201 001616       207 001617       209 001627       210 001640       211 001646       212 001651
    215 001733       216 001740       217 001745       218 001750       219 001754       221 001755       222 001760
    224 001763       225 001766       228 002051       230 002052       234 002130       236 002131       240 002200
    241 002205


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
