	COMPILATION LISTING OF SEGMENT load_mowse
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1116.79_Tue_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /****^  HISTORY COMMENTS:
       10*  1) change(86-07-17,MAgar), approve(86-12-12,MCR7548),
       11*     audit(86-12-12,Gilcrease), install(87-08-07,MR12.1-1075):
       12*     Created.
       13*  2) change(87-03-25,Flegel), approve(87-03-25,MCR7548),
       14*     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
       15*     Corrected mechanism for locating the source to using standard search
       16*     rules (hcs_$make_ptr).
       17*                                                   END HISTORY COMMENTS */
       18 
       19 /* format: style4,indattr,ifthen,^indcomtxt,thendo,^indproc,^indblkcom,initcol1,declareind8,dclind4,struclvlind3,comcol55 */
       20 load_mowse:
       21      proc ();
       22 
       23 /* FUNCTION
       24*
       25*   This program will read mowse.com, exitmows.com, bft.com, or bft_load.com
       26*   wsterm.exe on Multics and convert them to Hex and ship them out over the
       27*   communicatons line to the PC.
       28**/
       29 
       30 /* SUBSYSTEM DOCUMENTATION
       31**/
       32 
       33 /* NOTES
       34**/
       35 
       36 
       37 /* INPUT PARAMETERS */
       38 
       39 
       40 /* OUTPUT PARAMETERS */
       41 
       42 
       43 /* SYSTEM CALLS */
       44 dcl hcs_$fs_get_path_name  entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
       45 dcl hcs_$status_mins       entry (ptr, fixed bin (2), fixed bin (24), fixed bin (35));
       46 dcl hcs_$make_ptr	       entry (ptr, char (*), char (*), ptr, fixed bin (35));
       47 dcl ioa_$ioa_switch	       entry () options (variable);
       48 dcl com_err_	       entry options (variable);
       49 dcl iox_$modes	       entry (ptr, char (*), char (*), fixed bin (35));
       50 dcl cu_$arg_ptr_rel	       entry (fixed bin, ptr, fixed bin, fixed bin (35),
       51 		       ptr);
       52 dcl cu_$arg_list_ptr       entry (ptr);
       53 dcl cu_$arg_count_rel      entry (fixed bin, ptr, fixed bin (35));
       54 dcl iox_$detach_iocb       entry (ptr, fixed bin (35));
       55 dcl iox_$destroy_iocb      entry (ptr, fixed bin (35));
       56 dcl iox_$attach_name       entry (char (*), ptr, char (*), ptr,
       57 		       fixed bin (35));
       58 dcl iox_$put_chars	       entry (ptr, ptr, fixed bin (21), fixed bin (35));
       59 dcl iox_$get_chars	       entry (ptr, ptr, fixed bin (21), fixed bin (21),
       60 		       fixed bin (35));
       61 dcl iox_$open	       entry (ptr, fixed bin, bit (1) aligned,
       62 		       fixed bin (35));
       63 dcl iox_$close	       entry (ptr, fixed bin (35));
       64 
       65 
       66 /* SYSTEM CALL SUPPORT */
       67 dcl bit_count	       fixed bin (24);	    /* bits in file */
       68 dcl cont_ptr	       ptr;		    /* ptr to continue */
       69 dcl arg_ptr	       ptr;		    /* ptr to filename */
       70 dcl arg		       char (arg_len) based (arg_ptr);
       71 					    /* filename */
       72 dcl arg_len	       fixed bin;		    /* length of filename */
       73 dcl arg_count	       fixed bin;		    /* number of args */
       74 dcl arg_list_ptr	       ptr;		    /* ptr to args list */
       75 dcl iox_$error_output      ptr ext static;	    /* Error message IOCB */
       76 dcl error_table_$wrong_no_of_args
       77 		       fixed bin (35) ext static;
       78 
       79 /* EXTERNAL CALLS */
       80 
       81 
       82 /* EXTERNAL CALL SUPPORT */
       83 dcl start_ptr	       ptr;		    /* ptr to start transmit packet */
       84 dcl start		       char (50);		    /* start packet */
       85 dcl num_left	       fixed bin (21);	    /* number of chars to EOF */
       86 dcl num_read	       fixed bin (21);	    /* number of chars read */
       87 dcl iox_$user_io	       ptr external;	    /* screen ptr */
       88 dcl in_ptr	       ptr;		    /* input file ptr */
       89 dcl code		       fixed bin (35);	    /* error code */
       90 
       91 
       92 /* BUILTINS */
       93 dcl rtrim		       builtin;
       94 dcl substr	       builtin;
       95 dcl addr		       builtin;
       96 dcl convert	       builtin;
       97 dcl length	       builtin;
       98 dcl mod		       builtin;
       99 dcl null		       builtin;
      100 
      101 
      102 /* CONSTANTS */
      103 dcl TRUE		       bit (1) init ("1"b) int static options (constant);
      104 dcl FALSE		       bit (1) init ("0"b) int static options (constant);
      105 dcl USAGE		       char (31) int static options (constant) init ("^/^5tUsage: load_mowse FILENAME");
      106 dcl MY_NAME	       char (10) int static options (constant) init ("load_mowse");
      107 dcl PACKET_SIZE	       fixed bin (21) int static options (constant) init (4);
      108 dcl CHECK_SUM_MASK	       fixed bin int static options (constant) init (30);
      109 dcl ASCII_MASK	       bit (5) int static options (constant) init ("00010"b);
      110 dcl BYTE_SIZE	       fixed bin int static options (constant) init (9);
      111 dcl BYTE_ON	       bit (9) int static options (constant) init ("111111111"b);
      112 
      113 /* MISC VARIABLES */
      114 dcl temp_string	       char (5);
      115 dcl path_name	       char (168);		    /* Full pathname of source */
      116 dcl entry_name	       char (32);		    /* Segment name */
      117 dcl dir_name_len	       fixed bin;		    /* Length of dir name */
      118 dcl dir_name	       char (168);		    /* Directory of source */
      119 dcl seg_type	       fixed bin (2);	    /* segment type */
      120 dcl seg_ptr	       ptr;		    /* segment pointer to source */
      121 dcl maxsize	       fixed bin (21);	    /* maximum file size */
      122 dcl temp		       fixed bin (21);	    /* temporary storage for check sum */
      123 dcl check_out_ptr	       ptr;		    /* ptr to check_sum */
      124 dcl buf_check	       char (1) aligned;	    /* aligned address of check_sum */
      125 dcl check_out	       bit (9) based (check_out_ptr);
      126 					    /* transmitted check sum */
      127 dcl check_sum	       fixed bin (8);	    /* check_sum */
      128 dcl ttl_read	       fixed bin (21);	    /* number of characters read */
      129 dcl new_modes	       char (256);		    /* new terminal modes */
      130 dcl old_modes	       char (256);		    /* original terminal modes */
      131 dcl eof		       bit (1);		    /* end of file */
      132 dcl continue	       char (1);		    /* continuation */
      133 dcl line_in_ptr	       ptr;		    /* ptr to input */
      134 dcl buf_in	       char (1) aligned;	    /* aligned address of line in */
      135 dcl 01 line_in	       based (line_in_ptr),	    /* input storage */
      136        02 drop1	       bit (1),		    /* drop multics first bit */
      137        02 top1	       bit (4),		    /* save top 4 bits from character */
      138        02 bot1	       bit (4),		    /* save bottom 4 bits from character */
      139        02 drop2	       bit (1),		    /* second character */
      140        02 top2	       bit (4),
      141        02 bot2	       bit (4),
      142        02 drop3	       bit (1),		    /* third character */
      143        02 top3	       bit (4),
      144        02 bot3	       bit (4),
      145        02 drop4	       bit (1),		    /* fourth character */
      146        02 top4	       bit (4),
      147        02 bot4	       bit (4);
      148 dcl line_out_ptr	       ptr;		    /* ptr to output */
      149 dcl buf_out	       char (2) aligned;	    /* aligned address of output line */
      150 dcl 01 line_out	       based (line_out_ptr),	    /* output strg */
      151        02 ntop1	       bit (9),		    /* new top for character 1 */
      152        02 nbot1	       bit (9),		    /* new bottom for character 1 */
      153        02 ntop2	       bit (9),		    /* new top for charater 2 */
      154        02 nbot2	       bit (9),		    /* new bottom for charater 2 */
      155        02 ntop3	       bit (9),		    /* new top for character 3 */
      156        02 nbot3	       bit (9),		    /* new bottom for character 3 */
      157        02 ntop4	       bit (9),		    /* new top for character 4 */
      158        02 nbot4	       bit (9);		    /* new bottom for character 4 */
      159 
      160 
      161 /**/
      162 
      163 /* INITIALIZATION */
      164 	temp_string = "*****";
      165 	path_name = "";
      166 	entry_name = "";
      167 	dir_name_len = 0;
      168 	dir_name = "";
      169 
      170 	check_sum = 0;			    /* init check sum */
      171 	code = 0;				    /* init code */
      172 	ttl_read = 0;			    /* init total characters read */
      173 	eof = FALSE;			    /* set end of file to false */
      174 	start = "                                 strt";
      175 					    /* init start packet(34<sp>strt) */
      176 	in_ptr = null ();			    /* Infile IOCB pointer */
      177 	cont_ptr = addr (continue);		    /* set pointer to continue */
      178 	line_in_ptr = addr (buf_in);		    /* set pointer to input line */
      179 	line_out_ptr = addr (buf_out);	    /* set pointer to output line */
      180 	check_out_ptr = addr (buf_check);	    /* set pointer to check sum */
      181 	start_ptr = addr (start);		    /* set pointer to start packet */
      182 
      183 
      184 /* : get arguments */
      185 
      186 	call cu_$arg_list_ptr (arg_list_ptr);
      187 	call cu_$arg_count_rel (arg_count, arg_list_ptr, code);
      188 	if code ^= 0 then do;
      189 	     call com_err_ (code, MY_NAME, "Unable to get argument count.");
      190 	     return;
      191 	end;
      192 
      193 
      194 /* : if wrong number of arguments given then quit */
      195 
      196 	if arg_count ^= 1 then do;
      197 	     call com_err_ (error_table_$wrong_no_of_args, MY_NAME, USAGE);
      198 	     return;
      199 	end;
      200 
      201 
      202 /* : connect to file name for input */
      203 
      204 	call cu_$arg_ptr_rel (1, arg_ptr, arg_len, code, arg_list_ptr);
      205 	if code ^= 0 then do;
      206 	     call com_err_ (code, MY_NAME, "Getting arguments.");
      207 	     return;
      208 	end;
      209 
      210 	if (arg ^= "bft.com") & (arg ^= "mowse.com") & (arg ^= "wsterm.exe")
      211 	     & (arg ^= "bft_load.com") & (arg ^= "exitmows.com")
      212 	then do;
      213 	     call com_err_ (0, MY_NAME, "Incorrect file ^a." || USAGE, arg);
      214 	     return;
      215 	end;
      216 
      217 /* : Find the absolute path of the argument in the user's paths or initiated
      218*     segments */
      219 
      220 	call hcs_$make_ptr (null, arg, "", seg_ptr, code);
      221 	if code ^= 0 then do;
      222 	     call com_err_ (code, MY_NAME, "Finding ^a.", arg);
      223 	     return;
      224 	end;
      225 
      226 /* : set maxsize for each file */
      227 
      228 	call hcs_$status_mins (seg_ptr, seg_type, bit_count, code);
      229 	if code ^= 0 then do;
      230 	     call com_err_ (code, MY_NAME, "Getting size of ^a.", arg);
      231 	     return;
      232 	end;
      233 
      234 	maxsize = bit_count / BYTE_SIZE;
      235 
      236 /* : Find the absolute path of the segment */
      237 
      238 	call hcs_$fs_get_path_name (seg_ptr, dir_name, dir_name_len,
      239 	     entry_name, code);
      240 	if code ^= 0 then do;
      241 	     call com_err_ (code, MY_NAME, "Getting pathname of ^a.",
      242 		arg);
      243 	     return;
      244 	end;
      245 
      246 	path_name
      247 	     = substr (dir_name, 1, dir_name_len)
      248 	     || ">"
      249 	     || rtrim (entry_name);
      250 
      251 /* : Attach the IOCB for the file to be transferred */
      252 
      253 	call iox_$attach_name ("load_mowse_in", in_ptr,
      254 	     "vfile_ " || rtrim (path_name), null (), code);
      255 	if code ^= 0 then do;
      256 	     call com_err_ (code, MY_NAME,
      257 		"Unable to attach I/O switch.");
      258 	     return;
      259 	end;
      260 
      261 /* : make sure file is in a closed state */
      262 
      263 	call iox_$close (in_ptr, (0));
      264 
      265 /* : open file, quit if not found */
      266 
      267 	call iox_$open (in_ptr, 1, "0"b, code);
      268 	if code ^= 0 then do;
      269 	     call clean_up;
      270 	     call com_err_ (code, MY_NAME, "Looking for ^a.", arg);
      271 	     return;
      272 	end;
      273 
      274 /* : set initial modes */
      275 
      276 	new_modes = "^echoplex";
      277 	call iox_$modes (iox_$user_io, new_modes, old_modes, code);
      278 	if code ^= 0 then do;
      279 	     call clean_up;
      280 	     call com_err_ (code, MY_NAME, "Setting modes.");
      281 	     return;
      282 	end;
      283 
      284 /* : send start of comm to PC */
      285 
      286 	call iox_$put_chars (iox_$user_io, start_ptr,
      287 	     length (rtrim (start)), code);
      288 	if code ^= 0 then do;
      289 	     call clean_up;
      290 	     call com_err_ (code, MY_NAME, "Start packet failed.");
      291 	     return;
      292 	end;
      293 
      294 	call wait;
      295 	if (continue = "q") then do;
      296 	     call clean_up;
      297 	     call ioa_$ioa_switch (iox_$error_output,
      298 		"load_mowse: Start packet failed.");
      299 	     return;
      300 	end;
      301 
      302 
      303 /* : transfer file name to PC */
      304 
      305 	call iox_$put_chars (iox_$user_io, addr (temp_string), 5, (0));
      306 	call iox_$put_chars (iox_$user_io, addr (entry_name),
      307 	     length (rtrim (entry_name)), code);
      308 
      309 	call wait;
      310 	if (continue = "q") then do;
      311 	     call clean_up;
      312 	     call ioa_$ioa_switch (iox_$error_output,
      313 		"load_mowse: Name packet failed.");
      314 	     return;
      315 	end;
      316 
      317 
      318 /* : transfer file to PC */
      319 
      320 	call send;
      321 
      322 
      323 /* : reset modes and close files */
      324 
      325 	call clean_up;
      326 
      327 
      328 /**/
      329 /* INTERNAL PROCEDURES */
      330 
      331 clean_up:
      332      proc;
      333 
      334 /* FUNCTION
      335*   This procedure will close the open file, detach the pointer and quit */
      336 
      337 
      338 /* : reset terminal modes */
      339 
      340 	call iox_$modes (iox_$user_io, old_modes, new_modes, (0));
      341 
      342 
      343 /* : close and detach and destroy file IOCB */
      344 
      345 	call iox_$close (in_ptr, (0));
      346 	call iox_$detach_iocb (in_ptr, (0));
      347 	call iox_$destroy_iocb (in_ptr, (0));	    /* wipe in iocb out */
      348 
      349 
      350 /* : end of program */
      351 
      352 	return;
      353 
      354      end;
      355 
      356 
      357 wait:
      358      proc;
      359 
      360 /* FUNCTION
      361*   This procedure will wait until it receives a reply from the PC */
      362 
      363 
      364 	code = 0;
      365 	continue = "n";
      366 	do while ((continue ^= "y") & (continue ^= "q"));
      367 	     call iox_$get_chars (iox_$user_io, cont_ptr, 1, num_read, code);
      368 	end;
      369      end;
      370 
      371 
      372 end_of_send:
      373      proc;
      374 
      375 /* FUNCTION
      376*   This procedure will send the end of transmission info to the PC */
      377 
      378 
      379 /* : print end of transmission to PC */
      380 
      381 	ntop1 = BYTE_ON;
      382 	nbot1 = BYTE_ON;
      383 	ntop2 = BYTE_ON;
      384 	nbot2 = BYTE_ON;
      385 	ntop3 = BYTE_ON;
      386 	nbot3 = BYTE_ON;
      387 	ntop4 = BYTE_ON;
      388 	nbot4 = BYTE_ON;
      389 	call iox_$put_chars (iox_$user_io, line_out_ptr, num_left * 2, code);
      390 	call clean_up;
      391 
      392 	return;
      393      end;
      394 
      395 
      396 /**/
      397 send:
      398      proc;
      399 
      400 /* FUNCTION
      401*   This procedure will send the file to the PC. It will transfer the
      402*   entire file unless there is a transmission error. On any such error
      403*   the transmission is stopped. There is no provision for retransmitting
      404*   a packet or for error correction. */
      405 
      406 
      407 	continue = "y";
      408 	eof = FALSE;
      409 
      410 
      411 /* : read a line from input file */
      412 
      413 	call iox_$get_chars (in_ptr, line_in_ptr, PACKET_SIZE, num_read, code);
      414 	if code ^= 0 then do;
      415 	     call clean_up;
      416 	     call com_err_ (code, MY_NAME, "Error reading ^a.", arg);
      417 	     return;
      418 	end;
      419 	if (num_read = 0) then
      420 	     eof = TRUE;
      421 	ttl_read = ttl_read + num_read;
      422 
      423 
      424 /* : transmit while there is more to do and no errors have occured */
      425 
      426 	do while ((eof = FALSE) & (continue ^= "q"));
      427 
      428 
      429 /* : initialize output line */
      430 
      431 	     ntop1 = ""b;
      432 	     nbot1 = ""b;
      433 	     ntop2 = ""b;
      434 	     nbot2 = ""b;
      435 	     ntop3 = ""b;
      436 	     nbot3 = ""b;
      437 	     ntop4 = ""b;
      438 	     nbot4 = ""b;
      439 
      440 
      441 /* : convert to ascii */
      442 
      443 	     ntop1 = ASCII_MASK || top1;
      444 	     nbot1 = ASCII_MASK || bot1;
      445 	     ntop2 = ASCII_MASK || top2;
      446 	     nbot2 = ASCII_MASK || bot2;
      447 	     ntop3 = ASCII_MASK || top3;
      448 	     nbot3 = ASCII_MASK || bot3;
      449 	     ntop4 = ASCII_MASK || top4;
      450 	     nbot4 = ASCII_MASK || bot4;
      451 
      452 
      453 /* : calculate check-sum for error checking */
      454 
      455 	     check_sum = 0;
      456 	     temp = convert (check_sum, ntop1);
      457 	     check_sum = check_sum + temp;
      458 	     temp = convert (check_sum, nbot1);
      459 	     check_sum = check_sum + temp;
      460 	     temp = convert (check_sum, ntop2);
      461 	     check_sum = check_sum + temp;
      462 	     temp = convert (check_sum, nbot2);
      463 	     check_sum = check_sum + temp;
      464 	     temp = convert (check_sum, ntop3);
      465 	     check_sum = check_sum + temp;
      466 	     temp = convert (check_sum, nbot3);
      467 	     check_sum = check_sum + temp;
      468 	     temp = convert (check_sum, ntop4);
      469 	     check_sum = check_sum + temp;
      470 	     temp = convert (check_sum, nbot4);
      471 	     check_sum = check_sum + temp;
      472 	     check_sum = mod (check_sum, CHECK_SUM_MASK) + CHECK_SUM_MASK;
      473 	     check_out = convert (check_out, check_sum);
      474 
      475 
      476 /* : transfer chars to PC */
      477 
      478 	     call iox_$put_chars (iox_$user_io, line_out_ptr, num_read * 2,
      479 		code);
      480 	     if code ^= 0 then do;
      481 		call clean_up;
      482 		call com_err_ (code, MY_NAME, "Error in transfer of ^a.", arg);
      483 		return;
      484 	     end;
      485 	     if (num_read < PACKET_SIZE) then do;
      486 		num_left = PACKET_SIZE - num_read;
      487 		call end_of_send;
      488 		return;
      489 	     end;
      490 
      491 
      492 /* : wait for acknowledgment before continuing */
      493 
      494 	     call wait;
      495 	     if (continue = "q") then do;
      496 		call clean_up;
      497 		call ioa_$ioa_switch (iox_$error_output,
      498 		     "load_mowse: Error in transfer of ^a.", arg);
      499 		return;
      500 	     end;
      501 
      502 
      503 /* : send check_sum to PC */
      504 
      505 	     call iox_$put_chars (iox_$user_io, check_out_ptr, 1, code);
      506 	     if code ^= 0 then do;
      507 		call clean_up;
      508 		call com_err_ (code, MY_NAME, "Transfer error in checksum.");
      509 		return;
      510 	     end;
      511 	     call wait;
      512 	     if (continue = "q") then do;
      513 		call clean_up;
      514 		call ioa_$ioa_switch (iox_$error_output, MY_NAME,
      515 		     "Received checksum error in ^a.", arg);
      516 		return;
      517 	     end;
      518 
      519 
      520 /* : read a line from input file */
      521 
      522 	     num_read = 0;
      523 	     call iox_$get_chars (in_ptr, line_in_ptr, PACKET_SIZE, num_read, code);
      524 	     ttl_read = ttl_read + num_read;
      525 	     if (num_read = 0) then do;
      526 		num_left = PACKET_SIZE;
      527 		call end_of_send;
      528 		return;
      529 	     end;
      530 	end;
      531      end;
      532 
      533 
      534 
      535 /* INCLUDE FILES */
      536 
      537      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1116.7  load_mowse.pl1                    >udd>sm>ds>w>ml>load_mowse.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ASCII_MASK                             constant        bit(5)                   initial packed unaligned dcl 109 ref 443 444 445 446
                                                                                  447 448 449 450
BYTE_ON                                constant        bit(9)                   initial packed unaligned dcl 111 ref 381 382 383 384
                                                                                  385 386 387 388
BYTE_SIZE                       002650 constant        fixed bin(17,0)          initial dcl 110 ref 234
CHECK_SUM_MASK                  002651 constant        fixed bin(17,0)          initial dcl 108 ref 472 472
FALSE                                  constant        bit(1)                   initial packed unaligned dcl 104 ref 173 408 426
MY_NAME                         000001 constant        char(10)                 initial packed unaligned dcl 106 set ref 189* 197*
                                                                                  206* 213* 222* 230* 241* 256* 270* 280* 290* 416*
                                                                                  482* 508* 514*
PACKET_SIZE                     000000 constant        fixed bin(21,0)          initial dcl 107 set ref 413* 485 486 523* 526
TRUE                                   constant        bit(1)                   initial packed unaligned dcl 103 ref 419
USAGE                           000004 constant        char(31)                 initial packed unaligned dcl 105 set ref 197* 213
addr                                                   builtin function         dcl 95 ref 177 178 179 180 181 305 305 306 306
arg                                    based           char                     packed unaligned dcl 70 set ref 210 210 210 210 210
                                                                                  213* 220* 222* 230* 241* 270* 416* 482* 497* 514*
arg_count                       000107 automatic       fixed bin(17,0)          dcl 73 set ref 187* 196
arg_len                         000106 automatic       fixed bin(17,0)          dcl 72 set ref 204* 210 210 210 210 210 213 213 220
                                                                                  220 222 222 230 230 241 241 270 270 416 416 482
                                                                                  482 497 497 514 514
arg_list_ptr                    000110 automatic       pointer                  dcl 74 set ref 186* 187* 204*
arg_ptr                         000104 automatic       pointer                  dcl 69 set ref 204* 210 210 210 210 210 213 220 222
                                                                                  230 241 270 416 482 497 514
bit_count                       000100 automatic       fixed bin(24,0)          dcl 67 set ref 228* 234
bot1                      0(05)        based           bit(4)                   level 2 packed packed unaligned dcl 135 ref 444
bot2                      0(14)        based           bit(4)                   level 2 packed packed unaligned dcl 135 ref 446
bot3                      0(23)        based           bit(4)                   level 2 packed packed unaligned dcl 135 ref 448
bot4                      0(32)        based           bit(4)                   level 2 packed packed unaligned dcl 135 ref 450
buf_check                       000306 automatic       char(1)                  dcl 124 set ref 180
buf_in                          000516 automatic       char(1)                  dcl 134 set ref 178
buf_out                         000522 automatic       char(2)                  dcl 149 set ref 179
check_out                              based           bit(9)                   packed unaligned dcl 125 set ref 473* 473
check_out_ptr                   000304 automatic       pointer                  dcl 123 set ref 180* 473 473 505*
check_sum                       000307 automatic       fixed bin(8,0)           dcl 127 set ref 170* 455* 456 457* 457 458 459* 459
                                                                                  460 461* 461 462 463* 463 464 465* 465 466 467*
                                                                                  467 468 469* 469 470 471* 471 472* 472 473
code                            000136 automatic       fixed bin(35,0)          dcl 89 set ref 171* 187* 188 189* 204* 205 206* 220*
                                                                                  221 222* 228* 229 230* 238* 240 241* 253* 255 256*
                                                                                  267* 268 270* 277* 278 280* 286* 288 290* 306*
                                                                                  364* 367* 389* 413* 414 416* 478* 480 482* 505*
                                                                                  506 508* 523*
com_err_                        000020 constant        entry                    external dcl 48 ref 189 197 206 213 222 230 241 256
                                                                                  270 280 290 416 482 508
cont_ptr                        000102 automatic       pointer                  dcl 68 set ref 177* 367*
continue                        000512 automatic       char(1)                  packed unaligned dcl 132 set ref 177 295 310 365*
                                                                                  366 366 407* 426 495 512
convert                                                builtin function         dcl 96 ref 456 458 460 462 464 466 468 470 473
cu_$arg_count_rel               000030 constant        entry                    external dcl 53 ref 187
cu_$arg_list_ptr                000026 constant        entry                    external dcl 52 ref 186
cu_$arg_ptr_rel                 000024 constant        entry                    external dcl 50 ref 204
dir_name                        000225 automatic       char(168)                packed unaligned dcl 118 set ref 168* 238* 246
dir_name_len                    000224 automatic       fixed bin(17,0)          dcl 117 set ref 167* 238* 246
entry_name                      000214 automatic       char(32)                 packed unaligned dcl 116 set ref 166* 238* 246 306
                                                                                  306 306 306
eof                             000511 automatic       bit(1)                   packed unaligned dcl 131 set ref 173* 408* 419* 426
error_table_$wrong_no_of_args   000052 external static fixed bin(35,0)          dcl 76 set ref 197*
hcs_$fs_get_path_name           000010 constant        entry                    external dcl 44 ref 238
hcs_$make_ptr                   000014 constant        entry                    external dcl 46 ref 220
hcs_$status_mins                000012 constant        entry                    external dcl 45 ref 228
in_ptr                          000134 automatic       pointer                  dcl 88 set ref 176* 253* 263* 267* 345* 346* 347*
                                                                                  413* 523*
ioa_$ioa_switch                 000016 constant        entry                    external dcl 47 ref 297 312 497 514
iox_$attach_name                000036 constant        entry                    external dcl 56 ref 253
iox_$close                      000046 constant        entry                    external dcl 63 ref 263 345
iox_$destroy_iocb               000034 constant        entry                    external dcl 55 ref 347
iox_$detach_iocb                000032 constant        entry                    external dcl 54 ref 346
iox_$error_output               000050 external static pointer                  dcl 75 set ref 297* 312* 497* 514*
iox_$get_chars                  000042 constant        entry                    external dcl 59 ref 367 413 523
iox_$modes                      000022 constant        entry                    external dcl 49 ref 277 340
iox_$open                       000044 constant        entry                    external dcl 61 ref 267
iox_$put_chars                  000040 constant        entry                    external dcl 58 ref 286 305 306 389 478 505
iox_$user_io                    000054 external static pointer                  dcl 87 set ref 277* 286* 305* 306* 340* 367* 389*
                                                                                  478* 505*
length                                                 builtin function         dcl 97 ref 286 286 306 306
line_in                                based           structure                level 1 packed packed unaligned dcl 135
line_in_ptr                     000514 automatic       pointer                  dcl 133 set ref 178* 413* 443 444 445 446 447 448
                                                                                  449 450 523*
line_out                               based           structure                level 1 packed packed unaligned dcl 150
line_out_ptr                    000520 automatic       pointer                  dcl 148 set ref 179* 381 382 383 384 385 386 387 388
                                                                                  389* 431 432 433 434 435 436 437 438 443 444 445
                                                                                  446 447 448 449 450 456 458 460 462 464 466 468
                                                                                  470 478*
maxsize                         000302 automatic       fixed bin(21,0)          dcl 121 set ref 234*
mod                                                    builtin function         dcl 98 ref 472
nbot1                     0(09)        based           bit(9)                   level 2 packed packed unaligned dcl 150 set ref 382*
                                                                                  432* 444* 458
nbot2                     0(27)        based           bit(9)                   level 2 packed packed unaligned dcl 150 set ref 384*
                                                                                  434* 446* 462
nbot3                     1(09)        based           bit(9)                   level 2 packed packed unaligned dcl 150 set ref 386*
                                                                                  436* 448* 466
nbot4                     1(27)        based           bit(9)                   level 2 packed packed unaligned dcl 150 set ref 388*
                                                                                  438* 450* 470
new_modes                       000311 automatic       char(256)                packed unaligned dcl 129 set ref 276* 277* 340*
ntop1                                  based           bit(9)                   level 2 packed packed unaligned dcl 150 set ref 381*
                                                                                  431* 443* 456
ntop2                     0(18)        based           bit(9)                   level 2 packed packed unaligned dcl 150 set ref 383*
                                                                                  433* 445* 460
ntop3                     1            based           bit(9)                   level 2 packed packed unaligned dcl 150 set ref 385*
                                                                                  435* 447* 464
ntop4                     1(18)        based           bit(9)                   level 2 packed packed unaligned dcl 150 set ref 387*
                                                                                  437* 449* 468
null                                                   builtin function         dcl 99 ref 176 220 220 253 253
num_left                        000131 automatic       fixed bin(21,0)          dcl 85 set ref 389 486* 526*
num_read                        000132 automatic       fixed bin(21,0)          dcl 86 set ref 367* 413* 419 421 478 485 486 522*
                                                                                  523* 524 525
old_modes                       000411 automatic       char(256)                packed unaligned dcl 130 set ref 277* 340*
path_name                       000142 automatic       char(168)                packed unaligned dcl 115 set ref 165* 246* 253
rtrim                                                  builtin function         dcl 93 ref 246 253 286 286 306 306
seg_ptr                         000300 automatic       pointer                  dcl 120 set ref 220* 228* 238*
seg_type                        000277 automatic       fixed bin(2,0)           dcl 119 set ref 228*
start                           000114 automatic       char(50)                 packed unaligned dcl 84 set ref 174* 181 286 286
start_ptr                       000112 automatic       pointer                  dcl 83 set ref 181* 286*
substr                                                 builtin function         dcl 94 ref 246
temp                            000303 automatic       fixed bin(21,0)          dcl 122 set ref 456* 457 458* 459 460* 461 462* 463
                                                                                  464* 465 466* 467 468* 469 470* 471
temp_string                     000140 automatic       char(5)                  packed unaligned dcl 114 set ref 164* 305 305
top1                      0(01)        based           bit(4)                   level 2 packed packed unaligned dcl 135 ref 443
top2                      0(10)        based           bit(4)                   level 2 packed packed unaligned dcl 135 ref 445
top3                      0(19)        based           bit(4)                   level 2 packed packed unaligned dcl 135 ref 447
top4                      0(28)        based           bit(4)                   level 2 packed packed unaligned dcl 135 ref 449
ttl_read                        000310 automatic       fixed bin(21,0)          dcl 128 set ref 172* 421* 421 524* 524

NAMES DECLARED BY EXPLICIT CONTEXT.
clean_up                        001604 constant        entry                    internal dcl 331 ref 269 279 289 296 311 325 390 415
                                                                                  481 496 507 513
end_of_send                     001726 constant        entry                    internal dcl 372 ref 487 527
load_mowse                      000267 constant        entry                    external dcl 20
send                            002002 constant        entry                    internal dcl 397 ref 320
wait                            001671 constant        entry                    internal dcl 357 ref 294 309 494 511

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3100        3156    2653        3110
Length      3376    2653        56         204     225           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
load_mowse                          516 external procedure  is an external procedure.  
clean_up                                internal procedure  shares stack frame of external procedure load_mowse.  
wait                                    internal procedure  shares stack frame of external procedure load_mowse.  
end_of_send                             internal procedure  shares stack frame of external procedure load_mowse.  
send                                    internal procedure  shares stack frame of external procedure load_mowse.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
load_mowse               000100 bit_count                   load_mowse
                         000102 cont_ptr                    load_mowse
                         000104 arg_ptr                     load_mowse
                         000106 arg_len                     load_mowse
                         000107 arg_count                   load_mowse
                         000110 arg_list_ptr                load_mowse
                         000112 start_ptr                   load_mowse
                         000114 start                       load_mowse
                         000131 num_left                    load_mowse
                         000132 num_read                    load_mowse
                         000134 in_ptr                      load_mowse
                         000136 code                        load_mowse
                         000140 temp_string                 load_mowse
                         000142 path_name                   load_mowse
                         000214 entry_name                  load_mowse
                         000224 dir_name_len                load_mowse
                         000225 dir_name                    load_mowse
                         000277 seg_type                    load_mowse
                         000300 seg_ptr                     load_mowse
                         000302 maxsize                     load_mowse
                         000303 temp                        load_mowse
                         000304 check_out_ptr               load_mowse
                         000306 buf_check                   load_mowse
                         000307 check_sum                   load_mowse
                         000310 ttl_read                    load_mowse
                         000311 new_modes                   load_mowse
                         000411 old_modes                   load_mowse
                         000511 eof                         load_mowse
                         000512 continue                    load_mowse
                         000514 line_in_ptr                 load_mowse
                         000516 buf_in                      load_mowse
                         000520 line_out_ptr                load_mowse
                         000522 buf_out                     load_mowse

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        return_mac          mdfx1
shorten_stack       ext_entry           trunc_fx2           divide_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count_rel             cu_$arg_list_ptr              cu_$arg_ptr_rel
hcs_$fs_get_path_name         hcs_$make_ptr                 hcs_$status_mins              ioa_$ioa_switch
iox_$attach_name              iox_$close                    iox_$destroy_iocb             iox_$detach_iocb
iox_$get_chars                iox_$modes                    iox_$open                     iox_$put_chars

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$wrong_no_of_args iox_$error_output             iox_$user_io




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     20 000266       164 000274       165 000276       166 000301       167 000304       168 000305       170 000310
    171 000311       172 000312       173 000313       174 000314       176 000317       177 000321       178 000323
    179 000325       180 000327       181 000331       186 000333       187 000341       188 000354       189 000356
    190 000402       196 000403       197 000406       198 000427       204 000430       205 000451       206 000453
    207 000502       210 000503       213 000531       214 000570       220 000571       221 000626       222 000630
    223 000665       228 000666       229 000703       230 000705       231 000743       234 000744       238 000753
    240 001004       241 001006       243 001041       246 001042       253 001103       255 001170       256 001173
    258 001217       263 001220       267 001232       268 001253       269 001255       270 001256       271 001312
    276 001313       277 001316       278 001342       279 001344       280 001345       281 001372       286 001373
    288 001422       289 001424       290 001425       291 001451       294 001452       295 001453       296 001456
    297 001457       299 001477       305 001500       306 001522       309 001553       310 001554       311 001557
    312 001560       314 001600       320 001601       325 001602       537 001603       331 001604       340 001605
    345 001632       346 001644       347 001656       352 001670       357 001671       364 001672       365 001673
    366 001675       367 001703       368 001724       369 001725       372 001726       381 001727       382 001733
    383 001736       384 001741       385 001744       386 001747       387 001752       388 001755       389 001760
    390 002000       392 002001       397 002002       407 002003       408 002005       413 002006       414 002025
    415 002027       416 002030       417 002066       419 002067       421 002073       426 002074       431 002101
    432 002105       433 002110       434 002113       435 002116       436 002121       437 002124       438 002127
    443 002132       444 002145       445 002157       446 002171       447 002203       448 002215       449 002227
    450 002241       455 002253       456 002254       457 002262       458 002263       459 002271       460 002272
    461 002300       462 002301       463 002307       464 002310       465 002316       466 002317       467 002325
    468 002326       469 002334       470 002335       471 002343       472 002344       473 002351       478 002362
    480 002402       481 002404       482 002405       483 002440       485 002441       486 002444       487 002447
    488 002450       494 002451       495 002452       496 002455       497 002456       499 002505       505 002506
    506 002525       507 002527       508 002530       509 002554       511 002555       512 002556       513 002561
    514 002562       516 002615       522 002616       523 002617       524 002636       525 002640       526 002642
    527 002644       528 002645       530 002646       531 002647


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
