	COMPILATION LISTING OF SEGMENT linus_lila_get_token
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/29/86  0952.1 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(86-01-13,Dupuis), approve(86-01-13,MCR7188), audit(86-07-23,GWMay),
       14*     install(86-07-29,MR12.0-1106):
       15*     84-12-28 Matthew Pierret: Changed to use linus_lila_tokens_ external
       16*     variables instead of hard-coding reserved words into the code.
       17*                                                   END HISTORY COMMENTS */
       18 
       19 
       20 linus_lila_get_token:
       21      proc (lcb_ptr, lsh_ptr, start_pos, td_ptr, code);
       22 
       23 /* DESCRIPTION:
       24*
       25*   This procedure is the lexical analizer for the LILA translator.  It isolates
       26*   the  next  token  after  the start_pos, returns its key and a pointer to and
       27*   length  of  its  value.   The  start_pos  is adjusted to the first character
       28*   following the token just isolated.
       29*
       30*
       31*
       32*   HISTORY:
       33*
       34*   77-07-01 J. A. Weeldreyer: Initially written.
       35*
       36*   77-12-01  J.   A.   Weeldreyer:  Modified  to correctly parse complex arith.
       37*   constants.
       38*
       39*   78-02-01 J. A. Weeldreyer: Modified to better handle hyphenated idents.
       40*
       41*   78-06-01 J. A. Weeldreyer: Modified to properly detect keywords.
       42*
       43*   78-07-01 J. A. Weeldreyer: Modified to properly parse row designators.
       44*
       45*   78-07-01 J. A. Weeldreyer: Modified to properly parse linus variables.
       46*
       47*   79-02-01  J.   C.   C.   Jagernauth:  Modified to access version 4 resultant
       48*   information.
       49*
       50*   80-04-13  Rickie  E.   Brinegar:  Modified  to  use  a  work area defined on
       51*   lcb.lila_area_ptr instead of getting system free area.
       52*
       53*   81-01-14  Rickie  E.   Brinegar:  Modified to use linus_rel_array instead of
       54*   using the resultant model.
       55*
       56*   81-02-02  Rickie  E.   Brinegar: moved the internal static debug_switch from
       57*   the db_on entry to the main entry.
       58*
       59*   81-02-03 Rickie E.  Brinegar: the builtins char, fixed and rel were added to
       60*   the  declarations.   The  unused  variables  i,  k, rindex were removed from
       61*   various  procedures.   The valid_rel procedure was modified to add temp_rels
       62*   to the linus_rel_array structure by the LINUS temp_table_name.
       63*
       64*   81-06-03  Rickie  E.   Brinegar: Modified to remember temporary tables as a
       65*   result of TR9817.
       66*   
       67*   81-07-15 Rickie E. Brinegar: Removed useless cleanup condition handler.
       68*   
       69*   81-10-05  Rickie  E.   Brinegar:  Changed  the  valid_attr procedure to use
       70*   ls_block.range_items.rel_index (tv_index) as a subscript for temp_tab_names
       71*   when  instead  of tv_index.  This alleviates the losing of temporary tables
       72*   when  they do not appear in the order that they are defined in.  This is in
       73*   response to TRs 11494, 11626 and 11645
       74*   
       75*   81-10-07  Rickie  E.   Brinegar: Modified the ident_proc proc to only check
       76*   for    valid    relations    when    being    called   by   linus_lila_from
       77*   (ls_header.from_token = "1"b). This is in response to TR11628.
       78*   
       79*   81-10-19   Rickie   E.    Brinegar:   Modified   the   error  proc  to  set
       80*   ls_header.cur_pos  to cur_pos before returning to the caller.  This permits
       81*   linus_lila_error  to  correctly  determine the line that the error occurred
       82*   in.  This is in response to TR8988.
       83*
       84*   81-10-30  DJ  Schimke:  Modified  is_const internal function to use verify
       85*   instead of index.
       86*
       87*   81-11-05  DJ  Schimke:  Modified  to  permit unary operators in constants.
       88*   This includes both leading +- signs and parenthesized constants.  Declared
       89*   first_op and first_dp. This is in response to TR6446.
       90*
       91*   81-11-25 Rickie E. Brinegar: Modified to time calls to MRDS (dsl_ calls).
       92*
       93*   83-06-16  DJ  Schimke:  Modified to permit single constants as arguments to
       94*   functions. This amounts to letting (1) through as an expression rather than
       95*   as a constant. This is in response to TR15411.
       96*
       97**/
       98 
  1     1 /* BEGIN INCLUDE FILE linus_lcb.incl.pl1 -- jaw 8/30/77 */
  1     2    
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(86-04-23,Dupuis), approve(86-05-23,MCR7188), audit(86-07-23,GWMay),
  1     7*     install(86-07-29,MR12.0-1106):
  1     8*     Added general_work_area_ptr and renamed sfr_ptr to
  1     9*     force_retrieve_scope_ptr.
  1    10*                                                   END HISTORY COMMENTS */
  1    11 
  1    12 
  1    13 /* HISTORY:
  1    14*
  1    15*   78-09-29 J. C. C. Jagernauth: Modified for MR7.0.
  1    16*
  1    17*   81-05-11  Rickie E.  Brinegar: added security bit and andministrator bit as
  1    18*   a part of the attribute level control work.
  1    19*   
  1    20*   81-06-17  Rickie E.  Brinegar: deleted the sd_ptr as a part of removing the
  1    21*   scope_data  structure  from  LINUS.   LINUS now depends totally on MRDS for
  1    22*   scope information.
  1    23*   
  1    24*   81-11-11  Rickie  E.   Brinegar:  added the timing bit and three fields for
  1    25*   retaining  various  vcpu  times  to  be collected when in timing mode.  The
  1    26*   times  to  be collected are: LINUS parsing time, LINUS processing time, and
  1    27*   MRDS processing time.
  1    28*
  1    29*   82-01-15  DJ  Schimke:  Added the build_increment and build_start fields as
  1    30*   part of the line numbering implementation.  This allows for possible  later
  1    31*   LINUS control of the build defaults.
  1    32* 
  1    33*   82-03-01 Paul W. Benjamin: Removed linus_prompt_chars_ptr, as that 
  1    34*   information is now retained by ssu_.  Removed parse_timer as no longer
  1    35*   meaningful.  Added linus_version.  Added iteration bit.  Added 6 entry 
  1    36*   variables for ssu_ replaceable procedures.  Added actual_input_iocbp.
  1    37*
  1    38*   82-06-23 Al Dupuis: Added subsystem_control_info_ptr, 
  1    39*   subsystem_invocation_level, and selection_expression_identifier.
  1    40*
  1    41*   82-08-26 DJ Schimke: Added report_control_info_ptr, and
  1    42*   table_control_info_ptr. 
  1    43*
  1    44*   82-10-19 DJ Schimke: Added ssu_abort_line.
  1    45*
  1    46*   83-06-06 Bert Moberg: Added print_search_order (pso) and no_optimize (no_ot)
  1    47*
  1    48*   83-04-07 DJ Schimke: Added temp_seg_info_ptr.
  1    49*
  1    50*   83-08-26 Al Dupuis: Added query_temp_segment_ptr.
  1    51**/
  1    52     
  1    53 dcl 1 lcb aligned based (lcb_ptr),			/* LINUS control block */
  1    54     2 db_index fixed bin (35),			/* index of open data base, or 0 */
  1    55     2 rb_len fixed bin (21),				/* length of request buffer */
  1    56     2 lila_count fixed bin (35),			/* number of LILA text lines */
  1    57     2 lila_chars fixed bin (35),			/* number of LILA source test chars */
  1    58     2 trans_id fixed bin (35),			/* used by checkpoint and rollback facilities (MR7.0) */
  1    59     2 lila_fn char (32) unal,				/* entry name of lila data file */
  1    60     2 prompt_flag bit (1) unal,			/* on if in prompt mode */
  1    61     2 test_flag bit (1) unal,				/* on if in test mode */
  1    62     2 new_version bit (1) unal init (1),		/* on for new version data base (MR7.0) */
  1    63     2 secured_db bit (1) unal,                              /* on if the db is in a secure state */
  1    64     2 administrator bit (1) unal,                           /* on if the user is a db administrator */
  1    65     2 timing_mode bit (1) unal,                             /* on if timing is to be done */
  1    66     2 iteration bit (1) unal,				/* interpret parens as iteration sets */
  1    67     2 pso_flag bit (1) unal,				/* add print_search_order to select */
  1    68     2 no_ot_flag bit (1) unal,			/* add no_optimize to select */
  1    69     2 reserved bit (27) unal,
  1    70     2 liocb_ptr ptr,				/* iocb ptr for lila file */
  1    71     2 rb_ptr ptr,					/* ptr to request buffer */
  1    72     2 is_ptr ptr,					/* iocb ptr for currentinput stream switch */
  1    73     2 cal_ptr ptr,					/* ptr to current arg list for invoke (or null) */
  1    74     2 ttn_ptr ptr,					/* pointer to table info structure */
  1    75     2 force_retrieve_scope_info_ptr ptr,		/* structure pointer to force retrieve scope operation */
  1    76     2 lv_ptr ptr,					/* pointer linus variables */
  1    77     2 si_ptr ptr,					/* pointer to select_info structure */
  1    78     2 setfi_ptr ptr,				/* pointer to set function information */
  1    79     2 sclfi_ptr ptr,				/* pointer to user declared scalar fun. names */
  1    80     2 ivs_ptr ptr,					/* pointer to stack of invoke iocb pointers */
  1    81     2 lit_ptr ptr,					/* pointer to literal pool */
  1    82     2 lvv_ptr ptr,					/* pointer to linus variable alloc. pool  */
  1    83     2 rd_ptr ptr,					/* point to readied files mode information (MR7.0) */
  1    84     2 rt_ptr ptr,                                           /* point to table of relation names and their readied modes
  1    85*                                                               (MR7.0) */
  1    86     2 actual_input_iocbp ptr,				/* ptr to input while in macros */
  1    87     2 lila_promp_chars_ptr ptr,			/* pointer to the prompt characters for lila */
  1    88     2 linus_area_ptr ptr,				/* LINUS temporary segment pointer */
  1    89     2 lila_area_ptr ptr,				/* LILA temporary segment pointer */
  1    90     2 i_o_area_ptr ptr,				/* temporary segment pointer used by write, print, create_list */
  1    91     2 rel_array_ptr ptr,                                    /* ptr to array of names rslt info structure
  1    92*                                                               for current lila expression */
  1    93     2 unused_timer float bin (63),			/* future expansion */
  1    94     2 request_time float bin (63),                          /* How much request time was spent
  1    95*                                                                in LINUS. (-1 = user has just enabled 
  1    96*						    timing, do not report) */
  1    97     2 mrds_time float bin (63),                             /* How much time was spent in MRDS */
  1    98     2 build_increment fixed bin,			/* default increment for build mode */
  1    99     2 build_start fixed bin,				/* default start count for build mode */
  1   100     2 linus_version char (4),				/* current version of LINUS */
  1   101     2 subsystem_control_info_ptr ptr,                       /* the same ptr passed by ssu_ to each request procedure */
  1   102     2 subsystem_invocation_level fixed bin,                 /* identifies this invocation of LINUS */
  1   103     2 selection_expression_identifier fixed bin,            /* identifies the current processed selection expression */
  1   104     2 report_control_info_ptr ptr,			/* pointer to linus_report_control_info structure */
  1   105     2 table_control_info_ptr ptr,			/* pointer to linus_table control structure */
  1   106     2 temp_seg_info_ptr ptr,				/* pointer to linus_temp_seg_mgr control structure */
  1   107     2 query_temp_segment_ptr ptr,			/* points to temp seg used for manipulating query */
  1   108     2 general_work_area_ptr ptr,			/* a freeing area for general use */
  1   109     2 word_pad (6) bit (36) unal,
  1   110 						/* procedures that will be optionally */
  1   111 						/* replaced by the user.  Saved so they */
  1   112 						/* can be reinstated if desired. */
  1   113     2 ssu_abort_line entry options (variable),
  1   114     2 ssu_post_request_line variable entry (ptr),
  1   115     2 ssu_pre_request_line variable entry (ptr),
  1   116 
  1   117     2 curr_lit_offset fixed bin (35),			/* index of first free bit in lit. pool */
  1   118     2 curr_lv_val_offset fixed bin (35),		/* index of first free bit lv. val. pool */
  1   119     2 static_area area (sys_info$max_seg_size - fixed (rel (addr (lcb.static_area))) + 1);
  1   120 
  1   121 dcl  lcb_ptr ptr;
  1   122 
  1   123 /* END INCLUDE FILE linus_lcb.incl.pl1 */
       99 
      100 
  2     1 /* BEGIN INCLUDE FILE linus_ls_block.incl.pl1 -- jaw 8/7/78 */
  2     2 
  2     3 dcl 1 ls_block aligned based (lsb_ptr),			/* lila stack frame for outer lila block */
  3     1 /* BEGIN INCLUDE FILE linus_ls_common.incl.pl1 -- jaw 7/12/77 */
  3     2 
  3     3     2 type fixed bin,				/* type of frame:
  3     4*						   1 => header,
  3     5*						   2 => set value,
  3     6*						   3 => lila set,
  3     7*						   4 => lila block */
  3     8     2 back_ptr ptr,					/* pointer to previous frame */
  3     9     2 fwd_ptr ptr,					/* pointer to next frame */
  3    10 
  3    11 /* END INCLUDE FILE linus_ls_common.incl.pl1 */
  2     4 
  2     5     2 reserved bit (36) unal,
  2     6     2 ib_level fixed bin,				/* current depth of inner blocks */
  2     7     2 nrs_chars fixed bin,				/* total chars. in range strings */
  2     8     2 nritems fixed bin,				/* current number of range items */
  2     9     2 range_items (linus_data_$max_range_items),
  2    10       3 tup_var char (32) var,			/* name of linus tuple variable */
  2    11       3 mrds_var char (32) var,			/* name of mrds tuple variable */
  2    12       3 rel_name char (32) var,			/* name of relation */
  2    13       3 rel_index fixed bin (35),			/* rel. index if temp tab */
  2    14       3 level fixed bin,				/* level of block generating item */
  2    15       3 arg_ptr ptr,
  2    16       3 desc_ptr ptr,
  2    17     2 nselects fixed bin,				/* number of select items currently defined */
  2    18     2 sel_items (mrds_data_$max_select_items) char (mrds_data_$max_token_size) var, /* the mrds select items */
  2    19     2 nprops fixed bin,				/* number of operators in pred stack */
  2    20     2 pred_op_stack (linus_data_$max_pred_stack_size),
  2    21       3 key fixed bin (17) unal,
  2    22       3 p_cnt fixed bin (17) unal,			/* current paren count */
  2    23     2 pred_pcnt fixed bin,				/* current paren. count in predicate */
  2    24     2 term_op fixed bin,				/* rel. op. for current term */
  2    25     2 nterms fixed bin,				/* no. of terms currently in term stack */
  2    26     2 dflt_ritem fixed bin,				/* index of range item to be used for default */
  2    27     2 nrange_args fixed bin,				/* no. of args for temp rel indexes */
  2    28     2 rs_hd_ptr ptr,				/* pointer to head of range strings */
  2    29     2 term_hd_ptr ptr,				/* pointer to top item in term stack */
  2    30     2 leaf_ptr (2) ptr;				/* ptr to mrds block for each leaf of current term */
  2    31 
  2    32 dcl  lsb_ptr ptr;
  2    33 
  2    34 /* END INCLUDE FILE linus_ls_block.incl.pl1 */
      101 
      102 
  4     1 /* BEGIN INCLUDE FILE linus_ls_header.incl.pl1 -- jaw 7/28/77 */
  4     2 
  4     3 dcl 1 ls_header aligned based (lsh_ptr),		/* header for LILA stack */
  5     1 /* BEGIN INCLUDE FILE linus_ls_common.incl.pl1 -- jaw 7/12/77 */
  5     2 
  5     3     2 type fixed bin,				/* type of frame:
  5     4*						   1 => header,
  5     5*						   2 => set value,
  5     6*						   3 => lila set,
  5     7*						   4 => lila block */
  5     8     2 back_ptr ptr,					/* pointer to previous frame */
  5     9     2 fwd_ptr ptr,					/* pointer to next frame */
  5    10 
  5    11 /* END INCLUDE FILE linus_ls_common.incl.pl1 */
  4     4 
  4     5     2 cur_ptr ptr,					/* pointer to current frame */
  4     6     2 src_ptr ptr,					/* pointer to LILA source string */
  4     7     2 trans_failed bit (1) unal,			/* on if translate failed */
  4     8     2 from_token bit (1) unal,                              /* on if the calling routine is  linus_lila_from */
  4     9     2 reserved bit (34) unal,
  4    10     2 cur_pos fixed bin (35),				/* current position in source string */
  4    11     2 line_data (0 : lcb.lila_count),			/* data for each source line */
  4    12       3 lno char (4),				/* line number */
  4    13       3 last_char fixed bin (35);			/* index of last char */
  4    14 
  4    15 dcl  lsh_ptr ptr;
  4    16 
  4    17 /* END INCLUDE FILE linus_ls_header.incl.pl1 */
      103 
      104 
  6     1 /* BEGIN INCLUDE FILE -- linus_rel_array.incl.pl1 -- reb 09/09/80
  6     2*
  6     3*   80-09-09 Rickie E. Brinegar: Initially written.
  6     4*
  6     5*   81-01-29 Rickie E. Brinegar: changed to comform to standards for include
  6     6*   files.
  6     7*
  6     8**/
  6     9 
  6    10 dcl 1 linus_rel_array based (linus_rel_array_ptr),
  6    11       2 num_of_rels fixed bin,
  6    12       2 rels (num_of_rels_init refer (linus_rel_array.num_of_rels)),
  6    13         3 rel_name char (32),
  6    14         3 rslt_info_ptr ptr;
  6    15 
  6    16 dcl  linus_rel_array_ptr ptr;
  6    17 	
  6    18 dcl  num_of_rels_init fixed bin init (0);
  6    19 	
  6    20 /* END INCLUDE FILE linus_rel_array.incl.pl1 */
  6    21 
      105 
      106 
  7     1 /* BEGIN INCLUDE FILE linus_set_fn_info.incl.pl1 -- jaw 6/16/77 
  7     2*
  7     3*   81-10-26  Rickie E.  Brinegar: Changed the entry pointer to entry variables
  7     4*   and  added  bits to define whether or not the entry variables had been set.
  7     5*   Renamed the structure from set_fn_info to linus_set_fn_info and the pointer
  7     6*   that it was based on from setfi_ptr to linus_set_fn_info_ptr.
  7     7*
  7     8*   81-11-05 Rickie E.  Brinegar: Changed the entry pointers to entry variables
  7     9*   and  added bit switches to determine when the entries have or have not been
  7    10*   set.  Renamed the set_fn_info structure to linus_set_fn_info, the setfi_ptr
  7    11*   to      linus_set_fn_info_ptr,      and      nset_fn_info_init_args      to
  7    12*   initial_number_of_set_fn_info_args.
  7    13*      
  7    14**/
  7    15 
  7    16 dcl 1 linus_set_fn_info aligned based (linus_set_fn_info_ptr),
  7    17                                                           	/* set function info block */
  7    18     2 fwd_ptr ptr,					/* pointer too next function in list */
  7    19     2 name char (32),				/* name of function */
  7    20     2 assign_entry entry variable,			/* pointer to assign entry */
  7    21     2 calc_entry entry variable,			/* pointer to calc entry */
  7    22     2 info_entry entry variable,			/* pointer to info entry, if var. fun. */
  7    23     2 init_entry entry variable,			/* pointer to initialization entry */
  7    24     2 flags,
  7    25       3 assign_entry_set bit (1) unaligned,                 /* 0 => null, 1 => not null */
  7    26       3 calc_entry_set bit (1) unaligned,                   /* 0 => null, 1 => not null */
  7    27       3 info_entry_set bit (1) unaligned,                   /* 0 => null, 1 => not null */
  7    28       3 init_entry_set bit (1) unaligned,                   /* 0 => null, 1 => not null */
  7    29       3 pad_bits bit (32) unaligned,
  7    30     2 rslt_desc bit (36),				/* descriptor of result of fixed fun */
  7    31     2 nargs fixed bin,				/* no of input args of calc entry */
  7    32     2 arg_desc (initial_number_of_set_fn_info_args refer (linus_set_fn_info.nargs)) bit (36); /* descriptor
  7    33*                                                               for each input arg */
  7    34 
  7    35 dcl  linus_set_fn_info_ptr ptr;
  7    36 dcl  initial_number_of_set_fn_info_args fixed bin;
  7    37 
  7    38 /* END INCLUDE FILE linus_set_fn_info.incl.pl1 */
      107 
      108 
  8     1 /* BEGIN INCLUDE FILE linus_source.incl.pl1 -- jaw 7/12/77 */
  8     2 
  8     3 dcl  source_str char (lcb.lila_chars) based (ls_header.src_ptr);
  8     4 dcl  source_array (lcb.lila_chars) char (1) based (ls_header.src_ptr);
  8     5 
  8     6 /* END INCLUDE FILE linus_source.incl.pl1 */
      109 
      110 
  9     1 /* BEGIN INCLUDE FILE  linus_temp_tab_names.incl.pl1 -- jaw  6/16/77 */
  9     2 
  9     3 dcl  temp_tab_names (mrds_data_$max_temp_rels) char (32) based (ttn_ptr); /* names of temp rels in slot corr. to rel. index */
  9     4 
  9     5 dcl  ttn_ptr ptr;
  9     6 
  9     7 /* END INCLUDE FILE linus_temp_tab_names.incl.pl1 */
      111 
      112 
 10     1 /* BEGIN INCLUDE FILE linus_token_data.incl.pl1 -- jaw 8/7/78 */
 10     2 
 10     3 dcl 1 token_data aligned based (td_ptr),		/* data for lila tokens */
 10     4     2 key fixed bin (17) unal,			/* key of token */
 10     5     2 must_free bit (1) unal,				/* on if value must be freed */
 10     6     2 temp_tab bit (1) unal,				/* on if temporary table */
 10     7     2 reserved bit (16) unal,
 10     8     2 mvar char (32) var,				/* mrds variable if identifier */
 10     9     2 lvar char (32) var,				/* linus variable if identifier */
 10    10     2 length fixed bin (35),				/* char length of token value */
 10    11     2 t_ptr ptr;					/* points to token value */
 10    12 
 10    13 dcl ((NULL init (0)),
 10    14     (RP init (1)),
 10    15     (COL_SPEC init (2)),
 10    16     (LINUS_VAR init (3)),
 10    17     (CONST init (4)),
 10    18     (SET_FN init (5)),
 10    19     (SCAL_FN init (6)),
 10    20     (LP init (7)),
 10    21     (STAR init (8)),
 10    22     (DIV init (9)),
 10    23     (PLUS init (10)),
 10    24     (MINUS init (11)),
 10    25     (TAB_NAME init (12)),
 10    26     (ROW_TAB_PAIR init (13)),
 10    27     (UNION init (14)),
 10    28     (INTER init (15)),
 10    29     (DIFFER init (16)),
 10    30     (ROW_DES init (17)),
 10    31     (LB init (18)),
 10    32     (RB init (19)),
 10    33     (SELECT init (20)),
 10    34     (NOT init (21)),
 10    35     (AND init (22)),
 10    36     (OR init (23)),
 10    37     (EQ init (24)),
 10    38     (NE init (25)),
 10    39     (GT init (26)),
 10    40     (GE init (27)),
 10    41     (LT init (28)),
 10    42     (LE init (29)),
 10    43     (FROM init (30)),
 10    44     (WHERE init (31)),
 10    45     (DUP init (32)),
 10    46     (UNIQUE init (33)),
 10    47     (COMMA init (34))) fixed bin int static options (constant);
 10    48 
 10    49 dcl  td_ptr ptr;
 10    50 
 10    51 /* END INCLUDE FILE linus_token_data.incl.pl1 */
      113 
      114 
 11     1 /* BEGIN INCLUDE FILE linus_variables.incl.pl1 -- jaw 7/19/77 */
 11     2 
 11     3 dcl 1 variables aligned based (lv_ptr),			/* info for all variables */
 11     4     2 nvars_alloc fixed bin,				/* no. var. slots alloc. */
 11     5     2 nvars fixed bin,				/* no. of variables currently defined */
 11     6     2 var_info (nvars_init refer (variables.nvars_alloc)),
 11     7       3 name char (32),				/* name of variable */
 11     8       3 var_ptr ptr,				/* ptr to  curr. value */
 11     9       3 bit_len fixed bin (35),			/* bit length of current value */
 11    10       3 assn_type fixed bin,				/* assign_ type code of current value */
 11    11       3 assn_len fixed bin (35),			/* assign_ length of current value */
 11    12       3 desc bit (36);				/* descrptor of current value */
 11    13 
 11    14 dcl  lv_ptr ptr;
 11    15 dcl  nvars_init fixed bin;
 11    16 
 11    17 /* END INCLUDE FILE linus_variables.incl.pl1 */
      115 
      116 
 12     1 /*	BEGIN INCLUDE FILE		mrds_rslt_info.incl.pl1		rgl  07/22/77			*/
 12     2 
 12     3 /*  Modified by R. Lackey  09/20/76 to handle inverted attributes */
 12     4 
 12     5 /*  Modified by D. Woodka 06/28/82 to fix size condition */
 12     6 
 12     7 dcl 1 rslt_info aligned based (rslt_ptr),		/* resultant information description */
 12     8     2 num_attr fixed bin,				/* number of attributes in view */
 12     9     2 num_key_attr fixed bin,				/* number of key attributes in data relation */
 12    10     2 key_length fixed bin (35),			/* length in bits of key portion of tuple */
 12    11     2 retrieve bit (1) unal,				/* retrieve permitted = "1"b */
 12    12     2 modify bit (1) unal,				/* modify permitted = "1"b */
 12    13     2 store bit (1) unal,				/* store permitted = "1"b */
 12    14     2 delete bit (1) unal,				/* delete permitted = "1"b */
 12    15     2 total_key bit (1) unal,				/* on if view includes the total key */
 12    16     2 inversion bit (1) unal,				/* On if this view contains any inverted attributes */
 12    17     2 reserved bit (30) unal,				/* reserved for future use */
 12    18     2 attr (rslt_alloc refer (rslt_info.num_attr)),	/* per attribute info */
 12    19       3 attr_name char (32),				/* name of attribute */
 12    20       3 domain_name char (32),			/* name of underlying domain */
 12    21       3 attr_length fixed bin (18),			/* length of attribute data in bits */
 12    22       3 attr_index fixed bin (24),			/* index to bit_offset in dbcbrw */
 12    23       3 descriptor bit (36) aligned,			/* attribute description */
 12    24       3 key_flag bit (1) unal,			/* key attribute = "1"b */
 12    25       3 inver_flag bit (1) unal,			/* On if this attribute is inverted */
 12    26       3 unused bit (34) unal,				/* reserved for future use */
 12    27       3 key_attr_order fixed bin,			/* order no. of this key attr. */
 12    28       3 inver_iocb_index fixed bin;			/* Index to inversion iocb in dbcbw */
 12    29 
 12    30 
 12    31 
 12    32 dcl  rslt_ptr ptr;
 12    33 
 12    34 dcl  rslt_alloc fixed bin;
 12    35 
 12    36 /*	END INCLUDE FILE		mrds_rslt_info.incl.pl1						*/
 12    37 
      117 
      118 
      119 
      120 	dcl     (
      121 	        code,				/* Output:  status code */
      122 	        cur_pos,				/* current position in string */
      123 	        i,				/* internal index */
      124 	        icode,				/* internal status code */
      125 	        j,				/* internal index */
      126 	        start_pos				/* Input/Output:  position at which to start scan */
      127 	        )			 fixed bin (35);
      128 
      129 	dcl     initial_mrds_vclock	 float bin (63);
      130 
      131 	dcl     found		 bit (1);
      132 
      133 	dcl     ARITH_CHARS		 char (16) int static options (constant)
      134 				 init (".eib0123456789+-");
      135 	dcl     CONS_PREC		 char (9) int static options (constant) init ("(,+-*/<>=");
      136 	dcl     ARITH_START		 char (14) int static options (constant)
      137 				 init (".0123456789+-(");
      138 	dcl     DELIMS		 char (3) int static options (constant) init ("
      139 	 ");
      140 	dcl     ID_CHARS		 char (64) int static options (constant)
      141 				 init (
      142 				 "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-");
      143 	dcl     BLOCK		 fixed bin int static options (constant) init (4);
      144 	dcl     debug_switch	 bit (1) int static init ("0"b);
      145 	dcl     sfi_ptr		 ptr;		/* pointer to scalfn_info structure */
      146 
      147 	dcl     (
      148 	        linus_data_$max_pred_stack_size,
      149 	        linus_data_$max_range_items,
      150 	        linus_error_$dup_row_des,
      151 	        linus_error_$inv_string_const,
      152 	        linus_error_$invalid_token,
      153 	        linus_error_$linus_var_not_defined,
      154 	        linus_error_$long_id,
      155 	        linus_error_$long_lv_name,
      156 	        linus_error_$unbal_parens,
      157 	        linus_error_$undef_col,
      158 	        linus_error_$undef_id,
      159 	        linus_error_$undef_row_des,
      160 	        linus_error_$undef_tab,
      161 	        mrds_data_$max_id_len,
      162 	        mrds_data_$max_select_items,
      163 	        mrds_data_$max_temp_rels,
      164 	        mrds_data_$max_token_size,
      165 	        sys_info$max_seg_size
      166 	        )			 fixed bin (35) ext;
      167 dcl (linus_lila_tokens_$first_chars,
      168 linus_lila_tokens_$differ,
      169 linus_lila_tokens_$dup,
      170 linus_lila_tokens_$from,
      171 linus_lila_tokens_$inter,
      172 linus_lila_tokens_$select,
      173 linus_lila_tokens_$union,
      174 linus_lila_tokens_$unique,
      175 linus_lila_tokens_$where) char (32) varying ext;
      176 
      177 	dcl     (addr, collate, char, fixed, index, length, null, rel, search, substr,
      178                   translate, vclock, verify)
      179                                          builtin;
      180 
      181 	dcl     dsl_$get_fn_info
      182 				 entry (fixed bin (35), char (*), ptr, ptr, fixed bin (35));
      183 	dcl     dsl_$get_rslt_info
      184 				 entry (fixed bin (35), char (*), ptr, ptr, fixed bin (35));
      185 	dcl     dsl_$get_temp_info
      186 				 entry (fixed bin (35), fixed bin (35), ptr, ptr, fixed bin (35));
      187 	dcl     ioa_		 entry options (variable);
      188 	dcl     ioa_$nnl		 entry options (variable);
      189 	dcl     first_op		 fixed bin;	/* position of first unary operator in a constant */
      190 	dcl     first_dp		 fixed bin;	/* position of first decimal point in a constant */
      191 
      192 	ttn_ptr = lcb.ttn_ptr;
      193 	linus_rel_array_ptr = lcb.rel_array_ptr;
      194 	rslt_ptr = null;
      195 
      196 	if start_pos > lcb.lila_chars then /* nothing left */
      197 	     token_data.key = NULL;
      198 	else do;					/* if have something left */
      199 
      200 		i = verify (substr (source_str, start_pos), DELIMS);
      201 						/* skip white space */
      202 		if i > 0 then do;			/* if possible token */
      203 			cur_pos = start_pos + i - 1;	/* first char of poss. token */
      204 			go to char_proc (index (collate (), source_array (cur_pos)));
      205 						/* see what we have */
      206 
      207 char_proc (1):					/* special characters */
      208 char_proc (2):
      209 char_proc (3):
      210 char_proc (4):
      211 char_proc (5):
      212 char_proc (6):
      213 char_proc (7):
      214 char_proc (8):
      215 char_proc (9):
      216 char_proc (10):
      217 char_proc (11):
      218 char_proc (12):
      219 char_proc (13):
      220 char_proc (14):
      221 char_proc (15):
      222 char_proc (16):
      223 char_proc (17):
      224 char_proc (18):
      225 char_proc (19):
      226 char_proc (20):
      227 char_proc (21):
      228 char_proc (22):
      229 char_proc (23):
      230 char_proc (24):
      231 char_proc (25):
      232 char_proc (26):
      233 char_proc (27):
      234 char_proc (28):
      235 char_proc (29):
      236 char_proc (30):
      237 char_proc (31):
      238 char_proc (32):
      239 char_proc (33):					/* space */
      240 char_proc (36):					/* # */
      241 char_proc (37):					/* $ */
      242 char_proc (38):					/* % */
      243 char_proc (40):					/* ' */
      244 char_proc (59):					/* : */
      245 char_proc (60):					/* ; */
      246 char_proc (64):					/* ? */
      247 char_proc (65):					/* @ */
      248 char_proc (92):					/* [ */
      249 char_proc (93):					/* \ */
      250 char_proc (94):					/* ] */
      251 char_proc (96):					/* _ */
      252 char_proc (97):					/* ` */
      253 char_proc (127):					/* ~ */
      254 char_proc (128):					/* PAD */
      255 			token_data.length = 1;	/* so user knows what caused problem */
      256 			token_data.t_ptr = addr (source_array (cur_pos));
      257 			token_data.must_free = "0"b;
      258 			call error (linus_error_$invalid_token); /* none of these chars. can start a token */
      259 
      260 char_proc (34):					/* ! */
      261 			token_data.key = LINUS_VAR;	/* this is a linus variable */
      262 			token_data.must_free = "0"b;	/* wont alloc. */
      263 			cur_pos = cur_pos + 1;	/* first char past ! */
      264 			token_data.t_ptr = addr (source_array (cur_pos));
      265 			i = verify (substr (source_str, cur_pos), ID_CHARS);
      266 						/* find end of token */
      267 			if i <= 0 then
      268 			     i = lcb.lila_chars - cur_pos + 2;
      269 			token_data.length = i - 1;
      270 			if lcb.lv_ptr = null then /* if no variables defined */
      271 			     call error (linus_error_$linus_var_not_defined);
      272 			lv_ptr = lcb.lv_ptr;
      273 			if variables.nvars <= 0 then /* if no variables */
      274 			     call error (linus_error_$linus_var_not_defined);
      275 			do j = 1 to variables.nvars
      276 			     while (variables.var_info.name (j)
      277 			     ^= substr (source_str, cur_pos, token_data.length));
      278 						/* look for var. */
      279 			end;
      280 			if j > variables.nvars then do; /* if didn't find it */
      281 				i = index (substr (source_str, cur_pos, token_data.length), "-");
      282 						/* look for imbedded hyphen */
      283 				if i <= 0 then
      284 				     call error (linus_error_$linus_var_not_defined);
      285 						/* not there */
      286 				token_data.length = i - 1; /* found one, check first part */
      287 				do j = 1 to variables.nvars
      288 				     while (variables.var_info.name (j)
      289 				     ^= substr (source_str, cur_pos, token_data.length));
      290 				end;
      291 				if j > variables.nvars then
      292 				     call error (linus_error_$linus_var_not_defined);
      293 			     end;			/* if didn't find it first time */
      294 			if token_data.length > mrds_data_$max_id_len then
      295 			     /* if too long */
      296 			     call error (linus_error_$long_lv_name);
      297 			start_pos = cur_pos + token_data.length; /* adjust scan start pos. */
      298 			go to exit;		/* end ! */
      299 
      300 char_proc (35):					/* " */
      301 			token_data.key = CONST;	/* this is a string constant */
      302 			token_data.must_free = "0"b;	/* not allocating */
      303 			token_data.t_ptr = addr (source_array (cur_pos));
      304 			found = "0"b;		/* init for end search */
      305 			cur_pos = cur_pos + 1;
      306 			token_data.length = 1;
      307 			i = index (substr (source_str, cur_pos), """"); /* look for next " */
      308 			do while (i > 0 & ^found);	/* search for single quote */
      309 			     token_data.length = token_data.length + i; /* increment length */
      310 			     cur_pos = cur_pos + i;	/* first char beyond */
      311 			     if cur_pos > lcb.lila_chars then
      312 				found = "1"b;	/* single quote at end of string */
      313 			     else if source_array (cur_pos) = """" then do;
      314 				     cur_pos = cur_pos + 1;
      315 				     token_data.length = token_data.length + 1;
      316 				     if cur_pos <= lcb.lila_chars then
      317 					i = index (substr (source_str, cur_pos), """");
      318 				     else i = 0;
      319 				end;		/* if double " */
      320 			     else found = "1"b;	/* if single " */
      321 			end;			/* single " search loop */
      322 			if ^found then
      323 			     call error (linus_error_$inv_string_const);
      324 			if cur_pos ^> lcb.lila_chars then
      325 			     if source_array (cur_pos) = "b" then do; /* if bit string */
      326 				     cur_pos = cur_pos + 1;
      327 				     token_data.length = token_data.length + 1;
      328 				end;
      329 			start_pos = cur_pos;
      330 			go to exit;		/* end " */
      331 
      332 char_proc (39):					/* & */
      333 			call set_token (AND, 1);	/* return AND token */
      334 			go to exit;
      335 
      336 char_proc (41):					/* ( */
      337 			token_data.key = LP;	/* assume LP unless proven other */
      338 			i = verify (substr (source_str, cur_pos + 1), "0123456789");
      339 						/* is possible string const */
      340 			if source_array (cur_pos + i) = ")" & i > 1 then do;
      341 						/* good chance of string const */
      342 				j = verify (substr (source_str, cur_pos + i + 1), DELIMS);
      343 						/* skip white space */
      344 				if source_array (cur_pos + i + j) = """" then do;
      345 						/* have string const */
      346 					token_data.key = CONST;
      347 					token_data.length = i + j + 1; /* init for quote search loop */
      348 					token_data.t_ptr = addr (source_array (cur_pos));
      349 					cur_pos = cur_pos + i + j + 1;
      350 					found = "0"b;
      351 					i = index (substr (source_str, cur_pos), """");
      352 						/* find next quote */
      353 					do while (i > 0 & ^found); /* until we find a single quote */
      354 					     token_data.length = token_data.length + i;
      355 						/* incr. length */
      356 					     cur_pos = cur_pos + i; /* first char beyond */
      357 					     if cur_pos > lcb.lila_chars then
      358 						call error (linus_error_$inv_string_const);
      359 					     if source_array (cur_pos) = """" then do;
      360 						/* if double quote */
      361 						     cur_pos = cur_pos + 1;
      362 						     token_data.length = token_data.length + 1;
      363 						     if cur_pos <= lcb.lila_chars then
      364 							i = index (substr (source_str, cur_pos), """");
      365 						     else i = 0; /* terminate if past end of string */
      366 						end; /* if double quote */
      367 					     else do; /* if single quote */
      368 						     found = "1"b;
      369 						     cur_pos = cur_pos + i;
      370 						     token_data.length = token_data.length + i;
      371 						end; /* if single quote */
      372 					end;	/* single quote search loop */
      373 					if ^found then
      374 					     call error (linus_error_$inv_string_const);
      375 					if source_array (cur_pos) = "b" then do; /* if bit string */
      376 						cur_pos = cur_pos + 1;
      377 						token_data.length = token_data.length + 1;
      378 					     end;
      379 					token_data.must_free = "0"b;
      380 					start_pos = cur_pos;
      381 				     end;		/* if string const */
      382 			     end;			/* if good chance */
      383 			i = verify (substr (source_str, cur_pos + 1), ARITH_CHARS || DELIMS);			
      384 			if source_array (cur_pos + i) = ")" then do; /* possible arith constant */
      385 			     first_op = search (substr (source_str, cur_pos + 1, i), "+-");
      386 			     /* find first unary operator */
      387 			     if first_op ^= 0
      388 			          & search (substr (source_str, cur_pos + first_op + 1, i - first_op),
      389 			          "+-") = 0
      390 			          & search (substr (source_str, cur_pos + 1, first_op),
      391 			          "1234567890") = 0 then do; /* valid unary */
      392 			               first_dp = index (substr (source_str, cur_pos + 1, i), ".");
      393 				     /* find first period */
      394 				     if search (
      395 				          substr (source_str, cur_pos + first_dp + 1, i - first_dp),
      396 				          ".") = 0 then
      397 				          call arith_const;
      398 				     end;		/* is valid unary */
      399 				  end;			/* possible arith constant */
      400 
      401 			if token_data.key = LP then
      402 			     call set_token (LP, 1);	/* if wasn't const */
      403 			go to exit;		/* end ( */
      404 
      405 char_proc (42):					/* ) */
      406 			call set_token (RP, 1);
      407 			go to exit;
      408 
      409 char_proc (43):					/* * */
      410 			call set_token (STAR, 1);
      411 			go to exit;
      412 
      413 char_proc (44):					/* + */
      414 			if is_const () = "1"b then
      415 			     call arith_const;	/* is arith const = "1"b */
      416 			else call set_token (PLUS, 1);/* is operator */
      417 			go to exit;
      418 
      419 char_proc (45):					/* , */
      420 			call set_token (COMMA, 1);
      421 			go to exit;
      422 
      423 char_proc (46):					/* - */
      424 			if is_const () = "1"b then
      425 			     call arith_const;
      426 			else call set_token (MINUS, 1);
      427 			go to exit;
      428 
      429 char_proc (47):					/* . */
      430 char_proc (49):					/* 0 */
      431 char_proc (50):					/* 1 */
      432 char_proc (51):					/* 2 */
      433 char_proc (52):					/* 3 */
      434 char_proc (53):					/* 4 */
      435 char_proc (54):					/* 5 */
      436 char_proc (55):					/* 6 */
      437 char_proc (56):					/* 7 */
      438 char_proc (57):					/* 8 */
      439 char_proc (58):					/* 9 */
      440 						/* these characters begin an arith. const. */
      441 			call arith_const;
      442 			go to exit;
      443 
      444 char_proc (48):					/* / */
      445 			call set_token (DIV, 1);
      446 			go to exit;
      447 
      448 char_proc (61):					/* < */
      449 			if source_array (cur_pos + 1) = "=" then
      450 			     call set_token (LE, 2);
      451 			else call set_token (LT, 1);
      452 			go to exit;
      453 
      454 char_proc (62):					/* = */
      455 			call set_token (EQ, 1);
      456 			go to exit;
      457 
      458 char_proc (63):					/* > */
      459 			if source_array (cur_pos + 1) = "=" then
      460 			     call set_token (GE, 2);
      461 			else call set_token (GT, 1);
      462 			go to exit;
      463 
      464 char_proc (66):					/* A */
      465 char_proc (67):					/* B */
      466 char_proc (68):					/* C */
      467 char_proc (69):					/* D */
      468 char_proc (70):					/* E */
      469 char_proc (71):					/* F */
      470 char_proc (72):					/* G */
      471 char_proc (73):					/* H */
      472 char_proc (74):					/* I */
      473 char_proc (75):					/* J */
      474 char_proc (76):					/* K */
      475 char_proc (77):					/* L */
      476 char_proc (78):					/* M */
      477 char_proc (79):					/* N */
      478 char_proc (80):					/* O */
      479 char_proc (81):					/* P */
      480 char_proc (82):					/* Q */
      481 char_proc (83):					/* R */
      482 char_proc (84):					/* S */
      483 char_proc (85):					/* T */
      484 char_proc (86):					/* U */
      485 char_proc (87):					/* V */
      486 char_proc (88):					/* W */
      487 char_proc (89):					/* X */
      488 char_proc (90):					/* Y */
      489 char_proc (91):					/* Z */
      490 			call ident_proc;		/* determine identifier type, and set up token data */
      491 			go to exit;
      492 
      493 char_proc (98):					/* a */
      494 char_proc (99):					/* b */
      495 char_proc (100):					/* c */
      496 char_proc (101):                                            /* d */
      497 char_proc (102):					/* e */
      498 char_proc (103):                                            /* f */
      499 char_proc (104):					/* g */
      500 char_proc (105):					/* h */
      501 char_proc (106):                                            /* i */
      502 char_proc (107):					/* j */
      503 char_proc (108):					/* k */
      504 char_proc (109):					/* l */
      505 char_proc (110):					/* m */
      506 char_proc (111):					/* n */
      507 char_proc (112):					/* o */
      508 char_proc (113):					/* p */
      509 char_proc (114):					/* q */
      510 char_proc (115):					/* r */
      511 char_proc (116):                                            /* s */
      512 char_proc (117):					/* t */
      513 char_proc (118):                                            /* u */
      514 char_proc (119):					/* v */
      515 char_proc (120):                                            /* w */
      516 char_proc (121):					/* x */
      517 char_proc (122):					/* y */
      518 char_proc (123):					/* z */
      519 			if verify (substr (source_str, cur_pos, 1), linus_lila_tokens_$first_chars) ^= 0
      520 			then do;
      521 			     call ident_proc;		/* determine identifier type, and set up token data */
      522 			     go to exit;
      523 			end;
      524 			else do;
      525 			     i = verify (substr (source_str, cur_pos + 1), ID_CHARS);
      526 			     if substr (source_str, cur_pos, i) = linus_lila_tokens_$from
      527 			     then call set_token (FROM, length(linus_lila_tokens_$from));
      528 			     else if substr (source_str, cur_pos, i) = linus_lila_tokens_$select
      529 			     then call set_token (SELECT, length(linus_lila_tokens_$select));
      530 			     else if substr (source_str, cur_pos, i) = linus_lila_tokens_$where 
      531 			     then call set_token (WHERE, length(linus_lila_tokens_$where));
      532 			     else if substr (source_str, cur_pos, i) = linus_lila_tokens_$differ
      533 			     then call set_token (DIFFER, length(linus_lila_tokens_$differ));
      534 			     else if substr (source_str, cur_pos, i) = linus_lila_tokens_$dup
      535 			     then call set_token (DUP, length(linus_lila_tokens_$dup));
      536 			     else if substr (source_str, cur_pos, i) = linus_lila_tokens_$inter
      537 			     then call set_token (INTER, length(linus_lila_tokens_$inter));
      538 			     else if substr (source_str, cur_pos, i) = linus_lila_tokens_$unique
      539 			     then call set_token (UNIQUE, length(linus_lila_tokens_$unique));
      540 			     else if substr (source_str, cur_pos, i) = linus_lila_tokens_$union
      541 			     then call set_token (UNION, length (linus_lila_tokens_$union));
      542 			     else call ident_proc;
      543 			end;
      544 			go to exit;
      545 
      546 char_proc (95):					/* ^ */
      547 			if source_array (cur_pos + 1) = "=" then
      548 			     call set_token (NE, 2);
      549 			else call set_token (NOT, 1);
      550 			go to exit;
      551 
      552 char_proc (124):					/* { */
      553 			call set_token (LB, 1);
      554 			go to exit;
      555 
      556 char_proc (125):					/* | */
      557 			call set_token (OR, 1);
      558 			go to exit;
      559 
      560 char_proc (126):					/* } */
      561 			call set_token (RB, 1);
      562 			go to exit;
      563 
      564 exit:
      565 		     end;				/* token section */
      566 
      567 		else do;				/* ran out of tokens */
      568 			token_data.key = NULL;
      569 			start_pos = lcb.lila_chars + 1;
      570 		     end;
      571 	     end;					/* if something to do */
      572 
      573 	code = 0;
      574 	if debug_switch then do;
      575 		if cur_pos >= 1 & start_pos > cur_pos then
      576 		     call
      577 			ioa_ ("Token: ""^a""",
      578 			substr (source_str, cur_pos, start_pos - cur_pos));
      579 		else call
      580 			ioa_ ("Token: start_pos = ^i; cur_pos = ^i", start_pos,
      581 			cur_pos);
      582 		call ioa_ ("^2-key = ^i", token_data.key);
      583 
      584 		call ioa_$nnl ("^2-Flags: ");
      585 		if ^token_data.must_free then
      586 		     call ioa_$nnl ("^^");
      587 		call ioa_$nnl ("must_free,");
      588 		if ^token_data.temp_tab then
      589 		     call ioa_$nnl ("^^");
      590 		call ioa_ ("temp_tab");
      591 
      592 		call ioa_ ("^2-mvar = ""^a""^/^2-lvar = ""^a""", mvar, lvar);
      593 		call ioa_ ("^2-length = ^i", token_data.length);
      594 
      595 		call ioa_ ("^2-t_ptr = ^p", token_data.t_ptr);
      596 	     end;					/* if debug_switch */
      597 
      598 real_exit:
      599 	;
      600 	return;
      601 
      602 db_on:
      603      entry;
      604 
      605 /* Usage:
      606*   linus_lila_get_token$db_on
      607*
      608*   Turns on a switch which causes the value of the current
      609*   token to be displayed at the terminal.
      610**/
      611 
      612 	debug_switch = "1"b;
      613 	return;
      614 
      615 db_off:
      616      entry;
      617 
      618 /* Usage:
      619*   linus_lila_get_token$db_off
      620*
      621*   Turns off the switch which causes the value of the current
      622*   token to be displayed at the terminal.
      623**/
      624 
      625 	debug_switch = "0"b;
      626 	return;
      627 
      628 set_token:
      629      proc (key, length);
      630 
      631 /* Procedure to set up token_data given a key value and token length */
      632 
      633 	dcl     (key, length)	 fixed bin;
      634 
      635 	token_data.key = key;
      636 	token_data.length = length;
      637 	token_data.temp_tab, token_data.must_free = "0"b; /* didn't allocate */
      638 	token_data.mvar, token_data.lvar = "";
      639 	token_data.t_ptr = addr (source_array (cur_pos));
      640 	start_pos = cur_pos + length;
      641 
      642      end set_token;
      643 
      644 set_id_token:
      645      proc (key, mvar, lvar, length);
      646 
      647 /* Procedure to set up an ident. token data */
      648 
      649 	dcl     (key, length)	 fixed bin;
      650 	dcl     (mvar, lvar)	 char (32) var;
      651 
      652 	token_data.key = key;
      653 	token_data.length = length;
      654 	token_data.temp_tab, token_data.must_free = "0"b; /* didn't allocate */
      655 	token_data.t_ptr = addr (source_array (cur_pos));
      656 	token_data.mvar = mvar;
      657 	token_data.lvar = lvar;
      658 	start_pos = cur_pos + length;
      659 
      660      end set_id_token;
      661 
      662 set_tab_name:
      663      proc (temp_flag, length);
      664 
      665 /* procedure to set up table name token */
      666 
      667 	dcl     length		 fixed bin;
      668 	dcl     temp_flag		 bit (1);
      669 
      670 	token_data.key = TAB_NAME;
      671 	token_data.length = length;
      672 	token_data.must_free = "0"b;
      673 	token_data.t_ptr = addr (source_array (cur_pos));
      674 	token_data.temp_tab = temp_flag;
      675 	token_data.mvar, token_data.lvar = "";
      676 	start_pos = cur_pos + length;
      677 
      678      end set_tab_name;
      679 
      680 is_const:
      681      proc returns (bit (1));
      682 
      683 /* Procedure to determine if token at cur_pos is an arithmetic constant or
      684*   is an operator. */
      685 
      686 	dcl     i			 fixed bin;
      687 	dcl     flag		 bit (1);
      688 
      689 	if verify (source_array (cur_pos + 1), ARITH_START) = 0 then do;
      690 						/* possible const. */
      691 		do i = cur_pos - 1 to 1 by -1
      692 		     while (verify (source_array (i), DELIMS) = 0);
      693 		end;				/* search for end of prev token */
      694 		if i < 1 then
      695 		     flag = "1"b;			/* first token, must be const */
      696 		else if verify (source_array (i), CONS_PREC) = 0 then
      697 		     flag = "1"b;			/* if predecessor forces constant */
      698 		else flag = "0"b;			/* is operator */
      699 	     end;					/* possible constant */
      700 	else flag = "0"b;				/* if no chance of constant */
      701 	return (flag);
      702      end is_const;
      703 
      704 arith_const:
      705      proc;
      706 
      707 /* Procedure to isolate an arithmetic constant, and set up the resulting token
      708*   data */
      709 
      710 	dcl     i			 fixed bin;	/* length of constant */
      711 	dcl     j			 fixed bin;	/* location of LP */
      712 
      713 	token_data.key = CONST;
      714 	token_data.t_ptr = addr (source_array (cur_pos));
      715 	token_data.must_free = "0"b;
      716 	i = verify (substr (source_str, cur_pos + 1), ARITH_CHARS);
      717 	if i <= 0 then
      718 	     i = lcb.lila_chars - cur_pos + 1;
      719 	else if source_array (cur_pos + i - 1) = "+" /* see if ended with operator */
      720 		| source_array (cur_pos + i - 1) = "-" then
      721 	     i = i - 1;
      722 
      723 	j = index (substr (source_str, cur_pos), "(");	/* find lp position (if any)*/
      724 	if (j = 1) | (j = 2 & search (substr (source_str, cur_pos, 2), "-+") = 1)
      725 	then do;					/* constant enclosed in parentheses */
      726 		i = index (substr (source_str, cur_pos), ")"); /* must end in matching parentheses */
      727 		if search (substr (source_str, cur_pos + j, i - j - 1), "()") ^= 0 then
      728 		     call error (linus_error_$unbal_parens); /* no others allowed */
      729 		if j = 1 then
      730 		     substr (source_str, cur_pos, i) =
      731 			substr (source_str, cur_pos + 1, i - 1);
      732 		else substr (source_str, cur_pos, i) =
      733 			source_array (cur_pos)
      734 			|| substr (source_str, cur_pos + 2, i - 2); /* strip out lp */
      735 		substr (source_str, cur_pos, i) =
      736 		     translate (substr (source_str, cur_pos, i), "", " +)");
      737 						/* strip out spaces, rp, and plus */
      738 	     end;					/* enclosed constant */
      739 
      740 	token_data.length = i;			/* set length constant */
      741 	token_data.mvar, token_data.lvar = "";
      742 	start_pos = cur_pos + i;
      743 
      744      end arith_const;
      745 
      746 ident_proc:
      747      proc;
      748 
      749 /* Procedure to determine identifier type.  The following items are checked for,
      750*   in the order specified: row_designator, relation name, column name, set function,
      751*   scalar function. */
      752 
      753 	dcl     (i, j, k, vindex)	 fixed bin;
      754 	dcl     temp_flag		 bit (1);
      755 	dcl     f_choice		 char (i) based (addr (source_array (cur_pos)));
      756 	dcl     s_choice		 char (j) based (addr (source_array (cur_pos)));
      757           dcl     ip_character_string_length fixed bin;
      758 	dcl     ip_character_string char (ip_character_string_length) based (addr (source_array (cur_pos + i + 1)));
      759 
      760 	j = 0;					/* init */
      761 	i = verify (substr (source_str, cur_pos), ID_CHARS); /* find end of id. */
      762 	if i <= 0 then
      763 	     i = lcb.lila_chars - cur_pos + 1;
      764 	else i = i - 1;				/* i is length */
      765 	token_data.length = i;			/* init. token in case of error */
      766 	token_data.t_ptr = addr (source_array (cur_pos));
      767 	token_data.must_free = "0"b;
      768 	if i > mrds_data_$max_id_len then do;		/* too long, may have hidden - */
      769 		j = index (substr (source_str, cur_pos, i), "-");
      770 		if j <= 0 then
      771 		     call error (linus_error_$long_id); /* is bad */
      772 		if j > mrds_data_$max_id_len then
      773 		     call error (linus_error_$long_id); /* if first part too long */
      774 		else do;				/* first part ok */
      775 			i = j - 1;
      776 			j = 0;
      777 		     end;
      778 	     end;					/* if orig. id. too long */
      779 	else j = index (substr (source_str, cur_pos, i), "-"); /* see if there is second choice */
      780 	if j > 0 then
      781 	     j = j - 1;				/* yes, set true length */
      782 
      783 	lsb_ptr = ls_header.cur_ptr;			/* point to current lila stack frame */
      784 	if ls_block.type = BLOCK then do;		/* if in lila block */
      785 		if source_array (cur_pos + i) = ":" then do; /* row tab pair */
      786 			if valid_var (f_choice, vindex) then
      787 			     call error (linus_error_$dup_row_des); /* was prev. defined */
      788 			j = verify (substr (source_str, cur_pos + i + 1), ID_CHARS);
      789 						/* isolate rel name */
      790 			ip_character_string_length = j - 1;
      791 			if ^valid_rel (ip_character_string, temp_flag) then
      792 			     call error (linus_error_$undef_tab);
      793 			call set_token (ROW_TAB_PAIR, i + j); /* is valid row tab pair */
      794 			token_data.temp_tab = temp_flag; /* remember if it was a temp table */
      795 		     end;				/* if : */
      796 		else if ls_block.nritems > 0 then do;	/* if range started */
      797 			if source_array (cur_pos + i) = "." then do; /* possible col. spec. */
      798 				if source_array (cur_pos + i + 1) = "*" then /* select. of entire tuple */
      799 				     if valid_var (f_choice, vindex) then do;
      800 					     call
      801 						set_id_token (ROW_DES,
      802 						ls_block.range_items.mrds_var (vindex),
      803 						ls_block.range_items.tup_var (vindex), i);
      804 					     start_pos = start_pos + 2; /* adjust beyond * */
      805 					end;
      806 				     else call error (linus_error_$undef_row_des);
      807 				else do;		/* if not entire tuple */
      808 					do k = ls_block.nritems by -1 to 1
      809 					     while (f_choice ^= ls_block.range_items.tup_var (k));
      810 					end;	/* look for tuple var. */
      811 					if k < 1 then
      812 					     call error (linus_error_$undef_row_des);
      813 					vindex = k; /* save var. index */
      814 					j = verify (substr (source_str, cur_pos + i + 1), ID_CHARS);
      815 						/* get attr. name */
      816 					if j <= 0 then
      817 					     j = lcb.lila_chars - cur_pos - i;
      818 					ip_character_string_length = j - 1;
      819 					if ^valid_attr (vindex,
      820 					     ip_character_string) then do;
      821 						/* may be - */
      822 						k = index (substr (source_str, cur_pos + i + 1, j - 1),
      823 						     "-");
      824 						if k <= 0 then
      825 						     call error (linus_error_$undef_col);
      826 						ip_character_string_length = k - 1;
      827 						if ^valid_attr (vindex,
      828 						    ip_character_string) then
      829 						     call error (linus_error_$undef_col);
      830 						j = k; /* first part ok */
      831 					     end; /* failed first attr. choice */
      832 					cur_pos = cur_pos + i + 1;
      833 					call
      834 					     set_id_token (COL_SPEC,
      835 					     ls_block.range_items.mrds_var (vindex),
      836 					     ls_block.range_items.tup_var (vindex), j - 1);
      837 				     end;		/* if not entire tuple */
      838 			     end;			/* if col. spec. */
      839 			else if ls_header.from_token then do;
      840 				if valid_rel (f_choice, temp_flag) then
      841 				     call set_tab_name (temp_flag, i);
      842 				else if valid_rel (s_choice, temp_flag) then
      843 				     call set_tab_name (temp_flag, j);
      844 				else call error (linus_error_$undef_tab);
      845 			     end;
      846 			else if valid_attr (0, f_choice) then
      847 			     call set_col_spec (i);
      848 			else if valid_var (f_choice, vindex) then
      849 			     call
      850 				set_id_token (ROW_DES,
      851 				ls_block.range_items.mrds_var (vindex),
      852 				ls_block.range_items.tup_var (vindex), i);
      853 			else if valid_rel (f_choice, temp_flag) then
      854 			     call set_tab_name (temp_flag, i);
      855 			else if valid_set_fn (f_choice) then
      856 			     call set_token (SET_FN, i);
      857 			else if valid_scal_fn (f_choice) then
      858 			     call set_token (SCAL_FN, i);
      859 			else if valid_attr (0, s_choice) then
      860 			     call set_col_spec (j);
      861 			else if valid_var (s_choice, vindex) then
      862 			     call
      863 				set_id_token (ROW_DES,
      864 				ls_block.range_items.mrds_var (vindex),
      865 				ls_block.range_items.tup_var (vindex), j);
      866 			else if valid_rel (s_choice, temp_flag) then
      867 			     call set_tab_name (temp_flag, j);
      868 			else call error (linus_error_$undef_id);
      869 		     end;				/* if have range start */
      870 
      871 		else if valid_rel (f_choice, temp_flag) then /* if first item in range */
      872 		     call set_tab_name (temp_flag, i);
      873 		else call error (linus_error_$undef_id);
      874 	     end;					/* if in lila block */
      875 	else if valid_set_fn (f_choice) then
      876 	     call set_token (SET_FN, i);
      877 	else call error (linus_error_$undef_id);
      878 
      879 valid_rel:
      880      proc (rel_name, temp_flag) returns (bit (1));
      881 
      882 /* Procedure to determine if a relation is defined in the database */
      883 
      884 	dcl     rel_name		 char (*);
      885 	dcl     (result, temp_flag)	 bit (1);
      886 	dcl     (i, j)		 fixed bin (35);
      887 
      888 	temp_flag, result = "0"b;
      889 
      890 	if length (rel_name) > 0 then do;		/* make sure is non-null */
      891 		do j = 1 to linus_rel_array.num_of_rels
      892 		     while (linus_rel_array.rels.rel_name (j) ^= rel_name);
      893 		end;
      894 		if j ^> linus_rel_array.num_of_rels then
      895 		     result = "1"b;
      896 		if ^result & linus_rel_array.num_of_rels < linus_data_$max_range_items
      897 		then do;				/* not referenced, check database */
      898 			rslt_ptr = null;
      899 			if lcb.timing_mode then
      900 			     initial_mrds_vclock = vclock;
      901 			call
      902 			     dsl_$get_rslt_info (lcb.db_index, rel_name, lcb.lila_area_ptr,
      903 			     rslt_ptr, icode);	/* see if defined in db. */
      904 			if lcb.timing_mode then
      905 			     lcb.mrds_time = lcb.mrds_time + (vclock - initial_mrds_vclock);
      906 			if icode = 0 then do;	/* was found in db */
      907 				result = "1"b;
      908 				linus_rel_array.num_of_rels = linus_rel_array.num_of_rels + 1;
      909 				linus_rel_array.rels.rel_name (linus_rel_array.num_of_rels) =
      910 				     rel_name;
      911 				linus_rel_array.rels
      912 				     .rslt_info_ptr (linus_rel_array.num_of_rels) = rslt_ptr;
      913 				rslt_ptr = null;
      914 			     end;
      915 		     end;				/* data base search */
      916 		if ^result & linus_rel_array.num_of_rels < linus_data_$max_range_items
      917 		then do;				/* not found, check temps */
      918 			if ttn_ptr ^= null then do;	/* if temps defined */
      919 				do i = 1 to mrds_data_$max_temp_rels
      920 				     while (temp_tab_names (i) ^= rel_name);
      921 				end;		/* search through temp tab table */
      922 				if i <= mrds_data_$max_temp_rels then do; /* if found */
      923 					if lcb.timing_mode then
      924 					     initial_mrds_vclock = vclock;
      925 					call
      926 					     dsl_$get_temp_info (lcb.db_index, i, lcb.lila_area_ptr,
      927 					     rslt_ptr, icode);
      928 					if lcb.timing_mode then
      929 					     lcb.mrds_time =
      930 						lcb.mrds_time + (vclock - initial_mrds_vclock);
      931 					if icode = 0 then do;
      932 						linus_rel_array.num_of_rels =
      933 						     linus_rel_array.num_of_rels + 1;
      934 						linus_rel_array.rels
      935 						     .rel_name (linus_rel_array.num_of_rels) = rel_name;
      936 						linus_rel_array.rels
      937 						     .rslt_info_ptr (linus_rel_array.num_of_rels) = rslt_ptr;
      938 						rslt_ptr = null;
      939 						result, temp_flag = "1"b;
      940 					     end;
      941 				     end;
      942 			     end;			/* if temps defined */
      943 		     end;				/* temps search */
      944 	     end;					/* if non-null */
      945 
      946 	return (result);
      947 
      948      end valid_rel;
      949 
      950 valid_attr:
      951      proc (tv_index, attr_name) returns (bit (1));
      952 
      953 /* Procedure to determine if an attribute is defined in the
      954*   specified relation.  If tv_index is zero, the current default
      955*   relation is chosen */
      956 
      957 	dcl     rname		 char (32);
      958 	dcl     attr_name		 char (*);
      959 	dcl     result		 bit (1);
      960 	dcl     (i, j, tv_index)	 fixed bin;
      961 
      962 	result = "0"b;
      963 	icode = 0;
      964 
      965 	if tv_index <= 0 then
      966 	     tv_index = ls_block.dflt_ritem;
      967 	if tv_index > 0 then do;
      968 		rslt_ptr = null;
      969 		rname = ls_block.range_items.rel_name (tv_index);
      970 		if rname = ".V." then do;
      971 			rname = char (ls_block.range_items.rel_index (tv_index));
      972 			do j = 1 to linus_rel_array.num_of_rels
      973 			     while (linus_rel_array.rels.rel_name (j)
      974 			     ^= temp_tab_names (ls_block.range_items.rel_index (tv_index)));
      975 			end;
      976 		     end;
      977 		else
      978 		     do j = 1 to linus_rel_array.num_of_rels
      979 			while (linus_rel_array.rels.rel_name (j) ^= rname);
      980 		     end;
      981 		if j ^> linus_rel_array.num_of_rels then do; /* if found */
      982 			rslt_ptr = linus_rel_array.rels.rslt_info_ptr (j);
      983 			do i = 1 to rslt_info.num_attr
      984 			     while (attr_name ^= rslt_info.attr.attr_name (i));
      985 			end;			/* search for attr info */
      986 			if i <= rslt_info.num_attr then
      987 			     result = "1"b;		/* found it */
      988 		     end;				/* found rel */
      989 		rslt_ptr = null;
      990 	     end;					/* search for rel info */
      991 
      992 	return (result);
      993 
      994      end valid_attr;
      995 
      996 valid_var:
      997      proc (var_name, i) returns (bit (1));
      998 
      999 /* Procedure to determine is a tuple variable has been defined */
     1000 
     1001 	dcl     var_name		 char (*);
     1002 	dcl     result		 bit (1);
     1003 	dcl     i			 fixed bin;
     1004 
     1005 	result = "0"b;
     1006 
     1007 	if ls_block.type = BLOCK then /* need search only if in block */
     1008 	     if ls_block.nritems > 0 then do;		/* if some range items defined */
     1009 		     do i = ls_block.nritems by -1 to 1
     1010 			while (var_name ^= ls_block.range_items.tup_var (i));
     1011 		     end;				/* search for tuple var */
     1012 		     if i >= 1 then
     1013 			result = "1"b;		/* was found */
     1014 		end;
     1015 
     1016 	return (result);
     1017 
     1018      end valid_var;
     1019 
     1020 valid_set_fn:
     1021      proc (fn_name) returns (bit (1));
     1022 
     1023 /* Procedure to determine if a set function is defined */
     1024 
     1025 	dcl     fn_name		 char (*);
     1026 	dcl     result		 bit (1);
     1027 
     1028 	result = "0"b;
     1029 
     1030 	do linus_set_fn_info_ptr = lcb.setfi_ptr
     1031 	     repeat linus_set_fn_info.fwd_ptr
     1032 	     while (linus_set_fn_info.fwd_ptr ^= null
     1033 	     & linus_set_fn_info.name ^= fn_name);
     1034 	end;					/* search for set fn name */
     1035 	if linus_set_fn_info.name = fn_name then
     1036 	     result = "1"b;
     1037 
     1038 	return (result);
     1039 
     1040      end valid_set_fn;
     1041 
     1042 valid_scal_fn:
     1043      proc (fn_name) returns (bit (1));
     1044 
     1045 /* Procedure to determine if a scalar function has been defined */
     1046 
     1047 	dcl     fn_name		 char (*);
     1048 	dcl     result		 bit (1);
     1049 
     1050 	if lcb.timing_mode then
     1051 	     initial_mrds_vclock = vclock;
     1052 	call
     1053 	     dsl_$get_fn_info (lcb.db_index, fn_name, lcb.lila_area_ptr, sfi_ptr,
     1054 	     icode);
     1055 	if lcb.timing_mode then
     1056 	     lcb.mrds_time = lcb.mrds_time + (vclock - initial_mrds_vclock);
     1057 	if icode = 0 then
     1058 	     result = "1"b;
     1059 	else result = "0"b;
     1060 
     1061 	return (result);
     1062 
     1063      end valid_scal_fn;
     1064 
     1065      end ident_proc;
     1066 
     1067 set_col_spec:
     1068      proc (length);
     1069 
     1070 /* Procedure to create a tuple var . attr token */
     1071 
     1072 	dcl     length		 fixed bin;
     1073 
     1074 	token_data.must_free = "0"b;			/* not allocated this time */
     1075 	token_data.key = COL_SPEC;
     1076 	token_data.t_ptr = addr (source_array (cur_pos));
     1077 	token_data.length = length;
     1078 	token_data.mvar = ls_block.range_items.mrds_var (ls_block.dflt_ritem);
     1079 	token_data.lvar = ls_block.range_items.tup_var (ls_block.dflt_ritem);
     1080 	start_pos = cur_pos + length;
     1081 
     1082      end set_col_spec;
     1083 
     1084 error:
     1085      proc (cd);
     1086 
     1087 /* Error procedure */
     1088 
     1089 	dcl     cd		 fixed bin (35);
     1090 
     1091 	code = cd;
     1092 	ls_header.cur_pos = cur_pos;
     1093 	go to real_exit;
     1094 
     1095      end error;
     1096 
     1097      end linus_lila_get_token;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/29/86  0937.0  linus_lila_get_token.pl1          >special_ldd>install>MR12.0-1106>linus_lila_get_token.pl1
99           1    07/29/86  0937.8  linus_lcb.incl.pl1                >special_ldd>install>MR12.0-1106>linus_lcb.incl.pl1
101          2    03/27/82  0434.5  linus_ls_block.incl.pl1           >ldd>include>linus_ls_block.incl.pl1
2-4          3    03/27/82  0434.5  linus_ls_common.incl.pl1          >ldd>include>linus_ls_common.incl.pl1
103          4    11/23/82  1327.2  linus_ls_header.incl.pl1          >ldd>include>linus_ls_header.incl.pl1
4-4          5    03/27/82  0434.5  linus_ls_common.incl.pl1          >ldd>include>linus_ls_common.incl.pl1
105          6    03/27/82  0434.5  linus_rel_array.incl.pl1          >ldd>include>linus_rel_array.incl.pl1
107          7    11/23/82  1327.2  linus_set_fn_info.incl.pl1        >ldd>include>linus_set_fn_info.incl.pl1
109          8    03/27/82  0434.5  linus_source.incl.pl1             >ldd>include>linus_source.incl.pl1
111          9    03/27/82  0434.5  linus_temp_tab_names.incl.pl1     >ldd>include>linus_temp_tab_names.incl.pl1
113         10    03/27/82  0434.5  linus_token_data.incl.pl1         >ldd>include>linus_token_data.incl.pl1
115         11    03/27/82  0434.5  linus_variables.incl.pl1          >ldd>include>linus_variables.incl.pl1
117         12    10/14/83  1609.0  mrds_rslt_info.incl.pl1           >ldd>include>mrds_rslt_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AND                                    constant        fixed bin(17,0)          initial dcl 10-13 set ref 332*
ARITH_CHARS                     000230 constant        char(16)                 initial unaligned dcl 133 ref 383 716
ARITH_START                     000221 constant        char(14)                 initial unaligned dcl 136 ref 689
BLOCK                                  constant        fixed bin(17,0)          initial dcl 143 ref 784 1007
COL_SPEC                        000312 constant        fixed bin(17,0)          initial dcl 10-13 set ref 833* 1075
COMMA                                  constant        fixed bin(17,0)          initial dcl 10-13 set ref 419*
CONST                                  constant        fixed bin(17,0)          initial dcl 10-13 ref 300 346 713
CONS_PREC                       000225 constant        char(9)                  initial unaligned dcl 135 ref 696
DELIMS                          000220 constant        char(3)                  initial unaligned dcl 138 ref 200 342 383 691
DIFFER                          000252 constant        fixed bin(17,0)          initial dcl 10-13 set ref 532*
DIV                                    constant        fixed bin(17,0)          initial dcl 10-13 set ref 444*
DUP                             000235 constant        fixed bin(17,0)          initial dcl 10-13 set ref 534*
EQ                              000244 constant        fixed bin(17,0)          initial dcl 10-13 set ref 454*
FROM                            000237 constant        fixed bin(17,0)          initial dcl 10-13 set ref 526*
GE                              000241 constant        fixed bin(17,0)          initial dcl 10-13 set ref 458*
GT                              000242 constant        fixed bin(17,0)          initial dcl 10-13 set ref 461*
ID_CHARS                        000200 constant        char(64)                 initial unaligned dcl 140 ref 265 525 761 788 814
INTER                           000253 constant        fixed bin(17,0)          initial dcl 10-13 set ref 536*
LB                                     constant        fixed bin(17,0)          initial dcl 10-13 set ref 552*
LE                                     constant        fixed bin(17,0)          initial dcl 10-13 set ref 448*
LINUS_VAR                              constant        fixed bin(17,0)          initial dcl 10-13 ref 260
LP                              000256 constant        fixed bin(17,0)          initial dcl 10-13 set ref 336 401 401*
LT                              000240 constant        fixed bin(17,0)          initial dcl 10-13 set ref 451*
MINUS                           000255 constant        fixed bin(17,0)          initial dcl 10-13 set ref 426*
NE                              000243 constant        fixed bin(17,0)          initial dcl 10-13 set ref 546*
NOT                             000246 constant        fixed bin(17,0)          initial dcl 10-13 set ref 549*
NULL                                   constant        fixed bin(17,0)          initial dcl 10-13 ref 196 568
OR                              000245 constant        fixed bin(17,0)          initial dcl 10-13 set ref 556*
PLUS                                   constant        fixed bin(17,0)          initial dcl 10-13 set ref 416*
RB                              000250 constant        fixed bin(17,0)          initial dcl 10-13 set ref 560*
ROW_DES                         000251 constant        fixed bin(17,0)          initial dcl 10-13 set ref 800* 848* 861*
ROW_TAB_PAIR                    000254 constant        fixed bin(17,0)          initial dcl 10-13 set ref 793*
RP                                     constant        fixed bin(17,0)          initial dcl 10-13 set ref 405*
SCAL_FN                         000257 constant        fixed bin(17,0)          initial dcl 10-13 set ref 857*
SELECT                          000247 constant        fixed bin(17,0)          initial dcl 10-13 set ref 528*
SET_FN                                 constant        fixed bin(17,0)          initial dcl 10-13 set ref 855* 875*
STAR                                   constant        fixed bin(17,0)          initial dcl 10-13 set ref 409*
TAB_NAME                               constant        fixed bin(17,0)          initial dcl 10-13 ref 670
UNION                                  constant        fixed bin(17,0)          initial dcl 10-13 set ref 540*
UNIQUE                          000234 constant        fixed bin(17,0)          initial dcl 10-13 set ref 538*
WHERE                           000236 constant        fixed bin(17,0)          initial dcl 10-13 set ref 530*
addr                                                   builtin function         dcl 177 ref 256 264 303 348 639 655 673 714 766 786
                                                                                  791 798 808 819 827 840 842 846 848 853 855 857
                                                                                  859 861 866 871 875 1076
attr                      4            based           structure                array level 2 dcl 12-7
attr_name                 4            based           char(32)                 array level 3 in structure "rslt_info" dcl 12-7
                                                                                  in procedure "linus_lila_get_token" ref 983
attr_name                              parameter       char                     unaligned dcl 958 in procedure "valid_attr" ref 950
                                                                                  983
cd                                     parameter       fixed bin(35,0)          dcl 1089 ref 1084 1091
char                                                   builtin function         dcl 177 ref 971
code                                   parameter       fixed bin(35,0)          dcl 120 set ref 20 573* 1091*
collate                                                builtin function         dcl 177 ref 204
cur_pos                  13            based           fixed bin(35,0)          level 2 in structure "ls_header" dcl 4-3
                                                                                  in procedure "linus_lila_get_token" set ref 1092*
cur_pos                         000116 automatic       fixed bin(35,0)          dcl 120 in procedure "linus_lila_get_token" set ref
                                                                                  203* 204 256 263* 263 264 265 267 275 281 287 297
                                                                                  303 305* 305 307 310* 310 311 313 314* 314 316 316
                                                                                  324 324 326* 326 329 338 340 342 344 348 349* 349
                                                                                  351 356* 356 357 359 361* 361 363 363 369* 369 375
                                                                                  376* 376 380 383 384 385 387 387 392 394 448 458
                                                                                  493 525 526 528 530 532 534 536 538 540 546 575
                                                                                  575 575 575 575 575 579* 639 640 655 658 673 676
                                                                                  689 691 714 716 717 719 719 723 724 726 727 729
                                                                                  729 732 732 732 735 735 742 761 762 766 769 779
                                                                                  785 786 788 791 797 798 798 808 814 816 819 822
                                                                                  827 832* 832 840 842 846 848 853 855 857 859 861
                                                                                  866 871 875 1076 1080 1092
cur_ptr                   6            based           pointer                  level 2 dcl 4-3 ref 783
db_index                               based           fixed bin(35,0)          level 2 dcl 1-53 set ref 901* 925* 1052*
debug_switch                    000010 internal static bit(1)                   initial unaligned dcl 144 set ref 574 612* 625*
dflt_ritem                             based           fixed bin(17,0)          level 2 dcl 2-3 ref 965 1078 1079
dsl_$get_fn_info                000076 constant        entry                    external dcl 181 ref 1052
dsl_$get_rslt_info              000100 constant        entry                    external dcl 183 ref 901
dsl_$get_temp_info              000102 constant        entry                    external dcl 185 ref 925
f_choice                               based           char                     unaligned dcl 755 set ref 786* 798* 808 840* 846*
                                                                                  848* 853* 855* 857* 871* 875*
first_dp                        000131 automatic       fixed bin(17,0)          dcl 190 set ref 392* 394 394
first_op                        000130 automatic       fixed bin(17,0)          dcl 189 set ref 385* 387 387 387 387
flag                            000165 automatic       bit(1)                   unaligned dcl 687 set ref 694* 696* 698* 700* 701
fn_name                                parameter       char                     unaligned dcl 1025 in procedure "valid_set_fn" ref
                                                                                  1020 1030 1035
fn_name                                parameter       char                     unaligned dcl 1047 in procedure "valid_scal_fn" set
                                                                                  ref 1042 1052*
found                           000124 automatic       bit(1)                   unaligned dcl 131 set ref 304* 308 311* 320* 322
                                                                                  350* 353 368* 373
from_token               12(01)        based           bit(1)                   level 2 packed unaligned dcl 4-3 ref 839
fwd_ptr                                based           pointer                  level 2 dcl 7-16 ref 1030 1034
i                               000221 automatic       fixed bin(35,0)          dcl 886 in procedure "valid_rel" set ref 919* 919*
                                                                                  922 925*
i                               000164 automatic       fixed bin(17,0)          dcl 686 in procedure "is_const" set ref 691* 691*
                                                                                  694 696
i                               000245 automatic       fixed bin(17,0)          dcl 960 in procedure "valid_attr" set ref 983* 983*
                                                                                  986
i                               000204 automatic       fixed bin(17,0)          dcl 753 in procedure "ident_proc" set ref 761* 762
                                                                                  762* 764* 764 765 768 769 775* 779 785 786 786 788
                                                                                  791 793 797 798 798 798 800* 808 814 816 819 822
                                                                                  827 832 840 840 840* 846 846 846* 848 848 848* 853
                                                                                  853 853* 855 855 855* 857 857 857* 871 871 871*
                                                                                  875 875 875*
i                                      parameter       fixed bin(17,0)          dcl 1003 in procedure "valid_var" set ref 996 1009*
                                                                                  1009* 1012
i                               000174 automatic       fixed bin(17,0)          dcl 710 in procedure "arith_const" set ref 716* 717
                                                                                  717* 719 719 719* 719 726* 727 729 729 732 732 735
                                                                                  735 740 742
i                               000117 automatic       fixed bin(35,0)          dcl 120 in procedure "linus_lila_get_token" set ref
                                                                                  200* 202 203 265* 267 267* 269 281* 283 286 307*
                                                                                  308 309 310 316* 318* 338* 340 340 342 344 347 349
                                                                                  351* 353 354 356 363* 365* 369 370 383* 384 385
                                                                                  387 392 394 525* 526 528 530 532 534 536 538 540
icode                           000120 automatic       fixed bin(35,0)          dcl 120 set ref 901* 906 925* 931 963* 1052* 1057
index                                                  builtin function         dcl 177 ref 204 281 307 316 351 363 392 723 726 769
                                                                                  779 822
initial_mrds_vclock             000122 automatic       float bin(63)            dcl 129 set ref 899* 904 923* 928 1050* 1055
ioa_                            000104 constant        entry                    external dcl 187 ref 575 579 582 590 592 593 595
ioa_$nnl                        000106 constant        entry                    external dcl 188 ref 584 585 587 588
ip_character_string                    based           char                     unaligned dcl 758 set ref 791* 819* 827*
ip_character_string_length      000211 automatic       fixed bin(17,0)          dcl 757 set ref 790* 791 791 818* 819 819 826* 827
                                                                                  827
j                               000205 automatic       fixed bin(17,0)          dcl 753 in procedure "ident_proc" set ref 760* 769*
                                                                                  770 772 775 776* 779* 780 780* 780 788* 790 793
                                                                                  814* 816 816* 818 822 830* 833 842 842 842* 859
                                                                                  859 859* 861 861 861* 866 866 866*
j                               000121 automatic       fixed bin(35,0)          dcl 120 in procedure "linus_lila_get_token" set ref
                                                                                  275* 275* 280 287* 287* 291 342* 344 347 349
j                               000175 automatic       fixed bin(17,0)          dcl 711 in procedure "arith_const" set ref 723* 724
                                                                                  724 727 727 729
j                               000222 automatic       fixed bin(35,0)          dcl 886 in procedure "valid_rel" set ref 891* 891*
                                                                                  894
j                               000246 automatic       fixed bin(17,0)          dcl 960 in procedure "valid_attr" set ref 972* 972*
                                                                                  977* 977* 981 982
k                               000206 automatic       fixed bin(17,0)          dcl 753 set ref 808* 808* 811 813 822* 824 826 830
key                                    parameter       fixed bin(17,0)          dcl 649 in procedure "set_id_token" ref 644 652
key                                    parameter       fixed bin(17,0)          dcl 633 in procedure "set_token" ref 628 635
key                                    based           fixed bin(17,0)          level 2 in structure "token_data" packed unaligned
                                                                                  dcl 10-3 in procedure "linus_lila_get_token" set
                                                                                  ref 196* 260* 300* 336* 346* 401 568* 582* 635*
                                                                                  652* 670* 713* 1075*
lcb                                    based           structure                level 1 dcl 1-53
lcb_ptr                                parameter       pointer                  dcl 1-121 ref 20 192 193 196 200 265 267 270 272 275
                                                                                  281 287 307 311 316 316 324 338 342 351 357 363
                                                                                  363 383 385 387 387 392 394 493 525 526 528 530
                                                                                  532 534 536 538 540 569 575 575 716 717 723 724
                                                                                  726 727 729 729 732 732 735 735 761 762 769 779
                                                                                  788 814 816 822 899 901 901 904 904 904 923 925
                                                                                  925 928 928 928 1030 1050 1052 1052 1055 1055 1055
length                                                 builtin function         dcl 177 in procedure "linus_lila_get_token" ref 526
                                                                                  526 528 528 530 530 532 532 534 534 536 536 538
                                                                                  538 540 540 890
length                                 parameter       fixed bin(17,0)          dcl 649 in procedure "set_id_token" ref 644 653 658
length                                 parameter       fixed bin(17,0)          dcl 633 in procedure "set_token" ref 628 636 640
length                                 parameter       fixed bin(17,0)          dcl 667 in procedure "set_tab_name" ref 662 671 676
length                                 parameter       fixed bin(17,0)          dcl 1072 in procedure "set_col_spec" ref 1067 1077
                                                                                  1080
length                   23            based           fixed bin(35,0)          level 2 in structure "token_data" dcl 10-3
                                                                                  in procedure "linus_lila_get_token" set ref 207*
                                                                                  269* 275 281 286* 287 294 297 306* 309* 309 315*
                                                                                  315 327* 327 347* 354* 354 362* 362 370* 370 377*
                                                                                  377 593* 636* 653* 671* 740* 765* 1077*
lila_area_ptr            62            based           pointer                  level 2 dcl 1-53 set ref 901* 925* 1052*
lila_chars                3            based           fixed bin(35,0)          level 2 dcl 1-53 ref 196 200 265 267 275 281 287 307
                                                                                  311 316 316 324 338 342 351 357 363 363 383 385
                                                                                  387 387 392 394 493 525 526 528 530 532 534 536
                                                                                  538 540 569 575 575 716 717 723 724 726 727 729
                                                                                  729 732 732 735 735 761 762 769 779 788 814 816
                                                                                  822
linus_data_$max_pred_stack_size 000012 external static fixed bin(35,0)          dcl 147 ref 965 1078 1079
linus_data_$max_range_items     000014 external static fixed bin(35,0)          dcl 147 ref 896 916 965 1078 1079
linus_error_$dup_row_des        000016 external static fixed bin(35,0)          dcl 147 set ref 786*
linus_error_$inv_string_const   000020 external static fixed bin(35,0)          dcl 147 set ref 322* 357* 373*
linus_error_$invalid_token      000022 external static fixed bin(35,0)          dcl 147 set ref 258*
linus_error_$linus_var_not_defined
                                000024 external static fixed bin(35,0)          dcl 147 set ref 270* 273* 283* 291*
linus_error_$long_id            000026 external static fixed bin(35,0)          dcl 147 set ref 770* 772*
linus_error_$long_lv_name       000030 external static fixed bin(35,0)          dcl 147 set ref 294*
linus_error_$unbal_parens       000032 external static fixed bin(35,0)          dcl 147 set ref 727*
linus_error_$undef_col          000034 external static fixed bin(35,0)          dcl 147 set ref 824* 827*
linus_error_$undef_id           000036 external static fixed bin(35,0)          dcl 147 set ref 868* 873* 877*
linus_error_$undef_row_des      000040 external static fixed bin(35,0)          dcl 147 set ref 806* 811*
linus_error_$undef_tab          000042 external static fixed bin(35,0)          dcl 147 set ref 791* 844*
linus_lila_tokens_$differ       000056 external static varying char(32)         dcl 167 ref 532 532 532
linus_lila_tokens_$dup          000060 external static varying char(32)         dcl 167 ref 534 534 534
linus_lila_tokens_$first_chars  000054 external static varying char(32)         dcl 167 ref 493
linus_lila_tokens_$from         000062 external static varying char(32)         dcl 167 ref 526 526 526
linus_lila_tokens_$inter        000064 external static varying char(32)         dcl 167 ref 536 536 536
linus_lila_tokens_$select       000066 external static varying char(32)         dcl 167 ref 528 528 528
linus_lila_tokens_$union        000070 external static varying char(32)         dcl 167 ref 540 540 540
linus_lila_tokens_$unique       000072 external static varying char(32)         dcl 167 ref 538 538 538
linus_lila_tokens_$where        000074 external static varying char(32)         dcl 167 ref 530 530 530
linus_rel_array                        based           structure                level 1 unaligned dcl 6-10
linus_rel_array_ptr             000102 automatic       pointer                  dcl 6-16 set ref 193* 891 891 894 896 908 908 909
                                                                                  909 911 911 916 932 932 934 934 936 936 972 972
                                                                                  977 977 981 982
linus_set_fn_info                      based           structure                level 1 dcl 7-16
linus_set_fn_info_ptr           000106 automatic       pointer                  dcl 7-35 set ref 1030* 1030 1030* 1034 1035
ls_block                               based           structure                level 1 dcl 2-3
ls_header                              based           structure                level 1 dcl 4-3
lsb_ptr                         000100 automatic       pointer                  dcl 2-32 set ref 783* 784 796 800 800 808 808 833
                                                                                  833 848 848 861 861 965 969 971 972 1007 1007 1009
                                                                                  1009 1078 1078 1079 1079
lsh_ptr                                parameter       pointer                  dcl 4-15 ref 20 200 204 256 264 265 275 281 287 303
                                                                                  307 313 316 324 338 340 342 344 348 351 359 363
                                                                                  375 383 384 385 387 387 392 394 448 458 493 525
                                                                                  526 528 530 532 534 536 538 540 546 575 575 639
                                                                                  655 673 689 691 696 714 716 719 719 723 724 726
                                                                                  727 729 729 732 732 732 735 735 761 766 769 779
                                                                                  783 785 786 788 791 797 798 798 808 814 819 822
                                                                                  827 839 840 842 846 848 853 855 857 859 861 866
                                                                                  871 875 1076 1092
lv_ptr                   32            based           pointer                  level 2 in structure "lcb" dcl 1-53 in procedure
                                                                                  "linus_lila_get_token" ref 270 272
lv_ptr                          000112 automatic       pointer                  dcl 11-14 in procedure "linus_lila_get_token" set
                                                                                  ref 272* 273 275 275 280 287 287 291
lvar                     12            based           varying char(32)         level 2 in structure "token_data" dcl 10-3
                                                                                  in procedure "linus_lila_get_token" set ref 592*
                                                                                  638* 657* 675* 741* 1079*
lvar                                   parameter       varying char(32)         dcl 650 in procedure "set_id_token" ref 644 657
mrds_data_$max_id_len           000044 external static fixed bin(35,0)          dcl 147 ref 294 768 772
mrds_data_$max_select_items     000046 external static fixed bin(35,0)          dcl 147 ref 965 1078 1079
mrds_data_$max_temp_rels        000050 external static fixed bin(35,0)          dcl 147 ref 919 922
mrds_data_$max_token_size       000052 external static fixed bin(35,0)          dcl 147 ref 965 1078 1079
mrds_time                74            based           float bin(63)            level 2 dcl 1-53 set ref 904* 904 928* 928 1055*
                                                                                  1055
mrds_var                 23            based           varying char(32)         array level 3 dcl 2-3 set ref 800* 833* 848* 861*
                                                                                  1078
must_free                 0(18)        based           bit(1)                   level 2 packed unaligned dcl 10-3 set ref 257* 262*
                                                                                  302* 379* 585 637* 654* 672* 715* 767* 1074*
mvar                      1            based           varying char(32)         level 2 in structure "token_data" dcl 10-3
                                                                                  in procedure "linus_lila_get_token" set ref 592*
                                                                                  638* 656* 675* 741* 1078*
mvar                                   parameter       varying char(32)         dcl 650 in procedure "set_id_token" ref 644 656
name                      2            based           char(32)                 level 2 in structure "linus_set_fn_info" dcl 7-16
                                                                                  in procedure "linus_lila_get_token" ref 1030 1035
name                      2            based           char(32)                 array level 3 in structure "variables" dcl 11-3
                                                                                  in procedure "linus_lila_get_token" ref 275 287
nritems                  11            based           fixed bin(17,0)          level 2 dcl 2-3 ref 796 808 1007 1009
null                                                   builtin function         dcl 177 ref 194 270 898 913 918 938 968 989 1030
num_attr                               based           fixed bin(17,0)          level 2 dcl 12-7 ref 983 986
num_of_rels                            based           fixed bin(17,0)          level 2 dcl 6-10 set ref 891 894 896 908* 908 909
                                                                                  911 916 932* 932 934 936 972 977 981
num_of_rels_init                000104 automatic       fixed bin(17,0)          initial dcl 6-18 set ref 6-18*
nvars                     1            based           fixed bin(17,0)          level 2 dcl 11-3 ref 273 275 280 287 291
range_items              12            based           structure                array level 2 dcl 2-3
rel_array_ptr            66            based           pointer                  level 2 dcl 1-53 ref 193
rel_index                45            based           fixed bin(35,0)          array level 3 dcl 2-3 ref 971 972
rel_name                 34            based           varying char(32)         array level 3 in structure "ls_block" dcl 2-3
                                                                                  in procedure "linus_lila_get_token" ref 969
rel_name                  2            based           char(32)                 array level 3 in structure "linus_rel_array" packed
                                                                                  unaligned dcl 6-10 in procedure
                                                                                  "linus_lila_get_token" set ref 891 909* 934* 972
                                                                                  977
rel_name                               parameter       char                     unaligned dcl 884 in procedure "valid_rel" set ref
                                                                                  879 890 891 901* 909 919 934
rels                      2            based           structure                array level 2 unaligned dcl 6-10
result                          000260 automatic       bit(1)                   unaligned dcl 1002 in procedure "valid_var" set ref
                                                                                  1005* 1012* 1016
result                          000244 automatic       bit(1)                   unaligned dcl 959 in procedure "valid_attr" set ref
                                                                                  962* 986* 992
result                          000220 automatic       bit(1)                   unaligned dcl 885 in procedure "valid_rel" set ref
                                                                                  888* 894* 896 907* 916 939* 946
result                          000270 automatic       bit(1)                   unaligned dcl 1026 in procedure "valid_set_fn" set
                                                                                  ref 1028* 1035* 1038
result                          000300 automatic       bit(1)                   unaligned dcl 1048 in procedure "valid_scal_fn" set
                                                                                  ref 1057* 1059* 1061
rname                           000234 automatic       char(32)                 unaligned dcl 957 set ref 969* 970 971* 977
rslt_info                              based           structure                level 1 dcl 12-7
rslt_info_ptr            12            based           pointer                  array level 3 dcl 6-10 set ref 911* 936* 982
rslt_ptr                        000114 automatic       pointer                  dcl 12-32 set ref 194* 898* 901* 911 913* 925* 936
                                                                                  938* 968* 982* 983 983 986 989*
s_choice                               based           char                     unaligned dcl 756 set ref 842* 859* 861* 866*
search                                                 builtin function         dcl 177 ref 385 387 387 394 724 727
setfi_ptr                36            based           pointer                  level 2 dcl 1-53 ref 1030
sfi_ptr                         000126 automatic       pointer                  dcl 145 set ref 1052*
source_array                           based           char(1)                  array unaligned dcl 8-4 set ref 204 256 264 303 313
                                                                                  324 340 344 348 359 375 384 448 458 546 639 655
                                                                                  673 689 691 696 714 719 719 732 766 785 786 791
                                                                                  797 798 798 808 819 827 840 842 846 848 853 855
                                                                                  857 859 861 866 871 875 1076
source_str                             based           char                     unaligned dcl 8-3 set ref 200 265 275 281 287 307
                                                                                  316 338 342 351 363 383 385 387 387 392 394 493
                                                                                  525 526 528 530 532 534 536 538 540 575 575 716
                                                                                  723 724 726 727 729* 729 732* 732 735* 735 761 769
                                                                                  779 788 814 822
src_ptr                  10            based           pointer                  level 2 dcl 4-3 ref 200 204 256 264 265 275 281 287
                                                                                  303 307 313 316 324 338 340 342 344 348 351 359
                                                                                  363 375 383 384 385 387 387 392 394 448 458 493
                                                                                  525 526 528 530 532 534 536 538 540 546 575 575
                                                                                  639 655 673 689 691 696 714 716 719 719 723 724
                                                                                  726 727 729 729 732 732 732 735 735 761 766 769
                                                                                  779 785 786 788 791 797 798 798 808 814 819 822
                                                                                  827 840 842 846 848 853 855 857 859 861 866 871
                                                                                  875 1076
start_pos                              parameter       fixed bin(35,0)          dcl 120 set ref 20 196 200 203 297* 329* 380* 569*
                                                                                  575 575 575 579* 640* 658* 676* 742* 804* 804
                                                                                  1080*
substr                                                 builtin function         dcl 177 set ref 200 265 275 281 287 307 316 338 342
                                                                                  351 363 383 385 387 387 392 394 493 525 526 528
                                                                                  530 532 534 536 538 540 575 575 716 723 724 726
                                                                                  727 729* 729 732* 732 735* 735 761 769 779 788 814
                                                                                  822
t_ptr                    24            based           pointer                  level 2 dcl 10-3 set ref 256* 264* 303* 348* 595*
                                                                                  639* 655* 673* 714* 766* 1076*
td_ptr                                 parameter       pointer                  dcl 10-49 ref 20 196 207 256 257 260 262 264 269 275
                                                                                  281 286 287 294 297 300 302 303 306 309 309 315
                                                                                  315 327 327 336 346 347 348 354 354 362 362 370
                                                                                  370 377 377 379 401 568 582 585 588 592 592 593
                                                                                  595 635 636 637 637 638 638 639 652 653 654 654
                                                                                  655 656 657 670 671 672 673 674 675 675 713 714
                                                                                  715 740 741 741 765 766 767 794 1074 1075 1076
                                                                                  1077 1078 1079
temp_flag                              parameter       bit(1)                   unaligned dcl 885 in procedure "valid_rel" set ref
                                                                                  879 888* 939*
temp_flag                              parameter       bit(1)                   unaligned dcl 668 in procedure "set_tab_name" ref
                                                                                  662 674
temp_flag                       000210 automatic       bit(1)                   unaligned dcl 754 in procedure "ident_proc" set ref
                                                                                  791* 794 840* 840* 842* 842* 853* 853* 866* 866*
                                                                                  871* 871*
temp_tab                  0(19)        based           bit(1)                   level 2 packed unaligned dcl 10-3 set ref 588 637*
                                                                                  654* 674* 794*
temp_tab_names                         based           char(32)                 array unaligned dcl 9-3 ref 919 972
timing_mode              15(05)        based           bit(1)                   level 2 packed unaligned dcl 1-53 ref 899 904 923
                                                                                  928 1050 1055
token_data                             based           structure                level 1 dcl 10-3
translate                                              builtin function         dcl 177 ref 735
ttn_ptr                         000110 automatic       pointer                  dcl 9-5 in procedure "linus_lila_get_token" set ref
                                                                                  192* 918 919 972
ttn_ptr                  26            based           pointer                  level 2 in structure "lcb" dcl 1-53 in procedure
                                                                                  "linus_lila_get_token" ref 192
tup_var                  12            based           varying char(32)         array level 3 dcl 2-3 set ref 800* 808 833* 848*
                                                                                  861* 1009 1079
tv_index                               parameter       fixed bin(17,0)          dcl 960 set ref 950 965 965* 967 969 971 972
type                                   based           fixed bin(17,0)          level 2 dcl 2-3 ref 784 1007
var_info                  2            based           structure                array level 2 dcl 11-3
var_name                               parameter       char                     unaligned dcl 1001 ref 996 1009
variables                              based           structure                level 1 dcl 11-3
vclock                                                 builtin function         dcl 177 ref 899 904 923 928 1050 1055
verify                                                 builtin function         dcl 177 ref 200 265 338 342 383 493 525 689 691 696
                                                                                  716 761 788 814
vindex                          000207 automatic       fixed bin(17,0)          dcl 753 set ref 786* 798* 800 800 813* 819* 827* 833
                                                                                  833 848* 848 848 861* 861 861

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
fixed                                                  builtin function         dcl 177
initial_number_of_set_fn_info_args     automatic       fixed bin(17,0)          dcl 7-36
nvars_init                             automatic       fixed bin(17,0)          dcl 11-15
rel                                                    builtin function         dcl 177
rslt_alloc                             automatic       fixed bin(17,0)          dcl 12-34
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 147

NAMES DECLARED BY EXPLICIT CONTEXT.
arith_const                     003304 constant        entry                    internal dcl 704 ref 394 413 423 429
char_proc                       000000 constant        label                    array(128) dcl 207 ref 204
db_off                          003001 constant        entry                    external dcl 615
db_on                           002766 constant        entry                    external dcl 602
error                           006510 constant        entry                    internal dcl 1084 ref 258 270 273 283 291 294 322
                                                                                  357 373 727 770 772 786 791 806 811 824 827 844
                                                                                  868 873 877
exit                            002430 constant        label                    dcl 564 ref 298 330 334 403 407 411 417 421 427 442
                                                                                  446 452 456 462 491 522 544 550 554 558 562
ident_proc                      003576 constant        entry                    internal dcl 746 ref 464 521 542
is_const                        003176 constant        entry                    internal dcl 680 ref 413 423
linus_lila_get_token            000446 constant        entry                    external dcl 20
real_exit                       002763 constant        label                    dcl 598 ref 1093
set_col_spec                    006414 constant        entry                    internal dcl 1067 ref 846 859
set_id_token                    003051 constant        entry                    internal dcl 644 ref 800 833 848 861
set_tab_name                    003132 constant        entry                    internal dcl 662 ref 840 842 853 866 871
set_token                       003012 constant        entry                    internal dcl 628 ref 332 401 405 409 416 419 426 444
                                                                                  448 451 454 458 461 526 528 530 532 534 536 538
                                                                                  540 546 549 552 556 560 793 855 857 875
valid_attr                      005736 constant        entry                    internal dcl 950 ref 819 827 846 859
valid_rel                       005401 constant        entry                    internal dcl 879 ref 791 840 842 853 866 871
valid_scal_fn                   006310 constant        entry                    internal dcl 1042 ref 857
valid_set_fn                    006232 constant        entry                    internal dcl 1020 ref 855 875
valid_var                       006154 constant        entry                    internal dcl 996 ref 786 798 848 861

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11624       11734   11242       11634
Length     12502   11242       110         532     361           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
linus_lila_get_token                345 external procedure  is an external procedure.  
set_token                               internal procedure  shares stack frame of external procedure linus_lila_get_token.  
set_id_token                            internal procedure  shares stack frame of external procedure linus_lila_get_token.  
set_tab_name                            internal procedure  shares stack frame of external procedure linus_lila_get_token.  
is_const                                internal procedure  shares stack frame of external procedure linus_lila_get_token.  
arith_const                             internal procedure  shares stack frame of external procedure linus_lila_get_token.  
ident_proc                              internal procedure  shares stack frame of external procedure linus_lila_get_token.  
valid_rel                               internal procedure  shares stack frame of external procedure linus_lila_get_token.  
valid_attr                              internal procedure  shares stack frame of external procedure linus_lila_get_token.  
valid_var                               internal procedure  shares stack frame of external procedure linus_lila_get_token.  
valid_set_fn                            internal procedure  shares stack frame of external procedure linus_lila_get_token.  
valid_scal_fn                           internal procedure  shares stack frame of external procedure linus_lila_get_token.  
set_col_spec                            internal procedure  shares stack frame of external procedure linus_lila_get_token.  
error                                   internal procedure  shares stack frame of external procedure linus_lila_get_token.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 debug_switch                linus_lila_get_token

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
linus_lila_get_token     000100 lsb_ptr                     linus_lila_get_token
                         000102 linus_rel_array_ptr         linus_lila_get_token
                         000104 num_of_rels_init            linus_lila_get_token
                         000106 linus_set_fn_info_ptr       linus_lila_get_token
                         000110 ttn_ptr                     linus_lila_get_token
                         000112 lv_ptr                      linus_lila_get_token
                         000114 rslt_ptr                    linus_lila_get_token
                         000116 cur_pos                     linus_lila_get_token
                         000117 i                           linus_lila_get_token
                         000120 icode                       linus_lila_get_token
                         000121 j                           linus_lila_get_token
                         000122 initial_mrds_vclock         linus_lila_get_token
                         000124 found                       linus_lila_get_token
                         000126 sfi_ptr                     linus_lila_get_token
                         000130 first_op                    linus_lila_get_token
                         000131 first_dp                    linus_lila_get_token
                         000164 i                           is_const
                         000165 flag                        is_const
                         000174 i                           arith_const
                         000175 j                           arith_const
                         000204 i                           ident_proc
                         000205 j                           ident_proc
                         000206 k                           ident_proc
                         000207 vindex                      ident_proc
                         000210 temp_flag                   ident_proc
                         000211 ip_character_string_length  ident_proc
                         000220 result                      valid_rel
                         000221 i                           valid_rel
                         000222 j                           valid_rel
                         000234 rname                       valid_attr
                         000244 result                      valid_attr
                         000245 i                           valid_attr
                         000246 j                           valid_attr
                         000260 result                      valid_var
                         000270 result                      valid_set_fn
                         000300 result                      valid_scal_fn

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        return              shorten_stack       ext_entry
verify_eis          vclock

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
dsl_$get_fn_info              dsl_$get_rslt_info            dsl_$get_temp_info            ioa_
ioa_$nnl

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
linus_data_$max_pred_stack_size                             linus_data_$max_range_items   linus_error_$dup_row_des
linus_error_$inv_string_const linus_error_$invalid_token    linus_error_$linus_var_not_defined
linus_error_$long_id          linus_error_$long_lv_name     linus_error_$unbal_parens     linus_error_$undef_col
linus_error_$undef_id         linus_error_$undef_row_des    linus_error_$undef_tab        linus_lila_tokens_$differ
linus_lila_tokens_$dup        linus_lila_tokens_$first_chars                              linus_lila_tokens_$from
linus_lila_tokens_$inter      linus_lila_tokens_$select     linus_lila_tokens_$union      linus_lila_tokens_$unique
linus_lila_tokens_$where      mrds_data_$max_id_len         mrds_data_$max_select_items   mrds_data_$max_temp_rels
mrds_data_$max_token_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 6   18 000436        20 000441       192 000454       193 000461       194 000463       196 000465       200 000475
    202 000524       203 000525       204 000534       207 000545       256 000551       257 000556       258 000562
    260 000571       262 000576       263 000600       264 000604       265 000614       267 000645       269 000655
    270 000666       272 000701       273 000706       275 000717       279 000746       280 000753       281 000757
    283 001000       286 001010       287 001021       290 001050       291 001055       294 001070       297 001105
    298 001114       300 001115       302 001121       303 001123       304 001131       305 001132       306 001136
    307 001143       308 001175       309 001204       310 001213       311 001217       313 001226       314 001235
    315 001241       316 001245       318 001274       319 001275       320 001276       321 001300       322 001301
    324 001312       326 001327       327 001333       329 001341       330 001343       332 001344       334 001350
    336 001351       338 001355       340 001375       342 001406       344 001435       346 001442       347 001445
    348 001453       349 001460       350 001464       351 001465       353 001517       354 001526       356 001535
    357 001541       359 001554       361 001565       362 001571       363 001577       365 001630       366 001631
    368 001632       369 001634       370 001640       372 001646       373 001647       375 001660       376 001671
    377 001675       379 001703       380 001706       383 001710       384 001734       385 001742       387 001756
    392 002013       394 002025       401 002046       403 002060       405 002061       407 002065       409 002066
    411 002072       413 002073       416 002103       417 002107       419 002110       421 002114       423 002115
    426 002125       427 002131       429 002132       442 002133       444 002134       446 002140       448 002141
    451 002153       452 002157       454 002160       456 002164       458 002165       461 002177       462 002203
    464 002204       491 002205       493 002206       521 002222       522 002223       525 002224       526 002240
    528 002253       530 002266       532 002301       534 002314       536 002327       538 002342       540 002355
    542 002370       544 002371       546 002372       549 002404       550 002410       552 002411       554 002415
    556 002416       558 002422       560 002423       562 002427       568 002430       569 002434       573 002440
    574 002442       575 002445       579 002511       582 002534       584 002557       585 002575       587 002615
    588 002632       590 002652       592 002665       593 002713       595 002737       598 002763       600 002764
    602 002765       612 002774       613 002777       615 003000       625 003007       626 003011       628 003012
    635 003014       636 003022       637 003025       638 003031       639 003033       640 003043       642 003050
    644 003051       652 003053       653 003061       654 003064       655 003070       656 003100       657 003114
    658 003123       660 003131       662 003132       670 003134       671 003141       672 003144       673 003146
    674 003156       675 003166       676 003170       678 003175       680 003176       689 003200       691 003215
    693 003243       694 003246       696 003254       698 003273       699 003274       700 003275       701 003276
    704 003304       713 003305       714 003312       715 003323       716 003326       717 003350       719 003361
    723 003374       724 003417       726 003436       727 003450       729 003477       732 003516       735 003543
    738 003561       740 003562       741 003567       742 003571       744 003575       746 003576       760 003577
    761 003600       762 003632       764 003643       765 003645       766 003651       767 003656       768 003661
    769 003664       770 003702       772 003711       775 003724       776 003726       778 003727       779 003730
    780 003746       783 003752       784 003757       785 003762       786 003774       788 004034       790 004071
    791 004073       793 004131       794 004136       795 004145       796 004146       797 004150       798 004152
    800 004210       804 004227       805 004234       806 004235       808 004245       810 004267       811 004272
    813 004304       814 004306       816 004343       818 004355       819 004357       822 004407       824 004432
    826 004442       827 004445       830 004507       832 004511       833 004516       838 004541       839 004542
    840 004545       842 004600       844 004637       845 004646       846 004647       848 004704       853 004761
    855 005020       857 005054       859 005110       861 005151       866 005226       868 005265       869 005274
    871 005275       873 005330       874 005337       875 005340       877 005371      1065 005400       879 005401
    888 005412       890 005420       891 005422       893 005443       894 005450       896 005455       898 005463
    899 005465       901 005477       904 005530       906 005544       907 005546       908 005550       909 005551
    911 005563       913 005565       916 005567       918 005575       919 005601       921 005623       922 005630
    923 005634       925 005646       928 005665       931 005701       932 005703       934 005704       936 005716
    938 005720       939 005722       946 005730       950 005736       962 005747       963 005750       965 005751
    967 005774       968 005776       969 006000       970 006010       971 006015       972 006031       975 006061
    976 006063       977 006064       980 006102       981 006104       982 006107       983 006113       985 006135
    986 006137       989 006144       992 006146       996 006154      1005 006165      1007 006166      1009 006174
   1011 006214      1012 006217      1016 006224      1020 006232      1028 006243      1030 006244      1034 006266
   1035 006271      1038 006303      1042 006310      1050 006321      1052 006333      1055 006364      1057 006400
   1059 006405      1061 006406      1067 006414      1074 006416      1075 006422      1076 006425      1077 006436
   1078 006443      1079 006472      1080 006501      1082 006507      1084 006510      1091 006512      1092 006515
   1093 006521


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
