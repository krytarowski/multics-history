THIS FILE IS DAMAGED

	COMPILATION LISTING OF SEGMENT ext_parse
	Compiled by: Multics PL/I Compiler, Release 33c, of October 25, 1990
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 91-12-11_2227.17_Wed_mst
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1987 *
        8*        *                                                         *
        9*        * Copyright, (C) Honeywell Limited, 1983                  *
       10*        *                                                         *
       11*        * Copyright (c) 1972 by Massachusetts Institute of        *
       12*        * Technology and Honeywell Information Systems, Inc.      *
       13*        *                                                         *
       14*        *********************************************************** */
       15 
       16 
       17 
       18 /****^  HISTORY COMMENTS:
       19*  1) change(86-07-14,BWong), approve(86-07-14,MCR7286), audit(86-07-17,Ginter),
       20*     install(86-07-28,MR12.0-1105):
       21*     Fix fortran bugs 457, 458, 461, and 463.
       22*  2) change(86-07-14,BWong), approve(86-07-14,MCR7382), audit(86-07-17,Ginter),
       23*     install(86-07-28,MR12.0-1105):
       24*     Fix fortran bugs 122, 389, 396, 428, 470, 473, 481, and 482.
       25*  3) change(86-07-14,BWong), approve(86-07-14,MCR7442), audit(86-07-17,Ginter),
       26*     install(86-07-28,MR12.0-1105):
       27*     Fix fortran bugs 410, 497, and 498.
       28*  4) change(87-04-15,Huen), approve(87-04-15,MCR7651), audit(87-04-15,RWaters),
       29*     install(87-05-08,MR12.1-1031):
       30*     Fix fortran bugs 479 and 431.
       31*  5) change(87-06-23,RWaters), approve(87-06-23,MCR7703), audit(87-07-10,Huen),
       32*     install(87-08-06,MR12.1-1069):
       33*     Implemented SCP 6315: Added a fortran runtime error-handler argument.
       34*  6) change(88-02-29,Huen), approve(88-02-29,MCR7846), audit(88-03-07,RWaters),
       35*     install(88-03-15,MR12.2-1036):
       36*     Fix bug 506: Do not always assign bp -> header.units to char_units
       37*     whenever the first element of  the common block is of character type.
       38*  7) change(88-04-28,RWaters), approve(88-04-28,MCR7875), audit(88-07-13,Huen),
       39*     install(88-11-10,MR12.2-1209):
       40*     Implement SCP 6339:  Allow  character variables to be up to 128K-1
       41*     (131071) character long.
       42*  8) change(89-06-14,RWaters), approve(89-06-14,MCR8115),
       43*     audit(89-07-21,Blackmore), install(89-07-31,MR12.3-1065):
       44*     Fix bug 511; error in format statements > 512 chars long.
       45*  9) change(91-11-06,Huen), approve(91-11-06,MCR8246), audit(91-11-25,Vu),
       46*     install(91-12-11,MR12.5-1004):
       47*     Fix Fortran compiler (ft_514) to be able to consistently diagnose errors
       48*     when the VLA size is greater than the maximum value.  The maximum value is
       49*     (2**24 - 1) words long.
       50*                                                   END HISTORY COMMENTS */
       51 
       52 
       53 /* format: style3,^indattr,linecom,ifthendo,ifthen,^indnoniterdo,^elsestmt,dclind9 */
       54 ext_parse:
       55      procedure (p, q);
       56 
       57 /* Created:	June 1976, David Levin
       58*
       59*   Modified:
       60*          15 May 87, RW SCP 6315 added the -debug_io argument, set
       61*                    io_bits.debug according to subr_options.debug_io;
       62*          23 Feb 87, SH & RW - 431: Allow substrings in equivalence
       63*                    statements in ansi77 mode.
       64*          02 Jan 87, SH - 479: Whenever a left parenthesis prior to
       65*                    an input list item in a set context, display 
       66*                    additional information "A redundant parenthesis
       67*                    was encountered." after the error message 95.
       68*          21 Mar 86, NS - 498: Put in check for invalid unit numbers.
       69*          18 Mar 86, NS - 497: Check for the typeless function fld.
       70*          08 Mar 86, SH - 410: Allow builtin functions to be declared 
       71*                    in external statements in ansi66 mode. Update the
       72*                    bif_table.external table and delete the intrinsic
       73*                    include file.
       74*	28 Feb 86, BW - 428.a: Make minor declaration changes:
       75*		o default_char_size only needs to be increased from
       76*		  fixed bin (9) to fixed bin (10)
       77*		o token can be left as bit (9) aligned
       78*		o token_list structure is padded to make it word aligned
       79*		o temp_str only needs to be increased from char (256)
       80*		  to char (512).
       81*	27 Feb 86, BW - 461.a: Fix error introduced with the character
       82*		equivalencing.  Block lengths were calculated larger then
       83*		they should be causing unnecessarily large text sections.
       84*	19 Feb 86, BW & AG - 473.a: Fix allowing individual storage classes 
       85*		(automatic, static, parameter, or common) to be addressed
       86*		as VLA's or LA's.  Move code to set maximum array sizes
       87*		from fort_defaults_$check_global_args to the new routine
       88*		set_max_array_size so the values are set properly.
       89*          12 Dec 85, NS, MM, & BW - 482: Change the default in precision of 
       90*                    an unsupported REAL type from single to double precision.
       91*          12 Dec 85, NS, MM, & BW - 481: Warn user of a change in the 
       92*		precision of a real variable from that in which it was
       93*     		declared.
       94*          11 Dec 85, NS - 389: Warn user of a complex type declaration of
       95*                    precision other than single precision.
       96*          05 Dec 85, RW - 396: Stop compiler from changing automatics into
       97*		named constants if they are in equivalence statements.
       98*          29 Nov 85, RW - 428: Allow strings up to 512 (up from 256)
       99*          25 Nov 85, RW - 122: Changed max number of items in a format 
      100*                    statement to 1023 (up from 510)
      101*	09 Oct 85, BW - 473: Allow individual storage classes (automatic,
      102*		static, parameter, or common) to be addressed as
      103*		VLA's or LA's.
      104*	26 Sept 85, BW - 470: Use only the significant digits of real and
      105*		double precision constants when converting from
      106*		character to floating point representation.
      107*	02 Aug 85, BW - 463: Removed code to set must_save_stack_extent.
      108*		The saving will no longer be done because of fortran_io_
      109*		problems.
      110*	16 Jul 85, MM & BW - 461: Allow character variables and
      111*		non-character variables to be equivalenced in ansi77.
      112*          12 Jun 85, BW - 458: Suppress generation of error messages for
      113*                    compiler generated symbols.
      114*          12 Jun 85, BW - 457: Correct cross referencing of format statements
      115*                    which are declared before they are referenced.
      116*	22 Mar 85, MM - 433: Correct the polish for the bypass label that
      117*		is emitted around entry statements.  The label itself must
      118*		fall on the end of the last entry statement - not on the
      119*		following statement.
      120*          12 Aug 84, BW - 435: Generate correct polish for entry points
      121*                    followed by non-executable statements only.
      122*          03 Aug 84, BW - 434: Allow option names of up to 32 characters.
      123*	22 Jun 84, MM - Install typeless functions support.
      124*	25 Apr 84, HH - 424: Argument type & shape specification disallowed
      125*		after 1st executable statement.
      126*	13 Apr 84, MM - 419: Generate correct polish for routines that do
      127*		not contain executable statements.  
      128*	12 Apr 84, BW - 418: Correct lexer error which occurred when a
      129*		Hollerith string was followed by a labelled statement.
      130*	28 Mar 84, MM - Install HFP support.
      131*	05 Dec 83, HH - 412: Prevent possible endless loop when checking
      132*		for branches into do-loops in '77 mode.
      133*	16 Sep 83, RG & MM - 242/370: Pass ptr (symbol.general) to arg_desc in entry node.
      134*	14 Aug 83, HH - 387: Allow substrings as targets in DATA statements.
      135*	14 Aug 83, HH - 386: Generalize expressions in DATA statements to
      136*		comply with the '77 Standard.
      137*	12 Jul 83, MM - 379: Give more consistancy to compilation options.
      138*	 4 Jul 83, RG - 385: To allow conversions to integer in DATA statements
      139*	19 Jun 83, HH - 145: Disallowing branching into do-loops in '77 mode.
      140*	17 Jun 83, HH - 383: Make adjustable arrays conform to the Standard
      141*		in '77 mode.
      142*	10 May 83, MM - 375: Allow common variables to be initilized to 0.
      143*	10 May 83, RG - 174: Allow include files to be archive components.
      144*	10 Feb 83, HH - Install LA/VLA support.
      145*	21 Oct 82, TO - 360: Add default 'UNIT=' to INQUIRE.
      146*	21 Oct 82, TO - 362: Add parsing for 'CHARACTER*(*) FUNCTION f ('.
      147*	14 May 82, TO  - Modify extraneous text error for parenthesis test.
      148*	 5 May 82, TO  - Save stack extent if char_star_function is only one.
      149*	22 Mar 82, TO  - Fix navy test bug 1, label with code on continuation lines only.
      150*	22 Mar 82, TO  - Fix navy test bug 2, lack of comma in assigned goto.
      151*	18 Mar 82, TO  - Fix bug 296 - implied IO do loop gets errors on left_parn of expression.
      152*	17 Mar 82, TO  - Fix bug 326 - assign lex doesn't know about logical if with substr assign target.
      153*     	16 Mar 82, TO  - Fix bug 269 - incorrect line number reporting.
      154*	12 Mar 82, TO  - Fix bug 320 - failure to detect duplicate entries.
      155*	17 Dec 81, MEP - Fix bug in doubly subscripted implied do in data statement.
      156*	15 Dec 81, MEP - Fix bugs in label_const parsing (*<int>) and filed length in mode statements.
      157*	14 Dec 81, MEP - Fix unreported bug in parsing of * as unit number.
      158*	4 Dec 81, MEP - Fix bug 257 allow proper equivalencing of ansi66 and ansi77 arrays
      159*	19 Nov 81, MEP - Fix bug 246 too many constants for variable list in data statment
      160*	17 Nov 81, MEP - Fix bug 327 not allow chars and non-chars in fortran 77 equiv groups
      161*	17 Nov 81, MEP - Fix bug 328 on external (descriptors) character functions in ansi_77.
      162*	16 Nov 81, MEP - Fix bug 323 on lacking s permission of include file's directory.
      163*	13 Nov 81, MEP - Fix unreported bug in typed functions
      164*	22 Oct 81, MEP - Added code for INQUIRE statement.  Changed parse_open_field to have parameter
      165*		for expression_type.
      166*	1 Oct 1981, MEP - Fortran 77 internal files
      167*	5 August 1981, MEP - Fixed bug 324, incorrect tally of stack high-water mark
      168*	16 July 1981, MEP - Completion of ASSIGN with format labels
      169*	14 July 1981, MEP - Full ansi77 format specifiers
      170*	30 June 1981, MEP - Allow format statements to be objects of ASSIGN TO
      171*	June 1981, MEP - Finished alteration to REWIND, etc.  Began changes for new 
      172*		READ/WRITE specifications.
      173*	1 June 81, MEP - Alterations to parse_parameter_list, and argument list of statement functions to
      174*		allow functions with no arguments.
      175*	20 May 81, MEP - Alterations in the lex to allow blank lines to be comments in ansi77
      176*	12 May 81, MEP - Added code for INTRINSIC statement.
      177*     	11 May 81, MEP - Added code for .EQV., .NEQV., and SAVE /common-block-name/
      178*	4 May 81, MEP - Added code for new features in rewind, backspace, and  endfile statements.
      179*	3 May 81, MEP - Minor changes per CRD's audit for array and data changes.
      180*	29 Apr 81, MEP - Program statement and named block data subprogs.
      181*	11 Mar 81, MEP - Began the enhancements for ansi77 array declarators
      182*	22 Feb 81, MEP - Fixed bug 307 (blank common not recognized unless first in common statement and bug 305
      183*		(parse fails when identifier continued onto next line and next char is not letter or digit).
      184*	26 January 1981, CRD - Improve interaction of elseif statement with
      185*		profile and breakpoints.
      186*	 5 January 1980, MEP - Added code to handle illegally referenced labels
      187*	31 December 1980, MEP - Added a field in statement_attributes for warnings on labelled statements 
      188*	29 December 1980, MEP - Cleaned up the error handling for improperly nested do's and block if's.
      189*	15 December 1980, MEP - Added code that manipulates the do_blockif_stack, formerly the do_stack for nested do loops
      190*		and the code for the parsing of block if's.
      191*	19 November 1980, CRD - Fix bug in which array_size was computed for
      192*		star extent arrays instead of leaving it to later phases.
      193*	24 October 1980, CRD - Added new intrinsics for Fortran 77.
      194*	8 October 1980, CRD - Fixed bug 283.  Lex was not properly handling
      195*		hollerith constants which need to be blank padded but are
      196*		not continued.
      197*	29 September 1980, CRD - Fixed bug 281.  Changed the lex not to make
      198*		substr_left_parn tokens; and invented the subroutine
      199*		get_next_token$paren_operator which differentiates between
      200*		left_parn and substr_left_parn by scanning the token list.
      201*		parse_expression calls this new subroutine, as it is the 
      202*		only place which needs to differentiate.
      203*	17 September 1980, CRD - Fixed bug 277: %include lex was not
      204*		stripping white space properly.  Also fixed bug 268:
      205*		fold keyword not allowed in %options or %global.
      206*	31 July 80, MEP - Added code to allow evaluation of fortran 77
      207*		parameter statements
      208*	29 July 80, CRD - Fix bug in declaration processing of entry_points.
      209*	16 July 80, MEP - Set symbol.variable_arglist in external statement.
      210*	10 June 80, MEP - Added code to set must_save_stack_extent iff more
      211*		than one subprogram and char star-extent variables seen.
      212*	5 June 80, MEP - Changed parse to properly set needs_descriptors bit
      213*		for all entry points.  This is done if any of the formal parameters
      214*		is star_extents or the function itself is.
      215*	16 May 80, MEP - Added code to set io_bits.ansi_77 so that character array i/o
      216*		is handled correctly in both modes.
      217*	09 May 1980, MEP - Fixed two bugs in character mode.  The first
      218*		bug was that the use of two substered variables in an expression was mishandled.
      219*		The second was that a reference to an unsubscripted substered variable failed to
      220*		correctly set the variable bit in symbol.attribute.
      221*	01 May 1980, MEP - Removed the builtins until such time as the required
      222*		alterations to the back end are implemented.  Also fixed a bug in which subscripted
      223*		substered references are correctly handled.
      224*	04 Apr 1980, MEP - Add the new builtins sinh, cosh, dcosh, dtanh,
      225*		dsinh.  Also fix bug to make tan externable.
      226*	04 Apr 1980, PES - Fix uninitialized subroutine_options bug.
      227*	18 Dec 1979, PES - Change parse to emit (read write)_namelist_op rather than namelist_op
      228*		when optimizing, to fix bug 249, in which the optimizer appears to ignore the 
      229*		fact that a namelist read sets the values in the namelist.  Eliminate all
      230*		references to the obsolete bit symbol.need_word_count.
      231*	06 Dec 1979, PES - Multiplied all positive precedences in parse_expression by 10, to ease
      232*		addition of new operators.  Since only relative values are  supposed to matter, this
      233*		should have no visible effect.
      234*	27 Nov 1979, PES - Fix bug 248, in which symbol.in_equiv_stmnt is not set for a
      235*		variable which is in both a common block and an equivalence statement.
      236*	26 Sep 1979, PES - major butchery for new CHARACTER mode.  Make comma in assigned goto
      237*		statement optional.
      238*	02 Sep 1979, PES - Fix bug 206, in which certain unfortunate placements of delimiters in
      239*		card-image format statements could cause spurious error 134 messages.
      240*	02 Sep 1979, PES - Allow multiple namelist declarations to refer to same namelist, if
      241*		they are consecutive statements; fix unreported bug in multiple segment
      242*		handling; minor cleanups; allow optional comma in COMMON statements declaring
      243*		multiple commons; change to allow blank lines before %options and %global
      244*		statements; slightly limit the free form check for unintended comment lines;
      245*		fix an unreported namelist bug in which if the first ref to a namelist was in a
      246*		write any following refs in a read would not cause the namelist members to be
      247*		marked set; fixed an unreported namelist bug in which namelist names were
      248*		always listed in the "not referenced" list, with proper cross-reference info;
      249*		changed namelist so that a namelist reference is also cross-referenced as a
      250*		reference to each member; and fixed bug 208, in which variables on the lhs of
      251*		the first assignment statement might be multiply cross-referenced.
      252*	18 Jul 1979, PES - fix bug 211 in which fortran incorrectly evaluates a**b**c as
      253*		(a**b)**c, rather than as a**(b**c).  Also adds diagnosis of possible
      254*		unintended comments in free format input.  Also correct an error in handling of
      255*		encode/decode statements when the string is an entire character array,
      256*		introduced by the fix to 222/223.
      257*	13 Jul 1979, CRD - initialize io_bits.fold to implement fortran_io_ suggested improvement
      258*		078 (case insensitive namelist input with -fold or -card).
      259*	12 Jul 1979, PES - changes to fix bug 222 and implement suggested improvment 223, both
      260*		having to do with encode/decode problems; and to fix various unreported bugs in
      261*		encode/decode.  Also, allow the optional comma after the statement number in a
      262*		do statement, as permitted by the 77 ANSI Standard.
      263*	05 Jul 1979, PES - fixes bug 219 in which an uninitialized variable in the parse may
      264*		cause the listing generator to fault.
      265*	03 Jul 1979, PES - fix uninited variable which caused misc faults.
      266*	12 Jun 1979, PES - major butchery for new PARAMETER statement.
      267*	07 Jun 1979, PES - fixes bug 210 in which the parse will generate a spurious error 125
      268*		message (data type of entry does not match data type of function) if the data
      269*		type of a function entry does not match the default data type of the primary
      270*		function name.
      271*	14 Mar 1979, PES - serious modifications towards include file handling.
      272*	28 Feb 1979, PES - fixes bug 202 in which a missing ; on an %options or %global statement
      273*		will cause the parse to fault.
      274*	8 Jan 1979, RAB - fixes bug 200 in which equivalence alignment is wrong if the second
      275*		item in a pair belongs to a header that is further to the left than the first
      276*		item and difference is odd.
      277*	13 Dec 1978, PES -fixes bug in which named constants are not marked as referenced, and
      278*		bug in which fort_converter does not properly handle string_op.
      279*	12 Dec 1978, PES - fixes bug 189 in which the compiler does not diagnose statements of
      280*		the form "x+y = exp".  If optimizing, such a statement causes a fault; if not
      281*		optimizing, useless code is produced.
      282*	06 Dec 1978, RAB - fixes 193 in which missing comma in implied do causes fault.
      283*	06 Dec 1978, PES - Implement %options and %global--change implementation of octal
      284*		constants to match old_fortran.
      285*	25 Oct 1978, PES - Changes for larger common and arrays.
      286*	25 Sep 1978, PES - Change to fix bug 188, in which block data fails if data statements
      287*		for a common block contain only equivalenced variables and do not contain any
      288*		variables actually appearing in the common statement.
      289*	06 Sep 1978, PES - Change so variables read by namelist directed read are marked as set.
      290*	31 Aug 1978, PES - Change to the constants used by convert_real to check real number
      291*		magnitudes before conversion.  Both original values were too small, meaning:
      292*		(1) That certain very large real constants would not be accepted, even though
      293*		they were proper values; and (2) that certain very small magnitude real
      294*		constants could cause the compiler to take an underflow fault , instead of
      295*		being diagnosed as errors.
      296*	19 July 1978, PES - Fix to relaxed statment ordering, to again permit variables to be
      297*		declared in common after they have been declared equivalenced.  This feature
      298*		was broken by the last change.
      299*	20 June 1978, DSL - Fixes to declaration processing.  Bug fixed in which a variable can
      300*		have two storage classes because default storage class was applied before(!)
      301*		equivalence processing; improved processing of invalid equiv groups; set
      302*		symbol.equivalenced when equiv st is parsed, rather than when dcl processor is
      303*		run.  See comments concerning this parse design change under equiv st parser
      304*		#13.
      305*	12 June 1978, DSL - Have "declaration_processor" set storage class as well as data type
      306*		for all variables, and data type for all ext funcs.  Declare alternate return
      307*		symbol as a variable (bug fix).
      308*	25 May 1978, DSL - Fix bug 157 correctly so compiler will not fault if label > 999999.
      309*		Move create_node to include file.  Insure that statement.put_in_profile and
      310*		statement.put_in_map are always set correctly.
      311*	18 May 1978, DSL - Final fix to bug 144 in which dcl for based_double assumed double word
      312*		alignment for all dp values; fix bug in which text of first statement appears
      313*		as text for main entry point entry sequence; fix bug 158 in which data type for
      314*		float bif is erroneously d.p.; fix bug 157 in which parse faults trying to
      315*		print error message for label > 131071.
      316*	2 May 1978, dsl - minor code changes for v2 opt; also clean up a_complex_constant.
      317*	26 April 1978, DSL - Fix introduced bug in which label parsing was broken.  Other small
      318*		fixes.
      319*	18 April 1978, DSL - Set symbol.set for a format if it is ref'd in a read st and
      320*		contains_hollerith; fix bug 151 in which parse neglects to set symbol.ref'd
      321*		(etc.) for parameter bounds.
      322*	7 April 1978, DSL - Move complex constant processing from lexical analyzer to expression
      323*		parser; fix introduced bug in optimizer in which parse does not force data type
      324*		of a symbol before deciding how much temp space it needs; change card-image lex
      325*		to supply blanks for lines less than 72 chars in length.
      326*	28 March 1978, DSL - Finish relaxed statement ordering; allow another form of function
      327*		statement; fix bug 144 in which conversion from dp to real fails because dcl of
      328*		based_double is wrong.
      329*
      330*******************  Converted to version 2 optimizer.  ******************
      331*
      332*	28 February 1978, DSL - Change logic to allow statements to appear in any order.  The
      333*		only surviving restrictions are: a) declaratives must precede first reference;
      334*		b) all statement func.  defs.  must precede all other executables.
      335*	2 February 1978, DSL - Mark return statement code generated by an end line as being
      336*		executable.
      337*	1 February 1978, DSL - Fix post-parse declaration processor to set all symbol.data_type
      338*		and symbol.element_size.
      339*	29 December 1977, DSL - Fix bug 124 so that -3435...  (-2**35) is accepted in a data
      340*		specification; fix bug 126 so that cg will not fault on an unreferenced
      341*		st.func.  def.; fix bug 137 so that max number of consts is 500, not 200.
      342*		Also, some changes were made in preparation for relaxing all stmnt order
      343*		requirements.  Also, fixed unreported bug in which char func with different
      344*		lengths declared at each entry point would not be diagnosed, although compiler
      345*		does not handle this case correctly.  Also, modified data spec parse to allow
      346*		char consts and octal consts for all data type.  Data spec parse no longer
      347*		limits the number of error msgs it prints.  print_message is made responsible.
      348*	30 August 1977, D Levin - print message if subr or func ref has too many args;
      349*		NOTE - value of bias changed from 65536 to 131072.
      350*	18 July 1977, David Levin - fix bugs in open and close.
      351*	30 June 1977, David Levin - 1) new fort_system_constants.incl.pl1; 2) open and close
      352*		statements; 3) move block data code from fort_ to here.
      353*	26 May 1977, David Levin - data parser printed random stuff instead of octal constant in
      354*		error msg.
      355*	2 May 1977, David Levin - for new fort_system_constants.incl.pl1 and changes for implied
      356*		do loop optimization and bug fix for stop/pause.
      357*	22 April 1977, David Levin - convert long real const (>8) to dp; warn user if char var
      358*		init'ed with const too long; fix bug in warning msg.
      359*	14 April 1977 David Levin - small optimizer fix; add 6 new builtin functions.
      360*	25 March 1977 David Levin - fix for char const as fmt; set label.referenced_executable.
      361*	24 February 1977 Gabriel Chang - to emit a zero operand for not, and negate operators and
      362*		emit no_ops for complicated subscripts for optimization.
      363*	10 February 1977 David Levin - fix bug in equiv stmnt; improve lex for real constants.
      364*	24 January 1977 David Levin - minor tuning; prepare for the addition of optimizer changes.
      365*	19 January 1977 David Levin - bug fix for data stmnt parser.
      366*	14 September 1976 David Levin - listing addition bug fixes, some error msg clean up.
      367*	9 September, 1976 David Levin - bug fixes for listing additions.
      368**/
      369 
      370 dcl      p pointer;
      371 dcl      q pointer;
      372 dcl      parse_ptr pointer;
      373 dcl      shared_ptr pointer;
      374 dcl      polish_string (0:polish_max_len - 1) fixed bin (19) aligned based (polish_base);
      375 dcl      polish_base ptr;
      376 dcl      operand_base ptr;
      377 dcl      object_base ptr;
      378 dcl      cref_base ptr;
      379 dcl      source_line_base ptr;
      380 dcl      listing_base ptr;
      381 dcl      polish_max_len fixed bin (19);
      382 dcl      object_max_len fixed bin (19);
      383 dcl      1 max_array_size,
      384 	 2 auto fixed bin (24),
      385 	 2 char fixed bin (24),
      386 	 2 common fixed bin (24),
      387 	 2 parm fixed bin (24),
      388 	 2 static fixed bin (24);
      389 
      390 dcl      1 segment_options aligned like fortran_options;
      391 dcl      1 subr_options aligned like fortran_options;
      392 dcl      1 segment_declared aligned like fortran_declared;
      393 dcl      1 subr_declared aligned like fortran_declared;
      394 
      395 dcl      1 parse_structure aligned based (parse_ptr),
  1     1 
  1     2 	  2 source_info_ptr		ptr,
  1     3 
  1     4 	  2 add_to_lib_list		entry(char(*),fixed bin(35))
  1     5 				variable,
  1     6 	  2 get_next_source_seg	entry(ptr)
  1     7 				variable,
  1     8 	  2 add_to_lib_list_run	entry(char(*),fixed bin(35))
  1     9 				entry;
  1    10 
      396 
      397 
      398 dcl      1 shared_structure aligned based (shared_ptr),
  2     1 
  2     2 /* BEGIN fort_shared_vars.incl.pl1 */
  2     3 
  2     4 
  2     5 
  2     6 /****^  HISTORY COMMENTS:
  2     7*  1) change(86-07-14,BWong), approve(86-07-14,MCR7286), audit(86-07-17,Ginter),
  2     8*     install(86-07-28,MR12.0-1105):
  2     9*     Fix fortran bug 463.
  2    10*                                                   END HISTORY COMMENTS */
  2    11 
  2    12 
  2    13 /* Created:	June 1976, David Levin
  2    14*
  2    15*	Modified:	30 Aug 76, David Levin - to add global variables for listing segment.
  2    16*	Modified:	22 Nov 76, Richard Barnes - to add profile_size
  2    17*	Modified: 24 Feb 77, Gabriel Chang - for the optimizer
  2    18*	Modified:	06 Oct 77, Richard Barnes - for the loop optimizer
  2    19*	Modified: 16 Nov 77, David Levin - add next_free_(temp array_ref).
  2    20*	Modified: 09 Oct 78, Paul Smee - for larger common and arrays.
  2    21*	Modified: 03 Apr 79, Paul Smee - add list of include file data.
  2    22*	Modified: 17 May 79, Paul Smee - add cur_statement_list.
  2    23*	Modified: 28 Jun 79, Paul Smee - add compile-time math entry arrays.
  2    24*	Modified: 13 Sep 79, Paul Smee - add default_char_size.
  2    25*	Modified:	18 Dec 79, Richard Barnes - add free and freei
  2    26*	Modified: 03 Mar 80, C R Davis - add must_save_stack_extent.
  2    27*	Modified: 15 Mar 82, T G Oke - add source (line_number, file_number).
  2    28*	Modified: 20 Sept 82, T G Oke - add VLA_is_256K flag
  2    29*	Modified: 22 Sept 82, T G Oke - add area creation info to pass to
  2    30*	     listing generator.
  2    31*	Modified: 17 May 83, M Mabey - add declared_options.
  2    32*	Modified: 02 Aug 85, B Wong - 463: changed 'must_save_stack_extent'
  2    33*	     to 'pad' since the variable is no longer used.
  2    34**/
  2    35 
  2    36 	  2 polish_base		ptr,
  2    37 	  2 operand_base		ptr,
  2    38 	  2 object_base		ptr,
  2    39 	  2 quadruple_base		ptr,
  2    40 	  2 opt_base		ptr,
  2    41 	  2 relocation_base		ptr,
  2    42 
  2    43 	  2 cref_base		ptr,		/* base of cross reference segment */
  2    44 	  2 source_line_base	ptr,		/* base of source line offset segment */
  2    45 	  2 listing_base		ptr,		/* base of listing info segment */
  2    46 	  2 cur_listing		ptr,		/* points to listing info for the active subprogram */
  2    47 
  2    48 	  2 free(2:4)		ptr,		/* free chains for optimizer */
  2    49 	  2 freei			ptr,		/* .. */
  2    50 
  2    51 	  2 polish_max_len		fixed bin (19),
  2    52 	  2 operand_max_len		fixed bin (19),
  2    53 	  2 object_max_len		fixed bin (19),
  2    54 	  2 quad_max_len		fixed bin (19),
  2    55 	  2 opt_max_len		fixed bin (19),
  2    56 
  2    57 	  2 next_free_polish	fixed bin (18),
  2    58 	  2 next_free_operand	fixed bin (18),
  2    59 	  2 next_free_object	fixed bin (18),
  2    60 	  2 next_free_listing	fixed bin (18),
  2    61 	  2 next_free_quad		fixed bin (18),
  2    62 	  2 next_free_array_ref	fixed bin (18),	/* Chain for freed array_ref nodes. */
  2    63 	  2 next_free_temp		fixed bin (18),	/* Chain for freed temporary nodes. */
  2    64 	  2 next_free_opt		fixed bin (18),
  2    65 
  2    66 	  2 first_segment		fixed bin,
  2    67 	  2 number_of_source_segments	fixed bin (8),
  2    68 	  2 number_of_lines		fixed bin,
  2    69 	  2 number_of_crefs		fixed bin,
  2    70 	  2 profile_size		fixed bin,
  2    71 
  2    72 	  2 main_entry_point_name	char (32) varying,
  2    73 
  2    74 	  2 cur_statement		fixed bin (18),
  2    75 	  2 cur_statement_list        fixed bin (17),
  2    76 	  2 cur_subprogram		fixed bin (18),
  2    77 	  2 first_subprogram	fixed bin (18),
  2    78 	  2 last_subprogram		fixed bin (18),
  2    79 	  2 unnamed_block_data_subprogram
  2    80 				fixed bin (18),
  2    81 	  2 first_entry_name	fixed bin (18),
  2    82 	  2 last_entry_name		fixed bin (18),
  2    83 
  2    84 	  2 constant_info (4)	aligned structure,
  2    85 	    3 constant_count	fixed bin (17),
  2    86 	    3 first_constant	fixed bin (18),
  2    87 	    3 last_constant		fixed bin (18),
  2    88 
  2    89 	  2 options		aligned,
  2    90 	    3 user_options		aligned like fortran_options,
  2    91 	    3 system_options	aligned,
  2    92 	      4 is_fast		bit (1) unaligned,
  2    93 	      4 namelist_used	bit (1) unaligned,
  2    94 	      4 compile_only	bit (1) unaligned,
  2    95 	      4 VLA_is_256K		bit (1) unaligned,	/* FLAG 255/256K code */
  2    96 	      4 pad		bit (32) unaligned,
  2    97 
  2    98 	  2 incl_data		aligned,
  2    99 	    3 incl_count		fixed bin,
  2   100 	    3 file_list (0:255),
  2   101 	      4 source_node_offset	fixed bin (18),
  2   102 	      4 incl_len		fixed bin (21),
  2   103 	      4 incl_ptr		unaligned ptr,
  2   104 
  2   105 	  2 create_constant		entry (fixed bin (4), bit (72) aligned) returns (fixed bin (18))
  2   106 				variable,
  2   107 	  2 create_char_constant	entry (char (*)) returns (fixed bin (18))
  2   108 				variable,
  2   109 	  2 print_message		entry options (variable)
  2   110 				variable,
  2   111 	  2 get_next_temp_segment	entry (ptr, fixed bin (18)) returns (ptr)
  2   112 				variable,
  2   113 	  2 negate_round (6)	entry (fixed bin (35), bit (72), bit (72), fixed bin (35))
  2   114 				returns (bit (72)) variable,
  2   115 	  2 negate_trunc (6)	entry (fixed bin (35), bit (72), bit (72), fixed bin (35))
  2   116 				returns (bit (72)) variable,
  2   117 	  2 binop_round (6,6)	entry (fixed bin (35), bit (72), bit (72), fixed bin (35))
  2   118 				returns (bit (72)) variable,
  2   119 	  2 binop_trunc (6,6)	entry (fixed bin (35), bit (72), bit (72), fixed bin (35))
  2   120 				returns (bit (72)) variable,
  2   121 	  2 comp_parm (6,6)		entry (fixed bin (35), bit (72), bit (72), fixed bin (35))
  2   122 				returns (bit (72)) variable,
  2   123 	  2 conv_round (6,6)		entry (bit (72), fixed bin (35))
  2   124 				returns (bit (72)) variable,
  2   125 	  2 conv_trunc (6,6)	entry (bit (72), fixed bin (35))
  2   126 				returns (bit (72)) variable,
  2   127 	  2 pad			bit (1) aligned,
  2   128 
  2   129 /* The following are used by "print_message - decode_source_id" if use_source_info set. */
  2   130 
  2   131 	  2 use_source_info		bit (1) aligned,
  2   132 	  2 source_file_number	fixed bin (35),
  2   133 	  2 source_line_number	fixed bin (35),
  2   134 	  2 Area_create_first	fixed bin (18),	/* start of text to do creation */
  2   135             2 Area_create_last	fixed bin (18),	/* Last item */
  2   136             2 Area_init_first		fixed bin (18),	/* start of text to init areas */
  2   137             2 Area_init_last		fixed bin (18),	/* Last item */
  2   138 	  2 declared_options	aligned like fortran_declared;
  2   139 
  2   140 dcl	num_of_word_constants	fixed bin (17) defined (constant_info (1).constant_count);
  2   141 dcl	first_word_constant		fixed bin (18) defined (constant_info (1).first_constant);
  2   142 dcl	last_word_constant		fixed bin (18) defined (constant_info (1).last_constant);
  2   143 
  2   144 dcl	num_of_dw_constants		fixed bin (17) defined (constant_info (2).constant_count);
  2   145 dcl	first_dw_constant		fixed bin (18) defined (constant_info (2).first_constant);
  2   146 dcl	last_dw_constant		fixed bin (18) defined (constant_info (2).last_constant);
  2   147 
  2   148 dcl	num_of_char_constants	fixed bin (17) defined (constant_info (3).constant_count);
  2   149 dcl	first_char_constant		fixed bin (18) defined (constant_info (3).first_constant);
  2   150 dcl	last_char_constant		fixed bin (18) defined (constant_info (3).last_constant);
  2   151 
  2   152 dcl	num_of_block_constants	fixed bin (17) defined (constant_info (4).constant_count);
  2   153 dcl	first_block_constant	fixed bin (18) defined (constant_info (4).first_constant);
  2   154 dcl	last_block_constant		fixed bin (18) defined (constant_info (4).last_constant);
  2   155 
  2   156 /* END   fort_shared_vars.incl.pl1 */
      399 
  3     1 /* BEGIN INCLUDE FILE fort_options.incl.pl1  */
  3     2 
  3     3 /****^  ***********************************************************
  3     4*        *                                                         *
  3     5*        * Copyright, (C) Honeywell Information Systems Inc., 1987 *
  3     6*        *                                                         *
  3     7*        *********************************************************** */
  3     8 
  3     9 /****^  HISTORY COMMENTS:
  3    10*  1) change(86-07-14,BWong), approve(86-07-14,MCR7382), audit(86-07-17,Ginter),
  3    11*     install(86-07-28,MR12.0-1105):
  3    12*     Fix fortran bug 473.
  3    13*  2) change(87-06-23,RWaters), approve(87-06-23,MCR7703), audit(87-07-10,Huen),
  3    14*     install(87-08-06,MR12.1-1069):
  3    15*     Implemented SCP 6315: fortran error-handling argument.
  3    16*                                                   END HISTORY COMMENTS */
  3    17 
  3    18 
  3    19 /*
  3    20*          Modified: 12 May 87 by RWaters added debug_io
  3    21*	Modified: 19 February 1986 by B. Wong & A. Ginter - 473.a: Correct
  3    22*		comments and size of pad field in fort_declared
  3    23*		and pad out dfast and fast bit masks to two words.
  3    24*	Modified: 09 October 1985 by B. Wong - 473: add VLA_auto, VLA_static,
  3    25*		VLA_parm, VLC, LA_auto, and LA_static.  Remove VLA and LA.
  3    26*	Modified: 28 March 1984 by M. Mabey - Install HFP support.
  3    27*	Modified: 21 September 1983 by M. Mabey - correct size of pad field in  fortran_declared.
  3    28*	Modified: 16 May 1983 by M. Mabey - add fortran_declared
  3    29*	Modified: 18 December 1982 by T. Oke - Add 'long_profile'.
  3    30*	Modified: 22 September 1982 by T. Oke - add VLA and LA
  3    31*	Modified:  3 May  1982 by T. Oke - add check_multiply
  3    32*	Modified: 06/24/81 by S. Herbst - add do_rounding & auto_zero to fast_mask and dfast_mask
  3    33*	Modified: 26 February 1980 by C R Davis - add fast_mask,  fix dfast_mask.
  3    34*	Modified: 31 January 1980 by C R Davis - add stringrange.
  3    35*	Modified: 13 September 1979 by Paul E. Smee--add ansi_77.
  3    36*	Modified: 05 December 1978 by Paul E. Smee--add do_rounding, auto_zero.
  3    37*	Modified:	25 January 1978 by Richard A. Barnes for the loop optimizer
  3    38**/
  3    39 
  3    40 declare
  3    41 
  3    42     1 fortran_options aligned based,
  3    43       2 use_library bit (1) unaligned,		/* (1) ON if library statements will be parsed */
  3    44       2 optimize bit (1) unaligned,		/* (2) ON if optimized code is to be produced */
  3    45       2 time bit (1) unaligned,		/* (3) ON for compile timing */
  3    46       2 source_format unaligned,
  3    47         3 has_line_numbers bit (1) unaligned,	/* (4) ON if each line begins with a line number */
  3    48         3 fold bit (1) unaligned,		/* (5) ON if variable names are to be folded to lowercase */
  3    49         3 card bit (1) unaligned,		/* (6) ON for card format */
  3    50         3 convert bit (1) unaligned,		/* (7) ON for card format to be converted */
  3    51       2 listing unaligned,
  3    52         3 source bit (1) unaligned,		/* (8) ON for listing of numbered source */
  3    53         3 symbol bit (1) unaligned,		/* (9) ON for listing with symbol map */
  3    54         3 map bit (1) unaligned,		/* (10) ON for listing with statement map */
  3    55         3 list bit (1) unaligned,		/* (11) ON for listing with assembler instructions */
  3    56       2 error_messages unaligned,
  3    57         3 brief bit (1) unaligned,		/* (12) ON for brief error messages */
  3    58         3 severity fixed bin (3),		/* (13-16) suppresses messages below this severity */
  3    59       2 debugging unaligned,
  3    60         3 subscriptrange bit (1) unaligned,	/* (17) ON for subscript range checking */
  3    61         3 stringrange bit (1) unaligned,	/* (18) ON for string range checking */
  3    62         3 brief_table bit (1) unaligned,	/* (19) ON for statement table */
  3    63         3 table bit (1) unaligned,		/* (20) ON for statement and symbol table */
  3    64         3 profile bit (1) unaligned,		/* (21) ON to generate code to meter statements */
  3    65         3 check bit (1) unaligned,		/* (22) ON for syntactic and semantic checking only */
  3    66       2 system_debugging unaligned,
  3    67         3 stop_after_cg bit (1) unaligned,	/* (23) ON if debug stop after code generator */
  3    68         3 stop_after_parse bit (1) unaligned,	/* (24) ON if debug stop after parse */
  3    69       2 relocatable bit (1) unaligned,		/* (25) ON if relocatable object segment generated */
  3    70       2 optimizing unaligned,
  3    71         3 time_optimizer bit (1) unaligned,	/* (26) ON if timings for optimizer requested */
  3    72 					/* (27) ON if optimizer can loosen safety constraints */
  3    73         3 ignore_articulation_blocks bit (1) unaligned,
  3    74         3 consolidate bit(1) unaligned,		/* (28) ON if optimizer should run consolidation phase */
  3    75       2 do_rounding bit(1) unaligned,		/* (29) ON if floating point round should be used */
  3    76       2 auto_zero bit(1) unaligned,		/* (30) ON if auto storage should be zeroed when allocated */
  3    77       2 ansi_77 bit (1) unaligned,		/* (31) ON if ansi77 rules are to be followed */
  3    78       2 check_multiply bit (1) unaligned,	/* (32) ON if check integer multiply extent */
  3    79       2 VLA_auto bit (1) unaligned,		/* (33) ON if auto VLA's being done */
  3    80       2 VLA_parm bit (1) unaligned,		/* (34) ON if parm VLA's being done */
  3    81       2 VLA_static bit (1) unaligned,		/* (35) ON if static VLA's being done */
  3    82       2 VLC bit (1) unaligned,		/* (36) ON if VLC's being done */
  3    83       2 LA_auto bit (1) unaligned,		/* (1)  ON if auto LA's being done */
  3    84       2 LA_static bit (1) unaligned,		/* (2)  ON if static LA's being done */
  3    85       2 long_profile bit (1) unaligned,		/* (3)  ON to generate long_profile */
  3    86       2 static_storage bit (1) unaligned,	/* (4)  ON if static storage */
  3    87       2 hfp bit (1) unaligned,		/* (5)  ON if using hex floating point math */
  3    88       2 debug_io bit (1) unaligned,               /* (6) */
  3    89       2 pad bit(30) unaligned;		/* (7-36) Pad bits */
  3    90 
  3    91 declare
  3    92 
  3    93    1  fortran_declared aligned based,
  3    94       2  ansi66 bit(1) unaligned,		/* (1) First word */
  3    95       2  ansi77 bit(1) unaligned,		/* (2) */
  3    96       2  auto bit(1) unaligned,		/* (3) */
  3    97       2  auto_zero bit(1) unaligned,		/* (4) */
  3    98       2  brief bit(1) unaligned,		/* (5) */
  3    99       2  binary_floating_point bit(1) unaligned,	/* (6) */
  3   100       2  brief_table bit(1) unaligned,		/* (7) */
  3   101       2  card bit(1) unaligned,		/* (8) */
  3   102       2  check bit(1) unaligned,		/* (9) */
  3   103       2  check_multiply bit(1) unaligned,	/* (10) */
  3   104       2  consolidate bit(1) unaligned,		/* (11) */
  3   105       2  debug bit(1) unaligned,		/* (12) */
  3   106       2  debug_cg bit(1) unaligned,		/* (13) */
  3   107       2  debug_io bit(1) unaligned,		/* (14) */
  3   108       2  default_full bit(1) unaligned,		/* (15) */
  3   109       2  default_safe bit(1) unaligned,		/* (16) */
  3   110       2  fold bit(1) unaligned,		/* (17) */
  3   111       2  free bit(1) unaligned,		/* (18) */
  3   112       2  full_optimize bit(1) unaligned,	/* (19) */
  3   113       2  hexadecimal_floating_point bit(1) unaligned,
  3   114 					/* (20) */
  3   115       2  la_auto bit(1) unaligned,		/* (21) */
  3   116       2  la_static bit(1) unaligned,		/* (22) */
  3   117       2  large_array bit(1) unaligned,		/* (23) */
  3   118       2  line_numbers bit(1) unaligned,		/* (24) */
  3   119       2  list bit(1) unaligned,		/* (25) */
  3   120       2  long bit(1) unaligned,		/* (26) */
  3   121       2  long_profile bit(1) unaligned,		/* (27) */
  3   122       2  map bit(1) unaligned,		/* (28) */
  3   123       2  no_auto_zero bit(1) unaligned,		/* (29) */
  3   124       2  no_check bit(1) unaligned,		/* (30) */
  3   125       2  no_fold bit(1) unaligned,		/* (31) */
  3   126       2  no_large_array bit(1) unaligned,	/* (32) */
  3   127       2  no_line_numbers bit(1) unaligned,	/* (33) */
  3   128       2  no_map bit(1) unaligned,		/* (34) */
  3   129       2  no_optimize bit(1) unaligned,		/* (35) */
  3   130       2  no_check_multiply bit(1) unaligned,	/* (36) */
  3   131       2  no_debug_io bit(1) unal,                 /* (1) Second Word */
  3   132       2  no_stringrange bit(1) unaligned,	/* (2) */
  3   133       2  no_subscriptrange bit(1) unaligned,	/* (3) */
  3   134       2  no_table bit(1) unaligned,		/* (4) */
  3   135       2  no_very_large_array bit(1) unaligned,	/* (5) */
  3   136       2  no_vla_parm bit(1) unaligned,		/* (6) */
  3   137       2  no_version bit(1) unaligned,		/* (7) */
  3   138       2  non_relocatable bit(1) unaligned,	/* (8) */
  3   139       2  optimize bit(1) unaligned,		/* (9) */
  3   140       2  profile bit(1) unaligned,		/* (10) */
  3   141       2  relocatable bit(1) unaligned,		/* (11) */
  3   142       2  round bit(1) unaligned,		/* (12) */
  3   143       2  safe_optimize bit(1) unaligned,	/* (13) */
  3   144       2  severity fixed bin(3) unaligned,	/* (14-16) */
  3   145       2  static bit(1) unaligned,		/* (17) */
  3   146       2  stringrange bit(1) unaligned,		/* (18) */
  3   147       2  subscriptrange bit(1) unaligned,	/* (19) */
  3   148       2  table bit(1) unaligned,		/* (20) */
  3   149       2  time bit(1) unaligned,		/* (21) */
  3   150       2  time_ot bit(1) unaligned,		/* (22) */
  3   151       2  top_down bit(1) unaligned,		/* (23) */
  3   152       2  truncate bit(1) unaligned,		/* (24) */
  3   153       2  version bit(1) unaligned,		/* (25) */
  3   154       2  very_large_array bit(1) unaligned,	/* (26) */
  3   155       2  very_large_common bit(1) unaligned,	/* (27) */
  3   156       2  vla_auto bit(1) unaligned,		/* (28) */
  3   157       2  vla_parm bit(1) unaligned,		/* (29) */
  3   158       2  vla_static bit(1) unaligned,		/* (30) */
  3   159       2  pad bit(6) unaligned;		/* (31-36) */
  3   160 
  3   161 
  3   162 declare					/* Options used by DFAST */
  3   163 
  3   164      dfast_mask bit (72) internal static options (constant) initial ("100110000000000010100000000011"b);
  3   165 	/* use_library, has_line_numbers, fold, subscriptrange, brief_table */
  3   166 
  3   167 
  3   168 declare					/* Options used by FAST */
  3   169 
  3   170      fast_mask bit (72) internal static options (constant) initial ("000100000000000010100000000011"b);
  3   171 	/* has_line_numbers, subscriptrange, brief_table */
  3   172 
  3   173 /* END INCLUDE FILE fort_options.incl.pl1 */
      400 
  4     1 /* BEGIN fort_system_constants.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(86-07-14,BWong), approve(86-07-14,MCR7382), audit(86-07-17,Ginter),
  4     7*     install(86-07-28,MR12.0-1105):
  4     8*     Fix fortran bug 428.
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 
  4    12 /* Created:	June 1976, David Levin  */
  4    13 
  4    14 /* Modified:
  4    15*	15 Dec 85, RW - 428: Changed max_char_length from 256 to 512.
  4    16*	22 Jun 84, MM - Install typeless functions support.
  4    17*	17 Jun 83, HH - 383: Added 'process_param_list_op'.
  4    18*	12 Jan 83, HH - Added 'form_VLA_packed_ptr_op'.
  4    19*	05 Oct 82, HH - Added 'units_per_word'.
  4    20*	27 Sep 82, HH - Added 'max_fixed_bin_18', 'max_fixed_bin_24' and 'sys_info$max_seg_size'.
  4    21*		Removed 'max_stored_value' and 'min_stored_value'.
  4    22*	24 October 1981, ME Presser - added inquire_op.
  4    23*	20 October 1981, C R Davis - add (read write)_internal_file_op.
  4    24*   	11 May 1981, Marshall Presser - added op-codes for .EQV. and .NEQV.
  4    25*	28 April 1981, Marshall Presser - added default_main_entry_point_name
  4    26*	11 March 1981, Marshall Presser - add min_stored_value
  4    27*	8 December 1980, C R Davis - add block_if_op, else_if_op, else_op.
  4    28*	15 January 1980, C R Davis - add bits_per_char.
  4    29*	21 December 1979, Richard A. Barnes - add unrecoverable_errror and
  4    30*		max_error_level.
  4    31*	3 November 1979, Richard Barnes - add pointer_node.
  4    32*	17 September 1979, Richard Barnes - add load_preg_op & load_xreg_op
  4    33*	13 September 1979, Paul Smee - add colon and concat token types,
  4    34*		change value of EOS_token, remove default_char_size.
  4    35*	31 August 1979, Charlie Davis - change offset units to
  4    36*		be consistent with those in runtime symbols.
  4    37*	13 August 1979, Richard Barnes - add cat_op & substr_op
  4    38*	19 July 1979, Richard Barnes - char mode
  4    39*	10 October 1978, Paul Smee - double max_stored_value and bias.
  4    40*	15 June 1978, Paul Smee - add max_num_of_rands
  4    41*	16 November 1977, David Levin - add machine_state_node
  4    42*	12 September 1977, Richard Barnes - new ops for loop optimizer
  4    43*	30 August 1977, David Levin - change bias from 65536 to 131072.
  4    44*	5 July 1977, David Levin - add open_op, close_op, and iostat_op.
  4    45*	28 April 1977, David Levin - add xmit_vector_op in operator list
  4    46*	22 April 1977, David Levin - add max_prec_single, last_assigned_mode
  4    47*	24 February 1977, Gabriel Chang for the optimizer.
  4    48*	23 February 1977, David Levin to change name of count operand.
  4    49*	28 October 1976, David Levin and Gabriel Chang to add 2 new ops and
  4    50*		1 new node type.
  4    51*	2 September 1976, David Levin - add 8 new ops and change name of
  4    52*		data_op.
  4    53**/
  4    54 	/* SYSTEM CONSTANTS */
  4    55 
  4    56 dcl	bias		init(262144) fixed bin(19) int static options(constant);
  4    57 dcl	gap_value		init(0) fixed bin int static options(constant);
  4    58 dcl       max_fixed_bin_18    init(111111111111111111b) fixed bin (18) static options (constant);
  4    59 dcl       max_fixed_bin_24    init(111111111111111111111111b) fixed bin (24) static options (constant);
  4    60 dcl	max_num_of_rands	init(127) fixed bin int static options(constant);
  4    61 dcl       sys_info$max_seg_size
  4    62                               fixed bin (18) ext;
  4    63 
  4    64 dcl (	unrecoverable_error	init(3),
  4    65 	max_error_level	init(4))
  4    66 	fixed bin int static options(constant);
  4    67 
  4    68 dcl	(main_program	init(0),
  4    69 	 block_data	init(1),
  4    70 	 subroutine	init(2),
  4    71 	 function		init(3),
  4    72 	 chars_per_word	init(4),
  4    73 	 chars_per_dw	init(8),
  4    74 	 bits_per_char	init(9),
  4    75 	 first_auto_loc	init(64),
  4    76 	 max_prec_single	init(8)) fixed bin(9) int static options(constant);
  4    77 dcl	 max_char_length	init(512) fixed bin(10) int static options(constant);	
  4    78 
  4    79 dcl	blank_common_name	init("blnk*com") char(8) aligned int static options(constant);
  4    80 declare	default_main_entry_point_name
  4    81 			char (5) int static options (constant) initial ("main_");
  4    82 declare	unnamed_block_data_subprg_name
  4    83 			char (29) int static options (constant) initial ("unnamed block data subprogram");
  4    84 
  4    85 	/*  NODE TYPES	*/
  4    86 
  4    87 dcl	(fill_node	init(0),
  4    88 	 source_node	init(1),
  4    89 	 symbol_node	init(2),
  4    90 	 dimension_node	init(3),
  4    91 	 temporary_node	init(4),
  4    92 	 constant_node	init(5),
  4    93 	 label_node	init(6),
  4    94 	 header_node	init(7),
  4    95 	 char_constant_node	init(8),
  4    96 	 array_ref_node	init(9),
  4    97 	 proc_frame_node	init(10),
  4    98 	 library_node	init(11),
  4    99 	 subprogram_node	init(12),
  4   100 	 arg_desc_node	init(13),
  4   101 	 pointer_node	init(14),
  4   102 	 machine_state_node init(15)) fixed bin(4) aligned internal static options(constant);
  4   103 
  4   104 	/*  DATA TYPES	*/
  4   105 
  4   106 dcl	(int_mode  	init(1),
  4   107 	 real_mode 	init(2),
  4   108 	 dp_mode   	init(3),
  4   109 	 cmpx_mode 	init(4),
  4   110 	 logical_mode	init(5),
  4   111 	 char_mode 	init(6),
  4   112 	 typeless_mode	init(7),
  4   113 	 last_assigned_mode init(7)) fixed bin(4) aligned internal static options(constant);
  4   114 
  4   115 dcl	data_type_size(7)	init(1,1,2,2,1,0,1) fixed bin int static options(constant);
  4   116 
  4   117 
  4   118 	/*  OPERAND TYPES	*/
  4   119 
  4   120 dcl	(variable_type	init(1),
  4   121 	 constant_type	init(2),
  4   122 	 array_ref_type	init(3),
  4   123 	 temp_type	init(4),
  4   124 	 count_type	init(5),
  4   125 	 rel_constant	init(6),
  4   126 	 bif		init(7),
  4   127 	 statement_function	init(8),
  4   128 	 external		init(9),
  4   129 	 entry_type	init(10),
  4   130 	 dummy		init(11),
  4   131 	 error		init(12)) fixed bin(4) aligned internal static options(constant);
  4   132 
  4   133 
  4   134 	/* OFFSET UNITS */
  4   135 
  4   136 dcl
  4   137 	(word_units	init (0),
  4   138 	 bit_units	init (1),
  4   139 	 char_units	init (2),
  4   140 	 halfword_units	init (3)) fixed bin (3) aligned internal static options(constant);
  4   141 
  4   142 dcl        units_per_word     (0:3) init (1, 36, 4, 2) fixed bin (6) static options (constant);
  4   143 
  4   144 
  4   145 	/* TOKEN MASKS */
  4   146 
  4   147 dcl
  4   148 	(is_operand		initial("101000000"b),
  4   149 	 is_operator		initial("010000000"b),
  4   150 	 is_constant		initial("001000000"b),
  4   151 	 is_arith_constant		initial("000100000"b)) bit(9) aligned internal static options(constant);
  4   152 
  4   153 
  4   154 	/* TOKEN TYPES */
  4   155 
  4   156 dcl	(no_token		initial("000000000"b),
  4   157 	 ident		initial("100000000"b),
  4   158 	 plus		initial("010000001"b),
  4   159 	 minus		initial("010000010"b),
  4   160 	 asterisk		initial("010000011"b),
  4   161 	 slash		initial("010000100"b),
  4   162 	 expon		initial("010000101"b),
  4   163 	 not		initial("010000110"b),
  4   164 	 and		initial("010000111"b),
  4   165 	 or		initial("010001000"b),
  4   166 	 eq		initial("010001001"b),
  4   167 	 ne		initial("010001010"b),
  4   168 	 lt		initial("010001011"b),
  4   169 	 gt		initial("010001100"b),
  4   170 	 le		initial("010001101"b),
  4   171 	 ge		initial("010001110"b),
  4   172 	 assign		initial("010001111"b),
  4   173 	 comma		initial("010010000"b),
  4   174 	 left_parn	initial("010010001"b),
  4   175 	 right_parn	initial("010010010"b),
  4   176 	 apostrophe	initial("010010011"b),
  4   177 	 colon		initial("010010100"b),
  4   178 	 concat		initial("010010101"b),
  4   179 	 substr_left_parn	initial("010010110"b),
  4   180 	 eqv		initial("010010111"b),
  4   181 	 neqv		initial("010011000"b),
  4   182 	 EOS_token	initial("010011111"b),
  4   183 	 char_string	initial("001000001"b),
  4   184 	 logical_const	initial("001000010"b),
  4   185 	 false		initial("001000010"b),	/* Must be identical to true except low order bit off. */
  4   186 	 true		initial("001000011"b),	/* Must be identical to false except low order bit on. */
  4   187 	 label_const	initial("001000100"b),
  4   188 	 octal_const	initial("001000101"b),
  4   189 	 dec_int		initial("001100110"b),
  4   190 	 real_const	initial("001100111"b),
  4   191 	 double_const	initial("001101000"b),
  4   192 	 complex_const	initial("001101001"b)) bit(9) aligned internal static options(constant);
  4   193 
  4   194 
  4   195 	/* OPERATOR NAMES */
  4   196 
  4   197 declare
  4   198 	(assign_op		initial(1),
  4   199 	 add_op			initial(2),
  4   200 	 sub_op			initial(3),
  4   201 	 mult_op			initial(4),
  4   202 	 div_op			initial(5),
  4   203 	 exponentiation_op		initial(6),
  4   204 	 negate_op		initial(7),
  4   205 	 less_op			initial(8),
  4   206 	 less_or_equal_op		initial(9),
  4   207 	 equal_op			initial(10),
  4   208 	 not_equal_op		initial(11),
  4   209 	 greater_or_equal_op	initial(12),
  4   210 	 greater_op		initial(13),
  4   211 	 or_op			initial(14),
  4   212 	 and_op			initial(15),
  4   213 	 not_op			initial(16),
  4   214 	 jump_op			initial(17),
  4   215 	 jump_logical_op		initial(18),
  4   216 	 jump_arithmetic_op		initial(19),
  4   217 	 jump_computed_op		initial(20),
  4   218 	 jump_assigned_op		initial(21),
  4   219 	 assign_label_op		initial(22),
  4   220 	 read_op			initial(23),
  4   221 	 write_op			initial(24),
  4   222 	 format_op		initial(25),
  4   223 	 end_label_op		initial(26),
  4   224 	 error_label_op		initial(27),
  4   225 	 xmit_scalar_op		initial(28),
  4   226 	 xmit_array_op		initial(29),
  4   227 	 xmit_vector_op		initial(30),
  4   228 	 endfile_op		initial(31),
  4   229 	 rewind_op		initial(32),
  4   230 	 backspace_op		initial(33),
  4   231 	 margin_op		initial(34),
  4   232 	 openfile_op		initial(35),
  4   233 	 closefile_op		initial(36),
  4   234 	 record_number_op		initial(37),
  4   235 	 string_op		initial(38),
  4   236 	 string_length_op		initial(39),
  4   237 	 terminate_op		initial(40),
  4   238 	 return_op		initial(41),
  4   239 	 pause_op			initial(42),
  4   240 	 stop_op			initial(43),
  4   241 	 item_op			initial(44),
  4   242 	 exit_op			initial(45),
  4   243 	 eol_op			initial(46),
  4   244 	 do_op			initial(47),
  4   245 	 builtin_op		initial(48),
  4   246 	 sf_op			initial(49),
  4   247 	 sf_def_op		initial(50),
  4   248 	 subscript_op		initial(51),
  4   249 	 func_ref_op		initial(52),
  4   250 	 block_data_op		initial(53),
  4   251 	 increment_polish_op	initial(54),
  4   252 	 main_op			initial(55),
  4   253 	 func_op			initial(56),
  4   254 	 subr_op			initial(57),
  4   255 	 stat_op			initial(58),
  4   256 	 label_op			initial(59),
  4   257 	 call_op			initial(60),
  4   258 	 chain_op			initial(61),
  4   259 	 endunit_op		initial(62),
  4   260 	 non_executable		initial(63),
  4   261 	 no_op			initial(64),
  4   262 	 form_VLA_packed_ptr_op	initial(65),
  4   263 	 opt_subscript_op		initial(66),
  4   264 	 left_shift_op		initial(67),
  4   265 	 right_shift_op		initial(68),
  4   266 	 store_zero_op		initial(69),
  4   267 	 storage_add_op		initial(70),
  4   268 	 storage_sub_op		initial(71),
  4   269 	 neg_storage_add_op		initial(72),
  4   270 	 storage_add_one_op		initial(73),
  4   271 	 namelist_op		initial(74),
  4   272 	 open_op			initial(75),
  4   273 	 close_op			initial(76),
  4   274 	 iostat_op		initial(77),
  4   275 	 convert_to_int_op		initial(78),
  4   276 	 convert_to_real_op		initial(79),
  4   277 	 convert_to_dp_op		initial(80),
  4   278 	 convert_to_cmpx_op		initial(81),
  4   279 	 read_scalar_op		initial(82),
  4   280 	 read_array_op		initial(83),
  4   281 	 read_vector_op		initial(84),
  4   282 	 write_scalar_op		initial(85),
  4   283 	 write_array_op		initial(86),
  4   284 	 write_vector_op		initial(87),
  4   285 	 jump_true_op		initial(88),
  4   286 	 jump_false_op		initial(89),
  4   287 	 sub_index_op		initial(90),
  4   288 	 loop_end_op		initial(91),
  4   289 	 read_namelist_op		initial(92),
  4   290 	 write_namelist_op		initial(93),
  4   291 	 decode_string_op		initial(94),
  4   292 	 encode_string_op		initial(95),
  4   293 	 cat_op			initial(96),
  4   294 	 substr_op		initial(97),
  4   295 	 load_xreg_op		initial(98),
  4   296 	 load_preg_op		initial(99),
  4   297 	 block_if_op		initial(100),
  4   298 	 else_if_op		initial(101),
  4   299 	 else_op			initial(102),
  4   300 	 equiv_op			initial (103),
  4   301 	 not_equiv_op		initial (104),
  4   302 	 read_internal_file_op	initial (105),
  4   303 	 write_internal_file_op	initial (106),
  4   304 	 inquire_op		initial (107),
  4   305 	 process_param_list_op	initial (108),
  4   306 	 lhs_fld_op		initial (109),
  4   307 	 last_assigned_op		initial (109))  fixed bin(18) internal static options(constant);
  4   308 
  4   309 /* END   fort_system_constants.incl.pl1 */
      401 
  5     1 /* BEGIN fort_nodes.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(86-07-14,BWong), approve(86-07-14,MCR7382), audit(86-07-17,Ginter),
  5     7*     install(86-07-28,MR12.0-1105):
  5     8*     Fix fortran bug 473.
  5     9*  2) change(88-04-28,RWaters), approve(88-04-28,MCR7875), audit(88-07-13,Huen),
  5    10*     install(88-11-10,MR12.2-1209):
  5    11*     Implement SCP 6339: Allow character variable to be up to 128K-1 (131071)
  5    12*     character long.
  5    13*                                                   END HISTORY COMMENTS */
  5    14 
  5    15 
  5    16 /* Written: June 1976 by David Levin and Richard Barnes
  5    17*
  5    18*Modified:
  5    19*	Feb 24 1977 by G. Chang for the optimizer
  5    20*	Sept 12, 1977 by R. Barnes for the loop optimizer
  5    21*	Nov 16, 1977 by D. Levin to add machine state node for loop optimizer
  5    22*	Oct 09 1978 by P Smee for larger common and arrays.
  5    23*	Dec 05 1978 by P Smee for %options statement.
  5    24*	Jan 17 1979 by R Barnes for machine_state.value_in_xr
  5    25*	May 23 1979 by P Smee to add source.line_number
  5    26*	July 19 1979 by R Barnes for char mode changes
  5    27*	Sept 17 1979 by R Barnes for register optimizer changes
  5    28*	Oct 3 1979 by C R Davis for new EAQ management scheme.
  5    29*	29 Oct 1979 by C R Davis for machine_state.eaq.reserved.
  5    30*	3 Nov 1979 by R. Barnes for pointer node and to change
  5    31*		machine_state.next from a fixed bin to a pointer.
  5    32*	18 Dec 1979 by R. Barnes for loop_ref_count to finalize
  5    33*		changes for the register optimizer.
  5    34*	17 Dec 1979 by C R Davis for symbol.descriptor
  5    35*	22 Dec 1979 by R. Barnes to remove in_list.
  5    36*	22 Jan 1980 by P E Smee to try for long char arrays.
  5    37*	23 Jan 1980 by C R Davis to fix bugs with yesterday's changes.
  5    38*	4 Mar 1980 by C R Davis to rename node.multi_position to
  5    39*		node.stack_indirect, and to add machine_state.stack_extended
  5    40*		and machine_state.last_dynamic_temp.
  5    41*	5 Jun 1980 by M E Presser to alter arg_desc node for use
  5    42*		in stack-extensions and arg-descriptor generation.
  5    43*	16 July 1980 by C R Davis for symbol.variable_arglist.
  5    44*	8 Jan 81 by M E Presser for label.not_referencable
  5    45*	17 Feb 1981 by C R Davis for new dimension node layout.
  5    46*	11 March 1981 by MEP for dimension.assumed_size
  5    47*	 3 May   1982 by TO to add star_extent_function to subprogram node.
  5    48* Mod 1	25 August 1982 by TO to add VLA_chain and LA_chain to subprogram node.
  5    49* Mod 1     2 September 1982 by TO to add 5 more entries to storage_info in
  5    50*	     the subprogram node (13-17), and to add VLA and LA bits to the
  5    51*	     symbol node.
  5    52* Mod 1	 2 September 1982 by TO move fields around in nodes to get correct
  5    53*	     24 (really 35) bit fields and still maintain mapping between
  5    54*	     node, temporary, and array_ref (others limit to word 6 like node.)
  5    55*	19 Jun 83, HH - 145: Add 'branched_to', 'ends_do_loop' & 'loop_end'
  5    56*		to 'label' node.
  5    57*	19 Feb 86, BW & AG - 473.a: Add 'VLA' to 'arg_desc' node.
  5    58*END Modifications */
  5    59 
  5    60 
  5    61 	/* GENERAL NODE TEMPLATE */
  5    62 
  5    63 dcl	1 node			aligned based structure,
  5    64 
  5    65 	/* WORD 1 */
  5    66 
  5    67 	  2 node_type		fixed bin (4) unaligned,
  5    68 	  2 data_type		fixed bin (4) unaligned unsigned,
  5    69 	  2 operand_type		fixed bin (4) unaligned,
  5    70 
  5    71 	  2 addressing_bits		unaligned structure,
  5    72 	    3 is_addressable	bit (1),
  5    73 	    3 value_in,
  5    74 	      4 eaq		bit (1),
  5    75 	      4 x			bit (1),
  5    76 	    3 allocated		bit (1),
  5    77 	    3 needs_pointer		bit (1),
  5    78 	    3 stack_indirect	bit (1),
  5    79 	    3 large_address		bit (1),
  5    80 	    3 address_in_base	bit (1),
  5    81 	    3 dont_update		bit (1),		/* for optimizer */
  5    82 	    3 not_in_storage	bit (1),		/* for optimizer */
  5    83 	    3 globally_assigned	bit (1),		/* for optimizer */
  5    84 
  5    85 	  2 bits			unaligned structure,
  5    86 	    3 standard_bits,
  5    87 	      4 allocate		bit (1),
  5    88 	      4 set		bit (1),
  5    89 	      4 referenced		bit (1),
  5    90 	      4 passed_as_arg	bit (1),
  5    91 
  5    92 	    3 fill		bit (7),		/* These bits may be used by individual nodes. */
  5    93 
  5    94 	/* WORD 2 */
  5    95 
  5    96 	  2 address		aligned structure,
  5    97 	    3 base		bit (3) unaligned,	     /* For labels and constants, base and offset are */
  5    98 	    3 offset		fixed bin (14) unaligned, /* combined to: fixed bin (18) unsigned unaligned. */
  5    99 	    3 char_num		fixed bin (2) unaligned unsigned,
  5   100 	    3 bit_num		fixed bin (4) unaligned unsigned,
  5   101 	    3 fill		bit (4) unaligned,
  5   102 	    3 inhibit		bit (1) unaligned,
  5   103 	    3 ext_base		bit (1) unaligned,
  5   104 	    3 tag			bit (6) unaligned,
  5   105 
  5   106 	/* WORD 3 */
  5   107 
  5   108 	  2 units			fixed bin (3) unaligned unsigned,
  5   109 	  2 fill			bit (3) unaligned,	/* already used in symbol node */
  5   110 	  2 reloc_hold		bit (6) unaligned,
  5   111 	  2 reloc			bit (6) unaligned,
  5   112 	  2 addr_hold		bit (18) unaligned,
  5   113 
  5   114 	/* WORD 4. Must not change for constant, char_constant, header, label, or symbol nodes. */
  5   115 
  5   116 	  2 next			fixed bin (18) unsigned unaligned,
  5   117 	  2 hash_chain		fixed bin (18) unsigned unaligned, /* No hash chain for header nodes. */
  5   118 
  5   119 	/* WORD 5 */
  5   120 
  5   121 	  2 pad			fixed bin (18) unsigned unaligned,
  5   122 	  2 loop_ref_count		fixed bin (17) unaligned,	/* Only for symbols and temporaries. */
  5   123 
  5   124 	/* WORD 6 */
  5   125 
  5   126 	  2 location		fixed bin (24) aligned;       /* Only for array refs, symbols, temporaries, and headers. */
  5   127 
  5   128 	/* ARG DESCRIPTOR NODE */
  5   129 
  5   130 dcl	1 arg_desc		based aligned,
  5   131 
  5   132 	/* WORD 1 */
  5   133 
  5   134 	  2 node_type		fixed bin (4) unaligned,
  5   135 	  2 n_args		fixed bin (12) unaligned,
  5   136 	  2 pad			bit (18) unaligned,
  5   137 
  5   138 	/* WORDS 2 - N_ARGS + 1 */
  5   139 
  5   140 	  2 arg(num_args refer(n_args))	aligned,
  5   141 	    3 data_type		fixed bin (4) unaligned unsigned,
  5   142 	    3 must_be		unaligned,
  5   143 	      4 array		bit (1) unaligned,
  5   144 	      4 scalar		bit (1) unaligned,
  5   145 	      4 VLA		bit (1) unaligned,
  5   146 	    3 star_extents		bit (1) unaligned,
  5   147 	    3 pad			bit (9) unaligned,
  5   148 	    3 symbol		fixed bin (18) unaligned;
  5   149 
  5   150 dcl	num_args fixed bin;
  5   151 
  5   152 
  5   153 	/*  ARRAY REF NODE -- Must be same size as TEMPORARY NODE.  */
  5   154 
  5   155 dcl	1 array_ref		aligned based structure,
  5   156 
  5   157 	/* WORD 1 */
  5   158 
  5   159 	  2 node_type		fixed bin (4) unaligned,
  5   160 	  2 data_type		fixed bin (4) unaligned unsigned,
  5   161 	  2 operand_type		fixed bin (4) unaligned,
  5   162 
  5   163 	  2 addressing_bits		unaligned structure,
  5   164 	    3 is_addressable	bit (1),
  5   165 	    3 value_in,
  5   166 	      4 eaq		bit (1),
  5   167 	      4 x			bit (1),
  5   168 	    3 allocated		bit (1),
  5   169 	    3 needs_pointer		bit (1),
  5   170 	    3 stack_indirect	bit (1),
  5   171 	    3 large_address		bit (1),
  5   172 	    3 address_in_base	bit (1),
  5   173 	    3 dont_update		bit (1),		/* for optimizer */
  5   174 	    3 not_in_storage	bit (1),		/* for optimizer */
  5   175 	    3 globally_assigned	bit (1),		/* for optimizer */
  5   176 
  5   177 	  2 bits			unaligned structure,
  5   178 	    3 standard_bits,
  5   179 	      4 allocate		bit (1),
  5   180 	      4 set		bit (1),
  5   181 	      4 referenced		bit (1),
  5   182 	      4 passed_as_arg	bit (1),
  5   183 
  5   184 	    3 variable_length	bit (1),
  5   185 
  5   186 	    3 variable_offset	bit (1),
  5   187 
  5   188 	    3 invariant		bit (1),	/* must line up with temporary node */
  5   189 	    3 irreducible		bit (1),	/* .. */
  5   190 	    3 used_across_loops	bit (1),	/* .. */
  5   191 
  5   192 	    3 large_offset		bit (1),
  5   193 
  5   194 	    3 has_address		bit (1),
  5   195 
  5   196 	/* WORD 2 */
  5   197 
  5   198 	  2 address		aligned structure,
  5   199 	    3 base		bit (3) unaligned,
  5   200 	    3 offset		fixed bin (14) unaligned,
  5   201 	    3 char_num		fixed bin (2) unaligned unsigned,
  5   202 	    3 bit_num		fixed bin (4) unaligned unsigned,
  5   203 	    3 fill		bit (4) unaligned,
  5   204 	    3 inhibit		bit (1) unaligned,
  5   205 	    3 ext_base		bit (1) unaligned,
  5   206 	    3 tag			bit (6) unaligned,
  5   207 
  5   208 	/* WORD 3 */
  5   209 
  5   210 	  2 units			fixed bin (3) unaligned unsigned,
  5   211 	  2 fill			bit (3) unaligned,
  5   212 	  2 reloc_hold		bit (6) unaligned,
  5   213 	  2 reloc			bit (6) unaligned,
  5   214 	  2 addr_hold		bit (18) unaligned,
  5   215 
  5   216 	/* WORD 4 */
  5   217 
  5   218 	  2 next			fixed bin (18) unsigned unaligned,
  5   219 	  2 loop_end_fu_pos		fixed bin (17) unaligned,	/* must overlay temporary.loop_end_fu_pos */
  5   220 
  5   221 	/* WORD 5 */
  5   222 
  5   223 	  2 pad			fixed bin (18) unsigned unaligned,
  5   224 	  2 v_offset		fixed bin (18) unsigned unaligned,
  5   225 
  5   226 	/* WORD 6 */
  5   227 
  5   228 	  2 location		fixed bin (24) aligned,
  5   229 
  5   230 	/* WORD 7 */
  5   231 
  5   232 	  2 ref_count		fixed bin (17) unaligned,	/* must overlay temporary.ref_count */
  5   233 	  2 output_by		fixed bin (18) unsigned unal,		/* must overlay temporary.output_by */
  5   234 
  5   235 	/* WORD 8 */
  5   236 
  5   237 	  2 length		fixed bin (24) aligned,
  5   238 
  5   239 	/* WORD 9 */
  5   240 
  5   241 	  2 start_input_to 		fixed bin (18) unsigned unal,		/* must overlay temporary.start_input_to */
  5   242 	  2 end_input_to		fixed bin (18) unsigned unal,		/* must overlay temporary.end_input_to */
  5   243 
  5   244 	/* WORD 10 */
  5   245 
  5   246 	  2 ref_count_copy		fixed bin (17) unaligned,	/* must overlay temporary.ref_count_copy */
  5   247 	  2 parent		fixed bin (18) unsigned unaligned,
  5   248 
  5   249 	/* WORD 11 */
  5   250 
  5   251             2 unused                    fixed bin (24) aligned;	/*  Pad to size of 'temporary'.  */
  5   252 
  5   253 
  5   254 	/* CONSTANT NODE */
  5   255 
  5   256 dcl	1 constant		aligned based structure,
  5   257 
  5   258 	/* WORD 1 */
  5   259 
  5   260 	  2 node_type		fixed bin (4) unaligned,
  5   261 	  2 data_type		fixed bin (4) unaligned unsigned,
  5   262 	  2 operand_type		fixed bin (4) unaligned,
  5   263 
  5   264 	  2 addressing_bits		unaligned structure,
  5   265 	    3 is_addressable	bit (1),
  5   266 	    3 value_in,
  5   267 	      4 eaq		bit (1),
  5   268 	      4 x			bit (1),
  5   269 	    3 allocated		bit (1),
  5   270 	    3 needs_pointer		bit (1),
  5   271 	    3 stack_indirect	bit (1),
  5   272 	    3 large_address		bit (1),
  5   273 	    3 address_in_base	bit (1),
  5   274 	    3 dont_update		bit (1),		/* for optimizer */
  5   275 	    3 not_in_storage	bit (1),		/* for optimizer */
  5   276 	    3 globally_assigned	bit (1),		/* for optimizer */
  5   277 
  5   278 	  2 bits			unaligned structure,
  5   279 	    3 standard_bits,
  5   280 	      4 allocate		bit (1),
  5   281 	      4 set		bit (1),
  5   282 	      4 referenced		bit (1),
  5   283 	      4 passed_as_arg	bit (1),
  5   284 
  5   285 	    3 fill		bit (7),
  5   286 
  5   287 	/* WORD 2 */
  5   288 
  5   289 	  2 address		aligned structure,
  5   290 	    3 location		fixed bin (18) unsigned unaligned,
  5   291 	    3 op			bit (10) unaligned,
  5   292 	    3 inhibit		bit (1) unaligned,
  5   293 	    3 ext_base		bit (1) unaligned,
  5   294 	    3 tag			bit (6) unaligned,
  5   295 
  5   296 	/* WORD 3 */
  5   297 
  5   298 	  2 units			fixed bin (3) unaligned unsigned,
  5   299 	  2 fill			bit (3) unaligned,
  5   300 	  2 reloc_hold		bit (6) unaligned,
  5   301 	  2 reloc			bit (6) unaligned,
  5   302 	  2 addr_hold		bit (18) unaligned,
  5   303 
  5   304 	/* WORD 4 */
  5   305 
  5   306 	  2 next_constant		fixed bin (18) unsigned unaligned,
  5   307 	  2 hash_chain		fixed bin (18) unsigned unaligned,
  5   308 
  5   309 	/* WORDS 5 & 6 */
  5   310 
  5   311 	  2 value			bit (72) aligned;
  5   312 
  5   313 
  5   314 	/* CHARACTER CONSTANT NODE */
  5   315 
  5   316 dcl	1 char_constant		aligned based structure,
  5   317 
  5   318 	/* WORD 1 */
  5   319 
  5   320 	  2 node_type		fixed bin (4) unaligned,
  5   321 	  2 data_type		fixed bin (4) unaligned unsigned,
  5   322 	  2 operand_type		fixed bin (4) unaligned,
  5   323 
  5   324 	  2 addressing_bits		unaligned structure,
  5   325 	    3 is_addressable	bit (1),
  5   326 	    3 value_in,
  5   327 	      4 eaq		bit (1),
  5   328 	      4 x			bit (1),
  5   329 	    3 allocated		bit (1),
  5   330 	    3 needs_pointer		bit (1),
  5   331 	    3 stack_indirect	bit (1),
  5   332 	    3 large_address		bit (1),
  5   333 	    3 address_in_base	bit (1),
  5   334 	    3 dont_update		bit (1),		/* for optimizer */
  5   335 	    3 not_in_storage	bit (1),		/* for optimizer */
  5   336 	    3 globally_assigned	bit (1),		/* for optimizer */
  5   337 
  5   338 	  2 bits			unaligned structure,
  5   339 	    3 standard_bits,
  5   340 	      4 allocate		bit (1),
  5   341 	      4 set		bit (1),
  5   342 	      4 referenced		bit (1),
  5   343 	      4 passed_as_arg	bit (1),
  5   344 
  5   345 	    3 no_value_stored	bit (1),
  5   346 
  5   347 	    3 fill		bit (6),
  5   348 
  5   349 	/* WORD 2 */
  5   350 
  5   351 	  2 address		aligned structure,
  5   352 	    3 location		fixed bin (18) unsigned unaligned,
  5   353 	    3 char_num		fixed bin (2) unaligned unsigned,
  5   354 	    3 bit_num		fixed bin (4) unaligned unsigned,
  5   355 	    3 fill		bit (4) unaligned,
  5   356 	    3 inhibit		bit (1) unaligned,
  5   357 	    3 ext_base		bit (1) unaligned,
  5   358 	    3 tag			bit (6) unaligned,
  5   359 
  5   360 	/* WORD 3 */
  5   361 
  5   362 	  2 units			fixed bin (3) unaligned unsigned,
  5   363 	  2 fill			bit (3) unaligned,
  5   364 	  2 reloc_hold		bit (6) unaligned,
  5   365 	  2 reloc			bit (6) unaligned,
  5   366 	  2 addr_hold		bit (18) unaligned,
  5   367 
  5   368 	/* WORD 4 */
  5   369 
  5   370 	  2 next_constant		fixed bin (18) unsigned unaligned,
  5   371 	  2 hash_chain		fixed bin (18) unsigned unaligned,
  5   372 
  5   373 	/* WORDS 5 thru n */
  5   374 
  5   375 	  2 length		fixed bin (18) unsigned unaligned,
  5   376 	  2 value			char(char_constant_length refer(char_constant.length)) unaligned;
  5   377 
  5   378 dcl	char_constant_length	fixed bin (18) unsigned;
  5   379 
  5   380 
  5   381 	/* DIMENSION NODE */
  5   382 
  5   383 dcl	1 dimension		aligned based structure,
  5   384 
  5   385 	/* WORD 1 */
  5   386 
  5   387 	  2 node_type 		fixed bin (4) unaligned,	/* The only field in common with other nodes */
  5   388 
  5   389 	  2 number_of_dims		fixed bin (3) unaligned,	/* Number of dimensions */
  5   390 
  5   391 	  2 v_bound		(7) unaligned,		/* Variable bound info - up to 7 dims. */
  5   392 	    3 lower		bit (1) unaligned,		/* On if lower bound is variable */
  5   393 	    3 upper		bit (1) unaligned,		/* On if upper bound is variable */
  5   394 
  5   395 	  2 has_virtual_origin	bit (1) unaligned,		/* On if virtual_origin is valid */
  5   396 	  2 has_array_size		bit (1) unaligned,		/* On if array_size is valid */
  5   397 	  2 has_dim_sizes		bit (1) unaligned,		/* On if dim.size (*) is valid */
  5   398 
  5   399 	  2 variable_virtual_origin	bit (1) unaligned,		/* On if virtual_origin is variable */
  5   400 	  2 variable_array_size	bit (1) unaligned,		/* On if array_size is variable */
  5   401 	  2 assumed_size		bit (1) unaligned,		/* On if array has assumed size */
  5   402 
  5   403 	  2 fill			bit (7) unaligned,
  5   404 
  5   405 	/* WORD 2 */
  5   406 
  5   407 	  2 virtual_origin		fixed bin (24) aligned,
  5   408 
  5   409 	/* WORD 3 */
  5   410 
  5   411 	  2 element_count		fixed bin (24) aligned,
  5   412 
  5   413 	/* WORD 4 */
  5   414 
  5   415 	  2 array_size		fixed bin (24) aligned,	/* Expressed in symbol.units */
  5   416 
  5   417 	/* WORD 5 */
  5   418 
  5   419 	  2 VLA_base_addressor	fixed bin (18) aligned,
  5   420 
  5   421 	/* WORDS 6 - n (max = 26) */
  5   422 
  5   423 	  2 dim (num_dims refer (dimension.number_of_dims)) aligned,
  5   424 
  5   425 	    3 lower_bound		fixed bin (24) aligned,	/* Lower bound of this dimension */
  5   426 
  5   427 	    3 upper_bound		fixed bin (24) aligned,	/* Upper bound of this dimension */
  5   428 
  5   429 	    3 size		fixed bin (24) aligned;	/* No. of elements in this dimension */
  5   430 
  5   431 dcl	num_dims			fixed bin (3);
  5   432 
  5   433 
  5   434 	/* HEADER NODE */
  5   435 
  5   436 dcl	1 header			aligned based structure,
  5   437 
  5   438 	/* WORD 1 */
  5   439 
  5   440 	  2 node_type		fixed bin (4) unaligned,
  5   441 	  2 data_type		fixed bin (4) unaligned unsigned,
  5   442 	  2 operand_type		fixed bin (4) unaligned,
  5   443 
  5   444 	  2 addressing_bits		unaligned structure,
  5   445 	    3 is_addressable	bit (1),
  5   446 	    3 value_in,
  5   447 	      4 eaq		bit (1),
  5   448 	      4 x			bit (1),
  5   449 	    3 allocated		bit (1),
  5   450 	    3 needs_pointer		bit (1),
  5   451 	    3 stack_indirect	bit (1),
  5   452 	    3 large_address		bit (1),
  5   453 	    3 address_in_base	bit (1),
  5   454 	    3 dont_update		bit (1),		/* for optimizer */
  5   455 	    3 not_in_storage	bit (1),		/* for optimizer */
  5   456 	    3 globally_assigned	bit (1),		/* for optimizer */
  5   457 
  5   458 	  2 bits			unaligned structure,
  5   459 	    3 storage_info,
  5   460 	      4 standard_bits,
  5   461 		5 allocate	bit (1),
  5   462 		5 set		bit (1),
  5   463 		5 referenced	bit (1),
  5   464 		5 passed_as_arg	bit (1),
  5   465 	      4 initialed		bit (1),		/* On if any member has initial attribute. */
  5   466 
  5   467 	    3 alignment		structure unaligned,
  5   468 	      4 even		bit (1),
  5   469 	      4 odd		bit (1),
  5   470 	      4 character		bit (1),
  5   471 
  5   472 	    3 storage_class		structure unaligned,
  5   473 	      4 automatic		bit (1),
  5   474 	      4 static		bit (1),
  5   475 	      4 in_common		bit (1),
  5   476 
  5   477 	/* WORD 2 */
  5   478 
  5   479 	  2 address		aligned structure,
  5   480 	    3 base		bit (3) unaligned,
  5   481 	    3 offset		fixed bin (14) unaligned,
  5   482 	    3 char_num		fixed bin (2) unaligned unsigned,
  5   483 	    3 bit_num		fixed bin (4) unaligned unsigned,
  5   484 	    3 fill		bit (4) unaligned,
  5   485 	    3 inhibit		bit (1) unaligned,
  5   486 	    3 ext_base		bit (1) unaligned,
  5   487 	    3 tag			bit (6) unaligned,
  5   488 
  5   489 	/* WORD 3 */
  5   490 
  5   491 	  2 units			fixed bin (3) unaligned unsigned,
  5   492 	  2 VLA bit (1) unaligned,			/* chain for VLA's */
  5   493 	  2 LA bit (1) unaligned,			/* chain for LA's */
  5   494 	  2 fill bit (1) unaligned,
  5   495 	  2 reloc_hold		bit (6) unaligned,
  5   496 	  2 reloc			bit (6) unaligned,
  5   497 	  2 addr_hold		bit (18) unaligned,
  5   498 
  5   499 	/* WORD 4 */
  5   500 
  5   501 	  2 next_header		fixed bin (18) unsigned unaligned,
  5   502 	  2 first_element		fixed bin (18) unsigned unaligned,
  5   503 
  5   504 	/* WORD 5 */
  5   505 
  5   506 	  2 last_element		fixed bin (18) unsigned unaligned,
  5   507 	  2 name_length		fixed bin (17) unaligned,
  5   508 
  5   509 	/* WORD 6 */
  5   510 
  5   511 	  2 location		fixed bin (24) aligned,
  5   512 
  5   513 	/* WORD 7 */
  5   514 
  5   515 	  2 length		fixed bin (24) aligned,
  5   516 
  5   517 	/* WORD 8 */
  5   518 
  5   519 	  2 VLA_base_addressor	fixed bin (18) aligned,
  5   520 
  5   521 	/* WORDS 9 - n. This field is variable in length. Its length is zero for equivalence groups. */
  5   522 
  5   523 	  2 block_name		char(allocate_symbol_name refer (header.name_length)) aligned;
  5   524 
  5   525 dcl	allocate_symbol_name	fixed bin;
  5   526 
  5   527 
  5   528 	/* LABEL NODE */
  5   529 
  5   530 dcl	1 label			aligned based structure,
  5   531 
  5   532 	/* WORD 1 */
  5   533 
  5   534 	  2 node_type		fixed bin (4) unaligned,
  5   535 	  2 data_type		fixed bin (4) unaligned unsigned,
  5   536 	  2 operand_type		fixed bin (4) unaligned,
  5   537 
  5   538 	  2 addressing_bits		unaligned structure,
  5   539 	    3 is_addressable	bit (1),
  5   540 	    3 value_in,
  5   541 	      4 eaq		bit (1),
  5   542 	      4 x			bit (1),
  5   543 	    3 allocated		bit (1),
  5   544 	    3 needs_pointer		bit (1),
  5   545 	    3 stack_indirect	bit (1),
  5   546 	    3 large_address		bit (1),
  5   547 	    3 address_in_base	bit (1),
  5   548 	    3 dont_update		bit (1),		/* for optimizer */
  5   549 	    3 not_in_storage	bit (1),		/* for optimizer */
  5   550 	    3 globally_assigned	bit (1),		/* for optimizer */
  5   551 
  5   552 	  2 bits			unaligned structure,
  5   553 	    3 storage_info,
  5   554 	      4 standard_bits,
  5   555 		5 allocate	bit (1),
  5   556 		5 set		bit (1),
  5   557 		5 referenced	bit (1),
  5   558 		5 passed_as_arg	bit (1),
  5   559 	      4 referenced_executable bit (1),
  5   560 
  5   561 	    3 usage,	/* Label is on a non-executable stmnt if both bits are ON. */
  5   562 	      4 format		bit (1),
  5   563 	      4 executable		bit (1),
  5   564 
  5   565 	    3 restore_prs		bit (1),
  5   566 	    3 not_referencable	bit (1),
  5   567 	    3 branched_to		bit (1),
  5   568 	    3 ends_do_loop		bit (1),
  5   569 
  5   570 	/* WORD 2 */
  5   571 
  5   572 	  2 address		aligned structure,
  5   573 	    3 location		fixed bin (18) unsigned unaligned,
  5   574 	    3 op			bit (10) unaligned,
  5   575 	    3 inhibit		bit (1) unaligned,
  5   576 	    3 ext_base		bit (1) unaligned,
  5   577 	    3 tag			bit (6) unaligned,
  5   578 
  5   579 	/* WORD 3 */
  5   580 
  5   581 	  2 units			fixed bin (3) unaligned unsigned,
  5   582 	  2 fill			bit (3) unaligned,
  5   583 	  2 reloc_hold		bit (6) unaligned,
  5   584 	  2 reloc			bit (6) unaligned,
  5   585 	  2 addr_hold		bit (18) unaligned,
  5   586 
  5   587 	/* WORD 4 */
  5   588 
  5   589 	  2 next_label		fixed bin (18) unsigned unaligned,
  5   590 	  2 hash_chain		fixed bin (18) unsigned unaligned,
  5   591 
  5   592 	/* WORD 5 */
  5   593 
  5   594 	  2 format_var		fixed bin (18) unsigned unaligned,
  5   595 	  2 name			fixed bin (17) unaligned,
  5   596 
  5   597 	/* WORD 6 */
  5   598 
  5   599 	  2 statement		fixed bin (18) unsigned unaligned,
  5   600 	  2 loop_end		fixed bin (18) unsigned unaligned;
  5   601 
  5   602 
  5   603 	/*  LIBRARY NODE  */
  5   604 
  5   605 dcl	1 library			aligned based structure,
  5   606 
  5   607 	/* WORD 1 */
  5   608 
  5   609 	  2 node_type		fixed bin (4) unaligned, /* The only field in common with the other nodes. */
  5   610 	  2 fill 			bit (13) unaligned,
  5   611 	  2 next_library_node	fixed bin (18) unsigned unaligned,
  5   612 
  5   613 	/* WORD 2 */
  5   614 
  5   615 	  2 character_operand	fixed bin (18) unsigned aligned;
  5   616 
  5   617 
  5   618 	/* MACHINE_STATE NODE */
  5   619 
  5   620 dcl	1 machine_state		aligned based structure,
  5   621 
  5   622 	/* WORD 1 */
  5   623 
  5   624 	  2 node_type		fixed bin (4) unal,
  5   625 	  2 pad			bit (31) unal,
  5   626 
  5   627 	/* WORD 2 */
  5   628 
  5   629 	  2 next			pointer unaligned,
  5   630 
  5   631 	/* WORDS 3-104 */
  5   632 
  5   633 	  2 ms			aligned,
  5   634 
  5   635 	    3 eaq (4),				/* One for each of the A, Q, EAQ, and IND */
  5   636 	      4 name		fixed bin,
  5   637 	      4 number		fixed bin,
  5   638 	      4 variable(4)		fixed bin (18),
  5   639 	      4 reserved		bit (1) aligned,
  5   640 	    3 rounded		bit (1) aligned,
  5   641 	    3 indicators_valid	fixed bin (18),
  5   642 
  5   643 	    3 value_in_xr		bit (1) aligned,
  5   644 
  5   645 	    3 index_regs(0:7),
  5   646 	      4 bits		structure unaligned,
  5   647 	        5 global		bit (1),
  5   648 	        5 reserved		bit (1),
  5   649 	        5 mbz		bit (34),
  5   650 	      4 type		fixed bin (18),
  5   651 	      4 variable		fixed bin (18),
  5   652 	      4 used		fixed bin (18),
  5   653 	      4 mbz		fixed bin (18),
  5   654 
  5   655 	    3 address_in_base	bit (1) aligned,
  5   656 
  5   657 	    3 base_regs(0:7),
  5   658 	      4 bits		structure unaligned,
  5   659 	        5 global		bit (1),
  5   660 	        5 reserved		bit (1),
  5   661 	        5 mbz		bit (34),
  5   662 	      4 type		fixed bin (18),
  5   663 	      4 variable		fixed bin (18),
  5   664 	      4 used		fixed bin (18),
  5   665 	      4 offset		fixed bin (18),
  5   666 
  5   667 	    3 stack_extended	bit (1) aligned,
  5   668 	    3 last_dynamic_temp	fixed bin (18);
  5   669 
  5   670 	/* POINTER NODE */
  5   671 
  5   672 dcl	1 pointer			aligned based structure,
  5   673 
  5   674 	/* WORD 1 */
  5   675 
  5   676 	  2 node_type		fixed bin (4) unaligned,
  5   677 	  2 pad			bit (4) unaligned,
  5   678 	  2 code			fixed bin (9) unaligned unsigned,
  5   679 	  2 variable		fixed bin (18) unaligned unsigned,
  5   680 
  5   681 	/* WORD 2 */
  5   682 
  5   683 	  2 offset		fixed bin (18) unaligned unsigned,
  5   684 	  2 count			fixed bin (18) unaligned unsigned,
  5   685 
  5   686 	/* WORD 3 */
  5   687 
  5   688 	  2 hash_chain		fixed bin (18) aligned;
  5   689 
  5   690 
  5   691 	/* SOURCE NODE */
  5   692 
  5   693 dcl	1 source			aligned based structure,
  5   694 
  5   695 	/* WORD 1 */
  5   696 
  5   697 	  2 node_type		fixed bin (4) unal,
  5   698 	  2 pad			bit (13) unal,
  5   699 	  2 line_number		fixed bin (17) unaligned,
  5   700 
  5   701 	/* WORD 2 */
  5   702 
  5   703 	  2 uid			bit (36) aligned,
  5   704 
  5   705 	/* WORDS 3 & 4 */
  5   706 
  5   707 	  2 dtm			fixed bin (71) unaligned,
  5   708 
  5   709 	/* WORD 5 */
  5   710 
  5   711 	  2 next			fixed bin (18) unsigned unaligned,
  5   712 	  2 initial_subprogram	fixed bin (18) unsigned unaligned,
  5   713 
  5   714 	/* WORDS 6 - ? (depends on length of pathname) */
  5   715 
  5   716 	  2 pathname		char(256) varying;
  5   717 
  5   718 
  5   719 	/* STATEMENT NODE - This node only appears in the polish. */
  5   720 
  5   721 dcl	1 statement		aligned based structure,
  5   722 
  5   723 	/* WORD 1 */
  5   724 
  5   725 	  2 op_code		fixed bin aligned,	/* Always equal to "stat_op". */
  5   726 
  5   727 	/* WORD 2 */
  5   728 
  5   729 	  2 next			bit (18) unaligned,	/* "0"b = no next stmnt */
  5   730 	  2 location		bit (18) unaligned,	/* (18)"1"b = no text */
  5   731 
  5   732 	/* WORD 3 */
  5   733 
  5   734 	  2 source_id		structure unaligned,
  5   735 	    3 file		fixed bin (8) unsigned,	/* 0 = first file */
  5   736 	    3 line		bit (14),
  5   737 	    3 statement		bit (5),		/* 1 = first statement */
  5   738 
  5   739 	  2 length		bit (9) unaligned,
  5   740 
  5   741 	/* WORD 4 */
  5   742 
  5   743 	  2 bits			structure unaligned,
  5   744 	    3 put_in_map		bit (1) unaligned,
  5   745 	    3 put_in_profile	bit (1) unaligned,
  5   746 	    3 pad			bit (7) unaligned,
  5   747 
  5   748 	  2 start			fixed bin (26) unaligned;
  5   749 
  5   750 
  5   751 	/* SUBPROGRAM NODE */
  5   752 
  5   753 dcl	1 subprogram		aligned based structure,
  5   754 
  5   755 	/* WORD 1 */
  5   756 
  5   757 	  2 node_type		fixed bin (4) unaligned, /* The only field in common with the other nodes. */
  5   758 	  2 subprogram_type		fixed bin (3) unaligned,
  5   759 	  2 default_is		unaligned,
  5   760 	    3 auto		bit (1),
  5   761 	    3 static		bit (1),
  5   762 	  2 need_PS		bit (1) unaligned,
  5   763 	  2 need_prologue		bit (1) unaligned,
  5   764 	  2 multiple_entry		bit (1) unaligned,
  5   765 	  2 namelist_used		bit (1) unaligned,
  5   766 	  2 has_parameters		bit (1) unaligned,
  5   767 	  2 star_extent_function	bit (1) unaligned,
  5   768 	  2 fill			bit (1) unaligned,
  5   769 
  5   770 	  2 symbol		fixed bin (18) unsigned unaligned, /* symbol node for subprogram name */
  5   771 
  5   772 	/* WORD 2 */
  5   773 
  5   774 	  2 previous_subprogram	fixed bin (18) unsigned unaligned,
  5   775 	  2 next_subprogram		fixed bin (18) unsigned unaligned,
  5   776 
  5   777 	/* WORD 3 */
  5   778 
  5   779 	  2 common_chain		fixed bin (18) unsigned unaligned,
  5   780 	  2 equiv_chain		fixed bin (18) unsigned unaligned,
  5   781 
  5   782 	/* WORD 4 */
  5   783 
  5   784 	  2 first_symbol		fixed bin (18) unsigned unaligned,
  5   785 	  2 last_symbol		fixed bin (18) unsigned unaligned,
  5   786 
  5   787 	/* WORD 5 */
  5   788 
  5   789 	  2 first_label		fixed bin (18) unsigned unaligned,
  5   790 	  2 last_label		fixed bin (18) unsigned unaligned,
  5   791 
  5   792 	/* WORD 6 */
  5   793 
  5   794 	  2 first_polish		fixed bin (18) unsigned unaligned,
  5   795 	  2 last_polish		fixed bin (18) unsigned unaligned,
  5   796 
  5   797 	/* WORD 7 */
  5   798 
  5   799 	  2 map			unaligned,
  5   800 	    3 first		fixed bin (18) unsigned unaligned,
  5   801 	    3 last		fixed bin (18) unsigned unaligned,
  5   802 
  5   803 	/* WORD 8 */
  5   804 
  5   805 	  2 entry_info		fixed bin (18) unsigned unaligned,
  5   806 	  2 runtime		fixed bin (18) unsigned unaligned,
  5   807 
  5   808 	/* WORD 9 */
  5   809 
  5   810 	  2 first_quad		fixed bin (18) unsigned unaligned,
  5   811 	  2 last_quad		fixed bin (18) unsigned unaligned,
  5   812 
  5   813 	/* WORD 10 */
  5   814 
  5   815 	  2 options		aligned like fortran_options,
  5   816 
  5   817 	/* WORDS 11 - 44 */
  5   818 
  5   819 	  2 storage_info(17)	aligned,
  5   820 	    3 first		fixed bin (18) unsigned unaligned,
  5   821 	    3 last		fixed bin (18) unsigned unaligned,
  5   822 	    3 next_loc		fixed bin (18) aligned,
  5   823 
  5   824 	/* WORD 45 */
  5   825 
  5   826 	  2 loop_vector_p		pointer unaligned,
  5   827 
  5   828 	/* WORD 46 */
  5   829 
  5   830 	  2 n_loops		fixed bin (18) unsigned unaligned,
  5   831 	  2 max_operators		fixed bin (18) unsigned unaligned,
  5   832 
  5   833 	/* WORD 47 */
  5   834 
  5   835 	  2 VLA_chain		fixed bin (18) unsigned unaligned,  /* Mod 1 */
  5   836 	  2 LA_chain		fixed bin (18) unsigned unaligned,  /* Mod 1 */
  5   837 	/* WORD 48 */
  5   838 
  5   839 	  2 max_sym		fixed bin (18) aligned;
  5   840 
  5   841 
  5   842 	/* SYMBOL NODE */
  5   843 
  5   844 dcl	1 symbol			aligned based structure,
  5   845 
  5   846 	/* WORD 1 */
  5   847 
  5   848 	  2 node_type		fixed bin (4) unaligned,
  5   849 	  2 data_type		fixed bin (4) unaligned unsigned,
  5   850 	  2 operand_type		fixed bin (4) unaligned,
  5   851 
  5   852 	  2 addressing_bits		unaligned structure,
  5   853 	    3 is_addressable	bit (1),
  5   854 	    3 value_in,
  5   855 	      4 eaq		bit (1),
  5   856 	      4 x			bit (1),
  5   857 	    3 allocated		bit (1),
  5   858 	    3 needs_pointer		bit (1),
  5   859 	    3 stack_indirect	bit (1),
  5   860 	    3 large_address		bit (1),
  5   861 	    3 address_in_base 	bit (1),
  5   862 	    3 dont_update		bit (1),		/* for optimizer */
  5   863 	    3 not_in_storage	bit (1),		/* for optimizer */
  5   864 	    3 globally_assigned	bit (1),		/* for optimizer */
  5   865 
  5   866 	  2 bits			unaligned structure,
  5   867 	    3 storage_info,
  5   868 	      4 standard_bits,
  5   869 		5 allocate	bit (1),
  5   870 		5 set		bit (1),
  5   871 		5 referenced	bit (1),
  5   872 		5 passed_as_arg	bit (1),
  5   873 	      4 initialed		bit (1),		/* Allows variable to become a constant. */
  5   874 
  5   875 	    3 variable_arglist	bit (1),
  5   876 	    3 dummy_arg		bit (1),
  5   877 	    3 variable_extents	bit (1),
  5   878 	    3 needs_descriptors	bit (1),
  5   879 	    3 put_in_symtab		bit (1),
  5   880 	    3 by_compiler		bit (1),
  5   881 
  5   882 	/* WORD 2 */
  5   883 
  5   884 	  2 address		aligned structure,
  5   885 	    3 base		bit (3) unaligned,
  5   886 	    3 offset		fixed bin (14) unaligned,
  5   887 	    3 char_num		fixed bin (2) unaligned unsigned,
  5   888 	    3 bit_num		fixed bin (4) unaligned unsigned,
  5   889 	    3 fill		bit (4) unaligned,
  5   890 	    3 inhibit		bit (1) unaligned,
  5   891 	    3 ext_base		bit (1) unaligned,
  5   892 	    3 tag			bit (6) unaligned,
  5   893 
  5   894 	/* WORD 3 */
  5   895 
  5   896 	  2 units			fixed bin (3) unaligned unsigned,
  5   897 	  2 aliasable		bit (1) unaligned,
  5   898 	  2 has_constant_value	bit (1) unaligned,
  5   899 	  2 new_induction_var	bit (1) unaligned,
  5   900 	  2 reloc_hold		bit (6) unaligned,
  5   901 	  2 reloc			bit (6) unaligned,
  5   902 	  2 addr_hold		bit (18) unaligned,
  5   903 
  5   904 	/* WORD 4 */
  5   905 
  5   906 	  2 next_symbol		fixed bin (18) unsigned unaligned,
  5   907 	  2 hash_chain		fixed bin (18) unsigned unaligned,
  5   908 
  5   909 	/* WORD 5 */
  5   910 
  5   911 	  2 ext_attributes unaligned structure,
  5   912 	    3 VLA bit (1),				/* symbol is Very large Element */
  5   913 	    3 LA bit (1),				/* symbol is Large Element */
  5   914 	    3 pad bit (18-2),
  5   915 
  5   916 	  2 loop_ref_count		fixed bin (17) unaligned,
  5   917 
  5   918 	/* WORD 6 */
  5   919 
  5   920 	  2 location		fixed bin (24) aligned,
  5   921 
  5   922 	/* WORD 7 */
  5   923 
  5   924 	  2 v_length		fixed bin (18) unsigned unaligned,
  5   925 	  2 general		fixed bin (18) unsigned unaligned,
  5   926 
  5   927 	/* WORD 8 */
  5   928 
  5   929 	  2 parent		fixed bin (18) unsigned unaligned,
  5   930 	  2 next_member		fixed bin (18) unsigned unaligned,
  5   931 
  5   932 	/* WORD 9 */
  5   933 
  5   934 	  2 attributes		aligned structure,
  5   935 	    3 mode_bits		unaligned structure,
  5   936 	      4 char_size		fixed bin (20) unsigned,
  5   937 	      4 mode,
  5   938 	        5 integer		bit (1),
  5   939 	        5 real		bit (1),
  5   940 	        5 double_precision	bit (1),
  5   941 	        5 complex		bit (1),
  5   942 	        5 logical		bit (1),
  5   943 	        5 character		bit (1),
  5   944 	        5 label_value	bit (1),
  5   945 	        5 entry_value	bit (1),
  5   946 
  5   947 	    3 misc_attributes	unaligned structure,
  5   948 	      4 function		bit (1),
  5   949 	      4 subroutine		bit (1),
  5   950 	      4 entry_point		bit (1),
  5   951 	      4 external		bit (1),
  5   952 	      4 builtin		bit (1),
  5   953 	      4 stmnt_func		bit (1),
  5   954 	      4 namelist		bit (1),
  5   955 	      4 dimensioned		bit (1),
  5   956 
  5   957 	/* WORD 10 */
  5   958 
  5   959 	    3 storage_class		unaligned structure,
  5   960 	      4 automatic		bit (1),
  5   961 	      4 static		bit (1),
  5   962 	      4 in_common		bit (1),
  5   963 	      4 equivalenced	bit (1),
  5   964 	      4 parameter		bit (1),
  5   965 	      4 constant		bit (1),		/* If external or entry_point. */
  5   966 	      4 named_constant	bit (1),
  5   967 
  5   968 	    3 variable		bit (1) unaligned,
  5   969 	    3 in_equiv_stmnt	bit (1) unaligned,
  5   970 	    3 star_extents		bit (1) unaligned,
  5   971 	    3 descriptor		bit (1) unaligned,
  5   972 	  2 pad			bit (25) unaligned,
  5   973 
  5   974           /* WORD 11 */
  5   975 
  5   976 	  2 dimension		fixed bin (18) unsigned unaligned,	/* Bounds may be added after symbol is declared. */
  5   977 	  2 initial		fixed bin (18) unsigned unaligned,
  5   978 
  5   979           /* WORD 12 */
  5   980 
  5   981 	  2 runtime		bit (18) unaligned,
  5   982 	  2 name_length		fixed bin (17) unaligned,
  5   983 
  5   984           /* WORD 13 */
  5   985 
  5   986 	  2 coordinate		fixed bin (17) unaligned,	/* used by loop optimizer */
  5   987 	  2 element_size		fixed bin (17) unaligned,
  5   988 
  5   989           /* WORD 14 */
  5   990 
  5   991 	  2 secondary		pointer unaligned,		/* used by loop optimizer */
  5   992 
  5   993           /* WORD 15 */
  5   994 
  5   995 	  2 offset		fixed bin (24) aligned,
  5   996 
  5   997 	/* WORDS 16 - n. This field is variable in length. */
  5   998 
  5   999 	  2 name			char(allocate_symbol_name refer (symbol.name_length)) aligned;
  5  1000 
  5  1001 
  5  1002 
  5  1003 	/*  TEMPORARY NODE -- Must be same size as ARRAY REF NODE.  */
  5  1004 
  5  1005 dcl	1 temporary		aligned based structure,
  5  1006 
  5  1007 	/* WORD 1 */
  5  1008 
  5  1009 	  2 node_type		fixed bin (4) unaligned,
  5  1010 	  2 data_type		fixed bin (4) unaligned unsigned,
  5  1011 	  2 operand_type		fixed bin (4) unaligned,
  5  1012 
  5  1013 	  2 addressing_bits		unaligned structure,
  5  1014 	    3 is_addressable	bit (1),
  5  1015 	    3 value_in,
  5  1016 	      4 eaq		bit (1),
  5  1017 	      4 x			bit (1),
  5  1018 	    3 allocated		bit (1),
  5  1019 	    3 needs_pointer		bit (1),
  5  1020 	    3 stack_indirect	bit (1),
  5  1021 	    3 large_address		bit (1),
  5  1022 	    3 address_in_base	bit (1),
  5  1023 	    3 dont_update		bit (1),		/* for optimizer */
  5  1024 	    3 not_in_storage	bit (1),		/* for optimizer */
  5  1025 	    3 globally_assigned	bit (1),		/* for optimizer */
  5  1026 
  5  1027 	  2 bits			unaligned structure,
  5  1028 	    3 standard_bits,
  5  1029 	      4 allocate		bit (1),
  5  1030 	      4 set		bit (1),
  5  1031 	      4 referenced		bit (1),
  5  1032 	      4 passed_as_arg	bit (1),
  5  1033 
  5  1034 	    3 variable_length	bit (1),
  5  1035 
  5  1036 	    3 fill		bit (1),	/* can be used */
  5  1037 
  5  1038 	    3 invariant		bit (1),	/* must line up with array_ref node */
  5  1039 	    3 irreducible		bit (1),	/* .. */
  5  1040 	    3 used_across_loops	bit (1),	/* .. */
  5  1041 	    3 frozen_for_do		bit (1),
  5  1042 	    3 used_as_subscript	bit (1),
  5  1043 
  5  1044 	/* WORD 2 */
  5  1045 
  5  1046 	  2 address		aligned structure,
  5  1047 	    3 base		bit (3) unaligned,
  5  1048 	    3 offset		fixed bin (14) unaligned,
  5  1049 	    3 char_num		fixed bin (2) unaligned unsigned,
  5  1050 	    3 bit_num		fixed bin (4) unaligned unsigned,
  5  1051 	    3 fill		bit (4) unaligned,
  5  1052 	    3 inhibit		bit (1) unaligned,
  5  1053 	    3 ext_base		bit (1) unaligned,
  5  1054 	    3 tag			bit (6) unaligned,
  5  1055 
  5  1056 	/* WORD 3 */
  5  1057 
  5  1058 	  2 units			fixed bin (3) unaligned unsigned,
  5  1059 	  2 fill			bit (3) unaligned,
  5  1060 	  2 reloc_hold		bit (6) unaligned,
  5  1061 	  2 reloc			bit (6) unaligned,
  5  1062 	  2 addr_hold		bit (18) unaligned,
  5  1063 
  5  1064 	/* WORD 4 */
  5  1065 
  5  1066 	  2 next			fixed bin (18) unsigned unaligned,
  5  1067 	  2 loop_end_fu_pos		fixed bin (17) unaligned,	/* must overlay array_ref.loop_end_fu_pos */
  5  1068 
  5  1069 	/* WORD 5 */
  5  1070 
  5  1071 	  2 pad			fixed bin (18) unsigned unaligned,
  5  1072 	  2 loop_ref_count		fixed bin (17) unaligned,
  5  1073 
  5  1074 	/* WORD 6 */
  5  1075 
  5  1076 	  2 location		fixed bin (24) aligned,
  5  1077 
  5  1078 	/* WORD 7*/
  5  1079 
  5  1080 	  2 ref_count		fixed bin (17) unaligned,	/* must overlay array_ref.ref_count */
  5  1081 	  2 output_by		fixed bin (18) unsigned unal,		/* must overlay array_ref.output_by */
  5  1082 
  5  1083 	/* WORD 8 */
  5  1084 
  5  1085 	  2 size			fixed bin (24) aligned,		/* size in words */
  5  1086 
  5  1087 	/* WORD 9 */
  5  1088 
  5  1089 	  2 start_input_to		fixed bin (18) unsigned unal,		/* must overlay array_ref.start_input_to */
  5  1090 	  2 end_input_to		fixed bin (18) unsigned unal,		/* must overlay array_ref.end_input_to */
  5  1091 
  5  1092 	/* WORD 10 */
  5  1093 
  5  1094 	  2 ref_count_copy		fixed bin (17) unaligned,	/* must overlay array_ref.ref_count_copy */
  5  1095 	  2 ms_ref_count		fixed bin (17) unaligned,	/* counts occurances in saved machine states */
  5  1096 
  5  1097 	/* WORD 11 */
  5  1098 
  5  1099 	  2 length		fixed bin (24) aligned;	/* length in characters */
  5  1100 
  5  1101 /* END   fort_nodes.incl.pl1 */
      402 
  6     1 /* BEGIN fort_listing_nodes.incl.pl1 */
  6     2 
  6     3 /* Created:	30 August 1976, David Levin
  6     4*
  6     5*Last Modified:	 9 October 1978, Paul Smee
  6     6**/
  6     7 
  6     8 dcl	1 cross_reference(261120)	aligned structure based(cref_base),
  6     9 	  2 symbol		fixed bin (18) unsigned unaligned,
  6    10 	  2 line_no		fixed bin(17) unaligned;
  6    11 
  6    12 dcl	1 listing_info		aligned structure based(cur_listing),
  6    13 	  2 subprogram		fixed bin (18) unsigned,
  6    14 	  2 next			fixed bin (18) unsigned,
  6    15 	  2 first_line		fixed bin (18) unsigned,
  6    16 	  2 last_line		fixed bin (18) unsigned,
  6    17 	  2 first_cref		fixed bin (18) unsigned,
  6    18 	  2 last_cref		fixed bin (18) unsigned,
  6    19 	  2 first_error		fixed bin (18) unsigned,
  6    20 	  2 last_error		fixed bin (18) unsigned;
  6    21 
  6    22 dcl	listing_seg(0:261119)	fixed bin based(listing_base);
  6    23 
  6    24 dcl	1 error_text		aligned structure based,
  6    25 	  2 next			fixed bin (18) unsigned,
  6    26 	  2 length		fixed bin,
  6    27 	  2 string		char(error_text_length refer(error_text.length)) aligned;
  6    28 
  6    29 dcl	error_text_length		fixed bin;
  6    30 
  6    31 dcl	1 source_list (130560)	aligned structure based (source_line_base),
  6    32 	  2 file_number		fixed bin (8) unaligned,
  6    33 	  2 line_start		fixed bin (21) unsigned unaligned,
  6    34 	  2 unused_bits		bit (6) unaligned,
  6    35 	  2 line_length		fixed bin (18) unsigned unaligned,
  6    36 	  2 line_number_in_file	fixed bin (18) unsigned unaligned;
  6    37 
  6    38 /* END   fort_listing_nodes.incl.pl1 */
      403 
  7     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
  7     2 
  7     3 
  7     4 /****^  HISTORY COMMENTS:
  7     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  7     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  7     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
  7     8*     Objects of this type are PASCAL string types.
  7     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  7    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  7    11*     Added the new C types.
  7    12*                                                   END HISTORY COMMENTS */
  7    13 
  7    14 /* This include file defines mnemonic names for the Multics
  7    15*   standard descriptor types, using both pl1 and cobol terminology.
  7    16*   PG 780613
  7    17*   JRD 790530
  7    18*   JRD 791016
  7    19*   MBW 810731
  7    20*   TGO 830614 Add hex types.
  7    21*   Modified June 83 JMAthane to add PASCAL data types
  7    22*   TGO 840120 Add float dec extended and generic, float binary generic
  7    23**/
  7    24 
  7    25      dcl	   (real_fix_bin_1_dtype  init (1),
  7    26 	   real_fix_bin_2_dtype   init (2),
  7    27 	   real_flt_bin_1_dtype   init (3),
  7    28 	   real_flt_bin_2_dtype   init (4),
  7    29 	   cplx_fix_bin_1_dtype   init (5),
  7    30 	   cplx_fix_bin_2_dtype   init (6),
  7    31 	   cplx_flt_bin_1_dtype   init (7),
  7    32 	   cplx_flt_bin_2_dtype   init (8),
  7    33 	   real_fix_dec_9bit_ls_dtype init (9),
  7    34 	   real_flt_dec_9bit_dtype init (10),
  7    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
  7    36 	   cplx_flt_dec_9bit_dtype init (12),
  7    37 	   pointer_dtype	      init (13),
  7    38 	   offset_dtype	      init (14),
  7    39 	   label_dtype	      init (15),
  7    40 	   entry_dtype	      init (16),
  7    41 	   structure_dtype	      init (17),
  7    42 	   area_dtype	      init (18),
  7    43 	   bit_dtype	      init (19),
  7    44 	   varying_bit_dtype      init (20),
  7    45 	   char_dtype	      init (21),
  7    46 	   varying_char_dtype     init (22),
  7    47 	   file_dtype	      init (23),
  7    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
  7    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
  7    50 	   real_fix_bin_1_uns_dtype init (33),
  7    51 	   real_fix_bin_2_uns_dtype init (34),
  7    52 	   real_fix_dec_9bit_uns_dtype init (35),
  7    53 	   real_fix_dec_9bit_ts_dtype init (36),
  7    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
  7    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
  7    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
  7    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
  7    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
  7    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
  7    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
  7    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
  7    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
  7    63 	   real_flt_hex_1_dtype   init (47),
  7    64 	   real_flt_hex_2_dtype   init (48),
  7    65 	   cplx_flt_hex_1_dtype   init (49),
  7    66 	   cplx_flt_hex_2_dtype   init (50),
  7    67 	   c_typeref_dtype        init (54),
  7    68 	   c_enum_dtype           init (55),
  7    69              c_enum_const_dtype     init (56),
  7    70 	   c_union_dtype          init (57),
  7    71 	   algol68_straight_dtype init (59),
  7    72 	   algol68_format_dtype   init (60),
  7    73 	   algol68_array_descriptor_dtype init (61),
  7    74 	   algol68_union_dtype    init (62),
  7    75 
  7    76 	   cobol_comp_6_dtype     init (1),
  7    77 	   cobol_comp_7_dtype     init (1),
  7    78 	   cobol_display_ls_dtype init (9),
  7    79 	   cobol_structure_dtype  init (17),
  7    80 	   cobol_char_string_dtype init (21),
  7    81 	   cobol_display_ls_overp_dtype init (29),
  7    82 	   cobol_display_ts_overp_dtype init (30),
  7    83 	   cobol_display_uns_dtype init (35),
  7    84 	   cobol_display_ts_dtype init (36),
  7    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
  7    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
  7    87 	   cobol_comp_5_uns_dtype init (40),
  7    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
  7    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
  7    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
  7    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
  7    92 	   cplx_flt_dec_generic_dtype init (84),
  7    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
  7    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
  7    95 
  7    96      dcl	   (ft_integer_dtype      init (1),
  7    97 	   ft_real_dtype	      init (3),
  7    98 	   ft_double_dtype	      init (4),
  7    99 	   ft_complex_dtype	      init (7),
  7   100 	   ft_complex_double_dtype init (8),
  7   101 	   ft_external_dtype      init (16),
  7   102 	   ft_logical_dtype	      init (19),
  7   103 	   ft_char_dtype	      init (21),
  7   104 	   ft_hex_real_dtype      init (47),
  7   105 	   ft_hex_double_dtype    init (48),
  7   106 	   ft_hex_complex_dtype   init (49),
  7   107 	   ft_hex_complex_double_dtype init (50)
  7   108 	   )		      fixed bin internal static options (constant);
  7   109 
  7   110      dcl	   (algol68_short_int_dtype init (1),
  7   111 	   algol68_int_dtype      init (1),
  7   112 	   algol68_long_int_dtype init (2),
  7   113 	   algol68_real_dtype     init (3),
  7   114 	   algol68_long_real_dtype init (4),
  7   115 	   algol68_compl_dtype    init (7),
  7   116 	   algol68_long_compl_dtype init (8),
  7   117 	   algol68_bits_dtype     init (19),
  7   118 	   algol68_bool_dtype     init (19),
  7   119 	   algol68_char_dtype     init (21),
  7   120 	   algol68_byte_dtype     init (21),
  7   121 	   algol68_struct_struct_char_dtype init (22),
  7   122 	   algol68_struct_struct_bool_dtype init (20)
  7   123 	   )		      fixed bin internal static options (constant);
  7   124 
  7   125      dcl	   (label_constant_runtime_dtype init (24),
  7   126 	   int_entry_runtime_dtype init (25),
  7   127 	   ext_entry_runtime_dtype init (26),
  7   128 	   ext_procedure_runtime_dtype init (27),
  7   129 	   picture_runtime_dtype  init (63)
  7   130 	   )		      fixed bin internal static options (constant);
  7   131 
  7   132      dcl	   (pascal_integer_dtype  init (1),
  7   133 	   pascal_real_dtype      init (4),
  7   134 	   pascal_label_dtype     init (24),
  7   135 	   pascal_internal_procedure_dtype init (25),
  7   136 	   pascal_exportable_procedure_dtype init (26),
  7   137 	   pascal_imported_procedure_dtype init (27),
  7   138 	   pascal_typed_pointer_type_dtype init (64),
  7   139 	   pascal_char_dtype      init (65),
  7   140 	   pascal_boolean_dtype   init (66),
  7   141 	   pascal_record_file_type_dtype init (67),
  7   142 	   pascal_record_type_dtype init (68),
  7   143 	   pascal_set_dtype	      init (69),
  7   144 	   pascal_enumerated_type_dtype init (70),
  7   145 	   pascal_enumerated_type_element_dtype init (71),
  7   146 	   pascal_enumerated_type_instance_dtype init (72),
  7   147 	   pascal_user_defined_type_dtype init (73),
  7   148 	   pascal_user_defined_type_instance_dtype init (74),
  7   149 	   pascal_text_file_dtype init (75),
  7   150 	   pascal_procedure_type_dtype init (76),
  7   151 	   pascal_variable_formal_parameter_dtype init (77),
  7   152 	   pascal_value_formal_parameter_dtype init (78),
  7   153 	   pascal_entry_formal_parameter_dtype init (79),
  7   154 	   pascal_parameter_procedure_dtype init (80),
  7   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
  7   156 
  7   157 
  7   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
      404 
      405 
      406 	parse_ptr = q;
      407 	shared_ptr = p;
      408 
      409 	polish_base = shared_structure.polish_base;
      410 	operand_base = shared_structure.operand_base;
      411 	object_base = shared_structure.object_base;
      412 
      413 	if shared_structure.options.map then do;
      414 	     cref_base = shared_structure.cref_base;
      415 	     source_line_base = shared_structure.source_line_base;
      416 	     listing_base = shared_structure.listing_base;
      417 	end;
      418 
      419 	polish_max_len = shared_structure.polish_max_len;
      420 	object_max_len = shared_structure.object_max_len;
      421 	max_array_size.char = sys_info$max_seg_size;
      422 	call set_max_array_size;
      423 	call parse_source (source_info_ptr);
      424 	return;
      425 
      426 set_max_array_size:
      427      procedure;
      428 
      429 	if shared_structure.options.VLA_auto then
      430 	     max_array_size.auto = max_fixed_bin_24;
      431 	else
      432 	     max_array_size.auto = sys_info$max_seg_size;
      433 	if shared_structure.options.VLA_parm then
      434 	     max_array_size.parm = max_fixed_bin_24;
      435 	else
      436 	     max_array_size.parm = sys_info$max_seg_size;
      437 	if shared_structure.options.VLA_static then
      438 	     max_array_size.static = max_fixed_bin_24;
      439 	else
      440 	     max_array_size.static = sys_info$max_seg_size;
      441 	if shared_structure.options.VLC then
      442 	     max_array_size.common = max_fixed_bin_24;
      443 	else
      444 	     max_array_size.common = sys_info$max_seg_size;
      445 	return;
      446      end;
      447 
  8     1 /* BEGIN fort_utilities.incl.pl1 */
  8     2 
  8     3 /* Created:	October 1977, Richard Barnes
  8     4*
  8     5*   Modified:
  8     6*	22 May 1978, DSL - add create_constant.
  8     7*	09 Oct 1978, PES - make create_(constant node) return fixed bin(18) unsigned.
  8     8*	13 Dec 1978, PES - Get create_node from include file, rather than copy.
  8     9**/
  8    10 
  9     1 /* BEGIN fort_create_node.incl.pl1 */
  9     2 
  9     3 /* Created:	October 1977, Richard Barnes
  9     4*
  9     5*   Modified:
  9     6*	22 May 1978, DSL - add create_constant.
  9     7*	09 Oct 1978, PES - make create_(constant node) return fixed bin(18) unsigned.
  9     8*	13 Dec 1978, PES - changes for large common and arrays.
  9     9**/
  9    10 create_node:   proc(type,length) returns(fixed bin (18));
  9    11 
  9    12 dcl	length			fixed bin;
  9    13 dcl	offset			fixed bin(18);
  9    14 dcl	type			fixed bin(4);
  9    15 dcl	storage(length)		fixed bin aligned based;
  9    16 dcl	x(0:operand_max_len-1)	fixed bin(35) aligned based(operand_base);
  9    17 dcl	(addr,char,ltrim,unspec)	builtin;
  9    18 
  9    19 
  9    20 	if (length + next_free_operand) < operand_max_len
  9    21 	   then do;
  9    22 	        offset = next_free_operand;
  9    23 	        next_free_operand = next_free_operand + length;
  9    24 	        unspec(addr(x(offset)) -> storage) = "0"b;
  9    25 	        addr(x(offset)) -> node.node_type = type;
  9    26 	        return(offset);
  9    27 	        end;
  9    28 	   else do;
  9    29 		call print_message(407, "operand region", ltrim(char(operand_max_len))); /* FATAL */
  9    30 	        end;
  9    31 
  9    32 	end create_node;
  9    33 
  9    34 /* END fort_create_node.incl.pl1 */
  8    11 
  8    12 
  8    13 create_constant:	proc(data_type,value) returns(fixed bin (18));
  8    14 
  8    15 dcl	(data_type,a_data_type) 	fixed bin(4);	/* data type of constant */
  8    16 dcl	(value,a_value)	 	bit(72) aligned;	/* value of constant */
  8    17 
  8    18 dcl	addr			builtin;
  8    19 dcl	binary			builtin;
  8    20 dcl	bool			builtin;
  8    21 dcl	char			builtin;
  8    22 dcl	data_size			fixed bin(17);
  8    23 dcl	decimal			builtin;
  8    24 dcl	hash_index		fixed bin;
  8    25 dcl	hash_table(0:hash_table_size-1) fixed bin(35) aligned based(operand_base);
  8    26 dcl	hash_table_size		fixed bin int static options(constant) init(211);
  8    27 dcl	hbound			builtin;
  8    28 dcl	ltrim			builtin;
  8    29 dcl	mod			builtin;
  8    30 dcl	mod_2_sum			bit(36) aligned;
  8    31 dcl	node_offset		fixed bin;
  8    32 dcl	node_ptr			pointer;
  8    33 dcl	size			builtin;
  8    34 dcl	v_array(2)		bit(36) aligned based(addr(a_value));
  8    35 dcl	x(0:operand_max_len-1)	fixed bin(35) aligned based(operand_base);
  8    36 
 10     1 /* BEGIN INCLUDE FILE relocation_bits.incl.pl1 */
 10     2 
 10     3 /* This include file defines the relocation bits as bit (6) entities.  See
 10     4*   also relbts.incl.pl1 and reloc_lower.incl.pl1. */
 10     5 
 10     6 dcl (	rc_a	initial("000000"b),		/* absolute */
 10     7 	rc_t	initial("010000"b),		/* text */
 10     8 	rc_nt	initial("010001"b),		/* negative text */
 10     9 	rc_lp18	initial("010010"b),		/* linkage, 18 bit */
 10    10 	rc_nlp18	initial("010011"b),		/* negative link, 18 bit */
 10    11 	rc_lp15	initial("010100"b),		/* linkage, 15 bit */
 10    12 	rc_dp	initial("010101"b),		/* def section */
 10    13 	rc_s	initial("010110"b),		/* symbol segment */
 10    14 	rc_ns	initial("010111"b),		/* negative symbol */
 10    15 	rc_is18	initial("011000"b),		/* internal static 18 */
 10    16 	rc_is15	initial("011001"b),		/* internal static 15 */
 10    17 	rc_lb	initial("011000"b),		/* link block */
 10    18 	rc_nlb	initial("011001"b),		/* negative link block */
 10    19 	rc_sr	initial("011010"b),		/* self relative */
 10    20 	rc_e	initial("011111"b))		/* escape */
 10    21 	bit(6) int static options(constant);
 10    22 
 10    23 /* END INCLUDE FILE relocation_bits.incl.pl1 */
  8    37 
  8    38 
  8    39 
  8    40 	a_data_type = data_type;
  8    41 	a_value = value;
  8    42 
  8    43 	if a_data_type = char_mode | a_data_type <= 0 | a_data_type > hbound(data_type_size,1)
  8    44 	then do;
  8    45 	     call print_message(452, ltrim(char(decimal(a_data_type,12)))); /* cannot create the node */
  8    46 	     end;
  8    47 	else data_size = data_type_size(a_data_type);
  8    48 
  8    49 	if data_size = 1
  8    50 	then do;
  8    51 	     mod_2_sum = v_array(1);
  8    52 	     v_array(2) = "0"b;
  8    53 	     end;
  8    54 	else mod_2_sum = bool(v_array(1),v_array(2),"0110"b);
  8    55 
  8    56 
  8    57 	hash_index = mod(binary(mod_2_sum,35),hash_table_size);
  8    58 
  8    59 	/* Search the hash table for the constant. */
  8    60 
  8    61 	node_offset = hash_table(hash_index);
  8    62 	do while(node_offset > 0);			/* search the entire bucket */
  8    63 	     node_ptr = addr(x(node_offset));
  8    64 
  8    65 	     if node_ptr -> constant.value = a_value	/* must be same value */
  8    66 	     then if node_ptr -> node.data_type = a_data_type /* and same data type */
  8    67 		then return(node_offset);
  8    68 
  8    69 	     node_offset = node_ptr -> node.hash_chain;	/* NB - pointer remains pointing at last item in bucket */
  8    70 	     end;
  8    71 
  8    72 	/* a new constant node must be created */
  8    73 
  8    74 	node_offset = create_node(constant_node, size(constant));
  8    75 
  8    76 	if hash_table(hash_index) = 0			/* Is this the first item in the bucket? */
  8    77 	then hash_table(hash_index) = node_offset;	/* yes */
  8    78 	else node_ptr -> node.hash_chain = node_offset;	/* no, add it to the end */
  8    79 
  8    80 	node_ptr = addr(x(node_offset));
  8    81 	node_ptr -> constant.data_type = a_data_type;
  8    82 	node_ptr -> constant.operand_type = constant_type;
  8    83 	node_ptr -> constant.is_addressable = "1"b;
  8    84 	node_ptr -> constant.reloc = rc_t;
  8    85 	node_ptr -> constant.value = a_value;
  8    86 
  8    87 	constant_info(data_size).constant_count = constant_info(data_size).constant_count + 1;
  8    88 
  8    89 	if constant_info(data_size).first_constant = 0	/* Is this the first item of this size? */
  8    90 	then constant_info(data_size).first_constant = node_offset; /* yes */
  8    91 	else addr(x(constant_info(data_size).last_constant)) -> constant.next_constant = node_offset; /* no, add it */
  8    92 
  8    93 	constant_info(data_size).last_constant = node_offset;
  8    94 
  8    95 	return(node_offset);
  8    96 
  8    97 	end create_constant;
  8    98 
  8    99 /* END fort_utilities.incl.pl1 */
      448 
      449 
      450 parse_source:
      451      procedure (src_info_ptr);
      452 
      453 /*	Program Specifications (parse_source)
      454*
      455*     Inputs
      456*
      457*     Output
      458*
      459*     Description - This routine parses one or more source segment and produces
      460*	the intermediate representation. Before each subprogram is parsed,
      461*	all local work areas are reinitialized. This includes the operand table (or symbol table),
      462*	the segment containing the intermediate representation of each statement, etc.
      463*
      464*	Each symbol table is independent except there is a single thread which runs through
      465*	all symbols in all segments compiled. There are similar threads for constants and labels.
      466*
      467*	Each subprogram compiled produces a block of independent intermediate text. This text is
      468*	preceded by a header which indicates subprogram name and type, and some switches. One switch
      469*	indicates whether or not the intermediate text should be skipped or compiled. This switch
      470*	will be used primarily to prevent the compilation of more than one subprogram with the
      471*	same name.
      472*
      473**/
      474 
      475 dcl      COLON_BEFORE_ASSIGN bit (1) aligned;
      476 dcl      BEGIN_DO_LOOP fixed bin (18) static options (constant) init (-1);
      477 declare	CURRENT_VALUE fixed binary (18) internal static options (constant) initial (1);
      478 dcl      DECLARED bit (5) aligned int static options (constant) init ("0"b);
      479 dcl      DIGIT char (10) aligned int static options (constant) init ("0123456789");
      480 declare	END_DO_LOOP fixed binary (18) internal static options (constant) initial (-2);
      481 declare	END_DO_LOOP_SIZE fixed binary (18) internal static options (constant) initial (1);
      482 dcl      END_DO_RANGE bit (1) aligned;
      483 dcl      FALSE bit (1) aligned int static options (constant) init ("0"b);
      484 dcl      GOTO_REF bit (5) aligned int static options (constant) init ("10101"b);
      485 dcl      GOTO_TARGET bit (5) aligned int static options (constant) init ("11101"b);
      486 dcl      INIT bit (5) aligned int static options (constant) init ("00001"b);
      487 declare	INITIAL_EXPRESSION fixed binary (18) internal static options (constant) initial (2);
      488 dcl      NO_NAME char (8) unaligned int static options (constant) init ("");
      489 dcl      NOT_SET bit (1) int static options (constant) init ("0"b);
      490 dcl      NULL_STRING char (0) int static options (constant) init ("");
      491 dcl      ONE fixed bin (18) int static options (constant) init (1);
      492 dcl      OS (0:operand_max_len - 1) bit (36) aligned based (operand_base);
      493 dcl      PASSED bit (5) aligned int static options (constant) init ("10110"b);
      494 dcl      REF bit (5) aligned int static options (constant) init ("10100"b);
      495 dcl      SECOND_EQUALS bit (1) aligned;
      496 dcl      SET bit (5) aligned int static options (constant) init ("11100"b);
      497 dcl      SET_ATTR bit (1) int static options (constant) init ("1"b);
      498 dcl      SI fixed bin (18);
      499 dcl      SKIP fixed bin (18) static options (constant) init (0);
      500 dcl      SUBSCRIPTED_VAR fixed bin (18) static options (constant) init (-4);
      501 dcl      SUBSCRIPTED_SUBSTR fixed bin (18) static options (constant) init (-5);
      502 dcl      SUBSTR fixed bin (18) static options (constant) init (-3);
      503 declare	SYMBOL_INDEX fixed binary (18) internal static options (constant) initial (1);
      504 dcl      TRUE bit (1) aligned int static options (constant) init ("1"b);
      505 dcl      ZERO bit (1) aligned int static options (constant) init ("0"b);
      506 dcl      max_char_var_length fixed bin (21) internal static options (constant) init (131071);
      507 
      508 dcl      abs builtin;
      509 dcl      addr builtin;
      510 dcl      after_subprogram fixed bin (18) int static options (constant) init (11);
      511 dcl      all_attributes bit (47) aligned int static options (constant)
      512 	    init ("11111111111111111111111111111111111111111111111"b);
      513 dcl      allow_star_after bit (1) aligned;
      514 dcl      alphabetic char (52) aligned int static options (constant)
      515 	    init ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
      516 dcl      alternate_return_index fixed bin (18);
      517 dcl      any_label bit (2) aligned int static options (constant) init ("00"b);
      518 dcl      arg_type bit (36) aligned;
      519 dcl      asf_attribute bit (47) aligned int static options (constant)
      520 	    init ("00000000000000000000000000000000010000000000000"b);
      521 dcl      asf_conflicts bit (47) aligned int static options (constant)
      522 	    init ("00000000000000000000000000111111111111111110000"b);
      523 dcl      asf_definition fixed bin (18) int static options (constant) init (28);
      524 dcl      assign_ entry (ptr, fixed bin, fixed bin (35), ptr, fixed bin, fixed bin (35));
      525 dcl      assignment_statement fixed bin (18) int static options (constant) init (60);
      526 dcl      assignment_statement_index fixed bin (18);
      527 declare	asterisk_seen bit (1) aligned;
      528 dcl      attr_table (0:6) bit (47) aligned int static options (constant)
      529 	    init ("00000000000000000000000000000000000000000000000"b,
      530 	    "00000000000000000000100000000000000000000000000"b, "00000000000000000000010000000000000000000000000"b,
      531 	    "00000000000000000000001000000000000000000000000"b, "00000000000000000000000100000000000000000000000"b,
      532 	    "00000000000000000000000010000000000000000000000"b, "00000000000000000000000001000000000000000000000"b);
      533 dcl      attributes bit (47) aligned;
      534 dcl      auto_attribute bit (47) aligned int static options (constant)
      535 	    init ("00000000000000000000000000000000000010000001000"b);
      536 dcl      b72_one bit (72) aligned int static options (constant)
      537 	    init ("100000000000000000000000000000000000000000000000000000000000000000000000"b);
      538 dcl      b72_zero bit (72) aligned int static options (constant)
      539 	    init ("000000000000000000000000000000000000000000000000000000000000000000000000"b);
      540 dcl      bad_type fixed bin (18);
      541 dcl      based_bit_72 bit (72) aligned based;
      542 dcl      based_char char (8) aligned based;
      543 dcl      based_integer fixed bin (35) based;
      544 dcl      based_real (2) float bin (27) based aligned;
      545 dcl      based_words (512) bit (36) aligned based;
      546 dcl      before builtin;
      547 dcl      begin_char fixed bin (18);
      548 dcl      bif_conflicts bit (47) aligned int static options (constant)
      549 	    init ("11111111111111111111000011111110011111111111000"b);
      550 dcl      binary builtin;
      551 dcl      bit builtin;
      552 dcl      bit_mask (4) bit (36) aligned int static options (constant)
      553 	    init ("111111111000000000000000000000000000"b, "111111111111111111000000000000000000"b,
      554 	    "111111111111111111111111111000000000"b, "111111111111111111111111111111111111"b);
      555 dcl      bit_value bit (9) aligned;
      556 dcl      bypass_first_pending_entry bit (1);
      557 dcl      card_image bit (1) aligned;
      558 dcl      char builtin;
      559 dcl      char_index fixed bin (20);
      560 dcl      char_siz fixed bin (18);
      561 dcl      char_temp char (1320) aligned;			/* Refer to procedure "create_format" before changing. */
      562 dcl      char_type fixed bin (18);
      563 dcl      char_value char (1) aligned based (addr (bit_value));
      564 dcl      code fixed bin (35);
      565 dcl      common_name char (256) varying;
      566 dcl      common_storage bit (3) aligned int static options (constant) init ("001"b);
      567 dcl      const_index fixed bin (18);
      568 dcl      const_count fixed bin (18);
      569 dcl      constant_type (6) bit (9) aligned int static options (constant)
      570 	    init ("001100110"b, "001100111"b, "001101000"b, "001101001"b, "001000010"b, "001000001"b);
      571 dcl      continuation_line fixed bin (18) int static options (constant) init (2);
      572 dcl      copy builtin;
      573 dcl      count fixed bin (18);
      574 dcl      cp_count fixed bin (18);
      575 dcl      cp_label_count fixed bin (18);
      576 dcl      cur_paren fixed bin (18);
      577 dcl      cur_segment fixed bin (18);
      578 dcl      cur_stmnt_ptr pointer;
      579 dcl      current_character char (1) aligned;
      580 dcl      current_parameter fixed bin (18);
      581 dcl      current_token fixed bin (18);
      582 dcl      decimal builtin;
      583 dcl      decode_statement fixed bin (18) int static options (constant) init (44);
      584 dcl      default_char_size fixed bin (10);
      585 dcl      default_table (52) bit (47) aligned;
      586 declare	default_unit_specifier fixed binary (18);
      587 dcl      defined fixed bin (18);
      588 dcl      dim_attr bit (47) aligned int static options (constant)
      589 	    init ("00000000000000000000000000000000000100000001000"b);
      590 dcl      dim_conflicts bit (47) aligned int static options (constant)
      591 	    init ("00000000000000000000000000111111111100000110000"b);
      592 dcl      dim builtin;
      593 dcl      digits fixed bin (18) int static options (constant) init (3);
      594 dcl      divide builtin;
      595 dcl      do_index fixed bin (18);
      596 dcl      do_info (8) fixed bin (18);
      597 dcl      do_level fixed bin (18);
      598 dcl      do_statement fixed bin (18) int static options (constant) init (61);
      599 dcl      dp pointer;
      600 dcl      (E_start, E_finish) fixed bin;
      601 dcl      E_token fixed bin;
      602 dcl      elseif_statement fixed bin (18) int static options (constant) init (30);
      603 dcl      else_statement fixed bin (18) int static options (constant) init (31);
      604 dcl      end_char fixed bin (18);
      605 dcl      end_line fixed bin (18) int static options (constant) init (64);
      606 dcl      end_of_line fixed bin (18);
      607 dcl      end_possible bit (1) aligned;
      608 dcl      entry_point_conflicts bit (47) aligned int static options (constant)
      609 	    init ("00000000000000000000000000111111111111111111000"b);
      610 dcl      entry_value bit (47) aligned int static options (constant)
      611 	    init ("00000000000000000000000000000001000000000000000"b);
      612 dcl      entry_value_conflicts bit (47) aligned int static options (constant)
      613 	    init ("00000000000000000000000000110010011111110111000"b);
      614 declare	equivalence_statement fixed bin (18) int static options (constant) init (14);
      615 dcl      equiv_conflicts bit (47) aligned int static options (constant)
      616 	    init ("00000000000000000000000000111111111000001110000"b);
      617 dcl      error bit (1);
      618 dcl      error_code fixed bin (35);
      619 dcl      executable_label bit (2) aligned int static options (constant) init ("01"b);
      620 dcl      ext_attributes bit (47) aligned int static options (constant)
      621 	    init ("00000000000000000000000000000001000000000000000"b);
      622 dcl      ext_conflicts bit (47) aligned int static options (constant)
      623 	    init ("00000000000000000000000000111111111111110111000"b);
      624 dcl      fast_lookup char (24) unaligned defined (full_name);
      625 dcl      fields_specified bit (72) aligned;
      626 dcl      file_number fixed bin (8) init (0);
      627 dcl      file_number_pic picture "zzz-";
      628 dcl      file_stack_depth fixed bin (17);
      629 dcl      first_mode_keyword fixed bin (18) int static options (constant) init (15);
      630 dcl      first_time bit (1) aligned;
      631 dcl      first_token fixed bin (18);
      632 dcl      first_word fixed bin (18);
      633 dcl      fixed builtin;
      634 dcl      fold_option bit (1) aligned;
      635 dcl      force_symtab_entry fixed bin (2) int static options (constant) init (2);
      636 dcl      format_label bit (2) aligned int static options (constant) init ("10"b);
      637 dcl      format_label_attributes bit (47) aligned int static options (constant)
      638 	    init ("00000000000000000000000001000000000001000001000"b);
      639 dcl      fort_defaults_$global ext entry (ptr, fixed bin, ptr, entry);
      640 dcl      fort_defaults_$check_global_args ext entry (ptr, ptr, entry);
      641 dcl      fort_defaults_$init_shared_vars external entry (ptr);
      642 dcl      fort_defaults_$option ext entry (ptr, fixed bin, ptr, ptr, ptr, bit (1) aligned, bit (1) aligned, entry);
      643 dcl      fort_defaults_$set ext entry (ptr, ptr);
      644 
      645 declare	fort_eval_parm ext entry (ptr, char (*), fixed bin (35));
      646 dcl      free_chain fixed bin (18);
      647 dcl      from_data_parser bit (1) aligned;
      648 dcl      full_name char (256) unaligned;
      649 dcl      func_conflicts bit (47) aligned int static options (constant)
      650 	    init ("00000000000000000000000000110110111111110111000"b);
      651 dcl      func_ref_attribute bit (47) aligned int static options (constant)
      652 	    init ("00000000000000000000000000001001000000000000000"b);
      653 dcl      function_attribute bit (47) aligned int static options (constant)
      654 	    init ("00000000000000000000000000001010000000000100000"b);
      655 declare	function_statement fixed binary (18) internal static options (constant) initial (4);
      656 dcl      general_format_parse_ entry (char (1320) aligned, char (4096) aligned, bit (1) aligned, fixed bin (35));
      657 dcl      hash_table (0:210) fixed bin (18);
      658 dcl      have_auto_option bit (1) aligned;
      659 dcl      have_auto_stmnt bit (1) aligned;
      660 dcl      have_save_stmnt bit (1) aligned;
      661 dcl      have_static_option bit (1) aligned;
      662 dcl      have_subscript bit (1);
      663 dcl      hbound builtin;
      664 dcl      i fixed bin (18);
      665 dcl      ignore_bits bit (36) aligned;
      666 dcl      ignore_octal_value bit (72) aligned;
      667 dcl      ignore_symtab_entry fixed bin (2) int static options (constant) init (0);
      668 dcl      ignore_value fixed bin (18);
      669 dcl      impossible_align bit (2) aligned int static options (constant) init ("11"b);
      670 dcl      impossible_class (0:7) bit (1) aligned int static options (constant) init ((3) (1)"0"b, "1"b, "0"b, (3) (1)"1"b);
      671 dcl      in_list bit (1) aligned;
      672 dcl      in_stmnt bit (1) aligned;
      673 dcl      index builtin;
      674 dcl      indx fixed bin (18);
      675 declare	indx_type fixed binary (18);
      676 dcl      initial_line fixed bin (18) int static options (constant) init (1);
      677 dcl      inx fixed binary;
      678 declare	io_control_type fixed binary (4);
      679 dcl      jnx fixed binary;
      680 dcl      keyword_index fixed bin (18);
      681 dcl      label_args bit (1) aligned;
      682 dcl      label_hash_table (0:210) fixed bin (18);
      683 dcl      label_ptr fixed bin (18);
      684 dcl      last_cur_statement fixed bin (18);
      685 dcl      last_do fixed bin (18);
      686 dcl      last_element fixed bin (18);
      687 dcl      last_mode_keyword fixed bin (18) int static options (constant) init (20);
      688 dcl      last_namelist fixed bin (18);
      689 dcl      last_namelist_word_offset fixed bin (18);
      690 dcl      last_paren_parsed fixed bin (18);
      691 dcl      last_source_line fixed bin (18);
      692 dcl      last_statement fixed bin (18);
      693 dcl      last_statement_type fixed bin (18);
      694 dcl      last_token fixed bin (18);
      695 dcl      lbound builtin;
      696 dcl      length builtin;
      697 dcl      letters fixed bin (18) int static options (constant) init (1);
      698 dcl      line_number fixed bin (18);
      699 dcl      line_number_pic picture "zzzzz9";
      700 dcl      line_numbered_text bit (1) aligned;
      701 dcl      locate_symtab_entry fixed bin (2) int static options (constant) init (1);
      702 dcl      logical_if_statement bit (1) aligned;
      703 dcl      local_attributes bit (47) aligned;
      704 dcl      ltrim builtin;
      705 dcl      main_attr bit (47) aligned int static options (constant) init ("000000000000000000010000000000100000"b);
      706 dcl      max builtin;
      707 dcl      max_arglist fixed bin (18) int static options (constant) init (63);
      708 dcl      max_stack fixed bin (18);
      709 dcl      member_attr bit (47) aligned int static options (constant)
      710 	    init ("00000000000000000000000000000000000000110001000"b);
      711 dcl      member_conflicts bit (47) aligned int static options (constant)
      712 	    init ("00000000000000000000000000111111111011101110000"b);
      713 dcl      min builtin;
      714 dcl      mod builtin;
      715 dcl      mode_defined bit (52) aligned;
      716 dcl      mode_type fixed bin (4);
      717 dcl      must_have_label bit (1) aligned;
      718 dcl      named_constant_ptr pointer;
      719 dcl      named_constant_ptr_valid bit (1) aligned;
      720 dcl      named_const_attr bit (47) aligned int static options (constant)
      721 	    init ("00000000000000000000000000000000000000000010000"b);
      722 dcl      named_const_conflicts bit (47) aligned int static options (constant)
      723 	    init ("00000000000000000000000000111111111111111111101"b);
      724 dcl      namelist_attr bit (47) aligned int static options (constant)
      725 	    init ("00000000000000000000000000000000001000000000000"b);
      726 dcl      need_comma bit (1) aligned;
      727 declare	need_ref bit (1) aligned;
      728 dcl      new fixed bin (18);
      729 dcl      next_line_index fixed bin (20);
      730 dcl      next_statement_label fixed bin (18);
      731 dcl      next_token bit (9) aligned;
      732 dcl      no_attributes bit (47) aligned int static options (constant)
      733 	    init ("00000000000000000000000000000000000000000000000"b);
      734 dcl      no_more_source fixed bin (18) int static options (constant) init (0);
      735 declare	not_found bit (1) aligned;
      736 dcl      null builtin;
      737 dcl      number_of_dims fixed bin;
      738 dcl      number_of_subs fixed bin;
      739 dcl      old fixed bin (18);
      740 dcl      op_code fixed bin;
      741 dcl      1 other_segment_info aligned like compiler_source_info;
      742 dcl      out_of_sequence fixed bin (18) int static options (constant) init (63);
      743 dcl      p fixed bin (18);
      744 dcl      param_attr bit (47) aligned int static options (constant)
      745 	    init ("00000000000000000000000000000000000000001000000"b);
      746 dcl      param_conflicts bit (47) aligned int static options (constant)
      747 	    init ("00000000000000000000000000111110111011110110000"b);
      748 dcl      param_ptr pointer;
      749 dcl      param_variable_attrs bit (47) aligned int static options (constant)
      750 	    init ("00000000000000000000000000000000000000001001000"b);
      751 dcl      parameter_statement fixed bin (18) int static options (constant) init (24);
      752 dcl      paren_array (660) fixed bin (18);
      753 dcl      paren_count fixed bin (18);
      754 dcl      01 pending_entry (50) aligned,
      755 	 02 entry_symbol fixed bin (18),
      756 	 02 entry_stmnt bit (36 * size (statement));
      757 dcl      pending_entry_cnt fixed bin;
      758 dcl      produce_listing bit (1) aligned;
      759 dcl      put_in_map bit (9) aligned int static options (constant) init ("100000000"b);
      760 dcl      put_in_profile bit (9) aligned int static options (constant) init ("110000000"b);
      761 dcl      reset_stack (max_stack) bit (36) aligned based (object_base);
      762 dcl      return_value fixed bin (18);
      763 dcl      return_value_param fixed bin (18);
      764 dcl      round builtin;
      765 dcl      rtrim builtin;
      766 dcl      save_attributes bit (47) aligned int static options (constant)
      767 	    init ("00000000000000000000000000000000000001000001000"b);
      768 dcl      save_conflicts bit (47) aligned int static options (constant)
      769 	    init ("00000000000000000000000000111111111011111110000"b);
      770 dcl      save_current_token fixed bin (18);
      771 dcl      saved_number_of_crefs fixed bin (18);
      772 dcl      scalar_conflicts bit (47) aligned int static options (constant)
      773 	    init ("00000000000000000000000000111111111100000110000"b);
      774 dcl      search builtin;
      775 dcl      seg_ptr pointer;
      776 dcl      seg_chain_end_ptr pointer;
      777 dcl      sign bit (9) aligned;			/* Refer to proc "convert_integer_constant" before using. */
      778 dcl      size builtin;
      779 dcl      source_info pointer;
      780 dcl      source_len fixed bin (21);
      781 dcl      source_ptr pointer;
      782 dcl      src_info_ptr pointer;
      783 dcl      stack (0:sys_info$max_seg_size - 1) fixed bin (18) based (object_base);
      784 dcl      stack_base fixed bin (18);
      785 dcl      stack_index fixed bin (18);
      786 dcl      start_of_expression fixed bin (18);
      787 dcl      start_of_node fixed bin (18);
      788 dcl      statement_info bit (36 * size (statement)) aligned;
      789 dcl      statement_label fixed bin (18);
      790 dcl      statement_length fixed bin (18);
      791 dcl      statement_offset fixed bin (20);
      792 dcl      statement_type fixed bin (18);
      793 dcl      string builtin;
      794 dcl      st_copy char (1320) aligned;
      795 dcl      st_lbl_type bit (2) aligned;
      796 dcl      sub_ptr pointer;
      797 dcl      subprogram_attributes bit (47) aligned;
      798 dcl      subprogram_conflicts bit (47) aligned;
      799 dcl      subprogram_op fixed bin;
      800 dcl      subprogram_symbol fixed bin (18);
      801 dcl      subroutine_attributes bit (47) aligned int static options (constant)
      802 	    init ("00000000000000000000000000000110000000000100000"b);
      803 dcl      subroutine_conflicts bit (47) aligned int static options (constant)
      804 	    init ("11111111111111111111111111111010111111110111000"b);
      805 dcl      subroutine_reference bit (47) aligned int static options (constant)
      806 	    init ("00000000000000000000000000000101000000000000000"b);
      807 dcl      subs_list (0:7) fixed bin (18);
      808 dcl      subscript fixed bin (24);
      809 dcl      substr builtin;
      810 dcl      symbol_index fixed bin (18);
      811 dcl      symbol_length fixed bin (18);
      812 dcl      symp pointer;
      813 dcl      temp pointer;
      814 dcl      token bit (9) aligned;
      815 dcl      token_length fixed bin (18);
      816 dcl      token_offset fixed bin (18);
      817 dcl      translate builtin;
      818 dcl      type_conflicts bit (47) aligned int static options (constant)
      819 	    init ("11111111111111111111111111110100011000000110000"b);
      820 dcl      type_of_line fixed bin (18);
      821 dcl      unknown_statement fixed bin (18) int static options (constant) init (62);
      822 dcl      unspec builtin;
      823 dcl      v_length_attributes bit (47) aligned int static options (constant)
      824 	    init ("00000000000000000000100000000000000010000001000"b);
      825 dcl      value_0 fixed bin (18);
      826 dcl      value_1 fixed bin (18);
      827 dcl      value_7 fixed bin (18);
      828 dcl      variable_attributes bit (47) aligned int static options (constant)
      829 	    init ("00000000000000000000000000000000000000000001000"b);
      830 dcl      variable_conflicts bit (47) aligned int static options (constant)
      831 	    init ("00000000000000000000000000111111111000000110000"b);
      832 dcl      verify builtin;
      833 dcl      word_offset fixed bin (18);
      834 dcl      work bit (72) aligned;
      835 
      836 dcl      1 do_blockif_stack (50) aligned,
      837 	 2 label_ptr fixed binary (18),
      838 	 2 clauses fixed binary (18),
      839 	 2 count_op fixed binary (18),
      840 	 2 line_number fixed binary (18),
      841 	 2 do_loop bit (1) aligned,
      842 	 2 else_seen bit (1) aligned;
      843 
      844 dcl      1 word_align aligned based,
      845 	 2 based_double float bin (63) unaligned;
      846 
      847 dcl      1 token_list (1000) aligned,
      848 	 2 type bit (9) unaligned,
      849 	 2 pad bit (9) unaligned,
      850 	 2 offset fixed bin (18) unaligned unsigned,
      851 	 2 length fixed bin (10) aligned;
      852 
      853 dcl      1 constant_array (500) aligned,
      854 	 2 prec fixed bin (8) unaligned,
      855 	 2 scale fixed bin (8) unaligned,
      856 	 2 exponent fixed bin (8) unaligned,
      857 	 2 length fixed bin (8) unaligned;
      858 
      859 dcl      1 file_stack (0:32) aligned,
      860 	 2 fs_seg_ptr ptr,				/* ptr to source_node for segment. */
      861 	 2 fs_source_ptr ptr,			/* ptr to base of source segment. */
      862 	 2 fs_end_of_line fixed bin (21),		/* offset of end of current line in source seg. */
      863 	 2 fs_source_length fixed bin (21),		/* length in chars of source segment. */
      864 	 2 fs_line_number fixed bin (18),		/* line number in source segment. */
      865 	 2 fs_file_number fixed bin (8);		/* file number of source segment. */
      866 
      867 dcl      1 token_structure aligned based (addr (st_copy)),
      868 	 2 pad char (token_offset) unaligned,
      869 	 2 token_string char (token_length) unaligned;
      870 
      871 dcl      1 format_structure aligned based (addr (st_copy)),
      872 	 2 pad char (6) unaligned,
      873 	 2 format_string char (statement_length - 6) unaligned;
      874 
      875 dcl      1 paren_info (100) aligned structure,
      876 	 2 chain fixed bin (18),
      877 	 2 position fixed bin (18),
      878 	 2 begin_index fixed bin (18),
      879 	 2 implied_loop bit (1);
      880 
 11     1 /* BEGIN INCLUDE FILE ... fort_parameter.incl.pl1  */
 11     2 
 11     3 /* Created:	August 1980, MEP
 11     4*
 11     5*   Modified:	24 March 1981, MEP = Enlarge structure to carry some of thearguments in the call.
 11     6**/
 11     7      declare 1 parameter	      aligned based,
 11     8 	     2 desired_data_type  fixed binary (4) unaligned,
 11     9 						/* IN - result converted to this if ^= 0 */
 11    10 	     2 result_data_type   fixed binary (4) unaligned,
 11    11 						/* OUT - if no conversion requested, the data_type */
 11    12 	     2 rounding	      bit (1) unaligned,	/* IN - rounding/trunc flag */
 11    13 	     2 start_of_polish    fixed binary (18) unaligned,
 11    14 						/* IN - offset of first polish for expression */
 11    15 	     2 end_of_polish      fixed binary (18) unaligned,
 11    16 						/* IN - offset of last_polish + 1 */
 11    17 	     2 stack_index	      fixed binary (18) unaligned,
 11    18 						/* IN - next free spot in stack, work area above this */
 11    19 	     2 max_stack	      fixed binary (18) unaligned,
 11    20 						/* IN/OUT - stack high water mark */
 11    21 	     2 result_location    fixed binary (18) unaligned,
 11    22 						/* OUT - if error_code ^= 0, OS offset constant node */
 11    23 	     2 shared_pointer     pointer;		/* IN - pointer to shared globals structure */
 11    24 
 11    25 /* END INCLUDE FILE ... fort_parameter.incl.pl1 */
      881 
      882 
      883 declare	1 parameter_info aligned like parameter;
      884 
      885 dcl      1 io_bits unaligned structure,
 12     1 /* BEGIN INCLUDE FILE fortran_job_bits.incl.pl1 */
 12     2 
 12     3 /****^  ***********************************************************
 12     4*        *                                                         *
 12     5*        * Copyright, (C) Honeywell Information Systems Inc., 1987 *
 12     6*        *                                                         *
 12     7*        *********************************************************** */
 12     8 
 12     9 
 12    10 /****^  HISTORY COMMENTS:
 12    11*  1) change(86-07-14,BWong), approve(86-07-14,MCR7286), audit(86-07-17,Ginter),
 12    12*     install(86-07-28,MR12.0-1105):
 12    13*     Fix fortran bug 454.
 12    14*  2) change(87-06-23,RWaters), approve(87-06-23,MCR7703), audit(87-07-10,Huen),
 12    15*     install(87-08-06,MR12.1-1069):
 12    16*     Implemented SCP 6315: fortran error-handling argument.
 12    17*                                                   END HISTORY COMMENTS */
 12    18 
 12    19 
 12    20 /* Modified:
 12    21*          May 15 1987 by R. Waters - SCP 6315 added debug_io bit.
 12    22*	May 23 1985 by B.Wong - 454: document internal file mode.
 12    23*	March 28 1984 by M. Mabey to install HFP support.
 12    24*	May 11 1980 by Marshall Presser to add ansi_77 bit
 12    25*	July 13 1979 by C R Davis to add fold bit.
 12    26*	May 17 1977 by David Levin to extend control_type field and add iostat_var
 12    27**/
 12    28 
 12    29 	     2 job_bits		unaligned structure,
 12    30 		3 error_label	bit(1),		/* if err= supplied in statement. */
 12    31 		3 end_label	bit(1),		/* if end= supplied in statement. */
 12    32 		3 read		bit(1),		/* if not control stmnt then read if true, write if false. */
 12    33 		3 format		bit(2),		/* list directed-"00"b, unfmt-"01"b, fmt-"10"b, namelist-"11"b */
 12    34 		3 mode		bit(2),		/* seq-"00"b, direct access-"01"b, string io-"10"b, internal file-"11"b */
 12    35 		3 list		bit(1),		/* if I/O transmission includes a list. */
 12    36 		3 control_type	bit(4),		/* see fortran_io_consts.incl.pl1 for meanings */
 12    37 		3 mbz		bit(1),		/* to allow expansion of control_type. MUST BE ZERO */
 12    38 		3 iostat_var	bit(1),		/* if iostat= supplied in statement */
 12    39 		3 debug_io          bit(1),             /* if user wants cu_$cl called after an io error */
 12    40 		3 reserved	bit(3),             /* used to be bit (4) but I stole one for debug_io. Hope they're not important :-) */
 12    41 
 12    42 		     /* the following two fields are generated at runtime */
 12    43 
 12    44 		3 have_input	bit(1),		/* if buffer contains a printable input record. */
 12    45 		3 end_of_input	bit(1),		/* if user has terminated list-dir input */
 12    46 
 12    47 		3 fold		bit (1),		/* if symbol names have been folded to lower case */
 12    48 		3 ansi_77		bit(1),		/* if source has been compiled in ansii77 mode */
 12    49 		3 hfp		bit(1),		/* if hex floating point math is to be used */
 12    50 		3 pad		bit(13),
 12    51 
 12    52 /* END   fortran_job_bits.incl.pl1 */
 12    53 
      886 
      887 	dummy fixed bin (18);
      888 
 13     1 /* BEGIN format_tables.incl.pl1 */
 13     2 
 13     3 /****^  HISTORY COMMENTS:
 13     4*  1) change(86-07-14,BWong), approve(86-07-14,MCR7382), audit(86-07-17,Ginter):
 13     5*     Fix fortran bug 122.
 13     6*                                                   END HISTORY COMMENTS */
 13     7 
 13     8 /* format: style2 */
 13     9 /*
 13    10*   Modified:
 13    11*          27 Nov 85, RW 122 - Changed fmt_len from fixed bin (11) to 
 13    12*                fixed bin (12) unsigned.
 13    13*	19 Oct 82, TO - Added 'd_format'.
 13    14*	27-31 July 1981, MEP - Changed names of format_desc_bit fields, and added names of new formats.
 13    15*	23 May 1978, DSL - Change precision of scalars to fixed bin(8).
 13    16*	Modified: March 1978, DSL - to implement new runtime format
 13    17*	modified: June 1976, by D Levin
 13    18*
 13    19*     This include file defines the internal representation of format specifications for fortran. */
 13    20 
 13    21 
 13    22 /* number of array elements required to represent a format specification */
 13    23 
 13    24 /* format: off */
 13    25      dcl	   increment_table	      (0:29) fixed bin internal static options (constant)
 13    26 	init (3, 4, 4, 3, 4, 3, 4, 0, 0, 3, 3, 3, 2, 3, 2, 2, 1, 1, 1, 3, 1, 3, 0, 0, 0, 1, 1, 1, 1, 1);
 13    27 /*	      i  f  e  l  d  o  g        r  a  h  x  t  p  (  )  /  :  "  E  tr          bz bn s  sp ss */
 13    28 
 13    29 /* format: on */
 13    30 /* actual representation of a format statement */
 13    31 
 13    32      dcl	   1 runtime_format	      based aligned structure,
 13    33 	     2 header_word	      unaligned structure,
 13    34 	       3 version	      bit (6),		/* current version is fmt_parse_ver1 */
 13    35 	       3 last_left_paren  fixed bin (11),	/* position at which to repeat the spec */
 13    36 	       3 format_desc_bits structure,
 13    37 	         4 anyitems	      bit (1),		/* ON if format contains a field descriptor */
 13    38 	         4 list_directed  bit (1),		/* ON if format specifies list directed format */
 13    39 	         4 skip_line_numbers
 13    40 			      bit (1),		/* ON if format specifies skiping line numbers */
 13    41 	         4 contains_hollerith
 13    42 			      bit (1),		/* ON if format contains hollerith fields */
 13    43 	         4 suppress_newline
 13    44 			      bit (1),		/* ON if final new_line not wanted */
 13    45 	         4 pad	      bit (1),
 13    46 	       3 fmt_len	      fixed bin (12) unsigned,/* length of format, in chars */
 13    47 	     2 fmt	      (1023) bit (36);	/* encoded format specs */
 13    48 
 13    49      dcl	   1 old_format	      aligned based structure,
 13    50 	     2 header_word	      like runtime_format.header_word unaligned structure,
 13    51 	     2 fmt	      (1022) fixed bin (17) unaligned;
 13    52 
 13    53      dcl	   1 format	      aligned based,
 13    54 	     2 long_format	      bit (1) unaligned,
 13    55 	     2 spec	      fixed bin (7) unaligned,
 13    56 	     2 rep_factor	      fixed bin (8) unaligned,
 13    57 	     2 width	      fixed bin (8) unaligned,
 13    58 	     2 precision	      fixed bin (8) unaligned;
 13    59 
 13    60      dcl	   1 long_format	      aligned based,
 13    61 	     2 long_format	      bit (1) unaligned,
 13    62 	     2 spec	      fixed bin (7) unaligned,
 13    63 	     2 exponent	      fixed bin (9) unsigned unaligned,
 13    64 	     2 rep_factor	      fixed bin (17) unaligned,
 13    65 	     2 width	      fixed bin (17) unaligned,
 13    66 	     2 precision	      fixed bin (17) unaligned;
 13    67 
 13    68 
 13    69 /* error message overlay */
 13    70 
 13    71      dcl	   1 format_error	      aligned based structure,
 13    72 	     2 input_length	      fixed bin,
 13    73 	     2 error_message      char (128);
 13    74 
 13    75 
 13    76 /* named constants for format specifications */
 13    77 
 13    78      dcl	   (
 13    79 	   a_format	      init (10),
 13    80 	   bn_format	      init (25),
 13    81 	   bz_format	      init (26),
 13    82 	   d_format	      init (4),
 13    83 	   e_format	      init (2),
 13    84 	   extended_i_format      init (22),
 13    85 	   g_format	      init (6),
 13    86 	   i_format	      init (0),
 13    87 	   s_format	      init (27),
 13    88 	   sp_format	      init (28),
 13    89 	   ss_format	      init (29),
 13    90 	   t_format	      init (13),
 13    91 	   tr_format	      init (21),
 13    92 	   end_of_format	      init (20),
 13    93 	   hollerith_field	      init (11),
 13    94 	   quoted_string	      init (19)
 13    95 	   )		      fixed bin int static options (constant);
 13    96 
 13    97      dcl	   fmt_parse_ver1	      bit (6) aligned int static options (constant) init ("110000"b);
 13    98      dcl	   max_value	      fixed bin (8) int static options (constant) init (255);
 13    99      dcl	   chars_per_word	      fixed bin (8) int static options (constant) init (4);
 13   100      dcl	   chars_per_halfword     fixed bin (8) int static options (constant) init (2);
 13   101 
 13   102 /* END   format_tables.incl.pl1 */
      889 
      890 
      891 /* format: off */
      892 dcl	1 statement_attributes
      893 			(64) aligned structure internal static options (constant),
      894 	  2 statement_label_type
      895 			bit (2) unaligned		/* Stmnt label is: executable, format, non-executable */
      896 init (
      897 			(28) (1)"11"b,		/* 1-28 */
      898 			"01"b,			/* 29 */
      899 			(3) (1)"01"b,		/* 30-32 */
      900 			(4) (1)"01"b,		/* 33-36 */
      901 			"10"b, "11"b,		/* 37&38 */
      902 			(7) (1)"01"b,		/* 39-45 */
      903 			"11"b,			/* 46 */
      904 			(17) (1)"01"b,		/* 47-63 */
      905 			"11"b),			/* 64 */
      906 	  2 ok_second_statement
      907 			bit (1) unaligned /* On if legal second stmnt for logical if stmnt. */ 
      908 init (
      909 			(28) (1)"0"b,		/* 1-28 */
      910 			"1"b,			/* 29 */
      911 			(3) (1)"0"b,		/* 30-32 */
      912 			(4) (1)"1"b,		/* 33-36 */
      913 			"0"b, "0"b,		/* 37&38 */
      914 			(7) (1)"1"b,		/* 39-45 */
      915 			"0"b,			/* 46 */
      916 			(14) (1)"1"b,		/* 47-60 */
      917 			"0"b, "1"b, "1"b, "0"b),	/* 61-64 */
      918 	  2 need_label	bit (1) unaligned /* On if FOLLOWING stmnt must have a label. */ 
      919 init (
      920 			(28) (1)"0"b,		/* 1-28 */
      921 			"1"b,			/* 29 */
      922 			(3) (1)"0"b,		/* 30-32 */
      923 			"1"b,			/* 33 */
      924 			(5) (1)"0"b,		/* 34-38 */
      925 			"1"b,			/* 39 */
      926 			(7) (1)"0"b,		/* 40-46 */
      927 			"1"b,			/* 47 */
      928 			(5) (1)"0"b,		/* 48-52 */
      929 			"1"b,			/* 53 */
      930 			(11) (1)"0"b),		/* 54-64 */
      931 	  2 cant_be_reached bit (1) unaligned		/* On if THIS statement is not reached by block if */
      932 init (
      933 			(29) (1)"1"b,		/* 1-29 */
      934 			(3) (1)"0"b,		/* 30-32 */
      935 			(32) (1)"1"b),		/* 33-64 */
      936 
      937 	  2 cant_ref_label	bit (1) unaligned		/* ON if label on  this statment cant be referenced */
      938 init (
      939 			(29) (1)"0"b,		/* 1 -29 */
      940 			(2) (1)"1"b,		/* 30-31 */
      941 			(33) (1)"0"b),		/* 32-64 */
      942 	  2 reserved	bit (12) unaligned init ((64) (1)""b),
      943 						/* Unused. */
      944 	  2 first_keyword	fixed bin (18) unaligned unsigned
      945 						/* Beginning of program section for this stmnt. */
      946 init (
      947 			(11) 11,			/* 1-11 */
      948 			(50) 12,			/* 12-61 */
      949 			(3) 0);			/* 62-64 */
      950 
      951 /* format: on */
      952 /* Keyword character strings. */
      953 
      954 dcl      keyword_table (64) char (28) varying internal static options (constant)
      955 	    init ("program", "blockdata", "subroutine", "function", "integerfunction", "realfunction",
      956 	    "doubleprecisionfunction", "complexfunction", "logicalfunction", "characterfunction", "implicit",
      957 	    "dimension", "common", "equivalence", "integer", "real", "doubleprecision", "complex", "logical",
      958 	    "character", "external", "intrinsic", "namelist", "parameter", "library", "save", "automatic",
      959 	    "statement func. definition", "if", "elseif", "else", "endif", "goto", "call", "continue", "write",
      960 	    "format", "data", "return", "rewind", "endfile", "read", "encode", "decode", "print", "entry", "stop",
      961 	    "pause", "assign", "punch", "input", "backspace", "chain", "closefile", "margin", "openfile", "open",
      962 	    "close", "inquire", "assignment", "do", "UNKNOWN", "SEQUENCE ERROR", "end");
      963 
      964 /*	Statement			Key Label      Ok   Need 1st
      965*	Type			Len Type      2nd  Label Key
      966*	
      967*	 1 Program		 7  Un   .    No   No    11
      968*	 2 Block Data		 9  Un   .    No   No    11
      969*	 3 Subroutine		10  Un   .    No   No    11
      970*	 4 Function		 8  Un   .    No   No    11	= function_statement
      971*	 5 Integer Function		15  Un   .    No   No    11
      972*	 6 Real Function		12  Un   .    No   No    11
      973*	 7 Double Precision Function	23  Un   .    No   No    11
      974*	 8 Complex Function		15  Un   .    No   No    11
      975*	 9 Logical Function		15  Un   .    No   No    11
      976*	10 Character Function	17  Un   .    No   No    11
      977*	11 Implicit		 8  Un   .    No   No    11	= after_subprogram
      978*	12 Dimension		 9  Un   .    No   No    12
      979*	13 Common			 6  Un   .    No   No    12
      980*	14 Equivalence		11  Un   .    No   No    12   = equivalence_statement
      981*	15 Integer		 7  Un   .    No   No    12	= first_mode_keyword
      982*	16 Real			 4  Un   .    No   No    12
      983*	17 Double Precision		15  Un   .    No   No    12
      984*	18 Complex		 7  Un   .    No   No    12
      985*	19 Logical		 7  Un   .    No   No    12
      986*	20 Character		 9  Un   .    No   No    12	= last_mode_keyword
      987*	21 External		 8  Un   .    No   No    12
      988*	22 Intrinsic		 9  Un   .    No   No    12
      989*	23 Namelist		 8  Un   .    No   No    12
      990*	24 Parameter		 9  Un   .    No   No    12	= parameter_statement
      991*	25 Library		 7  Un   .    No   No    12
      992*	26 Save			 4  Un   .    No   No    12
      993*	27 Automatic		 9  Un   .    No   No    12
      994*	28 Statement Function Def	 0  Un   .    No   No    12	= asf_definition
      995*	29 If (Arithmetic)		 2  Ex   .    Yes  Yes   12
      996*	30 Elseif			 6  Un   .    No   No    12	= elseif_statement
      997*	31 Else			 4  Un   .    No   No    12	= else_statement
      998*	32 Endif			 5  Un   .    No   No    12
      999*	33 Goto			 4  Ex   .    Yes  Yes   12
     1000*	34 Call			 4  Ex   .    Yes  No    12
     1001*	35 Continue		 8  Ex   .    Yes  No    12
     1002*	36 Write			 5  Ex   .    Yes  No    12
     1003*	37 Format			 6  Fmt  .    No   No    12
     1004*	38 Data			 4  Un   .    No   No    12
     1005*	39 Return			 6  Ex   .    Yes  Yes   12
     1006*	40 Rewind			 6  Ex   .    Yes  No    12
     1007*	41 Endfile		 7  Ex   .    Yes  No    12
     1008*	42 Read			 4  Ex   .    Yes  No    12
     1009*	43 Encode			 6  Ex   .    Yes  No    12
     1010*	44 Decode			 6  Ex   .    Yes  No    12	= decode_statement
     1011*	45 Print			 5  Ex   .    Yes  No    12
     1012*	46 Entry			 5  Un   .    No   No    12
     1013*	47 Stop			 4  Ex   .    Yes  Yes   12
     1014*	48 Pause			 5  Ex   .    Yes  No    12
     1015*	49 Assign To		 6  Ex   .    Yes  No    12
     1016*	50 Punch			 5  Ex   .    Yes  No    12
     1017*	51 Input			 5  Ex   .    Yes  No    12
     1018*	52 Backspace		 9  Ex   .    Yes  No    12
     1019*	53 Chain			 5  Ex   .    Yes  Yes   12
     1020*	54 Closefile		 9  Ex   .    Yes  No    12
     1021*	55 Margin			 6  Ex   .    Yes  No    12
     1022*	56 Openfile		 8  Ex   .    Yes  No    12
     1023*	57 Open			 4  Ex   .    Yes  No    12
     1024*	58 Close			 5  Ex   .    Yes  No    12
     1025*	59 Inquire		 7  Ex   .    Yes  No    12
     1026*	60 Assignment		 0  Ex   .    Yes  No    12	= assignment_statement
     1027*	61 Do			 2  Ex   .    No   No    12	= do_statement
     1028*	62 Unknown		 0  Ex   .    Yes  No     0	= unknown_statement
     1029*	63 Out of Sequence		 0  Ex   .    Yes  No     0	= out_of_sequence
     1030*	64 End			 0  Un   .    No   No     0	= end_line
     1031**/
     1032 
     1033 
     1034 dcl      1 expression aligned based structure,
     1035 	 2 storage_info like symbol.storage_info unaligned,
     1036 						/* currently 5 bits */
     1037 	 2 allow_array_name bit (1) unaligned,
     1038 	 2 reset_arg_bit bit (1) unaligned,
     1039 	 2 needs_descriptors bit (1) unaligned,
     1040 	 2 not_scalar_ref unaligned structure,
     1041 	   3 subscripted_ref bit (1) unaligned,
     1042 	   3 array_name bit (1) unaligned,
     1043 	   3 not_simple_ref bit (1) unaligned,
     1044 	   3 substring_ref bit (1) unaligned,
     1045 	 2 not_constant bit (1) unaligned,
     1046 	 2 no_assumed_size_array bit (1) unaligned;
     1047 
     1048 /* format: off */
     1049 /*		L E G E N D
     1050*		IN = set by caller to parse_expression
     1051*		OUT = set by parse_expression
     1052*
     1053*			       allocate (IN)
     1054*			       |set (IN)
     1055*			       | referenced (IN)
     1056*			       | |passed_as_arg (IN - OUT)
     1057*			       | | initialed (IN)
     1058*			       | | |allow_array_name (IN)
     1059*			       | | | reset_arg_bit (IN)
     1060*			       | | | |needs_descriptors (IN) 
     1061*			       | | | | subscripted_ref (OUT)
     1062*			       | | | | |array_name (OUT)
     1063*			       | | | | | not_simple_ref (OUT)
     1064*			       | | | | | |substring_ref (OUT)
     1065*			       | | | | | | not_constant (OUT)
     1066*			       | | | | | | |no_assumed_size_array (IN)
     1067*			       ||||||||||||||	
     1068*			       ||||||||||||||
     1069*          Constant Names	       ||||||||||||||
     1070*			       vvvvvvvvvvvvvv */
     1071 declare	(
     1072 	any_expression	init ("101000000000000000000000000000000000"b),
     1073 	set_reference	init ("111000000000000000000000000000000000"b),
     1074 	input_element	init ("111001000000010000000000000000000000"b),
     1075 	output_element	init ("101001000000010000000000000000000000"b),
     1076 	string_target	init ("111001000000010000000000000000000000"b),
     1077 	string_source	init ("101001000000010000000000000000000000"b),
     1078 	arg_list_expr	init ("101101100000000000000000000000000000"b),
     1079 	darg_list_expr	init ("101101110000000000000000000000000000"b),
     1080 	simple_reference	init ("101000000000000000000000000000000000"b),
     1081 	format_reference	init ("101001000000010000000000000000000000"b),
     1082 	set_no_symbol_bits	init ("000000000000000000000000000000000000"b)
     1083 	)		bit (36) aligned int static options (constant);
     1084 
     1085 /* format: on */
     1086 
     1087 dcl      out bit (36) aligned;			/* for return value */
     1088 
 14     1 /* BEGIN INCLUDE FILE ... compiler_source_info.incl.pl1 */
 14     2 /* coded in 1973 by B. Wolman */
 14     3 /* modified 12/75 by M. Weaver to include more source info */
 14     4 /* modified 12/76 by M. Weaver to include still more source info (version 2) */
 14     5 
 14     6 dcl  1 compiler_source_info	aligned based,
 14     7      2 version 		fixed bin,
 14     8      2 given_ename		char (32) var,
 14     9      2 dirname		char (168) var,
 14    10      2 segname		char (32) var,
 14    11      2 date_time_modified	fixed bin (71),
 14    12      2 unique_id		bit (36),
 14    13      2 input_lng		fixed bin (21),
 14    14      2 input_pointer	ptr;
 14    15 
 14    16 dcl compiler_source_info_version_2 fixed bin static init (2) options (constant);
 14    17 
 14    18 /* END INCLUDE FILE ... compiler_source_info.incl.pl1 */
     1089 
 15     1 /* BEGIN fortran_io_consts.incl.pl1 - various constants for fortran I/O */
 15     2 
 15     3 /* Modified:
 15     4*	24 Oct 81, MEP  added inquire_opr, deleted unused_9 (op_9)
 15     5*	1 Oct 1981 - MEP internal file
 15     6*	17 June 1981 - MEP for ansi77 i/o enhancements
 15     7**/
 15     8 declare
 15     9 	(list_directed	initial("00"b),
 15    10 	 unformatted	initial("01"b),
 15    11 	 formatted	initial("10"b),
 15    12 	 namelist		initial("11"b),
 15    13 
 15    14 	 sequential_access	initial("00"b),
 15    15 	 direct_access	initial("01"b),
 15    16 	 string_io	initial("10"b),
 15    17 	 internal_file	initial("11"b) )bit(2) aligned internal static options(constant);
 15    18 
 15    19 dcl	(write_opr	initial(1),
 15    20 	 old_endfile_opr	initial(2),
 15    21 	 read_opr		initial(3),
 15    22 	 rewind_opr	initial(4),
 15    23 	 op_5		initial(5),
 15    24 	 closefile_opr	initial(6),
 15    25 	 close_opr	initial(7),
 15    26 	 backspace_opr	initial(8),
 15    27 	 inquire_opr	initial(9),
 15    28 	 openfile_opr	initial(10),
 15    29 	 open_opr		initial(11),
 15    30 	 margin_opr	initial(12),
 15    31 	 op_13		initial(13),
 15    32 	 endfile_opr	initial(14)) fixed bin(4) int static options(constant);
 15    33 
 15    34 dcl	(stream_file	init("001"b),
 15    35 	 record_file	init("010"b),
 15    36 	 blocked_file	init("011"b),
 15    37 	 binary_file	init("100"b) ) bit(3) aligned int static options(constant);
 15    38 
 15    39 dcl	(undefined	init(-1),
 15    40 	 nonexistent	init(0),
 15    41 	 unstructured	init(1),
 15    42 	 sequential	init(2),
 15    43 	 blocked		init(3),
 15    44 	 indexed		init(4),
 15    45 	 binary_stream	init(5) ) fixed bin int static options(constant);
 15    46 
 15    47 /* This is the list of fields of the fields_specified word.  It is used to check for duplication in the parse, and
 15    48*   is positionally importan for the code generator, fortran_io, and pl1_operators. */
 15    49 
 15    50 dcl	(status_field	init(1),
 15    51 	 io_switch_field	init(2),
 15    52 	 attach_desc_field	init(3),
 15    53 	 filename_field	init(4),
 15    54 	 mode_field	init(5),
 15    55 	 access_field	init(6),
 15    56 	 form_field	init(7),
 15    57 	 recl_field	init (8),
 15    58 	 binarystream_field init (9),
 15    59 	 prompt_field	init (10),
 15    60 	 carriage_field	init (11),
 15    61 	 defer_field	init (12),
 15    62 	 blank_field	init (13),
 15    63 	 units_field	init (14),
 15    64 	 fmt_field	init (15),
 15    65 	 rec_field	init (16),
 15    66 	 exist_field	init (17),
 15    67 	 opened_field	init (18),
 15    68 	 number_field	init (19),
 15    69 	 named_field	init (20),
 15    70 	 name_field	init (21),
 15    71 	 sequential_field	init (22),
 15    72 	 formatted_field	init (23),
 15    73 	 unformatted_field	init (24),
 15    74 	 nextrec_field	init (25),
 15    75 	 direct_field	init (26) ) fixed bin int static options(constant);
 15    76 
 15    77 /* The following masks indicate the valid keywords and fields known to the i/o routines:
 15    78*	read: unit, fmt, iostat, err, end, rec.
 15    79*	write: unit, fmt, iostat, err, end.
 15    80*	open: unit, iostat, err, file, status, access, form, recl, blank, status, ioswitch, 
 15    81*	      attach, mode, binarystream, prompt, carriage, defer.
 15    82*	close: unit, iostat, err, status.
 15    83*	inquire: unit _x_o_r file, iostat, err, exist, opened, number, named, name, access, sequential, direct,
 15    84*	         form, formatted, unformatted, recl, nextrec, blank.
 15    85* */
 15    86 declare   (open_keyword_mask 	  init ("111111111111100000000000000000000000"b),
 15    87 	 valid_open_keyword	  init ("111111111111110000000000000000000000"b),
 15    88 	 valid_read_keyword	  init ("000000000000011100000000000000000000"b),
 15    89 	 valid_write_keyword  init ("000000000000011000000000000000000000"b),
 15    90 	 valid_close_keyword  init ("100000000000010000000000000000000000"b),
 15    91 	 valid_inquire_keyword init("000100000000010011111111110000000000"b))
 15    92 		bit (36) aligned internal static options (constant);
 15    93 /* END   fortran_io_consts.incl.pl1 */
     1090 
     1091 
     1092 /* THE PARSE PHASE BEGINS HERE. */
     1093 
     1094 /* Initialize constants used by the entire phase. */
     1095 
     1096 	addr (work) -> based_integer = 0;
     1097 	value_0 = create_constant (int_mode, work);
     1098 	default_unit_specifier = value_0;
     1099 	addr (work) -> based_integer = 1;
     1100 	value_1 = create_constant (int_mode, work);
     1101 	value_7 = 0;
     1102 
     1103 	cur_segment = 0;				/* Used to chain the source nodes. */
     1104 	first_segment = 0;				/* Head of source node chain. */
     1105 	number_of_source_segments = 0;
     1106 	number_of_lines = 0;			/* count total number of lines parsed */
     1107 	last_source_line = 0;			/* insures comments print with following program unit */
     1108 	profile_size = 0;				/* counts number of profile entries required */
     1109 	unnamed_block_data_subprogram = 0;		/* keep track of whether or not one was compiled */
     1110 	from_data_parser = FALSE;			/* Used by get_next_token to suppress error msgs. */
     1111 
     1112 	free_chain = 0;				/* Free initial "nodes". */
     1113 	max_stack = 0;				/* Number of words used in stack. */
     1114 	file_stack_depth = 0;			/* Current include file nesting depth. */
     1115 	shared_structure.incl_count = -1;		/* Count of include files used in this compilation. */
     1116 
     1117 	subprogram_op = main_op;
     1118 	subprogram_attributes = main_attr;
     1119 	subprogram_conflicts = all_attributes;
     1120 
     1121 	sign = ZERO;				/* Refer to procedure "convert_integer_constant" for explanation. */
     1122 
     1123 	options.namelist_used = FALSE;
     1124 	line_numbered_text = shared_structure.options.has_line_numbers;
     1125 	produce_listing = string (shared_structure.options.listing) ^= ZERO;
     1126 	parameter_info.shared_pointer = shared_ptr;
     1127 
     1128 /* the following makes a template for the statement node */
     1129 
     1130 	unspec (statement_info) = ZERO;
     1131 	addr (statement_info) -> statement.op_code = stat_op;
     1132 	addr (statement_info) -> statement.next = (18)"0"b;
     1133 	addr (statement_info) -> statement.location = (18)"1"b;
     1134 	addr (statement_info) -> statement.statement = "00001"b;
     1135 
     1136 /* SEGMENT LOOP. THIS LOOP IS EXECUTED ONCE FOR EACH SOURCE SEGMENT. */
     1137 
     1138 	source_info = src_info_ptr;			/* Copy input argument. */
     1139 	source_ptr = source_info -> compiler_source_info.input_pointer;
     1140 						/* Points to source segment. */
     1141 
     1142 	shared_structure.source_file_number, shared_structure.source_line_number = 0;
     1143 	do while (source_ptr ^= null);
     1144 
     1145 	     source_len = source_info -> compiler_source_info.input_lng;
     1146 
     1147 /* Build source node and save segment info. */
     1148 
     1149 	     shared_structure.incl_count = shared_structure.incl_count + 1;
     1150 
     1151 	     addr (statement_info) -> statement.file = shared_structure.incl_count;
     1152 
     1153 	     number_of_source_segments = number_of_source_segments + 1;
     1154 
     1155 	     if source_info -> compiler_source_info.segname = "" then
     1156 		i = 63 - divide (length (source_info -> compiler_source_info.dirname), chars_per_word, 17, 0);
     1157 	     i = 63
     1158 		-
     1159 		divide (length (source_info -> compiler_source_info.dirname)
     1160 		+ length (source_info -> compiler_source_info.segname), chars_per_word, 17, 0);
     1161 
     1162 	     indx = create_node (source_node, size (source) - i);
     1163 						/* Pathname cannot be made longer. */
     1164 
     1165 	     shared_structure.source_node_offset (incl_count) = indx;
     1166 	     shared_structure.incl_len (incl_count) = source_len;
     1167 	     shared_structure.incl_ptr (incl_count) = source_ptr;
     1168 
     1169 	     if cur_segment = 0 then
     1170 		first_segment = indx;
     1171 	     else
     1172 		seg_ptr -> source.next = indx;
     1173 
     1174 	     cur_segment = indx;
     1175 	     seg_chain_end_ptr, seg_ptr = addr (OS (cur_segment));
     1176 
     1177 	     seg_ptr -> source.pathname = source_info -> compiler_source_info.dirname;
     1178 	     if source_info -> compiler_source_info.segname ^= "" then do;
     1179 		seg_ptr -> source.pathname = seg_ptr -> source.pathname || ">";
     1180 		seg_ptr -> source.pathname =
     1181 		     seg_ptr -> source.pathname || source_info -> compiler_source_info.segname;
     1182 	     end;
     1183 
     1184 	     seg_ptr -> source.uid = source_info -> compiler_source_info.unique_id;
     1185 	     seg_ptr -> source.dtm = source_info -> compiler_source_info.date_time_modified;
     1186 
     1187 /* Initialize the lex and get the first significant character in the segment. */
     1188 
     1189 	     call statement_lex$initialize;		/* Sets "type_of_line", subr_options, segment_options */
     1190 
     1191 	     if type_of_line = no_more_source		/* Abort if segment contains no statements. */
     1192 	     then do;
     1193 		call print_message (1);		/* segment contains no source code */
     1194 	     end;
     1195 
     1196 /* SUBPROGRAM LOOP. EXECUTED ONCE FOR EACH SUBPROGRAM. */
     1197 
     1198 	     do while (type_of_line ^= no_more_source);
     1199 
     1200 /* INITIALIZATION REQUIRED FOR EACH SUBPROGRAM. */
     1201 
     1202 /* Build a subprogram header for the subprogram's attributes. */
     1203 
     1204 		cur_subprogram = create_node (subprogram_node, size (subprogram));
     1205 		sub_ptr = addr (OS (cur_subprogram));
     1206 
     1207 		if last_subprogram ^= 0		/* Chain this header in with the others. */
     1208 		then do;
     1209 		     sub_ptr -> previous_subprogram = last_subprogram;
     1210 		     addr (OS (last_subprogram)) -> next_subprogram = cur_subprogram;
     1211 		end;
     1212 		else
     1213 		     first_subprogram = cur_subprogram;
     1214 		last_subprogram = cur_subprogram;
     1215 
     1216 		if seg_ptr -> source.initial_subprogram = 0
     1217 						/* Set field as needed. */
     1218 		     then
     1219 		     seg_ptr -> source.initial_subprogram = cur_subprogram;
     1220 
     1221 		sub_ptr -> first_polish = next_free_polish;
     1222 		sub_ptr -> subprogram.options = subr_options;
     1223 		last_statement = -1;		/* No previous statement. */
     1224 		subprogram_op = 0;			/* Not a function or subroutine yet. */
     1225 		alternate_return_index = 0;		/* argument to implement alternate return */
     1226 
     1227 
     1228 /* If a listing is to be produced, build the listing_info node */
     1229 
     1230 		if produce_listing then do;
     1231 		     listing_info.next = next_free_listing;
     1232 						/* build forward chain */
     1233 
     1234 		     cur_listing = addr (listing_seg (next_free_listing));
     1235 						/* point to new node */
     1236 		     unspec (listing_info) = ZERO;	/* initialize the node */
     1237 		     next_free_listing = next_free_listing + size (listing_info);
     1238 
     1239 		     listing_info.subprogram = cur_subprogram;
     1240 
     1241 		     listing_info.first_cref = number_of_crefs + 1;
     1242 		     listing_info.first_line = last_source_line + 1;
     1243 		end;
     1244 
     1245 
     1246 /* Initialize symbol and label hash tables, and zero count of compiler generated symbols. */
     1247 
     1248 		unspec (hash_table) = ZERO;
     1249 		unspec (label_hash_table) = ZERO;
     1250 		cp_count = 0;			/* Count of compiler generated names. */
     1251 		cp_label_count = 0;			/* Count of compiler labels. */
     1252 
     1253 		have_auto_stmnt = FALSE;		/* information about storage class statements */
     1254 		have_save_stmnt = FALSE;
     1255 
     1256 /* Set up the default mode tables. The letters i thru n are integer. All others are real. */
     1257 
     1258 		do i = 1 to 8;			/* The letters a thru h in each case. */
     1259 		     default_table (i) = attr_table (real_mode);
     1260 		     default_table (i + 26) = attr_table (real_mode);
     1261 		end;
     1262 		do i = 9 to 14;			/* The letters i thru n in each case. */
     1263 		     default_table (i) = attr_table (int_mode);
     1264 		     default_table (i + 26) = attr_table (int_mode);
     1265 		end;
     1266 		do i = 15 to 26;			/* The letters o thru z in each case. */
     1267 		     default_table (i) = attr_table (real_mode);
     1268 		     default_table (i + 26) = attr_table (real_mode);
     1269 		end;
     1270 
     1271 		mode_defined = ZERO;		/* Nothing defined by the user. */
     1272 
     1273 /* Initialize the parse of a subprogram. */
     1274 
     1275 		must_have_label = FALSE;		/* Label not required for first executable statement. */
     1276 		assignment_statement_index = asf_definition;
     1277 						/* First apparent asgn stmnt might be st.func.def. */
     1278 		bypass_first_pending_entry = FALSE;	/* No need to bypass main entry. */
     1279 		pending_entry_cnt = 0;		/* No entries pending. */
     1280 		keyword_index = 1;			/* First statement may be anything. */
     1281 		do_index = 0;			/* Reset do loop stack. */
     1282 		stack_index = lbound (stack, 1);	/* Stack is initially empty. */
     1283 
     1284 		stack_base = stack_index;		/* lex first statement separately because of special case below. */
     1285 
     1286 		call statement_lex (statement_type);	/* Lex the first statement of a subprogram. */
     1287 
     1288 /* Function statements of the form "mode*k function" look like mode statements
     1289*		   to the statement recognizer. Decide if initial mode st is really a func st. */
     1290 
     1291 		allow_star_after = TRUE;		/* Allow either form of function statement. */
     1292 
     1293 		if statement_type >= first_mode_keyword & statement_type <= last_mode_keyword
     1294 						/* a mode st */
     1295 		     then
     1296 		     if token_list (first_token).type = asterisk & first_token + 2 <= last_token then do;
     1297 			if token_list (first_token + 2).type = ident then
     1298 			     if substr (st_copy, token_list (first_token + 2).offset + 1, 8) = "function" then do;
     1299 
     1300 /* Set stmnt type = function_statement + mode. Delete "function" chars. */
     1301 
     1302 				statement_type = function_statement + (statement_type - first_mode_keyword + 1);
     1303 				call split_token (8, first_token + 2, TRUE);
     1304 				allow_star_after = FALSE;
     1305 						/* "*k" field must precede func name. */
     1306 			     end;
     1307 			     else
     1308 				;
     1309 			else			/* process potential character *(*) function */
     1310 			     if token_list (first_token + 1).type = left_parn
     1311 			     & token_list (first_token + 2).type = asterisk
     1312 			     & token_list (first_token + 3).type = right_parn
     1313 			     & token_list (first_token + 4).type = ident & first_token + 4 <= last_token then
     1314 			     if substr (st_copy, token_list (first_token + 4).offset + 1, 8) = "function" then do;
     1315 
     1316 /* re-build the list as if we read 'CHARACTER FUNCTION f*(*) */
     1317 /* list looked like: (referenced to first_token)                                        */
     1318 /* token  -2    -1    0     1     2     3     4              */
     1319 /*      ----- -----   *     (     *     )   FUNCTIONvar      */
     1320 /* and moves to be:      (FUNCTION is deleted)               */
     1321 /* token  -2    -1    0     1     2     3     4              */
     1322 /*      ----- -----  var    *     (     *     )              */
     1323 
     1324 /* Set stmnt type = function_statement + mode. Delete "function" chars. */
     1325 
     1326 				statement_type = function_statement + (statement_type - first_mode_keyword + 1);
     1327 
     1328 				call split_token (8, first_token + 4, TRUE);
     1329 
     1330 				token_list (first_token + 0) = token_list (first_token + 4);
     1331 				token_list (first_token + 4) = token_list (first_token + 3);
     1332 				token_list (first_token + 3) = token_list (first_token + 2);
     1333 				token_list (first_token + 2) = token_list (first_token + 1);
     1334 				token_list (first_token + 1) = token_list (first_token + 3);
     1335 			     end;
     1336 		     end;
     1337 
     1338 /* The first statement of a program unit specifies the type of subprogram. An end line at this point is
     1339*	   legal.  If the first statement is not a subroutine, function, or block data statement,
     1340*             then this is a main program and a "main statement" must be manufactured. */
     1341 
     1342 		if statement_type >= after_subprogram then do;
     1343 		     main_entry_point_name = default_main_entry_point_name;
     1344 		     call build_main_program (build_symbol ((main_entry_point_name), main_attr, SET));
     1345 		end;
     1346 
     1347 /* STATEMENT LOOP. EXECUTED ONCE FOR EACH STATEMENT OF A SUBPROGRAM, EXCEPT THE END LINE. */
     1348 /* Note - a subprogram consisting of only an end_line is diagnosed above. */
     1349 
     1350 		do while (statement_type ^= end_line);
     1351 
     1352 /* This removes some statement types from look up at appropriate time. */
     1353 
     1354 		     if first_keyword (statement_type) > keyword_index then
     1355 			keyword_index = first_keyword (statement_type);
     1356 						/* "Shorten" the keyword list. */
     1357 
     1358 /* Initialize for statement label processing. */
     1359 
     1360 		     END_DO_RANGE = FALSE;		/* This stmnt is not the terminal stmnt of a do loop. */
     1361 		     st_lbl_type = statement_label_type (statement_type);
     1362 
     1363 /* If this is the first executable statement, inhibit future recognition of s.f. defs.
     1364*			Also, if any s.f. defs. have been parsed, emit a label to prevent the
     1365*			execution of the s.f. defs. by erroneous means. */
     1366 
     1367 		     if st_lbl_type = executable_label then
     1368 			if assignment_statement_index ^= assignment_statement then
     1369 			     call finish_sf_defs;
     1370 
     1371 /* If the next statement is executable and there are any entries pending,
     1372*   process them now. */
     1373 
     1374 		     if st_lbl_type = executable_label & pending_entry_cnt > 0 then
     1375 			call process_pending_entries;
     1376 
     1377 /* Process statement label. "statement_label" is set by statement_lex; to zero if no label or value of label.
     1378*   All statement labels are entered in the label table. Only executable labels are checked when looking for
     1379*   the end of a do loop. Only executable stmnts are checked for missing labels. i.e. - the first executable
     1380*   statement after an unconditional transfer of control. */
     1381 
     1382 		     if statement_label ^= 0 then do;
     1383 			statement_label = enter_label (st_lbl_type, statement_label, SET);
     1384 			addr (OS (statement_label)) -> label.not_referencable =
     1385 			     statement_attributes.cant_ref_label (statement_type);
     1386 
     1387 			if produce_listing		/* mark cref node as a defining ref */
     1388 			then do;
     1389 			     if ^(addr (OS (statement_label)) -> label.referenced) then
     1390 				cross_reference (number_of_crefs - 1).line_no =
     1391 				     -cross_reference (number_of_crefs - 1).line_no;
     1392 			     else
     1393 				cross_reference (number_of_crefs).line_no =
     1394 				     -cross_reference (number_of_crefs).line_no;
     1395 			end;
     1396 
     1397 			if st_lbl_type = executable_label then do;
     1398 			     END_DO_RANGE = "0"b;
     1399 
     1400 /* check if this terminates any do loops 
     1401*   if so insure proper nesting of do loops and block if's and pop stack to terinating level */
     1402 
     1403 			     do inx = do_index to 1 by -1 while (^END_DO_RANGE);
     1404 				if do_blockif_stack (inx).do_loop then
     1405 				     END_DO_RANGE = statement_label = do_blockif_stack (inx).label_ptr;
     1406 				if END_DO_RANGE then
     1407 				     do jnx = do_index to inx + 1 by -1;
     1408 					if do_blockif_stack (jnx).do_loop then
     1409 					     call print_message (183, do_blockif_stack (jnx).label_ptr);
     1410 					else
     1411 					     call print_message (184,
     1412 						ltrim (char (do_blockif_stack (jnx).line_number)));
     1413 				     end;
     1414 			     end;
     1415 
     1416 			     if END_DO_RANGE then
     1417 				do_index = inx + 1;
     1418 			     must_have_label = need_label (statement_type);
     1419 						/* Reset need for label on following stmnt. */
     1420 
     1421 			     call emit_operand (statement_label);
     1422 						/* Emit label operand and label operator. */
     1423 			     call emit_operator (label_op);
     1424 			end;
     1425 		     end;
     1426 		     else if st_lbl_type = executable_label then do;
     1427 						/* Executable stmnt without label */
     1428 			if must_have_label & statement_attributes.cant_be_reached (statement_type) then
     1429 			     call print_message (5);	/* statement cannot be referenced */
     1430 			must_have_label = need_label (statement_type);
     1431 		     end;
     1432 
     1433 /* Reset global variables modified by the stmnt parsers. */
     1434 
     1435 		     logical_if_statement = FALSE;	/* Statement is not a logical if statement. */
     1436 		     stack_base = stack_index;	/* Stack can only grow by resetting stack_base. */
     1437 		     current_token = first_token - 1;	/* First token of stmnt is next not current. */
     1438 		     go to parser (statement_type);	/* Actually case(statement_type) */
     1439 
     1440 /* Input conditions true for all statement parsers:
     1441*	1. values of token, token_offset, and token_length are invalid at entry; parsers must get first token by
     1442*	   incrementing current_token; (i.e. - get_next_token(TRUE, ...))
     1443*	2. value of "statement_type" is valid when parser is entered;
     1444*	3. value of "statement_label" is valid when parser is entered (pointer to label operand for statement label);
     1445*
     1446*   Output requirements for each statement parser:
     1447*	1. parser must position after last token processed to allow test for extraneous text;
     1448**/
     1449 
     1450 /* End of case(statement_type) */
     1451 
     1452 
     1453 missing_identifier:
     1454 		     call print_message (10, err_string ());
     1455 		     go to statement_parse_abort;
     1456 
     1457 missing_right_paren:
     1458 		     call print_message (11, err_string ());
     1459 		     go to statement_parse_abort;
     1460 
     1461 missing_slash:
     1462 		     call print_message (13, err_string ());
     1463 		     go to statement_parse_abort;
     1464 
     1465 missing_left_paren:
     1466 		     call print_message (22, err_string ());
     1467 		     go to statement_parse_abort;
     1468 
     1469 missing_comma:
     1470 		     call print_message (26, err_string ());
     1471 		     go to statement_parse_abort;
     1472 
     1473 missing_equals_sign:
     1474 		     call print_message (49, err_string ());
     1475 		     go to statement_parse_abort;
     1476 
     1477 missing_label:
     1478 		     call print_message (23, err_string ());
     1479 		     go to statement_parse_abort;
     1480 
     1481 missing_keyword:
     1482 		     call print_message (40, err_string ());
     1483 		     go to statement_parse_abort;
     1484 invalid_keyword:
     1485 		     call print_message (66, err_string (), keyword_table (statement_type));
     1486 		     go to statement_parse_abort;
     1487 
     1488 invalid_substring:
     1489 		     call print_message (195);
     1490 		     go to statement_parse_abort;
     1491 
     1492 parse_done:					/* Check for extraneous text in statement. */
     1493 		     if current_token <= last_token then
     1494 			if token = right_parn	/* be more explicit if parenthesis */
     1495 			     then
     1496 			     call print_message (90);
     1497 			else
     1498 			     call print_message (6, keyword_table (statement_type));
     1499 						/* extra text */
     1500 
     1501 statement_parse_abort:				/* If stmnt was a logical if, an exit operator must be emitted. */
     1502 		     if logical_if_statement then do;
     1503 			call emit_operator (exit_op);
     1504 		     end;
     1505 
     1506 /* If current stmnt terminates a do loop, emit exit operators for each loop which is terminated, 
     1507*   but not if there is a block if seperating them */
     1508 
     1509 		     if END_DO_RANGE then
     1510 			do do_index = do_index to 1 by -1
     1511 			     while (do_blockif_stack (do_index).do_loop
     1512 			     & statement_label = do_blockif_stack (do_index).label_ptr);
     1513 			     call emit_operator (exit_op);
     1514 			end;
     1515 
     1516 /* Lex the next statement in the subprogram. Reexecute the loop if it is not an end_line. */
     1517 
     1518 		     stack_index = stack_base;	/* Insure validity of what is on the stack. */
     1519 		     last_statement_type = statement_type;
     1520 		     call statement_lex (statement_type);
     1521 		end;				/* END OF STATEMENT LOOP. */
     1522 
     1523 /* The following code is executed after a subprogram is completely parsed. */
     1524 
     1525 		cur_statement = -1;			/* Suppress line number in error msgs. */
     1526 
     1527 /* Check for main program, subroutine, function, or entry point without executable code. */
     1528 
     1529 		if sub_ptr -> subprogram_type ^= block_data
     1530 		     & (assignment_statement_index ^= assignment_statement | pending_entry_cnt > 0) then
     1531 		     call process_pending_entries;
     1532 
     1533 /* Terminate all unended do loops and block ifs for the code generator. */
     1534 
     1535 		do i = do_index to 1 by -1;
     1536 		     if do_blockif_stack (i).do_loop then do;
     1537 			call emit_operator (exit_op);
     1538 			call print_message (8, do_blockif_stack (i).label_ptr);
     1539 		     end;
     1540 		     else do;
     1541 			call emit_operator (item_op);
     1542 			call emit_operator (eol_op);
     1543 			call print_message (178, ltrim (char (do_blockif_stack (i).line_number)));
     1544 		     end;
     1545 		end;
     1546 
     1547 /* Generate a return stmnt if control would pass thru to end_line. Then generate an endunit operator. */
     1548 
     1549 		if ^must_have_label & sub_ptr -> subprogram_type ^= block_data then do;
     1550 		     profile_size = profile_size + 1;
     1551 		     string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     1552 
     1553 		     call emit_return_op;
     1554 		     call emit_statement_op (addr (statement_info));
     1555 						/* NOT in profile or map */
     1556 		end;
     1557 
     1558 		call emit_operator (endunit_op);
     1559 
     1560 /* Indicate default storage class to storage allocator. */
     1561 
     1562 		if ^have_auto_stmnt & ^have_save_stmnt then do;
     1563 		     if have_auto_option | have_static_option then
     1564 			sub_ptr -> default_is.static = have_static_option;
     1565 		     else
     1566 			sub_ptr -> default_is.static = shared_structure.options.user_options.static_storage;
     1567 		end;
     1568 
     1569 		sub_ptr -> default_is.auto = ^sub_ptr -> default_is.static;
     1570 
     1571 /* Save offset of last emitted halfword. */
     1572 
     1573 		sub_ptr -> last_polish = next_free_polish - 1;
     1574 
     1575 
     1576 		call declaration_processor;
     1577 
     1578 
     1579 /* For listings, finish up the listing_info node */
     1580 
     1581 		if produce_listing then do;
     1582 		     listing_info.last_cref = number_of_crefs;
     1583 		     last_source_line = number_of_lines;/* insures comments following endline are printed */
     1584 		end;
     1585 
     1586 /* Get first significant character of next subprogram, if such exists. */
     1587 
     1588 		call statement_lex$get_next_subprogram; /* Sets "type_of_line". */
     1589 	     end;					/* END OF SUBPROGRAM LOOP. */
     1590 
     1591 /* The following code is executed after all subprograms in the current source segment have been parsed. */
     1592 
     1593 	     source_info = addr (other_segment_info);	/* use separate area for second thru nth segments */
     1594 
     1595 	     call get_next_source_seg (source_info);	/* Returns new source info ptr or null. */
     1596 
     1597 	     if source_info = null then
     1598 		source_ptr = null;
     1599 	     else
     1600 		source_ptr = source_info -> compiler_source_info.input_pointer;
     1601 	end;					/* END OF SEGMENT LOOP. */
     1602 
     1603 /* if there is an entry name chain, insure it is separate from the symbol table */
     1604 
     1605 	if last_entry_name ^= 0 then
     1606 	     addr (OS (last_entry_name)) -> symbol.next_symbol = 0;
     1607 	call check_entry_duplication;			/* Ensure no dups */
     1608 
     1609 /* Zero the object segment. */
     1610 
     1611 	unspec (reset_stack) = ZERO;
     1612 	return;
     1613 
     1614 /* BEGIN  ext_parse section - PARSE - split 82-03-29  T. Oke */
     1615 /* Modification History:
     1616*
     1617*83-02-10 HH - Install LA/VLA support.
     1618*82-06-28 TO.  Change INQUIRE keyword "filename=" to "file=" to conform to
     1619*	standard.
     1620*82-05-03 TO. Implement star_extent functions.
     1621*82-05-03 TO. Start on multiply_check option catching.
     1622*82-04-19 TO, Fix bug 287 in declaration_processor - create named_constant if
     1623*	static or automatic variable fit limits.  Stolen from optimizer.
     1624*82-04-05 TO, Fix bug 306 in get_equiv_var, by correctly throwing back a header
     1625*	node if equivalence cannot be made.
     1626*	*/
     1627 
     1628 /* BEGIN case(statement_type) */
     1629 
     1630 /* Case		Program
     1631*
     1632*Syntax:	<program_name>
     1633*
     1634*Polish:	<program_name> <count_op> <main_op> <eol_op>
     1635*
     1636*Notes:	If present, must be the first statement in the source segment.
     1637**/
     1638 
     1639 parser (1):
     1640 	string (cur_stmnt_ptr -> statement.bits) = put_in_map;
     1641 
     1642 	call get_next_token (force_symtab_entry, subprogram_symbol);
     1643 	if token ^= ident then
     1644 	     go to missing_identifier;
     1645 
     1646 	call build_main_program (subprogram_symbol);
     1647 	current_token = current_token + 1;
     1648 	go to parse_done;
     1649 
     1650 /* Case		Block Data
     1651*
     1652*Syntax:	[ <block_data_subprog_name> ] 
     1653*
     1654*Polish:	<non_executable> <block_data>
     1655*
     1656*Notes:
     1657*	sub_ptr		points to subprogram header node in polish
     1658*	subprogram_op, etc	unchanged
     1659*	common_name used to hold the name (or "unnamed name) of sub_prog
     1660*	it is also used in the parsing of common statements.
     1661**/
     1662 parser (2):
     1663 	call emit_operator (block_data_op);
     1664 
     1665 	call get_next_token (ignore_symtab_entry, ignore_value);
     1666 
     1667 	if token = EOS_token then do;
     1668 	     if unnamed_block_data_subprogram ^= 0 then
     1669 		call print_message (15);		/* duplicate unnamed block data subprograms */
     1670 	     unnamed_block_data_subprogram = cur_subprogram;
     1671 	     common_name = unnamed_block_data_subprg_name;
     1672 	end;
     1673 	else if token = ident then do;
     1674 	     common_name = token_string;
     1675 	     current_token = current_token + 1;
     1676 	end;
     1677 	else
     1678 	     goto missing_identifier;
     1679 
     1680 	sub_ptr -> subprogram_type = block_data;
     1681 	SI, sub_ptr -> subprogram.symbol = build_symbol (common_name, no_attributes, SET);
     1682 
     1683 /* if named block data, then indicate it's a user defined name.  build symbol assumes compiler generated names */
     1684 
     1685 	if common_name ^= unnamed_block_data_subprg_name then
     1686 	     addr (OS (SI)) -> symbol.by_compiler = FALSE;
     1687 
     1688 	go to parse_done;
     1689 
     1690 
     1691 /* Case		Subroutine
     1692*
     1693*Syntax:	<subroutine_name> [ ( [ <parameter_list> ] ) ] <eos>
     1694*
     1695*Polish:	<subroutine_name> <parameter_count> <subr>  [ <parameter> <item> ] <eol>
     1696*
     1697*Notes:
     1698*	subprogram_attributes	same as a subroutine
     1699*	subprogram_conflicts	any and all attributes
     1700*	subprogram_op	subroutine opr
     1701**/
     1702 parser (3):
     1703 	string (cur_stmnt_ptr -> statement.bits) = put_in_map;
     1704 
     1705 	call get_next_token (force_symtab_entry, subprogram_symbol);
     1706 	if token ^= ident then
     1707 	     go to missing_identifier;
     1708 
     1709 /* set fields in subprogram node */
     1710 
     1711 	sub_ptr -> subprogram_type = subroutine;
     1712 	sub_ptr -> subprogram.symbol = subprogram_symbol;
     1713 
     1714 /* set global variables for parameter list parse and entry statement parse */
     1715 
     1716 	subprogram_op = subr_op;			/* This symbol and its entries are subroutines. */
     1717 	subprogram_attributes = subroutine_attributes;
     1718 	subprogram_conflicts = all_attributes;
     1719 	return_value_param = 0;			/* used if label args are in parameter list */
     1720 
     1721 	call parse_parameter_list (subprogram_symbol);	/* emits all polish for stmnt and parses param list */
     1722 	go to parse_done;
     1723 
     1724 
     1725 /* Case		Function
     1726*
     1727*Syntax:	[ <mode_keyword> [ <*> <K> ] ] <function_name> ( [ <parameter_list> ] ) <eos>
     1728*
     1729*Polish:	<function_name> <func_count> <func> <parameter> <item> ... <return_value> <item> <eol>
     1730*
     1731*Notes:
     1732*	<func_count> includes return value parameter
     1733**/
     1734 parser (4):
     1735 parser (5):
     1736 parser (6):
     1737 parser (7):
     1738 parser (8):
     1739 parser (9):
     1740 parser (10):
     1741 	string (cur_stmnt_ptr -> statement.bits) = put_in_map;
     1742 	attributes = attr_table (statement_type - function_statement);
     1743 
     1744 /* if mode keyword is provided, set function data type */
     1745 
     1746 	if statement_type = function_statement then
     1747 	     allow_star_after = FALSE;		/* mode not specified, so "*k" is invalid */
     1748 	else if ^allow_star_after			/* i.e., "*k" must appear before name */
     1749 	     then
     1750 	     call get_mode_size (statement_type - function_statement, (default_char_size), attributes, asterisk_seen);
     1751 
     1752 /* get name of function */
     1753 
     1754 	call get_next_token (force_symtab_entry, return_value);
     1755 	if token ^= ident then
     1756 	     go to missing_identifier;
     1757 
     1758 /* if alternate form is possible, check for "*k" */
     1759 
     1760 	if allow_star_after then
     1761 	     call get_mode_size (statement_type - function_statement, (default_char_size), attributes, asterisk_seen);
     1762 
     1763 /* function return value will be in hash table. Set accumulated attributes. */
     1764 
     1765 	attributes = attributes | auto_attribute;	/* force auto storage for return value */
     1766 	if declare_symbol (return_value, attributes, all_attributes, DECLARED) then
     1767 	     ;					/* Error is impossible */
     1768 
     1769 /* function name is not in hash table */
     1770 
     1771 	subprogram_symbol = build_symbol (substr (full_name, 1, symbol_length), no_attributes, SET);
     1772 	addr (OS (subprogram_symbol)) -> symbol.by_compiler = FALSE;
     1773 						/* treat as user symbol */
     1774 
     1775 /* function return value parameter */
     1776 /* do a little work on this to handle character*(*) functions. */
     1777 
     1778 /* if the attributes of the symbol indexed by "return_value" have star_extents
     1779*   then set them here too, and set the return_value as being stack_indirect. */
     1780 
     1781 	return_value_param = build_symbol ((NO_NAME), param_variable_attrs, SET);
     1782 	if addr (OS (return_value)) -> symbol.star_extents then do;
     1783 	     sub_ptr -> subprogram.star_extent_function = "1"b;
     1784 	     addr (OS (return_value)) -> symbol.stack_indirect = "1"b;
     1785 	     addr (OS (return_value_param)) -> symbol.star_extents = "1"b;
     1786 	     addr (OS (subprogram_symbol)) -> symbol.star_extents = "1"b;
     1787 	end;
     1788 
     1789 /* set fields in subprogram node */
     1790 
     1791 	sub_ptr -> subprogram_type = function;
     1792 	sub_ptr -> subprogram.symbol = subprogram_symbol;
     1793 
     1794 /* set global variables for parameter list and entry statement parsers */
     1795 
     1796 	subprogram_op = func_op;
     1797 	subprogram_attributes = function_attribute;
     1798 	subprogram_conflicts = entry_point_conflicts;
     1799 
     1800 	call parse_parameter_list (subprogram_symbol);	/* emits all polish for stmnt and parses param list */
     1801 
     1802 	go to parse_done;
     1803 
     1804 
     1805 /* Case		Implicit
     1806*
     1807*Syntax:
     1808*
     1809*Polish:
     1810*
     1811*Notes:
     1812**/
     1813 parser (11):					/* Parse each mode range separately. */
     1814 	in_stmnt = TRUE;
     1815 	do while (in_stmnt);
     1816 
     1817 /* Get mode type and build attribute bit string. */
     1818 
     1819 	     call get_next_token (ignore_symtab_entry, ignore_value);
     1820 	     if token ^= ident then
     1821 		go to missing_keyword;
     1822 
     1823 	     if length (fast_lookup) - symbol_length > 0	/* pad with blanks when necessary */
     1824 		then
     1825 		substr (fast_lookup, symbol_length + 1, length (fast_lookup) - symbol_length) = NULL_STRING;
     1826 
     1827 	     do i = first_mode_keyword to last_mode_keyword while (keyword_table (i) ^= fast_lookup);
     1828 	     end;
     1829 
     1830 	     if i > last_mode_keyword then
     1831 		go to invalid_keyword;
     1832 
     1833 	     attributes = attr_table (i - first_mode_keyword + 1);
     1834 	     call get_mode_size (i - first_mode_keyword + 1, (default_char_size), attributes, asterisk_seen);
     1835 
     1836 /* Parse letter range(s). */
     1837 
     1838 	     call get_next_token$operator;		/* Get left parenthesis. */
     1839 	     if token ^= left_parn then
     1840 		go to missing_left_paren;
     1841 
     1842 	     in_list = TRUE;
     1843 	     do while (in_list);
     1844 
     1845 /* get the first, or only letter in the range */
     1846 
     1847 		call get_next_token (ignore_symtab_entry, ignore_value);
     1848 		if token ^= ident | symbol_length ^= 1 then do;
     1849 		     call print_message (45, err_string ());
     1850 		     go to statement_parse_abort;
     1851 		end;
     1852 
     1853 		begin_char, end_char = index (alphabetic, substr (full_name, 1, 1));
     1854 
     1855 /* there is a second letter if the first is followed by a hyphen */
     1856 
     1857 		call get_next_token$operator;		/* get comma, right paren, or hyphen (minus) */
     1858 		if token = minus then do;
     1859 		     call get_next_token (ignore_symtab_entry, ignore_value);
     1860 		     if token ^= ident | symbol_length ^= 1 then do;
     1861 			call print_message (45, err_string ());
     1862 			go to statement_parse_abort;
     1863 		     end;
     1864 
     1865 		     end_char = index (alphabetic, substr (full_name, 1, 1));
     1866 
     1867 /* insure the range specified is valid */
     1868 
     1869 		     if end_char < begin_char then do;
     1870 			call print_message (46);	/* chars wrong order */
     1871 			go to statement_parse_abort;
     1872 		     end;
     1873 
     1874 		     if divide (begin_char - 1, 26, 17, 0) ^= divide (end_char - 1, 26, 17, 0) then do;
     1875 			call print_message (47);
     1876 			go to statement_parse_abort;
     1877 		     end;
     1878 
     1879 		     call get_next_token$operator;	/* get comma or right paren */
     1880 		end;
     1881 
     1882 /* regardless of how we got the range, see if it's been used before */
     1883 
     1884 		if substr (mode_defined, begin_char, end_char - begin_char + 1) ^= ZERO then
     1885 		     call print_message (129);
     1886 
     1887 		substr (mode_defined, begin_char, end_char - begin_char + 1) = (26)"1"b;
     1888 
     1889 /* set range to desired type */
     1890 
     1891 		do i = begin_char to end_char;
     1892 		     default_table (i) = attributes;
     1893 		end;
     1894 		if token ^= comma then
     1895 		     in_list = FALSE;
     1896 	     end;
     1897 	     if token ^= right_parn then
     1898 		go to missing_right_paren;
     1899 
     1900 	     call get_next_token$operator;		/* get comma or eos */
     1901 	     if token ^= comma then
     1902 		in_stmnt = FALSE;
     1903 	end;
     1904 	go to parse_done;
     1905 
     1906 
     1907 /* Case		Dimension
     1908*
     1909*Syntax:
     1910*
     1911*Polish:
     1912*
     1913*Notes:
     1914**/
     1915 parser (12):
     1916 	in_list = TRUE;
     1917 	do while (in_list);
     1918 	     call get_next_token (force_symtab_entry, SI);
     1919 	     if token ^= ident then
     1920 		go to missing_identifier;
     1921 
     1922 	     if addr (OS (SI)) -> symbol.referenced	/* Symbol has already been used */
     1923 		then
     1924 		call print_message (140, SI, (keyword_table (statement_type)));
     1925 
     1926 	     call get_next_token$operator;		/* get left paren */
     1927 	     if token ^= left_parn then
     1928 		go to missing_left_paren;
     1929 
     1930 	     call get_bounds (SI);
     1931 	     if token ^= comma then
     1932 		in_list = FALSE;
     1933 	end;
     1934 	go to parse_done;
     1935 
     1936 
     1937 /* Case		Common
     1938*
     1939*Syntax:	[ / [ <name> ] / ] <list> [ / [ <name> ] / <list> ] ...
     1940*
     1941*Polish:	<non_executable>
     1942*
     1943*Notes:
     1944*	common_name	8 (?)-character name of common block, also used in block_data statement parse
     1945*	in_stmnt		on while parsing a common block list; off if current list not followed by another list
     1946*	SI		passes output from get_next_token to other subroutines
     1947*	indx		word offset of current common block header node
     1948*	in_list		on while conditions for loop still hold
     1949**/
     1950 parser (13):
     1951 	call get_next_token (force_symtab_entry, SI);	/* Get slash or first member of list. */
     1952 
     1953 	in_stmnt = TRUE;				/* Indicates more text left to parse. */
     1954 	do while (in_stmnt);			/* Loop for each common list. */
     1955 
     1956 /* Get common block name. */
     1957 
     1958 	     if token = slash			/* Name is given explicitly. */
     1959 	     then do;
     1960 		call get_next_token (ignore_symtab_entry, ignore_value);
     1961 						/* Get slash or block name. */
     1962 
     1963 		if token ^= ident then
     1964 		     go to missing_identifier;
     1965 		common_name = substr (full_name, 1, symbol_length);
     1966 						/* save block name */
     1967 
     1968 		call get_next_token$operator;		/* Get slash. */
     1969 
     1970 		if token ^= slash then
     1971 		     go to missing_slash;
     1972 
     1973 		call get_next_token (force_symtab_entry, SI);
     1974 						/* Get first member of list. */
     1975 	     end;
     1976 	     else if token = concat			/* Two slashes in a row */
     1977 	     then do;
     1978 		common_name = blank_common_name;
     1979 		call get_next_token (force_symtab_entry, SI);
     1980 	     end;
     1981 	     else
     1982 		common_name = blank_common_name;	/* initial common name is omitted */
     1983 
     1984 /* Find header node if already defined or create a new one. */
     1985 
     1986 	     indx = sub_ptr -> common_chain;		/* Get head of list. */
     1987 	     if indx = 0 then do;
     1988 
     1989 /* create a header node for this common block and thread into chain */
     1990 
     1991 		indx = build_common_block (common_name);
     1992 		sub_ptr -> common_chain = indx;
     1993 	     end;
     1994 
     1995 	     else do;				/* List is not empty. */
     1996 		in_list = TRUE;
     1997 		do while (in_list);			/* Search the list. */
     1998 		     if addr (OS (indx)) -> header.block_name = common_name then
     1999 			in_list = FALSE;		/* Found old block. */
     2000 		     else if addr (OS (indx)) -> header.next_header = 0 then do;
     2001 						/* End of list and not found. Create a new header node. */
     2002 			in_list = FALSE;		/* Indicate end of search. */
     2003 
     2004 			addr (OS (indx)) -> header.next_header = build_common_block (common_name);
     2005 			indx = addr (OS (indx)) -> header.next_header;
     2006 		     end;
     2007 
     2008 		     else
     2009 			indx = addr (OS (indx)) -> header.next_header;
     2010 		end;
     2011 	     end;
     2012 
     2013 
     2014 /* If needed, generate cross reference nodes */
     2015 
     2016 	     if produce_listing then
     2017 		call generate_cross_ref (indx);
     2018 
     2019 
     2020 /* Parse common block list. */
     2021 
     2022 	     in_list = TRUE;
     2023 	     do while (in_list);
     2024 		if token ^= ident then
     2025 		     go to missing_identifier;
     2026 
     2027 		if addr (OS (SI)) -> symbol.referenced	/* Symbol has already been used */
     2028 		     then
     2029 		     call print_message (140, SI, (keyword_table (statement_type)));
     2030 
     2031 		if declare_symbol (SI, member_attr, member_conflicts, DECLARED) then do;
     2032 
     2033 /* Thread new member into common block list. */
     2034 
     2035 		     if addr (OS (indx)) -> header.last_element = 0 then
     2036 			addr (OS (indx)) -> header.first_element = SI;
     2037 		     else
     2038 			addr (OS (addr (OS (indx)) -> header.last_element)) -> symbol.next_member = SI;
     2039 		     addr (OS (indx)) -> header.last_element = SI;
     2040 
     2041 		     addr (OS (SI)) -> symbol.parent = indx;
     2042 
     2043 /* insure it is initialized only in a block data subprogram */
     2044 
     2045 		     if addr (OS (SI)) -> symbol.initialed then
     2046 			if sub_ptr -> subprogram_type = block_data then
     2047 			     string (addr (OS (indx)) -> header.storage_info) =
     2048 				string (addr (OS (indx)) -> header.storage_info)
     2049 				| string (addr (OS (SI)) -> symbol.storage_info);
     2050 			else
     2051 			     call print_message (80, SI);
     2052 		end;
     2053 
     2054 		else
     2055 		     call print_message (20, SI, indx); /* Cannot be in this common block. */
     2056 
     2057 /* Process member bound, next member, or end of list. */
     2058 
     2059 		call get_next_token$operator;		/* Get left paren, comma, or slash. */
     2060 		if token = left_parn then
     2061 		     call get_bounds (SI);
     2062 
     2063 		if token = comma then do;
     2064 		     call get_next_token (force_symtab_entry, SI);
     2065 						/* Get next member of list. */
     2066 		     if token = slash | token = concat then
     2067 			in_list = FALSE;
     2068 		end;
     2069 		else
     2070 		     in_list = FALSE;
     2071 	     end;
     2072 	     if token ^= slash & token ^= concat then
     2073 		in_stmnt = FALSE;
     2074 	end;
     2075 	go to parse_done;
     2076 
     2077 
     2078 /* Case		Equivalence
     2079*
     2080*Syntax:
     2081*
     2082*Polish:
     2083*
     2084*Notes:
     2085*	78.06.20 - Parse has been changed so that symbol.equivalenced DOES NOT imply that symbol.parent
     2086*		is valid. symbol.equivalenced may be TRUE while symbol.parent equals zero.
     2087*
     2088*	Automatic storage is equivalence conflict.
     2089**/
     2090 parser (14):
     2091 	in_stmnt = TRUE;
     2092 	do while (in_stmnt);
     2093 	     call get_next_token$operator;		/* get left paren */
     2094 	     if token ^= left_parn then
     2095 		go to missing_left_paren;
     2096 
     2097 	     if token_list (current_token + 2).type = right_parn then do;
     2098 		call print_message (28);		/* at least two required in group */
     2099 		go to statement_parse_abort;
     2100 	     end;
     2101 
     2102 	     call stack_operand ((cur_statement));	/* For error messages. */
     2103 
     2104 	     in_list = TRUE;
     2105 	     do while (in_list);
     2106 		call get_next_token (force_symtab_entry, SI);
     2107 		if token ^= ident then
     2108 		     go to missing_identifier;
     2109 
     2110 		E_token = SI;
     2111 		if addr (OS (SI)) -> symbol.referenced	/* Symbol has already been used */
     2112 		     then
     2113 		     call print_message (140, SI, (keyword_table (statement_type)));
     2114 		else
     2115 		     addr (OS (SI)) -> symbol.in_equiv_stmnt, addr (OS (SI)) -> symbol.equivalenced,
     2116 						/* mark as equiv'd */
     2117 			addr (OS (SI)) -> symbol.variable = TRUE;
     2118 						/* must remain a variable */
     2119 
     2120 		call stack_operand (SI);
     2121 
     2122 		call get_next_token$paren_operator;	/* get comma, left paren, substring left paren, or right paren */
     2123 
     2124 		if token = left_parn | token = substr_left_parn then do;
     2125 
     2126 		     if token = left_parn		/* Parse subscripts */
     2127 			then
     2128 			call stack_operand (get_constant_offset (SI, FALSE));
     2129 						/* inhibit variable subscripts */
     2130 
     2131 		     if token = substr_left_parn	/* Parse substring */
     2132 		     then do;
     2133 			if ^subr_options.ansi_77 then do;
     2134 			     call print_message (154);
     2135 			     goto statement_parse_abort;
     2136 			end;
     2137 			call stack_operand (0);
     2138 
     2139 			call get_next_token (ignore_symtab_entry, SI);
     2140 			if token = dec_int then do;
     2141 			     E_start = binary (addr (st_copy) -> token_structure.token_string, 17);
     2142 
     2143 /* Check the constant start is in range */
     2144 			     if (E_start < 1) then
     2145 				call print_message (155, SI, "Start has a length < 1.");
     2146 			     else if (E_start > addr (OS (E_token)) -> symbol.char_size + 1) then
     2147 				call print_message (155, SI, "Start > length.");
     2148 			     else
     2149 				call stack_operand (E_start - 1);
     2150 
     2151 			     call get_next_token$operator;
     2152 			     if token = colon then do;
     2153 
     2154 				call get_next_token (ignore_symtab_entry, SI);
     2155 				if token = dec_int then do;
     2156 				     E_finish = binary (addr (st_copy) -> token_structure.token_string);
     2157 
     2158 /* Check if the constant finish is in range */
     2159 				     if (E_finish < E_start) then
     2160 					call print_message (155, SI, "Finish < start.");
     2161 				     if (E_finish > addr (OS (E_token)) -> symbol.char_size + 1) then
     2162 					call print_message (155, SI, "Finish > length.");
     2163 				     call get_next_token$operator;
     2164 				end;
     2165 				else if token ^= right_parn then
     2166 				     go to invalid_substring;
     2167 			     end;
     2168 			     else
     2169 				go to invalid_substring;
     2170 			     call get_next_token$operator;
     2171 			end;
     2172 			else if token = colon then do;
     2173 			     E_start = 1;
     2174 			     call stack_operand (E_start - 1);
     2175 			     call get_next_token (ignore_symtab_entry, SI);
     2176 			     if token = dec_int then do;
     2177 				E_finish = binary (addr (st_copy) -> token_structure.token_string);
     2178 						/* Check if the constant finish is in range */
     2179 				if (E_finish < 1) then
     2180 				     call print_message (155, SI, "Finish < 1.");
     2181 				if (E_finish > addr (OS (E_token)) -> symbol.char_size + 1) then
     2182 				     call print_message (155, SI, "Finish > length.");
     2183 				call get_next_token$operator;
     2184 			     end;
     2185 			     else if token ^= right_parn then
     2186 				go to invalid_substring;
     2187 			     call get_next_token$operator;
     2188 			end;
     2189 			else
     2190 			     go to invalid_substring;
     2191 		     end;
     2192 		     else
     2193 			call stack_operand (0);
     2194 		end;
     2195 		else do;
     2196 		     call stack_operand (0);
     2197 		     call stack_operand (0);
     2198 		end;
     2199 
     2200 		if token ^= comma then
     2201 		     in_list = FALSE;
     2202 	     end;
     2203 
     2204 	     if token ^= right_parn then
     2205 		go to missing_right_paren;
     2206 
     2207 	     call stack_operator (-1);		/* End of equivalence group. */
     2208 	     stack_base = stack_index;		/* Prevent the info from being lost. */
     2209 
     2210 	     call get_next_token$operator;		/* get comma or eos */
     2211 	     if token ^= comma then
     2212 		in_stmnt = FALSE;
     2213 	end;
     2214 	go to parse_done;
     2215 
     2216 
     2217 /* Case		Character, Complex, Double Precision, Integer, Logical, Real
     2218*
     2219*Syntax:	[ * k ] <name> [ * k ] [ ( d1 , ... dn ) ] ... [ / <constants> / ] ...
     2220*
     2221*Polish:	<non_executable> [ <increment_polish_op> <halfword> <junk> ]
     2222*     where
     2223*	<halfword> is the number of halfwords in <junk>
     2224*	<junk> is the code representing the data specifications.
     2225*
     2226*Notes:
     2227*	mode_type		mode, or data type, specified by this statement
     2228*	in_stmnt		on if data specifications are encountered; otherwise off
     2229*	char_siz		used only for char stmnt; global char size to be used
     2230*	attributes	attributes to be aplied to the variable being declared
     2231*	SI		passes output from get_next_token to other subroutines
     2232**/
     2233 parser (15):
     2234 parser (16):
     2235 parser (17):
     2236 parser (18):
     2237 parser (19):
     2238 parser (20):
     2239 	mode_type = statement_type - first_mode_keyword + 1;
     2240 						/* Convert stmnt type to mode. */
     2241 	first_word = 0;				/* No "nodes" generated by data specs. */
     2242 	char_siz = default_char_size;			/* Only used if mode is character. */
     2243 	attributes = attr_table (mode_type);
     2244 	call get_mode_size (mode_type, char_siz, attributes, asterisk_seen);
     2245 						/* Get the global mode for this statement. */
     2246 
     2247 	in_list = TRUE;
     2248 	do while (in_list);				/* Loop thru variable list. */
     2249 	     call get_next_token (force_symtab_entry, SI);/* Get variable name. */
     2250 	     if token ^= ident then
     2251 		go to missing_identifier;
     2252 
     2253 	     if addr (OS (SI)) -> symbol.referenced	/* Symbol has already been used */
     2254 		then
     2255 		call print_message (140, SI, (keyword_table (statement_type)));
     2256 
     2257 	     local_attributes = attributes;
     2258 	     call get_mode_size ((mode_type), (char_siz), local_attributes, asterisk_seen);
     2259 						/* Get local attributes, but save global ones. */
     2260 
     2261 	     call stack_operand (SI);			/* Stack it in case of data specifications. */
     2262 
     2263 	     call get_next_token$operator;		/* Get left paren, slash, comma, or eos. */
     2264 
     2265 	     if token = left_parn then do;
     2266 		call get_bounds (SI);		/* Declaring bounds in mode stmnt. */
     2267 		if ^asterisk_seen & mode_type = char_mode then do;
     2268 		     current_token = current_token - 1;
     2269 		     call get_mode_size ((mode_type), (char_siz), local_attributes, asterisk_seen);
     2270 		     call get_next_token$operator;
     2271 		end;
     2272 	     end /* left_parn */;
     2273 	     if ^declare_symbol (SI, local_attributes, type_conflicts, DECLARED) then
     2274 		call print_message (30, keyword_table (statement_type), SI);
     2275 
     2276 	     if token = slash then
     2277 		call parse_data;			/* Data spec in mode stmnt. */
     2278 
     2279 	     if token ^= comma then
     2280 		in_list = FALSE;			/* If no comma, list is done. */
     2281 	end;
     2282 
     2283 /* If data specs generated "nodes" in polish, must indicate how many halfwords are used. */
     2284 	if first_word ^= 0 then
     2285 	     polish_string (first_word) = next_free_polish - first_word - 1;
     2286 
     2287 	go to parse_done;
     2288 
     2289 
     2290 /* Case		External
     2291*
     2292*Syntax:
     2293*
     2294*Polish:
     2295*
     2296*Notes:
     2297**/
     2298 parser (21):
     2299 	in_list = TRUE;
     2300 	do while (in_list);
     2301 	     call get_next_token (force_symtab_entry, SI);
     2302 	     if token ^= ident then
     2303 		go to missing_identifier;
     2304 
     2305 	     if addr (OS (SI)) -> symbol.referenced	/* Symbol has already been used */
     2306 		then
     2307 		call print_message (140, SI, (keyword_table (statement_type)));
     2308 
     2309 /* In ansi66 mode, builtin functions may be declared in external statements */
     2310 
     2311 	     if ^(sub_ptr -> subprogram.options.ansi_77) & (builtin_lookup (SI, NOT_SET)) then do;
     2312 		if ^declare_symbol (SI, no_attributes, bif_conflicts, DECLARED) then
     2313 		     call print_message (30, keyword_table (statement_type), SI);
     2314 		if (builtin_lookup (SI, SET_ATTR)) then do;
     2315 		     call get_next_token$operator;
     2316 		     in_list = (token = comma);
     2317 		end;
     2318 	     end;
     2319 	     else do;
     2320 		if ^declare_symbol (SI, ext_attributes, ext_conflicts, DECLARED) then
     2321 		     call print_message (30, keyword_table (statement_type), SI);
     2322 
     2323 		call get_next_token$operator;		/* get comma, left paren, or eos */
     2324 
     2325 /* the name may optionally be followed by "(descriptors)" */
     2326 
     2327 		if token = left_parn then do;
     2328 		     call get_next_token (ignore_symtab_entry, ignore_value);
     2329 						/* get "descriptors" */
     2330 		     if token ^= ident | substr (full_name, 1, symbol_length) ^= "descriptors" then do;
     2331 			call print_message (044, "descriptors", err_string ());
     2332 			go to statement_parse_abort;
     2333 		     end;
     2334 
     2335 		     call get_next_token$operator;	/* get right paren */
     2336 		     if token ^= right_parn then
     2337 			go to missing_right_paren;
     2338 
     2339 		     addr (OS (SI)) -> symbol.needs_descriptors = TRUE;
     2340 		     addr (OS (SI)) -> symbol.variable_arglist = TRUE;
     2341 		     call get_next_token$operator;	/* get comma or eos */
     2342 		end;
     2343 
     2344 		if token ^= comma then
     2345 		     in_list = FALSE;
     2346 	     end;
     2347 	end;
     2348 	go to parse_done;
     2349 
     2350 /* Case		Intrinsic
     2351*
     2352*Syntax:	<fun> [,<fun>] where <fun> in a builtin function name
     2353*
     2354*Polish:	None
     2355*
     2356*Notes:	Check to see name is not referenced and no declaration conflicts.
     2357*
     2358**/
     2359 parser (22):
     2360 	in_list = TRUE;
     2361 	do while (in_list);
     2362 	     call get_next_token (force_symtab_entry, SI);
     2363 	     if token ^= ident then
     2364 		goto missing_identifier;
     2365 
     2366 	     if addr (OS (SI)) -> symbol.referenced	/* symbol previously used */
     2367 		then
     2368 		call print_message (140, SI, (keyword_table (statement_type)));
     2369 
     2370 	     if ^declare_symbol (SI, no_attributes, bif_conflicts, DECLARED) then
     2371 		call print_message (30, keyword_table (statement_type), SI);
     2372 
     2373 	     if ^builtin_lookup (SI, SET_ATTR)		/* name is not recognized as a builtin */
     2374 		then
     2375 		call print_message (93, SI);
     2376 
     2377 	     call get_next_token$operator;		/* get comma or EOS */
     2378 	     in_list = (token = comma);
     2379 	end /* in_list loop */;
     2380 	goto parse_done;
     2381 
     2382 /* Case		Namelist
     2383*
     2384*Syntax:
     2385*
     2386*Polish:
     2387*
     2388*Notes:
     2389*	Not Audited.
     2390**/
     2391 parser (23):
     2392 	call get_next_token$operator;			/* get slash */
     2393 	if token ^= slash then
     2394 	     go to missing_slash;
     2395 
     2396 	in_stmnt = TRUE;
     2397 	do while (in_stmnt);
     2398 	     call get_next_token (force_symtab_entry, SI);
     2399 	     if token ^= ident then
     2400 		go to missing_identifier;
     2401 
     2402 	     if ^declare_symbol (SI, namelist_attr, all_attributes, DECLARED) then do;
     2403 		if last_statement_type = statement_type & last_namelist = SI then do;
     2404 		     word_offset = last_namelist_word_offset;
     2405 		     next_free_polish = cur_statement;
     2406 		     cur_statement = last_cur_statement;
     2407 		end;
     2408 		else
     2409 		     call print_message (30, keyword_table (statement_type), SI);
     2410 	     end;
     2411 	     else do;
     2412 		call emit_operator (increment_polish_op);
     2413 		call emit_count (word_offset);
     2414 		polish_string (word_offset) = 0;	/* count will always be correct */
     2415 		addr (OS (SI)) -> symbol.initial = word_offset;
     2416 	     end;
     2417 
     2418 	     last_namelist = SI;
     2419 	     last_namelist_word_offset = word_offset;
     2420 
     2421 	     call get_next_token$operator;		/* get slash */
     2422 	     if token ^= slash then
     2423 		go to missing_slash;
     2424 
     2425 	     in_list = TRUE;
     2426 	     do while (in_list);
     2427 		call get_next_token (force_symtab_entry, SI);
     2428 		if token ^= ident then
     2429 		     go to missing_identifier;
     2430 
     2431 		if ^declare_symbol (SI, variable_attributes, variable_conflicts, REF) then
     2432 		     call print_message (10, SI);
     2433 
     2434 		call emit_operand (SI);		/* list is saved in the polish */
     2435 		polish_string (word_offset) = polish_string (word_offset) + 1;
     2436 						/* keep count accurate */
     2437 
     2438 		call get_next_token$operator;		/* get comma, slash, or eos */
     2439 		if token ^= comma then
     2440 		     in_list = FALSE;
     2441 	     end;
     2442 	     if token ^= slash then
     2443 		in_stmnt = FALSE;
     2444 	end;
     2445 	go to parse_done;
     2446 
     2447 
     2448 /* Case		Parameter
     2449*
     2450*Syntax:
     2451*
     2452*Polish:
     2453*
     2454*Notes:
     2455*	Not Audited.
     2456**/
     2457 parser (24):
     2458 	call get_next_token (force_symtab_entry, SI);
     2459 	in_list = TRUE;
     2460 
     2461 /* To de-implement the old style PARAMETER statement, delete the block of
     2462*   code at old_parameter_stmt, and replace the following statement with:
     2463*
     2464*	if token ^= left_parn then go to missing_left_paren;
     2465*
     2466**/
     2467 
     2468 	if token ^= left_parn then
     2469 	     go to old_parameter_statement;
     2470 
     2471 /* New style parameter statement.  Using parse_expression, while round-about
     2472*   insures consistency of expression interpretation with what would be done
     2473*   at run-time.
     2474**/
     2475 
     2476 	parameter_info.start_of_polish = next_free_polish;
     2477 
     2478 	do while (in_list);
     2479 	     call get_next_token (force_symtab_entry, SI);
     2480 	     if token ^= ident then
     2481 		go to missing_identifier;
     2482 
     2483 	     if ^declare_symbol (SI, named_const_attr, named_const_conflicts, DECLARED) then do;
     2484 		call print_message (30, "named constant", SI);
     2485 		SI = 0;				/* indicates an error. */
     2486 	     end;
     2487 	     current_parameter = SI;
     2488 
     2489 	     call get_next_token$operator;		/* get equals  */
     2490 	     if token ^= assign then
     2491 		go to missing_equals_sign;
     2492 
     2493 	     call get_next_token (force_symtab_entry, SI);
     2494 
     2495 	     call parse_expression (any_expression, SI, ignore_bits);
     2496 
     2497 	     if current_parameter > 0 then do;
     2498 		call assign_data_type (current_parameter);
     2499 
     2500 		param_ptr = addr (OS (current_parameter));
     2501 		parameter_info.stack_index = stack_index;
     2502 		parameter_info.max_stack = max_stack;
     2503 		parameter_info.desired_data_type = index (string (param_ptr -> symbol.mode), "1"b);
     2504 		parameter_info.end_of_polish = next_free_polish - 1;
     2505 		parameter_info.rounding = subr_options.do_rounding;
     2506 
     2507 		call fort_eval_parm (addr (parameter_info), (param_ptr -> symbol.name), error_code);
     2508 		max_stack = parameter_info.max_stack;
     2509 
     2510 		if error_code = 0 then do;
     2511 
     2512 /* non-star-extent character parameters require different treatment, since the string must be padded or truncated
     2513*   or padded with blanks to make it of the declared length */
     2514 
     2515 		     if param_ptr -> symbol.mode.character then do;
     2516 
     2517 /* for star extent stuff, set the length to the length of the calculated string, otherwise pad on the right
     2518*   with blanks or truncated to set to declared length */
     2519 
     2520 			if param_ptr -> symbol.star_extents then do;
     2521 			     param_ptr -> symbol.initial = parameter_info.result_location;
     2522 			     param_ptr -> symbol.star_extents = "0"b;
     2523 			     param_ptr -> symbol.mode_bits.char_size =
     2524 				addr (OS (parameter_info.result_location)) -> char_constant.length - 1;
     2525 			end;
     2526 			else do;
     2527 			     param_ptr -> symbol.initial =
     2528 				create_char_constant (
     2529 				substr (addr (OS (parameter_info.result_location)) -> char_constant.value
     2530 				|| copy (" ", max_char_length), 1, param_ptr -> symbol.mode_bits.char_size + 1));
     2531 			end;
     2532 		     end /* character parameters */;
     2533 
     2534 		     else do;
     2535 			param_ptr -> symbol.initial = parameter_info.result_location;
     2536 		     end /* non_character params */;
     2537 
     2538 		end /* error_code = 0 */;
     2539 
     2540 		else do;
     2541 		     param_ptr -> symbol.initial = 0;
     2542 		end /* non_zero error_codes */;
     2543 
     2544 
     2545 	     end;
     2546 
     2547 	     next_free_polish = parameter_info.start_of_polish;
     2548 
     2549 	     if token ^= comma then
     2550 		in_list = FALSE;
     2551 	end;
     2552 
     2553 	if token ^= right_parn then
     2554 	     go to missing_right_paren;
     2555 	current_token = current_token + 1;		/* Skip over the right paren. */
     2556 
     2557 	go to parse_done;
     2558 
     2559 old_parameter_statement:
     2560 	first_time = TRUE;
     2561 
     2562 	do while (in_list);
     2563 	     if ^first_time then
     2564 		call get_next_token (force_symtab_entry, SI);
     2565 	     first_time = FALSE;
     2566 
     2567 	     if token ^= ident then
     2568 		go to missing_identifier;
     2569 
     2570 	     if ^declare_symbol (SI, named_const_attr, all_attributes, DECLARED) then do;
     2571 		call print_message (30, "named constant", SI);
     2572 		SI = 0;				/* indicates an error */
     2573 	     end;
     2574 
     2575 	     call get_next_token$operator;		/* get equals */
     2576 	     if token ^= assign then
     2577 		go to missing_equals_sign;
     2578 
     2579 	     call get_next_token (ignore_symtab_entry, const_index);
     2580 						/* get constant or sign */
     2581 
     2582 	     call parse_a_constant (FALSE, const_index, ignore_octal_value);
     2583 						/* FALSE= octal is invalid */
     2584 
     2585 	     if SI > 0 then
     2586 		addr (OS (SI)) -> symbol.initial = const_index;
     2587 						/* store it only if valid */
     2588 
     2589 	     call get_next_token$operator;		/* get comma or eos */
     2590 	     if token ^= comma then
     2591 		in_list = FALSE;
     2592 	end;
     2593 	go to parse_done;
     2594 
     2595 
     2596 /* Case		Library
     2597*
     2598*Syntax:
     2599*
     2600*Polish:
     2601*
     2602*Notes:
     2603**/
     2604 parser (25):
     2605 	call get_next_token (ignore_symtab_entry, const_index);
     2606 
     2607 	if token ^= char_string then do;
     2608 	     call print_message (53, err_string ());	/* missing char ref */
     2609 	     go to statement_parse_abort;
     2610 	end;
     2611 
     2612 	if options.compile_only			/* If compiling, call our own routine. */
     2613 	     then
     2614 	     call add_to_lib_list (addr (OS (const_index)) -> char_constant.value, code);
     2615 	else
     2616 	     call add_to_lib_list_run (addr (OS (const_index)) -> char_constant.value, code);
     2617 
     2618 	if code ^= 0 then
     2619 	     call print_message (54);			/* illegal pathname */
     2620 	current_token = current_token + 1;
     2621 	go to parse_done;
     2622 
     2623 
     2624 /* Case		Save
     2625*
     2626*Syntax: <eos> | <save-element> [,<save-element>]
     2627*	where save-element is an array-name, a variable-name, or /common-block-name/
     2628*
     2629*Polish: None
     2630*
     2631*Notes: This statement serves to set the save attributes for a symbol.
     2632**/
     2633 parser (26):					/* Save statements and automatic statements cannot co-exist in a program unit. */
     2634 	if have_auto_stmnt then do;
     2635 	     call print_message (38);
     2636 	     go to statement_parse_abort;
     2637 	end;
     2638 
     2639 /* If there is no list, this is a global save statement. */
     2640 
     2641 	if current_token >= last_token then do;
     2642 	     if have_save_stmnt then
     2643 		call print_message (33);		/* global save must be only save stmnt */
     2644 	     else
     2645 		sub_ptr -> default_is.static = TRUE;
     2646 
     2647 	     have_save_stmnt = TRUE;
     2648 
     2649 	     current_token = current_token + 1;
     2650 	     go to parse_done;
     2651 	end;
     2652 
     2653 /* Particular save statement may not follow global one. */
     2654 
     2655 	if sub_ptr -> default_is.static then
     2656 	     call print_message (33);			/* global save statement already encountered */
     2657 	else
     2658 	     sub_ptr -> default_is.auto = TRUE;
     2659 
     2660 	have_save_stmnt = TRUE;
     2661 
     2662 /* Parse list of variable names. */
     2663 
     2664 	in_list = TRUE;
     2665 	do while (in_list);
     2666 	     call get_next_token (force_symtab_entry, SI);
     2667 
     2668 /* if this is a common-block-name, add a header if not there already. header.first_element will be zero */
     2669 
     2670 	     if token = slash then do;
     2671 		call get_next_token (ignore_symtab_entry, ignore_value);
     2672 		if token ^= ident then
     2673 		     goto missing_identifier;
     2674 		common_name = substr (full_name, 1, symbol_length);
     2675 		not_found = TRUE;
     2676 		indx = sub_ptr -> common_chain;
     2677 
     2678 		do while (indx ^= 0 & not_found);
     2679 		     if substr (addr (OS (indx)) -> header.block_name, 1, symbol_length) = common_name then
     2680 			not_found = FALSE;
     2681 		     else
     2682 			indx = addr (OS (indx)) -> header.next_header;
     2683 		end /* search loop for common-block-name */;
     2684 
     2685 /* if not found, then add the header to the end of the chain of headers (or to the start if this is the first header). */
     2686 
     2687 		if not_found then do;
     2688 		     SI = build_common_block (common_name);
     2689 		     if sub_ptr -> common_chain = 0 then
     2690 			sub_ptr -> common_chain = SI;
     2691 		     else
     2692 			addr (OS (indx)) -> header.next_header = SI;
     2693 		end;
     2694 		call get_next_token$operator;
     2695 		if token ^= slash then
     2696 		     goto missing_slash;
     2697 	     end;
     2698 	     else if token ^= ident then
     2699 		go to missing_identifier;
     2700 
     2701 	     else do;
     2702 		if addr (OS (SI)) -> symbol.referenced	/* Symbol has already been used */
     2703 		     then
     2704 		     call print_message (140, SI, (keyword_table (statement_type)));
     2705 
     2706 		if ^declare_symbol (SI, save_attributes, save_conflicts, DECLARED) then
     2707 		     call print_message (30, keyword_table (statement_type), SI);
     2708 	     end;
     2709 	     call get_next_token$operator;		/* get comma or eos */
     2710 	     if token ^= comma then
     2711 		in_list = FALSE;
     2712 	end;
     2713 	go to parse_done;
     2714 
     2715 
     2716 /* Case		Automatic
     2717*
     2718*Syntax:
     2719*
     2720*Polish:	non_executable {increment_polish_op}
     2721*
     2722*Notes:
     2723*	Not audited.
     2724**/
     2725 parser (27):					/* save and automatic statements cannot co-exist in a single program unit */
     2726 	if have_save_stmnt then do;
     2727 	     call print_message (38);
     2728 	     go to statement_parse_abort;
     2729 	end;
     2730 
     2731 	have_auto_stmnt = TRUE;
     2732 	sub_ptr -> default_is.static = TRUE;
     2733 
     2734 
     2735 	in_list = TRUE;
     2736 	do while (in_list);				/* Loop thru variable list. */
     2737 	     call get_next_token (force_symtab_entry, SI);/* Get variable name. */
     2738 	     if token ^= ident then
     2739 		go to missing_identifier;
     2740 
     2741 	     if addr (OS (SI)) -> symbol.referenced	/* Symbol has already been used */
     2742 		then
     2743 		call print_message (140, SI, (keyword_table (statement_type)));
     2744 
     2745 	     if ^declare_symbol (SI, auto_attribute, save_conflicts, DECLARED) then
     2746 		call print_message (30, keyword_table (statement_type), SI);
     2747 
     2748 	     call stack_operand (SI);			/* Stack it in case of data specifications. */
     2749 
     2750 	     call get_next_token$operator;		/* Get left paren or comma. */
     2751 
     2752 	     if token = left_parn then
     2753 		call get_bounds (SI);		/* Declaring bounds in automatic stmnt. */
     2754 
     2755 	     if token ^= comma then
     2756 		in_list = FALSE;			/* If no comma, list is done. */
     2757 	end;
     2758 
     2759 	go to parse_done;
     2760 
     2761 
     2762 /* Case		Statement Function Definition
     2763*
     2764*Syntax:
     2765*
     2766*Polish:
     2767*
     2768*Notes:
     2769*	label_ptr		set in parse loop to point to stmnt's label node
     2770*	SI		st func name
     2771*	indx		arg as provided by user
     2772*	new		arg used by compiler
     2773*	old		previous member of hash chain for indx
     2774**/
     2775 parser (28):
     2776 	saved_number_of_crefs = number_of_crefs;
     2777 
     2778 	call get_next_token (force_symtab_entry, SI);
     2779 	if token ^= ident then
     2780 	     go to missing_identifier;
     2781 
     2782 	if token_list (current_token + 1).type = left_parn & ^COLON_BEFORE_ASSIGN then
     2783 	     if declare_symbol (SI, asf_attribute, asf_conflicts, DECLARED) then do;
     2784 
     2785 		profile_size = profile_size + 1;	/* profile entry required by this statement */
     2786 		string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     2787 
     2788 		current_token = current_token + 1;
     2789 
     2790 /* The statement function definition (sfd) will now be placed in the polish string
     2791*		   using the expression parser. The fields, symbol.initial and symbol.dimension,
     2792*		   are used to store the offset of the first word of the sfd and the offset of
     2793*		   the first word after the sfd. If the sf is not referenced, these values are
     2794*		   used to "remove" the sfd from the polish string. */
     2795 
     2796 		addr (OS (SI)) -> symbol.initial = next_free_polish;
     2797 						/* offset of first word. */
     2798 
     2799 		call emit_operand (SI);
     2800 		call emit_operator (sf_def_op);
     2801 		last_element = 0;
     2802 		count = 0;
     2803 
     2804 /* if the next token is a right_paren, then an empty arg list, no need to scan */
     2805 		in_list = (token_list (current_token + 1).type ^= right_parn);
     2806 		if ^in_list then
     2807 		     call get_next_token$operator;
     2808 
     2809 		do while (in_list);
     2810 		     call get_next_token (locate_symtab_entry, indx);
     2811 		     if token ^= ident then
     2812 			go to missing_identifier;
     2813 
     2814 		     count = count + 1;
     2815 
     2816 		     if indx = 0 then
     2817 			call find_symbol_index (symbol_length, new, force_symtab_entry, old);
     2818 		     else do;
     2819 			call find_symbol_index (symbol_length, indx, force_symtab_entry, old);
     2820 			new = build_symbol (substr (full_name, 1, symbol_length),
     2821 			     unspec (addr (OS (indx)) -> symbol.mode_bits), DECLARED);
     2822 			addr (OS (new)) -> symbol.hash_chain = indx;
     2823 
     2824 			if old > hbound (hash_table, 1) then
     2825 			     addr (OS (old)) -> symbol.hash_chain = new;
     2826 			else
     2827 			     hash_table (old) = new;
     2828 		     end;
     2829 
     2830 		     if ^declare_symbol (new, auto_attribute, variable_conflicts, DECLARED) then
     2831 			call print_message (30, keyword_table (statement_type), new);
     2832 						/* conflicting attr. */
     2833 
     2834 		     addr (OS (new)) -> symbol.parent = old;
     2835 		     addr (OS (new)) -> symbol.general = last_element;
     2836 
     2837 		     addr (OS (new)) -> symbol.by_compiler = TRUE;
     2838 						/* flag as special symbol */
     2839 		     addr (OS (new)) -> symbol.dummy_arg = TRUE;
     2840 						/* flag as stmnt func param */
     2841 
     2842 		     if last_element = 0 then
     2843 			addr (OS (SI)) -> symbol.next_member = new;
     2844 		     else
     2845 			addr (OS (last_element)) -> symbol.next_member = new;
     2846 		     last_element = new;
     2847 
     2848 		     call get_next_token$operator;	/* get comma or right paren */
     2849 		     if token ^= comma then
     2850 			in_list = FALSE;
     2851 		end;
     2852 		if token ^= right_parn then
     2853 		     go to missing_right_paren;
     2854 
     2855 		call get_next_token$operator;		/* get equals */
     2856 		if token ^= assign then
     2857 		     go to missing_equals_sign;
     2858 
     2859 		call get_next_token (force_symtab_entry, indx);
     2860 		call parse_expression (any_expression, indx, ignore_bits);
     2861 
     2862 		do i = last_element repeat addr (OS (i)) -> symbol.general while (i ^= 0);
     2863 		     if ^addr (OS (i)) -> symbol.referenced
     2864 						/* Check for unused parameter. */
     2865 		     then do;
     2866 			addr (OS (i)) -> symbol.allocate = TRUE;
     2867 			call print_message (68, i, SI);
     2868 		     end;
     2869 
     2870 		     old = addr (OS (i)) -> symbol.parent;
     2871 
     2872 		     if old > hbound (hash_table, 1) then
     2873 			addr (OS (old)) -> symbol.hash_chain = addr (OS (i)) -> symbol.hash_chain;
     2874 		     else
     2875 			hash_table (old) = addr (OS (i)) -> symbol.hash_chain;
     2876 
     2877 		     addr (OS (i)) -> symbol.parent = SI;
     2878 		end;
     2879 
     2880 		call emit_operator (exit_op);
     2881 
     2882 		addr (OS (SI)) -> symbol.dimension = next_free_polish;
     2883 						/* offset of 1st word after sfd */
     2884 
     2885 		if count > 511 then do;
     2886 		     call print_message (55, 511 - bias);
     2887 						/* implementation restriction */
     2888 		     count = 511;
     2889 		end;
     2890 
     2891 		addr (OS (SI)) -> symbol.char_size = count;
     2892 
     2893 		go to parse_done;
     2894 	     end;
     2895 
     2896 /* Control passes this point only if the statement cannot be an asf def. Stmnt becomes an assignment. */
     2897 
     2898 	call finish_sf_defs;			/* End of sf defs. Emit by-pass label. */
     2899 
     2900 /* Process all pending entries now. */
     2901 	if pending_entry_cnt > 0 then
     2902 	     call process_pending_entries;
     2903 
     2904 	current_token = first_token - 1;
     2905 	number_of_crefs = saved_number_of_crefs;
     2906 
     2907 	if statement_label ^= 0 then do;
     2908 	     string (addr (OS (statement_label)) -> label.usage) = executable_label;
     2909 	     call emit_operand (statement_label);
     2910 	     call emit_operator (label_op);
     2911 	end;
     2912 
     2913 	statement_type = assignment_statement;
     2914 	keyword_index = first_keyword (assignment_statement);
     2915 
     2916 /* assignment statement parse code must follow. */
     2917 
     2918 
     2919 /* Case		Assignment
     2920*
     2921*Syntax:
     2922*
     2923*Polish:
     2924*
     2925*Notes:
     2926**/
     2927 parser (60):
     2928 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     2929 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     2930 
     2931 	call get_next_token (force_symtab_entry, SI);
     2932 
     2933 /* test for the assignment being to the typeless function "fld".  This is the
     2934*only builtin function that can appear on the left hand side of an equal sign */
     2935 
     2936 	if (addr (OS (SI)) -> symbol.name = "fld" & ^addr (OS (SI)) -> symbol.dimensioned
     2937 	     & token_list (current_token + 1).type = left_parn & ^addr (OS (SI)) -> symbol.mode.character) then do;
     2938 	     call get_next_token (force_symtab_entry, SI);/* swallow left paren */
     2939 	     call get_next_token (force_symtab_entry, SI);
     2940 	     do i = 1 to 2;
     2941 		call parse_expression (any_expression, SI, ignore_bits);
     2942 		if token ^= comma then
     2943 		     go to missing_comma;
     2944 		call get_next_token (force_symtab_entry, SI);
     2945 	     end;
     2946 	     call parse_expression (set_reference, SI, ignore_bits);
     2947 	     if token ^= right_parn then
     2948 		go to missing_right_paren;
     2949 	     call get_next_token (force_symtab_entry, SI);
     2950 	     if token ^= assign then
     2951 		go to missing_equals_sign;
     2952 	     call get_next_token (force_symtab_entry, SI);
     2953 	     call parse_expression (any_expression, SI, ignore_bits);
     2954 	     call emit_operator (lhs_fld_op);
     2955 	     go to parse_done;
     2956 	end;
     2957 	call parse_expression (set_reference, SI, ignore_bits);
     2958 	if token ^= assign then
     2959 	     go to missing_equals_sign;
     2960 
     2961 	call get_next_token (force_symtab_entry, SI);
     2962 	call parse_expression (any_expression, SI, ignore_bits);
     2963 	call emit_operator (assign_op);
     2964 	go to parse_done;
     2965 
     2966 /* Case		Elseif
     2967*
     2968*Syntax:	elseif <left_parn> <expression> <right_parn> then
     2969*
     2970*Polish: 	<item_op> <polish for expression> <else_if_op>
     2971*
     2972*Notes:	Must check for proper nesting, but in most ways this is much like
     2973*the parsing of block if's, so we parse it the same way.  A new statement is
     2974*created for the logical expression and else_if_op for the benefit of profiling
     2975*and setting breakpoints.
     2976*
     2977**/
     2978 
     2979 parser (30):					/* this stmnt NOT in profile or map */
     2980 	call emit_operator (item_op);			/* elseif's terminate previous block ifs */
     2981 	call emit_statement_op (cur_stmnt_ptr);		/* make new statement for if part */
     2982 						/* fall through to if parser */
     2983 
     2984 /* Case		If
     2985*
     2986*Syntax:	if <left_parn> <expression> <right_parn> <logical, block or arithmetic if>
     2987*	<logical if> ::= <some legit second statment>
     2988*	<arithmetic if>::= <a sequence of labels for jumps>
     2989*	<block if>::= then
     2990*
     2991*Polish:
     2992*
     2993*Notes:
     2994**/
     2995 
     2996 parser (29):
     2997 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     2998 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     2999 
     3000 /* Parse if statement expression. */
     3001 
     3002 	call get_next_token$operator;			/* Get left paren. */
     3003 	if token ^= left_parn then
     3004 	     go to missing_left_paren;
     3005 
     3006 	call get_next_token (force_symtab_entry, SI);	/* Get first token of expression. */
     3007 	call parse_expression (any_expression, SI, ignore_bits);
     3008 	if token ^= right_parn then
     3009 	     go to missing_right_paren;
     3010 
     3011 	call get_next_token (ignore_symtab_entry, ignore_value);
     3012 						/* Get integer, comma, or statement keyword. */
     3013 
     3014 /* Arithmetic-if statement if integer or comma, and not an ELSEIF. */
     3015 
     3016 	if statement_type ^= elseif_statement & (token = dec_int | token = comma) then do;
     3017 	     if END_DO_RANGE & ^logical_if_statement then
     3018 		call print_message (16, keyword_table (statement_type));
     3019 						/* cannot terminate do loop */
     3020 
     3021 /* Parse three target labels. */
     3022 
     3023 	     do i = 1 to 3;
     3024 		if token = dec_int			/* label is given */
     3025 		then do;
     3026 		     call emit_operand (enter_label (executable_label, (addr (work) -> based_integer), GOTO_REF));
     3027 		     call get_next_token$operator;	/* get comma or eos */
     3028 		end;
     3029 
     3030 		else if token = comma | token = EOS_token
     3031 						/* label is omitted */
     3032 		then do;
     3033 		     must_have_label = FALSE;
     3034 		     call emit_count (ignore_value);
     3035 		end;
     3036 
     3037 		else
     3038 		     go to missing_label;		/* syntax error */
     3039 
     3040 /* Commas must appear between the labels, even if the labels are omitted. */
     3041 
     3042 		if i < 3 then do;
     3043 		     if token ^= comma then
     3044 			go to missing_comma;
     3045 
     3046 		     call get_next_token$label (ignore_symtab_entry, ignore_value);
     3047 		end;
     3048 	     end;
     3049 	     call emit_operator (jump_arithmetic_op);
     3050 	     go to parse_done;
     3051 	end;
     3052 
     3053 /* Parse logical-if, block-if, and else-if statements. */
     3054 
     3055 	if logical_if_statement then
     3056 	     call print_message (42, "logical if");	/* illegal second statement */
     3057 
     3058 /* distinguish between logical if's and (block if's and else if's) */
     3059 
     3060 	logical_if_statement =
     3061 	     statement_type ^= elseif_statement & (SECOND_EQUALS | substr (full_name, 1, token_length) ^= "then");
     3062 	must_have_label = FALSE;
     3063 
     3064 	if logical_if_statement then do;
     3065 	     if SECOND_EQUALS then
     3066 		statement_type = assignment_statement;
     3067 	     else
     3068 		call statement_lex$recognize_statement (statement_type);
     3069 						/* Get second stmnt type. */
     3070 
     3071 	     call emit_operator (jump_logical_op);
     3072 
     3073 	     if ^ok_second_statement (statement_type) then
     3074 		call print_message (42, keyword_table (statement_type));
     3075 						/* illegal second statement */
     3076 
     3077 /* Now process the second statement. In order to make the profile option work usefully, a second
     3078*	   stat_op will be generated in the polish. This allows separated counts for the if statement and
     3079*	   its then clause. */
     3080 
     3081 	     call emit_statement_op (cur_stmnt_ptr);
     3082 
     3083 	     profile_size = profile_size + 1;		/* profile entry required by this statement */
     3084 	     string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     3085 
     3086 	     current_token = current_token - 1;		/* Backup lex for all parsers. */
     3087 	     go to parser (statement_type);
     3088 	end /* logical_if_statement */;
     3089 
     3090 	else do;					/*  else if and block if */
     3091 	     if END_DO_RANGE then
     3092 		call print_message (16, keyword_table (statement_type));
     3093 
     3094 	     if substr (full_name, 1, token_length) ^= "then"
     3095 						/* required keyword */
     3096 		then
     3097 		call print_message (179, "then", keyword_table (statement_type));
     3098 
     3099 	     else if statement_type = elseif_statement then do;
     3100 		current_token = current_token + 1;
     3101 
     3102 /* elseif must be nested in blockif's not do loops, peel off erroneous do's */
     3103 
     3104 		do do_index = do_index to 1 by -1 while (do_blockif_stack (do_index).do_loop);
     3105 		     call print_message (182, do_blockif_stack (do_index).label_ptr, keyword_table (statement_type));
     3106 		end;
     3107 
     3108 		if do_index = 0			/* insure that elseif follows a if at same level */
     3109 		     then
     3110 		     call print_message (180, keyword_table (statement_type));
     3111 
     3112 		else if do_blockif_stack (do_index).else_seen
     3113 						/* cant follow else on same level */
     3114 		     then
     3115 		     call print_message (181, keyword_table (statement_type));
     3116 
     3117 		else do;
     3118 		     call emit_operator (else_if_op);
     3119 		     do_blockif_stack (do_index).clauses = do_blockif_stack (do_index).clauses + 1;
     3120 		end;
     3121 	     end;
     3122 	     else do;
     3123 		if do_index = hbound (do_blockif_stack, 1)
     3124 						/* stack oflo */
     3125 		     then
     3126 		     call print_message (27, hbound (do_blockif_stack, 1) - bias);
     3127 		else do;				/* block if */
     3128 		     current_token = current_token + 1;
     3129 		     call emit_count (word_offset);
     3130 		     call emit_operator (block_if_op);
     3131 
     3132 /* pop up the do_blockif_stack and set values */
     3133 
     3134 		     do_index = do_index + 1;
     3135 		     do_blockif_stack (do_index).do_loop = "0"b;
     3136 		     do_blockif_stack (do_index).clauses = 1;
     3137 		     do_blockif_stack (do_index).line_number = line_number - 1;
     3138 		     do_blockif_stack (do_index).count_op = word_offset;
     3139 		     do_blockif_stack (do_index).else_seen = "0"b;
     3140 		end;
     3141 	     end;
     3142 	end /* block_if and else if */;
     3143 	goto parse_done;
     3144 
     3145 /* Case		Else
     3146*
     3147*Syntax:	else
     3148*
     3149*Polish:	<item op> <else op>
     3150*
     3151*Notes: 	An else clause if valid iff it exists within a block_if  and is nested properly
     3152*	within the do_blockif_stack, nor can it be the object of a GOTO .
     3153**/
     3154 /* Case		Endif
     3155*
     3156*Syntax: endif
     3157*
     3158*Polish: <item_op> <eol_op>
     3159*
     3160*Notes:  In addition to checking for the nesting of the block_if's and the do loops, the endif
     3161*        must also properly set the count in the count_op emitted by the block_if
     3162**/
     3163 
     3164 parser (31):
     3165 parser (32):
     3166 	profile_size = profile_size + 1;		/* profile entry required by these statements */
     3167 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     3168 	current_token = current_token + 1;
     3169 
     3170 	if END_DO_RANGE then
     3171 	     call print_message (16, keyword_table (statement_type));
     3172 
     3173 	do do_index = do_index to 1 by -1 while (do_blockif_stack (do_index).do_loop);
     3174 	     call print_message (182, do_blockif_stack (do_index).label_ptr, keyword_table (statement_type));
     3175 	end;
     3176 
     3177 	if do_index = 0				/* nesting check */
     3178 	     then
     3179 	     call print_message (180, keyword_table (statement_type));
     3180 
     3181 	else if statement_type = else_statement then do;
     3182 	     if do_blockif_stack (do_index).else_seen	/* cant have > 1 else at same level */
     3183 		then
     3184 		call print_message (181, keyword_table (statement_type));
     3185 	     else do;
     3186 		call emit_operator (item_op);
     3187 		call emit_operator (else_op);
     3188 		do_blockif_stack (do_index).clauses = do_blockif_stack (do_index).clauses + 1;
     3189 		do_blockif_stack (do_index).else_seen = "1"b;
     3190 	     end;
     3191 	end;
     3192 
     3193 	else do;					/* endif statement */
     3194 	     call emit_operator (item_op);
     3195 	     call emit_operator (eol_op);
     3196 
     3197 /* having come to the end of the blockif, set count operator reserved by the block if and pop stack */
     3198 
     3199 	     polish_string (do_blockif_stack (do_index).count_op) = do_blockif_stack (do_index).clauses - bias;
     3200 	     do_index = do_index - 1;
     3201 	end;
     3202 
     3203 	goto parse_done;
     3204 
     3205 /* Case		Goto
     3206*
     3207*Syntax:
     3208*
     3209*Polish:
     3210**/
     3211 parser (33):
     3212 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     3213 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     3214 
     3215 	if END_DO_RANGE & ^logical_if_statement then
     3216 	     call print_message (16, keyword_table (statement_type));
     3217 						/* cannot terminate do loop */
     3218 
     3219 /* First token of statement determines type of goto. */
     3220 
     3221 	call get_next_token$label (force_symtab_entry, SI);
     3222 						/* Get label, name, or left paren. */
     3223 
     3224 	if token = dec_int				/* UNCONDITIONAL GOTO */
     3225 	then do;
     3226 	     call emit_operand (enter_label (executable_label, (addr (work) -> based_integer), GOTO_REF));
     3227 	     call emit_operator (jump_op);
     3228 	     current_token = current_token + 1;
     3229 	end;
     3230 
     3231 	else if token = ident			/* ASSIGNED GOTO */
     3232 	then do;
     3233 	     if token_list (current_token + 1).type ^= left_parn then do;
     3234 		call parse_expression (simple_reference, SI, out);
     3235 
     3236 		if addr (out) -> expression.not_simple_ref
     3237 						/* must check result ourselves */
     3238 		     then
     3239 		     call print_message (143, SI);
     3240 	     end;
     3241 	     else do;				/* Let parse expression do its trick */
     3242 		token_list (current_token + 1).type = comma;
     3243 						/* Tell a white lie */
     3244 		call parse_expression (simple_reference, SI, out);
     3245 		if addr (out) -> expression.not_simple_ref then
     3246 		     call print_message (143, SI);
     3247 		token, token_list (current_token).type = left_parn;
     3248 	     end;
     3249 
     3250 	     call emit_operator (jump_assigned_op);
     3251 
     3252 	     if token = comma then do;
     3253 		call get_next_token$operator;		/* get left paren */
     3254 		if token ^= left_parn then
     3255 		     go to missing_left_paren;
     3256 	     end;
     3257 
     3258 	     if token = left_parn then do;
     3259 		call scan_label_list (FALSE);		/* Returns pointing to right paren. */
     3260 		current_token = current_token + 1;
     3261 	     end;
     3262 	end;
     3263 
     3264 	else if token = left_parn			/* COMPUTED GOTO */
     3265 	then do;
     3266 	     call scan_label_list (TRUE);		/* Returns pointing to right paren. */
     3267 	     call get_next_token (force_symtab_entry, SI);
     3268 	     if token = comma then
     3269 		call get_next_token (force_symtab_entry, SI);
     3270 	     call parse_expression (any_expression, SI, ignore_bits);
     3271 	     call emit_operator (exit_op);
     3272 	     must_have_label = FALSE;			/* label not required after computed goto */
     3273 	end;
     3274 
     3275 	else do;					/* syntax error */
     3276 	     call print_message (41, err_string ());	/* missing  int, ident, or left paren */
     3277 	     go to statement_parse_abort;
     3278 	end;
     3279 	go to parse_done;
     3280 
     3281 
     3282 /* Case		Call
     3283*
     3284*Syntax:	<subroutine name> [ ( [ <subroutine arg list> ] ) ]
     3285*
     3286*Polish:	<subroutine name> <arg count> <call_op> [ <arg_list> ] <eol_op>
     3287*
     3288*Notes:
     3289*	SI	passes output from get_next_token to parse_expr
     3290**/
     3291 parser (34):
     3292 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     3293 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     3294 
     3295 	call get_next_token (force_symtab_entry, SI);	/* Get subroutine name. */
     3296 	if token ^= ident then
     3297 	     go to missing_identifier;
     3298 
     3299 	if ^declare_symbol (SI, subroutine_reference, subroutine_conflicts, REF) then
     3300 	     call print_message (21, SI);
     3301 
     3302 /* if the arg list contains label constants, must initialize alt ret value */
     3303 
     3304 	if label_args then do;
     3305 	     if alternate_return_index = 0		/* first ref so create it */
     3306 		then
     3307 		alternate_return_index = build_symbol ((NO_NAME), auto_attribute | attr_table (int_mode), PASSED);
     3308 
     3309 	     call emit_operand (alternate_return_index);
     3310 	     call emit_operand (value_0);
     3311 	     call emit_operator (assign_op);
     3312 	end;
     3313 
     3314 /* emit polish for a call statement */
     3315 
     3316 	call emit_operand (SI);
     3317 	call emit_count (word_offset);
     3318 	call emit_operator (call_op);
     3319 
     3320 /* parse the argument list */
     3321 
     3322 	call get_next_token$operator;			/* Get left paren or eos. */
     3323 
     3324 	if token = left_parn then do;
     3325 	     count = 0;
     3326 
     3327 	     if addr (OS (SI)) -> symbol.needs_descriptors then
     3328 		arg_type = darg_list_expr;
     3329 	     else
     3330 		arg_type = arg_list_expr;
     3331 
     3332 	     in_list = (token_list (current_token + 1).type ^= right_parn);
     3333 	     if ^in_list then
     3334 		call get_next_token$operator;
     3335 
     3336 	     do while (in_list);
     3337 		call get_next_token (force_symtab_entry, indx);
     3338 						/* Get next argument. expression or label const */
     3339 
     3340 		if token = label_const then do;
     3341 		     call stack_operand (indx);
     3342 		     call get_next_token$operator;	/* get comma or right paren */
     3343 		end;
     3344 		else do;
     3345 		     call parse_expression (arg_type, indx, ignore_bits);
     3346 		     call emit_operator (item_op);
     3347 		     count = count + 1;
     3348 		end;
     3349 
     3350 		if token ^= comma then
     3351 		     in_list = FALSE;
     3352 	     end;
     3353 
     3354 	     if token ^= right_parn then
     3355 		go to missing_right_paren;
     3356 	     current_token = current_token + 1;		/* skip over paren */
     3357 
     3358 /* if there are label args, include alt ret value in arg list */
     3359 
     3360 	     if label_args then do;
     3361 		call emit_operand (alternate_return_index);
     3362 		call emit_operator (item_op);
     3363 		count = count + 1;
     3364 	     end;
     3365 
     3366 /* check number of arguments and update count word */
     3367 
     3368 	     if count > max_arglist then
     3369 		call print_message (138, max_arglist - bias, SI);
     3370 
     3371 	     polish_string (word_offset) = count - bias;
     3372 	end;
     3373 
     3374 	call emit_operator (eol_op);			/* terminate call arg list */
     3375 
     3376 /* alternate return is implemented as computed goto */
     3377 
     3378 	if stack_index - stack_base > 0 then do;
     3379 	     call emit_halfword ((stack_index - stack_base) - bias);
     3380 						/* count of labels */
     3381 	     call emit_operator (jump_computed_op);
     3382 
     3383 	     do i = stack_base to stack_index - 1;	/* copy the labels into the polish */
     3384 		call emit_operand (stack (i));
     3385 		call emit_operator (item_op);
     3386 	     end;
     3387 	     call emit_operator (eol_op);		/* end of the list */
     3388 
     3389 	     call emit_operand (alternate_return_index);	/* computed goto expression */
     3390 	     call emit_operator (exit_op);		/* end of expression */
     3391 	end;
     3392 	go to parse_done;
     3393 
     3394 
     3395 /* Case		Continue
     3396*
     3397*Syntax:
     3398*
     3399*Polish:
     3400*
     3401*Notes:
     3402**/
     3403 parser (35):
     3404 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     3405 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     3406 
     3407 	current_token = current_token + 1;
     3408 	go to parse_done;
     3409 
     3410 
     3411 /* Case		Write
     3412*
     3413*Syntax:
     3414*
     3415*Polish:
     3416*
     3417*Notes:
     3418**/
     3419 parser (36):
     3420 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     3421 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     3422 
     3423 	call parse_io (FALSE);
     3424 	go to parse_done;
     3425 
     3426 
     3427 /* Case		Format
     3428*
     3429*Syntax:
     3430*
     3431*Polish:
     3432*
     3433*Notes:
     3434**/
     3435 parser (37):
     3436 	if statement_label = 0 then
     3437 	     call print_message (37);			/* format statement without label */
     3438 
     3439 	call create_format (format_string, statement_label);
     3440 	current_token = last_token + 1;
     3441 	go to parse_done;
     3442 
     3443 
     3444 /* Case		Data
     3445*
     3446*Syntax:
     3447*
     3448*Polish:
     3449*
     3450*Notes:
     3451*	The stack is built up with a series of "nodes", which are then interpreted by parse_data as it works its way 
     3452*	through the list of data elements.  The first word of each node determines what type of node it is.  A node may
     3453*	be any of the following:
     3454*
     3455*	(1) a scalar variable node, which corresponds to the appearance of a scalar variable in the target list.
     3456*	It consists of a single word containing the index of the symbol node of the variable.
     3457*
     3458*	(2) an array name node, which corresponds to the appearance of an array name in the target list.  It
     3459*	consists of a single word containing the index of the symbol node of the array.
     3460*
     3461*	(3) a BEGIN_DO_LOOP node, which corresponds to the start of an implied do-loop in the target list.  It
     3462*	consists of 8 or more words.  The first word contains BEGIN_DO_LOOP, the code for this type of node.  The
     3463*	second word contains the index of the symbol node for the index variable of the loop.  The remaining words
     3464*	contain the Polish for the initial, final and increment expressions of the loop.  The first word of each
     3465*	expression is not part of the Polish, but rather the count of the number of following words which are the
     3466*	Polish.  The Polish is slightly nonstandard in that a variable (which must be an index of a containing
     3467*	implied loop) is represented by a negative value whose absolute value is the index in the stack of the
     3468*	symbol node index of the BEGIN_DO_LOOP node for the implied loop having the variable as its index. (Note
     3469*	that 'parse_data' will keep the current value of the loop index in that same location.)
     3470*
     3471*	(4) an END_DO_LOOP node, which corresponds to the end of an implied do-loop in the target list.  It
     3472*	consists of a single word containing END_DO_LOOP, the code for this type of node.
     3473*
     3474*	(5) a SUBSTRING node, which corresponds to a substring of a variable in the target list.  It consists
     3475*	of 6 or more words.  The first contains SUBSTR, the code for this type of node.  The second contains
     3476*	the index of the symbol node for the variable.  The remaining words contain the Polish (in the same
     3477*	format as the expressions in a BEGIN_DO_LOOP node) for the start and finish positions of the substring.
     3478*
     3479*	(6) a SUBSCRIPTED_VAR node, which corresponds to a subscripted variable in the target list.  It
     3480*	consists of 6 or more words.  The first contains SUBSCRIPTED_VAR, the code for this type of node.
     3481*	The second contains the index of the symbol node for the variable.  The remaining words contain the
     3482*	Polish for the subscript expressions, in the same format as the expressions in a BEGIN_DO_LOOP node.
     3483*
     3484*	(7) a SUBSCRIPTED_SUBSTR node, which corresponds to a substring of a subscripted variable in the target
     3485*	list.  It consists of 10 or more words.  The first contains SUBSCRIPTED_SUBSTR, the code for this type
     3486*	of node.  The second contains the index of the symbol node for the variable.  The remaining words contain
     3487*	the Polish for the subscript expressions, followed by the Polish for the start and finish positions of the
     3488*	substring.
     3489*
     3490*	(8) a SKIP node, which corresponds to a substring, subscripted variable or subscripted substring
     3491*	in the target list in which an error was detected.  It consists of a single word containing SKIP,
     3492*	the code for this type of node.
     3493*
     3494*	Note that the codes for node types (3) through (8) above are less than or equal to zero so that they can be
     3495*	distinguished from node types (1) and (2), which are always positive.
     3496**/
     3497 parser (38):
     3498 	first_word = 0;				/* No "nodes" generated by data specs. */
     3499 	last_paren_parsed = 0;			/* indicates no pre-scan has occurred */
     3500 
     3501 /* Parse each set of variables and constants separately. */
     3502 
     3503 	in_stmnt = TRUE;
     3504 	do while (in_stmnt);
     3505 
     3506 	     do_level = 0;				/* no implied do loops encountered */
     3507 	     last_do = 0;				/* ditto */
     3508 
     3509 /* Parse variables, subscripted references, and implied do loops. */
     3510 
     3511 	     in_list = TRUE;
     3512 	     do while (in_list);
     3513 
     3514 /* Parse left paren or variable. */
     3515 
     3516 		call get_next_token (force_symtab_entry, SI);
     3517 
     3518 /* left paren must delimit an implied do loop */
     3519 
     3520 		if token = left_parn then
     3521 		     if is_implied_loop () then do;
     3522 			save_current_token = current_token;
     3523 						/* remember current token position */
     3524 			current_token = paren_info (cur_paren).begin_index;
     3525 						/* move up to loop code */
     3526 
     3527 			call stack_operator (BEGIN_DO_LOOP);
     3528 						/* stack begin loop operator */
     3529 			if do_level = hbound (do_info, 1) then do;
     3530 			     call print_message (89, hbound (do_info, 1) - bias);
     3531 						/* do loop nesting is too deep */
     3532 			     go to statement_parse_abort;
     3533 			end;
     3534 			else
     3535 			     do_info (do_level + 1) = stack_index;
     3536 						/* stack pointer to do loop info */
     3537 
     3538 /* process new do loop index variable */
     3539 
     3540 			call get_next_token (force_symtab_entry, indx);
     3541 			if token ^= ident then
     3542 			     go to missing_identifier;
     3543 
     3544 			do i = 1 to do_level;	/* check for reused index variable */
     3545 			     if stack (do_info (i)) = indx then do;
     3546 				call print_message (18, indx);
     3547 						/* reused loop index */
     3548 				go to statement_parse_abort;
     3549 			     end;
     3550 			end;
     3551 
     3552 			call stack_operand (indx);	/* stack loop index variable */
     3553 
     3554 /* index must be scalar integer variable */
     3555 
     3556 			if addr (OS (indx)) -> symbol.dimensioned then
     3557 			     call print_message (141, indx);
     3558 			else if (unspec (addr (OS (indx)) -> symbol.attributes) & scalar_conflicts) ^= ZERO then
     3559 			     call print_message (141, indx);
     3560 			else do;
     3561 			     call assign_data_type (indx);
     3562 			     if ^addr (OS (indx)) -> symbol.integer then
     3563 				call print_message (141, indx);
     3564 			end;
     3565 
     3566 			call get_next_token$operator;
     3567 
     3568 /* get equals */
     3569 			if token ^= assign then
     3570 			     go to missing_equals_sign;
     3571 
     3572 /* Get and stack the initial, final and increment expressions. */
     3573 			start_of_expression = stack_index;
     3574 			call get_data_statement_expression;
     3575 			if stack (start_of_expression) = 0 then
     3576 			     goto statement_parse_abort;
     3577 			if token ^= comma then
     3578 			     go to missing_comma;
     3579 			start_of_expression = stack_index;
     3580 			call get_data_statement_expression;
     3581 			if stack (start_of_expression) = 0 then
     3582 			     goto statement_parse_abort;
     3583 			if token = comma then do;
     3584 			     start_of_expression = stack_index;
     3585 			     call get_data_statement_expression;
     3586 			     if stack (start_of_expression) = 0 then
     3587 				goto statement_parse_abort;
     3588 			end;
     3589 			else do;			/* Assume increment of 1. */
     3590 			     call stack_operand (1);
     3591 			     call stack_operand (value_1);
     3592 			end;
     3593 
     3594 			if token ^= right_parn then
     3595 			     go to missing_right_paren;
     3596 
     3597 			paren_info (cur_paren).position = current_token;
     3598 						/* remember end of loop code */
     3599 			current_token = save_current_token;
     3600 						/* restore scan to proper position */
     3601 
     3602 			last_do = cur_paren;
     3603 			do_level = do_level + 1;	/* put this implied loop on stack */
     3604 		     end /* is implied do_loop */;
     3605 
     3606 		     else do /* not implied do_loop */;
     3607 			call print_message (34);	/* syntax error in do loop */
     3608 			go to statement_parse_abort;
     3609 		     end;
     3610 
     3611 		else do /* not a left_parn */;
     3612 		     if token ^= ident then
     3613 			go to missing_identifier;
     3614 
     3615 		     call get_next_token$paren_operator;/* Get left paren, comma, or slash. */
     3616 
     3617 /* Stack variable, substring, subscripted variable, or subscripted substring reference. */
     3618 
     3619 		     symp = addr (OS (SI));
     3620 		     if token = left_parn | token = substr_left_parn then do;
     3621 						/* substr, subscripted variable or subscripted substring */
     3622 			error = FALSE;
     3623 			start_of_node = stack_index;
     3624 			if token = substr_left_parn then do;
     3625 			     call stack_operand (SUBSTR);
     3626 			     call stack_operand (SI);
     3627 			end;
     3628 			else do;
     3629 			     call stack_operand (SUBSCRIPTED_VAR);
     3630 			     call stack_operand (SI);
     3631 			     dp = null;
     3632 			     number_of_dims, number_of_subs = 0;
     3633 			     if ^symp -> symbol.dimensioned then do;
     3634 				call print_message (76, SI);
     3635 				error = TRUE;
     3636 			     end;
     3637 			     else if symp -> symbol.variable_extents then do;
     3638 				call print_message (77, SI);
     3639 				error = TRUE;
     3640 			     end;
     3641 			     else do;
     3642 				dp = addr (OS (symp -> symbol.dimension));
     3643 				number_of_dims = dp -> dimension.number_of_dims;
     3644 			     end;
     3645 
     3646 			     have_subscript = TRUE;
     3647 			     do while (have_subscript);
     3648 				number_of_subs = number_of_subs + 1;
     3649 				start_of_expression = stack_index;
     3650 				call get_data_statement_expression;
     3651 				if stack (start_of_expression) = 0 then
     3652 				     error = TRUE;
     3653 				else if number_of_subs <= number_of_dims & stack (start_of_expression) = 1
     3654 				     & stack (start_of_expression + 1) > last_assigned_op then do;
     3655 						/* Verify constant subscript is in range. */
     3656 				     subscript =
     3657 					addr (addr (OS (stack (start_of_expression + 1))) -> constant.value)
     3658 					-> based_integer;
     3659 				     if subscript < dp -> dimension.lower_bound (number_of_subs) then do;
     3660 					call print_message (78, subscript - bias, "lower", SI);
     3661 					error = TRUE;
     3662 				     end;
     3663 				     else if subscript > dp -> dimension.upper_bound (number_of_subs) then do;
     3664 					call print_message (78, subscript - bias, "upper", SI);
     3665 					error = TRUE;
     3666 				     end;
     3667 				end;
     3668 				if token ^= comma then
     3669 				     have_subscript = FALSE;
     3670 			     end;
     3671 			     if token ^= right_parn then
     3672 				goto missing_right_paren;
     3673 			     if number_of_subs ^= number_of_dims & number_of_dims ^= 0 then do;
     3674 				call print_message (79, SI, "the wrong number of");
     3675 				error = TRUE;
     3676 			     end;
     3677 			     call get_next_token$paren_operator;
     3678 						/* Next token must be an operator. */
     3679 			end;
     3680 			if token = substr_left_parn then do;
     3681 						/* Parse substring start and finish. */
     3682 			     if stack (start_of_node) = SUBSCRIPTED_VAR then
     3683 				stack (start_of_node) = SUBSCRIPTED_SUBSTR;
     3684 			     if ^subr_options.ansi_77 then do;
     3685 				call print_message (154);
     3686 				error = TRUE;
     3687 			     end;
     3688 			     if symp -> symbol.character then
     3689 				char_siz = symp -> symbol.char_size + 1;
     3690 			     else do;
     3691 				char_siz = 0;
     3692 				call print_message (159, SI);
     3693 				error = TRUE;
     3694 			     end;
     3695 
     3696 			     inx = 1;
     3697 			     if token_list (current_token + 1).type = colon then do;
     3698 				call stack_operand (1);
     3699 				call stack_operand (value_1);
     3700 			     end;
     3701 			     else do;
     3702 				start_of_expression = stack_index;
     3703 				call get_data_statement_expression;
     3704 				if token ^= colon then do;
     3705 				     call print_message (102, err_string ());
     3706 				     goto statement_parse_abort;
     3707 				end;
     3708 				if stack (start_of_expression) = 0 then
     3709 				     error = TRUE;
     3710 				else if stack (start_of_expression) = 1
     3711 				     & stack (start_of_expression + 1) > last_assigned_op then do;
     3712 						/* Check that constant index is in range. */
     3713 				     inx = addr (addr (OS (stack (start_of_expression + 1))) -> constant.value)
     3714 					-> based_integer;
     3715 				     if inx < 1 then do;
     3716 					call print_message (155, SI, "start < 1");
     3717 					error = TRUE;
     3718 				     end;
     3719 				     else if inx > char_siz & char_siz ^= 0 then do;
     3720 					call print_message (155, SI, "start > length");
     3721 					error = TRUE;
     3722 				     end;
     3723 				end;
     3724 			     end;
     3725 			     if token_list (current_token + 1).type = right_parn then do;
     3726 				call stack_operand (1);
     3727 				addr (work) -> based_integer = char_siz;
     3728 				call stack_operand (create_constant (int_mode, work));
     3729 			     end;
     3730 			     else do;
     3731 				start_of_expression = stack_index;
     3732 				call get_data_statement_expression;
     3733 				if token ^= right_parn then
     3734 				     goto missing_right_paren;
     3735 				if stack (start_of_expression) = 0 then
     3736 				     error = TRUE;
     3737 				else if stack (start_of_expression) = 1
     3738 				     & stack (start_of_expression + 1) > last_assigned_op then do;
     3739 						/* Check that constant finish is in range. */
     3740 				     jnx = addr (addr (OS (stack (start_of_expression + 1))) -> constant.value)
     3741 					-> based_integer;
     3742 
     3743 				     if jnx < inx then do;
     3744 					call print_message (155, SI, "finish < start");
     3745 					error = TRUE;
     3746 				     end;
     3747 				     else if jnx > char_siz & char_siz ^= 0 then do;
     3748 					call print_message (155, SI, "finish > length");
     3749 					error = TRUE;
     3750 				     end;
     3751 				end;
     3752 			     end;
     3753 			     call get_next_token$operator;
     3754 						/* Next token must be an operator. */
     3755 			end;
     3756 			if error then do;
     3757 			     stack (start_of_node) = SKIP;
     3758 			     stack_index = start_of_node + 1;
     3759 			end;
     3760 		     end;
     3761 		     else do /* ident with no parn */;
     3762 			call stack_operand (SI);
     3763 		     end;
     3764 
     3765 /* comma, end of loop, or end of list must follow reference */
     3766 
     3767 		     need_comma = TRUE;
     3768 		     do while (need_comma & in_list);
     3769 
     3770 			if token ^= comma then
     3771 			     in_list = FALSE;
     3772 			else if last_do > 0 & current_token = paren_info (last_do).begin_index then do;
     3773 			     current_token = paren_info (last_do).position;
     3774 						/* skip over loop code */
     3775 			     last_do = paren_info (last_do).chain;
     3776 						/* step up to containing loop */
     3777 			     do_level = do_level - 1;
     3778 
     3779 			     call stack_operand (END_DO_LOOP);
     3780 						/* end of implied loop */
     3781 
     3782 			     call get_next_token$operator;
     3783 						/* get comma or slash */
     3784 			end;
     3785 			else
     3786 			     need_comma = FALSE;
     3787 		     end /* need_comma & in_list */;
     3788 		end /* not left paren */;
     3789 	     end /* loop to parse all list elements */;
     3790 
     3791 	     if token ^= slash then
     3792 		go to missing_slash;
     3793 
     3794 /* Parse constant list. */
     3795 
     3796 	     call parse_data;
     3797 
     3798 	     if token ^= comma then
     3799 		in_stmnt = FALSE;
     3800 	end /* do while (in_stmnt) */;
     3801 
     3802 /* If data specs generated "nodes" in polish, must indicate how many halfwords are used. */
     3803 
     3804 	if first_word ^= 0 then
     3805 	     polish_string (first_word) = next_free_polish - first_word - 1;
     3806 	go to parse_done;
     3807 
     3808 
     3809 /* Case		Return
     3810*
     3811*Syntax:
     3812*
     3813*Polish:
     3814*
     3815*Notes:
     3816**/
     3817 parser (39):
     3818 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     3819 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     3820 
     3821 	if END_DO_RANGE & ^logical_if_statement		/* ends a loop only as part of logical if */
     3822 	     then
     3823 	     call print_message (16, keyword_table (statement_type));
     3824 						/* cannot terminate do loop */
     3825 
     3826 	if sub_ptr -> subprogram_type = main_program then
     3827 	     call print_message (17, keyword_table (statement_type));
     3828 						/* return stmnt illegal in main */
     3829 
     3830 /* if subroutine and text follows keyword, assume alternate return statement */
     3831 
     3832 	call get_next_token (force_symtab_entry, SI);
     3833 
     3834 	if subprogram_op = subr_op & token ^= EOS_token then do;
     3835 	     if return_value_param = 0		/* first ref so create it */
     3836 		then
     3837 		return_value_param = build_symbol ((NO_NAME), param_variable_attrs | attr_table (int_mode), REF);
     3838 
     3839 	     call emit_operand (return_value_param);
     3840 	     call parse_expression (any_expression, SI, ignore_bits);
     3841 	     call emit_operator (assign_op);
     3842 	end;
     3843 
     3844 	call emit_return_op;
     3845 	go to parse_done;
     3846 
     3847 
     3848 /* Case		Backspace, Rewind, Endfile
     3849*
     3850*Syntax:	<expression> <eos> | (<specifier>...) <eos>
     3851*	<specifier> ::= [unit] = u | iostat = ios | err = s
     3852*Polish:	<expression> <op_code> [<polish for err> <error_label_op>]
     3853*		[<polish for iostat> <iostat_op>]
     3854*
     3855*Notes:
     3856*	need_PS	indicates presence of an I/O statement
     3857*	SI	passes output from get_next_token to parse_expr
     3858*	at most one iostat or err and exactly 1 unit specifier
     3859**/
     3860 parser (40):					/* rewind */
     3861 	op_code = rewind_op;
     3862 	io_control_type = rewind_opr;
     3863 	goto rewind_endfile_backspace;
     3864 
     3865 parser (41):					/* endfile */
     3866 	op_code = endfile_op;
     3867 	io_control_type = endfile_opr;
     3868 	goto rewind_endfile_backspace;
     3869 
     3870 parser (52):					/* backspace */
     3871 	op_code = backspace_op;
     3872 	io_control_type = backspace_opr;
     3873 	goto rewind_endfile_backspace;
     3874 
     3875 rewind_endfile_backspace:
     3876 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     3877 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     3878 
     3879 /* Initialize and then begin the parse */
     3880 
     3881 	fields_specified = ZERO;
     3882 	string (io_bits) = ZERO;
     3883 	io_bits.control_type = bit (binary (io_control_type, 4, 0), 4);
     3884 	io_bits.fold = subr_options.fold;
     3885 	io_bits.ansi_77 = subr_options.ansi_77;
     3886 	io_bits.hfp = subr_options.hfp;
     3887 	io_bits.debug_io = subr_options.debug_io;
     3888 	count = 0;
     3889 
     3890 	call get_next_token (force_symtab_entry, SI);	/* Get first token of the expr. */
     3891 	if token = left_parn			/* Keyword driven */
     3892 	then do;
     3893 	     in_list = TRUE;
     3894 	     do while (in_list);
     3895 		call get_next_token (ignore_symtab_entry, ignore_value);
     3896 
     3897 /* if next token is an equals sign, then this may be a true keyword driven value, 
     3898*   otherwise it's the expression defining UNIT or some sort of syntactic error */
     3899 		count = count + 1;
     3900 		if token_list (current_token + 1).type = assign then do;
     3901 		     if token ^= ident then
     3902 			goto missing_keyword;
     3903 		     else if substr (full_name, 1, symbol_length) = "err" then
     3904 			call parse_error_label;
     3905 		     else if substr (full_name, 1, symbol_length) = "iostat" then
     3906 			call parse_iostat_var;
     3907 		     else if substr (full_name, 1, symbol_length) = "unit" then
     3908 			call parse_unit_specifier (FALSE, FALSE);
     3909 						/* asterisk forbidden */
     3910 		     else
     3911 			goto invalid_keyword;
     3912 		end;
     3913 		else do;
     3914 
     3915 /* no keyword, UNIT = assumed (if first element in list ) */
     3916 
     3917 		     if count = 1 then
     3918 			call parse_unit_specifier$no_keyword (FALSE, FALSE);
     3919 		     else
     3920 			goto missing_identifier;
     3921 		end /* no keyword */;
     3922 		in_list = (token = comma);
     3923 	     end /* looping over list */;
     3924 
     3925 	     if token ^= right_parn then
     3926 		goto missing_right_paren;
     3927 	     if ^substr (fields_specified, units_field, 1) then
     3928 		call print_message (31, keyword_table (statement_type), "unit");
     3929 	     current_token = current_token + 1;
     3930 	end /* then clause */;
     3931 
     3932 	else
     3933 	     call parse_expression (any_expression, SI, ignore_bits);
     3934 	call emit_operand (create_constant (int_mode, string (io_bits)));
     3935 	call emit_operator ((op_code));
     3936 	sub_ptr -> need_PS = TRUE;
     3937 	go to parse_done;
     3938 
     3939 
     3940 /* Case		Read
     3941*
     3942*Syntax:
     3943*
     3944*Polish:
     3945*
     3946*Notes:
     3947**/
     3948 parser (42):
     3949 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     3950 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     3951 
     3952 	if token_list (current_token + 1).type = left_parn then
     3953 	     call parse_io (TRUE);
     3954 	else
     3955 	     call parse_implied_io (TRUE, value_0, TRUE);
     3956 	go to parse_done;
     3957 
     3958 
     3959 /* Case		Decode, Encode - get and put string
     3960*
     3961*Syntax:
     3962*
     3963*Polish:
     3964*
     3965*Notes:
     3966**/
     3967 parser (43):
     3968 parser (44):
     3969 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     3970 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     3971 
     3972 	call get_next_token$operator;			/* Get left paren. */
     3973 	if token ^= left_parn then
     3974 	     go to missing_left_paren;
     3975 
     3976 /* Set up control string. */
     3977 
     3978 	string (io_bits) = FALSE;
     3979 	io_bits.read = statement_type = decode_statement;
     3980 	io_bits.fold = subr_options.fold;
     3981 	io_bits.ansi_77 = subr_options.ansi_77;
     3982 	io_bits.hfp = subr_options.hfp;
     3983 	io_bits.debug_io = subr_options.debug_io;
     3984 
     3985 	fields_specified = ZERO;
     3986 	sub_ptr -> need_PS = TRUE;			/* Indicate presence of an I/O statement. */
     3987 
     3988 /* Parse the string reference. */
     3989 
     3990 	call get_next_token (force_symtab_entry, SI);
     3991 	if token ^= ident then
     3992 	     go to missing_identifier;
     3993 
     3994 /*  get_internal_file builds the polish for stmnt.  parameter indicates it is being called from encode/decode */
     3995 
     3996 	call set_data_fields (SI);
     3997 	call get_internal_file (TRUE);
     3998 
     3999 /* Process format and err=l fields. */
     4000 
     4001 	if token ^= comma then
     4002 	     go to missing_comma;
     4003 
     4004 	call parse_io_options;			/* io_bits.format may change. */
     4005 	if io_bits.format = unformatted		/* string io may not be unformatted */
     4006 	     then
     4007 	     call print_message (31, keyword_table (statement_type), "format");
     4008 	call parse_io_list;
     4009 	go to parse_done;
     4010 
     4011 
     4012 /* Case		Print
     4013*
     4014*Syntax:
     4015*
     4016*Polish:
     4017*
     4018*Notes:
     4019**/
     4020 parser (45):
     4021 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     4022 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     4023 
     4024 	call parse_implied_io (FALSE, value_0, TRUE);
     4025 	go to parse_done;
     4026 
     4027 
     4028 /* Case		Entry
     4029*
     4030*Syntax:
     4031*
     4032*Polish:
     4033*
     4034*Notes:
     4035*	Not Audited -- not for first release.
     4036**/
     4037 parser (46):
     4038 	string (cur_stmnt_ptr -> statement.bits) = put_in_map;
     4039 
     4040 /* tell code generator there are multiple entry points */
     4041 
     4042 	sub_ptr -> subprogram.multiple_entry = TRUE;
     4043 
     4044 	if sub_ptr -> subprogram_type = main_program then
     4045 	     call print_message (35, keyword_table (statement_type));
     4046 						/* entry invalid in main program */
     4047 
     4048 	call get_next_token (force_symtab_entry, SI);
     4049 	if token ^= ident then
     4050 	     go to missing_identifier;
     4051 
     4052 /* if entry in function, data type must agree with main entry point */
     4053 
     4054 	if subprogram_op = func_op then do;
     4055 	     call assign_data_type (return_value);	/* make sure main e.p. has data type, too */
     4056 	     call assign_data_type (SI);
     4057 
     4058 	     if (unspec (addr (OS (SI)) -> symbol.mode_bits) ^= unspec (addr (OS (return_value)) -> symbol.mode_bits))
     4059 		then
     4060 		call print_message (125, SI, subprogram_symbol);
     4061 	end;
     4062 
     4063 	call parse_parameter_list (SI);		/* parses param list */
     4064 
     4065 	if pending_entry_cnt = 1 then
     4066 	     bypass_first_pending_entry = ^must_have_label;
     4067 	must_have_label = FALSE;			/* statement following entry stmt never needs label */
     4068 
     4069 	go to parse_done;
     4070 
     4071 
     4072 /* Case		Pause, Stop
     4073*
     4074*Syntax:
     4075*
     4076*Polish:
     4077*
     4078*Notes:
     4079**/
     4080 parser (47):					/* Stop Statement */
     4081 	op_code = stop_op;
     4082 	go to stop_pause_common;
     4083 
     4084 parser (48):					/* Pause Statement */
     4085 	op_code = pause_op;
     4086 
     4087 stop_pause_common:
     4088 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     4089 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     4090 
     4091 	if END_DO_RANGE & ^logical_if_statement then
     4092 	     call print_message (16, keyword_table (statement_type));
     4093 						/* cannot terminate do loop */
     4094 
     4095 	call get_next_token (locate_symtab_entry, indx);
     4096 
     4097 	if token = char_string then do;
     4098 	     current_token = current_token + 1;
     4099 	end;
     4100 	else if token = dec_int then do;
     4101 	     indx = create_char_constant (token_string);
     4102 	     current_token = current_token + 1;
     4103 	end;
     4104 	else do;
     4105 	     indx = create_char_constant (NULL_STRING);
     4106 	end;
     4107 	call emit_operand (indx);
     4108 	call emit_operator ((op_code));
     4109 	go to parse_done;
     4110 
     4111 
     4112 /* Case		Assign To
     4113*
     4114*Syntax:
     4115*
     4116*Polish:
     4117*
     4118*Notes:
     4119**/
     4120 parser (49):
     4121 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     4122 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     4123 
     4124 	call get_next_token$label (ignore_symtab_entry, ignore_value);
     4125 	if token ^= dec_int then
     4126 	     go to missing_label;
     4127 
     4128 	call emit_operand (enter_label (any_label, (addr (work) -> based_integer), GOTO_REF));
     4129 	call get_next_token (ignore_symtab_entry, ignore_value);
     4130 	if token ^= ident then do;
     4131 	     call print_message (44, "to", err_string ());/* missing keyword */
     4132 	     go to statement_parse_abort;
     4133 	end;
     4134 
     4135 	if substr (fast_lookup, 1, 2) ^= "to" then do;
     4136 	     call print_message (44, "to", err_string ());/* missing keyword */
     4137 	     go to statement_parse_abort;
     4138 	end;
     4139 
     4140 	call split_token (2, current_token, TRUE);
     4141 	current_token = current_token - 1;		/* Get the token again. */
     4142 	call get_next_token (force_symtab_entry, SI);
     4143 
     4144 	call parse_expression (set_reference, SI, ignore_bits);
     4145 	call emit_operator (assign_label_op);
     4146 	go to parse_done;
     4147 
     4148 
     4149 /* Case	 	Punch
     4150*
     4151*Syntax:
     4152*
     4153*Polish:
     4154*
     4155*Notes:
     4156**/
     4157 parser (50):
     4158 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     4159 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     4160 
     4161 	if is_fast then
     4162 	     go to parser (unknown_statement);
     4163 
     4164 	if value_7 = 0 then do;
     4165 	     addr (work) -> based_integer = 7;
     4166 	     value_7 = create_constant (int_mode, work);
     4167 	end;
     4168 
     4169 	call parse_implied_io (FALSE, value_7, FALSE);
     4170 	go to parse_done;
     4171 
     4172 
     4173 /* Case		Input
     4174*
     4175*Syntax:
     4176*
     4177*Polish:
     4178*
     4179*Notes:
     4180**/
     4181 parser (51):
     4182 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     4183 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     4184 
     4185 	call parse_implied_io (TRUE, value_0, TRUE);
     4186 	go to parse_done;
     4187 
     4188 
     4189 /* Case		Chain */
     4190 parser (53):
     4191 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     4192 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     4193 
     4194 	call get_next_token (force_symtab_entry, SI);
     4195 
     4196 	call parse_expression (any_expression, SI, ignore_bits);
     4197 
     4198 	if token = comma then do;
     4199 	     in_stmnt = TRUE;
     4200 	     call get_next_token (ignore_symtab_entry, ignore_value);
     4201 	     if token ^= ident then
     4202 		go to missing_keyword;
     4203 
     4204 	end;
     4205 	else
     4206 	     in_stmnt = FALSE;
     4207 
     4208 	if in_stmnt & substr (fast_lookup, 1, 6) = "system" then do;
     4209 	     call split_token (6, current_token, TRUE);
     4210 	     current_token = current_token - 1;		/* Get the token again. */
     4211 	     call get_next_token (force_symtab_entry, SI);
     4212 
     4213 	     call parse_expression (any_expression, SI, ignore_bits);
     4214 
     4215 	     if token = comma then do;
     4216 		in_stmnt = TRUE;
     4217 		call get_next_token (ignore_symtab_entry, ignore_value);
     4218 		if token ^= ident then do;
     4219 		     call print_message (44, "with", err_string ());
     4220 						/* missing keyword */
     4221 		     go to statement_parse_abort;
     4222 		end;
     4223 
     4224 	     end;
     4225 	     else
     4226 		in_stmnt = FALSE;
     4227 	end;
     4228 	else
     4229 	     call emit_operand (create_char_constant ("fortran"));
     4230 
     4231 	call emit_count (word_offset);
     4232 	call emit_operator (chain_op);
     4233 
     4234 	if in_stmnt then
     4235 	     if substr (fast_lookup, 1, 4) = "with" then do;
     4236 		call split_token (4, current_token, TRUE);
     4237 		current_token = current_token - 1;
     4238 		count = 0;
     4239 		in_list = TRUE;
     4240 		do while (in_list);
     4241 		     call get_next_token (force_symtab_entry, SI);
     4242 		     call parse_expression (any_expression, SI, ignore_bits);
     4243 		     count = count + 1;
     4244 		     if token ^= comma then
     4245 			in_list = FALSE;
     4246 
     4247 		     call emit_operator (item_op);
     4248 		end;
     4249 		polish_string (word_offset) = count - bias;
     4250 	     end;
     4251 	     else
     4252 		current_token = current_token - 1;
     4253 
     4254 	call emit_operator (eol_op);
     4255 	go to parse_done;
     4256 
     4257 
     4258 /* Case		Closefile
     4259*
     4260*Syntax:	<expression> <eos>
     4261*
     4262*Polish:	<expression> <closefile_op>
     4263*
     4264*Notes:
     4265*	need_PS	indicates presence of an I/O statement
     4266*	SI	passes output from get_next_token to parse_expr
     4267**/
     4268 parser (54):
     4269 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     4270 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     4271 
     4272 	call get_next_token (force_symtab_entry, SI);	/* Get first token of the expr. */
     4273 	call parse_expression (any_expression, SI, ignore_bits);
     4274 	call emit_operator (closefile_op);
     4275 	sub_ptr -> need_PS = TRUE;
     4276 	go to parse_done;
     4277 
     4278 
     4279 /* Case		Margin
     4280*
     4281*Syntax:
     4282*
     4283*Polish:
     4284*
     4285*Notes:
     4286**/
     4287 parser (55):
     4288 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     4289 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     4290 
     4291 	call get_next_token (force_symtab_entry, SI);
     4292 	call parse_expression (any_expression, SI, ignore_bits);
     4293 	if token ^= comma then
     4294 	     go to missing_comma;
     4295 
     4296 	call get_next_token (force_symtab_entry, SI);
     4297 	call parse_expression (any_expression, SI, ignore_bits);
     4298 	call emit_operator (margin_op);
     4299 	sub_ptr -> need_PS = TRUE;
     4300 	go to parse_done;
     4301 
     4302 
     4303 /* Case		Openfile
     4304*
     4305*Syntax:
     4306*
     4307*Polish:
     4308*
     4309*Notes:
     4310**/
     4311 parser (56):
     4312 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     4313 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     4314 
     4315 	call get_next_token (force_symtab_entry, SI);
     4316 	sub_ptr -> need_PS = TRUE;
     4317 	call parse_expression (any_expression, SI, ignore_bits);
     4318 	if token ^= comma then
     4319 	     go to missing_comma;
     4320 
     4321 	call get_next_token (force_symtab_entry, SI);
     4322 
     4323 	call parse_expression (any_expression, SI, ignore_bits);
     4324 
     4325 	if token = comma then do;
     4326 	     call get_next_token (force_symtab_entry, SI);
     4327 
     4328 	     call parse_expression (any_expression, SI, ignore_bits);
     4329 
     4330 	end;
     4331 	else
     4332 	     call emit_operand (create_char_constant ("terminal"));
     4333 	call emit_operator (openfile_op);
     4334 	go to parse_done;
     4335 
     4336 
     4337 /* Case		Open
     4338*
     4339*Syntax:	open ( <option list> )
     4340*
     4341*		where option list is any of these in any order:
     4342*		(exactly one unit specifier is required)
     4343*	err=, status=, iostat=, attach=, switch=, form=, access=, mode=, prompt=, defer=, carriage=,
     4344*	file=, binary=, recl=, [unit =].
     4345*
     4346*Polish:
     4347*	file_#  job_bits  fields_specified  #_of_fields  open  field_expre  field_#  item  ...  eol
     4348*	 <saved>  opnd	opnd		count	op	expre	count  op		op
     4349*
     4350*Notes:
     4351*	THE CORRESPONDENCE BETWEEN FIELD AND NUMBER IS NOT ALTERABLE WITHOUT CHANGING:
     4352*		the parse (ext_parse), the macros (fort_cg_macros_), and bound_pl1_operators_.
     4353*	     Also, the include file fortran_open_data.incl.(pl1 alm).
     4354**/
     4355 parser (57):
     4356 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     4357 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     4358 
     4359 	sub_ptr -> subprogram.need_PS = TRUE;
     4360 
     4361 /* Initialize */
     4362 
     4363 	string (io_bits) = ZERO;			/* Control word to define type of operation. */
     4364 	io_bits.control_type = bit (binary (open_opr, 4, 0), 4);
     4365 	io_bits.fold = subr_options.fold;
     4366 	io_bits.ansi_77 = subr_options.ansi_77;
     4367 	io_bits.hfp = subr_options.hfp;
     4368 	io_bits.debug_io = subr_options.debug_io;
     4369 
     4370 	fields_specified = ZERO;			/* Bit string to specify which fields have already appeared. */
     4371 
     4372 	count = 0;				/* counts the number of fields present */
     4373 
     4374 /* Begin the parse */
     4375 
     4376 	call get_next_token$operator;			/* get left paren */
     4377 	if token ^= left_parn then
     4378 	     go to missing_left_paren;
     4379 
     4380 /* Allocate polish for 0) unit_specifier built by code gen, 1) job_bits, 2) fields_specified, 3) a count */
     4381 
     4382 	word_offset = next_free_polish;		/* remember where */
     4383 	call increment_polish (4);
     4384 	call emit_operator (open_op);
     4385 
     4386 	in_list = TRUE;
     4387 	count = 0;
     4388 	do while (in_list);
     4389 	     count = count + 1;
     4390 	     call get_next_token (ignore_symtab_entry, ignore_value);
     4391 						/* get the keyword */
     4392 	     if token_list (current_token + 1).type ^= assign then do;
     4393 						/* non-keyword, must be implied unit if first */
     4394 		if count = 1 then
     4395 		     call parse_unit_specifier$no_keyword (FALSE, TRUE);
     4396 		else
     4397 		     goto missing_identifier;
     4398 	     end;
     4399 	     else do;
     4400 
     4401 		if token ^= ident then
     4402 		     go to missing_keyword;
     4403 
     4404 		if substr (full_name, 1, symbol_length) = "err" then
     4405 		     call parse_error_label;
     4406 
     4407 		else if substr (full_name, 1, symbol_length) = "iostat" then
     4408 		     call parse_iostat_var;
     4409 
     4410 		else if substr (full_name, 1, symbol_length) = "status" then
     4411 		     call parse_open_field (status_field, any_expression);
     4412 
     4413 		else if substr (full_name, 1, symbol_length) = "ioswitch" then
     4414 		     call parse_open_field (io_switch_field, any_expression);
     4415 
     4416 		else if substr (full_name, 1, symbol_length) = "attach" then
     4417 		     call parse_open_field (attach_desc_field, any_expression);
     4418 
     4419 		else if substr (full_name, 1, symbol_length) = "file" then
     4420 		     call parse_open_field (filename_field, any_expression);
     4421 
     4422 		else if substr (full_name, 1, symbol_length) = "mode" then
     4423 		     call parse_open_field (mode_field, any_expression);
     4424 
     4425 		else if substr (full_name, 1, symbol_length) = "access" then
     4426 		     call parse_open_field (access_field, any_expression);
     4427 
     4428 		else if substr (full_name, 1, symbol_length) = "form" then
     4429 		     call parse_open_field (form_field, any_expression);
     4430 
     4431 		else if substr (full_name, 1, symbol_length) = "recl" then
     4432 		     call parse_open_field (recl_field, any_expression);
     4433 
     4434 		else if substr (full_name, 1, symbol_length) = "binarystream" then
     4435 		     call parse_open_field (binarystream_field, any_expression);
     4436 
     4437 		else if substr (full_name, 1, symbol_length) = "prompt" then
     4438 		     call parse_open_field (prompt_field, any_expression);
     4439 
     4440 		else if substr (full_name, 1, symbol_length) = "carriage" then
     4441 		     call parse_open_field (carriage_field, any_expression);
     4442 
     4443 		else if substr (full_name, 1, symbol_length) = "defer" then
     4444 		     call parse_open_field (defer_field, any_expression);
     4445 
     4446 		else if substr (full_name, 1, symbol_length) = "blank" then
     4447 		     call parse_open_field (blank_field, any_expression);
     4448 
     4449 		else if substr (full_name, 1, symbol_length) = "unit" then
     4450 		     call parse_unit_specifier (FALSE, TRUE);
     4451 
     4452 		else
     4453 		     go to invalid_keyword;
     4454 	     end /* keyword driven */;
     4455 	     in_list = (token = comma);
     4456 	end;					/* loop through option fields */
     4457 
     4458 	if token ^= right_parn then
     4459 	     go to missing_right_paren;
     4460 	if ^substr (fields_specified, units_field, 1) then
     4461 	     call print_message (31, keyword_table (statement_type), "unit");
     4462 	current_token = current_token + 1;		/* skip over right paren */
     4463 
     4464 	call emit_operator (eol_op);
     4465 
     4466 /* copy values into polish slots reserved earlier */
     4467 
     4468 	polish_string (word_offset) = -bias;
     4469 	polish_string (word_offset + 1) = create_constant (int_mode, string (io_bits));
     4470 	polish_string (word_offset + 2) = create_constant (int_mode, fields_specified);
     4471 	polish_string (word_offset + 3) = -bias;	/* count of zero. Index for field-specified bit string. */
     4472 	go to parse_done;
     4473 
     4474 /* Case		Close
     4475*
     4476*Syntax:	close ( <option list> )
     4477*
     4478*		where option list is any of these in any order:
     4479*		(exactly one unit specifier required, keyword optional)
     4480*	err=, status=, iostat=, [unit = ],
     4481*
     4482*Polish:
     4483*	file_#  job_bits  fields_specified  #_of_fields  close field_expre  field_#  item  ...  eol
     4484*	 <save>  opnd	opnd		count	op	expre	count  op		op
     4485*
     4486*Notes:
     4487*	THE CORRESPONDENCE BETWEEN FIELD AND NUMBER IS NOT ALTERABLE WITHOUT CHANGING:
     4488*		the parse (ext_parse), the macros (fort_cg_macros_), and bound_pl1_operators_.
     4489*	     Also, the include file fortran_open_data.incl.(pl1 alm).
     4490**/
     4491 parser (58):
     4492 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     4493 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     4494 
     4495 	sub_ptr -> subprogram.need_PS = TRUE;
     4496 
     4497 /* Initialize */
     4498 
     4499 	string (io_bits) = ZERO;			/* Control word to define type of operation. */
     4500 	io_bits.control_type = bit (binary (close_opr, 4, 0), 4);
     4501 	io_bits.fold = subr_options.fold;
     4502 	io_bits.ansi_77 = subr_options.ansi_77;
     4503 	io_bits.hfp = subr_options.hfp;
     4504 	io_bits.debug_io = subr_options.debug_io;
     4505 
     4506 	fields_specified = ZERO;			/* Bit string to specify which fields have already appeared. */
     4507 
     4508 	count = 0;				/* counts the number of fields present */
     4509 
     4510 /* Begin the parse */
     4511 
     4512 	call get_next_token$operator;			/* get left paren */
     4513 	if token ^= left_parn then
     4514 	     go to missing_left_paren;
     4515 
     4516 /* Allocate polish for 0) unit id built by code gen, 1) job_bits, 2) fields_specified, 3) a count */
     4517 
     4518 	word_offset = next_free_polish;		/* remember where */
     4519 	call increment_polish (4);
     4520 	call emit_operator (close_op);
     4521 
     4522 	in_list = TRUE;
     4523 	do while (in_list);
     4524 	     count = count + 1;
     4525 	     call get_next_token (ignore_symtab_entry, ignore_value);
     4526 						/* get the keyword */
     4527 	     if token_list (current_token + 1).type ^= assign then do;
     4528 						/* non-keyword, must be implied unit if first */
     4529 		if count = 1 then
     4530 		     call parse_unit_specifier$no_keyword (FALSE, TRUE);
     4531 		else
     4532 		     goto missing_identifier;
     4533 	     end;
     4534 	     else do;
     4535 		if token ^= ident then
     4536 		     go to missing_keyword;
     4537 
     4538 		if substr (full_name, 1, symbol_length) = "err" then
     4539 		     call parse_error_label;
     4540 
     4541 		else if substr (full_name, 1, symbol_length) = "iostat" then
     4542 		     call parse_iostat_var;
     4543 
     4544 		else if substr (full_name, 1, symbol_length) = "status" then
     4545 		     call parse_open_field (status_field, any_expression);
     4546 
     4547 		else if substr (full_name, 1, symbol_length) = "unit" then
     4548 		     call parse_unit_specifier (FALSE, TRUE);
     4549 
     4550 		else
     4551 		     go to invalid_keyword;
     4552 	     end /* keyword driven */;
     4553 	     in_list = (token = comma);
     4554 	end;					/* loop through option fields */
     4555 
     4556 	if token ^= right_parn then
     4557 	     go to missing_right_paren;
     4558 	if ^substr (fields_specified, units_field, 1) then
     4559 	     call print_message (31, keyword_table (statement_type), "unit");
     4560 	current_token = current_token + 1;		/* skip over right paren */
     4561 
     4562 	call emit_operator (eol_op);
     4563 
     4564 /* copy values into polish slots reserved earlier */
     4565 
     4566 	polish_string (word_offset) = -bias;
     4567 	polish_string (word_offset + 1) = create_constant (int_mode, string (io_bits));
     4568 	polish_string (word_offset + 2) = create_constant (int_mode, fields_specified);
     4569 	polish_string (word_offset + 3) = -bias;	/* count of zero. Index for field-specified bit string. */
     4570 	go to parse_done;
     4571 
     4572 
     4573 /* Case		Inquire
     4574*
     4575*Syntax:	inquire ( <option list> )
     4576*
     4577*		where option list is any of these in any order:
     4578*		(exactly one of unit or file is required)
     4579*	err=, iostat=, file=, form=, blank=, access=, exist=, opened=, number=, named=,
     4580*	sequential=, formatted=, recl=, unit =, unformatted=, nextrec=, direct=.
     4581*
     4582*Polish:
     4583*	job_bits  fields_specified  #_of_fields  inquire  field_expre  field_#  item  ...  eol
     4584*
     4585*Notes: This is much like the method in which the open statement is implemented, except that 
     4586*       here everything is returned by fortran_io_ except unit/file
     4587**/
     4588 parser (59):
     4589 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     4590 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     4591 
     4592 	sub_ptr -> subprogram.need_PS = TRUE;
     4593 
     4594 /* Initialize */
     4595 
     4596 	string (io_bits) = ZERO;			/* Control word to define type of operation. */
     4597 	io_bits.control_type = bit (binary (inquire_opr, 4, 0), 4);
     4598 	io_bits.fold = subr_options.fold;
     4599 	io_bits.ansi_77 = subr_options.ansi_77;
     4600 	io_bits.hfp = subr_options.hfp;
     4601 	io_bits.debug_io = subr_options.debug_io;
     4602 
     4603 	fields_specified = ZERO;			/* Bit string to specify which fields have already appeared. */
     4604 
     4605 /* Begin the parse */
     4606 
     4607 	call get_next_token$operator;			/* get left paren */
     4608 	if token ^= left_parn then
     4609 	     go to missing_left_paren;
     4610 
     4611 /* Allocate polish for 0) job_bits, 1) fields_specified, 2) a count */
     4612 
     4613 	word_offset = next_free_polish;		/* remember where */
     4614 	call increment_polish (3);
     4615 	call emit_operator (inquire_op);
     4616 
     4617 	in_list = TRUE;
     4618 	count = 0;
     4619 	do while (in_list);
     4620 	     count = count + 1;
     4621 	     call get_next_token (ignore_symtab_entry, ignore_value);
     4622 						/* get the keyword */
     4623 	     if token_list (current_token + 1).type = assign then do;
     4624 
     4625 		if token ^= ident then
     4626 		     go to missing_keyword;
     4627 
     4628 		if substr (full_name, 1, symbol_length) = "err" then
     4629 		     call parse_error_label;
     4630 
     4631 		else if substr (full_name, 1, symbol_length) = "iostat" then
     4632 		     call parse_iostat_var;
     4633 
     4634 		else if substr (full_name, 1, symbol_length) = "file" then
     4635 		     call parse_open_field (filename_field, any_expression);
     4636 
     4637 		else if substr (full_name, 1, symbol_length) = "unit" then
     4638 		     call parse_unit_specifier (FALSE, TRUE);
     4639 
     4640 		else if substr (full_name, 1, symbol_length) = "access" then
     4641 		     call parse_open_field (access_field, set_reference);
     4642 
     4643 		else if substr (full_name, 1, symbol_length) = "form" then
     4644 		     call parse_open_field (form_field, set_reference);
     4645 
     4646 		else if substr (full_name, 1, symbol_length) = "recl" then
     4647 		     call parse_open_field (recl_field, set_reference);
     4648 
     4649 		else if substr (full_name, 1, symbol_length) = "blank" then
     4650 		     call parse_open_field (blank_field, set_reference);
     4651 
     4652 		else if substr (full_name, 1, symbol_length) = "exist" then
     4653 		     call parse_open_field (exist_field, set_reference);
     4654 
     4655 		else if substr (full_name, 1, symbol_length) = "opened" then
     4656 		     call parse_open_field (opened_field, set_reference);
     4657 
     4658 		else if substr (full_name, 1, symbol_length) = "number" then
     4659 		     call parse_open_field (number_field, set_reference);
     4660 
     4661 		else if substr (full_name, 1, symbol_length) = "named" then
     4662 		     call parse_open_field (named_field, set_reference);
     4663 
     4664 		else if substr (full_name, 1, symbol_length) = "name" then
     4665 		     call parse_open_field (name_field, set_reference);
     4666 
     4667 		else if substr (full_name, 1, symbol_length) = "sequential" then
     4668 		     call parse_open_field (sequential_field, set_reference);
     4669 
     4670 		else if substr (full_name, 1, symbol_length) = "formatted" then
     4671 		     call parse_open_field (formatted_field, set_reference);
     4672 
     4673 		else if substr (full_name, 1, symbol_length) = "unformatted" then
     4674 		     call parse_open_field (unformatted_field, set_reference);
     4675 
     4676 		else if substr (full_name, 1, symbol_length) = "nextrec" then
     4677 		     call parse_open_field (nextrec_field, set_reference);
     4678 
     4679 		else if substr (full_name, 1, symbol_length) = "direct" then
     4680 		     call parse_open_field (direct_field, set_reference);
     4681 
     4682 		else
     4683 		     go to invalid_keyword;
     4684 	     end /* keyword driven */;
     4685 	     else do;				/* presume 'UNIT=' */
     4686 		if count = 1 then
     4687 		     call parse_unit_specifier$no_keyword (FALSE, TRUE);
     4688 		else
     4689 		     goto missing_identifier;
     4690 	     end;
     4691 
     4692 	     in_list = (token = comma);
     4693 	end;					/* loop through option fields */
     4694 
     4695 	if token ^= right_parn then
     4696 	     go to missing_right_paren;
     4697 
     4698 	if ^substr (fields_specified, units_field, 1) & ^substr (fields_specified, filename_field, 1) then
     4699 	     call print_message (31, keyword_table (statement_type), "unit or a file");
     4700 	if substr (fields_specified, units_field, 1) & substr (fields_specified, filename_field, 1) then
     4701 	     call print_message (187, keyword_table (statement_type), "file and unit");
     4702 
     4703 	current_token = current_token + 1;		/* skip over right paren */
     4704 
     4705 	call emit_operator (eol_op);
     4706 
     4707 /* copy values into polish slots reserved earlier */
     4708 
     4709 	polish_string (word_offset) = create_constant (int_mode, string (io_bits));
     4710 	polish_string (word_offset + 1) = create_constant (int_mode, fields_specified);
     4711 	polish_string (word_offset + 2) = -bias;	/* count of zero. Index for field-specified bit string. */
     4712 	go to parse_done;
     4713 
     4714 /* Case		Do
     4715*
     4716*Syntax:
     4717*
     4718*Polish:
     4719*
     4720*Notes:
     4721**/
     4722 parser (61):
     4723 	profile_size = profile_size + 1;		/* profile entry required by this statement */
     4724 	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
     4725 
     4726 	if END_DO_RANGE then
     4727 	     call print_message (16, keyword_table (statement_type));
     4728 						/* cannot terminate do loop */
     4729 
     4730 	call get_next_token$label (ignore_symtab_entry, ignore_value);
     4731 	if token ^= dec_int then
     4732 	     go to missing_label;
     4733 
     4734 	label_ptr = enter_label (executable_label, (addr (work) -> based_integer), REF);
     4735 	call get_next_token (force_symtab_entry, SI);
     4736 
     4737 	if token = comma then
     4738 	     call get_next_token (force_symtab_entry, SI);
     4739 
     4740 	call parse_expression (set_reference, SI, ignore_bits);
     4741 	if token ^= assign then
     4742 	     go to missing_equals_sign;
     4743 
     4744 	call get_next_token (force_symtab_entry, SI);
     4745 	call parse_expression (any_expression, SI, ignore_bits);
     4746 	if token ^= comma then
     4747 	     go to missing_comma;
     4748 
     4749 	call get_next_token (force_symtab_entry, SI);
     4750 	call parse_expression (any_expression, SI, ignore_bits);
     4751 	if token = comma then do;
     4752 	     call get_next_token (force_symtab_entry, SI);
     4753 	     call parse_expression (any_expression, SI, ignore_bits);
     4754 	end;
     4755 	else
     4756 	     call emit_operand (value_1);
     4757 	call emit_operator (do_op);
     4758 
     4759 	if do_index = hbound (do_blockif_stack, 1) then
     4760 	     call print_message (27, hbound (do_blockif_stack, 1) - bias);
     4761 						/* too many do loop nestings */
     4762 	else do;
     4763 	     do_index = do_index + 1;
     4764 	     do_blockif_stack (do_index).do_loop = "1"b;
     4765 	     do_blockif_stack (do_index).label_ptr = label_ptr;
     4766 	end;
     4767 	go to parse_done;
     4768 
     4769 
     4770 /* Case		Unknown */
     4771 parser (62):
     4772 	call get_next_token (ignore_symtab_entry, ignore_value);
     4773 						/* get first token of statement */
     4774 
     4775 	if token = ident then
     4776 	     call print_message (32, token_string);	/* unknown keyword */
     4777 	else
     4778 	     call print_message (92, token_string);	/* doesnt start with identifier */
     4779 
     4780 	go to statement_parse_abort;
     4781 
     4782 
     4783 /* Case		Out of Sequence */
     4784 parser (63):
     4785 	call print_message (56, keyword_table (bad_type));/* statement is out of sequence */
     4786 	go to statement_parse_abort;
     4787 
     4788 declaration_processor:
     4789      procedure;
     4790 
     4791 /*	Program Specifications (declaration_processor)
     4792*
     4793*     Inputs
     4794*
     4795*     Output
     4796*
     4797*     Description - Process common blocks and equvalence groups.
     4798**/
     4799 
     4800 dcl      LA_hdri fixed bin (18);
     4801 dcl      LA_hdrp ptr;
     4802 dcl      VLA_hdri fixed bin (18);
     4803 dcl      VLA_hdrp ptr;
     4804 dcl      added pointer;
     4805 dcl      added_group bit (1);
     4806 dcl      added_header_length fixed binary (24);
     4807 dcl      adesc fixed binary (18);
     4808 dcl      all_character_offsets_in_group bit (1);
     4809 dcl      ap pointer;
     4810 dcl      array_max_size fixed bin (24);
     4811 dcl      block_length fixed bin (25);
     4812 dcl      block_max_size fixed bin (24);
     4813 dcl      bp pointer;
     4814 dcl      (chars_in_block, chars_in_group, character_offset) bit (1);
     4815 dcl      common_hdri fixed bin (18);
     4816 dcl      common_hdrp ptr;
     4817 dcl      difference fixed bin (24);
     4818 dcl      displacement fixed bin (24);
     4819 dcl      equiv_error bit (1) aligned;
     4820 dcl      equiv_hdri fixed bin (18);
     4821 dcl      equiv_hdrp ptr;
     4822 dcl      group_align bit (2) aligned;
     4823 dcl      group_class bit (4) aligned;
     4824 dcl      group_length fixed bin (24);
     4825 dcl      i fixed bin (18);
     4826 dcl      ii fixed bin;
     4827 dcl      indx fixed bin (18);
     4828 dcl      indx_ptr pointer;
     4829 dcl      j fixed bin (18);
     4830 dcl      k fixed bin (24);
     4831 dcl      max_length_this_pass fixed bin (18);
     4832 dcl      new fixed bin (18);
     4833 dcl      old fixed bin (18);
     4834 dcl      original pointer;
     4835 dcl      prev_LA_hdrp ptr;
     4836 dcl      prev_common_hdrp ptr;
     4837 dcl      prev_equiv_hdrp ptr;
     4838 dcl      real_statement fixed bin (18);
     4839 dcl      sp pointer;
     4840 dcl      sp_header_length fixed binary (24);
     4841 dcl      symbol_even bit (1);
     4842 dcl      symbol_length fixed bin (24);
     4843 dcl      symbol_storage bit (5) unaligned defined (addr (OS (indx)) -> symbol.storage_info);
     4844 dcl      symbol_storage_class bit (3);
     4845 dcl      symi fixed bin (18);
     4846 dcl      tp pointer;
     4847 dcl      vbai fixed bin (18);
     4848 dcl      vbap ptr;
     4849 dcl      vba_name char (256) varying;
     4850 
     4851 dcl      01 initial_in_polish aligned based,		/* Used to transform to named constant */
     4852 	 02 next fixed binary (17) aligned,
     4853 	 02 limit fixed binary (17) aligned,
     4854 	 02 value fixed binary (17) aligned;
     4855 
     4856 
     4857 	real_statement = cur_statement;		/* cur_statement is changed for error messages. */
     4858 	cur_statement = -1;				/* There is no current statement. */
     4859 
     4860 /* force data type for function return value */
     4861 
     4862 	if subprogram_op = func_op then do;
     4863 
     4864 /* Insure that the function return value was set. */
     4865 
     4866 	     if ^addr (OS (return_value)) -> symbol.set & ^addr (OS (return_value)) -> symbol.passed_as_arg then
     4867 		call print_message (9, return_value);	/* return value is not set */
     4868 
     4869 	     call set_data_fields (return_value);	/* must have data type */
     4870 
     4871 	     unspec (addr (OS (return_value_param)) -> symbol.mode_bits) =
     4872 		unspec (addr (OS (return_value)) -> symbol.mode_bits);
     4873 	     addr (OS (return_value_param)) -> symbol.data_type = addr (OS (return_value)) -> symbol.data_type;
     4874 	     addr (OS (return_value_param)) -> symbol.element_size = addr (OS (return_value)) -> symbol.element_size;
     4875 	end;
     4876 
     4877 /*  *  *  *  *  *  LABEL PROCESSOR  *  *  *  *  *  */
     4878 
     4879 /*	Check all labels for illegal reference. For format labels, if they
     4880*	contain hollerith fields and are referenced by a read statement, set symbol.set. */
     4881 
     4882 	do SI = sub_ptr -> subprogram.first_label repeat symp -> label.next_label while (SI ^= 0);
     4883 	     symp = addr (OS (SI));
     4884 
     4885 	     if symp -> label.referenced & ^symp -> label.set then
     4886 		call print_message (12, SI);
     4887 
     4888 	     if symp -> label.referenced_executable & symp -> label.not_referencable then
     4889 		call print_message (185, SI);
     4890 
     4891 	     if string (symp -> label.usage) = format_label then do;
     4892 		sp = addr (OS (symp -> label.format_var));
     4893 
     4894 		if sp -> symbol.set			/* used in a read st, check for hollerith */
     4895 		then do;
     4896 		     addr (work) -> based_char /* copy because char_const.value is not word aligned */ =
     4897 			addr (addr (OS (polish_string (sp -> symbol.initial + 2))) -> char_constant.value)
     4898 			-> based_char;
     4899 		     if ^addr (work) -> runtime_format.contains_hollerith then
     4900 			sp -> symbol.set = FALSE;
     4901 		end;
     4902 	     end;
     4903 	end;
     4904 
     4905 
     4906 /*  *  *  *  *  *  SYMBOL TABLE PROCESSOR  *  *  *  *  *  */
     4907 
     4908 /* The symbol table chain must be destroyed and replaced by two chains, -- a chain for entry point
     4909*   symbols and a chain for everything else. Also, while walking the original symbol table chain,
     4910*   the following actions are performed:
     4911*
     4912*     o	symbol.general is zeroed; the cg assumes this as its initial value.
     4913*
     4914*     o	symbols with the external attribute that are not builtins and without a storage class
     4915*	are assigned to constant storage.
     4916*
     4917*     o	arrays with variable extents must be parameters; the bounds must all be scalar
     4918*	integer parameters.
     4919*
     4920*     o	functions, statement functions, and variables are assigned a data type,
     4921*	if they don't already have one; symbol.data_type, symbol.element_size,
     4922*	(also dimension.element_count, dimension.array_size) are set if
     4923*	symbol.data_type is zero. */
     4924 
     4925 	SI = sub_ptr -> subprogram.first_symbol;	/* get head of original symbol table chain */
     4926 
     4927 	sub_ptr -> subprogram.first_symbol = 0;		/* general symbol chain is initially empty */
     4928 	sub_ptr -> subprogram.last_symbol = 0;
     4929 
     4930 	do while (SI ^= 0);
     4931 
     4932 /* get pointer to current node */
     4933 
     4934 	     symp = addr (OS (SI));
     4935 
     4936 	     new = symp -> symbol.next_symbol;		/* next member of the original chain */
     4937 	     symp -> symbol.next_symbol = 0;		/* destroy original chain */
     4938 
     4939 /* Process each symbol. */
     4940 
     4941 /* entry point symbols are added to the entry point chain */
     4942 
     4943 	     if symp -> symbol.entry_point then do;
     4944 
     4945 /* All function entry points must have a data type. */
     4946 
     4947 		if subprogram_op = func_op then do;
     4948 		     unspec (addr (OS (SI)) -> symbol.mode_bits) =
     4949 			unspec (addr (OS (return_value)) -> symbol.mode_bits);
     4950 		     addr (OS (SI)) -> symbol.data_type = addr (OS (return_value)) -> symbol.data_type;
     4951 		     addr (OS (SI)) -> symbol.element_size = addr (OS (return_value)) -> symbol.element_size;
     4952 		end;
     4953 
     4954 /* an entry_point needs descriptors iff any of its parameters is declared to
     4955*   be of star_extent.  The index of the symbol nodes for these parameters is
     4956*   put into an arg_desc node by parse_parameter_list for each entry point, but 
     4957*   as the symbols need not have been declared yet, star_extent_edness must be  
     4958*   checked on a per-subprogram basis.   */
     4959 
     4960 		adesc = symp -> symbol.general;
     4961 		if adesc ^= 0 then do;
     4962 		     ap = addr (OS (adesc));
     4963 		     num_args = ap -> arg_desc.n_args;
     4964 		     if symp -> symbol.function then
     4965 			symp -> symbol.needs_descriptors = symp -> symbol.star_extents;
     4966 		     do i = 1 to num_args while (^symp -> symbol.needs_descriptors);
     4967 			if ap -> arg_desc.symbol (i) > 0
     4968 						/* if parameter was a symbol, not a *  */
     4969 			     then
     4970 			     symp -> symbol.needs_descriptors =
     4971 				addr (OS (ap -> arg_desc.symbol (i))) -> symbol.star_extents;
     4972 		     end;
     4973 
     4974 		end;
     4975 
     4976 		if first_entry_name = 0 then
     4977 		     first_entry_name = SI;
     4978 		else
     4979 		     addr (OS (last_entry_name)) -> symbol.next_symbol = SI;
     4980 
     4981 		last_entry_name = SI;
     4982 	     end;
     4983 
     4984 /* all others are added to symbol table chain */
     4985 
     4986 	     else do;
     4987 
     4988 
     4989 /* DATA TYPE and STORAGE CLASS ALLOCATION. The parse sets the data type for
     4990*   all external functions, statement functions, and variables. It also assigns
     4991*   a storage class to all variables that do not have one. */
     4992 
     4993 		if symp -> symbol.function | symp -> symbol.stmnt_func then
     4994 		     call set_data_fields (SI);	/* Assign a data type and set related fields. */
     4995 
     4996 		else if symp -> symbol.variable | symp -> symbol.parameter then do;
     4997 		     call set_data_fields (SI);	/* Assign a data type and set related fields. */
     4998 
     4999 /* Insure that all non-equivalenced variables have a storage class. */
     5000 
     5001 		     if ^symp -> symbol.equivalenced	/* this symbol is not in common nor equivalenced */
     5002 			then
     5003 			if string (symp -> symbol.storage_class) = ZERO then do;
     5004 			     string (symp -> symbol.storage_class) = string (sub_ptr -> subprogram.default_is);
     5005 			     if symp -> symbol.dimensioned & ^symp -> symbol.variable_extents
     5006 				& ^symp -> symbol.star_extents then do;
     5007 				if symp -> symbol.automatic then
     5008 				     array_max_size = max_array_size.auto;
     5009 				else if symp -> symbol.static then
     5010 				     array_max_size = max_array_size.static;
     5011 
     5012 				if (addr (OS (symp -> symbol.dimension)) -> dimension.array_size)
     5013 				     > array_max_size * units_per_word (symp -> symbol.units) then
     5014 				     call print_message (136, "size", SI,
     5015 					ltrim (char (array_max_size)) || " words");
     5016 			     end;
     5017 			end;
     5018 
     5019 /* Print warning if variable is used but not set. Parameters, members of
     5020*   common and equiv groups, initialed vars, compiler generated symbols,
     5021*   and s.f. dummy args are excluded. */
     5022 
     5023 		     if symp -> symbol.referenced then
     5024 			if ^symp -> symbol.set & ^symp -> symbol.passed_as_arg then
     5025 			     if ^symp -> symbol.parameter & ^symp -> symbol.equivalenced
     5026 				& ^symp -> symbol.dummy_arg & ^symp -> symbol.by_compiler
     5027 						/* make sure it wasn't compiler generated */
     5028 				then
     5029 				if symp -> symbol.initial = 0
     5030 						/* do this way to catch init to zero */
     5031 				     then
     5032 				     call print_message (043, SI);
     5033 
     5034 /* If static variable is init'd to zero, is referenced, is not set or passed
     5035*   as arg, mark as init'd so that optimizer can make it a constant. */
     5036 
     5037 		     if symp -> symbol.static then
     5038 			if ^symp -> symbol.set & ^symp -> symbol.passed_as_arg then
     5039 			     if ^symp -> symbol.initialed & symp -> symbol.initial ^= 0 then
     5040 				symp -> symbol.initialed = TRUE;
     5041 
     5042 /* Convert a symbol into a named constant if possible. */
     5043 
     5044 		     if (symp -> symbol.static | symp -> symbol.automatic) & symp -> symbol.initial ^= 0
     5045 			& ^symp -> symbol.set & ^symp -> symbol.passed_as_arg & ^symp -> symbol.aliasable
     5046 			& ^symp -> symbol.dimensioned & ^symp -> symbol.equivalenced then do;
     5047 						/* CONVERT FROM OPTMIZER */
     5048 			symp -> symbol.automatic, symp -> symbol.static = "0"b;
     5049 			symp -> symbol.named_constant = "1"b;
     5050 			symp -> symbol.initial =
     5051 			     addr (polish_string (symp -> symbol.initial)) -> initial_in_polish.value;
     5052 		     end;
     5053 		end;
     5054 
     5055 /* default storage class for external references is constant and use word units
     5056*   for external (descriptors) character functions in ansi77 */
     5057 
     5058 		if symp -> symbol.external then do;
     5059 		     if ^symp -> symbol.parameter & ^symp -> symbol.builtin then
     5060 			symp -> symbol.constant = TRUE;
     5061 		     if symp -> symbol.function then
     5062 			if symp -> symbol.mode.character then
     5063 			     if subr_options.ansi_77 then do;
     5064 				symp -> symbol.units = word_units;
     5065 				symp -> symbol.element_size =
     5066 				     divide (symp -> symbol.char_size + chars_per_word, chars_per_word, 17, 0);
     5067 			     end;
     5068 		end;
     5069 
     5070 /* process variable bounds */
     5071 
     5072 		else if symp -> symbol.variable_extents then do;
     5073 		     if ^symp -> symbol.parameter then
     5074 			call print_message (14, SI);
     5075 
     5076 		     dp = addr (OS (symp -> symbol.dimension));
     5077 
     5078 /* As we check the validity of the bounds, we will force their allocation. */
     5079 
     5080 		     do i = 1 to dp -> dimension.number_of_dims;
     5081 			if dp -> dimension.v_bound.lower (i) then
     5082 			     call validate_array_bound (dp -> dimension.dim.lower_bound (i));
     5083 
     5084 /* warning - dont attempt to validate the last upper bound for assumed size arrays */
     5085 
     5086 			if dp -> dimension.v_bound.upper (i) then
     5087 			     if ^(i = dp -> dimension.number_of_dims & dp -> dimension.assumed_size) then
     5088 				call validate_array_bound (dp -> dimension.dim.upper_bound (i));
     5089 		     end;
     5090 		end;
     5091 
     5092 /* Statement function definitions are masked if the statement function
     5093*   is not referenced. The borrowed fields symbol.initial and symbol.dimension
     5094*   are always zeroed. */
     5095 
     5096 		else if symp -> symbol.stmnt_func then do;
     5097 		     if ^symp -> symbol.allocate then do;
     5098 
     5099 /* The definition is removed from the polish string by overwriting it
     5100*   with an increment_polish_op. The def. is guaranteed to be at least
     5101*   three (3) words in length. */
     5102 
     5103 			word_offset = symp -> symbol.initial;
     5104 			polish_string (word_offset) = increment_polish_op;
     5105 			polish_string (word_offset + 1) = symp -> symbol.dimension - word_offset - 2;
     5106 
     5107 /* All of the s.f. parameters should not be allocated. */
     5108 
     5109 			do indx = symp -> symbol.next_member repeat addr (OS (indx)) -> symbol.next_member
     5110 			     while (indx ^= 0);
     5111 			     symbol_storage = ZERO;
     5112 			end;
     5113 		     end;
     5114 
     5115 		     symp -> symbol.initial = 0;
     5116 		     symp -> symbol.dimension = 0;
     5117 		end;
     5118 
     5119 /* Check to make sure *-length declaration has not been used improperly;
     5120*   if used validly, create a symbol to hold length info. */
     5121 
     5122 		if symp -> symbol.star_extents then
     5123 		     if ^(sub_ptr -> subprogram_type = function & SI = return_value) then
     5124 			if ^symp -> symbol.function & ^symp -> symbol.parameter then do;
     5125 			     call print_message (147, SI, default_char_size - bias);
     5126 			     symp -> symbol.star_extents = "0"b;
     5127 			     symp -> symbol.char_size = default_char_size - 1;
     5128 			end;
     5129 			else do;
     5130 			     if symp -> symbol.v_length = 0 then do;
     5131 				symp -> symbol.v_length = build_symbol ((NO_NAME), v_length_attributes, SET);
     5132 				addr (OS (symp -> symbol.v_length)) -> symbol.data_type = int_mode;
     5133 				addr (OS (symp -> symbol.v_length)) -> symbol.element_size = 1;
     5134 
     5135 				if sub_ptr -> subprogram.star_extent_function & SI = return_value_param
     5136 						/* Update return_value symbol with our star extent for length. */
     5137 				then do;
     5138 				     addr (OS (return_value)) -> symbol.v_length = symp -> symbol.v_length;
     5139 				     addr (OS (subprogram_symbol)) -> symbol.v_length = symp -> symbol.v_length;
     5140 				     if addr (OS (return_value)) -> symbol.needs_descriptors then
     5141 					symp -> symbol.needs_descriptors = "1"b;
     5142 				end;
     5143 			     end;
     5144 			end;
     5145 
     5146 /* Now, add the symbol to the general symbol table chain. */
     5147 
     5148 		if sub_ptr -> subprogram.last_symbol = 0 then
     5149 		     sub_ptr -> subprogram.first_symbol = SI;
     5150 		else
     5151 		     addr (OS (sub_ptr -> subprogram.last_symbol)) -> symbol.next_symbol = SI;
     5152 
     5153 		sub_ptr -> subprogram.last_symbol = SI;
     5154 	     end;
     5155 
     5156 /* ensure that this field is zero for the code generator */
     5157 
     5158 	     symp -> symbol.general = 0;
     5159 
     5160 /* exception entrypoints, general point to argument descriptor */
     5161 	     if symp -> symbol.attributes.misc_attributes.entry_point then
     5162 		symp -> symbol.general = adesc;
     5163 
     5164 /* step to next member of the original chain */
     5165 
     5166 	     SI = new;
     5167 	end;
     5168 
     5169 
     5170 /*  *  *  *  *  *  COMMON BLOCK PROCESSOR  *  *  *  *  *  */
     5171 
     5172 /* Walk common block chain calculating offsets and lengths. */
     5173 
     5174 	do i = sub_ptr -> common_chain repeat bp -> header.next_header while (i ^= 0);
     5175 	     bp = addr (OS (i));
     5176 	     block_length = 0;			/* accumulates the block length */
     5177 	     if sub_ptr -> subprogram.options.ansi_77	/* If any var is char, all must be */
     5178 		then
     5179 		if addr (OS (bp -> header.first_element)) -> symbol.data_type = char_mode then do;
     5180 		     bp -> header.alignment.character = TRUE;
     5181 		     bp -> header.units = char_units;
     5182 		end;
     5183 
     5184 /* Should the header node be associated with no elements, it has appeared only in a SAVE statement and not a COMMON statement */
     5185 
     5186 	     if bp -> header.first_element = 0 then
     5187 		call print_message (186, i);
     5188 
     5189 	     do j = bp -> header.first_element repeat sp -> symbol.next_member while (j ^= 0);
     5190 		sp = addr (OS (j));
     5191 
     5192 		if (unspec (addr (OS (j)) -> symbol.attributes) & variable_conflicts) = ZERO then do;
     5193 						/* Enforce the ANSI77 character vars in common restriction (all or none) */
     5194 
     5195 		     if sub_ptr -> subprogram.options.ansi_77 then
     5196 			if bp -> header.alignment.character then
     5197 			     if sp -> symbol.data_type ^= char_mode then
     5198 				call print_message (156, i);
     5199 			     else
     5200 				;
     5201 			else if sp -> symbol.data_type = char_mode then
     5202 			     call print_message (156, i);
     5203 
     5204 /* Set member offset and update total block length. */
     5205 
     5206 		     if sp -> symbol.double_precision | sp -> symbol.complex then
     5207 			if mod (block_length, 2) ^= 0 then do;
     5208 			     call print_message (57, i, j);
     5209 						/* Adding word to common for alignment */
     5210 			     block_length = block_length + 1;
     5211 			end;
     5212 
     5213 		     sp -> symbol.offset = block_length;/* Set offset. */
     5214 
     5215 		     if sp -> symbol.dimensioned then
     5216 			if sp -> symbol.variable_extents then do;
     5217 			     call print_message (58, j);
     5218 						/* cannot have variable extents in common */
     5219 			     k = 0;
     5220 			end;
     5221 			else
     5222 			     k = addr (OS (sp -> symbol.dimension)) -> dimension.array_size;
     5223 		     else
     5224 			k = sp -> symbol.element_size;
     5225 
     5226 		     block_length = block_length + k;	/* Update length. */
     5227 		end;
     5228 
     5229 		else
     5230 		     call print_message (20, j, i);	/* symbol cannot be in common */
     5231 
     5232 /* copy block length into header */
     5233 
     5234 		if block_length > max_fixed_bin_24 then
     5235 		     call print_message (136, "length", i, ltrim (char (max_fixed_bin_24)) || " words");
     5236 		else
     5237 		     bp -> header.length = block_length;
     5238 	     end;
     5239 	end;
     5240 
     5241 
     5242 /*  *  *  *  *  *  EQUIVALENCE GROUP PROCESSOR  *  *  *  *  *  */
     5243 
     5244 /* Loop thru all equivalence groups. */
     5245 
     5246 	i = lbound (stack, 1);
     5247 	do while (i < stack_index);
     5248 
     5249 /* Get the beginning of a group. */
     5250 
     5251 	     cur_statement = stack (i);
     5252 	     i = i + 1;
     5253 
     5254 	     if subr_options.ansi_77 then do;
     5255 		all_character_offsets_in_group = TRUE;
     5256 		ii = i;
     5257 		do while (stack (ii) ^= -1 & all_character_offsets_in_group);
     5258 		     all_character_offsets_in_group = addr (OS (stack (ii))) -> symbol.mode.character;
     5259 		     ii = ii + 3;
     5260 		end;
     5261 	     end;
     5262 	     else
     5263 		all_character_offsets_in_group = FALSE;
     5264 
     5265 	     equiv_error = TRUE;
     5266 	     do while (equiv_error & stack (i) ^= -1);
     5267 		displacement = get_equiv_var (old, bp, character_offset);
     5268 	     end;
     5269 
     5270 /* Allow ansi77 characters to be equivalenced to other data types. */
     5271 
     5272 	     displacement = verify_offset_type_kludge (displacement, character_offset);
     5273 						/* Loop thru remaining group members. */
     5274 
     5275 	     do while (stack (i) ^= -1);
     5276 
     5277 /* Get next member and difference between its offset and the group offset. */
     5278 
     5279 		equiv_error = TRUE;
     5280 		do while (equiv_error & stack (i) ^= -1);
     5281 		     difference = get_equiv_var (new, sp, character_offset);
     5282 		end;
     5283 
     5284 		if equiv_error then
     5285 		     go to equivalence_member_abort;
     5286 
     5287 /* Allow ansi77 characters to be equivalenced to other data types. */
     5288 
     5289 		difference = displacement - verify_offset_type_kludge (difference, character_offset);
     5290 
     5291 /* Calculate new storage class for group. */
     5292 
     5293 		group_class = string (bp -> header.storage_class) | string (sp -> header.storage_class);
     5294 		if impossible_class (binary (substr (group_class, 1, 3), 3, 0)) then do;
     5295 		     call print_message (59, indx);	/* conflicting storage classes */
     5296 		     go to equivalence_member_abort;
     5297 		end;
     5298 
     5299 /* Process offset and alignment. */
     5300 
     5301 		if old = new then
     5302 		     if difference ^= 0		/* If group is equivalenced to itself. */
     5303 		     then do;
     5304 			call print_message (60, indx);/* conflicting offset */
     5305 			go to equivalence_member_abort;
     5306 		     end;
     5307 		     else
     5308 			;
     5309 		else do;				/* Two different groups. */
     5310 
     5311 /* OPTIMIZATION. If either group is in common, insure it is pointed to by "old".
     5312*   Both groups cannot be in common. */
     5313 
     5314 		     if sp -> header.in_common then do;
     5315 			displacement = displacement - difference;
     5316 			difference = -difference;
     5317 			j = old;
     5318 			old = new;
     5319 			new = j;
     5320 			tp = bp;
     5321 			bp = sp;
     5322 			sp = tp;
     5323 		     end;
     5324 
     5325 /* Handle special constraints raised by common. a) the origin of common may not
     5326*   be changed; b) two common blocks may not be equivalenced. */
     5327 
     5328 		     if bp -> header.in_common then
     5329 			if difference < 0 then do;
     5330 			     call print_message (61, old);
     5331 						/* attempt to change address of common block */
     5332 			     go to equivalence_member_abort;
     5333 			end;
     5334 			else if sp -> header.in_common then do;
     5335 			     call print_message (62, indx, old);
     5336 						/* equivalencing two common blocks */
     5337 			     go to equivalence_member_abort;
     5338 			end;
     5339 
     5340 /* If "difference" is non-zero, offsets in one group must be increased by abs(difference). */
     5341 
     5342 		     if difference ^= 0 then do;
     5343 			if difference < 0 then do;	/* Old group is fiddled. This redefines its origin. */
     5344 			     difference = -difference;
     5345 			     added = bp;
     5346 			     original = sp;
     5347 			     displacement = displacement + difference;
     5348 						/* Fiddling is permanent. */
     5349 			end;
     5350 			else do;			/* New group is fiddled. */
     5351 			     added = sp;
     5352 			     original = bp;
     5353 			end;
     5354 
     5355 /* Change all offsets in appropriate group. */
     5356 
     5357 			do j = added -> header.first_element repeat tp -> symbol.next_member while (j ^= 0);
     5358 			     tp = addr (OS (j));
     5359 			     block_length = tp -> symbol.offset + difference;
     5360 			     if block_length <= max_fixed_bin_24 then do;
     5361 				if character_offset & tp -> symbol.mode.character
     5362 				     & ^all_character_offsets_in_group then
     5363 				     tp -> symbol.offset = block_length * 4;
     5364 				else
     5365 				     tp -> symbol.offset = block_length;
     5366 			     end;
     5367 			end;
     5368 
     5369 /* Update length to include origin shift. */
     5370 
     5371 			if bp -> header.units ^= added -> header.units then
     5372 			     if bp -> header.units = char_units then
     5373 				added_header_length = (added -> header.length + difference) * 4;
     5374 			     else
     5375 				added_header_length = (added -> header.length + difference) / 4;
     5376 			else
     5377 			     added_header_length = added -> header.length + difference;
     5378 			block_length = max (bp -> header.length, added_header_length);
     5379 			if block_length > max_fixed_bin_24 then
     5380 			     call print_message (136, "length", old, ltrim (char (max_fixed_bin_24)));
     5381 			else
     5382 			     bp -> header.length = block_length;
     5383 		     end;
     5384 
     5385 		     else do;
     5386 			added = sp;
     5387 			original = bp;
     5388 		     end;
     5389 
     5390 /* Calculate required group alignment: even word, odd word, or any word. */
     5391 
     5392 
     5393 		     group_align = string (added -> header.alignment);
     5394 		     if mod (difference, 2) ^= 0 & group_align ^= ZERO then
     5395 			group_align = ^group_align;
     5396 		     group_align = group_align | string (original -> header.alignment);
     5397 		     if group_align = impossible_align then do;
     5398 			call print_message (63, indx);/* conflicting alignment */
     5399 			go to equivalence_member_abort;
     5400 		     end;
     5401 
     5402 /* Update member's storage class if it has changed. */
     5403 
     5404 		     if substr (group_class, 1, 3) ^= string (bp -> header.storage_class) then
     5405 			do j = bp -> header.first_element repeat tp -> symbol.next_member while (j ^= 0);
     5406 			     tp = addr (OS (j));
     5407 			     string (tp -> symbol.storage_class) =
     5408 				string (tp -> symbol.storage_class) | group_class;
     5409 			end;
     5410 
     5411 /* Update length if new group is longer than the old. */
     5412 
     5413 		     if bp -> header.units ^= sp -> header.units then
     5414 			if bp -> header.units = char_units then
     5415 			     sp_header_length = 4 * sp -> header.length;
     5416 			else
     5417 			     sp_header_length = sp -> header.length / 4;
     5418 		     else
     5419 			sp_header_length = sp -> header.length;
     5420 		     bp -> header.length = max (bp -> header.length, sp_header_length);
     5421 						/* cannot overflow */
     5422 
     5423 /* Thread the two group chains into one big one. */
     5424 
     5425 		     addr (OS (bp -> header.last_element)) -> symbol.next_member = sp -> header.first_element;
     5426 		     bp -> header.last_element = sp -> header.last_element;
     5427 
     5428 /* Change symbol.parent and storage class for all members of added group. */
     5429 
     5430 		     do j = sp -> header.first_element repeat tp -> symbol.next_member while (j ^= 0);
     5431 			tp = addr (OS (j));
     5432 			tp -> symbol.parent = old;
     5433 			string (tp -> symbol.storage_class) = string (tp -> symbol.storage_class) | group_class;
     5434 		     end;
     5435 
     5436 /* allocation information of both groups must be combined */
     5437 
     5438 		     string (bp -> header.storage_info) =
     5439 			string (bp -> header.storage_info) | string (sp -> header.storage_info);
     5440 
     5441 /* Added group can be eliminated from general equivalence chain. */
     5442 
     5443 		     if sub_ptr -> equiv_chain = new then
     5444 			sub_ptr -> equiv_chain = sp -> header.next_header;
     5445 		     else do;
     5446 			do j = sub_ptr -> equiv_chain repeat addr (OS (j)) -> header.next_header
     5447 			     while (addr (OS (j)) -> header.next_header ^= new);
     5448 			end;
     5449 			addr (OS (j)) -> header.next_header = sp -> header.next_header;
     5450 		     end;
     5451 
     5452 /* Added group header can be released if it is at the end of our area. */
     5453 
     5454 		     allocate_symbol_name = sp -> header.name_length;
     5455 		     if new + size (header) = next_free_operand then
     5456 			next_free_operand = new;
     5457 
     5458 /* Update group storage class and required alignment. */
     5459 
     5460 		     string (bp -> header.alignment) = group_align;
     5461 		     string (bp -> header.storage_class) = group_class;
     5462 		end;
     5463 
     5464 equivalence_member_abort:
     5465 	     end;					/* element loop. */
     5466 	     i = i + 1;
     5467 
     5468 	     if all_character_offsets_in_group then
     5469 		bp -> header.alignment.character = TRUE;
     5470 
     5471 	end;					/* equiv group. */
     5472 
     5473 	stack_index = lbound (stack, 1);
     5474 	stack_base = lbound (stack, 1);
     5475 
     5476 	cur_statement = real_statement;
     5477 
     5478 
     5479 /*  *  *  *  *  *   COMMON BLOCK & EQUIVALENCE GROUP POST-PROCESSOR  *  *  *  *  *  */
     5480 
     5481 /*  Check the length of each common block.  Permanent common blocks may not  */
     5482 /*  exceed a segment in size.  Normal common blocks that contain character   */
     5483 /*  variables may not exceed 'max_array_size.char' in size.  Normal common   */
     5484 /*  blocks which do not contain character variables are limited in size to   */
     5485 /*  'max_array_size.common'.                                                 */
     5486 
     5487 	do common_hdri = sub_ptr -> subprogram.common_chain repeat common_hdrp -> header.next_header
     5488 	     while (common_hdri ^= 0);
     5489 	     common_hdrp = addr (OS (common_hdri));
     5490 	     if index (common_hdrp -> header.block_name, "$") > 0 then
     5491 		block_max_size = sys_info$max_seg_size;
     5492 	     else do;
     5493 		chars_in_block = FALSE;
     5494 		do symi = common_hdrp -> header.first_element repeat symp -> symbol.next_member
     5495 		     while (symi ^= 0 & ^chars_in_block);
     5496 		     symp = addr (OS (symi));
     5497 		     if symp -> symbol.character then
     5498 			chars_in_block = TRUE;
     5499 		end;
     5500 		if chars_in_block then
     5501 		     block_max_size = max_array_size.char;
     5502 		else
     5503 		     block_max_size = max_array_size.common;
     5504 	     end;
     5505 	     if common_hdrp -> header.length > block_max_size * units_per_word (common_hdrp -> header.units) then
     5506 		call print_message (136, "size", common_hdri, ltrim (char (block_max_size)) || " words");
     5507 	end;
     5508 
     5509 /*  Check the size of each equivalence group and insure it has been assigned */
     5510 /*  a storage class.  Equivalence groups which contain character variables   */
     5511 /*  may not exceed 'max_array_size.char' in size, while those that do not    */
     5512 /*  contain character variables are limited by 'max_array_size.auto',        */
     5513 /*  'max_array_size.common', or 'max_array_size.static'.                     */
     5514 
     5515 	do equiv_hdri = sub_ptr -> subprogram.equiv_chain repeat equiv_hdrp -> header.next_header
     5516 	     while (equiv_hdri ^= 0);
     5517 	     equiv_hdrp = addr (OS (equiv_hdri));
     5518 	     if string (equiv_hdrp -> header.storage_class) = ZERO then
     5519 		string (equiv_hdrp -> header.storage_class) = string (sub_ptr -> subprogram.default_is);
     5520 	     chars_in_group = FALSE;
     5521 	     do symi = equiv_hdrp -> header.first_element repeat symp -> symbol.next_member
     5522 		while (symi ^= 0 & ^chars_in_group);
     5523 		symp = addr (OS (symi));
     5524 		if symp -> symbol.character then
     5525 		     chars_in_group = TRUE;
     5526 	     end;
     5527 
     5528 	     if chars_in_group then
     5529 		block_max_size = max_array_size.char;
     5530 	     else if equiv_hdrp -> header.in_common then
     5531 		block_max_size = max_array_size.common;
     5532 	     else if equiv_hdrp -> header.automatic then
     5533 		block_max_size = max_array_size.auto;
     5534 	     else
     5535 		block_max_size = max_array_size.static; /* if equiv_hdrp -> header.static */
     5536 
     5537 	     if equiv_hdrp -> header.length > block_max_size * units_per_word (equiv_hdrp -> header.units) then
     5538 		call print_message (136, "size of the equivalence group",
     5539 		     bin (equiv_hdrp -> header.first_element, 18), ltrim (char (block_max_size)) || " words");
     5540 	end;
     5541 
     5542 /*  *  *  *  *  *  VERY LARGE ARRAY PROCESSOR  *  *  *  *  *  */
     5543 
     5544 /*  Begin VLA processing.  */
     5545 
     5546 /*  Move common blocks that exceed a segment in size from the common block   */
     5547 /*  chain to the VLA chain.                                                  */
     5548 	if subr_options.VLC | subr_options.VLA_auto | subr_options.VLA_static | subr_options.VLA_parm then do;
     5549 
     5550 	     if subr_options.VLC then do;
     5551 		prev_common_hdrp = null;
     5552 		common_hdri = sub_ptr -> subprogram.common_chain;
     5553 		do while (common_hdri ^= 0);
     5554 		     common_hdrp = addr (OS (common_hdri));
     5555 		     block_length =
     5556 			divide (common_hdrp -> header.length + units_per_word (common_hdrp -> header.units) - 1,
     5557 			units_per_word (common_hdrp -> header.units), 24);
     5558 		     if block_length > sys_info$max_seg_size then do;
     5559 						/*  Move block to VLA chain.  */
     5560 			if prev_common_hdrp = null then
     5561 			     sub_ptr -> subprogram.common_chain = common_hdrp -> header.next_header;
     5562 			else
     5563 			     prev_common_hdrp -> header.next_header = common_hdrp -> header.next_header;
     5564 			common_hdrp -> header.next_header = sub_ptr -> subprogram.VLA_chain;
     5565 			sub_ptr -> subprogram.VLA_chain = common_hdri;
     5566 			common_hdrp -> header.VLA = TRUE;
     5567 			do symi = common_hdrp -> header.first_element repeat symp -> symbol.next_member
     5568 			     while (symi ^= 0);
     5569 			     symp = addr (OS (symi));
     5570 			     symp -> symbol.VLA = TRUE;
     5571 			end;
     5572 		     end;
     5573 		     else
     5574 			prev_common_hdrp = common_hdrp;
     5575 						/*  Leave block on common chain.  */
     5576 		     if prev_common_hdrp = null then
     5577 			common_hdri = sub_ptr -> subprogram.common_chain;
     5578 		     else
     5579 			common_hdri = prev_common_hdrp -> header.next_header;
     5580 		end;
     5581 	     end;
     5582 
     5583 /*  Move equivalence groups that exceed a segment in size from the           */
     5584 /*  equivalence chain to the VLA chain.                                      */
     5585 	     if subr_options.VLC | subr_options.VLA_auto | subr_options.VLA_static then do;
     5586 		prev_equiv_hdrp = null;
     5587 		equiv_hdri = sub_ptr -> subprogram.equiv_chain;
     5588 		do while (equiv_hdri ^= 0);
     5589 		     equiv_hdrp = addr (OS (equiv_hdri));
     5590 		     if ((subr_options.VLC & equiv_hdrp -> header.in_common)
     5591 			| (subr_options.VLA_auto & equiv_hdrp -> header.automatic)
     5592 			| (subr_options.VLA_static & equiv_hdrp -> header.static)) then do;
     5593 			block_length =
     5594 			     divide (equiv_hdrp -> header.length + units_per_word (equiv_hdrp -> header.units) - 1,
     5595 			     units_per_word (equiv_hdrp -> header.units), 24);
     5596 			if block_length > sys_info$max_seg_size then do;
     5597 						/*  Move group to VLA chain.  */
     5598 			     if prev_equiv_hdrp = null then
     5599 				sub_ptr -> subprogram.equiv_chain = equiv_hdrp -> header.next_header;
     5600 			     else
     5601 				prev_equiv_hdrp -> header.next_header = equiv_hdrp -> header.next_header;
     5602 			     equiv_hdrp -> header.next_header = sub_ptr -> subprogram.VLA_chain;
     5603 			     sub_ptr -> subprogram.VLA_chain = equiv_hdri;
     5604 			     equiv_hdrp -> header.VLA = TRUE;
     5605 			     do symi = equiv_hdrp -> header.first_element repeat symp -> symbol.next_member
     5606 				while (symi ^= 0);
     5607 				symp = addr (OS (symi));
     5608 				symp -> symbol.VLA = TRUE;
     5609 			     end;
     5610 			end;
     5611 			else
     5612 			     prev_equiv_hdrp = equiv_hdrp;
     5613 						/*  Leave group on equiv chain.  */
     5614 		     end;
     5615 		     else
     5616 			prev_equiv_hdrp = equiv_hdrp; /*  Leave group on equiv chain.  */
     5617 		     if prev_equiv_hdrp = null then
     5618 			equiv_hdri = sub_ptr -> subprogram.equiv_chain;
     5619 		     else
     5620 			equiv_hdri = prev_equiv_hdrp -> header.next_header;
     5621 		end;
     5622 	     end;
     5623 
     5624 /*  Set the VLA flag and allocate a base addressor for each dimensioned,     */
     5625 /*  noncharacter parameter.  Add to the VLA chain all dimensioned, nonchar,  */
     5626 /*  parentless (i.e. not equivalenced nor common) variables whose size       */
     5627 /*  exceeds that of a segment.                                               */
     5628 
     5629 	     if subr_options.VLA_auto | subr_options.VLA_static | subr_options.VLA_parm then do;
     5630 		symi = sub_ptr -> subprogram.first_symbol;
     5631 		do while (symi ^= 0);
     5632 		     symp = addr (OS (symi));
     5633 		     if symp -> symbol.dimensioned & ^symp -> symbol.character then
     5634 			if subr_options.VLA_parm & symp -> symbol.parameter then do;
     5635 			     symp -> symbol.VLA = TRUE;
     5636 			     vba_name = symp -> symbol.name;
     5637 			     vbai = build_symbol (vba_name, variable_attributes | attr_table (int_mode), SET);
     5638 			     vbap = addr (OS (vbai));
     5639 			     vbap -> symbol.data_type = int_mode;
     5640 			     vbap -> symbol.automatic = TRUE;
     5641 			     vbap -> symbol.element_size = 1;
     5642 			     addr (OS (symp -> symbol.dimension)) -> dimension.VLA_base_addressor = vbai;
     5643 			end;
     5644 			else if ((subr_options.VLA_auto & symp -> symbol.automatic)
     5645 			     | (subr_options.VLA_static & symp -> symbol.static)) then do;
     5646 			     if divide (addr (OS (symp -> symbol.dimension)) -> dimension.array_size
     5647 				+ units_per_word (symp -> symbol.units) - 1,
     5648 				units_per_word (symp -> symbol.units), 24) > sys_info$max_seg_size
     5649 				& symp -> symbol.parent = 0 then do;
     5650 						/*  Add symbol to VLA chain.  */
     5651 				allocate_symbol_name = 0;
     5652 				VLA_hdri = create_node (header_node, size (header));
     5653 				VLA_hdrp = addr (OS (VLA_hdri));
     5654 				VLA_hdrp -> header.next_header = sub_ptr -> subprogram.VLA_chain;
     5655 				sub_ptr -> subprogram.VLA_chain = VLA_hdri;
     5656 				string (VLA_hdrp -> header.storage_info) = string (symp -> symbol.storage_info);
     5657 				if symp -> symbol.double_precision | symp -> symbol.complex then
     5658 				     VLA_hdrp -> header.even = TRUE;
     5659 				else if symp -> symbol.character & subr_options.ansi_77 then
     5660 				     VLA_hdrp -> header.character = TRUE;
     5661 				string (VLA_hdrp -> header.storage_class) =
     5662 				     substr (string (symp -> symbol.storage_class), 1, 3);
     5663 				VLA_hdrp -> header.units = symp -> symbol.units;
     5664 				VLA_hdrp -> header.VLA = TRUE;
     5665 				VLA_hdrp -> header.length =
     5666 				     addr (OS (symp -> symbol.dimension)) -> dimension.array_size;
     5667 				VLA_hdrp -> header.first_element, VLA_hdrp -> header.last_element = symi;
     5668 				symp -> symbol.VLA = TRUE;
     5669 				symp -> symbol.parent = VLA_hdri;
     5670 			     end;
     5671 			end;
     5672 		     symi = symp -> symbol.next_symbol;
     5673 		end;
     5674 	     end;
     5675 
     5676 /*  For each VLA group, create an integer variable to hold the base address  */
     5677 /*  of the group.  If the group has a name, that name is also given to the   */
     5678 /*  integer variable; otherwise, the name of the first variable in the group */
     5679 /*  which has an offset of zero is given to the integer variable.            */
     5680 
     5681 	     do VLA_hdri = sub_ptr -> subprogram.VLA_chain repeat VLA_hdrp -> header.next_header while (VLA_hdri ^= 0);
     5682 		VLA_hdrp = addr (OS (VLA_hdri));
     5683 		if VLA_hdrp -> header.block_name = "" then
     5684 		     vba_name = NO_NAME;
     5685 		else
     5686 		     vba_name = VLA_hdrp -> header.block_name;
     5687 		do symi = VLA_hdrp -> header.first_element repeat symp -> symbol.next_member
     5688 		     while (vba_name = NO_NAME & symi ^= 0);
     5689 		     symp = addr (OS (symi));
     5690 		     if symp -> symbol.offset = 0 then
     5691 			vba_name = symp -> symbol.name;
     5692 		end;
     5693 		vbai = build_symbol (vba_name, variable_attributes | attr_table (int_mode), SET);
     5694 		vbap = addr (OS (vbai));
     5695 		vbap -> symbol.data_type = int_mode;
     5696 		if VLA_hdrp -> header.automatic then
     5697 		     vbap -> symbol.automatic = TRUE;
     5698 		else
     5699 		     vbap -> symbol.static = TRUE;
     5700 		vbap -> symbol.element_size = 1;
     5701 		VLA_hdrp -> header.VLA_base_addressor = vbai;
     5702 		do symi = VLA_hdrp -> header.first_element repeat symp -> symbol.next_member while (symi ^= 0);
     5703 		     symp = addr (OS (symi));
     5704 		     if symp -> symbol.dimensioned then
     5705 			addr (OS (symp -> symbol.dimension)) -> dimension.VLA_base_addressor = vbai;
     5706 		end;
     5707 	     end;
     5708 
     5709 	end;					/*  End VLA processing.  */
     5710 
     5711 /*  *  *  *  *  *  LARGE ARRAY PROCESSOR  *  *  *  *  *  */
     5712 
     5713 	if subr_options.LA_auto | subr_options.LA_static then do;
     5714 						/*  Begin LA processing.  */
     5715 
     5716 /*  We must add all the array variables that are not parameters, nor VLA's   */
     5717 /*  nor in common to the Large Array chain.  We must also add long scalar    */
     5718 /*  character variables (i.e. longer than 'max_char_length') which are       */
     5719 /*  not parameters nor in common.  Each member of the Large Array chain looks*/
     5720 /*  like an equivalence group whose total storage does not exceed a segment. */
     5721 /*  Array variables are assigned to the Large Array chain in such a way that */
     5722 /*  a variable that does not exceed 16K in size will be totally contained in */
     5723 /*  the first 16K of the group in which it is entered.  (This allows us to   */
     5724 /*  generate more efficient code, since extra instructions are generated to  */
     5725 /*  access data outside the first 16K of a storage area.)                    */
     5726 /*                                                                           */
     5727 /*  There are two sources of arrays for the Large Array chain: parentless,   */
     5728 /*  dimensioned nonparameter symbols and the equivalence chain.  We pass     */
     5729 /*  through each of these sources twice.  The first time we pick out all     */
     5730 /*  arrays less than or equal to 16K in size.  The second time we pick up    */
     5731 /*  the rest.                                                                */
     5732 
     5733 	     do max_length_this_pass = 16384, sys_info$max_seg_size;
     5734 
     5735 /*  Run through the symbol table looking for parentless, nonparameter arrays */
     5736 /*  and long, parentless, nonparameter character scalars.  Add those whose   */
     5737 /*  size does not exceed 'max_length_this_pass' to a group in the LA chain,  */
     5738 /*  creating a new group if necessary.                                       */
     5739 
     5740 		do symi = sub_ptr -> subprogram.first_symbol repeat symp -> symbol.next_symbol while (symi ^= 0);
     5741 		     symp = addr (OS (symi));
     5742 		     if ^symp -> symbol.parameter & symp -> symbol.parent = 0
     5743 			& (symp -> symbol.dimensioned
     5744 			| (symp -> symbol.character & symp -> symbol.char_size >= max_char_length)) then do;
     5745 			if ((subr_options.LA_auto & symp -> symbol.automatic)
     5746 			     | (subr_options.LA_static & symp -> symbol.static)) then do;
     5747 			     if symp -> symbol.dimensioned then
     5748 				symbol_length =
     5749 				     divide (addr (OS (symp -> symbol.dimension)) -> dimension.array_size
     5750 				     + units_per_word (symp -> symbol.units) - 1,
     5751 				     units_per_word (symp -> symbol.units), 18);
     5752 			     else
     5753 				symbol_length =
     5754 				     divide (symp -> symbol.char_size + chars_per_word - 1, chars_per_word, 18);
     5755 			     if symbol_length <= max_length_this_pass then do;
     5756 						/*  Add symbol to an LA group.  */
     5757 				symbol_even = symp -> symbol.double_precision | symp -> symbol.complex;
     5758 				symbol_storage_class = substr (string (symp -> symbol.storage_class), 1, 3);
     5759 				if symbol_storage_class = ""b then
     5760 				     symbol_storage_class = string (sub_ptr -> subprogram.default_is);
     5761 				prev_LA_hdrp = null;
     5762 				do LA_hdri = sub_ptr -> subprogram.LA_chain
     5763 				     repeat LA_hdrp -> header.next_header
     5764 				     while (symp -> symbol.parent = 0 & LA_hdri ^= 0);
     5765 				     LA_hdrp = addr (OS (LA_hdri));
     5766 				     block_length = LA_hdrp -> header.length;
     5767 				     if symbol_even then
     5768 					block_length = block_length + mod (block_length, 2);
     5769 				     if string (LA_hdrp -> header.storage_class) = symbol_storage_class
     5770 					& block_length + symbol_length <= max_length_this_pass then do;
     5771 						/*  Add symbol to end of this LA group.  */
     5772 					addr (OS (LA_hdrp -> header.last_element)) -> symbol.next_member = symi;
     5773 					string (LA_hdrp -> header.storage_info) =
     5774 					     string (LA_hdrp -> storage_info)
     5775 					     | string (symp -> symbol.storage_info);
     5776 					LA_hdrp -> header.last_element = symi;
     5777 					LA_hdrp -> header.length = block_length + symbol_length;
     5778 					symp -> symbol.LA = TRUE;
     5779 					symp -> symbol.parent = LA_hdri;
     5780 					symp -> symbol.offset =
     5781 					     units_per_word (symp -> symbol.units) * block_length;
     5782 				     end;
     5783 				     prev_LA_hdrp = LA_hdrp;
     5784 				end;
     5785 				if symp -> symbol.parent = 0 then do;
     5786 						/*  Create a new group for this array.  */
     5787 				     allocate_symbol_name = 0;
     5788 				     LA_hdri = create_node (header_node, size (header));
     5789 				     if prev_LA_hdrp = null then
     5790 					sub_ptr -> subprogram.LA_chain = LA_hdri;
     5791 				     else
     5792 					prev_LA_hdrp -> header.next_header = LA_hdri;
     5793 				     LA_hdrp = addr (OS (LA_hdri));
     5794 				     string (LA_hdrp -> header.storage_info) =
     5795 					string (symp -> symbol.storage_info);
     5796 				     LA_hdrp -> header.even = TRUE;
     5797 				     string (LA_hdrp -> header.storage_class) = symbol_storage_class;
     5798 				     LA_hdrp -> header.LA = TRUE;
     5799 				     LA_hdrp -> header.length = symbol_length;
     5800 				     LA_hdrp -> header.first_element, LA_hdrp -> header.last_element = symi;
     5801 				     symp -> symbol.LA = TRUE;
     5802 				     symp -> symbol.parent = LA_hdri;
     5803 				end;
     5804 			     end;
     5805 			end;
     5806 		     end;
     5807 		end;
     5808 
     5809 /*  Run through the equivalence chain looking for groups whose size is more  */
     5810 /*  than that required for one element of the dominant type in the group but */
     5811 /*  not exceeding 'max_length_this_pass' and move them to a group in the LA  */
     5812 /*  chain, creating a new group if necessary.                                */
     5813 
     5814 		prev_equiv_hdrp = null;
     5815 		equiv_hdri = sub_ptr -> subprogram.equiv_chain;
     5816 		do while (equiv_hdri ^= 0);
     5817 		     equiv_hdrp = addr (OS (equiv_hdri));
     5818 		     if ((subr_options.LA_auto & equiv_hdrp -> header.automatic)
     5819 			| (subr_options.LA_static & equiv_hdrp -> header.static)) then do;
     5820 			group_length =
     5821 			     divide (equiv_hdrp -> header.length + units_per_word (equiv_hdrp -> header.units) - 1,
     5822 			     units_per_word (equiv_hdrp -> header.units), 18);
     5823 			if group_length > bin (equiv_hdrp -> header.even) + 1 & group_length <= max_length_this_pass
     5824 			then do;			/*  Move this equivalence group to the LA chain.  */
     5825 			     if prev_equiv_hdrp = null then
     5826 				sub_ptr -> subprogram.equiv_chain = equiv_hdrp -> header.next_header;
     5827 			     else
     5828 				prev_equiv_hdrp -> header.next_header = equiv_hdrp -> header.next_header;
     5829 			     prev_LA_hdrp = null;
     5830 			     added_group = FALSE;
     5831 			     do LA_hdri = sub_ptr -> subprogram.LA_chain repeat LA_hdrp -> header.next_header
     5832 				while (^added_group & LA_hdri ^= 0);
     5833 				LA_hdrp = addr (OS (LA_hdri));
     5834 				block_length = LA_hdrp -> header.length;
     5835 				if equiv_hdrp -> header.even then
     5836 				     block_length = block_length + mod (block_length, 2);
     5837 				if string (LA_hdrp -> header.storage_class)
     5838 				     = string (equiv_hdrp -> header.storage_class)
     5839 				     & block_length + group_length <= max_length_this_pass then do;
     5840 						/*  Move equiv group to end of this LA group.  */
     5841 				     addr (OS (LA_hdrp -> header.last_element)) -> symbol.next_member =
     5842 					equiv_hdrp -> header.first_element;
     5843 				     string (LA_hdrp -> header.storage_info) =
     5844 					string (LA_hdrp -> storage_info)
     5845 					| string (equiv_hdrp -> header.storage_info);
     5846 				     LA_hdrp -> header.last_element = equiv_hdrp -> header.last_element;
     5847 				     LA_hdrp -> header.length = block_length + group_length;
     5848 				     do symi = equiv_hdrp -> header.first_element
     5849 					repeat symp -> symbol.next_member while (symi ^= 0);
     5850 					symp = addr (OS (symi));
     5851 					symp -> symbol.LA = TRUE;
     5852 					symp -> symbol.parent = LA_hdri;
     5853 					symp -> symbol.offset =
     5854 					     symp -> symbol.offset
     5855 					     + units_per_word (symp -> symbol.units) * block_length;
     5856 				     end;
     5857 				     allocate_symbol_name = equiv_hdrp -> header.name_length;
     5858 				     if equiv_hdri + size (header) = next_free_operand then
     5859 					next_free_operand = equiv_hdri;
     5860 						/*  Storage can be reused.  */
     5861 				     added_group = TRUE;
     5862 				end;
     5863 				prev_LA_hdrp = LA_hdrp;
     5864 			     end;
     5865 			     if ^added_group then do; /*  Create a new LA group from the equiv group.  */
     5866 				if prev_LA_hdrp = null then
     5867 				     sub_ptr -> subprogram.LA_chain = equiv_hdri;
     5868 				else
     5869 				     prev_LA_hdrp -> header.next_header = equiv_hdri;
     5870 				equiv_hdrp -> header.next_header = 0;
     5871 				equiv_hdrp -> header.LA = TRUE;
     5872 				equiv_hdrp -> header.units = word_units;
     5873 				equiv_hdrp -> header.length = group_length;
     5874 				do symi = equiv_hdrp -> header.first_element
     5875 				     repeat symp -> symbol.next_member while (symi ^= 0);
     5876 				     symp = addr (OS (symi));
     5877 				     symp -> symbol.LA = TRUE;
     5878 				end;
     5879 			     end;
     5880 			end;
     5881 			else
     5882 			     prev_equiv_hdrp = equiv_hdrp;
     5883 						/*  Leave group on equiv chain.  */
     5884 		     end;
     5885 		     else
     5886 			prev_equiv_hdrp = equiv_hdrp; /*  Leave group on equiv chain.  */
     5887 		     if prev_equiv_hdrp = null then
     5888 			equiv_hdri = sub_ptr -> subprogram.equiv_chain;
     5889 		     else
     5890 			equiv_hdri = prev_equiv_hdrp -> header.next_header;
     5891 		end;
     5892 	     end;
     5893 	end /*  End of LA processing.  */;
     5894 
     5895 	return;
     5896 
     5897 
     5898 get_equiv_var:
     5899      procedure (hdr, hdr_ptr, char_offset) returns (fixed bin (24));
     5900 
     5901 dcl      hdr fixed bin (18);
     5902 dcl      hdr_ptr pointer;
     5903 dcl      char_offset bit (1);
     5904 dcl      offset fixed bin (24);
     5905 dcl      length fixed bin (24);
     5906 
     5907 	indx = stack (i);
     5908 	indx_ptr = addr (OS (indx));
     5909 	i = i + 1;
     5910 
     5911 /* set character_offset to see if ansi77 equiv group rules hold, tested later
     5912*   in the routine 'verify_offset_type_kludge' */
     5913 
     5914 	char_offset = indx_ptr -> symbol.mode.character & subr_options.ansi_77;
     5915 
     5916 	if (unspec (addr (OS (indx)) -> symbol.attributes) & equiv_conflicts) | addr (OS (indx)) -> symbol.by_compiler
     5917 	then do;
     5918 	     call print_message (64, indx);		/* cannot be equivalenced */
     5919 	     i = i + 1;
     5920 	     return (0);
     5921 	end;
     5922 
     5923 	offset = stack (i) * indx_ptr -> symbol.element_size + stack (i + 1);
     5924 	i = i + 2;
     5925 
     5926 	if offset > max_fixed_bin_24 then do;
     5927 	     call print_message (136, "length", indx, ltrim (char (max_fixed_bin_24)));
     5928 						/* implementation restriction */
     5929 	     return (0);
     5930 	end;
     5931 
     5932 	if indx_ptr -> symbol.equivalenced & indx_ptr -> symbol.parent > 0 then do;
     5933 	     hdr = indx_ptr -> symbol.parent;
     5934 	     hdr_ptr = addr (OS (hdr));
     5935 
     5936 	     offset = offset + indx_ptr -> symbol.offset;
     5937 	     if char_offset then
     5938 		hdr_ptr -> header.units = char_units;
     5939 	end;
     5940 	else do;
     5941 	     if indx_ptr -> symbol.dimensioned then do;
     5942 		length = addr (OS (indx_ptr -> symbol.dimension)) -> dimension.array_size;
     5943 		if length = 0 then do;
     5944 		     call print_message (65, indx);	/* cannot be equivalenced */
     5945 		     return (0);
     5946 		end;
     5947 	     end;
     5948 	     else
     5949 		length = indx_ptr -> symbol.element_size;
     5950 
     5951 	     allocate_symbol_name = 0;		/* no name for equivalence group */
     5952 	     hdr = create_node (header_node, size (header));
     5953 	     hdr_ptr = addr (OS (hdr));
     5954 
     5955 	     string (hdr_ptr -> header.storage_class) = substr (string (indx_ptr -> symbol.storage_class), 1, 3);
     5956 	     string (hdr_ptr -> header.storage_info) = string (indx_ptr -> symbol.storage_info);
     5957 	     hdr_ptr -> header.next_header = sub_ptr -> equiv_chain;
     5958 	     sub_ptr -> equiv_chain = hdr;
     5959 	     hdr_ptr -> header.first_element, hdr_ptr -> header.last_element = indx;
     5960 	     hdr_ptr -> header.length = length;
     5961 	     if char_offset then
     5962 		hdr_ptr -> header.units = char_units;
     5963 
     5964 	     if indx_ptr -> symbol.double_precision | indx_ptr -> symbol.complex then
     5965 		hdr_ptr -> header.even = TRUE;
     5966 
     5967 	     indx_ptr -> symbol.parent = hdr;
     5968 	     indx_ptr -> symbol.equivalenced = TRUE;
     5969 	end;
     5970 
     5971 	equiv_error = FALSE;
     5972 
     5973 	return (offset);
     5974      end get_equiv_var;
     5975 
     5976 verify_offset_type_kludge:
     5977      proc (offset, char_type_offset) returns (fixed bin (24));
     5978 
     5979 /* This routine allows ansi77 character variables to be equivalenced to other
     5980*   data types.  This is strickly AGAINST the standard.  We allow it for people
     5981*   who wish to use strange and dangerous programming practices.
     5982*
     5983*   The code just checks to see if the offset is of type character and then
     5984*   whether the offset is actually supposed to be in words.  If so, it is
     5985*   converted.  */
     5986 
     5987 dcl      char_type_offset bit (1);
     5988 dcl      offset fixed bin (24);
     5989 dcl      new_offset fixed bin (24);
     5990 
     5991 	new_offset = offset;
     5992 
     5993 	if char_type_offset then
     5994 	     if ^all_character_offsets_in_group then do;
     5995 		if stack (i + 2) > 0 then
     5996 		     return (new_offset);
     5997 
     5998 		if mod (new_offset, 4) ^= 0 then do;
     5999 		     call print_message (63, indx);
     6000 		     goto equivalence_member_abort;
     6001 		end;
     6002 		new_offset = new_offset / 4;
     6003 	     end;
     6004 	return (new_offset);
     6005      end verify_offset_type_kludge;
     6006 
     6007 validate_array_bound:
     6008      proc (bnd_sym_idx);
     6009 
     6010 /* Check that a variable array bound is a common or parameter, scalar, integer
     6011*   variable, or the result of an arithmetic expression of such variables. */
     6012 
     6013 dcl      bnd_sym_idx fixed bin (24);			/* Index of the symbol containing the bound. */
     6014 
     6015 dcl      bnd_sym_ptr ptr,
     6016          expression_size fixed bin,
     6017          expression_start fixed bin (18),
     6018          opnd_idx fixed bin (24),
     6019          polish_idx fixed bin (18);
     6020 
     6021 	bnd_sym_ptr = addr (OS (bnd_sym_idx));
     6022 	if ^bnd_sym_ptr -> symbol.by_compiler then
     6023 	     call validate (bnd_sym_idx);
     6024 	else if bnd_sym_ptr -> symbol.initial ^= 0 then do;
     6025 	     expression_start = bnd_sym_ptr -> symbol.initial;
     6026 	     expression_size = polish_string (expression_start - 1);
     6027 	     do polish_idx = expression_start to expression_start + expression_size - 1;
     6028 		opnd_idx = polish_string (polish_idx);
     6029 		if opnd_idx > last_assigned_op then
     6030 		     if addr (OS (opnd_idx)) -> node.node_type = symbol_node then
     6031 			call validate (opnd_idx);
     6032 	     end;
     6033 	end;
     6034 	return;
     6035 
     6036 
     6037 validate:
     6038      procedure (ndx);
     6039 
     6040 declare	ndx fixed binary (24);			/* INPUT: index of array bound symbol */
     6041 declare	symbol_storage bit (5) unaligned defined (sym_ptr -> symbol.storage_info);
     6042 declare	sym_ptr pointer;
     6043 declare	header_storage bit (5) unaligned defined (addr (OS (sym_ptr -> symbol.parent)) -> header.storage_info);
     6044 
     6045 	sym_ptr = addr (OS (ndx));
     6046 	call set_data_fields ((ndx));
     6047 
     6048 	if ^(sym_ptr -> symbol.parameter | sym_ptr -> symbol.in_common) | ^sym_ptr -> symbol.integer
     6049 	     | sym_ptr -> symbol.dimensioned then
     6050 	     call print_message (19, ndx, SI);
     6051 	else
     6052 	     symbol_storage = symbol_storage | REF;
     6053 
     6054 /* if variable is in common, set common block header to indicate it is REF */
     6055 
     6056 	if sym_ptr -> symbol.in_common & sym_ptr -> symbol.parent ^= 0 then
     6057 	     header_storage = header_storage | REF;
     6058 
     6059      end validate;
     6060      end validate_array_bound;
     6061 
     6062      end declaration_processor;
     6063 
     6064 /* BEGIN ext_parse section -SUPPORT  - split 82-03-29  T. Oke */
     6065 
     6066 /* Modification History - 82-04-05 */
     6067 
     6068 /* Modification:
     6069*	10 Feb 83, HH - Install LA/VLA support.
     6070*	08 Feb 83, HH - 366/369: Fix bug where 'parse_data' fails to force
     6071*	     initial value of a character variable to be at least as long
     6072*	     as the character variable.
     6073*	13 Dec 82, TO - 365: Fix bug in 'parse_expression', where substr
     6074*	     processing of (x:) uses 'indx' left from 'x' expression parse,
     6075*	     rather than the index of the string symbol which is currently
     6076*	     in the stack.
     6077*	21 May 82,  TO  - Have needs_descriptors of args set if character
     6078*	     and in ansi77 mode.
     6079*	19 May 82,  TO  - Have needs_descriptors set if star_extent char 
     6080*	     array, as well as variable_extents array in parse_expression.
     6081*	 6 May 82,  TO  - Fix bug of reference to entry point in assigning
     6082*	     result of  function, link entry assignment to 'return_value'.
     6083*	 4 May 82,  TO  - Add needs_descriptors check in parse_expression,
     6084*	     to manage setting descriptor requirement for local auto
     6085*	     stack allocated variable of character*(*) function.
     6086*	 5 Apr 82,  TO  - Check number of args in parse_parameter_list.
     6087*	*/
     6088 
     6089 set_data_fields:
     6090      procedure (a_sym);
     6091 
     6092 dcl      a_sym fixed bin (18);
     6093 dcl      sym fixed bin (18);
     6094 dcl      array_max_size fixed bin (24);
     6095 dcl      dt fixed bin (18);
     6096 dcl      sp pointer;
     6097 dcl      te fixed bin (24);
     6098 dcl      wc fixed bin (18);
     6099 
     6100 	sym = a_sym;
     6101 
     6102 	call assign_data_type (sym);
     6103 
     6104 	sp = addr (OS (sym));
     6105 	if sp -> symbol.data_type ^= 0 then
     6106 	     return;
     6107 
     6108 	dt, sp -> symbol.data_type = index (string (sp -> symbol.mode), TRUE);
     6109 
     6110 	if dt ^= char_mode then
     6111 	     wc, sp -> symbol.element_size = data_type_size (dt);
     6112 	else if subr_options.ansi_77 then do;
     6113 	     wc, sp -> symbol.element_size = sp -> symbol.char_size + 1;
     6114 	     sp -> symbol.units = char_units;
     6115 	end;
     6116 	else
     6117 	     wc, sp -> symbol.element_size = divide (sp -> symbol.char_size + chars_per_word, chars_per_word, 17, 0);
     6118 
     6119 	if sp -> symbol.dimensioned & ^sp -> symbol.variable_extents & ^sp -> symbol.star_extents then do;
     6120 	     te = addr (OS (sp -> symbol.dimension)) -> dimension.element_count * wc;
     6121 
     6122 	     if dt = char_mode then
     6123 		array_max_size = max_array_size.char;
     6124 	     else if sp -> symbol.automatic then
     6125 		array_max_size = max_array_size.auto;
     6126 	     else if sp -> symbol.in_common then
     6127 		array_max_size = max_array_size.common;
     6128 	     else if sp -> symbol.parameter then
     6129 		array_max_size = max_array_size.parm;
     6130 	     else if sp -> symbol.static then
     6131 		array_max_size = max_array_size.static;
     6132 	     else
     6133 		array_max_size =
     6134 		     max (max_array_size.auto, max_array_size.common, max_array_size.parm, max_array_size.static);
     6135 
     6136 	     if te > array_max_size * units_per_word (sp -> symbol.units) then
     6137 		call print_message (136, "size", sym, ltrim (char (array_max_size)) || " words");
     6138 	     else
     6139 		addr (OS (sp -> symbol.dimension)) -> dimension.array_size = te;
     6140 	end;
     6141 
     6142 	return;
     6143      end set_data_fields;
     6144 
     6145 assign_data_type:
     6146      procedure (sym_index);
     6147 
     6148 dcl      sp pointer;
     6149 dcl      sym_index fixed bin (18);
     6150 
     6151 	sp = addr (OS (sym_index));
     6152 	if string (sp -> symbol.mode) ^= ZERO then
     6153 	     return;
     6154 
     6155 	unspec (sp -> symbol.attributes) =
     6156 	     unspec (sp -> symbol.attributes) | default_table (index (alphabetic, substr (sp -> symbol.name, 1, 1)));
     6157      end assign_data_type;
     6158 
     6159 build_main_program:
     6160      procedure (subpr_symb);
     6161 
     6162 /* given the index of the symbol for this main program, set the subprogram node */
     6163 
     6164 declare	subpr_symb fixed binary (18);			/* INPUT: index of symbol for main prog */
     6165 
     6166 /* main program must be first */
     6167 	if cur_subprogram ^= first_subprogram then
     6168 	     call print_message (3);
     6169 
     6170 /* set symbol for the entry point, link entry point to block, treat as user symbol */
     6171 	subprogram_symbol = subpr_symb;
     6172 	subprogram_conflicts = all_attributes;
     6173 	subprogram_attributes = main_attr;
     6174 	unspec (addr (OS (subprogram_symbol)) -> symbol.attributes) = main_attr;
     6175 	unspec (addr (OS (subprogram_symbol)) -> symbol.storage_info) = SET;
     6176 	addr (OS (subprogram_symbol)) -> symbol.parent = cur_subprogram;
     6177 	addr (OS (subprogram_symbol)) -> symbol.by_compiler = FALSE;
     6178 
     6179 /* fill in type of subprogram and point to its symbol */
     6180 
     6181 	sub_ptr -> subprogram_type = main_program;
     6182 	sub_ptr -> subprogram.symbol = subprogram_symbol;
     6183 
     6184 /* Start the list of pending entries. */
     6185 
     6186 	pending_entry_cnt = 1;
     6187 	pending_entry (1).entry_symbol = subprogram_symbol;
     6188 	if statement_type < after_subprogram then
     6189 	     pending_entry (1).entry_stmnt = unspec (cur_stmnt_ptr -> statement);
     6190 	else do;					/* There is no 'program' statement; fake a 'statement' node. */
     6191 	     pending_entry (1).entry_stmnt = ""b;
     6192 	     addr (pending_entry (1).entry_stmnt) -> statement.op_code = stat_op;
     6193 	     addr (pending_entry (1).entry_stmnt) -> statement.location = (18)"1"b;
     6194 	     addr (pending_entry (1).entry_stmnt) -> statement.statement = "00001"b;
     6195 	     addr (pending_entry (1).entry_stmnt) -> statement.put_in_map = TRUE;
     6196 	end;
     6197 
     6198 	subprogram_op = main_op;
     6199 	return_value_param = 0;
     6200 
     6201 	return;
     6202      end build_main_program;
     6203 
     6204 build_common_block:
     6205      procedure (common_blk_name) returns (fixed binary (18));
     6206 
     6207 /* build a header node and initialize it for a common-block */
     6208 
     6209 declare	common_blk_name char (256) varying;		/* INPUT - name of common block */
     6210 declare	indxx fixed binary (18);			/* Return value */
     6211 declare	header_ptr pointer;
     6212 
     6213 	allocate_symbol_name = length (common_blk_name);
     6214 	indxx = create_node (header_node, size (header));
     6215 	header_ptr = addr (OS (indxx));
     6216 
     6217 	string (header_ptr -> header.storage_class) = common_storage;
     6218 	header_ptr -> header.even = TRUE;		/* MUST be on double-word boundary */
     6219 	header_ptr -> header.name_length = allocate_symbol_name;
     6220 	substr (header_ptr -> header.block_name, 1, allocate_symbol_name) = common_blk_name;
     6221 
     6222 	return (indxx);
     6223      end build_common_block;
     6224 
     6225 process_pending_entries:
     6226      proc;
     6227 
     6228 /* For each pending entry, emit a 'main', 'func' or 'subr' operator, as
     6229*   appropriate.  If the entry has parameters, emit assignments to initialize
     6230*   any associated compiler generated array bound variables, then emit a
     6231*   'process_param_list' operator. */
     6232 
     6233 dcl      Asterisk fixed bin static options (constant) init (0);
     6234 
     6235 dcl      arg_desc_cnt fixed bin,
     6236          arg_desc_idx fixed bin,
     6237          arg_desc_ptr ptr,
     6238          arg_symbol_ptr ptr,
     6239          bound_is_expression bit (1),
     6240          bound_symbol_ptr ptr,
     6241          bypass_label fixed bin (18),
     6242          dim_cnt fixed bin,
     6243          dim_idx fixed bin,
     6244          dimension_ptr ptr,
     6245          entry_symbol fixed bin (18),
     6246          entry_symbol_ptr ptr,
     6247          expression_size fixed bin,
     6248          expression_start fixed bin (18),
     6249          i fixed bin,
     6250          idx_of_count fixed bin (18),
     6251          last_upper_bound fixed bin,
     6252          param_count fixed bin,
     6253          pending_entry_idx fixed bin,
     6254          polish_idx fixed bin,
     6255          stmnt_ptr ptr;
     6256 
     6257 	if cur_statement + size (statement) < next_free_polish then
     6258 	     call emit_statement_op (cur_stmnt_ptr);	/* Insure last Polish item is a stat-op. */
     6259 	bypass_label = 0;
     6260 	do pending_entry_idx = 1 to pending_entry_cnt;
     6261 	     entry_symbol = pending_entry (pending_entry_idx).entry_symbol;
     6262 
     6263 /* If there is more than one pending entry, the second and subsequent ones
     6264*   must be bypassed (i.e. preceded by a branch to the statement following
     6265*   the last pending entry) so that control can not "fall" into the entry
     6266*   sequence code from the preceding entry.  The 'bypass_first_pending_entry'
     6267*   flag tells us if we have to bypass the first entry. */
     6268 
     6269 	     if bypass_label = 0 & (pending_entry_idx > 1 | bypass_first_pending_entry) then do;
     6270 						/* This is the 1st entry to bypass; create the bypass label. */
     6271 		cp_label_count = cp_label_count - 1;	/* Generate a unique label number. */
     6272 		bypass_label = create_label (cp_label_count, executable_label, GOTO_TARGET);
     6273 	     end;
     6274 	     if bypass_label ^= 0 then do;		/* Emit a jump to the bypass label. */
     6275 		call emit_operand (bypass_label);
     6276 		call emit_operator (jump_op);
     6277 		stmnt_ptr = cur_stmnt_ptr;
     6278 		call emit_statement_op (cur_stmnt_ptr);
     6279 		unspec (stmnt_ptr -> statement) = pending_entry (pending_entry_idx).entry_stmnt;
     6280 		stmnt_ptr -> statement.next = bit (cur_statement, 18);
     6281 	     end;
     6282 
     6283 /* Emit a 'main_op', 'subr_op' or 'func_op', as required for this entry. */
     6284 
     6285 	     call emit_operand (entry_symbol);
     6286 	     call emit_count (idx_of_count);
     6287 	     call emit_operator ((subprogram_op));
     6288 
     6289 /* Determine the number of parameters for this entry.  The parameters are
     6290*   the "nonasterisk" arguments plus any return value.  Also, if the entry
     6291*   has any expression extent array parameters, emit assignments to
     6292*   initialize the compiler generated bound variables to the expressions. */
     6293 
     6294 	     if return_value_param = 0 then
     6295 		param_count = 0;
     6296 	     else
     6297 		param_count = 1;
     6298 
     6299 	     entry_symbol_ptr = addr (OS (entry_symbol));
     6300 	     if entry_symbol_ptr -> symbol.general = 0 then
     6301 		arg_desc_cnt = 0;
     6302 	     else do;
     6303 		arg_desc_ptr = addr (OS (entry_symbol_ptr -> symbol.general));
     6304 		arg_desc_cnt = arg_desc_ptr -> arg_desc.n_args;
     6305 	     end;
     6306 
     6307 	     do arg_desc_idx = 1 to arg_desc_cnt;
     6308 		if arg_desc_ptr -> arg_desc.symbol (arg_desc_idx) ^= Asterisk then do;
     6309 		     param_count = param_count + 1;
     6310 		     arg_symbol_ptr = addr (OS (arg_desc_ptr -> arg_desc.symbol (arg_desc_idx)));
     6311 
     6312 		     if arg_symbol_ptr -> symbol.variable_extents then do;
     6313 						/* Check if any of the variable extents are expressions. */
     6314 			dimension_ptr = addr (OS (arg_symbol_ptr -> symbol.dimension));
     6315 			dim_cnt = dimension_ptr -> dimension.number_of_dims;
     6316 
     6317 			if dimension_ptr -> dimension.assumed_size then
     6318 			     last_upper_bound = dim_cnt - 1;
     6319 			else
     6320 			     last_upper_bound = dim_cnt;
     6321 
     6322 			do dim_idx = 1 to dim_cnt;
     6323 			     do i = 1 to 2;		/* Check lower and upper bound of 'dim_idx'th dimension. */
     6324 				if i = 1 then
     6325 				     if dimension_ptr -> dimension.v_bound (dim_idx).lower then do;
     6326 					bound_symbol_ptr =
     6327 					     addr (OS (dimension_ptr -> dimension.lower_bound (dim_idx)));
     6328 					bound_is_expression = bound_symbol_ptr -> symbol.by_compiler;
     6329 				     end;
     6330 				     else
     6331 					bound_is_expression = FALSE;
     6332 				else if dimension_ptr -> dimension.v_bound (dim_idx).upper
     6333 				     & dim_idx <= last_upper_bound then do;
     6334 				     bound_symbol_ptr =
     6335 					addr (OS (dimension_ptr -> dimension.upper_bound (dim_idx)));
     6336 				     bound_is_expression = bound_symbol_ptr -> symbol.by_compiler;
     6337 				end;
     6338 				else
     6339 				     bound_is_expression = FALSE;
     6340 
     6341 				if bound_is_expression then do;
     6342 						/* Emit assignment of bound expression to bound variable. */
     6343 				     expression_start = bound_symbol_ptr -> symbol.initial;
     6344 				     expression_size = polish_string (expression_start - 1);
     6345 
     6346 				     if next_free_polish + expression_size + 2 >= polish_max_len then
     6347 					call print_message (67, "polish string", char (polish_max_len));
     6348 				     else do;
     6349 					call emit_operand (fixed (rel (bound_symbol_ptr)));
     6350 					do polish_idx = expression_start
     6351 					     to expression_start + expression_size - 1;
     6352 					     polish_string (next_free_polish) = polish_string (polish_idx);
     6353 					     next_free_polish = next_free_polish + 1;
     6354 					end;
     6355 					call emit_operator (assign_op);
     6356 				     end;
     6357 				end;
     6358 			     end;
     6359 			end;
     6360 		     end;
     6361 		end;
     6362 	     end;
     6363 
     6364 /* If there are any parameters, emit the 'process_param_list' operator. */
     6365 
     6366 	     if param_count > 0 then do;
     6367 		polish_string (idx_of_count) = param_count - bias;
     6368 						/* Store param_count in entry op. */
     6369 		call emit_operand (param_count - bias);
     6370 		call emit_operator (process_param_list_op);
     6371 		do arg_desc_idx = 1 to arg_desc_cnt;
     6372 		     if arg_desc_ptr -> arg_desc.symbol (arg_desc_idx) ^= Asterisk then do;
     6373 			call emit_operand ((arg_desc_ptr -> arg_desc.symbol (arg_desc_idx)));
     6374 			call emit_operator (item_op);
     6375 		     end;
     6376 		end;
     6377 		if return_value_param ^= 0 then do;
     6378 		     call emit_operand (return_value_param);
     6379 		     call emit_operator (item_op);
     6380 		end;
     6381 		call emit_operator (eol_op);
     6382 	     end;
     6383 
     6384 /* Emit a new stat-op for the next statement, then change the preceding one
     6385*   to reflect the entry we just processed. */
     6386 
     6387 	     stmnt_ptr = cur_stmnt_ptr;
     6388 	     call emit_statement_op (cur_stmnt_ptr);
     6389 	     unspec (stmnt_ptr -> statement) = pending_entry (pending_entry_idx).entry_stmnt;
     6390 	     stmnt_ptr -> statement.next = bit (cur_statement, 18);
     6391 	end;
     6392 
     6393 /* If we bypassed any entries, emit the bypass label. */
     6394 
     6395 	if bypass_label ^= 0 then do;
     6396 	     call emit_operand (bypass_label);
     6397 	     call emit_operator (label_op);
     6398 	     stmnt_ptr = cur_stmnt_ptr;
     6399 	     call emit_statement_op (cur_stmnt_ptr);
     6400 	     unspec (stmnt_ptr -> statement) = pending_entry (pending_entry_cnt).entry_stmnt;
     6401 	     stmnt_ptr -> statement.next = bit (cur_statement, 18);
     6402 	end;
     6403 
     6404 	pending_entry_cnt = 0;
     6405      end process_pending_entries;
     6406 
     6407 emit_operator:
     6408 emit_operand:
     6409 emit_halfword:
     6410      procedure (op_name_or_opnd_or_data);		/*	Program Specifications (emit_operator)
     6411*
     6412*     Inputs
     6413*
     6414*     Output
     6415*
     6416*     Description (emit_operator)
     6417**/
     6418 
     6419 dcl      count fixed bin (18);
     6420 dcl      op_name_or_opnd_or_data fixed bin (18);
     6421 dcl      st_info_p ptr;
     6422 dcl      stmnt_info_ptr ptr;
     6423 dcl      wrd_off fixed bin (18);
     6424 
     6425 	if next_free_polish >= polish_max_len then
     6426 	     call print_message (67, "polish string", char (polish_max_len));
     6427 						/* polish string too long */
     6428 	else do;
     6429 	     polish_string (next_free_polish) = op_name_or_opnd_or_data;
     6430 	     next_free_polish = next_free_polish + 1;
     6431 	end;
     6432 	return;
     6433 
     6434 emit_count:
     6435      entry (wrd_off);
     6436 	if next_free_polish >= polish_max_len then
     6437 	     call print_message (67, "polish string", char (polish_max_len));
     6438 						/* polish string too long */
     6439 	else do;
     6440 	     polish_string (next_free_polish) = -bias;
     6441 	     wrd_off = next_free_polish;
     6442 	     next_free_polish = next_free_polish + 1;
     6443 	end;
     6444 	return;
     6445 
     6446 emit_statement_op:
     6447      entry (st_info_p);
     6448 	stmnt_info_ptr = st_info_p;			/* Copy value in case input arg is cur_stmnt_ptr. */
     6449 
     6450 	last_cur_statement = cur_statement;
     6451 
     6452 	if next_free_polish + size (statement) >= polish_max_len then
     6453 	     call print_message (67, "polish string", char (polish_max_len));
     6454 	else do;
     6455 	     cur_statement = next_free_polish;
     6456 	     cur_stmnt_ptr = addr (polish_string (cur_statement));
     6457 	     cur_stmnt_ptr -> statement = stmnt_info_ptr -> statement;
     6458 
     6459 	     next_free_polish = next_free_polish + size (statement);
     6460 
     6461 	     if last_statement ^< 0 then
     6462 		addr (polish_string (last_statement)) -> statement.next = bit (cur_statement, 18);
     6463 
     6464 	     last_statement = cur_statement;
     6465 	end;
     6466 	return;
     6467 
     6468 increment_polish:
     6469      entry (count);
     6470 	if next_free_polish + count >= polish_max_len then
     6471 	     call print_message (67, "polish string", char (polish_max_len));
     6472 	else do;
     6473 	     if count = 1 then
     6474 		polish_string (next_free_polish) = no_op;
     6475 	     else do;
     6476 		polish_string (next_free_polish) = increment_polish_op;
     6477 		polish_string (next_free_polish + 1) = count - 2;
     6478 	     end;
     6479 	     next_free_polish = next_free_polish + count;
     6480 	end;
     6481 	return;
     6482      end emit_operator;
     6483 
     6484 emit_return_op:
     6485      procedure;
     6486 	if subprogram_op = func_op then do;
     6487 	     call emit_operand (return_value_param);
     6488 	     call emit_operand (return_value);
     6489 	     call emit_operator (assign_op);
     6490 	end;
     6491 	call emit_operator (return_op);
     6492      end emit_return_op;
     6493 
     6494 finish_sf_defs:
     6495      proc;
     6496 	if sub_ptr -> subprogram_type = block_data then
     6497 	     call print_message (4);			/* executable statement in block data */
     6498 
     6499 	assignment_statement_index = assignment_statement;
     6500      end finish_sf_defs;
     6501 
     6502 generate_cross_ref:
     6503      procedure (item);
     6504 
     6505 dcl      item fixed bin (18);
     6506 
     6507 
     6508 	if number_of_crefs = max_fixed_bin_18 then
     6509 	     call print_message (67, "cross reference region", char (max_fixed_bin_18));
     6510 
     6511 	number_of_crefs = number_of_crefs + 1;
     6512 	cross_reference (number_of_crefs).symbol = item;
     6513 
     6514 	if cur_statement < 0 | addr (polish_string (cur_statement)) -> statement.line = ZERO then
     6515 	     cross_reference (number_of_crefs).line_no = 0;
     6516 	else
     6517 	     cross_reference (number_of_crefs).line_no = cur_statement_list;
     6518      end generate_cross_ref;
     6519 
     6520 declare_symbol:
     6521      procedure (indx, attributes, conflicts, storage_type) returns (bit (1) aligned);
     6522 
     6523 /*	Program Specifications (declare_symbol)
     6524*
     6525*     Inputs
     6526*
     6527*     Output
     6528*
     6529*     Description (declare_symbol)
     6530**/
     6531 
     6532 dcl      attributes bit (47) aligned;
     6533 dcl      conflicts bit (47) aligned;
     6534 dcl      header_storage bit (5) unaligned defined (addr (OS (indx_ptr -> symbol.parent)) -> header.storage_info);
     6535 dcl      indx fixed bin (18);
     6536 dcl      indx_ptr pointer;
     6537 dcl      storage_type bit (5) aligned;
     6538 dcl      symbol_storage bit (5) unaligned defined (indx_ptr -> symbol.storage_info);
     6539 
     6540 	indx_ptr = addr (OS (indx));
     6541 
     6542 	if (unspec (indx_ptr -> symbol.attributes) & conflicts) ^= ZERO then
     6543 	     return (FALSE);
     6544 
     6545 	unspec (indx_ptr -> symbol.attributes) = unspec (indx_ptr -> symbol.attributes) | attributes;
     6546 
     6547 	if storage_type ^= DECLARED then do;
     6548 	     symbol_storage = symbol_storage | storage_type;
     6549 	     if indx_ptr -> symbol.equivalenced then
     6550 		if indx_ptr -> symbol.parent > 0	/* update header only if it exists */
     6551 		     then
     6552 		     header_storage = header_storage | storage_type;
     6553 	end;
     6554 
     6555 	return (TRUE);
     6556      end declare_symbol;
     6557 
     6558 enter_label:
     6559      procedure (a_type, a_value, a_usage) returns (fixed bin (18));
     6560 
     6561 /*	Program Specifications (enter_label)
     6562*
     6563*     Inputs
     6564*
     6565*     Output
     6566*
     6567*     Description (enter_label)
     6568*	The fact that legal values for label_type are "01"b, "10"b, "11"b is used in
     6569*	selecting error messages.
     6570*
     6571*	In '66 mode, branching into a do-loop is legal.  It is not legal in
     6572*	'77 mode and we diagnose a fatal error if we detect it.  We detect
     6573*	a branch into a do-loop as follows:  For each executable label, we
     6574*	keep track (in its 'label' node) of whether it is branched to or
     6575*	ends a do loop, and the statement number of the loop end of the
     6576*	do-loop that immediately contains the first executable reference
     6577*	to the label.  If we are asked to define an executable label that
     6578*	is branched to but which does not end a loop, we check that the
     6579*	loop which contained the first branch to the label is the same
     6580*	as or contained in the current loop.  If we are asked to reference
     6581*	a label in a DO statement, we check that the label has not yet
     6582*	been branched to.  If we are asked to reference a label that has
     6583*	already been defined, we check that it does not end a loop and
     6584*	that the loop containing the referencing statement is the same
     6585*	as or contained in the loop which contained the statement which
     6586*	defined the label.
     6587**/
     6588 
     6589 dcl      a_type bit (2) aligned;
     6590 dcl      a_usage bit (5) aligned;
     6591 dcl      a_value fixed bin (18);
     6592 dcl      actual_type bit (2) aligned;
     6593 dcl      current_loop_end fixed bin (18);
     6594 dcl      in_list bit (1) aligned;
     6595 dcl      indx fixed bin (18);
     6596 dcl      label_storage bit (5) aligned;
     6597 dcl      label_type bit (2) aligned;
     6598 dcl      label_value fixed bin (18);
     6599 dcl      last_item fixed bin (18);
     6600 dcl      loop_end fixed bin (18);
     6601 dcl      lp pointer;
     6602 
     6603 	label_type = a_type;
     6604 	label_value = a_value;
     6605 	label_storage = a_usage;
     6606 
     6607 	current_loop_end = 0;
     6608 	do indx = do_index to 1 by -1 while (current_loop_end = 0);
     6609 	     if do_blockif_stack (indx).do_loop then
     6610 		current_loop_end = do_blockif_stack (indx).label_ptr;
     6611 	end;
     6612 
     6613 	if label_value <= 0 | label_value > 99999 then do;
     6614 	     call print_message (69, char (decimal (label_value, 12)));
     6615 						/* label is illegal */
     6616 	     label_value = min (max_fixed_bin_18, abs (label_value));
     6617 	end;
     6618 
     6619 	last_item = mod (label_value, dim (label_hash_table, 1));
     6620 	indx = label_hash_table (last_item);
     6621 
     6622 	in_list = TRUE;
     6623 
     6624 	if indx > 0 then
     6625 	     do while (in_list);
     6626 		lp = addr (OS (indx));
     6627 		if lp -> label.name = label_value then
     6628 		     in_list = FALSE;
     6629 		else do;
     6630 		     last_item = indx;
     6631 		     indx = lp -> label.hash_chain;
     6632 		     if indx = 0 then
     6633 			in_list = FALSE;
     6634 		end;
     6635 	     end;
     6636 
     6637 	if indx = 0 then do;
     6638 	     indx = create_label (label_value, (label_type), (label_storage));
     6639 	     lp = addr (OS (indx));
     6640 
     6641 	     if last_item <= hbound (label_hash_table, 1) then
     6642 		label_hash_table (last_item) = indx;
     6643 	     else
     6644 		addr (OS (last_item)) -> label.hash_chain = indx;
     6645 
     6646 	     if produce_listing then
     6647 		call generate_cross_ref (indx);
     6648 
     6649 	     if label_type = format_label then do;
     6650 		if label_storage = SET then
     6651 		     label_storage = INIT;
     6652 
     6653 		indx = build_symbol ((NO_NAME), format_label_attributes, (label_storage));
     6654 		lp -> label.format_var = indx;
     6655 	     end;
     6656 
     6657 	     if label_type = executable_label & subr_options.ansi_77 then do;
     6658 		if substr (label_storage, 1, 3) = REF then
     6659 		     if statement_type = do_statement then
     6660 			lp -> label.ends_do_loop = TRUE;
     6661 		     else
     6662 			lp -> label.branched_to = TRUE;
     6663 		lp -> label.loop_end = current_loop_end;
     6664 	     end;
     6665 	     return (indx);
     6666 	end;
     6667 
     6668 	if produce_listing then
     6669 	     call generate_cross_ref (indx);
     6670 
     6671 	actual_type = string (lp -> label.usage);
     6672 
     6673 /* if label previous entered with no usage info, e.g. in an ASSIGN, and we now can determine its usage, update the info 
     6674*   on the other hand, if this is an assign and previous was not, make this label type be consistent with previous */
     6675 
     6676 	if actual_type = any_label & label_type ^= any_label then do;
     6677 	     actual_type = label_type;
     6678 	     string (lp -> label.usage) = label_type;
     6679 	end;
     6680 	else if label_type = any_label & actual_type ^= any_label then
     6681 	     label_type = actual_type;
     6682 
     6683 	if substr (label_storage, 1, 3) = SET then
     6684 	     if lp -> label.set then
     6685 		call print_message (70, indx);	/* label is multiply declared */
     6686 	     else if actual_type ^= label_type then
     6687 		call print_message (70 + binary (label_type, 2, 0));
     6688 						/* usage conflicts with stmnt type */
     6689 	     else if label_type = executable_label & subr_options.ansi_77 then
     6690 		if lp -> label.branched_to & ^lp -> label.ends_do_loop then do;
     6691 		     if current_loop_end ^= 0 then do;
     6692 			do loop_end = lp -> label.loop_end repeat addr (OS (loop_end)) -> label.loop_end
     6693 			     while (loop_end ^= current_loop_end & loop_end ^= 0);
     6694 			end;
     6695 			if loop_end ^= current_loop_end then
     6696 			     call print_message (190, indx, current_loop_end);
     6697 		     end;
     6698 		     lp -> label.loop_end = current_loop_end;
     6699 		end;
     6700 
     6701 	if substr (label_storage, 1, 3) = REF then
     6702 	     if label_type ^= actual_type then
     6703 		call print_message (73 + binary (label_type, 2, 0), indx);
     6704 						/* ref conflicts with previous */
     6705 	     else if label_type = executable_label & subr_options.ansi_77 then
     6706 		if lp -> label.set then do;		/* Label is already defined. */
     6707 		     if statement_type = do_statement then
     6708 			call print_message (70, indx);
     6709 		     else if lp -> label.ends_do_loop then
     6710 			call print_message (190, indx, indx);
     6711 		     else do;
     6712 			if lp -> label.loop_end ^= 0 then do;
     6713 			     do loop_end = current_loop_end repeat addr (OS (loop_end)) -> label.loop_end
     6714 				while (loop_end ^= lp -> label.loop_end & loop_end ^= 0);
     6715 			     end;
     6716 			     if loop_end ^= lp -> label.loop_end then
     6717 				call print_message (190, indx, fixed (lp -> label.loop_end, 18));
     6718 			end;
     6719 		     end;
     6720 
     6721 		end;
     6722 		else do;				/* Label is not yet defined. */
     6723 		     if statement_type = do_statement then do;
     6724 			if lp -> label.branched_to then
     6725 			     call print_message (190, indx, indx);
     6726 			if ^lp -> label.ends_do_loop then do;
     6727 			     lp -> label.ends_do_loop = TRUE;
     6728 			     lp -> label.loop_end = current_loop_end;
     6729 			end;
     6730 		     end;
     6731 		     else if ^lp -> label.branched_to then do;
     6732 			lp -> label.branched_to = TRUE;
     6733 			if ^lp -> label.ends_do_loop then
     6734 			     lp -> label.loop_end = current_loop_end;
     6735 		     end;
     6736 		end;
     6737 	string (lp -> label.storage_info) = string (lp -> label.storage_info) | label_storage;
     6738 
     6739 	if actual_type = format_label then do;
     6740 	     indx = lp -> label.format_var;
     6741 	     if indx = 0				/* no previous use in format context */
     6742 	     then do;
     6743 		indx = build_symbol ((NO_NAME), format_label_attributes, (label_storage));
     6744 		lp -> label.format_var = indx;
     6745 	     end;
     6746 	     if label_storage = SET then
     6747 		label_storage = INIT;
     6748 	     string (addr (OS (indx)) -> symbol.storage_info) =
     6749 		string (addr (OS (indx)) -> symbol.storage_info) | label_storage;
     6750 	end;
     6751 
     6752 	return (indx);
     6753      end enter_label;
     6754 
     6755 create_label:
     6756      procedure (label_name, label_usage, label_allocate_bits) returns (fixed bin (18));
     6757 
     6758 dcl      label_allocate_bits bit (5) aligned;
     6759 dcl      label_name fixed bin (18);
     6760 dcl      label_usage bit (2) aligned;
     6761 dcl      new_label fixed bin (18);
     6762 
     6763 	new_label = create_node (label_node, size (label));
     6764 
     6765 	addr (OS (new_label)) -> label.operand_type = rel_constant;
     6766 	addr (OS (new_label)) -> label.name = label_name;
     6767 	string (addr (OS (new_label)) -> label.usage) = label_usage;
     6768 	string (addr (OS (new_label)) -> label.storage_info) = label_allocate_bits;
     6769 
     6770 	if sub_ptr -> last_label = 0 then
     6771 	     sub_ptr -> first_label = new_label;
     6772 	else
     6773 	     addr (OS (sub_ptr -> last_label)) -> label.next_label = new_label;
     6774 	sub_ptr -> last_label = new_label;
     6775 	return (new_label);
     6776      end create_label;
     6777 
     6778 get_constant_offset:
     6779      procedure (sym, allow_variable_subscripts) returns (fixed bin (18));
     6780 
     6781 /*	Program Specifications (get_constant_offset)
     6782*
     6783*     Inputs
     6784*
     6785*     Output
     6786*
     6787*     Description - calculates a constant offset, in elements, from constant subscript expressions
     6788**/
     6789 
     6790 dcl      allow_variable_subscripts bit (1) aligned;
     6791 declare	ansi66_equivalence_statement bit (1) aligned;
     6792 dcl      count fixed bin (18);
     6793 declare	dim_size fixed binary (18);
     6794 dcl      dp pointer;
     6795 declare	error_code fixed binary (35);
     6796 dcl      in_list bit (1) aligned;
     6797 declare	lower fixed binary (18);
     6798 dcl      multiplier fixed bin (18);
     6799 dcl      no_dims fixed bin (18);
     6800 dcl      off fixed bin (18);
     6801 dcl      sym fixed bin (18);
     6802 dcl      sp pointer;
     6803 dcl      subs fixed bin (18);
     6804 dcl      upper fixed bin (18);
     6805 declare	value fixed binary (24);
     6806 declare	variable_sub bit (1);
     6807 
     6808 	sp = addr (OS (sym));
     6809 
     6810 	off = 0;					/* calculated offset */
     6811 	multiplier = 1;				/* Multiplier for current subscript */
     6812 	count = 0;				/* number of subscripts */
     6813 	ansi66_equivalence_statement = (statement_type = equivalence_statement) & ^subr_options.ansi_77;
     6814 
     6815 /* symbol must be dimensioned without variable bounds */
     6816 
     6817 	if ^sp -> symbol.dimensioned then do;
     6818 	     call print_message (76, sym);		/* symbol must have dimension attribute */
     6819 	     no_dims = 0;
     6820 	     multiplier = 0;			/* final offset should be zero */
     6821 	end;
     6822 	else do;
     6823 	     dp = addr (OS (sp -> symbol.dimension));
     6824 
     6825 	     if sp -> symbol.variable_extents then do;
     6826 		call print_message (77, sym);
     6827 		no_dims = 0;
     6828 		multiplier = 0;			/* final offset should be zero */
     6829 	     end;
     6830 	     else
     6831 		no_dims = dp -> dimension.number_of_dims;
     6832 	end;
     6833 
     6834 	in_list = TRUE;
     6835 	do while (in_list);
     6836 	     count = count + 1;
     6837 
     6838 	     call get_next_token (force_symtab_entry, subs);
     6839 
     6840 /* pick up lower and upper bounds; used for bound checking and to build the multiplier */
     6841 
     6842 	     if count <= no_dims then
     6843 		call get_bounds_and_size;
     6844 	     else
     6845 		upper, multiplier, lower = 0;		/* final offset will not include these subscripts */
     6846 
     6847 /* subscript can be integer or an identifier is allowed */
     6848 
     6849 	     const_index = subs;			/* save for err msg */
     6850 	     call get_integer_constant (subs, (allow_variable_subscripts), value, variable_sub, error_code);
     6851 	     if error_code ^= 0 then do;		/* illegal expression in constant or variable */
     6852 		call print_message (24, "the invalid expression");
     6853 		goto statement_parse_abort;
     6854 	     end;
     6855 
     6856 	     else if ^variable_sub then do;		/* check that constant subscript within bounds */
     6857 
     6858 		if value < lower then do;
     6859 		     if count <= no_dims & ^ansi66_equivalence_statement then do;
     6860 			call print_message (78, const_index, "lower", sym);
     6861 			value, off, multiplier = 0;
     6862 		     end;
     6863 		end;
     6864 
     6865 		if value > upper then do;
     6866 		     if count <= no_dims & ^ansi66_equivalence_statement then do;
     6867 			call print_message (78, const_index, "upper", sym);
     6868 						/* subscript exceeds upper bound */
     6869 			value, off, multiplier = 0;	/* final offset will be zero */
     6870 		     end;
     6871 		end;
     6872 
     6873 		off = off + (value - lower) * multiplier;
     6874 						/* accumulate constant offset */
     6875 	     end;
     6876 	     else do;				/* subscript can be a variable in some contexts */
     6877 
     6878 		subs_list (0) = no_dims;		/* inexpensive way to tell caller there are subscripts */
     6879 		if count <= no_dims then
     6880 		     subs_list (count) = const_index;
     6881 	     end;
     6882 
     6883 	     multiplier = multiplier * dim_size;	/* multiplier gets bigger */
     6884 
     6885 
     6886 	     if token ^= comma then
     6887 		in_list = FALSE;
     6888 	end;
     6889 
     6890 	if token ^= right_parn then
     6891 	     go to missing_right_paren;
     6892 	call get_next_token$paren_operator;		/* next token must be an operator or a substr_left_parn */
     6893 
     6894 	if no_dims ^= 0				/* check subscript count for valid refs */
     6895 	then do;
     6896 	     if ansi66_equivalence_statement then do;
     6897 		if count ^= 1 & count ^= no_dims then
     6898 		     call print_message (79, sym, "the wrong number of");
     6899 		else
     6900 		     do count = count + 1 to no_dims;
     6901 			call get_bounds_and_size;
     6902 			multiplier = multiplier * dim_size;
     6903 		     end;
     6904 		if multiplier < off then
     6905 		     call print_message (422, off + 1 - bias, sym);
     6906 	     end;
     6907 	     else if count ^= no_dims then
     6908 		call print_message (79, sym, "the wrong number of");
     6909 	end;
     6910 	return (off);
     6911 
     6912 get_bounds_and_size:
     6913      procedure;
     6914 	upper = dp -> dimension.dim.upper_bound (count);
     6915 	lower = dp -> dimension.dim.lower_bound (count);
     6916 	dim_size = dp -> dimension.dim.size (count);
     6917      end get_bounds_and_size;
     6918 
     6919      end get_constant_offset;
     6920 
     6921 get_char_length:
     6922      procedure (action, sym_index) returns (fixed bin (18));
     6923 
     6924 dcl      action fixed bin (2);
     6925 dcl      sym_index fixed bin (18);
     6926 dcl      symp pointer;
     6927 
     6928 	symp = addr (OS (sym_index));
     6929 	if ^symp -> symbol.star_extents then do;
     6930 	     addr (work) -> based_integer = symp -> symbol.char_size + 1;
     6931 	     return (create_constant (int_mode, work));
     6932 	end;
     6933 	else if symp -> symbol.v_length ^= 0 then
     6934 	     return (symp -> symbol.v_length);
     6935 	else if action = force_symtab_entry then do;
     6936 	     symp -> symbol.v_length = build_symbol ((NO_NAME), v_length_attributes, SET);
     6937 	     addr (OS (symp -> symbol.v_length)) -> symbol.data_type = int_mode;
     6938 	     addr (OS (symp -> symbol.v_length)) -> symbol.element_size = 1;
     6939 	     return (symp -> symbol.v_length);
     6940 	end;
     6941 	else
     6942 	     return (0);
     6943      end;
     6944 
     6945 get_data_statement_expression:
     6946      proc;
     6947 
     6948 /* Parse an expression.  Check that its operands are all integer constants
     6949*   or implied do-loop indices.  Check that its operators are only '+', '-',
     6950*   '*', '/' and '**'.  If the expression is valid, stack its size and Polish;
     6951*   otherwise, stack 0 (i.e. a zero-length expression) to indicate it was
     6952*   invalid.  To save time later on during expression interpretation, we
     6953*   replace the node address of each implied do-loop index by the negative
     6954*   of the index of the stack element which will hold the current value of
     6955*   the loop index during interpretation. */
     6956 
     6957 dcl      INVALID_CONSTANT fixed bin static options (constant) init (1),
     6958          INVALID_OPERATOR fixed bin static options (constant) init (2),
     6959          INVALID_SYMBOL fixed bin static options (constant) init (3);
     6960 
     6961 dcl      do_idx fixed bin,
     6962          indx fixed bin (18),
     6963          op fixed bin (18),
     6964          opnd_ptr ptr,
     6965          polish_idx fixed bin (18),
     6966          start_of_polish fixed bin (18),
     6967          status fixed bin (35);
     6968 
     6969 	start_of_polish = next_free_polish;
     6970 	call get_next_token (force_symtab_entry, indx);
     6971 	call parse_expression (set_no_symbol_bits, indx, out);
     6972 	status = 0;
     6973 	do polish_idx = start_of_polish to next_free_polish - 1 while (status = 0);
     6974 	     op = polish_string (polish_idx);
     6975 	     if op > last_assigned_op then do;
     6976 		opnd_ptr = addr (OS (op));
     6977 		if opnd_ptr -> node.node_type = constant_node then do;
     6978 		     if opnd_ptr -> constant.data_type ^= int_mode then
     6979 			status = INVALID_CONSTANT;
     6980 		end;
     6981 		else if opnd_ptr -> node.node_type = symbol_node then do;
     6982 		     do do_idx = 1 to do_level while (op ^= stack (do_info (do_idx)));
     6983 		     end;
     6984 		     if do_idx <= do_level then
     6985 			polish_string (polish_idx) = -do_info (do_idx);
     6986 		     else
     6987 			status = INVALID_SYMBOL;
     6988 		end;
     6989 		else
     6990 		     status = INVALID_CONSTANT;
     6991 	     end;
     6992 	     else if op < add_op | op > negate_op then
     6993 		status = INVALID_OPERATOR;
     6994 	end;
     6995 	if status = 0 then
     6996 	     if next_free_polish > start_of_polish + 1 & ^addr (out) -> expression.not_constant then do;
     6997 						/* Replace constant expression by its value. */
     6998 		parameter_info.desired_data_type = int_mode;
     6999 		parameter_info.rounding = subr_options.do_rounding;
     7000 		parameter_info.start_of_polish = start_of_polish;
     7001 		parameter_info.end_of_polish = next_free_polish;
     7002 		parameter_info.stack_index = stack_index;
     7003 		parameter_info.max_stack = max_stack;
     7004 		call fort_eval_parm (addr (parameter_info), "an integer constant expression", status);
     7005 		max_stack = parameter_info.max_stack;
     7006 		if status = 0 then do;
     7007 		     polish_string (start_of_polish) = parameter_info.result_location;
     7008 		     next_free_polish = start_of_polish + 1;
     7009 		end;
     7010 	     end;
     7011 	if status ^= 0 then do;
     7012 	     if status = INVALID_CONSTANT then
     7013 		call print_message (24, op);
     7014 	     else if status = INVALID_OPERATOR then
     7015 		call print_message (175, "an integer expression");
     7016 	     else if status = INVALID_SYMBOL then
     7017 		call print_message (135, op);
     7018 	     next_free_polish = start_of_polish;
     7019 	end;
     7020 	call stack_operand (next_free_polish - start_of_polish);
     7021 	do polish_idx = start_of_polish to next_free_polish - 1;
     7022 	     op = polish_string (polish_idx);
     7023 	     if op < 1 | op > last_assigned_op then
     7024 		call stack_operand (op);
     7025 	     else
     7026 		call stack_operator (op);
     7027 	end;
     7028 	next_free_polish = start_of_polish;
     7029      end get_data_statement_expression;
     7030 
     7031 parse_parameter_list:
     7032      procedure (entry_point_name);			/* Not Audited. */
     7033 
     7034 /*	Program Specifications (parse_parameter_list)
     7035*
     7036*     Inputs
     7037*
     7038*     Output
     7039*
     7040*     Description - parses parameter list for subroutine, function, and entry statements.
     7041**/
     7042 dcl      adesc fixed binary (18);
     7043 dcl      alternate_return bit (1) aligned;
     7044 dcl      ap pointer;
     7045 dcl      entry_point_name fixed bin (18);
     7046 dcl      ep_name fixed bin (18);
     7047 dcl      saved_stack_index fixed binary (18);
     7048 
     7049 	ep_name = entry_point_name;
     7050 
     7051 	if declare_symbol (ep_name, subprogram_attributes, subprogram_conflicts, SET) then
     7052 	     addr (OS (ep_name)) -> symbol.parent = cur_subprogram;
     7053 						/* link entry point to block */
     7054 	else
     7055 	     call print_message (127, ep_name);
     7056 
     7057 /* parse parameter list */
     7058 
     7059 	call get_next_token$operator;			/* get left paren or eos */
     7060 
     7061 	count = 0;
     7062 	num_args = 0;
     7063 	saved_stack_index = stack_index;
     7064 	alternate_return = FALSE;			/* param list does not contain alt ret param */
     7065 
     7066 	if token = left_parn then do;
     7067 	     in_list = (token_list (current_token + 1).type ^= right_parn);
     7068 
     7069 /* an empty parameter list is just a left and right paren and needs no further analysis */
     7070 
     7071 	     if in_list then
     7072 		sub_ptr -> subprogram.has_parameters = TRUE;
     7073 	     else
     7074 		call get_next_token$operator;
     7075 
     7076 	     do while (in_list);			/* loop thru parameters */
     7077 
     7078 		call get_next_token (force_symtab_entry, indx);
     7079 
     7080 /* parameter must be name or * */
     7081 
     7082 		if token = ident then do;
     7083 		     count = count + 1;
     7084 
     7085 		     if ^declare_symbol (indx, param_attr, param_conflicts, DECLARED) then
     7086 			call print_message (30, "parameter", indx);
     7087 		     else
     7088 			call check_param_position (indx);
     7089 						/* check for different position */
     7090 
     7091 		     call stack_operand (indx);	/* save indx for arg_desc  */
     7092 		end;
     7093 
     7094 		else if token = asterisk & subprogram_op = subr_op then do;
     7095 		     alternate_return = TRUE;
     7096 		     call stack_operand (0);		/* tell we're  not a symbol   */
     7097 		end;
     7098 
     7099 		else
     7100 		     go to missing_identifier;
     7101 
     7102 		num_args = num_args + 1;
     7103 		call get_next_token$operator;		/* get comma or right paren */
     7104 		if token ^= comma then
     7105 		     in_list = FALSE;
     7106 
     7107 	     end;
     7108 
     7109 	     if token ^= right_parn then
     7110 		go to missing_right_paren;
     7111 
     7112 	     current_token = current_token + 1;		/* skip over right paren */
     7113 	end;
     7114 
     7115 /* entry and subroutine statements don't require the parens for a null list, but all function statements do */
     7116 
     7117 	else if statement_type >= function_statement & statement_type < after_subprogram then
     7118 	     goto missing_left_paren;
     7119 
     7120 /* for functions, the return value must be added to the parameter list */
     7121 
     7122 	if subprogram_op = func_op then do;
     7123 	     count = count + 1;
     7124 
     7125 	     call check_param_position (return_value_param);
     7126 						/* check for different position */
     7127 
     7128 	end;
     7129 
     7130 /* for subroutines with label value parameters, alt ret value must be added to param list */
     7131 
     7132 	else if alternate_return then do;
     7133 	     count = count + 1;
     7134 
     7135 	     if return_value_param = 0		/* first ref so create it */
     7136 		then
     7137 		return_value_param = build_symbol ((NO_NAME), param_variable_attrs | attr_table (int_mode), REF);
     7138 
     7139 	     call check_param_position (return_value_param);
     7140 						/* otherwise check for different position */
     7141 
     7142 	end;
     7143 
     7144 /* create  an arg_desc node for the parameter-list and fill it in with the
     7145*   info placed in the stack - then reset the stack_index */
     7146 
     7147 	adesc = create_node (arg_desc_node, size (arg_desc));
     7148 	ap = addr (OS (adesc));
     7149 	ap -> arg_desc.n_args = num_args;
     7150 
     7151 	do i = 1 to num_args;
     7152 	     ap -> arg_desc.symbol (i) = stack (saved_stack_index + i - 1);
     7153 	end;
     7154 
     7155 
     7156 /* Check if too many parameters.  Warn if so. */
     7157 
     7158 	if num_args > max_arglist then
     7159 	     call print_message (189, max_arglist - bias);
     7160 
     7161 	addr (OS (ep_name)) -> symbol.general = adesc;
     7162 	stack_index = saved_stack_index;
     7163 
     7164 /* Add this entry to the list of pending entries. */
     7165 
     7166 	if pending_entry_cnt < hbound (pending_entry, 1) then do;
     7167 	     pending_entry_cnt = pending_entry_cnt + 1;
     7168 	     pending_entry (pending_entry_cnt).entry_symbol = ep_name;
     7169 	     pending_entry (pending_entry_cnt).entry_stmnt = unspec (cur_stmnt_ptr -> statement);
     7170 	end;
     7171 	else
     7172 	     call print_message (67, "pending_entry", char (hbound (pending_entry, 1)));
     7173 
     7174 	return;
     7175 
     7176 check_param_position:
     7177      procedure (formal_parameter);
     7178 
     7179 dcl      formal_parameter fixed bin (18);
     7180 
     7181 	if addr (OS (formal_parameter)) -> symbol.location ^= 0 then
     7182 	     if addr (OS (formal_parameter)) -> symbol.location ^= count then
     7183 		if addr (OS (formal_parameter)) -> symbol.general ^= ep_name then
     7184 		     addr (OS (formal_parameter)) -> symbol.stack_indirect = TRUE;
     7185 		else
     7186 		     call print_message (39, formal_parameter);
     7187 
     7188 	addr (OS (formal_parameter)) -> symbol.location = count;
     7189 	addr (OS (formal_parameter)) -> symbol.general = ep_name;
     7190      end check_param_position;
     7191      end parse_parameter_list;
     7192 
     7193 parse_data:
     7194      procedure;					/* Not Audited. */
     7195 
     7196 /*	Program Specifications (parse_data)
     7197*
     7198*     Inputs
     7199*
     7200*     Output
     7201*
     7202*     Description (parse_data)
     7203*
     7204*Parses the constant list and generates "initial value nodes" to represent the required initiation.
     7205*These are not true nodes because they are allocated in the polish string. Each node requires three
     7206*halfwords that are used as follows:
     7207*
     7208*	+0	pointer to next node (Also used to chain free "nodes")
     7209*	+1	repetition count for this value
     7210*	+2	pointer to operand table node for constant or has the value "gap_value"
     7211*
     7212*
     7213*     Initial values for arrays (and variables) are stored in a chained list
     7214*in the order of the array elements. This method prevents multiple initial values
     7215*for a given element and allows the storage allocator to make a single pass to
     7216*generate initial value templates.
     7217*
     7218*     The initial attribute is assigned to the symbol only if a non-zero value
     7219*is given as an initial value.
     7220*
     7221*
     7222*     This parser is driven by information stored by either a data statement parser or a mode
     7223*statement parser. The information stored includes implied do loop control information as well as
     7224*variables, array element names, or array vectors. See the description under the data statement
     7225*parse for a complete description of how the information is encoded.
     7226**/
     7227 
     7228 dcl      c_count fixed bin (18);
     7229 dcl      c_dt fixed bin (4);
     7230 dcl      char_count fixed bin (18);
     7231 dcl      char_len fixed bin (18);
     7232 dcl      char_var_length fixed bin (10);
     7233 dcl      char_var_value char (char_var_length) based (addr (char_temp));
     7234 dcl      cv_ptr pointer;
     7235 dcl      conv_error fixed bin (35);
     7236 dcl      const fixed bin (18);
     7237 dcl      current_spec fixed bin (18);
     7238 declare	current_value fixed binary (18);
     7239 dcl      data_error bit (1) aligned;
     7240 declare	dim_size fixed bin (18);
     7241 dcl      dp pointer;
     7242 dcl      el_ct fixed bin (18);
     7243 dcl      final_expression_idx fixed bin (18);
     7244 declare	final_value fixed binary (18);
     7245 dcl      have_constant_subscripts bit (1) aligned;
     7246 dcl      i fixed bin (18);
     7247 dcl      in_list bit (1) aligned;
     7248 dcl      increment_expression_idx fixed bin (18);
     7249 declare	increment_value fixed binary (18);
     7250 dcl      indx fixed bin (18);
     7251 dcl      initial_expression_idx fixed bin (18);
     7252 dcl      interval fixed bin (18);
     7253 dcl      interval_ptr fixed bin (18);
     7254 dcl      j fixed bin (18);
     7255 dcl      last fixed bin (18);
     7256 declare	loop_info fixed binary (18);
     7257 declare	lower fixed bin (18);
     7258 dcl      multiplier fixed bin (18);
     7259 dcl      non_zero_value bit (5) aligned;
     7260 dcl      octal_value bit (72) aligned;
     7261 dcl      off fixed bin (18);
     7262 dcl      partial_offset fixed bin (18);
     7263 dcl      substr_finish fixed bin (10);
     7264 dcl      substr_length fixed bin (10);
     7265 dcl      substr_start fixed bin (10);
     7266 dcl      t_ct fixed bin (18);
     7267 dcl      target fixed bin (18);
     7268 dcl      upper fixed bin (18);
     7269 dcl      v_dt fixed bin (4);
     7270 dcl      v_count fixed bin (18);
     7271 
     7272 
     7273 	from_data_parser = TRUE;			/* To suppress msgs in get_next_token */
     7274 	c_count = 0;				/* number of constants parsed and as yet unused */
     7275 	token = comma;				/* token is actually a slash; this for loop */
     7276 	do_level = 0;				/* no do loops encountered. */
     7277 
     7278 /* loop thru information stored on the stack */
     7279 
     7280 	current_spec = stack_base;			/* beginning of the list */
     7281 	do while (current_spec < stack_index);
     7282 
     7283 /* pick up all do loops that start with this variable */
     7284 
     7285 	     do while (stack (current_spec) = BEGIN_DO_LOOP);
     7286 		if do_level = hbound (do_info, 1) then do;
     7287 		     call print_message (89, hbound (do_info, 1) - bias);
     7288 						/* too deeply nested */
     7289 		     go to statement_parse_abort;
     7290 		end;
     7291 
     7292 		do_level = do_level + 1;
     7293 		do_info (do_level) = current_spec;	/* remember where loop starts */
     7294 		initial_expression_idx = current_spec + INITIAL_EXPRESSION;
     7295 		stack (current_spec + CURRENT_VALUE) = value (initial_expression_idx);
     7296 
     7297 /* skip over do loop parameters */
     7298 		final_expression_idx = initial_expression_idx + stack (initial_expression_idx) + 1;
     7299 		increment_expression_idx = final_expression_idx + stack (final_expression_idx) + 1;
     7300 		current_spec = increment_expression_idx + stack (increment_expression_idx) + 1;
     7301 	     end /* current_spec = BEGIN_DO_LOOP */;
     7302 
     7303 /* get the next item from the list, either subscripted or not */
     7304 
     7305 	     target = stack (current_spec);
     7306 
     7307 	     if target > 0				/* array name or scalar variable */
     7308 	     then do;
     7309 		indx = target;
     7310 		current_spec = current_spec + 1;
     7311 		if addr (OS (indx)) -> symbol.dimensioned then do;
     7312 		     v_count = addr (OS (addr (OS (indx)) -> symbol.dimension)) -> dimension.element_count;
     7313 		     if v_count = 0 then
     7314 			call print_message (77, indx);/* symbol must have constant extents */
     7315 		end;
     7316 		else
     7317 		     v_count = 1;
     7318 		off = 0;
     7319 		have_constant_subscripts = FALSE;
     7320 	     end /* array_name or scalar var */;
     7321 
     7322 	     else if target = SUBSTR | target = SUBSCRIPTED_VAR | target = SUBSCRIPTED_SUBSTR then do;
     7323 		indx = stack (current_spec + SYMBOL_INDEX);
     7324 		off = 0;
     7325 		v_count = 1;
     7326 		current_spec = current_spec + 2;
     7327 		if target = SUBSTR then
     7328 		     have_constant_subscripts = FALSE;
     7329 		else do;
     7330 		     have_constant_subscripts = TRUE;	/* Assume all subscripts are constant. */
     7331 
     7332 		     dp = addr (OS (addr (OS (indx)) -> symbol.dimension));
     7333 						/* dimension node for symbol */
     7334 		     multiplier = 1;		/* used to calculate offset */
     7335 
     7336 		     do i = 1 to dp -> dimension.number_of_dims;
     7337 
     7338 /* find and process subscripts */
     7339 			upper = dp -> dimension.dim.upper_bound (i);
     7340 			lower = dp -> dimension.dim.lower_bound (i);
     7341 			dim_size = dp -> dimension.dim.size (i);
     7342 
     7343 			if stack (current_spec) ^= 1 | stack (current_spec + 1) < 0 then
     7344 			     have_constant_subscripts = FALSE;
     7345 						/* At least one subscript is not constant. */
     7346 			j = value (current_spec);
     7347 			if j > upper then do;
     7348 			     call print_message (78, j - bias, "upper", indx);
     7349 						/* value exceeds upper bound */
     7350 			     j = upper;
     7351 			end;
     7352 			else if j < lower then do;
     7353 			     call print_message (78, j - bias, "lower", indx);
     7354 			     j = lower;
     7355 			end;
     7356 
     7357 			off = off + (j - lower) * multiplier;
     7358 						/* add subscript to offset */
     7359 			multiplier = multiplier * dim_size;
     7360 			current_spec = current_spec + stack (current_spec) + 1;
     7361 						/* skip over this subscript */
     7362 		     end;
     7363 		end;
     7364 
     7365 		if target = SUBSTR | target = SUBSCRIPTED_SUBSTR then do;
     7366 						/* Extract start and finish positions. */
     7367 		     char_var_length = addr (OS (indx)) -> symbol.char_size + 1;
     7368 		     substr_start = value (current_spec);
     7369 		     current_spec = current_spec + stack (current_spec) + 1;
     7370 		     if substr_start < 1 then do;
     7371 			call print_message (155, indx, "start < 1");
     7372 			substr_start = 1;
     7373 		     end;
     7374 		     else if substr_start > char_var_length then do;
     7375 			call print_message (155, indx, "start > length");
     7376 			substr_start = char_var_length;
     7377 		     end;
     7378 		     substr_finish = value (current_spec);
     7379 		     current_spec = current_spec + stack (current_spec) + 1;
     7380 		     if substr_finish < substr_start then do;
     7381 			call print_message (155, indx, "finish < start");
     7382 			substr_finish = substr_start;
     7383 		     end;
     7384 		     else if substr_finish > char_var_length then do;
     7385 			call print_message (155, indx, "finish > length");
     7386 			substr_finish = char_var_length;
     7387 		     end;
     7388 		     substr_length = substr_finish - substr_start + 1;
     7389 		end;
     7390 	     end;
     7391 
     7392 	     else do;				/* It had better be SKIP. */
     7393 		have_constant_subscripts = FALSE;
     7394 		indx = 0;
     7395 		off = 0;
     7396 		v_count = 1;
     7397 		current_spec = current_spec + 1;
     7398 	     end;
     7399 
     7400 /* insure variable can acquire the initial attribute */
     7401 
     7402 	     if indx = 0 then do;
     7403 		v_dt = 0;
     7404 		data_error = TRUE;
     7405 	     end;
     7406 	     else if ^declare_symbol (indx, variable_attributes, equiv_conflicts, DECLARED) then do;
     7407 		call print_message (126, indx);
     7408 		v_dt = 0;
     7409 		data_error = TRUE;
     7410 	     end;
     7411 	     else do;
     7412 		call set_data_fields (indx);
     7413 		v_dt = addr (OS (indx)) -> symbol.data_type;
     7414 						/* copy data type */
     7415 		data_error = FALSE;
     7416 	     end;
     7417 
     7418 /* Common is initialed in block data only. Allocate bit is set only if in block data. */
     7419 
     7420 	     if indx = 0 then
     7421 		non_zero_value = DECLARED;
     7422 	     else if addr (OS (indx)) -> symbol.in_common then
     7423 		if sub_ptr -> subprogram_type = block_data then
     7424 		     if addr (OS (addr (OS (indx)) -> symbol.parent)) -> header.block_name = blank_common_name
     7425 		     then do;
     7426 			call print_message (128, indx);
     7427 						/* a member of blank common */
     7428 			data_error = TRUE;
     7429 			non_zero_value = DECLARED;
     7430 		     end;
     7431 		     else
     7432 			non_zero_value = REF;	/* member of common in block data */
     7433 		else do;
     7434 		     call print_message (80, indx);	/* cannot initial common block */
     7435 		     data_error = TRUE;
     7436 		     non_zero_value = DECLARED;
     7437 		end;
     7438 	     else if sub_ptr -> subprogram_type = block_data then
     7439 		if addr (OS (indx)) -> symbol.equivalenced then
     7440 		     non_zero_value = REF;
     7441 		else
     7442 		     non_zero_value = DECLARED;
     7443 	     else
     7444 		non_zero_value = DECLARED;
     7445 
     7446 /* If the offset > 0, then the correct element position must be found. */
     7447 
     7448 	     partial_offset = off;			/* copy offset */
     7449 	     last = -indx;				/* indicates that there is no previous interval */
     7450 	     interval = 0;				/* number of elements in interval being redefined */
     7451 	     current_value = gap_value;		/* indicates there is no current value */
     7452 
     7453 	     in_list = TRUE;
     7454 	     if indx = 0 then
     7455 		interval_ptr = 0;
     7456 	     else
     7457 		interval_ptr = addr (OS (indx)) -> symbol.initial;
     7458 	     do while (in_list & interval_ptr ^= 0);
     7459 
     7460 		interval = polish_string (interval_ptr + 1);
     7461 						/* number of elements */
     7462 
     7463 		if partial_offset < interval		/* initialization will redefine an existing interval */
     7464 		then do;
     7465 		     in_list = FALSE;
     7466 		     interval = interval - partial_offset;
     7467 						/* number of elements preceding new value */
     7468 
     7469 /* interval being redefined must be empty and its length >= number of new values */
     7470 
     7471 		     current_value = polish_string (interval_ptr + 2);
     7472 		     if current_value ^= gap_value then
     7473 			if target = SUBSTR | target = SUBSCRIPTED_SUBSTR then do;
     7474 			     if unspec (
     7475 				substr (addr (OS (current_value)) -> char_constant.value, substr_start,
     7476 				substr_length)) ^= ""b then do;
     7477 				call print_message (81, indx);
     7478 				data_error = TRUE;
     7479 			     end;
     7480 			end;
     7481 			else do;
     7482 			     call print_message (81, indx);
     7483 						/* redefining an element */
     7484 			     data_error = TRUE;
     7485 			end;
     7486 
     7487 		     if polish_string (interval_ptr) ^= 0 & v_count > interval
     7488 						/* check length, if required */
     7489 		     then do;
     7490 			call print_message (81, indx);/* redefining an element */
     7491 			data_error = TRUE;
     7492 		     end;
     7493 		end;
     7494 
     7495 /* not on this interval, get the next one */
     7496 
     7497 		else do;
     7498 		     partial_offset = partial_offset - interval;
     7499 						/* reduce offset by width of this interval */
     7500 		     interval = 0;			/* no current interval */
     7501 		     last = interval_ptr;		/* remember this interval */
     7502 		     interval_ptr = polish_string (interval_ptr);
     7503 						/* get next interval or end of list */
     7504 		end;
     7505 	     end;
     7506 
     7507 /* if the new element is in the middle of an interval, filler is required for preceding elements */
     7508 
     7509 	     if partial_offset > 0 then
     7510 		call store_value (partial_offset, (current_value));
     7511 
     7512 /* loop thru all the elements being initialized for this reference */
     7513 
     7514 	     do while (v_count > 0);
     7515 
     7516 /* if there are no left over constants, parse another one */
     7517 
     7518 		if c_count = 0 then do;
     7519 		     if token ^= comma then
     7520 			if token ^= slash then
     7521 			     go to missing_comma;
     7522 			else do;
     7523 			     call print_message (82); /* fewer constants than variables */
     7524 			     call get_next_token (ignore_symtab_entry, ignore_value);
     7525 			     stack_index = stack_base;
     7526 			     return;
     7527 			end;
     7528 
     7529 		     call get_next_token (locate_symtab_entry, const);
     7530 
     7531 		     c_count = 1;
     7532 		     if token = dec_int then
     7533 			if token_list (current_token + 1).type = asterisk then do;
     7534 			     c_count = addr (work) -> based_integer;
     7535 			     if c_count <= 0 then do;
     7536 				call print_message (24, const);
     7537 						/* count must be positive */
     7538 				c_count = 1;
     7539 			     end;
     7540 
     7541 			     current_token = current_token + 1;
     7542 						/* skip over the asterisk */
     7543 			     call get_next_token (locate_symtab_entry, const);
     7544 			end;
     7545 
     7546 		     call parse_a_constant (TRUE, const, octal_value);
     7547 						/* TRUE= allow octal */
     7548 
     7549 		     if const = 0 then
     7550 			c_dt = 0;			/* octal constants have no data type */
     7551 		     else do;
     7552 			c_dt = addr (OS (const)) -> constant.data_type;
     7553 			if c_dt ^= char_mode then
     7554 			     cv_ptr = addr (addr (OS (const)) -> constant.value);
     7555 		     end;
     7556 
     7557 		     call get_next_token$operator;	/* get comma or slash */
     7558 		end;				/* loop to parse a constant and replication factor */
     7559 
     7560 		el_ct = min (v_count, c_count);	/* only use what is available */
     7561 
     7562 /* Now store the initial value, converting to target data type if required. */
     7563 
     7564 		if v_dt > 0			/* zero if variable cannot take an initial value */
     7565 		then do;
     7566 
     7567 		     if v_dt > char_mode then
     7568 			go to conversion_error;	/* weird mode for variable */
     7569 
     7570 		     if c_dt > char_mode then
     7571 			go to conversion_error;	/* weird mode for constant */
     7572 
     7573 		     go to convert_initial (v_dt * (char_mode + 1) - char_mode + c_dt);
     7574 
     7575 convert_initial (42):				/* character = character */
     7576 		     char_var_length = addr (OS (indx)) -> symbol.char_size + 1;
     7577 		     if target = SUBSTR | target = SUBSCRIPTED_SUBSTR then do;
     7578 			if current_value = gap_value then
     7579 			     unspec (char_var_value) = ""b;
     7580 			else
     7581 			     char_var_value = addr (OS (current_value)) -> char_constant.value;
     7582 			if addr (OS (const)) -> char_constant.length > substr_length then do;
     7583 			     call print_message (139, indx, substr_length - bias);
     7584 			     substr (char_var_value, substr_start, substr_length) =
     7585 				substr (addr (OS (const)) -> char_constant.value, 1, substr_length);
     7586 			end;
     7587 			else
     7588 			     substr (char_var_value, substr_start, substr_length) =
     7589 				addr (OS (const)) -> char_constant.value;
     7590 			call store_value (el_ct, create_char_constant (char_var_value));
     7591 		     end;
     7592 		     else if addr (OS (const)) -> char_constant.length < char_var_length then do;
     7593 						/*  Too short: Create constant of required size.  */
     7594 			char_var_value = addr (OS (const)) -> char_constant.value;
     7595 			call store_value (el_ct, create_char_constant (char_var_value));
     7596 		     end;
     7597 		     else do;			/*  Long enough:  Use as much as needed.  */
     7598 			if addr (OS (const)) -> char_constant.length > char_var_length then
     7599 			     call print_message (139, indx, char_var_length - bias);
     7600 			call store_value (el_ct, (const));
     7601 		     end;
     7602 		     goto reduce_counts;
     7603 
     7604 convert_initial (2):				/* integer = integer */
     7605 convert_initial (10):				/* real = real */
     7606 convert_initial (18):				/* double precision = double precision */
     7607 convert_initial (26):				/* complex = complex */
     7608 convert_initial (34):				/* logical = logical */
     7609 		     call store_value (el_ct, (const)); /* store without conversion */
     7610 		     go to reduce_counts;
     7611 
     7612 
     7613 convert_initial (6):				/* integer = logical */
     7614 convert_initial (13):				/* real = logical */
     7615 convert_initial (20):				/* double precision = logical */
     7616 convert_initial (27):				/* complex = logical */
     7617 convert_initial (29):				/* logical = octal constant */
     7618 convert_initial (30):				/* logical = integer */
     7619 convert_initial (31):				/* logical = real */
     7620 convert_initial (32):				/* logical = double precision */
     7621 convert_initial (33):				/* logical = complex */
     7622 convert_initial (36):				/* character = octal constant */
     7623 convert_initial (37):				/* character = integer */
     7624 convert_initial (38):				/* character = real */
     7625 convert_initial (39):				/* character = double precision */
     7626 convert_initial (40):				/* character = complex */
     7627 convert_initial (41):				/* character = logical */
     7628 conversion_error:
     7629 		     call print_message (83, const, indx);
     7630 		     call store_value (el_ct, gap_value);
     7631 						/* prevents reinitialization of these elements */
     7632 		     go to reduce_counts;
     7633 
     7634 
     7635 convert_initial (14):				/* real by character */
     7636 convert_initial (21):				/* double precision by character */
     7637 convert_initial (28):				/* complex by character */
     7638 convert_initial (35):				/* logical by character */
     7639 convert_initial (7):				/* integer = character */
     7640 						/* An entire array may be set using a single constant if the first element is specified. */
     7641 		     char_len = chars_per_word * data_type_size (v_dt);
     7642 						/* characters per element */
     7643 		     char_count = addr (OS (const)) -> char_constant.length;
     7644 
     7645 		     if off = 0 & have_constant_subscripts & el_ct = 1 & do_level = 0 then do;
     7646 			t_ct = divide (char_count + char_len - 1, char_len, 17, 0);
     7647 
     7648 			if t_ct > addr (OS (addr (OS (indx)) -> symbol.dimension)) -> dimension.element_count
     7649 			     & ^data_error then do;
     7650 			     t_ct = addr (OS (addr (OS (indx)) -> symbol.dimension)) -> dimension.element_count;
     7651 			     call print_message (139, indx, t_ct * char_len - bias);
     7652 			end;
     7653 
     7654 			if interval_ptr ^= 0 & polish_string (interval_ptr) ^= 0 & t_ct > interval then do;
     7655 						/* Attempt to reinitialize an element. */
     7656 			     call print_message (81, indx);
     7657 			     t_ct = interval;
     7658 			end;
     7659 
     7660 			do j = 1 to (t_ct - 1) * char_len by char_len;
     7661 						/* Store all but last value. */
     7662 			     substr (addr (work) -> based_char, 1, char_len) =
     7663 				substr (addr (OS (const)) -> char_constant.value, j, char_len);
     7664 			     call store_value (1, create_constant (v_dt, work));
     7665 			end;
     7666 
     7667 			char_count = char_count - j + 1;
     7668 						/* number of chars remaining */
     7669 		     end;
     7670 		     else
     7671 			j = 1;
     7672 
     7673 		     if char_count > char_len then
     7674 			call print_message (139, indx, char_len - bias);
     7675 						/* more chars than will fit */
     7676 
     7677 		     substr (addr (work) -> based_char, 1, char_len) /* common code assigns last (or only) word. */ =
     7678 			substr (addr (OS (const)) -> char_constant.value, j, char_count);
     7679 		     go to converted;
     7680 
     7681 convert_initial (1):				/* integer = octal constant */
     7682 convert_initial (8):				/* real = octal constant */
     7683 		     addr (work) -> based_bit_72 = substr (octal_value, 37, 36);
     7684 		     go to converted;
     7685 
     7686 convert_initial (3):				/* integer = real */
     7687 convert_initial (5):				/* integer = complex */
     7688 		     conv_error = 0;
     7689 		     unspec (addr (work) -> based_integer) =
     7690 			conv_round (int_mode, real_mode) ((unspec (cv_ptr -> based_real (1))), conv_error);
     7691 		     if conv_error < 0		/* number is too large to be an integer */
     7692 			then
     7693 			call print_message (119, const);
     7694 		     goto converted;
     7695 
     7696 convert_initial (4):				/* integer = double_precision */
     7697 		     conv_error = 0;
     7698 		     unspec (addr (work) -> based_integer) =
     7699 			conv_round (int_mode, dp_mode) ((unspec (cv_ptr -> based_double)), conv_error);
     7700 		     if conv_error < 0		/* number is too large to be an integer */
     7701 			then
     7702 			call print_message (119, const);
     7703 		     goto converted;
     7704 
     7705 convert_initial (15):				/* double precision = octal constant */
     7706 convert_initial (22):				/* complex = octal constant */
     7707 		     addr (work) -> based_bit_72 = octal_value;
     7708 		     go to converted;
     7709 
     7710 convert_initial (23):				/* complex = integer */
     7711 		     addr (work) -> based_real (2) = 0.0;
     7712 						/* 0 is the same in hex */
     7713 
     7714 convert_initial (9):				/* real = integer */
     7715 		     unspec (addr (work) -> based_real (1)) =
     7716 			conv_round (real_mode, int_mode) ((unspec (cv_ptr -> based_integer)), 0);
     7717 		     go to converted;
     7718 
     7719 convert_initial (25):				/* complex = double precision */
     7720 		     addr (work) -> based_real (2) = 0.0;
     7721 						/* 0 is the same in hex */
     7722 
     7723 convert_initial (11):				/* real = double precision */
     7724 		     unspec (addr (work) -> based_real (1)) =
     7725 			conv_round (real_mode, dp_mode) ((unspec (cv_ptr -> based_double)), 0);
     7726 		     go to converted;
     7727 
     7728 convert_initial (24):				/* complex = real */
     7729 		     addr (work) -> based_real (2) = 0.0;
     7730 						/* 0 is the same in hex */
     7731 
     7732 convert_initial (12):				/* real = complex */
     7733 convert_initial (17):				/* double precision = real */
     7734 convert_initial (19):				/* double precision = complex */
     7735 		     addr (work) -> based_real (1) = cv_ptr -> based_real (1);
     7736 		     go to converted;
     7737 
     7738 convert_initial (16):				/* double precision = integer */
     7739 		     unspec (addr (work) -> based_double) =
     7740 			conv_round (dp_mode, int_mode) ((unspec (cv_ptr -> based_integer)), 0);
     7741 
     7742 converted:
     7743 		     call store_value (el_ct, create_constant (v_dt, work));
     7744 		end /* loop: v_dt > 0 */;
     7745 
     7746 reduce_counts:
     7747 		v_count = v_count - el_ct;
     7748 		c_count = c_count - el_ct;
     7749 		interval = interval - el_ct;
     7750 	     end /* loop: v_count>0 */;
     7751 
     7752 /* Initialization is done. If interval existed, attempt to combine it with last created node or eliminate it. */
     7753 
     7754 	     if interval_ptr ^= 0 & ^data_error		/* Initialization redefined an existing interval. */
     7755 		then
     7756 		if interval <= 0 then do;		/* Interval was completely redefined. Remove it from chain. */
     7757 		     if last <= 0 then
     7758 			addr (OS (-last)) -> symbol.initial = polish_string (interval_ptr);
     7759 		     else
     7760 			polish_string (last) = polish_string (interval_ptr);
     7761 
     7762 		     polish_string (interval_ptr) = free_chain;
     7763 						/* Free the "node". */
     7764 		     free_chain = interval_ptr;
     7765 		end;
     7766 		else if last > 0 then
     7767 		     if polish_string (last + 2) = polish_string (interval_ptr + 2) then do;
     7768 						/* Remaining part of interval can be combined. */
     7769 			polish_string (last + 1) = polish_string (last + 1) + interval;
     7770 
     7771 			polish_string (interval_ptr) = free_chain;
     7772 						/* Free the "node". */
     7773 			free_chain = interval_ptr;
     7774 		     end;
     7775 		     else
     7776 			polish_string (interval_ptr + 1) = interval;
     7777 						/* Shorten the interval. */
     7778 		else
     7779 		     polish_string (interval_ptr + 1) = interval;
     7780 						/* Shorten the interval. */
     7781 
     7782 /* Set attributes for symbol (and header) only if there are non zero values in initial chain. */
     7783 
     7784 	     if (non_zero_value & INIT) = INIT & ^data_error then do;
     7785 		string (addr (OS (indx)) -> symbol.storage_info) =
     7786 		     string (addr (OS (indx)) -> symbol.storage_info) | non_zero_value;
     7787 
     7788 		if addr (OS (indx)) -> symbol.equivalenced then
     7789 		     if addr (OS (indx)) -> symbol.parent > 0
     7790 						/* update header only if it exists */
     7791 			then
     7792 			string (addr (OS (addr (OS (indx)) -> symbol.parent)) -> header.storage_info) =
     7793 			     string (addr (OS (addr (OS (indx)) -> symbol.parent)) -> header.storage_info)
     7794 			     | non_zero_value;
     7795 	     end;
     7796 
     7797 /* process all do loops terminating after this variable */
     7798 
     7799 	     do while (stack (current_spec) = END_DO_LOOP);
     7800 		loop_info = do_info (do_level);	/* pointer to loop info */
     7801 		initial_expression_idx = loop_info + INITIAL_EXPRESSION;
     7802 		final_expression_idx = initial_expression_idx + stack (initial_expression_idx) + 1;
     7803 		increment_expression_idx = final_expression_idx + stack (final_expression_idx) + 1;
     7804 
     7805 /* increment loop variable */
     7806 		increment_value = value (increment_expression_idx);
     7807 		current_value, stack (loop_info + CURRENT_VALUE) =
     7808 		     stack (loop_info + CURRENT_VALUE) + increment_value;
     7809 
     7810 /* test if loop is complete */
     7811 		final_value = value (final_expression_idx);
     7812 		if (increment_value > 0 & current_value > final_value)
     7813 		     | (increment_value < 0 & current_value < final_value) then do;
     7814 						/* loop is completed, go forward */
     7815 		     current_spec = current_spec + END_DO_LOOP_SIZE;
     7816 		     do_level = do_level - 1;		/* one fewer containing loops */
     7817 		end;
     7818 		else
     7819 		     current_spec = increment_expression_idx + stack (increment_expression_idx) + 1;
     7820 						/* re-execute the range of the loop */
     7821 	     end /* loops terminating after this var */;
     7822 	end /* main driving loop: current_spec < stack_index */;
     7823 
     7824 /* All variables have been processed. The constant list should also be expended; c_count >0 => excess in repeated value */
     7825 
     7826 	if token ^= slash | c_count > 0 then do;
     7827 	     call print_message (84);			/* missing slash */
     7828 	     go to statement_parse_abort;
     7829 	end;
     7830 
     7831 	call get_next_token (ignore_symtab_entry, ignore_value);
     7832 	stack_index = stack_base;
     7833 	from_data_parser = FALSE;
     7834 	return;
     7835 
     7836 
     7837 store_value:
     7838      procedure (count, value);
     7839 
     7840 dcl      count fixed bin (18);
     7841 dcl      value fixed bin;
     7842 
     7843 	if data_error then
     7844 	     return;
     7845 
     7846 	if value ^= gap_value then
     7847 	     non_zero_value = non_zero_value | INIT;
     7848 
     7849 /* This value is combined with previous node if possible, otherwise, a new node is created. */
     7850 
     7851 	if last > 0 then
     7852 	     if polish_string (last + 2) = value then do;
     7853 		polish_string (last + 1) = polish_string (last + 1) + count;
     7854 		return;
     7855 	     end;
     7856 
     7857 /* A "node" is needed. Allocate it and return. */
     7858 
     7859 	last = create_initial_node (last, interval_ptr, count, (value));
     7860      end store_value;
     7861 
     7862 
     7863 value:
     7864      proc (expression_idx) returns (fixed bin (18));
     7865 
     7866 /* Return the value of an expression in the stack whose operands are integer
     7867*   constants or implied do-loop variables, and whose operators are '+', '-',
     7868*   '*', '/', and '**'.  The expression consists of a "size" word (indicating
     7869*   how many of the following words are in the expression) and the Polish for
     7870*   the expression.  A negative value in the Polish indicates an implied
     7871*   do-loop variable and its absolute value is the index of the stack location
     7872*   containing the current value of that variable. */
     7873 
     7874 dcl      expression_idx fixed bin (18);
     7875 
     7876 dcl      error condition,
     7877          fixedoverflow condition,
     7878          zerodivide condition;
     7879 
     7880 dcl      exp_idx fixed bin (18),
     7881          op fixed bin (18),
     7882          orig_stack_index fixed bin (18);
     7883 
     7884 	if stack (expression_idx) = 0 then
     7885 	     return (0);				/* Assume zero for value of null expression. */
     7886 
     7887 	orig_stack_index = stack_index;
     7888 	on error goto error_detected;
     7889 	on fixedoverflow goto fixedoverflow_detected;
     7890 	on zerodivide goto zerodivide_detected;
     7891 
     7892 	do exp_idx = expression_idx + 1 to expression_idx + stack (expression_idx);
     7893 	     op = stack (exp_idx);
     7894 	     if op < 0 then
     7895 		call stack_operand (stack (-op));
     7896 	     else if op > last_assigned_op then
     7897 		call stack_operand ((addr (addr (OS (op)) -> constant.value) -> based_integer));
     7898 	     else if op >= add_op & op <= negate_op then do;
     7899 		if op < negate_op then do;
     7900 		     if stack_index < orig_stack_index + 2 then
     7901 			goto invalid_expression;
     7902 		     stack_index = stack_index - 1;
     7903 		end;
     7904 		else if stack_index < orig_stack_index + 1 then
     7905 		     goto invalid_expression;
     7906 		unspec (stack (stack_index - 1)) =
     7907 		     binop_trunc (int_mode, int_mode)
     7908 		     (op - add_op + 1, (unspec (stack (stack_index - 1))), (unspec (stack (stack_index))), 0);
     7909 	     end;
     7910 	     else
     7911 		goto invalid_expression;
     7912 	end;
     7913 
     7914 	if stack_index ^= orig_stack_index + 1 then
     7915 	     goto invalid_expression;
     7916 	stack_index = orig_stack_index;
     7917 	return (stack (stack_index));
     7918 
     7919 error_detected:
     7920 	call print_message (174, "error", "an integer expression");
     7921 	goto statement_parse_abort;
     7922 
     7923 fixedoverflow_detected:
     7924 	call print_message (174, "fixedoverflow", "an integer expression");
     7925 	goto statement_parse_abort;
     7926 
     7927 invalid_expression:
     7928 	call print_message (525, "in an integer expression");
     7929 	goto statement_parse_abort;
     7930 
     7931 zerodivide_detected:
     7932 	call print_message (174, "zerodivide", "an integer expression");
     7933 	goto statement_parse_abort;
     7934 
     7935      end value;
     7936      end parse_data;
     7937 
     7938 parse_a_constant:
     7939      procedure (allow_octal_constant, constant_offset, octal_value);
     7940 
     7941 /* This procedure parses one constant, preceded optionally by a sign. It returns a
     7942*	   pointer to the constant node for the constant parsed. */
     7943 
     7944 dcl      allow_octal_constant bit (1) aligned;
     7945 dcl      const_offset fixed bin (18);
     7946 dcl      constant_offset fixed bin (18);
     7947 dcl      (i, j) fixed bin;
     7948 dcl      octal_digits char (8) aligned int static options (constant) init ("01234567");
     7949 dcl      octal_value bit (72) aligned;
     7950 dcl      octal_work bit (72) aligned;
     7951 dcl      temp_sign bit (9) aligned;
     7952 
     7953 	const_offset = constant_offset;
     7954 
     7955 	if token = plus | token = minus then do;
     7956 	     sign = token;
     7957 	     call get_next_token (locate_symtab_entry, const_offset);
     7958 	end;
     7959 
     7960 /* If constant is a complex constant, call expression parser to parse it. */
     7961 
     7962 	if token = left_parn then do;
     7963 	     temp_sign = sign;			/* Copy sign in case components also have signs */
     7964 	     sign = ZERO;				/* See procedure "convert_integer_constant" for explanation. */
     7965 
     7966 	     if ^is_complex_constant (const_offset) then
     7967 		go to invalid_constant;
     7968 
     7969 	     sign = temp_sign;			/* Restore sign for entire constant */
     7970 	end;
     7971 
     7972 	else if (token & is_constant) = ZERO then
     7973 	     if token = ident & substr (fast_lookup, 1, 1) = "o" & allow_octal_constant then do;
     7974 
     7975 		octal_work = "0"b;
     7976 
     7977 /* convert the string of digits */
     7978 
     7979 		do i = 1 to min (symbol_length - 1, 24);
     7980 		     j = index (octal_digits, substr (full_name, symbol_length - i + 1, 1)) - 1;
     7981 
     7982 		     if j < 0			/* non_octal digit */
     7983 			then
     7984 			call print_message (130, substr (full_name, symbol_length - i + 1, 1));
     7985 
     7986 		     else if j > 0 then
     7987 			substr (octal_work, 73 - 3 * i, 3) = bit (fixed (j, 3), 3);
     7988 		end;
     7989 
     7990 		octal_value = octal_work;
     7991 		const_offset = 0;
     7992 	     end;
     7993 
     7994 	     else do;
     7995 invalid_constant:
     7996 		call print_message (50, err_string ()); /* missing constant */
     7997 		const_offset = value_0;
     7998 	     end;
     7999 
     8000 /* If sign is supplied, negate an arithmetic constant. */
     8001 
     8002 	if sign ^= ZERO then do;
     8003 	     if const_offset = 0			/* sign invalid for octal constant */
     8004 		then
     8005 		call print_message (51);
     8006 
     8007 	     else if (token & is_arith_constant) = ZERO then
     8008 		call print_message (51);		/* not arithmetic */
     8009 
     8010 	     else if sign = minus then
     8011 		const_offset = negate_constant (const_offset);
     8012 
     8013 	     sign = ZERO;				/* See procedure "convert_integer_constant" for explanation. */
     8014 	end;
     8015 
     8016 	constant_offset = const_offset;
     8017      end parse_a_constant;
     8018 
     8019 create_initial_node:
     8020      procedure (last_node, next_node, rep_count, value_ptr) returns (fixed bin (18));
     8021 
     8022 dcl      last_node fixed bin (18);
     8023 dcl      next_node fixed bin (18);
     8024 dcl      new_node fixed bin (18);
     8025 dcl      rep_count fixed bin (18);
     8026 dcl      value_ptr fixed bin (18);
     8027 
     8028 /* Reuse a free "node" or allocate a new one. */
     8029 
     8030 	if free_chain ^= 0 then do;			/* Reuse an old "node". */
     8031 	     new_node = free_chain;			/* Remove node from free chain. */
     8032 	     free_chain = polish_string (new_node);
     8033 
     8034 	     polish_string (new_node) = next_node;	/* Store values. */
     8035 	     polish_string (new_node + 1) = rep_count;
     8036 	     polish_string (new_node + 2) = value_ptr;
     8037 	end;
     8038 	else do;					/* Create a new "node". */
     8039 	     if first_word = 0			/* First "node" for this statement. */
     8040 	     then do;
     8041 		call emit_operator (increment_polish_op);
     8042 		call emit_count (first_word);
     8043 	     end;
     8044 
     8045 	     new_node = next_free_polish;		/* Build a "node". */
     8046 	     call emit_halfword (next_node);
     8047 	     call emit_halfword (rep_count);
     8048 	     call emit_halfword (value_ptr);
     8049 	end;
     8050 
     8051 	if last_node <= 0 then
     8052 	     addr (OS (-last_node)) -> symbol.initial = new_node;
     8053 	else
     8054 	     polish_string (last_node) = new_node;
     8055 	return (new_node);
     8056      end create_initial_node;
     8057 
     8058 create_format:
     8059      procedure (fmt_str, sym_index);			/* Not Audited. */
     8060 
     8061 /*	Program Specifications (create_format)
     8062*
     8063*     Inputs
     8064*
     8065*     Output
     8066*
     8067*     Description (create_format)
     8068*
     8069*     Notes - The variable "char_temp", declared in a containing procedure, must be an acceptable
     8070*	input argument in the call to general_format_parse_, below.
     8071**/
     8072 
     8073 dcl      fmt_length fixed bin (18);
     8074 dcl      fmt_ptr pointer;
     8075 dcl      fmt_str char (*);
     8076 dcl      fmt_word (512) char (4) unaligned based (addr (new_format));
     8077 dcl      format_string char (fmt_length) based (addr (new_format));
     8078 dcl      i fixed bin (18);
     8079 dcl      j fixed bin (18);
     8080 dcl      k fixed bin (18);
     8081 dcl      new_format char (4096) aligned;
     8082 dcl      sym_index fixed bin (18);
     8083 
     8084 dcl      1 encoded_format like runtime_format aligned based (addr (new_format));
     8085 
     8086 	if length (fmt_str) > length (char_temp) then do;
     8087 	     call print_message (85, length (char_temp) - bias);
     8088 						/* too many characters in format */
     8089 	     return;
     8090 	end;
     8091 
     8092 	char_temp = fmt_str;
     8093 
     8094 	call general_format_parse_ (char_temp, new_format, (subr_options.ansi_77), code);
     8095 	if code ^= 0 then do;
     8096 	     call print_message (86, addr (new_format) -> error_message);
     8097 						/* syntax error in format */
     8098 	     return;
     8099 	end;
     8100 
     8101 /* The length, in characters, of the output string is returned in "fmt_len". It is always even.
     8102*	   The halfword immediately following the output string contains the number of characters parsed.
     8103*	   The number of characters parsed must equal the length of the input to this procedure. */
     8104 
     8105 	fmt_length = encoded_format.fmt_len;		/* character length of encoded string */
     8106 
     8107 /* compare length of input string with the number of characters parsed. */
     8108 
     8109 	if length (fmt_str) ^= addr (new_format) -> old_format.fmt (divide (fmt_length, 2, 17, 0) - 1) then
     8110 	     call print_message (134);		/* garbage at end */
     8111 
     8112 /* If the specification contains hollerith or character-string fields, the appropriate strings must
     8113*	   be copied into the representation of the format spec. */
     8114 
     8115 	if encoded_format.contains_hollerith & encoded_format.version ^= fmt_parse_ver1 then do;
     8116 
     8117 	     i = 1;
     8118 	     do k = addr (new_format) -> old_format.fmt (i) repeat addr (new_format) -> old_format.fmt (i)
     8119 		while (k ^= end_of_format);
     8120 
     8121 		if k = hollerith_field | k = quoted_string then do;
     8122 		     j = addr (new_format) -> old_format.fmt (i + 1);
     8123 						/* length of the string */
     8124 
     8125 		     if fmt_length + j > length (new_format)
     8126 						/* too big */
     8127 		     then do;
     8128 			call print_message (85, length (new_format) - bias);
     8129 			return;
     8130 		     end;
     8131 
     8132 		     substr (new_format, fmt_length + 1, j) =
     8133 			substr (char_temp, addr (new_format) -> old_format.fmt (i + 2), j);
     8134 		     addr (new_format) -> old_format.fmt (i + 2) = fmt_length + 1;
     8135 						/* copy string and update offset field */
     8136 
     8137 		     fmt_length = fmt_length + j;	/* update total length */
     8138 		end;
     8139 
     8140 		i = i + increment_table (k);		/* point to next specification */
     8141 	     end;
     8142 
     8143 	     addr (new_format) -> old_format.fmt_len = fmt_length;
     8144 						/* update length field to include strings */
     8145 	end;
     8146 
     8147 /* now build the appropriate constant */
     8148 
     8149 	first_word = 0;				/* No "nodes" allocated by this statement. */
     8150 
     8151 	k = -sym_index;
     8152 	fmt_ptr = addr (OS (-k));
     8153 	fmt_ptr -> symbol.initialed = TRUE;
     8154 
     8155 	if fmt_length > max_char_length		/* 512 */
     8156 	then do;
     8157 	     fmt_ptr -> symbol.dimensioned = TRUE;
     8158 	     fmt_ptr -> symbol.char_size = chars_per_word - 1;
     8159 
     8160 	     i = divide (fmt_length + chars_per_word - 1, chars_per_word, 17, 0);
     8161 	     num_dims = 1;
     8162 	     j = create_node (dimension_node, size (dimension));
     8163 	     addr (OS (j)) -> dimension.number_of_dims = 1;
     8164 	     addr (OS (j)) -> dimension.dim.lower_bound (1) = 1;
     8165 	     addr (OS (j)) -> dimension.dim.upper_bound (1) = i;
     8166 	     addr (OS (j)) -> dimension.dim.size (1) = i;
     8167 	     addr (OS (j)) -> dimension.has_dim_sizes = TRUE;
     8168 	     addr (OS (j)) -> dimension.v_bound (1) = ""b;
     8169 	     addr (OS (j)) -> dimension.element_count = i;
     8170 	     fmt_ptr -> symbol.dimension = j;
     8171 
     8172 	     if fmt_length - i * chars_per_word ^= 0	/* insure there is no garbage */
     8173 		then
     8174 		addr (new_format) -> based_words (i) =
     8175 		     addr (new_format) -> based_words (i)
     8176 		     & bit_mask ((fmt_length - i * chars_per_word) + chars_per_word);
     8177 
     8178 	     do j = 1 to i;
     8179 		k = create_initial_node (k, 0, 1, create_char_constant (fmt_word (j)));
     8180 	     end;
     8181 	end;
     8182 	else do;
     8183 	     fmt_ptr -> symbol.char_size = fmt_length - 1;
     8184 	     ignore_value = create_initial_node (k, 0, 1, create_char_constant (format_string));
     8185 	end;
     8186 
     8187 /* If data specs generated "nodes" in polish, must indicate how many halfwords are used. */
     8188 	if first_word ^= 0 then
     8189 	     polish_string (first_word) = next_free_polish - first_word - 1;
     8190      end create_format;
     8191 
     8192 find_symbol_index:
     8193      procedure (a_len, a_index, create_sw, a_last);
     8194 
     8195 /*	Program Specifications (find_symbol_index)
     8196*
     8197*     Inputs
     8198*
     8199*     Output
     8200*
     8201*     Description (find_symbol_index)
     8202**/
     8203 
     8204 dcl      a_index fixed bin (18);
     8205 dcl      a_last fixed bin (18);
     8206 dcl      a_len fixed bin (18);
     8207 dcl      bool builtin;
     8208 dcl      create_sw fixed bin (2);
     8209 dcl      fast_bits bit (36) aligned;
     8210 dcl      in_list bit (1) aligned;
     8211 dcl      last_item fixed bin (18);
     8212 dcl      n fixed bin (18);
     8213 dcl      returned_index fixed bin (18);
     8214 
     8215 	allocate_symbol_name = a_len;
     8216 
     8217 /* Calculate hash bucket value. */
     8218 
     8219 	if allocate_symbol_name = 1 then
     8220 	     last_item = binary (unspec (substr (full_name, 1, 1)), 9, 0);
     8221 	else do;
     8222 
     8223 /* calculate number of words and mod(length, chars_per_word) */
     8224 
     8225 	     last_item = divide (allocate_symbol_name - 1, chars_per_word, 17, 0) + 1;
     8226 	     n = allocate_symbol_name - (last_item - 1) * chars_per_word;
     8227 
     8228 /* mask last word of the symbol name (bit_mask(4) is all ones) */
     8229 
     8230 	     addr (full_name) -> based_words (last_item) = addr (full_name) -> based_words (last_item) & bit_mask (n);
     8231 
     8232 /* form hash index by exclusive or'ing all the words of the symbol name */
     8233 
     8234 	     fast_bits = addr (full_name) -> based_words (1);
     8235 
     8236 	     if last_item >= 2 then
     8237 		do n = 2 to last_item;
     8238 		     fast_bits = bool (fast_bits, addr (full_name) -> based_words (n), "0110"b);
     8239 		end;
     8240 
     8241 	     last_item = mod (binary (fast_bits, 35), dim (hash_table, 1));
     8242 	end;
     8243 
     8244 	returned_index = hash_table (last_item);
     8245 	in_list = TRUE;
     8246 
     8247 /* search through the symbol table */
     8248 
     8249 	if returned_index > 0 then
     8250 	     do while (in_list);
     8251 		if addr (OS (returned_index)) -> symbol.name = substr (full_name, 1, allocate_symbol_name) then do;
     8252 		     in_list = FALSE;
     8253 		     if produce_listing then
     8254 			call generate_cross_ref (returned_index);
     8255 		end;
     8256 		else do;
     8257 		     last_item = returned_index;
     8258 		     returned_index = addr (OS (returned_index)) -> symbol.hash_chain;
     8259 		     if returned_index = 0 then
     8260 			in_list = FALSE;
     8261 		end;
     8262 	     end;
     8263 
     8264 	if returned_index = 0 then
     8265 	     if create_sw = force_symtab_entry then do;
     8266 		returned_index = create_node (symbol_node, size (symbol));
     8267 
     8268 		addr (OS (returned_index)) -> symbol.name_length = allocate_symbol_name;
     8269 		substr (addr (OS (returned_index)) -> symbol.name, 1, allocate_symbol_name) =
     8270 		     substr (full_name, 1, allocate_symbol_name);
     8271 
     8272 		if sub_ptr -> last_symbol = 0 then
     8273 		     sub_ptr -> first_symbol = returned_index;
     8274 		else
     8275 		     addr (OS (sub_ptr -> last_symbol)) -> symbol.next_symbol = returned_index;
     8276 		sub_ptr -> last_symbol = returned_index;
     8277 
     8278 		if last_item <= hbound (hash_table, 1) then
     8279 		     hash_table (last_item) = returned_index;
     8280 		else
     8281 		     addr (OS (last_item)) -> symbol.hash_chain = returned_index;
     8282 
     8283 		if produce_listing then
     8284 		     call generate_cross_ref (returned_index);
     8285 	     end;
     8286 
     8287 	a_index = returned_index;
     8288 	a_last = last_item;
     8289      end find_symbol_index;
     8290 
     8291 get_mode_size:
     8292      procedure (mode, a_size, attributes, asterisk_seen);
     8293 
     8294 /*	Program Specifications (get_mode_size)
     8295*
     8296*     Inputs
     8297*
     8298*     Output
     8299*
     8300*     Description (get_mode_size)
     8301*	this procedure is called with the current token being the token before the asterisk, when it exists.
     8302**/
     8303 
     8304 dcl      a_size fixed bin (18);
     8305 declare	asterisk_seen bit (1) aligned;
     8306 dcl      1 attr like symbol.attributes based (addr (attributes));
     8307 dcl      attributes bit (47) aligned;
     8308 dcl      mode fixed bin (4);
     8309 dcl      size fixed bin (9);
     8310 dcl      star_extents bit (1) aligned;
     8311 
     8312 	star_extents, asterisk_seen = FALSE;
     8313 
     8314 	if token_list (current_token + 1).type = asterisk then do;
     8315 	     asterisk_seen = TRUE;
     8316 	     current_token = current_token + 1;
     8317 	     call get_next_token (locate_symtab_entry, const_index);
     8318 
     8319 	     if token = dec_int then do;
     8320 		size = addr (work) -> based_integer;
     8321 		if mode = cmpx_mode then do;		/*   if not single precision then error  */
     8322 		     if size ^= 8 then
     8323 			call print_message (365, ltrim (char (size, 7)));
     8324 		end;
     8325 	     end;
     8326 	     else if token ^= left_parn then do;
     8327 		call print_message (24, err_string ());
     8328 		go to statement_parse_abort;
     8329 	     end;
     8330 
     8331 	     else do;
     8332 		call get_next_token (force_symtab_entry, symbol_index);
     8333 
     8334 		if token = asterisk then
     8335 		     if mode = char_mode then
     8336 			if subr_options.ansi_77 then do;
     8337 			     star_extents = "1"b;
     8338 			     call get_next_token$operator;
     8339 			end;
     8340 			else do;
     8341 			     call print_message (158);
     8342 			     go to statement_parse_abort;
     8343 			end;
     8344 		     else do;
     8345 			call print_message (24, err_string ());
     8346 			go to statement_parse_abort;
     8347 		     end;
     8348 
     8349 		else do;
     8350 		     parameter_info.start_of_polish = next_free_polish;
     8351 		     call parse_expression (any_expression, symbol_index, ignore_bits);
     8352 
     8353 		     parameter_info.max_stack = max_stack;
     8354 		     parameter_info.stack_index = stack_index;
     8355 		     parameter_info.desired_data_type = int_mode;
     8356 		     parameter_info.end_of_polish = next_free_polish - 1;
     8357 		     parameter_info.rounding = subr_options.do_rounding;
     8358 
     8359 		     call fort_eval_parm (addr (parameter_info), "a length field expression", error_code);
     8360 		     max_stack = parameter_info.max_stack;
     8361 		     next_free_polish = parameter_info.start_of_polish;
     8362 
     8363 		     if error_code = 0 then do;
     8364 			const_index = parameter_info.result_location;
     8365 			size = addr (addr (OS (const_index)) -> constant.value) -> based_integer;
     8366 		     end;
     8367 		     else if mode = char_mode then
     8368 			size = default_char_size;
     8369 		end;
     8370 
     8371 		if token ^= right_parn then
     8372 		     go to missing_right_paren;
     8373 	     end;
     8374 
     8375 	     if mode = char_mode then
     8376 		if star_extents then
     8377 		     attr.star_extents = "1"b;
     8378 		else do;
     8379 		     attr.star_extents = "0"b;
     8380 		     if size <= 0 then do;
     8381 			call print_message (24, const_index);
     8382 			size = default_char_size;
     8383 		     end;
     8384 		     else if size > max_char_var_length /*131071*/
     8385 		     then do;
     8386 			call print_message (87, addr (OS (SI)) -> symbol.name,
     8387 			     max_char_var_length /*131071*/ - bias);
     8388 			size = default_char_size;
     8389 		     end;
     8390 		end;
     8391 	     else if (mode = real_mode | mode = dp_mode) then do;
     8392 		if size <= 4 then do;
     8393 		     if size ^= 4 then
     8394 			call print_message (366, "single", ltrim (char (size, 7)));
     8395 		     mode = real_mode;
     8396 		end;
     8397 		else do;
     8398 		     if size ^= 8 then
     8399 			call print_message (366, "double", ltrim (char (size, 7)));
     8400 		     mode = dp_mode;
     8401 		end;
     8402 	     end;
     8403 
     8404 	end;
     8405 	else
     8406 	     size = a_size;
     8407 
     8408 	if mode = char_mode then
     8409 	     if attr.star_extents then do;
     8410 		attr.char_size = 0;
     8411 		a_size = 0;
     8412 	     end;
     8413 	     else do;
     8414 		attr.char_size = size - 1;
     8415 		a_size = size;
     8416 	     end;
     8417 	else
     8418 	     attributes = attr_table (mode);
     8419 
     8420      end get_mode_size;
     8421 
     8422 parse_implied_io:
     8423      procedure (rd_sw, unit, allow_asterisk);
     8424 
     8425 /*	Program Specifications (parse_implied_io)
     8426*
     8427*     Inputs
     8428*
     8429*     Output
     8430*
     8431*     Description (parse_implied_io)
     8432**/
     8433 
     8434 dcl      indx fixed bin (18);
     8435 dcl      rd_sw bit (1) aligned;
     8436 declare	allow_asterisk bit (1) aligned;
     8437 
     8438 dcl      unit fixed bin (18);
     8439 
     8440 	string (io_bits) = FALSE;
     8441 	fields_specified = ZERO;
     8442 	io_bits.read = rd_sw;
     8443 	io_bits.fold = subr_options.fold;
     8444 	io_bits.ansi_77 = subr_options.ansi_77;
     8445 	io_bits.hfp = subr_options.hfp;
     8446 	io_bits.debug_io = subr_options.debug_io;
     8447 
     8448 	sub_ptr -> need_PS = TRUE;
     8449 
     8450 	call emit_operand (unit);
     8451 
     8452 	call get_next_token$label (force_symtab_entry, indx);
     8453 	if token ^= comma & token ^= EOS_token then do;
     8454 	     call get_format (indx, allow_asterisk);
     8455 	end;
     8456 
     8457 	if token = comma then do;
     8458 	     if current_token >= last_token then do;
     8459 		current_token = current_token + 1;
     8460 		go to missing_identifier;
     8461 	     end;
     8462 	end;
     8463 	else if token ^= EOS_token then
     8464 	     go to missing_comma;
     8465 
     8466 	call parse_io_list;
     8467      end parse_implied_io;
     8468 
     8469 parse_io:
     8470      procedure (rd_sw);
     8471 
     8472 /*	Program Specifications (parse_io)
     8473*
     8474*     Inputs
     8475*
     8476*     Output
     8477*
     8478*     Description (parse_io)
     8479**/
     8480 
     8481 dcl      indx fixed bin (18);
     8482 dcl      rd_sw bit (1) aligned;
     8483 declare	no_keyword fixed binary;
     8484 declare	fmt fixed binary (18);
     8485 
     8486 	string (io_bits) = FALSE;
     8487 	fields_specified = ZERO;
     8488 	io_bits.read = rd_sw;
     8489 	io_bits.fold = subr_options.fold;
     8490 	io_bits.ansi_77 = subr_options.ansi_77;
     8491 	io_bits.hfp = subr_options.hfp;
     8492 	io_bits.debug_io = subr_options.debug_io;
     8493 
     8494 	sub_ptr -> need_PS = TRUE;
     8495 
     8496 	call get_next_token$operator;			/* get left paren */
     8497 	if token ^= left_parn then
     8498 	     go to missing_left_paren;
     8499 
     8500 	count = 0;
     8501 	no_keyword = 0;
     8502 	in_list = TRUE;
     8503 	do while (in_list);
     8504 	     count = count + 1;
     8505 	     call get_next_token (ignore_symtab_entry, ignore_value);
     8506 	     if token_list (current_token + 1).type = assign then do;
     8507 						/* keyword driven list element */
     8508 		if token ^= ident then
     8509 		     go to missing_keyword;
     8510 		else if substr (full_name, 1, symbol_length) = "err" then
     8511 		     call parse_error_label;
     8512 		else if substr (full_name, 1, symbol_length) = "end" then
     8513 		     call parse_end_label;
     8514 		else if substr (full_name, 1, symbol_length) = "unit" then
     8515 		     call parse_unit_specifier (TRUE, FALSE);
     8516 		else if substr (full_name, 1, symbol_length) = "iostat" then
     8517 		     call parse_iostat_var;
     8518 		else if substr (full_name, 1, symbol_length) = "fmt" then do;
     8519 		     call get_next_token$operator;	/* skip over the "=" */
     8520 		     call get_next_token$label (force_symtab_entry, fmt);
     8521 		     call get_format (fmt, TRUE);
     8522 		end;
     8523 		else if substr (full_name, 1, symbol_length) = "rec" then do;
     8524 		     call get_next_token$operator;
     8525 		     call get_next_token (force_symtab_entry, indx);
     8526 		     call parse_record_number (indx);
     8527 		end;
     8528 		else
     8529 		     goto invalid_keyword;
     8530 	     end;
     8531 	     else do;
     8532 
     8533 /* if no keyword, then assume UNIT = if first in list, FMT = if second in list
     8534*and first was also unit, but with no keyword, otherwise an error */
     8535 
     8536 		no_keyword = no_keyword + 1;
     8537 		if count = 1 then do;
     8538 		     call parse_unit_specifier$no_keyword (TRUE, FALSE);
     8539 		     if token = apostrophe then do;
     8540 			call get_next_token (force_symtab_entry, indx);
     8541 			call parse_record_number (indx);
     8542 		     end;
     8543 		end;
     8544 		else if count = 2 then do;
     8545 		     if no_keyword = 2 then
     8546 			if token = comma | token = right_parn then do;
     8547 						/* old list directed input */
     8548 			     io_bits.format = list_directed;
     8549 			     substr (fields_specified, fmt_field, 1) = TRUE;
     8550 			end /* null list element */;
     8551 			else do;
     8552 			     current_token = current_token - 1;
     8553 			     call get_next_token$label (force_symtab_entry, fmt);
     8554 			     call get_format (fmt, TRUE);
     8555 			end /* usual parse of format */;
     8556 		     else do;
     8557 
     8558 /* if this is not keyword driven, is the second list item, the first item should have been keyword driven */
     8559 			go to missing_keyword;
     8560 		     end;
     8561 		end /* count = 2 */;
     8562 		else
     8563 		     goto missing_keyword;		/* count > 2 */
     8564 	     end /* no keyword */;
     8565 
     8566 	     in_list = (token = comma);
     8567 	end /* while loop */;
     8568 
     8569 /* error checking */
     8570 
     8571 	if ^substr (fields_specified, units_field, 1) then
     8572 	     call print_message (31, keyword_table (statement_type), "unit");
     8573 
     8574 	if substr (fields_specified, rec_field, 1) & io_bits.end_label then
     8575 	     call print_message (187, keyword_table (statement_type), "rec and end");
     8576 
     8577 	if io_bits.end_label & ^io_bits.read then
     8578 	     call print_message (187, keyword_table (statement_type), "end");
     8579 
     8580 	if io_bits.read & io_bits.end_label & io_bits.mode ^= sequential_access then
     8581 	     call print_message (187, keyword_table (statement_type), "sequential access and end");
     8582 
     8583 	if ^substr (fields_specified, fmt_field, 1) then
     8584 	     io_bits.format = unformatted;
     8585 
     8586 	if io_bits.mode = internal_file then do;
     8587 	     if io_bits.format = unformatted then
     8588 		call print_message (31, "internal file" || keyword_table (statement_type), "format");
     8589 	     else if io_bits.format = list_directed then
     8590 		call print_message (187, keyword_table (statement_type), "internal file and list directed");
     8591 	end;
     8592 	if token ^= right_parn then
     8593 	     go to missing_right_paren;
     8594 
     8595 	call parse_io_list;
     8596      end parse_io;
     8597 
     8598 parse_io_options:
     8599      procedure;
     8600 
     8601 /*	Program Specifications (parse_io_options)
     8602*
     8603*     Inputs
     8604*
     8605*     Output
     8606*
     8607*     Description (parse_io_options)
     8608*	Comment the sneakiness loudly.
     8609**/
     8610 dcl      fmt fixed bin (18);
     8611 
     8612 	if token ^= comma then
     8613 	     io_bits.format = unformatted;
     8614 	else do;
     8615 	     next_token = token_list (current_token + 1).type;
     8616 	     if next_token = comma then
     8617 		call get_next_token$operator;		/* get that comma */
     8618 	     else if token_list (current_token + 2).type = assign & current_token + 2 <= last_token then
     8619 		io_bits.format = unformatted;
     8620 	     else if next_token = right_parn then
     8621 		call get_next_token$operator;		/* get that right paren */
     8622 	     else do;
     8623 		call get_next_token$label (force_symtab_entry, fmt);
     8624 		call get_format (fmt, FALSE);
     8625 	     end;
     8626 	     do while (token = comma);
     8627 		call get_next_token (ignore_symtab_entry, ignore_value);
     8628 		if token ^= ident then
     8629 		     go to missing_keyword;
     8630 
     8631 		if substr (fast_lookup, 1, symbol_length) = "err" then
     8632 		     call parse_error_label;
     8633 
     8634 		else if io_bits.read & io_bits.mode = sequential_access
     8635 		     & substr (fast_lookup, 1, symbol_length) = "end" then
     8636 		     call parse_end_label;
     8637 
     8638 		else
     8639 		     go to invalid_keyword;
     8640 
     8641 	     end /* exception loop */;
     8642 	end /* token = comma */;
     8643 
     8644 	if token ^= right_parn then
     8645 	     go to missing_right_paren;
     8646      end parse_io_options;
     8647 
     8648 parse_error_label:
     8649      procedure;
     8650 
     8651 dcl      exit_lbl fixed bin (18);
     8652 dcl      op_name fixed bin;
     8653 
     8654 	if io_bits.error_label then
     8655 	     call print_message (48, "err");
     8656 	io_bits.error_label = TRUE;
     8657 
     8658 	op_name = error_label_op;
     8659 	go to parse_error_common;
     8660 
     8661 parse_end_label:
     8662      entry;
     8663 	if io_bits.end_label then
     8664 	     call print_message (48, "end");
     8665 	io_bits.end_label = TRUE;
     8666 
     8667 	op_name = end_label_op;
     8668 
     8669 parse_error_common:
     8670 	call get_next_token$operator;			/* get equals */
     8671 	if token ^= assign then
     8672 	     go to missing_equals_sign;
     8673 
     8674 	call get_next_token$label (ignore_symtab_entry, ignore_value);
     8675 	if token ^= dec_int then
     8676 	     go to missing_label;
     8677 
     8678 	exit_lbl = enter_label (executable_label, (addr (work) -> based_integer), GOTO_REF);
     8679 	addr (OS (exit_lbl)) -> label.restore_prs = TRUE;
     8680 
     8681 	call emit_operand (exit_lbl);
     8682 	call emit_operator ((op_name));
     8683 	call get_next_token (ignore_symtab_entry, ignore_value);
     8684      end parse_error_label;
     8685 
     8686 parse_iostat_var:
     8687      procedure;
     8688 
     8689 dcl      first_sym fixed bin (18);
     8690 
     8691 	if io_bits.iostat_var then
     8692 	     call print_message (48, "iostat");
     8693 	io_bits.iostat_var = TRUE;
     8694 
     8695 	call get_next_token$operator;			/* get equals */
     8696 	if token ^= assign then
     8697 	     go to missing_equals_sign;
     8698 
     8699 	call get_next_token (force_symtab_entry, first_sym);
     8700 	call parse_expression (set_reference, first_sym, ignore_bits);
     8701 
     8702 	call emit_operator (iostat_op);
     8703      end parse_iostat_var;
     8704 
     8705 parse_unit_specifier:
     8706      procedure (allow_asterisk, build_list_item);
     8707 
     8708 /* the unit specifier is either an asterisk, identifying the default unit specifier, or an integer expression > 0.
     8709*   If allow_asterisk is false (e.g. for backspace, endfile, etc.) then must be of the usual variety.
     8710*   Unlike parse_iostat_var and parse_end_label, this subroutine does not emit any polish for a "unit" operator.
     8711*   This is done as part of the polish by the caller in an appropriate place.
     8712**/
     8713 declare	allow_asterisk bit (1) aligned;		/* INPUT */
     8714 declare	build_list_item bit (1) aligned;		/* INPUT */
     8715 
     8716 	call get_next_token$operator;
     8717 	if token ^= assign then
     8718 	     goto missing_equals_sign;
     8719 	goto unit_parse_common;
     8720 
     8721 parse_unit_specifier$no_keyword:
     8722      entry (allow_asterisk, build_list_item);
     8723 
     8724 	current_token = current_token - 1;		/* back it up, we assumed it was a keyword */
     8725 
     8726 unit_parse_common:
     8727 	if substr (fields_specified, units_field, 1) then
     8728 	     call print_message (48, "unit specifier or unit");
     8729 	substr (fields_specified, units_field, 1) = TRUE;
     8730 
     8731 	call get_next_token (force_symtab_entry, SI);
     8732 
     8733 /* Check for invalid unit numbers. */
     8734 
     8735 	if (token = dec_int | token = minus) then do;
     8736 	     if (token = minus) then do;
     8737 		call get_next_token (force_symtab_entry, SI);
     8738 		call print_message (194, "-" || (ltrim (char (addr (work) -> based_integer))));
     8739 	     end;
     8740 	     else if (addr (work) -> based_integer > 99) then
     8741 		call print_message (194, ltrim (char (addr (work) -> based_integer)));
     8742 	end;
     8743 
     8744 	if token = asterisk then do;
     8745 	     if allow_asterisk then do;
     8746 		call emit_operand (default_unit_specifier);
     8747 		call get_next_token$operator;
     8748 	     end;
     8749 	     else
     8750 		call print_message (149, keyword_table (statement_type));
     8751 	end;
     8752 	else if token = ident then do;
     8753 	     call set_data_fields (SI);
     8754 	     if addr (OS (SI)) -> symbol.character then
     8755 		call get_internal_file (FALSE);
     8756 	     else
     8757 		goto not_internal_file;
     8758 	end;
     8759 	else do;
     8760 not_internal_file:
     8761 	     call parse_expression (any_expression, SI, ignore_bits);
     8762 	end;
     8763 
     8764 /* if building list item, put out the polish - open and close statements */
     8765 
     8766 	if build_list_item then do;
     8767 	     call emit_halfword (units_field - bias);
     8768 	     call emit_operator (item_op);
     8769 	end;
     8770 	return;
     8771      end parse_unit_specifier;
     8772 
     8773 parse_record_number:
     8774      procedure (indx);
     8775 
     8776 declare	indx fixed binary (18);			/* INPUT: 1st symbol in expression for record number */
     8777 
     8778 	if substr (fields_specified, rec_field, 1) then
     8779 	     call print_message (48, "record specifier or rec");
     8780 	if io_bits.mode = internal_file then
     8781 	     call print_message (187, keyword_table (statement_type), "internal file and direct access");
     8782 	substr (fields_specified, rec_field, 1) = TRUE;
     8783 
     8784 	call parse_expression (any_expression, indx, ignore_bits);
     8785 	io_bits.mode = direct_access;
     8786 	call emit_operator (record_number_op);
     8787      end parse_record_number;
     8788 
     8789 get_internal_file:
     8790      procedure (from_encode_decode);
     8791 
     8792 declare	from_encode_decode bit (1) aligned;		/* INPUT: T if from encode/decode, F if from read/write */
     8793 declare	symp pointer;				/* ptr to symbol node */
     8794 
     8795 	symp = addr (OS (SI));
     8796 	call emit_operand (value_0);			/* Dummy file number. */
     8797 	if io_bits.read then
     8798 	     call parse_expression (string_source, SI, out);
     8799 	else
     8800 	     call parse_expression (string_target, SI, out);
     8801 
     8802 /* this must be a variable, array name, array element, or substring of those */
     8803 
     8804 	if addr (out) -> expression.not_simple_ref then
     8805 	     call print_message (29, keyword_table (statement_type));
     8806 
     8807 /* Emit proper operator, check for errors, and emit polish for string length (encode_decode only) */
     8808 
     8809 	if from_encode_decode then do;
     8810 	     if ^sub_ptr -> subprogram.options.optimize then
     8811 		call emit_operator (string_op);
     8812 	     else if io_bits.read then
     8813 		call emit_operator (decode_string_op);
     8814 	     else
     8815 		call emit_operator (encode_string_op);
     8816 
     8817 	     if io_bits.mode = direct_access then
     8818 		call print_message (187, keyword_table (statement_type), "direct access");
     8819 	     else
     8820 		io_bits.mode = string_io;
     8821 
     8822 /* We must emit the polish for the length of the string 
     8823*   for encode/decode, we permit character scalars and non-logical arrays and array elements 
     8824**/
     8825 
     8826 	     if symp -> symbol.character then do;
     8827 		addr (work) -> based_integer = symp -> symbol.char_size + 1;
     8828 		call emit_operand (create_constant (int_mode, work));
     8829 	     end;
     8830 	     else do;
     8831 		addr (work) -> based_integer = chars_per_word * symp -> symbol.element_size;
     8832 		if symp -> symbol.dimensioned & addr (out) -> expression.array_name then do;
     8833 		     dp = addr (OS (symp -> symbol.dimension));
     8834 		     p = 0;
     8835 
     8836 		     if symp -> symbol.variable_extents then do;
     8837 			if dp -> dimension.assumed_size then do;
     8838 			     call print_message (166, keyword_table (statement_type));
     8839 			     goto statement_parse_abort;
     8840 			end;
     8841 			do i = 1 to dp -> dimension.number_of_dims;
     8842 			     if string (dp -> dimension.v_bound (i)) = ""b
     8843 						/* both bounds constant just multiply constant part by size */
     8844 				then
     8845 				addr (work) -> based_integer =
     8846 				     addr (work) -> based_integer * dp -> dimension.dim.size (i);
     8847 			     else if string (dp -> dimension.v_bound (i)) = "11"b
     8848 						/* both bounds variable, size = upper - lower + 1 */
     8849 			     then do;
     8850 				call emit_operand ((dp -> dimension.dim.upper_bound (i)));
     8851 				call emit_operand ((dp -> dimension.dim.lower_bound (i)));
     8852 				call emit_operator (sub_op);
     8853 				call emit_operand (value_1);
     8854 				call emit_operator (add_op);
     8855 				p = p + 1;
     8856 			     end;
     8857 			     else if dp -> dimension.v_bound.lower (i)
     8858 						/* only lower bound is variable.  size = constant (upper_bound +1) - lower_bound */
     8859 			     then do;
     8860 				call emit_operand (
     8861 				     create_constant (int_mode, bit (dp -> dimension.dim.upper_bound (i) + 1, 72))
     8862 				     );
     8863 				call emit_operand ((dp -> dimension.dim.lower_bound (i)));
     8864 				call emit_operator (sub_op);
     8865 				p = p + 1;
     8866 			     end;
     8867 			     else do;
     8868 
     8869 /* only upper bound is variable.  size = upper - constant (lower -1) */
     8870 				call emit_operand ((dp -> dimension.dim.upper_bound (i)));
     8871 				call emit_operand (
     8872 				     create_constant (int_mode, bit (dp -> dimension.dim.lower_bound (i) - 1, 72))
     8873 				     );
     8874 				call emit_operator (sub_op);
     8875 				p = p + 1;
     8876 			     end;
     8877 
     8878 			     if i = dp -> dimension.number_of_dims then do;
     8879 				call emit_operand (create_constant (int_mode, work));
     8880 				p = p + 1;
     8881 			     end;
     8882 
     8883 			     if p > 1 then
     8884 				call emit_operator (mult_op);
     8885 			end /* do loop number of dimesnions */;
     8886 		     end /* variable extents */;
     8887 		     else do;
     8888 			addr (work) -> based_integer = addr (work) -> based_integer * dp -> dimension.element_count;
     8889 			call emit_operand (create_constant (int_mode, work));
     8890 		     end;
     8891 		end /* dimension and array_name */;
     8892 		else
     8893 		     call emit_operand (create_constant (int_mode, work));
     8894 	     end /* not character */;
     8895 
     8896 	     call emit_operator (string_length_op);
     8897 	end /* from_encode_decode */;
     8898 
     8899 /* for internal_files from read/write, the code generator deals with length */
     8900 
     8901 	else do;
     8902 	     if io_bits.read then
     8903 		call emit_operator (read_internal_file_op);
     8904 	     else
     8905 		call emit_operator (write_internal_file_op);
     8906 	     if io_bits.mode = direct_access then
     8907 		call print_message (187, keyword_table (statement_type), "direct access and internal file");
     8908 	     else
     8909 		io_bits.mode = internal_file;
     8910 	end /* read-write internal files */;
     8911 
     8912      end get_internal_file;
     8913 
     8914 get_format:
     8915      procedure (fmt, allow_asterisk);
     8916 
     8917 /*	Program Specifications (get_format)
     8918*
     8919*     Inputs
     8920*
     8921*     Output
     8922*
     8923*     Description (get_format)
     8924**/
     8925 
     8926 dcl      fmt fixed bin (18);
     8927 declare	allow_asterisk bit (1) aligned;
     8928 
     8929 dcl      label_ptr fixed bin (18);
     8930 dcl      label_storage bit (5) aligned;
     8931 dcl      nl_ind fixed bin (18);
     8932 dcl      nl_off fixed bin (18);
     8933 declare	saved_polish fixed binary (18);
     8934 
     8935 	if io_bits.read then
     8936 	     label_storage = SET;
     8937 	else
     8938 	     label_storage = REF;
     8939 
     8940 	if substr (fields_specified, fmt_field, 1) then
     8941 	     call print_message (48, "format specifier or format label");
     8942 	substr (fields_specified, fmt_field, 1) = TRUE;
     8943 
     8944 	if token = dec_int				/* FORMAT STATEMENT LABEL */
     8945 	then do;
     8946 	     label_ptr = enter_label (format_label, (addr (work) -> based_integer), REF);
     8947 	     call emit_operand (label_ptr);
     8948 
     8949 	     call process_format_symbol (/* label_ptr */);
     8950 
     8951 	     call get_next_token$operator;		/* get comma or right paren */
     8952 	end;
     8953 
     8954 	else if token = ident then do;
     8955 	     label_ptr = fmt;
     8956 
     8957 	     if addr (OS (label_ptr)) -> symbol.namelist	/* NAMELIST REFERENCE */
     8958 	     then do;
     8959 
     8960 /* mark the group as used and force members into symbol table; add crossref entries for the namelist variables.  */
     8961 
     8962 		addr (OS (label_ptr)) -> symbol.allocate = TRUE;
     8963 		nl_off = addr (OS (label_ptr)) -> symbol.initial;
     8964 						/* offset into polish */
     8965 
     8966 		do nl_ind = nl_off + 1 to nl_off + polish_string (nl_off);
     8967 						/* loop thru members */
     8968 		     addr (OS (polish_string (nl_ind))) -> symbol.put_in_symtab = TRUE;
     8969 						/* force into symtab */
     8970 		     if produce_listing then
     8971 			call generate_cross_ref ((polish_string (nl_ind)));
     8972 
     8973 		     if io_bits.read then
     8974 			addr (OS (polish_string (nl_ind))) -> symbol.set = TRUE;
     8975 						/* if read, mark as set */
     8976 		end;				/* loop thru members */
     8977 
     8978 /* emit polish */
     8979 
     8980 		call emit_operand (label_ptr);
     8981 		if ^sub_ptr -> subprogram.options.optimize then
     8982 		     call emit_operator (namelist_op);
     8983 		else if io_bits.read then
     8984 		     call emit_operator (read_namelist_op);
     8985 		else
     8986 		     call emit_operator (write_namelist_op);
     8987 
     8988 		addr (OS (label_ptr)) -> symbol.bits.referenced = TRUE;
     8989 
     8990 		io_bits.format = namelist;		/* set type of I/O */
     8991 
     8992 		options.namelist_used = TRUE;		/* tell code generator namelist occurred */
     8993 		sub_ptr -> subprogram.namelist_used = TRUE;
     8994 						/* ditto */
     8995 
     8996 		call get_next_token$operator;		/* get comma or right paren */
     8997 	     end;					/* do block for namelist */
     8998 
     8999 	     else do;				/* VARIABLE REFERENCE */
     9000 		call parse_expression (format_reference, (label_ptr), out);
     9001 
     9002 		call process_format_symbol (/* label_ptr */);
     9003 
     9004 		if ^addr (OS (label_ptr)) -> symbol.attributes.mode_bits.mode.character
     9005 		     & addr (out) -> expression.not_simple_ref then
     9006 		     call print_message (143, label_ptr);
     9007 	     end;					/* do block for var ref */
     9008 	end;					/* do block for identifier */
     9009 
     9010 	else if token = char_string			/* CHARACTER STRING REFERENCE */
     9011 	then do;
     9012 
     9013 /* optimization: if the expression is a single char_string, at compile time we can create its format variable, much as if
     9014*   it were a dec_int, saving the work of the code generator */
     9015 
     9016 	     saved_polish = next_free_polish;
     9017 	     label_ptr = fmt;
     9018 	     call parse_expression (format_reference, label_ptr, out);
     9019 	     if next_free_polish > saved_polish + 1 then
     9020 		call process_format_symbol (/* label_ptr */);
     9021 	     else do;
     9022 		next_free_polish = saved_polish;
     9023 		label_ptr = build_symbol ((NO_NAME), format_label_attributes, label_storage);
     9024 		call create_format (addr (OS (fmt)) -> char_constant.value, label_ptr);
     9025 		call emit_operand (label_ptr);
     9026 		call process_format_symbol (/* label_ptr */);
     9027 	     end;
     9028 	end;
     9029 
     9030 	else if allow_asterisk & token = asterisk then do;
     9031 	     io_bits.format = list_directed;		/* set format */
     9032 	     call get_next_token$operator;		/* comma or right parn */
     9033 	end;
     9034 
     9035 	else do;
     9036 	     call print_message (88, err_string ());	/* syntax error */
     9037 	     go to statement_parse_abort;
     9038 	end;
     9039 
     9040 
     9041 process_format_symbol:
     9042      proc;
     9043 
     9044 /* Procedure to handle any weird stuff for format symbols. */
     9045 
     9046 	call emit_operator (format_op);
     9047 	io_bits.format = formatted;
     9048 
     9049 	if io_bits.read then
     9050 	     addr (OS (label_ptr)) -> symbol.set = TRUE;
     9051      end process_format_symbol;
     9052      end get_format;
     9053 
     9054 is_implied_loop:
     9055      procedure /* ( paren_info, paren_count, cur_paren, last_paren_parsed ) */ returns (bit (1) aligned);
     9056 
     9057 /*	Program Specifications
     9058*
     9059*
     9060*     Inputs
     9061*
     9062*	No explicit arguments.
     9063*	This routine assumes the current token is a left paren. It prescans the
     9064*	remaining tokens of the statement to determine if this paren begins an implied loop.
     9065*
     9066*
     9067*     Output
     9068*
     9069*	No explicit arguments.
     9070*	Implicit arguments:
     9071*	     paren_info - a structure, see notes below
     9072*	     paren_count - number of implied do loops encountered. If there were none, this field
     9073*		is set to one, and the first vector of the array appears to be a set of parens.
     9074*	     cur_paren - index into paren_info for current left paren
     9075*	     last_paren_parsed - set to last right paren scanned.
     9076*
     9077*
     9078*     Description (is_implied_loop)
     9079*
     9080*Notes:
     9081*	The structure paren_info contains the following subfields:
     9082*
     9083*	implied_loop - initially false; set to true if an equal sign encountered within this set of parens.
     9084*
     9085*	position - token index of left paren; e.i. - value of current_token for left paren.
     9086*
     9087*	chain - multi-purpose chain; while scanning, it is chain to containing paren for this set; as loops are
     9088*	     encountered, a left to right chain is made of the do loops.
     9089*
     9090*	begin_index - token index of last comma encountered before the equal sign; this is updated every time
     9091*	     a comma is encountered until an equal sign is encountered.
     9092**/
     9093 
     9094 dcl      j fixed bin (18);
     9095 dcl      last_do fixed bin (18);
     9096 dcl      previous fixed bin (18);
     9097 dcl      token bit (9) aligned;
     9098 
     9099 
     9100 /* if the current paren is enclosed in another set of parens, scanning is already done */
     9101 
     9102 	if current_token < last_paren_parsed then do;
     9103 
     9104 	     if paren_count = 0 then
     9105 		return (FALSE);			/* all scanned parens are not loops */
     9106 
     9107 /* must find info for current paren or there is a logic error */
     9108 
     9109 	     do cur_paren = cur_paren + 1 to paren_count;
     9110 		if paren_info (cur_paren).position = current_token then
     9111 		     return (paren_info (cur_paren).implied_loop);
     9112 	     end;
     9113 
     9114 	     call print_message (34);			/* apparent syntax error or logic error */
     9115 	     go to statement_parse_abort;
     9116 	end;
     9117 
     9118 /* this paren (and contained parens) has not been prescanned; do it now */
     9119 
     9120 	last_do = 0;				/* left to right chain of nested loops */
     9121 
     9122 	paren_count = 1;				/* current token is first left paren */
     9123 	cur_paren = 1;				/* current paren info is in first array slot */
     9124 
     9125 	paren_info (1).implied_loop = FALSE;		/* not yet determined to be an implied loop */
     9126 	paren_info (1).chain = 0;			/* no containing paren set exists */
     9127 	paren_info (1).position = current_token;	/* first paren is at current token position */
     9128 	paren_info (1).begin_index = 0;		/* no comma found yet */
     9129 
     9130 /* loop until matching right paren is found or end of statement */
     9131 
     9132 	do j = 1 to last_token - current_token;
     9133 
     9134 	     token = token_list (current_token + j).type;
     9135 
     9136 /* process left parenthesis */
     9137 
     9138 	     if token = left_parn then
     9139 		if paren_count >= hbound (paren_info, 1) then do;
     9140 		     call print_message (89, hbound (paren_info, 1) - bias);
     9141 						/* imp res - too many nested parens */
     9142 		     go to statement_parse_abort;
     9143 		end;
     9144 		else do;
     9145 		     paren_count = paren_count + 1;	/* stack a new set of parens */
     9146 		     paren_info (paren_count).implied_loop = FALSE;
     9147 		     paren_info (paren_count).chain = cur_paren;
     9148 						/* chain to previous left paren */
     9149 		     paren_info (paren_count).position = current_token + j;
     9150 						/* token index for left paren */
     9151 		     paren_info (paren_count).begin_index = 0;
     9152 						/* no comma found yet */
     9153 
     9154 		     cur_paren = paren_count;		/* becomes current set of parens */
     9155 		end;
     9156 
     9157 /* process right parenthesis */
     9158 
     9159 	     else if token = right_parn then do;
     9160 		if cur_paren = 0 then do;
     9161 		     call print_message (90);		/* mismatched parens - more right parens than left */
     9162 		     go to statement_parse_abort;
     9163 		end;
     9164 
     9165 		previous = paren_info (cur_paren).chain;/* save index of previous left paren */
     9166 
     9167 		if paren_info (cur_paren).implied_loop then do;
     9168 		     if last_do > 0 then
     9169 			paren_info (last_do).chain = cur_paren;
     9170 						/* forward chain of do loops */
     9171 		     last_do = cur_paren;
     9172 		end;
     9173 
     9174 		cur_paren = previous;		/* step to containing set of parens */
     9175 
     9176 /* if we closed first paren set, return */
     9177 
     9178 		if cur_paren = 0 then do;
     9179 		     if last_do > 0 then
     9180 			paren_info (last_do).chain = 0;
     9181 						/* last element of chain */
     9182 
     9183 		     cur_paren = 1;			/* paren of interest is first one */
     9184 		     last_paren_parsed = current_token + j;
     9185 						/*remember how far the stmnt has been scanned */
     9186 
     9187 		     if paren_count = 0 then
     9188 			return (FALSE);		/* all parens encountered are not loops */
     9189 		     return (paren_info (1).implied_loop);
     9190 		end;
     9191 	     end;
     9192 
     9193 /* check for comma and assign tokens only if assign token not yet encountered */
     9194 
     9195 	     else if ^paren_info (cur_paren).implied_loop then
     9196 		if token = comma then
     9197 		     paren_info (cur_paren).begin_index = current_token + j;
     9198 						/* remember last comma */
     9199 
     9200 		else if token = assign then
     9201 		     if paren_info (cur_paren).begin_index ^= 0
     9202 						/* make sure comma has been encountered */
     9203 			then
     9204 			paren_info (cur_paren).implied_loop = TRUE;
     9205 		     else do;
     9206 			call print_message (91);	/* syntax error in implied loop */
     9207 			go to statement_parse_abort;
     9208 		     end;
     9209 	end;
     9210 
     9211 /* loop exits here only if parens are not matched */
     9212 
     9213 	call print_message (90);			/* mismatched parens - too few right parens */
     9214 	go to statement_parse_abort;
     9215      end is_implied_loop;
     9216 
     9217 parse_io_list:
     9218      procedure;
     9219 
     9220 /*	Program Specifications (parse_io_list)
     9221*
     9222*     Inputs
     9223*
     9224*     Output
     9225*
     9226*     Description (parse_io_list)
     9227**/
     9228 
     9229 dcl      element_type bit (36) aligned;
     9230 dcl      in_list bit (1) aligned;
     9231 dcl      io_ele fixed bin (18);
     9232 dcl      last_do fixed bin (18);
     9233 dcl      need_comma bit (1) aligned;
     9234 dcl      need_element bit (1) aligned;
     9235 
     9236 	if current_token < last_token then
     9237 	     io_bits.list = TRUE;
     9238 	else
     9239 	     current_token = current_token + 1;		/* current token has been parsed */
     9240 
     9241 	call emit_operand (create_constant (int_mode, string (io_bits)));
     9242 
     9243 	if io_bits.read then do;			/* a read statement */
     9244 	     call emit_operator (read_op);
     9245 	     element_type = input_element;
     9246 	end;
     9247 	else do;					/* a write statement */
     9248 	     call emit_operator (write_op);
     9249 	     element_type = output_element;
     9250 	end;
     9251 
     9252 /* process I/O list or return */
     9253 
     9254 	if io_bits.list then do;
     9255 	     if io_bits.format = namelist then
     9256 		call print_message (145, keyword_table (statement_type));
     9257 						/* list is illegal */
     9258 	end;
     9259 	else do;
     9260 	     if io_bits.mode = string_io then
     9261 		call print_message (146, keyword_table (statement_type));
     9262 						/* list is required */
     9263 	     return;
     9264 	end;
     9265 
     9266 	last_paren_parsed = 0;			/* indicates no prescan has occurred */
     9267 	last_do = 0;
     9268 
     9269 	in_list = TRUE;
     9270 	do while (in_list);
     9271 	     call get_next_token (force_symtab_entry, io_ele);
     9272 	     if token = left_parn then
     9273 		if is_implied_loop ()		/* Modifies paren_info, paren_count, cur_paren, last_paren_parsed */
     9274 		then do;
     9275 		     save_current_token = current_token;
     9276 		     current_token = paren_info (cur_paren).begin_index;
     9277 						/* move up to do_loop specs */
     9278 		     call get_next_token (force_symtab_entry, io_ele);
     9279 
     9280 		     call parse_expression (set_reference, io_ele, out);
     9281 
     9282 		     if addr (out) -> expression.subscripted_ref then
     9283 			call print_message (25, io_ele);
     9284 
     9285 		     call get_next_token (force_symtab_entry, io_ele);
     9286 		     call parse_expression (any_expression, io_ele, ignore_bits);
     9287 		     if token ^= comma then
     9288 			go to missing_comma;
     9289 
     9290 		     call get_next_token (force_symtab_entry, io_ele);
     9291 		     call parse_expression (any_expression, io_ele, ignore_bits);
     9292 		     if token = comma then do;
     9293 			call get_next_token (force_symtab_entry, io_ele);
     9294 			call parse_expression (any_expression, io_ele, ignore_bits);
     9295 		     end;
     9296 		     else
     9297 			call emit_operand (value_1);
     9298 		     if token ^= right_parn then
     9299 			go to missing_right_paren;
     9300 
     9301 		     call emit_operator (do_op);
     9302 		     paren_info (cur_paren).position = current_token;
     9303 		     current_token = save_current_token;
     9304 		     need_element = FALSE;
     9305 		     last_do = cur_paren;
     9306 		end;
     9307 		else
     9308 		     need_element = TRUE;		/* paren is part of expression */
     9309 	     else
     9310 		need_element = TRUE;		/* obviously not an implied do loop */
     9311 
     9312 	     if need_element then do;
     9313 		call parse_expression (element_type, io_ele, out);
     9314 
     9315 		if addr (out) -> expression.array_name then
     9316 		     call emit_operator (xmit_array_op);
     9317 		else
     9318 		     call emit_operator (xmit_scalar_op);
     9319 
     9320 		need_comma = TRUE;
     9321 		do while (need_comma & in_list);
     9322 		     if token ^= comma then
     9323 			in_list = FALSE;
     9324 		     else if last_do > 0 & current_token = paren_info (last_do).begin_index then do;
     9325 			current_token = paren_info (last_do).position;
     9326 			last_do = paren_info (last_do).chain;
     9327 			call emit_operator (exit_op);
     9328 			call get_next_token$operator; /* get comma or eos */
     9329 		     end;
     9330 		     else
     9331 			need_comma = FALSE;
     9332 		end /* item_op loop */;
     9333 	     end /* parse list element */;
     9334 	end /* list loop */;
     9335 
     9336 	if last_do ^= 0 then
     9337 	     call print_message (91);			/* syntax error in implied loop */
     9338 
     9339 	call emit_operator (terminate_op);
     9340      end parse_io_list;
     9341 
     9342 parse_open_field:
     9343      procedure (field_no, expression_type);
     9344 
     9345 dcl      field_no fixed bin;
     9346 declare	expression_type bit (36) aligned;
     9347 dcl      field_number fixed bin (18);
     9348 dcl      first_sym fixed bin (18);
     9349 
     9350 /* parse the fields in open and possibly other i/o statments.  The field numbers of fields_specified are listed in the
     9351*   include file fortran_io_consts.  Changes must be made consistently with EP, FIO, pl1_ops, and the code generators. 
     9352**/
     9353 
     9354 	field_number = field_no;
     9355 
     9356 	if substr (fields_specified, field_number, 1) = TRUE then
     9357 	     call print_message (48, substr (full_name, 1, symbol_length));
     9358 
     9359 	substr (fields_specified, field_number, 1) = TRUE;
     9360 
     9361 	call get_next_token$operator;
     9362 	if token ^= assign then
     9363 	     go to missing_equals_sign;
     9364 
     9365 	call get_next_token (force_symtab_entry, first_sym);
     9366 	call parse_expression (expression_type, first_sym, ignore_bits);
     9367 
     9368 	call emit_halfword (field_number - bias);
     9369 	call emit_operator (item_op);
     9370 
     9371 	count = count + 1;
     9372      end parse_open_field;
     9373 
     9374 scan_label_list:
     9375      procedure (build_list);
     9376 
     9377 /*	Program Specifications (scan_label_list)
     9378*
     9379*     Inputs
     9380*
     9381*     Output
     9382*
     9383*     Description (scan_label_list)
     9384**/
     9385 
     9386 dcl      count fixed bin (18);
     9387 dcl      word_offset fixed bin (18);
     9388 dcl      build_list bit (1) aligned;
     9389 dcl      in_list bit (1) aligned;
     9390 dcl      label_ptr fixed bin (18);
     9391 dcl      list_bits bit (5) aligned;
     9392 
     9393 	if build_list				/* list of lbls will be emitted in polish */
     9394 	then do;
     9395 	     list_bits = GOTO_REF;			/* computed goto IS goto_ref */
     9396 
     9397 	     call emit_count (word_offset);
     9398 	     count = 0;
     9399 	     call emit_operator (jump_computed_op);
     9400 	end;
     9401 	else
     9402 	     list_bits = DECLARED;			/* assigned goto is NOT goto_ref */
     9403 
     9404 	in_list = TRUE;
     9405 	do while (in_list);
     9406 	     call get_next_token$label (ignore_symtab_entry, ignore_value);
     9407 	     if token ^= dec_int then
     9408 		go to missing_label;
     9409 
     9410 	     label_ptr = enter_label (executable_label, (addr (work) -> based_integer), list_bits);
     9411 
     9412 	     call get_next_token$operator;		/* get comma or right paren */
     9413 	     count = count + 1;
     9414 	     if token ^= comma then
     9415 		in_list = FALSE;
     9416 
     9417 	     if list_bits ^= DECLARED then do;
     9418 		call emit_operand (label_ptr);
     9419 		call emit_operator (item_op);
     9420 
     9421 		if ^in_list then do;
     9422 		     call emit_operator (eol_op);
     9423 		     polish_string (word_offset) = count - bias;
     9424 		end;
     9425 	     end;
     9426 	end;
     9427 	if token ^= right_parn then
     9428 	     go to missing_right_paren;
     9429 
     9430      end scan_label_list;
     9431 
     9432 get_bounds:
     9433      procedure (symb);
     9434 
     9435 /*	Program Specifications (get_bounds)
     9436*
     9437*     Inputs
     9438*
     9439*     Output
     9440*
     9441*     Description (get_bounds)
     9442*
     9443*NB - An entire dimension node may not be allocated. Only enough words are allocated
     9444*for the actual number of dimensions.
     9445*
     9446*	explain use of positive and negative
     9447**/
     9448 
     9449 declare	assumed_size_index fixed bin (18);
     9450 dcl      bound_error bit (1) aligned;
     9451 dcl      count fixed bin (18);
     9452 dcl      dim_node fixed bin (18);
     9453 declare	dim_size fixed bin (24);
     9454 dcl      dp pointer;
     9455 dcl      ele_cnt fixed bin (48);
     9456 declare	error_code fixed binary (35);
     9457 dcl      indx fixed bin (18);
     9458 dcl      in_list bit (1) aligned;
     9459 declare	size builtin;
     9460 dcl      symb fixed bin (18);
     9461 dcl      sp pointer;
     9462 dcl      var_bounds bit (1) aligned;
     9463 
     9464 declare	1 bounds (7) aligned like dimension.dim;
     9465 declare	1 v_bounds (7) aligned like dimension.v_bound;
     9466 
     9467 	count = 0;
     9468 	ele_cnt = 1;
     9469 	var_bounds = FALSE;
     9470 	assumed_size_index = 0;
     9471 	bounds = 0;
     9472 	v_bounds = ""b;
     9473 
     9474 	bound_error = ^declare_symbol (symb, dim_attr, dim_conflicts, DECLARED);
     9475 
     9476 	if bound_error then
     9477 	     call print_message (30, "dimension", symb);	/* redundant declaration */
     9478 
     9479 	in_list = TRUE;
     9480 	do while (in_list);
     9481 	     count = count + 1;
     9482 	     if count = hbound (bounds, 1) then
     9483 		in_list = FALSE;
     9484 
     9485 /* get the next declarator, check for errors.  Assume it  is upper bound, can change later if required */
     9486 
     9487 	     call get_next_token (force_symtab_entry, indx);
     9488 
     9489 	     if token = asterisk then
     9490 		call check_assumed_size;
     9491 	     else do;
     9492 		call get_one_bound (indx, bounds (count).upper_bound, v_bounds (count).upper, error_code);
     9493 
     9494 		if error_code ^= 0 then do;
     9495 		     call print_message (169, symb);
     9496 		     bound_error = TRUE;
     9497 		end;
     9498 		else if ^v_bounds (count).upper then
     9499 		     call check_size;
     9500 
     9501 	     end /* not asterisk */;
     9502 
     9503 	     if token = colon then do;		/* this dimension has user defined lower bound */
     9504 		if assumed_size_index = count		/* asterisk in lower bound */
     9505 		     then
     9506 		     call print_message (167, symb);
     9507 
     9508 		bounds (count).lower_bound = bounds (count).upper_bound;
     9509 		bounds (count).upper_bound = 0;
     9510 		v_bounds (count).lower = v_bounds (count).upper;
     9511 		v_bounds (count).upper = FALSE;
     9512 
     9513 /* get the upper bound information and do error checking */
     9514 
     9515 		call get_next_token (force_symtab_entry, indx);
     9516 
     9517 		if token = asterisk then
     9518 		     call check_assumed_size;
     9519 		else do;
     9520 		     call get_one_bound (indx, bounds (count).upper_bound, v_bounds (count).upper, error_code);
     9521 		     if error_code ^= 0 then do;
     9522 			call print_message (169, symb);
     9523 			bound_error = TRUE;
     9524 		     end;
     9525 		     else if ^v_bounds (count).upper then
     9526 			call check_size;
     9527 
     9528 		end /* not asterisk in upper bound */;
     9529 	     end /* token = colon */;
     9530 	     else do;
     9531 
     9532 /* if no colon, the bounds we see are the upper bounds - set the lower to 1 */
     9533 
     9534 		bounds (count).lower_bound = 1;
     9535 		v_bounds (count).lower = FALSE;
     9536 	     end;
     9537 
     9538 /* if both bounds are not variable or assumed-size, then compute size, otherwise set var_bounds */
     9539 
     9540 	     if string (v_bounds (count)) = ""b then do;
     9541 		dim_size = bounds (count).upper_bound - bounds (count).lower_bound + 1;
     9542 		if dim_size < 1			/* lower bnd > upper bnd */
     9543 		then do;
     9544 		     call print_message (168, symb);
     9545 		     bound_error = TRUE;
     9546 		     dim_size = 1;
     9547 		end;
     9548 		ele_cnt = ele_cnt * dim_size;
     9549 		bounds (count).size = dim_size;
     9550 		if ele_cnt > max_fixed_bin_24		/* prevent overflow */
     9551 		     then
     9552 		     ele_cnt = max_fixed_bin_24 + 1;
     9553 	     end;
     9554 	     else
     9555 		var_bounds = TRUE;
     9556 
     9557 /* see if any other bounds */
     9558 
     9559 	     if token ^= comma then
     9560 		in_list = FALSE;
     9561 	end /* do while (in_list) */;
     9562 
     9563 	if token ^= right_parn then
     9564 	     go to missing_right_paren;
     9565 
     9566 	call get_next_token (ignore_symtab_entry, ignore_value);
     9567 
     9568 	if assumed_size_index ^= 0 then
     9569 	     if assumed_size_index ^= count		/* assumed size in non-final  dimension */
     9570 	     then do;
     9571 		call print_message (167, symb);
     9572 		bound_error = TRUE;
     9573 	     end;
     9574 	     else
     9575 		var_bounds = TRUE;
     9576 
     9577 	if bound_error then
     9578 	     return;
     9579 
     9580 	num_dims = count;
     9581 	dim_node = create_node (dimension_node, size (dimension));
     9582 	dp = addr (OS (dim_node));
     9583 	dp -> dimension.number_of_dims = count;
     9584 	dp -> dimension.assumed_size = (assumed_size_index ^= 0);
     9585 
     9586 	sp = addr (OS (symb));
     9587 	sp -> symbol.dimension = dim_node;
     9588 	sp -> symbol.variable_extents = var_bounds;
     9589 
     9590 	do i = 1 to num_dims;
     9591 	     dp -> dimension.dim (i) = bounds (i);
     9592 	     dp -> dimension.v_bound (i) = v_bounds (i);
     9593 	end;
     9594 
     9595 	if ^var_bounds				/* store the element count if constant and in range */
     9596 	     then
     9597 	     if ele_cnt <= max_fixed_bin_24 then
     9598 		dp -> dimension.element_count = ele_cnt;
     9599 	     else
     9600 		call print_message (136, "length", symb, ltrim (char (max_fixed_bin_24)));
     9601 						/* array is too long */
     9602 	return;
     9603 
     9604 check_assumed_size:
     9605      procedure;
     9606 	if assumed_size_index ^= 0			/* second assumed size in this array */
     9607 	then do;
     9608 	     call print_message (167, symb);
     9609 	     bound_error = TRUE;
     9610 	end;
     9611 	else do;
     9612 	     assumed_size_index = count;
     9613 	     v_bounds (count).upper = TRUE;
     9614 	     call get_next_token$operator;
     9615 	end;
     9616 	return;
     9617      end check_assumed_size;
     9618 
     9619 check_size:
     9620      procedure;
     9621 
     9622 	if abs (bounds (count).upper_bound) > max_fixed_bin_24 then do;
     9623 	     call print_message (136, "magnitude of an array bound", symb, ltrim (char (max_fixed_bin_24)));
     9624 	     if bounds (count).upper_bound > 0 then
     9625 		bounds (count).upper_bound = max_fixed_bin_24;
     9626 	     else
     9627 		bounds (count).upper_bound = -max_fixed_bin_24;
     9628 	end;
     9629      end check_size;
     9630 
     9631 get_one_bound:
     9632      procedure (indx, bound, bound_is_variable, err_code);
     9633 
     9634 /* Parse one bound of an array declaration and, if the syntax of the bound
     9635*   is correct (i.e. is an arithmetic expression of integer constants and
     9636*   scalar variables), return either the value of the bound (if constant) or
     9637*   the index of a symbol for the value of the bound.  If the bound is not
     9638*   a constant or a constant expression, an anonymous automatic integer
     9639*   variable is created to hold the value of the bound, unless the bound
     9640*   is a scalar variable and we are in '66 mode, in which case we just use
     9641*   the variable.  If we create a variable to hold the bound, the index of
     9642*   the Polish to initialize it is stored in the 'initial' field of its
     9643*   symbol node.  This Polish is preceded by an 'increment_polish' operator
     9644*   to "hide" it from the code generator.  The 'process_pending_entries'
     9645*   routine is responsible for generating the assignment to initialize a
     9646*   compiler generated array bound variable at the appropriate point in
     9647*   the entry sequence. */
     9648 
     9649 dcl      indx fixed bin (18),				/* INPUT: index of initial symbol in expression */
     9650          bound fixed bin (24),			/* OUTPUT: if bound is constant then its value else indx of its symbol */
     9651          bound_is_variable bit (1),			/* OUTPUT: "1"b if bound is not constant */
     9652          err_code fixed binary (35);			/* OUTPUT: error code */
     9653 
     9654 dcl      Invalid_operand fixed bin (35) static options (constant) init (1),
     9655          Invalid_operator fixed bin (35) static options (constant) init (2);
     9656 
     9657 dcl      idx_of_expression fixed bin (18),
     9658          idx_of_increment_polish_op fixed bin (18),
     9659          opnd_ptr ptr,
     9660          polish_idx fixed bin (18);
     9661 
     9662 
     9663 	idx_of_increment_polish_op = next_free_polish;
     9664 	call increment_polish (2);
     9665 	idx_of_expression = next_free_polish;
     9666 	call parse_expression (set_no_symbol_bits, indx, out);
     9667 
     9668 	err_code = 0;
     9669 	do polish_idx = idx_of_expression to next_free_polish - 1 while (err_code = 0);
     9670 	     if polish_string (polish_idx) > last_assigned_op then do;
     9671 						/* Found an operand; check if it is valid. */
     9672 		opnd_ptr = addr (OS (polish_string (polish_idx)));
     9673 		if opnd_ptr -> node.data_type ^= 0 then
     9674 		     if opnd_ptr -> node.data_type ^= int_mode then
     9675 			err_code = Invalid_operand;
     9676 	     end;
     9677 	     else if polish_string (polish_idx) < add_op | polish_string (polish_idx) > negate_op then
     9678 		err_code = Invalid_operator;
     9679 	end;
     9680 
     9681 	bound = 0;
     9682 	bound_is_variable = addr (out) -> expression.not_constant;
     9683 	if err_code ^= 0 then
     9684 	     next_free_polish = idx_of_increment_polish_op;
     9685 	else if bound_is_variable then
     9686 	     if next_free_polish > idx_of_expression + 1 | subr_options.ansi_77 then do;
     9687 						/* Generate an anonymous variable to receive the bound. */
     9688 		bound = build_symbol ((NO_NAME), v_length_attributes, SET);
     9689 		addr (OS (bound)) -> symbol.initial = idx_of_expression;
     9690 		polish_string (idx_of_increment_polish_op + 1) = next_free_polish - idx_of_expression;
     9691 	     end;
     9692 	     else do;				/* Use the scalar variable as the bound. */
     9693 		bound = indx;
     9694 		next_free_polish = idx_of_increment_polish_op;
     9695 	     end;
     9696 	else if next_free_polish > idx_of_expression + 1
     9697 	     | addr (OS (polish_string (idx_of_expression))) -> constant.data_type ^= int_mode then do;
     9698 						/* Reduce the expression to an integer value. */
     9699 	     parameter_info.desired_data_type = int_mode;
     9700 	     parameter_info.max_stack = max_stack;
     9701 	     parameter_info.stack_index = stack_index;
     9702 	     parameter_info.start_of_polish = idx_of_expression;
     9703 	     parameter_info.end_of_polish = next_free_polish - 1;
     9704 	     parameter_info.rounding = subr_options.do_rounding;
     9705 
     9706 	     call fort_eval_parm (addr (parameter_info), "an integer constant expression", err_code);
     9707 	     max_stack = parameter_info.max_stack;
     9708 
     9709 	     if err_code = 0 then
     9710 		unspec (bound) = addr (OS (parameter_info.result_location)) -> constant.value;
     9711 	     next_free_polish = idx_of_increment_polish_op;
     9712 	end;
     9713 	else do;					/* Use the integer value as the bound. */
     9714 	     unspec (bound) = addr (OS (polish_string (idx_of_expression))) -> constant.value;
     9715 	     next_free_polish = idx_of_increment_polish_op;
     9716 	end;
     9717 
     9718      end get_one_bound;
     9719      end get_bounds;
     9720 
     9721 get_integer_constant:
     9722      procedure (indx, allow_variables, value, variable_found, err_code);
     9723 declare	indx fixed bin (18);			/* INPUT: index of initial symbol in expression */
     9724 declare	allow_variables bit (1);			/* INPUT: "1"b iff scalar integer expressions permitted */
     9725 declare	value fixed bin (24);			/* OUTPUT: value or (symbol index, if variable_found set) */
     9726 declare	variable_found bit (1);			/* OUTPUT: "1"b if non-constant found and allowed */
     9727 declare	err_code fixed binary (35);			/* OUTPUT: error code */
     9728 
     9729 declare	sp pointer;
     9730 declare	ILLEGAL_EXPRESSION_FOUND fixed binary (35) internal static options (constant) initial (1);
     9731 
     9732 
     9733 /* parses the next expression in the input stream, usually searching for integer constants or constant expressions which
     9734*   it converts to constants via fort_eval_parm.  Optionally allows scalars integer variables as well, 
     9735*   and if permitted and found, it sets variable_found TRUE.   
     9736**/
     9737 	variable_found = FALSE;
     9738 	err_code = 0;
     9739 
     9740 	parameter_info.start_of_polish = next_free_polish;
     9741 
     9742 	call parse_expression (set_no_symbol_bits, indx, out);
     9743 
     9744 /* result can be either constant expression or simple scalar variable.
     9745*   if it is not a simple_ref
     9746*   then if not constant, it is a  error
     9747*        else it's a constant expression
     9748*	 if only one operand and it is an integer constant
     9749*	 then simply get its value.
     9750*	 else it is a constant expression of more than term
     9751*	      call fort_eval_parm to get its value.
     9752*   else its a simple ref
     9753*        cant be a substr or subscripted ref
     9754*        must be a simple variable.
     9755**/
     9756 
     9757 	if addr (out) -> expression.not_simple_ref then do;
     9758 	     if addr (out) -> expression.not_constant then
     9759 		err_code = ILLEGAL_EXPRESSION_FOUND;
     9760 
     9761 	     else do;				/* constant expression */
     9762 		sp = addr (OS (polish_string (parameter_info.start_of_polish)));
     9763 
     9764 /* if bound is a single integer constant simply gets its value */
     9765 
     9766 		if next_free_polish = parameter_info.start_of_polish + 1 & sp -> constant.data_type = int_mode then
     9767 		     unspec (value) = sp -> constant.value;
     9768 		else do;
     9769 		     parameter_info.desired_data_type = int_mode;
     9770 		     parameter_info.max_stack = max_stack;
     9771 		     parameter_info.stack_index = stack_index;
     9772 		     parameter_info.end_of_polish = next_free_polish - 1;
     9773 		     parameter_info.rounding = subr_options.do_rounding;
     9774 
     9775 		     call fort_eval_parm (addr (parameter_info), "an integer constant expression", err_code);
     9776 		     max_stack = parameter_info.max_stack;
     9777 
     9778 		     if err_code = 0 then
     9779 			unspec (value) = addr (OS (parameter_info.result_location)) -> constant.value;
     9780 		end /* complex constant expression */;
     9781 	     end /* constant expression */;
     9782 	end /* not simple reference */;
     9783 	else do;					/* simple reference */
     9784 	     if addr (out) -> expression.substring_ref | addr (out) -> expression.subscripted_ref
     9785 						/* must be scalar ref */
     9786 		then
     9787 		err_code = ILLEGAL_EXPRESSION_FOUND;
     9788 	     else do;
     9789 		variable_found = TRUE;
     9790 		if allow_variables then
     9791 		     value = indx;
     9792 		else
     9793 		     err_code = ILLEGAL_EXPRESSION_FOUND;
     9794 	     end;
     9795 	end;
     9796 	next_free_polish = parameter_info.start_of_polish;
     9797 
     9798      end get_integer_constant;
     9799 
     9800 stack_operand:
     9801 stack_operator:
     9802      procedure (op_code_or_operand);
     9803 
     9804 dcl      op_code_or_operand fixed bin (18);
     9805 
     9806 	if stack_index > hbound (stack, 1) then
     9807 	     call print_message (67, "stack", hbound (stack, 1) - bias);
     9808 						/* stack overflow */
     9809 	stack (stack_index) = op_code_or_operand;
     9810 	stack_index = stack_index + 1;
     9811 	max_stack = max (stack_index, max_stack);
     9812      end stack_operator;
     9813 
     9814 build_symbol:
     9815      procedure (name, attributes, storage_bits) returns (fixed bin (18));
     9816 
     9817 dcl      name char (256) varying;
     9818 dcl      attributes bit (47) aligned;
     9819 dcl      storage_bits bit (5) aligned;
     9820 dcl      sym_indx fixed bin (18);
     9821 dcl      sym_ptr pointer;
     9822 dcl      count_pic picture "9999";
     9823 
     9824 	allocate_symbol_name = length (name);
     9825 	sym_indx = create_node (symbol_node, size (symbol));
     9826 	sym_ptr = addr (OS (sym_indx));
     9827 
     9828 	if sub_ptr -> last_symbol = 0 then
     9829 	     sub_ptr -> first_symbol = sym_indx;
     9830 	else
     9831 	     addr (OS (sub_ptr -> last_symbol)) -> symbol.next_symbol = sym_indx;
     9832 	sub_ptr -> last_symbol = sym_indx;
     9833 
     9834 	unspec (sym_ptr -> symbol.attributes) = attributes;
     9835 	string (sym_ptr -> symbol.storage_info) = storage_bits;
     9836 	sym_ptr -> symbol.by_compiler = TRUE;		/* indicate declared by compiler */
     9837 
     9838 	sym_ptr -> symbol.name_length = allocate_symbol_name;
     9839 
     9840 	if substr (name, 1, length (NO_NAME)) = NO_NAME then do;
     9841 	     substr (sym_ptr -> symbol.name, 1, 4) = "ftn.";
     9842 	     cp_count = cp_count + 1;
     9843 	     count_pic = cp_count;
     9844 	     substr (sym_ptr -> symbol.name, 5, 4) = count_pic;
     9845 	end;
     9846 	else
     9847 	     substr (sym_ptr -> symbol.name, 1, allocate_symbol_name) = name;
     9848 
     9849 	if produce_listing then
     9850 	     call generate_cross_ref (sym_indx);
     9851 
     9852 	return (sym_indx);
     9853      end build_symbol;
     9854 
     9855 /* 08 Mar 86, SH - 410: The bif_table.external has been updated. This table
     9856*                        defines the validity of builtins for use as external
     9857*                        entry references.*/
     9858 builtin_lookup:
     9859      procedure (indx, set_attributes) returns (bit (1) aligned);
     9860 
     9861 dcl      bif_dt fixed bin (18);
     9862 dcl      bif_name char (8) aligned;
     9863 dcl      bif_ptr pointer;
     9864 dcl      i fixed bin (18);
     9865 dcl      indx fixed bin (18);
     9866 dcl      lower fixed bin (18);
     9867 dcl      not_found bit (1) aligned;
     9868 dcl      set_attributes bit (1);
     9869 dcl      upper fixed bin (18);
     9870 
     9871 /* format: off */
     9872 
     9873 dcl	1 bif_table	(95) aligned int static options (constant),
     9874 	  2 name		char (8) aligned init (
     9875 			"abs     ", "acos    ", "aimag   ", "aint    ", "alog    ", "alog10  ", "amax0   ", "amax1   ",
     9876 			"amin0   ", "amin1   ", "amod    ", "and     ", "anint   ", "asin    ", "atan    ", "atan2   ",
     9877 			"bool    ", "cabs    ", "ccos    ", "cexp    ", "char    ", "clog    ", "cmplx   ", "compl   ",
     9878 			"conjg   ", "cos     ", "cosh    ", "csin    ", "csqrt   ", "dabs    ", "dacos   ", "dasin   ",
     9879 			"datan   ", "datan2  ", "dble    ", "dcos    ", "dcosh   ", "ddim    ", "dexp    ", "dim     ",
     9880 			"dint    ", "dlog    ", "dlog10  ", "dmax1   ", "dmin1   ", "dmod    ", "dnint   ", "dprod   ",
     9881 			"dsign   ", "dsin    ", "dsinh   ", "dsqrt   ", "dtan    ", "dtanh   ", "exp     ", "fld     ",
     9882 			"float   ", "iabs    ", "ichar   ", "idim    ", "idint   ", "idnint  ", "ifix    ", "ilr     ",
     9883 			"ils     ", "index   ", "int     ", "irl     ", "irs     ", "isign   ", "len     ", "lge     ",
     9884 			"lgt     ", "lle     ", "llt     ", "log     ", "log10   ", "max     ", "max0    ", "max1    ",
     9885 			"min     ", "min0    ", "min1    ", "mod     ", "nint    ", "or      ", "real    ", "sign    ",
     9886 			"sin     ", "sinh    ", "sngl    ", "sqrt    ", "tan     ", "tanh    ", "xor     "),
     9887 	  2 external	bit (1) unaligned init (
     9888 			"1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b,
     9889 			"0"b, "0"b, "1"b, "0"b, "1"b, "1"b, "1"b, "1"b,
     9890 			"0"b, "1"b, "1"b, "1"b, "0"b, "1"b, "0"b, "0"b,
     9891 			"1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "1"b,
     9892 			"1"b, "1"b, "0"b, "1"b, "1"b, "1"b, "1"b, "1"b,
     9893 			"1"b, "1"b, "1"b, "0"b, "0"b, "1"b, "1"b, "1"b,
     9894 			"1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "0"b,
     9895 			"0"b, "1"b, "0"b, "1"b, "0"b, "1"b, "0"b, "1"b,
     9896 			"1"b, "1"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b,
     9897 			"0"b, "0"b, "0"b, "1"b, "1"b, "0"b, "0"b, "0"b,
     9898 			"0"b, "0"b, "0"b, "1"b, "1"b, "0"b, "0"b, "1"b,
     9899 			"1"b, "1"b, "0"b, "1"b, "1"b, "1"b, "0"b),
     9900 	  2 pad		bit (3) unaligned init ((95) (3)"0"b),
     9901 	  2 data_type	fixed bin (4) unaligned init (
     9902 			0, 0, 2, 0, 0, 0, 2, 2,
     9903 			2, 2, 2, 7, 0, 0, 0, 0,
     9904 			7, 2, 4, 4, 6, 4, 4, 7,
     9905 			4, 0, 0, 4, 4, 3, 3, 3,
     9906 			3, 3, 3, 3, 3, 3, 3, 2,
     9907 			3, 3, 3, 3, 3, 3, 3, 3,
     9908 			3, 3, 3, 3, 3, 3, 0, 7,
     9909 			2, 1, 1, 1, 1, 1, 1, 1,
     9910 			1, 1, 1, 1, 1, 1, 1, 5,
     9911 			5, 5, 5, 0, 0, 0, 1, 1,
     9912 			0, 1, 1, 0, 0, 7, 2, 2,
     9913 			0, 0, 2, 0, 0, 0, 7),
     9914 	  2 index		fixed bin (8) unaligned init (
     9915 			001, 063, 055, 049, 005, 008, 024, 025,
     9916 			030, 031, 036, 084, 079, 061, 010, 012,
     9917 			085, 004, 016, 022, 065, 007, 057, 086,
     9918 			058, 014, 073, 043, 046, 003, 064, 062,
     9919 			011, 013,	056, 015, 075, 019, 021, 017,
     9920 			078, 006,	009, 028, 034, 037, 080, 083,
     9921 			040, 042,	076, 045, 060, 077, 020, 087,
     9922 			051, 002, 066, 018, 050, 082, 052, 088,
     9923 			089, 067, 048, 090, 091, 039, 068, 069,
     9924 			070, 071, 072, 005, 008, 023, 026, 027,
     9925 			029, 032, 033, 035, 081, 092, 054, 038,
     9926 			041, 074, 053, 044, 059, 047, 093);
     9927 
     9928 /* format: revert */
     9929 
     9930 	bif_ptr = addr (OS (indx));
     9931 
     9932 	if bif_ptr -> symbol.builtin then
     9933 	     return (TRUE);
     9934 	else if bif_ptr -> symbol.external then
     9935 	     return (FALSE);
     9936 
     9937 	if (unspec (bif_ptr -> symbol.attributes) & bif_conflicts) ^= ZERO then
     9938 	     return (FALSE);
     9939 
     9940 	if bif_ptr -> symbol.name_length > length (bif_name) then
     9941 	     return (FALSE);
     9942 	bif_name = bif_ptr -> symbol.name;
     9943 	i = 1;
     9944 	lower = 1;
     9945 	upper = hbound (bif_table, 1);
     9946 
     9947 	not_found = TRUE;
     9948 	do while (not_found);
     9949 	     if bif_name = bif_table (i).name then
     9950 		not_found = FALSE;
     9951 	     else do;
     9952 		if bif_name < bif_table (i).name then do;
     9953 		     upper = i;
     9954 		     i = i - divide (upper - lower + 1, 2, 17, 0);
     9955 		end;
     9956 		else do;
     9957 		     lower = i;
     9958 		     i = i + divide (upper - lower + 1, 2, 17, 0);
     9959 		end;
     9960 		if i = lower then
     9961 		     return (FALSE);
     9962 	     end;
     9963 	end;
     9964 
     9965 	bif_dt = bif_table (i).data_type;
     9966 
     9967 	if bif_dt ^= 0 then
     9968 	     if unspec (bif_ptr -> symbol.mode_bits) ^= ZERO then
     9969 		if (unspec (bif_ptr -> symbol.attributes) & attr_table (bif_dt)) = ZERO then
     9970 		     return (FALSE);		/* Data types differ. */
     9971 
     9972 	if bif_ptr -> symbol.referenced then do;
     9973 	     call print_message (93, indx);		/* cannot become a bif */
     9974 	     return (FALSE);
     9975 	end;
     9976 
     9977 /* symbol.char_size holds the number of the builtin */
     9978 
     9979 	if (set_attributes) then do;
     9980 	     bif_ptr -> symbol.char_size = bif_table (i).index;
     9981 	     bif_ptr -> symbol.builtin = TRUE;
     9982 	     bif_ptr -> symbol.external = bif_table (i).external;
     9983 	     if unspec (bif_ptr -> symbol.mode_bits) = ZERO then
     9984 		unspec (bif_ptr -> symbol.attributes) = unspec (bif_ptr -> symbol.attributes) | attr_table (bif_dt);
     9985 	end;
     9986 
     9987 	return (TRUE);
     9988      end builtin_lookup;
     9989 
     9990 parse_expression:
     9991      procedure (control_bits, save_index, return_bits);	/* Not audited. */
     9992 
     9993 /*	Program Specifications (parse_expr)
     9994*
     9995*     Inputs
     9996*
     9997*     Output
     9998*
     9999*     Description (parse_expr)
    10000*
    10001*
    10002*		 left right
    10003*	operator	 prec  prec  type  op_code
    10004*
    10005*	0. BOE	   0    -1   -	  0
    10006*	1. +	  60    60   both	  2
    10007*	2. -	  60    60   both	  3
    10008*	3. *	  70    70   infix	  4
    10009*	4. /	  70    70   infix	  5
    10010*	5. **	  90   100   infix	  6
    10011*	6. not	  30    30   prefix	  16
    10012*	7. and	  20    20   infix	  15
    10013*	8. or	  10    10   infix	  14
    10014*	9. eq	  40    40   infix	  10
    10015*	10. ne	  40    40   infix	  11
    10016*	11. lt	  40    40   infix	  8
    10017*	12. gt	  40    40   infix	  13
    10018*	13. le	  40    40   infix	  9
    10019*	14. ge	  40    40   infix	  12
    10020*	15. =	  -1     0   -	  0
    10021*	16. ,	  -1     0   -	  0
    10022*	17. (	   0    -1   prefix	  0
    10023*	18. )	  -1     0   -	  0
    10024*	19. '	  -1     0   -	  0
    10025*	20. :	  -1     0   -        0
    10026*	21. //	  50    50   infix    96
    10027*	22. substr  -1     0   -        0
    10028*	 left_parn
    10029*	23. eqv	   0     0   infix    103
    10030*	24. neqv	   0     0   infix	  104
    10031*	25.	   0     0   not used
    10032*	26.	   0     0   not used
    10033*	27.	   0     0   not used
    10034*	28.	   0     0   not used
    10035*	29.	   0     0   not used
    10036*	30.	   0     0   not used
    10037*	31.	   0     0   not used
    10038*	32.	   0     0   not used
    10039*	33.	   0     0   not used
    10040*	34. negate  80    -1   prefix	   7
    10041**/
    10042 
    10043 dcl      BOE fixed bin (18) int static options (constant) init (0);
    10044 dcl      concat_op fixed bin (18) int static options (constant) init (23);
    10045 dcl      control_bits bit (36) aligned;
    10046 dcl      count fixed bin (18);
    10047 dcl      expr bit (36) aligned;
    10048 dcl      expon_op fixed bin (18) int static options (constant) init (5);
    10049 dcl      have_operand bit (1) aligned;
    10050 dcl      header_storage bit (5) unaligned defined (addr (OS (sp -> symbol.parent)) -> header.storage_info);
    10051 dcl      in_expr bit (1) aligned;
    10052 dcl      indx fixed bin (18);
    10053 dcl      is_infix bit (2) aligned int static options (constant) init ("10"b);
    10054 dcl      is_prefix bit (2) aligned int static options (constant) init ("01"b);
    10055 dcl      left_parenthesis fixed bin (18) int static options (constant) init (10001b);
    10056 dcl      may_need_descriptors bit (1);			/* true if may need descriptors */
    10057 dcl      negate_token fixed bin (18) int static options (constant) init (34);
    10058 dcl      new_state bit (36) aligned;
    10059 dcl      not_token fixed bin (18) int static options (constant) init (00110b);
    10060 dcl      opc fixed bin;
    10061 dcl      pop_stack bit (1) aligned;
    10062 dcl      return_bits bit (36) aligned;
    10063 dcl      save_index fixed bin (18);
    10064 declare	set_storage bit (1) aligned;
    10065 dcl      sp pointer;
    10066 dcl      subs_or_arg_list fixed bin (18) int static options (constant) init (32);
    10067 dcl      substr_paren fixed bin (18) int static options (constant) init (33);
    10068 dcl      symbol_storage bit (5) unaligned defined (sp -> symbol.storage_info);
    10069 dcl      token_prec fixed bin (18);
    10070 dcl      top fixed bin (18);
    10071 dcl      tkn fixed bin (18);
    10072 dcl      word_offset fixed bin (18);
    10073 
    10074 
    10075 /* Precedence table initializations */
    10076 
    10077 dcl      lprec (0:34) fixed bin (18) int static options (constant)
    10078 	    init (0, 60, 60, 70, 70, 90, 30, 20, 10, (6) 40, (2) - 1, 0, (3) - 1, 50, -1, (2) 5, (9) 0, 80);
    10079 dcl      rprec (0:34) fixed bin (18) int static options (constant)
    10080 	    init (-1, 60, 60, 70, 70, 100, 30, 20, 10, (6) 40, (2) 0, -1, (3) 0, 50, 0, (2) 5, (7) 0, (3) - 1);
    10081 dcl      op_code (0:34) fixed bin (18) int static options (constant)
    10082 	    init (0, 2, 3, 4, 5, 6, 16, 15, 14, 10, 11, 8, 13, 9, 12, (6) 0, 96, 0, 103, 104, (9) 0, 7);
    10083 dcl      t_type (0:34) bit (2) aligned int static options (constant)
    10084 	    init ("0"b, (2) (2)"1"b, (3) (1)"10"b, "01"b, (8) (1)"10"b, (2) (2)"0"b, "01"b, (3) (2)"0"b, "10"b, "00"b,
    10085 	    (2) (1)"10"b, (9) (2)"0"b, "01"b);
    10086 
    10087 /* Expression parsing begins here. */
    10088 
    10089 	top = BOE;				/* Prime the top of stack. */
    10090 	word_offset = 0;				/* Current symbol does not have a list. */
    10091 	count = 0;				/* Therefore list has zero items. */
    10092 
    10093 	expr = control_bits;			/* Copy initial state from input arg. */
    10094 	symbol_index = save_index;			/* Copy initial symbol ptr from input arg. */
    10095 	set_storage = control_bits ^= set_no_symbol_bits; /* Flag indicates handling of symbol node */
    10096 
    10097 /* EXPRESSION LOOP. Exited when expression is completely parsed. */
    10098 
    10099 	have_operand = FALSE;
    10100 	in_expr = TRUE;
    10101 	do while (in_expr);
    10102 
    10103 /* OPERAND LOOP. Exited after one opnd, and any prefix operators and left parens, have been parsed. */
    10104 
    10105 	     do while (^have_operand);
    10106 
    10107 /* Stack any prefix operators and left parens which precede the operand. */
    10108 
    10109 		do while (token & is_operator);
    10110 
    10111 /*	Recognition of complex tokens was moved from the lexical analyzer to the
    10112*			expression parser on 78.04.07, by David Levin. */
    10113 
    10114 		     if token = left_parn then
    10115 			if is_complex_constant (symbol_index) then
    10116 			     go to have_constant;
    10117 
    10118 		     tkn = binary (substr (token, 5, 5), 5, 0);
    10119 
    10120 		     if (t_type (tkn) & is_prefix) = ZERO then do;
    10121 			call print_message (94, err_string ());
    10122 			go to statement_parse_abort;
    10123 		     end;
    10124 
    10125 		     if addr (expr) -> expression.set	/* expr in set reference */
    10126 			then
    10127 			if token = left_parn then
    10128 			     call print_message (95, "A redundant parenthesis was encountered. ");
    10129 			else
    10130 			     call print_message (95);
    10131 		     else
    10132 			;
    10133 		     addr (expr) -> expression.not_simple_ref = TRUE;
    10134 
    10135 		     if token ^= plus		/* No need to stack prefix plus. */
    10136 		     then do;
    10137 			call stack_operator (top);	/* Stack the old one. */
    10138 			if token = minus then
    10139 			     top = negate_token;	/* Prefix minus is negate. */
    10140 
    10141 			else if token = not then
    10142 			     top = not_token;
    10143 
    10144 			else
    10145 			     top = tkn;		/* The rest are what they seem. */
    10146 		     end;
    10147 
    10148 		     call get_next_token (force_symtab_entry, symbol_index);
    10149 						/* Get token after prefix. */
    10150 		end;
    10151 
    10152 /* Prefix operators and left parens are parsed. Now there must be an operand. */
    10153 
    10154 		if token & is_constant		/* All constants. */
    10155 		then do;
    10156 have_constant:
    10157 		     if addr (expr) -> expression.set then
    10158 			call print_message (95);	/* constant in set reference */
    10159 
    10160 		     if named_constant_ptr_valid then do;
    10161 			sp = named_constant_ptr;
    10162 			symbol_storage = symbol_storage | string (addr (expr) -> expression.storage_info);
    10163 		     end;
    10164 		     call emit_operand (symbol_index);	/* Put constant into polish string. */
    10165 
    10166 		     call get_next_token$operator;	/* Get binary opr or end of expr. */
    10167 		     tkn = binary (substr (token, 5, 5), 5, 0);
    10168 
    10169 		     call determine_complexity;	/*  sets not_simple_ref, passed_as_arg, and have_operand */
    10170 		     addr (expr) -> expression.not_simple_ref = TRUE;
    10171 						/* constant is never simple ref */
    10172 
    10173 		     if addr (expr) -> expression.passed_as_arg
    10174 						/* constant is passed as arg */
    10175 			then
    10176 			addr (OS (symbol_index)) -> constant.passed_as_arg = TRUE;
    10177 		end;
    10178 
    10179 		else if token = ident		/* Otherwise, it could be an identifier. */
    10180 		then do;
    10181 		     addr (expr) -> expression.not_constant = TRUE;
    10182 		     indx = symbol_index;		/* freeze index to the symbol. */
    10183 		     sp = addr (OS (indx));		/* Pointer to the symbol node. */
    10184 
    10185 		     if addr (expr) -> expression.needs_descriptors = "1"b
    10186 			| (sp -> node.node_type = symbol_node & sp -> symbol.mode.character = "1"b
    10187 			& addr (expr) -> expression.passed_as_arg = "1"b) then
    10188 			may_need_descriptors = "1"b;
    10189 		     else
    10190 			may_need_descriptors = "0"b;
    10191 
    10192 		     call get_next_token$paren_operator;/* Get left paren, bin opr, or end of expr. */
    10193 
    10194 		     if token = left_parn | token = substr_left_parn
    10195 						/* Subscripted ref or some kind of func ref. */
    10196 		     then do;
    10197 
    10198 /* Determine the semantics of this reference. */
    10199 
    10200 			if token = substr_left_parn then do;
    10201 						/* better be substring */
    10202 			     if sp -> symbol.dimensioned & ^addr (expr) -> expression.subscripted_ref then
    10203 				call print_message (155, indx,
    10204 				     "Substring may only be applied to simple variables or array elements");
    10205 						/* can't substr an array */
    10206 
    10207 			     if (unspec (sp -> symbol.attributes) & scalar_conflicts) = ZERO
    10208 						/* simple ref */
    10209 				then
    10210 				if set_storage then
    10211 				     sp -> symbol.variable = TRUE;
    10212 						/* Symbol must remain a variable */
    10213 
    10214 			     new_state = any_expression;
    10215 			     opc = substr_op;
    10216 			end;
    10217 
    10218 			else if sp -> symbol.dimensioned then do;
    10219 						/* Subscripted reference. */
    10220 			     addr (expr) -> expression.subscripted_ref = TRUE;
    10221 			     new_state = any_expression;
    10222 			     opc = subscript_op;
    10223 			end;
    10224 
    10225 /* if not dimensioned, Then some sort of func ref */
    10226 
    10227 			else if sp -> symbol.external & sp -> symbol.function then do;
    10228 						/* External function reference. */
    10229 			     addr (expr) -> expression.not_simple_ref = TRUE;
    10230 
    10231 			     if addr (expr) -> expression.set then
    10232 				call print_message (96, indx);
    10233 
    10234 			     if sp -> symbol.needs_descriptors then
    10235 				new_state = darg_list_expr;
    10236 			     else
    10237 				new_state = arg_list_expr;
    10238 
    10239 			     opc = func_ref_op;
    10240 			end;
    10241 
    10242 			else if sp -> symbol.stmnt_func then do;
    10243 						/* st func reference. */
    10244 			     addr (expr) -> expression.not_simple_ref = TRUE;
    10245 
    10246 			     if addr (expr) -> expression.set then
    10247 				call print_message (96, indx);
    10248 
    10249 			     new_state = any_expression;
    10250 			     opc = sf_op;
    10251 			end;
    10252 
    10253 			else if builtin_lookup (indx, SET_ATTR) then do;
    10254 						/* builtin func reference. */
    10255 			     addr (expr) -> expression.not_simple_ref = TRUE;
    10256 						/* fld is the only bif that can be used in a set reference */
    10257 
    10258 			     if addr (expr) -> expression.set & addr (OS (indx)) -> symbol.name ^= "fld" then
    10259 				call print_message (96, indx);
    10260 
    10261 			     new_state = any_expression;
    10262 			     opc = builtin_op;
    10263 			end;
    10264 
    10265 			else do;			/* Anything else must become an external func ref. */
    10266 			     if (unspec (sp -> symbol.attributes) & func_conflicts) = ZERO then do;
    10267 				if set_storage then
    10268 				     unspec (sp -> symbol.attributes) =
    10269 					unspec (sp -> symbol.attributes) | func_ref_attribute;
    10270 			     end;
    10271 			     else
    10272 				call print_message (97, indx);
    10273 						/* cannot be ext func */
    10274 
    10275 			     addr (expr) -> expression.not_simple_ref = TRUE;
    10276 
    10277 			     if addr (expr) -> expression.set then
    10278 				call print_message (96, indx);
    10279 
    10280 			     if sp -> symbol.needs_descriptors then
    10281 				new_state = darg_list_expr;
    10282 			     else
    10283 				new_state = arg_list_expr;
    10284 
    10285 			     opc = func_ref_op;
    10286 			end;
    10287 
    10288 /* Stack the current expression state. State will be restored after correct right paren encountered. */
    10289 
    10290 			call emit_operand (indx);
    10291 substring_of_array_ref:
    10292 			call stack_operator (top);	/* Stack previous operator. */
    10293 			call stack_operator ((addr (expr) -> based_integer));
    10294 						/* Stack state */
    10295 			call stack_operator (count);
    10296 			if opc = substr_op then do;
    10297 			     call stack_operator (indx);
    10298 			     top = substr_paren;
    10299 			     if ^subr_options.ansi_77 then
    10300 				call print_message (154);
    10301 			end;
    10302 			else do;
    10303 			     top = subs_or_arg_list;
    10304 			     call stack_operator (word_offset);
    10305 			end;
    10306 
    10307 			expr = new_state;
    10308 
    10309 /* Emit correct polish. */
    10310 			if opc ^= substr_op then do;
    10311 			     call emit_count (word_offset);
    10312 			     call emit_operator ((opc));
    10313 			end;
    10314 			count = 0;		/* Local copy of item count. */
    10315 
    10316 			call get_next_token (force_symtab_entry, symbol_index);
    10317 						/* Get beginning of first item or right paren. */
    10318 
    10319 			if token = right_parn	/* func ref with no args. */
    10320 			then do;
    10321 			     call process_eol;
    10322 			     call get_next_token$operator;
    10323 						/* get binary opr or end of expr */
    10324 			end;
    10325 
    10326 			else if token = colon	/* substring, no start given */
    10327 			then do;
    10328 			     count = count + 1;
    10329 
    10330 			     call get_next_token (force_symtab_entry, symbol_index);
    10331 
    10332 			     if token = right_parn	/* (:)--just ignore it */
    10333 			     then do;
    10334 				have_operand = TRUE;
    10335 				call process_end_of_substr;
    10336 				call get_next_token$operator;
    10337 			     end;
    10338 
    10339 			     else
    10340 				call emit_operand (value_1);
    10341 						/* otherwise, beginning is implicitly 1 */
    10342 			end;
    10343 
    10344 		     end;				/* SUBSCRIPTED REF or FUNCTION REF */
    10345 
    10346 		     else do;
    10347 
    10348 /* ident without left_parn */
    10349 			tkn = binary (substr (token, 5, 5), 5, 0);
    10350 						/* gives context */
    10351 			call determine_complexity;	/*  sets not_simple_ref, passed_as_arg, and have_operand */
    10352 
    10353 			if set_storage then do;
    10354 
    10355 /* determine the semantics */
    10356 			     if sp -> symbol.function & sp -> symbol.entry_point then do;
    10357 						/* LINK  ENTRY TO return_value */
    10358 				indx = return_value;
    10359 				sp = addr (OS (indx));
    10360 			     end;
    10361 
    10362 			     if (unspec (sp -> symbol.attributes) & scalar_conflicts) = ZERO
    10363 						/* simple ref */
    10364 			     then do;
    10365 				sp -> symbol.variable = TRUE;
    10366 
    10367 /* If star extent automatic, then it will not get picked up by declaration
    10368*   processor, entry argument processing to set the needs descriptors.  Therefore
    10369*   we must set it when we know the reference. */
    10370 
    10371 				if sp -> symbol.star_extents & may_need_descriptors then
    10372 				     sp -> symbol.needs_descriptors = "1"b;
    10373 			     end;			/* Symbol must remain a variable */
    10374 
    10375 			     else if sp -> symbol.dimensioned
    10376 						/* array name ref */
    10377 			     then do;
    10378 				if may_need_descriptors
    10379 				     & (sp -> symbol.variable_extents | sp -> symbol.star_extents) then
    10380 				     sp -> symbol.needs_descriptors = TRUE;
    10381 
    10382 				addr (expr) -> expression.array_name = TRUE;
    10383 
    10384 				if ^addr (expr) -> expression.allow_array_name
    10385 				     | addr (expr) -> expression.not_simple_ref then
    10386 				     call print_message (98, indx);
    10387 						/* array name is illegal */
    10388 				if addr (expr) -> expression.no_assumed_size_array then
    10389 				     if addr (OS (sp -> symbol.dimension)) -> dimension.assumed_size then
    10390 					call print_message (166, keyword_table (statement_type));
    10391 			     end;
    10392 
    10393 			     else if sp -> symbol.external | sp -> symbol.builtin
    10394 						/* entry value in arg list */
    10395 			     then do;
    10396 				if ^addr (expr) -> expression.passed_as_arg then
    10397 				     call print_message (99, indx);
    10398 						/* illegal use of entry value */
    10399 				if ^sp -> symbol.external then
    10400 				     call print_message (461, indx);
    10401 						/* Not a passable intrinsic */
    10402 				addr (expr) -> expression.not_simple_ref = TRUE;
    10403 
    10404 				if (unspec (sp -> symbol.attributes) & entry_value_conflicts) = ZERO then
    10405 				     unspec (sp -> symbol.attributes) =
    10406 					unspec (sp -> symbol.attributes) | entry_value;
    10407 				else
    10408 				     call print_message (99, indx);
    10409 			     end;
    10410 
    10411 			     else
    10412 				call print_message (100, indx);
    10413 						/* ref is in wrong context */
    10414 
    10415 			     call set_storage_bits;
    10416 
    10417 			end /* set_storage */;
    10418 			call emit_operand (indx);
    10419 		     end;
    10420 		end /* ident */;
    10421 		else do;
    10422 		     call print_message (94, err_string ());
    10423 		     go to statement_parse_abort;	/* missing operand */
    10424 		end;
    10425 	     end /* looking for operand */;
    10426 
    10427 /* Now parse one binary operator or the end of the expression. Then check precedence. */
    10428 
    10429 	     if (token & is_operator) = ZERO		/* Token must be an operator. */
    10430 	     then do;
    10431 		call print_message (101, err_string ());
    10432 		go to statement_parse_abort;		/* missing operator */
    10433 	     end;
    10434 
    10435 	     if t_type (tkn) = is_prefix		/* Must be infix operator. */
    10436 	     then do;
    10437 		call print_message (101, err_string ());
    10438 		go to statement_parse_abort;		/* missing operator */
    10439 	     end;
    10440 
    10441 	     if addr (expr) -> expression.set then
    10442 		if (t_type (tkn) & is_infix) ^= ZERO then
    10443 		     call print_message (95);		/* expr in set reference */
    10444 
    10445 	     have_operand = FALSE;			/* Must have operand if not end of expression. */
    10446 
    10447 /* Unstack operators as long as the current token has lower or equal precedence. */
    10448 
    10449 	     token_prec = rprec (tkn);		/* right precedence for the token */
    10450 
    10451 	     pop_stack = lprec (top) >= token_prec;
    10452 	     do while (pop_stack);
    10453 
    10454 /* If stack contains executable ops, start emitting them. */
    10455 
    10456 		if op_code (top) ^= 0		/* All executable operators. */
    10457 		then do;
    10458 		     call emit_operator ((op_code (top)));
    10459 		     stack_index = stack_index - 1;	/* Get the previous operator from stack. */
    10460 		     top = stack (stack_index);
    10461 		     pop_stack = lprec (top) >= token_prec;
    10462 		end;
    10463 
    10464 /* Otherwise, end of expr, end of subs or arg list, end of parenthesized expr, or error. */
    10465 
    10466 		else do;
    10467 		     pop_stack = FALSE;		/* No iteration possible. */
    10468 		     if top = BOE			/* If we're here, we're done. */
    10469 			then
    10470 			in_expr = FALSE;
    10471 
    10472 		     else if top = left_parenthesis & token = right_parn
    10473 						/* Eliminate pair of parens. */
    10474 		     then do;
    10475 			stack_index = stack_index - 1;/* Get the previous operator from stack. */
    10476 			top = stack (stack_index);
    10477 			tkn = binary (substr (token_list (current_token + 1).type, 5, 5), 5, 0);
    10478 			have_operand = TRUE;
    10479 		     end;
    10480 
    10481 		     else if top = subs_or_arg_list & (token = right_parn | token = comma) then do;
    10482 			count = count + 1;
    10483 
    10484 			call emit_operator (item_op);
    10485 
    10486 			if token = right_parn then do;
    10487 			     call process_eol;
    10488 			     if token_list (current_token + 1).type = left_parn then do;
    10489 				call get_next_token$paren_operator;
    10490 				if token ^= substr_left_parn then do;
    10491 				     call print_message (101, err_string ());
    10492 				     go to statement_parse_abort;
    10493 				end;
    10494 				have_operand = FALSE;
    10495 				opc = substr_op;
    10496 				addr (expr) -> expression.substring_ref = TRUE;
    10497 				new_state = any_expression;
    10498 				if sp -> symbol.attributes.mode.character then
    10499 				     go to substring_of_array_ref;
    10500 				else do;
    10501 				     call print_message (102, err_string ());
    10502 				     go to statement_parse_abort;
    10503 				end;
    10504 			     end;
    10505 			end;			/* End of list. */
    10506 
    10507 			else do;			/* Get next expression. */
    10508 			     unspec (addr (expr) -> expression.not_scalar_ref) = ZERO;
    10509 
    10510 			     if addr (expr) -> expression.reset_arg_bit then
    10511 				addr (expr) -> expression.passed_as_arg = TRUE;
    10512 			end;
    10513 		     end;
    10514 
    10515 		     else if top = substr_paren & token = colon then do;
    10516 			count = count + 1;
    10517 			if count ^= 1 then do;
    10518 			     call print_message (102, err_string ());
    10519 			     go to statement_parse_abort;
    10520 			end;
    10521 
    10522 			unspec (addr (expr) -> expression.not_scalar_ref) = ZERO;
    10523 
    10524 			if token_list (current_token + 1).type = right_parn then do;
    10525 			     call get_next_token$operator;
    10526 
    10527 /* recover index of string symbol from stacked expression */
    10528 
    10529 			     indx = stack (stack_index - 1);
    10530 			     call emit_operand (get_char_length (force_symtab_entry, (indx)));
    10531 			     call process_end_of_substr;
    10532 			end;
    10533 		     end;
    10534 
    10535 		     else if top = substr_paren & token = right_parn then do;
    10536 			if count ^= 1 then do;
    10537 			     call print_message (102, err_string ());
    10538 			     goto statement_parse_abort;
    10539 			end;
    10540 			call process_end_of_substr;
    10541 		     end;
    10542 
    10543 		     else do;
    10544 			call print_message (102, err_string ());
    10545 						/* comma out of place */
    10546 			go to statement_parse_abort;
    10547 		     end;
    10548 		end;
    10549 	     end /* unstack loop */;
    10550 
    10551 /* Stack the current operator if it is not the end of the expression. */
    10552 
    10553 	     if token_prec > 0 then do;
    10554 		if top = expon_op & tkn = expon_op then
    10555 		     call print_message (144);
    10556 		call stack_operator (top);		/* Stack previous operator. */
    10557 		top = tkn;
    10558 		addr (expr) -> expression.not_simple_ref = TRUE;
    10559 	     end;
    10560 
    10561 /* The test for concat in non-ansi77 subr moved to the code generator or
    10562*   converter ...  */
    10563 /* if tkn = concat_op & ^subr_options.ansi_77
    10564*	     then call print_message (153);     */
    10565 
    10566 
    10567 	     if in_expr then
    10568 		call get_next_token (force_symtab_entry, symbol_index);
    10569 	end /* expression loop */;
    10570 
    10571 	return_bits = expr;				/* return final expression status */
    10572 	return;
    10573 
    10574 
    10575 determine_complexity:
    10576      procedure;					/* check for binary operators and sets have_operand */
    10577 						/* also sets expr.not_simple_ref and expr.passed_as_arg */
    10578 	have_operand = TRUE;			/* binary opr or end of expr must follow */
    10579 
    10580 	if t_type (tkn) & is_infix then
    10581 	     addr (expr) -> expression.not_simple_ref = TRUE;
    10582 						/* Is ref part of expr? */
    10583 
    10584 	if addr (expr) -> expression.not_simple_ref then
    10585 	     addr (expr) -> expression.passed_as_arg = FALSE;
    10586 						/* argument only if not expr. */
    10587      end determine_complexity;
    10588 
    10589 
    10590 process_eol:
    10591      procedure;
    10592 
    10593 	unspec (expr) = unspec (stack (stack_index - 3)); /* Restore expression status bits. */
    10594 
    10595 	indx = polish_string (word_offset - 1);		/* Restore pointer to owner of this list. */
    10596 	sp = addr (OS (indx));			/* ditto. */
    10597 
    10598 	call emit_operator (eol_op);
    10599 
    10600 	if count > 0 then do;
    10601 	     if count > max_arglist - 1		/* must leave room for return value */
    10602 		then
    10603 		call print_message (138, max_arglist - 1 - bias, indx);
    10604 
    10605 	     polish_string (word_offset) = count - bias;	/* Store list count in polish. */
    10606 	end;
    10607 
    10608 	tkn = binary (substr (token_list (current_token + 1).type, 5, 5), 5, 0);
    10609 						/* gives context */
    10610 	call determine_complexity;			/*  sets not_simple_ref, passed_as_arg, and have_operand */
    10611 
    10612 	if set_storage then
    10613 	     call set_storage_bits;
    10614 
    10615 	word_offset = stack (stack_index - 1);		/* Restore list info for containing list. */
    10616 	count = stack (stack_index - 2);
    10617 	stack_index = stack_index - 4;		/* Remove this list from the stack and get prev opr. */
    10618 	top = stack (stack_index);
    10619      end process_eol;
    10620 process_end_of_substr:
    10621      procedure;
    10622 
    10623 	unspec (expr) = unspec (stack (stack_index - 3));
    10624 
    10625 	if ^have_operand then do;
    10626 	     have_operand = TRUE;
    10627 	     call emit_operator (substr_op);
    10628 	     addr (expr) -> expression.substring_ref = TRUE;
    10629 	end;
    10630 
    10631 	top = stack (stack_index - 4);
    10632 	count = stack (stack_index - 2);
    10633 	indx = stack (stack_index - 1);
    10634 	sp = addr (OS (indx));
    10635 	if set_storage then
    10636 	     call set_storage_bits;
    10637 	stack_index = stack_index - 4;
    10638 
    10639 	tkn = binary (substr (token_list (current_token + 1).type, 5, 5), 5, 0);
    10640 
    10641 	return;
    10642      end process_end_of_substr;
    10643 set_storage_bits:
    10644      procedure;
    10645 
    10646 	symbol_storage = symbol_storage | string (addr (expr) -> expression.storage_info);
    10647 	if sp -> symbol.equivalenced then
    10648 	     if sp -> symbol.parent > 0 then
    10649 		header_storage = header_storage | string (addr (expr) -> expression.storage_info);
    10650 
    10651 	return;
    10652      end set_storage_bits;
    10653      end parse_expression;
    10654 
    10655 is_complex_constant:
    10656      procedure (complex_constant_offset) returns (bit (1) aligned);
    10657 
    10658 dcl      complex_constant_offset fixed bin (18);
    10659 dcl      cx fixed bin (18);
    10660 dcl      following_token (2) bit (9) aligned int static options (constant) init ("220"b3, "222"b3);
    10661 						/* comma & right_parn */
    10662 dcl      i fixed bin (18);
    10663 dcl      indx fixed bin (18);
    10664 dcl      symb fixed bin (18);
    10665 dcl      var_len fixed bin (18);
    10666 
    10667 dcl      1 complex_info (2) aligned,
    10668 	 2 sign_char bit (9),
    10669 	 2 value fixed bin (18);
    10670 
    10671 dcl      1 two_words aligned,
    10672 	 2 words (2) bit (36) aligned;
    10673 
    10674 	indx = current_token;
    10675 
    10676 /* First, see if this is a complex const; while we check, we'll save what info we get. */
    10677 
    10678 	do i = 1 to 2;
    10679 
    10680 	     if token_list (indx + 1).type = plus | token_list (indx + 1).type = minus then do;
    10681 		complex_info (i).sign_char = token_list (indx + 1).type;
    10682 		indx = indx + 1;
    10683 	     end;
    10684 	     else
    10685 		complex_info (i).sign_char = ZERO;
    10686 
    10687 	     if token_list (indx + 2).type ^= following_token (i) then
    10688 		return (FALSE);
    10689 
    10690 	     if token_list (indx + 1).type = real_const | token_list (indx + 1).type = dec_int then
    10691 		complex_info (i).value = indx + 1;
    10692 	     else do;
    10693 		if token_list (indx + 1).type ^= ident then
    10694 		     return (FALSE);
    10695 
    10696 		var_len = token_list (indx + 1).length + 1;
    10697 
    10698 		substr (full_name, 1, var_len) = substr (st_copy, token_list (indx + 1).offset + 1, var_len);
    10699 
    10700 		call find_symbol_index (var_len, symb, locate_symtab_entry, ignore_value);
    10701 		if symb = 0 then
    10702 		     return (FALSE);
    10703 		if ^addr (OS (symb)) -> symbol.named_constant then
    10704 		     return (FALSE);
    10705 
    10706 		symb = addr (OS (symb)) -> symbol.initial;
    10707 		if addr (OS (symb)) -> constant.data_type ^= real_mode then
    10708 		     return (FALSE);
    10709 		complex_info (i).value = -symb;
    10710 	     end;
    10711 
    10712 	     indx = indx + 2;
    10713 	end;					/* loop to check each part of a complex const */
    10714 
    10715 /* Now, convert both parts to binary. */
    10716 
    10717 	do i = 1 to 2;
    10718 
    10719 	     sign = complex_info (i).sign_char;
    10720 	     cx = complex_info (i).value;
    10721 
    10722 	     if cx > 0				/* then this is a token node */
    10723 		then
    10724 		if token_list (cx).type = real_const then do;
    10725 		     token_offset = token_list (cx).offset;
    10726 						/* get token info for conversion */
    10727 		     cx = token_list (cx).length + 1;
    10728 		     token_length = constant_array (cx).length + 1;
    10729 
    10730 		     work = convert_real_constant (cx);
    10731 		     unspec (addr (two_words) -> based_real (i)) =
    10732 			conv_round (real_mode, dp_mode) ((unspec (addr (work) -> based_double)), 0);
    10733 		end;
    10734 
    10735 		else do;				/* otherwise an integer */
    10736 		     work = convert_integer_constant ((token_list (cx).offset), token_list (cx).length + 1);
    10737 		     unspec (addr (two_words) -> based_real (i)) =
    10738 			conv_round (real_mode, int_mode) ((unspec (addr (work) -> based_integer)), 0);
    10739 		end;
    10740 
    10741 	     else
    10742 		words (i) = addr (OS (-cx)) -> constant.value;
    10743 						/* this is named constant, get const value */
    10744 
    10745 	     if sign = minus then
    10746 		unspec (addr (two_words) -> based_real (i)) =
    10747 		     negate_round (real_mode) (6, (unspec (addr (two_words) -> based_real (i))), "0"b, 0);
    10748 	end;
    10749 
    10750 	sign = ZERO;				/* See procedure convert_integer_constant */
    10751 
    10752 /* Next, modify token list info. */
    10753 
    10754 	current_token = indx;
    10755 
    10756 	if current_token >= last_token then
    10757 	     token_length, token_list (current_token).length = statement_length - token_offset - 1;
    10758 	else
    10759 	     token_length, token_list (current_token).length = token_list (current_token + 1).offset - token_offset - 1;
    10760 
    10761 	token, token_list (current_token).type = complex_const;
    10762 
    10763 	token_list (current_token).offset = token_offset;
    10764 
    10765 /* Finally, create a complex constant. */
    10766 
    10767 	work = string (two_words);			/* Many parsers expect the value to be here. */
    10768 	complex_constant_offset = create_constant (cmpx_mode, work);
    10769 	return (TRUE);
    10770      end is_complex_constant;
    10771 
    10772 /* BEGIN ext_parse section - LEX - split 82-03-29  T. Oke */
    10773 
    10774 /* Modification History:
    10775*
    10776*   Modified 10 Feb 83, HH - Install LA/VLA support.
    10777*   Modified  21 June  1982, TO - Change global and option names to:
    10778*	"ckmpy", "nckmpy", change optional "nsubrg", "nstrg".
    10779*   Modified   4 April 1982, TO - Change global and option names to:
    10780*	"ck_mpy" and "no_ck_mpy", add optional "no_subrg", "no_strg".
    10781*   Modified:  7 May 1982, TO - Make %global options print in header and binary.
    10782*   Modified:  3 May 1982, TO - change error_table_$no_entry to error_table_$noentry.
    10783*   Modified:  3 May 1982, TO - Add "-check_multiply" and "-no_check_multiply".
    10784*   Modified: 28 April 1982, TO - Fix phx12940, X FORMAT not followed by comma.
    10785*   Modified: 15 April 1982, TO - Fix bug300 to permit lex to see an apostrophe
    10786*	even if not preceeded by an operator, if in a FORMAT statement.
    10787*   */
    10788 
    10789 statement_lex:
    10790      procedure (a_stmnt_type);
    10791 
    10792 /*	Program Specifications (statement_lex)
    10793*
    10794*     Inputs
    10795*
    10796*     Output
    10797*
    10798*     Description (statement_lex)
    10799**/
    10800 
    10801 dcl      ASSIGN bit (1) aligned;
    10802 dcl      EOS bit (1) aligned;
    10803 dcl      FORTRAN_ONLY bit (2) aligned int static options (constant) init ("00"b);
    10804 dcl      GLOBAL_OK bit (2) aligned int static options (constant) init ("11"b);
    10805 dcl      LOWER char (26) aligned int static options (constant) init ("abcdefghijklmnopqrstuvwxyz");
    10806 dcl      NL char (1) aligned init ("
    10807 ") int static options (constant);
    10808 dcl      OPTIONS_OK bit (2) aligned int static options (constant) init ("01"b);
    10809 dcl      UPPER char (26) aligned int static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
    10810 dcl      WHITE char (2) aligned int static options (constant) init ("	 ");
    10811 						/* tab & space */
    10812 dcl      a_stmnt_type fixed bin (18);
    10813 dcl      alphanumeric char (64) aligned int static options (constant)
    10814 	    init ("$0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz");
    10815 dcl      apostrophe_char char (1) aligned int static options (constant) init ("'");
    10816 dcl      begin_text fixed bin (20);
    10817 dcl      blank_cont_count fixed bin (18);
    10818 dcl      cname char (32);
    10819 declare	command character (7) internal static options (constant) initial ("fortran");
    10820 dcl      count fixed bin (18);
    10821 dcl      dname char (256);
    10822 dcl      dtm fixed bin (71);
    10823 dcl      ename char (256);
    10824 dcl      end_text fixed bin (20);
    10825 dcl      end_zero fixed bin (18);
    10826 dcl      exp fixed bin (18);
    10827 dcl      extra_blanks fixed bin (18);
    10828 dcl      i fixed bin (18);
    10829 dcl      last_token_type bit (9) aligned;
    10830 dcl      lexing_a_token bit (1) aligned;
    10831 dcl      operator_follows bit (1) aligned;
    10832 dcl      paren_level fixed bin (18);
    10833 declare	penultimate_token_type bit (9) aligned;
    10834 dcl      percent_line_flag bit (2) aligned;
    10835 dcl      precision fixed bin (18);
    10836 dcl      quote char (1) aligned int static options (constant) init ("""");
    10837 dcl      stmnt_type fixed bin (18);
    10838 dcl      t_scale fixed bin (18);
    10839 dcl      token_table (0:127) fixed bin (18) int static options (constant)
    10840 						/* 000 - 037 */
    10841 	    init ((9) 0, -1, (22) 0,			/* 040 - 047 */
    10842 	    -1, 0, 13, 0, 15, (2) 0, 12,		/* 050 - 057 */
    10843 	    8, 9, 14, 4, 10, 5, 2, 11,		/* 060 - 100 */
    10844 	    (10) 3, 17, 16, 0, 7, (3) 0,		/* 101 - 177 */
    10845 	    (26) 1, (3) 0, 6, (2) 0, (26) 1, (5) 0);
    10846 dcl      token_type bit (9) aligned;
    10847 dcl      translate_string bit (1) aligned;
    10848 dcl      uid bit (36) aligned;
    10849 
    10850 dcl      1 line_structure aligned based (source_ptr),
    10851 	 2 pad char (char_index) unaligned,
    10852 	 2 rest_of_line char (end_of_line - char_index) unaligned;
    10853 
    10854 dcl      1 text_structure aligned based (source_ptr),
    10855 	 2 pad char (char_index) unaligned,
    10856 	 2 rest_of_text char (source_len - char_index) unaligned;
    10857 
    10858 dcl      find_include_file_$initiate_count entry (char (*), ptr, char (*), fixed bin (24), ptr, fixed bin (35));
    10859 dcl      hcs_$terminate_noname entry (ptr, fixed bin (35));
    10860 dcl      translator_info_$component_get_source_info
    10861 	    entry (ptr, char (*), char (*), char (*), fixed bin (71), bit (36) aligned, fixed bin (35));
    10862 declare	com_err_ entry () options (variable);
    10863 declare	error_table_$noentry external static fixed binary (35);
    10864 declare	error_table_$no_s_permission fixed bin (35) ext static;
    10865 
    10866 /* beginning of statement lexical analysis */
    10867 
    10868 lex_aborted:
    10869 	if cur_statement + size (statement) = next_free_polish then
    10870 	     cur_stmnt_ptr -> statement = addr (statement_info) -> statement;
    10871 	else
    10872 	     call emit_statement_op (addr (statement_info));
    10873 
    10874 	first_token = 2;				/* index of first token; leave room to split it */
    10875 	last_token = 1;				/* index of last token; it is always correct */
    10876 
    10877 /* loop until a non-null statement is encountered */
    10878 
    10879 	do while (last_token < first_token);
    10880 
    10881 	     statement_length = 0;			/* Length of statement text copy. */
    10882 	     COLON_BEFORE_ASSIGN = FALSE;
    10883 	     ASSIGN = FALSE;			/* No assign token encountered. */
    10884 	     SECOND_EQUALS = FALSE;			/* Second statement of logical if is assignment. */
    10885 	     label_args = FALSE;			/* indicate presence of label args; used by call stmnt parse */
    10886 	     paren_level = 0;			/* Paren level. */
    10887 	     end_zero = 0;				/* Used to recognize logical if statements. */
    10888 	     const_count = 0;			/* Count of real and dp constants. */
    10889 	     last_token_type, penultimate_token_type = no_token;
    10890 	     stmnt_type = 0;			/* Statement type of statement lexed. */
    10891 	     EOS = FALSE;				/* have not yet reached end of this statement */
    10892 
    10893 	     if line_number >= 16384			/* limitation imposed by stmnt map */
    10894 	     then do;
    10895 		cur_stmnt_ptr -> statement.line = ZERO; /* line has no line number */
    10896 		addr (statement_info) -> statement.line = ZERO;
    10897 						/* nor do future ones */
    10898 
    10899 		if type_of_line ^= no_more_source then
    10900 		     call print_message (103, char (decimal (line_number, 12)));
    10901 	     end;
    10902 	     else do;
    10903 		addr (statement_info) -> statement.line = bit (fixed (line_number, 14), 14);
    10904 		cur_stmnt_ptr -> statement.line = bit (fixed (line_number, 14), 14);
    10905 	     end;
    10906 
    10907 	     cur_statement_list = number_of_lines;
    10908 
    10909 	     begin_text, end_text = statement_offset;	/* used to calculate sttmnt length */
    10910 	     cur_stmnt_ptr -> statement.start = statement_offset;
    10911 
    10912 	     if type_of_line = no_more_source then do;
    10913 		call print_message (104);		/* missing end_line */
    10914 		statement_label = 0;
    10915 		a_stmnt_type = end_line;
    10916 		return;
    10917 	     end;
    10918 
    10919 /* pick up statement label */
    10920 
    10921 	     statement_label = next_statement_label;
    10922 	     if statement_label ^= 0 then do;
    10923 		end_possible = FALSE;
    10924 		next_statement_label = 0;
    10925 	     end;
    10926 
    10927 /* loop to lex a statement; terminates when the next statement is encountered */
    10928 
    10929 	     do while (^EOS);
    10930 
    10931 		token_length = 0;
    10932 		token_offset = statement_length;
    10933 
    10934 		translate_string = FALSE;		/* just copy, don't translate */
    10935 
    10936 		go to lexer (char_type);		/* CASE ( token type ) */
    10937 
    10938 /* Return here after lexing one token. If the token is simple, i.e.- an operator, only
    10939*		   the token type is stored. If it is complicated, its length and offset are also stored. */
    10940 
    10941 store_token_length:					/* a complicated token */
    10942 		token_list (last_token + 1).offset = token_offset;
    10943 						/* last_token will never exceed the array bound */
    10944 
    10945 		if token_length > 512 then do;
    10946 		     token_list (last_token + 1).length = 512;
    10947 		     call print_message (124, 512 - bias);
    10948 						/* token string too long */
    10949 		end;
    10950 		else
    10951 		     token_list (last_token + 1).length = token_length - 1;
    10952 
    10953 
    10954 have_token:					/* a simple token */
    10955 		last_token = last_token + 1;
    10956 
    10957 		if last_token >= hbound (token_list, 1) then do;
    10958 		     call print_message (123, hbound (token_list, 1) - 1 - bias);
    10959 						/* token table overflow */
    10960 		     go to abort_lex;
    10961 		end;
    10962 
    10963 		token_list (last_token).type = token_type;
    10964 		penultimate_token_type = last_token_type;
    10965 		last_token_type = token_type;
    10966 
    10967 lex_next_token:					/* if token lex fails */
    10968 	     end;					/* lex of a single statement */
    10969 
    10970 	     if last_token < first_token then do;
    10971 		call print_message (105);		/* null statement */
    10972 	     end;
    10973 	end;					/* loop to lex a non-null statement */
    10974 
    10975 	if end_text - begin_text < 512 then
    10976 	     cur_stmnt_ptr -> statement.length = bit (binary (end_text - begin_text, 9), 9);
    10977 	else
    10978 	     cur_stmnt_ptr -> statement.length = "111111111"b;
    10979 						/* maximum length possible */
    10980 
    10981 	current_token = 2;
    10982 
    10983 	token_list (last_token + 1).type = EOS_token;	/* indicates the end to the parsers */
    10984 
    10985 	if stmnt_type ^= 0				/* Statement type is already known. */
    10986 	then do;
    10987 	     if stmnt_type ^= asf_definition & stmnt_type ^= assignment_statement then
    10988 		call split_token ((length (keyword_table (stmnt_type))), current_token, FALSE);
    10989 
    10990 	     a_stmnt_type = stmnt_type;
    10991 	     return;
    10992 	end;
    10993 
    10994 statement_lex$recognize_statement:
    10995      entry (a_stmnt_type);
    10996 
    10997 /* Lookup first token in table to determine statement type. */
    10998 
    10999 	if token_list (current_token).type ^= ident then do;
    11000 	     a_stmnt_type = unknown_statement;
    11001 	     return;
    11002 	end;
    11003 
    11004 	fast_lookup = substr (st_copy, token_list (current_token).offset + 1, token_list (current_token).length + 1);
    11005 
    11006 /* Order of look up is based on whether we are out of "declarative section". */
    11007 
    11008 	if assignment_statement_index ^= assignment_statement then do;
    11009 						/* Most likely a declarative. */
    11010 	     do stmnt_type = keyword_index to asf_definition - 1
    11011 		while (substr (fast_lookup, 1, length (keyword_table (stmnt_type))) ^= keyword_table (stmnt_type));
    11012 	     end;
    11013 
    11014 	     if stmnt_type >= asf_definition then
    11015 		do stmnt_type = asf_definition + 1 to assignment_statement - 1
    11016 		     while (substr (fast_lookup, 1, length (keyword_table (stmnt_type)))
    11017 		     ^= keyword_table (stmnt_type));
    11018 		end;
    11019 	end;
    11020 
    11021 	else do;					/* Most likely executable. */
    11022 	     do stmnt_type = asf_definition + 1 to assignment_statement - 1
    11023 		while (substr (fast_lookup, 1, length (keyword_table (stmnt_type))) ^= keyword_table (stmnt_type));
    11024 	     end;
    11025 
    11026 	     if stmnt_type >= assignment_statement then do;
    11027 		do stmnt_type = keyword_index to asf_definition - 1
    11028 		     while (substr (fast_lookup, 1, length (keyword_table (stmnt_type)))
    11029 		     ^= keyword_table (stmnt_type));
    11030 		end;
    11031 		if stmnt_type >= asf_definition then
    11032 		     stmnt_type = assignment_statement;
    11033 	     end;
    11034 	end;
    11035 
    11036 /* If not found, see if it unknown or just out of sequence. */
    11037 
    11038 	if stmnt_type >= assignment_statement then do;
    11039 	     do stmnt_type = 1 to keyword_index - 1
    11040 		while (substr (fast_lookup, 1, length (keyword_table (stmnt_type))) ^= keyword_table (stmnt_type));
    11041 	     end;
    11042 	     if stmnt_type >= keyword_index then
    11043 		stmnt_type = unknown_statement;
    11044 	     else do;
    11045 		bad_type = stmnt_type;
    11046 		stmnt_type = out_of_sequence;
    11047 	     end;
    11048 	end;
    11049 
    11050 /* If it is legitimate, remove the keyword from the token. If stmnt_type = asf_definition
    11051*	   & stmnt_type = assignement_statement split_token will incorrectly remove valid characters. */
    11052 
    11053 	else
    11054 	     call split_token ((length (keyword_table (stmnt_type))), current_token, FALSE);
    11055 
    11056 	a_stmnt_type = stmnt_type;
    11057 	return;
    11058 
    11059 statement_lex$initialize:
    11060      entry;
    11061 
    11062 	percent_line_flag = GLOBAL_OK;
    11063 	extra_blanks, blank_cont_count, source_line_number, line_number = 0;
    11064 	next_line_index, end_of_line = -1;
    11065 
    11066 statement_lex$get_next_subprogram:
    11067      entry;
    11068 
    11069 	percent_line_flag = percent_line_flag | OPTIONS_OK;
    11070 	have_auto_option, have_static_option = "0"b;
    11071 	cur_statement = -1;
    11072 	next_statement_label = 0;
    11073 
    11074 /* loop until the first initial line or end of text */
    11075 
    11076 	EOS = FALSE;
    11077 
    11078 	do while (^EOS);
    11079 	     call get_line_image (percent_line_flag);	/* Sets "type_of_line" & "EOS", processes %global, %options */
    11080 
    11081 	     if type_of_line = continuation_line & ^EOS	/* continuation precedes initial line, error */
    11082 		then
    11083 		call print_message (112);
    11084 	end;
    11085 
    11086 	call get_new_character;			/* get information about first character */
    11087 	return;
    11088 
    11089 abort_lex:					/* if lex of a statement must be aborted */
    11090 	EOS = FALSE;
    11091 	do while (^EOS);
    11092 	     call get_line_image (FORTRAN_ONLY);
    11093 	end;
    11094 
    11095 	call get_new_character;			/* reset global variables */
    11096 
    11097 	go to lex_aborted;
    11098 
    11099 /* Case	White space -- only possible if first significant char of a statement is on a continuation line */
    11100 lexer (-1):
    11101 	if statement_label ^= 0 then
    11102 	     next_statement_label = -1;		/* prevent multiple labels */
    11103 	call skip_characters (0);
    11104 	if next_statement_label < 0 then
    11105 	     next_statement_label = 0;
    11106 	go to lex_next_token;
    11107 
    11108 /* Case	non-ASCII, characters not in character set. */
    11109 lexer (0):
    11110 	if binary (bit_value, 9, 0) <= 32 | binary (bit_value, 9, 0) >= hbound (token_table, 1) then
    11111 	     call print_message (106, "whose bit value is " || char (bit_value));
    11112 	else
    11113 	     call print_message (106, char_value);
    11114 	call skip_characters (ONE);
    11115 	go to lex_next_token;
    11116 
    11117 /* Case A-Z a-z */
    11118 lexer (1):
    11119 	token_type = ident;
    11120 	translate_string = fold_option;		/* translate name if specified by user */
    11121 
    11122 	lexing_a_token = TRUE;
    11123 	do while (lexing_a_token);
    11124 	     i = verify (rest_of_line, alphanumeric) - 1;
    11125 	     if i = 0 then
    11126 		lexing_a_token = FALSE;
    11127 	     else do;
    11128 		if i < 0 then
    11129 		     i = length (rest_of_line);
    11130 		call skip_characters (i);
    11131 		if EOS then
    11132 		     lexing_a_token = FALSE;
    11133 		else if char_type ^= digits & char_type ^= letters & current_character ^= "_"
    11134 		     & current_character ^= "$" then
    11135 		     lexing_a_token = FALSE;
    11136 	     end;
    11137 	end;
    11138 
    11139 	go to store_token_length;
    11140 
    11141 /* Case . decimal point */
    11142 lexer (2):
    11143 	call skip_characters (ONE);
    11144 
    11145 	if EOS then do;
    11146 	     call print_message (107, ".");		/* illegal "." */
    11147 	     go to lex_next_token;
    11148 	end;
    11149 
    11150 	if char_type = digits then do;
    11151 	     call get_digits (precision);
    11152 	     token_type = real_const;
    11153 	     t_scale = precision;
    11154 	     operator_follows = FALSE;
    11155 	     call parse_exponent;
    11156 	end;
    11157 	else do;
    11158 	     translate_string = fold_option;
    11159 	     call build_fortran_operator;
    11160 	end;
    11161 	go to store_token_length;
    11162 
    11163 /* Case 0-9 digits */
    11164 lexer (3):
    11165 	token_type = dec_int;
    11166 	call get_digits (precision);
    11167 	t_scale = 0;
    11168 	operator_follows = FALSE;
    11169 
    11170 /* for ansi77, a few changes here.  If the last token_type was an asterisk, there are several possibilities.
    11171*   If we're wihtin parens, and the next_to_last token is either a comma, or a left paren,
    11172*   then this should be a label constant (e.g. *8 ,like Multics $8) in a call statment.
    11173*   We can also detect an initial field length (e.g. character*30), but not an internal one,
    11174*   e.g. character *3 foo, bar *33.  The *33 can't be distinguished from an arithemetic expression at this point.
    11175**/
    11176 
    11177 	if EOS then
    11178 	     go to store_token_length;
    11179 	if last_token_type = asterisk then do;
    11180 	     if paren_level = 0 & last_token - first_token = 1 then
    11181 		go to store_token_length;		/* a initial length field */
    11182 	     else if paren_level > 0 & (penultimate_token_type = comma | penultimate_token_type = left_parn) then do;
    11183 
    11184 /* The previous asterisk actually began an alternate return arg in a call.  We must back up the token list,
    11185*   and incorporate the "*" into this token.  This requires changing the token_type, and the length and offset.
    11186**/
    11187 
    11188 		token_offset = token_offset - 1;
    11189 		token_length = token_length + 1;
    11190 		label_args = TRUE;
    11191 		token_type = label_const;
    11192 		last_token = last_token - 1;
    11193 		goto store_token_length;
    11194 	     end /* label arg */;
    11195 	end /* last was asterisk */;
    11196 
    11197 /* A little diddling added to handle x format within formats, but not
    11198*   followed by an operator, such as ) or ,. PHX12940.  Here detect the
    11199*   presence of a 6 character token as first on a line, followed by a
    11200*   left_parn, the best we can do other than actually setting a FORMAT flag. */
    11201 
    11202 	if current_character = "x" | current_character = "X" then
    11203 	     if paren_level >= 1 & last_token > 2 & token_list (2).length = 5 & token_list (3).type = left_parn then do;
    11204 						/* must be FORMAT nX */
    11205 		call skip_characters (ONE);
    11206 		go to store_token_length;
    11207 	     end;
    11208 
    11209 /* an integer followed by an h is usually a hollerith constant */
    11210 
    11211 	if current_character = "h" | current_character = "H" then do;
    11212 	     unspec (count) = convert_integer_constant (token_offset, token_length);
    11213 
    11214 	     token_length = -1;
    11215 	     token_offset = statement_length + 1;
    11216 	     token_type = char_string;
    11217 
    11218 	     if count = 0				/* "call skip_characters" even if error. */
    11219 	     then do;
    11220 		call print_message (108);
    11221 		call skip_characters (ONE);		/* Skip "h". */
    11222 		go to store_token_length;
    11223 	     end;
    11224 
    11225 	     count = count + 1;			/* Include the "h" in the count. */
    11226 	     do while (count > 0);
    11227 		i = min (count, length (rest_of_line));
    11228 		count = count - i;
    11229 		if count > 0 then do;
    11230 		     call get_continuation_line (count);/* Sets: type_of_line, EOS and its argument */
    11231 
    11232 		     if EOS			/* string is terminated by the end of the statement */
    11233 		     then do;
    11234 			if count > 0		/* statement terminated before we got enough chars */
    11235 			     then
    11236 			     call print_message (109);
    11237 			if token_length = 0 then
    11238 			     call print_message (108);
    11239 			call skip_characters (0);
    11240 			go to store_token_length;
    11241 		     end;
    11242 
    11243 		     i = count;			/* set i to number of remaining chars in const */
    11244 		end;
    11245 	     end;
    11246 
    11247 	     call skip_characters (i);		/* copy end of string and find next significant char */
    11248 	     go to store_token_length;
    11249 	end;
    11250 
    11251 /* now see if the number contains a decimal point */
    11252 
    11253 	if current_character = "." then do;
    11254 	     call skip_characters (ONE);
    11255 	     token_type = real_const;
    11256 	     if ^EOS then do;
    11257 		if char_type = digits		/* Digits after the decimal point? */
    11258 		then do;				/* Yes. */
    11259 		     call get_digits (t_scale);
    11260 		     precision = precision + t_scale;
    11261 		end;
    11262 		else do;
    11263 		     translate_string = fold_option;	/* in case integer is followed by rel op */
    11264 		     operator_follows = TRUE;		/* could be integer followed by rel op */
    11265 		end;
    11266 	     end;
    11267 	end;
    11268 
    11269 /* finally, see if there is an exponent field */
    11270 
    11271 	call parse_exponent;
    11272 
    11273 	if operator_follows				/* set by parse_exponent if rel op follows int */
    11274 	then do;
    11275 
    11276 /*	A decimal point encountered is actually part of a relational operator. We will store the
    11277*		integer (which is the only possible token to precede it) and then process the rel op. */
    11278 
    11279 	     last_token = last_token + 1;
    11280 
    11281 	     if last_token >= hbound (token_list, 1) then do;
    11282 		call print_message (123, hbound (token_list, 1) - 1 - bias);
    11283 						/* token table overflow */
    11284 		go to abort_lex;
    11285 	     end;
    11286 
    11287 	     token_list (last_token).type = dec_int;
    11288 	     token_list (last_token).offset = token_offset;
    11289 
    11290 	     if precision > 512 then do;
    11291 		token_list (last_token).length = 511;
    11292 		call print_message (124, 512 - bias);	/* token string too long */
    11293 	     end;
    11294 	     else
    11295 		token_list (last_token).length = precision - 1;
    11296 
    11297 /* now update length and offset to exclude the integer */
    11298 
    11299 	     token_offset = token_offset + precision;
    11300 	     token_length = token_length - precision;
    11301 	     call build_fortran_operator;
    11302 	end;
    11303 	go to store_token_length;
    11304 
    11305 /* Case + */
    11306 lexer (4):
    11307 	token_type = plus;
    11308 	call skip_characters (ONE);
    11309 	go to have_token;
    11310 
    11311 /* Case - */
    11312 lexer (5):
    11313 	token_type = minus;
    11314 	call skip_characters (ONE);
    11315 	go to have_token;
    11316 
    11317 /* Case ^ */
    11318 lexer (6):
    11319 	token_type = expon;
    11320 	call skip_characters (ONE);
    11321 	go to have_token;
    11322 
    11323 /* Case = */
    11324 lexer (7):
    11325 	token_type = assign;
    11326 	if paren_level = 0 & ^ASSIGN then do;
    11327 	     ASSIGN = TRUE;				/* These tests made only once per statement. */
    11328 	     if substr (st_copy, 1, 3) = "if("		/* See if "if" stmnt */
    11329 		& ((end_zero = 1 & last_token_type = ident)
    11330 						/* if() x = */
    11331 		| (end_zero = 2 & last_token_type = right_parn))
    11332 						/* if () x() = */
    11333 		| (end_zero = 3 & last_token_type = right_parn & COLON_BEFORE_ASSIGN)
    11334 						/* if () x () (n:m) = */
    11335 		then
    11336 		SECOND_EQUALS = TRUE;		/* Probably log if stmnt whose second is assignmnt. */
    11337 	     else if keyword_index > parameter_statement	/* obviously not parameter. */
    11338 		then
    11339 		stmnt_type = assignment_statement_index;
    11340 	     else if substr (st_copy, 1, 9) = "parameter" & statement_length > 9 then
    11341 		stmnt_type = parameter_statement;
    11342 	     else
    11343 		stmnt_type = assignment_statement_index;
    11344 	end;
    11345 
    11346 	call skip_characters (ONE);
    11347 	go to have_token;
    11348 
    11349 /* Case ( */
    11350 lexer (8):
    11351 	token_type = left_parn;
    11352 	paren_level = paren_level + 1;
    11353 	call skip_characters (ONE);
    11354 	paren_array (paren_level) = last_token + 1;
    11355 	go to have_token;
    11356 
    11357 /* Case ) */
    11358 lexer (9):
    11359 	token_type = right_parn;
    11360 	call skip_characters (ONE);
    11361 
    11362 	paren_level = paren_level - 1;
    11363 	if paren_level = 0 then
    11364 	     end_zero = end_zero + 1;
    11365 	go to have_token;
    11366 
    11367 /* Case , */
    11368 lexer (10):
    11369 	token_type = comma;
    11370 	if ASSIGN & paren_level = 0 & substr (st_copy, 1, 2) = "do" then
    11371 	     stmnt_type = do_statement;
    11372 
    11373 	call skip_characters (ONE);
    11374 	go to have_token;
    11375 
    11376 /* Case / */
    11377 lexer (11):
    11378 	token_type = slash;
    11379 	call skip_characters (ONE);
    11380 	if EOS then
    11381 	     go to have_token;
    11382 	if current_character ^= "/" then
    11383 	     go to have_token;
    11384 	token_type = concat;
    11385 	call skip_characters (ONE);
    11386 	go to have_token;
    11387 
    11388 /* Case ' apostrophe */
    11389 /* A little diddling added to handle ' strings within formats, but not
    11390*   preceeded by an operator, such as ( or ,.  bug 300.  Here detect the
    11391*   presence of a 6 character token as first on a line, followed by a
    11392*   left_parn, the best we can do other than actually setting a FORMAT flag. */
    11393 
    11394 lexer (12):
    11395 	token_type = apostrophe;
    11396 
    11397 	if paren_level = 1 & (last_token_type = right_parn | (last_token_type & is_operand) ^= ZERO)
    11398 	     & ^(last_token > 2 & token_list (2).length = 5 & token_list (3).type = left_parn) then do;
    11399 						/* apostrophe operator */
    11400 	     call skip_characters (ONE);
    11401 	     go to have_token;
    11402 	end;
    11403 	else do;					/* char str constant */
    11404 	     call build_string (apostrophe_char);
    11405 	     go to store_token_length;
    11406 	end;
    11407 
    11408 /* Case " quote */
    11409 lexer (13):
    11410 	call build_string (quote);
    11411 	go to store_token_length;
    11412 
    11413 /* Case * */
    11414 lexer (14):
    11415 	token_type = asterisk;
    11416 	call skip_characters (ONE);
    11417 	if EOS then
    11418 	     go to have_token;
    11419 	if current_character ^= "*" then
    11420 	     go to have_token;
    11421 	token_type = expon;
    11422 	call skip_characters (ONE);
    11423 	go to have_token;
    11424 
    11425 /* Case $ */
    11426 lexer (15):
    11427 	token_type = label_const;
    11428 	call skip_characters (ONE);
    11429 
    11430 	if ^EOS & char_type = digits then
    11431 	     call get_digits (ignore_value);
    11432 
    11433 	label_args = TRUE;
    11434 	go to store_token_length;
    11435 
    11436 /* Case ; */
    11437 lexer (16):
    11438 	if card_image then
    11439 	     go to lexer (0);
    11440 
    11441 	statement_offset, end_text = char_index + 1;	/* unless there is a newline, next stmnt starts here */
    11442 
    11443 /* add one to the statement count for this line. it is reset if a new line is read */
    11444 
    11445 	addr (statement_info) -> statement.statement =
    11446 	     bit (binary (binary (addr (statement_info) -> statement.statement, 5, 0) + 1, 5, 0), 5);
    11447 
    11448 	end_possible = FALSE;			/* end line cannot contain a semi-colon */
    11449 	call skip_characters (ONE);			/* skip over the semi-colon */
    11450 	statement_length = statement_length - 1;	/* to keep format parse happy */
    11451 
    11452 	EOS = TRUE;				/* semi-colon is the end of a statement */
    11453 	go to lex_next_token;			/* semi-colon is not stored in token table */
    11454 
    11455 /* Case : */
    11456 lexer (17):
    11457 	token_type = colon;
    11458 	call skip_characters (ONE);
    11459 	if ^ASSIGN then
    11460 	     COLON_BEFORE_ASSIGN = TRUE;
    11461 	go to have_token;
    11462 
    11463 get_continuation_line:
    11464      procedure (a_count);
    11465 
    11466 /*	Program Specifications (get_continuation_line)
    11467*
    11468*     Inputs
    11469*
    11470*     Output
    11471*
    11472*     Description (get_continuation_line)
    11473*
    11474*     NOTE - This procedure modifies:
    11475*	char_index
    11476*	st_copy
    11477*	statement_length
    11478*	token_length
    11479*	end_possible
    11480**/
    11481 
    11482 dcl      a_count fixed bin (18);
    11483 dcl      blank_count fixed bin (18);
    11484 dcl      const_max_len fixed bin (18);
    11485 dcl      i fixed bin (18);
    11486 dcl      len fixed bin (18);
    11487 dcl      more_on_this_line bit (1) aligned;
    11488 
    11489 
    11490 /* This entry point is used to get the next line if no blank suppression is desired. It also appends
    11491*	   blanks characters implied by card-image format that were removed as trailing white space.
    11492*	   Currently, it is only used if a character-string constant is continued onto a following line. */
    11493 
    11494 
    11495 	const_max_len = a_count;
    11496 	blank_count = min (const_max_len, extra_blanks);	/* number of blanks present and needed on this line */
    11497 	blank_cont_count = 0;			/* number of intervening completely blank cont. lines */
    11498 	end_possible = FALSE;			/* an endline cannot contain character-string constants */
    11499 
    11500 /* copy character-string constant value into temp buffer */
    11501 
    11502 	len = length (rest_of_line);			/* number of characters from this line */
    11503 	if len > 0 then
    11504 	     call concatenate_text;			/* must be something to concatenate */
    11505 
    11506 	if blank_count > 0				/* add blanks for original line */
    11507 	then do;
    11508 	     const_max_len = const_max_len - blank_count;
    11509 	     call concatenate_blanks;
    11510 	end;
    11511 
    11512 	call get_line_image (FORTRAN_ONLY);		/* Sets: type_of_line,EOS,blank_cont_count,extra_blanks */
    11513 
    11514 	if blank_cont_count > 0			/* If we have skipped over some completely blank
    11515*	then if const_max_len > 0			/* continuation lines, add to constant if needed. */
    11516 	then do;
    11517 	     blank_count = min (const_max_len, blank_cont_count * 66);
    11518 	     const_max_len = const_max_len - blank_count;
    11519 	     call concatenate_blanks;
    11520 	end;
    11521 
    11522 	a_count = const_max_len;
    11523 	return;
    11524 
    11525 
    11526 skip_characters:
    11527      entry (a_count);
    11528 
    11529 /* this entry point is called to skip zero or more characters and then find the next non-white character.
    11530*	   It also recognizes end lines as it is the only procedure with sufficient knowledge to make
    11531*	   the distinctions necessary */
    11532 
    11533 /* copy characters into temp buffer */
    11534 
    11535 	len = min (a_count, length (rest_of_line));	/* number of characters to cancatenate and skip */
    11536 	if len > 0 then
    11537 	     call concatenate_text;			/* must be something to concatenate */
    11538 
    11539 /* loop until a non-blank character or the end of the text */
    11540 
    11541 	more_on_this_line = length (rest_of_line) > 0;	/* something left on this line */
    11542 	current_character = substr (rest_of_line, 1, 1);
    11543 
    11544 	do while (TRUE);
    11545 
    11546 /* except for first line, always get a new line image */
    11547 
    11548 	     if ^more_on_this_line			/* only on if first line had remaining chars */
    11549 	     then do;
    11550 		if end_possible then
    11551 		     if statement_length = 3 then
    11552 			if translate (substr (st_copy, 1, 3), LOWER, UPPER) = "end" then do;
    11553 			     EOS = TRUE;
    11554 			     stmnt_type = end_line;
    11555 			     return;
    11556 			end;
    11557 
    11558 		call get_line_image (FORTRAN_ONLY);	/* Sets "type_of_line" & "EOS" */
    11559 		if type_of_line = no_more_source then
    11560 		     return;
    11561 	     end;
    11562 
    11563 	     else
    11564 		more_on_this_line = FALSE;		/* only used once per line image, if at all */
    11565 
    11566 	     call get_new_character;			/* determine character type */
    11567 
    11568 	     if EOS | char_type > 0 then
    11569 		return;				/* return if it is a Fortran character */
    11570 
    11571 	     i = verify (rest_of_line, WHITE) - 1;	/* is it white space? */
    11572 
    11573 	     if i >= 0				/* at least one non-blank left on this line */
    11574 	     then do;				/* skip it */
    11575 		if i > 0				/* actually was white space; get new character */
    11576 		then do;
    11577 		     char_index = char_index + i;	/* skip the white space */
    11578 		     current_character = substr (rest_of_line, 1, 1);
    11579 						/* new cur char needed */
    11580 		end;
    11581 
    11582 		if current_character ^= "!" | card_image/* found a non-blank character, return it */
    11583 		then do;
    11584 		     if i > 0 then
    11585 			call get_new_character;	/* determine character type */
    11586 		     return;
    11587 		end;
    11588 	     end;					/* skipping white space */
    11589 	end;
    11590 
    11591 /* should never exit this loop here */
    11592 
    11593 
    11594 /* Procedure to append extra blank characters implied by a short card-image record. */
    11595 
    11596 concatenate_blanks:
    11597      procedure;
    11598 
    11599 	if statement_length + blank_count > length (st_copy) then do;
    11600 	     call print_message (111, length (st_copy) - bias);
    11601 						/* text buffer overflow */
    11602 	     go to abort_lex;
    11603 	end;
    11604 
    11605 	else do;
    11606 	     substr (st_copy, statement_length + 1, blank_count) = " ";
    11607 	     statement_length = statement_length + blank_count;
    11608 	     token_length = token_length + blank_count;
    11609 	end;
    11610      end concatenate_blanks;
    11611 
    11612 
    11613 concatenate_text:
    11614      procedure;
    11615 
    11616 	if statement_length + len > length (st_copy) then do;
    11617 	     call print_message (111, length (st_copy) - bias);
    11618 						/* text buffer overflow */
    11619 	     go to abort_lex;
    11620 	end;
    11621 
    11622 	else do;
    11623 	     if translate_string			/* user specified folding and token requires it */
    11624 	     then do;
    11625 		substr (st_copy, statement_length + 1, len) = translate (substr (rest_of_line, 1, len), LOWER, UPPER);
    11626 		statement_length = statement_length + len;
    11627 						/* included here to keep "shorten_stack" call out of main line */
    11628 	     end;
    11629 	     else do;
    11630 		substr (st_copy, statement_length + 1, len) = substr (rest_of_line, 1, len);
    11631 		statement_length = statement_length + len;
    11632 	     end;
    11633 	     char_index = char_index + len;
    11634 	     token_length = token_length + len;
    11635 	end;
    11636      end concatenate_text;
    11637      end get_continuation_line;
    11638 
    11639 get_line_image:
    11640      procedure (options_flag);
    11641 
    11642 /*	Program Specifications (get_line_image)
    11643*
    11644*     Inputs
    11645*	options_flag indicates what sorts of lines are acceptable:
    11646*	     "00"b -- only standard FORTRAN program lines (FORTRAN_ONLY)
    11647*	     "01"b -- FORTRAN lines of %options lines (OPTIONS_OK)
    11648*	     "11"b -- FORTRAN, %options, %global ok (GLOBAL_OK)
    11649*
    11650*     Output
    11651*	options_flag is continuously updated to reflect the fact that %globals must precede %options,
    11652*	and that both must precede FORTRAN source statements, including comments.  By the time
    11653*	get_line_image returns, options_flag will be set to "00"b (FORTRAN_ONLY)
    11654*
    11655*     Description
    11656*
    11657*     this procedure isolates line images; it should be the only procedure to know about the actual
    11658*format of the source text
    11659*
    11660*THERE ARE TWO LEXERS -- CARD IMAGE and FREE FORM
    11661*
    11662*		The following block of code should be the only block of code to differentiate
    11663*		lines. For each type of source input three types of lines are defined:
    11664*
    11665*			1. Initial lines
    11666*			2. Continuation lines
    11667*			3. Comment lines
    11668*
    11669*		In the ansi77 standard, blank lines are treated differently  than they are in
    11670*		the 66 standard.  In ansi77 mode, they are comments, whereas in 66 mode they are initial lines.
    11671*
    11672*		Each lex shall define these three line types. Comment lines are useful to the reader of the
    11673*		source code and not to the parsers or token lexers.
    11674*
    11675*
    11676*	CARD IMAGE LEX
    11677*
    11678*		1. A comment line is any line whose first character is either a c, C, or *. This is the first
    11679*		      type of line to be checked for.
    11680*		2. An initial line is any line whose sixth character is neither a blank nor a zero.
    11681*		      Lines with fewer than six characters are initial lines.
    11682*		3. If neither of the above are satisfied, the line is a continuation line.
    11683*
    11684*	FREE FORM LEX
    11685*
    11686*		If the source text is required to have line numbers, they are processed and then
    11687*		stripped from the line.
    11688*
    11689*		1. A comment line is either: a) a line whose first character is a c or C, or
    11690*		   b) a line whose first non blank character is * or !.
    11691*		2. A continuation line is a line whose first non blank character is &.
    11692*		3. An initial line is any other line. A line containing no text is an initial line.
    11693*
    11694*
    11695*THERE IS ADDITIONALLY A PSEUDO-LEXER
    11696*
    11697*	which precedes the above, to recognize and process %options and %global statements, if they are
    11698*	allowed.  This processing has to be done at this point, since it is the first place at which
    11699*	the information necessary to process the statements is readily accessible, and the information
    11700*	is needed in this subprogram since it may affect which of the two lexers are to be used.
    11701*
    11702*     NOTE - This procedure modifies:
    11703*	char_index
    11704*	next_line_index
    11705*	EOS
    11706*	type_of_line
    11707*	subr_options
    11708*	segment_options
    11709**/
    11710 
    11711 dcl      ERROR bit (1) aligned int static options (constant) init ("0"b);
    11712 dcl      LEGAL_NON_WHITE_SPACE char (66) aligned int static options (constant)
    11713 	    init ("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890()=_");
    11714 dcl      RETURN bit (1) aligned int static options (constant) init ("1"b);
    11715 dcl      WHITE_AND_DIGITS char (12) aligned int static options (constant) init ("	 0123456789");
    11716 						/* ht sp digits */
    11717 dcl      depthx fixed bin (17);
    11718 dcl      file_string_index fixed bin (17);
    11719 dcl      file_string_length fixed bin (17);
    11720 dcl      i fixed bin (18);
    11721 dcl      include_file_bit_count fixed bin (24);
    11722 dcl      include_file_name char (256) varying;
    11723 dcl      include_file_ptr pointer;
    11724 dcl      just_white_space fixed bin (18) int static options (constant) init (-1);
    11725 dcl      line_no fixed dec (6);
    11726 dcl      options_flag bit (2) aligned;
    11727 dcl      percent_index fixed bin (18);
    11728 
    11729 dcl      last_label_line fixed bin (18) static;		/* source line of last label */
    11730 
    11731 dcl      1 line_no_overlay aligned structure based (addr (line_no)),
    11732 	 2 pad char (1) unaligned,
    11733 	 2 ln_digits char (6) unaligned;
    11734 
    11735 /* NOTE. use_source_info is ONLY ON IN get_line_image.  This is the peculiarity*/
    11736 /* of error message reporting.				         */
    11737 
    11738 	shared_structure.use_source_info = "1"b;
    11739 	end_text = next_line_index + 1;		/* stmnt len will not include following comment lines */
    11740 
    11741 	if options_flag then do;
    11742 	     if options_flag = GLOBAL_OK then do;
    11743 		segment_options = shared_structure.options.user_options;
    11744 		unspec (segment_declared) = "0"b;
    11745 	     end;
    11746 	     else
    11747 		subr_options = segment_options;
    11748 	     unspec (subr_declared) = "0"b;
    11749 	end;
    11750 
    11751 /* loop until a significant character is found */
    11752 
    11753 	type_of_line = just_white_space;
    11754 	do while (type_of_line = just_white_space);
    11755 
    11756 /* get the next line image or the end of text */
    11757 
    11758 NEED_NEW_LINE:					/* escape for case where options lexer eats the line. */
    11759 	     statement_offset, char_index = next_line_index + 1;
    11760 
    11761 	     if char_index >= source_len		/* no more text */
    11762 	     then do;
    11763 		call test_orphan_label;
    11764 		if file_stack_depth = 0 then do;
    11765 		     EOS = TRUE;
    11766 		     type_of_line = no_more_source;
    11767 		end;
    11768 
    11769 		else do;
    11770 		     file_stack_depth = file_stack_depth - 1;
    11771 		     seg_ptr = file_stack (file_stack_depth).fs_seg_ptr;
    11772 		     source_ptr = file_stack (file_stack_depth).fs_source_ptr;
    11773 		     next_line_index = file_stack (file_stack_depth).fs_end_of_line;
    11774 		     source_len = file_stack (file_stack_depth).fs_source_length;
    11775 		     source_line_number, line_number = file_stack (file_stack_depth).fs_line_number;
    11776 		     source_file_number, file_number = file_stack (file_stack_depth).fs_file_number;
    11777 		     addr (statement_info) -> statement.file = file_number;
    11778 		     go to NEED_NEW_LINE;
    11779 		end;
    11780 
    11781 		goto exit_get_line_image;
    11782 	     end;
    11783 
    11784 	     number_of_lines = number_of_lines + 1;	/* count lines */
    11785 
    11786 /* now find the end of this line */
    11787 
    11788 	     next_line_index = index (rest_of_text, NL) + char_index - 1;
    11789 	     if next_line_index < char_index then
    11790 		next_line_index = source_len;
    11791 	     end_of_line = next_line_index;		/* line ends with the beginning of the next one */
    11792 
    11793 	     if produce_listing then do;
    11794 		source_list (number_of_lines).file_number = file_number;
    11795 		source_list (number_of_lines).line_start = statement_offset;
    11796 		source_list (number_of_lines).line_length = next_line_index - statement_offset + 1;
    11797 		source_list (number_of_lines).line_number_in_file = line_number + 1;
    11798 	     end;
    11799 
    11800 /* %(OPTIONS GLOBAL INCLUDE) PSEUDO-LEX */
    11801 
    11802 	     percent_index = verify (rest_of_line, WHITE_AND_DIGITS);
    11803 
    11804 	     if percent_index > 0 then
    11805 		if substr (rest_of_line, percent_index, 1) = "%" then
    11806 		     call test_orphan_label;
    11807 	     if percent_index > 0 then
    11808 		if substr (rest_of_line, percent_index, 1) = "%" then
    11809 		     if translate (substr (rest_of_line, percent_index, 8), LOWER, UPPER) = "%include" then do;
    11810 
    11811 			source_line_number, line_number = line_number + 1;
    11812 			char_index = char_index + percent_index + 7;
    11813 
    11814 			if length (rest_of_line) <= 0 then do;
    11815 			     call print_message (160);
    11816 			     go to NEED_NEW_LINE;
    11817 			end;
    11818 
    11819 			file_string_index = verify (rest_of_line, WHITE);
    11820 			char_index = char_index + file_string_index - 1;
    11821 			if length (rest_of_line) <= 0 then do;
    11822 			     call print_message (160);
    11823 			     go to NEED_NEW_LINE;
    11824 			end;
    11825 
    11826 			file_string_length = search (rest_of_line, WHITE) - 1;
    11827 
    11828 			if file_string_length <= 0 then
    11829 			     file_string_length = length (rest_of_line);
    11830 			if file_string_length >= 244 then do;
    11831 			     call print_message (161, substr (rest_of_line, 1, file_string_length));
    11832 			     go to NEED_NEW_LINE;
    11833 			end;
    11834 
    11835 			include_file_name = substr (rest_of_line, 1, file_string_length) || ".incl.fortran";
    11836 
    11837 			call find_include_file_$initiate_count (command, source_ptr, (include_file_name),
    11838 			     include_file_bit_count, include_file_ptr, code);
    11839 			if include_file_ptr = null	/* file not found */
    11840 			then do;
    11841 			     call print_message (162, include_file_name);
    11842 			     if code ^= 0 & code ^= error_table_$noentry then
    11843 				call com_err_ (code, command, "^a", include_file_name);
    11844 			     go to NEED_NEW_LINE;
    11845 			end;
    11846 
    11847 
    11848 			if shared_structure.incl_count > 255 then do;
    11849 			     call hcs_$terminate_noname (include_file_ptr, code);
    11850 			     call print_message (163, include_file_name);
    11851 			     go to NEED_NEW_LINE;
    11852 			end;
    11853 
    11854 			if file_stack_depth > hbound (file_stack, 1) then do;
    11855 			     call hcs_$terminate_noname (include_file_ptr, code);
    11856 			     call print_message (164, include_file_name);
    11857 			     go to NEED_NEW_LINE;
    11858 			end;
    11859 
    11860 			file_stack (file_stack_depth).fs_seg_ptr = seg_ptr;
    11861 			file_stack (file_stack_depth).fs_source_ptr = source_ptr;
    11862 			file_stack (file_stack_depth).fs_end_of_line = end_of_line;
    11863 			file_stack (file_stack_depth).fs_source_length = source_len;
    11864 			file_stack (file_stack_depth).fs_line_number = line_number;
    11865 			file_stack (file_stack_depth).fs_file_number =
    11866 			     binary (addr (statement_info) -> statement.file, 8, 0);
    11867 
    11868 			do depthx = lbound (file_stack, 1) to file_stack_depth;
    11869 			     if file_stack (depthx).fs_source_ptr = include_file_ptr then do;
    11870 				call hcs_$terminate_noname (include_file_ptr, code);
    11871 				call print_message (165, include_file_name);
    11872 				go to NEED_NEW_LINE;
    11873 			     end;
    11874 			end;
    11875 
    11876 			file_stack_depth = file_stack_depth + 1;
    11877 			shared_structure.incl_count = shared_structure.incl_count + 1;
    11878 
    11879 			call translator_info_$component_get_source_info (include_file_ptr, dname, ename, cname, dtm,
    11880 			     uid, code);
    11881 			if code ^= 0 then do;
    11882 			     if code = error_table_$no_s_permission then
    11883 				call print_message (188, include_file_name);
    11884 			     else
    11885 				call com_err_ (code, command, "^a", include_file_name);
    11886 			     cname = "";
    11887 			     if substr (include_file_name, 1, 1) ^= ">" then do;
    11888 				dname = "UNKNOWN DIRECTORY NAME";
    11889 				ename = include_file_name;
    11890 			     end;
    11891 			     else do;
    11892 				ename = reverse (before (reverse (include_file_name), ">"));
    11893 				dname = before (include_file_name || " ", ">" || rtrim (ename) || " ");
    11894 			     end;
    11895 			     uid = ""b;
    11896 			     dtm = 0;
    11897 			end;
    11898 
    11899 			number_of_source_segments = number_of_source_segments + 1;
    11900 			i = 63 - divide (length (ename) + length (dname), chars_per_word, 17, 0);
    11901 
    11902 			indx = create_node (source_node, size (source) - i);
    11903 			seg_chain_end_ptr -> source.next = indx;
    11904 			cur_segment = indx;
    11905 			seg_chain_end_ptr, seg_ptr = addr (OS (cur_segment));
    11906 
    11907 			if cname = "" then
    11908 			     seg_ptr -> source.pathname = rtrim (dname) || ">" || rtrim (ename);
    11909 			else
    11910 			     seg_ptr -> source.pathname =
    11911 				rtrim (dname) || ">" || before (ename, ".archive") || "::" || rtrim (cname);
    11912 			seg_ptr -> source.uid = uid;
    11913 			seg_ptr -> source.dtm = dtm;
    11914 			seg_ptr -> source.line_number = number_of_lines;
    11915 
    11916 			source_ptr = include_file_ptr;
    11917 			char_index = 0;
    11918 			source_len = divide (include_file_bit_count + 8, 9, 21, 0);
    11919 			source_line_number, line_number = 0;
    11920 			source_file_number, file_number = shared_structure.incl_count;
    11921 			addr (statement_info) -> statement.file = file_number;
    11922 			next_line_index = -1;
    11923 
    11924 			shared_structure.source_node_offset (shared_structure.incl_count) = cur_segment;
    11925 			shared_structure.incl_len (shared_structure.incl_count) = source_len;
    11926 			shared_structure.incl_ptr (shared_structure.incl_count) = source_ptr;
    11927 
    11928 			go to NEED_NEW_LINE;
    11929 		     end;
    11930 
    11931 		     else if options_flag then
    11932 			if translate (substr (rest_of_line, percent_index, 7), LOWER, UPPER) = "%global" then do;
    11933 			     source_line_number, line_number = line_number + 1;
    11934 			     if options_flag = GLOBAL_OK then
    11935 				call lex_global;
    11936 			     else
    11937 				call print_message (193);
    11938 			     go to NEED_NEW_LINE;
    11939 			end;
    11940 
    11941 			else if translate (substr (rest_of_line, percent_index, 8), LOWER, UPPER) = "%options"
    11942 			then do;
    11943 			     if options_flag = GLOBAL_OK then do;
    11944 				options_flag = OPTIONS_OK;
    11945 				call fort_defaults_$check_global_args (addr (segment_declared),
    11946 				     addr (shared_structure.declared_options), print_message);
    11947 						/* check for any conflicts between arguments and %globals */
    11948 				unspec (segment_declared) =
    11949 				     unspec (segment_declared) | unspec (shared_structure.declared_options);
    11950 				call fort_defaults_$set (addr (segment_declared), addr (segment_options));
    11951 				shared_structure.options.user_options = segment_options;
    11952 				call set_max_array_size;
    11953 				subr_options = segment_options;
    11954 				shared_structure.declared_options = segment_declared;
    11955 				call fort_defaults_$init_shared_vars (addr (shared_structure));
    11956 			     end;
    11957 			     source_line_number, line_number = line_number + 1;
    11958 			     call lex_options;
    11959 			     go to NEED_NEW_LINE;
    11960 			end;
    11961 
    11962 	     if options_flag ^= FORTRAN_ONLY then do;
    11963 		if options_flag = GLOBAL_OK then do;
    11964 		     call fort_defaults_$check_global_args (addr (segment_declared),
    11965 			addr (shared_structure.declared_options), print_message);
    11966 						/* check for any conflicts between arguments and %globals */
    11967 		     unspec (segment_declared) =
    11968 			unspec (segment_declared) | unspec (shared_structure.declared_options);
    11969 		     call fort_defaults_$set (addr (segment_declared), addr (segment_options));
    11970 		     shared_structure.options.user_options = segment_options;
    11971 		     call set_max_array_size;
    11972 		     subr_options = segment_options;
    11973 		     shared_structure.declared_options = segment_declared;
    11974 		     call fort_defaults_$init_shared_vars (addr (shared_structure));
    11975 		end;
    11976 		card_image = subr_options.card;
    11977 		fold_option = subr_options.fold;
    11978 		if subr_options.ansi_77 then
    11979 		     default_char_size = 1;
    11980 		else
    11981 		     default_char_size = 8;
    11982 	     end;
    11983 
    11984 /* CARD IMAGE LEX */
    11985 
    11986 	     if card_image then do;
    11987 		source_line_number, line_number = line_number + 1;
    11988 						/* use sequence number as the line number */
    11989 
    11990 		if length (rest_of_line) <= 0 then
    11991 		     EOS = ^subr_options.ansi_77;
    11992 		else do;
    11993 		     if length (rest_of_line) > 72	/* only use 72 columns per card */
    11994 		     then do;
    11995 			if length (rest_of_line) > 80 /* warn user of a long card image */
    11996 			     then
    11997 			     call print_message (132);
    11998 
    11999 			end_of_line = char_index + 72;
    12000 		     end;
    12001 
    12002 		     if substr (rest_of_line, 1, 1) ^= "c" & substr (rest_of_line, 1, 1) ^= "C"
    12003 			& substr (rest_of_line, 1, 1) ^= "*" then
    12004 			if length (rest_of_line) < 6	/* column 6 is blank, an initial line */
    12005 			then do;
    12006 			     EOS = ^subr_options.ansi_77;
    12007 			     if rest_of_line ^= ""	/* Initial line */
    12008 				then
    12009 				EOS = TRUE;
    12010 			     call lex_label_field (length (rest_of_line), ERROR);
    12011 			end;
    12012 			else if substr (rest_of_line, 6, 1) ^= " " & substr (rest_of_line, 6, 1) ^= "0" then
    12013 			     if length (rest_of_line) > 6
    12014 						/* a non blank continuation line */
    12015 			     then do;
    12016 				char_index = char_index + 6;
    12017 				extra_blanks = max (0, 66 - length (rest_of_line));
    12018 				end_possible = FALSE;
    12019 						/* cont line cannot be end line */
    12020 				type_of_line = continuation_line;
    12021 			     end;
    12022 
    12023 /* blank continuation line -- treat as comment line */
    12024 
    12025 			     else
    12026 				blank_cont_count = blank_cont_count + 1;
    12027 
    12028 			else do;			/* possibly an initial line */
    12029 			     EOS = (substr (rest_of_line, 6, 1) = "0" | ^subr_options.ansi_77);
    12030 			     if rest_of_line ^= " "	/* Determine if comment */
    12031 				then
    12032 				EOS = TRUE;
    12033 			     call lex_label_field (5, ERROR);
    12034 			     char_index = char_index + 1;
    12035 						/* skip continuation field */
    12036 
    12037 /* find first non blank char on this line or get another line */
    12038 
    12039 			     if length (rest_of_line) > 0 then do;
    12040 				i = verify (rest_of_line, WHITE) - 1;
    12041 				if i >= 0		/* non blank found */
    12042 				then do;
    12043 				     EOS = TRUE;
    12044 				     extra_blanks = max (0, 66 - length (rest_of_line));
    12045 				     char_index = char_index + i;
    12046 				     end_possible = TRUE;
    12047 						/* init line can be end line */
    12048 				     type_of_line = initial_line;
    12049 				end;
    12050 			     end;
    12051 			end;
    12052 		end;				/* non blank lines */
    12053 	     end;					/* CARD IMAGE LEX */
    12054 
    12055 
    12056 /* FREE FORM LEX */
    12057 
    12058 	     else do;
    12059 
    12060 		if line_numbered_text		/* for line numbered text, lex a line number */
    12061 		then do;
    12062 		     i = verify (rest_of_line, DIGIT) - 1;
    12063 						/* count digits in line number */
    12064 		     if i < 0 then
    12065 			i = length (rest_of_line);	/* entire line is digits (or length(line) = 0) */
    12066 
    12067 		     if i = 0 then
    12068 			call print_message (113, rest_of_line);
    12069 						/* missing line number */
    12070 
    12071 		     else do;			/* process line number field */
    12072 			if i - length (ln_digits) > 0 /* limit length of line number */
    12073 			then do;
    12074 			     call print_message (114, substr (rest_of_line, 1, i));
    12075 						/* line number too long */
    12076 			     char_index = char_index + (i - length (ln_digits));
    12077 						/* skip excess digits */
    12078 			     i = length (ln_digits);
    12079 			end;
    12080 
    12081 			line_no = 0;		/* convert line number to binary */
    12082 			substr (ln_digits, length (ln_digits) - i + 1, i) = substr (rest_of_line, 1, i);
    12083 
    12084 			char_index = char_index + i;	/* skip line number field */
    12085 
    12086 			if line_no <= line_number	/* sequence check the line number */
    12087 			     then
    12088 			     call print_message (115, ln_digits, char (decimal (line_number, 12)));
    12089 						/* out of sequence */
    12090 
    12091 			source_line_number, line_number = line_no;
    12092 						/* set current line number */
    12093 		     end;				/* processing existing line number */
    12094 		end;				/* lex for line numbers */
    12095 
    12096 		else
    12097 		     source_line_number, line_number = line_number + 1;
    12098 						/* no line numbers, use sequence number */
    12099 
    12100 		if length (rest_of_line) <= 0 then
    12101 		     EOS = ^subr_options.ansi_77;
    12102 		else if substr (rest_of_line, 1, 1) ^= "c" & substr (rest_of_line, 1, 1) ^= "C" then do;
    12103 
    12104 		     i = verify (rest_of_line, WHITE) - 1;
    12105 		     if i < 0 then
    12106 			EOS = ^subr_options.ansi_77;
    12107 		     else do;			/* a line with text */
    12108 			char_index = char_index + i;
    12109 			current_character = substr (rest_of_line, 1, 1);
    12110 
    12111 			if current_character ^= "*" & current_character ^= "!" then
    12112 			     if current_character = "&" then do;
    12113 						/* continuation line */
    12114 				char_index = char_index + 1;
    12115 						/* skip "&" */
    12116 				if length (rest_of_line) > 0 then do;
    12117 				     end_possible = FALSE;
    12118 						/* cont line cannot be end line */
    12119 				     type_of_line = continuation_line;
    12120 				end;
    12121 			     end;
    12122 			     else do;		/* initial line */
    12123 				call test_orphan_label;
    12124 				call get_new_character;
    12125 						/* Sets "char_type" */
    12126 
    12127 				if char_type = digits
    12128 						/* lex label field if it exists */
    12129 				     then
    12130 				     call lex_label_field (length (rest_of_line), RETURN);
    12131 
    12132 				if length (rest_of_line) > 0 then do;
    12133 				     end_possible = TRUE;
    12134 						/* init line can be end line */
    12135 				     type_of_line = initial_line;
    12136 				end;
    12137 				EOS = TRUE;
    12138 			     end;			/* initial line */
    12139 		     end;				/* non blank line */
    12140 		end;				/* non comment line */
    12141 
    12142 		else do;				/* Quick cheap check to catch some unintended comments */
    12143 		     if index (LEGAL_NON_WHITE_SPACE, substr (rest_of_line, 2, 1)) ^= 0 then do;
    12144 			line_number_pic = line_number;
    12145 			file_number_pic = -file_number;
    12146 			call print_message (148, file_number_pic, line_number_pic);
    12147 		     end;
    12148 		end;
    12149 	     end;					/* FREE FORM LEX */
    12150 
    12151 	end;					/* loop to get significant character */
    12152 
    12153 	if options_flag ^= FORTRAN_ONLY then
    12154 	     options_flag = FORTRAN_ONLY;
    12155 
    12156 	addr (statement_info) -> statement.statement = "00001"b;
    12157 						/* reset statement count for line */
    12158 
    12159 	current_character = substr (rest_of_line, 1, 1);	/* return character just found */
    12160 exit_get_line_image:
    12161 	shared_structure.use_source_info = "0"b;	/* TURN OFF SOURCE LINE NUMBERS */
    12162 	return;
    12163 
    12164 lex_global:
    12165      procedure;
    12166 
    12167 dcl      option char (32);
    12168 
    12169 	char_index = char_index + percent_index + 7;
    12170 
    12171 	call get_next_option (option);
    12172 
    12173 	do while (option ^= "");
    12174 
    12175 	     call fort_defaults_$global (addr (option), length (option), addr (segment_declared), print_message);
    12176 
    12177 	     call get_next_option (option);
    12178 
    12179 	end;
    12180 
    12181 	return;
    12182      end lex_global;
    12183 
    12184 lex_options:
    12185      procedure;
    12186 
    12187 dcl      option char (32);
    12188 
    12189 	char_index = char_index + percent_index + 8;
    12190 
    12191 	call get_next_option (option);
    12192 
    12193 	do while (option ^= "");
    12194 
    12195 	     call fort_defaults_$option (addr (option), length (option), addr (subr_options), addr (subr_declared),
    12196 		addr (segment_options), have_auto_option, have_static_option, print_message);
    12197 
    12198 	     call get_next_option (option);
    12199 
    12200 	end;
    12201 
    12202 	return;
    12203      end lex_options;
    12204 
    12205 get_next_option:
    12206      procedure (option);
    12207 
    12208 dcl      i fixed bin (18);
    12209 dcl      option char (32);
    12210 dcl      OPTION_DELIMS char (4) static int options (constant) init ("	 ,;");
    12211 						/* tab, space, comma, semi */
    12212 dcl      OPTION_SKIP char (3) static int options (constant) init ("	 ,");
    12213 						/* tab, space, comma */
    12214 
    12215 	i = verify (rest_of_line, OPTION_SKIP) - 1;
    12216 	if i < 0 then do;
    12217 	     option = "";
    12218 	     char_index = char_index + length (rest_of_line);
    12219 	     return;
    12220 	end;
    12221 
    12222 	else do;
    12223 	     char_index = char_index + i;
    12224 
    12225 	     if substr (rest_of_line, 1, 1) = ";" then do;
    12226 		option = "";
    12227 		char_index = char_index + length (rest_of_line);
    12228 		return;
    12229 	     end;
    12230 
    12231 	     i = search (rest_of_line, OPTION_DELIMS) - 1;
    12232 	     if i < 0 then
    12233 		i = length (rest_of_line);
    12234 
    12235 	     if i = 0 then
    12236 		option = "";
    12237 
    12238 	     else do;
    12239 		if substr (rest_of_line, i, 1) = ";" then
    12240 		     i = i - 1;
    12241 		option = translate (substr (rest_of_line, 1, min (i, 32)), LOWER, UPPER);
    12242 		char_index = char_index + i;
    12243 	     end;
    12244 
    12245 	end;
    12246 
    12247 	return;
    12248      end get_next_option;
    12249 
    12250 
    12251 lex_label_field:
    12252      procedure (width, action_on_non_numeric);
    12253 
    12254 dcl      action_on_non_numeric bit (1) aligned;
    12255 dcl      digit fixed bin (18);
    12256 dcl      loop_index fixed bin (18);
    12257 dcl      numeric bit (1) aligned;
    12258 dcl      width fixed bin (18);
    12259 
    12260 	call test_orphan_label;			/* ensure no label outstanding */
    12261 	numeric = FALSE;				/* no digits encountered */
    12262 
    12263 	do loop_index = 1 to width;
    12264 	     digit = binary (unspec (substr (rest_of_line, 1, 1)), 9, 0);
    12265 	     if digit > hbound (token_table, 1) then
    12266 		char_type = 0;
    12267 	     else
    12268 		char_type = token_table (digit);
    12269 
    12270 	     if char_type = digits then do;
    12271 		next_statement_label = next_statement_label * 10 + digit - 000110000b;
    12272 		numeric = TRUE;
    12273 	     end;
    12274 
    12275 	     else if char_type ^= just_white_space then do;
    12276 		if action_on_non_numeric = ERROR then do;
    12277 		     call print_message (133);
    12278 		     char_index = char_index + (width - loop_index + 1);
    12279 		end;
    12280 
    12281 		if numeric & next_statement_label = 0 then
    12282 		     call print_message (69, "0");
    12283 		return;
    12284 	     end;
    12285 
    12286 	     char_index = char_index + 1;
    12287 	end;
    12288 
    12289 	if numeric then
    12290 	     if next_statement_label = 0 then
    12291 		call print_message (69, "0");
    12292 	     else
    12293 		last_label_line = source_line_number;
    12294      end lex_label_field;
    12295 
    12296 test_orphan_label:
    12297      proc;
    12298 
    12299 /* Declare error if there is an orphan statement label */
    12300 
    12301 /* see if there is a left over statement label */
    12302 /* code moved from "get_line_image to prevent navy bug #1 */
    12303 
    12304 	if next_statement_label ^= 0 then do;
    12305 	     source_line_number = last_label_line;
    12306 	     call print_message (131);		/* label without text */
    12307 	     source_line_number = line_number;
    12308 	     next_statement_label = 0;
    12309 	end;
    12310      end test_orphan_label;
    12311      end get_line_image;
    12312 
    12313 
    12314 get_new_character:
    12315      procedure;
    12316 
    12317 	char_value = current_character;		/* do not want current_character to have an alias */
    12318 	if binary (bit_value, 9, 0) > hbound (token_table, 1)
    12319 						/* non ASCII character */
    12320 	     then
    12321 	     char_type = 0;
    12322 	else
    12323 	     char_type = token_table (binary (bit_value, 9, 0));
    12324      end get_new_character;
    12325 
    12326 get_digits:
    12327      procedure (digit_count);
    12328 
    12329 /*	Program Specifications (get_digits)
    12330*
    12331*     Inputs
    12332*
    12333*     Output
    12334*
    12335*     Description (get_digits)
    12336*
    12337*     NOTE - This procedure modifies:
    12338*	EOS
    12339*	text_bit
    12340**/
    12341 
    12342 dcl      i fixed bin (18);
    12343 dcl      d_count fixed bin (18);
    12344 dcl      digit_count fixed bin (18);
    12345 
    12346 	d_count = 0;
    12347 
    12348 	lexing_a_token = TRUE;
    12349 	do while (lexing_a_token);
    12350 	     i = verify (rest_of_line, DIGIT) - 1;
    12351 	     if i = 0 then
    12352 		lexing_a_token = FALSE;
    12353 	     else do;
    12354 		if i < 0 then
    12355 		     i = length (rest_of_line);
    12356 		call skip_characters (i);
    12357 		d_count = d_count + i;
    12358 		if EOS then
    12359 		     lexing_a_token = FALSE;
    12360 		else if char_type ^= digits then
    12361 		     lexing_a_token = FALSE;
    12362 	     end;
    12363 	end;
    12364 
    12365 	digit_count = d_count;
    12366      end get_digits;
    12367 
    12368 build_fortran_operator:
    12369      procedure;
    12370 
    12371 /*	Program Specifications (build_fortran_operator)
    12372*
    12373*     Inputs
    12374*
    12375*     Output
    12376*
    12377*     Description (build_fortran_operator)
    12378**/
    12379 
    12380 dcl      i fixed bin (18);
    12381 dcl      sp_op_name (13) char (8) aligned int static options (constant)
    12382 	    init (".not.", ".and.", ".or.", ".eq.", ".ne.", ".lt.", ".gt.", ".le.", ".ge.", ".false.", ".true.",
    12383 	    ".eqv.", ".neqv.");
    12384 dcl      sp_op_type (13) bit (9) aligned int static options (constant)
    12385 	    init ("010000110"b, "010000111"b, "010001000"b, "010001001"b, "010001010"b, "010001011"b, "010001100"b,
    12386 	    "010001101"b, "010001110"b, "001000010"b, "001000011"b, "010010111"b, "010011000"b);
    12387 
    12388 	lexing_a_token = TRUE;
    12389 	do while (lexing_a_token);
    12390 	     i = verify (rest_of_line, alphabetic) - 1;
    12391 	     if i = 0 then
    12392 		lexing_a_token = FALSE;
    12393 	     else do;
    12394 		if i < 0 then
    12395 		     i = length (rest_of_line);
    12396 		call skip_characters (i);
    12397 		if EOS then
    12398 		     lexing_a_token = FALSE;
    12399 		else if char_type ^= letters then
    12400 		     lexing_a_token = FALSE;
    12401 	     end;
    12402 	end;
    12403 
    12404 	if EOS then do;
    12405 	     call print_message (116);		/* missing "." */
    12406 	     go to lex_next_token;
    12407 	end;
    12408 
    12409 	if current_character ^= "." then do;
    12410 	     call print_message (116);		/* missing "." */
    12411 	     go to lex_next_token;
    12412 	end;
    12413 
    12414 	call skip_characters (ONE);
    12415 
    12416 	if token_length > length (sp_op_name (1)) then do;
    12417 	     call print_message (117, token_string);	/* unknown operator */
    12418 	     go to lex_next_token;
    12419 	end;
    12420 
    12421 	substr (fast_lookup, 1, length (sp_op_name (1))) = token_string;
    12422 
    12423 	do i = 1 to hbound (sp_op_name, 1) while (substr (fast_lookup, 1, length (sp_op_name (1))) ^= sp_op_name (i));
    12424 	end;
    12425 
    12426 	if i > hbound (sp_op_name, 1) then do;
    12427 	     call print_message (117, token_string);	/* unknown operator */
    12428 	     go to lex_next_token;
    12429 	end;
    12430 
    12431 	token_type = sp_op_type (i);
    12432      end build_fortran_operator;
    12433 
    12434 parse_exponent:
    12435      procedure;
    12436 
    12437 /*	Program Specifications (parse_exponent)
    12438*
    12439*     Inputs
    12440*
    12441*     Output
    12442*
    12443*     Description (parse_exponent)
    12444**/
    12445 
    12446 	exp = 0;
    12447 	if EOS then do;
    12448 	     if token_type ^= dec_int then
    12449 		call store_real_constant;
    12450 	     return;
    12451 	end;
    12452 	if current_character = "d" | current_character = "D" then
    12453 	     token_type = double_const;
    12454 	else if current_character = "e" | current_character = "E" then
    12455 	     token_type = real_const;
    12456 	else if token_type = dec_int then
    12457 	     return;
    12458 	else do;
    12459 	     if t_scale > 0 | char_type ^= letters then
    12460 		call store_real_constant;
    12461 	     return;
    12462 	end;
    12463 	call skip_characters (ONE);
    12464 
    12465 	if EOS then do;
    12466 	     call missing_exponent;
    12467 	     return;
    12468 	end;
    12469 
    12470 	exp = token_length;
    12471 
    12472 	if current_character = "+" then do;
    12473 	     operator_follows = FALSE;
    12474 	     translate_string = FALSE;		/* translation is no longer necessary */
    12475 
    12476 	     call skip_characters (ONE);
    12477 	     exp = exp + 1;
    12478 	end;
    12479 	else if current_character = "-" then do;
    12480 	     operator_follows = FALSE;
    12481 	     translate_string = FALSE;		/* translation is no longer necessary */
    12482 
    12483 	     call skip_characters (ONE);
    12484 	     exp = -token_length;
    12485 	end;
    12486 
    12487 	if EOS then do;
    12488 	     call missing_exponent;
    12489 	     return;
    12490 	end;
    12491 
    12492 	if char_type = digits then do;
    12493 	     call get_digits (ignore_value);
    12494 	     call store_real_constant;
    12495 	end;
    12496 	else if ^operator_follows then
    12497 	     call missing_exponent;
    12498 
    12499 	return;
    12500 
    12501 
    12502 store_real_constant:
    12503      procedure;
    12504 
    12505 	operator_follows = FALSE;
    12506 	translate_string = FALSE;			/* translation is no longer necessary */
    12507 
    12508 	const_count = const_count + 1;
    12509 	if const_count > hbound (constant_array, 1)	/* check for constant table overflow */
    12510 	then do;
    12511 	     if const_count = hbound (constant_array, 1) + 1
    12512 						/* only print message once */
    12513 		then
    12514 		call print_message (110, hbound (constant_array, 1) - bias);
    12515 	     go to lex_next_token;
    12516 	end;
    12517 
    12518 	constant_array (const_count).prec = precision;
    12519 	constant_array (const_count).scale = t_scale;
    12520 	constant_array (const_count).exponent = exp;
    12521 	constant_array (const_count).length = token_length - 1;
    12522 	token_length = const_count;
    12523      end store_real_constant;
    12524 
    12525 
    12526 missing_exponent:
    12527      procedure;
    12528 
    12529 	call print_message (118);
    12530 	exp = 0;
    12531 	call store_real_constant;
    12532      end missing_exponent;
    12533      end parse_exponent;
    12534 
    12535 build_string:
    12536      procedure (delimiter);
    12537 
    12538 /*	Program Specifications (build_string)
    12539*
    12540*     Inputs
    12541*
    12542*     Output
    12543*
    12544*     Description (build_string)
    12545*	Modified 01/28/77 to allow embedded delimiters in char strings.
    12546**/
    12547 
    12548 dcl      embedded bit (1) aligned;
    12549 dcl      delimiter char (1) aligned;
    12550 dcl      len fixed bin (18);
    12551 dcl      len_pic picture "zz9";
    12552 dcl      off fixed bin (18);
    12553 dcl      temp_str char (512);
    12554 
    12555 	token_offset = statement_length + 1;
    12556 	token_length = -1;
    12557 	token_type = char_string;
    12558 
    12559 	off = 1;					/* skip over initial delimiter */
    12560 	embedded = FALSE;				/* no embedded delimiters found */
    12561 
    12562 	do while (TRUE);
    12563 
    12564 	     len = index (substr (rest_of_line, off + 1), delimiter) + off;
    12565 
    12566 	     if len = off				/* delimiter not found, add rest of line */
    12567 	     then do;
    12568 		call get_continuation_line ((max_fixed_bin_18));
    12569 						/* get next line */
    12570 
    12571 		if EOS				/* oops, no more lines for us */
    12572 		then do;
    12573 		     call print_message (109);
    12574 		     call get_new_character;		/* prime the lex */
    12575 		     go to return_string;
    12576 		end;
    12577 
    12578 		off = 0;				/* begin with first character */
    12579 	     end;
    12580 
    12581 	     else do;				/* see if encountered delimiter terminates the string */
    12582 		if len = length (rest_of_line) then do; /* following char is on next line */
    12583 
    12584 		     if extra_blanks > 0 then
    12585 			go to final_delimiter;	/* last char followed by blank, must be delim */
    12586 
    12587 		     call get_continuation_line (0);	/* no blanks follow, so get next line */
    12588 
    12589 		     if blank_cont_count > 0		/* line of blanks follow, so must be delim */
    12590 		     then do;
    12591 			len = 0;			/* Characters have already been skipped */
    12592 			go to final_delimiter;
    12593 		     end;
    12594 
    12595 		     if EOS then do;
    12596 			token_length = token_length - 1;
    12597 						/* length does not include the delimiters */
    12598 			call get_new_character;	/* prime the lex */
    12599 			go to return_string;
    12600 		     end;
    12601 
    12602 		     off, len = 0;			/* want the first char on the line */
    12603 		end;
    12604 
    12605 		if substr (rest_of_line, len + 1, 1) ^= delimiter then do;
    12606 						/* the final delimiter, done */
    12607 final_delimiter:
    12608 		     call skip_characters (len);
    12609 
    12610 		     token_length = token_length - 1;	/* length does not include the delimiters */
    12611 		     go to return_string;
    12612 		end;
    12613 
    12614 		embedded = TRUE;			/* an embedded delimiter; remove one from the const */
    12615 		call skip_characters (len);		/* next char is obviously non-blank */
    12616 
    12617 		token_length = token_length - 1;	/* remove first delimiter of the pair from */
    12618 		statement_length = statement_length - 1;/* from the constant's value */
    12619 
    12620 		off = 1;				/* continue processing with second delimiter */
    12621 	     end;
    12622 	end;
    12623 
    12624 /* loop cannot exit here */
    12625 
    12626 return_string:
    12627 	if token_length = 0 then
    12628 	     call print_message (108);		/* string length is zero */
    12629 	else if embedded				/* for format statements, strings with embedded */
    12630 	     then
    12631 	     if substr (st_copy, 1, 6) = "format"	/* delimiters must be converted to hollerith consts */
    12632 	     then do;
    12633 		if token_length > 512		/* string is too long */
    12634 		then do;
    12635 		     call print_message (124, 512 - bias);
    12636 						/* token length too long */
    12637 		     token_length = 512;
    12638 		end;
    12639 
    12640 		substr (temp_str, 1, token_length) = token_string;
    12641 						/* save str value */
    12642 
    12643 		statement_length = token_offset - 1;	/* remove original string from buffer */
    12644 
    12645 		len_pic = token_length;		/* build length field for hollerith const */
    12646 		off = verify (len_pic, WHITE);	/* first significant char */
    12647 		len = length (len_pic) - off + 1;	/* number of digits */
    12648 
    12649 		if statement_length + len + 1 + token_length > length (st_copy)
    12650 						/* will it fit? */
    12651 		then do;
    12652 		     call print_message (111, length (st_copy) - bias);
    12653 						/* text buffer overflow */
    12654 		     go to abort_lex;
    12655 		end;
    12656 
    12657 		substr (st_copy, statement_length + 1, len) = substr (len_pic, off, len);
    12658 		statement_length = statement_length + len + 1;
    12659 		substr (st_copy, statement_length, 1) = "h";
    12660 
    12661 		token_offset = statement_length;	/* new offset */
    12662 
    12663 		token_string = substr (temp_str, 1, token_length);
    12664 						/* move value back */
    12665 		statement_length = statement_length + token_length;
    12666 	     end;
    12667      end build_string;
    12668      end statement_lex;
    12669 
    12670 convert_integer_constant:
    12671      procedure (off, len) returns (bit (72) aligned);
    12672 
    12673 /*	Program Specifications (convert_integer_constant)
    12674*
    12675*     Inputs
    12676*	Arguments
    12677*	     off - Offset into the character string "st_copy" at which the character representation
    12678*		 of the value to be converted is stored.
    12679*	     len - Length of the string to be converted.
    12680*
    12681*	Implicit Arguments
    12682*	     sign - (Declared in the procedure parse_source.) This variable is used to simulate
    12683*		a condition handler for fixedoverflow in order to allow the conversion of the
    12684*		value -34359738368.  If "sign" has the value "minus", the conversion succeeds;
    12685*		otherwise the conversion fails. If "sign" is used to create a negative value,
    12686*		the procedure sets the value of "sign" to "ZERO" to prevent another negation.
    12687*
    12688*     Output
    12689*	A 36-bit binary representation of the constant stored left justified in a 72-bit field.
    12690*	The remaining bits are undefined.
    12691**/
    12692 
    12693 dcl      based_dec char (12) aligned based (addr (dec_value));
    12694 dcl      dec_value fixed decimal (11);
    12695 dcl      i fixed bin (18);
    12696 dcl      int_bits bit (72) aligned;
    12697 dcl      j fixed bin (18);
    12698 dcl      max_value fixed decimal (11) int static options (constant) init (34359738368);
    12699 dcl      len fixed bin (18);
    12700 dcl      off fixed bin (18);
    12701 
    12702 	j = off + verify (substr (st_copy, off + 1, len), "0") - 1;
    12703 	if j < off then
    12704 	     return (b72_zero);
    12705 	i = len - (j - off);
    12706 
    12707 	if i >= length (based_dec) then do;
    12708 	     call print_message (119, substr (st_copy, off + 1, len));
    12709 						/* fixed overflow */
    12710 	     return (b72_zero);
    12711 	end;
    12712 
    12713 	dec_value = 0;
    12714 	substr (based_dec, length (based_dec) - i + 1, i) = substr (st_copy, j + 1, i);
    12715 
    12716 	if dec_value >= max_value			/* i.e., fixedoverflow will occur. */
    12717 	     then
    12718 	     if (dec_value = max_value) & (sign = minus) then do;
    12719 		sign = ZERO;
    12720 		return (b72_one);
    12721 	     end;
    12722 	     else do;
    12723 		call print_message (119, substr (st_copy, off + 1, len));
    12724 						/* fixed overflow */
    12725 		return (b72_zero);
    12726 	     end;
    12727 
    12728 	addr (int_bits) -> based_integer = dec_value;
    12729 	return (int_bits);
    12730      end convert_integer_constant;
    12731 
    12732 negate_constant:
    12733      procedure (in_const) returns (fixed bin (18));
    12734 
    12735 dcl      in_const fixed bin (18);
    12736 
    12737 	go to negate_code (addr (OS (in_const)) -> constant.data_type);
    12738 
    12739 negate_code (1):					/* integer */
    12740 	if addr (work) -> based_integer = -34359738368 then do;
    12741 	     call print_message (137, in_const);
    12742 	     return (in_const);
    12743 	end;
    12744 	else do;
    12745 	     addr (work) -> based_integer = -addr (work) -> based_integer;
    12746 	     return (create_constant (int_mode, work));
    12747 	end;
    12748 
    12749 negate_code (2):					/* real */
    12750 	unspec (addr (work) -> based_real (1)) =
    12751 	     negate_round (real_mode) (6, (unspec (addr (work) -> based_real (1))), "0"b, 0);
    12752 	return (create_constant (real_mode, work));
    12753 
    12754 negate_code (3):					/* double precision */
    12755 	unspec (addr (work) -> based_double) =
    12756 	     negate_round (dp_mode) (6, (unspec (addr (work) -> based_double)), "0"b, 0);
    12757 	return (create_constant (dp_mode, work));
    12758 
    12759 negate_code (4):					/* complex */
    12760 	unspec (addr (work) -> based_real (1)) =
    12761 	     negate_round (real_mode) (6, (unspec (addr (work) -> based_real (1))), "0"b, 0);
    12762 	unspec (addr (work) -> based_real (2)) =
    12763 	     negate_round (real_mode) (6, (unspec (addr (work) -> based_real (2))), "0"b, 0);
    12764 	return (create_constant (cmpx_mode, work));
    12765      end negate_constant;
    12766 
    12767 convert_real_constant:
    12768      procedure (offset) returns (bit (72) aligned);
    12769 
    12770 dcl      dec_exp fixed dec (3);
    12771 dcl      mantissa fixed dec (30) based (addr (ext_float_dec));
    12772 dcl      exp fixed bin (18);
    12773 dcl      indx fixed bin (18);
    12774 dcl      l_significant_digits fixed bin (18);
    12775 dcl      ldigits fixed bin (18);
    12776 dcl      ldigits_parm fixed bin (18);
    12777 dcl      lsd_parm fixed bin (18);
    12778 dcl      offset fixed bin (18);
    12779 dcl      r_significant_digits fixed bin (18);
    12780 dcl      rdigits fixed bin (18);
    12781 dcl      rdigits_parm fixed bin (18);
    12782 dcl      rsd_parm fixed bin (18);
    12783 dcl      real_bits bit (72) aligned;
    12784 
    12785 dcl      1 ext_float_dec aligned,
    12786 	 2 sign char (1) unaligned,
    12787 	 2 digits char (30) unaligned,
    12788 	 2 expnt fixed bin (8) unaligned;
    12789 
    12790 	rdigits = constant_array (offset).scale;
    12791 	ldigits = constant_array (offset).prec - rdigits;
    12792 
    12793 	if ldigits > 0 then
    12794 	     l_significant_digits = length (ltrim (substr (token_string, 1, ldigits), "0"));
    12795 	else
    12796 	     l_significant_digits = 0;
    12797 	if rdigits > 0 then
    12798 	     r_significant_digits = length (rtrim (substr (token_string, ldigits + 2, rdigits), "0"));
    12799 	else
    12800 	     r_significant_digits = 0;		/* trim off the extraneous zeros */
    12801 	goto convert_constant;
    12802 
    12803 convert_real_constant_from_real:
    12804      entry (offset, rdigits_parm, ldigits_parm, rsd_parm, lsd_parm) returns (bit (72) aligned);
    12805 
    12806 	rdigits = rdigits_parm;
    12807 	ldigits = ldigits_parm;
    12808 	r_significant_digits = rsd_parm;
    12809 	l_significant_digits = lsd_parm;
    12810 
    12811 convert_constant:
    12812 	exp = constant_array (offset).exponent;
    12813 	mantissa = 0;
    12814 	if l_significant_digits + r_significant_digits > length (digits) then do;
    12815 	     call print_message (120, length (digits) - bias, token_string);
    12816 						/* constant too long */
    12817 	     return (b72_one);
    12818 	end;
    12819 
    12820 	if l_significant_digits > 0 & ldigits > 0 then
    12821 	     substr (digits, 1, l_significant_digits) = ltrim (substr (token_string, 1, ldigits), "0");
    12822 	if r_significant_digits > 0 & rdigits > 0 then
    12823 	     substr (digits, l_significant_digits + 1, r_significant_digits) =
    12824 		rtrim (substr (token_string, ldigits + 2, rdigits), "0");
    12825 
    12826 	if exp ^= 0 then do;
    12827 	     dec_exp = 0;
    12828 	     if exp < 0 then do;
    12829 		exp = -exp;
    12830 		substr (addr (dec_exp) -> based_char, 1, 1) = "-";
    12831 	     end;
    12832 
    12833 	     indx = token_length - exp;
    12834 	     if indx > 3 then do;
    12835 		call print_message (121, token_string); /* exponent too large */
    12836 		return (b72_one);
    12837 	     end;
    12838 
    12839 	     substr (addr (dec_exp) -> based_char, 5 - indx, indx) = substr (token_string, exp + 1, indx);
    12840 	     exp = dec_exp;
    12841 	end;
    12842 
    12843 	exp = exp + l_significant_digits - length (digits);
    12844 
    12845 	if mantissa = 0 then
    12846 	     return (b72_one);
    12847 
    12848 	if exp > 255 then
    12849 	     call print_message (121, token_string);
    12850 	else if exp < -256 then
    12851 	     call print_message (122, token_string);
    12852 	else do;
    12853 	     expnt = exp;
    12854 
    12855 /*THE NEXT FLOAT DEC CONSTANTS YOU SEE ARE THE LARGEST AND SMALLEST CONVERTIBLE FLOATING POINT DECIMAL MANTISSA'S */
    12856 	     if shared_structure.user_options.hfp then do;
    12857 		if (mantissa > 837987995621412318632521721850 & expnt = 123) | (expnt > 123) then
    12858 		     call print_message (121, token_string);
    12859 		else if (mantissa < 745834073120020674248233039307 & expnt = -184) | (expnt < -184) then
    12860 		     call print_message (122, token_string);
    12861 		else do;
    12862 		     call assign_ (addr (real_bits), 2 * ft_hex_double_dtype, 63, addr (ext_float_dec),
    12863 			2 * real_flt_dec_extended_dtype, 30);
    12864 		     return (real_bits);
    12865 		end;
    12866 	     end;
    12867 	     else do;
    12868 		if (mantissa > 170141183460469231713240559642 & expnt = 9) | (expnt > 9) then
    12869 		     call print_message (121, token_string);
    12870 		else if (mantissa < 146936793852785938496092067153 & expnt = -68) | (expnt < -68) then
    12871 		     call print_message (122, token_string);
    12872 		else do;
    12873 		     call assign_ (addr (real_bits), 2 * ft_double_dtype, 63, addr (ext_float_dec),
    12874 			2 * real_flt_dec_extended_dtype, 30);
    12875 		     return (real_bits);
    12876 		end;
    12877 	     end;
    12878 	end;
    12879 	return (b72_one);
    12880      end convert_real_constant;
    12881 
    12882 get_next_token:
    12883      procedure (action, sym_index);
    12884 
    12885 /*	Program Specifications (get_next_token)
    12886*
    12887*     Inputs
    12888*
    12889*     Output
    12890*
    12891*     Description (get_next_token)
    12892*	current_token
    12893*	token
    12894*	token_offset
    12895*	token_length
    12896**/
    12897 
    12898 dcl      action fixed bin (2);
    12899 dcl      l_significant_digits fixed bin (18);
    12900 dcl      ldigits fixed bin (18);
    12901 dcl      paren_level fixed bin (18);
    12902 dcl      r_significant_digits fixed bin (18);
    12903 dcl      rdigits fixed bin (18);
    12904 dcl      sym_index fixed bin (18);
    12905 dcl      symtab_action fixed bin (2);
    12906 dcl      temp fixed bin (18);
    12907 
    12908 	current_token = current_token + 1;
    12909 
    12910 	named_constant_ptr_valid = FALSE;
    12911 	token = token_list (current_token).type;
    12912 
    12913 	if token = ident then do;
    12914 	     token_offset = token_list (current_token).offset;
    12915 	     token_length = token_list (current_token).length + 1;
    12916 	     symbol_length = token_length;
    12917 	     substr (full_name, 1, symbol_length) = token_string;
    12918 
    12919 	     symtab_action = action;
    12920 	     if symtab_action = ignore_symtab_entry then
    12921 		return;
    12922 
    12923 	     call find_symbol_index (symbol_length, temp, symtab_action, ignore_value);
    12924 
    12925 	     if temp ^= 0 then
    12926 		if addr (OS (temp)) -> symbol.named_constant then do;
    12927 		     named_constant_ptr = addr (OS (temp));
    12928 		     named_constant_ptr_valid = TRUE;
    12929 		     temp = addr (OS (temp)) -> symbol.initial;
    12930 		     token = constant_type (addr (OS (temp)) -> constant.data_type);
    12931 
    12932 		     if token ^= char_string then
    12933 			work = addr (OS (temp)) -> constant.value;
    12934 		end;
    12935 	     sym_index = temp;
    12936 	end;
    12937 
    12938 	else if token & is_constant then do;
    12939 	     token_offset = token_list (current_token).offset;
    12940 	     token_length = token_list (current_token).length + 1;
    12941 
    12942 	     go to convert (binary (substr (token, 5, 5), 5, 0));
    12943 						/* actually case of token_type */
    12944 	end;
    12945 	return;
    12946 
    12947 
    12948 get_next_token$operator:
    12949      entry;
    12950 
    12951 	current_token = current_token + 1;
    12952 	token = token_list (current_token).type;
    12953 	return;
    12954 
    12955 
    12956 get_next_token$paren_operator:
    12957      entry;
    12958 
    12959 	current_token = current_token + 1;
    12960 	token = token_list (current_token).type;
    12961 	if token = left_parn then do;
    12962 	     paren_level = 1;
    12963 	     do temp = current_token + 1 to last_token while (paren_level > 0);
    12964 		if token_list (temp).type = left_parn then
    12965 		     paren_level = paren_level + 1;
    12966 		else if token_list (temp).type = right_parn then
    12967 		     paren_level = paren_level - 1;
    12968 		else if paren_level = 1 & token_list (temp).type = colon then do;
    12969 		     token = substr_left_parn;
    12970 		     return;
    12971 		end;
    12972 	     end;					/* token search loop */
    12973 	end;					/* left parenthesis case */
    12974 	return;
    12975 
    12976 
    12977 get_next_token$label:
    12978      entry (action, sym_index);
    12979 
    12980 	current_token = current_token + 1;
    12981 	token = token_list (current_token).type;
    12982 
    12983 	if token = dec_int then do;
    12984 	     token_offset = token_list (current_token).offset;
    12985 	     token_length = token_list (current_token).length + 1;
    12986 
    12987 	     work = convert_integer_constant (token_offset, token_length);
    12988 	     return;
    12989 	end;
    12990 
    12991 	else if token & is_operator then
    12992 	     return;
    12993 
    12994 	else if token = ident then do;
    12995 	     token_offset = token_list (current_token).offset;
    12996 	     token_length = token_list (current_token).length + 1;
    12997 	     symbol_length = token_length;
    12998 	     substr (full_name, 1, symbol_length) = token_string;
    12999 
    13000 	     call find_symbol_index (symbol_length, temp, force_symtab_entry, ignore_value);
    13001 
    13002 	     if addr (OS (temp)) -> symbol.named_constant /* named const cannot be label value */
    13003 		then
    13004 		call print_message (142, substr (full_name, 1, symbol_length));
    13005 
    13006 	     sym_index = temp;
    13007 	     return;
    13008 	end;
    13009 
    13010 	else if token = char_string then do;
    13011 	     token_offset = token_list (current_token).offset;
    13012 	     token_length = token_list (current_token).length + 1;
    13013 	     sym_index = create_char_constant (token_string);
    13014 	     return;
    13015 	end;
    13016 
    13017 	go to missing_label;
    13018 
    13019 
    13020 /* Case		Character String */
    13021 convert (1):
    13022 	sym_index = create_char_constant (token_string);
    13023 	return;
    13024 
    13025 /* Case		False */
    13026 convert (2):
    13027 	token = logical_const;
    13028 	work = FALSE;
    13029 	sym_index = create_constant (logical_mode, work);
    13030 	return;
    13031 
    13032 /* Case		True */
    13033 convert (3):
    13034 	token = logical_const;
    13035 	work = TRUE;
    13036 	sym_index = create_constant (logical_mode, work);
    13037 	return;
    13038 
    13039 /* Case		Label */
    13040 convert (4):
    13041 	if token_length > 1 then
    13042 	     work = convert_integer_constant (token_offset + 1, token_length - 1);
    13043 	else
    13044 	     addr (work) -> based_integer = 0;
    13045 
    13046 	sym_index = enter_label (executable_label, (addr (work) -> based_integer), GOTO_REF);
    13047 	return;
    13048 
    13049 /* Case		Octal */
    13050 convert (5):
    13051 	call print_message (229);			/* constant type not implemented */
    13052 	return;
    13053 
    13054 /* Case		Integer */
    13055 convert (6):
    13056 	work = convert_integer_constant (token_offset, token_length);
    13057 	sym_index = create_constant (int_mode, work);
    13058 	return;
    13059 
    13060 /* Case		Real */
    13061 convert (7):
    13062 	temp = token_length;
    13063 	token_length = constant_array (temp).length + 1;
    13064 
    13065 	rdigits = constant_array (temp).scale;
    13066 	ldigits = constant_array (temp).prec - rdigits;
    13067 	if ldigits > 0 then
    13068 	     l_significant_digits = length (ltrim (substr (token_string, 1, ldigits), "0"));
    13069 	else
    13070 	     l_significant_digits = 0;
    13071 	if rdigits > 0 then
    13072 	     r_significant_digits = length (rtrim (substr (token_string, ldigits + 2, rdigits), "0"));
    13073 	else
    13074 	     r_significant_digits = 0;		/* trim off the extraneous zeros */
    13075 	if l_significant_digits + r_significant_digits > max_prec_single
    13076 						/* too many digits for single precision (after trimming extraneous zeros) */
    13077 	then do;					/* so, convert to double precision, with warning */
    13078 	     if ^from_data_parser then
    13079 		call print_message (36, token_string, max_prec_single - bias);
    13080 	     token = double_const;
    13081 	     go to convert_to_dp;
    13082 	end;
    13083 
    13084 	work = convert_real_constant_from_real (temp, rdigits, ldigits, r_significant_digits, l_significant_digits);
    13085 	unspec (addr (work) -> based_real (1)) =
    13086 	     conv_round (real_mode, dp_mode) ((unspec (addr (work) -> based_double)), 0);
    13087 	sym_index = create_constant (real_mode, work);
    13088 	return;
    13089 
    13090 /* Case		Double Precision */
    13091 convert (8):
    13092 	temp = token_length;
    13093 	token_length = constant_array (temp).length + 1;
    13094 
    13095 convert_to_dp:
    13096 	work = convert_real_constant (temp);
    13097 	sym_index = create_constant (dp_mode, work);
    13098 	return;
    13099 
    13100 /* Case		Complex */
    13101 convert (9):
    13102 	call print_message (229);			/* complex constant cannot be handled by get_next_token */
    13103 	return;
    13104 
    13105      end get_next_token;
    13106 
    13107 split_token:
    13108      procedure (length, indx, must_be_one);
    13109 
    13110 /*	Program Specifications (split_token)
    13111*
    13112*     Inputs
    13113*
    13114*     Output
    13115*
    13116*     Description (split_token)
    13117*
    13118*     NOTE - This procedure modifies:
    13119*	token_list
    13120*	first_token
    13121**/
    13122 
    13123 dcl      j fixed bin (18);
    13124 dcl      indx fixed bin (18);
    13125 dcl      len fixed bin (18);
    13126 dcl      length fixed bin (18);
    13127 dcl      must_be_one bit (1) aligned;
    13128 dcl      off fixed bin (18);
    13129 
    13130 dcl      1 split_structure aligned based (addr (st_copy)),
    13131 	 2 pad char (off) unaligned,
    13132 	 2 tkn char (len) unaligned;
    13133 
    13134 	off, token_list (indx).offset = token_list (indx).offset + length;
    13135 	token_list (indx).length = token_list (indx).length - length;
    13136 	len = token_list (indx).length + 1;
    13137 
    13138 	if len > 0 then do;
    13139 	     j = verify (tkn, DIGIT) - 1;
    13140 	     if j ^= 0 then
    13141 		if j < 0 then do;
    13142 		     j = len;
    13143 		     len = 0;
    13144 		end;
    13145 		else do;
    13146 		     if must_be_one then
    13147 			call print_message (52, tkn); /* extraneous characters */
    13148 		     if indx = first_token then
    13149 			first_token = first_token - 1;
    13150 		     token_list (indx).offset = token_list (indx).offset + j;
    13151 		     token_list (indx).length = token_list (indx).length - j;
    13152 		end;
    13153 
    13154 	     if len - j > 0 then
    13155 		if verify (substr (tkn, j + 1, 1), alphabetic) ^= 0 then do;
    13156 		     call print_message (52, substr (tkn, j + 1));
    13157 		     if j > 0 then
    13158 			indx = indx - 1;		/* extraneous characters */
    13159 		end;
    13160 		else if j > 0 then
    13161 		     indx = indx - 1;
    13162 	     if j > 0 then do;
    13163 		token_list (indx).type = dec_int;
    13164 		token_list (indx).offset = off;
    13165 		token_list (indx).length = j - 1;
    13166 	     end;
    13167 	end;
    13168 	else do;
    13169 	     token_list (indx).type = no_token;
    13170 	     if indx = first_token then
    13171 		first_token = first_token + 1;
    13172 	     indx = indx + 1;
    13173 	end;
    13174      end split_token;
    13175 
    13176 err_string:
    13177      procedure () returns (char (512) varying);		/* makes a printable string from the current token */
    13178 
    13179 dcl      TKN bit (9) aligned;				/* to keep token a padded ref */
    13180 dcl      op_chars (22) char (4) aligned int static options (constant)
    13181 	    init ("+", "-", "*", "/", "**", "not", "and", "or", "eq", "ne", "lt", "gt", "le", "ge", "=", ",", "(", ")",
    13182 	    "'", ":", "//", "(");
    13183 
    13184 	if current_token > last_token then
    13185 	     return ("the end of this statement");
    13186 
    13187 	TKN = token_list (current_token).type;
    13188 	token_offset = token_list (current_token).offset;
    13189 	token_length = token_list (current_token).length + 1;
    13190 
    13191 	if TKN = ident then
    13192 	     return ("the name " || token_string);
    13193 
    13194 	else if TKN = octal_const then
    13195 	     return ("the octal constant " || token_string);
    13196 
    13197 	else if TKN & is_constant then do;
    13198 	     if TKN = real_const | TKN = double_const then
    13199 		token_length = constant_array (token_length).length + 1;
    13200 
    13201 	     return ("the constant " || token_string);
    13202 	end;
    13203 
    13204 	else if TKN & is_operator then
    13205 	     return ("the operator " || op_chars (binary (substr (TKN, 5, 5), 5, 0)));
    13206 
    13207 	else
    13208 	     return ("the token " || char (TKN) || " (compiler error)");
    13209      end err_string;
    13210 
    13211 /*Check to ensure no duplicate entries. */
    13212 
    13213 check_entry_duplication:
    13214      proc;
    13215 
    13216 /* Routine to scan through list of entry points built by                     */
    13217 /* "declaration_processor" (first_entry_name, last_entry_name).  The method  */
    13218 /* used is a simple decreasing length scan and is not in the least elegant.  */
    13219 /* If a duplication is encountered error 428 is signaled.		       */
    13220 
    13221 dcl      1 master like symbol based (addr (OS (master_index)));
    13222 dcl      1 slave like symbol based (addr (OS (slave_index)));
    13223 dcl      master_index fixed bin (18);
    13224 dcl      slave_index fixed bin (18);
    13225 
    13226 	master_index = first_entry_name;
    13227 	do while (master_index ^= 0);			/* scan through list */
    13228 	     slave_index = master.next_symbol;
    13229 	     do while (slave_index ^= 0);		/* checking dups */
    13230 		if slave.name = master.name then
    13231 		     call print_message (428, slave.name);
    13232 		slave_index = slave.next_symbol;
    13233 	     end;
    13234 	     master_index = master.next_symbol;
    13235 	end;
    13236      end check_entry_duplication;
    13237 
    13238      end parse_source;
    13239      end ext_parse;
    13240 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/11/91  2227.1  ext_parse.pl1                     >spec>install>1004>ext_parse.pl1
396          1    03/27/82  0439.3  fort_parse_vars.incl.pl1          >ldd>incl>fort_parse_vars.incl.pl1
399          2    08/04/86  2015.0  fort_shared_vars.incl.pl1         >ldd>incl>fort_shared_vars.incl.pl1
400          3    08/06/87  1153.7  fort_options.incl.pl1             >ldd>incl>fort_options.incl.pl1
401          4    08/04/86  2015.0  fort_system_constants.incl.pl1    >ldd>incl>fort_system_constants.incl.pl1
402          5    11/10/88  1450.9  fort_nodes.incl.pl1               >ldd>incl>fort_nodes.incl.pl1
403          6    03/27/82  0439.3  fort_listing_nodes.incl.pl1       >ldd>incl>fort_listing_nodes.incl.pl1
404          7    10/26/88  1255.5  std_descriptor_types.incl.pl1     >ldd>incl>std_descriptor_types.incl.pl1
448          8    03/27/82  0437.1  fort_utilities.incl.pl1           >ldd>incl>fort_utilities.incl.pl1
8-11         9    03/27/82  0437.8  fort_create_node.incl.pl1         >ldd>incl>fort_create_node.incl.pl1
8-37        10    10/30/80  1648.7  relocation_bits.incl.pl1          >ldd>incl>relocation_bits.incl.pl1
881         11    03/27/82  0424.8  fort_parameter.incl.pl1           >ldd>incl>fort_parameter.incl.pl1
886         12    08/06/87  1153.7  fortran_job_bits.incl.pl1         >ldd>incl>fortran_job_bits.incl.pl1
889         13    08/04/86  2015.0  format_tables.incl.pl1            >ldd>incl>format_tables.incl.pl1
1089        14    03/10/77  1345.4  compiler_source_info.incl.pl1     >ldd>incl>compiler_source_info.incl.pl1
1090        15    03/27/82  0424.8  fortran_io_consts.incl.pl1        >ldd>incl>fortran_io_consts.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ASSIGN                          016770 automatic       bit(1)                   dcl 10801 set ref 10883* 11326 11327* 11370 11459
Asterisk                               constant        fixed bin(17,0)          initial dcl 6233 ref 6308 6372
BEGIN_DO_LOOP                   003300 constant        fixed bin(18,0)          initial dcl 476 set ref 3527* 7285
BOE                                    constant        fixed bin(18,0)          initial dcl 10043 ref 10089 10468
COLON_BEFORE_ASSIGN             000130 automatic       bit(1)                   dcl 475 set ref 2782 10882* 11328 11459*
CURRENT_VALUE                          constant        fixed bin(18,0)          initial dcl 477 ref 7295 7807 7807
DECLARED                        003262 constant        bit(5)                   initial dcl 478 set ref 1766* 2031* 2273* 2312*
                                                                                  2320* 2370* 2402* 2483* 2570* 2706* 2745* 2782*
                                                                                  2820* 2830* 6547 7085* 7406* 7420 7429 7436 7441
                                                                                  7443 9401 9417 9474*
DIGIT                           003022 constant        char(10)                 initial dcl 479 ref 12062 12350 13139
END_DO_LOOP                     003240 constant        fixed bin(18,0)          initial dcl 480 set ref 3779* 7799
END_DO_LOOP_SIZE                       constant        fixed bin(18,0)          initial dcl 481 ref 7815
END_DO_RANGE                    000131 automatic       bit(1)                   dcl 482 set ref 1360* 1398* 1403 1404* 1406 1416
                                                                                  1509 3017 3091 3170 3215 3821 4091 4726
EOS                             016771 automatic       bit(1)                   dcl 10802 set ref 10891* 10929 11076* 11078 11081
                                                                                  11089* 11091 11131 11145 11177 11232 11256 11380
                                                                                  11417 11430 11452* 11553* 11568 11765* 11990*
                                                                                  12006* 12007* 12029* 12030* 12043* 12100* 12105*
                                                                                  12137* 12358 12397 12404 12447 12465 12487 12571
                                                                                  12595
EOS_token                              constant        bit(9)                   initial dcl 4-156 ref 1667 3030 3834 8453 8463 10983
ERROR                                  constant        bit(1)                   initial dcl 11711 set ref 12010* 12033* 12276
E_finish                        001175 automatic       fixed bin(17,0)          dcl 600 set ref 2156* 2159 2161 2177* 2179 2181
E_start                         001174 automatic       fixed bin(17,0)          dcl 600 set ref 2141* 2144 2146 2148 2159 2173* 2174
E_token                         001176 automatic       fixed bin(17,0)          dcl 601 set ref 2110* 2146 2161 2181
FALSE                                  constant        bit(1)                   initial dcl 483 set ref 1110 1123 1253 1254 1275
                                                                                  1278 1304 1360 1435 1685 1746 1772 1894 1901 1931
                                                                                  1998 2002 2066 2069 2072 2126* 2126* 2200 2211
                                                                                  2279 2344 2439 2442 2549 2565 2582* 2590 2679 2710
                                                                                  2755 2849 3033 3062 3259* 3272 3350 3423* 3622
                                                                                  3668 3770 3785 3798 3907* 3907* 3917* 3917* 3978
                                                                                  4024* 4067 4169* 4169* 4205 4225 4244 4394* 4449*
                                                                                  4529* 4547* 4637* 4686* 4899 5262 5493 5520 5830
                                                                                  5971 6177 6330 6338 6542 6627 6632 6886 7064 7104
                                                                                  7319 7327 7343 7393 7415 7465 7833 8252 8259 8312
                                                                                  8440 8486 8514* 8538* 8624* 8754* 9104 9125 9146
                                                                                  9187 9304 9322 9330 9414 9469 9482 9511 9535 9559
                                                                                  9737 9934 9937 9940 9949 9960 9967 9974 10099
                                                                                  10445 10467 10468 10494 10584 10687 10693 10701
                                                                                  10703 10707 10882 10883 10884 10885 10891 10923
                                                                                  10934 10987* 11053* 11076 11089 11125 11131 11133
                                                                                  11154 11168 11448 11498 11563 12018 12117 12261
                                                                                  12351 12358 12360 12391 12397 12399 12473 12474
                                                                                  12480 12481 12505 12506 12560 12910 13028
FORTRAN_ONLY                           constant        bit(2)                   initial dcl 10803 set ref 11092* 11512* 11558* 11962
                                                                                  12153 12153
GLOBAL_OK                              constant        bit(2)                   initial dcl 10804 ref 11062 11742 11934 11943 11963
GOTO_REF                        003021 constant        bit(5)                   initial dcl 484 set ref 3026* 3026* 3226* 3226*
                                                                                  4128* 4128* 8678* 9395 13046*
GOTO_TARGET                     003020 constant        bit(5)                   initial dcl 485 set ref 6272*
ILLEGAL_EXPRESSION_FOUND               constant        fixed bin(35,0)          initial dcl 9730 ref 9758 9784 9792
INIT                                   constant        bit(5)                   initial dcl 486 ref 6650 6746 7784 7784 7846
INITIAL_EXPRESSION                     constant        fixed bin(18,0)          initial dcl 487 ref 7294 7801
INVALID_CONSTANT                       constant        fixed bin(17,0)          initial dcl 6957 ref 6978 6989 7012
INVALID_OPERATOR                       constant        fixed bin(17,0)          initial dcl 6957 ref 6992 7014
INVALID_SYMBOL                         constant        fixed bin(17,0)          initial dcl 6957 ref 6986 7016
Invalid_operand                        constant        fixed bin(35,0)          initial dcl 9654 ref 9673
Invalid_operator                       constant        fixed bin(35,0)          initial dcl 9654 ref 9677
LA                        2(04)        based           bit(1)                   level 2 in structure "header" packed packed
                                                                                  unaligned dcl 5-436 in procedure "ext_parse" set
                                                                                  ref 5798* 5871*
LA                        4(01)        based           bit(1)                   level 3 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 5778* 5801* 5851* 5877*
LA_auto                   1     000132 automatic       bit(1)                   level 2 packed packed unaligned dcl 391 set ref 5713
                                                                                  5745 5818
LA_chain                 57(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-753
                                                                                  set ref 5762 5789* 5831 5866*
LA_hdri                         013266 automatic       fixed bin(18,0)          dcl 4800 set ref 5762* 5762* 5765 5779* 5788* 5789
                                                                                  5791 5793 5802 5831* 5831* 5833 5852*
LA_hdrp                         013270 automatic       pointer                  dcl 4801 set ref 5765* 5766 5769 5772 5773 5773 5776
                                                                                  5777 5783 5784 5793* 5794 5796 5797 5798 5799 5800
                                                                                  5800 5833* 5834 5837 5841 5843 5843 5846 5847 5863
                                                                                  5864
LA_static                 1(01) 000132 automatic       bit(1)                   level 2 packed packed unaligned dcl 391 set ref 5713
                                                                                  5745 5818
LEGAL_NON_WHITE_SPACE           001053 constant        char(66)                 initial dcl 11712 ref 12143
LOWER                           001330 constant        char(26)                 initial dcl 10805 ref 11550 11625 11807 11931 11941
                                                                                  12241
NL                                     constant        char(1)                  initial dcl 10806 ref 11788
NOT_SET                                constant        bit(1)                   initial packed unaligned dcl 489 set ref 2311*
NO_NAME                         003016 constant        char(8)                  initial packed unaligned dcl 488 ref 1781 3305 3835
                                                                                  5131 5683 5687 6653 6743 6936 7135 9023 9688 9840
                                                                                  9840
NULL_STRING                     003262 constant        char                     initial packed unaligned dcl 490 set ref 1823 4105*
ONE                                    constant        fixed bin(18,0)          initial dcl 491 set ref 11114* 11142* 11205* 11221*
                                                                                  11254* 11308* 11314* 11320* 11346* 11353* 11360*
                                                                                  11373* 11379* 11385* 11400* 11416* 11422* 11428*
                                                                                  11449* 11458* 12414* 12463* 12476* 12483*
OPTIONS_OK                             constant        bit(2)                   initial dcl 10808 ref 11069 11944
OPTION_DELIMS                   001047 constant        char(4)                  initial packed unaligned dcl 12210 ref 12231
OPTION_SKIP                     001046 constant        char(3)                  initial packed unaligned dcl 12212 ref 12215
OS                                     based           bit(36)                  array dcl 492 set ref 1175 1205 1210 1384 1389 1605
                                                                                  1685 1772 1782 1784 1785 1786 1922 1998 2000 2004
                                                                                  2005 2008 2027 2035 2035 2037 2037 2039 2041 2045
                                                                                  2045 2045 2045 2111 2114 2114 2114 2146 2161 2181
                                                                                  2253 2305 2339 2340 2366 2415 2500 2523 2527 2527
                                                                                  2585 2612 2615 2679 2681 2691 2702 2741 2796 2820
                                                                                  2820 2822 2824 2834 2835 2837 2839 2842 2844 2863
                                                                                  2866 2870 2872 2872 2874 2877 2878 2882 2891 2908
                                                                                  2936 2936 2936 3327 3556 3558 3562 3619 3642 3656
                                                                                  3713 3740 4058 4058 4866 4866 4871 4871 4873 4873
                                                                                  4874 4874 4883 4892 4896 4934 4948 4948 4950 4950
                                                                                  4951 4951 4962 4967 4978 5012 5076 5111 5112 5132
                                                                                  5133 5138 5139 5140 5150 5175 5177 5190 5192 5221
                                                                                  5258 5358 5406 5425 5431 5446 5448 5449 5489 5496
                                                                                  5517 5523 5554 5569 5589 5607 5632 5638 5642 5646
                                                                                  5653 5665 5682 5689 5694 5703 5704 5741 5747 5765
                                                                                  5772 5793 5817 5833 5841 5850 5876 5908 5916 5916
                                                                                  5934 5942 5953 6021 6029 6045 6056 6056 6104 6120
                                                                                  6138 6151 6174 6175 6176 6177 6215 6299 6303 6310
                                                                                  6314 6326 6334 6540 6549 6549 6626 6639 6643 6694
                                                                                  6715 6748 6748 6765 6766 6767 6768 6772 6808 6823
                                                                                  6928 6937 6938 6976 7051 7148 7161 7181 7181 7181
                                                                                  7181 7188 7189 7311 7312 7312 7332 7332 7367 7413
                                                                                  7422 7422 7422 7438 7456 7474 7552 7553 7575 7580
                                                                                  7582 7584 7587 7592 7594 7598 7643 7648 7648 7650
                                                                                  7650 7662 7677 7757 7785 7785 7788 7788 7788 7788
                                                                                  7788 7788 7896 8051 8152 8163 8164 8165 8166 8167
                                                                                  8168 8169 8251 8258 8268 8269 8274 8280 8365 8386
                                                                                  8679 8754 8795 8833 8957 8962 8963 8968 8973 8988
                                                                                  9004 9024 9049 9582 9586 9672 9689 9696 9709 9714
                                                                                  9762 9778 9826 9830 9930 10173 10183 10258 10359
                                                                                  10388 10596 10634 10647 10647 10703 10706 10707
                                                                                  10741 11905 12737 12925 12927 12929 12930 12932
                                                                                  13002 13228 13230 13230 13230 13232 13234
PASSED                          003015 constant        bit(5)                   initial dcl 493 set ref 3305*
REF                                    constant        bit(5)                   initial dcl 494 set ref 2431* 3299* 3835* 4734* 6051
                                                                                  6056 6658 6701 7135* 7431 7438 8937 8946*
RETURN                                 constant        bit(1)                   initial dcl 11714 set ref 12127*
SECOND_EQUALS                   000132 automatic       bit(1)                   dcl 495 set ref 3060 3065 10884* 11328*
SET                             003014 constant        bit(5)                   initial dcl 496 set ref 1344* 1344* 1383* 1681*
                                                                                  1771* 1781* 5131* 5637* 5693* 6175 6650 6683 6746
                                                                                  6936* 7051* 8935 9688*
SET_ATTR                               constant        bit(1)                   initial packed unaligned dcl 497 set ref 2314* 2373*
                                                                                  10253*
SI                              000133 automatic       fixed bin(18,0)          dcl 498 set ref 1681* 1685 1918* 1922 1922* 1930*
                                                                                  1950* 1973* 1979* 2027 2027* 2031* 2035 2037 2039
                                                                                  2041 2045 2045 2050* 2054* 2060* 2064* 2106* 2110
                                                                                  2111 2111* 2114 2114 2114 2120* 2126* 2126* 2139*
                                                                                  2144* 2146* 2154* 2159* 2161* 2175* 2179* 2181*
                                                                                  2249* 2253 2253* 2261* 2266* 2273* 2273* 2301*
                                                                                  2305 2305* 2311* 2312* 2312* 2314* 2320* 2320*
                                                                                  2339 2340 2362* 2366 2366* 2370* 2370* 2373* 2373*
                                                                                  2398* 2402* 2403 2408* 2415 2418 2427* 2431* 2431*
                                                                                  2434* 2457* 2479* 2483* 2484* 2485* 2487 2493*
                                                                                  2495* 2563* 2570* 2571* 2572* 2585 2585 2666*
                                                                                  2688* 2689 2691 2702 2702* 2706* 2706* 2737* 2741
                                                                                  2741* 2745* 2745* 2748* 2752* 2778* 2782* 2796
                                                                                  2799* 2842 2867* 2877 2882 2891 2931* 2936 2936
                                                                                  2936 2938* 2939* 2941* 2944* 2946* 2949* 2952*
                                                                                  2953* 2957* 2961* 2962* 3006* 3007* 3221* 3234*
                                                                                  3236* 3244* 3245* 3267* 3268* 3270* 3295* 3299*
                                                                                  3299* 3316* 3327 3368* 3516* 3619 3626* 3630*
                                                                                  3634* 3638* 3660* 3664* 3674* 3692* 3716* 3720*
                                                                                  3744* 3748* 3762* 3832* 3840* 3890* 3932* 3990*
                                                                                  3996* 4048* 4056* 4058 4058* 4063* 4142* 4144*
                                                                                  4194* 4196* 4211* 4213* 4241* 4242* 4272* 4273*
                                                                                  4291* 4292* 4296* 4297* 4315* 4317* 4321* 4323*
                                                                                  4326* 4328* 4735* 4737* 4740* 4744* 4745* 4749*
                                                                                  4750* 4752* 4753* 4882* 4882* 4883 4885* 4888*
                                                                                  4925* 4930 4934 4948 4950 4951 4976 4978 4981
                                                                                  4993* 4997* 5012* 5023* 5073* 5122 5125* 5135 5148
                                                                                  5150 5153 5166* 6048* 8386 8731* 8737* 8753* 8754
                                                                                  8760* 8795 8797* 8799*
SKIP                                   constant        fixed bin(18,0)          initial dcl 499 ref 3757
SUBSCRIPTED_SUBSTR              076434 constant        fixed bin(18,0)          initial dcl 501 ref 3682 7322 7365 7472 7577
SUBSCRIPTED_VAR                 003177 constant        fixed bin(18,0)          initial dcl 500 set ref 3629* 3682 7322
SUBSTR                          003236 constant        fixed bin(18,0)          initial dcl 502 set ref 3625* 7322 7327 7365 7472
                                                                                  7577
SYMBOL_INDEX                           constant        fixed bin(18,0)          initial dcl 503 ref 7323
TKN                             020072 automatic       bit(9)                   dcl 13179 set ref 13187* 13191 13194 13197 13198
                                                                                  13198 13204 13204 13207
TRUE                            003251 constant        bit(1)                   initial dcl 504 set ref 1291 1303* 1328* 1813 1842
                                                                                  1915 1953 1996 2022 2090 2104 2114 2247 2298 2339
                                                                                  2340 2359 2396 2425 2459 2559 2644 2647 2657 2660
                                                                                  2664 2675 2731 2732 2735 2837 2839 2866 3266* 3503
                                                                                  3511 3635 3639 3646 3651 3661 3665 3675 3686 3693
                                                                                  3708 3717 3721 3735 3745 3749 3767 3893 3936 3952*
                                                                                  3954* 3954* 3986 3997* 4024* 4042 4140* 4185*
                                                                                  4185* 4199 4209* 4216 4236* 4239 4275 4299 4316
                                                                                  4359 4386 4394* 4449* 4495 4522 4529* 4547* 4592
                                                                                  4617 4637* 4686* 5037 5059 5180 5255 5265 5279
                                                                                  5468 5497 5524 5566 5570 5604 5608 5635 5640 5657
                                                                                  5659 5664 5668 5696 5698 5778 5796 5798 5801 5851
                                                                                  5861 5871 5877 5964 5968 6108 6195 6218 6555 6622
                                                                                  6658 6661 6727 6732 6834 7071 7095 7181 7273 7330
                                                                                  7404 7409 7428 7435 7453 7478 7484 7491 7546* 8153
                                                                                  8157 8167 8245 8315 8448 8494 8502 8514* 8521*
                                                                                  8538* 8549 8554* 8656 8665 8679 8693 8729 8782
                                                                                  8942 8962 8968 8973 8988 8992 8993 9049 9200 9236
                                                                                  9269 9307 9309 9320 9356 9359 9404 9479 9496 9523
                                                                                  9545 9554 9572 9574 9609 9613 9789 9836 9932 9947
                                                                                  9981 9987 10100 10133 10170 10173 10181 10207
                                                                                  10220 10229 10244 10255 10275 10334 10365 10378
                                                                                  10382 10402 10478 10496 10510 10558 10578 10580
                                                                                  10626 10628 10769 11122 11190 11264 11327 11328
                                                                                  11433 11452 11459 11544 11553 11765 12007 12030
                                                                                  12043 12046 12133 12137 12272 12348 12388 12562
                                                                                  12614 12928 13035
UPPER                           001321 constant        char(26)                 initial dcl 10809 ref 11550 11625 11807 11931 11941
                                                                                  12241
VLA                       4            based           bit(1)                   level 3 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 5570* 5608* 5635* 5668*
VLA                       2(03)        based           bit(1)                   level 2 in structure "header" packed packed
                                                                                  unaligned dcl 5-436 in procedure "ext_parse" set
                                                                                  ref 5566* 5604* 5664*
VLA_auto                113(32)        based           bit(1)                   level 4 in structure "shared_structure" packed
                                                                                  packed unaligned dcl 398 in procedure "ext_parse"
                                                                                  set ref 429
VLA_auto                  0(32) 000132 automatic       bit(1)                   level 2 in structure "subr_options" packed packed
                                                                                  unaligned dcl 391 in procedure "ext_parse" set ref
                                                                                  5548 5585 5590 5629 5644
VLA_base_addressor        7            based           fixed bin(18,0)          level 2 in structure "header" dcl 5-436 in procedure
                                                                                  "ext_parse" set ref 5701*
VLA_base_addressor        4            based           fixed bin(18,0)          level 2 in structure "dimension" dcl 5-383
                                                                                  in procedure "ext_parse" set ref 5642* 5704*
VLA_chain                57            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-753
                                                                                  set ref 5564 5565* 5602 5603* 5654 5655* 5681
VLA_hdri                        013272 automatic       fixed bin(18,0)          dcl 4802 set ref 5652* 5653 5655 5669 5681* 5681*
                                                                                  5682*
VLA_hdrp                        013274 automatic       pointer                  dcl 4803 set ref 5653* 5654 5656 5657 5659 5661 5663
                                                                                  5664 5665 5667 5667 5682* 5683 5685 5687 5696 5701
                                                                                  5702 5707
VLA_parm                113(33)        based           bit(1)                   level 4 in structure "shared_structure" packed
                                                                                  packed unaligned dcl 398 in procedure "ext_parse"
                                                                                  set ref 433
VLA_parm                  0(33) 000132 automatic       bit(1)                   level 2 in structure "subr_options" packed packed
                                                                                  unaligned dcl 391 in procedure "ext_parse" set ref
                                                                                  5548 5629 5633
VLA_static                0(34) 000132 automatic       bit(1)                   level 2 in structure "subr_options" packed packed
                                                                                  unaligned dcl 391 in procedure "ext_parse" set ref
                                                                                  5548 5585 5590 5629 5644
VLA_static              113(34)        based           bit(1)                   level 4 in structure "shared_structure" packed
                                                                                  packed unaligned dcl 398 in procedure "ext_parse"
                                                                                  set ref 437
VLC                       0(35) 000132 automatic       bit(1)                   level 2 in structure "subr_options" packed packed
                                                                                  unaligned dcl 391 in procedure "ext_parse" set ref
                                                                                  5548 5550 5585 5590
VLC                     113(35)        based           bit(1)                   level 4 in structure "shared_structure" packed
                                                                                  packed unaligned dcl 398 in procedure "ext_parse"
                                                                                  set ref 441
WHITE                                  constant        char(2)                  initial dcl 10810 ref 11571 11819 11826 12040 12104
                                                                                  12646
WHITE_AND_DIGITS                001050 constant        char(12)                 initial dcl 11715 ref 11802
ZERO                                   constant        bit(1)                   initial dcl 505 ref 1121 1125 1130 1236 1248 1249
                                                                                  1271 1611 1884 3558 3881 3882 3985 4363 4370 4499
                                                                                  4506 4596 4603 5001 5111 5192 5394 5518 6152 6514
                                                                                  6542 7964 7972 8002 8007 8013 8441 8487 9937 9967
                                                                                  9967 9983 10120 10207 10266 10362 10404 10429
                                                                                  10441 10508 10522 10684 10750 10895 10896 11397
                                                                                  12719
a_count                                parameter       fixed bin(18,0)          dcl 11482 set ref 11463 11495 11522* 11526 11535
a_data_type                     000116 automatic       fixed bin(4,0)           dcl 8-15 set ref 8-40* 8-43 8-43 8-43 8-45 8-45 8-47
                                                                                  8-65 8-81
a_index                                parameter       fixed bin(18,0)          dcl 8204 set ref 8192 8287*
a_last                                 parameter       fixed bin(18,0)          dcl 8205 set ref 8192 8288*
a_len                                  parameter       fixed bin(18,0)          dcl 8206 ref 8192 8215
a_size                                 parameter       fixed bin(18,0)          dcl 8304 set ref 8291 8405 8411* 8415*
a_stmnt_type                           parameter       fixed bin(18,0)          dcl 10812 set ref 10789 10915* 10990* 10994 11000*
                                                                                  11056*
a_sym                                  parameter       fixed bin(18,0)          dcl 6092 ref 6089 6100
a_type                                 parameter       bit(2)                   dcl 6589 ref 6558 6603
a_usage                                parameter       bit(5)                   dcl 6590 ref 6558 6605
a_value                                parameter       fixed bin(18,0)          dcl 6591 in procedure "enter_label" ref 6558 6604
a_value                         000120 automatic       bit(72)                  dcl 8-16 in procedure "create_constant" set ref
                                                                                  8-41* 8-51 8-52 8-54 8-54 8-65 8-85
abs                                                    builtin function         dcl 508 ref 6616 9622
access_field                           constant        fixed bin(17,0)          initial dcl 15-50 set ref 4425* 4640*
action                                 parameter       fixed bin(2,0)           dcl 12898 in procedure "get_next_token" ref 12882
                                                                                  12919 12977
action                                 parameter       fixed bin(2,0)           dcl 6924 in procedure "get_char_length" ref 6921
                                                                                  6935
action_on_non_numeric                  parameter       bit(1)                   dcl 12254 ref 12251 12276
actual_type                     013744 automatic       bit(2)                   dcl 6592 set ref 6671* 6676 6677* 6680 6680 6686
                                                                                  6701 6739
add_op                                 constant        fixed bin(18,0)          initial dcl 4-197 set ref 6992 7898 7906 8854* 9677
add_to_lib_list           2            based           entry variable           level 2 dcl 395 ref 2612
add_to_lib_list_run      12            based           entry variable           level 2 dcl 395 ref 2615
added                           013276 automatic       pointer                  dcl 4804 set ref 5345* 5351* 5357 5371 5371 5374
                                                                                  5376 5386* 5393
added_group                     013300 automatic       bit(1)                   packed unaligned dcl 4805 set ref 5830* 5831 5861*
                                                                                  5865
added_header_length             013301 automatic       fixed bin(24,0)          dcl 4806 set ref 5371* 5374* 5376* 5378
addr                                                   builtin function         dcl 8-18 in procedure "create_constant" ref 8-51
                                                                                  8-52 8-54 8-54 8-63 8-80 8-91
addr                                                   builtin function         dcl 509 in procedure "parse_source" ref 1096 1099
                                                                                  1131 1132 1133 1134 1151 1175 1205 1210 1234 1384
                                                                                  1389 1554 1554 1593 1605 1674 1685 1772 1782 1784
                                                                                  1785 1786 1922 1998 2000 2004 2005 2008 2027 2035
                                                                                  2035 2037 2037 2039 2041 2045 2045 2045 2045 2111
                                                                                  2114 2114 2114 2141 2146 2156 2161 2177 2181 2253
                                                                                  2305 2339 2340 2366 2415 2500 2507 2507 2523 2527
                                                                                  2527 2585 2612 2615 2679 2681 2691 2702 2741 2796
                                                                                  2820 2820 2822 2824 2834 2835 2837 2839 2842 2844
                                                                                  2863 2866 2870 2872 2872 2874 2877 2878 2882 2891
                                                                                  2908 2936 2936 2936 3026 3026 3226 3226 3236 3245
                                                                                  3327 3439 3556 3558 3562 3619 3642 3656 3656 3713
                                                                                  3713 3727 3740 3740 4058 4058 4101 4128 4128 4165
                                                                                  4734 4775 4777 4866 4866 4871 4871 4873 4873 4874
                                                                                  4874 4883 4892 4896 4896 4896 4899 4934 4948 4948
                                                                                  4950 4950 4951 4951 4962 4967 4978 5012 5050 5076
                                                                                  5111 5112 5132 5133 5138 5139 5140 5150 5175 5177
                                                                                  5190 5192 5221 5258 5358 5406 5425 5431 5446 5448
                                                                                  5449 5489 5496 5517 5523 5554 5569 5589 5607 5632
                                                                                  5638 5642 5646 5653 5665 5682 5689 5694 5703 5704
                                                                                  5741 5747 5765 5772 5793 5817 5833 5841 5850 5876
                                                                                  5908 5916 5916 5934 5942 5953 6021 6029 6045 6056
                                                                                  6056 6104 6120 6138 6151 6174 6175 6176 6177 6192
                                                                                  6193 6194 6195 6215 6299 6303 6310 6314 6326 6334
                                                                                  6456 6461 6514 6540 6549 6549 6626 6639 6643 6694
                                                                                  6715 6748 6748 6765 6766 6767 6768 6772 6808 6823
                                                                                  6928 6930 6937 6938 6976 6995 7004 7004 7051 7148
                                                                                  7161 7181 7181 7181 7181 7188 7189 7311 7312 7312
                                                                                  7332 7332 7367 7413 7422 7422 7422 7438 7456 7474
                                                                                  7534 7552 7553 7553 7575 7578 7580 7580 7582 7584
                                                                                  7584 7587 7587 7590 7590 7592 7594 7594 7595 7595
                                                                                  7598 7643 7648 7648 7650 7650 7662 7662 7677 7677
                                                                                  7681 7689 7698 7705 7710 7714 7719 7723 7728 7732
                                                                                  7738 7757 7785 7785 7788 7788 7788 7788 7788 7788
                                                                                  7896 7896 8051 8096 8105 8109 8115 8115 8118 8122
                                                                                  8132 8134 8141 8143 8152 8163 8164 8165 8166 8167
                                                                                  8168 8169 8172 8172 8179 8179 8184 8184 8230 8230
                                                                                  8234 8238 8251 8258 8268 8269 8274 8280 8320 8359
                                                                                  8359 8365 8365 8375 8379 8386 8408 8410 8414 8678
                                                                                  8679 8738 8740 8740 8740 8754 8795 8804 8827 8831
                                                                                  8832 8833 8842 8842 8888 8888 8946 8957 8962 8963
                                                                                  8968 8973 8988 9004 9004 9024 9049 9282 9315 9410
                                                                                  9582 9586 9672 9682 9689 9696 9706 9706 9709 9714
                                                                                  9757 9758 9762 9775 9775 9778 9784 9784 9826 9830
                                                                                  9930 10125 10133 10156 10162 10170 10173 10173
                                                                                  10181 10183 10185 10185 10202 10220 10229 10231
                                                                                  10244 10246 10255 10258 10258 10275 10277 10293
                                                                                  10359 10382 10384 10384 10388 10388 10396 10402
                                                                                  10441 10496 10508 10510 10510 10522 10558 10580
                                                                                  10584 10584 10596 10628 10634 10646 10647 10647
                                                                                  10647 10703 10706 10707 10731 10731 10737 10737
                                                                                  10741 10745 10745 10868 10871 10871 10896 10903
                                                                                  11112 11445 11445 11777 11865 11905 11921 11945
                                                                                  11945 11945 11945 11950 11950 11950 11950 11955
                                                                                  11955 11964 11964 11964 11964 11969 11969 11969
                                                                                  11969 11974 11974 12072 12076 12078 12082 12082
                                                                                  12086 12156 12175 12175 12175 12175 12195 12195
                                                                                  12195 12195 12195 12195 12195 12195 12317 12417
                                                                                  12421 12427 12640 12663 12707 12714 12714 12728
                                                                                  12737 12739 12745 12745 12749 12749 12754 12754
                                                                                  12759 12759 12762 12762 12793 12797 12813 12815
                                                                                  12820 12822 12830 12835 12839 12839 12845 12848
                                                                                  12850 12857 12857 12859 12859 12862 12862 12862
                                                                                  12862 12868 12868 12870 12870 12873 12873 12873
                                                                                  12873 12917 12925 12927 12929 12930 12932 12998
                                                                                  13002 13013 13021 13043 13046 13067 13071 13078
                                                                                  13085 13085 13139 13146 13154 13156 13156 13191
                                                                                  13194 13201 13228 13230 13230 13230 13232 13234
addr                                                   builtin function         dcl 9-17 in procedure "create_node" ref 9-24 9-25
addressing_bits           0(14)        based           structure                level 2 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse"
addressing_bits           0(14)        based           structure                level 2 in structure "constant" packed packed
                                                                                  unaligned dcl 5-256 in procedure "ext_parse"
adesc                           014070 automatic       fixed bin(18,0)          dcl 7042 in procedure "parse_parameter_list" set ref
                                                                                  7147* 7148 7161
adesc                           013302 automatic       fixed bin(18,0)          dcl 4807 in procedure "declaration_processor" set
                                                                                  ref 4960* 4961 4962 5161
after_subprogram                       constant        fixed bin(18,0)          initial dcl 510 ref 1342 6188 7117
aliasable                 2(03)        based           bit(1)                   level 2 packed packed unaligned dcl 5-844 ref 5044
alignment                 0(30)        based           structure                level 3 packed packed unaligned dcl 5-436 set ref
                                                                                  5393 5396 5460*
all_attributes                  003012 constant        bit(47)                  initial dcl 511 set ref 1119 1718 1766* 2402* 2570*
                                                                                  6172
all_character_offsets_in_group  013303 automatic       bit(1)                   packed unaligned dcl 4808 set ref 5255* 5257 5258*
                                                                                  5262* 5361 5468 5993
allocate                  0(25)        based           bit(1)                   level 5 packed packed unaligned dcl 5-844 set ref
                                                                                  2866* 5097 8962*
allocate_symbol_name            000144 automatic       fixed bin(17,0)          dcl 5-525 set ref 5454* 5455 5651* 5652 5652 5787*
                                                                                  5788 5788 5857* 5858 5951* 5952 5952 6213* 6214
                                                                                  6214 6219 6220 8215* 8219 8225 8226 8251 8266 8266
                                                                                  8268 8269 8269 9824* 9825 9825 9838 9846
allow_array_name          0(05)        based           bit(1)                   level 2 packed packed unaligned dcl 1034 ref 10384
allow_asterisk                         parameter       bit(1)                   dcl 8927 in procedure "get_format" ref 8914 9030
allow_asterisk                         parameter       bit(1)                   dcl 8713 in procedure "parse_unit_specifier" ref
                                                                                  8705 8721 8745
allow_asterisk                         parameter       bit(1)                   dcl 8436 in procedure "parse_implied_io" set ref
                                                                                  8422 8454*
allow_octal_constant                   parameter       bit(1)                   dcl 7944 ref 7938 7972
allow_star_after                000134 automatic       bit(1)                   dcl 513 set ref 1291* 1304* 1746* 1748 1760
allow_variable_subscripts              parameter       bit(1)                   dcl 6790 ref 6778 6850
allow_variables                        parameter       bit(1)                   packed unaligned dcl 9724 ref 9721 9790
alphabetic                      002774 constant        char(52)                 initial dcl 514 ref 1853 1865 6155 12390 13154
alphanumeric                    001301 constant        char(64)                 initial dcl 10813 ref 11124
alternate_return                014071 automatic       bit(1)                   dcl 7043 set ref 7064* 7095* 7132
alternate_return_index          000135 automatic       fixed bin(18,0)          dcl 516 set ref 1225* 3305 3305* 3309* 3361* 3389*
ansi66_equivalence_statement    013776 automatic       bit(1)                   dcl 6791 set ref 6813* 6859 6866 6896
ansi_77                   0(30) 000132 automatic       bit(1)                   level 2 in structure "subr_options" packed packed
                                                                                  unaligned dcl 391 in procedure "ext_parse" set ref
                                                                                  2133 3684 3885 3981 4366 4502 4599 5061 5254 5659
                                                                                  5914 6112 6657 6689 6705 6813 8094 8334 8444 8490
                                                                                  9685 10299 11978 11990 12006 12029 12100 12105
ansi_77                  11(30)        based           bit(1)                   level 3 in structure "subprogram" packed packed
                                                                                  unaligned dcl 5-753 in procedure "ext_parse" set
                                                                                  ref 2311 5177 5195
ansi_77                   0(21) 013240 automatic       bit(1)                   level 3 in structure "io_bits" packed packed
                                                                                  unaligned dcl 885 in procedure "parse_source" set
                                                                                  ref 3885* 3981* 4366* 4502* 4599* 8444* 8490*
any_expression                  003030 constant        bit(36)                  initial dcl 1071 set ref 2495* 2860* 2941* 2953*
                                                                                  2962* 3007* 3270* 3840* 3932* 4196* 4213* 4242*
                                                                                  4273* 4292* 4297* 4317* 4323* 4328* 4410* 4413*
                                                                                  4416* 4419* 4422* 4425* 4428* 4431* 4434* 4437*
                                                                                  4440* 4443* 4446* 4544* 4634* 4745* 4750* 4753*
                                                                                  8351* 8760* 8784* 9286* 9291* 9294* 10214 10221
                                                                                  10249 10261 10497
any_label                              constant        bit(2)                   initial dcl 517 set ref 4128* 4128* 6676 6676 6680
                                                                                  6680
ap                              014072 automatic       pointer                  dcl 7044 in procedure "parse_parameter_list" set ref
                                                                                  7148* 7149 7152
ap                              013304 automatic       pointer                  dcl 4809 in procedure "declaration_processor" set
                                                                                  ref 4962* 4963 4967 4967
apostrophe                             constant        bit(9)                   initial dcl 4-156 ref 8539 11394
apostrophe_char                 001300 constant        char(1)                  initial dcl 10815 set ref 11404*
arg                       1            based           structure                array level 2 dcl 5-130
arg_desc                               based           structure                level 1 dcl 5-130 set ref 7147 7147
arg_desc_cnt                    013630 automatic       fixed bin(17,0)          dcl 6235 set ref 6300* 6304* 6307 6371
arg_desc_idx                    013631 automatic       fixed bin(17,0)          dcl 6235 set ref 6307* 6308 6310* 6371* 6372 6373*
arg_desc_node                          constant        fixed bin(4,0)           initial dcl 4-87 set ref 7147*
arg_desc_ptr                    013632 automatic       pointer                  dcl 6235 set ref 6303* 6304 6308 6310 6372 6373
arg_list_expr                          constant        bit(36)                  initial dcl 1071 ref 3329 10236 10282
arg_symbol_ptr                  013634 automatic       pointer                  dcl 6235 set ref 6310* 6312 6314
arg_type                        000136 automatic       bit(36)                  dcl 518 set ref 3327* 3329* 3345*
array_max_size                  013563 automatic       fixed bin(24,0)          dcl 6094 in procedure "set_data_fields" set ref
                                                                                  6122* 6124* 6126* 6128* 6130* 6132* 6136 6136
array_max_size                  013306 automatic       fixed bin(24,0)          dcl 4810 in procedure "declaration_processor" set
                                                                                  ref 5007* 5009* 5012 5012
array_name                0(09)        based           bit(1)                   level 3 packed packed unaligned dcl 1034 set ref
                                                                                  8832 9315 10382*
array_size                3            based           fixed bin(24,0)          level 2 dcl 5-383 set ref 5012 5221 5646 5665 5747
                                                                                  5942 6138*
asf_attribute                   002772 constant        bit(47)                  initial dcl 519 set ref 2782*
asf_conflicts                   002770 constant        bit(47)                  initial dcl 521 set ref 2782*
asf_definition                         constant        fixed bin(18,0)          initial dcl 523 ref 1276 10987 11010 11014 11014
                                                                                  11022 11027 11031
assign                                 constant        bit(9)                   initial dcl 4-156 ref 2490 2576 2856 2950 2958 3569
                                                                                  3900 4392 4527 4623 4741 8506 8618 8671 8696 8717
                                                                                  9200 9362 11324
assign_                         000014 constant        entry                    external dcl 524 ref 12862 12873
assign_label_op                        constant        fixed bin(18,0)          initial dcl 4-197 set ref 4145*
assign_op                              constant        fixed bin(18,0)          initial dcl 4-197 set ref 2963* 3311* 3841* 6355*
                                                                                  6489*
assignment_statement                   constant        fixed bin(18,0)          initial dcl 525 ref 1367 1529 2913 2914 3065 6499
                                                                                  10987 11008 11014 11022 11026 11031 11038
assignment_statement_index      000137 automatic       fixed bin(18,0)          dcl 526 set ref 1276* 1367 1529 6499* 11008 11337
                                                                                  11342
assumed_size              0(28)        based           bit(1)                   level 2 packed packed unaligned dcl 5-383 set ref
                                                                                  5086 6317 8837 9584* 10388
assumed_size_index              016506 automatic       fixed bin(18,0)          dcl 9449 set ref 9470* 9504 9568 9568 9584 9606
                                                                                  9612*
asterisk                               constant        bit(9)                   initial dcl 4-156 ref 1293 1309 7094 7532 8314 8334
                                                                                  8744 9030 9489 9517 11179 11414
asterisk_seen                   000140 automatic       bit(1)                   dcl 527 in procedure "parse_source" set ref 1748*
                                                                                  1760* 1834* 2244* 2258* 2267 2269*
asterisk_seen                          parameter       bit(1)                   dcl 8305 in procedure "get_mode_size" set ref 8291
                                                                                  8312* 8315*
attach_desc_field                      constant        fixed bin(17,0)          initial dcl 15-50 set ref 4416*
attr                                   based           structure                level 1 packed packed unaligned dcl 8306
attr_table                      002752 constant        bit(47)                  initial array dcl 528 ref 1259 1260 1263 1264 1267
                                                                                  1268 1742 1833 2243 3305 3835 5637 5693 7135 8417
                                                                                  9967 9983
attributes                             parameter       bit(47)                  dcl 8307 in procedure "get_mode_size" set ref 8291
                                                                                  8375 8379 8408 8410 8414 8417*
attributes               10            based           structure                level 2 in structure "master" dcl 13221 in procedure
                                                                                  "check_entry_duplication"
attributes                             parameter       bit(47)                  dcl 9818 in procedure "build_symbol" ref 9814 9834
attributes                      000142 automatic       bit(47)                  dcl 533 in procedure "parse_source" set ref 1742*
                                                                                  1748* 1760* 1765* 1765 1766* 1833* 1834* 1892
                                                                                  2243* 2244* 2257
attributes               10            based           structure                level 2 in structure "symbol" dcl 5-844 in procedure
                                                                                  "ext_parse" set ref 3558 5192 5916 6155* 6155
                                                                                  6174* 6542 6545* 6545 9834* 9937 9967 9983* 9983
                                                                                  10207 10266 10267* 10267 10362 10404 10404* 10404
attributes                             parameter       bit(47)                  dcl 6532 in procedure "declare_symbol" ref 6520 6545
attributes               10            based           structure                level 2 in structure "slave" dcl 13222 in procedure
                                                                                  "check_entry_duplication"
auto                            000122 automatic       fixed bin(24,0)          level 2 in structure "max_array_size" dcl 383
                                                                                  in procedure "ext_parse" set ref 429* 431* 5007
                                                                                  5532 6124 6132
auto                      0(09)        based           bit(1)                   level 3 in structure "subprogram" packed packed
                                                                                  unaligned dcl 5-753 in procedure "ext_parse" set
                                                                                  ref 1569* 2657*
auto_attribute                  002750 constant        bit(47)                  initial dcl 534 set ref 1765 2745* 2830* 3305
automatic                11            based           bit(1)                   level 4 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 5007 5044 5048* 5640* 5644 5696* 5745 6124
automatic                 0(33)        based           bit(1)                   level 4 in structure "header" packed packed
                                                                                  unaligned dcl 5-436 in procedure "ext_parse" set
                                                                                  ref 5532 5590 5696 5818
b72_one                         002746 constant        bit(72)                  initial dcl 536 ref 12720 12817 12836 12845 12879
b72_zero                        002744 constant        bit(72)                  initial dcl 538 ref 12703 12710 12725
backspace_op                           constant        fixed bin(18,0)          initial dcl 4-197 ref 3870
backspace_opr                          constant        fixed bin(4,0)           initial dcl 15-19 ref 3872
bad_type                        000144 automatic       fixed bin(18,0)          dcl 540 set ref 4784 11045*
based_bit_72                           based           bit(72)                  dcl 541 set ref 7681* 7705*
based_char                             based           char(8)                  dcl 542 set ref 4896* 4896 7662* 7677* 12830* 12839*
based_dec                              based           char(12)                 dcl 12693 set ref 12707 12714 12714*
based_double                           based           float bin(63)            level 2 packed packed unaligned dcl 844 set ref 7698
                                                                                  7723 7738* 10731 12754* 12754 13085
based_integer                          based           fixed bin(35,0)          dcl 543 set ref 1096* 1099* 3026 3026 3226 3226 3656
                                                                                  3713 3727* 3740 4128 4128 4165* 4734 6930* 7534
                                                                                  7689* 7698* 7714 7738 7896 8320 8365 8678 8738
                                                                                  8740 8740 8740 8827* 8831* 8842* 8842 8888* 8888
                                                                                  8946 9410 10293 10737 12728* 12739 12745* 12745
                                                                                  13043* 13046
based_real                             based           float bin(27)            array dcl 544 set ref 7689 7710* 7714* 7719* 7723*
                                                                                  7728* 7732* 7732 10731* 10737* 10745* 10745 12749*
                                                                                  12749 12759* 12759 12762* 12762 13085*
based_words                            based           bit(36)                  array dcl 545 set ref 8172* 8172 8230* 8230 8234
                                                                                  8238
before                                                 builtin function         dcl 546 ref 11892 11893 11909
begin_char                      000145 automatic       fixed bin(18,0)          dcl 547 set ref 1853* 1869 1874 1884 1884 1887 1887
                                                                                  1891
begin_index               2     012412 automatic       fixed bin(18,0)          array level 2 dcl 875 set ref 3524 3772 9128* 9151*
                                                                                  9195* 9200 9276 9324
begin_text                      016772 automatic       fixed bin(20,0)          dcl 10816 set ref 10909* 10975 10975
bias                                   constant        fixed bin(19,0)          initial dcl 4-56 ref 2886 3123 3199 3368 3371 3379
                                                                                  3530 3660 3664 4249 4468 4471 4566 4569 4711 4759
                                                                                  5125 6367 6369 6440 6904 7158 7287 7348 7353 7583
                                                                                  7598 7651 7673 8087 8128 8386 8767 9140 9368 9423
                                                                                  9806 10601 10605 10947 10958 11282 11292 11600
                                                                                  11617 12511 12635 12652 12815 13078
bif_conflicts                   002742 constant        bit(47)                  initial dcl 548 set ref 2312* 2370* 9937
bif_dt                          016650 automatic       fixed bin(18,0)          dcl 9861 set ref 9965* 9967 9967 9983
bif_name                        016652 automatic       char(8)                  dcl 9862 set ref 9940 9942* 9949 9952
bif_ptr                         016654 automatic       pointer                  dcl 9863 set ref 9930* 9932 9934 9937 9940 9942 9967
                                                                                  9967 9972 9980 9981 9982 9983 9983 9983
bif_table                       000251 constant        structure                array level 1 dcl 9873 ref 9945
binary                                                 builtin function         dcl 550 in procedure "parse_source" ref 2141 2156
                                                                                  2177 3883 4364 4500 4597 5294 6686 6701 8219 8241
                                                                                  10118 10167 10349 10477 10608 10639 10975 11109
                                                                                  11109 11445 11445 11865 12264 12318 12322 12942
                                                                                  13204
binary                                                 builtin function         dcl 8-19 in procedure "create_constant" ref 8-57
binarystream_field                     constant        fixed bin(17,0)          initial dcl 15-50 set ref 4434*
binop_trunc            2040            based           entry variable           array level 2 dcl 398 set ref 7906
bit                                                    builtin function         dcl 551 ref 3883 4364 4500 4597 6280 6390 6401 6461
                                                                                  7986 8860 8860 8860 8860 8871 8871 8871 8871 10903
                                                                                  10904 10975 11445
bit_mask                        002736 constant        bit(36)                  initial array dcl 552 ref 8172 8230
bit_value                       000146 automatic       bit(9)                   dcl 555 set ref 11109 11109 11109 11112 12317 12318
                                                                                  12322
bits                      0(25)        based           structure                level 2 in structure "master" packed packed
                                                                                  unaligned dcl 13221 in procedure
                                                                                  "check_entry_duplication"
bits                      3            based           structure                level 2 in structure "statement" packed packed
                                                                                  unaligned dcl 5-721 in procedure "ext_parse" set
                                                                                  ref 1551* 1639* 1702* 1734* 2786* 2929* 2998*
                                                                                  3084* 3167* 3213* 3293* 3405* 3421* 3819* 3877*
                                                                                  3950* 3970* 4022* 4037* 4089* 4122* 4159* 4183*
                                                                                  4192* 4270* 4289* 4313* 4357* 4493* 4590* 4724*
bits                      0(25)        based           structure                level 2 in structure "label" packed packed unaligned
                                                                                  dcl 5-530 in procedure "ext_parse"
bits                      0(25)        based           structure                level 2 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse"
bits                      0(25)        based           structure                level 2 in structure "slave" packed packed unaligned
                                                                                  dcl 13222 in procedure "check_entry_duplication"
bits                      0(25)        based           structure                level 2 in structure "constant" packed packed
                                                                                  unaligned dcl 5-256 in procedure "ext_parse"
bits                      0(25)        based           structure                level 2 in structure "header" packed packed
                                                                                  unaligned dcl 5-436 in procedure "ext_parse"
blank_common_name               003056 constant        char(8)                  initial dcl 4-79 ref 1978 1981 7422
blank_cont_count                016773 automatic       fixed bin(18,0)          dcl 10817 set ref 11063* 11497* 11514 11517 12025*
                                                                                  12025 12589
blank_count                     017244 automatic       fixed bin(18,0)          dcl 11483 set ref 11496* 11506 11508 11517* 11518
                                                                                  11599 11606 11607 11608
blank_field                            constant        fixed bin(17,0)          initial dcl 15-50 set ref 4446* 4649*
block_data                             constant        fixed bin(9,0)           initial dcl 4-68 ref 1529 1549 1680 2045 6496 7422
                                                                                  7438
block_data_op                          constant        fixed bin(18,0)          initial dcl 4-197 set ref 1662*
block_if_op                            constant        fixed bin(18,0)          initial dcl 4-197 set ref 3130*
block_length                    013307 automatic       fixed bin(25,0)          dcl 4811 set ref 5176* 5206 5210* 5210 5213 5226*
                                                                                  5226 5234 5236 5359* 5360 5361 5364 5378* 5379
                                                                                  5381 5555* 5558 5593* 5596 5766* 5767* 5767 5767
                                                                                  5769 5777 5780 5834* 5835* 5835 5835 5837 5847
                                                                                  5853
block_max_size                  013310 automatic       fixed bin(24,0)          dcl 4812 set ref 5490* 5500* 5502* 5505 5505 5528*
                                                                                  5530* 5532* 5534* 5537 5537
block_name               10            based           char                     level 2 dcl 5-436 set ref 1998 2679 5490 5683 5685
                                                                                  6220* 7422
bnd_sym_idx                            parameter       fixed bin(24,0)          dcl 6013 set ref 6007 6021 6022*
bnd_sym_ptr                     013534 automatic       pointer                  dcl 6015 set ref 6021* 6022 6024 6025
bool                                                   builtin function         dcl 8-20 in procedure "create_constant" ref 8-54
bool                                                   builtin function         dcl 8207 in procedure "find_symbol_index" ref 8238
bound                                  parameter       fixed bin(24,0)          dcl 9649 set ref 9631 9681* 9688* 9689 9693* 9709*
                                                                                  9714*
bound_error                     016507 automatic       bit(1)                   dcl 9450 set ref 9474* 9476 9496* 9523* 9545* 9572*
                                                                                  9577 9609*
bound_is_expression             013636 automatic       bit(1)                   packed unaligned dcl 6235 set ref 6328* 6330* 6336*
                                                                                  6338* 6341
bound_is_variable                      parameter       bit(1)                   packed unaligned dcl 9649 set ref 9631 9682* 9685
bound_symbol_ptr                013640 automatic       pointer                  dcl 6235 set ref 6326* 6328 6334* 6336 6343 6349
                                                                                  6349
bounds                          016527 automatic       structure                array level 1 dcl 9464 set ref 9471* 9482 9591
bp                              013312 automatic       pointer                  dcl 4813 set ref 5175* 5177 5180 5181 5186 5189 5195
                                                                                  5236 5239 5267* 5293 5320 5321* 5328 5345 5352
                                                                                  5371 5371 5378 5381 5387 5404 5404 5413 5413 5420
                                                                                  5420 5425 5426 5438 5438 5460 5461 5468
branched_to               0(34)        based           bit(1)                   level 3 packed packed unaligned dcl 5-530 set ref
                                                                                  6661* 6689 6724 6731 6732*
build_list                             parameter       bit(1)                   dcl 9388 ref 9374 9393
build_list_item                        parameter       bit(1)                   dcl 8714 ref 8705 8721 8766
builtin                  10(32)        based           bit(1)                   level 4 packed packed unaligned dcl 5-844 set ref
                                                                                  5059 9932 9981* 10393
builtin_op                             constant        fixed bin(18,0)          initial dcl 4-197 ref 10262
by_compiler               0(35)        based           bit(1)                   level 3 packed packed unaligned dcl 5-844 set ref
                                                                                  1685* 1772* 2837* 5023 5916 6022 6177* 6328 6336
                                                                                  9836*
bypass_first_pending_entry      000147 automatic       bit(1)                   packed unaligned dcl 556 set ref 1278* 4065* 6269
bypass_label                    013642 automatic       fixed bin(18,0)          dcl 6235 set ref 6259* 6269 6272* 6274 6275* 6395
                                                                                  6396*
c_count                         014114 automatic       fixed bin(18,0)          dcl 7228 set ref 7274* 7518 7531* 7534* 7535 7538*
                                                                                  7560 7748* 7748 7826
c_dt                            014115 automatic       fixed bin(4,0)           dcl 7229 set ref 7549* 7552* 7553 7570 7573
call_op                                constant        fixed bin(18,0)          initial dcl 4-197 set ref 3318*
cant_be_reached           0(04) 000000 constant        bit(1)                   initial array level 2 packed packed unaligned
                                                                                  dcl 892 ref 1428
cant_ref_label            0(05) 000000 constant        bit(1)                   initial array level 2 packed packed unaligned
                                                                                  dcl 892 ref 1384
card                      0(05) 000132 automatic       bit(1)                   level 3 packed packed unaligned dcl 391 set ref
                                                                                  11976
card_image                      000150 automatic       bit(1)                   dcl 557 set ref 11437 11582 11976* 11986
carriage_field                         constant        fixed bin(17,0)          initial dcl 15-50 set ref 4440*
chain                           012412 automatic       fixed bin(18,0)          array level 2 dcl 875 set ref 3775 9126* 9147* 9165
                                                                                  9168* 9179* 9326
chain_op                               constant        fixed bin(18,0)          initial dcl 4-197 set ref 4232*
char                                                   builtin function         dcl 9-17 in procedure "create_node" ref 9-29 9-29
char                      1     000122 automatic       fixed bin(24,0)          level 2 in structure "max_array_size" dcl 383
                                                                                  in procedure "ext_parse" set ref 421* 5500 5528
                                                                                  6122
char                                                   builtin function         dcl 8-21 in procedure "create_constant" ref 8-45
                                                                                  8-45
char                                                   builtin function         dcl 558 in procedure "parse_source" ref 1410 1410
                                                                                  1543 1543 5012 5234 5379 5379 5505 5537 5927 5927
                                                                                  6136 6346 6346 6425 6425 6436 6436 6452 6452 6470
                                                                                  6470 6508 6508 6614 6614 7171 7171 8322 8322 8393
                                                                                  8393 8398 8398 8738 8740 8740 9599 9599 9623 9623
                                                                                  10899 10899 11109 12086 12086 13207
char_constant                          based           structure                level 1 dcl 5-316
char_count                      014116 automatic       fixed bin(18,0)          dcl 7230 set ref 7643* 7646 7667* 7667 7673 7677
char_index                      000151 automatic       fixed bin(20,0)          dcl 559 set ref 11124 11124 11128 11128 11227 11227
                                                                                  11441 11502 11502 11535 11535 11541 11541 11542
                                                                                  11542 11571 11571 11577* 11577 11578 11578 11625
                                                                                  11625 11630 11630 11633* 11633 11758* 11761 11788
                                                                                  11788 11788 11789 11802 11802 11804 11804 11807
                                                                                  11807 11807 11807 11812* 11812 11814 11814 11819
                                                                                  11819 11820* 11820 11821 11821 11826 11826 11828
                                                                                  11828 11831 11831 11831 11831 11835 11835 11917*
                                                                                  11931 11931 11941 11941 11990 11990 11993 11993
                                                                                  11995 11995 11999 12002 12002 12002 12002 12002
                                                                                  12002 12002 12002 12007 12007 12010 12010 12010
                                                                                  12010 12012 12012 12012 12012 12012 12012 12016*
                                                                                  12016 12017 12017 12029 12029 12030 12030 12034*
                                                                                  12034 12039 12039 12040 12040 12044 12044 12045*
                                                                                  12045 12062 12062 12064 12064 12067 12067 12067
                                                                                  12074 12074 12074 12074 12076* 12076 12082 12082
                                                                                  12084* 12084 12100 12100 12102 12102 12102 12102
                                                                                  12104 12104 12108* 12108 12109 12109 12114* 12114
                                                                                  12116 12116 12127 12127 12127 12127 12132 12132
                                                                                  12143 12143 12159 12159 12169* 12169 12189* 12189
                                                                                  12215 12215 12218* 12218 12218 12218 12223* 12223
                                                                                  12225 12225 12227* 12227 12227 12227 12231 12231
                                                                                  12232 12232 12239 12239 12241 12241 12242* 12242
                                                                                  12264 12264 12278* 12278 12286* 12286 12350 12350
                                                                                  12354 12354 12390 12390 12394 12394 12564 12564
                                                                                  12582 12582 12605 12605
char_len                        014117 automatic       fixed bin(18,0)          dcl 7231 set ref 7635* 7646 7646 7651 7660 7660 7662
                                                                                  7662 7673 7673 7677
char_mode                              constant        fixed bin(4,0)           initial dcl 4-106 ref 8-43 2267 5177 5195 5201 6110
                                                                                  6122 7553 7567 7570 7573 7573 8334 8367 8375 8408
char_offset                            parameter       bit(1)                   packed unaligned dcl 5903 set ref 5898 5914* 5937
                                                                                  5961
char_siz                        000152 automatic       fixed bin(18,0)          dcl 560 set ref 2242* 2244* 2258 2269 3688* 3691*
                                                                                  3719 3719 3727 3747 3747
char_size                10            based           fixed bin(20,0)          level 4 in structure "symbol" packed packed unsigned
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 2146 2161 2181 2523* 2527 2527 2891* 3688 5065
                                                                                  5127* 5742 5752 6113 6116 6930 7367 7575 8158*
                                                                                  8183* 8827 9980*
char_size                              based           fixed bin(20,0)          level 3 in structure "attr" packed packed unsigned
                                                                                  unaligned dcl 8306 in procedure "get_mode_size"
                                                                                  set ref 8410* 8414*
char_string                            constant        bit(9)                   initial dcl 4-156 ref 2607 4097 9010 11216 12557
                                                                                  12932 13010
char_temp                       000153 automatic       char(1320)               dcl 561 set ref 7578 7580 7584 7587 7590 7590 7594
                                                                                  7595 7595 8086 8087 8092* 8094* 8132
char_type                       000665 automatic       fixed bin(18,0)          dcl 562 set ref 10936 11133 11133 11150 11257 11430
                                                                                  11568 12127 12265* 12267* 12270 12275 12318*
                                                                                  12322* 12360 12399 12459 12492
char_type_offset                       parameter       bit(1)                   packed unaligned dcl 5987 ref 5976 5993
char_units                             constant        fixed bin(3,0)           initial dcl 4-136 ref 5181 5371 5413 5937 5961 6114
char_value                             based           char(1)                  dcl 563 set ref 11112* 12317*
char_var_length                 014120 automatic       fixed bin(10,0)          dcl 7232 set ref 7367* 7374 7376 7384 7386 7575*
                                                                                  7578 7580 7584 7587 7590 7590 7590 7590 7592 7594
                                                                                  7595 7595 7595 7595 7598 7598
char_var_value                         based           char                     packed unaligned dcl 7233 set ref 7578* 7580* 7584*
                                                                                  7587* 7590* 7590* 7594* 7595* 7595*
character                10(25)        based           bit(1)                   level 5 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 2515 2936 3688 5061 5258 5361 5497 5524 5633
                                                                                  5659 5742 5914 8754 8826 9004 10185 10498
character                 0(32)        based           bit(1)                   level 4 in structure "header" packed packed
                                                                                  unaligned dcl 5-436 in procedure "ext_parse" set
                                                                                  ref 5180* 5195 5468* 5659*
character_offset                013316 automatic       bit(1)                   packed unaligned dcl 4814 set ref 5267* 5272* 5281*
                                                                                  5289* 5361
chars_in_block                  013314 automatic       bit(1)                   packed unaligned dcl 4814 set ref 5493* 5494 5497*
                                                                                  5500
chars_in_group                  013315 automatic       bit(1)                   packed unaligned dcl 4814 set ref 5520* 5521 5524*
                                                                                  5528
chars_per_word                         constant        fixed bin(8,0)           initial dcl 13-99 ref 1155 1157 5065 5065 5752 5752
                                                                                  6116 6116 7635 8158 8160 8160 8172 8172 8172 8225
                                                                                  8226 8831 11900
clauses                   1     004422 automatic       fixed bin(18,0)          array level 2 dcl 836 set ref 3119* 3119 3136* 3188*
                                                                                  3188 3199
close_op                               constant        fixed bin(18,0)          initial dcl 4-197 set ref 4520*
close_opr                              constant        fixed bin(4,0)           initial dcl 15-19 ref 4500
closefile_op                           constant        fixed bin(18,0)          initial dcl 4-197 set ref 4274*
cmpx_mode                       003275 constant        fixed bin(4,0)           initial dcl 4-106 set ref 8321 10768* 12764*
cname                           016774 automatic       char(32)                 packed unaligned dcl 10818 set ref 11879* 11886*
                                                                                  11907 11909
code                            000666 automatic       fixed bin(35,0)          dcl 564 set ref 2612* 2615* 2618 8094* 8095 11837*
                                                                                  11842 11842 11842* 11849* 11855* 11870* 11879*
                                                                                  11881 11882 11884*
colon                                  constant        bit(9)                   initial dcl 4-156 ref 2152 2172 3697 3704 9503 10326
                                                                                  10515 11456 12968
com_err_                        000042 constant        entry                    external dcl 10862 ref 11842 11884
comma                                  constant        bit(9)                   initial dcl 4-156 ref 1894 1901 1931 2063 2200 2211
                                                                                  2279 2316 2344 2378 2439 2549 2590 2710 2755 2849
                                                                                  2942 3016 3030 3043 3242 3252 3268 3350 3577 3583
                                                                                  3668 3770 3798 3922 4001 4198 4215 4244 4293 4318
                                                                                  4325 4455 4553 4692 4737 4746 4751 6886 7104 7275
                                                                                  7519 8453 8457 8545 8566 8612 8616 8626 9195 9287
                                                                                  9292 9322 9414 9559 10481 11182 11368
command                         001276 constant        char(7)                  initial packed unaligned dcl 10819 set ref 11837*
                                                                                  11842* 11884*
common                    2     000122 automatic       fixed bin(24,0)          level 2 dcl 383 set ref 441* 443* 5502 5530 6126
                                                                                  6132
common_blk_name                        parameter       varying char(256)        dcl 6209 ref 6204 6213 6220
common_chain              2            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-753
                                                                                  set ref 1986 1992* 2676 2689 2689* 5174 5487 5552
                                                                                  5560* 5576
common_hdri                     013317 automatic       fixed bin(18,0)          dcl 4815 set ref 5487* 5487* 5489 5505* 5552* 5553
                                                                                  5554 5565 5576* 5578*
common_hdrp                     013320 automatic       pointer                  dcl 4816 set ref 5489* 5490 5494 5505 5505 5507
                                                                                  5554* 5555 5555 5555 5560 5562 5564 5566 5567 5573
common_name                     000667 automatic       varying char(256)        dcl 565 set ref 1671* 1674* 1681* 1685 1965* 1978*
                                                                                  1981* 1991* 1998 2004* 2674* 2679 2688*
common_storage                         constant        bit(3)                   initial dcl 566 ref 6217
compile_only            115(02)        based           bit(1)                   level 4 packed packed unaligned dcl 398 set ref 2612
compiler_source_info                   based           structure                level 1 dcl 14-6
complex                  10(23)        based           bit(1)                   level 5 packed packed unaligned dcl 5-844 set ref
                                                                                  5206 5657 5757 5964
complex_const                          constant        bit(9)                   initial dcl 4-156 ref 10761
complex_constant_offset                parameter       fixed bin(18,0)          dcl 10658 set ref 10655 10768*
complex_info                    016753 automatic       structure                array level 1 dcl 10667
concat                                 constant        bit(9)                   initial dcl 4-156 ref 1976 2066 2072 11384
conflicts                              parameter       bit(47)                  dcl 6533 ref 6520 6542
const                           014125 automatic       fixed bin(18,0)          dcl 7236 set ref 7529* 7536* 7543* 7546* 7549 7552
                                                                                  7553 7582 7584 7587 7592 7594 7598 7600 7604 7613*
                                                                                  7643 7662 7677 7691* 7700*
const_count                     000771 automatic       fixed bin(18,0)          dcl 568 set ref 10888* 12508* 12508 12509 12511
                                                                                  12518 12519 12520 12521 12522
const_index                     000770 automatic       fixed bin(18,0)          dcl 567 set ref 2579* 2582* 2585 2604* 2612 2615
                                                                                  6849* 6860* 6867* 6879 8317* 8364* 8365 8381*
const_max_len                   017245 automatic       fixed bin(18,0)          dcl 11484 set ref 11495* 11496 11508* 11508 11517
                                                                                  11518* 11518 11522
const_offset                    014216 automatic       fixed bin(18,0)          dcl 7945 set ref 7953* 7957* 7966* 7991* 7997* 8003
                                                                                  8010* 8010* 8016
constant                               based           structure                level 1 dcl 5-256 in procedure "ext_parse" set ref
                                                                                  8-74 8-74
constant                 11(05)        based           bit(1)                   level 4 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 5059*
constant_array                  011016 automatic       structure                array level 1 dcl 853 set ref 12509 12511 12511
constant_count           77            based           fixed bin(17,0)          array level 3 dcl 398 set ref 8-87* 8-87
constant_info            77            based           structure                array level 2 dcl 398
constant_node                          constant        fixed bin(4,0)           initial dcl 4-87 set ref 8-74* 6977
constant_offset                        parameter       fixed bin(18,0)          dcl 7946 set ref 7938 7953 8016*
constant_type                          constant        fixed bin(4,0)           initial dcl 4-120 in procedure "ext_parse" ref 8-82
constant_type                   002730 constant        bit(9)                   initial array dcl 569 in procedure "parse_source"
                                                                                  ref 12930
contains_hollerith        0(21)        based           bit(1)                   level 4 in structure "runtime_format" packed packed
                                                                                  unaligned dcl 13-32 in procedure "parse_source"
                                                                                  ref 4899
contains_hollerith        0(21)        based           bit(1)                   level 4 in structure "encoded_format" packed packed
                                                                                  unaligned dcl 8084 in procedure "create_format"
                                                                                  ref 8115
continuation_line                      constant        fixed bin(18,0)          initial dcl 571 ref 11081 12020 12119
control_bits                           parameter       bit(36)                  dcl 10045 ref 9990 10093 10095
control_type              0(08) 013240 automatic       bit(4)                   level 3 packed packed unaligned dcl 885 set ref
                                                                                  3883* 4364* 4500* 4597*
conv_error                      014124 automatic       fixed bin(35,0)          dcl 7235 set ref 7686* 7689* 7691 7696* 7698* 7700
conv_round             2500            based           entry variable           array level 2 dcl 398 set ref 7689 7698 7714 7723
                                                                                  7738 10731 10737 13085
copy                                                   builtin function         dcl 572 ref 2527 2527
count                           016670 automatic       fixed bin(18,0)          dcl 10046 in procedure "parse_expression" set ref
                                                                                  10091* 10295* 10314* 10328* 10328 10482* 10482
                                                                                  10516* 10516 10517 10536 10600 10601 10605 10616*
                                                                                  10632*
count                                  parameter       fixed bin(18,0)          dcl 6419 in procedure "emit_halfword" ref 6468 6470
                                                                                  6473 6477 6479
count                           000772 automatic       fixed bin(18,0)          dcl 573 in procedure "parse_source" set ref 2802*
                                                                                  2814* 2814 2885 2888* 2891 3325* 3347* 3347 3363*
                                                                                  3363 3368 3371 3888* 3899* 3899 3917 4238* 4243*
                                                                                  4243 4249 4372* 4387* 4389* 4389 4394 4508* 4524*
                                                                                  4524 4529 4618* 4620* 4620 4686 7061* 7083* 7083
                                                                                  7123* 7123 7133* 7133 7181 7188 8500* 8504* 8504
                                                                                  8537 8544 9371* 9371
count                           016472 automatic       fixed bin(18,0)          dcl 9386 in procedure "scan_label_list" set ref
                                                                                  9398* 9413* 9413 9423
count                           016510 automatic       fixed bin(18,0)          dcl 9451 in procedure "get_bounds" set ref 9467*
                                                                                  9481* 9481 9482 9492 9492 9498 9504 9508 9508 9509
                                                                                  9510 9510 9511 9520 9520 9525 9534 9535 9540 9541
                                                                                  9541 9549 9568 9580 9583 9612 9613 9622 9624 9624
                                                                                  9626
count                           017004 automatic       fixed bin(18,0)          dcl 10820 in procedure "statement_lex" set ref
                                                                                  11212* 11218 11225* 11225 11226 11227 11228* 11228
                                                                                  11229 11230* 11234 11243
count                                  parameter       fixed bin(18,0)          dcl 7840 in procedure "store_value" set ref 7837
                                                                                  7853 7859*
count                           013777 automatic       fixed bin(18,0)          dcl 6792 in procedure "get_constant_offset" set ref
                                                                                  6812* 6836* 6836 6842 6859 6866 6879 6879 6897
                                                                                  6897 6899* 6899* 6907 6914 6915 6916
count_op                  2     004422 automatic       fixed bin(18,0)          array level 2 dcl 836 set ref 3138* 3199
count_pic                       016640 automatic       picture(4)               packed unaligned dcl 9822 set ref 9843* 9844
cp_count                        000773 automatic       fixed bin(18,0)          dcl 574 set ref 1250* 9842* 9842 9843
cp_label_count                  000774 automatic       fixed bin(18,0)          dcl 575 set ref 1251* 6271* 6271 6272*
create_char_constant   1524            based           entry variable           level 2 dcl 398 set ref 2527 4101 4105 4228 4228
                                                                                  4331 4331 7590 7590 7595 7595 8179 8179 8184 8184
                                                                                  13013 13021
create_sw                              parameter       fixed bin(2,0)           dcl 8208 ref 8192 8264
cref_base                14            based           pointer                  level 2 in structure "shared_structure" dcl 398
                                                                                  in procedure "ext_parse" set ref 414
cref_base                       000112 automatic       pointer                  dcl 378 in procedure "ext_parse" set ref 414* 1389
                                                                                  1389 1392 1392 6512 6514 6516
cross_reference                        based           structure                array level 1 dcl 6-8
cur_listing              22            based           pointer                  level 2 dcl 398 set ref 1231 1234* 1236 1237 1239
                                                                                  1241 1242 1582
cur_paren                       000775 automatic       fixed bin(18,0)          dcl 576 set ref 3524 3597 3602 9109* 9109* 9110
                                                                                  9110* 9123* 9147 9154* 9160 9165 9167 9168 9171
                                                                                  9174* 9178 9183* 9195 9195 9200 9200 9276 9302
                                                                                  9305
cur_segment                     000776 automatic       fixed bin(18,0)          dcl 577 set ref 1103* 1169 1174* 1175 11904* 11905
                                                                                  11924
cur_statement            67            based           fixed bin(18,0)          level 2 dcl 398 set ref 1525* 2102 2405 2406* 4857
                                                                                  4858* 5251* 5476* 6257 6280 6390 6401 6450 6455*
                                                                                  6456 6461 6464 6514 6514 10868 11071*
cur_statement_list       70            based           fixed bin(17,0)          level 2 dcl 398 set ref 6516 10907*
cur_stmnt_ptr                   001000 automatic       pointer                  dcl 578 set ref 1551 1639 1702 1734 2786 2929 2981*
                                                                                  2998 3081* 3084 3167 3213 3293 3405 3421 3819 3877
                                                                                  3950 3970 4022 4037 4089 4122 4159 4183 4192 4270
                                                                                  4289 4313 4357 4493 4590 4724 6188 6257* 6277
                                                                                  6278* 6387 6388* 6398 6399* 6456* 6457 7169 10868
                                                                                  10895 10904 10910 10975 10977
cur_subprogram           71            based           fixed bin(18,0)          level 2 dcl 398 set ref 1204* 1205 1210 1212 1214
                                                                                  1216 1239 1670 6167 6176 7051
current_character               001002 automatic       char(1)                  dcl 579 set ref 11133 11133 11202 11202 11211 11211
                                                                                  11253 11382 11419 11542* 11578* 11582 12109* 12111
                                                                                  12111 12111 12159* 12317 12409 12452 12452 12454
                                                                                  12454 12472 12479
current_loop_end                013745 automatic       fixed bin(18,0)          dcl 6593 set ref 6607* 6608 6609* 6663 6691 6692
                                                                                  6695 6695* 6698 6713 6728 6733
current_parameter               001003 automatic       fixed bin(18,0)          dcl 580 set ref 2487* 2497 2498* 2500
current_spec                    014126 automatic       fixed bin(18,0)          dcl 7237 set ref 7280* 7281 7285 7293 7294 7295
                                                                                  7300* 7305 7310* 7310 7323 7326* 7326 7343 7343
                                                                                  7346* 7360* 7360 7360 7368* 7369* 7369 7369 7378*
                                                                                  7379* 7379 7379 7397* 7397 7799 7815* 7815 7818*
current_token                   001004 automatic       fixed bin(18,0)          dcl 581 set ref 1437* 1492 1647* 1647 1675* 1675
                                                                                  2097 2268* 2268 2555* 2555 2620* 2620 2641 2649*
                                                                                  2649 2782 2788* 2788 2805 2904* 2936 3086* 3086
                                                                                  3100* 3100 3128* 3128 3168* 3168 3228* 3228 3233
                                                                                  3242 3247 3260* 3260 3332 3356* 3356 3407* 3407
                                                                                  3440* 3522 3524* 3597 3599* 3697 3725 3772 3773*
                                                                                  3900 3929* 3929 3952 4098* 4098 4102* 4102 4140*
                                                                                  4141* 4141 4209* 4210* 4210 4236* 4237* 4237 4251*
                                                                                  4251 4392 4462* 4462 4527 4560* 4560 4623 4703*
                                                                                  4703 7067 7112* 7112 7532 7541* 7541 8314 8316*
                                                                                  8316 8458 8459* 8459 8506 8552* 8552 8615 8618
                                                                                  8618 8724* 8724 9102 9110 9127 9132 9134 9149 9184
                                                                                  9195 9236 9238* 9238 9275 9276* 9302 9303* 9324
                                                                                  9325* 10477 10488 10524 10608 10639 10674 10754*
                                                                                  10756 10756 10758 10758 10761 10763 10981* 10987*
                                                                                  10999 11004 11004 11053* 12908* 12908 12911 12914
                                                                                  12915 12939 12940 12951* 12951 12952 12959* 12959
                                                                                  12960 12963 12980* 12980 12981 12984 12985 12995
                                                                                  12996 13011 13012 13184 13187 13188 13189
current_value                   014127 automatic       fixed bin(18,0)          dcl 7238 set ref 7451* 7471* 7472 7474 7509 7578
                                                                                  7580 7807* 7812 7812
cv_ptr                          014122 automatic       pointer                  dcl 7234 set ref 7553* 7689 7698 7714 7723 7732 7738
cx                              016746 automatic       fixed bin(18,0)          dcl 10659 set ref 10720* 10722 10722 10725 10727*
                                                                                  10727 10728 10730* 10736 10736 10741
d_count                         017511 automatic       fixed bin(18,0)          dcl 12343 set ref 12346* 12357* 12357 12365
darg_list_expr                         constant        bit(36)                  initial dcl 1071 ref 3327 10234 10280
data_error                      014130 automatic       bit(1)                   dcl 7239 set ref 7404* 7409* 7415* 7428* 7435* 7478*
                                                                                  7484* 7491* 7648 7754 7784 7843
data_size                       000122 automatic       fixed bin(17,0)          dcl 8-22 set ref 8-47* 8-49 8-87 8-87 8-89 8-89 8-91
                                                                                  8-93
data_type                 0(05)        based           fixed bin(4,0)           level 2 in structure "symbol" packed packed unsigned
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 4873* 4873 4950* 4950 5132* 5177 5195 5201
                                                                                  5639* 5695* 6105 6108* 6937* 7413
data_type                 2(04) 000251 constant        fixed bin(4,0)           initial array level 2 in structure "bif_table"
                                                                                  packed packed unaligned dcl 9873 in procedure
                                                                                  "builtin_lookup" ref 9965
data_type                 0(05)        based           fixed bin(4,0)           level 2 in structure "node" packed packed unsigned
                                                                                  unaligned dcl 5-63 in procedure "ext_parse" ref
                                                                                  8-65 9673 9673
data_type                 0(05)        based           fixed bin(4,0)           level 2 in structure "constant" packed packed
                                                                                  unsigned unaligned dcl 5-256 in procedure
                                                                                  "ext_parse" set ref 8-81* 6978 7552 9696 9766
                                                                                  10707 12737 12930
data_type                              parameter       fixed bin(4,0)           dcl 8-15 in procedure "create_constant" ref 8-13
                                                                                  8-40
data_type_size                  003035 constant        fixed bin(17,0)          initial array dcl 4-115 ref 8-43 8-47 6110 7635
date_time_modified       76            based           fixed bin(71,0)          level 2 dcl 14-6 ref 1185
debug_io                  1(05) 000132 automatic       bit(1)                   level 2 in structure "subr_options" packed packed
                                                                                  unaligned dcl 391 in procedure "ext_parse" set ref
                                                                                  3887 3983 4368 4504 4601 8446 8492
debug_io                  0(14) 013240 automatic       bit(1)                   level 3 in structure "io_bits" packed packed
                                                                                  unaligned dcl 885 in procedure "parse_source" set
                                                                                  ref 3887* 3983* 4368* 4504* 4601* 8446* 8492*
dec_exp                         020010 automatic       fixed dec(3,0)           dcl 12770 set ref 12827* 12830 12839 12840
dec_int                                constant        bit(9)                   initial dcl 4-156 ref 2140 2155 2176 3016 3024 3224
                                                                                  4100 4125 4731 7532 8319 8675 8735 8944 9407 10690
                                                                                  11164 11287 12448 12456 12983 13163
dec_value                       017764 automatic       fixed dec(11,0)          dcl 12694 set ref 12707 12713* 12714 12714 12716
                                                                                  12716 12728
decimal                                                builtin function         dcl 8-23 in procedure "create_constant" ref 8-45
                                                                                  8-45
decimal                                                builtin function         dcl 582 in procedure "parse_source" ref 6614 6614
                                                                                  10899 10899 12086 12086
declared_options       3150            based           structure                level 2 dcl 398 set ref 11945 11945 11948 11954*
                                                                                  11964 11964 11967 11973*
decode_statement                       constant        fixed bin(18,0)          initial dcl 583 ref 3979
decode_string_op                       constant        fixed bin(18,0)          initial dcl 4-197 set ref 8812*
default_char_size               001005 automatic       fixed bin(10,0)          dcl 584 set ref 1748 1760 1834 2242 5125 5127 8367
                                                                                  8382 8388 11978* 11980*
default_is                0(09)        based           structure                level 2 packed packed unaligned dcl 5-753 set ref
                                                                                  5004 5518 5759
default_main_entry_point_name   003054 constant        char(5)                  initial packed unaligned dcl 4-80 ref 1343
default_table                   001006 automatic       bit(47)                  array dcl 585 set ref 1259* 1260* 1263* 1264* 1267*
                                                                                  1268* 1892* 6155
default_unit_specifier          001156 automatic       fixed bin(18,0)          dcl 586 set ref 1098* 8746*
defer_field                            constant        fixed bin(17,0)          initial dcl 15-50 set ref 4443*
delimiter                              parameter       char(1)                  dcl 12549 ref 12535 12564 12605
depthx                          017274 automatic       fixed bin(17,0)          dcl 11717 set ref 11868* 11869*
desired_data_type               013232 automatic       fixed bin(4,0)           level 2 packed packed unaligned dcl 883 set ref
                                                                                  2503* 6998* 8355* 9699* 9769*
difference                      013322 automatic       fixed bin(24,0)          dcl 4817 set ref 5281* 5289* 5289* 5301 5315 5316*
                                                                                  5316 5328 5342 5343 5344* 5344 5347 5359 5371 5374
                                                                                  5376 5394
digit                           017462 automatic       fixed bin(18,0)          dcl 12255 set ref 12264* 12265 12267 12271
digit_count                            parameter       fixed bin(18,0)          dcl 12344 set ref 12326 12365*
digits                                 constant        fixed bin(18,0)          initial dcl 593 in procedure "parse_source" ref
                                                                                  11133 11150 11257 11430 12127 12270 12360 12492
digits                    0(09) 020022 automatic       char(30)                 level 2 in structure "ext_float_dec" packed packed
                                                                                  unaligned dcl 12785 in procedure
                                                                                  "convert_real_constant" set ref 12814 12815 12820*
                                                                                  12822* 12843
dim                                                    builtin function         dcl 592 in procedure "parse_source" ref 6619 8241
dim                       5            based           structure                array level 2 in structure "dimension" dcl 5-383
                                                                                  in procedure "ext_parse" set ref 9591*
dim_attr                        002726 constant        bit(47)                  initial dcl 588 set ref 9474*
dim_cnt                         013643 automatic       fixed bin(17,0)          dcl 6235 set ref 6315* 6317 6319 6322
dim_conflicts                   002724 constant        bit(47)                  initial dcl 590 set ref 9474*
dim_idx                         013644 automatic       fixed bin(17,0)          dcl 6235 set ref 6322* 6324 6326 6332 6332 6334*
dim_node                        016511 automatic       fixed bin(18,0)          dcl 9452 set ref 9581* 9582 9587
dim_size                        014000 automatic       fixed bin(18,0)          dcl 6793 in procedure "get_constant_offset" set ref
                                                                                  6883 6902 6916*
dim_size                        014131 automatic       fixed bin(18,0)          dcl 7240 in procedure "parse_data" set ref 7341*
                                                                                  7359
dim_size                        016512 automatic       fixed bin(24,0)          dcl 9453 in procedure "get_bounds" set ref 9541*
                                                                                  9542 9546* 9548 9549
dimension                              based           structure                level 1 dcl 5-383 in procedure "ext_parse" set ref
                                                                                  8162 8162 9581 9581
dimension                12(25)        based           fixed bin(18,0)          level 2 in structure "symbol" packed packed unsigned
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 2882* 3642 5012 5076 5105 5116* 5221 5642 5646
                                                                                  5665 5704 5747 5942 6120 6138 6314 6823 7312 7332
                                                                                  7648 7650 8170* 8833 9587* 10388
dimension_node                         constant        fixed bin(4,0)           initial dcl 4-87 set ref 8162* 9581*
dimension_ptr                   013646 automatic       pointer                  dcl 6235 set ref 6314* 6315 6317 6324 6326 6332 6334
dimensioned              10(35)        based           bit(1)                   level 4 packed packed unaligned dcl 5-844 set ref
                                                                                  2936 3556 3633 5005 5044 5215 5633 5704 5742 5747
                                                                                  5941 6048 6119 6817 7311 8157* 8832 10202 10218
                                                                                  10375
direct_access                          constant        bit(2)                   initial dcl 15-8 ref 8785 8817 8906
direct_field                           constant        fixed bin(17,0)          initial dcl 15-50 set ref 4679*
dirname                  12            based           varying char(168)        level 2 dcl 14-6 ref 1155 1157 1177
displacement                    013323 automatic       fixed bin(24,0)          dcl 4818 set ref 5267* 5272* 5272* 5289 5315* 5315
                                                                                  5347* 5347
divide                                                 builtin function         dcl 594 ref 1155 1157 1874 1874 5065 5555 5593 5646
                                                                                  5747 5752 5820 6116 7646 8109 8160 8225 9954 9958
                                                                                  11900 11918
dname                           017005 automatic       char(256)                packed unaligned dcl 10821 set ref 11879* 11888*
                                                                                  11893* 11900 11907 11909
do_blockif_stack                004422 automatic       structure                array level 1 dcl 836 set ref 3123 3123 4759 4759
do_idx                          014046 automatic       fixed bin(17,0)          dcl 6961 set ref 6982* 6982* 6984 6984
do_index                        001157 automatic       fixed bin(18,0)          dcl 595 set ref 1281* 1403 1406 1416* 1509* 1509
                                                                                  1509 1509* 1535 3104* 3104 3104* 3105* 3108 3112
                                                                                  3119 3119 3123 3134* 3134 3135 3136 3137 3138 3139
                                                                                  3173* 3173 3173* 3174* 3177 3182 3188 3188 3189
                                                                                  3199 3199 3200* 3200 4759 4763* 4763 4764 4765
                                                                                  6608
do_info                         001160 automatic       fixed bin(18,0)          array dcl 596 set ref 3529 3530 3534* 3545 6982 6984
                                                                                  7286 7287 7293* 7800
do_level                        001170 automatic       fixed bin(18,0)          dcl 597 set ref 3506* 3529 3534 3544 3603* 3603
                                                                                  3777* 3777 6982 6984 7276* 7286 7292* 7292 7293
                                                                                  7645 7800 7816* 7816
do_loop                   4     004422 automatic       bit(1)                   array level 2 dcl 836 set ref 1404 1408 1509 1536
                                                                                  3104 3135* 3173 4764* 6609
do_op                                  constant        fixed bin(18,0)          initial dcl 4-197 set ref 4757* 9301*
do_rounding               0(28) 000132 automatic       bit(1)                   level 2 packed packed unaligned dcl 391 set ref 2505
                                                                                  6999 8357 9704 9773
do_statement                           constant        fixed bin(18,0)          initial dcl 598 ref 6658 6707 6723 11370
double_const                           constant        bit(9)                   initial dcl 4-156 ref 12452 13080 13198
double_precision         10(22)        based           bit(1)                   level 5 packed packed unaligned dcl 5-844 set ref
                                                                                  5206 5657 5757 5964
dp                              014002 automatic       pointer                  dcl 6794 in procedure "get_constant_offset" set ref
                                                                                  6823* 6830 6914 6915 6916
dp                              014132 automatic       pointer                  dcl 7241 in procedure "parse_data" set ref 7332*
                                                                                  7336 7339 7340 7341
dp                              001172 automatic       pointer                  dcl 599 in procedure "parse_source" set ref 3631*
                                                                                  3642* 3643 3659 3663 5076* 5080 5081 5081 5086
                                                                                  5086 5086 5086 8833* 8837 8841 8842 8842 8847 8850
                                                                                  8851 8857 8860 8860 8860 8860 8863 8870 8871 8871
                                                                                  8871 8871 8878 8888
dp                              016514 automatic       pointer                  dcl 9454 in procedure "get_bounds" set ref 9582*
                                                                                  9583 9584 9591 9592 9595
dp_mode                         003273 constant        fixed bin(4,0)           initial dcl 4-106 set ref 7698 7723 7738 8391 8400
                                                                                  10731 12754 12757* 13085 13097*
dt                              013564 automatic       fixed bin(18,0)          dcl 6095 set ref 6108* 6110 6110 6122
dtm                       2            based           fixed bin(71,0)          level 2 in structure "source" packed packed
                                                                                  unaligned dcl 5-693 in procedure "ext_parse" set
                                                                                  ref 1185* 11913*
dtm                             017106 automatic       fixed bin(71,0)          dcl 10822 in procedure "statement_lex" set ref
                                                                                  11879* 11896* 11913
dummy_arg                 0(31)        based           bit(1)                   level 3 packed packed unaligned dcl 5-844 set ref
                                                                                  2839* 5023
el_ct                           014134 automatic       fixed bin(18,0)          dcl 7242 set ref 7560* 7590* 7595* 7600* 7604* 7630*
                                                                                  7645 7742* 7746 7748 7749
ele_cnt                         016516 automatic       fixed bin(48,0)          dcl 9455 set ref 9468* 9548* 9548 9550 9550* 9595
                                                                                  9595
element_count             2            based           fixed bin(24,0)          level 2 dcl 5-383 set ref 6120 7312 7648 7650 8169*
                                                                                  8888 9595*
element_size             15(07)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-844 set ref
                                                                                  4874* 4874 4951* 4951 5065* 5133* 5223 5641* 5700*
                                                                                  5923 5948 6110* 6113* 6116* 6938* 8831
element_type                    016446 automatic       bit(36)                  dcl 9229 set ref 9245* 9249* 9313*
else_if_op                             constant        fixed bin(18,0)          initial dcl 4-197 set ref 3118*
else_op                                constant        fixed bin(18,0)          initial dcl 4-197 set ref 3187*
else_seen                 5     004422 automatic       bit(1)                   array level 2 dcl 836 set ref 3112 3139* 3182 3189*
else_statement                         constant        fixed bin(18,0)          initial dcl 603 ref 3181
elseif_statement                       constant        fixed bin(18,0)          initial dcl 602 ref 3016 3060 3099
embedded                        017552 automatic       bit(1)                   dcl 12548 set ref 12560* 12614* 12629
ename                           017110 automatic       char(256)                packed unaligned dcl 10823 set ref 11879* 11889*
                                                                                  11892* 11893 11900 11907 11909
encode_string_op                       constant        fixed bin(18,0)          initial dcl 4-197 set ref 8814*
encoded_format                         based           structure                level 1 dcl 8084
end_char                        001177 automatic       fixed bin(18,0)          dcl 604 set ref 1853* 1865* 1869 1874 1884 1887 1891
end_label                 0(01) 013240 automatic       bit(1)                   level 3 packed packed unaligned dcl 885 set ref 8574
                                                                                  8577 8580 8663 8665*
end_label_op                           constant        fixed bin(18,0)          initial dcl 4-197 ref 8667
end_line                               constant        fixed bin(18,0)          initial dcl 605 ref 1350 10915 11554
end_of_format                          constant        fixed bin(17,0)          initial dcl 13-78 ref 8118
end_of_line                     001200 automatic       fixed bin(18,0)          dcl 606 set ref 11064* 11124 11128 11227 11502 11535
                                                                                  11541 11542 11571 11578 11625 11630 11791* 11802
                                                                                  11804 11807 11807 11814 11819 11821 11826 11828
                                                                                  11831 11831 11835 11862 11931 11941 11990 11993
                                                                                  11995 11999* 12002 12002 12002 12002 12007 12010
                                                                                  12010 12012 12012 12012 12017 12029 12030 12039
                                                                                  12040 12044 12062 12064 12067 12067 12074 12074
                                                                                  12082 12100 12102 12102 12104 12109 12116 12127
                                                                                  12127 12132 12143 12159 12215 12218 12225 12227
                                                                                  12231 12232 12239 12241 12264 12350 12354 12390
                                                                                  12394 12564 12582 12605
end_of_polish             0(30) 013232 automatic       fixed bin(18,0)          level 2 packed packed unaligned dcl 883 set ref
                                                                                  2504* 7001* 8356* 9703* 9772*
end_possible                    001201 automatic       bit(1)                   dcl 607 set ref 10923* 11448* 11498* 11550 12018*
                                                                                  12046* 12117* 12133*
end_text                        017210 automatic       fixed bin(20,0)          dcl 10824 set ref 10909* 10975 10975 11441* 11739*
end_zero                        017211 automatic       fixed bin(18,0)          dcl 10825 set ref 10887* 11328 11328 11328 11363*
                                                                                  11363
endfile_op                             constant        fixed bin(18,0)          initial dcl 4-197 ref 3865
endfile_opr                            constant        fixed bin(4,0)           initial dcl 15-19 ref 3867
ends_do_loop              0(35)        based           bit(1)                   level 3 packed packed unaligned dcl 5-530 set ref
                                                                                  6658* 6689 6709 6726 6727* 6733
endunit_op                             constant        fixed bin(18,0)          initial dcl 4-197 set ref 1558*
entry_point              10(30)        based           bit(1)                   level 4 packed packed unaligned dcl 5-844 set ref
                                                                                  4943 5161 10356
entry_point_conflicts           002722 constant        bit(47)                  initial dcl 608 ref 1798
entry_point_name                       parameter       fixed bin(18,0)          dcl 7045 ref 7031 7049
entry_stmnt               1     003613 automatic       bit                      array level 2 dcl 754 set ref 6188* 6191* 6192 6193
                                                                                  6194 6195 6279 6389 6400 7169*
entry_symbol                    013650 automatic       fixed bin(18,0)          dcl 6235 in procedure "process_pending_entries" set
                                                                                  ref 6261* 6285* 6299
entry_symbol                    003613 automatic       fixed bin(18,0)          array level 2 in structure "pending_entry" dcl 754
                                                                                  in procedure "parse_source" set ref 6187* 6261
                                                                                  7168*
entry_symbol_ptr                013652 automatic       pointer                  dcl 6235 set ref 6299* 6300 6303
entry_value                     002720 constant        bit(47)                  initial dcl 610 ref 10404
entry_value_conflicts           002716 constant        bit(47)                  initial dcl 612 ref 10404
eol_op                                 constant        fixed bin(18,0)          initial dcl 4-197 set ref 1542* 3195* 3374* 3387*
                                                                                  4254* 4464* 4562* 4705* 6381* 9422* 10598*
ep_name                         014074 automatic       fixed bin(18,0)          dcl 7046 set ref 7049* 7051* 7051 7054* 7161 7168
                                                                                  7181 7189
equiv_chain               2(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-753
                                                                                  set ref 5443 5443* 5446 5515 5587 5598* 5617 5815
                                                                                  5825* 5887 5957 5958*
equiv_conflicts                 002714 constant        bit(47)                  initial dcl 615 set ref 5916 7406*
equiv_error                     013324 automatic       bit(1)                   dcl 4819 set ref 5265* 5266 5279* 5280 5284 5971*
equiv_hdri                      013325 automatic       fixed bin(18,0)          dcl 4820 set ref 5515* 5515* 5517* 5587* 5588 5589
                                                                                  5603 5617* 5619* 5815* 5816 5817 5858 5858 5866
                                                                                  5868 5887* 5889*
equiv_hdrp                      013326 automatic       pointer                  dcl 4821 set ref 5517* 5518 5518 5521 5530 5532 5537
                                                                                  5537 5537 5537 5540 5589* 5590 5590 5590 5593 5593
                                                                                  5593 5598 5600 5602 5604 5605 5611 5615 5817* 5818
                                                                                  5818 5820 5820 5820 5823 5825 5827 5835 5837 5841
                                                                                  5843 5846 5848 5857 5870 5871 5872 5873 5874 5881
                                                                                  5885
equivalence_statement                  constant        fixed bin(18,0)          initial dcl 614 ref 6813
equivalenced             11(03)        based           bit(1)                   level 4 packed packed unaligned dcl 5-844 set ref
                                                                                  2114* 5001 5023 5044 5932 5968* 6549 7438 7788
                                                                                  10647
err_code                               parameter       fixed bin(35,0)          dcl 9649 in procedure "get_one_bound" set ref 9631
                                                                                  9668* 9669 9673* 9677* 9683 9706* 9709
err_code                               parameter       fixed bin(35,0)          dcl 9727 in procedure "get_integer_constant" set ref
                                                                                  9721 9738* 9758* 9775* 9778 9784* 9792*
error                           000100 stack reference condition                dcl 7876 in procedure "value" ref 7888
error                           001202 automatic       bit(1)                   packed unaligned dcl 617 in procedure "parse_source"
                                                                                  set ref 3622* 3635* 3639* 3651* 3661* 3665* 3675*
                                                                                  3686* 3693* 3708* 3717* 3721* 3735* 3745* 3749*
                                                                                  3756
error_code                      001203 automatic       fixed bin(35,0)          dcl 618 in procedure "parse_source" set ref 2507*
                                                                                  2510 8359* 8363
error_code                      016520 automatic       fixed bin(35,0)          dcl 9456 in procedure "get_bounds" set ref 9492*
                                                                                  9494 9520* 9521
error_code                      014004 automatic       fixed bin(35,0)          dcl 6795 in procedure "get_constant_offset" set ref
                                                                                  6850* 6851
error_label                     013240 automatic       bit(1)                   level 3 packed packed unaligned dcl 885 set ref 8654
                                                                                  8656*
error_label_op                         constant        fixed bin(18,0)          initial dcl 4-197 ref 8658
error_message             1            based           char(128)                level 2 dcl 13-71 set ref 8096*
error_table_$no_s_permission    000046 external static fixed bin(35,0)          dcl 10864 ref 11882
error_table_$noentry            000044 external static fixed bin(35,0)          dcl 10863 ref 11842
even                      0(30)        based           bit(1)                   level 4 packed packed unaligned dcl 5-436 set ref
                                                                                  5657* 5796* 5823 5835 5964* 6218*
executable_label                003027 constant        bit(2)                   initial dcl 619 set ref 1367 1374 1397 1426 2908
                                                                                  3026* 3026* 3226* 3226* 4734* 6272* 6657 6689 6705
                                                                                  8678* 9410* 13046*
exist_field                            constant        fixed bin(17,0)          initial dcl 15-50 set ref 4652*
exit_lbl                        016340 automatic       fixed bin(18,0)          dcl 8651 set ref 8678* 8679 8681*
exit_op                                constant        fixed bin(18,0)          initial dcl 4-197 set ref 1503* 1513* 1537* 2880*
                                                                                  3271* 3390* 9327*
exp                             020011 automatic       fixed bin(18,0)          dcl 12772 in procedure "convert_real_constant" set
                                                                                  ref 12811* 12826 12828 12829* 12829 12833 12839
                                                                                  12840* 12843* 12843 12848 12850 12853
exp                             017212 automatic       fixed bin(18,0)          dcl 10826 in procedure "statement_lex" set ref
                                                                                  12446* 12470* 12477* 12477 12484* 12520 12530*
exp_idx                         000122 automatic       fixed bin(18,0)          dcl 7880 set ref 7892* 7893*
expnt                     7(27) 020022 automatic       fixed bin(8,0)           level 2 packed packed unaligned dcl 12785 set ref
                                                                                  12853* 12857 12857 12859 12859 12868 12868 12870
                                                                                  12870
expon                                  constant        bit(9)                   initial dcl 4-156 ref 11318 11421
expon_op                               constant        fixed bin(18,0)          initial dcl 10048 ref 10554 10554
exponent                  0(18) 011016 automatic       fixed bin(8,0)           array level 2 packed packed unaligned dcl 853 set
                                                                                  ref 12520* 12811
expr                            016671 automatic       bit(36)                  dcl 10047 set ref 10093* 10125 10133 10156 10162
                                                                                  10170 10173 10181 10185 10185 10202 10220 10229
                                                                                  10231 10244 10246 10255 10258 10275 10277 10293
                                                                                  10307* 10382 10384 10384 10388 10396 10402 10441
                                                                                  10496 10508 10510 10510 10522 10558 10571 10580
                                                                                  10584 10584 10593* 10623* 10628 10646 10647
expression                             based           structure                level 1 dcl 1034
expression_idx                         parameter       fixed bin(18,0)          dcl 7874 ref 7863 7884 7892 7892 7892
expression_size                 013654 automatic       fixed bin(17,0)          dcl 6235 in procedure "process_pending_entries" set
                                                                                  ref 6344* 6346 6350
expression_size                 013536 automatic       fixed bin(17,0)          dcl 6015 in procedure "validate_array_bound" set ref
                                                                                  6026* 6027
expression_start                013655 automatic       fixed bin(18,0)          dcl 6235 in procedure "process_pending_entries" set
                                                                                  ref 6343* 6344 6350 6350
expression_start                013537 automatic       fixed bin(18,0)          dcl 6015 in procedure "validate_array_bound" set ref
                                                                                  6025* 6026 6027 6027
expression_type                        parameter       bit(36)                  dcl 9346 set ref 9342 9366*
ext_attributes                  002712 constant        bit(47)                  initial dcl 620 in procedure "parse_source" set ref
                                                                                  2320*
ext_attributes            4            based           structure                level 2 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse"
ext_conflicts                   002710 constant        bit(47)                  initial dcl 622 set ref 2320*
ext_float_dec                   020022 automatic       structure                level 1 dcl 12785 set ref 12813 12845 12857 12859
                                                                                  12862 12862 12868 12870 12873 12873
external                 10(31)        based           bit(1)                   level 4 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 5058 9934 9982* 10227 10393 10399
external                  2     000251 constant        bit(1)                   initial array level 2 in structure "bif_table"
                                                                                  packed packed unaligned dcl 9873 in procedure
                                                                                  "builtin_lookup" ref 9982
extra_blanks                    017213 automatic       fixed bin(18,0)          dcl 10827 set ref 11063* 11496 12017* 12044* 12584
fast_bits                       016262 automatic       bit(36)                  dcl 8209 set ref 8234* 8238* 8238 8241
fast_lookup                            defined         char(24)                 packed unaligned dcl 624 set ref 1823 1823 1823*
                                                                                  1827 4135 4208 4234 7972 8631 8634 11004* 11010
                                                                                  11014 11022 11027 11039 12421* 12423
field_no                               parameter       fixed bin(17,0)          dcl 9345 ref 9342 9354
field_number                    016462 automatic       fixed bin(18,0)          dcl 9347 set ref 9354* 9356 9359 9368
fields_specified                001204 automatic       bit(72)                  dcl 625 set ref 3881* 3927 3985* 4370* 4460 4470*
                                                                                  4506* 4558 4568* 4603* 4698 4698 4700 4700 4710*
                                                                                  8441* 8487* 8549* 8571 8574 8583 8726 8729* 8778
                                                                                  8782* 8940 8942* 9356 9359*
file                      2            based           fixed bin(8,0)           level 3 packed packed unsigned unaligned dcl 5-721
                                                                                  set ref 1151* 11777* 11865 11921*
file_list               117            based           structure                array level 3 dcl 398
file_number                     001206 automatic       fixed bin(8,0)           initial dcl 626 in procedure "parse_source" set ref
                                                                                  626* 11776* 11777 11794 11920* 11921 12145
file_number                            based           fixed bin(8,0)           array level 2 in structure "source_list" packed
                                                                                  packed unaligned dcl 6-31 in procedure "ext_parse"
                                                                                  set ref 11794*
file_number_pic                 001207 automatic       picture(4)               packed unaligned dcl 627 set ref 12145* 12146*
file_stack                      012002 automatic       structure                array level 1 dcl 859 set ref 11854 11868
file_stack_depth                001210 automatic       fixed bin(17,0)          dcl 628 set ref 1114* 11764 11770* 11770 11771 11772
                                                                                  11773 11774 11775 11776 11854 11860 11861 11862
                                                                                  11863 11864 11865 11868 11876* 11876
file_string_index               017275 automatic       fixed bin(17,0)          dcl 11718 set ref 11819* 11820
file_string_length              017276 automatic       fixed bin(17,0)          dcl 11719 set ref 11826* 11828 11828* 11830 11831
                                                                                  11831 11835
filename_field                         constant        fixed bin(17,0)          initial dcl 15-50 set ref 4419* 4634* 4698 4700
final_expression_idx            014135 automatic       fixed bin(18,0)          dcl 7243 set ref 7298* 7299 7299 7802* 7803 7803
                                                                                  7811*
final_value                     014136 automatic       fixed bin(18,0)          dcl 7244 set ref 7811* 7812 7812
find_include_file_$initiate_count
                                000034 constant        entry                    external dcl 10858 ref 11837
first_constant          100            based           fixed bin(18,0)          array level 3 dcl 398 set ref 8-89 8-89*
first_cref                4            based           fixed bin(18,0)          level 2 unsigned dcl 6-12 set ref 1241*
first_element             3(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-436
                                                                                  set ref 2035* 5177 5186 5189 5357 5404 5425 5430
                                                                                  5494 5521 5537 5537 5567 5605 5667* 5687 5702
                                                                                  5800* 5841 5848 5874 5959*
first_entry_name         75            based           fixed bin(18,0)          level 2 dcl 398 set ref 4976 4976* 13226
first_keyword             0(18) 000000 constant        fixed bin(18,0)          initial array level 2 packed packed unsigned
                                                                                  unaligned dcl 892 ref 1354 1354 2914
first_label               4            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-753
                                                                                  set ref 4882 6770*
first_line                2            based           fixed bin(18,0)          level 2 unsigned dcl 6-12 set ref 1242*
first_mode_keyword                     constant        fixed bin(18,0)          initial dcl 629 ref 1293 1302 1326 1827 1833 1834
                                                                                  2233
first_polish              5            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-753
                                                                                  set ref 1221*
first_segment            51            based           fixed bin(17,0)          level 2 dcl 398 set ref 1104* 1169*
first_subprogram         72            based           fixed bin(18,0)          level 2 dcl 398 set ref 1212* 6167
first_sym                       016350 automatic       fixed bin(18,0)          dcl 8689 in procedure "parse_iostat_var" set ref
                                                                                  8699* 8700*
first_sym                       016463 automatic       fixed bin(18,0)          dcl 9348 in procedure "parse_open_field" set ref
                                                                                  9365* 9366*
first_symbol              3            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-753
                                                                                  set ref 4925 4927* 5148* 5630 5740 8272* 9828*
first_time                      001211 automatic       bit(1)                   dcl 630 set ref 2559* 2563 2565*
first_token                     001212 automatic       fixed bin(18,0)          dcl 631 set ref 1293 1293 1297 1297 1303 1309 1309
                                                                                  1309 1309 1309 1309 1328 1330 1330 1331 1331 1332
                                                                                  1332 1333 1333 1334 1334 1437 2904 10874* 10879
                                                                                  10970 11180 13148 13148* 13148 13170 13170* 13170
first_word                      001213 automatic       fixed bin(18,0)          dcl 632 set ref 2241* 2284 2284 2284 3497* 3804 3804
                                                                                  3804 8039 8042* 8149* 8188 8188 8188
fixed                                                  builtin function         dcl 633 ref 6349 6349 6716 6716 7986 10903 10904
fixedoverflow                   000106 stack reference condition                dcl 7876 ref 7889
fmt                             016320 automatic       fixed bin(18,0)          dcl 8484 in procedure "parse_io" set ref 8520* 8521*
                                                                                  8553* 8554*
fmt                                    parameter       fixed bin(18,0)          dcl 8926 in procedure "get_format" ref 8914 8955
                                                                                  9017 9024
fmt                       1            based           fixed bin(17,0)          array level 2 in structure "old_format" packed
                                                                                  packed unaligned dcl 13-49 in procedure
                                                                                  "parse_source" set ref 8109 8118 8122 8132 8134*
                                                                                  8141
fmt                             016330 automatic       fixed bin(18,0)          dcl 8610 in procedure "parse_io_options" set ref
                                                                                  8623* 8624*
fmt_field                              constant        fixed bin(17,0)          initial dcl 15-50 ref 8549 8583 8940 8942
fmt_len                   0(24)        based           fixed bin(12,0)          level 3 in structure "encoded_format" packed packed
                                                                                  unsigned unaligned dcl 8084 in procedure
                                                                                  "create_format" ref 8105
fmt_len                   0(24)        based           fixed bin(12,0)          level 3 in structure "old_format" packed packed
                                                                                  unsigned unaligned dcl 13-49 in procedure
                                                                                  "parse_source" set ref 8143*
fmt_length                      014244 automatic       fixed bin(18,0)          dcl 8073 set ref 8105* 8109 8125 8132 8134 8137*
                                                                                  8137 8143 8155 8160 8172 8172 8183 8184 8184 8184
                                                                                  8184
fmt_parse_ver1                         constant        bit(6)                   initial dcl 13-97 ref 8115
fmt_ptr                         014246 automatic       pointer                  dcl 8074 set ref 8152* 8153 8157 8158 8170 8183
fmt_str                                parameter       char                     packed unaligned dcl 8075 ref 8058 8086 8092 8109
fmt_word                               based           char(4)                  array packed unaligned dcl 8076 set ref 8179* 8179*
fold                      0(20) 013240 automatic       bit(1)                   level 3 in structure "io_bits" packed packed
                                                                                  unaligned dcl 885 in procedure "parse_source" set
                                                                                  ref 3884* 3980* 4365* 4501* 4598* 8443* 8489*
fold                      0(04) 000132 automatic       bit(1)                   level 3 in structure "subr_options" packed packed
                                                                                  unaligned dcl 391 in procedure "ext_parse" set ref
                                                                                  3884 3980 4365 4501 4598 8443 8489 11977
fold_option                     001214 automatic       bit(1)                   dcl 634 set ref 11120 11158 11263 11977*
following_token                 001340 constant        bit(9)                   initial array dcl 10660 ref 10687
force_symtab_entry                     constant        fixed bin(2,0)           initial dcl 635 set ref 1642* 1705* 1754* 1918*
                                                                                  1950* 1973* 1979* 2064* 2106* 2249* 2301* 2362*
                                                                                  2398* 2427* 2457* 2479* 2493* 2563* 2666* 2737*
                                                                                  2778* 2816* 2819* 2859* 2931* 2938* 2939* 2944*
                                                                                  2949* 2952* 2961* 3006* 3221* 3267* 3268* 3295*
                                                                                  3337* 3516* 3540* 3832* 3890* 3990* 4048* 4142*
                                                                                  4194* 4211* 4241* 4272* 4291* 4296* 4315* 4321*
                                                                                  4326* 4735* 4737* 4744* 4749* 4752* 6838* 6935
                                                                                  6970* 7078* 8264 8332* 8452* 8520* 8525* 8540*
                                                                                  8553* 8623* 8699* 8731* 8737* 9271* 9278* 9285*
                                                                                  9290* 9293* 9365* 9487* 9515* 10148* 10316* 10330*
                                                                                  10530* 10530* 10567* 13000*
form_field                             constant        fixed bin(17,0)          initial dcl 15-50 set ref 4428* 4643*
formal_parameter                       parameter       fixed bin(18,0)          dcl 7179 set ref 7176 7181 7181 7181 7181 7185* 7188
                                                                                  7189
format                    0(03) 013240 automatic       bit(2)                   level 3 packed packed unaligned dcl 885 set ref 4005
                                                                                  8548* 8583* 8587 8589 8612* 8618* 8990* 9031*
                                                                                  9047* 9255
format_desc_bits          0(18)        based           structure                level 3 in structure "runtime_format" packed packed
                                                                                  unaligned dcl 13-32 in procedure "parse_source"
format_desc_bits          0(18)        based           structure                level 3 in structure "encoded_format" packed packed
                                                                                  unaligned dcl 8084 in procedure "create_format"
format_error                           based           structure                level 1 dcl 13-71
format_label                           constant        bit(2)                   initial dcl 636 set ref 4891 6649 6739 8946*
format_label_attributes         002706 constant        bit(47)                  initial dcl 637 set ref 6653* 6743* 9023*
format_op                              constant        fixed bin(18,0)          initial dcl 4-197 set ref 9046*
format_reference                       constant        bit(36)                  initial dcl 1071 set ref 9000* 9018*
format_string             1(18)        based           char                     level 2 in structure "format_structure" packed
                                                                                  packed unaligned dcl 871 in procedure
                                                                                  "parse_source" set ref 3439*
format_string                          based           char                     packed unaligned dcl 8077 in procedure
                                                                                  "create_format" set ref 8184* 8184*
format_structure                       based           structure                level 1 dcl 871
format_var                4            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-530
                                                                                  set ref 4892 6654* 6740 6744*
formatted                              constant        bit(2)                   initial dcl 15-8 ref 9047
formatted_field                        constant        fixed bin(17,0)          initial dcl 15-50 set ref 4670*
fort_defaults_$check_global_args
                                000020 constant        entry                    external dcl 640 ref 11945 11964
fort_defaults_$global           000016 constant        entry                    external dcl 639 ref 12175
fort_defaults_$init_shared_vars 000022 constant        entry                    external dcl 641 ref 11955 11974
fort_defaults_$option           000024 constant        entry                    external dcl 642 ref 12195
fort_defaults_$set              000026 constant        entry                    external dcl 643 ref 11950 11969
fort_eval_parm                  000030 constant        entry                    external dcl 645 ref 2507 7004 8359 9706 9775
fortran_declared                       based           structure                level 1 dcl 3-91
fortran_options                        based           structure                level 1 dcl 3-40
free_chain                      001215 automatic       fixed bin(18,0)          dcl 646 set ref 1112* 7762 7764* 7771 7773* 8030
                                                                                  8031 8032*
from_data_parser                001216 automatic       bit(1)                   dcl 647 set ref 1110* 7273* 7833* 13078
from_encode_decode                     parameter       bit(1)                   dcl 8792 ref 8789 8809
fs_end_of_line            4     012002 automatic       fixed bin(21,0)          array level 2 dcl 859 set ref 11773 11862*
fs_file_number            7     012002 automatic       fixed bin(8,0)           array level 2 dcl 859 set ref 11776 11865*
fs_line_number            6     012002 automatic       fixed bin(18,0)          array level 2 dcl 859 set ref 11775 11864*
fs_seg_ptr                      012002 automatic       pointer                  array level 2 dcl 859 set ref 11771 11860*
fs_source_length          5     012002 automatic       fixed bin(21,0)          array level 2 dcl 859 set ref 11774 11863*
fs_source_ptr             2     012002 automatic       pointer                  array level 2 dcl 859 set ref 11772 11861* 11869
ft_double_dtype                        constant        fixed bin(17,0)          initial dcl 7-96 ref 12873
ft_hex_double_dtype                    constant        fixed bin(17,0)          initial dcl 7-96 ref 12862
full_name                       001217 automatic       char(256)                packed unaligned dcl 648 set ref 1771 1771 1823 1823
                                                                                  1823 1823 1823 1823 1827 1827 1853 1865 1965 2330
                                                                                  2674 2820 2820 3060 3094 3903 3905 3907 4135 4135
                                                                                  4208 4208 4234 4234 4404 4407 4410 4413 4416 4419
                                                                                  4422 4425 4428 4431 4434 4437 4440 4443 4446 4449
                                                                                  4538 4541 4544 4547 4628 4631 4634 4637 4640 4643
                                                                                  4646 4649 4652 4655 4658 4661 4664 4667 4670 4673
                                                                                  4676 4679 7972 7972 7980 7982 7982 8219 8230 8230
                                                                                  8234 8238 8251 8269 8510 8512 8514 8516 8518 8523
                                                                                  8631 8631 8634 8634 9356 9356 10698* 11004* 11004
                                                                                  11010 11010 11014 11014 11022 11022 11027 11027
                                                                                  11039 11039 12421 12421 12423 12423 12917* 12998*
                                                                                  13002 13002
func_conflicts                  002704 constant        bit(47)                  initial dcl 649 ref 10266
func_op                                constant        fixed bin(18,0)          initial dcl 4-197 ref 1796 4054 4862 4947 6486 7122
func_ref_attribute              002702 constant        bit(47)                  initial dcl 651 ref 10267
func_ref_op                            constant        fixed bin(18,0)          initial dcl 4-197 ref 10239 10285
function                               constant        fixed bin(9,0)           initial dcl 4-68 in procedure "ext_parse" ref 1791
                                                                                  5122
function                 10(28)        based           bit(1)                   level 4 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 4964 4993 5061 5122 10227 10356
function_attribute              002700 constant        bit(47)                  initial dcl 653 ref 1797
function_statement                     constant        fixed bin(18,0)          initial dcl 655 ref 1302 1326 1742 1746 1748 1760
                                                                                  7117
gap_value                              constant        fixed bin(17,0)          initial dcl 4-57 set ref 7451 7472 7578 7630* 7846
general                   6(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-844
                                                                                  set ref 2835* 2878 4960 5158* 5161* 6300 6303
                                                                                  7161* 7181 7189*
general_format_parse_           000032 constant        entry                    external dcl 656 ref 8094
get_next_source_seg       6            based           entry variable           level 2 dcl 395 ref 1595
group_align                     013330 automatic       bit(2)                   dcl 4822 set ref 5393* 5394 5394* 5394 5396* 5396
                                                                                  5397 5460
group_class                     013331 automatic       bit(4)                   dcl 4823 set ref 5293* 5294 5404 5407 5433 5461
group_length                    013332 automatic       fixed bin(24,0)          dcl 4824 set ref 5820* 5823 5823 5837 5847 5873
has_dim_sizes             0(25)        based           bit(1)                   level 2 packed packed unaligned dcl 5-383 set ref
                                                                                  8167*
has_line_numbers        113(03)        based           bit(1)                   level 5 packed packed unaligned dcl 398 set ref 1124
has_parameters            0(15)        based           bit(1)                   level 2 packed packed unaligned dcl 5-753 set ref
                                                                                  7071*
hash_chain                3(18)        based           fixed bin(18,0)          level 2 in structure "node" packed packed unsigned
                                                                                  unaligned dcl 5-63 in procedure "ext_parse" set
                                                                                  ref 8-69 8-78*
hash_chain                3(18)        based           fixed bin(18,0)          level 2 in structure "label" packed packed unsigned
                                                                                  unaligned dcl 5-530 in procedure "ext_parse" set
                                                                                  ref 6631 6643*
hash_chain                3(18)        based           fixed bin(18,0)          level 2 in structure "symbol" packed packed unsigned
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 2822* 2824* 2872* 2872 2874 8258 8280*
hash_index                      000123 automatic       fixed bin(17,0)          dcl 8-24 set ref 8-57* 8-61 8-76 8-76
hash_table                             based           fixed bin(35,0)          array dcl 8-25 in procedure "create_constant" set
                                                                                  ref 8-61 8-76 8-76*
hash_table                      001317 automatic       fixed bin(18,0)          array dcl 657 in procedure "parse_source" set ref
                                                                                  1248* 2824 2826* 2872 2874* 8241 8244 8278 8278*
hash_table_size                 076435 constant        fixed bin(17,0)          initial dcl 8-26 ref 8-57
have_auto_option                001642 automatic       bit(1)                   dcl 658 set ref 1563 11070* 12195*
have_auto_stmnt                 001643 automatic       bit(1)                   dcl 659 set ref 1253* 1562 2633 2731*
have_constant_subscripts        014137 automatic       bit(1)                   dcl 7245 set ref 7319* 7327* 7330* 7343* 7393* 7645
have_operand                    016672 automatic       bit(1)                   dcl 10049 set ref 10099* 10105 10334* 10445* 10478*
                                                                                  10494* 10578* 10625 10626*
have_save_stmnt                 001644 automatic       bit(1)                   dcl 660 set ref 1254* 1562 2642 2647* 2660* 2725
have_static_option              001645 automatic       bit(1)                   dcl 661 set ref 1563 1563 11070* 12195*
have_subscript                  001646 automatic       bit(1)                   packed unaligned dcl 662 set ref 3646* 3647 3668*
hbound                                                 builtin function         dcl 663 in procedure "parse_source" ref 2824 2872
                                                                                  3123 3123 3529 3530 4759 4759 6641 7166 7171 7171
                                                                                  7286 7287 8278 9138 9140 9482 9806 9806 9945 10957
                                                                                  10958 11109 11281 11282 11854 12265 12318 12423
                                                                                  12426 12509 12511 12511
hbound                                                 builtin function         dcl 8-27 in procedure "create_constant" ref 8-43
hcs_$terminate_noname           000036 constant        entry                    external dcl 10859 ref 11849 11855 11870
hdr                                    parameter       fixed bin(18,0)          dcl 5901 set ref 5898 5933* 5934 5952* 5953 5958
                                                                                  5967
hdr_ptr                                parameter       pointer                  dcl 5902 set ref 5898 5934* 5937 5953* 5955 5956
                                                                                  5957 5959 5959 5960 5961 5964
header                                 based           structure                level 1 dcl 5-436 set ref 5455 5652 5652 5788 5788
                                                                                  5858 5952 5952 6214 6214
header_node                     003265 constant        fixed bin(4,0)           initial dcl 4-87 set ref 5652* 5788* 5952* 6214*
header_ptr                      013620 automatic       pointer                  dcl 6211 set ref 6215* 6217 6218 6219 6220
header_storage                         defined         bit(5)                   packed unaligned dcl 6534 in procedure
                                                                                  "declare_symbol" set ref 6549* 6549
header_storage                         defined         bit(5)                   packed unaligned dcl 10050 in procedure
                                                                                  "parse_expression" set ref 10647* 10647
header_storage                         defined         bit(5)                   packed unaligned dcl 6043 in procedure "validate"
                                                                                  set ref 6056* 6056
header_word                            based           structure                level 2 in structure "runtime_format" packed packed
                                                                                  unaligned dcl 13-32 in procedure "parse_source"
header_word                            based           structure                level 2 in structure "old_format" packed packed
                                                                                  unaligned dcl 13-49 in procedure "parse_source"
header_word                            based           structure                level 2 in structure "encoded_format" packed packed
                                                                                  unaligned dcl 8084 in procedure "create_format"
hfp                       1(04) 000132 automatic       bit(1)                   level 2 in structure "subr_options" packed packed
                                                                                  unaligned dcl 391 in procedure "ext_parse" set ref
                                                                                  3886 3982 4367 4503 4600 8445 8491
hfp                     114(04)        based           bit(1)                   level 4 in structure "shared_structure" packed
                                                                                  packed unaligned dcl 398 in procedure "ext_parse"
                                                                                  set ref 12856
hfp                       0(22) 013240 automatic       bit(1)                   level 3 in structure "io_bits" packed packed
                                                                                  unaligned dcl 885 in procedure "parse_source" set
                                                                                  ref 3886* 3982* 4367* 4503* 4600* 8445* 8491*
hollerith_field                        constant        fixed bin(17,0)          initial dcl 13-78 ref 8121
i                               014250 automatic       fixed bin(18,0)          dcl 8078 in procedure "create_format" set ref 8117*
                                                                                  8118 8122 8132 8134 8140* 8140 8141 8160* 8165
                                                                                  8166 8169 8172 8172 8172 8172 8178
i                               014217 automatic       fixed bin(17,0)          dcl 7947 in procedure "parse_a_constant" set ref
                                                                                  7979* 7980 7982 7982 7986*
i                               001647 automatic       fixed bin(18,0)          dcl 664 in procedure "parse_source" set ref 1155*
                                                                                  1157* 1162 1258* 1259 1260* 1262* 1263 1264* 1266*
                                                                                  1267 1268* 1535* 1536 1538 1543 1543* 1827* 1827*
                                                                                  1830 1833 1834 1891* 1892* 2862* 2862* 2863 2866
                                                                                  2867* 2870 2872 2874 2877* 2878 2940* 3023* 3042*
                                                                                  3383* 3384* 3544* 3545* 7151* 7152 7152* 8841*
                                                                                  8842 8842 8847 8850 8851 8857 8860 8860 8860 8860
                                                                                  8863 8870 8871 8871 8871 8871 8878* 9590* 9591
                                                                                  9591 9592 9592 9592 9592*
i                               017520 automatic       fixed bin(18,0)          dcl 12380 in procedure "build_fortran_operator" set
                                                                                  ref 12390* 12391 12394 12394* 12396* 12423* 12423*
                                                                                  12426 12431
i                               017510 automatic       fixed bin(18,0)          dcl 12342 in procedure "get_digits" set ref 12350*
                                                                                  12351 12354 12354* 12356* 12357
i                               017452 automatic       fixed bin(18,0)          dcl 12208 in procedure "get_next_option" set ref
                                                                                  12215* 12216 12223 12231* 12232 12232* 12235 12239
                                                                                  12239* 12239 12241 12242
i                               016747 automatic       fixed bin(18,0)          dcl 10662 in procedure "is_complex_constant" set ref
                                                                                  10678* 10681 10684 10687 10690 10709* 10717* 10719
                                                                                  10720 10731 10737 10741 10745 10745*
i                               017767 automatic       fixed bin(18,0)          dcl 12695 in procedure "convert_integer_constant"
                                                                                  set ref 12705* 12707 12714 12714 12714
i                               017246 automatic       fixed bin(18,0)          dcl 11485 in procedure "get_continuation_line" set
                                                                                  ref 11571* 11573 11575 11577 11584
i                               013656 automatic       fixed bin(17,0)          dcl 6235 in procedure "process_pending_entries" set
                                                                                  ref 6323* 6324*
i                               017277 automatic       fixed bin(18,0)          dcl 11720 in procedure "get_line_image" set ref
                                                                                  11900* 11902 12040* 12041 12045 12062* 12064
                                                                                  12064* 12067 12072 12074 12074 12076 12078* 12082
                                                                                  12082 12082 12084 12104* 12105 12108
i                               014140 automatic       fixed bin(18,0)          dcl 7246 in procedure "parse_data" set ref 7336*
                                                                                  7339 7340 7341*
i                               013333 automatic       fixed bin(18,0)          dcl 4825 in procedure "declaration_processor" set
                                                                                  ref 4966* 4967 4967* 5080* 5081 5081 5086 5086
                                                                                  5086* 5174* 5174* 5175 5186* 5195* 5201* 5208*
                                                                                  5229* 5234* 5246* 5247 5251 5252* 5252 5256 5266
                                                                                  5275 5280 5466* 5466 5907 5909* 5909 5919* 5919
                                                                                  5923 5923 5924* 5924 5995
i                               016656 automatic       fixed bin(18,0)          dcl 9864 in procedure "builtin_lookup" set ref 9943*
                                                                                  9949 9952 9953 9954* 9954 9957 9958* 9958 9960
                                                                                  9965 9980 9982
i                               017214 automatic       fixed bin(18,0)          dcl 10828 in procedure "statement_lex" set ref
                                                                                  11124* 11125 11128 11128* 11130* 11227* 11228
                                                                                  11243* 11247*
ident                                  constant        bit(9)                   initial dcl 4-156 ref 1297 1309 1643 1673 1706 1755
                                                                                  1820 1848 1860 1919 1963 2024 2107 2250 2302 2330
                                                                                  2363 2399 2428 2480 2567 2672 2698 2738 2779 2811
                                                                                  3231 3296 3541 3612 3901 3991 4049 4130 4201 4218
                                                                                  4401 4535 4625 4775 7082 7972 8508 8628 8752 8954
                                                                                  10179 10693 10999 11118 11328 12913 12994 13191
idx_of_count                    013657 automatic       fixed bin(18,0)          dcl 6235 set ref 6286* 6367
idx_of_expression               016610 automatic       fixed bin(18,0)          dcl 9657 set ref 9665* 9669 9685 9689 9690 9696 9696
                                                                                  9702 9714
idx_of_increment_polish_op      016611 automatic       fixed bin(18,0)          dcl 9657 set ref 9663* 9683 9690 9694 9711 9715
ignore_bits                     001650 automatic       bit(36)                  dcl 665 set ref 2495* 2860* 2941* 2946* 2953* 2957*
                                                                                  2962* 3007* 3270* 3345* 3840* 3932* 4144* 4196*
                                                                                  4213* 4242* 4273* 4292* 4297* 4317* 4323* 4328*
                                                                                  4740* 4745* 4750* 4753* 8351* 8700* 8760* 8784*
                                                                                  9286* 9291* 9294* 9366*
ignore_octal_value              001652 automatic       bit(72)                  dcl 666 set ref 2582*
ignore_symtab_entry                    constant        fixed bin(2,0)           initial dcl 667 set ref 1665* 1819* 1847* 1859*
                                                                                  1960* 2139* 2154* 2175* 2328* 2579* 2604* 2671*
                                                                                  3011* 3046* 3895* 4124* 4129* 4200* 4217* 4390*
                                                                                  4525* 4621* 4730* 4771* 7524* 7831* 8505* 8627*
                                                                                  8674* 8683* 9406* 9566* 12920
ignore_value                    001654 automatic       fixed bin(18,0)          dcl 668 set ref 1665* 1819* 1847* 1859* 1960* 2328*
                                                                                  2671* 3011* 3034* 3046* 3895* 4124* 4129* 4200*
                                                                                  4217* 4390* 4525* 4621* 4730* 4771* 7524* 7831*
                                                                                  8184* 8505* 8627* 8674* 8683* 9406* 9566* 10700*
                                                                                  11430* 12493* 12923* 13000*
ii                              013334 automatic       fixed bin(17,0)          dcl 4826 set ref 5256* 5257 5258 5259* 5259
implied_loop              3     012412 automatic       bit(1)                   array level 2 dcl 875 set ref 9110 9125* 9146* 9167
                                                                                  9189 9195 9200*
impossible_align                       constant        bit(2)                   initial dcl 669 ref 5397
impossible_class                002670 constant        bit(1)                   initial array dcl 670 ref 5294
in_common                 0(35)        based           bit(1)                   level 4 in structure "header" packed packed
                                                                                  unaligned dcl 5-436 in procedure "ext_parse" set
                                                                                  ref 5314 5328 5334 5530 5590
in_common                11(02)        based           bit(1)                   level 4 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 6048 6056 6126 7422
in_const                               parameter       fixed bin(18,0)          dcl 12735 set ref 12732 12737 12741* 12742
in_equiv_stmnt           11(08)        based           bit(1)                   level 3 packed packed unaligned dcl 5-844 set ref
                                                                                  2114*
in_expr                         016673 automatic       bit(1)                   dcl 10051 set ref 10100* 10101 10468* 10567
in_list                         013746 automatic       bit(1)                   dcl 6594 in procedure "enter_label" set ref 6622*
                                                                                  6624 6627* 6632*
in_list                         016522 automatic       bit(1)                   dcl 9458 in procedure "get_bounds" set ref 9479*
                                                                                  9480 9482* 9559*
in_list                         016447 automatic       bit(1)                   dcl 9230 in procedure "parse_io_list" set ref 9269*
                                                                                  9270 9321 9322*
in_list                         001655 automatic       bit(1)                   dcl 671 in procedure "parse_source" set ref 1842*
                                                                                  1843 1894* 1915* 1917 1931* 1996* 1997 1998* 2002*
                                                                                  2022* 2023 2066* 2069* 2104* 2105 2200* 2247* 2248
                                                                                  2279* 2298* 2300 2316* 2344* 2359* 2361 2378*
                                                                                  2425* 2426 2439* 2459* 2478 2549* 2562 2590* 2664*
                                                                                  2665 2710* 2735* 2736 2755* 2805* 2806 2809 2849*
                                                                                  3332* 3333 3336 3350* 3511* 3512 3768 3770* 3893*
                                                                                  3894 3922* 4239* 4240 4244* 4386* 4388 4455* 4522*
                                                                                  4523 4553* 4617* 4619 4692* 7067* 7071 7076 7104*
                                                                                  8502* 8503 8566*
in_list                         014141 automatic       bit(1)                   dcl 7247 in procedure "parse_data" set ref 7453*
                                                                                  7458 7465*
in_list                         014005 automatic       bit(1)                   dcl 6796 in procedure "get_constant_offset" set ref
                                                                                  6834* 6835 6886*
in_list                         016474 automatic       bit(1)                   dcl 9389 in procedure "scan_label_list" set ref
                                                                                  9404* 9405 9414* 9421
in_list                         016263 automatic       bit(1)                   dcl 8210 in procedure "find_symbol_index" set ref
                                                                                  8245* 8249 8252* 8259*
in_stmnt                        001656 automatic       bit(1)                   dcl 672 set ref 1813* 1815 1901* 1953* 1954 2072*
                                                                                  2090* 2092 2211* 2396* 2397 2442* 3503* 3504 3798*
                                                                                  4199* 4205* 4208 4216* 4225* 4234
incl_count              116            based           fixed bin(17,0)          level 3 dcl 398 set ref 1115* 1149* 1149 1151 1165
                                                                                  1166 1167 11848 11877* 11877 11920 11924 11925
                                                                                  11926
incl_data               116            based           structure                level 2 dcl 398
incl_len                120            based           fixed bin(21,0)          array level 4 dcl 398 set ref 1166* 11925*
incl_ptr                121            based           pointer                  array level 4 packed packed unaligned dcl 398 set
                                                                                  ref 1167* 11926*
include_file_bit_count          017300 automatic       fixed bin(24,0)          dcl 11721 set ref 11837* 11918
include_file_name               017301 automatic       varying char(256)        dcl 11722 set ref 11835* 11837 11841* 11842* 11850*
                                                                                  11856* 11871* 11882* 11884* 11887 11889 11892
                                                                                  11893
include_file_ptr                017402 automatic       pointer                  dcl 11723 set ref 11837* 11839 11849* 11855* 11869
                                                                                  11870* 11879* 11916
increment_expression_idx        014142 automatic       fixed bin(18,0)          dcl 7248 set ref 7299* 7300 7300 7803* 7806* 7818
                                                                                  7818
increment_polish_op                    constant        fixed bin(18,0)          initial dcl 4-197 set ref 2412* 5104 6476 8041*
increment_table                 002562 constant        fixed bin(17,0)          initial array dcl 13-25 ref 8140
increment_value                 014143 automatic       fixed bin(18,0)          dcl 7249 set ref 7806* 7807 7812 7812
index                                                  builtin function         dcl 673 in procedure "parse_source" ref 1853 1865
                                                                                  2503 5490 6108 6155 7980 11788 12143 12564
index                     2(09) 000251 constant        fixed bin(8,0)           initial array level 2 in structure "bif_table"
                                                                                  packed packed unaligned dcl 9873 in procedure
                                                                                  "builtin_lookup" ref 9980
indx                            014144 automatic       fixed bin(18,0)          dcl 7250 in procedure "parse_data" set ref 7309*
                                                                                  7311 7312 7313* 7323* 7332 7348* 7353* 7367 7371*
                                                                                  7375* 7381* 7385* 7394* 7402 7406* 7407* 7412*
                                                                                  7413 7420 7422 7422 7426* 7434* 7438 7449 7454
                                                                                  7456 7477* 7482* 7490* 7575 7583* 7598* 7613* 7648
                                                                                  7650 7651* 7656* 7673* 7785 7785 7788 7788 7788
                                                                                  7788
indx                            016306 automatic       fixed bin(18,0)          dcl 8434 in procedure "parse_implied_io" set ref
                                                                                  8452* 8454*
indx                                   parameter       fixed bin(18,0)          dcl 6535 in procedure "declare_symbol" ref 6520 6540
indx                            016674 automatic       fixed bin(18,0)          dcl 10052 in procedure "parse_expression" set ref
                                                                                  10182* 10183 10202* 10231* 10246* 10253* 10258
                                                                                  10258* 10271* 10277* 10290* 10297* 10358* 10359
                                                                                  10384* 10396* 10399* 10407* 10411* 10418* 10529*
                                                                                  10530 10530 10595* 10596 10601* 10633* 10634
indx                            014047 automatic       fixed bin(18,0)          dcl 6961 in procedure
                                                                                  "get_data_statement_expression" set ref 6970*
                                                                                  6971*
indx                            020012 automatic       fixed bin(18,0)          dcl 12773 in procedure "convert_real_constant" set
                                                                                  ref 12833* 12834 12839 12839 12839
indx                            016750 automatic       fixed bin(18,0)          dcl 10663 in procedure "is_complex_constant" set ref
                                                                                  10674* 10680 10680 10681 10682* 10682 10687 10690
                                                                                  10690 10690 10693 10696 10698 10712* 10712 10754
indx                                   parameter       fixed bin(18,0)          dcl 9865 in procedure "builtin_lookup" set ref 9858
                                                                                  9930 9973*
indx                                   parameter       fixed bin(18,0)          dcl 9723 in procedure "get_integer_constant" set ref
                                                                                  9721 9742* 9790
indx                                   parameter       fixed bin(18,0)          dcl 13124 in procedure "split_token" set ref 13107
                                                                                  13134 13134 13135 13135 13136 13148 13150 13150
                                                                                  13151 13151 13157* 13157 13160* 13160 13163 13164
                                                                                  13165 13169 13170 13172* 13172
indx                                   parameter       fixed bin(18,0)          dcl 8776 in procedure "parse_record_number" set ref
                                                                                  8773 8784*
indx                            001657 automatic       fixed bin(18,0)          dcl 674 in procedure "parse_source" set ref 1162*
                                                                                  1165 1169 1171 1174 1986* 1987 1991* 1992 1998
                                                                                  2000 2004 2005* 2005 2008* 2008 2016* 2035 2035
                                                                                  2037 2039 2041 2045 2045 2054* 2676* 2678 2679
                                                                                  2681* 2681 2691 2810* 2816 2819* 2820 2820 2822
                                                                                  2859* 2860* 3337* 3341* 3345* 3540* 3545 3546*
                                                                                  3552* 3556 3556* 3558 3558* 3561* 3562 3562* 4095*
                                                                                  4101* 4105* 4107* 7078* 7085* 7085* 7087* 7091*
                                                                                  11902* 11903 11904
indx                            013747 automatic       fixed bin(18,0)          dcl 6595 in procedure "enter_label" set ref 6608*
                                                                                  6609 6609* 6620* 6624 6626 6630 6631* 6632 6637
                                                                                  6638* 6639 6641 6643 6646* 6653* 6654 6665 6668*
                                                                                  6683* 6695* 6701* 6707* 6709* 6709* 6716* 6724*
                                                                                  6724* 6740* 6741 6743* 6744 6748 6748 6752
indx                                   parameter       fixed bin(18,0)          dcl 9649 in procedure "get_one_bound" set ref 9631
                                                                                  9666* 9693
indx                            013335 automatic       fixed bin(18,0)          dcl 4827 in procedure "declaration_processor" set
                                                                                  ref 5109* 5109* 5111* 5112 5295* 5304* 5335* 5398*
                                                                                  5907* 5908 5916 5916 5918* 5927* 5944* 5959 5999*
indx                            016316 automatic       fixed bin(18,0)          dcl 8481 in procedure "parse_io" set ref 8525* 8526*
                                                                                  8540* 8541*
indx                            016521 automatic       fixed bin(18,0)          dcl 9457 in procedure "get_bounds" set ref 9487*
                                                                                  9492* 9515* 9520*
indx_ptr                        013336 automatic       pointer                  dcl 4828 in procedure "declaration_processor" set
                                                                                  ref 5908* 5914 5923 5932 5932 5933 5936 5941 5942
                                                                                  5948 5955 5956 5964 5964 5967 5968
indx_ptr                        013734 automatic       pointer                  dcl 6536 in procedure "declare_symbol" set ref 6540*
                                                                                  6542 6545 6545 6548 6548 6549 6549 6549 6549
indxx                           013616 automatic       fixed bin(18,0)          dcl 6210 set ref 6214* 6215 6222
initial                  13(07)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-844
                                                                                  set ref 2415* 2521* 2527* 2535* 2541* 2585* 2796*
                                                                                  4896 5023 5037 5044 5050* 5050 5103 5115* 6024
                                                                                  6025 6343 7456 7757* 8051* 8963 9689* 10706 12929
initial_expression_idx          014145 automatic       fixed bin(18,0)          dcl 7251 set ref 7294* 7295* 7298 7298 7801* 7802
                                                                                  7802
initial_in_polish                      based           structure                level 1 dcl 4851
initial_line                           constant        fixed bin(18,0)          initial dcl 676 ref 12048 12135
initial_subprogram        4(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-693
                                                                                  set ref 1216 1216*
initialed                 0(29)        based           bit(1)                   level 4 packed packed unaligned dcl 5-844 set ref
                                                                                  2045 5037 5037* 8153*
input_element                   001561 constant        bit(36)                  initial dcl 1071 ref 9245
input_lng               101            based           fixed bin(21,0)          level 2 dcl 14-6 ref 1145
input_pointer           102            based           pointer                  level 2 dcl 14-6 ref 1139 1599
inquire_op                             constant        fixed bin(18,0)          initial dcl 4-197 set ref 4615*
inquire_opr                            constant        fixed bin(4,0)           initial dcl 15-19 ref 4597
int_bits                        017770 automatic       bit(72)                  dcl 12696 set ref 12728 12729
int_mode                        003302 constant        fixed bin(4,0)           initial dcl 4-106 set ref 1097* 1100* 1263 1264 3305
                                                                                  3728* 3728* 3835 3934* 3934* 4166* 4469* 4470*
                                                                                  4567* 4568* 4709* 4710* 5132 5637 5639 5693 5695
                                                                                  6931* 6937 6978 6998 7135 7689 7698 7714 7738 7906
                                                                                  7906 8355 8828* 8828* 8860* 8860* 8871* 8871*
                                                                                  8879* 8879* 8889* 8889* 8892* 8892* 9241* 9241*
                                                                                  9673 9696 9699 9766 9769 10737 12746* 13057*
integer                  10(20)        based           bit(1)                   level 5 packed packed unaligned dcl 5-844 set ref
                                                                                  3562 6048
internal_file                          constant        bit(2)                   initial dcl 15-8 ref 8586 8780 8908
interval                        014146 automatic       fixed bin(18,0)          dcl 7252 set ref 7450* 7460* 7463 7466* 7466 7487
                                                                                  7498 7500* 7654 7657 7749* 7749 7754 7769 7775
                                                                                  7778
interval_ptr                    014147 automatic       fixed bin(18,0)          dcl 7253 set ref 7454* 7456* 7458 7460 7471 7487
                                                                                  7501 7502* 7502 7654 7654 7754 7757 7759 7762 7764
                                                                                  7766 7771 7773 7775 7778 7859*
inx                             001660 automatic       fixed bin(17,0)          dcl 677 set ref 1403* 1404 1404 1406* 1416 3696*
                                                                                  3713* 3715 3719 3743
io_bits                         013240 automatic       structure                level 1 packed packed unaligned dcl 885 set ref
                                                                                  3882* 3934 3934 3934 3934 3978* 4363* 4469 4469
                                                                                  4499* 4567 4567 4596* 4709 4709 8440* 8486* 9241
                                                                                  9241 9241 9241
io_control_type                 001661 automatic       fixed bin(4,0)           dcl 678 set ref 3862* 3867* 3872* 3883
io_ele                          016450 automatic       fixed bin(18,0)          dcl 9231 set ref 9271* 9278* 9280* 9282* 9285* 9286*
                                                                                  9290* 9291* 9293* 9294* 9313*
io_switch_field                        constant        fixed bin(17,0)          initial dcl 15-50 set ref 4413*
iostat_op                              constant        fixed bin(18,0)          initial dcl 4-197 set ref 8702*
iostat_var                0(13) 013240 automatic       bit(1)                   level 3 packed packed unaligned dcl 885 set ref 8691
                                                                                  8693*
is_addressable            0(14)        based           bit(1)                   level 3 packed packed unaligned dcl 5-256 set ref
                                                                                  8-83*
is_arith_constant                      constant        bit(9)                   initial dcl 4-147 ref 8007
is_constant                            constant        bit(9)                   initial dcl 4-147 ref 7972 10154 12938 13197
is_fast                 115            based           bit(1)                   level 4 packed packed unaligned dcl 398 set ref 4161
is_infix                               constant        bit(2)                   initial dcl 10053 ref 10441 10580
is_operand                      003030 constant        bit(9)                   initial dcl 4-147 ref 11397
is_operator                     003027 constant        bit(9)                   initial dcl 4-147 ref 10109 10429 12991 13204
is_prefix                              constant        bit(2)                   initial dcl 10054 ref 10120 10435
item                                   parameter       fixed bin(18,0)          dcl 6505 ref 6502 6512
item_op                                constant        fixed bin(18,0)          initial dcl 4-197 set ref 1541* 2979* 3186* 3194*
                                                                                  3346* 3362* 3385* 4247* 6374* 6379* 8768* 9369*
                                                                                  9419* 10484*
j                               014220 automatic       fixed bin(17,0)          dcl 7947 in procedure "parse_a_constant" set ref
                                                                                  7980* 7982 7986 7986
j                               014150 automatic       fixed bin(18,0)          dcl 7254 in procedure "parse_data" set ref 7346*
                                                                                  7347 7348 7350* 7352 7353 7354* 7357 7660* 7662*
                                                                                  7667 7670* 7677
j                               017772 automatic       fixed bin(18,0)          dcl 12697 in procedure "convert_integer_constant"
                                                                                  set ref 12702* 12703 12705 12714
j                               016432 automatic       fixed bin(18,0)          dcl 9094 in procedure "is_implied_loop" set ref
                                                                                  9132* 9134 9149 9184 9195*
j                               020060 automatic       fixed bin(18,0)          dcl 13123 in procedure "split_token" set ref 13139*
                                                                                  13140 13140 13142* 13150 13151 13154 13154 13156
                                                                                  13156 13157 13160 13162 13165
j                               014251 automatic       fixed bin(18,0)          dcl 8079 in procedure "create_format" set ref 8122*
                                                                                  8125 8132 8132 8137 8162* 8163 8164 8165 8166 8167
                                                                                  8168 8169 8170 8178* 8179 8179*
j                               013340 automatic       fixed bin(18,0)          dcl 4829 in procedure "declaration_processor" set
                                                                                  ref 5189* 5189* 5190 5192 5208* 5217* 5229* 5317*
                                                                                  5319 5357* 5357* 5358* 5404* 5404* 5406* 5430*
                                                                                  5430* 5431* 5446* 5446* 5448 5449
jnx                             001662 automatic       fixed bin(17,0)          dcl 679 set ref 1406* 1408 1408 1410 1410* 3740*
                                                                                  3743 3747
job_bits                        013240 automatic       structure                level 2 packed packed unaligned dcl 885
jump_arithmetic_op                     constant        fixed bin(18,0)          initial dcl 4-197 set ref 3049*
jump_assigned_op                       constant        fixed bin(18,0)          initial dcl 4-197 set ref 3250*
jump_computed_op                       constant        fixed bin(18,0)          initial dcl 4-197 set ref 3381* 9399*
jump_logical_op                        constant        fixed bin(18,0)          initial dcl 4-197 set ref 3071*
jump_op                                constant        fixed bin(18,0)          initial dcl 4-197 set ref 3227* 6276*
just_white_space                001450 constant        fixed bin(18,0)          initial dcl 11724 ref 11753 11754 12275
k                               013341 automatic       fixed bin(24,0)          dcl 4830 in procedure "declaration_processor" set
                                                                                  ref 5219* 5221* 5223* 5226
k                               014252 automatic       fixed bin(18,0)          dcl 8080 in procedure "create_format" set ref 8118*
                                                                                  8118* 8121 8121 8140* 8151* 8152 8179* 8179* 8184*
keyword_index                   001663 automatic       fixed bin(18,0)          dcl 680 set ref 1280* 1354 1354* 2914* 11010 11027
                                                                                  11039 11042 11337
keyword_table                   001562 constant        varying char(28)         initial array dcl 954 set ref 1484* 1497* 1827 1922
                                                                                  2027 2111 2253 2273* 2305 2312* 2320* 2366 2370*
                                                                                  2408* 2702 2706* 2741 2745* 2830* 3017* 3073*
                                                                                  3091* 3094* 3105* 3108* 3112* 3170* 3174* 3177*
                                                                                  3182* 3215* 3821* 3826* 3927* 4005* 4044* 4091*
                                                                                  4460* 4558* 4698* 4700* 4726* 4784* 8571* 8574*
                                                                                  8577* 8580* 8587 8589* 8749* 8780* 8804* 8817*
                                                                                  8838* 8906* 9255* 9260* 10388* 10987 11010 11010
                                                                                  11014 11014 11022 11022 11027 11027 11039 11039
                                                                                  11053
l_significant_digits            020042 automatic       fixed bin(18,0)          dcl 12899 in procedure "get_next_token" set ref
                                                                                  13067* 13069* 13075 13084*
l_significant_digits            020013 automatic       fixed bin(18,0)          dcl 12774 in procedure "convert_real_constant" set
                                                                                  ref 12793* 12795* 12809* 12814 12820 12820 12822
                                                                                  12843
label                                  based           structure                level 1 dcl 5-530 set ref 6763 6763
label_allocate_bits                    parameter       bit(5)                   dcl 6758 ref 6755 6768
label_args                      001664 automatic       bit(1)                   dcl 681 set ref 3304 3360 10885* 11190* 11433*
label_const                            constant        bit(9)                   initial dcl 4-156 ref 3340 11191 11426
label_hash_table                001665 automatic       fixed bin(18,0)          array dcl 682 set ref 1249* 6619 6620 6641 6641*
label_name                             parameter       fixed bin(18,0)          dcl 6759 ref 6755 6766
label_node                             constant        fixed bin(4,0)           initial dcl 4-87 set ref 6763*
label_op                               constant        fixed bin(18,0)          initial dcl 4-197 set ref 1423* 2910* 6397*
label_ptr                       004422 automatic       fixed bin(18,0)          array level 2 in structure "do_blockif_stack"
                                                                                  dcl 836 in procedure "parse_source" set ref 1404
                                                                                  1408* 1509 1538* 3105* 3174* 4765* 6609
label_ptr                       002210 automatic       fixed bin(18,0)          dcl 683 in procedure "parse_source" set ref 4734*
                                                                                  4765
label_ptr                       016410 automatic       fixed bin(18,0)          dcl 8929 in procedure "get_format" set ref 8946*
                                                                                  8947* 8955* 8957 8962 8963 8980* 8988 9000 9004
                                                                                  9004* 9017* 9018* 9023* 9024* 9025* 9049
label_ptr                       016475 automatic       fixed bin(18,0)          dcl 9390 in procedure "scan_label_list" set ref
                                                                                  9410* 9418*
label_storage                   016411 automatic       bit(5)                   dcl 8930 in procedure "get_format" set ref 8935*
                                                                                  8937* 9023*
label_storage                   013750 automatic       bit(5)                   dcl 6596 in procedure "enter_label" set ref 6605*
                                                                                  6638 6650 6650* 6653 6658 6683 6701 6737 6743 6746
                                                                                  6746* 6748
label_type                      013751 automatic       bit(2)                   dcl 6597 set ref 6603* 6638 6649 6657 6676 6677 6678
                                                                                  6680 6680* 6686 6686 6689 6701 6701 6705
label_usage                            parameter       bit(2)                   dcl 6760 ref 6755 6767
label_value                     013752 automatic       fixed bin(18,0)          dcl 6598 set ref 6604* 6613 6613 6614 6614 6616*
                                                                                  6616 6619 6627 6638*
last                            014151 automatic       fixed bin(18,0)          dcl 7255 set ref 7449* 7501* 7757 7757 7759 7766
                                                                                  7766 7769 7769 7851 7851 7853 7853 7859* 7859*
last_assigned_op                       constant        fixed bin(18,0)          initial dcl 4-197 ref 3653 3710 3737 6029 6975 7023
                                                                                  7896 9670
last_constant           101            based           fixed bin(18,0)          array level 3 dcl 398 set ref 8-91 8-93*
last_cref                 5            based           fixed bin(18,0)          level 2 unsigned dcl 6-12 set ref 1582*
last_cur_statement              002211 automatic       fixed bin(18,0)          dcl 684 set ref 2406 6450*
last_do                         016451 automatic       fixed bin(18,0)          dcl 9232 in procedure "parse_io_list" set ref 9267*
                                                                                  9305* 9324 9324 9325 9326* 9326 9336
last_do                         016433 automatic       fixed bin(18,0)          dcl 9095 in procedure "is_implied_loop" set ref
                                                                                  9120* 9168 9168 9171* 9179 9179
last_do                         002212 automatic       fixed bin(18,0)          dcl 685 in procedure "parse_source" set ref 3507*
                                                                                  3602* 3772 3772 3773 3775* 3775
last_element                    002213 automatic       fixed bin(18,0)          dcl 686 in procedure "parse_source" set ref 2801*
                                                                                  2835 2842 2844 2846* 2862
last_element              4            based           fixed bin(18,0)          level 2 in structure "header" packed packed unsigned
                                                                                  unaligned dcl 5-436 in procedure "ext_parse" set
                                                                                  ref 2035 2037 2039* 5425 5426* 5426 5667* 5772
                                                                                  5776* 5800* 5841 5846* 5846 5959*
last_entry_name          76            based           fixed bin(18,0)          level 2 dcl 398 set ref 1605 1605 4978 4981*
last_item                       016264 automatic       fixed bin(18,0)          dcl 8211 in procedure "find_symbol_index" set ref
                                                                                  8219* 8225* 8226 8230 8230 8236 8236 8241* 8244
                                                                                  8257* 8278 8278 8280 8288
last_item                       013753 automatic       fixed bin(18,0)          dcl 6599 in procedure "enter_label" set ref 6619*
                                                                                  6620 6630* 6641 6641 6643
last_label                4(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-753
                                                                                  set ref 6770 6772 6774*
last_label_line                 000010 internal static fixed bin(18,0)          dcl 11729 set ref 12292* 12305
last_mode_keyword                      constant        fixed bin(18,0)          initial dcl 687 ref 1293 1827 1830
last_namelist                   002214 automatic       fixed bin(18,0)          dcl 688 set ref 2403 2418*
last_namelist_word_offset       002215 automatic       fixed bin(18,0)          dcl 689 set ref 2404 2419*
last_node                              parameter       fixed bin(18,0)          dcl 8022 ref 8019 8051 8051 8053
last_paren_parsed               002216 automatic       fixed bin(18,0)          dcl 690 set ref 3499* 9102 9184* 9266*
last_polish               5(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-753
                                                                                  set ref 1573*
last_source_line                002217 automatic       fixed bin(18,0)          dcl 691 set ref 1107* 1242 1583*
last_statement                  002220 automatic       fixed bin(18,0)          dcl 692 set ref 1223* 6461 6461 6464*
last_statement_type             002221 automatic       fixed bin(18,0)          dcl 693 set ref 1519* 2403
last_subprogram          73            based           fixed bin(18,0)          level 2 dcl 398 set ref 1207 1209 1210 1214*
last_symbol               3(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-753
                                                                                  set ref 4928* 5148 5150 5153* 8272 8274 8276* 9828
                                                                                  9830 9832*
last_token                      002222 automatic       fixed bin(18,0)          dcl 694 set ref 1293 1309 1492 2641 3440 8458 8618
                                                                                  9132 9236 10756 10875* 10879 10941 10946 10950
                                                                                  10954* 10954 10957 10963 10970 10983 11180 11192*
                                                                                  11192 11202 11279* 11279 11281 11287 11288 11291
                                                                                  11294 11354 11397 12963 13184
last_token_type                 017215 automatic       bit(9)                   dcl 10829 set ref 10889* 10964 10965* 11179 11328
                                                                                  11328 11328 11397 11397
last_upper_bound                013660 automatic       fixed bin(17,0)          dcl 6235 set ref 6317* 6319* 6332
lbound                                                 builtin function         dcl 695 ref 1282 5246 5473 5474 11868
ldigits                         020014 automatic       fixed bin(18,0)          dcl 12775 in procedure "convert_real_constant" set
                                                                                  ref 12791* 12793 12793 12797 12807* 12820 12820
                                                                                  12822
ldigits                         020043 automatic       fixed bin(18,0)          dcl 12900 in procedure "get_next_token" set ref
                                                                                  13066* 13067 13067 13071 13084*
ldigits_parm                           parameter       fixed bin(18,0)          dcl 12776 ref 12803 12807
left_parenthesis                       constant        fixed bin(18,0)          initial dcl 10055 ref 10472
left_parn                              constant        bit(9)                   initial dcl 4-156 ref 1309 1839 1927 2060 2094 2124
                                                                                  2126 2265 2327 2468 2752 2782 2936 3003 3233 3247
                                                                                  3254 3258 3264 3324 3520 3620 3891 3952 3973 4377
                                                                                  4513 4608 7066 7962 8326 8497 9138 9272 10114
                                                                                  10125 10194 10488 11182 11202 11350 11397 12961
                                                                                  12964
len                             020061 automatic       fixed bin(18,0)          dcl 13125 in procedure "split_token" set ref 13136*
                                                                                  13138 13139 13142 13143* 13146 13146 13154 13154
                                                                                  13156 13156
len                             017553 automatic       fixed bin(18,0)          dcl 12550 in procedure "build_string" set ref 12564*
                                                                                  12566 12582 12591* 12602* 12605 12607* 12615*
                                                                                  12647* 12649 12657 12657 12658
len                                    parameter       fixed bin(18,0)          dcl 12699 in procedure "convert_integer_constant"
                                                                                  ref 12670 12702 12705 12708 12708 12723 12723
len                             017247 automatic       fixed bin(18,0)          dcl 11486 in procedure "get_continuation_line" set
                                                                                  ref 11502* 11503 11535* 11536 11616 11625 11625
                                                                                  11626 11630 11630 11631 11633 11634
len_pic                         017554 automatic       picture(3)               packed unaligned dcl 12551 set ref 12645* 12646
                                                                                  12647 12657
length                    4            based           fixed bin(18,0)          level 2 in structure "char_constant" packed packed
                                                                                  unsigned unaligned dcl 5-316 in procedure
                                                                                  "ext_parse" ref 2523 2527 2527 2612 2612 2615 2615
                                                                                  4896 7474 7580 7582 7584 7587 7592 7594 7598 7643
                                                                                  7662 7677 9024 9024
length                                                 builtin function         dcl 696 in procedure "parse_source" ref 1155 1157
                                                                                  1157 1823 1823 6213 8086 8086 8087 8109 8125 8128
                                                                                  9824 9840 9940 10987 11010 11014 11022 11027 11039
                                                                                  11053 11128 11227 11502 11535 11541 11599 11600
                                                                                  11616 11617 11814 11821 11828 11900 11900 11990
                                                                                  11993 11995 12002 12010 12010 12012 12017 12039
                                                                                  12044 12064 12072 12076 12078 12082 12100 12116
                                                                                  12127 12127 12132 12175 12175 12195 12195 12218
                                                                                  12227 12232 12354 12394 12416 12421 12423 12582
                                                                                  12647 12649 12652 12707 12714 12793 12797 12814
                                                                                  12815 12843 13067 13071
length                                 parameter       fixed bin(17,0)          dcl 9-12 in procedure "create_node" ref 9-10 9-20
                                                                                  9-23 9-24
length                    6            based           fixed bin(24,0)          level 2 in structure "header" dcl 5-436 in procedure
                                                                                  "ext_parse" set ref 5236* 5371 5374 5376 5378
                                                                                  5381* 5413 5416 5418 5420* 5420 5505 5537 5555
                                                                                  5593 5665* 5766 5777* 5799* 5820 5834 5847* 5873*
                                                                                  5960*
length                    0(27) 011016 automatic       fixed bin(8,0)           array level 2 in structure "constant_array" packed
                                                                                  packed unaligned dcl 853 in procedure
                                                                                  "parse_source" set ref 10728 12521* 13063 13093
                                                                                  13198
length                    1     005076 automatic       fixed bin(10,0)          array level 2 in structure "token_list" dcl 847
                                                                                  in procedure "parse_source" set ref 10696 10727
                                                                                  10736 10756* 10758* 10946* 10950* 11004 11202
                                                                                  11291* 11294* 11397 12915 12940 12985 12996 13012
                                                                                  13135* 13135 13136 13151* 13151 13165* 13189
length                          013515 automatic       fixed bin(24,0)          dcl 5905 in procedure "get_equiv_var" set ref 5942*
                                                                                  5943 5948* 5960
length                                 parameter       fixed bin(18,0)          dcl 13126 in procedure "split_token" ref 13107 13134
                                                                                  13135
length                    2(27)        based           bit(9)                   level 2 in structure "statement" packed packed
                                                                                  unaligned dcl 5-721 in procedure "ext_parse" set
                                                                                  ref 10975* 10977*
letters                                constant        fixed bin(18,0)          initial dcl 697 ref 11133 12399 12459
lexing_a_token                  017216 automatic       bit(1)                   dcl 10830 set ref 11122* 11123 11125* 11131* 11133*
                                                                                  12348* 12349 12351* 12358* 12360* 12388* 12389
                                                                                  12391* 12397* 12399*
lhs_fld_op                             constant        fixed bin(18,0)          initial dcl 4-197 set ref 2954*
line                      2(08)        based           bit(14)                  level 3 packed packed unaligned dcl 5-721 set ref
                                                                                  6514 10895* 10896* 10903* 10904*
line_length               1            based           fixed bin(18,0)          array level 2 packed packed unsigned unaligned
                                                                                  dcl 6-31 set ref 11796*
line_no                         017404 automatic       fixed dec(6,0)           dcl 11725 in procedure "get_line_image" set ref
                                                                                  12072 12076 12078 12081* 12082 12082 12086 12086
                                                                                  12091
line_no                   0(18)        based           fixed bin(17,0)          array level 2 in structure "cross_reference" packed
                                                                                  packed unaligned dcl 6-8 in procedure "ext_parse"
                                                                                  set ref 1389* 1389 1392* 1392 6514* 6516*
line_no_overlay                        based           structure                level 1 dcl 11731
line_number                     002223 automatic       fixed bin(18,0)          dcl 698 in procedure "parse_source" set ref 3137
                                                                                  10893 10899 10899 10903 10904 11063* 11775* 11797
                                                                                  11811 11811* 11864 11919* 11933 11933* 11957
                                                                                  11957* 11987 11987* 12086 12086 12086 12091* 12096
                                                                                  12096* 12144 12307
line_number               3     004422 automatic       fixed bin(18,0)          array level 2 in structure "do_blockif_stack"
                                                                                  dcl 836 in procedure "parse_source" set ref 1410
                                                                                  1410 1543 1543 3137*
line_number               0(18)        based           fixed bin(17,0)          level 2 in structure "source" packed packed
                                                                                  unaligned dcl 5-693 in procedure "ext_parse" set
                                                                                  ref 11914*
line_number_in_file       1(18)        based           fixed bin(18,0)          array level 2 packed packed unsigned unaligned
                                                                                  dcl 6-31 set ref 11797*
line_number_pic                 002224 automatic       picture(6)               packed unaligned dcl 699 set ref 12144* 12146*
line_numbered_text              002226 automatic       bit(1)                   dcl 700 set ref 1124* 12060
line_start                0(09)        based           fixed bin(21,0)          array level 2 packed packed unsigned unaligned
                                                                                  dcl 6-31 set ref 11795*
line_structure                         based           structure                level 1 dcl 10850
list                      0(07) 013240 automatic       bit(1)                   level 3 packed packed unaligned dcl 885 set ref
                                                                                  9236* 9254
list_bits                       016476 automatic       bit(5)                   dcl 9391 set ref 9395* 9401* 9410* 9417
list_directed                          constant        bit(2)                   initial dcl 15-8 ref 8548 8589 9031
listing                 113(07)        based           structure                level 4 packed packed unaligned dcl 398 set ref 1125
listing_base                    000116 automatic       pointer                  dcl 380 in procedure "ext_parse" set ref 416* 1234
listing_base             20            based           pointer                  level 2 in structure "shared_structure" dcl 398
                                                                                  in procedure "ext_parse" set ref 416
listing_info                           based           structure                level 1 dcl 6-12 set ref 1236* 1237
listing_seg                            based           fixed bin(17,0)          array dcl 6-22 set ref 1234
ln_digits                 0(09)        based           char(6)                  level 2 packed packed unaligned dcl 11731 set ref
                                                                                  12072 12076 12078 12082 12082* 12086*
local_attributes                002230 automatic       bit(47)                  dcl 703 set ref 2257* 2258* 2269* 2273*
locate_symtab_entry                    constant        fixed bin(2,0)           initial dcl 701 set ref 2810* 4095* 7529* 7543*
                                                                                  7957* 8317* 10700*
location                  1(18)        based           bit(18)                  level 2 in structure "statement" packed packed
                                                                                  unaligned dcl 5-721 in procedure "ext_parse" set
                                                                                  ref 1133* 6193*
location                  5            based           fixed bin(24,0)          level 2 in structure "symbol" dcl 5-844 in procedure
                                                                                  "ext_parse" set ref 7181 7181 7188*
logical_const                          constant        bit(9)                   initial dcl 4-156 ref 13026 13033
logical_if_statement            002227 automatic       bit(1)                   dcl 702 set ref 1435* 1501 3017 3055 3060* 3064 3215
                                                                                  3821 4091
logical_mode                    003267 constant        fixed bin(4,0)           initial dcl 4-106 set ref 13029* 13036*
loop_end                        013754 automatic       fixed bin(18,0)          dcl 6600 in procedure "enter_label" set ref 6692*
                                                                                  6692 6692* 6694 6695 6713* 6713 6713* 6715 6716
loop_end                  5(18)        based           fixed bin(18,0)          level 2 in structure "label" packed packed unsigned
                                                                                  unaligned dcl 5-530 in procedure "ext_parse" set
                                                                                  ref 6663* 6692 6694 6698* 6712 6713 6715 6716 6716
                                                                                  6716 6728* 6733*
loop_index                      017463 automatic       fixed bin(18,0)          dcl 12256 set ref 12263* 12278*
loop_info                       014152 automatic       fixed bin(18,0)          dcl 7256 set ref 7800* 7801 7807 7807
lower                           016554 automatic       bit(1)                   array level 2 in structure "v_bounds" packed packed
                                                                                  unaligned dcl 9465 in procedure "get_bounds" set
                                                                                  ref 9510* 9535*
lower                           014006 automatic       fixed bin(18,0)          dcl 6797 in procedure "get_constant_offset" set ref
                                                                                  6844* 6858 6873 6915*
lower                           014153 automatic       fixed bin(18,0)          dcl 7257 in procedure "parse_data" set ref 7340*
                                                                                  7352 7354 7357
lower                     0(09)        based           bit(1)                   array level 3 in structure "dimension" packed packed
                                                                                  unaligned dcl 5-383 in procedure "ext_parse" set
                                                                                  ref 5081 6324 8857
lower                           016657 automatic       fixed bin(18,0)          dcl 9866 in procedure "builtin_lookup" set ref 9944*
                                                                                  9954 9957* 9958 9960
lower_bound                     016527 automatic       fixed bin(24,0)          array level 2 in structure "bounds" dcl 9464
                                                                                  in procedure "get_bounds" set ref 9508* 9534* 9541
lower_bound               5            based           fixed bin(24,0)          array level 3 in structure "dimension" dcl 5-383
                                                                                  in procedure "ext_parse" set ref 3659 5081* 6326
                                                                                  6915 7340 8164* 8851 8863 8871 8871 8871 8871
lp                              013756 automatic       pointer                  dcl 6601 set ref 6626* 6627 6631 6639* 6654 6658
                                                                                  6661 6663 6671 6678 6683 6689 6689 6692 6698 6705
                                                                                  6709 6712 6713 6716 6716 6716 6724 6726 6727 6728
                                                                                  6731 6732 6733 6733 6737 6737 6740 6744
lprec                           001513 constant        fixed bin(18,0)          initial array dcl 10077 ref 10451 10461
lsd_parm                               parameter       fixed bin(18,0)          dcl 12777 ref 12803 12809
ltrim                                                  builtin function         dcl 9-17 in procedure "create_node" ref 9-29 9-29
ltrim                                                  builtin function         dcl 704 in procedure "parse_source" ref 1410 1410
                                                                                  1543 1543 5012 5234 5379 5379 5505 5537 5927 5927
                                                                                  6136 8322 8322 8393 8393 8398 8398 8738 8740 8740
                                                                                  9599 9599 9623 9623 12793 12820 13067
ltrim                                                  builtin function         dcl 8-28 in procedure "create_constant" ref 8-45
                                                                                  8-45
main_attr                       002666 constant        bit(47)                  initial dcl 705 set ref 1118 1344* 1344* 6173 6174
main_entry_point_name
                         56            based           varying char(32)         level 2 dcl 398 set ref 1343* 1344 1344
main_op                                constant        fixed bin(18,0)          initial dcl 4-197 ref 1117 6198
main_program                           constant        fixed bin(9,0)           initial dcl 4-68 ref 3826 4044 6181
mantissa                               based           fixed dec(30,0)          dcl 12771 set ref 12813* 12845 12857 12859 12868
                                                                                  12870
map                     113(09)        based           bit(1)                   level 5 packed packed unaligned dcl 398 set ref 413
margin_op                              constant        fixed bin(18,0)          initial dcl 4-197 set ref 4298*
master                                 based           structure                level 1 unaligned dcl 13221
master_index                    020102 automatic       fixed bin(18,0)          dcl 13223 set ref 13226* 13227 13228 13230 13234*
                                                                                  13234
max                                                    builtin function         dcl 706 ref 5378 5420 6132 9811 12017 12044
max_arglist                            constant        fixed bin(18,0)          initial dcl 707 ref 3368 3368 7158 7158 10601 10601
max_array_size                  000122 automatic       structure                level 1 unaligned dcl 383
max_char_length                        constant        fixed bin(10,0)          initial dcl 4-77 ref 2527 2527 5742 8155
max_char_var_length                    constant        fixed bin(21,0)          initial dcl 506 ref 8384 8386
max_fixed_bin_18                076436 constant        fixed bin(18,0)          initial dcl 4-58 ref 6508 6508 6508 6616 12568
max_fixed_bin_24                003060 constant        fixed bin(24,0)          initial dcl 4-59 ref 429 433 437 441 5234 5234 5360
                                                                                  5379 5379 5379 5926 5927 5927 9550 9550 9595 9599
                                                                                  9599 9622 9623 9623 9624 9626
max_length_this_pass            013342 automatic       fixed bin(18,0)          dcl 4831 set ref 5733* 5755 5769 5823 5837*
max_prec_single                        constant        fixed bin(9,0)           initial dcl 4-68 ref 13075 13078
max_stack                       002232 automatic       fixed bin(18,0)          dcl 708 in procedure "parse_source" set ref 1113*
                                                                                  1611 2502 2508* 7003 7005* 8353 8360* 9700 9707*
                                                                                  9770 9776* 9811* 9811
max_stack                 1(32) 013232 automatic       fixed bin(18,0)          level 2 in structure "parameter_info" packed packed
                                                                                  unaligned dcl 883 in procedure "parse_source" set
                                                                                  ref 2502* 2508 7003* 7005 8353* 8360 9700* 9707
                                                                                  9770* 9776
max_value                       000774 constant        fixed dec(11,0)          initial dcl 12698 ref 12716 12716
may_need_descriptors            016675 automatic       bit(1)                   packed unaligned dcl 10056 set ref 10185* 10189*
                                                                                  10371 10378
member_attr                     002664 constant        bit(47)                  initial dcl 709 set ref 2031*
member_conflicts                002662 constant        bit(47)                  initial dcl 711 set ref 2031*
min                                                    builtin function         dcl 713 ref 6616 7560 7979 11227 11496 11517 11535
                                                                                  12241
minus                                  constant        bit(9)                   initial dcl 4-156 ref 1858 7955 8010 8735 8736 10138
                                                                                  10680 10745 11312 12716
misc_attributes          10(28)        based           structure                level 3 packed packed unaligned dcl 5-844
mod                                                    builtin function         dcl 8-29 in procedure "create_constant" ref 8-57
mod                                                    builtin function         dcl 714 in procedure "parse_source" ref 5206 5394
                                                                                  5767 5835 5998 6619 8241
mod_2_sum                       000124 automatic       bit(36)                  dcl 8-30 set ref 8-51* 8-54* 8-57
mode                                   parameter       fixed bin(4,0)           dcl 8308 in procedure "get_mode_size" set ref 8291
                                                                                  8321 8334 8367 8375 8391 8391 8395* 8400* 8408
                                                                                  8417
mode                      0(05) 013240 automatic       bit(2)                   level 3 in structure "io_bits" packed packed
                                                                                  unaligned dcl 885 in procedure "parse_source" set
                                                                                  ref 8580 8586 8634 8780 8785* 8817 8819* 8906
                                                                                  8908* 9260
mode                     10(20)        based           structure                level 4 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 2503 6108 6152
mode_bits                10            based           structure                level 3 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 2820 2820 4058 4058 4871* 4871 4948* 4948 9967
                                                                                  9983
mode_bits                              based           structure                level 2 in structure "attr" packed packed unaligned
                                                                                  dcl 8306 in procedure "get_mode_size"
mode_defined                    002234 automatic       bit(52)                  dcl 715 set ref 1271* 1884 1887*
mode_field                             constant        fixed bin(17,0)          initial dcl 15-50 set ref 4422*
mode_type                       002236 automatic       fixed bin(4,0)           dcl 716 set ref 2233* 2243 2244* 2258 2267 2269
more_on_this_line               017250 automatic       bit(1)                   dcl 11487 set ref 11541* 11548 11563*
mult_op                                constant        fixed bin(18,0)          initial dcl 4-197 set ref 8883*
multiple_entry            0(13)        based           bit(1)                   level 2 packed packed unaligned dcl 5-753 set ref
                                                                                  4042*
multiplier                      014007 automatic       fixed bin(18,0)          dcl 6798 in procedure "get_constant_offset" set ref
                                                                                  6811* 6820* 6828* 6844* 6861* 6869* 6873 6883*
                                                                                  6883 6902* 6902 6904
multiplier                      014154 automatic       fixed bin(18,0)          dcl 7258 in procedure "parse_data" set ref 7334*
                                                                                  7357 7359* 7359
must_be_one                            parameter       bit(1)                   dcl 13127 ref 13107 13146
must_have_label                 002237 automatic       bit(1)                   dcl 717 set ref 1275* 1418* 1428 1430* 1549 3033*
                                                                                  3062* 3272* 4065 4067*
n                               016265 automatic       fixed bin(18,0)          dcl 8212 set ref 8226* 8230 8236* 8238*
n_args                    0(05)        based           fixed bin(12,0)          level 2 packed packed unaligned dcl 5-130 set ref
                                                                                  4963 6304 7149*
name                     20            based           char                     level 2 in structure "symbol" dcl 5-844 in procedure
                                                                                  "ext_parse" set ref 2507 2936 5636 5690 6155 8251
                                                                                  8269* 8386* 9841* 9844* 9846* 9942 10258
name                     20            based           char                     level 2 in structure "master" dcl 13221 in procedure
                                                                                  "check_entry_duplication" ref 13230
name                                   parameter       varying char(256)        dcl 9817 in procedure "build_symbol" ref 9814 9824
                                                                                  9840 9846
name                      4(18)        based           fixed bin(17,0)          level 2 in structure "label" packed packed unaligned
                                                                                  dcl 5-530 in procedure "ext_parse" set ref 6627
                                                                                  6766*
name                            000251 constant        char(8)                  initial array level 2 in structure "bif_table"
                                                                                  dcl 9873 in procedure "builtin_lookup" ref 9949
                                                                                  9952
name                     20            based           char                     level 2 in structure "slave" dcl 13222 in procedure
                                                                                  "check_entry_duplication" set ref 13230 13230*
name_field                             constant        fixed bin(17,0)          initial dcl 15-50 set ref 4664*
name_length               4(18)        based           fixed bin(17,0)          level 2 in structure "header" packed packed
                                                                                  unaligned dcl 5-436 in procedure "ext_parse" set
                                                                                  ref 1998 2679 5454 5490 5683 5685 5857 6219* 6220
                                                                                  7422
name_length              14(07)        based           fixed bin(17,0)          level 2 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 2507 2936 5636 5690 6155 8251 8268* 8269 8386
                                                                                  8386 9838* 9841 9844 9846 9940 9942 10258 13230
                                                                                  13230 13230 13230
named_const_attr                002660 constant        bit(47)                  initial dcl 720 set ref 2483* 2570*
named_const_conflicts           002656 constant        bit(47)                  initial dcl 722 set ref 2483*
named_constant           11(06)        based           bit(1)                   level 4 packed packed unaligned dcl 5-844 set ref
                                                                                  5049* 10703 12925 13002
named_constant_ptr              002240 automatic       pointer                  dcl 718 set ref 10161 12927*
named_constant_ptr_valid        002242 automatic       bit(1)                   dcl 719 set ref 10160 12910* 12928*
named_field                            constant        fixed bin(17,0)          initial dcl 15-50 set ref 4661*
namelist                 10(34)        based           bit(1)                   level 4 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 8957
namelist                               constant        bit(2)                   initial dcl 15-8 in procedure "parse_source" ref
                                                                                  8990 9255
namelist_attr                   002654 constant        bit(47)                  initial dcl 724 set ref 2402*
namelist_op                     003026 constant        fixed bin(18,0)          initial dcl 4-197 set ref 8981*
namelist_used             0(14)        based           bit(1)                   level 2 in structure "subprogram" packed packed
                                                                                  unaligned dcl 5-753 in procedure "ext_parse" set
                                                                                  ref 8993*
namelist_used           115(01)        based           bit(1)                   level 4 in structure "shared_structure" packed
                                                                                  packed unaligned dcl 398 in procedure "ext_parse"
                                                                                  set ref 1123* 8992*
ndx                                    parameter       fixed bin(24,0)          dcl 6040 set ref 6037 6045 6046 6048*
need_PS                   0(11)        based           bit(1)                   level 2 packed packed unaligned dcl 5-753 set ref
                                                                                  3936* 3986* 4275* 4299* 4316* 4359* 4495* 4592*
                                                                                  8448* 8494*
need_comma                      016452 automatic       bit(1)                   dcl 9233 in procedure "parse_io_list" set ref 9320*
                                                                                  9321 9330*
need_comma                      002243 automatic       bit(1)                   dcl 726 in procedure "parse_source" set ref 3767*
                                                                                  3768 3785*
need_element                    016453 automatic       bit(1)                   dcl 9234 set ref 9304* 9307* 9309* 9312
need_label                0(03) 000000 constant        bit(1)                   initial array level 2 packed packed unaligned
                                                                                  dcl 892 ref 1418 1430
needs_descriptors         0(07)        based           bit(1)                   level 2 in structure "expression" packed packed
                                                                                  unaligned dcl 1034 in procedure "parse_source" ref
                                                                                  10185
needs_descriptors         0(33)        based           bit(1)                   level 3 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 2339* 3327 4964* 4966 4967* 5140 5140* 10234
                                                                                  10280 10371* 10378*
negate_op                              constant        fixed bin(18,0)          initial dcl 4-197 ref 6992 7898 7899 9677
negate_round           1540            based           entry variable           array level 2 dcl 398 set ref 10745 12749 12754
                                                                                  12759 12762
negate_token                           constant        fixed bin(18,0)          initial dcl 10057 ref 10138
new                             002244 automatic       fixed bin(18,0)          dcl 728 in procedure "parse_source" set ref 2816*
                                                                                  2820* 2822 2824 2826 2830* 2830* 2834 2835 2837
                                                                                  2839 2842 2844 2846
new                             013343 automatic       fixed bin(18,0)          dcl 4832 in procedure "declaration_processor" set
                                                                                  ref 4936* 5166 5281* 5301 5318 5319* 5443 5446
                                                                                  5455 5455
new_format                      014253 automatic       char(4096)               dcl 8081 set ref 8094* 8096 8105 8109 8115 8115 8118
                                                                                  8122 8125 8128 8132* 8132 8134 8141 8143 8172 8172
                                                                                  8179 8179 8184 8184
new_label                       013766 automatic       fixed bin(18,0)          dcl 6761 set ref 6763* 6765 6766 6767 6768 6770 6772
                                                                                  6774 6775
new_node                        014234 automatic       fixed bin(18,0)          dcl 8024 set ref 8031* 8032 8034 8035 8036 8045*
                                                                                  8051 8053 8055
new_offset                      013524 automatic       fixed bin(24,0)          dcl 5989 set ref 5991* 5995 5998 6002* 6002 6004
new_state                       016676 automatic       bit(36)                  dcl 10058 set ref 10214* 10221* 10234* 10236* 10249*
                                                                                  10261* 10280* 10282* 10307 10497*
next                      1            based           fixed bin(18,0)          level 2 in structure "listing_info" unsigned
                                                                                  dcl 6-12 in procedure "ext_parse" set ref 1231*
next                      4            based           fixed bin(18,0)          level 2 in structure "source" packed packed unsigned
                                                                                  unaligned dcl 5-693 in procedure "ext_parse" set
                                                                                  ref 1171* 11903*
next                      1            based           bit(18)                  level 2 in structure "statement" packed packed
                                                                                  unaligned dcl 5-721 in procedure "ext_parse" set
                                                                                  ref 1132* 6280* 6390* 6401* 6461*
next_constant             3            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-256
                                                                                  set ref 8-91*
next_free_listing        44            based           fixed bin(18,0)          level 2 dcl 398 set ref 1231 1234 1237* 1237
next_free_operand        42            based           fixed bin(18,0)          level 2 dcl 398 set ref 9-20 9-22 9-23* 9-23 5455
                                                                                  5455* 5858 5858*
next_free_polish         41            based           fixed bin(18,0)          level 2 dcl 398 set ref 1221 1573 2284 2405* 2476
                                                                                  2504 2547* 2796 2882 3804 4382 4518 4613 6257 6346
                                                                                  6352 6353* 6353 6425 6429 6430* 6430 6436 6440
                                                                                  6441 6442* 6442 6452 6455 6459* 6459 6470 6473
                                                                                  6476 6477 6479* 6479 6969 6973 6995 7001 7008*
                                                                                  7018* 7020 7021 7028* 8045 8188 8350 8356 8361*
                                                                                  9016 9019 9022* 9663 9665 9669 9683* 9685 9690
                                                                                  9694* 9696 9703 9711* 9715* 9740 9766 9772 9796*
                                                                                  10868
next_header               3            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-436
                                                                                  set ref 2000 2004* 2005 2008 2681 2691* 5239 5443
                                                                                  5446 5448 5449* 5449 5507 5540 5560 5562* 5562
                                                                                  5564* 5578 5598 5600* 5600 5602* 5619 5654* 5707
                                                                                  5784 5791* 5825 5827* 5827 5864 5868* 5870* 5889
                                                                                  5957*
next_label                3            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-530
                                                                                  set ref 4903 6772*
next_line_index                 002245 automatic       fixed bin(20,0)          dcl 729 set ref 11064* 11739 11758 11773* 11788*
                                                                                  11789 11789* 11791 11796 11922*
next_member               7(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-844
                                                                                  set ref 2037* 2842* 2844* 5109 5112 5238 5367 5409
                                                                                  5425* 5434 5499 5526 5571 5609 5692 5706 5772*
                                                                                  5841* 5856 5878
next_node                              parameter       fixed bin(18,0)          dcl 8023 set ref 8019 8034 8046*
next_statement_label            002246 automatic       fixed bin(18,0)          dcl 730 set ref 10921 10924* 11072* 11100* 11104
                                                                                  11104* 12271* 12271 12281 12289 12304 12308*
next_subprogram           1(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-753
                                                                                  set ref 1210*
next_symbol               3            based           fixed bin(18,0)          level 2 in structure "master" packed packed unsigned
                                                                                  unaligned dcl 13221 in procedure
                                                                                  "check_entry_duplication" ref 13228 13234
next_symbol               3            based           fixed bin(18,0)          level 2 in structure "slave" packed packed unsigned
                                                                                  unaligned dcl 13222 in procedure
                                                                                  "check_entry_duplication" ref 13232
next_symbol               3            based           fixed bin(18,0)          level 2 in structure "symbol" packed packed unsigned
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 1605* 4936 4937* 4978* 5150* 5672 5807 8274*
                                                                                  9830*
next_token                      002247 automatic       bit(9)                   dcl 731 set ref 8615* 8616 8620
nextrec_field                          constant        fixed bin(17,0)          initial dcl 15-50 set ref 4676*
nl_ind                          016412 automatic       fixed bin(18,0)          dcl 8931 set ref 8966* 8968 8970 8973*
nl_off                          016413 automatic       fixed bin(18,0)          dcl 8932 set ref 8963* 8966 8966 8966
no_assumed_size_array
                          0(13)        based           bit(1)                   level 2 packed packed unaligned dcl 1034 ref 10388
no_attributes                   002652 constant        bit(47)                  initial dcl 732 set ref 1681* 1771* 2312* 2370*
no_dims                         014010 automatic       fixed bin(18,0)          dcl 6799 set ref 6819* 6827* 6830* 6842 6859 6866
                                                                                  6878 6879 6894 6897 6899 6907
no_keyword                      016317 automatic       fixed bin(17,0)          dcl 8483 set ref 8501* 8536* 8536 8545
no_more_source                         constant        fixed bin(18,0)          initial dcl 734 ref 1191 1198 10899 10912 11559
                                                                                  11766
no_op                                  constant        fixed bin(18,0)          initial dcl 4-197 ref 6473
no_token                               constant        bit(9)                   initial dcl 4-156 ref 10889 13169
node                                   based           structure                level 1 dcl 5-63
node_offset                     000125 automatic       fixed bin(17,0)          dcl 8-31 set ref 8-61* 8-62 8-63 8-65 8-69* 8-74*
                                                                                  8-76 8-78 8-80 8-89 8-91 8-93 8-95
node_ptr                        000126 automatic       pointer                  dcl 8-32 set ref 8-63* 8-65 8-65 8-69 8-78 8-80*
                                                                                  8-81 8-82 8-83 8-84 8-85
node_type                              based           fixed bin(4,0)           level 2 packed packed unaligned dcl 5-63 set ref
                                                                                  9-25* 6029 6977 6981 10185
non_zero_value                  014155 automatic       bit(5)                   dcl 7259 set ref 7420* 7429* 7431* 7436* 7438* 7441*
                                                                                  7443* 7784 7785 7788 7846* 7846
not                                    constant        bit(9)                   initial dcl 4-156 ref 10141
not_constant              0(12)        based           bit(1)                   level 2 packed packed unaligned dcl 1034 set ref
                                                                                  6995 9682 9758 10181*
not_found                       016660 automatic       bit(1)                   dcl 9867 in procedure "builtin_lookup" set ref 9947*
                                                                                  9948 9949*
not_found                       002250 automatic       bit(1)                   dcl 735 in procedure "parse_source" set ref 2675*
                                                                                  2678 2679* 2687
not_referencable          0(33)        based           bit(1)                   level 3 packed packed unaligned dcl 5-530 set ref
                                                                                  1384* 4888
not_scalar_ref            0(08)        based           structure                level 2 packed packed unaligned dcl 1034 set ref
                                                                                  10508* 10522*
not_simple_ref            0(10)        based           bit(1)                   level 3 packed packed unaligned dcl 1034 set ref
                                                                                  3236 3245 8804 9004 9757 10133* 10170* 10229*
                                                                                  10244* 10255* 10275* 10384 10402* 10558* 10580*
                                                                                  10584
not_token                              constant        fixed bin(18,0)          initial dcl 10059 ref 10141
null                                                   builtin function         dcl 736 ref 1143 1597 1597 3631 5551 5560 5576 5586
                                                                                  5598 5617 5761 5789 5814 5825 5829 5866 5887 11839
num_args                        000142 automatic       fixed bin(17,0)          dcl 5-150 set ref 4963* 4966 7062* 7102* 7102 7147
                                                                                  7147 7149 7151 7158
num_dims                        000143 automatic       fixed bin(3,0)           dcl 5-431 set ref 8161* 8162 8162 9580* 9581 9581
                                                                                  9590
number_field                           constant        fixed bin(17,0)          initial dcl 15-50 set ref 4658*
number_of_crefs          54            based           fixed bin(17,0)          level 2 dcl 398 set ref 1241 1389 1389 1392 1392
                                                                                  1582 2775 2905* 6508 6511* 6511 6512 6514 6516
number_of_dims                  002251 automatic       fixed bin(17,0)          dcl 737 in procedure "parse_source" set ref 3632*
                                                                                  3643* 3653 3673 3673
number_of_dims            0(05)        based           fixed bin(3,0)           level 2 in structure "dimension" packed packed
                                                                                  unaligned dcl 5-383 in procedure "ext_parse" set
                                                                                  ref 3643 5080 5086 6315 6830 7336 8163* 8841 8878
                                                                                  9583*
number_of_lines          53            based           fixed bin(17,0)          level 2 dcl 398 set ref 1106* 1583 10907 11784*
                                                                                  11784 11794 11795 11796 11797 11914
number_of_source_segments
                         52            based           fixed bin(8,0)           level 2 dcl 398 set ref 1105* 1153* 1153 11899*
                                                                                  11899
number_of_subs                  002252 automatic       fixed bin(17,0)          dcl 738 set ref 3632* 3648* 3648 3653 3659 3663 3673
numeric                         017464 automatic       bit(1)                   dcl 12257 set ref 12261* 12272* 12281 12289
object_base                     000110 automatic       pointer                  dcl 377 in procedure "ext_parse" set ref 411* 1282
                                                                                  1611 3384 3545 3575 3581 3586 3651 3653 3653 3656
                                                                                  3682 3682 3708 3710 3710 3713 3735 3737 3737 3740
                                                                                  3757 5246 5251 5257 5258 5266 5275 5280 5473 5474
                                                                                  5907 5923 5923 5995 6982 7152 7285 7295 7298 7299
                                                                                  7300 7305 7323 7343 7343 7360 7369 7379 7799 7802
                                                                                  7803 7807 7807 7818 7884 7892 7893 7894 7906 7906
                                                                                  7906 7917 9806 9806 9809 10460 10476 10529 10593
                                                                                  10615 10616 10618 10623 10631 10632 10633
object_base               4            based           pointer                  level 2 in structure "shared_structure" dcl 398
                                                                                  in procedure "ext_parse" set ref 411
object_max_len           36            based           fixed bin(19,0)          level 2 in structure "shared_structure" dcl 398
                                                                                  in procedure "ext_parse" set ref 420
object_max_len                  000121 automatic       fixed bin(19,0)          dcl 382 in procedure "ext_parse" set ref 420*
octal_const                            constant        bit(9)                   initial dcl 4-156 ref 13194
octal_digits                    001556 constant        char(8)                  initial dcl 7948 ref 7980
octal_value                     014156 automatic       bit(72)                  dcl 7260 in procedure "parse_data" set ref 7546*
                                                                                  7681 7705
octal_value                            parameter       bit(72)                  dcl 7949 in procedure "parse_a_constant" set ref
                                                                                  7938 7990*
octal_work                      014222 automatic       bit(72)                  dcl 7950 set ref 7975* 7986* 7990
off                             017555 automatic       fixed bin(18,0)          dcl 12552 in procedure "build_string" set ref 12559*
                                                                                  12564 12564 12566 12578* 12602* 12620* 12646*
                                                                                  12647 12657
off                             014011 automatic       fixed bin(18,0)          dcl 6800 in procedure "get_constant_offset" set ref
                                                                                  6810* 6861* 6869* 6873* 6873 6904 6904 6910
off                             020062 automatic       fixed bin(18,0)          dcl 13128 in procedure "split_token" set ref 13134*
                                                                                  13139 13146 13154 13156 13156 13164
off                             014160 automatic       fixed bin(18,0)          dcl 7261 in procedure "parse_data" set ref 7318*
                                                                                  7324* 7357* 7357 7395* 7448 7645
off                                    parameter       fixed bin(18,0)          dcl 12700 in procedure "convert_integer_constant"
                                                                                  ref 12670 12702 12702 12703 12705 12708 12708
                                                                                  12723 12723
offset                   17            based           fixed bin(24,0)          level 2 in structure "symbol" dcl 5-844 in procedure
                                                                                  "ext_parse" set ref 5213* 5359 5361* 5364* 5690
                                                                                  5780* 5853* 5853 5936
offset                    0(18) 005076 automatic       fixed bin(18,0)          array level 2 in structure "token_list" packed
                                                                                  packed unsigned unaligned dcl 847 in procedure
                                                                                  "parse_source" set ref 1297 1309 10698 10725 10736
                                                                                  10758 10763* 10941* 11004 11288* 12914 12939 12984
                                                                                  12995 13011 13134 13134* 13150* 13150 13164* 13188
offset                          000106 automatic       fixed bin(18,0)          dcl 9-13 in procedure "create_node" set ref 9-22*
                                                                                  9-24 9-25 9-26
offset                          013514 automatic       fixed bin(24,0)          dcl 5904 in procedure "get_equiv_var" set ref 5923*
                                                                                  5926 5936* 5936 5973
offset                                 parameter       fixed bin(24,0)          dcl 5988 in procedure "verify_offset_type_kludge"
                                                                                  ref 5976 5991
offset                                 parameter       fixed bin(18,0)          dcl 12778 in procedure "convert_real_constant" ref
                                                                                  12767 12790 12791 12803 12811
ok_second_statement       0(02) 000000 constant        bit(1)                   initial array level 2 packed packed unaligned
                                                                                  dcl 892 ref 3073
old                             002253 automatic       fixed bin(18,0)          dcl 739 in procedure "parse_source" set ref 2816*
                                                                                  2819* 2824 2824 2826 2834 2870* 2872 2872 2874
old                             013344 automatic       fixed bin(18,0)          dcl 4833 in procedure "declaration_processor" set
                                                                                  ref 5267* 5301 5317 5318* 5330* 5335* 5379* 5432
old_format                             based           structure                level 1 dcl 13-49
op                              000123 automatic       fixed bin(18,0)          dcl 7880 in procedure "value" set ref 7893* 7894
                                                                                  7894 7896 7896 7898 7898 7899 7906
op                              014050 automatic       fixed bin(18,0)          dcl 6961 in procedure
                                                                                  "get_data_statement_expression" set ref 6974* 6975
                                                                                  6976 6982 6992 6992 7012* 7016* 7022* 7023 7023
                                                                                  7023* 7025*
op_chars                        000746 constant        char(4)                  initial array dcl 13180 ref 13204
op_code                                based           fixed bin(17,0)          level 2 in structure "statement" dcl 5-721
                                                                                  in procedure "ext_parse" set ref 1131* 6192*
op_code                         002254 automatic       fixed bin(17,0)          dcl 740 in procedure "parse_source" set ref 3860*
                                                                                  3865* 3870* 3935 4080* 4084* 4108
op_code                         001405 constant        fixed bin(18,0)          initial array dcl 10081 in procedure
                                                                                  "parse_expression" ref 10456 10458
op_code_or_operand                     parameter       fixed bin(18,0)          dcl 9804 ref 9800 9800 9809
op_name                         016341 automatic       fixed bin(17,0)          dcl 8652 set ref 8658* 8667* 8682
op_name_or_opnd_or_data                parameter       fixed bin(18,0)          dcl 6420 ref 6407 6407 6407 6429
opc                             016677 automatic       fixed bin(17,0)          dcl 10060 set ref 10215* 10222* 10239* 10250* 10262*
                                                                                  10285* 10296 10310 10312 10495*
open_op                         003025 constant        fixed bin(18,0)          initial dcl 4-197 set ref 4384*
open_opr                               constant        fixed bin(4,0)           initial dcl 15-19 ref 4364
opened_field                           constant        fixed bin(17,0)          initial dcl 15-50 set ref 4655*
openfile_op                            constant        fixed bin(18,0)          initial dcl 4-197 set ref 4333*
operand_base                    000106 automatic       pointer                  dcl 376 in procedure "ext_parse" set ref 410* 9-24
                                                                                  9-25 8-61 8-63 8-76 8-76 8-80 8-91 1175 1205 1210
                                                                                  1384 1389 1605 1685 1772 1782 1784 1785 1786 1922
                                                                                  1998 2000 2004 2005 2008 2027 2035 2035 2037 2037
                                                                                  2039 2041 2045 2045 2045 2045 2111 2114 2114 2114
                                                                                  2146 2161 2181 2253 2305 2339 2340 2366 2415 2500
                                                                                  2523 2527 2527 2585 2612 2615 2679 2681 2691 2702
                                                                                  2741 2796 2820 2820 2822 2824 2834 2835 2837 2839
                                                                                  2842 2844 2863 2866 2870 2872 2872 2874 2877 2878
                                                                                  2882 2891 2908 2936 2936 2936 3327 3556 3558 3562
                                                                                  3619 3642 3656 3713 3740 4058 4058 4866 4866 4871
                                                                                  4871 4873 4873 4874 4874 4883 4892 4896 4934 4948
                                                                                  4948 4950 4950 4951 4951 4962 4967 4978 5012 5076
                                                                                  5111 5112 5132 5133 5138 5139 5140 5150 5175 5177
                                                                                  5190 5192 5221 5258 5358 5406 5425 5431 5446 5448
                                                                                  5449 5489 5496 5517 5523 5554 5569 5589 5607 5632
                                                                                  5638 5642 5646 5653 5665 5682 5689 5694 5703 5704
                                                                                  5741 5747 5765 5772 5793 5817 5833 5841 5850 5876
                                                                                  5908 5916 5916 5934 5942 5953 6021 6029 6045 6056
                                                                                  6056 6104 6120 6138 6151 6174 6175 6176 6177 6215
                                                                                  6299 6303 6310 6314 6326 6334 6540 6549 6549 6626
                                                                                  6639 6643 6694 6715 6748 6748 6765 6766 6767 6768
                                                                                  6772 6808 6823 6928 6937 6938 6976 7051 7148 7161
                                                                                  7181 7181 7181 7181 7188 7189 7311 7312 7312 7332
                                                                                  7332 7367 7413 7422 7422 7422 7438 7456 7474 7552
                                                                                  7553 7575 7580 7582 7584 7587 7592 7594 7598 7643
                                                                                  7648 7648 7650 7650 7662 7677 7757 7785 7785 7788
                                                                                  7788 7788 7788 7788 7788 7896 8051 8152 8163 8164
                                                                                  8165 8166 8167 8168 8169 8251 8258 8268 8269 8274
                                                                                  8280 8365 8386 8679 8754 8795 8833 8957 8962 8963
                                                                                  8968 8973 8988 9004 9024 9049 9582 9586 9672 9689
                                                                                  9696 9709 9714 9762 9778 9826 9830 9930 10173
                                                                                  10183 10258 10359 10388 10596 10634 10647 10647
                                                                                  10703 10706 10707 10741 11905 12737 12925 12927
                                                                                  12929 12930 12932 13002 13228 13230 13230 13230
                                                                                  13232 13234
operand_base              2            based           pointer                  level 2 in structure "shared_structure" dcl 398
                                                                                  in procedure "ext_parse" set ref 410
operand_max_len          35            based           fixed bin(19,0)          level 2 dcl 398 set ref 9-20 9-29 9-29
operand_type              0(09)        based           fixed bin(4,0)           level 2 in structure "constant" packed packed
                                                                                  unaligned dcl 5-256 in procedure "ext_parse" set
                                                                                  ref 8-82*
operand_type              0(09)        based           fixed bin(4,0)           level 2 in structure "label" packed packed unaligned
                                                                                  dcl 5-530 in procedure "ext_parse" set ref 6765*
operator_follows                017217 automatic       bit(1)                   dcl 10831 set ref 11154* 11168* 11264* 11273 12473*
                                                                                  12480* 12496 12505*
opnd_idx                        013540 automatic       fixed bin(24,0)          dcl 6015 set ref 6028* 6029 6029 6029*
opnd_ptr                        014052 automatic       pointer                  dcl 6961 in procedure
                                                                                  "get_data_statement_expression" set ref 6976* 6977
                                                                                  6978 6981
opnd_ptr                        016612 automatic       pointer                  dcl 9657 in procedure "get_one_bound" set ref 9672*
                                                                                  9673 9673
optimize                 11(01)        based           bit(1)                   level 3 packed packed unaligned dcl 5-753 set ref
                                                                                  8810 8981
option                          017416 automatic       char(32)                 packed unaligned dcl 12167 in procedure "lex_global"
                                                                                  set ref 12171* 12173 12175 12175 12175 12175
                                                                                  12177*
option                                 parameter       char(32)                 packed unaligned dcl 12209 in procedure
                                                                                  "get_next_option" set ref 12205 12217* 12226*
                                                                                  12235* 12241*
option                          017434 automatic       char(32)                 packed unaligned dcl 12187 in procedure
                                                                                  "lex_options" set ref 12191* 12193 12195 12195
                                                                                  12195 12195 12198*
options                  11            based           structure                level 2 in structure "subprogram" dcl 5-753
                                                                                  in procedure "ext_parse" set ref 1222*
options                 113            based           structure                level 2 in structure "shared_structure" dcl 398
                                                                                  in procedure "ext_parse"
options_flag                           parameter       bit(2)                   dcl 11726 set ref 11639 11741 11742 11931 11934
                                                                                  11943 11944* 11962 11963 12153 12153*
orig_stack_index                000124 automatic       fixed bin(18,0)          dcl 7880 set ref 7887* 7900 7904 7914 7916
original                        013346 automatic       pointer                  dcl 4834 set ref 5346* 5352* 5387* 5396
other_segment_info              002256 automatic       structure                level 1 dcl 741 set ref 1593
out                             013241 automatic       bit(36)                  dcl 1087 set ref 3234* 3236 3244* 3245 6971* 6995
                                                                                  8797* 8799* 8804 8832 9000* 9004 9018* 9280* 9282
                                                                                  9313* 9315 9666* 9682 9742* 9757 9758 9784 9784
out_of_sequence                        constant        fixed bin(18,0)          initial dcl 742 ref 11046
output_element                  001560 constant        bit(36)                  initial dcl 1071 ref 9249
p                                      parameter       pointer                  dcl 370 in procedure "ext_parse" ref 54 407
p                               002362 automatic       fixed bin(18,0)          dcl 743 in procedure "parse_source" set ref 8834*
                                                                                  8855* 8855 8865* 8865 8875* 8875 8880* 8880 8883
param_attr                      002650 constant        bit(47)                  initial dcl 744 set ref 7085*
param_conflicts                 002646 constant        bit(47)                  initial dcl 746 set ref 7085*
param_count                     013661 automatic       fixed bin(17,0)          dcl 6235 set ref 6294* 6296* 6309* 6309 6366 6367
                                                                                  6369
param_ptr                       002364 automatic       pointer                  dcl 748 set ref 2500* 2503 2507 2515 2520 2521 2522
                                                                                  2523 2527 2527 2527 2535 2541
param_variable_attrs            002644 constant        bit(47)                  initial dcl 749 set ref 1781* 3835 7135
parameter                              based           structure                level 1 dcl 11-7 in procedure "parse_source"
parameter                11(04)        based           bit(1)                   level 4 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 4996 5023 5059 5073 5122 5633 5742 6048 6128
parameter_info                  013232 automatic       structure                level 1 dcl 883 set ref 2507 2507 7004 7004 8359
                                                                                  8359 9706 9706 9775 9775
parameter_statement                    constant        fixed bin(18,0)          initial dcl 751 ref 11337 11340
paren_array                     002366 automatic       fixed bin(18,0)          array dcl 752 set ref 11354*
paren_count                     003612 automatic       fixed bin(18,0)          dcl 753 set ref 9104 9109 9122* 9138 9145* 9145 9146
                                                                                  9147 9149 9151 9154 9187
paren_info                      012412 automatic       structure                array level 1 dcl 875 set ref 9138 9140
paren_level                     020044 automatic       fixed bin(18,0)          dcl 12901 in procedure "get_next_token" set ref
                                                                                  12962* 12963 12964* 12964 12966* 12966 12968
paren_level                     017220 automatic       fixed bin(18,0)          dcl 10832 in procedure "statement_lex" set ref
                                                                                  10886* 11180 11182 11202 11326 11352* 11352 11354
                                                                                  11362* 11362 11363 11370 11397
parent                    7            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-844
                                                                                  set ref 2041* 2834* 2870 2877* 5432* 5646 5669*
                                                                                  5742 5762 5779* 5785 5802* 5852* 5932 5933 5967*
                                                                                  6056 6056 6056 6176* 6549 6549 6549 7051* 7422
                                                                                  7788 7788 7788 10647 10647 10647
parm                      3     000122 automatic       fixed bin(24,0)          level 2 dcl 383 set ref 433* 435* 6128 6132
parse_ptr                       000100 automatic       pointer                  dcl 372 set ref 406* 423 1595 2612 2615
parse_structure                        based           structure                level 1 dcl 395
partial_offset                  014161 automatic       fixed bin(18,0)          dcl 7262 set ref 7448* 7463 7466 7498* 7498 7509
                                                                                  7509*
passed_as_arg             0(03)        based           bit(1)                   level 4 in structure "expression" packed packed
                                                                                  unaligned dcl 1034 in procedure "parse_source" set
                                                                                  ref 10173 10185 10396 10510* 10584*
passed_as_arg             0(28)        based           bit(1)                   level 4 in structure "constant" packed packed
                                                                                  unaligned dcl 5-256 in procedure "ext_parse" set
                                                                                  ref 10173*
passed_as_arg             0(28)        based           bit(1)                   level 5 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 4866 5023 5037 5044
pathname                  5            based           varying char(256)        level 2 dcl 5-693 set ref 1177* 1179* 1179 1180*
                                                                                  1180 11907* 11909*
pause_op                               constant        fixed bin(18,0)          initial dcl 4-197 ref 4084
pending_entry                   003613 automatic       structure                array level 1 dcl 754 set ref 7166 7171 7171
pending_entry_cnt               003613 automatic       fixed bin(17,0)          dcl 757 set ref 1279* 1374 1529 2901 4065 6186* 6260
                                                                                  6400 6404* 7166 7167* 7167 7168 7169
pending_entry_idx               013662 automatic       fixed bin(17,0)          dcl 6235 set ref 6260* 6261 6269 6279 6389*
penultimate_token_type          017221 automatic       bit(9)                   dcl 10833 set ref 10889* 10964* 11182 11182
percent_index                   017406 automatic       fixed bin(18,0)          dcl 11727 set ref 11802* 11804 11804 11807 11807
                                                                                  11807 11812 11931 11941 12169 12189
percent_line_flag               017222 automatic       bit(2)                   dcl 10834 set ref 11062* 11069* 11069 11079*
plus                                   constant        bit(9)                   initial dcl 4-156 ref 7955 10135 10680 11306
polish_base                     000104 automatic       pointer                  dcl 375 in procedure "ext_parse" set ref 409* 2284
                                                                                  2414 2435 2435 3199 3371 3804 4249 4468 4469 4470
                                                                                  4471 4566 4567 4568 4569 4709 4710 4711 4896 5050
                                                                                  5104 5105 6026 6028 6344 6352 6352 6367 6429 6440
                                                                                  6456 6461 6473 6476 6477 6514 6974 6984 7007 7022
                                                                                  7460 7471 7487 7502 7654 7757 7759 7759 7762 7766
                                                                                  7766 7769 7769 7771 7775 7778 7851 7853 7853 8032
                                                                                  8034 8035 8036 8053 8188 8966 8968 8970 8973 9423
                                                                                  9670 9672 9677 9677 9690 9696 9714 9762 10595
                                                                                  10605
polish_base                            based           pointer                  level 2 in structure "shared_structure" dcl 398
                                                                                  in procedure "ext_parse" set ref 409
polish_idx                      014054 automatic       fixed bin(18,0)          dcl 6961 in procedure
                                                                                  "get_data_statement_expression" set ref 6973* 6974
                                                                                  6984* 7021* 7022*
polish_idx                      016614 automatic       fixed bin(18,0)          dcl 9657 in procedure "get_one_bound" set ref 9669*
                                                                                  9670 9672 9677 9677*
polish_idx                      013663 automatic       fixed bin(17,0)          dcl 6235 in procedure "process_pending_entries" set
                                                                                  ref 6350* 6352*
polish_idx                      013541 automatic       fixed bin(18,0)          dcl 6015 in procedure "validate_array_bound" set ref
                                                                                  6027* 6028*
polish_max_len                  000120 automatic       fixed bin(19,0)          dcl 381 in procedure "ext_parse" set ref 419* 6346
                                                                                  6346 6346 6425 6425 6425 6436 6436 6436 6452 6452
                                                                                  6452 6470 6470 6470
polish_max_len           34            based           fixed bin(19,0)          level 2 in structure "shared_structure" dcl 398
                                                                                  in procedure "ext_parse" set ref 419
polish_string                          based           fixed bin(19,0)          array dcl 374 set ref 2284* 2414* 2435* 2435 3199*
                                                                                  3371* 3804* 4249* 4468* 4469* 4470* 4471* 4566*
                                                                                  4567* 4568* 4569* 4709* 4710* 4711* 4896 5050
                                                                                  5104* 5105* 6026 6028 6344 6352* 6352 6367* 6429*
                                                                                  6440* 6456 6461 6473* 6476* 6477* 6514 6974 6984*
                                                                                  7007* 7022 7460 7471 7487 7502 7654 7757 7759*
                                                                                  7759 7762* 7766 7766 7769* 7769 7771* 7775* 7778*
                                                                                  7851 7853* 7853 8032 8034* 8035* 8036* 8053* 8188*
                                                                                  8966 8968 8970 8973 9423* 9670 9672 9677 9677
                                                                                  9690* 9696 9714 9762 10595 10605*
pop_stack                       016700 automatic       bit(1)                   dcl 10061 set ref 10451* 10452 10461* 10467*
position                  1     012412 automatic       fixed bin(18,0)          array level 2 dcl 875 set ref 3597* 3773 9110 9127*
                                                                                  9149* 9302* 9325
prec                            011016 automatic       fixed bin(8,0)           array level 2 packed packed unaligned dcl 853 set
                                                                                  ref 12518* 12791 13066
precision                       017223 automatic       fixed bin(18,0)          dcl 10835 set ref 11151* 11153 11166* 11260* 11260
                                                                                  11290 11294 11299 11300 12518
prev_LA_hdrp                    013350 automatic       pointer                  dcl 4835 set ref 5761* 5783* 5789 5791 5829* 5863*
                                                                                  5866 5868
prev_common_hdrp                013352 automatic       pointer                  dcl 4836 set ref 5551* 5560 5562 5573* 5576 5578
prev_equiv_hdrp                 013354 automatic       pointer                  dcl 4837 set ref 5586* 5598 5600 5611* 5615* 5617
                                                                                  5619 5814* 5825 5827 5881* 5885* 5887 5889
previous                        016434 automatic       fixed bin(18,0)          dcl 9096 set ref 9165* 9174
previous_subprogram       1            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-753
                                                                                  set ref 1209*
print_message          1530            based           entry variable           level 2 dcl 398 set ref 9-29 8-45 1193 1408 1410
                                                                                  1428 1453 1457 1461 1465 1469 1473 1477 1481 1484
                                                                                  1488 1492 1497 1538 1543 1668 1849 1861 1870 1875
                                                                                  1884 1922 2027 2050 2054 2098 2111 2134 2144 2146
                                                                                  2159 2161 2179 2181 2253 2273 2305 2312 2320 2331
                                                                                  2366 2370 2373 2408 2431 2484 2571 2608 2618 2635
                                                                                  2642 2655 2702 2706 2727 2741 2745 2830 2867 2886
                                                                                  3017 3055 3073 3091 3094 3105 3108 3112 3123 3170
                                                                                  3174 3177 3182 3215 3236 3245 3276 3299 3368 3435
                                                                                  3530 3546 3556 3558 3562 3607 3634 3638 3660 3664
                                                                                  3674 3685 3692 3705 3716 3720 3744 3748 3821 3826
                                                                                  3927 4005 4044 4058 4091 4131 4136 4219 4460 4558
                                                                                  4698 4700 4726 4759 4775 4777 4784 4866 4885 4888
                                                                                  5012 5023 5073 5125 5186 5195 5201 5208 5217 5229
                                                                                  5234 5295 5304 5330 5335 5379 5398 5505 5537 5918
                                                                                  5927 5944 5999 6048 6136 6167 6346 6425 6436 6452
                                                                                  6470 6496 6508 6614 6683 6686 6695 6701 6707 6709
                                                                                  6716 6724 6818 6826 6852 6860 6867 6897 6904 6907
                                                                                  7012 7014 7016 7054 7085 7158 7171 7185 7287 7313
                                                                                  7348 7353 7371 7375 7381 7385 7407 7426 7434 7477
                                                                                  7482 7490 7523 7536 7583 7598 7613 7651 7656 7673
                                                                                  7691 7700 7827 7919 7923 7927 7931 7982 7995 8003
                                                                                  8007 8087 8096 8109 8128 8322 8327 8341 8345 8381
                                                                                  8386 8393 8398 8571 8574 8577 8580 8587 8589 8654
                                                                                  8663 8691 8726 8738 8740 8749 8778 8780 8804 8817
                                                                                  8838 8906 8940 9004 9036 9114 9140 9161 9206 9213
                                                                                  9255 9260 9282 9336 9356 9476 9495 9504 9522 9544
                                                                                  9571 9599 9608 9623 9806 9973 10121 10125 10129
                                                                                  10156 10202 10231 10246 10258 10271 10277 10299
                                                                                  10384 10388 10396 10399 10407 10411 10422 10431
                                                                                  10437 10441 10491 10501 10518 10537 10544 10554
                                                                                  10601 10899 10913 10947 10958 10971 11081 11109
                                                                                  11112 11146 11220 11234 11237 11282 11292 11600
                                                                                  11617 11815 11822 11831 11841 11850 11856 11871
                                                                                  11882 11936 11945* 11964* 11995 12067 12074 12086
                                                                                  12146 12175* 12195* 12277 12281 12289 12306 12405
                                                                                  12410 12417 12427 12511 12529 12573 12626 12635
                                                                                  12652 12708 12723 12741 12815 12835 12848 12850
                                                                                  12857 12859 12868 12870 13002 13050 13078 13101
                                                                                  13146 13156 13230
process_param_list_op                  constant        fixed bin(18,0)          initial dcl 4-197 set ref 6370*
produce_listing                 003614 automatic       bit(1)                   dcl 758 set ref 1125* 1230 1387 1581 2016 6646 6668
                                                                                  8253 8283 8970 9849 11793
profile_size             55            based           fixed bin(17,0)          level 2 dcl 398 set ref 1108* 1550* 1550 2785* 2785
                                                                                  2927* 2927 2996* 2996 3083* 3083 3164* 3164 3211*
                                                                                  3211 3291* 3291 3403* 3403 3419* 3419 3817* 3817
                                                                                  3875* 3875 3948* 3948 3967* 3967 4020* 4020 4087*
                                                                                  4087 4120* 4120 4157* 4157 4181* 4181 4190* 4190
                                                                                  4268* 4268 4287* 4287 4311* 4311 4355* 4355 4491*
                                                                                  4491 4588* 4588 4722* 4722
prompt_field                           constant        fixed bin(17,0)          initial dcl 15-50 set ref 4437*
put_in_map                3            based           bit(1)                   level 3 in structure "statement" packed packed
                                                                                  unaligned dcl 5-721 in procedure "ext_parse" set
                                                                                  ref 6195*
put_in_map                             constant        bit(9)                   initial dcl 759 in procedure "parse_source" ref 1639
                                                                                  1702 1734 4037
put_in_profile                         constant        bit(9)                   initial dcl 760 ref 1551 2786 2929 2998 3084 3167
                                                                                  3213 3293 3405 3421 3819 3877 3950 3970 4022 4089
                                                                                  4122 4159 4183 4192 4270 4289 4313 4357 4493 4590
                                                                                  4724
put_in_symtab             0(34)        based           bit(1)                   level 3 packed packed unaligned dcl 5-844 set ref
                                                                                  8968*
q                                      parameter       pointer                  dcl 371 ref 54 406
quote                           001274 constant        char(1)                  initial dcl 10836 set ref 11409*
quoted_string                          constant        fixed bin(17,0)          initial dcl 13-78 ref 8121
r_significant_digits            020015 automatic       fixed bin(18,0)          dcl 12779 in procedure "convert_real_constant" set
                                                                                  ref 12797* 12799* 12808* 12814 12822 12822
r_significant_digits            020045 automatic       fixed bin(18,0)          dcl 12902 in procedure "get_next_token" set ref
                                                                                  13071* 13073* 13075 13084*
rc_t                                   constant        bit(6)                   initial packed unaligned dcl 10-6 ref 8-84
rd_sw                                  parameter       bit(1)                   dcl 8435 in procedure "parse_implied_io" ref 8422
                                                                                  8442
rd_sw                                  parameter       bit(1)                   dcl 8482 in procedure "parse_io" ref 8469 8488
rdigits                         020046 automatic       fixed bin(18,0)          dcl 12903 in procedure "get_next_token" set ref
                                                                                  13065* 13066 13071 13071 13084*
rdigits                         020016 automatic       fixed bin(18,0)          dcl 12780 in procedure "convert_real_constant" set
                                                                                  ref 12790* 12791 12797 12797 12806* 12822 12822
rdigits_parm                           parameter       fixed bin(18,0)          dcl 12781 ref 12803 12806
read                      0(02) 013240 automatic       bit(1)                   level 3 packed packed unaligned dcl 885 set ref
                                                                                  3979* 8442* 8488* 8577 8580 8634 8797 8812 8902
                                                                                  8935 8973 8983 9049 9243
read_internal_file_op                  constant        fixed bin(18,0)          initial dcl 4-197 set ref 8902*
read_namelist_op                       constant        fixed bin(18,0)          initial dcl 4-197 set ref 8983*
read_op                                constant        fixed bin(18,0)          initial dcl 4-197 set ref 9244*
real_bits                       020020 automatic       bit(72)                  dcl 12783 set ref 12862 12862 12864 12873 12873
                                                                                  12875
real_const                             constant        bit(9)                   initial dcl 4-156 ref 10690 10722 11152 11255 12454
                                                                                  13198
real_flt_dec_extended_dtype            constant        fixed bin(17,0)          initial dcl 7-25 ref 12862 12873
real_mode                       003301 constant        fixed bin(4,0)           initial dcl 4-106 set ref 1259 1260 1267 1268 7689
                                                                                  7714 7723 8391 8395 10707 10731 10737 10745 12749
                                                                                  12752* 12759 12762 13085 13087*
real_statement                  013356 automatic       fixed bin(18,0)          dcl 4838 set ref 4857* 5476
rec_field                              constant        fixed bin(17,0)          initial dcl 15-50 ref 8574 8778 8782
recl_field                             constant        fixed bin(17,0)          initial dcl 15-50 set ref 4431* 4646*
record_number_op                       constant        fixed bin(18,0)          initial dcl 4-197 set ref 8786*
referenced                0(27)        based           bit(1)                   level 5 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 1922 2027 2111 2253 2305 2366 2702 2741 2863
                                                                                  5023 8988* 9972
referenced                0(27)        based           bit(1)                   level 5 in structure "label" packed packed unaligned
                                                                                  dcl 5-530 in procedure "ext_parse" set ref 1389
                                                                                  4885
referenced_executable
                          0(29)        based           bit(1)                   level 4 packed packed unaligned dcl 5-530 set ref
                                                                                  4888
rel_constant                           constant        fixed bin(4,0)           initial dcl 4-120 ref 6765
reloc                     2(12)        based           bit(6)                   level 2 packed packed unaligned dcl 5-256 set ref
                                                                                  8-84*
rep_count                              parameter       fixed bin(18,0)          dcl 8025 set ref 8019 8035 8047*
reset_arg_bit             0(06)        based           bit(1)                   level 2 packed packed unaligned dcl 1034 ref 10510
reset_stack                            based           bit(36)                  array dcl 761 set ref 1611*
rest_of_line                           based           char                     level 2 packed packed unaligned dcl 10850 set ref
                                                                                  11124 11128 11227 11502 11535 11541 11542 11571
                                                                                  11578 11625 11630 11802 11804 11807 11807 11814
                                                                                  11819 11821 11826 11828 11831 11831 11835 11931
                                                                                  11941 11990 11993 11995 12002 12002 12002 12002
                                                                                  12007 12010 12010 12012 12012 12012 12017 12029
                                                                                  12030 12039 12040 12044 12062 12064 12067* 12074
                                                                                  12074 12082 12100 12102 12102 12104 12109 12116
                                                                                  12127 12127 12132 12143 12159 12215 12218 12225
                                                                                  12227 12231 12232 12239 12241 12264 12350 12354
                                                                                  12390 12394 12564 12582 12605
rest_of_text                           based           char                     level 2 packed packed unaligned dcl 10854 ref 11788
restore_prs               0(32)        based           bit(1)                   level 3 packed packed unaligned dcl 5-530 set ref
                                                                                  8679*
result_location           2(15) 013232 automatic       fixed bin(18,0)          level 2 packed packed unaligned dcl 883 set ref 2521
                                                                                  2523 2527 2527 2535 7007 8364 9709 9778
return_bits                            parameter       bit(36)                  dcl 10062 set ref 9990 10571*
return_op                              constant        fixed bin(18,0)          initial dcl 4-197 set ref 6491*
return_value                    003615 automatic       fixed bin(18,0)          dcl 762 set ref 1754* 1766* 1782 1784 4055* 4058
                                                                                  4866 4866 4866* 4869* 4871 4873 4874 4948 4950
                                                                                  4951 5122 5138 5140 6488* 10358
return_value_param              003616 automatic       fixed bin(18,0)          dcl 763 set ref 1719* 1781* 1785 3835 3835* 3839*
                                                                                  4871 4873 4874 5135 6199* 6294 6377 6378* 6487*
                                                                                  7125* 7135 7135* 7139*
returned_index                  016266 automatic       fixed bin(18,0)          dcl 8213 set ref 8244* 8249 8251 8253* 8257 8258*
                                                                                  8258 8259 8264 8266* 8268 8269 8272 8274 8276 8278
                                                                                  8280 8283* 8287
rewind_op                              constant        fixed bin(18,0)          initial dcl 4-197 ref 3860
rewind_opr                             constant        fixed bin(4,0)           initial dcl 15-19 ref 3862
right_parn                             constant        bit(9)                   initial dcl 4-156 ref 1309 1492 1897 2097 2165 2185
                                                                                  2204 2336 2553 2805 2852 2947 3008 3332 3354 3594
                                                                                  3671 3725 3733 3925 4458 4556 4695 6890 7067 7109
                                                                                  8371 8545 8592 8620 8644 9159 9298 9427 9563 10319
                                                                                  10332 10472 10481 10486 10524 10535 11328 11328
                                                                                  11358 11397 12966
rounding                  0(10) 013232 automatic       bit(1)                   level 2 packed packed unaligned dcl 883 set ref
                                                                                  2505* 6999* 8357* 9704* 9773*
rprec                           001450 constant        fixed bin(18,0)          initial array dcl 10079 ref 10449
rsd_parm                               parameter       fixed bin(18,0)          dcl 12782 ref 12803 12808
rtrim                                                  builtin function         dcl 765 ref 11893 11907 11907 11909 11909 12797
                                                                                  12822 13071
runtime_format                         based           structure                level 1 dcl 13-32
save_attributes                 002642 constant        bit(47)                  initial dcl 766 set ref 2706*
save_conflicts                  002640 constant        bit(47)                  initial dcl 768 set ref 2706* 2745*
save_current_token              003617 automatic       fixed bin(18,0)          dcl 770 set ref 3522* 3599 9275* 9303
save_index                             parameter       fixed bin(18,0)          dcl 10063 ref 9990 10094
saved_number_of_crefs           003620 automatic       fixed bin(18,0)          dcl 771 set ref 2775* 2905
saved_polish                    016414 automatic       fixed bin(18,0)          dcl 8933 set ref 9016* 9019 9022
saved_stack_index               014075 automatic       fixed bin(18,0)          dcl 7047 set ref 7063* 7152 7162
scalar_conflicts                002636 constant        bit(47)                  initial dcl 772 ref 3558 10207 10362
scale                     0(09) 011016 automatic       fixed bin(8,0)           array level 2 packed packed unaligned dcl 853 set
                                                                                  ref 12519* 12790 13065
search                                                 builtin function         dcl 774 ref 11826 12231
seg_chain_end_ptr               003624 automatic       pointer                  dcl 776 set ref 1175* 11903 11905*
seg_ptr                         003622 automatic       pointer                  dcl 775 set ref 1171 1175* 1177 1179 1179 1180 1180
                                                                                  1184 1185 1216 1216 11771* 11860 11905* 11907
                                                                                  11909 11912 11913 11914
segment_declared                000134 automatic       structure                level 1 dcl 392 set ref 11744* 11945 11945 11948*
                                                                                  11948 11950 11950 11954 11964 11964 11967* 11967
                                                                                  11969 11969 11973 12175 12175
segment_options                 000130 automatic       structure                level 1 dcl 390 set ref 11743* 11746 11950 11950
                                                                                  11951 11953 11969 11969 11970 11972 12195 12195
segname                  65            based           varying char(32)         level 2 dcl 14-6 ref 1155 1157 1178 1180
sequential_access                      constant        bit(2)                   initial dcl 15-8 ref 8580 8634
sequential_field                       constant        fixed bin(17,0)          initial dcl 15-50 set ref 4667*
set                       0(26)        based           bit(1)                   level 5 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-844 in procedure "ext_parse" set
                                                                                  ref 4866 4894 4899* 5023 5037 5044 8973* 9049*
set                       0(26)        based           bit(1)                   level 5 in structure "label" packed packed unaligned
                                                                                  dcl 5-530 in procedure "ext_parse" set ref 4885
                                                                                  6683 6705
set                       0(01)        based           bit(1)                   level 4 in structure "expression" packed packed
                                                                                  unaligned dcl 1034 in procedure "parse_source" ref
                                                                                  10125 10156 10231 10246 10258 10277 10441
set_attributes                         parameter       bit(1)                   packed unaligned dcl 9868 ref 9858 9979
set_no_symbol_bits              002622 constant        bit(36)                  initial dcl 1071 set ref 6971* 9666* 9742* 10095
set_reference                          constant        bit(36)                  initial dcl 1071 set ref 2946* 2957* 4144* 4640*
                                                                                  4643* 4646* 4649* 4652* 4655* 4658* 4661* 4664*
                                                                                  4667* 4670* 4673* 4676* 4679* 4740* 8700* 9280*
set_storage                     016701 automatic       bit(1)                   dcl 10064 set ref 10095* 10207 10267 10353 10612
                                                                                  10635
sf_def_op                              constant        fixed bin(18,0)          initial dcl 4-197 set ref 2800*
sf_op                                  constant        fixed bin(18,0)          initial dcl 4-197 ref 10250
shared_pointer            4     013232 automatic       pointer                  level 2 dcl 883 set ref 1126*
shared_ptr                      000102 automatic       pointer                  dcl 373 set ref 407* 409 410 411 413 414 415 416 419
                                                                                  420 429 433 437 441 9-20 9-20 9-22 9-23 9-23 9-29
                                                                                  9-29 9-29 8-45 8-87 8-87 8-89 8-89 8-91 8-93 1104
                                                                                  1105 1106 1108 1109 1115 1123 1124 1125 1126 1142
                                                                                  1142 1149 1149 1151 1153 1153 1165 1165 1166 1166
                                                                                  1167 1167 1169 1193 1204 1205 1207 1209 1210 1210
                                                                                  1212 1212 1214 1214 1216 1221 1231 1231 1234 1234
                                                                                  1236 1237 1237 1237 1239 1239 1241 1241 1242 1343
                                                                                  1344 1344 1389 1389 1392 1392 1408 1410 1428 1453
                                                                                  1457 1461 1465 1469 1473 1477 1481 1484 1488 1492
                                                                                  1497 1525 1538 1543 1550 1550 1565 1573 1582 1582
                                                                                  1583 1605 1605 1668 1668 1670 1670 1849 1861 1870
                                                                                  1875 1884 1922 2027 2050 2054 2098 2102 2111 2134
                                                                                  2144 2146 2159 2161 2179 2181 2253 2273 2284 2305
                                                                                  2312 2320 2331 2366 2370 2373 2405 2405 2406 2408
                                                                                  2431 2476 2484 2504 2527 2547 2571 2608 2612 2618
                                                                                  2635 2642 2655 2702 2706 2727 2741 2745 2775 2785
                                                                                  2785 2796 2830 2867 2882 2886 2905 2927 2927 2996
                                                                                  2996 3017 3055 3073 3083 3083 3091 3094 3105 3108
                                                                                  3112 3123 3164 3164 3170 3174 3177 3182 3211 3211
                                                                                  3215 3236 3245 3276 3291 3291 3299 3368 3403 3403
                                                                                  3419 3419 3435 3530 3546 3556 3558 3562 3607 3634
                                                                                  3638 3660 3664 3674 3685 3692 3705 3716 3720 3744
                                                                                  3748 3804 3817 3817 3821 3826 3875 3875 3927 3948
                                                                                  3948 3967 3967 4005 4020 4020 4044 4058 4087 4087
                                                                                  4091 4101 4105 4120 4120 4131 4136 4157 4157 4161
                                                                                  4181 4181 4190 4190 4219 4228 4228 4268 4268 4287
                                                                                  4287 4311 4311 4331 4331 4355 4355 4382 4460 4491
                                                                                  4491 4518 4558 4588 4588 4613 4698 4700 4722 4722
                                                                                  4726 4759 4775 4777 4784 4857 4858 4866 4885 4888
                                                                                  4976 4976 4978 4981 5012 5023 5073 5125 5186 5195
                                                                                  5201 5208 5217 5229 5234 5251 5295 5304 5330 5335
                                                                                  5379 5398 5455 5455 5476 5505 5537 5858 5858 5918
                                                                                  5927 5944 5999 6048 6136 6167 6167 6167 6176 6257
                                                                                  6257 6280 6346 6346 6352 6353 6353 6390 6401 6425
                                                                                  6425 6429 6430 6430 6436 6436 6440 6441 6442 6442
                                                                                  6450 6452 6452 6455 6455 6456 6459 6459 6461 6464
                                                                                  6470 6470 6473 6476 6477 6479 6479 6496 6508 6508
                                                                                  6511 6511 6512 6514 6514 6514 6516 6516 6614 6683
                                                                                  6686 6695 6701 6707 6709 6716 6724 6818 6826 6852
                                                                                  6860 6867 6897 6904 6907 6969 6973 6995 7001 7008
                                                                                  7012 7014 7016 7018 7020 7021 7028 7051 7054 7085
                                                                                  7158 7171 7185 7287 7313 7348 7353 7371 7375 7381
                                                                                  7385 7407 7426 7434 7477 7482 7490 7523 7536 7583
                                                                                  7590 7590 7595 7595 7598 7613 7651 7656 7673 7689
                                                                                  7691 7698 7700 7714 7723 7738 7827 7906 7919 7923
                                                                                  7927 7931 7982 7995 8003 8007 8045 8087 8096 8109
                                                                                  8128 8179 8179 8184 8184 8188 8322 8327 8341 8345
                                                                                  8350 8356 8361 8381 8386 8393 8398 8571 8574 8577
                                                                                  8580 8587 8589 8654 8663 8691 8726 8738 8740 8749
                                                                                  8778 8780 8804 8817 8838 8906 8940 8992 9004 9016
                                                                                  9019 9022 9036 9114 9140 9161 9206 9213 9255 9260
                                                                                  9282 9336 9356 9476 9495 9504 9522 9544 9571 9599
                                                                                  9608 9623 9663 9665 9669 9683 9685 9690 9694 9696
                                                                                  9703 9711 9715 9740 9766 9772 9796 9806 9973 10121
                                                                                  10125 10129 10156 10202 10231 10246 10258 10271
                                                                                  10277 10299 10384 10388 10396 10399 10407 10411
                                                                                  10422 10431 10437 10441 10491 10501 10518 10537
                                                                                  10544 10554 10601 10731 10737 10745 10868 10868
                                                                                  10899 10907 10907 10913 10947 10958 10971 11063
                                                                                  11071 11081 11109 11112 11146 11220 11234 11237
                                                                                  11282 11292 11600 11617 11738 11743 11775 11776
                                                                                  11784 11784 11794 11795 11796 11797 11811 11815
                                                                                  11822 11831 11841 11848 11850 11856 11871 11877
                                                                                  11877 11882 11899 11899 11914 11919 11920 11920
                                                                                  11924 11924 11925 11925 11926 11926 11933 11936
                                                                                  11945 11945 11945 11948 11951 11954 11955 11955
                                                                                  11957 11964 11964 11964 11967 11970 11973 11974
                                                                                  11974 11987 11995 12067 12074 12086 12091 12096
                                                                                  12146 12160 12175 12195 12277 12281 12289 12292
                                                                                  12305 12306 12307 12405 12410 12417 12427 12511
                                                                                  12529 12573 12626 12635 12652 12708 12723 12741
                                                                                  12749 12754 12759 12762 12815 12835 12848 12850
                                                                                  12856 12857 12859 12868 12870 13002 13013 13021
                                                                                  13050 13078 13085 13101 13146 13156 13226 13230
shared_structure                       based           structure                level 1 dcl 398 set ref 11955 11955 11974 11974
sign                            003626 automatic       bit(9)                   dcl 777 set ref 1121* 7956* 7963 7964* 7969* 8002
                                                                                  8010 8013* 10719* 10745 10750* 12716 12719*
sign_char                       016753 automatic       bit(9)                   array level 2 dcl 10667 set ref 10681* 10684* 10719
simple_reference                       constant        bit(36)                  initial dcl 1071 set ref 3234* 3244*
size                                                   builtin function         dcl 8-33 in procedure "create_constant" ref 8-74
                                                                                  8-74
size                      2     016527 automatic       fixed bin(24,0)          array level 2 in structure "bounds" dcl 9464
                                                                                  in procedure "get_bounds" set ref 9549*
size                                                   builtin function         dcl 778 in procedure "parse_source" ref 754 788 1162
                                                                                  1204 1204 1237 5455 5652 5652 5788 5788 5858 5952
                                                                                  5952 6188 6191 6192 6193 6194 6195 6214 6214 6257
                                                                                  6279 6389 6400 6452 6459 6763 6763 7147 7147 7169
                                                                                  8162 8162 8266 8266 9825 9825 10868 11902
size                                                   builtin function         dcl 9459 in procedure "get_bounds" ref 9581 9581
size                            016276 automatic       fixed bin(9,0)           dcl 8309 in procedure "get_mode_size" set ref 8320*
                                                                                  8322 8322 8322 8365* 8367* 8380 8382* 8384 8388*
                                                                                  8392 8393 8393 8393 8398 8398 8398 8405* 8414 8415
size                      7            based           fixed bin(24,0)          array level 3 in structure "dimension" dcl 5-383
                                                                                  in procedure "ext_parse" set ref 6916 7341 8166*
                                                                                  8842
slash                                  constant        bit(9)                   initial dcl 4-156 ref 1958 1970 2066 2072 2276 2393
                                                                                  2422 2442 2670 2695 3791 7519 7826 11377
slave                                  based           structure                level 1 unaligned dcl 13222
slave_index                     020103 automatic       fixed bin(18,0)          dcl 13224 set ref 13228* 13229 13230 13230 13232*
                                                                                  13232
source                                 based           structure                level 1 dcl 5-693 set ref 1162 11902
source_file_number     3142            based           fixed bin(35,0)          level 2 dcl 398 set ref 1142* 11776* 11920*
source_format             0(03) 000132 automatic       structure                level 2 in structure "subr_options" packed packed
                                                                                  unaligned dcl 391 in procedure "ext_parse"
source_format           113(03)        based           structure                level 4 in structure "shared_structure" packed
                                                                                  packed unaligned dcl 398 in procedure "ext_parse"
source_id                 2            based           structure                level 2 packed packed unaligned dcl 5-721
source_info                     003630 automatic       pointer                  dcl 779 set ref 1138* 1139 1145 1155 1155 1157 1157
                                                                                  1177 1178 1180 1184 1185 1593* 1595* 1597 1599
source_info_ptr                        based           pointer                  level 2 dcl 395 set ref 423*
source_len                      003632 automatic       fixed bin(21,0)          dcl 780 set ref 1145* 1166 11761 11774* 11788 11789
                                                                                  11863 11918* 11925
source_line_base         16            based           pointer                  level 2 in structure "shared_structure" dcl 398
                                                                                  in procedure "ext_parse" set ref 415
source_line_base                000114 automatic       pointer                  dcl 379 in procedure "ext_parse" set ref 415* 11794
                                                                                  11795 11796 11797
source_line_number     3143            based           fixed bin(35,0)          level 2 dcl 398 set ref 1142* 11063* 11775* 11811*
                                                                                  11919* 11933* 11957* 11987* 12091* 12096* 12292
                                                                                  12305* 12307*
source_list                            based           structure                array level 1 dcl 6-31
source_node                            constant        fixed bin(4,0)           initial dcl 4-87 set ref 1162* 11902*
source_node_offset      117            based           fixed bin(18,0)          array level 4 dcl 398 set ref 1165* 11924*
source_ptr                      003634 automatic       pointer                  dcl 781 set ref 1139* 1143 1167 1597* 1599* 11124
                                                                                  11128 11227 11502 11535 11541 11542 11571 11578
                                                                                  11625 11630 11772* 11788 11802 11804 11807 11807
                                                                                  11814 11819 11821 11826 11828 11831 11831 11835
                                                                                  11837* 11861 11916* 11926 11931 11941 11990 11993
                                                                                  11995 12002 12002 12002 12002 12007 12010 12010
                                                                                  12012 12012 12012 12017 12029 12030 12039 12040
                                                                                  12044 12062 12064 12067 12074 12074 12082 12100
                                                                                  12102 12102 12104 12109 12116 12127 12127 12132
                                                                                  12143 12159 12215 12218 12225 12227 12231 12232
                                                                                  12239 12241 12264 12350 12354 12390 12394 12564
                                                                                  12582 12605
sp                              014012 automatic       pointer                  dcl 6802 in procedure "get_constant_offset" set ref
                                                                                  6808* 6817 6823 6825
sp                              016624 automatic       pointer                  dcl 9729 in procedure "get_integer_constant" set ref
                                                                                  9762* 9766 9766
sp                              013566 automatic       pointer                  dcl 6096 in procedure "set_data_fields" set ref
                                                                                  6104* 6105 6108 6108 6110 6113 6113 6114 6116 6116
                                                                                  6119 6119 6119 6120 6124 6126 6128 6130 6136 6138
sp                              013360 automatic       pointer                  dcl 4839 in procedure "declaration_processor" set
                                                                                  ref 4892* 4894 4896 4899 5190* 5195 5201 5206 5206
                                                                                  5213 5215 5215 5221 5223 5238 5281* 5293 5314 5321
                                                                                  5322* 5334 5346 5351 5386 5413 5413 5416 5418 5425
                                                                                  5426 5430 5438 5443 5449 5454
sp                              016702 automatic       pointer                  dcl 10065 in procedure "parse_expression" set ref
                                                                                  10161* 10162 10162 10183* 10185 10185 10202 10207
                                                                                  10207 10218 10227 10227 10234 10242 10266 10267
                                                                                  10267 10280 10356 10356 10359* 10362 10365 10371
                                                                                  10371 10375 10378 10378 10378 10388 10393 10393
                                                                                  10399 10404 10404 10404 10498 10596* 10634* 10646
                                                                                  10646 10647 10647 10647 10647
sp                              016524 automatic       pointer                  dcl 9461 in procedure "get_bounds" set ref 9586*
                                                                                  9587 9588
sp                              013600 automatic       pointer                  dcl 6148 in procedure "assign_data_type" set ref
                                                                                  6151* 6152 6155 6155 6155
sp_header_length                013362 automatic       fixed bin(24,0)          dcl 4840 set ref 5413* 5416* 5418* 5420
sp_op_name                      001014 constant        char(8)                  initial array dcl 12381 ref 12416 12421 12423 12423
                                                                    