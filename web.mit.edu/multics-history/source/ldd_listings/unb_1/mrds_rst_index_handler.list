	COMPILATION LISTING OF SEGMENT mrds_rst_index_handler
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1343.0 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(86-04-03,Spitzer), approve(86-04-03,MCR7311),
       13*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
       14*     remove unused dcls.
       15*                                                   END HISTORY COMMENTS */
       16 
       17 
       18 /* HISTORY:
       19*
       20*   originally written by jim gray - - october 1978
       21*   Modified November 1978, by Roger Lackey to  add define & cmdb section.
       22*
       23*   81-05-18 Jim Gray : added check for number of indexed attributes
       24*   exceeding the capabilities of the rel_id field used in the vfile
       25*   key for secondary indexes.
       26*
       27*   83-01-11 Ron Harvey : changed to zero out the index_id field and to set
       28*   set max_attr_index_id field to beyond the maximum.
       29*
       30*   83-02-17 Davids: explicitly declared variables that were declared by
       31*   context or implication and deleted declarations to variables that were
       32*   not referenced.
       33**/
       34 
       35 
       36 mrds_rst_index_handler: procedure (rsc_ptr, list_ptr);
       37 
       38 /* DESCRIPTION:
       39*
       40*   this routine builds/alters the mrds database model index information
       41*   and the global entity lists maintained by RMDB/CMDB,
       42*   based upon the index data and directive that is active when
       43*   called by the RMDB/CMDB parser.
       44*   the directive may be undefine, define, redefine, or cmdb and the data is a linked list of
       45*   structures holding the index information and its attribute list
       46*
       47**/
       48 
       49 /* PARAMETERS:
       50*
       51*   rsc_ptr - - (input) pointer to the common control segment
       52*
       53*   list_ptr - - (input) pointer to the relation structure headed list of attribute structures
       54*
       55*   database model - - (output) updated model with altered index information
       56*
       57*   global lists - - (output) the list of database entities, updated
       58*   according to directive and data
       59*
       60*   error_output - - (output) via mrds_rst_error calls, of error messages
       61*
       62**/
       63 
       64 /* REMAINING ERRORS:
       65*
       66*
       67*   define, cmdb:
       68*
       69*   the index name may be the <error_symbol>(this may be ignored)
       70*   one of the attribute names may be the <error_symbol>(this may be ignored)
       71*   the index may already be defined in the database
       72*   one of the given attributes may not be defined as part of the given index
       73*
       74*   undefine,    redefine:
       75*
       76*   same as define, except index name may not be defined in the database
       77*
       78*   note: "(this may be ignored)" means a previous error will prevent
       79*   a database model with erroneous information from being built
       80*
       81**/
       82 
       83 Start:
       84 	directive_ptr = rsc.directive_ptr;		/* So we can use directive str */
       85 	stmt_ptr = rsc.stmt_ptr;
       86 
       87 	index_ptr = list_ptr;
       88 	index_relation_name = rel_index.rel_name;	/* same for all directives */
       89 	if rsc.trace_sw then
       90 	     call mrds_rst_meter (rsc_ptr, "mrds_rst_index_handler", ON,
       91 		(index_relation_name));
       92 
       93 	if directive.type = UNDEFINE then do;		/* Undefine the index */
       94 
       95 /* THIS IS NOT IMPLEMENTED YET SO ISSUE AN ERROR MSG */
       96 
       97 		if stmt (directive.type).index.number > 0 then ;
       98 		else call error (2, mrds_error_$rst_undone_option,
       99 			"The index handler will not implement the ""undefine"" directive" ||
      100 			" until a later release.");
      101 
      102 	     end;					/* END of undefine */
      103 
      104 	if directive.type = DEFINE | directive.type = CMDB then do; /* Define or cmdb section */
      105 
      106 
      107 		item_ptr = rel_index.i_ptr;		/* rel_index.i_ptr points to list of indexed
      108*						   attributes for this relation */
      109 						/* Make sure relation is defined for data base */
      110 
      111 		call mrds_rst_tree_search (rel_index.rel_name, rsc.h_grel_ptr, node_ptr, parent_ptr, success);
      112 
      113 		if ^success then do;		/* Relation name was not found in db */
      114 
      115 			call mrds_rst_error (rsc_ptr, 2, mrds_error_$rst_undef_rel,
      116 			     "The indexed relation """ || rtrim (rel_index.rel_name) ||
      117 			     """ on line " || ltrim (char (rel_index.line_num)) ||
      118 			     " specified for the indexed attribute """
      119 			     || rtrim (item.name) || """ has not been defined in the database.");
      120 
      121 /* check that the given attributes are at least defined in the database */
      122 
      123 			do while (item_ptr ^= null ());
      124 
      125 			     call mrds_rst_tree_search (item.name, rsc.h_gattr_ptr, node_ptr, parent_ptr, success);
      126 
      127 			     if ^success then do;
      128 
      129 
      130 				     call mrds_rst_error (rsc_ptr, 2 /* severity */, mrds_error_$undef_attr,
      131 					"The attribute """ || rtrim (item.name) || """ given on line " ||
      132 					ltrim (char (item.line_num)) || " is not defined in the database.");
      133 
      134 				end;
      135 
      136 			     item_ptr = item.next;
      137 
      138 			end;
      139 
      140 
      141 		     end;
      142 
      143 		else do;				/* Relation exists for this attribute */
      144 
      145 			rel_gl_ptr = node_ptr -> node.data; /* Set the relation global element pointer */
      146 			ri_ptr = rel_gl_ptr -> gl.item_info_ptr; /* So we can reference rel_info */
      147 
      148 /* check for attempt to set index in a non-new file during the current release */
      149 
      150 			file_gl_ptr = rel_gl_ptr -> gl.other_info_ptr; /* get rel's file gl ptr */
      151 			if file_gl_ptr -> gl.parse_info_ptr = null () then do; /* not from source => existing file */
      152 				call ioa_$rs ("^a^a^a ^d ^a ^a", message, message_length,
      153 				     "The relation """, rel_index.rel_name, """ on line", rel_index.line_num,
      154 				     "has a secondary index statement given for it, but does not belong to a newly created file,",
      155 				     "this option will not be implemented until a later release.");
      156 				call mrds_rst_error (rsc_ptr, 2 /* severity */, mrds_error_$rst_undone_option, (message));
      157 			     end;
      158 			else do;			/* new file */
      159 				file_gl_ptr -> gl.affected = ON; /* file where relation resides is affected */
      160 				rel_gl_ptr -> gl.affected = ON; /* This relation is affected */
      161 
      162 /* Find attribute in sublist of relation */
      163 
      164 				do while (item_ptr ^= null); /* Do all attributes to indexed */
      165 
      166 				     call mrds_rst_tree_search (item.name, rel_gl_ptr -> gl.item_sub_list_ptr,
      167 					node_ptr, parent_ptr, success);
      168 
      169 				     if ^success then do; /* Attribute was not found in this relation */
      170 
      171 					     call mrds_rst_error (rsc_ptr, 2, mrds_error_$rst_not_rel_attr,
      172 						"The attribute """ || rtrim (item.name) ||
      173 						""" given on line " || ltrim (char (item.line_num)) ||
      174 						" was not defined for the relation """ ||
      175 						rtrim (rel_index.rel_name) || """.");
      176 
      177 					end;
      178 				     else do;	/* Attribute was found in this relation */
      179 
      180 					     attr_sl_ptr = node_ptr -> node.data; /* Attribute sub_list entry pointer */
      181 					     ai_ptr = attr_sl_ptr -> sl.item_info_ptr; /* So we can reference attr_info */
      182 					     fm_ptr = pointer (ai_ptr, 0); /* rel's file ptr */
      183 
      184 					     if ai_ptr = null () | ri_ptr = null () | fm_ptr = null () then ;
      185 					     else do;
      186 
      187 
      188 						     if attr_info.index_attr then /* Attribute was already indexed */
      189 							call mrds_rst_error (rsc_ptr, 1, mrds_error_$previously_defined_index,
      190 							     "The attribute """ || rtrim (item.name) ||
      191 							     """ on line " || ltrim (char (item.line_num)) ||
      192 							     " in relation """ || rtrim (rel_index.rel_name) ||
      193 							     """ was already defined as a secondary index.");
      194 
      195 						     else do; /* Make this attribute indexed */
      196 
      197 /* check for the indexed attribute being within maximum key length */
      198 
      199 							     if attr_info.bit_length > 9 * mrds_data_$max_key_len then
      200 								call mrds_rst_error (rsc_ptr, 2, mrds_error_$long_key,
      201 								     "The attribute """ || rtrim (item.name) ||
      202 								     """ on line " || ltrim (char (item.line_num)) ||
      203 								     " in relation """ || rtrim (rel_index.rel_name) ||
      204 								     """ has a secondary key data length of " ||
      205 								     ltrim (char (ceil (attr_info.bit_length / 9))) ||
      206 								     " characters, which is longer than the allowed maximum length of "
      207 								     || ltrim (char (mrds_data_$max_key_len)) || " characters.");
      208 							     else do;
      209 
      210 								     attr_info.index_attr = ON; /* Mark the attribute as a secondary index */
      211 								     rel_info.indexed = ON; /* relation now has secondary indexes */
      212 
      213 								     attr_info.index_id = OFF; /* This needs to be cleared */
      214 								     attr_gl_ptr = attr_sl_ptr -> sl.global_list_ptr;
      215 								     attr_gl_ptr -> gl.affected = ON; /* Mark attr as affected */
      216 								end;
      217 							end;
      218 						end;
      219 					end;
      220 
      221 				     item_ptr = item.next; /* Continue to next attribute to be indexed (if any) */
      222 				end;		/* End of DO WHILE (item_ptr ^= null) */
      223 
      224 			     end;
      225 		     end;				/* END of relation exists do */
      226 	     end;					/* END of DEFINE | CMDB  section */
      227 
      228 	if directive.type = REDEFINE then do;		/* REDEFINE section */
      229 
      230 /* THIS DIRECTIVE IS NOT IMPLEMENTED YET -- SO ISSUE AN ERROR MSG */
      231 
      232 
      233 		if stmt (directive.type).index.number > 0 then ;
      234 		else call error (2, mrds_error_$rst_undone_option,
      235 			"The index handler will not implement the ""redefine"" directive" ||
      236 			" until a later release.");
      237 
      238 
      239 	     end;					/* END of REDEFINE section */
      240 
      241 
      242 exit:
      243 	if rsc.trace_sw then
      244 	     call mrds_rst_meter (rsc_ptr, "mrds_rst_index_handler", OFF /* EXIT */,
      245 		(index_relation_name));
      246 	return;
      247 
      248 error: proc (sev, cd, msg);
      249 
      250 	dcl     sev		 fixed bin;	/* (INPUT) Severity level */
      251 	dcl     cd		 fixed bin (35);	/* (INPUT) error code */
      252 	dcl     msg		 char (*);	/* (INPUT)  specific error information */
      253 
      254 	call mrds_rst_error (rsc_ptr, sev, cd, msg);
      255 	goto exit;
      256 
      257      end error;
      258 
      259 	declare (fixed, addr, rel, null, ceil, char, ltrim, pointer, rtrim) builtin;
      260 	declare list_ptr		 ptr;		/*  pointer to parse info list */
      261 
      262 	dcl     mrds_rst_meter	 entry (ptr, char (*), bit (1), char (*)); /* metering/tracing routine */
      263 	dcl     mrds_rst_error	 entry (ptr, fixed bin, fixed bin (35), char (*)); /* general error handler */
      264 	dcl     mrds_rst_tree_search	 entry (char (32) aligned, ptr, ptr, ptr, bit (1)); /* list searcher */
      265 	declare ioa_$rs		 entry options (variable); /* string manipulator */
      266 
      267 	dcl     mrds_error_$previously_defined_index fixed bin (35) external;
      268 	dcl     mrds_error_$rst_undef_rel fixed bin (35) external;
      269 	dcl     mrds_error_$rst_not_rel_attr fixed bin (35) external;
      270 	declare mrds_error_$undef_attr fixed bin (35) ext;
      271 	dcl     mrds_error_$rst_undone_option fixed bin (35) external; /* option not coded yet */
      272 
      273 	declare attr_gl_ptr		 ptr;		/* pointer to global attr element */
      274 	declare file_gl_ptr		 ptr;		/* pointer to file global list element */
      275 	dcl     rel_gl_ptr		 pointer;		/* Pointer to global list structure (gl) for relation */
      276 	dcl     attr_sl_ptr		 pointer;		/* Pointer to relation sublist
      277*						   (list of attr's for this relation ) */
      278 
      279 	dcl     ON		 bit (1) internal static options (constant) init ("1"b); /* true state */
      280 	dcl     OFF		 bit (1) internal static options (constant) init ("0"b); /* false */
      281 
      282 	declare message		 char (256) varying;/* specifics of error message */
      283 	declare message_length	 fixed bin (21);	/* length of specifics message */
      284 	declare index_relation_name	 char (32);	/* input name for metering */
      285 	declare mrds_data_$max_key_len fixed bin (35) ext;/* longest key allowed, in chars */
      286 	declare mrds_error_$long_key	 fixed bin (35) ext;/* key too long error */
      287           declare sys_info$max_seg_size  fixed bin(35) ext static;
      288 
  1     1 /* BEGIN INCLUDE FILE mrds_rst_rsc.incl.pl1		RDL  7/7/78	*/
  1     2 
  1     3 /* Modified 8/21/78 by RDL */
  1     4 
  1     5 /* Modified 9/11/78 	by RDL to add directive and stmt pointers */
  1     6 
  1     7 /* Modified 11/4/78		by RDL to add debug,trace,meter switches
  1     8*
  1     9*   Modified 3/29/79 by RDL to change s_seg_info_ptr to source_seg_ptr
  1    10*
  1    11*   Modified by Jim Gray - - Jan. 1980, to add flags to disallow blocked files, forieng keys, and restructuring.
  1    12*
  1    13*   Modified by Jim Gray - - Feb. 1980, to add command level flag for cmdb subroutine interface.
  1    14*
  1    15*   Modified by Jim Gray - - 80-11-06, to add bit for cmdb -secure option.
  1    16*
  1    17*   81-05-18 Jim Gray : added bit for max_attributes error message, so that
  1    18*   it would only be issued on first occurence.
  1    19*
  1    20*   82-08-19 Davids: added the db_type field.
  1    21*
  1    22*   83-02-18 Mike Kubicar : Removed the db_type field and added the 
  1    23*   db_relation_mode_flags substructure to define the modes applicable
  1    24*   to the database's relations.  Also removed assorted unsed fields
  1    25*   (names that included the word unused).
  1    26*
  1    27**/
  1    28 
  1    29 dcl 1 rsc based (rsc_ptr),				/* Restructuring control info */
  1    30     2 rsc_dir char (200),				/* pathname of directory containing rsc segment */
  1    31     2 dbp char (168),				/* Database absolute path */
  1    32     2 temp_dir char (168),				/* Path name of temp restrucuring directory */
  1    33     2 temp_dir_sw bit (1) unal,			/* On => temp dir has been created */
  1    34     2 db_quiesced_sw bit (1) unal,			/* On => database has been quiesced */
  1    35     2 o_db_open_sw bit (1) unal,			/* On => old database has been opened */
  1    36     2 n_db_open_sw bit (1) unal,			/* On => temp database is open */
  1    37     2 listing_seg_sw bit (1) unal,			/* On => listing segment has been created */
  1    38     2 skip_scanner_conversion bit (1) unal,		/* Skip conversion in scanner */
  1    39     2 cmdb_option bit (1) unal,			/* ON => this is a cmdb source, not restructuring */
  1    40     2 trace_sw bit (1) unal,				/* On -> trace mode in affect */
  1    41     2 debug_sw bit (1) unal,				/* On = debug mode (NOT IMPLEMENTED) */
  1    42     2 meter_sw bit (1) unal,				/* On = procedures call metering procedure */
  1    43     2 delete_db_sw bit (1) unal,			/* On = delete data base in cleanup */
  1    44     2 model_consistent_sw bit (1) unal,			/* On => Model is consistent */
  1    45     2 physical_started_sw bit (1) unal,			/* On => Physical restructuring started */
  1    46     2 physical_complete_sw bit (1) unal,		/* On => Physical restructuring completed */
  1    47     2 model_overflow bit (1) unal,			/* ON => model segment area condition occurred */
  1    48     2 max_files bit (1) unal,				/* ON => maximum number of files reached */
  1    49     2 allow_foreign_keys bit (1) unal,			/* on => allow foreign key statment */
  1    50     2 foreign_key_seen bit (1) unal,			/* on => foreign key definition in source */
  1    51     2 allow_blocked_files bit (1) unal,			/* on => allow file statement with blocked option */
  1    52     2 blocked_file_seen bit (1) unal,			/* on => blocked file definition in source */
  1    53     2 allow_restructuring bit (1) unal,			/* on => allow RMDB entry point */
  1    54     2 command_level bit (1) unal,			/* on => called from command unal, not subroutine level */
  1    55     2 secure bit (1) unal,				/* on => -secure option given for cmdb */
  1    56     2 max_attrs bit (1) unal,				/* on => max attrs/rel or max indexes/rel exceeded */
  1    57     2 db_relation_mode_flags,
  1    58       3 dm_file_type bit (1) unal,			/* on => relations are dm files */
  1    59       3 protection_on bit (1) unal,			/* on => relations need transactions */
  1    60       3 concurrency_on bit (1) unal,			/* on => concurrency control enabled */
  1    61       3 rollback_on bit (1) unal,			/* on => before journalling is enabled */
  1    62     2 severity_high fixed bin,			/* Highest severity level error encountered */
  1    63     2 phase fixed bin,				/* 000 = init
  1    64*						   100 = global list init
  1    65*						   200 = parse
  1    66*						   300 = physical init
  1    67*						   400 = physical */
  1    68     2 h_o_seg_info_ls_ptr ptr,			/* Pointer to head of old db seg_info list */
  1    69     2 h_n_seg_info_ls_ptr ptr,			/* Pointer to head of new db seg_info list */
  1    70     2 h_gfile_ptr ptr,				/* Pointer to head of global file list */
  1    71     2 h_gdom_ptr ptr,				/* Pointer to head of global domain list */
  1    72     2 h_gattr_ptr ptr,				/* Pointer to head of global attribute list */
  1    73     2 h_grel_ptr ptr,				/* Pointer to head of global relation list */
  1    74     2 h_glink_ptr ptr,				/* Pointer to head of global link list */
  1    75     2 o_dm_ptr ptr,					/* Pointer to old data model seg  (dm_model ) */
  1    76     2 n_dm_ptr ptr,					/* Pointer to temp data model seg */
  1    77     2 o_fn_hdr_ptr ptr,				/* Pointer to head of original file list (fn structure) */
  1    78     2 source_seg_ptr ptr,				/* Pointer to source_seg */
  1    79     2 listing_iocb_ptr ptr,				/* Pointer to listing segment iocb */
  1    80     2 directive_ptr ptr,				/* Pointer to directive type str in mrds_rst_semactics.incl.pl1 */
  1    81     2 stmt_ptr ptr,					/* Pointer to statement str in mrds_rst_sematics.incl.pl1 */
  1    82     2 trace_metering_iocb_ptr ptr,			/* Pointer to seg used by trace and metering */
  1    83     2 tree_node_area_ptr ptr,				/* pointer to working storage for tree nodes */
  1    84     2 tree_data,
  1    85       3 seg_info_area_ptr ptr,			/* seg info working storage area */
  1    86       3 gl_area_ptr ptr,				/* global list data work storage area */
  1    87       3 sl_area_ptr ptr,				/* sublist data work storage area */
  1    88     2 parse_info_area_ptr ptr,			/* parse interface work area storage */
  1    89     2 static_info_area_ptr ptr,			/* directive, stmt and other static work storage area */
  1    90     2 variable_length_area_ptr ptr,			/* varibale allocates work storage area */
  1    91     2 other_area_ptr ptr,				/* unspecified work area storage */
  1    92     2 wa area (sys_info$max_seg_size - fixed (rel (addr (rsc.wa))) + 1); /* Work area */
  1    93 
  1    94 dcl  rsc_ptr ptr;					/* Pointer to base of rsc segment */
  1    95 
  1    96 
  1    97 
  1    98 /* END INCLUDE FILE mrds_rst_rsc.incl.pl1				*/
  1    99 
      289 
  2     1 /* BEGIN INCLUDE FILE mrds_rst_semantics.incl.pl1 jeg 8/31/78 */
  2     2 
  2     3 /* structure to remember what directives have been seen and are active */
  2     4 
  2     5 declare 1 directive based (directive_ptr),
  2     6         2 type fixed binary,				/* stmt structure index for given directive */
  2     7         2 undefine,
  2     8 	3 active bit (1) unal,
  2     9 	3 seen bit (1) unal,
  2    10 	3 pad bit (34) unal,
  2    11         2 define,
  2    12 	3 active bit (1) unal,
  2    13 	3 seen bit (1) unal,
  2    14 	3 pad bit (34) unal,
  2    15         2 redefine,
  2    16 	3 active bit (1) unal,
  2    17 	3 seen bit (1) unal,
  2    18 	3 pad bit (34) unal,
  2    19         2 cmdb,
  2    20 	3 active bit (1) unal,
  2    21 	3 seen bit (1) unal,
  2    22 	3 pad bit (34) unal ;
  2    23 
  2    24 declare  directive_ptr ptr internal static ;
  2    25 
  2    26 /* encoding for directive types */
  2    27 
  2    28 declare  UNDEFINE fixed bin internal static options (constant) init (1) ;
  2    29 declare  DEFINE fixed bin internal static options (constant) init (2) ;
  2    30 declare  REDEFINE fixed bin internal static options (constant) init (3) ;
  2    31 declare  CMDB fixed binary internal static options (constant) init (4) ;
  2    32 
  2    33 
  2    34 /* structure to remember what statements have been seen, are active,
  2    35*   and how many items are in the statement, and how big the list for the last item was */
  2    36 
  2    37 declare 1 stmt (4) based (stmt_ptr),
  2    38         2 domain,
  2    39 	3 active bit (1) unal,
  2    40 	3 pad bit (35) unal,
  2    41 	3 number fixed binary,
  2    42         2 attribute,
  2    43 	3 active bit (1) unal,
  2    44 	3 pad bit (35) unal,
  2    45 	3 number fixed binary,
  2    46         2 relation,
  2    47 	3 active bit (1) unal,
  2    48 	3 pad bit (35) unal,
  2    49 	3 number fixed binary,
  2    50         2 file,
  2    51 	3 active bit (1) unal,
  2    52 	3 pad bit (35) unal,
  2    53 	3 number fixed binary,
  2    54         2 foreign_key,
  2    55 	3 active bit (1) unal,
  2    56 	3 pad bit (35) unal,
  2    57 	3 number fixed binary,
  2    58         2 index,
  2    59 	3 active bit (1) unal,
  2    60 	3 pad bit (35) unal,
  2    61 	3 number fixed binary ;
  2    62 
  2    63 /* NOTE:
  2    64*   active ON => this stmt/directive is currently being processed
  2    65*   seen ON => this stmt/directive was or is being processed
  2    66**/
  2    67 
  2    68 declare  stmt_ptr ptr internal static ;
  2    69 
  2    70 /* END INCLUDE FILE mrds_rst_semantics.incl.pl1 */
  2    71 
      290 
  3     1 /* BEGIN INCLUDE FILE mrds_rst_parse_info.incl.pl1 -- oris, 6/30/78 */
  3     2 /* modified 9/6/78 -- jeg, for lrk parser - cmdb interface */
  3     3 /* modified 12/20/78 - - jeg, to add line number info for handlers */
  3     4 /* modified 3/15/79 - - jeg, to add scanner, semantic, and link handler variables to be allocated in rsc */
  3     5 /* Modified by Jim Gray - - 23-June-80, to separate max_string_size,
  3     6*   and max_line_size mrds_data_ items. */
  3     7 
  3     8 
  3     9 
  3    10 
  3    11 declare 1 domain aligned based (domain_ptr),
  3    12         2 name char (32),				/* name of this domain */
  3    13         2 descriptor bit (36),			/* Multics pl1 descriptor for domain type */
  3    14         2 varying_avg_length fixed bin (24),		/* average length of varying strings */
  3    15         2 options bit (1) unal,			/* ON => some option is present */
  3    16         2 pad bit (35) unal,
  3    17         2 check,
  3    18 	3 flag bit (1) unal,			/* ON => check option present */
  3    19 	3 pad bit (35) unal,
  3    20 	3 stack_ptr ptr,				/* pointer to postfix stack
  3    21*						   holding boolean expression */
  3    22 	3 stack_size fixed binary,			/* number of stack elements */
  3    23         2 check_proc,
  3    24 	3 flag bit (1) unal,			/* ON => check_proc option is present */
  3    25 	3 pad bit (35) unal,
  3    26 	3 path char (168),				/* check procedure pathname */
  3    27 	3 entry char (32),				/* check procedure entryname */
  3    28         2 encode_proc,
  3    29 	3 flag bit (1) unal,			/* ON => encode_proc option is present */
  3    30 	3 pad bit (35) unal,
  3    31 	3 path char (168),				/* encode procedure pathname */
  3    32 	3 entry char (32),				/* encode procedure entryname */
  3    33         2 decode_proc,
  3    34 	3 flag bit (1) unal,			/* ON => decode_proc option is present */
  3    35 	3 pad bit (35) unal,
  3    36 	3 path char (168),				/* decode procedure pathname */
  3    37 	3 entry char (32),				/* decode procedure entryname */
  3    38         2 decode_dcl,
  3    39 	3 flag bit (1) unal,			/* ON => decode declaration is present */
  3    40 	3 pad bit (35) unal,
  3    41 	3 descriptor bit (36),			/* decode declaration pl1 descriptor */
  3    42         2 line_num fixed bin (24) ;			/* line of domain name in source */
  3    43 
  3    44 
  3    45 declare  domain_ptr ptr ;
  3    46 
  3    47 
  3    48 
  3    49 
  3    50 
  3    51 dcl 1 relation aligned based (relation_ptr),
  3    52     2 a_ptr ptr,					/* ptr to attribute list for this relation */
  3    53     2 name char (32),				/* relation name */
  3    54     2 max_tup fixed bin,				/* maximum tuples for this relation if a blocked file */
  3    55     2 num_items fixed bin,				/* number of attributes in this relation */
  3    56     2 unused bit (36) unal,				/* future flags */
  3    57     2 line_num fixed bin (24) ;			/* line of relation name in source */
  3    58 
  3    59 
  3    60 dcl  relation_ptr ptr;
  3    61 
  3    62 
  3    63 dcl 1 attribute aligned based (attribute_ptr),
  3    64     2 next ptr,					/* ptr to next in list */
  3    65     2 name char (32),				/* name of attribute */
  3    66     2 pr_key bit (1) unal,				/* ON => part of primary key */
  3    67     2 pad bit (35) unal,
  3    68     2 defn_order fixed bin,				/* position within the relation */
  3    69     2 key_order fixed bin,				/* position within the primary key, if a key */
  3    70     2 line_num fixed bin (24) ;			/* line of attribute name in source */
  3    71 
  3    72 
  3    73 dcl  attribute_ptr ptr;
  3    74 
  3    75 
  3    76 
  3    77 dcl 1 attribute_domain aligned based (attdom_ptr),
  3    78     2 attr char (32),				/* attribute name */
  3    79     2 dom char (32),				/* domain name */
  3    80     2 default bit (1) unal,				/* on => defined as default attr, not by source */
  3    81     2 unused bit (35) unal,				/* future flags */
  3    82     2 line_num fixed bin (24) ;			/* line of attribute name in source */
  3    83 
  3    84 dcl  attdom_ptr ptr;				/* ptr to attribute_domain structure */
  3    85 
  3    86 
  3    87 
  3    88 
  3    89 dcl 1 file aligned based (file_ptr),
  3    90     2 i_ptr ptr,					/* ptr to item containing relation name */
  3    91     2 name char (30),				/* file name */
  3    92     2 type fixed bin,				/* blocked or unblocked */
  3    93 						/* type = 1 => unblocked,
  3    94*						   type = 2 => blocked */
  3    95     2 ppb fixed bin,				/* pages per block, if blocked */
  3    96     2 hbh fixed bin,				/* hash bucket headers per block */
  3    97     2 block fixed bin,				/* blocks per hash bucket headers */
  3    98     2 num_items fixed bin,				/* nbr. items -- relations -- in file */
  3    99     2 default bit (1) unal,				/* on => defined as default file, not by source */
  3   100     2 unused bit (35) unal,				/* future flags */
  3   101     2 line_num fixed bin (24) ;			/* line of file name in source */
  3   102 
  3   103 
  3   104 dcl  file_ptr ptr;					/* ptr to file structure */
  3   105 
  3   106 
  3   107 dcl 1 rel_index aligned based (index_ptr),
  3   108     2 i_ptr ptr,					/* ptr. to item containing index attr. name */
  3   109     2 rel_name char (32),				/* name of relation being indexed */
  3   110     2 num_items fixed bin,				/* nbr. items -- attributes -- indexed for a relation */
  3   111     2 unused bit (36) unal,				/* future flags */
  3   112     2 line_num fixed bin (24) ;			/* line of relation name in source */
  3   113 
  3   114 
  3   115 dcl  index_ptr ptr;					/* ptr to index structure */
  3   116 
  3   117 
  3   118 dcl 1 link aligned based (link_ptr),
  3   119     2 parent_ptr ptr,				/* ptr to foreign_key structure cont. parent rel. name */
  3   120     2 children_ptr ptr,				/* ptr. to list of children names for this link */
  3   121     2 clust_fl bit (1) unal,				/* ON => link is clustered in one file */
  3   122     2 pad bit (35) unal,
  3   123     2 name char (32),				/* name of this link */
  3   124     2 num_children fixed bin,				/* number of children for this link's parent */
  3   125     2 line_num fixed bin (24) ;			/* line of link name occurence in source */
  3   126 
  3   127 
  3   128 dcl  link_ptr ptr;					/* ptr to link structure */
  3   129 
  3   130 
  3   131 dcl 1 children aligned based (children_ptr),
  3   132     2 next ptr,					/* ptr to next in list */
  3   133     2 child_ptr ptr;				/* ptr. to foreign_key struct. containing child rel. name */
  3   134 
  3   135 
  3   136 dcl  children_ptr ptr;				/* ptr to children structure */
  3   137 
  3   138 
  3   139 dcl 1 foreign_key aligned based (forkey_ptr),
  3   140     2 i_ptr ptr,					/* ptr to item list containing foreign key attributes */
  3   141     2 rel_name char (32),				/* name of parent/child relation */
  3   142     2 num_items fixed bin,				/* nbr of attributes defining this foreign key */
  3   143     2 unused bit (36) unal,				/* future flags */
  3   144     2 line_num fixed bin (24) ;			/* line of relation occurence in source */
  3   145 
  3   146 
  3   147 dcl  forkey_ptr ptr;				/* ptr to foreign_key structure */
  3   148 
  3   149 
  3   150 dcl 1 item aligned based (item_ptr),
  3   151     2 next ptr,					/* ptr to next item in the list */
  3   152     2 name char (32),				/* name of item -- relation name or attribute name */
  3   153     2 unused bit (36) unal,				/* future flags */
  3   154     2 line_num fixed bin (24) ;			/* line of item occurence in source */
  3   155 
  3   156 
  3   157 dcl  item_ptr ptr;					/* ptr to item structure */
  3   158 
  3   159 
  3   160 declare 1 delete_name aligned based (delete_name_ptr),	/* overlay for  undefine parse information */
  3   161         2 overlay char (32),				/* name portion */
  3   162         2 unused bit (36) unal,			/* future flags */
  3   163         2 line_num fixed bin (24) ;			/* line number of name occurence in source */
  3   164 
  3   165 declare  delete_name_ptr ptr ;
  3   166 
  3   167 /* scanner variables */
  3   168 
  3   169 declare  token char (mrds_data_$max_string_size) varying
  3   170          based (accum_token_ptr) ;			/* temp store for accumulating the token */
  3   171 declare  accum_token_ptr ptr internal static ;		/* pointer to allocated accumulator store */
  3   172 declare  mrds_data_$max_string_size fixed bin (35) external ; /* max token  size in chars */
  3   173 declare  mrds_data_$max_line_size fixed bin (35) ext ;	/* max output listing line size */
  3   174 declare  token_length fixed binary (24) ;		/* current length of token */
  3   175 declare  output_text char (mrds_data_$max_line_size) varying
  3   176          based (output_text_ptr) ;			/* body of text for this line in output listing */
  3   177 declare  output_text_ptr ptr internal static ;		/* pointer to allocated output line storage */
  3   178 declare  fixup_token char (token_length) based ;		/* saved fixed up version of token */
  3   179 
  3   180 /* semantic variables */
  3   181 
  3   182 declare  source_size fixed bin (35) ;			/* length of source char string for any_to_any */
  3   183 declare  string_source_ptr ptr ;			/* pointer to source for any_to_any conversion */
  3   184 declare  string_source char (source_size) based (string_source_ptr) ; /* storage for expanded string constant */
  3   185 
  3   186 /* link handler variable */
  3   187 
  3   188 declare  dom_list_ptr ptr ;				/* pointer to domain list element */
  3   189 declare 1 dom_list based (dom_list_ptr),		/* element of parent attr domain ptr list */
  3   190         2 next ptr,					/* pointer to next in order on list */
  3   191         2 attr_name char (32) aligned,			/* parent attr's name */
  3   192         2 dom_info_ptr ptr ;				/* parent attr's domain ptr */
  3   193 
  3   194 /* END INCLUDE FILE mrds_rst_parse_info.incl.pl1 */
  3   195 
      291 
  4     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  4     6*     modified to save space occupied by model
  4     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  4     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  4     9*     the number of secondary indices in the relation - it was always zero.
  4    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  4    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  4    12*     DMS conversion.
  4    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  4    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  4    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  4    16*     for relation manager changes.
  4    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  4    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  4    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  4    20*     <rel> files are good (for rmdb)
  4    21*                                                   END HISTORY COMMENTS */
  4    22 
  4    23 
  4    24 /* each file in the database will have a model segment with the name
  4    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  4    26*   the file_model structure is allocated at the base of the segment for a given file.
  4    27*   it contains an area with which all other structures in this include file are allocated.
  4    28*   these structures contain the information about which relations, foreign keys,
  4    29*   and attributes are members of this file. all lists are singly linked lists in
  4    30*   definition order. pointers to these structures are obtained by using the "pointer"
  4    31*   builtin function with arguments of the segment base pointer, and the
  4    32*   offset (bit (18)) relative to that pointer that is actually stored in
  4    33*   the file model itself. this is because pointer segment numbers are
  4    34*   per process dependent. the major lists pointed to by the file_model structure
  4    35*   are the list of relations in this file(each with a contained attribute list),
  4    36*   and the list of foreign keys whose parent relation resides in this file
  4    37*   (along with a participating attribute sublist, and the child relation list,
  4    38*   if they are also in this file) */
  4    39 
  4    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  4    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  4    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  4    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  4    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  4    45     2 reserved bit (32) unal,				/* reserved for future flags */
  4    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  4    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  4    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  4    49     2 pad_1 fixed bin (35),				/* for future use */
  4    50     2 pad_2 fixed bin (35),
  4    51     2 ratd_len fixed bin (21),			/* length of above */
  4    52     2 mratd_len fixed bin (21),			/* length of above */
  4    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  4    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  4    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  4    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  4    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  4    58     2 block_size unal fixed bin,			/* no. pages in block */
  4    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  4    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  4    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  4    62     2 num_rels unal fixed bin,			/* number of relations in file */
  4    63     2 num_links unal fixed bin,			/* number of links in file */
  4    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  4    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  4    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  4    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  4    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  4    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  4    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  4    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  4    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  4    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  4    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  4    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  4    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  4    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  4    78     2 open_eu_err_path_ptr unal bit (18),
  4    79     2 open_eu_after_path_ptr unal bit (18),
  4    80     2 open_er_before_path_ptr unal bit (18),
  4    81     2 open_er_err_path_ptr unal bit (18),
  4    82     2 open_er_after_path_ptr unal bit (18),
  4    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  4    84     2 open_neu_err_path_ptr unal bit (18),
  4    85     2 open_neu_after_path_ptr unal bit (18),
  4    86     2 open_ner_before_path_ptr unal bit (18),
  4    87     2 open_ner_err_path_ptr unal bit (18),
  4    88     2 open_ner_after_path_ptr unal bit (18),
  4    89     2 open_pu_before_path_ptr unal bit (18),
  4    90     2 open_pu_err_path_ptr unal bit (18),
  4    91     2 open_pu_after_path_ptr unal bit (18),
  4    92     2 open_pr_before_path_ptr unal bit (18),
  4    93     2 open_pr_err_path_ptr unal bit (18),
  4    94     2 open_pr_after_path_ptr unal bit (18),
  4    95     2 open_cu_before_path_ptr unal bit (18),
  4    96     2 open_cu_err_path_ptr unal bit (18),
  4    97     2 open_cu_after_path_ptr unal bit (18),
  4    98     2 open_cr_before_path_ptr unal bit (18),
  4    99     2 open_cr_err_path_ptr unal bit (18),
  4   100     2 open_cr_after_path_ptr unal bit (18),
  4   101     2 close_before_path_ptr unal bit (18),
  4   102     2 close_err_path_ptr unal bit (18),
  4   103     2 close_after_path_ptr unal bit (18),
  4   104     2 unused_1 unal bit (18),				/* for future expansion */
  4   105     2 unused_2 unal bit (18),
  4   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  4   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  4   108 dcl  fm_ptr ptr;
  4   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  4   110 dcl  atd_ptr ptr;
  4   111 dcl  atd_len fixed bin;
  4   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  4   113     2 ncomponents fixed bin,
  4   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  4   115 dcl  cna_ptr ptr;
  4   116 dcl  ncomp_init fixed bin;
  4   117 
  4   118 /* a rel_info structure contains information describing a relation.
  4   119*   a relation may only occur in one file, thus there is one rel_info
  4   120*   per relation per database, each stored in the file_model area for
  4   121*   the file that contains it. the list of rel_info's in this file
  4   122*   form a singly linked list in definition order.
  4   123*   the rel_info itself points to a list of the attributes it contains,
  4   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  4   125 
  4   126 dcl 1 rel_info aligned based (ri_ptr),
  4   127     2 name char (32),				/* relation name */
  4   128     2 id  bit (36) aligned,				/* relation id number */
  4   129     2 hashed bit (1) unal,				/* on if hashed */
  4   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  4   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  4   132     2 system bit (1) unal,				/* on if dont care how stored */
  4   133     2 indexed bit (1) unal,				/* on if secondary index */
  4   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  4   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  4   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  4   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  4   138     2 reserved bit (27) unal,				/* for future flags */
  4   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  4   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  4   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  4   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  4   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  4   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  4   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  4   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  4   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  4   148     2 unused_3 unal fixed bin,			/* element that was never used */
  4   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  4   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  4   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  4   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  4   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  4   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  4   155     2 attr_ptr unal bit (18),				/* to attr. info */
  4   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  4   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  4   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  4   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  4   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  4   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  4   162     2 link_err_path_ptr unal bit (18),
  4   163     2 link_after_path_ptr unal bit (18),
  4   164     2 unlk_before_path_ptr unal bit (18),
  4   165     2 unlk_err_path_ptr unal bit (18),
  4   166     2 unlk_after_path_ptr unal bit (18),
  4   167     2 str_before_path_ptr unal bit (18),
  4   168     2 str_err_path_ptr unal bit (18),
  4   169     2 str_after_path_ptr unal bit (18),
  4   170     2 del_before_path_ptr unal bit (18),
  4   171     2 del_err_path_ptr unal bit (18),
  4   172     2 del_after_path_ptr unal bit (18),
  4   173     2 mod_before_path_ptr unal bit (18),
  4   174     2 mod_err_path_ptr unal bit (18),
  4   175     2 mod_after_path_ptr unal bit (18),
  4   176     2 find_before_path_ptr unal bit (18),
  4   177     2 find_err_path_ptr unal bit (18),
  4   178     2 find_after_path_ptr unal bit (18),
  4   179     2 retr_before_path_ptr unal bit (18),
  4   180     2 retr_err_path_ptr unal bit (18),
  4   181     2 retr_after_path_ptr unal bit (18),
  4   182     2 unused_1 unal bit (18),				/* for future expansion */
  4   183     2 unused_2 unal bit (18),
  4   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  4   185 dcl  ri_ptr ptr;
  4   186 
  4   187 /* a attr_info structure contains information about an attribute in a given relation.
  4   188*   since attributes may appear in more than one relation, each occurence of an attribute
  4   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  4   190*   the list is singly linked in definition order. the attr_info describes
  4   191*   the data it represents, and how that data is used during a database search. */
  4   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  4   193     2 name char (32),				/* name of attribute */
  4   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  4   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  4   196     2 link_attr bit (1) unal,				/* on if participates in link */
  4   197     2 reserved bit (33) unal,
  4   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  4   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  4   200     2 key_order unal fixed bin,			/* relative posit. in key */
  4   201     2 bit_offset fixed bin (35),			/* position in tuple */
  4   202     2 bit_length fixed bin (35),			/* length if fixed */
  4   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  4   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  4   205     2 domain_ptr unal bit (18),			/* to domain info */
  4   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  4   207     2 fwd_thread unal bit (18),			/* to next in list */
  4   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  4   209 dcl  ai_ptr ptr;
  4   210 
  4   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  4   212*   each time a foreign key definition indicates a relation as it's parent,
  4   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  4   214*   a relation can be parent and/or child in any number of foreign keys.
  4   215*   the parent_link_info structure describes the foreign key, and also points
  4   216*   to a list of the attributes that participate in this foreign key.
  4   217*   (this could be from 1 up to all attributes in the relation)
  4   218*   the attr_list structures are in a singly linked list in definition order
  4   219*   for this purpose. also pointed to is a list of child_link_info's
  4   220*   that describe the child relations in this foreign key. since foreign keys
  4   221*   may span files, not all related child_link_info's have to be in this file's
  4   222*   model area. */
  4   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  4   224     2 name char (32),				/* name of link */
  4   225     2 singular bit (1) unal,				/* on if system owned link */
  4   226     2 temp bit (1) unal,				/* on if temp. order */
  4   227     2 first bit (1) unal,				/* insertion indicators */
  4   228     2 last bit (1) unal,
  4   229     2 next bit (1) unal,
  4   230     2 prior bit (1) unal,
  4   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  4   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  4   233     2 dup_first bit (1) unal,				/* duplicates first */
  4   234     2 dup_last bit (1) unal,				/* duplicates last */
  4   235     2 indexed bit (1) unal,				/* locate parent via index */
  4   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  4   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  4   238     2 thread_27 bit (1) unal,
  4   239     2 thread_18 bit (1) unal,
  4   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  4   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  4   242     2 reserved bit (19) unal,				/* reserved for future flags */
  4   243     2 index_id aligned bit (8),			/* id of index if indexed */
  4   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  4   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  4   246     2 n_children unal fixed bin,			/* no. children in link */
  4   247     2 child_fn char (30),				/* file name for first child in list */
  4   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  4   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  4   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  4   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  4   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  4   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  4   254     2 sort_err_path_ptr unal bit (18),
  4   255     2 sort_after_path_ptr unal bit (18),
  4   256     2 srch_before_path_ptr unal bit (18),
  4   257     2 srch_err_path_ptr unal bit (18),
  4   258     2 srch_after_path_ptr unal bit (18),
  4   259     2 link_before_path_ptr unal bit (18),
  4   260     2 link_err_path_ptr unal bit (18),
  4   261     2 link_after_path_ptr unal bit (18),
  4   262     2 unlk_before_path_ptr unal bit (18),
  4   263     2 unlk_err_path_ptr unal bit (18),
  4   264     2 unlk_after_path_ptr unal bit (18),
  4   265     2 unused_1 unal bit (18),				/* for future expansion */
  4   266     2 unused_2 unal bit (18),
  4   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  4   268 dcl  pli_ptr ptr;
  4   269 
  4   270 /* a child_link_info structure is the counter part of a parent_link_info
  4   271*   for foreign key child relations. each time a relation is defined to be
  4   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  4   273*   this list is singly linked in foreign key definition order.
  4   274*   the child_link_info points to a list of participating attributes from the
  4   275*   child relation by means of a singly linked list of attr_list structures
  4   276*   in definition order. the number of attributes in the parent attr_list
  4   277*   and the child attr_list lists are the same with corresponding attr_list
  4   278*   attributes having the same domain. all child_link_infos in this file
  4   279*   are on a seperately linked list. this may not include all
  4   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  4   281*   since foreign keys may span files, and the child_link_info will
  4   282*   reside in the file containing it's associated relation_info. */
  4   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  4   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  4   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  4   286     2 fixed bit (1) unal,				/* on if membership fixed */
  4   287     2 optional bit (1) unal,				/* on if membership optional */
  4   288     2 auto bit (1) unal,				/* on if insertion automatic */
  4   289     2 manual bit (1) unal,				/* on if insertion manual */
  4   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  4   291     2 range_sel bit (1) unal,				/* on if range type selection */
  4   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  4   293     2 key_dup_last bit (1) unal,
  4   294     2 key_null bit (1) unal,				/* on if null allowed */
  4   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  4   296     2 sel_current bit (1) unal,
  4   297     2 sel_key bit (1) unal,
  4   298     2 sel_proc bit (1) unal,
  4   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  4   300     2 reserved bit (21) unal,
  4   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  4   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  4   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  4   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  4   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  4   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  4   307     2 parent_fn char (30),				/* file name for parent info */
  4   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  4   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  4   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  4   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  4   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  4   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  4   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  4   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  4   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  4   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  4   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  4   319     2 link_err_path_ptr unal bit (18),
  4   320     2 link_after_path_ptr unal bit (18),
  4   321     2 unlk_before_path_ptr unal bit (18),
  4   322     2 unlk_err_path_ptr unal bit (18),
  4   323     2 unlk_after_path_ptr unal bit (18),
  4   324     2 srch_before_path_ptr unal bit (18),
  4   325     2 srch_err_path_ptr unal bit (18),
  4   326     2 srch_after_path_ptr unal bit (18),
  4   327     2 unused_1 unal bit (18),				/* for future expansion */
  4   328     2 unused_2 unal bit (18) ;
  4   329 dcl  cli_ptr ptr;
  4   330 
  4   331 /* the attr_list structure is associated with the parent_link_info
  4   332*   and child_link_info structures to represent by means of a singly linked list
  4   333*   the participating attributes from relations in a foreign key.
  4   334*   the parent_link_info has a list for the parent relation,
  4   335*   and the child_link_info has a list for the child relation.
  4   336*   the participating attributes are a subset(not necessary proper) of
  4   337*   those attributes contained in a relation definition.
  4   338*   there are equal numbers of attr_list structures in the parent and
  4   339*   child lists of the same foreign key. the corresponding attributes in these
  4   340*   lists must have the same domain. */
  4   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  4   342     2 attr_fn char (30),				/* file name for attr. */
  4   343     2 attr_ptr unal bit (18),				/* to attr info block */
  4   344     2 fwd_thread unal bit (18);			/* to next in list */
  4   345 dcl  al_ptr ptr;
  4   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  4   347     2 ascend bit (1) unal,				/* ascending order */
  4   348     2 descend bit (1) unal,				/* descending order */
  4   349     2 reserved bit (34) unal,
  4   350     2 attr_ptr unal bit (18),				/* to attr info */
  4   351     2 fwd_thread unal bit (18);			/* to next in list */
  4   352 dcl  sk_ptr ptr;
  4   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  4   354     2 attr_ptr unal bit (18),				/* to attr info */
  4   355     2 fwd_thread unal bit (18);			/* to next in list */
  4   356 dcl  dp_ptr ptr;
  4   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  4   358     2 link_fn char (30),				/* file name for thru link */
  4   359     2 link_ptr unal bit (18),				/* to parent link info */
  4   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  4   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  4   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  4   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  4   364     2 fwd_thread unal bit (18);			/* to next in chain */
  4   365 dcl  sc_ptr ptr;
  4   366 
  4   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  4   368 
  4   369 
      292 
      293 
  5     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  5     6*     modified to save space occupied by model
  5     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  5     8*     to add mdbm_secured bit in db_model
  5     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  5    10*     collapsed the following into an unused_offset array:
  5    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  5    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  5    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  5    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  5    15*       unused_1
  5    16*     Also changed the name of unused_2 to restructuring_history_offset
  5    17*     and changed the comment on the changer structure to indicate
  5    18*     that it will contain on database creation information.
  5    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  5    20*     used one of the unused_offsets to point to a message which indicates
  5    21*     why the db is inconsistent. The offset will be null when the db is created
  5    22*     and set the first time the message is used. this is so it will be
  5    23*     consistent with existing data bases. Also added the message structure.
  5    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  5    25*     added the undo_request element to the message structure
  5    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  5    27*     changed unused_offset (12) to last_restructruring_history_offset and
  5    28*     changed restructuring_history_offset to first_restructuring_history_offset
  5    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  5    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  5    31*     1 => vfile database and 2 => page_file database. Up to this point all
  5    32*     database types were equal to 1.
  5    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  5    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  5    35*     flags. This will allow information about transactions and dm_file
  5    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  5    37*     change is compatable with all datamodels created by the released version
  5    38*     of mrds.
  5    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  5    40*     added the rollback_on flag to the db_type_flags since it appears that you
  5    41*     can have a dmfile database that requires transactions but does not have any
  5    42*     journalizing. Also switched the order of the transactions_needed and
  5    43*     concurrency_on flags - this makes the change compatable with existing
  5    44*     dmfile databases except when displaying the model since concurrency_on and
  5    45*     rollback_on will be off in the model even though the dmfile relations had
  5    46*     them on during creation.
  5    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  5    48*      Removed ctl_file_path_ptr.
  5    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  5    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  5    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  5    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  5    53*      in the flag word for rmdb copying.
  5    54*                                                   END HISTORY COMMENTS */
  5    55 
  5    56 
  5    57 /* this include file contains the structures that go into the make up
  5    58*   of the "db_model" segment in the model for the database.
  5    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  5    60*
  5    61*   the db_model structure goes at the base of the segment, and contains items unique to
  5    62*   the whole databse. in addition, it has an area of size to fill the
  5    63*   rest of a segment, that holds the lists of files and domains in the database.
  5    64*   these lists are singly forward linked lists. all "pointers" in the database model
  5    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  5    66*   since actual pointers are process dependent on segment number.
  5    67*   the remaining structures are first a path_entry one to save pathnames in,
  5    68*   and the stack_item and constent structures, used to save a boolean
  5    69*   expression in polish form, with the stack represented by a linked list.
  5    70*   the final structure is one for identifying the status of version information */
  5    71 
  5    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  5    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  5    74 	     2 db_type_flags      unal,
  5    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  5    76 	       3 unused	      (13) bit (1) unal,
  5    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  5    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  5    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  5    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  5    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  5    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  5    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  5    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  5    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  5    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  5    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  5    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  5    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  5    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  5    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  5    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  5    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  5    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  5    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  5    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  5    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  5    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  5    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  5   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  5   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  5   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  5   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  5   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  5   105 
  5   106      dcl	   dbm_ptr	      ptr;
  5   107 
  5   108 /* the files in the database each have a file_info containing
  5   109*   their name, the file_model for each file is found by initiating the
  5   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  5   111*   the file_info list is a singly linked list in definition order */
  5   112 
  5   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  5   114 	     2 file_name	      char (30),		/* name of file */
  5   115 	     2 file_id	      bit (36),		/* id number of file */
  5   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  5   117 	     2 unused	      unal bit (18);	/* for future expansion */
  5   118 
  5   119      dcl	   fi_ptr		      ptr;
  5   120 
  5   121 /* each domain used in the database will have a domain info saved in the db_model
  5   122*   segment. it describes the domain of the given name, and it's options.
  5   123*   the domain_info's form a singly linked list in definition order */
  5   124 
  5   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  5   126 	     2 name	      char (32),		/* name of domain */
  5   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  5   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  5   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  5   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  5   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  5   132 	     2 reserved	      bit (31) unal,
  5   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  5   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  5   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  5   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  5   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  5   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  5   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  5   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  5   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  5   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  5   143 	     2 str_err_path_ptr   unal bit (18),
  5   144 	     2 str_after_path_ptr unal bit (18),
  5   145 	     2 get_before_path_ptr unal bit (18),
  5   146 	     2 get_err_path_ptr   unal bit (18),
  5   147 	     2 get_after_path_ptr unal bit (18),
  5   148 	     2 mod_before_path_ptr unal bit (18),
  5   149 	     2 mod_err_path_ptr   unal bit (18),
  5   150 	     2 mod_after_path_ptr unal bit (18),
  5   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  5   152 	     2 unused_2	      unal bit (18),
  5   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  5   154 
  5   155      dcl	   di_ptr		      ptr;
  5   156 
  5   157 /* information necessary for attributes that are not used in any relation */
  5   158 
  5   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  5   160 	     2 name char (32),			/* name of attribute */
  5   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  5   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  5   163 	     2 unused (2) bit (18) unal;
  5   164 
  5   165      dcl     ua_ptr ptr;
  5   166 
  5   167 
  5   168 /* space saving pathname$entryname structure, to be allocated
  5   169*   only when a path$entry has to be saved, else only a bit(18)
  5   170*   offset takes up space in the main model structure */
  5   171 
  5   172      declare 1 path_entry	      based (path_entry_ptr),
  5   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  5   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  5   175 	     2 reserved	      unal bit (36);	/* for future use */
  5   176 
  5   177      declare path_entry_ptr	      ptr;
  5   178 
  5   179 
  5   180 
  5   181 
  5   182 
  5   183 /* declarations for model of postfix stack holding the check option boolean expression
  5   184*   the following encoding values indicate the corresponding type of stack element
  5   185*
  5   186*   1  =
  5   187*   2  ^=
  5   188*   3  >
  5   189*   4  <
  5   190*   5  >=
  5   191*   6  <=
  5   192*
  5   193*   10  and
  5   194*   20  or
  5   195*   30  not
  5   196*
  5   197*   40  - (minus)
  5   198*
  5   199*   50  domain variable(same name as domain)
  5   200*
  5   201*   60  constant(number, bit string, or character string)
  5   202*
  5   203**/
  5   204 
  5   205 
  5   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  5   207 	     2 next	      bit (18),		/* link to next in list */
  5   208 	     2 type	      fixed binary,		/* code for this element type */
  5   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  5   210*						   if this is a constant element type */
  5   211 
  5   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  5   213 
  5   214 
  5   215 
  5   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  5   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  5   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  5   219 
  5   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  5   221 
  5   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  5   223 
  5   224 /* version structure, giving status of source for CMDB/RMDB,
  5   225*   status of model, and status of resultant */
  5   226 
  5   227 /* version number is in form MM.N.Y
  5   228*   where MM is the major version number, N is the minor version alteration,
  5   229*   and Y is the lastest modification to that alteration,
  5   230*   where M and N represent numbers 0-9, and Y is a letter */
  5   231 
  5   232      declare 1 version_status	      unal based (version_status_ptr),
  5   233 	     2 cmdb_rmdb,
  5   234 	       3 major	      fixed bin,
  5   235 	       3 minor	      fixed bin,
  5   236 	       3 modification     char (4),
  5   237 	     2 model,
  5   238 	       3 major	      fixed bin,
  5   239 	       3 minor	      fixed bin,
  5   240 	       3 modification     char (4),
  5   241 	     2 resultant,
  5   242 	       3 major	      fixed bin,
  5   243 	       3 minor	      fixed bin,
  5   244 	       3 modification     char (4);
  5   245 
  5   246      declare version_status_ptr     ptr;
  5   247 
  5   248 
  5   249 /* maintains information only about the db creation */
  5   250 
  5   251      declare 1 changer	      unal based (changer_ptr),
  5   252 	     2 id		      char (32),
  5   253 	     2 time	      fixed bin (71),
  5   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  5   255 
  5   256      declare changer_ptr	      ptr;
  5   257 
  5   258 
  5   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  5   260 	     02 len	      fixed bin,		/* length of the message */
  5   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  5   262 	     02 name	      char (32),		/* name of thing that set the message */
  5   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  5   264*                                                               that caused the database to become inconsistent */
  5   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  5   266 
  5   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  5   268 
  5   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  5   270 
  5   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  5   272 
  5   273 
      294 
      295 
  6     1 /* BEGIN INCLUDE FILE mrds_rst_global_lists.incl.pl1	jeg	7/17/78	*/
  6     2 
  6     3 /* note: mrds_rst_list_element$add and delete entries
  6     4*   makes use of the following structure type correspondence
  6     5*
  6     6*   structure_type = 1  refers to gl (global list element)
  6     7*
  6     8*   structure_type = 2 refers to sl (global sublist element)
  6     9*
  6    10*   structure_type = 3  refers to seg_info(segment information element)
  6    11*
  6    12**/
  6    13 
  6    14 
  6    15 dcl 1 gl aligned based (gl_ptr),			/* Template for global list entry */
  6    16     2 type fixed bin,				/* structure_type, usefull when overlay used */
  6    17     2 name char (32),				/* Item name */
  6    18     2 item_info_ptr ptr,				/* Pointer to info structure for this item */
  6    19     2 parse_info_ptr ptr,				/* Pointer to info obtained by parsing source */
  6    20     2 other_info_ptr ptr,				/* Pointer to additional info str if needed */
  6    21     2 item_sub_list_ptr ptr,				/* Pointer to sub list of items if neccessary for this his item */
  6    22     2 file_info_ptr ptr,				/* Pointer to file info for this entry */
  6    23     2 file_model_ptr ptr,				/* Pointer to file model for this entry */
  6    24     2 affected bit (1) unal,				/* ON => affected by some directive */
  6    25     2 cmdb bit (1) unal,				/* ON => affected by cmdb directive */
  6    26     2 undefine bit (1) unal,				/* ON => affected by undefine directive */
  6    27     2 define bit (1) unal,				/* ON => affected by define directive */
  6    28     2 redefine bit (1) unal,				/* ON => affected by redefine directive */
  6    29     2 superior_assigned bit (1) unal,			/* ON => has parent */
  6    30     2 inferior_assigned bit (1) unal,			/* ON => child present */
  6    31     2 complete bit (1) unal,				/* ON => all things present */
  6    32     2 consistant bit (1) unal,			/* ON => correct model */
  6    33     2 reserved bit (26) unal,				/* for future use */
  6    34     2 child_defined bit (1) unal ;			/* ON => global element entered by child */
  6    35 
  6    36 dcl  gl_ptr ptr;					/* Pointer to gl structure */
  6    37 
  6    38 
  6    39 
  6    40 dcl 1 sl aligned based (sl_ptr),			/* Template of sub list entry for global list */
  6    41     2 type fixed bin,				/* structure_type, usefull when overlay used */
  6    42     2 name char (32),				/* Name of item */
  6    43     2 item_info_ptr ptr,				/* Pointer to info structure for this entry */
  6    44     2 parse_info_ptr ptr,				/* Pointer to info obtained by parsing source */
  6    45     2 old_other_info_ptr ptr,				/* Pointer to old version of other info */
  6    46     2 new_other_info_ptr ptr,				/* Pointer to new version of other info */
  6    47     2 global_list_ptr ptr,				/* pointer to corresponding global list element */
  6    48     2 reserved bit (36) unal;				/* Reserved for future use */
  6    49 
  6    50 dcl  sl_ptr ptr;					/* Pointer to sub list structure */
  6    51 
  6    52 
  6    53 dcl 1 seg_info based (seg_info_ptr),			/* Info about segment initiated */
  6    54     2 name char (32),				/* Segment name */
  6    55     2 dir char (168),				/* Absolute path of containing directory */
  6    56     2 seg_ptr ptr,					/* Pointer to base of segment */
  6    57     2 bcnt fixed bin (24);				/* Bit count of segment */
  6    58 
  6    59 dcl  seg_info_ptr ptr;				/* Pointer to seg_info str */
  6    60 
  6    61 
  6    62 
  6    63 dcl  MAIN_LIST fixed bin internal static options (constant) init (1);
  6    64 dcl  SUB_LIST fixed bin internal static options (constant) init (2);
  6    65 dcl  SEG_INFO fixed bin internal static options (constant) init (3);
  6    66 
  6    67 declare 1 list_ovrly aligned based (list_ovrly_ptr),	/* overlay for top part of gl and sl list elements */
  6    68         2 type fixed bin,				/* structure_type, 1 => gl, 2 => sl */
  6    69         2 name char (32),				/* Name of item */
  6    70         2 item_info_ptr ptr,				/* pointer to info structure for this entry */
  6    71         2 parse_info_ptr ptr,				/* pointer to info obtained by parsing source */
  6    72         2 other_info_ptr ptr ;			/* pointer to additional info structure if needed */
  6    73 
  6    74 declare  list_ovrly_ptr ptr ;				/* pointer to overlay structure */
  6    75 
  6    76 
  6    77 declare  saved_child_count fixed bin based (saved_child_count_ptr) ; /* parent link structure child count */
  6    78 declare  saved_child_count_ptr ptr ;			/* pointer to remembered number of children */
  6    79 
  6    80 
  6    81 /* USES AND MEANING OF LIST ELEMENT ENTRIES
  6    82*
  6    83*   DOMAIN GLOBAL LIST --------------------------
  6    84*
  6    85*   gl.type - - MAIN_LIST
  6    86*   gl.name - - 32 char domain name
  6    87*   gl.item_info_ptr - - pointer to domain_info for this domain
  6    88*   gl.parse_info_ptr - - pointer to parse info structure
  6    89*   gl.other_info_ptr - - dbm_ptr, pointer to mdbm_db_model
  6    90*   gl.item_sub_list_ptr - - pointer to sublist of attributes using this domain
  6    91*   gl.file_info_ptr - - null ()
  6    92*   gl.file_model_ptr - - null ()
  6    93*   gl.superior_assigned - - ON => domain referenced by some relation
  6    94*   gl.inferior_assigned - - ON => referencing attribute present
  6    95*   gl.complete - - ON => domain_info present
  6    96*   gl.consistant - - always ON
  6    97*
  6    98*   DOMAIN GLOBAL LIST "REFERENCING ATTRIBUTES" SUBLIST ----------------
  6    99*
  6   100*   sl.type - - SUB_LIST
  6   101*   sl.name - - 32 char attribute name
  6   102*   sl.item_info_ptr - - pointer to this attribute's attribute_info
  6   103*   sl.parse_info_ptr - - pointer to parse info structure
  6   104*   sl.old_other_info_ptr - - null ()
  6   105*   sl.new_other_info_ptr - - pointer to this domain's global list element
  6   106*   sl.global_list_ptr - - pointer to attribute's global list element
  6   107*
  6   108*   ATTRIBUTE GLOBAL LIST -----------------
  6   109*
  6   110*   gl.type - - MAIN_LIST
  6   111*   gl.name - - 32 char attribute name
  6   112*   gl.item_info_ptr - - pointer to corresponding domain sublist element for this attribute
  6   113*   gl.parse_info_ptr - - pointer to parse info structure
  6   114*   gl.other_info_ptr - - domain_info of domain for this attribute
  6   115*   gl.item_sub_list_ptr - - pointer to sublist of relations that use this attribute
  6   116*   gl.file_info_ptr - - null (), use pointer(fm_ptr,file_model.fi_ptr)
  6   117*   gl.file_model_ptr - - null (), use pointer(ai_ptr,0), ai_ptr from corres. rel's attr sublist
  6   118*   gl.superior_assigned - - ON => relation contains this attribute
  6   119*   gl.inferior_assigned - - ON => attribute references known domain
  6   120*   gl.complete - - ON => attr_info present for this attribute
  6   121*   gl.consistant - - OFF => no domain for this attribute
  6   122*
  6   123*   ATTRIBUTE GLOBAL LIST "USED IN RELATION" SUBLIST ------------------
  6   124*
  6   125*   sl.type - - SUB_LIST
  6   126*   sl.name - - 32 char relation name
  6   127*   sl.item_info_ptr - - pointer to this relation's rel_info
  6   128*   sl.parse_info_ptr - - pointer to parse info structure
  6   129*   sl.old_other_info_ptr - - pointer to attribute's attr_info in this relation
  6   130*   sl.new_other_info_ptr - - pointer to this attribute's global list element
  6   131*   sl.global_list_ptr - - pointer to relation's global list element
  6   132*
  6   133*   RELATION GLOBAL LIST -------------------
  6   134*
  6   135*   gl.type - - MAIN_LIST
  6   136*   gl.name - - 32 char relation name
  6   137*   gl.item_info_ptr - - pointer to rel_info for this relation
  6   138*   gl.parse_info_ptr - - pointer to parse info structure
  6   139*   gl.other_info_ptr - - pointer to global list element of file containing this relation
  6   140*   gl.item_sub_list_ptr - - pointer to sublist of attributes in this relation
  6   141*   gl.file_info_ptr - - pointer to file_info of this relation's file
  6   142*   gl.file_model_ptr - - pointer to file_model of this relation's file
  6   143*   gl.superior_assigned - - ON => file present to hold this relation
  6   144*   gl.inferior_assigned - - ON => attribute's present in this relation
  6   145*   gl.complete - - ON => rel_info assigned to this relation
  6   146*   gl.consistant - - OFF => no attributes for this relation
  6   147*
  6   148*   RELATION GLOBAL LIST "CONTAINED ATTRIBUTE" SUBLIST ----------------
  6   149*
  6   150*   sl.type - - SUB_LIST
  6   151*   sl.name - - 32 char attribute name
  6   152*   sl.item_info_ptr - - pointer to this attribute's attribute_info
  6   153*   sl.parse_info_ptr - - pointer to parse info structure
  6   154*   sl.old_other_info_ptr - - pointer to domain_info for this attribute in old model
  6   155*   sl.new_other_info_ptr - - pointer to domain_info for this attribute in new model
  6   156*   sl.global_list_ptr - - pointer to attribute's global list element
  6   157*
  6   158*   FILE GLOBAL LIST -----------------------
  6   159*
  6   160*   gl.type - - MAIN_LIST
  6   161*   gl.name - - 30 char file name plus 2 trailing blanks
  6   162*   gl.item_info_ptr - - pointer to file_info for this file
  6   163*   gl.parse_info_ptr - - pointer to parse info structure
  6   164*   gl.other_info_ptr - - null ()
  6   165*   gl.item_sub_list_ptr - - pointer to sublist of relations contained in this file
  6   166*   gl.file_info_ptr - - pointer to file_info for this file
  6   167*   gl.file_model_ptr - - pointer to file_model for this file
  6   168*   gl.superior_assigned - - ON => file_model present for this file
  6   169*   gl.inferior_assigned - - ON => relation present for this file
  6   170*   gl.complete - - OFF => not formatted yet
  6   171*   gl.consistant - - ON => no relations present
  6   172*
  6   173*   FILE GLOBAL LIST "CONTAINED RELATION" SUBLIST ----------------
  6   174*
  6   175*   sl.type - - SUB_LIST
  6   176*   sl.name - - 32 char relation name
  6   177*   sl.item_info_ptr - - relation's rel_info pointer
  6   178*   sl.parse_info_ptr - - pointer to parse info structure
  6   179*   sl.old_other_info_ptr - - null ()
  6   180*   sl.new_other_info_ptr - - pointer to file global list element
  6   181*   sl.global_list_ptr - - pointer to relation's global list element
  6   182*
  6   183*   FOREIGN KEY GLOBAL LIST --------------------
  6   184*
  6   185*   gl.type - - MAIN_LIST
  6   186*   gl.name - - 32 char link(foreign key) name, parent_link_info.name
  6   187*   gl.item_info_ptr - - pointer to parent_link_info for this foreign key
  6   188*   gl.parse_info_ptr - - pointer to parse info structure
  6   189*   gl.other_info_ptr - - pointer to parent relation global list element
  6   190*   gl.item_sub_list_ptr - - pointer to sublist of child relations for this parent
  6   191*   gl.file_info_ptr - - pointer to file_info for parent relation's file
  6   192*   gl.file_model_ptr - - pointer to file_model for parent relation's file
  6   193*   gl.superior_assigned - - ON => parent present
  6   194*   gl.inferior_assigned - - ON => child present
  6   195*   gl.complete - - ON => pli_info and cli_info present
  6   196*   gl.consistant - - ON => rels/attrs found and corres domains match
  6   197*   gl.child_defined - - ON => not defined by parent, but by one of it's children
  6   198*
  6   199*   FOREIGN KEY GLOBAL LIST CHILDREN SUBLIST
  6   200*
  6   201*   sl.type - - SUB_LIST
  6   202*   sl.name - - 32 char name of relation representing this child
  6   203*   sl.item_info_ptr - - pointer to child_link_info for this child
  6   204*   sl.parse_info_ptr - - pointer to parse info structure
  6   205*   sl.old_other_info_ptr - - pointer to file_model holding this child relation
  6   206*   sl.new_other_info_ptr - - pointer to rel_info for this child
  6   207*   sl.global_list_ptr - - pointer to child relation global list element
  6   208*
  6   209*   NOTE: all pointers are to the new model unless otherwise indicated
  6   210*
  6   211**/
  6   212 
  6   213 /* END INCLUDE FILE mrds_rst_global_lists.incl.pl1	*/
  6   214 
      296 
      297 
  7     1 /* BEGIN INCLUDE FILE mrds_rst_tree.incl.pl1   jeg 7/19/78 */
  7     2 
  7     3 /* common declarations for threaded binary tree routines
  7     4*
  7     5*   The tree maintains an inorder list of it's keys.
  7     6*   this means that for a given node, any key in it's left subtree
  7     7*   is "less" than the given node's key and that any key in it's
  7     8*   right subtree is "greater" than the given node's key.
  7     9*
  7    10*   Threads are maintained to allow fast and easy traversal of the tree.
  7    11*   threads occupy the position of null pointers of an straight binary tree,
  7    12*   thus they only occur in leaf nodes.
  7    13*   left threads point to that nodes inorder predecessor.
  7    14*   right threads point to that nodes inorder successor.
  7    15*
  7    16*   note: root_ptr must be passed by reference
  7    17*   ( not by value ) so it can be changed .
  7    18*   Also, each parameter must be a different
  7    19*   variable. The same variable used for two
  7    20*   or more arguments when any of the tree
  7    21*   routines are called will produce errors */
  7    22 
  7    23 
  7    24 declare  key char (32) aligned ;			/* data key directing search */
  7    25 
  7    26 declare  root_ptr ptr ;				/* pointer to head of desired list */
  7    27 declare  node_ptr ptr ;				/* pointer to key node, when success */
  7    28 declare  parent_ptr ptr ;				/* pointer to direct parent of current node */
  7    29 declare  data_ptr ptr ;				/* pointer from tree node to data structure headed by node */
  7    30 declare  successor_ptr ptr ;				/* pointer to inorder successor of current node in tree */
  7    31 declare  successor_parent_ptr ptr ;			/* pointer to immediate tree parent of inorder successor node */
  7    32 declare  predecessor_ptr ptr ;			/* pointer to inorder predecessor of current node */
  7    33 declare  predecessor_parent_ptr ptr ;			/* pointer to direct parent of predecessor */
  7    34 declare  area_ptr ptr ;				/* pointer to based area for node allocation/freeing */
  7    35 
  7    36 declare  work_area area based (area_ptr) ;		/* area of storage for tree */
  7    37 
  7    38 declare  success bit (1) ;				/* on if operation successful */
  7    39 declare  thread bit (1) aligned ;			/* current thread indicator, on = thread, off = pointer */
  7    40 
  7    41 declare 1 node based (node_ptr) aligned,		/* tree element */
  7    42         2 data ptr,					/* data field link */
  7    43         2 key char (32),				/* data key */
  7    44         2 right,					/* right branch link */
  7    45 	3 thread bit (1),				/* indicates whether link is thread or pointer */
  7    46 	3 link ptr,				/* pointer to right descendent or thread to successor */
  7    47         2 left,					/* left branch link */
  7    48 	3 thread bit (1),				/* indicates whether link is thread or pointer */
  7    49 	3 link ptr,				/* pointer to left descendent or thread to predecessor */
  7    50         2 pad bit (34) ;				/* reserved for future flags */
  7    51 
  7    52 /* END INCLUDE FILE mrds_rst_tree.incl.pl1  */
  7    53 
  7    54 
  7    55 
  7    56 
      298 
      299      end mrds_rst_index_handler;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1142.6  mrds_rst_index_handler.pl1        >special_ldd>install>MR12.0-1187>mrds_rst_index_handler.pl1
289          1    10/14/83  1609.1  mrds_rst_rsc.incl.pl1             >ldd>include>mrds_rst_rsc.incl.pl1
290          2    10/14/83  1608.4  mrds_rst_semantics.incl.pl1       >ldd>include>mrds_rst_semantics.incl.pl1
291          3    10/14/83  1608.6  mrds_rst_parse_info.incl.pl1      >ldd>include>mrds_rst_parse_info.incl.pl1
292          4    10/16/86  1139.9  mdbm_file_model.incl.pl1          >special_ldd>install>MR12.0-1187>mdbm_file_model.incl.pl1
294          5    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
296          6    10/14/83  1608.4  mrds_rst_global_lists.incl.pl1    >ldd>include>mrds_rst_global_lists.incl.pl1
298          7    10/14/83  1608.6  mrds_rst_tree.incl.pl1            >ldd>include>mrds_rst_tree.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CMDB                                   constant        fixed bin(17,0)          initial dcl 2-31 ref 104
DEFINE                                 constant        fixed bin(17,0)          initial dcl 2-29 ref 104
OFF                             000016 constant        bit(1)                   initial unaligned dcl 280 set ref 213 242*
ON                              000000 constant        bit(1)                   initial unaligned dcl 279 set ref 89* 159 160 210
                                                                                  211 215
REDEFINE                               constant        fixed bin(17,0)          initial dcl 2-30 ref 228
UNDEFINE                               constant        fixed bin(17,0)          initial dcl 2-28 ref 93
affected                 26            based           bit(1)                   level 2 packed unaligned dcl 6-15 set ref 159* 160*
                                                                                  215*
ai_ptr                          000232 automatic       pointer                  dcl 4-209 set ref 181* 182 184 188 199 199 210 213
attr_gl_ptr                     000100 automatic       pointer                  dcl 273 set ref 214* 215
attr_info                              based           structure                level 1 dcl 4-192
attr_sl_ptr                     000106 automatic       pointer                  dcl 276 set ref 180* 181 214
bit_length               14            based           fixed bin(35,0)          level 2 dcl 4-192 ref 199 199
cd                                     parameter       fixed bin(35,0)          dcl 251 set ref 248 254*
ceil                                                   builtin function         dcl 259 ref 199
char                                                   builtin function         dcl 259 ref 115 130 171 188 199 199 199
data                                   based           pointer                  level 2 dcl 7-41 ref 145 180
directive                              based           structure                level 1 unaligned dcl 2-5
directive_ptr                   000010 internal static pointer                  dcl 2-24 in procedure "mrds_rst_index_handler" set
                                                                                  ref 83* 93 97 104 104 228 233
directive_ptr           242            based           pointer                  level 2 in structure "rsc" dcl 1-29 in procedure
                                                                                  "mrds_rst_index_handler" ref 83
file_gl_ptr                     000102 automatic       pointer                  dcl 274 set ref 150* 151 159
fm_ptr                          000226 automatic       pointer                  dcl 4-108 set ref 182* 184
gl                                     based           structure                level 1 dcl 6-15
global_list_ptr          22            based           pointer                  level 2 dcl 6-40 ref 214
h_gattr_ptr             222            based           pointer                  level 2 dcl 1-29 set ref 125*
h_grel_ptr              224            based           pointer                  level 2 dcl 1-29 set ref 111*
i_ptr                                  based           pointer                  level 2 dcl 3-107 ref 107
index                    12            based           structure                array level 2 unaligned dcl 2-37
index_attr               10(01)        based           bit(1)                   level 2 packed unaligned dcl 4-192 set ref 188 210*
index_id                 11            based           bit(36)                  level 2 dcl 4-192 set ref 213*
index_ptr                       000222 automatic       pointer                  dcl 3-115 set ref 87* 88 107 111 115 115 152 152 171
                                                                                  188 199
index_relation_name             000212 automatic       char(32)                 unaligned dcl 284 set ref 88* 89 242
indexed                  11(04)        based           bit(1)                   level 2 packed unaligned dcl 4-126 set ref 211*
ioa_$rs                         000022 constant        entry                    external dcl 265 ref 152
item                                   based           structure                level 1 dcl 3-150
item_info_ptr            12            based           pointer                  level 2 in structure "sl" dcl 6-40 in procedure
                                                                                  "mrds_rst_index_handler" ref 181
item_info_ptr            12            based           pointer                  level 2 in structure "gl" dcl 6-15 in procedure
                                                                                  "mrds_rst_index_handler" ref 146
item_ptr                        000224 automatic       pointer                  dcl 3-157 set ref 107* 115 123 125 130 130 136* 136
                                                                                  164 166 171 171 188 188 199 199 221* 221
item_sub_list_ptr        20            based           pointer                  level 2 dcl 6-15 set ref 166*
line_num                 14            based           fixed bin(24,0)          level 2 in structure "rel_index" dcl 3-107
                                                                                  in procedure "mrds_rst_index_handler" set ref 115
                                                                                  152*
line_num                 13            based           fixed bin(24,0)          level 2 in structure "item" dcl 3-150 in procedure
                                                                                  "mrds_rst_index_handler" ref 130 171 188 199
list_ptr                               parameter       pointer                  dcl 260 ref 36 87
ltrim                                                  builtin function         dcl 259 ref 115 130 171 188 199 199 199
message                         000110 automatic       varying char(256)        dcl 282 set ref 152* 156
message_length                  000211 automatic       fixed bin(21,0)          dcl 283 set ref 152*
mrds_data_$max_key_len          000036 external static fixed bin(35,0)          dcl 285 ref 199 199
mrds_error_$long_key            000040 external static fixed bin(35,0)          dcl 286 set ref 199*
mrds_error_$previously_defined_index
                                000024 external static fixed bin(35,0)          dcl 267 set ref 188*
mrds_error_$rst_not_rel_attr    000030 external static fixed bin(35,0)          dcl 269 set ref 171*
mrds_error_$rst_undef_rel       000026 external static fixed bin(35,0)          dcl 268 set ref 115*
mrds_error_$rst_undone_option   000034 external static fixed bin(35,0)          dcl 271 set ref 98* 156* 234*
mrds_error_$undef_attr          000032 external static fixed bin(35,0)          dcl 270 set ref 130*
mrds_rst_error                  000016 constant        entry                    external dcl 263 ref 115 130 156 171 188 199 254
mrds_rst_meter                  000014 constant        entry                    external dcl 262 ref 89 242
mrds_rst_tree_search            000020 constant        entry                    external dcl 264 ref 111 125 166
msg                                    parameter       char                     unaligned dcl 252 set ref 248 254*
name                      2            based           char(32)                 level 2 dcl 3-150 set ref 115 125* 130 166* 171 188
                                                                                  199
next                                   based           pointer                  level 2 dcl 3-150 ref 136 221
node                                   based           structure                level 1 dcl 7-41
node_ptr                        000234 automatic       pointer                  dcl 7-27 set ref 111* 125* 145 166* 180
null                                                   builtin function         dcl 259 ref 123 151 164 184 184 184
number                   13            based           fixed bin(17,0)          array level 3 dcl 2-37 ref 97 233
other_info_ptr           16            based           pointer                  level 2 dcl 6-15 ref 150
parent_ptr                      000236 automatic       pointer                  dcl 7-28 set ref 111* 125* 166*
parse_info_ptr           14            based           pointer                  level 2 dcl 6-15 ref 151
pointer                                                builtin function         dcl 259 ref 182
rel_gl_ptr                      000104 automatic       pointer                  dcl 275 set ref 145* 146 150 160 166
rel_index                              based           structure                level 1 dcl 3-107
rel_info                               based           structure                level 1 dcl 4-126
rel_name                  2            based           char(32)                 level 2 dcl 3-107 set ref 88 111* 115 152* 171 188
                                                                                  199
ri_ptr                          000230 automatic       pointer                  dcl 4-185 set ref 146* 184 211
rsc                                    based           structure                level 1 unaligned dcl 1-29
rsc_ptr                                parameter       pointer                  dcl 1-94 set ref 36 83 85 89 89* 111 115* 125 130*
                                                                                  156* 171* 188* 199* 242 242* 254*
rtrim                                                  builtin function         dcl 259 ref 115 115 130 171 171 188 188 199 199
sev                                    parameter       fixed bin(17,0)          dcl 250 set ref 248 254*
sl                                     based           structure                level 1 dcl 6-40
stmt                                   based           structure                array level 1 unaligned dcl 2-37
stmt_ptr                        000012 internal static pointer                  dcl 2-68 in procedure "mrds_rst_index_handler" set
                                                                                  ref 85* 97 233
stmt_ptr                244            based           pointer                  level 2 in structure "rsc" dcl 1-29 in procedure
                                                                                  "mrds_rst_index_handler" ref 85
success                         000240 automatic       bit(1)                   unaligned dcl 7-38 set ref 111* 113 125* 127 166*
                                                                                  169
trace_sw                206(07)        based           bit(1)                   level 2 packed unaligned dcl 1-29 ref 89 242
type                                   based           fixed bin(17,0)          level 2 dcl 2-5 ref 93 97 104 104 228 233

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
MAIN_LIST                              internal static fixed bin(17,0)          initial dcl 6-63
SEG_INFO                               internal static fixed bin(17,0)          initial dcl 6-65
SUB_LIST                               internal static fixed bin(17,0)          initial dcl 6-64
accum_token_ptr                        internal static pointer                  dcl 3-171
addr                                                   builtin function         dcl 259
al_ptr                                 automatic       pointer                  dcl 4-345
alloc_length                           internal static fixed bin(35,0)          dcl 5-222
area_ptr                               automatic       pointer                  dcl 7-34
atd                                    based           char                     unaligned dcl 4-109
atd_len                                automatic       fixed bin(17,0)          dcl 4-111
atd_ptr                                automatic       pointer                  dcl 4-110
attdom_ptr                             automatic       pointer                  dcl 3-84
attr_list                              based           structure                level 1 dcl 4-341
attribute                              based           structure                level 1 dcl 3-63
attribute_domain                       based           structure                level 1 dcl 3-77
attribute_ptr                          automatic       pointer                  dcl 3-73
changer                                based           structure                level 1 packed unaligned dcl 5-251
changer_ptr                            automatic       pointer                  dcl 5-256
child_link_info                        based           structure                level 1 dcl 4-283
children                               based           structure                level 1 dcl 3-131
children_ptr                           automatic       pointer                  dcl 3-136
cli_ptr                                automatic       pointer                  dcl 4-329
cna_ptr                                automatic       pointer                  dcl 4-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 4-112
constant                               based           structure                level 1 unaligned dcl 5-216
constant_ptr                           automatic       pointer                  dcl 5-220
data_ptr                               automatic       pointer                  dcl 7-29
db_model                               based           structure                level 1 dcl 5-72
dbm_ptr                                automatic       pointer                  dcl 5-106
delete_name                            based           structure                level 1 dcl 3-160
delete_name_ptr                        automatic       pointer                  dcl 3-165
di_ptr                                 automatic       pointer                  dcl 5-155
dom_list                               based           structure                level 1 unaligned dcl 3-189
dom_list_ptr                           automatic       pointer                  dcl 3-188
domain                                 based           structure                level 1 dcl 3-11
domain_info                            based           structure                level 1 dcl 5-125
domain_ptr                             automatic       pointer                  dcl 3-45
dp_ptr                                 automatic       pointer                  dcl 4-356
dup_prev                               based           structure                level 1 dcl 4-353
fi_ptr                                 automatic       pointer                  dcl 5-119
file                                   based           structure                level 1 dcl 3-89
file_info                              based           structure                level 1 dcl 5-113
file_model                             based           structure                level 1 dcl 4-40
file_ptr                               automatic       pointer                  dcl 3-104
fixed                                                  builtin function         dcl 259
fixup_token                            based           char                     unaligned dcl 3-178
foreign_key                            based           structure                level 1 dcl 3-139
forkey_ptr                             automatic       pointer                  dcl 3-147
gl_ptr                                 automatic       pointer                  dcl 6-36
key                                    automatic       char(32)                 dcl 7-24
link                                   based           structure                level 1 dcl 3-118
link_ptr                               automatic       pointer                  dcl 3-128
list_ovrly                             based           structure                level 1 dcl 6-67
list_ovrly_ptr                         automatic       pointer                  dcl 6-74
message_str                            based           structure                level 1 packed unaligned dcl 5-259
message_str_len                        automatic       fixed bin(17,0)          dcl 5-269
message_str_ptr                        automatic       pointer                  dcl 5-267
mrds_data_$max_line_size               external static fixed bin(35,0)          dcl 3-173
mrds_data_$max_string_size             external static fixed bin(35,0)          dcl 3-172
ncomp_init                             automatic       fixed bin(17,0)          dcl 4-116
output_text                            based           varying char             dcl 3-175
output_text_ptr                        internal static pointer                  dcl 3-177
parent_link_info                       based           structure                level 1 dcl 4-223
path_entry                             based           structure                level 1 packed unaligned dcl 5-172
path_entry_ptr                         automatic       pointer                  dcl 5-177
pli_ptr                                automatic       pointer                  dcl 4-268
predecessor_parent_ptr                 automatic       pointer                  dcl 7-33
predecessor_ptr                        automatic       pointer                  dcl 7-32
rel                                                    builtin function         dcl 259
relation                               based           structure                level 1 dcl 3-51
relation_ptr                           automatic       pointer                  dcl 3-60
root_ptr                               automatic       pointer                  dcl 7-26
saved_child_count                      based           fixed bin(17,0)          dcl 6-77
saved_child_count_ptr                  automatic       pointer                  dcl 6-78
sc_ptr                                 automatic       pointer                  dcl 4-365
seg_info                               based           structure                level 1 unaligned dcl 6-53
seg_info_ptr                           automatic       pointer                  dcl 6-59
select_chain                           based           structure                level 1 dcl 4-357
sk_ptr                                 automatic       pointer                  dcl 4-352
sl_ptr                                 automatic       pointer                  dcl 6-50
sort_key                               based           structure                level 1 dcl 4-346
source_size                            automatic       fixed bin(35,0)          dcl 3-182
stack_item                             based           structure                level 1 unaligned dcl 5-206
stack_item_ptr                         automatic       pointer                  dcl 5-212
string_source                          based           char                     unaligned dcl 3-184
string_source_ptr                      automatic       pointer                  dcl 3-183
successor_parent_ptr                   automatic       pointer                  dcl 7-31
successor_ptr                          automatic       pointer                  dcl 7-30
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 287
thread                                 automatic       bit(1)                   dcl 7-39
token                                  based           varying char             dcl 3-169
token_length                           automatic       fixed bin(24,0)          dcl 3-174
ua_ptr                                 automatic       pointer                  dcl 5-165
unreferenced_attribute                 based           structure                level 1 dcl 5-159
version_status                         based           structure                level 1 packed unaligned dcl 5-232
version_status_ptr                     automatic       pointer                  dcl 5-246
work_area                              based           area(1024)               dcl 7-36

NAMES DECLARED BY EXPLICIT CONTEXT.
Start                           000342 constant        label                    dcl 83
error                           002365 constant        entry                    internal dcl 248 ref 98 234
exit                            002323 constant        label                    dcl 242 ref 255
mrds_rst_index_handler          000335 constant        entry                    external dcl 36

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2614        2656    2436        2624
Length      3234    2436        42         341     155           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_rst_index_handler              324 external procedure  is an external procedure.  
error                                   internal procedure  shares stack frame of external procedure mrds_rst_index_handler.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 directive_ptr               mrds_rst_index_handler
000012 stmt_ptr                    mrds_rst_index_handler

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_rst_index_handler   000100 attr_gl_ptr                 mrds_rst_index_handler
                         000102 file_gl_ptr                 mrds_rst_index_handler
                         000104 rel_gl_ptr                  mrds_rst_index_handler
                         000106 attr_sl_ptr                 mrds_rst_index_handler
                         000110 message                     mrds_rst_index_handler
                         000211 message_length              mrds_rst_index_handler
                         000212 index_relation_name         mrds_rst_index_handler
                         000222 index_ptr                   mrds_rst_index_handler
                         000224 item_ptr                    mrds_rst_index_handler
                         000226 fm_ptr                      mrds_rst_index_handler
                         000230 ri_ptr                      mrds_rst_index_handler
                         000232 ai_ptr                      mrds_rst_index_handler
                         000234 node_ptr                    mrds_rst_index_handler
                         000236 parent_ptr                  mrds_rst_index_handler
                         000240 success                     mrds_rst_index_handler

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        return_mac          shorten_stack
ext_entry           ceil_fx2            divide_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_$rs                       mrds_rst_error                mrds_rst_meter                mrds_rst_tree_search

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mrds_data_$max_key_len        mrds_error_$long_key          mrds_error_$previously_defined_index
mrds_error_$rst_not_rel_attr  mrds_error_$rst_undef_rel     mrds_error_$rst_undone_option mrds_error_$undef_attr




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     36 000331        83 000342        85 000347        87 000351        88 000354        89 000357        93 000414
     97 000420        98 000425       104 000452       107 000460       111 000463       113 000505       115 000510
    123 000700       125 000706       127 000731       130 000734       134 001070       136 001071       138 001074
    141 001075       145 001076       146 001101       150 001103       151 001105       152 001111       156 001212
    157 001252       159 001254       160 001256       164 001260       166 001264       169 001305       171 001310
    177 001500       180 001502       181 001505       182 001507       184 001511       188 001526       195 001722
    199 001723       208 002246       210 002247       211 002251       213 002254       214 002255       215 002257
    221 002261       222 002264       228 002265       233 002271       234 002276       242 002323       246 002364
    248 002365       254 002376       255 002426


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
