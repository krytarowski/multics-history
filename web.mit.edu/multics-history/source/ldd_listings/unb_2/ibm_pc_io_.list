	COMPILATION LISTING OF SEGMENT ibm_pc_io_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/19/84  0930.7 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* format: style2 */
        7 /*  the user ring ibm_pc io module --- ibm_pc_io_
        8*    Uses the IBM PC-to-PC data transfer protocol as defined by IBM in their
        9*   "Asynchronous Communication Support" manual, version 2.0.
       10*
       11*1.  Definitions
       12*
       13*    CR$     Carriage Return (Hex 0D) (Oct 15)
       14*    XON$    XON Character (Hex 11) (Oct 21)
       15*    XOFF$   XOFF Character (Hex 13) (Oct 23)
       16*    IBG$    Begin Transmission Code (Hex 1C) (Oct 34)
       17*    ITM$    Terminate Transmission Code (Hex 17) (Oct 27)
       18*
       19*2.  Transmission Medium Level Protocol
       20*
       21*    Asynchronous, 7 data bits.
       22*
       23*    Files must be ASCII text files and have no lines longer than 250
       24*    characters. 
       25*
       26*3.  Message Block Level Protocol
       27*
       28*    The standard transmission portion of the block is a variable length
       29*    character block, maximum 250 characters, followed by a carriage return.  
       30*
       31*4.  Program Considerations
       32*
       33*    1.  The program loops, reading the communications line and waiting for
       34*        reception of a text line ending with the control characters IBG$CR$.
       35*
       36*    2.  When such a line is received, the program sends a text line ending
       37*        with IBG$CR$.  (This line may contain an informative message as well,
       38*        such as Starting file transmission)
       39*
       40*
       41*    3.  The program transmits the file.  Each line in the file should
       42*        be sent as a line ending in a Carriage Return (CR$)
       43*
       44*    4.  While transmission is taking place the program should monitor the
       45*        input from the communications line and take the following actions:
       46*            a.  If an XOFF$CR$ is seen, stop transmission of lines.  When
       47*                an XON$CR$ is seen, resume transmission.
       48*            b.  If a line ending in ITM$CR$ is seen, stop all transmission.
       49*                This line will contain as text the reason the receiving IBM
       50*                Personal Computer has requested termination.
       51*            c.  When all lines in the file have been sent, the program should
       52*                send a line ending in ITM$CR$. (This line can contain an
       53*                appropriate message, such as "file transmission completed".)
       54*
       55*5. Program Considerations
       56*
       57*    1.  The program loops, sending out a message ending in IBG$CR$ every 15
       58*        to 20 seconds.  This message may also contain text, such as Ready to
       59*        receive file.)
       60*
       61*    2.  During the loop in Step 1, the communications line is continually 
       62*        monitored for messages from the IBM Personal Computer.   When a line
       63*        ending in IBG$CR$ is received, the program moves on to step 3.
       64*
       65*    3.  Each line received (after the one ending in IBG$CR$) is stored as
       66*        a file record.  As these lines end with Carriage Returns (CR$), the
       67*        program might delete the CR$ before storing a line.  Before storing
       68*        a line, the program checks it to see if it ends in ITM$CR$.  If it
       69*        does, the program does not store that line, but closes the file
       70*        and stops operation.
       71*
       72*    4.  The program can stop transmission by the IBM Personal Computer by 
       73*        sending a line ending with an ITM$CR$.  This line may also contain
       74*        a message giving the reason for the termination.
       75*
       76*    5.  If the program is receiving lines faster that they can be stored, it
       77*        can suspend transmission by sending a line consisting of an XOFF$CR$
       78*        to the IBM Personal Computer.  When it has caught up with the input,
       79*        it can start up transmission by sending a line consisting of an XON$CR$
       80*        to the IBM Personal Computer.
       81**/
       82 
       83 
       84 ibm_pc_io_:
       85      proc;
       86 	return;					/* not an entry  */
       87 						/*  iox_ io module for ibm_pc protocol i/o written 6/84 by M.J. Mallmes  */
       88 
       89 /*  Parameters  */
       90 
       91 	dcl     arg_actual_len	 fixed bin (21);
       92 	dcl     arg_buf_ptr		 ptr;		/* ptr to user buffer (input) */
       93 	dcl     arg_buf_len		 fixed bin (21);	/* length of user buffer (input) */
       94 	dcl     arg_iocbp		 ptr;		/* ptr to iocb (input) */
       95 	dcl     code		 fixed bin (35);	/*  Multics standard error code  (output */
       96 	dcl     com_err_switch	 bit (1) aligned;	/* ON if should call com_err_ for errors (input)  */
       97 	dcl     mode		 fixed bin;
       98 	dcl     option_array	 (*) char (*) varying;
       99 
      100 
      101 /*  Automatic  */
      102 
      103 	dcl     actual_iocbp	 ptr;		/* copy of iocb.actual_iocb_ptr */
      104 	dcl     arg_buf_pos		 fixed bin;	/* index into passed argument buffer  */
      105 	dcl     attach_data_ptr	 ptr;		/* ptr to iocb's attach_data  */
      106 	dcl     buf_ptr		 ptr;
      107 	dcl     buffer_empty	 bit (1);		/* ON if a packet is to be received  */
      108 	dcl     buffer_full		 bit (1);		/* ON if a packet is to be sent  */
      109 	dcl     carriage_return_found	 bit (1);
      110 	dcl     carriage_return_needed bit (1);
      111 	dcl     control_chars	 char (2);
      112 	dcl     ec		 fixed bin (35);
      113 	dcl     iocbp		 ptr;		/*  copy of arg_iocbp */
      114 	dcl     mask		 bit (36) aligned;	/* ips mask */
      115 	dcl     system_free_area_ptr	 ptr;
      116 
      117 /*  Based  */
      118 
      119 	dcl     01 attach_data	 aligned based (attach_data_ptr),
      120 						/* iocb attach_data */
      121 		02 attach_descrip	 char (256) varying,
      122 		02 open_descrip	 char (32) varying,
      123 		02 target_iocbp	 ptr,		/* ptr to target switch iocb */
      124 		02 buf		 char (250),	/* internal buffer  */
      125 		02 buf_pos	 fixed bin (21),	/* index into buf  */
      126 		02 error_code	 fixed bin (35),	/* 0 if normal close operation */
      127 		02 xon_sw		 bit (1) unal,
      128 		02 eof_sw		 bit (1) unal;
      129 
      130 
      131 	dcl     01 open_descrip	 based aligned,	/* open description for iocb  */
      132 		02 length		 fixed bin (17),
      133 		02 string		 char (0 refer (open_descrip.length));
      134 
      135 	dcl     system_free_area	 area based (system_free_area_ptr);
      136 
      137 /*  Constants  */
      138 
      139 	dcl     One_Second		 fixed bin (71) static options (constant) init (1000000);
      140 	dcl     Ten_Seconds		 fixed bin (71) static options (constant) init (10000000);
      141 						/* 110 seconds */
      142 	dcl     Terminate_Transmission char (2) static options (constant) init ("");
      143 	dcl     Buf_Size		 fixed bin (21) static options (constant) init (250);
      144 	dcl     Begin_Transmission	 char (2) static options (constant) init ("");
      145 	dcl     Dim_name		 char (10) static options (constant) init ("ibm_pc_io_");
      146 	dcl     XON		 char (2) static options (constant) init ("");
      147 	dcl     XOFF		 char (2) static options (constant) init ("");
      148 	dcl     CR		 char (1) static options (constant) init ("");
      149 
      150 /*  Builtin    */
      151 
      152 	dcl     (addcharno, addr, hbound, index, lbound, null, rtrim, substr)
      153 				 builtin;
      154 
      155 /* Conditions */
      156 
      157 	dcl     (any_other, cleanup)	 condition;
      158 
      159 /*  External Static  */
      160 
      161 	dcl     error_table_$bad_arg	 fixed bin (35) ext static;
      162 	dcl     error_table_$bad_mode	 fixed bin (35) ext static;
      163 	dcl     error_table_$badopt	 fixed bin (35) ext static;
      164 	dcl     error_table_$end_of_info
      165 				 fixed bin (35) ext static;
      166 	dcl     error_table_$long_record
      167 				 fixed bin (35) ext static;
      168 	dcl     error_table_$noarg	 fixed bin (35) ext static;
      169 	dcl     error_table_$no_iocb	 fixed bin (35) ext static;
      170 	dcl     error_table_$not_attached
      171 				 fixed bin (35) ext static;
      172 	dcl     error_table_$not_detached
      173 				 fixed bin (35) ext static;
      174 	dcl     error_table_$not_open	 fixed bin (35) ext static;
      175 	dcl     error_table_$timeout	 fixed bin (35) ext static;
      176 	dcl     error_table_$unable_to_do_io
      177 				 fixed bin (35) ext static;
      178 
      179 /*  Procedures       */
      180 
      181 	dcl     com_err_		 entry () options (variable);
      182 	dcl     get_system_free_area_	 entry () returns (ptr);
      183 	dcl     hcs_$reset_ips_mask	 entry (bit (36) aligned, bit (36) aligned);
      184 	dcl     hcs_$set_ips_mask	 entry (bit (36) aligned, bit (36) aligned);
      185 	dcl     iox_$err_no_operation	 entry () options (variable);
      186 	dcl     iox_$err_not_attached	 entry () options (variable);
      187 	dcl     iox_$err_not_open	 entry () options (variable);
      188 	dcl     iox_$err_not_closed	 entry () options (variable);
      189 	dcl     iox_$get_chars	 entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
      190 	dcl     iox_$look_iocb	 entry (char (*), ptr, fixed bin (35));
      191 	dcl     iox_$propagate	 entry (ptr);
      192 	dcl     iox_$put_chars	 entry (ptr, ptr, fixed bin (21), fixed bin (35));
      193 	dcl     timed_io_$get_chars	 entry (ptr, fixed bin (71), ptr, fixed bin (21), fixed bin (21), fixed bin (35));
      194 
      195 
      196 
      197 
      198 /*  Include Files    */
      199 
  1     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  1     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  1     3*      version number to IOX2. */
  1     4 /* format: style2 */
  1     5 
  1     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  1     7 	     2 version	      character (4) aligned,	/* IOX2 */
  1     8 	     2 name	      char (32),		/* I/O name of this block. */
  1     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  1    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  1    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  1    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  1    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  1    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  1    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  1    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  1    17 						/* open(p,mode,not_used,s) */
  1    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  1    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  1    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  1    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    24 						/* put_chars(p,bufptr,buflen,s) */
  1    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  1    26 						/* modes(p,newmode,oldmode,s) */
  1    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  1    28 						/* position(p,u1,u2,s) */
  1    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  1    30 						/* control(p,order,infptr,s) */
  1    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  1    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    34 						/* write_record(p,bufptr,buflen,s) */
  1    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  1    36 						/* rewrite_record(p,bufptr,buflen,s) */
  1    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  1    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    39 						/* seek_key(p,key,len,s) */
  1    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    41 						/* read_key(p,key,len,s) */
  1    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  1    43 						/* read_length(p,len,s) */
  1    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  1    45 						/* open_file(p,mode,desc,not_used,s) */
  1    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  1    47 						/* close_file(p,desc,s) */
  1    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  1    49 						/* detach(p,desc,s) */
  1    50 
  1    51      declare iox_$iocb_version_sentinel
  1    52 			      character (4) aligned external static;
  1    53 
  1    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      200 
      201 
  2     1 /* Begin include file ..... iox_modes.incl.pl1 */
  2     2 
  2     3 /* Written by C. D. Tavares, 03/17/75 */
  2     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  2     5 
  2     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  2     7     ("stream_input", "stream_output", "stream_input_output",
  2     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  2     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  2    10      "direct_input", "direct_output", "direct_update");
  2    11 
  2    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  2    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  2    14 
  2    15 dcl (Stream_input initial (1),
  2    16      Stream_output initial (2),
  2    17      Stream_input_output initial (3),
  2    18      Sequential_input initial (4),
  2    19      Sequential_output initial (5),
  2    20      Sequential_input_output initial (6),
  2    21      Sequential_update initial (7),
  2    22      Keyed_sequential_input initial (8),
  2    23      Keyed_sequential_output initial (9),
  2    24      Keyed_sequential_update initial (10),
  2    25      Direct_input initial (11),
  2    26      Direct_output initial (12),
  2    27      Direct_update initial (13)) fixed bin int static options (constant);
  2    28 
  2    29 /* End include file ..... iox_modes.incl.pl1 */
      202 
      203 
      204 
      205 /*  This entry attaches the ibm_pc_io_ i/o module after verifying that
      206*    the target switch is open for stream_input_output  */
      207 
      208 ibm_pc_io_attach:
      209      entry (arg_iocbp, option_array, com_err_switch, code);
      210 
      211 	ec = 0;
      212 	mask = ""b;
      213 	iocbp = arg_iocbp;
      214 
      215 	if hbound (option_array, 1) < 1
      216 	then call error (0, com_err_switch, error_table_$noarg, "Usage:  ibm_pc_io_ switch_name {-control_arguments}");
      217 
      218 	attach_data_ptr = null ();
      219 	on cleanup call clean_up_attach;
      220 
      221 	if iocbp -> iocb.attach_descrip_ptr ^= null ()
      222 	then call error (0, com_err_switch, error_table_$not_detached, "");
      223 
      224 	system_free_area_ptr = get_system_free_area_ ();
      225 	allocate attach_data in (system_free_area) set (attach_data_ptr);
      226 
      227 /*  see if the target switch is attached and open  for stream_input_output */
      228 	call iox_$look_iocb (rtrim (option_array (1)), target_iocbp, ec);
      229 	if ec = error_table_$no_iocb
      230 	then call error (1, com_err_switch, ec, rtrim (option_array (1)));
      231 	if target_iocbp -> iocb.actual_iocb_ptr -> iocb.attach_descrip_ptr = null
      232 	then call error (1, com_err_switch, error_table_$not_attached, rtrim (option_array (1)));
      233 	if target_iocbp -> iocb.actual_iocb_ptr -> iocb.open_descrip_ptr = null
      234 	then call error (1, com_err_switch, error_table_$not_open, rtrim (option_array (1)));
      235 	if target_iocbp -> iocb.actual_iocb_ptr -> iocb.open_descrip_ptr -> open_descrip.string
      236 	     ^= iox_modes (Stream_input_output)
      237 	then call error (1, com_err_switch, error_table_$bad_mode, rtrim (option_array (1)));
      238 
      239 
      240 	attach_data.attach_descrip = Dim_name || " " || rtrim (option_array (1));
      241 	attach_data.open_descrip = "";
      242 	attach_data.eof_sw = "0"b;
      243 	attach_data.buf_pos = 0;
      244 	attach_data.error_code = 0;
      245 
      246 	call hcs_$set_ips_mask (""b, mask);
      247 	iocbp -> iocb.attach_data_ptr = attach_data_ptr;
      248 	iocbp -> iocb.attach_descrip_ptr = addr (attach_data.attach_descrip);
      249 	iocbp -> iocb.detach_iocb = ibm_pc_io_detach;
      250 	iocbp -> iocb.open_descrip_ptr = null ();
      251 	iocbp -> iocb.open = ibm_pc_io_open;
      252 	iocbp -> iocb.modes = iox_$err_no_operation;
      253 	iocbp -> iocb.control = iox_$err_no_operation;
      254 	call iox_$propagate (iocbp);
      255 	call hcs_$reset_ips_mask (mask, ""b);
      256 EXIT:
      257 	return;
      258 
      259 
      260 
      261 /*  Error calls com_err_ if the loud switch is set and goes to the attach return */
      262 
      263 error:
      264      proc (cleanup_level, call_com_err, ec, msg);
      265 
      266 	dcl     cleanup_level	 fixed bin;
      267 	dcl     call_com_err	 bit (1) aligned;
      268 	dcl     ec		 fixed bin (35);	/* Multics standard error code */
      269 	dcl     msg		 char (*);	/* Additional error information */
      270 
      271 	goto Err (cleanup_level);
      272 
      273 Err (1):
      274 	free attach_data;
      275 
      276 Err (0):
      277 	if call_com_err
      278 	then call com_err_ (ec, Dim_name, "^a", msg);
      279 	code = ec;
      280 	goto EXIT;
      281      end error;
      282 
      283 
      284 
      285 
      286 /*  This entry detaches the ibm_pc_io_ i/o module and frees the associated
      287*    information  */
      288 
      289 ibm_pc_io_detach:
      290      entry (arg_iocbp, code);
      291 
      292 	call set_up;
      293 	on any_other call handler;
      294 	call hcs_$set_ips_mask ("0"b, mask);
      295 	actual_iocbp -> iocb.attach_descrip_ptr = null ();
      296 	actual_iocbp -> iocb.attach_data_ptr = null ();
      297 	actual_iocbp -> iocb.open = iox_$err_not_attached;
      298 	actual_iocbp -> iocb.detach_iocb = iox_$err_not_attached;
      299 	call iox_$propagate (actual_iocbp);
      300 	call hcs_$reset_ips_mask (mask, "0"b);
      301 	revert any_other;
      302 	free attach_data;
      303 	return;
      304 
      305 
      306 
      307 /*  This entry sets the open description and the legal operation entries
      308*    in the iocb.  Operation permitted:
      309*
      310*             all the time: close
      311*	   input:        get_chars, get_line
      312*	   output:       put_chars
      313*
      314*    Before returning it performs a handshake with the remote ibm_pc.  */
      315 
      316 
      317 ibm_pc_io_open:
      318      entry (arg_iocbp, mode, com_err_switch, code);
      319 
      320 	on cleanup call terminate_io;
      321 	call set_up;
      322 
      323 	if mode ^= Stream_input & mode ^= Stream_output
      324 	then do;
      325 		code = error_table_$bad_mode;
      326 		return;
      327 	     end;
      328 
      329 	if mode = Stream_output
      330 	then do;					/* Perform handshake - sender */
      331 		call get_control_chars (control_chars, Ten_Seconds, ec);
      332 		if control_chars = Terminate_Transmission
      333 		then ec = error_table_$unable_to_do_io;
      334 
      335 		do while ((ec = 0 | ec = error_table_$timeout) & control_chars ^= Begin_Transmission);
      336 		     call get_control_chars (control_chars, Ten_Seconds, ec);
      337 		     if control_chars = Terminate_Transmission
      338 		     then ec = error_table_$unable_to_do_io;
      339 		end;
      340 
      341 		if ec ^= 0
      342 		then do;
      343 			code = error_table_$unable_to_do_io;
      344 			return;
      345 		     end;
      346 
      347 /* The receiver sent IBG$CR$ so complete the handshake  */
      348 		call send_control_chars (Begin_Transmission);
      349 		attach_data.xon_sw = "1"b;
      350 	     end;
      351 
      352 
      353 	if mode = Stream_input
      354 	then do;					/* Perform handshake - receiver */
      355 
      356 		call send_control_chars (Begin_Transmission);
      357 		call get_control_chars (control_chars, Ten_Seconds, ec);
      358 		if control_chars = Terminate_Transmission
      359 		then ec = error_table_$unable_to_do_io;
      360 
      361 		do while ((ec = 0 | ec = error_table_$timeout) & control_chars ^= Begin_Transmission);
      362 		     call send_control_chars (Begin_Transmission);
      363 		     call get_control_chars (control_chars, Ten_Seconds, ec);
      364 		     if control_chars = Terminate_Transmission
      365 		     then ec = error_table_$unable_to_do_io;
      366 		end;
      367 
      368 		if ec ^= 0
      369 		then do;
      370 			code = error_table_$unable_to_do_io;
      371 			return;
      372 		     end;
      373 	     end;
      374 
      375 	attach_data_ptr -> attach_data.open_descrip = iox_modes (mode);
      376 	on any_other call handler;
      377 	call hcs_$set_ips_mask (""b, mask);
      378 	actual_iocbp -> iocb.open_descrip_ptr = addr (attach_data.open_descrip);
      379 	actual_iocbp -> iocb.open = iox_$err_not_closed;
      380 	actual_iocbp -> iocb.close = ibm_pc_io_close;
      381 	actual_iocbp -> iocb.detach_iocb = iox_$err_not_closed;
      382 	if mode = Stream_input
      383 	then do;
      384 		actual_iocbp -> iocb.get_line = ibm_pc_io_get_line;
      385 		actual_iocbp -> iocb.get_chars = ibm_pc_io_get_chars;
      386 	     end;
      387 	else if mode = Stream_output
      388 	then actual_iocbp -> iocb.put_chars = ibm_pc_io_put_chars;
      389 	call iox_$propagate (actual_iocbp);
      390 	call hcs_$reset_ips_mask (mask, ""b);
      391 	revert any_other;
      392 
      393 	return;
      394 
      395 
      396 /*  This procedure closes the ibm_pc i/o switch.  If the switch was
      397*    open for stream_output it flushes the output buffer and sends
      398*    the ITM$CR$ control characters to the remote ibm_pc.
      399*    If the last packet cannot be transmitted, the i/o switch is
      400*    closed and the error code error_table_$unable_to_do_io is returned.   */
      401 
      402 ibm_pc_io_close:
      403      entry (arg_iocbp, code);
      404 
      405 	on cleanup call terminate_io;
      406 	call set_up;
      407 
      408 	if actual_iocbp -> iocb.open_descrip_ptr -> open_descrip.string = iox_modes (Stream_output)
      409 	     & attach_data.error_code = 0
      410 	then do;
      411 		buf_ptr = addr (attach_data.buf);
      412 		if attach_data.buf_pos ^= 0 & substr (attach_data.buf, buf_pos, 1) ^= CR
      413 		then do;
      414 			attach_data.buf_pos = attach_data.buf_pos + 1;
      415 			substr (attach_data.buf, attach_data.buf_pos, 1) = CR;
      416 		     end;
      417 		call send_data_packet (ec);
      418 		if attach_data.error_code = 0
      419 		then call terminate_io;
      420 	     end;
      421 
      422 	on any_other call handler;
      423 	call hcs_$set_ips_mask ("0"b, mask);
      424 	actual_iocbp -> iocb.open_descrip_ptr = null;
      425 	actual_iocbp -> iocb.open = ibm_pc_io_open;
      426 	actual_iocbp -> iocb.detach_iocb = ibm_pc_io_detach;
      427 	call iox_$propagate (actual_iocbp);
      428 	call hcs_$reset_ips_mask (mask, "0"b);
      429 	revert any_other;
      430 	code = ec;
      431 	return;
      432 
      433 /*  This entry is called to input characters received from the remote
      434*    connection.  Packets are read until the user request is satisfied.  
      435*    Data received, but not requested by the user, is stored in an internal
      436*    buffer, and is available on subsequent reads.            */
      437 
      438 ibm_pc_io_get_chars:
      439      entry (arg_iocbp, arg_buf_ptr, arg_buf_len, arg_actual_len, code);
      440 
      441 	carriage_return_needed = "0"b;
      442 	goto get_data;
      443 
      444 /*  This entry is called to input characters received from the remote
      445*    connection.  Packets are read until the user request is satisfied.
      446*    i.e. a carriage_return is found or the user buffer is filled. Data
      447*    received, but not requested by the user, is stored in an internal
      448*    buffer, and is available on subsequent reads            */
      449 
      450 ibm_pc_io_get_line:
      451      entry (arg_iocbp, arg_buf_ptr, arg_buf_len, arg_actual_len, code);
      452 
      453 	carriage_return_needed = "1"b;
      454 
      455 get_data:
      456 	on cleanup call terminate_io;
      457 	call set_up;
      458 
      459 	if arg_buf_len = 0
      460 	then return;
      461 	if arg_buf_len < 0
      462 	then do;
      463 		code = error_table_$bad_arg;
      464 		return;
      465 	     end;
      466 
      467 	carriage_return_found = "0"b;
      468 	arg_buf_pos = 0;
      469 
      470 	do while ("1"b);
      471 	     ec = 0;
      472 	     call unload_internal_buffer (buffer_empty);
      473 	     if buffer_empty
      474 	     then do;
      475 
      476 		     if attach_data.eof_sw
      477 		     then do;
      478 			     ec = error_table_$end_of_info;
      479 			     return;
      480 			end;
      481 
      482 		     call get_data_packet (ec);
      483 		     if ec ^= 0
      484 		     then do;
      485 			     if ec = error_table_$end_of_info
      486 			     then attach_data.eof_sw = "1"b;
      487 			     else call terminate_io;
      488 			     attach_data.buf_pos = 0;
      489 			     goto done_receive;
      490 			end;
      491 		end;
      492 	     else goto done_receive;
      493 	end;
      494 
      495 done_receive:
      496 	if (ec = 0) & carriage_return_needed & ^carriage_return_found
      497 	then ec = error_table_$long_record;
      498 	arg_actual_len = arg_buf_pos;
      499 	code = ec;
      500 	return;
      501 
      502 
      503 
      504 
      505 /*  This internal procedure moves the data from the internal buffer to the user's
      506*    buffer during a get_chars or get_line operation.  */
      507 
      508 unload_internal_buffer:
      509      proc (buffer_empty);
      510 	dcl     buffer_empty	 bit (1);		/* ON if we need more data from the remote ibm_pc */
      511 	dcl     n_chars		 fixed bin;
      512 	dcl     overlay		 char (arg_buf_len) based;
      513 						/* user buffer */
      514 	dcl     i			 fixed bin;
      515 
      516 
      517 	buffer_empty = "0"b;
      518 	if attach_data.buf_pos = 0
      519 	then do;
      520 		buffer_empty = "1"b;
      521 		return;
      522 	     end;
      523 
      524 	if arg_buf_len - arg_buf_pos > attach_data.buf_pos
      525 	then n_chars = attach_data.buf_pos;
      526 	else n_chars = arg_buf_len - arg_buf_pos;
      527 
      528 	if carriage_return_needed
      529 	then do;
      530 		i = index (substr (attach_data.buf, 1, n_chars), CR);
      531 		if i ^= 0
      532 		then do;
      533 			carriage_return_found = "1"b;
      534 			n_chars = i;
      535 		     end;
      536 
      537 	     end;
      538 
      539 	substr (arg_buf_ptr -> overlay, arg_buf_pos + 1, n_chars) = substr (attach_data.buf, 1, n_chars);
      540 	substr (attach_data.buf, 1, attach_data.buf_pos - n_chars) =
      541 	     substr (attach_data.buf, n_chars + 1, attach_data.buf_pos - n_chars);
      542 	attach_data.buf_pos = attach_data.buf_pos - n_chars;
      543 	arg_buf_pos = arg_buf_pos + n_chars;
      544 	if (^carriage_return_found) & (arg_buf_pos < arg_buf_len)
      545 	then buffer_empty = "1"b;
      546 	return;
      547      end unload_internal_buffer;
      548 
      549 
      550 /*  This internal procedure gets the actual packet from the remote ibm_pc
      551*    during a get_chars or get_line operation.  Data is received via variable
      552*    length packets ending in a carriage return character.  */
      553 
      554 get_data_packet:
      555      proc (ec);
      556 
      557 	dcl     chase_buf_ptr	 ptr;
      558 	dcl     ec		 fixed bin (35);
      559 	dcl     n_read		 fixed bin (21);
      560 	dcl     to_read		 fixed bin (21);
      561 
      562 	ec = 0;
      563 	attach_data.buf_pos = 0;
      564 	to_read = Buf_Size;
      565 	buf_ptr = addr (attach_data.buf);
      566 	chase_buf_ptr = buf_ptr;
      567 
      568 	do while (to_read > 0 & ec = 0);
      569 	     call iox_$get_chars (attach_data.target_iocbp, chase_buf_ptr, to_read, n_read, ec);
      570 	     if ec ^= 0
      571 	     then return;
      572 	     attach_data.buf_pos = attach_data.buf_pos + n_read;
      573 	     if substr (attach_data.buf, attach_data.buf_pos, 1) = CR
      574 	     then to_read = 0;
      575 	     else to_read = Buf_Size - attach_data.buf_pos;
      576 	     chase_buf_ptr = addcharno (buf_ptr, attach_data.buf_pos);
      577 	end;
      578 
      579 	if index (attach_data.buf, Terminate_Transmission) ^= 0
      580 	then ec = error_table_$end_of_info;
      581 	return;
      582      end get_data_packet;
      583 
      584 
      585 
      586 
      587 /*  This entry is called to output characters to the remote connection.
      588*    Data passed by the user is transmitted via variable length packets.
      589*    Where each packet ends in a carriage return. 
      590*    Packets are transmitted until the user request is satisfied.  */
      591 
      592 
      593 ibm_pc_io_put_chars:
      594      entry (arg_iocbp, arg_buf_ptr, arg_buf_len, code);
      595 	/*** entry to perform put_chars operation */
      596 
      597 	on cleanup call terminate_io;
      598 	call set_up;
      599 
      600 	if arg_buf_len = 0
      601 	then return;
      602 	if arg_buf_len < 0
      603 	then do;
      604 		code = error_table_$bad_arg;
      605 		return;
      606 	     end;
      607 
      608 	arg_buf_pos = 0;
      609 	buf_ptr = addr (attach_data.buf);
      610 
      611 	do while ("1"b);
      612 	     ec = 0;
      613 	     call load_internal_buffer (buffer_full);
      614 	     if buffer_full
      615 	     then do;
      616 		     call send_data_packet (ec);
      617 		     if ec ^= 0
      618 		     then do;
      619 			     call terminate_io;
      620 			     goto done_transmitting;
      621 			end;
      622 		     else attach_data.buf_pos = 0;
      623 		end;
      624 	     else goto done_transmitting;
      625 	end;
      626 done_transmitting:
      627 	code = ec;
      628 	return;
      629 
      630 
      631 /*  This internal procedure controls the necessary buffer operations
      632*    during a put_chars operation.  If the user's buffer contains more
      633*    than 250 characters or the user's buffer contains a carriage return
      634*    character then buffer_full = true.
      635*    Otherwise, if a full packet cannot be sent (data does not end in a
      636*    carriage return), data is stored in an internal buffer until 
      637*    (1) subsequent writes fill the buffer, or (2) the ibm_pc switch is
      638*    closed, or (3) a subsequent write operation passes data containing a
      639*    carriage return.             */
      640 
      641 load_internal_buffer:
      642      proc (buffer_full);
      643 
      644 	dcl     buffer_full		 bit (1);
      645 	dcl     CR_found		 bit (1);
      646 	dcl     n_chars		 fixed bin;
      647 	dcl     overlay		 char (arg_buf_len) based;
      648 	dcl     temp_buf_len	 fixed bin (21);
      649 
      650 
      651 	buffer_full = "0"b;
      652 	CR_found = "0"b;
      653 	if arg_buf_pos = arg_buf_len
      654 	then return;
      655 
      656 	temp_buf_len = index (substr (arg_buf_ptr -> overlay, arg_buf_pos + 1, arg_buf_len - arg_buf_pos), CR);
      657 	if temp_buf_len = 0
      658 	then temp_buf_len = arg_buf_len;
      659 	else do;
      660 		temp_buf_len = arg_buf_pos + temp_buf_len;
      661 		CR_found = "1"b;
      662 	     end;
      663 
      664 	if temp_buf_len - arg_buf_pos > Buf_Size - attach_data.buf_pos
      665 	then n_chars = Buf_Size - attach_data.buf_pos;
      666 	else n_chars = temp_buf_len - arg_buf_pos;
      667 
      668 	substr (attach_data.buf, attach_data.buf_pos + 1, n_chars) =
      669 	     substr (arg_buf_ptr -> overlay, arg_buf_pos + 1, n_chars);
      670 
      671 	arg_buf_pos = arg_buf_pos + n_chars;
      672 	attach_data.buf_pos = attach_data.buf_pos + n_chars;
      673 	if CR_found
      674 	then buffer_full = "1"b;
      675 	else if attach_data.buf_pos = Buf_Size
      676 	then do;					/* force a 250-character line */
      677 		arg_buf_pos = arg_buf_pos - 1;
      678 		substr (attach_data.buf, Buf_Size, 1) = CR;
      679 		buffer_full = "1"b;
      680 	     end;
      681 
      682 	return;
      683      end load_internal_buffer;
      684 
      685 
      686 
      687 
      688 
      689 /*  This internal procedure sends a data packet  during a put_chars operation.  */
      690 send_data_packet:
      691      proc (ec);
      692 	dcl     ec		 fixed bin (35);
      693 
      694 
      695 	ec = 0;
      696 
      697 	call get_control_chars (control_chars, One_Second, ec);
      698 	if ec ^= 0 & ec ^= error_table_$timeout
      699 	then goto send_data_error;
      700 	if control_chars = XOFF
      701 	then attach_data.xon_sw = "0"b;
      702 
      703 	do while (^attach_data.xon_sw & control_chars ^= Terminate_Transmission);
      704 	     if control_chars = XON
      705 	     then attach_data.xon_sw = "1"b;
      706 	     if ^attach_data.xon_sw
      707 	     then call get_control_chars (control_chars, One_Second, ec);
      708 	     if ec ^= 0 & ec ^= error_table_$timeout
      709 	     then goto send_data_error;
      710 	end;
      711 
      712 	if control_chars = Terminate_Transmission
      713 	then do;
      714 		ec = error_table_$unable_to_do_io;
      715 		attach_data.error_code = 1;
      716 		return;
      717 	     end;
      718 
      719 	call iox_$put_chars (attach_data.target_iocbp, buf_ptr, attach_data.buf_pos, ec);
      720 	if ec ^= 0
      721 	then goto send_data_error;
      722 	attach_data.buf_pos = 0;
      723 	ec = 0;
      724 	return;
      725 
      726 send_data_error:
      727 	call terminate_io;
      728 	return;
      729      end send_data_packet;
      730 
      731 
      732 /*  This internal procedure sends a control character */
      733 
      734 send_control_chars:
      735      proc (control_chars);
      736 	dcl     control_chars	 char (2);
      737 	dcl     control_char_ptr	 ptr;
      738 
      739 
      740 	control_char_ptr = addr (control_chars);
      741 	call iox_$put_chars (attach_data_ptr -> attach_data.target_iocbp, control_char_ptr, 2, (0));
      742 	return;
      743      end send_control_chars;
      744 
      745 
      746 
      747 
      748 /*  Get a packet control character  */
      749 
      750 get_control_chars:
      751      proc (control_chars, interval, ec);
      752 	dcl     control_buf		 char (1);
      753 	dcl     control_buf_ptr	 ptr;
      754 	dcl     control_chars	 char (2);
      755 	dcl     ec		 fixed bin (35);
      756 	dcl     interval		 fixed bin (71);
      757 	dcl     n_read		 fixed bin (21);
      758 
      759 	ec = 0;
      760 	control_chars = " ";
      761 	control_buf_ptr = addr (control_buf);
      762 	control_buf = " ";
      763 
      764 	do while (ec = 0);
      765 	     call timed_io_$get_chars (attach_data.target_iocbp, interval, control_buf_ptr, 1, n_read, ec);
      766 	     if ec ^= 0
      767 	     then return;
      768 	     if control_buf ^= CR
      769 	     then substr (control_chars, 1, 1) = control_buf;
      770 	     else do;
      771 		     substr (control_chars, 2, 1) = control_buf;
      772 		     return;
      773 		end;
      774 	end;
      775 	return;
      776      end get_control_chars;
      777 
      778 
      779 set_up:
      780      proc;					/* fill in */
      781 	ec = 0;
      782 	mask = ""b;
      783 	actual_iocbp = arg_iocbp -> iocb.actual_iocb_ptr;
      784 	attach_data_ptr = actual_iocbp -> iocb.attach_data_ptr;
      785 	return;
      786      end set_up;
      787 
      788 
      789 
      790 /*  Cleans up the attach data and allocated storage if the attach operation is aborted  */
      791 
      792 clean_up_attach:
      793      proc;
      794 
      795 	if mask ^= ""b
      796 	then call handler;				/* Fatal error */
      797 	if attach_data_ptr = null ()
      798 	then return;
      799 	free attach_data_ptr -> attach_data;
      800 	return;
      801      end clean_up_attach;
      802 
      803 
      804 terminate_io:
      805      proc;
      806 
      807 	attach_data.error_code = 1;
      808 	call send_control_chars (Terminate_Transmission);
      809 	return;
      810      end;
      811 
      812 
      813 /*  Internal procedure to handle faults while IPS interrupts are masked.  For a
      814*    fault while masked, the process is terminated (with the reason "unable to do
      815*    critical I/O")  because the I/O control blocks are in an inconsistent state  */
      816 
      817 handler:
      818      procedure options (non_quick);			/* visible in ifd */
      819 
      820 	dcl     error_table_$unable_to_do_io
      821 				 fixed (35) ext;
      822 	if mask ^= ""b
      823 	then call terminate_this_process (error_table_$unable_to_do_io);
      824 	else return;
      825      end handler;
      826 
      827 
      828 
      829 terminate_this_process:
      830      proc (cd);
      831 
      832 	dcl     cd		 fixed bin (35);
      833 	dcl     terminate_process_	 entry (char (*), ptr);
      834 	dcl     01 ti		 aligned automatic,
      835 		02 version	 fixed,
      836 		02 code		 fixed (35);
      837 
      838 	ti.version = 0;
      839 	ti.code = code;
      840 	call terminate_process_ ("fatal_error", addr (ti));
      841 
      842      end terminate_this_process;
      843      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/19/84  0925.1  ibm_pc_io_.pl1                    >special_ldd>online>7045-11/19/84>ibm_pc_io_.pl1
200          1    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
202          2    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Begin_Transmission              000123 constant        char(2)                  initial unaligned dcl 144 set ref 335 348* 356* 361
                                                                                  362*
Buf_Size                               constant        fixed bin(21,0)          initial dcl 143 ref 564 575 664 664 675 678
CR                              003427 constant        char(1)                  initial unaligned dcl 148 ref 412 415 530 573 656
                                                                                  678 768
CR_found                        000172 automatic       bit(1)                   unaligned dcl 645 set ref 652* 661* 673
Dim_name                        000120 constant        char(10)                 initial unaligned dcl 145 set ref 240 276*
One_Second                      000130 constant        fixed bin(71,0)          initial dcl 139 set ref 697* 706*
Stream_input                           constant        fixed bin(17,0)          initial dcl 2-15 ref 323 353 382
Stream_input_output                    constant        fixed bin(17,0)          initial dcl 2-15 ref 235
Stream_output                          constant        fixed bin(17,0)          initial dcl 2-15 ref 323 329 387 408
Ten_Seconds                     000126 constant        fixed bin(71,0)          initial dcl 140 set ref 331* 336* 357* 363*
Terminate_Transmission          000124 constant        char(2)                  initial unaligned dcl 142 set ref 332 337 358 364
                                                                                  579 703 712 808*
XOFF                                   constant        char(2)                  initial unaligned dcl 147 ref 700
XON                                    constant        char(2)                  initial unaligned dcl 146 ref 704
actual_iocb_ptr          12            based           pointer                  level 2 dcl 1-6 ref 231 233 235 783
actual_iocbp                    000100 automatic       pointer                  dcl 103 set ref 295 296 297 298 299* 378 379 380 381
                                                                                  384 385 387 389* 408 424 425 426 427* 783* 784
addcharno                                              builtin function         dcl 152 ref 576
addr                                                   builtin function         dcl 152 ref 248 378 411 565 609 740 761 840 840
any_other                       000124 stack reference condition                dcl 157 ref 293 301 376 391 422 429
arg_actual_len                         parameter       fixed bin(21,0)          dcl 91 set ref 438 450 498*
arg_buf_len                            parameter       fixed bin(21,0)          dcl 93 ref 438 450 459 461 524 526 539 544 593 600
                                                                                  602 653 656 656 657 668
arg_buf_pos                     000102 automatic       fixed bin(17,0)          dcl 104 set ref 468* 498 524 526 539 543* 543 544
                                                                                  608* 653 656 656 660 664 666 668 671* 671 677* 677
arg_buf_ptr                            parameter       pointer                  dcl 92 ref 438 450 539 593 656 668
arg_iocbp                              parameter       pointer                  dcl 94 ref 208 213 289 317 402 438 450 593 783
attach_data                            based           structure                level 1 dcl 119 set ref 225 273 302 799
attach_data_ptr          16            based           pointer                  level 2 in structure "iocb" dcl 1-6 in procedure
                                                                                  "ibm_pc_io_" set ref 247* 296* 784
attach_data_ptr                 000104 automatic       pointer                  dcl 105 in procedure "ibm_pc_io_" set ref 218* 225*
                                                                                  228 231 233 235 240 241 242 243 244 247 248 273
                                                                                  302 349 375 378 408 411 412 412 412 414 414 415
                                                                                  415 418 476 485 488 518 524 524 530 539 540 540
                                                                                  540 540 542 542 563 565 569 572 572 573 573 575
                                                                                  576 579 609 622 664 664 668 668 672 672 675 678
                                                                                  700 703 704 706 715 719 719 722 741 765 784* 797
                                                                                  799 807
attach_descrip                         based           varying char(256)        level 2 dcl 119 set ref 240* 248
attach_descrip_ptr       14            based           pointer                  level 2 dcl 1-6 set ref 221 231 248* 295*
buf                     114            based           char(250)                level 2 dcl 119 set ref 411 412 415* 530 539 540*
                                                                                  540 565 573 579 609 668* 678*
buf_pos                 213            based           fixed bin(21,0)          level 2 dcl 119 set ref 243* 412 412 414* 414 415
                                                                                  488* 518 524 524 540 540 542* 542 563* 572* 572
                                                                                  573 575 576 622* 664 664 668 672* 672 675 719*
                                                                                  722*
buf_ptr                         000106 automatic       pointer                  dcl 106 set ref 411* 565* 566 576 609* 719*
buffer_empty                    000110 automatic       bit(1)                   unaligned dcl 107 in procedure "ibm_pc_io_" set ref
                                                                                  472* 473
buffer_empty                           parameter       bit(1)                   unaligned dcl 510 in procedure
                                                                                  "unload_internal_buffer" set ref 508 517* 520*
                                                                                  544*
buffer_full                            parameter       bit(1)                   unaligned dcl 644 in procedure
                                                                                  "load_internal_buffer" set ref 641 651* 673* 679*
buffer_full                     000111 automatic       bit(1)                   unaligned dcl 108 in procedure "ibm_pc_io_" set ref
                                                                                  613* 614
call_com_err                           parameter       bit(1)                   dcl 267 ref 263 276
carriage_return_found           000112 automatic       bit(1)                   unaligned dcl 109 set ref 467* 495 533* 544
carriage_return_needed          000113 automatic       bit(1)                   unaligned dcl 110 set ref 441* 453* 495 528
cd                                     parameter       fixed bin(35,0)          dcl 832 ref 829
chase_buf_ptr                   000160 automatic       pointer                  dcl 557 set ref 566* 569* 576*
cleanup                         000132 stack reference condition                dcl 157 ref 219 320 405 455 597
cleanup_level                          parameter       fixed bin(17,0)          dcl 266 ref 263 271
close                    36            based           entry variable           level 2 dcl 1-6 set ref 380*
code                      1     000106 automatic       fixed bin(35,0)          level 2 in structure "ti" dcl 834 in procedure
                                                                                  "terminate_this_process" set ref 839* 839
code                                   parameter       fixed bin(35,0)          dcl 95 in procedure "ibm_pc_io_" set ref 208 279*
                                                                                  289 317 325* 343* 370* 402 430* 438 450 463* 499*
                                                                                  593 604* 626*
com_err_                        000036 constant        entry                    external dcl 181 ref 276
com_err_switch                         parameter       bit(1)                   dcl 96 set ref 208 215* 221* 229* 231* 233* 235* 317
control                  66            based           entry variable           level 2 dcl 1-6 set ref 253*
control_buf                     000212 automatic       char(1)                  unaligned dcl 752 set ref 761 762* 768 768 771
control_buf_ptr                 000214 automatic       pointer                  dcl 753 set ref 761* 765*
control_char_ptr                000100 automatic       pointer                  dcl 737 set ref 740* 741*
control_chars                          parameter       char(2)                  unaligned dcl 736 in procedure "send_control_chars"
                                                                                  set ref 734 740
control_chars                          parameter       char(2)                  unaligned dcl 754 in procedure "get_control_chars"
                                                                                  set ref 750 760* 768* 771*
control_chars                   000114 automatic       char(2)                  unaligned dcl 111 in procedure "ibm_pc_io_" set ref
                                                                                  331* 332 335 336* 337 357* 358 361 363* 364 697*
                                                                                  700 703 704 706* 712
detach_iocb              26            based           entry variable           level 2 dcl 1-6 set ref 249* 298* 381* 426*
ec                                     parameter       fixed bin(35,0)          dcl 268 in procedure "error" set ref 263 276* 279
ec                                     parameter       fixed bin(35,0)          dcl 755 in procedure "get_control_chars" set ref 750
                                                                                  759* 764 765* 766
ec                                     parameter       fixed bin(35,0)          dcl 692 in procedure "send_data_packet" set ref 690
                                                                                  695* 697* 698 698 706* 708 708 714* 719* 720 723*
ec                              000115 automatic       fixed bin(35,0)          dcl 112 in procedure "ibm_pc_io_" set ref 211* 228*
                                                                                  229 229* 331* 332* 335 335 336* 337* 341 357* 358*
                                                                                  361 361 363* 364* 368 417* 430 471* 478* 482* 483
                                                                                  485 495 495* 499 612* 616* 617 626 781*
ec                                     parameter       fixed bin(35,0)          dcl 558 in procedure "get_data_packet" set ref 554
                                                                                  562* 568 569* 570 579*
eof_sw                  215(01)        based           bit(1)                   level 2 packed unaligned dcl 119 set ref 242* 476
                                                                                  485*
error_code              214            based           fixed bin(35,0)          level 2 dcl 119 set ref 244* 408 418 715* 807*
error_table_$bad_arg            000010 external static fixed bin(35,0)          dcl 161 ref 463 604
error_table_$bad_mode           000012 external static fixed bin(35,0)          dcl 162 set ref 235* 325
error_table_$end_of_info        000014 external static fixed bin(35,0)          dcl 164 ref 478 485 579
error_table_$long_record        000016 external static fixed bin(35,0)          dcl 166 ref 495
error_table_$no_iocb            000022 external static fixed bin(35,0)          dcl 169 ref 229
error_table_$noarg              000020 external static fixed bin(35,0)          dcl 168 set ref 215*
error_table_$not_attached       000024 external static fixed bin(35,0)          dcl 170 set ref 231*
error_table_$not_detached       000026 external static fixed bin(35,0)          dcl 172 set ref 221*
error_table_$not_open           000030 external static fixed bin(35,0)          dcl 174 set ref 233*
error_table_$timeout            000032 external static fixed bin(35,0)          dcl 175 ref 335 361 698 708
error_table_$unable_to_do_io    000066 external static fixed bin(35,0)          dcl 820 in procedure "handler" set ref 822*
error_table_$unable_to_do_io    000034 external static fixed bin(35,0)          dcl 176 in procedure "ibm_pc_io_" ref 332 337 343
                                                                                  358 364 370 714
get_chars                46            based           entry variable           level 2 dcl 1-6 set ref 385*
get_line                 42            based           entry variable           level 2 dcl 1-6 set ref 384*
get_system_free_area_           000040 constant        entry                    external dcl 182 ref 224
hbound                                                 builtin function         dcl 152 ref 215
hcs_$reset_ips_mask             000042 constant        entry                    external dcl 183 ref 255 300 390 428
hcs_$set_ips_mask               000044 constant        entry                    external dcl 184 ref 246 294 377 423
i                               000151 automatic       fixed bin(17,0)          dcl 514 set ref 530* 531 534
index                                                  builtin function         dcl 152 ref 530 579 656
interval                               parameter       fixed bin(71,0)          dcl 756 set ref 750 765*
iocb                                   based           structure                level 1 dcl 1-6
iocbp                           000116 automatic       pointer                  dcl 113 set ref 213* 221 247 248 249 250 251 252 253
                                                                                  254*
iox_$err_no_operation           000046 constant        entry                    external dcl 185 ref 252 253
iox_$err_not_attached           000050 constant        entry                    external dcl 186 ref 297 298
iox_$err_not_closed             000052 constant        entry                    external dcl 188 ref 379 381
iox_$get_chars                  000054 constant        entry                    external dcl 189 ref 569
iox_$look_iocb                  000056 constant        entry                    external dcl 190 ref 228
iox_$propagate                  000060 constant        entry                    external dcl 191 ref 254 299 389 427
iox_$put_chars                  000062 constant        entry                    external dcl 192 ref 719 741
iox_modes                       000002 constant        char(24)                 initial array dcl 2-6 ref 235 375 408
length                                 based           fixed bin(17,0)          level 2 dcl 131 ref 235 408
mask                            000120 automatic       bit(36)                  dcl 114 set ref 212* 246* 255* 294* 300* 377* 390*
                                                                                  423* 428* 782* 795 822
mode                                   parameter       fixed bin(17,0)          dcl 97 ref 317 323 323 329 353 375 382 387
modes                    56            based           entry variable           level 2 dcl 1-6 set ref 252*
msg                                    parameter       char                     unaligned dcl 269 set ref 263 276*
n_chars                         000173 automatic       fixed bin(17,0)          dcl 646 in procedure "load_internal_buffer" set ref
                                                                                  664* 666* 668 668 671 672
n_chars                         000150 automatic       fixed bin(17,0)          dcl 511 in procedure "unload_internal_buffer" set
                                                                                  ref 524* 526* 530 534* 539 539 540 540 540 542 543
n_read                          000162 automatic       fixed bin(21,0)          dcl 559 in procedure "get_data_packet" set ref 569*
                                                                                  572
n_read                          000216 automatic       fixed bin(21,0)          dcl 757 in procedure "get_control_chars" set ref
                                                                                  765*
null                                                   builtin function         dcl 152 ref 218 221 231 233 250 295 296 424 797
open                     32            based           entry variable           level 2 dcl 1-6 set ref 251* 297* 379* 425*
open_descrip                           based           structure                level 1 dcl 131 in procedure "ibm_pc_io_"
open_descrip            101            based           varying char(32)         level 2 in structure "attach_data" dcl 119
                                                                                  in procedure "ibm_pc_io_" set ref 241* 375* 378
open_descrip_ptr         20            based           pointer                  level 2 dcl 1-6 set ref 233 235 250* 378* 408 424*
option_array                           parameter       varying char             array dcl 98 ref 208 215 228 228 229 229 231 231 233
                                                                                  233 235 235 240
overlay                                based           char                     unaligned dcl 647 in procedure
                                                                                  "load_internal_buffer" ref 656 668
overlay                                based           char                     unaligned dcl 512 in procedure
                                                                                  "unload_internal_buffer" set ref 539*
put_chars                52            based           entry variable           level 2 dcl 1-6 set ref 387*
rtrim                                                  builtin function         dcl 152 ref 228 228 229 229 231 231 233 233 235 235
                                                                                  240
string                    1            based           char                     level 2 dcl 131 ref 235 408
substr                                                 builtin function         dcl 152 set ref 412 415* 530 539* 539 540* 540 573
                                                                                  656 668* 668 678* 768* 771*
system_free_area                       based           area(1024)               dcl 135 ref 225
system_free_area_ptr            000122 automatic       pointer                  dcl 115 set ref 224* 225
target_iocbp            112            based           pointer                  level 2 dcl 119 set ref 228* 231 233 235 569* 719*
                                                                                  741* 765*
temp_buf_len                    000174 automatic       fixed bin(21,0)          dcl 648 set ref 656* 657 657* 660* 660 664 666
terminate_process_              000070 constant        entry                    external dcl 833 ref 840
ti                              000106 automatic       structure                level 1 dcl 834 set ref 840 840
timed_io_$get_chars             000064 constant        entry                    external dcl 193 ref 765
to_read                         000163 automatic       fixed bin(21,0)          dcl 560 set ref 564* 568 569* 573* 575*
version                         000106 automatic       fixed bin(17,0)          level 2 dcl 834 set ref 838*
xon_sw                  215            based           bit(1)                   level 2 packed unaligned dcl 119 set ref 349* 700*
                                                                                  703 704* 706

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Direct_input                           internal static fixed bin(17,0)          initial dcl 2-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 2-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 2-15
Sequential_input                       internal static fixed bin(17,0)          initial dcl 2-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 2-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 2-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 2-15
error_table_$badopt                    external static fixed bin(35,0)          dcl 163
iox_$err_not_open               000000 constant        entry                    external dcl 187
iox_$iocb_version_sentinel             external static char(4)                  dcl 1-51
lbound                                                 builtin function         dcl 152
short_iox_modes                        internal static char(4)                  initial array dcl 2-12

NAMES DECLARED BY EXPLICIT CONTEXT.
EXIT                            001227 constant        label                    dcl 256 ref 280
Err                             000000 constant        label                    array(0:1) dcl 273 ref 271
clean_up_attach                 003257 constant        entry                    internal dcl 792 ref 219
done_receive                    002237 constant        label                    dcl 495 ref 473 489
done_transmitting               002354 constant        label                    dcl 626 ref 614 620
error                           002360 constant        entry                    internal dcl 263 ref 215 221 229 231 233 235
get_control_chars               003157 constant        entry                    internal dcl 750 ref 331 336 357 363 697 706
get_data                        002140 constant        label                    dcl 455 ref 442
get_data_packet                 002544 constant        entry                    internal dcl 554 ref 482
handler                         003324 constant        entry                    internal dcl 817 ref 293 376 422 795
ibm_pc_io_                      000204 constant        entry                    external dcl 84
ibm_pc_io_attach                000217 constant        entry                    external dcl 208
ibm_pc_io_close                 001713 constant        entry                    external dcl 402 ref 380
ibm_pc_io_detach                001234 constant        entry                    external dcl 289 ref 249 426
ibm_pc_io_get_chars             002112 constant        entry                    external dcl 438 ref 385
ibm_pc_io_get_line              002126 constant        entry                    external dcl 450 ref 384
ibm_pc_io_open                  001347 constant        entry                    external dcl 317 ref 251 425
ibm_pc_io_put_chars             002263 constant        entry                    external dcl 593 ref 387
load_internal_buffer            002650 constant        entry                    internal dcl 641 ref 613
send_control_chars              003125 constant        entry                    internal dcl 734 ref 348 356 362 808
send_data_error                 003117 constant        label                    dcl 726 ref 698 708 720
send_data_packet                002762 constant        entry                    internal dcl 690 ref 417 616
set_up                          003244 constant        entry                    internal dcl 779 ref 292 321 406 457 598
terminate_io                    003302 constant        entry                    internal dcl 804 ref 320 405 418 455 487 597 619 726
terminate_this_process          003345 constant        entry                    internal dcl 829 ref 822
unload_internal_buffer          002444 constant        entry                    internal dcl 508 ref 472

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4122        4214    3431        4132
Length      4532    3431        72         302     471           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ibm_pc_io_                          230 external procedure  is an external procedure.  
on unit on line 219                  70 on unit               
error                                84 internal procedure  is called during a stack extension.  
on unit on line 293                  64 on unit               
on unit on line 320                  64 on unit               
on unit on line 376                  64 on unit               
on unit on line 405                  64 on unit               
on unit on line 422                  64 on unit               
on unit on line 455                  64 on unit               
unload_internal_buffer                  internal procedure  shares stack frame of external procedure ibm_pc_io_.  
get_data_packet                         internal procedure  shares stack frame of external procedure ibm_pc_io_.  
on unit on line 597                  64 on unit               
load_internal_buffer                    internal procedure  shares stack frame of external procedure ibm_pc_io_.  
send_data_packet                        internal procedure  shares stack frame of external procedure ibm_pc_io_.  
send_control_chars                   78 internal procedure  is called by several nonquick procedures.  
get_control_chars                       internal procedure  shares stack frame of external procedure ibm_pc_io_.  
set_up                                  internal procedure  shares stack frame of external procedure ibm_pc_io_.  
clean_up_attach                         internal procedure  shares stack frame of on unit on line 219.  
terminate_io                         70 internal procedure  is called by several nonquick procedures.  
handler                              94 internal procedure  is declared options(non_quick).  
terminate_this_process                  internal procedure  shares stack frame of internal procedure handler.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
handler                  000106 ti                          terminate_this_process
ibm_pc_io_               000100 actual_iocbp                ibm_pc_io_
                         000102 arg_buf_pos                 ibm_pc_io_
                         000104 attach_data_ptr             ibm_pc_io_
                         000106 buf_ptr                     ibm_pc_io_
                         000110 buffer_empty                ibm_pc_io_
                         000111 buffer_full                 ibm_pc_io_
                         000112 carriage_return_found       ibm_pc_io_
                         000113 carriage_return_needed      ibm_pc_io_
                         000114 control_chars               ibm_pc_io_
                         000115 ec                          ibm_pc_io_
                         000116 iocbp                       ibm_pc_io_
                         000120 mask                        ibm_pc_io_
                         000122 system_free_area_ptr        ibm_pc_io_
                         000150 n_chars                     unload_internal_buffer
                         000151 i                           unload_internal_buffer
                         000160 chase_buf_ptr               get_data_packet
                         000162 n_read                      get_data_packet
                         000163 to_read                     get_data_packet
                         000172 CR_found                    load_internal_buffer
                         000173 n_chars                     load_internal_buffer
                         000174 temp_buf_len                load_internal_buffer
                         000212 control_buf                 get_control_chars
                         000214 control_buf_ptr             get_control_chars
                         000216 n_read                      get_control_chars
send_control_chars       000100 control_char_ptr            send_control_chars

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other      return              tra_ext             enable              shorten_stack       ext_entry
ext_entry_desc      int_entry           int_entry_desc      alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      get_system_free_area_         hcs_$reset_ips_mask           hcs_$set_ips_mask
iox_$err_no_operation         iox_$err_not_attached         iox_$err_not_closed           iox_$get_chars
iox_$look_iocb                iox_$propagate                iox_$put_chars                terminate_process_
timed_io_$get_chars

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$bad_mode         error_table_$end_of_info      error_table_$long_record
error_table_$no_iocb          error_table_$noarg            error_table_$not_attached     error_table_$not_detached
error_table_$not_open         error_table_$timeout          error_table_$unable_to_do_io  error_table_$unable_to_do_io




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     84 000203        86 000211       208 000212       211 000235       212 000236       213 000237       215 000243
    218 000301       219 000303       221 000321       224 000355       225 000364       228 000371       229 000454
    231 000550       233 000650       235 000750       240 001054       241 001140       242 001142       243 001144
    244 001145       246 001146       247 001161       248 001164       249 001166       250 001172       251 001174
    252 001200       253 001204       254 001206       255 001214       256 001227       289 001230       292 001244
    293 001245       294 001267       295 001302       296 001305       297 001306       298 001313       299 001315
    300 001323       301 001336       302 001337       303 001341       317 001342       320 001357       321 001401
    323 001402       325 001410       326 001413       329 001414       331 001416       332 001420       335 001427
    336 001441       337 001443       339 001452       341 001453       343 001455       344 001460       348 001461
    349 001467       353 001472       356 001476       357 001504       358 001506       361 001515       362 001527
    363 001535       364 001537       366 001546       368 001547       370 001551       371 001554       375 001555
    376 001570       377 001612       378 001625       379 001631       380 001636       381 001641       382 001644
    384 001650       385 001654       386 001657       387 001660       389 001666       390 001674       391 001707
    393 001710       402 001711       405 001723       406 001745       408 001746       411 001762       412 001764
    414 001772       415 001773       417 001777       418 002001       422 002010       423 002032       424 002045
    425 002050       426 002054       427 002057       428 002066       429 002101       430 002102       431 002104
    438 002105       441 002122       442 002123       450 002124       453 002136       455 002140       457 002162
    459 002163       461 002166       463 002167       464 002172       467 002173       468 002174       470 002175
    471 002176       472 002177       473 002201       476 002204       478 002210       479 002213       482 002214
    483 002216       485 002220       487 002227       488 002233       489 002235       493 002236       495 002237
    498 002250       499 002253       500 002255       593 002256       597 002273       598 002315       600 002316
    602 002321       604 002322       605 002325       608 002326       609 002327       612 002332       613 002333
    614 002335       616 002340       617 002342       619 002344       620 002350       622 002351       625 002353
    626 002354       628 002356       263 002357       271 002373       273 002376       276 002401       279 002435
    280 002441       508 002444       517 002446       518 002452       520 002455       521 002460       524 002461
    526 002471       528 002474       530 002476       531 002507       533 002510       534 002512       539 002513
    540 002522       542 002527       543 002531       544 002533       546 002543       554 002544       562 002546
    563 002547       564 002551       565 002553       566 002555       568 002556       569 002563       570 002603
    572 002607       573 002612       575 002621       576 002624       577 002630       579 002631       581 002647
    641 002650       651 002652       652 002656       653 002657       656 002664       657 002702       660 002706
    661 002710       664 002712       666 002726       668 002731       671 002735       672 002736       673 002737
    675 002745       677 002750       678 002752       679 002756       682 002761       690 002762       695 002764
    697 002765       698 003000       700 003006       703 003015       704 003026       706 003032       708 003050
    710 003056       712 003057       714 003063       715 003067       716 003071       719 003072       720 003110
    722 003113       723 003115       724 003116       726 003117       728 003123       734 003124       740 003132
    741 003135       742 003156       750 003157       759 003161       760 003162       761 003166       762 003170
    764 003172       765 003175       766 003221       768 003225       771 003235       772 003241       774 003242
    775 003243       779 003244       781 003245       782 003246       783 003247       784 003254       785 003256
    792 003257       795 003260       797 003270       799 003276       800 003300       804 003301       807 003307
    808 003313       809 003322       817 003323       822 003331       824 003343       825 003344       829 003345
    838 003347       839 003350       840 003352       842 003375


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
