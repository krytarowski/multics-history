	COMPILATION LISTING OF SEGMENT cv_cmcs_station_ctl
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/17/86  1452.1 mst Mon
	    Options: optimize map

        1 
        2 
        3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
        4 	/*							*/
        5 	/* COMPILED OUTPUT OF SEGMENT  cv_cmcs_station_ctl.rd          	*/
        6 	/* Compiled by:  reduction_compiler, Version 2.5 of Oct 21, 1985      */
        7 	/* Compiled on:  03/17/86  1452.1 mst Mon                             */
        8 	/*							*/
        9 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       10 
       11 /* ***********************************************************
       12*   *                                                         *
       13*   *                                                         *
       14*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
       15*   *                                                         *
       16*   *                                                         *
       17*   *********************************************************** */
       18 
       19 
       20 /* Modified on 04/23/81 by FCH, [4.4-2], accept minus in station names, BUG468 */
       21 /* Modified on 03/03/81 by FCH, [4.4-1], once per process initialization, BUG468 */
       22 /* Modified since Version 4.3 */
       23 
       24 /* This procedure converts an ASCII list of station subchannels and
       25*   their correspnding default station names to a binary control segment */
       26 
       27 /*++
       28*
       29*   BEGIN	/ <valid_station> ;		/ add LEX (2)		/ BEGIN \
       30*2	/ end ;			/ close			/ RETURN \
       31*3	/ <any-token>		/ ERROR (1) NEXT_STMT	/ BEGIN \
       32*4	/ <no-token>		/ ERROR (2)		/ RETURN \
       33*
       34*++*/
       35 
       36 cv_cmcs_station_ctl: proc;
       37 
       38 dcl  new_station_name char (12),
       39      j fixed bin,
       40      aclinfo_ptr ptr,				/* for use by tssi_ */
       41      temp3 char (3);
       42 
       43 dcl  test_sw bit (1) int static init ("0"b);
       44 
       45 /*  */
  1     1 /* BEGIN INCLUDE FILE... cmcs_control_hdr.incl.pl1 */
  1     2 
  1     3 /* This include file is the 1st part of all cobol_mcs tables */
  1     4 
  1     5 /* Bob May, 4/30/77 */
  1     6 
  1     7 dcl  control_hdr_len fixed bin int static options (constant) init (32);
  1     8 
  1     9 dcl  control_hdr_ptr ptr;
  1    10 
  1    11 dcl 1 control_hdr aligned based (control_hdr_ptr),
  1    12     2 lockword bit (36) aligned,			/* for process_id */
  1    13     2 version fixed bin,
  1    14     2 clock_created fixed bin (71),
  1    15     2 author aligned,
  1    16       3 group_id char (32),				/* person.proj.tag */
  1    17       3 process_id bit (36),
  1    18     2 max_size fixed bin (18),			/* maximum number of entries seg can hold */
  1    19     2 current_size fixed bin (18),			/* index of last active entry */
  1    20     2 entry_count fixed bin (18),			/* number of active entries */
  1    21     2 cmcs_control_hdr_filler (16) fixed bin;		/* words (17-32) for later expansion */
  1    22 
  1    23 /* END INCLUDE FILE... cmcs_control_hdr.incl.pl1 */
       46 
  2     1 /* BEGIN INCLUDE FILE... cmcs_entry_dcls.incl.pl1 */
  2     2 
  2     3 /* Entry declarations for the COBOL MCS runtime support package */
  2     4 
  2     5 /* Modified on 04/29/81 by FCH, [4.4-1] */
  2     6 /* Bob May, 6/01/77 */
  2     7 
  2     8 dcl  cmcs_create_queues_ entry (fixed bin (35));
  2     9 
  2    10 dcl  cmcs_date_time_ entry (fixed bin (71), char (6) unaligned, char (8) unaligned);
  2    11 
  2    12 dcl  cmcs_decode_status_ entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
  2    13 
  2    14 dcl  cmcs_expand_tree_path_ entry (char (*), char (48), fixed bin (35));
  2    15 
  2    16 dcl  cmcs_fillin_hdr_ entry (ptr, fixed bin, fixed bin, fixed bin, fixed bin (35));
  2    17 
  2    18 dcl  cmcs_initiate_ctl_ entry (char (*), ptr, fixed bin (35));
  2    19 
  2    20 dcl  cmcs_print_ entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  2    21 
  2    22 dcl  cmcs_purge_queues_ entry (fixed bin, bit (1), fixed bin (35));
  2    23 
  2    24 dcl  cmcs_queue_ctl_$accept_message_count entry (ptr, fixed bin, fixed bin (35));
  2    25 dcl  cmcs_queue_ctl_$disable entry (ptr, fixed bin, char (10), fixed bin (35));
  2    26 dcl  cmcs_queue_ctl_$enable entry (ptr, fixed bin, char (10), fixed bin (35));
  2    27 dcl  cmcs_queue_ctl_$print entry (ptr, fixed bin, ptr, fixed bin (35));
  2    28 dcl  cmcs_queue_ctl_$purge entry (ptr, fixed bin, fixed bin (35));
  2    29 dcl  cmcs_queue_ctl_$receive entry (ptr, fixed bin, ptr, fixed bin, fixed bin (35));
  2    30 dcl  cmcs_queue_ctl_$send entry (ptr, fixed bin, ptr, fixed bin, fixed bin, bit (36), fixed bin (35));
  2    31 dcl  cmcs_queue_ctl_$stop_run entry (fixed bin, fixed bin (35));
  2    32 
  2    33 dcl  cmcs_scramble_ entry (char (10)) returns (char (10));
  2    34 
  2    35 dcl  cmcs_set_lock_$lock entry (bit (36) aligned, fixed bin (35));
  2    36 dcl  cmcs_set_lock_$unlock entry (bit (36) aligned, fixed bin (35));
  2    37 
  2    38 dcl  cmcs_station_ctl_$attach entry (char (12), fixed bin, fixed bin (35));
  2    39 dcl  cmcs_station_ctl_$detach entry (fixed bin, fixed bin (35));
  2    40 dcl  cmcs_station_ctl_$detach_name entry (char (12), fixed bin (35));
  2    41 dcl  cmcs_station_ctl_$disable_input_terminal entry (ptr, char (10), fixed bin (35));
  2    42 dcl  cmcs_station_ctl_$disable_output_terminal entry (ptr, char (10), fixed bin (35));
  2    43 dcl  cmcs_station_ctl_$enable_input_terminal entry (ptr, char (10), fixed bin (35));
  2    44 dcl  cmcs_station_ctl_$enable_output_terminal entry (ptr, char (10), fixed bin (35));
  2    45 dcl cmcs_station_ctl_$find_destination entry(char(12),fixed bin,ptr,fixed bin(35));	/*[4.4-1]*/
  2    46 dcl  cmcs_station_ctl_$input_disabled entry (fixed bin, bit (1), fixed bin (35));
  2    47 dcl  cmcs_station_ctl_$output_disabled entry (fixed bin, bit (1), fixed bin (35));
  2    48 dcl  cmcs_station_ctl_$validate entry (char (12), fixed bin, fixed bin (35));
  2    49 
  2    50 dcl  cmcs_status_list_ctl_$add entry (ptr, ptr, ptr, fixed bin, fixed bin (35));
  2    51 dcl  cmcs_status_list_ctl_$delete entry (ptr, ptr, ptr, fixed bin, fixed bin (35));
  2    52 dcl  cmcs_status_list_ctl_$move entry (ptr, ptr, ptr, fixed bin, fixed bin, fixed bin (35));
  2    53 
  2    54 dcl  cmcs_terminal_ctl_$find entry (char (8), char (12), fixed bin (35));
  2    55 
  2    56 dcl  cmcs_tree_ctl_$find_destination entry (char (12), fixed bin, ptr, fixed bin (35));
  2    57 dcl  cmcs_tree_ctl_$find_index entry (fixed bin, ptr, fixed bin (35));
  2    58 dcl  cmcs_tree_ctl_$find_tree_path entry (ptr, fixed bin, fixed bin, ptr, fixed bin (35));
  2    59 dcl  cmcs_tree_ctl_$find_qual_name entry(char(12),fixed bin,ptr,char(52),fixed bin(35)); /*[4.4-1]*/
  2    60 
  2    61 dcl  cmcs_wait_ctl_$add entry (char (48), fixed bin, fixed bin (35));
  2    62 dcl  cmcs_wait_ctl_$delete entry (fixed bin, fixed bin (35));
  2    63 dcl  cmcs_wait_ctl_$find entry (char (48), ptr, fixed bin (35));
  2    64 dcl  cmcs_wait_ctl_$mp_available entry (fixed bin, fixed bin, fixed bin (35));
  2    65 dcl  cmcs_wait_ctl_$mp_login entry (fixed bin, fixed bin (35));
  2    66 dcl  cmcs_wait_ctl_$mp_logout entry (fixed bin, fixed bin (35));
  2    67 dcl  cmcs_wait_ctl_$clear_mp entry (fixed bin (35));
  2    68 dcl  cmcs_wait_ctl_$start_mp entry (fixed bin (35));
  2    69 dcl  cmcs_wait_ctl_$stop_mp entry (fixed bin (35));
  2    70 
  2    71 /* END INCLUDE FILE... cmcs_entry_dcls.incl.pl1 */
       47 
  3     1 /* BEGIN INCLUDE FILE... cmcs_station_ctl.incl.pl1 */
  3     2 
  3     3 /* This include file defines the station control structure for COBOL MCS */
  3     4 
  3     5 /* Bob May, 5/31/77 */
  3     6 
  3     7 dcl (station_ctl_hdr_len init (0),			/* no special fields in hdr */
  3     8      station_ctl_entry_len init (6),
  3     9      station_ctl_version init (1)) fixed bin int static options (constant);
  3    10 
  3    11 dcl  station_ctl_ptr ptr int static;
  3    12 
  3    13 dcl 1 station_ctl aligned based (station_ctl_ptr),
  3    14     2 hdr like control_hdr,
  3    15     2 entries (station_ctl.current_size) like station_ctl_entry;
  3    16 
  3    17 dcl  station_ctl_eindex fixed bin;
  3    18 
  3    19 dcl  station_ctl_eptr ptr;
  3    20 
  3    21 dcl 1 station_ctl_entry aligned based (station_ctl_eptr),
  3    22     2 station_name char (12),
  3    23     2 lockword bit (36) aligned,			/* owner process_id */
  3    24     2 flags,
  3    25      (3 inactive_sw bit (1),				/* station is currently not legal to use */
  3    26       3 destination_sw bit (1),			/* station attached as a destination */
  3    27       3 input_disabled_sw bit (1),			/* if terminal, can't input */
  3    28       3 output_disabled_sw bit (1),			/* if terminal, can't get output */
  3    29       3 filler bit (32)) unaligned,
  3    30     2 filler fixed bin;
  3    31 
  3    32 /* END INCLUDE FILE... cmcs_station_ctl.incl.pl1 */
       48 
       49 
       50 /*  */
       51 /* automatic */
       52 
       53 
       54 declare (APstmt, APtoken) ptr,
       55          area_ptr ptr,				/* for use by lex_string_. */
       56          arg_length fixed bin (21),			/* length of command argument. */
       57          arg_ptr ptr,				/* ptr to command argument */
       58          bitcount fixed bin (24),
       59          code fixed bin (35),
       60          dname char (168),
       61          ename char (32),
       62          i fixed bin,
       63          n_chars fixed bin (21),
       64          object_name char (32),			/* entry name of output control seg */
       65         (pntep, object_ptr) ptr,			/* ptrs to base of pnte and pnt */
       66          source_ptr ptr;				/* ptr to base of persmf */
       67 
       68 /* based */
       69 
       70 declare  arg_string char (arg_length) based (arg_ptr) unaligned;
       71 
       72 /* builtin */
       73 
       74 declare (addr, collate, dimension, divide, index, length, null,
       75          reverse, string, substr, verify) builtin;
       76 
       77 /* conditions */
       78 
       79 declare  cleanup condition;
       80 
       81 /* entries */
       82 
       83 declare
       84          clock_ entry () returns (fixed bin (71)),
       85          cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
       86          cv_dec_check_ entry (char (*), fixed bin) returns (fixed bin (35)),
       87          expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35)),
       88          get_group_id_ entry () returns (char (32) aligned),
       89          get_process_id_ entry () returns (bit (36)),
       90          get_wdir_ entry () returns (char (168) aligned),
       91          hcs_$delentry_seg entry (ptr, fixed bin (35)),
       92          hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (1), ptr, fixed bin (35)),
       93          hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35)),
       94          hcs_$set_bc_seg entry (ptr, fixed bin (24), fixed bin (35)),
       95          hcs_$terminate_noname entry (ptr, fixed bin (35)),
       96          hcs_$truncate_seg entry (ptr, fixed bin (18), fixed bin (35)),
       97         (ioa_, com_err_) entry options (variable),
       98          lex_error_ entry options (variable),
       99          lex_string_$init_lex_delims entry (char (*), char (*), char (*), char (*), char (*),
      100          bit (*), char (*) var, char (*) var, char (*) var, char (*) var),
      101          lex_string_$lex entry (ptr, fixed bin (21), fixed bin, ptr, bit (*), char (*), char (*), char (*),
      102          char (*), char (*), char (*) var, char (*) var, char (*) var, char (*) var, ptr, ptr, fixed bin (35)),
      103          translator_temp_$get_segment entry (char (*), ptr, fixed bin (35)),
      104          translator_temp_$release_all_segments entry (ptr, fixed bin (35)),
      105 
      106          tssi_$get_segment entry (char (*), char (*), ptr, ptr, fixed bin (35)),
      107          tssi_$finish_segment entry (ptr, fixed bin (24), bit (36) aligned, ptr, fixed bin (35)),
      108          tssi_$clean_up_segment entry (ptr),
      109 
      110          unique_chars_ entry (bit (*)) returns (char (15) aligned);
      111 
      112 /* internal static */
      113 
      114 declare ((BREAKS, IGBREAKS, LEXCTL, LEXDLM) char (128) varying,
      115 /*[4.4-1]*/         first_time bit (1) aligned initial ("1"b)) int static;
      116 
      117 dcl (LEGAL char (71) aligned initial ("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'_-^`~ ."),
      118      my_name char (20) initial ("cv_cmcs_station_ctl"),
      119      ALPHANUMERICS char (64) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-") /*[4.4-2]*/
      120      ) internal static options (constant);
      121 
      122 /* external static */
      123 
      124 declare ((error_table_$badopt, error_table_$entlong,
      125          error_table_$bad_name, error_table_$translation_failed) fixed bin (35),
      126          sys_info$max_seg_size fixed bin (18)
      127          ) external static;
      128 
      129 
      130 /* program */
      131 
      132 	call cu_$arg_ptr (1, arg_ptr, arg_length, code);
      133 
      134 	if code ^= 0
      135 	then do;
      136 
      137 	     call com_err_ (code, my_name, "Usage: cv_cmcs_station_ctl pathname (-brief|-bf|-long|-lg)");
      138 	     return;
      139 
      140 	end;
      141 
      142 	call expand_pathname_ (arg_string, dname, ename, code);
      143 
      144 	if code ^= 0
      145 	then do;
      146 
      147 	     call com_err_ (code, my_name, "^a", arg_string);
      148 	     return;
      149 
      150 	end;
      151 
      152 	call cu_$arg_ptr (2, arg_ptr, arg_length, code);
      153 
      154 	if code = 0
      155 	then if arg_string = "-brief" | arg_string = "-bf"
      156 	     then SERROR_CONTROL = "01"b;
      157 	     else if arg_string = "-long" | arg_string = "-lg"
      158 	     then SERROR_CONTROL = "10"b;
      159 	     else do;
      160 
      161 		call com_err_ (error_table_$badopt, my_name, "^a", arg_string);
      162 		return;
      163 
      164 	     end;
      165 
      166 	source_ptr = null;				/* Initialize for cleanup handler */
      167 	object_ptr = null;				/* .. */
      168 	area_ptr = null;				/* .. */
      169 	aclinfo_ptr = null;				/* .. */
      170 
      171 	on cleanup call clean_up;
      172 
      173 	call hcs_$initiate_count (dname, ename, "", bitcount, 1b, source_ptr, code);
      174 
      175 	if source_ptr = null
      176 	then do;
      177 
      178 report_error:
      179 
      180 	     call com_err_ (code, my_name, "^a>^a", dname, ename);
      181 	     return;
      182 
      183 	end;
      184 
      185 	i = index (ename, ".src") - 1;
      186 
      187 	if i < 1 then do;
      188 
      189 	     call com_err_ (error_table_$bad_name, my_name, "Source segment must have "".src"" suffix.");
      190 	     return;
      191 
      192 	end;
      193 
      194 	if i + length (".control") > length (object_name)
      195 	then do;
      196 
      197 	     code = error_table_$entlong;
      198 	     go to report_error;
      199 
      200 	end;
      201 
      202 	object_name = substr (ename, 1, i) || ".control";
      203 
      204 	n_chars = divide (bitcount + 8, 9, 24, 0);
      205 
      206 	dname = get_wdir_ ();
      207 
      208 	call tssi_$get_segment (dname, object_name, object_ptr, aclinfo_ptr, code);
      209 
      210 	if code ^= 0
      211 	then do;
      212 
      213 	     call com_err_ (code, my_name, "^a>^a", dname, object_name);
      214 	     return;
      215 
      216 	end;
      217 
      218 	station_ctl_ptr = object_ptr;			/* actual working ptr - other is generic ptr */
      219 
      220 	call cmcs_fillin_hdr_ (station_ctl_ptr, station_ctl_version, station_ctl_hdr_len, station_ctl_entry_len, code);
      221 
      222 	if code ^= 0
      223 	then do;
      224 	     call com_err_ (code, my_name, "Setting common header data.");
      225 	     return;
      226 
      227 	end;
      228 
      229 /*[4.4-1]*/	if first_time
      230 /*[4.4-1]*/	then	do;
      231 
      232 	     BREAKS = substr (collate, 1, 8) || substr (collate, 10, 24) || ";:,()";
      233 	     IGBREAKS = substr (BREAKS, 1, 8+24);
      234 
      235 	     call lex_string_$init_lex_delims ("""", """", "/*", "*/", ";", "10"b,
      236 		BREAKS, IGBREAKS, LEXDLM, LEXCTL);
      237 /*[4.4-1]*/	     first_time = "1"b;
      238 
      239 /*[4.4-1]*/		end;
      240 
      241 	call translator_temp_$get_segment (my_name, area_ptr, code);
      242 
      243 	if area_ptr = null
      244 	then do;
      245 
      246 
      247 	     call com_err_ (code, my_name, "Making temporary segment in process directory.");
      248 	     return;
      249 
      250 	end;
      251 
      252 	call lex_string_$lex (source_ptr, n_chars, 0, area_ptr, "1000"b, """", """", "/*", "*/", ";",
      253 	     BREAKS, IGBREAKS, LEXDLM, LEXCTL, APstmt, APtoken, code);
      254 
      255 	if code ^= 0
      256 	then do;
      257 
      258 	     call com_err_ (code, my_name, ename);
      259 	     return;
      260 
      261 	end;
      262 
      263 	Pthis_token = APtoken;
      264 
      265 	call SEMANTIC_ANALYSIS ();
      266 
      267 	if MERROR_SEVERITY > 1
      268 	then do;
      269 
      270 	     call com_err_ (error_table_$translation_failed, my_name, ename);
      271 	     call hcs_$delentry_seg (object_ptr, code);
      272 
      273 	end;
      274 	else do;
      275 
      276 	     bitcount = 36 * (station_ctl_hdr_len + station_ctl_entry_len * station_ctl.current_size);
      277 
      278 	     call tssi_$finish_segment (object_ptr, bitcount, "101"b, aclinfo_ptr, code);
      279 
      280 	     if code ^= 0
      281 	     then call com_err_ (code, my_name, "Unable to set bitcount on ^a>^a to ^d", dname, object_name, bitcount);
      282 
      283 	end;
      284 
      285 	call clean_up;				/* terminate input segments */
      286 
      287 	return;
      288 
      289 /* Clean up procedure. Called if command is "quit" out of, and at end of normal processing. */
      290 
      291 clean_up:
      292 	procedure;
      293 
      294 	     if source_ptr ^= null
      295 	     then call hcs_$terminate_noname (source_ptr, code);
      296 
      297 	     if object_ptr ^= null
      298 	     then call hcs_$terminate_noname (object_ptr, code);
      299 
      300 	     if area_ptr ^= null
      301 	     then call translator_temp_$release_all_segments (area_ptr, code);
      302 
      303 	     if aclinfo_ptr ^= null
      304 	     then call tssi_$clean_up_segment (aclinfo_ptr);
      305 
      306 	end /* clean_up */ ;
      307 
      308 
      309 
      310 
      311 declare 1 error_control_table (2) aligned internal static,
      312         2 severity fixed bin (17) unaligned initial (
      313        (2)3),
      314         2 Soutput_stmt bit (1) unaligned initial (
      315          "1"b,
      316          "0"b),
      317         2 message char (64) varying initial (
      318          "Syntax error in ""^a"" statement.",
      319          "Premature end of input encountered."),
      320         2 brief_message char (20) varying initial (
      321          "^a",
      322          "Premature EOF.");
      323 
      324 /*  */
      325 
      326 valid_station: proc () returns (bit (1) aligned);
      327 
      328 	     if test_sw then call ioa_ ("Parse: token (^a).", token_value);
      329 
      330 	     if token_value = "end" then return ("0"b);	/* special case this name */
      331 
      332 	     if length (token_value) > 12 then return ("0"b);
      333 
      334 	     if verify (token_value, ALPHANUMERICS) ^= 0 then return ("0"b);
      335 
      336 	     new_station_name = token_value;
      337 
      338 	     return ("1"b);
      339 
      340 	end /* valid_station */ ;
      341 
      342 close:	proc ();
      343 
      344 	     if test_sw then call ioa_ ("CLOSE");
      345 	     return;
      346 	end /* close */ ;
      347 
      348 /*  */
      349 
      350 add:	proc ();
      351 
      352 	     station_ctl.entry_count, station_ctl.current_size = station_ctl.current_size + 1;
      353 	     string (station_ctl.flags (station_ctl.current_size)) = (36) "0"b;
      354 	     station_ctl.station_name (station_ctl.current_size) = new_station_name;
      355 
      356 	     return;
      357 
      358 	end /* add */ ;
      359 
      360 /* */
      361 
      362 test:	entry;
      363 
      364 	test_sw = "1"b;
      365 	return;
      366 
      367 /* end of test entrypoint */
      368 
      369 
      370 
      371      dcl	TRACING			bit(1) aligned int static init("0"b);
      372 
      373 
  4     1 	/* START OF:	rdc_start_.incl.pl1		  *  *  *  *  *  *  */
  4     2 
  4     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     4 	/*							*/
  4     5 	/* N__a_m_e:  rdc_start_.incl.pl1					*/
  4     6 	/*							*/
  4     7 	/*      This include segment is used by compilers generated by the	*/
  4     8 	/* reduction_compiler.  Such compilers include a SEMANTIC_ANALYSIS	*/
  4     9 	/* subroutine generated by the reduction_compiler.  This subroutine	*/
  4    10 	/* compares a chain of input tokens with token requirements		*/
  4    11 	/* specified in reductions.  This include segment declares the 	*/
  4    12 	/* structure of the input tokens (which are generated by lex_string_),*/
  4    13 	/* defines the beginning of the SEMANTIC_ANALYSIS procedure, and	*/
  4    14 	/* declares Pthis_token, a global pointer variable which points to	*/
  4    15 	/* the "current" token being referenced by SEMANTIC_ANALYSIS.	*/
  4    16 	/*							*/
  4    17 	/* S__t_a_t_u_s							*/
  4    18 	/*							*/
  4    19 	/* 0) Created:  April, 1974 by G. C. Dixon			*/
  4    20 	/*							*/
  4    21 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4    22 
  4    23      dcl	Pthis_token		ptr;		/* ptr to the "current" token being acted upon.	*/
  4    24 
  5     1 	/*  START OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
  5     2 	
  5     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     4 	/*							*/
  5     5 	/* Name:  lex_descriptors_.incl.pl1				*/
  5     6 	/*							*/
  5     7 	/*      This include segment defines the structure of the token	*/
  5     8 	/* descriptor, statement descriptor, and comment descriptor created	*/
  5     9 	/* by the lex_string_ program.				*/
  5    10 	/*							*/
  5    11 	/* Status:						*/
  5    12 	/*							*/
  5    13 	/* 0) Created:  Dec, 1973 by G. C. Dixon			*/
  5    14 	/*							*/
  5    15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5    16 	
  5    17 	
  5    18 	
  5    19 	
  5    20      dcl	
  5    21 	1 comment			aligned based (Pcomment),
  5    22 						/* descriptor for a comment.			*/
  5    23 	  2 group1		unaligned,
  5    24 	    3 version		fixed bin(17),	/* comment descriptor version.		*/
  5    25 	    3 size		fixed bin(17),	/* comment descriptor size (in words).		*/
  5    26 	  2 Pnext			ptr unal,		/* ptr to next comment descriptor.		*/
  5    27 	  2 Plast			ptr unal,		/* ptr to last comment descriptor.		*/
  5    28 	  2 Pvalue		ptr unal,		/* ptr to comment.				*/
  5    29 	  2 Lvalue		fixed bin(18),	/* length of comment.			*/
  5    30 	  2 group2		unaligned,
  5    31 	    3 line_no		fixed bin(17),	/* line no of line containing comment.		*/
  5    32 	    3 S,					/* switches:				*/
  5    33 	      4 before_stmt		bit(1),		/* comment is before 1st token of stmt.		*/
  5    34 	      4 contiguous		bit(1),		/* no tokens between this and last comment.	*/
  5    35 	      4 pad		bit(16),
  5    36 	comment_value		char(comment.Lvalue) based (comment.Pvalue),
  5    37 						/* body of comment.				*/
  5    38 	Pcomment			ptr;		/* ptr to comment descriptor.			*/
  5    39 	
  5    40      dcl	
  5    41 	1 stmt			aligned based (Pstmt),
  5    42 						/* descriptor for a statement.		*/
  5    43 	  2 group1		unaligned,
  5    44 	    3 version		fixed bin(17),	/* statement descriptor version.		*/
  5    45 	    3 size		fixed bin(17),	/* statement descriptor size (in words).	*/
  5    46 	  2 Pnext			ptr unal,		/* ptr to next statement descriptor.		*/
  5    47 	  2 Plast			ptr unal,		/* ptr to last statement descriptor.		*/
  5    48 	  2 Pvalue		ptr unal,		/* ptr to statement.			*/
  5    49 	  2 Lvalue		fixed bin(18),	/* length of statement.			*/
  5    50 	  2 Pfirst_token		ptr unal,		/* ptr to 1st token of statement.		*/
  5    51 	  2 Plast_token		ptr unal,		/* ptr to last token of statement.		*/
  5    52 	  2 Pcomments		ptr unal,		/* ptr to comments in statement.		*/
  5    53 	  2 Puser			ptr unal,		/* user-defined ptr.			*/
  5    54 	  2 group2		unaligned,
  5    55 	    3 Ntokens		fixed bin(17),	/* number of tokens in statement.		*/
  5    56 	    3 line_no		fixed bin(17),	/* line no of line on which statement begins.	*/
  5    57 	    3 Istmt_in_line		fixed bin(17),	/* number of stmts in line containing this stmt.	*/
  5    58 						/* (the number includes this stmt.)		*/
  5    59 	    3 semant_type		fixed bin(17),	/* semantic type of the statement.		*/
  5    60 	    3 S,					/* switches:				*/
  5    61 	      4 error_in_stmt	bit(1),		/* stmt contains a syntactic error.		*/
  5    62 	      4 output_in_err_msg	bit(1),		/* stmt has been output in previous error message.*/
  5    63 	      4 pad		bit(34),
  5    64 	stmt_value		char(stmt.Lvalue) based (stmt.Pvalue),
  5    65 						/* text of the statement.			*/
  5    66 	Pstmt			ptr;		/* ptr to a stmt descriptor. 			*/
  5    67 	
  5    68      dcl	
  5    69 	1 token			aligned based (Ptoken),
  5    70 						/* descriptor for a token.			*/
  5    71 	  2 group1		unaligned,
  5    72 	    3 version		fixed bin(17),	/* token descriptor version.			*/
  5    73 	    3 size		fixed bin(17),	/* token descriptor size (in words).		*/
  5    74 	  2 Pnext			ptr unal,		/* ptr to next token descriptor.		*/
  5    75 	  2 Plast			ptr unal,		/* ptr to last token descriptor.		*/
  5    76 	  2 Pvalue		ptr unal,		/* ptr to token.				*/
  5    77 	  2 Lvalue		fixed bin(18),	/* length of token.				*/
  5    78 	  2 Pstmt			ptr unal,		/* ptr to descriptor of stmt containing token.	*/
  5    79 	  2 Psemant		ptr unal,		/* ptr to descriptor(s) of token's semantic value.*/
  5    80 	  2 group2		unaligned,
  5    81 	    3 Itoken_in_stmt	fixed bin(17),	/* position of token within its statement.	*/
  5    82 	    3 line_no		fixed bin(17),	/* line number of the line containing the token.	*/
  5    83 	    3 Nvalue		fixed bin(35),	/* numeric value of decimal-integer tokens.	*/
  5    84 	    3 S,					/* switches:				*/
  5    85 	      4 end_of_stmt		bit(1),		/* token is an end-of-stmt token.		*/
  5    86 	      4 quoted_string	bit(1),		/* token is a quoted string.			*/
  5    87 	      4 quotes_in_string	bit(1),		/* on if quote-close delimiters appear in quoted	*/
  5    88 						/* string (as doubled quotes on input.)		*/
  5    89 	      4 quotes_doubled	bit(1),		/* on if quotes in the string are doubled after	*/
  5    90 						/* string has been lexed into a token.		*/
  5    91 	      4 pad2		bit(32),
  5    92 	token_value		char(token.Lvalue) based (token.Pvalue),
  5    93 						/* value of the token.			*/
  5    94 	Ptoken			ptr;		/* ptr to a token descriptor.			*/
  5    95 
  5    96 	/*  END OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
  4    25 
  4    26 
  4    27 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4    28 
  4    29 
  4    30 SEMANTIC_ANALYSIS:	procedure;			/* procedure which analyzes the syntax and	*/
  4    31 						/* semantics of the tokens in the input list.	*/
  4    32 
  4    33      dcl						/*	automatic variables			*/
  4    34 	LTOKEN_REQD_VALUE		fixed bin(18),	/* length of a token requirement.		*/
  4    35 	NRED			fixed bin,	/* number of the reduction tokens are being	*/
  4    36 						/* compared to.				*/
  4    37 	PRED			ptr,		/* ptr to the reduction tokens are being	*/
  4    38 						/* compared to.				*/
  4    39 	PTOKEN_REQD		ptr,		/* ptr to token requirement descriptor associated	*/
  4    40 						/* with reduction tokens are being compared to.	*/
  4    41 	PTOKEN_REQD_VALUE		ptr,		/* ptr to a token requirement.		*/
  4    42 	STOKEN_FCN		bit(1) aligned,	/* return value from a relative syntax function.	*/
  4    43 	CODE			fixed bin(35),	/* an error code.				*/
  4    44 	I			fixed bin,	/* a do-group index.			*/
  4    45 	NUMBER			fixed bin(35);	/* fixed binary representation of a decimal 	*/
  4    46 						/* number character string.			*/
  4    47 
  4    48      dcl						/*	based variables			*/
  4    49 	1 RED			aligned based (PRED),
  4    50 						/* descriptor for reduction tokens are being 	*/
  4    51 						/* compared to.				*/
  4    52 	  2 TOKEN_REQD		unaligned,
  4    53 	    3 IFIRST		fixed bin(17) unal,	/* index of first token requirement.		*/
  4    54 	    3 ILAST		fixed bin(17) unal,	/* index of last  token requirement associated	*/
  4    55 						/* with this reduction.			*/
  4    56 	1 TOKEN_REQD		aligned based (PTOKEN_REQD),
  4    57 						/* a token requirement descriptor.		*/
  4    58 	  2 FORM			fixed bin(17) unal,	/* form of the token requirement:		*/
  4    59 						/*  -1 = relative token requirement function;	*/
  4    60 						/*       TYPE = index of the particular token	*/
  4    61 						/*	      function in the token_fcn array.	*/
  4    62 						/*   0 = built-in token requirement function;	*/
  4    63 						/*       TYPE = as defined below.		*/
  4    64 						/*  >0 = absolute token requirement:		*/
  4    65 						/*       FORM = index(TOKEN_STRINGS,TOKEN_REQD);	*/
  4    66 						/*       TYPE = length(TOKEN_REQD);		*/
  4    67 	  2 TYPE			fixed bin(17) unal,	/* TYPE of built-in token requirement function:	*/
  4    68 						/*   1 = compile test to see if input token 	*/
  4    69 						/*       chain is exhausted (<no-token>).	*/
  4    70 						/*   2 = compile test for any token value	*/
  4    71 						/*       (<any-token>).			*/
  4    72 						/*   3 = compile test for a PL/I identifier	*/
  4    73 						/*       (<name>) of 32 or fewer characters.	*/
  4    74 						/*   4 = compile test for token which is a	*/
  4    75 						/*       <decimal-integer>.			*/
  4    76 						/*   5 = compile test for token which is a single	*/
  4    77 						/*       backspace character (<BS>).		*/
  4    78 						/*   6 = compile test for a token which is a	*/
  4    79 						/*       <quoted-string>.			*/
  4    80 
  4    81 	1 TOKEN_REQD_STRING		aligned based (PTOKEN_REQD),
  4    82 						/* overlay for an absolute token requirement	*/
  4    83 						/* descriptor.				*/
  4    84 	  2 I			fixed bin(17) unal,	/* index into list of token strings of the	*/
  4    85 						/* absolute token string assoc w/ descriptor.	*/
  4    86 	  2 L			fixed bin(17) unal,	/* length of the absolute token string.		*/
  4    87 	TOKEN_REQD_VALUE		char(LTOKEN_REQD_VALUE) based (PTOKEN_REQD_VALUE);
  4    88 						/* absolute token string which token is reqd	*/
  4    89 						/* to match in order for tokens which are	*/
  4    90 						/* "current" on the list to match the reduction.	*/
  4    91 
  4    92      dcl						/*	builtin functions			*/
  4    93          (addr, max, null, search, substr, verify)
  4    94 				builtin;
  4    95 
  4    96      dcl						/*	entries				*/
  4    97 	cv_dec_check_		entry (char(*), fixed bin(35)) returns (fixed bin(35));
  4    98 
  4    99      dcl						/*	static variables			*/
  4   100 	BACKSPACE			char(1) aligned int static init ("");
  4   101 
  4   102 	/* END OF:	rdc_start_.incl.pl1		  *  *  *  *  *  *  */
      374 
      375 
      376      dcl	DIRECTION			fixed bin init(+1);	/* direction in which tokens compared.		*/
      377 
      378 
      379      dcl	1 REDUCTION (4)		unaligned based (addr (REDUCTIONS)),
      380 						/* object reductions.			*/
      381 	  2 TOKEN_REQD,
      382 	    3 IFIRST		fixed bin(17),	/* index of first required token.		*/
      383 	    3 ILAST		fixed bin(17),	/* index of last required token.		*/
      384 
      385 	REDUCTIONS  (8)		fixed bin(17) unaligned internal static options(constant) initial (
      386 	         1,     2,	/*     1/  <valid_station> ;                                                    */
      387 	         3,     4,	/*     2/  end ;                                                                */
      388 	         5,     5,	/*     3/  <any-token>                                                          */
      389 	         6,     6);	/*     4/  <no-token>                                                           */
      390 
      391      dcl	1 TOKEN_REQUIREMENT (6)	unaligned based (addr (TOKEN_REQUIREMENTS)),
      392 						/* object token requirements.			*/
      393 	  2 FORM			fixed bin(17),	/* form of the token requirement:		*/
      394 						/*  -1 = relative token requirement function;	*/
      395 						/*       TYPE = index of the particular token	*/
      396 						/*	      function in the token_fcn array.	*/
      397 						/*   0 = built-in token requirement function;	*/
      398 						/*       TYPE = as defined below.		*/
      399 						/*  >0 = absolute token requirement:		*/
      400 						/*       FORM = index(TOKEN_STRINGS,TOKEN_REQD);	*/
      401 						/*       TYPE = length(TOKEN_REQD);		*/
      402 	  2 TYPE			fixed bin(17) unal,	/* type of the built-in token requirement	*/
      403 						/* function:				*/
      404 						/*   1 = compile test to see if input token 	*/
      405 						/*       chain is exhausted (<no-token>).	*/
      406 						/*   2 = compile test for any token value	*/
      407 						/*       (<any-token>).			*/
      408 						/*   3 = compile test for a PL/I identifier	*/
      409 						/*       (<name>) of 32 or fewer characters.	*/
      410 						/*   4 = compile test for token which is a	*/
      411 						/*       <decimal-integer>.			*/
      412 						/*   5 = compile test for token which is a single	*/
      413 						/*       backspace character (<BS>).		*/
      414 						/*   6 = compile test for a token which is a	*/
      415 						/*       <quoted-string>.			*/
      416 
      417 	TOKEN_REQUIREMENTS  (12)	fixed bin(17) unaligned internal static options(constant) initial (
      418 	        -1,    1,       1,    1,       2,    3,       1,    1,       0,    2,       0,    1);
      419 
      420 
      421      dcl	TOKEN_STRINGS		char(4) aligned based (addr (TOKEN_STRING_ARRAYS)),
      422 						/* object token values.			*/
      423 	TOKEN_STRING_ARRAYS (1)	char(100) aligned internal static options(constant) initial (
      424 	     ";end");
      425 
      426 	/* START OF:	rdc_end_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(86-02-14,GWMay), approve(), audit(), install():
  6     6*     old history comments:
  6     7*      0) Created: April, 1974 by G. C. Dixon
  6     8*      1) Modified: Feb, 1975  by G. C. Dixon
  6     9*         a) support for Version 2.0 of reduction_compiler.
  6    10*      2) Modified: Feb, 1981  by G. C. Dixon
  6    11*         a) support for Version  2.2 of reduction_compiler
  6    12*      3) Modified: Aug, 1983  by G. C. Dixon - support for Version 2.3 of
  6    13*                        reductions command.
  6    14*  2) change(86-03-04,GDixon), approve(86-03-04,MCR7362), audit(86-03-17,GWMay),
  6    15*     install(86-03-17,MR12.0-1032):
  6    16*     Changed how the PUSH DOWN LANGUAGE (SPDL) definition of <no-token> is
  6    17*     implemented to avoid references through a null pointer.  The two
  6    18*     accepted uses are:
  6    19*     
  6    20*        / <no-token>               / ... / ... \
  6    21*                    A
  6    22*                    |
  6    23*           Pthis_token (points to top of push down stack)
  6    24*     
  6    25*     which checks to see if the push down stack is totally exhausted (ie,
  6    26*     Ptoken = null); and:
  6    27*     
  6    28*        / SPEC1 ... SPECN <no-token>         / ... / ... \
  6    29*                           A
  6    30*                           |
  6    31*                 Pthis_token (points to top of push down stack)
  6    32*     
  6    33*     which checks to see whether SPECN is topmost on the push down stack
  6    34*     AND is the final token in the input list.
  6    35*                                                   END HISTORY COMMENTS */
  6    36 
  6    37 
  6    38 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    39 	/*									*/
  6    40 	/* NAME:  rdc_end_.incl.pl1							*/
  6    41 	/*									*/
  6    42 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  6    43 	/* Such compilers include a SEMANTIC_ANALYSIS subroutine generated by the		*/
  6    44 	/* reduction_compiler.  This subroutine compares a chain of input tokens with token	*/
  6    45 	/* requirements specified in reductions.  The code in this include segment performs the	*/
  6    46 	/* actual comparisons.  This code is the middle part of the SEMANTIC_ANALYSIS procedure.	*/
  6    47 	/*									*/
  6    48 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    49 
  6    50 	TRACING = TRACING;				/* Kludge to prevent pl1 from making TRACING	*/
  6    51 						/*   options(constant) because it is never set.	*/
  6    52 	NRED = 1;
  6    53 	go to RD_TEST_REDUCTION;
  6    54 
  6    55 RD_NEXT_REDUCTION:
  6    56 	NRED = NRED + 1;
  6    57 
  6    58 RD_TEST_REDUCTION:
  6    59 	PRED = addr(REDUCTION(NRED));
  6    60 	Ptoken = Pthis_token;
  6    61 
  6    62 	do I = RED.TOKEN_REQD.IFIRST to RED.TOKEN_REQD.ILAST by DIRECTION;
  6    63 	     PTOKEN_REQD = addr(TOKEN_REQUIREMENT(I));
  6    64 	     if Ptoken = null then do;
  6    65 		if TOKEN_REQD.FORM = 0 then		/* No more tokens.  Only matches <no-token> spec.	*/
  6    66 		     if TOKEN_REQD.TYPE = 1 then
  6    67 			go to RD_TEST_TOKEN(1);
  6    68 		go to RD_NEXT_REDUCTION;
  6    69 		end;
  6    70 	     if TOKEN_REQD.FORM = 0 then do;		/* built-in syntax function.			*/
  6    71 		go to RD_TEST_TOKEN(TOKEN_REQD.TYPE);
  6    72 
  6    73 RD_TEST_TOKEN(1):   if SPDL then			/* <no-token>				*/
  6    74 						/* In push-down-language, there are 2 		*/
  6    75 						/*   interpretations of <no-token>.		*/
  6    76 		     if      RED.TOKEN_REQD.IFIRST = RED.TOKEN_REQD.ILAST &
  6    77 			   Ptoken = null then	/* When <no-token> is only spec, the spec asks 	*/
  6    78 			go to RD_MATCH_NO_TOKEN;	/* "Is push down stack empty (all input gone)?"   */
  6    79 		     else if RED.TOKEN_REQD.IFIRST^= RED.TOKEN_REQD.ILAST &
  6    80 			   RED.TOKEN_REQD.IFIRST = I &
  6    81 			   token.Pnext = null then	/* For SPEC1 ... SPECN <no-token>, the spec asks  */
  6    82 			go to RD_MATCH_NO_TOKEN;	/* "Are the topmost tokens on stack SPEC1 - SPECN,*/
  6    83 						/*  and is SPECN the final input token?"	*/
  6    84 		     else go to RD_NEXT_REDUCTION;	/* Those are the only two defs allowed in push	*/
  6    85 						/* down language mode for <no-token>.		*/
  6    86 		else if Ptoken = null then
  6    87 		     go to RD_MATCH_NO_TOKEN;
  6    88 		go to RD_NEXT_REDUCTION;
  6    89 
  6    90 RD_TEST_TOKEN(2):	go to RD_MATCH;			/* <any-token>				*/
  6    91 
  6    92 RD_TEST_TOKEN(3):	if token.Lvalue > 0 &		/* <name>					*/
  6    93 		   token.Lvalue <= 32 & ^token.S.quoted_string then
  6    94 		     if search(substr(token_value,1,1),"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
  6    95 		     > 0 then
  6    96 			if verify(token_value,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_$")
  6    97 			= 0 then
  6    98 			     go to RD_MATCH;
  6    99 		go to RD_NEXT_REDUCTION;
  6   100 
  6   101 RD_TEST_TOKEN(4):					/* <decimal-integer>			*/
  6   102 		if token.Nvalue ^= 0 then		/* token already determined to be a number.	*/
  6   103 		     go to RD_MATCH;
  6   104 		if token.S.quoted_string then
  6   105 		     go to RD_NEXT_REDUCTION;
  6   106 		NUMBER = cv_dec_check_ (token_value, CODE);
  6   107 		if CODE = 0 then do;
  6   108 		     token.Nvalue = NUMBER;
  6   109 		     go to RD_MATCH;
  6   110 		     end;
  6   111 		go to RD_NEXT_REDUCTION;
  6   112 
  6   113 RD_TEST_TOKEN(5):	if token.Lvalue = 1 then		/* <BS>					*/
  6   114 		     if token_value = BACKSPACE & ^token.S.quoted_string then
  6   115 			go to RD_MATCH;
  6   116 		go to RD_NEXT_REDUCTION;
  6   117 
  6   118 RD_TEST_TOKEN(6):	if token.S.quoted_string then		/* <quoted-string>				*/
  6   119 		     go to RD_MATCH;
  6   120 		go to RD_NEXT_REDUCTION;
  6   121 		end;
  6   122 
  6   123 	     else if TOKEN_REQD.FORM > 0 then do;	/* absolute syntax specification.		*/
  6   124 		if token.S.quoted_string then
  6   125 		     go to RD_NEXT_REDUCTION;
  6   126 		PTOKEN_REQD_VALUE = addr(substr(TOKEN_STRINGS,TOKEN_REQD_STRING.I));
  6   127 		LTOKEN_REQD_VALUE = TOKEN_REQD_STRING.L;
  6   128 		if token_value = TOKEN_REQD_VALUE then
  6   129 		     go to RD_MATCH;
  6   130 		go to RD_NEXT_REDUCTION;
  6   131 		end;
  6   132 
  6   133 	/* END OF:	rdc_end_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      426 
      427 
      428 	     else do;				/* relative syntax function.			*/
      429 		go to RD_TOKEN_FCN(TOKEN_REQD.TYPE);
      430 
      431 RD_TOKEN_FCN(1):	STOKEN_FCN = valid_station();
      432 		go to RD_TEST_RESULT;
      433 
      434 RD_TEST_RESULT:	if STOKEN_FCN then go to RD_MATCH;
      435 		else go to RD_NEXT_REDUCTION;
      436 		end;
      437 
      438 RD_MATCH:      Ptoken = token.Pnext;
      439 RD_MATCH_NO_TOKEN:
      440 	     end;
      441 	Ptoken = Pthis_token;
      442 	go to RD_ACTION(NRED);
      443 
      444 
      445 RD_ACTION(1):					/* /					*/
      446 	call					     add();
      447 	call 					     LEX ( 2 );
      448 	NRED = 1;
      449 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      450 
      451 RD_ACTION(2):					/* /					*/
      452 	call					     close();
      453 	return;					/* / RETURN	\			*/
      454 
      455 RD_ACTION(3):					/* /					*/
      456 	call 					     ERROR ( 1 );
      457 	call					     NEXT_STMT();
      458 	NRED = 1;
      459 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      460 
      461 RD_ACTION(4):					/* /					*/
      462 	call 					     ERROR ( 2 );
      463 	return;					/* / RETURN	\			*/
      464 
      465 
      466 	end SEMANTIC_ANALYSIS;
      467 
      468 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      469 
      470      dcl	SPDL			bit(1) aligned init ("0"b);
      471 						/* off: This compiler parses a non-PUSH DOWN	*/
      472 						/*      LANGUAGE.				*/
      473 	/* START OF:	rdc_lex_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7     4 	/*									*/
  7     5 	/* N__a_m_e:  rdc_lex_.incl.pl1							*/
  7     6 	/*									*/
  7     7 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  7     8 	/* It contains the LEX subroutine which is used to manipulate the pointer to the	*/
  7     9 	/* "current" token, Pthis_token.						*/
  7    10 	/*									*/
  7    11 	/* E__n_t_r_y:  LEX								*/
  7    12 	/*									*/
  7    13 	/*      This entry makes the |_nth|-next (or -preceding) token the "current" token, where	*/
  7    14 	/* _n is its positive (or negative) input argument.				*/
  7    15 	/*									*/
  7    16 	/* U__s_a_g_e									*/
  7    17 	/*									*/
  7    18 	/*      call LEX(n);							*/
  7    19 	/*									*/
  7    20 	/* 1) n   is the number of the token to be made the "current" token, relative to the	*/
  7    21 	/*        token identified by Pthis_token (the present "current" token).  If n is	*/
  7    22 	/*        positive, the nth token following the "current" token made "current".  If n	*/
  7    23 	/*        is negative, the nth token preceding the "current" token is made "current".	*/
  7    24 	/*									*/
  7    25 	/* S__t_a_t_u_s									*/
  7    26 	/*									*/
  7    27 	/* 0) Created by:  G. C. Dixon  in  February, 1975				*/
  7    28 	/*									*/
  7    29 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    30 
  7    31 LEX:	procedure (n);
  7    32 
  7    33      dcl	n			fixed bin,
  7    34 	i			fixed bin;
  7    35 
  7    36 	Ptoken = Pthis_token;			/* do everything relative to "current" token.	*/
  7    37 	if Ptoken = null then return;			/* can't lex if token list exhausted.		*/
  7    38 	if n >= 0 then do;				/* new "current" token will follow present one.	*/
  7    39 	     do i = 1 to n while (token.Pnext ^= null);	/* find new "current" token, taking care not to	*/
  7    40 		Ptoken = token.Pnext;		/*   run off end of token list.		*/
  7    41 		end;
  7    42 	     if ^SPDL then if i <= n then Ptoken = null;	/* if not in 'PUSH DOWN LANGUAGE' mode, allow	*/
  7    43 						/*   running off end of token list.		*/
  7    44 	     end;
  7    45 	else					/* new "current" token precedes present one.	*/
  7    46 	     do i = -1 to n by -1 while (token.Plast ^= null);
  7    47 		Ptoken = token.Plast;
  7    48 		end;
  7    49 	Pthis_token = Ptoken;			/* simple wasn't it.			*/
  7    50 
  7    51 	end LEX;
  7    52 
  7    53 /* END OF:	rdc_lex_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      473 
      474 
      475 		/* START OF:	rdc_error_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  8     2 
  8     3      dcl	MERROR_SEVERITY		fixed bin init (0),	/* Severity of highest-severity error.		*/
  8     4 	SERROR_CONTROL		bit(2) init ("00"b),/* Global switches control error message format.	*/
  8     5 	SERROR_PRINTED (dimension (error_control_table,1))
  8     6 				bit(1) unaligned init ((dimension (error_control_table,1))(1)"0"b),
  8     7 						/* Array bit is on if corresponding error message	*/
  8     8 						/* in error_control_table has already been printed*/
  8     9 	MIN_PRINT_SEVERITY		fixed bin init (0), /* Mimimum severity message that will be printed	*/
  8    10 	PRINT_SEVERITY_CONTROL	bit(2) init ("11"b);/* Action if severity < MIN_PRINT_SEVERITY	*/
  8    11 
  8    12 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  8    13 	/*									*/
  8    14 	/* N__a_m_e:  rdc_error_.incl.pl1							*/
  8    15 	/*									*/
  8    16 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  8    17 	/* It defines a procedure which the compilers can use to print error messages.  	*/
  8    18 	/*									*/
  8    19 	/* E__n_t_r_y:  ERROR								*/
  8    20 	/*									*/
  8    21 	/*      Given an error number, this procedure prints a corresponding error message.	*/
  8    22 	/* The message is stored in a compiler-defined error_control_table, along with an integer	*/
  8    23 	/* which specifies the severity level of the error, and a switch which specifies whether	*/
  8    24 	/* the source statement in which the error occurred (if any) should be printed after the	*/
  8    25 	/* error message.  The printing of the error message may be supressed for all messages	*/
  8    26 	/* having a severity less than a specified (MIN_PRINT_SEVERITY) value.  The ERROR	*/
  8    27 	/*  procedure calls the lex_error_ subroutine to perform the formatting and printing of	*/
  8    28 	/*  the error message.							*/
  8    29 	/*									*/
  8    30 	/* U__s_a_g_e									*/
  8    31 	/*									*/
  8    32 	/*      call ERROR (error_number);						*/
  8    33 	/*									*/
  8    34 	/* 1) error_number	is the index of one of the structures in the error_control_table	*/
  8    35 	/*		which defines the error message to be printed.			*/
  8    36 	/*									*/
  8    37 	/* N__o_t_e_s									*/
  8    38 	/*									*/
  8    39 	/*      The format of the error_control_table is shown below.			*/
  8    40 	/*									*/
  8    41 	/*   dcl	1 error_control_table (2)	aligned internal static,			*/
  8    42 	/*	  2 severity		fixed bin(17) unaligned init (2,3),		*/
  8    43 	/*	  2 Soutput_stmt		bit(1) unaligned initial ("0"b,"1"b),		*/
  8    44 	/*	  2 message		char(252) varying initial (			*/
  8    45 	/*		"The reduction source segment does not contain any reductions.",	*/
  8    46 	/*		"Reduction label  '^a'  is invalid."),				*/
  8    47 	/*	  2 brief_message		char(100) varying initial (			*/
  8    48 	/*		"", "'^a'");						*/
  8    49 	/*									*/
  8    50 	/* error_control_table is an array of structures, with one array element per error.	*/
  8    51 	/* Each structure contains: a severity level for the error; a switch which specifies	*/
  8    52 	/* whether the source statement being processed should be output after the error message;	*/
  8    53 	/* the long form of the error message text;  and the brief form of the error message text.*/
  8    54 	/* The dimension of the error_control_table array of structures, and the lengths of	*/
  8    55 	/* message (long message) and brief_message (brief message), are compiler-defined.	*/
  8    56 	/* structures and the lengths of the message and brief_message are compiler-defined.	*/
  8    57 	/* The only requirement is that the messages be 256 characters or less in length.	*/
  8    58 	/* (Remember that the longest character string which can be used in an initial attribute	*/
  8    59 	/* is 254 characters in length.)						*/
  8    60 	/*									*/
  8    61 	/*      The severity number causes the error message to be preceded by a herald which	*/
  8    62 	/* includes one of the following prefixes:					*/
  8    63 	/*									*/
  8    64 	/*       _s_e_v  _p_r_e_f_i_x 		  _e_x_p_l_a_n_a_t_i_o_n				*/
  8    65 	/*	0 = COMMENT		- this is a comment.			*/
  8    66 	/*	1 = WARNING		- a possible error has been detected.  The	*/
  8    67 	/*				  compiler will still generate an object segment.	*/
  8    68 	/*	2 = ERROR			- a probable error has been detected.  The	*/
  8    69 	/*				  compiler will still generate an object segment.	*/
  8    70 	/*	3 = FATAL ERROR		- an error has been detected which is so severe 	*/
  8    71 	/*				  that no object segment will be generated.	*/
  8    72 	/*	4 = TRANSLATOR ERROR	- an error has been detected in the operation of	*/
  8    73 	/*				  the compiler or translator.  No object segment	*/
  8    74 	/*				  will be generated.			*/
  8    75 	/*									*/
  8    76 	/* Full error messages are of the form:						*/
  8    77 	/*									*/
  8    78 	/*	_p_r_e_f_i_x _e_r_r_o_r__n_u_m_b_e_r, SEVERITY _s_e_v_e_r_i_t_y IN STATEMENT _n OF LINE _m		*/
  8    79 	/*	_t_e_x_t__o_f__e_r_r_o_r__m_e_s_s_a_g_e						*/
  8    80 	/*	SOURCE:								*/
  8    81 	/*	_s_o_u_r_c_e__s_t_a_t_e_m_e_n_t							*/
  8    82 	/*									*/
  8    83 	/* If only one statement appears in line _m, then "STATEMENT _n OF" is omitted.		*/
  8    84 	/* If the source statement has been printed in a previous error message, it is omitted.	*/
  8    85 	/*									*/
  8    86 	/*      The reduction compiler declares a bit string, SERROR_CONTROL, which controls the	*/
  8    87 	/* text of an error message.  The compiler may set this bit string, as shown below.	*/
  8    88 	/*									*/
  8    89 	/*   SERROR_CONTROL		_m_e_a_n_i_n_g						*/
  8    90 	/*	"00"b		the first time a particular error occurs, the long message	*/
  8    91 	/*			is printed; the brief message is used in subsequent	*/
  8    92 	/*			occurrences of that error.				*/
  8    93 	/*        "10"b or "11"b	the long error message is always used.			*/
  8    94 	/*	"01"b		the brief error message is always used.			*/
  8    95 	/* The initial value of SERROR_CONTROL is "00"b.					*/
  8    96 	/*									*/
  8    97 	/*      The reduction_compiler creates a declaration for SERROR_PRINTED, an array	*/
  8    98 	/* of switches (one per error).  The switch corresponding to a particular error is	*/
  8    99 	/* turned on whenever the error message is printed.  This allows lex_error_ to detect	*/
  8   100 	/* subsequent occurrences of that same error.					*/
  8   101 	/*									*/
  8   102 	/*      The reduction_compiler creates MERROR_SEVERITY, a fixed bin(17) integer		*/
  8   103 	/* in which the severity of the highest-severity error encountered is maintained.	*/
  8   104 	/* The compiler may reference this integer.					*/
  8   105 	/*									*/
  8   106 	/*      The reduction_compiler creates MIN_PRINT_SEVERITY, a fixed bin (17) integer	*/
  8   107 	/* which controls the printing of error messages by the ERROR procedure.		*/
  8   108 	/* Errors having a severity less than MIN_PRINT_SEVERITY will not cause lex_error_ to be	*/
  8   109 	/* and no error will be printed.  The behaviour of the ERROR procedure for such errors	*/
  8   110 	/* is controlled by the value of PRINT_SEVERITY_CONTROL, described below.		*/
  8   111 	/* The compiler may set the value of MIN_PRINT_SEVERITY; its initial value is 0.	*/
  8   112 
  8   113 	/*									*/
  8   114 	/*      The reduction_compiler declares a bit string, PRINT_SEVERITY_CONTROL, which 	*/
  8   115 	/* controls the updating of MERROR_SEVERITY and SERROR_PRINTED when the severity of an	*/
  8   116 	/* error is less than MIN_PRINT_SEVERITY.  In such cases, the lex_error_ procedure is not	*/
  8   117 	/* invoked, and the ERROR procedure must update these values as though lex_error_ were	*/
  8   118 	/* called.  The compiler may set this bit string, as shown below.			*/
  8   119 	/*									*/
  8   120 	/* PRINT_SEVERITY_CONTROL	_m_e_a_n_i_n_g						*/
  8   121 	/*	"00"b		update neither SERROR_PRINTED nor MERROR_SEVERITY.	*/
  8   122 	/*	"01"b		update SERROR_PRINTED to reflect the error.		*/
  8   123 	/*	"10"b		update MERROR_SEVERITY to reflect the error severity.	*/
  8   124 	/*	"11"b		update SERROR_PRINTED and MERROR_SEVERITY appropriately.	*/
  8   125 	/*The initial value of PRINT_SEVERITY_CONTROL is "11"b.				*/
  8   126 	/*									*/
  8   127 	/*      The ERROR procedure is simple to use, but it does limit the flexibility of the	*/
  8   128 	/* error message.  A compiler action routine can output more flexible error messages	*/
  8   129 	/* by calling lex_error_ directly.  See lex_error_ documentation for more details.	*/
  8   130 	/*									*/
  8   131 	/* S__t_a_t_u_s									*/
  8   132 	/*									*/
  8   133 	/* 0) Created:  April, 1974 by G. C. Dixon					*/
  8   134 	/* 1) Modified: April, 1982 by E. N. Kittlitz.  Added MIN_PRINT_SEVERITY, 		*/
  8   135 	/*		PRINT_SEVERITY_CONTROL.					*/
  8   136 	/*									*/
  8   137 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  8   138 
  8   139 ERROR:	procedure (Nerror);
  8   140 
  8   141      dcl	Nerror			fixed bin;	/* Number of the error which was detected. (In)	*/
  8   142 
  8   143      dcl	Pstmt			ptr,
  8   144 	1 erring_token		aligned based (Perring_token) like token,
  8   145 	Perring_token		ptr,
  8   146 	erring_token_value		char(erring_token.Lvalue) based (erring_token.Pvalue);
  8   147 
  8   148      dcl 	(max, null)		builtin;
  8   149 
  8   150      dcl	lex_error_		entry options (variable);
  8   151 
  8   152 
  8   153 	if error_control_table.severity(Nerror) < MIN_PRINT_SEVERITY then do; /* don't print		*/
  8   154 	     if PRINT_SEVERITY_CONTROL & "1"b then	/* update MERROR_SEVERITY			*/
  8   155 		MERROR_SEVERITY = max (MERROR_SEVERITY, error_control_table.severity(Nerror));
  8   156 	     if PRINT_SEVERITY_CONTROL & "01"b then	/* update SERROR_PRINTED			*/
  8   157 		SERROR_PRINTED(Nerror) = "1"b;
  8   158 	     return;
  8   159 	end;
  8   160 	Perring_token = Pthis_token;			/* address the current erring_token.		*/
  8   161 	if error_control_table.Soutput_stmt(Nerror) then
  8   162 	     if Perring_token = null then
  8   163 		Pstmt = null;
  8   164 	     else
  8   165 		Pstmt = erring_token.Pstmt;		/* address the statement descriptor.		*/
  8   166 	else
  8   167 	     Pstmt = null;
  8   168 	if Perring_token = null then
  8   169 	     call lex_error_ (Nerror, SERROR_PRINTED(Nerror), (error_control_table.severity(Nerror)),
  8   170 		MERROR_SEVERITY, Pstmt, Perring_token, SERROR_CONTROL, (error_control_table.message(Nerror)),
  8   171 		(error_control_table.brief_message(Nerror)));
  8   172 	else
  8   173 	     call lex_error_ (Nerror, SERROR_PRINTED(Nerror), (error_control_table.severity(Nerror)),
  8   174 		MERROR_SEVERITY, Pstmt, Perring_token, SERROR_CONTROL, (error_control_table.message(Nerror)),
  8   175 		(error_control_table.brief_message(Nerror)), erring_token_value, erring_token_value, erring_token_value);
  8   176 
  8   177 	end ERROR;
  8   178 
  8   179 	/* END OF:	rdc_error_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      475 
      476 
      477 		/* START OF:	rdc_next_stmt_.incl.pl1	  *  *  *  *  *  *  */
  9     2 
  9     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  9     4 	/*							*/
  9     5 	/* N__a_m_e:  rdc_next_stmt_.incl.pl1				*/
  9     6 	/*							*/
  9     7 	/*      This include segment is used by compilers generated by the	*/
  9     8 	/* reduction_compiler.  It includes a procedure which shifts the	*/
  9     9 	/* compilation process to the next source statement.		*/
  9    10 	/*							*/
  9    11 	/* S__t_a_t_u_s							*/
  9    12 	/*							*/
  9    13 	/* 0) Created:  April, 1974 by G. C. Dixon			*/
  9    14 	/*							*/
  9    15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  9    16 
  9    17 
  9    18 NEXT_STMT:	procedure;			/* invoked to begin parsing the next statement of	*/
  9    19 						/* the input tokens.			*/
  9    20 
  9    21      dcl	null			builtin,
  9    22 	Ssearching		bit(1) aligned;
  9    23 
  9    24 	Ptoken = Pthis_token;			/* make sure these pointers are the same.	*/
  9    25 	Pstmt = token.Pstmt;			/* address "current" statement's descriptor.	*/
  9    26 	Ssearching = "1"b;				/* start scanning forward for next statement.	*/
  9    27 	do while (Ssearching & token.Pnext ^= null);
  9    28 	     Ptoken = token.Pnext;
  9    29 	     if token.Pstmt = Pstmt then;
  9    30 	     else Ssearching = "0"b;
  9    31 	     end;
  9    32 	if token.Pstmt = Pstmt then			/* if there is no next statement, and		*/
  9    33 	     if SPDL then				/*   in PUSH DOWN LANGUAGE mode, can't run off	*/
  9    34 		Ptoken = Ptoken;			/*   end of input list.			*/
  9    35 	     else Ptoken, Pthis_token = null;		/*   otherwise, input list exhausted.		*/
  9    36 	else Pthis_token = Ptoken;			/* normally, next statement exists and Ptoken	*/
  9    37 						/*   points to its 1st _n_o_n-__d_e_l_e_t_e_d token.	*/
  9    38 
  9    39 	end NEXT_STMT;
  9    40 
  9    41 	/* END OF:	rdc_next_stmt_.incl.pl1	  *  *  *  *  *  *  */
      477 
      478 
      479 	end cv_cmcs_station_ctl;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/17/86  1452.1  cv_cmcs_station_ctl.pl1           >spec>install>1032>cv_cmcs_station_ctl.pl1
46           1    03/27/82  0439.5  cmcs_control_hdr.incl.pl1         >ldd>include>cmcs_control_hdr.incl.pl1
47           2    03/27/82  0431.4  cmcs_entry_dcls.incl.pl1          >ldd>include>cmcs_entry_dcls.incl.pl1
48           3    03/27/82  0439.6  cmcs_station_ctl.incl.pl1         >ldd>include>cmcs_station_ctl.incl.pl1
374          4    04/18/75  1242.4  rdc_start_.incl.pl1               >ldd>include>rdc_start_.incl.pl1
4-25         5    04/18/75  1242.4  lex_descriptors_.incl.pl1         >ldd>include>lex_descriptors_.incl.pl1
426          6    03/17/86  1404.9  rdc_end_.incl.pl1                 >spec>install>1032>rdc_end_.incl.pl1
473          7    04/18/75  1242.4  rdc_lex_.incl.pl1                 >ldd>include>rdc_lex_.incl.pl1
475          8    08/15/83  1511.7  rdc_error_.incl.pl1               >ldd>include>rdc_error_.incl.pl1
477          9    04/18/75  1242.4  rdc_next_stmt_.incl.pl1           >ldd>include>rdc_next_stmt_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALPHANUMERICS                   000136 constant        char(64)                 initial unaligned dcl 117 ref 334
APstmt                          000106 automatic       pointer                  dcl 54 set ref 252*
APtoken                         000110 automatic       pointer                  dcl 54 set ref 252* 263
BACKSPACE                       003733 constant        char(1)                  initial dcl 4-99 ref 6-113
BREAKS                          000014 internal static varying char(128)        dcl 114 set ref 232* 233 235* 252*
CODE                            000315 automatic       fixed bin(35,0)          dcl 4-33 set ref 6-106* 6-107
DIRECTION                       000320 automatic       fixed bin(17,0)          initial dcl 376 set ref 6-62 376*
FORM                                   based           fixed bin(17,0)          level 2 packed unaligned dcl 4-48 ref 6-65 6-70
                                                                                  6-123
I                               000316 automatic       fixed bin(17,0)          dcl 4-33 in procedure "SEMANTIC_ANALYSIS" set ref
                                                                                  6-62* 6-63 6-79*
I                                      based           fixed bin(17,0)          level 2 in structure "TOKEN_REQD_STRING" packed
                                                                                  unaligned dcl 4-48 in procedure
                                                                                  "SEMANTIC_ANALYSIS" ref 6-126
IFIRST                                 based           fixed bin(17,0)          level 3 packed unaligned dcl 4-48 ref 6-62 6-73 6-79
                                                                                  6-79
IGBREAKS                        000055 internal static varying char(128)        dcl 114 set ref 233* 235* 252*
ILAST                     0(18)        based           fixed bin(17,0)          level 3 packed unaligned dcl 4-48 ref 6-62 6-73 6-79
L                         0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 4-48 ref 6-127
LEXCTL                          000116 internal static varying char(128)        dcl 114 set ref 235* 252*
LEXDLM                          000157 internal static varying char(128)        dcl 114 set ref 235* 252*
LTOKEN_REQD_VALUE               000304 automatic       fixed bin(18,0)          dcl 4-33 set ref 6-127* 6-128
Lvalue                    4            based           fixed bin(18,0)          level 2 in structure "erring_token" dcl 8-143
                                                                                  in procedure "ERROR" ref 8-172 8-172 8-172 8-172
                                                                                  8-172 8-172
Lvalue                    4            based           fixed bin(18,0)          level 2 in structure "token" dcl 5-68 in procedure
                                                                                  "cv_cmcs_station_ctl" ref 328 328 330 332 334 336
                                                                                  6-92 6-92 6-92 6-92 6-106 6-106 6-113 6-113 6-128
MERROR_SEVERITY                 000237 automatic       fixed bin(17,0)          initial dcl 8-3 set ref 267 8-3* 8-154* 8-154 8-168*
                                                                                  8-172*
MIN_PRINT_SEVERITY              000241 automatic       fixed bin(17,0)          initial dcl 8-3 set ref 8-3* 8-153
NRED                            000305 automatic       fixed bin(17,0)          dcl 4-33 set ref 6-52* 6-55* 6-55 6-58 442 448* 458*
NUMBER                          000317 automatic       fixed bin(35,0)          dcl 4-33 set ref 6-106* 6-108
Nerror                                 parameter       fixed bin(17,0)          dcl 8-141 set ref 8-139 8-153 8-154 8-156 8-161
                                                                                  8-168* 8-168 8-168 8-168 8-168 8-172* 8-172 8-172
                                                                                  8-172 8-172
Nvalue                   10            based           fixed bin(35,0)          level 3 packed unaligned dcl 5-68 set ref 6-101
                                                                                  6-108*
PRED                            000306 automatic       pointer                  dcl 4-33 set ref 6-58* 6-62 6-62 6-73 6-73 6-79 6-79
                                                                                  6-79
PRINT_SEVERITY_CONTROL          000242 automatic       bit(2)                   initial unaligned dcl 8-3 set ref 8-3* 8-154 8-156
PTOKEN_REQD                     000310 automatic       pointer                  dcl 4-33 set ref 6-63* 6-65 6-65 6-70 6-71 6-123
                                                                                  6-126 6-127 429
PTOKEN_REQD_VALUE               000312 automatic       pointer                  dcl 4-33 set ref 6-126* 6-128
Perring_token                   000366 automatic       pointer                  dcl 8-143 set ref 8-160* 8-161 8-164 8-168 8-168*
                                                                                  8-172* 8-172 8-172 8-172 8-172 8-172 8-172 8-172
                                                                                  8-172 8-172
Plast                     2            based           pointer                  level 2 packed unaligned dcl 5-68 ref 7-45 7-47
Pnext                     1            based           pointer                  level 2 packed unaligned dcl 5-68 ref 6-79 438 7-39
                                                                                  7-40 9-27 9-28
Pstmt                           000232 automatic       pointer                  dcl 5-40 in procedure "cv_cmcs_station_ctl" set ref
                                                                                  9-25* 9-29 9-32
Pstmt                     5            based           pointer                  level 2 in structure "token" packed unaligned
                                                                                  dcl 5-68 in procedure "cv_cmcs_station_ctl" ref
                                                                                  9-25 9-29 9-32
Pstmt                           000364 automatic       pointer                  dcl 8-143 in procedure "ERROR" set ref 8-161* 8-164*
                                                                                  8-166* 8-168* 8-172*
Pstmt                     5            based           pointer                  level 2 in structure "erring_token" packed unaligned
                                                                                  dcl 8-143 in procedure "ERROR" ref 8-164
Pthis_token                     000230 automatic       pointer                  dcl 4-23 set ref 263* 6-60 441 7-36 7-49* 8-160 9-24
                                                                                  9-35* 9-36*
Ptoken                          000234 automatic       pointer                  dcl 5-68 set ref 328 328 328 330 330 332 332 334 334
                                                                                  336 336 6-60* 6-64 6-73 6-79 6-86 6-92 6-92 6-92
                                                                                  6-92 6-92 6-92 6-92 6-101 6-104 6-106 6-106 6-106
                                                                                  6-108 6-113 6-113 6-113 6-113 6-118 6-124 6-128
                                                                                  6-128 438* 438 441* 7-36* 7-37 7-39 7-40* 7-40
                                                                                  7-42* 7-45 7-47* 7-47 7-49 9-24* 9-25 9-27 9-28*
                                                                                  9-28 9-29 9-32 9-32* 9-32 9-35* 9-36
Pvalue                    3            based           pointer                  level 2 in structure "token" packed unaligned
                                                                                  dcl 5-68 in procedure "cv_cmcs_station_ctl" ref
                                                                                  328 330 332 334 336 6-92 6-92 6-106 6-113 6-128
Pvalue                    3            based           pointer                  level 2 in structure "erring_token" packed unaligned
                                                                                  dcl 8-143 in procedure "ERROR" ref 8-172 8-172
                                                                                  8-172
RED                                    based           structure                level 1 dcl 4-48
REDUCTION                              based           structure                array level 1 packed unaligned dcl 379 set ref 6-58
REDUCTIONS                      000132 constant        fixed bin(17,0)          initial array unaligned dcl 379 set ref 6-58
S                        11            based           structure                level 3 packed unaligned dcl 5-68
SERROR_CONTROL                  000240 automatic       bit(2)                   initial unaligned dcl 8-3 set ref 154* 157* 8-3*
                                                                                  8-168* 8-172*
SERROR_PRINTED                  000241 automatic       bit(1)                   initial array unaligned dcl 8-3 set ref 8-3* 8-156*
                                                                                  8-168* 8-172*
SPDL                            000236 automatic       bit(1)                   initial dcl 470 set ref 470* 6-73 7-42 9-32
STOKEN_FCN                      000314 automatic       bit(1)                   dcl 4-33 set ref 431* 434
Soutput_stmt              0(18) 000000 constant        bit(1)                   initial array level 2 packed unaligned dcl 311 ref
                                                                                  8-161
Ssearching                      000376 automatic       bit(1)                   dcl 9-21 set ref 9-26* 9-27 9-30*
TOKEN_REQD                             based           structure                level 2 in structure "RED" packed unaligned dcl 4-48
                                                                                  in procedure "SEMANTIC_ANALYSIS"
TOKEN_REQD                             based           structure                level 1 dcl 4-48 in procedure "SEMANTIC_ANALYSIS"
TOKEN_REQD_STRING                      based           structure                level 1 dcl 4-48
TOKEN_REQD_VALUE                       based           char                     unaligned dcl 4-48 ref 6-128
TOKEN_REQUIREMENT                      based           structure                array level 1 packed unaligned dcl 391 set ref 6-63
TOKEN_REQUIREMENTS              000124 constant        fixed bin(17,0)          initial array unaligned dcl 391 set ref 6-63
TOKEN_STRINGS                          based           char(4)                  dcl 421 set ref 6-126
TOKEN_STRING_ARRAYS             000073 constant        char(100)                initial array dcl 421 set ref 6-126
TRACING                         000221 internal static bit(1)                   initial dcl 371 set ref 6-50* 6-50
TYPE                      0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 4-48 ref 6-65 6-71 429
aclinfo_ptr                     000104 automatic       pointer                  dcl 38 set ref 169* 208* 278* 303 303*
addr                                                   builtin function         dcl 4-92 ref 6-58 6-58 6-63 6-63 6-126 6-126
area_ptr                        000112 automatic       pointer                  dcl 54 set ref 168* 241* 243 252* 300 300*
arg_length                      000114 automatic       fixed bin(21,0)          dcl 54 set ref 132* 142 142 147 147 152* 154 154 157
                                                                                  157 161 161
arg_ptr                         000116 automatic       pointer                  dcl 54 set ref 132* 142 147 152* 154 154 157 157 161
arg_string                             based           char                     unaligned dcl 70 set ref 142* 147* 154 154 157 157
                                                                                  161*
bitcount                        000120 automatic       fixed bin(24,0)          dcl 54 set ref 173* 204 276* 278* 280*
brief_message            22     000000 constant        varying char(20)         initial array level 2 dcl 311 ref 8-168 8-172
cleanup                         000222 stack reference condition                dcl 79 ref 171
cmcs_fillin_hdr_                000222 constant        entry                    external dcl 2-16 ref 220
code                            000121 automatic       fixed bin(35,0)          dcl 54 set ref 132* 134 137* 142* 144 147* 152* 154
                                                                                  173* 178* 197* 208* 210 213* 220* 222 224* 241*
                                                                                  247* 252* 255 258* 271* 278* 280 280* 294* 297*
                                                                                  300*
collate                                                builtin function         dcl 74 ref 232 232
com_err_                        000242 constant        entry                    external dcl 83 ref 137 147 161 178 189 213 224 247
                                                                                  258 270 280
control_hdr                            based           structure                level 1 dcl 1-11
cu_$arg_ptr                     000224 constant        entry                    external dcl 83 ref 132 152
current_size             16            based           fixed bin(18,0)          level 3 dcl 3-13 set ref 276 352 352* 353 354
cv_dec_check_                   000272 constant        entry                    external dcl 4-96 ref 6-106
dimension                                              builtin function         dcl 74 ref 8-3 8-3
divide                                                 builtin function         dcl 74 ref 204
dname                           000122 automatic       char(168)                unaligned dcl 54 set ref 142* 173* 178* 206* 208*
                                                                                  213* 280*
ename                           000174 automatic       char(32)                 unaligned dcl 54 set ref 142* 173* 178* 185 202 258*
                                                                                  270*
entries                  40            based           structure                array level 2 dcl 3-13
entry_count              17            based           fixed bin(18,0)          level 3 dcl 3-13 set ref 352*
erring_token                           based           structure                level 1 dcl 8-143
erring_token_value                     based           char                     unaligned dcl 8-143 set ref 8-172* 8-172* 8-172*
error_control_table             000000 constant        structure                array level 1 dcl 311 ref 8-3 8-3
error_table_$bad_name           000266 external static fixed bin(35,0)          dcl 124 set ref 189*
error_table_$badopt             000262 external static fixed bin(35,0)          dcl 124 set ref 161*
error_table_$entlong            000264 external static fixed bin(35,0)          dcl 124 ref 197
error_table_$translation_failed 000270 external static fixed bin(35,0)          dcl 124 set ref 270*
expand_pathname_                000226 constant        entry                    external dcl 83 ref 142
first_time                      000220 internal static bit(1)                   initial dcl 114 set ref 229 237*
flags                    44            based           structure                array level 3 dcl 3-13 set ref 353*
get_wdir_                       000230 constant        entry                    external dcl 83 ref 206
group2                    7            based           structure                level 2 packed unaligned dcl 5-68
hcs_$delentry_seg               000232 constant        entry                    external dcl 83 ref 271
hcs_$initiate_count             000234 constant        entry                    external dcl 83 ref 173
hcs_$terminate_noname           000236 constant        entry                    external dcl 83 ref 294 297
hdr                                    based           structure                level 2 dcl 3-13
i                               000352 automatic       fixed bin(17,0)          dcl 7-33 in procedure "LEX" set ref 7-39* 7-42 7-45*
i                               000204 automatic       fixed bin(17,0)          dcl 54 in procedure "cv_cmcs_station_ctl" set ref
                                                                                  185* 187 194 202
index                                                  builtin function         dcl 74 ref 185
ioa_                            000240 constant        entry                    external dcl 83 ref 328 344
length                                                 builtin function         dcl 74 ref 194 194 332
lex_error_                      000274 constant        entry                    external dcl 8-150 ref 8-168 8-172
lex_string_$init_lex_delims     000244 constant        entry                    external dcl 83 ref 235
lex_string_$lex                 000246 constant        entry                    external dcl 83 ref 252
max                                                    builtin function         dcl 8-148 ref 8-154
message                   1     000000 constant        varying char(64)         initial array level 2 dcl 311 ref 8-168 8-172
my_name                         000156 constant        char(20)                 initial unaligned dcl 117 set ref 137* 147* 161*
                                                                                  178* 189* 213* 224* 241* 247* 258* 270* 280*
n                                      parameter       fixed bin(17,0)          dcl 7-33 ref 7-31 7-38 7-39 7-42 7-45
n_chars                         000205 automatic       fixed bin(21,0)          dcl 54 set ref 204* 252*
new_station_name                000100 automatic       char(12)                 unaligned dcl 38 set ref 336* 354
null                                                   builtin function         dcl 4-92 in procedure "SEMANTIC_ANALYSIS" ref 6-64
                                                                                  6-73 6-79 6-86
null                                                   builtin function         dcl 9-21 in procedure "NEXT_STMT" ref 9-27 9-35
null                                                   builtin function         dcl 74 in procedure "cv_cmcs_station_ctl" ref 166
                                                                                  167 168 169 175 243 294 297 300 303 7-37 7-39 7-42
                                                                                  7-45
null                                                   builtin function         dcl 8-148 in procedure "ERROR" ref 8-161 8-161 8-166
                                                                                  8-168
object_name                     000206 automatic       char(32)                 unaligned dcl 54 set ref 194 202* 208* 213* 280*
object_ptr                      000216 automatic       pointer                  dcl 54 set ref 167* 208* 218 271* 278* 297 297*
quoted_string            11(01)        based           bit(1)                   level 4 packed unaligned dcl 5-68 ref 6-92 6-104
                                                                                  6-113 6-118 6-124
search                                                 builtin function         dcl 4-92 ref 6-92
severity                        000000 constant        fixed bin(17,0)          initial array level 2 packed unaligned dcl 311 ref
                                                                                  8-153 8-154 8-168 8-172
source_ptr                      000220 automatic       pointer                  dcl 54 set ref 166* 173* 175 252* 294 294*
station_ctl                            based           structure                level 1 dcl 3-13
station_ctl_entry                      based           structure                level 1 dcl 3-21
station_ctl_entry_len           000230 constant        fixed bin(17,0)          initial dcl 3-7 set ref 220* 276
station_ctl_hdr_len             000220 constant        fixed bin(17,0)          initial dcl 3-7 set ref 220* 276
station_ctl_ptr                 000012 internal static pointer                  dcl 3-11 set ref 218* 220* 276 352 352 352 353 353
                                                                                  354 354
station_ctl_version             000232 constant        fixed bin(17,0)          initial dcl 3-7 set ref 220*
station_name             40            based           char(12)                 array level 3 dcl 3-13 set ref 354*
string                                                 builtin function         dcl 74 set ref 353*
substr                                                 builtin function         dcl 4-92 in procedure "SEMANTIC_ANALYSIS" ref 6-92
                                                                                  6-126
substr                                                 builtin function         dcl 74 in procedure "cv_cmcs_station_ctl" ref 202
                                                                                  232 232 233
test_sw                         000010 internal static bit(1)                   initial unaligned dcl 43 set ref 328 344 364*
token                                  based           structure                level 1 dcl 5-68
token_value                            based           char                     unaligned dcl 5-68 set ref 328* 330 332 334 336 6-92
                                                                                  6-92 6-106* 6-113 6-128
translator_temp_$get_segment    000250 constant        entry                    external dcl 83 ref 241
translator_temp_$release_all_segments
                                000252 constant        entry                    external dcl 83 ref 300
tssi_$clean_up_segment          000260 constant        entry                    external dcl 83 ref 303
tssi_$finish_segment            000256 constant        entry                    external dcl 83 ref 278
tssi_$get_segment               000254 constant        entry                    external dcl 83 ref 208
verify                                                 builtin function         dcl 4-92 in procedure "SEMANTIC_ANALYSIS" ref 6-92
verify                                                 builtin function         dcl 74 in procedure "cv_cmcs_station_ctl" ref 334

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
LEGAL                                  internal static char(71)                 initial dcl 117
Pcomment                               automatic       pointer                  dcl 5-20
addr                                                   builtin function         dcl 74
clock_                          000000 constant        entry                    external dcl 83
cmcs_create_queues_             000000 constant        entry                    external dcl 2-8
cmcs_date_time_                 000000 constant        entry                    external dcl 2-10
cmcs_decode_status_             000000 constant        entry                    external dcl 2-12
cmcs_expand_tree_path_          000000 constant        entry                    external dcl 2-14
cmcs_initiate_ctl_              000000 constant        entry                    external dcl 2-18
cmcs_print_                     000000 constant        entry                    external dcl 2-20
cmcs_purge_queues_              000000 constant        entry                    external dcl 2-22
cmcs_queue_ctl_$accept_message_count
                                000000 constant        entry                    external dcl 2-24
cmcs_queue_ctl_$disable         000000 constant        entry                    external dcl 2-25
cmcs_queue_ctl_$enable          000000 constant        entry                    external dcl 2-26
cmcs_queue_ctl_$print           000000 constant        entry                    external dcl 2-27
cmcs_queue_ctl_$purge           000000 constant        entry                    external dcl 2-28
cmcs_queue_ctl_$receive         000000 constant        entry                    external dcl 2-29
cmcs_queue_ctl_$send            000000 constant        entry                    external dcl 2-30
cmcs_queue_ctl_$stop_run        000000 constant        entry                    external dcl 2-31
cmcs_scramble_                  000000 constant        entry                    external dcl 2-33
cmcs_set_lock_$lock             000000 constant        entry                    external dcl 2-35
cmcs_set_lock_$unlock           000000 constant        entry                    external dcl 2-36
cmcs_station_ctl_$attach        000000 constant        entry                    external dcl 2-38
cmcs_station_ctl_$detach        000000 constant        entry                    external dcl 2-39
cmcs_station_ctl_$detach_name   000000 constant        entry                    external dcl 2-40
cmcs_station_ctl_$disable_input_terminal
                                000000 constant        entry                    external dcl 2-41
cmcs_station_ctl_$disable_output_terminal
                                000000 constant        entry                    external dcl 2-42
cmcs_station_ctl_$enable_input_terminal
                                000000 constant        entry                    external dcl 2-43
cmcs_station_ctl_$enable_output_terminal
                                000000 constant        entry                    external dcl 2-44
cmcs_station_ctl_$find_destination
                                000000 constant        entry                    external dcl 2-45
cmcs_station_ctl_$input_disabled
                                000000 constant        entry                    external dcl 2-46
cmcs_station_ctl_$output_disabled
                                000000 constant        entry                    external dcl 2-47
cmcs_station_ctl_$validate      000000 constant        entry                    external dcl 2-48
cmcs_status_list_ctl_$add       000000 constant        entry                    external dcl 2-50
cmcs_status_list_ctl_$delete    000000 constant        entry                    external dcl 2-51
cmcs_status_list_ctl_$move      000000 constant        entry                    external dcl 2-52
cmcs_terminal_ctl_$find         000000 constant        entry                    external dcl 2-54
cmcs_tree_ctl_$find_destination 000000 constant        entry                    external dcl 2-56
cmcs_tree_ctl_$find_index       000000 constant        entry                    external dcl 2-57
cmcs_tree_ctl_$find_qual_name   000000 constant        entry                    external dcl 2-59
cmcs_tree_ctl_$find_tree_path   000000 constant        entry                    external dcl 2-58
cmcs_wait_ctl_$add              000000 constant        entry                    external dcl 2-61
cmcs_wait_ctl_$clear_mp         000000 constant        entry                    external dcl 2-67
cmcs_wait_ctl_$delete           000000 constant        entry                    external dcl 2-62
cmcs_wait_ctl_$find             000000 constant        entry                    external dcl 2-63
cmcs_wait_ctl_$mp_available     000000 constant        entry                    external dcl 2-64
cmcs_wait_ctl_$mp_login         000000 constant        entry                    external dcl 2-65
cmcs_wait_ctl_$mp_logout        000000 constant        entry                    external dcl 2-66
cmcs_wait_ctl_$start_mp         000000 constant        entry                    external dcl 2-68
cmcs_wait_ctl_$stop_mp          000000 constant        entry                    external dcl 2-69
comment                                based           structure                level 1 dcl 5-20
comment_value                          based           char                     unaligned dcl 5-20
control_hdr_len                        internal static fixed bin(17,0)          initial dcl 1-7
control_hdr_ptr                        automatic       pointer                  dcl 1-9
cv_dec_check_                   000000 constant        entry                    external dcl 83
get_group_id_                   000000 constant        entry                    external dcl 83
get_process_id_                 000000 constant        entry                    external dcl 83
hcs_$make_seg                   000000 constant        entry                    external dcl 83
hcs_$set_bc_seg                 000000 constant        entry                    external dcl 83
hcs_$truncate_seg               000000 constant        entry                    external dcl 83
j                                      automatic       fixed bin(17,0)          dcl 38
lex_error_                      000000 constant        entry                    external dcl 83
max                                                    builtin function         dcl 4-92
pntep                                  automatic       pointer                  dcl 54
reverse                                                builtin function         dcl 74
station_ctl_eindex                     automatic       fixed bin(17,0)          dcl 3-17
station_ctl_eptr                       automatic       pointer                  dcl 3-19
stmt                                   based           structure                level 1 dcl 5-40
stmt_value                             based           char                     unaligned dcl 5-40
sys_info$max_seg_size                  external static fixed bin(18,0)          dcl 124
temp3                                  automatic       char(3)                  unaligned dcl 38
unique_chars_                   000000 constant        entry                    external dcl 83

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR                           002743 constant        entry                    internal dcl 8-139 ref 455 461
LEX                             002656 constant        entry                    internal dcl 7-31 ref 447
NEXT_STMT                       003254 constant        entry                    internal dcl 9-18 ref 457
RD_ACTION                       000067 constant        label                    array(4) dcl 445 ref 442
RD_MATCH                        002615 constant        label                    dcl 438 ref 6-90 6-92 6-101 6-109 6-113 6-118 6-128
                                                                                  434
RD_MATCH_NO_TOKEN               002620 constant        label                    dcl 439 ref 6-73 6-79 6-86
RD_NEXT_REDUCTION               002321 constant        label                    dcl 6-55 ref 6-68 6-84 6-88 6-99 6-104 6-111 6-116
                                                                                  6-120 6-124 6-130 435
RD_TEST_REDUCTION               002322 constant        label                    dcl 6-58 ref 6-53 449 459
RD_TEST_RESULT                  002611 constant        label                    dcl 434 ref 432
RD_TEST_TOKEN                   000060 constant        label                    array(6) dcl 6-73 ref 6-65 6-71
RD_TOKEN_FCN                    000066 constant        label                    array(1) dcl 431 ref 429
SEMANTIC_ANALYSIS               002311 constant        entry                    internal dcl 4-30 ref 265
add                             002271 constant        entry                    internal dcl 350 ref 445
clean_up                        002055 constant        entry                    internal dcl 291 ref 171 285
close                           002252 constant        entry                    internal dcl 342 ref 451
cv_cmcs_station_ctl             000504 constant        entry                    external dcl 36
report_error                    001053 constant        label                    dcl 178 ref 198
test                            002042 constant        entry                    external dcl 362
valid_station                   002150 constant        entry                    internal dcl 326 ref 431

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4242        4540    3734        4252
Length      5170    3734       276         414     305         212

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cv_cmcs_station_ctl                 630 external procedure  is an external procedure.  
on unit on line 171                  64 on unit               
clean_up                             70 internal procedure  is called by several nonquick procedures.  
valid_station                           internal procedure  shares stack frame of external procedure cv_cmcs_station_ctl.  
close                                   internal procedure  shares stack frame of external procedure cv_cmcs_station_ctl.  
add                                     internal procedure  shares stack frame of external procedure cv_cmcs_station_ctl.  
SEMANTIC_ANALYSIS                       internal procedure  shares stack frame of external procedure cv_cmcs_station_ctl.  
LEX                                     internal procedure  shares stack frame of external procedure cv_cmcs_station_ctl.  
ERROR                                   internal procedure  shares stack frame of external procedure cv_cmcs_station_ctl.  
NEXT_STMT                               internal procedure  shares stack frame of external procedure cv_cmcs_station_ctl.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 test_sw                     cv_cmcs_station_ctl
000012 station_ctl_ptr             cv_cmcs_station_ctl
000014 BREAKS                      cv_cmcs_station_ctl
000055 IGBREAKS                    cv_cmcs_station_ctl
000116 LEXCTL                      cv_cmcs_station_ctl
000157 LEXDLM                      cv_cmcs_station_ctl
000220 first_time                  cv_cmcs_station_ctl
000221 TRACING                     cv_cmcs_station_ctl

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cv_cmcs_station_ctl      000100 new_station_name            cv_cmcs_station_ctl
                         000104 aclinfo_ptr                 cv_cmcs_station_ctl
                         000106 APstmt                      cv_cmcs_station_ctl
                         000110 APtoken                     cv_cmcs_station_ctl
                         000112 area_ptr                    cv_cmcs_station_ctl
                         000114 arg_length                  cv_cmcs_station_ctl
                         000116 arg_ptr                     cv_cmcs_station_ctl
                         000120 bitcount                    cv_cmcs_station_ctl
                         000121 code                        cv_cmcs_station_ctl
                         000122 dname                       cv_cmcs_station_ctl
                         000174 ename                       cv_cmcs_station_ctl
                         000204 i                           cv_cmcs_station_ctl
                         000205 n_chars                     cv_cmcs_station_ctl
                         000206 object_name                 cv_cmcs_station_ctl
                         000216 object_ptr                  cv_cmcs_station_ctl
                         000220 source_ptr                  cv_cmcs_station_ctl
                         000230 Pthis_token                 cv_cmcs_station_ctl
                         000232 Pstmt                       cv_cmcs_station_ctl
                         000234 Ptoken                      cv_cmcs_station_ctl
                         000236 SPDL                        cv_cmcs_station_ctl
                         000237 MERROR_SEVERITY             cv_cmcs_station_ctl
                         000240 SERROR_CONTROL              cv_cmcs_station_ctl
                         000241 MIN_PRINT_SEVERITY          cv_cmcs_station_ctl
                         000241 SERROR_PRINTED              cv_cmcs_station_ctl
                         000242 PRINT_SEVERITY_CONTROL      cv_cmcs_station_ctl
                         000304 LTOKEN_REQD_VALUE           SEMANTIC_ANALYSIS
                         000305 NRED                        SEMANTIC_ANALYSIS
                         000306 PRED                        SEMANTIC_ANALYSIS
                         000310 PTOKEN_REQD                 SEMANTIC_ANALYSIS
                         000312 PTOKEN_REQD_VALUE           SEMANTIC_ANALYSIS
                         000314 STOKEN_FCN                  SEMANTIC_ANALYSIS
                         000315 CODE                        SEMANTIC_ANALYSIS
                         000316 I                           SEMANTIC_ANALYSIS
                         000317 NUMBER                      SEMANTIC_ANALYSIS
                         000320 DIRECTION                   SEMANTIC_ANALYSIS
                         000352 i                           LEX
                         000364 Pstmt                       ERROR
                         000366 Perring_token               ERROR
                         000376 Ssearching                  NEXT_STMT

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            unpk_to_pk          cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return              alloc_auto_adj      mpfx2               enable              shorten_stack
ext_entry           int_entry           set_cs_eis          index_cs_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cmcs_fillin_hdr_              com_err_                      cu_$arg_ptr                   cv_dec_check_
expand_pathname_              get_wdir_                     hcs_$delentry_seg             hcs_$initiate_count
hcs_$terminate_noname         ioa_                          lex_error_                    lex_string_$init_lex_delims
lex_string_$lex               translator_temp_$get_segment  translator_temp_$release_all_segments
tssi_$clean_up_segment        tssi_$finish_segment          tssi_$get_segment

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_name         error_table_$badopt           error_table_$entlong
error_table_$translation_failed




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    470 000445    8    3 000446    8  168 000477        36 000503       132 000512       134 000531       137 000533
    138 000557       142 000560       144 000610       147 000612       148 000644       152 000645       154 000664
    157 000705       161 000722       162 000754       166 000755       167 000757       168 000760       169 000761
    171 000762       173 001004       175 001047       178 001053       181 001106       185 001107       187 001117
    189 001121       190 001145       194 001146       197 001151       198 001154       202 001155       204 001172
    206 001177       208 001211       210 001241       213 001243       214 001276       218 001277       220 001302
    222 001320       224 001322       225 001346       229 001347       232 001352       233 001374       235 001402
    237 001463       241 001466       243 001506       247 001512       248 001536       252 001537       255 001653
    258 001655       259 001676       263 001677       265 001701       267 001702       270 001705       271 001726
    273 001737       276 001740       278 001752       280 001772       285 002034       287 002040       362 002041
    364 002050       365 002053       291 002054       294 002062       297 002077       300 002115       303 002133
    306 002147       326 002150       328 002152       330 002204       332 002220       334 002226       336 002243
    338 002246       342 002252       344 002253       345 002270       350 002271       352 002272       353 002300
    354 002302       356 002310    4   30 002311       376 002312    6   50 002314    6   52 002317    6   53 002320
 6   55 002321    6   58 002322    6   60 002325    6   62 002327    6   63 002352    6   64 002355    6   65 002361
 6   68 002371    6   70 002372    6   71 002376    6   73 002400    6   79 002417    6   84 002430    6   86 002431
 6   88 002435    6   90 002436    6   92 002437    6   99 002473    6  101 002474    6  104 002477    6  106 002502
 6  107 002526    6  108 002530    6  109 002533    6  111 002534    6  113 002535    6  116 002551    6  118 002552
 6  120 002556    6  123 002557    6  124 002560    6  126 002564    6  127 002571    6  128 002575    6  130 002603
    429 002604       431 002606       432 002610       434 002611       435 002614       438 002615       439 002620
    441 002623       442 002625       445 002627       447 002630       448 002634       449 002636       451 002637
    453 002640       455 002641       457 002645       458 002646       459 002650       461 002651       463 002655
 7   31 002656    7   36 002660    7   37 002662    7   38 002667    7   39 002671    7   40 002703    7   41 002705
 7   42 002707    7   44 002717    7   45 002720    7   47 002733    7   48 002735    7   49 002740    7   51 002742
 8  139 002743    8  153 002745    8  154 002755    8  156 002764    8  158 002773    8  160 002774    8  161 002776
 8  164 003011    8  166 003015    8  168 003017    8  172 003123    8  177 003252    9   18 003254    9   24 003255
 9   25 003257    9   26 003262    9   27 003264    9   28 003272    9   29 003274    9   30 003301    9   31 003302
 9   32 003303    9   35 003314    9   36 003320    9   39 003321


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
