	COMPILATION LISTING OF SEGMENT apl_dim_util_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 11/29/83  1601.1 mst Tue
	    Options: optimize map

        1 /* ******************************************************
        2*   *                                                    *
        3*   *                                                    *
        4*   * Copyright (c) 1972 by Massachusetts Institute of   *
        5*   * Technology and Honeywell Information Systems, Inc. *
        6*   *                                                    *
        7*   *                                                    *
        8*   ****************************************************** */
        9 
       10 /* Utility Module of the APL Device Interface Module.
       11*   Paul Green, July 1973
       12*   Modified 740511 by PG to properly handle default line & page lengths.
       13*   Modified 740530 by PG to add tabsin mode.
       14*   Modified 741104 by PG to fix detach/reattach handling.
       15*   Modified 750722 by PG to get baud rate properly under MCS.
       16*   Modified 770406 by PG to have set_tab_width control tab mode, too.
       17*   Modified 771003 by PG to have initialize_sdb clear status in all cases.
       18*   Modified 790613 by PG to fix 402 (TTYDIM changes broke quit-editing).
       19*   Modified 790910 by PG to record 1200 baud info, and to complete switch to iox_.
       20*   Modified 800128 by Warren Johnson to allow graphic mode.
       21*   Modified 800130 by PG to use 1200 baud delay values if actual baud > 1200,
       22*	and to call apl_dim_select_table_.
       23*   Modified 800226 by PG to implement ^ll mode.
       24**/
       25 
       26 /* format: style3 */
       27 apl_dim_attach:
       28      procedure (stream, my_name, att_stream, modes, bv_status, sdb_ptr);
       29 
       30 /* parameters */
       31 
       32 dcl	(
       33 	bv_status		bit (72) aligned,		/* status returned by call */
       34 	stream		char (*),			/* stream name */
       35 	my_name		char (*),			/* this dim's name */
       36 	att_stream	char (*),			/* stream to which it is attached */
       37 	modes		char (*)
       38 	)		parameter;		/* i/o mode */
       39 
       40 /* entries */
       41 
       42 dcl	apl_dim_select_table_
       43 			entry (char (*), ptr, bit (1) aligned),
       44 	convert_binary_integer_$decimal_string
       45 			entry (fixed bin) returns (char (12) varying),
       46 	get_system_free_area_
       47 			entry () returns (ptr),
       48 	iox_$control	entry (ptr, char (*), ptr, fixed bin (35)),
       49 	iox_$find_iocb	entry (char (*), ptr, fixed bin (35)),
       50 	iox_$get_chars	entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35)),
       51 	iox_$modes	entry (ptr, char (*), char (*), fixed bin (35)),
       52 	iox_$put_chars	entry (ptr, ptr, fixed bin (21), fixed bin (35));
       53 
       54 /* external static */
       55 
       56 dcl	(
       57 	error_table_$ionmat,
       58 	error_table_$action_not_performed,
       59 	error_table_$bad_mode,
       60 	error_table_$no_room_for_sdb
       61 	)		external fixed bin (35) aligned static;
       62 
       63 /* builtin */
       64 
       65 dcl	(addr, addrel, binary, length, null, pointer, substr, unspec)
       66 			builtin;
       67 
       68 /* automatic */
       69 
       70 dcl	i		fixed bin,
       71 	quit_read_n_transmitted
       72 			fixed bin (21),
       73 	char_1		char (1) aligned,
       74 	bit_char		bit (9) aligned,
       75 	system_area_ptr	ptr,
       76 	quit_pending	bit (1) aligned;
       77 
       78 /* internal static */
       79 
       80 dcl	working_table_ptr	ptr internal static initial (null);
       81 
       82 /* internal static "constants" */
       83 
       84 dcl	new_line		char (1) internal static options (constant) initial ("
       85 ");
       86 
       87 /* based */
       88 
       89 dcl	system_area	area (65536) based (system_area_ptr);
       90 
       91 /* conditions */
       92 
       93 dcl	(apl_quit_, area, bad_area_format, quit)
       94 			condition;
       95 
       96 /* include files */
       97 
  1     1 /* ====== BEGIN INCLUDE SEGMENT	apl_dim_sdb.incl.pl1 ====================================== */
  1     2 
  1     3 /* format: style3,initlm0,idind30 */
  1     4 dcl	sdb_ptr			ptr;
  1     5 
  1     6 dcl	1 stream_data_block		aligned based (sdb_ptr),
  1     7 	  2 outer_module_name	char (32) init (my_name),
  1     8 						/* standard I/O System SDB header */
  1     9 	  2 device_name_list_ptr	ptr init (addr (stream_data_block.device_name)),
  1    10 	  2 device_name		aligned,
  1    11 	    3 next_ptr		ptr init (null ()),
  1    12 	    3 name_size		fixed bin init (length (att_stream)),
  1    13 	    3 name		char (32) init (att_stream),
  1    14 	  2 device_iocb_ptr		ptr,		/* ptr to IOCB for sdb.name */
  1    15 	  2 iocb_ptr		ptr,		/* ptr to IOCB for this attachment */
  1    16 						/* info about conversion tables */
  1    17 	  2 sequence_table_ptr	ptr,		/* points to escape sequences in use */
  1    18 	  2 device_info_ptr		ptr init (null ()), /* pointer to dev-info table */
  1    19 	  2 conv_tab_ptr		ptr init (null ()), /* pointer to conversion tables */
  1    20 	  2 compression_in_ptr	ptr initial (null ()),
  1    21 						/* pointer to compression input table */
  1    22 	  2 compression_out_ptr	ptr initial (null ()),
  1    23 						/* pointer to compression output table */
  1    24 						/* parameters of the device */
  1    25 	  2 keying_time		fixed bin (71) init (0),
  1    26 						/* keying time of device */
  1    27 	  2 max_col		fixed bin init (-1),/* number of columns per line */
  1    28 	  2 max_line		fixed bin init (-1),/* number of lines per frame */
  1    29 	  2 actcol		fixed bin init (0), /* present column */
  1    30 	  2 actline		fixed bin init (0), /* present line */
  1    31 	  2 actshift		unal bit (2) init ("11"b),
  1    32 						/* present shift */
  1    33 						/* modes of the device */
  1    34 	  2 tabm			unal bit (1) init ("1"b),
  1    35 						/* tabs may be used */
  1    36 	  2 conm			unal bit (1) init ("1"b),
  1    37 						/* canonicalization should be performed */
  1    38 	  2 graphic		unal bit (1) init ("0"b),
  1    39 						/* graphic mode */
  1    40 	  2 escm			unal bit (1) init ("1"b),
  1    41 						/* processing escapes on input */
  1    42 	  2 erklm			unal bit (1) init ("1"b),
  1    43 						/* erase/kill on */
  1    44 	  2 rawim			unal bit (1) init ("0"b),
  1    45 						/* raw input mode */
  1    46 	  2 red_mode		unal bit (1) init ("1"b),
  1    47 						/* red/black shifts may be transmitted */
  1    48 	  2 escape_out_seen		unal bit (1) init ("0"b),
  1    49 						/* user typed overstruck O-U-T */
  1    50 	  2 tabsin_mode		unal bit (1) init ("0"b),
  1    51 						/* ON means let tabs thru, OFF means change to spaces */
  1    52 	  2 hndlquit_mode		unal bit (1) init ("1"b),
  1    53 						/* ON means dim does reset(read write), OFF it doesn't */
  1    54 	  2 padding		unal bit (24),
  1    55 	  2 read_back		fixed bin init (0), /* input processing mode */
  1    56 						/* info about read/write buffers */
  1    57 	  2 canonicalization_index	fixed bin init (1), /* offset in canonicalization_buffer of next "free" char */
  1    58 	  2 read_offset		fixed bin init (-1),/* offset in canonicalization_buffer of first character */
  1    59 	  2 character_error_index	fixed bin init (-1),/* index of last good character */
  1    60 	  2 error_mark_column	fixed bin init (0), /* column error marker goes in */
  1    61 	  2 inimax		fixed bin init (0), /* index of last char (0-origin) + 1 */
  1    62 	  2 tab_width		fixed bin init (10),/* how wide a tab stop is. */
  1    63 	  2 baud_rate		fixed bin init (0), /* see apl_dim_table.incl.pl1 */
  1    64 	  2 internal_type		unal dim (0:255) bit (9),
  1    65 						/* copied from device_info.code_move */
  1    66 	  2 canonicalization_buffer	char (512),
  1    67 	  2 normal_read_buffer	char (512),
  1    68 	  2 quit_read_buffer	char (512);
  1    69 
  1    70 dcl	1 type			unal dim (0:255) defined (stream_data_block.internal_type (0)),
  1    71 						/* indexed by internal code */
  1    72 	  2 white			bit (1),		/* on if white space char */
  1    73 	  2 red			bit (1),		/* on if red/black shift char */
  1    74 	  2 action		bit (4),		/* 0 none, 1 esc, 2 erase, 3 kill, 4 delim, 5 break */
  1    75 	  2 move			bit (3);		/* 0=+1, 1=0, 2=-1, 3=tab, 4=cr, 5=nl, 6=np, 7=vt */
  1    76 
  1    77 /* constants for stream_data_block.read_back field. */
  1    78 
  1    79 declare	read_back_names		char (16) dimension (0:2) internal static options (constant)
  1    80 				initial ("read_back_spaces", "read_back_input", "read_back_output");
  1    81 
  1    82 dcl	(
  1    83 	read_back_spaces		init (0),		/* just keep track of column input starts in */
  1    84 	read_back_input		init (1),		/* just read what user typed */
  1    85 	read_back_output		init (2)		/* remember output & recanonicalize entire line */
  1    86 	)			fixed bin internal static options (constant);
  1    87 
  1    88 dcl	status			bit (72);
  1    89 
  1    90 dcl	1 status_bits		based (addr (status)),
  1    91 	  2 status_code		fixed bin (35),
  1    92 	  (
  1    93 	  2 logical_initiation	bit (1),
  1    94 	  2 logical_completion	bit (1),
  1    95 	  2 physical_initiation	bit (1),
  1    96 	  2 physical_completion	bit (1),
  1    97 	  2 transaction_terminated	bit (1),
  1    98 	  2 unused_42_45		bit (4),
  1    99 	  2 end_of_logical_data	bit (1),
  1   100 	  2 end_of_physical_data	bit (1),
  1   101 	  2 unused_48_51		bit (4),
  1   102 	  2 stream_detached		bit (1),
  1   103 	  2 unused_53		bit (1),
  1   104 	  2 transaction_aborted	bit (1),
  1   105 	  2 transaction_index	bit (18)
  1   106 	  )			unaligned;
  1   107 
  1   108 /* ------ END INCLUDE SEGMENT		apl_dim_sdb.incl.pl1 -------------------------------------- */
       98 
  2     1 /* ====== BEGIN INCLUDE SEGMENT	apl_dim_table.incl.pl1 ==================================== */
  2     2 
  2     3 dcl	 (conversion_ptr, device_ptr, sequence_ptr) ptr,
  2     4 	n fixed bin;
  2     5 
  2     6 dcl (	baud_rate_110		init (0),
  2     7 	baud_rate_150_or_134	init (1),
  2     8 	baud_rate_300		init (2),
  2     9 	baud_rate_1200		init (3)
  2    10 	) fixed bin internal static options (constant);
  2    11 
  2    12 
  2    13 dcl     1 device_info		based (device_ptr) aligned,
  2    14 	2 conversion_offset		unal bit (18),
  2    15 	2 sequence_offset		unal bit (18),
  2    16 	2 compression_in_offset	unal bit (18),
  2    17 	2 compression_out_offset	unal bit (18),
  2    18 	2 device_name		unal char (32),
  2    19 	2 graphic_terminal		unal bit (1),
  2    20 	2 shift_needed		unal bit (1),
  2    21 	2 quit_editing_allowed	unal bit (1),
  2    22 	2 unused_bits_1		unal bit (15),
  2    23 	2 linefeed_character_device	unal bit (9),
  2    24 	2 escape_character_code	unal bit (9),	/* internal 8-bit code */
  2    25 	2 delay_character		unal bit (9),
  2    26 	2 upper_case		unal bit (9),
  2    27 	2 lower_case		unal bit (9),
  2    28 	2 escape_character_device	unal bit (9),	/* external 7-bit device */
  2    29 	2 default_page_length	unal fixed bin (17),
  2    30 	2 default_line_length	unal fixed bin (17),
  2    31 	2 pad_info		dim (0:3) aligned,	/* 110, 150, 300, 1200 */
  2    32 	  3 nl_addend		unal fixed bin (17),
  2    33 	  3 nl_multiplier		unal fixed bin (17),
  2    34 	  3 tab_addend		unal fixed bin (17),
  2    35 	  3 tab_multiplier		unal fixed bin (17),
  2    36 	  3 bs_n_pads		unal fixed bin (17),	/* number of pads after bs. */
  2    37 	  3 np_n_pads		unal fixed bin (17),	/* number of pads after new page. */
  2    38 	2 editing_prompt		varying char (8);
  2    39 
  2    40 dcl	1 conversions	based (conversion_ptr) aligned,
  2    41 	2 out		unal dim (0:255) bit (9),	/* internal 8-bit code to external 7-bit device */
  2    42 	2 in		unal dim (0:127) bit (9),	/* external 7-bit device to internal 8-bit code */
  2    43 	2 code_move	unal dim (0:255) bit (9),	/* internal movement of code */
  2    44 	2 device_move	unal dim (0:127) bit (6),	/* external movement of device */
  2    45 	2 unused_1	unal bit (24),
  2    46 	2 size		fixed bin,
  2    47 	2 escape		dim (0:n refer (conversions.size)),
  2    48 	  3 prefix	unal bit (1),
  2    49 	  3 conceal	unal bit (1),
  2    50 	  3 unused_2	unal bit (7),
  2    51 	  3 inchar	unal bit (9),
  2    52 	  3 outchar	unal bit (9),
  2    53 	  3 unused_3	unal bit (9);
  2    54 
  2    55 dcl	1 sequence	based (sequence_ptr) aligned,
  2    56 	2 size		unal fixed bin (8),
  2    57 	2 characters	unal dim (sequence.size) bit (9);
  2    58 
  2    59 dcl	1 compression_in	based (compression_in_ptr) aligned,
  2    60 	2 size		fixed bin,
  2    61 	2 compression_string char (compression_in.size);
  2    62 
  2    63 dcl	1 compression_out	based (compression_out_ptr) aligned,
  2    64 	2 size		fixed bin,
  2    65 	2 output_character	dim (compression_out.size) unal bit (9);
  2    66 
  2    67 /* ------ END INCLUDE SEGMENT		apl_dim_table.incl.pl1 ------------------------------------ */
       99 
      100 
      101 /* program */
      102 
      103 	bv_status, status = ""b;
      104 	if sdb_ptr ^= null				/* multiple attachment */
      105 	then do;
      106 		status_code = error_table_$ionmat;
      107 		stream_detached = "1"b;
      108 		bv_status = status;
      109 		return;
      110 	     end;
      111 
      112 	on area, bad_area_format go to cant_do_it;
      113 
      114 	system_area_ptr = get_system_free_area_ ();
      115 
      116 	allocate stream_data_block in (system_area) set (sdb_ptr);
      117 
      118 	call iox_$find_iocb (stream, stream_data_block.iocb_ptr, status_code);
      119 	call iox_$find_iocb ((stream_data_block.name), stream_data_block.device_iocb_ptr, status_code);
      120 	call initialize_sdb (working_table_ptr);
      121 	go to chmodes;				/* set the modes */
      122 
      123 cant_do_it:
      124 	status_code = error_table_$no_room_for_sdb;
      125 	stream_detached = "1"b;
      126 	bv_status = status;
      127 	return;
      128 
      129 apl_dim_order:
      130      entry (sdb_ptr, request, arg_ptr, bv_status);	/* order requests are interpreted or passed on */
      131 
      132 dcl	request		char (*),			/* request */
      133 	arg_ptr		ptr,			/* ptr to table or to maximum length values */
      134 	fbin_arg		based (arg_ptr) fixed bin (35);
      135 						/* fixed point args to line_ */
      136 						/* and page_length calls */
      137 
      138 dcl	keying_time_param	fixed bin (71) based (arg_ptr),
      139 	device_type_param	char (32) based (arg_ptr);
      140 
      141 declare	1 read_status_structure
      142 			aligned,
      143 	  2 event_channel	fixed bin (71),
      144 	  2 input_available bit (1);
      145 
      146 	bv_status, status = ""b;
      147 
      148 	device_ptr = stream_data_block.device_info_ptr;
      149 	conversion_ptr = stream_data_block.conv_tab_ptr;
      150 
      151 	if request = "process_quit"			/* handle APL QUIT editing feature */
      152 	then do;
      153 
      154 /* To make this code immune to quits (in case the user manages to sneak in two
      155*   quits in a big hurry), we'll set up a handler which just sets a flag.
      156*   If the flag is on, we'll assume he didn't type anything first, and cause
      157*   an APL interrupt when things have settled down. */
      158 
      159 		quit_pending = "0"b;
      160 
      161 		on quit quit_pending = "1"b;
      162 
      163 		call iox_$control (stream_data_block.device_iocb_ptr, "read_status", addr (read_status_structure),
      164 		     status_code);
      165 		if status_code ^= 0
      166 		then quit_read_n_transmitted = 0;
      167 		else if ^input_available		/* No input waiting */
      168 		then quit_read_n_transmitted = 0;
      169 		else do;
      170 			call iox_$get_chars (stream_data_block.device_iocb_ptr, addr (quit_read_buffer),
      171 			     length (quit_read_buffer), quit_read_n_transmitted, status_code);
      172 		     end;
      173 
      174 /* do a reset-read just in case the line break (QUIT) looked like a character
      175*   with bad parity. */
      176 
      177 		call iox_$control (stream_data_block.device_iocb_ptr, "resetread", null, status_code);
      178 
      179 /* If the user didn't type anything, or this console doesn't
      180*   have LINE FEED, we treat the QUIT as an APL interrupt.
      181*   Note that APL/360 allows a user to type 0 characters
      182*   and still edit. What a crock! */
      183 
      184 		if quit_read_n_transmitted = 0 | ^quit_editing_allowed
      185 		then do;
      186 			call interrupt_action;
      187 			return;
      188 		     end;
      189 
      190 /* check for unmodified 2741-type terminals. */
      191 
      192 		if quit_read_n_transmitted = 1
      193 		then do;
      194 			char_1 = substr (quit_read_buffer, 1, 1);
      195 			bit_char = unspec (char_1);
      196 			if device_move (binary (bit_char, 9)) = "11"b3
      197 						/* 9 == Quit char (EOT) */
      198 			then do;
      199 				call interrupt_action;
      200 				return;
      201 			     end;
      202 		     end;
      203 
      204 /* we now know that this is an "editing quit" */
      205 
      206 		call iox_$put_chars (stream_data_block.device_iocb_ptr, addrel (addr (editing_prompt), 1),
      207 		     length (editing_prompt), status_code);
      208 
      209 		call iox_$control (stream_data_block.device_iocb_ptr, "start", null, status_code);
      210 
      211 		unspec (char_1) = linefeed_character_device;
      212 
      213 		if canonicalization_index <= 0	/* AAARRRGGGHHH!!!!!! */
      214 		then canonicalization_index = 1;
      215 
      216 		substr (canonicalization_buffer, canonicalization_index, quit_read_n_transmitted + 1) =
      217 		     substr (quit_read_buffer, 1, quit_read_n_transmitted) || char_1;
      218 						/* Mark Quit with LineFeed */
      219 		canonicalization_index = canonicalization_index + quit_read_n_transmitted + 1;
      220 
      221 		if quit_pending
      222 		then call interrupt_action;
      223 
      224 		return;
      225 
      226 /* Internal procedure which performs action upon
      227*   receiving an APL interrupt signal */
      228 
      229 interrupt_action:
      230      procedure;
      231 
      232 	call resetwrite ();
      233 
      234 	if hndlquit_mode
      235 	then do;
      236 		read_offset = -1;			/* finish resetread on apl_input_ */
      237 		canonicalization_index = 1;		/* .. (user_tty_ already reset) */
      238 		call iox_$put_chars (stream_data_block.iocb_ptr, addr (new_line), length (new_line), status_code);
      239 	     end;
      240 
      241 	call iox_$control (stream_data_block.device_iocb_ptr, "start", null, status_code);
      242 	signal apl_quit_;
      243 	return;
      244 
      245      end interrupt_action;
      246 
      247 	     end;
      248 
      249 	else if request = "set_table"			/* set translation table pointer */
      250 	then call initialize_sdb (arg_ptr);
      251 	else if request = "line_length"		/* set maximum line length */
      252 	then do;
      253 		if fbin_arg >= 3
      254 		then max_col = fbin_arg;		/* copy argument into sdb */
      255 	     end;
      256 	else if request = "page_length"		/* set maximum page length */
      257 	then do;
      258 		if fbin_arg >= 2
      259 		then max_line = fbin_arg;
      260 	     end;
      261 	else if request = "table_ptr"			/* pointer to translation table currently in use */
      262 	then do;
      263 		arg_ptr = device_info_ptr;
      264 	     end;
      265 	else if request = "get_keying_time"
      266 	then keying_time_param = stream_data_block.keying_time;
      267 
      268 	else if request = "get_device_type"
      269 	then device_type_param = device_info.device_name;
      270 
      271 	else if request = "read_back_output"
      272 	then do;
      273 		if arg_ptr ^= null
      274 		then device_type_param = read_back_names (stream_data_block.read_back);
      275 
      276 		stream_data_block.read_back = read_back_output;
      277 	     end;
      278 
      279 	else if request = "read_back_spaces"
      280 	then do;
      281 		if arg_ptr ^= null
      282 		then device_type_param = read_back_names (stream_data_block.read_back);
      283 
      284 		stream_data_block.read_back = read_back_spaces;
      285 	     end;
      286 
      287 	else if request = "read_back_input"
      288 	then do;
      289 		if arg_ptr ^= null
      290 		then device_type_param = read_back_names (stream_data_block.read_back);
      291 
      292 		stream_data_block.read_back = read_back_input;
      293 	     end;
      294 
      295 	else if request = "get_tab_width"
      296 	then do;
      297 		if arg_ptr ^= null
      298 		then fbin_arg = stream_data_block.tab_width;
      299 	     end;
      300 
      301 	else if request = "set_tab_width"
      302 	then do;
      303 		i = stream_data_block.tab_width;
      304 
      305 		if arg_ptr ^= null
      306 		then if fbin_arg >= 0
      307 		     then do;
      308 			     if fbin_arg < 2
      309 			     then stream_data_block.tabm = "0"b;
      310 						/* turn tabs off */
      311 			     else stream_data_block.tabm = "1"b;
      312 						/* turn tabs on */
      313 
      314 			     stream_data_block.tab_width = fbin_arg;
      315 			     fbin_arg = i;
      316 			end;
      317 		     else status_code = error_table_$action_not_performed;
      318 		else stream_data_block.tab_width = 10;
      319 	     end;
      320 
      321 	else call iox_$control (stream_data_block.device_iocb_ptr, request, arg_ptr, status_code);
      322 						/* pass on order call */
      323 
      324 	bv_status = status;
      325 	return;
      326 
      327 initialize_sdb:
      328      procedure (bv_table_ptr);
      329 
      330 /* parameters */
      331 
      332 declare	bv_table_ptr	ptr parameter;
      333 
      334 /* automatic */
      335 
      336 declare	table_ptr		ptr;
      337 
      338 declare	1 terminal_info	aligned,
      339 	  2 version	fixed bin,
      340 	  2 id		char (4) unal,
      341 	  2 term_type	char (32) unal,
      342 	  2 line_type	fixed bin,
      343 	  2 baud_rate	fixed bin,
      344 	  2 reserved	(4) fixed bin;
      345 
      346 /* program */
      347 
      348 	terminal_info.version = 1;
      349 	call iox_$control (stream_data_block.device_iocb_ptr, "terminal_info", addr (terminal_info), status_code);
      350 	if status_code = 0
      351 	then do;
      352 		if terminal_info.baud_rate = 110
      353 		then stream_data_block.baud_rate = baud_rate_110;
      354 		else if (terminal_info.baud_rate = 133) | (terminal_info.baud_rate = 150)
      355 		then stream_data_block.baud_rate = baud_rate_150_or_134;
      356 		else if terminal_info.baud_rate = 300
      357 		then stream_data_block.baud_rate = baud_rate_300;
      358 		else if terminal_info.baud_rate >= 1200
      359 		then stream_data_block.baud_rate = baud_rate_1200;
      360 		else stream_data_block.baud_rate = baud_rate_300;
      361 						/* default */
      362 	     end;
      363 	else do;
      364 		stream_data_block.baud_rate = baud_rate_300;
      365 		terminal_info.term_type = "ASCII";
      366 	     end;
      367 
      368 	status = ""b;
      369 
      370 	if bv_table_ptr = null
      371 	then call apl_dim_select_table_ (terminal_info.term_type, table_ptr, ("0"b));
      372 	else table_ptr = bv_table_ptr;
      373 
      374 	working_table_ptr,				/* save away to detach/reattach will use same table */
      375 	     device_info_ptr, device_ptr = table_ptr;
      376 
      377 	if device_info.shift_needed
      378 	then actshift = "01"b;			/* initially lower case */
      379 	else actshift = "00"b;
      380 
      381 	if max_col = -1				/* meaning it wasn't set by attach or changemode */
      382 	then max_col = device_info.default_line_length;
      383 
      384 	if max_line = -1
      385 	then max_line = device_info.default_page_length;
      386 
      387 	conv_tab_ptr, conversion_ptr = pointer (device_ptr, device_info.conversion_offset);
      388 	sequence_table_ptr, sequence_ptr = pointer (device_ptr, device_info.sequence_offset);
      389 	if device_info.compression_in_offset ^= ""b
      390 	then do;
      391 		compression_in_ptr = pointer (device_ptr, device_info.compression_in_offset);
      392 		compression_out_ptr = pointer (device_ptr, device_info.compression_out_offset);
      393 	     end;
      394 
      395 	stream_data_block.internal_type (*) = conversions.code_move (*);
      396 
      397 	if conv_tab_ptr -> out (9) = "110000010"b
      398 	then tabm = "0"b;
      399 
      400 	return;
      401 
      402      end initialize_sdb;
      403 
      404 apl_dim_detach:
      405      entry (sdb_ptr, att_stream, disposal, bv_status);
      406 
      407 dcl	disposal		char (*);			/* ignored */
      408 
      409 	bv_status, status = ""b;
      410 
      411 	system_area_ptr = get_system_free_area_ ();
      412 
      413 	free stream_data_block in (system_area);
      414 
      415 	sdb_ptr = null ();
      416 
      417 	stream_detached = "1"b;
      418 	bv_status = status;
      419 	return;
      420 
      421 apl_dim_abort:
      422      entry (sdb_ptr, oldstatus, bv_status);		/* this is simply passed on to the attached stream */
      423 
      424 dcl	oldstatus		bit (72);			/* transaction to be deleted */
      425 
      426 	bv_status, status = ""b;
      427 	call iox_$control (stream_data_block.device_iocb_ptr, "abort", null, status_code);
      428 	bv_status = status;
      429 	return;
      430 
      431 apl_dim_resetread:
      432      entry (sdb_ptr, bv_status);
      433 
      434 	bv_status, status = ""b;
      435 
      436 	read_offset = -1;
      437 	canonicalization_index = 1;
      438 	call iox_$control (stream_data_block.device_iocb_ptr, "resetread", null, status_code);
      439 
      440 	bv_status = status;
      441 	return;
      442 
      443 apl_dim_resetwrite:
      444      entry (sdb_ptr, bv_status);
      445 
      446 	bv_status, status = ""b;
      447 	call resetwrite ();
      448 	bv_status = status;
      449 	return;
      450 
      451 resetwrite:
      452      procedure;
      453 
      454 	call iox_$control (stream_data_block.device_iocb_ptr, "resetwrite", null, status_code);
      455 	return;
      456 
      457      end resetwrite;
      458 
      459 apl_dim_changemode:
      460      entry (sdb_ptr, modes, oldmodes, bv_status);
      461 
      462 dcl	oldmodes		char (*);
      463 dcl	mode		char (10) varying,
      464 	onsw		bit (1),
      465 	(stoff, endoff, col_temp, term_code)
      466 			fixed bin,
      467 	oms		char (128) varying;
      468 dcl	cv_dec_check_	entry (char (*), fixed bin) returns (fixed bin);
      469 
      470 	bv_status, status = ""b;
      471 
      472 	if tabm
      473 	then oms = "tabs,";
      474 	else oms = "^tabs,";
      475 
      476 	if tabsin_mode
      477 	then oms = oms || "tabsin,";
      478 	else oms = oms || "^tabsin,";
      479 
      480 	if hndlquit_mode
      481 	then oms = oms || "hndlquit,";
      482 	else oms = oms || "^hndlquit,";
      483 
      484 	if conm
      485 	then oms = oms || "can,";
      486 	else oms = oms || "^can,";
      487 
      488 	if escm
      489 	then oms = oms || "esc,";
      490 	else oms = oms || "^esc,";
      491 
      492 	if rawim
      493 	then oms = oms || "rawi,";
      494 	else oms = oms || "^rawi,";
      495 
      496 	if erklm
      497 	then oms = oms || "erkl,";
      498 	else oms = oms || "^erkl,";
      499 
      500 	if red_mode
      501 	then oms = oms || "red,";
      502 	else oms = oms || "^red,";
      503 
      504 	if graphic
      505 	then oms = oms || "graphic,";
      506 	else oms = oms || "^graphic,";
      507 
      508 	if max_line > 0
      509 	then oms = oms || "pl" || convert_binary_integer_$decimal_string (max_line) || ",";
      510 	else oms = oms || "^pl,";
      511 
      512 	if max_col > 0
      513 	then oms = oms || "ll" || convert_binary_integer_$decimal_string (max_col);
      514 	else oms = oms || "^ll";
      515 	oldmodes = oms;
      516 chmodes:						/* make any changes to the stream data block indicated by modes */
      517 	stoff = 1;
      518 	do endoff = 1 to length (modes);
      519 	     if substr (modes, endoff, 1) = "," | substr (modes, endoff, 1) = "."
      520 	     then go to check_mode;
      521 	     if endoff = length (modes)
      522 	     then do;
      523 		     endoff = endoff + 1;		/* allow setting of last mode if no "." at end of string */
      524 check_mode:
      525 		     mode = substr (modes, stoff, endoff - stoff);
      526 		     stoff = endoff + 1;
      527 		     if substr (mode, 1, 1) = "^"
      528 		     then do;			/* are you setting a mode on or off */
      529 			     mode = substr (mode, 2);
      530 			     onsw = "0"b;
      531 			end;
      532 		     else onsw = "1"b;
      533 		     if mode = "tabs"
      534 		     then tabm = onsw;		/* and set the appropriate bit */
      535 		     else if mode = "hndlquit"
      536 		     then hndlquit_mode = onsw;
      537 		     else if mode = "tabsin"
      538 		     then tabsin_mode = onsw;
      539 		     else if mode = "can"
      540 		     then conm = onsw;
      541 		     else if mode = "esc"
      542 		     then escm = onsw;
      543 		     else if mode = "rawi"
      544 		     then rawim = onsw;
      545 		     else if mode = "erkl"
      546 		     then erklm = onsw;
      547 		     else if mode = "red"
      548 		     then red_mode = onsw;
      549 		     else if mode = "graphic"
      550 		     then graphic = onsw;
      551 		     else if mode = "default"
      552 		     then do;
      553 			     erklm, conm, escm = "1"b;
      554 			     rawim = "0"b;
      555 			end;
      556 		     else if mode = "ll"
      557 		     then if onsw
      558 			then do;
      559 				status_code = error_table_$bad_mode;
      560 				bv_status = status;
      561 				return;
      562 			     end;
      563 			else stream_data_block.max_col = 0;
      564 		     else if substr (mode, 1, 2) = "ll"
      565 		     then do;
      566 			     col_temp = cv_dec_check_ (substr (mode, 3), term_code);
      567 			     if term_code ^= 0 | col_temp < 4
      568 			     then do;
      569 				     status_code = error_table_$bad_mode;
      570 				     bv_status = status;
      571 				     return;
      572 				end;
      573 
      574 			     call iox_$modes (stream_data_block.device_iocb_ptr, (mode), "", 0);
      575 			     max_col = col_temp;
      576 			end;
      577 		     else if mode = "pl"
      578 		     then if onsw
      579 			then do;
      580 				status_code = error_table_$bad_mode;
      581 				bv_status = status;
      582 				return;
      583 			     end;
      584 			else stream_data_block.max_line = 0;
      585 		     else if substr (mode, 1, 2) = "pl"
      586 		     then do;
      587 			     col_temp = cv_dec_check_ (substr (mode, 3), term_code);
      588 			     if term_code ^= 0 | col_temp < 2 | ^onsw
      589 			     then do;
      590 				     status_code = error_table_$bad_mode;
      591 				     bv_status = status;
      592 				     return;
      593 				end;
      594 
      595 			     call iox_$modes (stream_data_block.device_iocb_ptr, (mode), "", 0);
      596 			     max_line = col_temp;
      597 			end;
      598 		     else if mode ^= ""
      599 		     then status_code = error_table_$bad_mode;
      600 		end;
      601 	end;
      602 	bv_status = status;
      603 	return;
      604 
      605      end /* apl_dim_attach */;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/29/83  1346.3  apl_dim_util_.pl1                 >special_ldd>on>apl.1129>apl_dim_util_.pl1
98           1    03/27/82  0429.8  apl_dim_sdb.incl.pl1              >ldd>include>apl_dim_sdb.incl.pl1
99           2    03/27/82  0438.6  apl_dim_table.incl.pl1            >ldd>include>apl_dim_table.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
actcol                   50            based           fixed bin(17,0)          initial level 2 dcl 1-6 set ref 116*
actline                  51            based           fixed bin(17,0)          initial level 2 dcl 1-6 set ref 116*
actshift                 52            based           bit(2)                   initial level 2 packed unaligned dcl 1-6 set ref
                                                                                  116* 377* 379*
addr                                                   builtin function         dcl 65 ref 106 107 116 118 119 123 125 163 163 163
                                                                                  165 170 170 170 177 206 206 206 209 238 238 238
                                                                                  241 317 321 349 349 349 350 417 427 438 454 559
                                                                                  569 580 590 598
addrel                                                 builtin function         dcl 65 ref 206 206
apl_dim_select_table_           000012 constant        entry                    external dcl 42 ref 370
apl_quit_                       000000 stack reference condition                dcl 93 ref 242
area                            000110 stack reference condition                dcl 93 ref 112
arg_ptr                                parameter       pointer                  dcl 132 set ref 129 249* 253 253 258 258 263* 265
                                                                                  268 273 273 281 281 289 289 297 297 305 305 308
                                                                                  314 315 321*
att_stream                             parameter       char                     unaligned dcl 32 ref 27 116 116 404
bad_area_format                 000116 stack reference condition                dcl 93 ref 112
baud_rate                62            based           fixed bin(17,0)          initial level 2 in structure "stream_data_block"
                                                                                  dcl 1-6 in procedure "apl_dim_attach" set ref 116*
                                                                                  352* 354* 356* 358* 360* 364*
baud_rate                13     000262 automatic       fixed bin(17,0)          level 2 in structure "terminal_info" dcl 338
                                                                                  in procedure "initialize_sdb" set ref 352 354 354
                                                                                  356 358
baud_rate_110                          constant        fixed bin(17,0)          initial dcl 2-6 ref 352
baud_rate_1200                         constant        fixed bin(17,0)          initial dcl 2-6 ref 358
baud_rate_150_or_134                   constant        fixed bin(17,0)          initial dcl 2-6 ref 354
baud_rate_300                          constant        fixed bin(17,0)          initial dcl 2-6 ref 356 360 364
binary                                                 builtin function         dcl 65 ref 196
bit_char                        000103 automatic       bit(9)                   dcl 70 set ref 195* 196
bv_status                              parameter       bit(72)                  dcl 32 set ref 27 103* 108* 126* 129 146* 324* 404
                                                                                  409* 418* 421 426* 428* 431 434* 440* 443 446*
                                                                                  448* 459 470* 560* 570* 581* 591* 602*
bv_table_ptr                           parameter       pointer                  dcl 332 ref 327 370 372
canonicalization_buffer
                        163            based           char(512)                level 2 dcl 1-6 set ref 216*
canonicalization_index
                         54            based           fixed bin(17,0)          initial level 2 dcl 1-6 set ref 116* 213 213* 216
                                                                                  219* 219 237* 437*
char_1                          000102 automatic       char(1)                  dcl 70 set ref 194* 195 211* 216
character_error_index
                         56            based           fixed bin(17,0)          initial level 2 dcl 1-6 set ref 116*
code_move               140            based           bit(9)                   array level 2 packed unaligned dcl 2-40 ref 395
col_temp                        000154 automatic       fixed bin(17,0)          dcl 463 set ref 566* 567 575 587* 588 596
compression_in_offset
                          1            based           bit(18)                  level 2 packed unaligned dcl 2-13 ref 389 391
compression_in_ptr       40            based           pointer                  initial level 2 dcl 1-6 set ref 116* 391*
compression_out_offset
                          1(18)        based           bit(18)                  level 2 packed unaligned dcl 2-13 ref 392
compression_out_ptr      42            based           pointer                  initial level 2 dcl 1-6 set ref 116* 392*
conm                     52(03)        based           bit(1)                   initial level 2 packed unaligned dcl 1-6 set ref
                                                                                  116* 484 539* 553*
conv_tab_ptr             36            based           pointer                  initial level 2 dcl 1-6 set ref 116* 149 387* 397
conversion_offset                      based           bit(18)                  level 2 packed unaligned dcl 2-13 ref 387
conversion_ptr                  000134 automatic       pointer                  dcl 2-3 set ref 149* 196 387* 395
conversions                            based           structure                level 1 dcl 2-40
convert_binary_integer_$decimal_string
                                000014 constant        entry                    external dcl 42 ref 508 512
cv_dec_check_                   000042 constant        entry                    external dcl 468 ref 566 587
default_line_length      14(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-13 ref 381
default_page_length      14            based           fixed bin(17,0)          level 2 packed unaligned dcl 2-13 ref 384
device_info                            based           structure                level 1 dcl 2-13
device_info_ptr          34            based           pointer                  initial level 2 dcl 1-6 set ref 116* 148 263 374*
device_iocb_ptr          26            based           pointer                  level 2 dcl 1-6 set ref 119* 163* 170* 177* 206*
                                                                                  209* 241* 321* 349* 427* 438* 454* 574* 595*
device_move             240            based           bit(6)                   array level 2 packed unaligned dcl 2-40 ref 196
device_name              12            based           structure                level 2 in structure "stream_data_block" dcl 1-6
                                                                                  in procedure "apl_dim_attach" set ref 116
device_name               2            based           char(32)                 level 2 in structure "device_info" packed unaligned
                                                                                  dcl 2-13 in procedure "apl_dim_attach" ref 268
device_name_list_ptr     10            based           pointer                  initial level 2 dcl 1-6 set ref 116*
device_ptr                      000136 automatic       pointer                  dcl 2-3 set ref 148* 184 206 206 206 206 211 268
                                                                                  374* 377 381 384 387 387 388 388 389 391 391 392
                                                                                  392
device_type_param                      based           char(32)                 unaligned dcl 138 set ref 268* 273* 281* 289*
disposal                               parameter       char                     unaligned dcl 407 ref 404
editing_prompt           31            based           varying char(8)          level 2 dcl 2-13 set ref 206 206 206 206
endoff                          000153 automatic       fixed bin(17,0)          dcl 463 set ref 518* 519 519 521 523* 523 524 526*
erklm                    52(06)        based           bit(1)                   initial level 2 packed unaligned dcl 1-6 set ref
                                                                                  116* 496 545* 553*
error_mark_column        57            based           fixed bin(17,0)          initial level 2 dcl 1-6 set ref 116*
error_table_$action_not_performed
                                000034 external static fixed bin(35,0)          dcl 56 ref 317
error_table_$bad_mode           000036 external static fixed bin(35,0)          dcl 56 ref 559 569 580 590 598
error_table_$ionmat             000032 external static fixed bin(35,0)          dcl 56 ref 106
error_table_$no_room_for_sdb    000040 external static fixed bin(35,0)          dcl 56 ref 123
escape_out_seen          52(09)        based           bit(1)                   initial level 2 packed unaligned dcl 1-6 set ref
                                                                                  116*
escm                     52(05)        based           bit(1)                   initial level 2 packed unaligned dcl 1-6 set ref
                                                                                  116* 488 541* 553*
fbin_arg                               based           fixed bin(35,0)          dcl 132 set ref 253 253 258 258 297* 305 308 314
                                                                                  315*
get_system_free_area_           000016 constant        entry                    external dcl 42 ref 114 411
graphic                  52(04)        based           bit(1)                   initial level 2 packed unaligned dcl 1-6 set ref
                                                                                  116* 504 549*
hndlquit_mode            52(11)        based           bit(1)                   initial level 2 packed unaligned dcl 1-6 set ref
                                                                                  116* 234 480 535*
i                               000100 automatic       fixed bin(17,0)          dcl 70 set ref 303* 315
inimax                   60            based           fixed bin(17,0)          initial level 2 dcl 1-6 set ref 116*
input_available           2     000142 automatic       bit(1)                   level 2 dcl 141 set ref 167
internal_type            63            based           bit(9)                   array level 2 packed unaligned dcl 1-6 set ref 395*
iocb_ptr                 30            based           pointer                  level 2 dcl 1-6 set ref 118* 238*
iox_$control                    000020 constant        entry                    external dcl 42 ref 163 177 209 241 321 349 427 438
                                                                                  454
iox_$find_iocb                  000022 constant        entry                    external dcl 42 ref 118 119
iox_$get_chars                  000024 constant        entry                    external dcl 42 ref 170
iox_$modes                      000026 constant        entry                    external dcl 42 ref 574 595
iox_$put_chars                  000030 constant        entry                    external dcl 42 ref 206 238
keying_time              44            based           fixed bin(71,0)          initial level 2 dcl 1-6 set ref 116* 265
keying_time_param                      based           fixed bin(71,0)          dcl 138 set ref 265*
length                                                 builtin function         dcl 65 ref 116 170 170 206 206 238 238 518 521
linefeed_character_device
                         12(18)        based           bit(9)                   level 2 packed unaligned dcl 2-13 ref 211
max_col                  46            based           fixed bin(17,0)          initial level 2 dcl 1-6 set ref 116* 253* 381 381*
                                                                                  512 512* 563* 575*
max_line                 47            based           fixed bin(17,0)          initial level 2 dcl 1-6 set ref 116* 258* 384 384*
                                                                                  508 508* 584* 596*
mode                            000145 automatic       varying char(10)         dcl 463 set ref 524* 527 529* 529 533 535 537 539
                                                                                  541 543 545 547 549 551 556 564 566 566 574 577
                                                                                  585 587 587 595 598
modes                                  parameter       char                     unaligned dcl 32 ref 27 459 518 519 519 521 524
my_name                                parameter       char                     unaligned dcl 32 ref 27 116
name                     15            based           char(32)                 initial level 3 dcl 1-6 set ref 116* 119
name_size                14            based           fixed bin(17,0)          initial level 3 dcl 1-6 set ref 116*
new_line                        000014 constant        char(1)                  initial unaligned dcl 84 set ref 238 238 238 238
next_ptr                 12            based           pointer                  initial level 3 dcl 1-6 set ref 116*
null                                                   builtin function         dcl 65 ref 104 116 116 116 116 116 177 177 209 209
                                                                                  241 241 273 281 289 297 305 370 415 427 427 438
                                                                                  438 454 454
oldmodes                               parameter       char                     unaligned dcl 462 set ref 459 515*
oldstatus                              parameter       bit(72)                  unaligned dcl 424 ref 421
oms                             000156 automatic       varying char(128)        dcl 463 set ref 472* 474* 476* 476 478* 478 480* 480
                                                                                  482* 482 484* 484 486* 486 488* 488 490* 490 492*
                                                                                  492 494* 494 496* 496 498* 498 500* 500 502* 502
                                                                                  504* 504 506* 506 508* 508 510* 510 512* 512 514*
                                                                                  514 515
onsw                            000151 automatic       bit(1)                   unaligned dcl 463 set ref 530* 532* 533 535 537 539
                                                                                  541 543 545 547 549 556 577 588
out                                    based           bit(9)                   array level 2 packed unaligned dcl 2-40 ref 397
outer_module_name                      based           char(32)                 initial level 2 dcl 1-6 set ref 116*
pointer                                                builtin function         dcl 65 ref 387 388 391 392
quit                            000124 stack reference condition                dcl 93 ref 161
quit_editing_allowed     12(02)        based           bit(1)                   level 2 packed unaligned dcl 2-13 ref 184
quit_pending                    000106 automatic       bit(1)                   dcl 70 set ref 159* 161* 221
quit_read_buffer        563            based           char(512)                level 2 dcl 1-6 set ref 170 170 170 170 194 216
quit_read_n_transmitted         000101 automatic       fixed bin(21,0)          dcl 70 set ref 165* 167* 170* 184 192 216 216 219
rawim                    52(07)        based           bit(1)                   initial level 2 packed unaligned dcl 1-6 set ref
                                                                                  116* 492 543* 554*
read_back                53            based           fixed bin(17,0)          initial level 2 dcl 1-6 set ref 116* 273 276* 281
                                                                                  284* 289 292*
read_back_input                        constant        fixed bin(17,0)          initial dcl 1-82 ref 292
read_back_names                 000000 constant        char(16)                 initial array unaligned dcl 1-79 ref 273 281 289
read_back_output                       constant        fixed bin(17,0)          initial dcl 1-82 ref 276
read_back_spaces                       constant        fixed bin(17,0)          initial dcl 1-82 ref 284
read_offset              55            based           fixed bin(17,0)          initial level 2 dcl 1-6 set ref 116* 236* 436*
read_status_structure           000142 automatic       structure                level 1 dcl 141 set ref 163 163
red_mode                 52(08)        based           bit(1)                   initial level 2 packed unaligned dcl 1-6 set ref
                                                                                  116* 500 547*
request                                parameter       char                     unaligned dcl 132 set ref 129 151 249 251 256 261
                                                                                  265 268 271 279 287 295 301 321*
sdb_ptr                                parameter       pointer                  dcl 1-4 set ref 27 104 116* 116 118 119 119 129 148
                                                                                  149 163 170 170 170 170 170 177 194 206 209 213
                                                                                  213 216 216 216 219 219 234 236 237 238 241 253
                                                                                  258 263 265 273 276 281 284 289 292 297 303 308
                                                                                  311 314 318 321 349 352 354 356 358 360 364 374
                                                                                  377 379 381 381 384 384 387 388 391 392 395 397
                                                                                  397 404 413 415* 421 427 431 436 437 438 443 454
                                                                                  459 472 476 480 484 488 492 496 500 504 508 508
                                                                                  512 512 533 535 537 539 541 543 545 547 549 553
                                                                                  553 553 554 563 574 575 584 595 596
sequence_offset           0(18)        based           bit(18)                  level 2 packed unaligned dcl 2-13 ref 388
sequence_ptr                    000140 automatic       pointer                  dcl 2-3 set ref 388*
sequence_table_ptr       32            based           pointer                  level 2 dcl 1-6 set ref 388*
shift_needed             12(01)        based           bit(1)                   level 2 packed unaligned dcl 2-13 ref 377
status                          000132 automatic       bit(72)                  unaligned dcl 1-88 set ref 103* 106 107 108 118 119
                                                                                  123 125 126 146* 163 165 170 177 206 209 238 241
                                                                                  317 321 324 349 350 368* 409* 417 418 426* 427 428
                                                                                  434* 438 440 446* 448 454 470* 559 560 569 570 580
                                                                                  581 590 591 598 602
status_bits                            based           structure                level 1 unaligned dcl 1-90
status_code                            based           fixed bin(35,0)          level 2 dcl 1-90 set ref 106* 118* 119* 123* 163*
                                                                                  165 170* 177* 206* 209* 238* 241* 317* 321* 349*
                                                                                  350 427* 438* 454* 559* 569* 580* 590* 598*
stoff                           000152 automatic       fixed bin(17,0)          dcl 463 set ref 516* 524 524 526*
stream                                 parameter       char                     unaligned dcl 32 set ref 27 118*
stream_data_block                      based           structure                level 1 dcl 1-6 set ref 116 413
stream_detached           1(15)        based           bit(1)                   level 2 packed unaligned dcl 1-90 set ref 107* 125*
                                                                                  417*
substr                                                 builtin function         dcl 65 set ref 194 216* 216 519 519 524 527 529 564
                                                                                  566 566 585 587 587
system_area                            based           area(65536)              dcl 89 ref 116 413
system_area_ptr                 000104 automatic       pointer                  dcl 70 set ref 114* 116 411* 413
tab_width                61            based           fixed bin(17,0)          initial level 2 dcl 1-6 set ref 116* 297 303 314*
                                                                                  318*
table_ptr                       000260 automatic       pointer                  dcl 336 set ref 370* 372* 374
tabm                     52(02)        based           bit(1)                   initial level 2 packed unaligned dcl 1-6 set ref
                                                                                  116* 308* 311* 397* 472 533*
tabsin_mode              52(10)        based           bit(1)                   initial level 2 packed unaligned dcl 1-6 set ref
                                                                                  116* 476 537*
term_code                       000155 automatic       fixed bin(17,0)          dcl 463 set ref 566* 567 587* 588
term_type                 2     000262 automatic       char(32)                 level 2 packed unaligned dcl 338 set ref 365* 370*
terminal_info                   000262 automatic       structure                level 1 dcl 338 set ref 349 349
unspec                                                 builtin function         dcl 65 set ref 195 211*
version                         000262 automatic       fixed bin(17,0)          level 2 dcl 338 set ref 348*
working_table_ptr               000010 internal static pointer                  initial dcl 80 set ref 120* 374*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
compression_in                         based           structure                level 1 dcl 2-59
compression_out                        based           structure                level 1 dcl 2-63
n                                      automatic       fixed bin(17,0)          dcl 2-3
sequence                               based           structure                level 1 dcl 2-55
type                                   defined         structure                array level 1 packed unaligned dcl 1-70

NAMES DECLARED BY EXPLICIT CONTEXT.
apl_dim_abort                   001521 constant        entry                    external dcl 421
apl_dim_attach                  000236 constant        entry                    external dcl 27
apl_dim_changemode              001720 constant        entry                    external dcl 459
apl_dim_detach                  001442 constant        entry                    external dcl 404
apl_dim_order                   000554 constant        entry                    external dcl 129
apl_dim_resetread               001603 constant        entry                    external dcl 431
apl_dim_resetwrite              001671 constant        entry                    external dcl 443
cant_do_it                      000535 constant        label                    dcl 123 ref 112
check_mode                      002515 constant        label                    dcl 524 ref 519
chmodes                         002460 constant        label                    dcl 516 ref 121
initialize_sdb                  003402 constant        entry                    internal dcl 327 ref 120 249
interrupt_action                003310 constant        entry                    internal dcl 229 ref 186 199 221
resetwrite                      003702 constant        entry                    internal dcl 451 ref 232 447

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4242        4306    3753        4252
Length      4564    3753        44         241     266           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
apl_dim_attach                      410 external procedure  is an external procedure.  
on unit on line 112                  64 on unit               
on unit on line 161                  64 on unit               
interrupt_action                        internal procedure  shares stack frame of external procedure apl_dim_attach.  
initialize_sdb                          internal procedure  shares stack frame of external procedure apl_dim_attach.  
resetwrite                              internal procedure  shares stack frame of external procedure apl_dim_attach.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 working_table_ptr           apl_dim_attach

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
apl_dim_attach           000100 i                           apl_dim_attach
                         000101 quit_read_n_transmitted     apl_dim_attach
                         000102 char_1                      apl_dim_attach
                         000103 bit_char                    apl_dim_attach
                         000104 system_area_ptr             apl_dim_attach
                         000106 quit_pending                apl_dim_attach
                         000132 status                      apl_dim_attach
                         000134 conversion_ptr              apl_dim_attach
                         000136 device_ptr                  apl_dim_attach
                         000140 sequence_ptr                apl_dim_attach
                         000142 read_status_structure       apl_dim_attach
                         000145 mode                        apl_dim_attach
                         000151 onsw                        apl_dim_attach
                         000152 stoff                       apl_dim_attach
                         000153 endoff                      apl_dim_attach
                         000154 col_temp                    apl_dim_attach
                         000155 term_code                   apl_dim_attach
                         000156 oms                         apl_dim_attach
                         000260 table_ptr                   initialize_sdb
                         000262 terminal_info               initialize_sdb

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        return              tra_ext
signal              enable              shorten_stack       ext_entry           ext_entry_desc      int_entry
alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
apl_dim_select_table_         convert_binary_integer_$decimal_string                      cv_dec_check_
get_system_free_area_         iox_$control                  iox_$find_iocb                iox_$get_chars
iox_$modes                    iox_$put_chars

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$bad_mode         error_table_$ionmat
error_table_$no_room_for_sdb




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     27 000230       103 000273       104 000277       106 000303       107 000305       108 000307       109 000312
    112 000313       114 000337       116 000346       118 000453       119 000477       120 000525       121 000534
    123 000535       125 000540       126 000542       127 000546       129 000547       146 000574       148 000601
    149 000605       151 000607       159 000616       161 000617       163 000637       165 000674       167 000702
    170 000706       177 000733       184 000767       186 000775       187 000776       192 000777       194 001001
    195 001006       196 001011       199 001020       200 001021       206 001022       209 001050       211 001102
    213 001107       216 001115       219 001136       221 001143       224 001146       249 001147       251 001162
    253 001166       255 001173       256 001174       258 001200       260 001205       261 001206       263 001212
    264 001213       265 001214       268 001224       271 001237       273 001243       276 001257       277 001261
    279 001262       281 001266       284 001302       285 001304       287 001305       289 001311       292 001325
    293 001327       295 001330       297 001334       299 001343       301 001344       303 001350       305 001352
    308 001361       311 001366       314 001370       315 001371       316 001373       317 001374       318 001400
    319 001402       321 001403       324 001430       325 001434       404 001435       409 001466       411 001473
    413 001502       415 001504       417 001506       418 001510       419 001514       421 001515       426 001533
    427 001540       428 001572       429 001576       431 001577       434 001615       436 001622       437 001626
    438 001630       440 001662       441 001666       443 001667       446 001703       447 001710       448 001711
    449 001715       459 001716       470 001744       472 001751       474 001764       476 001771       478 002007
    480 002021       482 002037       484 002051       486 002067       488 002101       490 002117       492 002131
    494 002147       496 002161       498 002177       500 002211       502 002227       504 002241       506 002257
    508 002271       510 002351       512 002364       514 002436       515 002451       516 002460       518 002462
    519 002475       521 002506       523 002514       524 002515       526 002527       527 002532       529 002536
    530 002547       531 002550       532 002551       533 002553       535 002570       537 002605       539 002622
    541 002637       543 002654       545 002671       547 002706       549 002723       551 002740       553 002745
    554 002755       555 002757       556 002760       559 002767       560 002772       561 002776       563 002777
    564 003003       566 003010       567 003041       569 003047       570 003052       571 003056       574 003057
    575 003117       576 003124       577 003125       580 003134       581 003137       582 003143       584 003144
    585 003150       587 003152       588 003203       590 003213       591 003216       592 003222       595 003223
    596 003263       597 003270       598 003271       601 003301       602 003303       603 003307       229 003310
    232 003311       234 003312       236 003317       237 003321       238 003323       241 003344       242 003376
    243 003401       327 003402       348 003404       349 003406       350 003442       352 003444       354 003454
    356 003465       358 003474       360 003503       362 003507       364 003510       365 003514       368 003517
    370 003521       372 003552       374 003555       377 003564       379 003576       381 003602       384 003613
    387 003621       388 003630       389 003641       391 003645       392 003652       395 003661       397 003671
    400 003701       451 003702       454 003703       455 003737


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
