	COMPILATION LISTING OF SEGMENT list_imft_requests
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/14/88  1215.5 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* Displays status of Inter-Multics File Transfer (IMFT) requests */
       10 
       11 /* Created:  April 1982 by G. Palter */
       12 /* Modified: 16 July 1982 by G. Palter to rename "-entry_name" to "-entryname" */
       13 /* Modified: March 1983 by Robert Coren to recognize "-source" and to list all queues by default */
       14 /* Modified: February 23, 1984 by C. Marker to use version 5 message segments */
       15 
       16 
       17 /****^  HISTORY COMMENTS:
       18*  1) change(88-07-02,Beattie), approve(88-08-01,MCR7948),
       19*     audit(88-10-11,Farley), install(88-10-14,MR12.2-1165):
       20*     Display new options: -delete, -extend and -update.
       21*                                                   END HISTORY COMMENTS */
       22 
       23 
       24 /* format: style4,delnl,insnl,ifthenstmt,ifthen */
       25 
       26 list_imft_requests:
       27 lir:
       28      procedure () options (variable);
       29 
       30 dcl  system_area area based (system_area_ptr);
       31 dcl  system_area_ptr pointer;
       32 
       33 dcl  1 local_sb aligned like status_branch;
       34 dcl  1 local_mmi aligned like mseg_message_info;
       35 
       36 dcl  1 message_ids (total_message_ids) aligned based (message_ids_ptr),
       37        2 id bit (72),
       38        2 position fixed binary,
       39        2 pad bit (36);
       40 dcl  message_ids_ptr pointer;
       41 dcl  total_message_ids fixed binary;
       42 
       43 dcl  argument character (argument_lth) unaligned based (argument_ptr);
       44 dcl  id_qualifier character (id_qualifier_lth) unaligned based (id_qualifier_ptr);
       45 dcl  (the_argument_list, argument_ptr, id_qualifier_ptr) pointer;
       46 dcl  (argument_lth, id_qualifier_lth) fixed binary (21);
       47 dcl  (n_arguments, id_qualifier_idx, argument_idx) fixed binary;
       48 
       49 dcl  1 n_selections aligned,
       50        2 path fixed binary,				/* # of pathname specifiers */
       51        2 entry fixed binary,				/* # of -entry STR specifiers */
       52        2 id fixed binary;				/* # of request ID specifiers */
       53 dcl  process_selections bit (1) aligned;
       54 
       55 dcl  array_bound fixed binary;
       56 
       57 dcl  request_type character (24);
       58 dcl  foreign_system character (24);
       59 dcl  remote bit (1) aligned;
       60 dcl  (queue_indeces, total_requests, selected_requests, first_id_indeces) dimension (4) fixed binary;
       61 dcl  (queue, default_queue, max_queues, queue_idx) fixed binary;
       62 dcl  (generic_type, queue_string) character (32);
       63 dcl  (opened_a_queue, all_queues_empty) bit (1) aligned;
       64 
       65 dcl  (output_mode, path_output_mode, id_output_mode, position_mode, user_selection) fixed binary (2);
       66 
       67 dcl  (user_id, person_id, project_id) character (32);
       68 dcl  (match_any_person, match_any_project) bit (1) aligned;
       69 
       70 dcl  a_dirname character (168);
       71 dcl  an_ename character (32);
       72 
       73 dcl  request_id_nonvarying character (19);
       74 dcl  request_id character (19) varying;
       75 
       76 dcl  access_required bit (36) aligned;
       77 
       78 dcl  message_idx fixed binary;
       79 dcl  first_message_in_queue bit (1) aligned;
       80 
       81 dcl  code fixed binary (35);
       82 
       83 /* format: off */
       84 dcl (DEFAULT	initial (00b),			/* default setting for control argument */
       85      BRIEF	initial (01b),			/* -brief */
       86      LONG		initial (10b),			/* -long */
       87 
       88      NO_POSITION	initial (01b),			/* -no_position */
       89      SHOW_POSITION	initial (10b),			/* -position */
       90 
       91      TOTALS	initial (11b),			/* -totals */
       92 
       93      USER		initial (01b),			/* -own */
       94      SUBSET	initial (10b),			/* -user STR */
       95      ALL		initial (11b),			/* -admin */
       96 
       97      NONE		initial (00b),			/* not a selection control argument */
       98      PATH		initial (01b),			/* pathname selection */
       99      ENTRY	initial (10b),			/* -entry STR */
      100      ID		initial (11b))			/* -id STR */
      101 	fixed binary (2) static options (constant);
      102 
      103 dcl (
      104 /*   A_EXTENDED_ACCESS	initial ("400000000000"b3),*/
      105      O_EXTENDED_ACCESS	initial ("040000000000"b3),
      106      R_EXTENDED_ACCESS	initial ("100000000000"b3),
      107      S_EXTENDED_ACCESS	initial ("020000000000"b3))
      108 	bit (36) aligned static options (constant);
      109 
      110 dcl  STATE_UNKNOWN fixed binary static options (constant) initial (-1);
      111 
      112 dcl  STATE_NAMES (-1:4) character (32) varying static options (constant) initial (
      113 	"unknown",	"unprocessed",	"deferred",	"state changing",
      114 	"eligible",	"running");
      115 /* format: on */
      116 
      117 dcl  CHASE fixed binary (1) static options (constant) initial (1);
      118 
      119 /*
      120*dcl  READ_FIRST_MESSAGE bit (1) aligned static options (constant) initial ("0"b);
      121*dcl  READ_THIS_MESSAGE bit (2) aligned static options (constant) initial ("00"b);
      122**/
      123 dcl  READ_NEXT_MESSAGE bit (2) aligned static options (constant) initial ("01"b);
      124 
      125 dcl  LIST_IMFT_REQUESTS character (32) static options (constant) initial ("list_imft_requests");
      126 
      127 dcl  imft_data_$queue_dirname character (168) external;
      128 
      129 /* format: off */
      130 dcl (error_table_$bad_segment, error_table_$badopt, error_table_$id_not_found, error_table_$inconsistent,
      131      error_table_$moderr, error_table_$no_message, error_table_$no_s_permission, error_table_$noarg)
      132 	fixed binary (35) external;
      133 /* format: on */
      134 
      135 dcl  check_star_name_$entry entry (character (*), fixed binary (35));
      136 dcl  com_err_ entry () options (variable);
      137 dcl  cu_$arg_count entry (fixed binary, fixed binary (35));
      138 dcl  cu_$arg_list_ptr entry () returns (pointer);
      139 dcl  cu_$arg_ptr_rel entry (fixed binary, pointer, fixed binary (21), fixed binary (35), pointer);
      140 dcl  cv_dec_check_ entry (character (*), fixed binary (35)) returns (fixed binary (35));
      141 dcl  date_time_ entry (fixed binary (71), character (*));
      142 dcl  expand_pathname_ entry (character (*), character (*), character (*), fixed binary (35));
      143 dcl  get_group_id_ entry () returns (character (32));
      144 dcl  get_system_free_area_ entry () returns (pointer);
      145 dcl  get_temp_segment_ entry (character (*), pointer, fixed binary (35));
      146 dcl  hcs_$status_long entry (character (*), character (*), fixed binary (1), pointer, pointer, fixed binary (35));
      147 dcl  imft_default_rqt_ entry () returns (char (*));
      148 dcl  ioa_ entry () options (variable);
      149 dcl  iod_info_$generic_type entry (character (*), character (32), fixed binary (35));
      150 dcl  iod_info_$queue_data entry (character (*), fixed binary, fixed binary, fixed binary (35));
      151 dcl  match_request_id_ entry (fixed binary (71), character (*)) returns (bit (1) aligned);
      152 dcl  match_star_name_ entry (character (*), character (*), fixed binary (35));
      153 dcl  message_segment_$close entry (fixed binary, fixed binary (35));
      154 dcl  message_segment_$get_message_count_index entry (fixed binary, fixed binary, fixed binary (35));
      155 dcl  message_segment_$get_mode_index entry (fixed binary, bit (36) aligned, fixed binary (35));
      156 dcl  message_segment_$open entry (character (*), character (*), fixed binary, fixed binary (35));
      157 dcl message_segment_$read_message_index entry (fixed binary, pointer, pointer, fixed binary (35));
      158 dcl  pathname_ entry (character (*), character (*)) returns (character (168));
      159 dcl  release_temp_segment_ entry (character (*), pointer, fixed binary (35));
      160 dcl  request_id_ entry (fixed binary (71)) returns (character (19));
      161 
      162 dcl  cleanup condition;
      163 
      164 dcl  (addr, after, before, convert, index, length, max, null, rtrim, substr, sum, unspec, verify) builtin;
      165 
      166 /**/
      167 
      168 	call cu_$arg_count (n_arguments, code);
      169 	if code ^= 0 then do;
      170 	     call com_err_ (code, LIST_IMFT_REQUESTS);
      171 	     return;
      172 	end;
      173 
      174 	the_argument_list = cu_$arg_list_ptr ();
      175 
      176 
      177 /* Establish defaults */
      178 
      179 	array_bound = max (n_arguments, 1);		/* PL/I abhors a vacuum */
      180 
      181 	n_selections = 0;				/* no path, entry, or ID selections */
      182 
      183 	request_type = imft_default_rqt_ ();		/* returns real name of default request type */
      184 	queue = -1;				/* list all queues by default */
      185 
      186 	output_mode = BRIEF;			/* default is -brief */
      187 	path_output_mode = DEFAULT;			/* default is -absp if -long and -etnm if -brief */
      188 	id_output_mode = DEFAULT;			/* default is -short_id if -brief and -long_id if -long */
      189 	position_mode = DEFAULT;			/* default is -no_position */
      190 	user_selection = USER;			/* default is -own */
      191 
      192 MAIN_LIR_BLOCK:
      193 	begin;
      194 
      195 dcl  selection_types (array_bound) fixed binary (2);	/* type of selection indicated by this argument */
      196 dcl  dir_uids (array_bound) bit (36) aligned;		/* UIDs of directory part of pathname selections */
      197 
      198 	     selection_types (*) = NONE;
      199 	     dir_uids (*) = ""b;
      200 	     id_qualifier_idx = 0;			/* index of first -id STR */
      201 
      202 
      203 /* Scan the argument list, verify the syntax of all request_identifiers, process all control arguments, and apply other
      204*   appropriate defaults */
      205 
      206 	     do argument_idx = 1 to n_arguments;
      207 
      208 		call cu_$arg_ptr_rel (argument_idx, argument_ptr, argument_lth, code, the_argument_list);
      209 		if code ^= 0 then do;
      210 		     call com_err_ (code, LIST_IMFT_REQUESTS, "Accessing argument #^d.", argument_idx);
      211 		     return;
      212 		end;
      213 
      214 		if index (argument, "-") = 1 then	/* a control argument */
      215 		     if (argument = "-destination") | (argument = "-ds") then do;
      216 			remote = "0"b;
      217 			go to FOREIGN_SYSTEM;
      218 		     end;
      219 
      220 		     else if (argument = "-source") | (argument = "-sc") then do;
      221 			remote = "1"b;
      222 FOREIGN_SYSTEM:
      223 			call get_next_argument ("A system name", foreign_system);
      224 			if remote then
      225 			     request_type = substr ("From_" || foreign_system, 1, length (request_type));
      226 			else request_type = substr ("To_" || foreign_system, 1, length (request_type));
      227 
      228 			call iod_info_$generic_type (request_type, generic_type, code);
      229 			if code ^= 0 then do;	/* couldn't lookup the specified destination */
      230 INVALID_DESTINATION_SPECIFICATION:
      231 			     if code = error_table_$id_not_found then
      232 				call com_err_ (0, LIST_IMFT_REQUESTS, "Unknown ^[source^;destination^].  ""^a""",
      233 				     remote, foreign_system);
      234 			     else call com_err_ (code, LIST_IMFT_REQUESTS, "-^[source^;destination^] ""^a""",
      235 				     remote, foreign_system);
      236 			     return;
      237 			end;
      238 			if generic_type ^= FT_GENERIC_TYPE then do;
      239 			     call com_err_ (0, LIST_IMFT_REQUESTS, "Unknown ^[source^;destination^].  ""^a""",
      240 				remote, foreign_system);
      241 			     return;
      242 			end;
      243 		     end;
      244 
      245 		     else if (argument = "-queue") | (argument = "-q") then do;
      246 			call get_next_argument ("A number", queue_string);
      247 			queue = cv_dec_check_ (queue_string, code);
      248 			if code ^= 0 then do;
      249 INVALID_QUEUE_SPECIFICATION:
      250 			     call com_err_ (0, LIST_IMFT_REQUESTS,
      251 				"The queue must be a number between 1 and 4; not ""^a"".", queue_string);
      252 			     return;
      253 			end;
      254 			if (queue < 1) | (queue > 4) then go to INVALID_QUEUE_SPECIFICATION;
      255 		     end;				/* will check if queue is OK for destination later */
      256 
      257 		     else if (argument = "-all") | (argument = "-a") then queue = -1;
      258 						/* special indicator to match all queues */
      259 
      260 		     else if (argument = "-brief") | (argument = "-bf") then output_mode = BRIEF;
      261 		     else if (argument = "-long") | (argument = "-lg") then output_mode = LONG;
      262 		     else if (argument = "-totals") | (argument = "-total") | (argument = "-tt") then
      263 			output_mode = TOTALS;
      264 
      265 		     else if (argument = "-absolute_pathname") | (argument = "-absp") then path_output_mode = LONG;
      266 		     else if (argument = "-entryname") | (argument = "-etnm") then path_output_mode = BRIEF;
      267 
      268 		     else if (argument = "-long_id") | (argument = "-lgid") then id_output_mode = LONG;
      269 		     else if (argument = "-short_id") | (argument = "-shid") then id_output_mode = BRIEF;
      270 
      271 		     else if (argument = "-position") | (argument = "-psn") then position_mode = SHOW_POSITION;
      272 		     else if (argument = "-no_position") | (argument = "-npsn") then position_mode = NO_POSITION;
      273 
      274 		     else if argument = "-own" then user_selection = USER;
      275 		     else if (argument = "-admin") | (argument = "-am") then user_selection = ALL;
      276 		     else if argument = "-user" then do;
      277 			call get_next_argument ("A user ID", user_id);
      278 			if after (after (user_id, "."), ".") ^= "" then do;
      279 			     call com_err_ (0, LIST_IMFT_REQUESTS, "Improper syntax for user ID.  ""^a""", user_id);
      280 			     return;
      281 			end;
      282 			match_any_person = (before (user_id, ".") = "") | (before (user_id, ".") = "*");
      283 			match_any_project = (after (user_id, ".") = "") | (after (user_id, ".") = "*");
      284 			if match_any_person & match_any_project then
      285 			     user_selection = ALL;
      286 			else do;			/* matches a subset of all users */
      287 			     user_selection = SUBSET;
      288 			     person_id = before (user_id, ".");
      289 			     project_id = after (user_id, ".");
      290 			     if person_id = "" then person_id = "*";
      291 			     if project_id = "" then project_id = "*";
      292 			end;
      293 		     end;
      294 
      295 		     else if (argument = "-entry") | (argument = "-et") then do;
      296 			call get_next_argument ("A starname", an_ename);
      297 			call check_star_name_$entry (an_ename, code);
      298 			if (code ^= 0) & (code ^= 1) & (code ^= 2) then do;
      299 			     call com_err_ (code, LIST_IMFT_REQUESTS, "^a", an_ename);
      300 			     return;
      301 			end;
      302 			n_selections.entry = n_selections.entry + 1;
      303 			selection_types (argument_idx) = ENTRY;
      304 		     end;
      305 
      306 		     else if argument = "-id" then do;
      307 			call get_next_argument ("A request ID match string", request_id_nonvarying);
      308 			request_id = rtrim (request_id_nonvarying);
      309 			if verify (request_id, "0123456789.") ^= 0 then do;
      310 INVALID_REQUEST_ID:
      311 			     call com_err_ (0, LIST_IMFT_REQUESTS,
      312 				"Improper syntax for a request ID match string.  ""^a""", request_id);
      313 			     return;
      314 			end;
      315 			if after (after (request_id, "."), ".") ^= "" then go to INVALID_REQUEST_ID;
      316 			if length (before (request_id, ".")) > length ("YYMMDDHHMMSS") then
      317 			     go to INVALID_REQUEST_ID;
      318 			if length (after (request_id, ".")) > length ("FFFFFF") then go to INVALID_REQUEST_ID;
      319 			n_selections.id = n_selections.id + 1;
      320 			selection_types (argument_idx) = ID;
      321 			if id_qualifier_idx = 0 then id_qualifier_idx = argument_idx;
      322 		     end;				/* record index of first -id STR */
      323 
      324 		     else do;
      325 			call com_err_ (error_table_$badopt, LIST_IMFT_REQUESTS, """^a""", argument);
      326 			return;
      327 		     end;
      328 
      329 		else do;				/* a pathname selection */
      330 		     call expand_pathname_ (argument, a_dirname, an_ename, code);
      331 		     if code ^= 0 then do;
      332 			call com_err_ (code, LIST_IMFT_REQUESTS, "^a", argument);
      333 			return;
      334 		     end;
      335 		     call check_star_name_$entry (an_ename, code);
      336 		     if (code ^= 0) & (code ^= 1) & (code ^= 3) then do;
      337 			call com_err_ (code, LIST_IMFT_REQUESTS, pathname_ (a_dirname, an_ename));
      338 			return;
      339 		     end;
      340 		     n_selections.path = n_selections.path + 1;
      341 		     selection_types (argument_idx) = PATH;
      342 		     call hcs_$status_long (a_dirname, "", CHASE, addr (local_sb), null (), code);
      343 		     if (code = 0) | (code = error_table_$no_s_permission) then
      344 			dir_uids (argument_idx) = local_sb.uid;
      345 		end;				/* get the UID now: will need it later */
      346 	     end;
      347 
      348 	     if (output_mode = TOTALS)
      349 		& ((path_output_mode ^= DEFAULT) | (id_output_mode ^= DEFAULT) | (position_mode ^= DEFAULT)) then do;
      350 		if path_output_mode ^= DEFAULT then
      351 		     call com_err_ (error_table_$inconsistent, LIST_IMFT_REQUESTS,
      352 			"""-total"" and ""^[-entryname^;absolute_pathname^]""", (path_output_mode = BRIEF));
      353 		if id_output_mode ^= DEFAULT then
      354 		     call com_err_ (error_table_$inconsistent, LIST_IMFT_REQUESTS,
      355 			"""-total"" and ""^[-short_id^;long_id^]""", (id_output_mode = BRIEF));
      356 		if position_mode ^= DEFAULT then
      357 		     call com_err_ (error_table_$inconsistent, LIST_IMFT_REQUESTS,
      358 			"""-total"" and ""^[-no_position^;-position^]""", (position_mode = NO_POSITION));
      359 		return;
      360 	     end;
      361 
      362 	     if path_output_mode = DEFAULT then path_output_mode = output_mode;
      363 	     if id_output_mode = DEFAULT then id_output_mode = output_mode;
      364 	     if position_mode = DEFAULT then position_mode = NO_POSITION;
      365 
      366 	     if ((n_selections.entry + n_selections.path) > 0) & (n_selections.id > 1) then do;
      367 		call com_err_ (error_table_$inconsistent, LIST_IMFT_REQUESTS,
      368 		     "More than one ""-id"" control argument with path/entry selections.");
      369 		return;
      370 	     end;
      371 
      372 	     call iod_info_$queue_data (request_type, default_queue, max_queues, code);
      373 	     if code ^= 0 then go to INVALID_DESTINATION_SPECIFICATION;
      374 
      375 	     if queue = 0 then queue = default_queue;	/* supply default if needed */
      376 	     if queue > max_queues then do;
      377 		call com_err_ (0, LIST_IMFT_REQUESTS,
      378 		     "^[Source^;Destination^] ^a has only ^d queue^[s^]; you specified queue ^d.", remote, request_type, max_queues,
      379 		     (max_queues ^= 1), queue);
      380 		return;
      381 	     end;
      382 
      383 /**/
      384 
      385 /* Fetch the next argument */
      386 
      387 get_next_argument:
      388      procedure (p_arg_description, p_argument);
      389 
      390 dcl  p_arg_description character (*) parameter;
      391 dcl  p_argument character (*) parameter;
      392 dcl  control_argument character (32);
      393 
      394 	control_argument = argument;			/* save control arg's name for error messages */
      395 
      396 	if argument_idx = n_arguments then do;		/* there is no next argument */
      397 	     call com_err_ (error_table_$noarg, LIST_IMFT_REQUESTS, "^a must follow ""^a"".", p_arg_description,
      398 		control_argument);
      399 	     go to ABORT_ARGUMENT_PARSE;
      400 	end;
      401 
      402 	argument_idx = argument_idx + 1;
      403 
      404 	call cu_$arg_ptr_rel (argument_idx, argument_ptr, argument_lth, code, the_argument_list);
      405 	if code ^= 0 then do;
      406 	     call com_err_ (code, LIST_IMFT_REQUESTS, "Accessing argument #^d.", argument_idx);
      407 	     go to ABORT_ARGUMENT_PARSE;
      408 	end;
      409 
      410 	if argument_lth > length (p_argument) then do;	/* it's too long */
      411 	     call com_err_ (0, LIST_IMFT_REQUESTS, "Value after ""^a"" may not be longer than ^d characters.  ""^a""",
      412 		control_argument, length (p_argument), argument);
      413 	     go to ABORT_ARGUMENT_PARSE;
      414 	end;
      415 
      416 	p_argument = argument;			/* it's OK */
      417 
      418 	return;
      419 
      420      end get_next_argument;
      421 
      422 /**/
      423 
      424 /* Argument parsing completed: open the appropriate queues and determine if the user has sufficient access */
      425 
      426 	     system_area_ptr = get_system_free_area_ ();
      427 
      428 	     queue_indeces (*) = 0;			/* for cleanup handler */
      429 	     message_ids_ptr, ft_request_ptr = null ();
      430 
      431 	     unspec (local_mmi) = ""b;
      432 	     local_mmi.version = MSEG_MESSAGE_INFO_V1;
      433 
      434 	     on condition (cleanup) call cleanup_handler ();
      435 
      436 	     if (position_mode = SHOW_POSITION) & (user_selection = USER) then do;
      437 		person_id = before (get_group_id_ (), ".");
      438 		project_id = "*";			/* need to match just this user */
      439 	     end;
      440 
      441 	     if (position_mode = SHOW_POSITION) | (user_selection ^= USER) then access_required = R_EXTENDED_ACCESS;
      442 
      443 	     else do;
      444 		access_required = O_EXTENDED_ACCESS;
      445 		local_mmi.own = "1"b;
      446 	     end;
      447 
      448 	     total_requests (*) = -1;			/* don't know what's in any of the queues yet */
      449 
      450 	     if queue = -1 then do;			/* want to examine all the queues */
      451 		opened_a_queue = "0"b;
      452 		do queue_idx = 1 to max_queues;
      453 		     call open_single_queue (queue_idx);
      454 		     if queue_indeces (queue_idx) ^= 0 then opened_a_queue = "1"b;
      455 		end;
      456 		if ^opened_a_queue then go to RETURN_FROM_LIST_IMFT_REQUESTS;
      457 	     end;
      458 
      459 	     else do;				/* just one queue please */
      460 		call open_single_queue (queue);
      461 		if queue_indeces (queue) = 0 then go to RETURN_FROM_LIST_IMFT_REQUESTS;
      462 	     end;					/* couldn't open it: nothing we can do */
      463 
      464 /**/
      465 
      466 /* Opens a single queue's message segment and validates access */
      467 
      468 open_single_queue:
      469      procedure (p_queue_number);
      470 
      471 dcl  p_queue_number fixed binary parameter;
      472 dcl  queue_ename character (32);
      473 dcl  queue_picture picture "9";
      474 dcl  queue_mode bit (36) aligned;
      475 
      476 	queue_ename = rtrim (request_type) || "_" || convert (queue_picture, p_queue_number) || ".ms";
      477 
      478 	call message_segment_$open (imft_data_$queue_dirname, queue_ename, queue_indeces (p_queue_number), code);
      479 	if code ^= 0 then do;
      480 	     call com_err_ (code, LIST_IMFT_REQUESTS, "Opening ^a.", pathname_ (imft_data_$queue_dirname, queue_ename));
      481 	     go to RETURN_FROM_LIST_IMFT_REQUESTS;
      482 	end;
      483 
      484 	call message_segment_$get_mode_index (queue_indeces (p_queue_number), queue_mode, code);
      485 	if code ^= 0 then do;
      486 	     call com_err_ (code, LIST_IMFT_REQUESTS, "Determining access to ^a.",
      487 		pathname_ (imft_data_$queue_dirname, queue_ename));
      488 	     go to RETURN_FROM_LIST_IMFT_REQUESTS;
      489 	end;
      490 
      491 	if (queue_mode & access_required) ^= access_required then do;
      492 	     call com_err_ (error_table_$moderr, LIST_IMFT_REQUESTS,
      493 		"You do not have ""^[r^;o^]"" access to ^a queue ^d.", (access_required = R_EXTENDED_ACCESS),
      494 		request_type, p_queue_number);
      495 	     call message_segment_$close (queue_indeces (p_queue_number), (0));
      496 	     queue_indeces (p_queue_number) = 0;	/* not fatal: just don't list this queue */
      497 	     return;
      498 	end;
      499 
      500 	if (queue_mode & S_EXTENDED_ACCESS) = S_EXTENDED_ACCESS then do;
      501 	     call message_segment_$get_message_count_index (queue_indeces (p_queue_number),
      502 		total_requests (p_queue_number), code);
      503 	     if code ^= 0 then			/* couldn't get the message count: not fatal */
      504 		call com_err_ (code, LIST_IMFT_REQUESTS, "Determining number of messages in ^a.",
      505 		     pathname_ (imft_data_$queue_dirname, queue_ename));
      506 	end;
      507 
      508 	return;
      509 
      510      end open_single_queue;
      511 
      512 /**/
      513 
      514 /* Scan each of the selected queues generating a list of matching requests */
      515 
      516 	     first_id_indeces (*) = 0;		/* index into message_ids array of first request in queue */
      517 	     selected_requests (*) = 0;
      518 
      519 	     call get_temp_segment_ (LIST_IMFT_REQUESTS, message_ids_ptr, code);
      520 	     if code ^= 0 then do;
      521 		call com_err_ (code, LIST_IMFT_REQUESTS, "Getting a temporary segment.");
      522 		go to RETURN_FROM_LIST_IMFT_REQUESTS;
      523 	     end;
      524 
      525 	     total_message_ids = 0;			/* haven't used any yet */
      526 
      527 	     process_selections = ((n_selections.path + n_selections.entry + n_selections.id) ^= 0);
      528 
      529 	     if ((n_selections.path + n_selections.entry) > 0) & (n_selections.id = 1) then
      530 		call cu_$arg_ptr_rel (id_qualifier_idx, id_qualifier_ptr, id_qualifier_lth, (0), the_argument_list);
      531 	     else do;				/* no -id STR qualifier present: avoid faults */
      532 		id_qualifier_ptr = addr (LIST_IMFT_REQUESTS);
      533 		id_qualifier_lth = 0;
      534 	     end;
      535 
      536 	     do queue_idx = 1 to max_queues;		/* scan each queue that's open */
      537 		if queue_indeces (queue_idx) ^= 0 then call scan_single_queue (queue_idx);
      538 	     end;
      539 
      540 	     if sum (selected_requests (*)) = 0 then do;	/* no matching requests were found */
      541 		all_queues_empty = "1"b;		/* ... assume thery're all empty */
      542 		do queue_idx = 1 to max_queues while (all_queues_empty);
      543 		     if total_requests (queue_idx) ^= 0 then all_queues_empty = "0"b;
      544 		end;
      545 		if all_queues_empty then		/* ... and there's nothing in any of the queues */
      546 		     call ioa_ ("There are no requests in any ^a queue.", request_type);
      547 		else do;				/* ... explain about each empty queue */
      548 		     do queue_idx = 1 to max_queues;
      549 			if queue_indeces (queue_idx) ^= 0 then
      550 			     call ioa_ ("^/^a queue ^d:^-^[0 requests^]^[; ^]^[^d total request^[s^]^].",
      551 				request_type, queue_idx, (total_requests (queue_idx) ^= 0),
      552 				(total_requests (queue_idx) > 0), (total_requests (queue_idx) ^= -1),
      553 				total_requests (queue_idx), (total_requests (queue_idx) ^= 1));
      554 		     end;
      555 		     call ioa_ ("");
      556 		end;
      557 		go to RETURN_FROM_LIST_IMFT_REQUESTS;
      558 	     end;
      559 
      560 /**/
      561 
      562 /* Scans a single queue and records the indeces of all requests matching the selection criteria */
      563 
      564 scan_single_queue:
      565      procedure (p_queue_number);
      566 
      567 dcl  p_queue_number fixed binary parameter;
      568 
      569 dcl  user_id character (30);
      570 dcl  position fixed binary;
      571 dcl  previous_message_id bit (72) aligned;
      572 dcl  request_uid bit (36) aligned;
      573 dcl  (retry_read, matches) bit (1) aligned;
      574 
      575 	position = 0;
      576 
      577 	retry_read = "0"b;				/* this isn't a retry */
      578 
      579 RETRY_FIRST_READ:
      580 	local_mmi.message_code = MSEG_READ_FIRST;
      581 	call message_segment_$read_message_index (queue_indeces (p_queue_number), system_area_ptr, addr (local_mmi), code);
      582 	if ^retry_read then
      583 	     if code = error_table_$bad_segment then do;
      584 		retry_read = "1"b;			/* queue might have been salvaged: try again */
      585 		go to RETRY_FIRST_READ;
      586 	     end;
      587 
      588 
      589 	do while (code = 0);			/* while we've got a message */
      590 
      591 	     previous_message_id = local_mmi.ms_id;	/* needed to read the next message */
      592 	     position = position + 1;			/* count the messages as we read them */
      593 
      594 	     ft_request_ptr = local_mmi.ms_ptr;
      595 
      596 	     user_id = substr (local_mmi.sender_id, 1, (length (rtrim (local_mmi.sender_id)) - 2));
      597 
      598 	     if (ft_request.hdr_version ^= queue_msg_hdr_version_1) | (ft_request.version ^= FT_REQUEST_VERSION_1)
      599 	     then do;				/* unrecognized message format */
      600 		if (user_selection ^= USER) | (position_mode = SHOW_POSITION) then do;
      601 		     if user_selection ^= ALL then do;	/* ... check if it's from an interesting user */
      602 			if person_id ^= "*" then
      603 			     if before (user_id, ".") ^= person_id then go to SKIP_THIS_MESSAGE;
      604 			if project_id ^= "*" then
      605 			     if after (user_id, ".") ^= project_id then go to SKIP_THIS_MESSAGE;
      606 		     end;
      607 		end;
      608 		call add_this_message ();		/* it's the right user anyway */
      609 		go to SKIP_THIS_MESSAGE;
      610 	     end;
      611 
      612 	     if (user_selection ^= USER) | (position_mode = SHOW_POSITION) then do;
      613 		if user_selection ^= ALL then do;	/* must check if the user IDs match */
      614 		     if person_id ^= "*" then
      615 			if before (user_id, ".") ^= person_id then go to SKIP_THIS_MESSAGE;
      616 		     if project_id ^= "*" then
      617 			if after (user_id, ".") ^= project_id then go to SKIP_THIS_MESSAGE;
      618 		end;
      619 	     end;
      620 
      621 	     if process_selections then do;		/* have to match path/entry/request ID */
      622 		matches = "0"b;			/* until proven otherwise */
      623 		do argument_idx = 1 to n_arguments while (^matches);
      624 		     if selection_types (argument_idx) ^= NONE then do;
      625 			call cu_$arg_ptr_rel (argument_idx, argument_ptr, argument_lth, (0), the_argument_list);
      626 			if (selection_types (argument_idx) = PATH) | (selection_types (argument_idx) = ENTRY)
      627 			then do;
      628 			     if selection_types (argument_idx) = PATH then
      629 				call expand_pathname_ (argument, a_dirname, an_ename, (0));
      630 			     else an_ename = argument;
      631 			     call match_star_name_ ((ft_request.ename), an_ename, code);
      632 			     if code = 0 then	/* entry names match ... */
      633 				if selection_types (argument_idx) = PATH then do;
      634 				     call hcs_$status_long ((ft_request.dirname), "", CHASE, addr (local_sb),
      635 					null (), code);
      636 				     if (code = 0) | (code = error_table_$no_s_permission) then
      637 					request_uid = local_sb.uid;
      638 				     else request_uid = ""b;
      639 				     if (request_uid ^= ""b) & (dir_uids (argument_idx) ^= ""b) then
      640 					matches = (request_uid = dir_uids (argument_idx));
      641 				     else if (request_uid = ""b) & (dir_uids (argument_idx) = ""b) then
      642 					matches = (ft_request.dirname = a_dirname);
      643 				end;
      644 				else matches = "1"b;
      645 			     if matches & (id_qualifier ^= "") then
      646 				matches = match_request_id_ (ft_request.msg_time, id_qualifier);
      647 			end;
      648 			else do;			/* a request ID: only if not using ID as a qualifier */
      649 			     if id_qualifier = "" then matches = match_request_id_ (ft_request.msg_time, argument);
      650 			end;
      651 		     end;
      652 		end;
      653 		if ^matches then go to SKIP_THIS_MESSAGE;
      654 	     end;
      655 
      656 	     call add_this_message ();		/* it passes all the selection criteria */
      657 
      658 SKIP_THIS_MESSAGE:
      659 	     free ft_request in (system_area);		/* done with this request for now */
      660 	     ft_request_ptr = null ();
      661 
      662 	     retry_read = "0"b;			/* first attempt to read the next message */
      663 
      664 RETRY_READ_NEXT_MESSAGE:
      665 	     local_mmi.message_code = MSEG_READ_AFTER_SPECIFIED;
      666 	     local_mmi.ms_id = previous_message_id;
      667 
      668 	     call message_segment_$read_message_index (queue_indeces (p_queue_number), system_area_ptr, addr (local_mmi), code);
      669 	     if ^retry_read then
      670 		if code = error_table_$bad_segment then do;
      671 		     retry_read = "1"b;		/* message segment may have been salvaged */
      672 		     go to RETRY_READ_NEXT_MESSAGE;
      673 		end;
      674 	end;
      675 
      676 	if (code ^= 0) & (code ^= error_table_$no_message) then do;
      677 	     call com_err_ (code, LIST_IMFT_REQUESTS, "Reading from ^a queue ^d.", request_type, p_queue_number);
      678 	     call message_segment_$close (queue_indeces (p_queue_number), (0));
      679 	     queue_indeces (p_queue_number) = 0;	/* fatal error while reading: drop this queue */
      680 	end;
      681 
      682 	return;
      683 
      684 
      685 /* Internal to scan_single_queue: adds the current request to the list of selected requests */
      686 
      687 add_this_message:
      688 	procedure ();
      689 
      690 	     selected_requests (p_queue_number) = selected_requests (p_queue_number) + 1;
      691 
      692 	     total_message_ids = total_message_ids + 1;
      693 
      694 	     message_ids.id (total_message_ids) = local_mmi.ms_id;
      695 	     message_ids.position (total_message_ids) = position;
      696 
      697 	     if first_id_indeces (p_queue_number) = 0 then first_id_indeces (p_queue_number) = total_message_ids;
      698 
      699 	     return;
      700 
      701 	end add_this_message;
      702 
      703      end scan_single_queue;
      704 
      705 /**/
      706 
      707 /* Display the descriptions of each matching request */
      708 
      709 	     do queue_idx = 1 to max_queues;
      710 
      711 		if queue_indeces (queue_idx) ^= 0 then do;
      712 
      713 		     if (selected_requests (queue_idx) ^= 0) | (total_requests (queue_idx) > 0) then
      714 			call ioa_ ("^/^a queue ^d:^-^d request^[s^]^[; ^d total request^[s^]^].", request_type,
      715 			     queue_idx, selected_requests (queue_idx), (selected_requests (queue_idx) ^= 1),
      716 			     (total_requests (queue_idx) ^= -1), total_requests (queue_idx),
      717 			     (total_requests (queue_idx) ^= 1));
      718 
      719 		     if output_mode ^= TOTALS then do;	/* some requests to display */
      720 			first_message_in_queue = "1"b;
      721 			do message_idx = first_id_indeces (queue_idx)
      722 			     to (first_id_indeces (queue_idx) + selected_requests (queue_idx) - 1);
      723 			     call display_single_request (queue_idx, message_ids.id (message_idx),
      724 				message_ids.position (message_idx));
      725 			end;
      726 		     end;
      727 		end;
      728 	     end;
      729 
      730 	     if (output_mode ^= LONG) | first_message_in_queue then call ioa_ ("");
      731 
      732 /**/
      733 
      734 /* Displays a single request's description */
      735 
      736 display_single_request:
      737      procedure (p_queue, p_message_id, p_position);
      738 
      739 dcl  (p_queue, p_position) fixed binary parameter;
      740 dcl  p_message_id bit (72) aligned parameter;
      741 
      742 dcl  user_id character (30);
      743 dcl  time_queued_string character (24);
      744 dcl  long_id_string character (19);
      745 dcl  short_id_string character (8);
      746 dcl  (retry_read, supported_version) bit (1) aligned;
      747 
      748 	retry_read = "0"b;
      749 
      750 READ_THE_MESSAGE:
      751 	local_mmi.message_code = MSEG_READ_SPECIFIED;
      752 	local_mmi.ms_id = p_message_id;
      753 
      754 	call message_segment_$read_message_index (queue_indeces (p_queue), system_area_ptr, addr (local_mmi), code);
      755 	if retry_read then
      756 	     if code = error_table_$bad_segment then do;
      757 		retry_read = "1"b;			/* message segment has been salvaged */
      758 		go to READ_THE_MESSAGE;
      759 	     end;
      760 
      761 	if code ^= 0 then do;			/* couldn't get the message: OK if it was deleted */
      762 	     if code ^= error_table_$no_message then
      763 		call com_err_ (code, LIST_IMFT_REQUESTS, "Attempting to read message ^24.3b from ^a queue ^d.",
      764 		     p_message_id, request_type, p_queue);
      765 	     return;
      766 	end;
      767 
      768 	ft_request_ptr = local_mmi.ms_ptr;
      769 
      770 	user_id = substr (local_mmi.sender_id, 1, (length (rtrim (local_mmi.sender_id)) - 2));
      771 
      772 	if (ft_request.hdr_version ^= queue_msg_hdr_version_1) | (ft_request.version ^= FT_REQUEST_VERSION_1) then do;
      773 	     supported_version = "0"b;		/* unknown message */
      774 	     unspec (ft_request.msg_time) = local_mmi.ms_id;
      775 	     call date_time_ (ft_request.msg_time, time_queued_string);
      776 	end;
      777 
      778 	else do;
      779 	     supported_version = "1"b;		/* we recognize this message */
      780 	     if (ft_request.state < STATE_UNPROCESSED) | (ft_request.state > STATE_RUNNING) then
      781 		ft_request.state = STATE_UNKNOWN;	/* ... but the state is garbage so "fix" it */
      782 	     long_id_string = request_id_ (ft_request.msg_time);
      783 	     short_id_string = substr (long_id_string, 7, 8);
      784 	     call date_time_ (ft_request.msg_time, time_queued_string);
      785 	end;
      786 
      787 	if first_message_in_queue then do;
      788 	     first_message_in_queue = "0"b;
      789 	     call ioa_ ("");			/* put some space after the totals line */
      790 	     if (user_selection ^= USER) & (output_mode = BRIEF) then
      791 		call ioa_ ("User^31t^[^7x^]^2xID^[^19x^;^8x^]^[Entry name^;Pathname^]",
      792 		     (position_mode = SHOW_POSITION), (id_output_mode = LONG), (path_output_mode = BRIEF));
      793 	end;
      794 
      795 	if output_mode = BRIEF then
      796 	     if supported_version then
      797 		call ioa_ ("^[^30a^;^s^]^[^6d)^;^s^]^2x^[^a^s^;^s^a^]^2x^[^a^s^;^s^a^]^[ (^a)^]",
      798 		     (user_selection ^= USER), user_id, (position_mode = SHOW_POSITION), p_position,
      799 		     (id_output_mode = BRIEF), short_id_string, long_id_string, (path_output_mode = BRIEF),
      800 		     ft_request.ename, pathname_ ((ft_request.dirname), (ft_request.ename)),
      801 		     (ft_request.state ^= STATE_UNPROCESSED), STATE_NAMES (ft_request.state));
      802 
      803 	     else call ioa_ ("^[^30a^;^s^] (unrecognized request format); time queued: ^a", (user_selection ^= USER),
      804 		     user_id, time_queued_string);
      805 
      806 	else do;					/* long output format */
      807 	     if supported_version then do;
      808 		if user_selection ^= USER then call ioa_ ("User:^21t^a", user_id);
      809 		if position_mode = SHOW_POSITION then call ioa_ ("Position in queue:^21t^d", p_position);
      810 		call ioa_ ("Request ID:^21t^[^a^;^s^a^]", (id_output_mode = BRIEF), short_id_string, long_id_string);
      811 		call ioa_ ("Time queued:^21t^a", time_queued_string);
      812 		call ioa_ ("^[Local ^[entry^;pathname^]^;^[Entry^;Pathname^]^]:^21t^[^a^;^s^a^]",
      813 		     ft_request.foreign_path_given, (path_output_mode = BRIEF), (path_output_mode = BRIEF),
      814 		     ft_request.ename, pathname_ ((ft_request.dirname), (ft_request.ename)));
      815 		call ioa_ ("State:^21t^a", STATE_NAMES (ft_request.state));
      816 		if ft_request.foreign_path_given then
      817 		     call ioa_ ("Foreign pathname:^21t^a",
      818 			pathname_ (ft_request.foreign_dirname, ft_request.foreign_ename));
      819 		if ft_request.foreign_user_given then call ioa_ ("Foreign user:^21t^a", ft_request.foreign_user);
      820 		if (ft_request.directory_creation_mode ^= "00"b) then
      821 		     call ioa_ ("Options:^21t^[replace_directories^;merge_directories^]",
      822 			(ft_request.directory_creation_mode = REPLACE_DIRECTORIES));
      823 		if ft_request.delete then call ioa_ ("Delete:^21tyes");
      824 		if ft_request.extend then call ioa_ ("Extend:^21tyes");
      825 		if ft_request.notify then call ioa_ ("Notify:^21tyes");
      826 		if ft_request.update then call ioa_ ("Update:^21tyes");
      827 	     end;
      828 	     else do;				/* unrecognized message format */
      829 		call ioa_ ("User:^21t^a", user_id);
      830 		call ioa_ ("Time queued:^21t^a", time_queued_string);
      831 		call ioa_ ("^5x(unrecognized request format)");
      832 	     end;
      833 	     call ioa_ ("");			/* and end it with a blank line */
      834 	end;
      835 
      836 	free ft_request in (system_area);
      837 	ft_request_ptr = null ();
      838 
      839 	return;
      840 
      841      end display_single_request;
      842 
      843 	end MAIN_LIR_BLOCK;
      844 
      845 /**/
      846 
      847 RETURN_FROM_LIST_IMFT_REQUESTS:
      848 	call cleanup_handler ();
      849 
      850 ABORT_ARGUMENT_PARSE:
      851 	return;
      852 
      853 
      854 /* Cleanup after an invocation of list_imft_requests */
      855 
      856 cleanup_handler:
      857      procedure ();
      858 
      859 	if ft_request_ptr ^= null () then do;
      860 	     free ft_request in (system_area);
      861 	     ft_request_ptr = null ();
      862 	end;
      863 
      864 	if message_ids_ptr ^= null () then do;
      865 	     call release_temp_segment_ (LIST_IMFT_REQUESTS, message_ids_ptr, (0));
      866 	     message_ids_ptr = null ();
      867 	end;
      868 
      869 	do queue_idx = 1 to max_queues;
      870 	     if queue_indeces (queue_idx) ^= 0 then do;
      871 		call message_segment_$close (queue_indeces (queue_idx), (0));
      872 		queue_indeces (queue_idx) = 0;
      873 	     end;
      874 	end;
      875 
      876 	return;
      877 
      878      end cleanup_handler;
      879 
      880 /**/
      881 
  1     1 /* BEGIN INCLUDE FILE ... _imft_ft_request.incl.pl1 */
  1     2 
  1     3 /* Created:  April 1982 by G. Palter */
  1     4 /* Modified: March 1983 by Robert Coren, for requests for remote transfer */
  1     5 
  1     6 
  1     7 /****^  HISTORY COMMENTS:
  1     8*  1) change(88-06-22,Beattie), approve(88-08-01,MCR7948),
  1     9*     audit(88-10-14,Farley), install(88-10-14,MR12.2-1165):
  1    10*     Add flags to support extend, update and delete operations.
  1    11*                                                   END HISTORY COMMENTS */
  1    12 
  1    13 
  1    14 /* IMFT file transfer request definition */
  1    15 
  1    16 dcl 1 ft_request aligned based (ft_request_ptr),
  1    17       2 header like queue_msg_hdr,
  1    18       2 request,					/* see _imft_ft_commands.incl.pl1 */
  1    19         3 version character (8),
  1    20         3 foreign_user character (32) unaligned,		/* Person.Project at other Multics for reload access check */
  1    21         3 foreign_dirname character (168) unaligned,	/* where to put the branch on the other system */
  1    22         3 foreign_ename character (32) unaligned,		/* ... */
  1    23         3 flags,
  1    24 	4 foreign_user_given bit (1) unaligned,		/* ON => forreign_user different from local user */
  1    25 	4 foreign_path_given bit (1) unaligned,		/* ON => foreign pathname different from local */
  1    26 	4 directory_creation_mode bit (2) unaligned,	/* controls whether directories are replaced/merged */
  1    27 	4 remote_transfer bit (1) unaligned,		/* ON => request for transfer from foreign system */
  1    28 	4 include_files bit (1) unaligned,		/* ON => match files when interpreting starname */
  1    29 	4 include_subtrees bit (1) unaligned,		/* ON => match subtrees when interpreting starname */
  1    30 	4 chase_control bit (2) unaligned,		/* controls chasing of links when submitting remote request */
  1    31 	4 delete bit (1) unaligned,			/* delete source object after good transfer */
  1    32 	4 extend bit (1) unaligned,			/* place this data at end of current segment */
  1    33 	4 update bit (1) unaligned,			/* replace contents of current segment with this data */
  1    34 	4 pad bit (24) unaligned;
  1    35 
  1    36 dcl  ft_request_ptr pointer;
  1    37 
  1    38 dcl  FT_REQUEST_VERSION_1 character (8) static options (constant) initial ("ftr_1.00");
  1    39 
  1    40 dcl  FT_GENERIC_TYPE character (32) static options (constant) initial ("imft");
  1    41 dcl  FT_MESSAGE_TYPE fixed binary static options (constant) initial (5);
  1    42 
  1    43 dcl (REPLACE_DIRECTORIES	initial ("10"b),		/* replace entry on target if namedup and source is a dir */
  1    44      MERGE_DIRECTORIES	initial ("11"b))		/* merge target and source dirs; replace if target not dir */
  1    45 	bit (2) aligned static options (constant);
  1    46 
  1    47 dcl (DEFAULT_CHASE		initial ("00"b),		/* chase non-starnames; don't chase starnames */
  1    48      NEVER_CHASE		initial ("01"b),		/* never chase any links */
  1    49      ALWAYS_CHASE		initial ("10"b))		/* always chase links */
  1    50 	bit (2) aligned static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... _imft_ft_request.incl.pl1 */
      882 
      883 
  2     1 /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
  2     2 /* format: style3,idind30 */
  2     3 
  2     4 /* structure returned when message is read from a message segment */
  2     5 
  2     6 
  2     7 dcl	mseg_message_info_ptr	pointer;
  2     8 
  2     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
  2    10 	  2 version		char (8) aligned,
  2    11 	  2 message_code		fixed bin,
  2    12 	  2 control_flags		unaligned,
  2    13 	    3 own			bit (1),
  2    14 	    3 delete		bit (1),
  2    15 	    3 pad			bit (34),
  2    16 	  2 ms_ptr		ptr,		/* pointer to message */
  2    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
  2    18 	  2 ms_id			bit (72),		/* unique ID of message */
  2    19 						/* input in some cases */
  2    20 	  2 ms_access_class		bit (72),		/* message access class */
  2    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
  2    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
  2    23 	  2 sender_level		fixed bin,	/* validation level of sender */
  2    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
  2    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
  2    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
  2    27 
  2    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
  2    29 
  2    30 declare	(
  2    31 	MSEG_READ_FIRST		init (1),
  2    32 	MSEG_READ_LAST		init (2),
  2    33 	MSEG_READ_SPECIFIED		init (3),
  2    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
  2    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
  2    36 	fixed bin int static options (constant);
  2    37 
  2    38 declare  (MSEG_READ_OWN		init ("1"b),
  2    39 	MSEG_READ_DELETE		init ("01"b)
  2    40 	)			bit (36) aligned internal static options (constant);
  2    41 
  2    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
      884 
      885 
  3     1 /* BEGIN INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
  3     2 
  3     3 /* This is the message header used for standard system queue messages, namely:
  3     4*   IO daemon requests, absentee requests, retrieval requests.
  3     5**/
  3     6 
  3     7 /* Written by Jerry Whitmore, Spring 1978.
  3     8*   Modified by T. Casey, November 1978, to add values for state.
  3     9*   Modified by R. Kovalcik, June 1982, defer_until_process_terminataion
  3    10**/
  3    11 
  3    12 dcl 1 queue_msg_hdr based aligned,			/* standard header for all system queue messages */
  3    13     2 msg_time fixed bin (71),			/* date and time of request */
  3    14     2 hdr_version fixed bin,				/* version of this declaration */
  3    15     2 dirname char (168),				/* directory name */
  3    16     2 ename char (32),				/* entry name of file requested */
  3    17     2 message_type fixed bin,				/* message format descriptor   */
  3    18 						/* 0 = absentee request        */
  3    19 						/* 1 = print request           */
  3    20 						/* 2 = punch request           */
  3    21 						/* 3 = tape request            */
  3    22 						/* 4 = retrieval request       */
  3    23     2 bit_flags,
  3    24       3 delete_sw bit (1) unal,			/* delete file when done */
  3    25       3 notify bit (1) unal,				/* user wants to be notified */
  3    26       3 defer_until_process_termination bit (1) unal,	/* don't process request until process terminates */
  3    27       3 padding bit (33) unal,
  3    28     2 state fixed bin,				/* stage of processing after being queued:
  3    29*						   0 = initial unprocessed state, 1 = deferred,
  3    30*						   2 = in state transition, 3 = eligible, 4 = running,
  3    31*                                                               5 = bumped, 6 = deferred_until_process_termination */
  3    32     2 orig_queue fixed bin,				/* queue the request was submitted to */
  3    33     2 std_length fixed bin,				/* length of std msg for this type */
  3    34     2 dupt_lock bit (36) aligned,			/* lock word for defer until process termination */
  3    35     2 hdr_pad (3) fixed bin;
  3    36 
  3    37 dcl  queue_msg_hdr_version_1 fixed bin int static options (constant) init (1); /* current version of the header */
  3    38 
  3    39 /* Values for queue_msg_hdr.state */
  3    40 
  3    41 dcl  STATE_UNPROCESSED fixed bin int static options (constant) init (0);
  3    42 dcl  STATE_DEFERRED fixed bin int static options (constant) init (1);
  3    43 dcl  STATE_TRANSITION fixed bin int static options (constant) init (2);
  3    44 dcl  STATE_ELIGIBLE fixed bin int static options (constant) init (3);
  3    45 dcl  STATE_RUNNING fixed bin int static options (constant) init (4);
  3    46 dcl  STATE_BUMPED fixed bin int static options (constant) init (5);
  3    47 dcl  STATE_DUPT fixed bin int static options (constant) init (6);
  3    48 
  3    49 /* END INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
      886 
      887 
  4     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  4     2 
  4     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  4     4 
  4     5 /* This include file contains branch and link structures returned by
  4     6*   hcs_$status_ and hcs_$status_long. */
  4     7 
  4     8 dcl 1 status_branch aligned based (status_ptr),
  4     9     2 short aligned,
  4    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  4    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  4    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  4    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  4    14       3 dtu bit (36) unaligned,			/* date/time last used */
  4    15       3 mode bit (5) unaligned,			/* caller's effective access */
  4    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  4    17       3 pad1 bit (8) unaligned,
  4    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  4    19 
  4    20 /* Limit of information returned by hcs_$status_ */
  4    21 
  4    22     2 long aligned,
  4    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  4    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  4    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  4    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  4    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  4    28       3 pad2 bit (8) unaligned,
  4    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  4    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  4    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  4    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  4    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  4    34       3 pad3 bit (5) unaligned,
  4    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  4    36       3 uid bit (36) unaligned;			/* unique ID */
  4    37 
  4    38 dcl 1 status_link aligned based (status_ptr),
  4    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  4    40     2 nnames fixed bin (16) unaligned unsigned,
  4    41     2 names_relp bit (18) unaligned,
  4    42     2 dtem bit (36) unaligned,
  4    43     2 dtd bit (36) unaligned,
  4    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  4    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  4    46 
  4    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  4    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  4    49 						/* array of names returned */
  4    50      status_pathname character (status_link.pathname_length) aligned
  4    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  4    52 						/* link target path */
  4    53      status_area_ptr pointer,
  4    54      status_ptr pointer;
  4    55 
  4    56 dcl (Link initial (0),
  4    57      Segment initial (1),
  4    58      Directory initial (2)) fixed bin internal static options (constant);
  4    59 						/* values for type fields declared above */
  4    60 
  4    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
      888 
      889 
      890      end list_imft_requests;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/14/88  1211.3  list_imft_requests.pl1            >special_ldd>install>MR12.2-1165>list_imft_requests.pl1
882          1    10/14/88  1212.4  _imft_ft_request.incl.pl1         >special_ldd>install>MR12.2-1165>_imft_ft_request.incl.pl1
884          2    01/10/85  2002.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
886          3    08/31/82  1636.3  queue_msg_hdr.incl.pl1            >ldd>include>queue_msg_hdr.incl.pl1
888          4    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALL                                    constant        fixed bin(2,0)           initial dcl 84 ref 275 284 601 613
BRIEF                                  constant        fixed bin(2,0)           initial dcl 84 ref 186 260 266 269 350 353 790 790
                                                                                  795 795 795 810 812 812
CHASE                           000222 constant        fixed bin(1,0)           initial dcl 117 set ref 342* 634*
DEFAULT                                constant        fixed bin(2,0)           initial dcl 84 ref 187 188 189 348 348 348 350 353
                                                                                  356 362 363 364
ENTRY                                  constant        fixed bin(2,0)           initial dcl 84 ref 303 626
FT_GENERIC_TYPE                 000002 constant        char(32)                 initial packed unaligned dcl 1-40 ref 238
FT_REQUEST_VERSION_1            000012 constant        char(8)                  initial packed unaligned dcl 1-38 ref 598 772
ID                                     constant        fixed bin(2,0)           initial dcl 84 ref 320
LIST_IMFT_REQUESTS              000014 constant        char(32)                 initial packed unaligned dcl 125 set ref 170* 210*
                                                                                  230* 234* 239* 249* 279* 299* 310* 325* 332* 337*
                                                                                  350* 353* 356* 367* 377* 397* 406* 411* 480* 486*
                                                                                  492* 503* 519* 521* 532 677* 762* 865*
LONG                                   constant        fixed bin(2,0)           initial dcl 84 ref 261 265 268 730 790
MSEG_MESSAGE_INFO_V1            000000 constant        char(8)                  initial dcl 2-28 ref 432
MSEG_READ_AFTER_SPECIFIED              constant        fixed bin(17,0)          initial dcl 2-30 ref 664
MSEG_READ_FIRST                        constant        fixed bin(17,0)          initial dcl 2-30 ref 579
MSEG_READ_SPECIFIED                    constant        fixed bin(17,0)          initial dcl 2-30 ref 750
NONE                                   constant        fixed bin(2,0)           initial dcl 84 ref 198 624
NO_POSITION                            constant        fixed bin(2,0)           initial dcl 84 ref 272 356 364
O_EXTENDED_ACCESS                      constant        bit(36)                  initial dcl 103 ref 444
PATH                                   constant        fixed bin(2,0)           initial dcl 84 ref 341 626 628 632
REPLACE_DIRECTORIES                    constant        bit(2)                   initial dcl 1-43 ref 820
R_EXTENDED_ACCESS                      constant        bit(36)                  initial dcl 103 ref 441 492
SHOW_POSITION                          constant        fixed bin(2,0)           initial dcl 84 ref 271 436 441 600 612 790 795 809
STATE_NAMES                     000024 constant        varying char(32)         initial array dcl 112 set ref 795* 815*
STATE_RUNNING                          constant        fixed bin(17,0)          initial dcl 3-45 ref 780
STATE_UNKNOWN                          constant        fixed bin(17,0)          initial dcl 110 ref 780
STATE_UNPROCESSED                      constant        fixed bin(17,0)          initial dcl 3-41 ref 780 795
SUBSET                                 constant        fixed bin(2,0)           initial dcl 84 ref 287
S_EXTENDED_ACCESS                      constant        bit(36)                  initial dcl 103 ref 500 500
TOTALS                                 constant        fixed bin(2,0)           initial dcl 84 ref 262 348 719
USER                                   constant        fixed bin(2,0)           initial dcl 84 ref 190 274 436 441 600 612 790 795
                                                                                  803 808
a_dirname                       000314 automatic       char(168)                packed unaligned dcl 70 set ref 330* 337* 337* 342*
                                                                                  628* 641
access_required                 000411 automatic       bit(36)                  dcl 76 set ref 441* 444* 491 491 492
addr                                                   builtin function         dcl 164 ref 342 342 532 581 581 634 634 668 668 754
                                                                                  754
after                                                  builtin function         dcl 164 ref 278 278 283 283 289 315 315 318 604 616
all_queues_empty                000254 automatic       bit(1)                   dcl 63 set ref 541* 542 543* 545
an_ename                        000366 automatic       char(32)                 packed unaligned dcl 71 set ref 296* 297* 299* 330*
                                                                                  335* 337* 337* 628* 630* 631*
argument                               based           char                     packed unaligned dcl 43 set ref 214 214 214 220 220
                                                                                  245 245 257 257 260 260 261 261 262 262 262 265
                                                                                  265 266 266 268 268 269 269 271 271 272 272 274
                                                                                  275 275 276 295 295 306 325* 330* 332* 394 411*
                                                                                  416 628* 630 649*
argument_idx                    000164 automatic       fixed bin(17,0)          dcl 47 set ref 206* 208* 210* 303 320 321 341 343*
                                                                                  396 402* 402 404* 406* 623* 624 625* 626 626 628
                                                                                  632 639 639 641*
argument_lth                    000160 automatic       fixed bin(21,0)          dcl 46 set ref 208* 214 214 214 220 220 245 245 257
                                                                                  257 260 260 261 261 262 262 262 265 265 266 266
                                                                                  268 268 269 269 271 271 272 272 274 275 275 276
                                                                                  295 295 306 325 325 330 330 332 332 394 404* 410
                                                                                  411 411 416 625* 628 628 630 649 649
argument_ptr                    000154 automatic       pointer                  dcl 45 set ref 208* 214 214 214 220 220 245 245 257
                                                                                  257 260 260 261 261 262 262 262 265 265 266 266
                                                                                  268 268 269 269 271 271 272 272 274 275 275 276
                                                                                  295 295 306 325 330 332 394 404* 411 416 625* 628
                                                                                  630 649
array_bound                     000171 automatic       fixed bin(17,0)          dcl 55 set ref 179* 195 196
before                                                 builtin function         dcl 164 ref 282 282 288 316 437 602 614
bit_flags                66            based           structure                level 3 dcl 1-16
check_star_name_$entry          000032 constant        entry                    external dcl 135 ref 297 335
cleanup                         000000 stack reference condition                dcl 162 ref 434
code                            000414 automatic       fixed bin(35,0)          dcl 81 set ref 168* 169 170* 208* 209 210* 228* 229
                                                                                  230 234* 247* 248 297* 298 298 298 299* 330* 331
                                                                                  332* 335* 336 336 336 337* 342* 343 343 372* 373
                                                                                  404* 405 406* 478* 479 480* 484* 485 486* 501* 503
                                                                                  503* 519* 520 521* 581* 582 589 631* 632 634* 636
                                                                                  636 668* 669 676 676 677* 754* 755 761 762 762*
com_err_                        000034 constant        entry                    external dcl 136 ref 170 210 230 234 239 249 279 299
                                                                                  310 325 332 337 350 353 356 367 377 397 406 411
                                                                                  480 486 492 503 521 677 762
control_argument                000136 automatic       char(32)                 packed unaligned dcl 392 set ref 394* 397* 411*
control_flags             3     000114 automatic       structure                level 2 packed packed unaligned dcl 34
convert                                                builtin function         dcl 164 ref 476
cu_$arg_count                   000036 constant        entry                    external dcl 137 ref 168
cu_$arg_list_ptr                000040 constant        entry                    external dcl 138 ref 174
cu_$arg_ptr_rel                 000042 constant        entry                    external dcl 139 ref 208 404 529 625
cv_dec_check_                   000044 constant        entry                    external dcl 140 ref 247
date_time_                      000046 constant        entry                    external dcl 141 ref 775 784
default_queue                   000230 automatic       fixed bin(17,0)          dcl 61 set ref 372* 375
delete                  172(09)        based           bit(1)                   level 4 packed packed unaligned dcl 1-16 ref 823
dir_uids                        000100 automatic       bit(36)                  array dcl 196 set ref 199* 343* 639 639 641
directory_creation_mode
                        172(02)        based           bit(2)                   level 4 packed packed unaligned dcl 1-16 ref 820 820
dirname                   3            based           char(168)                level 3 dcl 1-16 ref 634 641 795 795 812 812
ename                    55            based           char(32)                 level 3 dcl 1-16 set ref 631 795* 795 795 812* 812
                                                                                  812
entry                     1     000165 automatic       fixed bin(17,0)          level 2 dcl 49 set ref 302* 302 366 527 529
error_table_$bad_segment        000012 external static fixed bin(35,0)          dcl 130 ref 582 669 755
error_table_$badopt             000014 external static fixed bin(35,0)          dcl 130 set ref 325*
error_table_$id_not_found       000016 external static fixed bin(35,0)          dcl 130 ref 230
error_table_$inconsistent       000020 external static fixed bin(35,0)          dcl 130 set ref 350* 353* 356* 367*
error_table_$moderr             000022 external static fixed bin(35,0)          dcl 130 set ref 492*
error_table_$no_message         000024 external static fixed bin(35,0)          dcl 130 ref 676 762
error_table_$no_s_permission    000026 external static fixed bin(35,0)          dcl 130 ref 343 636
error_table_$noarg              000030 external static fixed bin(35,0)          dcl 130 set ref 397*
expand_pathname_                000050 constant        entry                    external dcl 142 ref 330 628
extend                  172(10)        based           bit(1)                   level 4 packed packed unaligned dcl 1-16 ref 824
first_id_indeces                000223 automatic       fixed bin(17,0)          array dcl 60 set ref 516* 697 697* 721 721
first_message_in_queue          000413 automatic       bit(1)                   dcl 79 set ref 720* 730 787 788*
flags                   172            based           structure                level 3 dcl 1-16
foreign_dirname         110            based           char(168)                level 3 packed packed unaligned dcl 1-16 set ref
                                                                                  816* 816*
foreign_ename           162            based           char(32)                 level 3 packed packed unaligned dcl 1-16 set ref
                                                                                  816* 816*
foreign_path_given      172(01)        based           bit(1)                   level 4 packed packed unaligned dcl 1-16 set ref
                                                                                  812* 816
foreign_system                  000200 automatic       char(24)                 packed unaligned dcl 58 set ref 222* 224 226 230*
                                                                                  234* 239*
foreign_user            100            based           char(32)                 level 3 packed packed unaligned dcl 1-16 set ref
                                                                                  819*
foreign_user_given      172            based           bit(1)                   level 4 packed packed unaligned dcl 1-16 ref 819
ft_request                             based           structure                level 1 dcl 1-16 set ref 658 836 860
ft_request_ptr                  000416 automatic       pointer                  dcl 1-36 set ref 429* 594* 598 598 631 634 641 645
                                                                                  649 658 660* 768* 772 772 774 775 780 780 780 782
                                                                                  784 795 795 795 795 795 795 795 812 812 812 812
                                                                                  812 812 815 816 816 816 816 816 819 819 820 820
                                                                                  823 824 825 826 836 837* 859 860 861*
generic_type                    000233 automatic       char(32)                 packed unaligned dcl 62 set ref 228* 238
get_group_id_                   000052 constant        entry                    external dcl 143 ref 437
get_system_free_area_           000054 constant        entry                    external dcl 144 ref 426
get_temp_segment_               000056 constant        entry                    external dcl 145 ref 519
hcs_$status_long                000060 constant        entry                    external dcl 146 ref 342 634
hdr_version               2            based           fixed bin(17,0)          level 3 dcl 1-16 ref 598 772
header                                 based           structure                level 2 dcl 1-16
id                                     based           bit(72)                  array level 2 in structure "message_ids" dcl 36
                                                                                  in procedure "lir" set ref 694* 723*
id                        2     000165 automatic       fixed bin(17,0)          level 2 in structure "n_selections" dcl 49
                                                                                  in procedure "lir" set ref 319* 319 366 527 529
id_output_mode                  000257 automatic       fixed bin(2,0)           dcl 65 set ref 188* 268* 269* 348 353 353 363 363*
                                                                                  790 795 810
id_qualifier                           based           char                     packed unaligned dcl 44 set ref 645 645* 649
id_qualifier_idx                000163 automatic       fixed bin(17,0)          dcl 47 set ref 200* 321 321* 529*
id_qualifier_lth                000161 automatic       fixed bin(21,0)          dcl 46 set ref 529* 533* 645 645 645 649
id_qualifier_ptr                000156 automatic       pointer                  dcl 45 set ref 529* 532* 645 645 649
imft_data_$queue_dirname        000010 external static char(168)                packed unaligned dcl 127 set ref 478* 480* 480* 486*
                                                                                  486* 503* 503*
imft_default_rqt_               000062 constant        entry                    external dcl 147 ref 183
index                                                  builtin function         dcl 164 ref 214
ioa_                            000064 constant        entry                    external dcl 148 ref 545 549 555 713 730 789 790 795
                                                                                  803 808 809 810 811 812 815 816 819 820 823 824
                                                                                  825 826 829 830 831 833
iod_info_$generic_type          000066 constant        entry                    external dcl 149 ref 228
iod_info_$queue_data            000070 constant        entry                    external dcl 150 ref 372
length                                                 builtin function         dcl 164 ref 224 226 316 316 318 318 410 411 411 596
                                                                                  770
local_mmi                       000114 automatic       structure                level 1 dcl 34 set ref 431* 581 581 668 668 754 754
local_sb                        000102 automatic       structure                level 1 dcl 33 set ref 342 342 634 634
long                      4     000102 automatic       structure                level 2 dcl 33
long_id_string                  000246 automatic       char(19)                 packed unaligned dcl 744 set ref 782* 783 795* 810*
match_any_person                000312 automatic       bit(1)                   dcl 68 set ref 282* 284
match_any_project               000313 automatic       bit(1)                   dcl 68 set ref 283* 284
match_request_id_               000072 constant        entry                    external dcl 151 ref 645 649
match_star_name_                000074 constant        entry                    external dcl 152 ref 631
matches                         000212 automatic       bit(1)                   dcl 573 set ref 622* 623 639* 641* 644* 645 645*
                                                                                  649* 653
max                                                    builtin function         dcl 164 ref 179
max_queues                      000231 automatic       fixed bin(17,0)          dcl 61 set ref 372* 376 377* 377 452 536 542 548 709
                                                                                  869
message_code              2     000114 automatic       fixed bin(17,0)          level 2 dcl 34 set ref 579* 664* 750*
message_ids                            based           structure                array level 1 dcl 36
message_ids_ptr                 000146 automatic       pointer                  dcl 40 set ref 429* 519* 694 695 723 723 864 865*
                                                                                  866*
message_idx                     000412 automatic       fixed bin(17,0)          dcl 78 set ref 721* 723 723*
message_segment_$close          000076 constant        entry                    external dcl 153 ref 495 678 871
message_segment_$get_message_count_index
                                000100 constant        entry                    external dcl 154 ref 501
message_segment_$get_mode_index 000102 constant        entry                    external dcl 155 ref 484
message_segment_$open           000104 constant        entry                    external dcl 156 ref 478
message_segment_$read_message_index
                                000106 constant        entry                    external dcl 157 ref 581 668 754
ms_id                     7     000114 automatic       bit(72)                  level 2 dcl 34 set ref 591 666* 694 752* 774
ms_ptr                    4     000114 automatic       pointer                  level 2 dcl 34 set ref 594 768
mseg_message_info                      based           structure                level 1 dcl 2-9
msg_time                               based           fixed bin(71,0)          level 3 dcl 1-16 set ref 645* 649* 774* 775* 782*
                                                                                  784*
n_arguments                     000162 automatic       fixed bin(17,0)          dcl 47 set ref 168* 179 206 396 623
n_selections                    000165 automatic       structure                level 1 dcl 49 set ref 181*
notify                   66(01)        based           bit(1)                   level 4 packed packed unaligned dcl 1-16 ref 825
null                                                   builtin function         dcl 164 ref 342 342 429 634 634 660 837 859 861 864
                                                                                  866
opened_a_queue                  000253 automatic       bit(1)                   dcl 63 set ref 451* 454* 456
output_mode                     000255 automatic       fixed bin(2,0)           dcl 65 set ref 186* 260* 261* 262* 348 362 363 719
                                                                                  730 790 795
own                       3     000114 automatic       bit(1)                   level 3 packed packed unaligned dcl 34 set ref 445*
p_arg_description                      parameter       char                     packed unaligned dcl 390 set ref 387 397*
p_argument                             parameter       char                     packed unaligned dcl 391 set ref 387 410 411 411
                                                                                  416*
p_message_id                           parameter       bit(72)                  dcl 740 set ref 736 752 762*
p_position                             parameter       fixed bin(17,0)          dcl 739 set ref 736 795* 809*
p_queue                                parameter       fixed bin(17,0)          dcl 739 set ref 736 754 762*
p_queue_number                         parameter       fixed bin(17,0)          dcl 471 in procedure "open_single_queue" set ref 468
                                                                                  476 478 484 492* 495 496 501 501
p_queue_number                         parameter       fixed bin(17,0)          dcl 567 in procedure "scan_single_queue" set ref 564
                                                                                  581 668 677* 678 679 690 690 697 697
path                            000165 automatic       fixed bin(17,0)          level 2 dcl 49 set ref 340* 340 366 527 529
path_output_mode                000256 automatic       fixed bin(2,0)           dcl 65 set ref 187* 265* 266* 348 350 350 362 362*
                                                                                  790 795 812 812
pathname_                       000110 constant        entry                    external dcl 158 ref 337 337 480 480 486 486 503 503
                                                                                  795 795 812 812 816 816
person_id                       000272 automatic       char(32)                 packed unaligned dcl 67 set ref 288* 290 290* 437*
                                                                                  602 602 614 614
position                  2            based           fixed bin(17,0)          array level 2 in structure "message_ids" dcl 36
                                                                                  in procedure "lir" set ref 695* 723*
position                        000204 automatic       fixed bin(17,0)          dcl 570 in procedure "scan_single_queue" set ref
                                                                                  575* 592* 592 695
position_mode                   000260 automatic       fixed bin(2,0)           dcl 65 set ref 189* 271* 272* 348 356 356 364 364*
                                                                                  436 441 600 612 790 795 809
previous_message_id             000206 automatic       bit(72)                  dcl 571 set ref 591* 666
process_selections              000170 automatic       bit(1)                   dcl 53 set ref 527* 621
project_id                      000302 automatic       char(32)                 packed unaligned dcl 67 set ref 289* 291 291* 438*
                                                                                  604 604 616 616
queue                           000227 automatic       fixed bin(17,0)          dcl 61 set ref 184* 247* 254 254 257* 375 375* 376
                                                                                  377* 450 460* 461
queue_ename                     000154 automatic       char(32)                 packed unaligned dcl 472 set ref 476* 478* 480* 480*
                                                                                  486* 486* 503* 503*
queue_idx                       000232 automatic       fixed bin(17,0)          dcl 61 set ref 452* 453* 454* 536* 537 537* 542*
                                                                                  543* 548* 549 549* 549 549 549 549 549* 709* 711
                                                                                  713 713 713* 713 713 713 713 713 721 721 721 723*
                                                                                  869* 870 871 872*
queue_indeces                   000207 automatic       fixed bin(17,0)          array dcl 60 set ref 428* 454 461 478* 484* 495*
                                                                                  496* 501* 537 549 581* 668* 678* 679* 711 754* 870
                                                                                  871* 872*
queue_mode                      000164 automatic       bit(36)                  dcl 474 set ref 484* 491 500
queue_msg_hdr                          based           structure                level 1 dcl 3-12
queue_msg_hdr_version_1                constant        fixed bin(17,0)          initial dcl 3-37 ref 598 772
queue_picture                          automatic       picture(1)               packed unaligned dcl 473 ref 476
queue_string                    000243 automatic       char(32)                 packed unaligned dcl 62 set ref 246* 247* 249*
release_temp_segment_           000112 constant        entry                    external dcl 159 ref 865
remote                          000206 automatic       bit(1)                   dcl 59 set ref 216* 221* 224 230* 234* 239* 377*
request                  76            based           structure                level 2 dcl 1-16
request_id                      000403 automatic       varying char(19)         dcl 74 set ref 308* 309 310* 315 316 318
request_id_                     000114 constant        entry                    external dcl 160 ref 782
request_id_nonvarying           000376 automatic       char(19)                 packed unaligned dcl 73 set ref 307* 308
request_type                    000172 automatic       char(24)                 packed unaligned dcl 57 set ref 183* 224* 224 226*
                                                                                  226 228* 372* 377* 476 492* 545* 549* 677* 713*
                                                                                  762*
request_uid                     000210 automatic       bit(36)                  dcl 572 set ref 636* 638* 639 639 641
retry_read                      000211 automatic       bit(1)                   dcl 573 in procedure "scan_single_queue" set ref
                                                                                  577* 582 584* 662* 669 671*
retry_read                      000256 automatic       bit(1)                   dcl 746 in procedure "display_single_request" set
                                                                                  ref 748* 755 757*
rtrim                                                  builtin function         dcl 164 ref 308 476 596 770
selected_requests               000217 automatic       fixed bin(17,0)          array dcl 60 set ref 517* 540 690* 690 713 713* 713
                                                                                  721
selection_types                 000100 automatic       fixed bin(2,0)           array dcl 195 set ref 198* 303* 320* 341* 624 626
                                                                                  626 628 632
sender_id                13     000114 automatic       char(32)                 level 2 packed packed unaligned dcl 34 set ref 596
                                                                                  596 770 770
short_id_string                 000254 automatic       char(8)                  packed unaligned dcl 745 set ref 783* 795* 810*
state                    67            based           fixed bin(17,0)          level 3 dcl 1-16 set ref 780 780 780* 795 795 815
status_branch                          based           structure                level 1 dcl 4-8
substr                                                 builtin function         dcl 164 ref 224 226 596 770 783
sum                                                    builtin function         dcl 164 ref 540
supported_version               000257 automatic       bit(1)                   dcl 746 set ref 773* 779* 795 807
system_area                            based           area(1024)               dcl 30 ref 658 836 860
system_area_ptr                 000100 automatic       pointer                  dcl 31 set ref 426* 581* 658 668* 754* 836 860
the_argument_list               000152 automatic       pointer                  dcl 45 set ref 174* 208* 404* 529* 625*
time_queued_string              000240 automatic       char(24)                 packed unaligned dcl 743 set ref 775* 784* 803* 811*
                                                                                  830*
total_message_ids               000150 automatic       fixed bin(17,0)          dcl 41 set ref 525* 692* 692 694 695 697
total_requests                  000213 automatic       fixed bin(17,0)          array dcl 60 set ref 448* 501* 543 549 549 549 549*
                                                                                  549 713 713 713* 713
uid                      11     000102 automatic       bit(36)                  level 3 packed packed unaligned dcl 33 set ref 343
                                                                                  636
unspec                                                 builtin function         dcl 164 set ref 431* 774*
update                  172(11)        based           bit(1)                   level 4 packed packed unaligned dcl 1-16 ref 826
user_id                         000230 automatic       char(30)                 packed unaligned dcl 742 in procedure
                                                                                  "display_single_request" set ref 770* 795* 803*
                                                                                  808* 829*
user_id                         000174 automatic       char(30)                 packed unaligned dcl 569 in procedure
                                                                                  "scan_single_queue" set ref 596* 602 604 614 616
user_id                         000262 automatic       char(32)                 packed unaligned dcl 67 in procedure "lir" set ref
                                                                                  277* 278 279* 282 282 283 283 288 289
user_selection                  000261 automatic       fixed bin(2,0)           dcl 65 set ref 190* 274* 275* 284* 287* 436 441 600
                                                                                  601 612 613 790 795 803 808
verify                                                 builtin function         dcl 164 ref 309
version                         000114 automatic       char(8)                  level 2 in structure "local_mmi" dcl 34 in procedure
                                                                                  "lir" set ref 432*
version                  76            based           char(8)                  level 3 in structure "ft_request" dcl 1-16
                                                                                  in procedure "lir" ref 598 772

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALWAYS_CHASE                           internal static bit(2)                   initial dcl 1-47
DEFAULT_CHASE                          internal static bit(2)                   initial dcl 1-47
Directory                              internal static fixed bin(17,0)          initial dcl 4-56
FT_MESSAGE_TYPE                        internal static fixed bin(17,0)          initial dcl 1-41
Link                                   internal static fixed bin(17,0)          initial dcl 4-56
MERGE_DIRECTORIES                      internal static bit(2)                   initial dcl 1-43
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 2-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 2-38
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 2-30
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 2-38
NEVER_CHASE                            internal static bit(2)                   initial dcl 1-47
READ_NEXT_MESSAGE                      internal static bit(2)                   initial dcl 123
STATE_BUMPED                           internal static fixed bin(17,0)          initial dcl 3-46
STATE_DEFERRED                         internal static fixed bin(17,0)          initial dcl 3-42
STATE_DUPT                             internal static fixed bin(17,0)          initial dcl 3-47
STATE_ELIGIBLE                         internal static fixed bin(17,0)          initial dcl 3-44
STATE_TRANSITION                       internal static fixed bin(17,0)          initial dcl 3-43
Segment                                internal static fixed bin(17,0)          initial dcl 4-56
mseg_message_info_ptr                  automatic       pointer                  dcl 2-7
status_area_ptr                        automatic       pointer                  dcl 4-47
status_entry_names                     based           char(32)                 array dcl 4-47
status_link                            based           structure                level 1 dcl 4-38
status_pathname                        based           char                     dcl 4-47
status_ptr                             automatic       pointer                  dcl 4-47

NAMES DECLARED BY EXPLICIT CONTEXT.
ABORT_ARGUMENT_PARSE            010063 constant        label                    dcl 850 ref 399 407 413
FOREIGN_SYSTEM                  001465 constant        label                    dcl 222 ref 217
INVALID_DESTINATION_SPECIFICATION
                                001566 constant        label                    dcl 230 ref 373
INVALID_QUEUE_SPECIFICATION     002005 constant        label                    dcl 249 ref 254
INVALID_REQUEST_ID              002662 constant        label                    dcl 310 ref 315 316 318
MAIN_LIR_BLOCK                  001273 constant        label                    dcl 192
READ_THE_MESSAGE                006504 constant        label                    dcl 750 ref 758
RETRY_FIRST_READ                005522 constant        label                    dcl 579 ref 585
RETRY_READ_NEXT_MESSAGE         006327 constant        label                    dcl 664 ref 672
RETURN_FROM_LIST_IMFT_REQUESTS  010057 constant        label                    dcl 847 ref 456 461 481 488 522 557
SKIP_THIS_MESSAGE               006320 constant        label                    dcl 658 ref 602 604 609 614 616 653
add_this_message                006453 constant        entry                    internal dcl 687 ref 608 656
cleanup_handler                 010065 constant        entry                    internal dcl 856 ref 434 847
display_single_request          006501 constant        entry                    internal dcl 736 ref 723
get_next_argument               004603 constant        entry                    internal dcl 387 ref 222 246 277 296 307
lir                             001154 constant        entry                    external dcl 26
list_imft_requests              001163 constant        entry                    external dcl 26
open_single_queue               005036 constant        entry                    internal dcl 468 ref 453 460
scan_single_queue               005516 constant        entry                    internal dcl 564 ref 537

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11046       11164   10377       11056
Length     11602   10377       116         401     447           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lir                                 291 external procedure  is an external procedure.  
begin block on line 192             778 begin block         uses auto adjustable storage, and enables or reverts conditions.  
get_next_argument                       internal procedure  shares stack frame of begin block on line 192.  
on unit on line 434                  64 on unit               
open_single_queue                       internal procedure  shares stack frame of begin block on line 192.  
scan_single_queue                       internal procedure  shares stack frame of begin block on line 192.  
add_this_message                        internal procedure  shares stack frame of begin block on line 192.  
display_single_request                  internal procedure  shares stack frame of begin block on line 192.  
cleanup_handler                      80 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 192  000100 selection_types             begin block on line 192
                         000100 dir_uids                    begin block on line 192
                         000136 control_argument            get_next_argument
                         000154 queue_ename                 open_single_queue
                         000164 queue_mode                  open_single_queue
                         000174 user_id                     scan_single_queue
                         000204 position                    scan_single_queue
                         000206 previous_message_id         scan_single_queue
                         000210 request_uid                 scan_single_queue
                         000211 retry_read                  scan_single_queue
                         000212 matches                     scan_single_queue
                         000230 user_id                     display_single_request
                         000240 time_queued_string          display_single_request
                         000246 long_id_string              display_single_request
                         000254 short_id_string             display_single_request
                         000256 retry_read                  display_single_request
                         000257 supported_version           display_single_request
lir                      000100 system_area_ptr             lir
                         000102 local_sb                    lir
                         000114 local_mmi                   lir
                         000146 message_ids_ptr             lir
                         000150 total_message_ids           lir
                         000152 the_argument_list           lir
                         000154 argument_ptr                lir
                         000156 id_qualifier_ptr            lir
                         000160 argument_lth                lir
                         000161 id_qualifier_lth            lir
                         000162 n_arguments                 lir
                         000163 id_qualifier_idx            lir
                         000164 argument_idx                lir
                         000165 n_selections                lir
                         000170 process_selections          lir
                         000171 array_bound                 lir
                         000172 request_type                lir
                         000200 foreign_system              lir
                         000206 remote                      lir
                         000207 queue_indeces               lir
                         000213 total_requests              lir
                         000217 selected_requests           lir
                         000223 first_id_indeces            lir
                         000227 queue                       lir
                         000230 default_queue               lir
                         000231 max_queues                  lir
                         000232 queue_idx                   lir
                         000233 generic_type                lir
                         000243 queue_string                lir
                         000253 opened_a_queue              lir
                         000254 all_queues_empty            lir
                         000255 output_mode                 lir
                         000256 path_output_mode            lir
                         000257 id_output_mode              lir
                         000260 position_mode               lir
                         000261 user_selection              lir
                         000262 user_id                     lir
                         000272 person_id                   lir
                         000302 project_id                  lir
                         000312 match_any_person            lir
                         000313 match_any_project           lir
                         000314 a_dirname                   lir
                         000366 an_ename                    lir
                         000376 request_id_nonvarying       lir
                         000403 request_id                  lir
                         000411 access_required             lir
                         000412 message_idx                 lir
                         000413 first_message_in_queue      lir
                         000414 code                        lir
                         000416 ft_request_ptr              lir

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars   enter_begin_block
leave_begin_block   call_ext_out_desc   call_ext_out        call_int_this       call_int_other      begin_return_mac
return_mac          tra_ext_1           alloc_auto_adj      enable_op           shorten_stack       ext_entry
int_entry           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
check_star_name_$entry        com_err_                      cu_$arg_count                 cu_$arg_list_ptr
cu_$arg_ptr_rel               cv_dec_check_                 date_time_                    expand_pathname_
get_group_id_                 get_system_free_area_         get_temp_segment_             hcs_$status_long
imft_default_rqt_             ioa_                          iod_info_$generic_type        iod_info_$queue_data
match_request_id_             match_star_name_              message_segment_$close
message_segment_$get_message_count_index                    message_segment_$get_mode_index
message_segment_$open         message_segment_$read_message_index                         pathname_
release_temp_segment_         request_id_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_segment      error_table_$badopt           error_table_$id_not_found     error_table_$inconsistent
error_table_$moderr           error_table_$no_message       error_table_$no_s_permission  error_table_$noarg
imft_data_$queue_dirname




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     26 001153       168 001170       169 001200       170 001202       171 001217       174 001220       179 001227
    181 001234       183 001237       184 001260       186 001263       187 001265       188 001267       189 001270
    190 001271       192 001273       195 001276       196 001303       198 001307       199 001322       200 001333
    206 001335       208 001346       209 001365       210 001370       211 001423       214 001425       216 001451
    217 001452       220 001453       221 001463       222 001465       224 001505       226 001526       228 001542
    229 001563       230 001566       234 001630       236 001663       238 001665       239 001671       241 001726
    243 001730       245 001731       246 001741       247 001757       248 002003       249 002005       252 002036
    254 002040       255 002045       257 002046       260 002061       261 002074       262 002107       265 002126
    266 002141       268 002154       269 002167       271 002202       272 002215       274 002230       275 002237
    276 002252       277 002256       278 002276       279 002335       280 002365       282 002367       283 002407
    284 002427       287 002435       288 002437       289 002443       290 002450       291 002457       293 002466
    295 002467       296 002477       297 002520       298 002536       299 002545       300 002573       302 002575
    303 002576       304 002602       306 002603       307 002607       308 002626       309 002647       310 002662
    313 002714       315 002716       316 002755       318 002765       319 002770       320 002771       321 002775
    322 003001       325 003002       326 003034       327 003036       330 003037       331 003067       332 003072
    333 003124       335 003126       336 003143       337 003152       338 003214       340 003216       341 003217
    342 003223       343 003263       346 003275       348 003300       350 003311       353 003346       356 003404
    359 003442       362 003444       363 003450       364 003454       366 003460       367 003466       369 003512
    372 003514       373 003540       375 003543       376 003547       377 003551       380 003624       426 003626
    428 003635       429 003647       431 003652       432 003655       434 003657       436 003701       437 003710
    438 003730       441 003733       444 003744       445 003746       448 003750       450 003762       451 003765
    452 003766       453 003776       454 004004       455 004012       456 004014       457 004021       460 004022
    461 004030       516 004037       517 004051       519 004063       520 004104       521 004107       522 004133
    525 004136       527 004137       529 004145       532 004173       533 004175       536 004176       537 004210
    538 004220       540 004223       541 004243       542 004245       543 004260       544 004263       545 004265
    548 004310       549 004320       554 004403       555 004406       557 004417       709 004422       711 004432
    713 004434       719 004521       720 004525       721 004527       723 004542       725 004556       728 004561
    730 004563       843 004601       387 004603       394 004621       396 004627       397 004632       399 004672
    402 004675       404 004676       405 004715       406 004720       407 004753       410 004756       411 004761
    413 005023       416 005026       418 005035       468 005036       476 005040       478 005121       479 005151
    480 005154       481 005226       484 005231       485 005246       486 005251       488 005322       491 005325
    492 005331       495 005376       496 005413       497 005417       500 005420       501 005424       503 005441
    508 005515       564 005516       575 005520       577 005521       579 005522       581 005525       582 005546
    584 005555       585 005557       589 005560       591 005563       592 005566       594 005567       596 005571
    598 005606       600 005616       601 005624       602 005627       604 005644       608 005667       609 005670
    612 005671       613 005677       614 005702       616 005717       621 005742       622 005744       623 005745
    624 005761       625 005764       626 006004       628 006014       630 006050       631 006055       632 006103
    634 006113       636 006157       638 006170       639 006171       641 006203       643 006217       644 006220
    645 006222       647 006256       649 006257       652 006311       653 006314       656 006317       658 006320
    660 006323       662 006326       664 006327       666 006332       668 006335       669 006356       671 006365
    672 006367       674 006370       676 006371       677 006375       678 006431       679 006446       682 006452
    687 006453       690 006454       692 006460       694 006461       695 006471       697 006473       699 006500
    736 006501       748 006503       750 006504       752 006507       754 006515       755 006535       757 006544
    758 006546       761 006547       762 006552       765 006615       768 006616       770 006620       772 006635
    773 006645       774 006646       775 006652       776 006667       779 006670       780 006672       782 006700
    783 006711       784 006714       787 006732       788 006735       789 006736       790 006747       795 007020
    803 007176       807 007233       808 007235       809 007262       810 007312       811 007347       812 007367
    815 007472       816 007517       819 007567       820 007617       823 007650       824 007672       825 007714
    826 007736       827 007760       829 007761       830 010003       831 010023       833 010037       836 010050
    837 010053       839 010056       847 010057       850 010063       856 010064       859 010072       860 010077
    861 010101       864 010104       865 010110       866 010132       869 010135       870 010146       871 010150
    872 010163       874 010166       876 010170


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
