	COMPILATION LISTING OF SEGMENT task_create_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/05/86  1104.2 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* format: style4,delnl,insnl,tree,ifthenstmt,indnoniterend */
       12 task_create_:
       13      procedure (Task_create_data_ptr, Task_data_ptr, Code);
       14 
       15 dcl  Task_create_data_ptr ptr parameter;
       16 dcl  Task_data_ptr ptr parameter;
       17 dcl  Code fixed bin (35) parameter;
       18 
       19 dcl  1 abort_label_overlay aligned based (addr (task_data.abort)),
       20        2 code_ptr ptr,
       21        2 env_ptr ptr;
       22 dcl  1 defptr_overlay aligned based,			/* overlays defptr in active linkage section */
       23        2 pad1 bit (29) unaligned,
       24        2 pps_sw bit (1) unaligned,
       25        2 pad2 bit (6) unaligned;
       26 dcl  based_ptr ptr based;
       27 dcl  based_words (stack_header.cur_lot_size) fixed bin (35) based;
       28 dcl  task_area area based (task_data.task_area_ptr);
       29 
       30 dcl  active_all_rings_data$hcscnt fixed bin (15) external;
       31 dcl  error_table_$unimplemented_version fixed bin (35) ext static;
       32 dcl  sys_info$max_seg_size fixed bin (19) ext static;
       33 
       34 dcl  define_area_ entry (ptr, fixed bin (35));
       35 dcl  get_temp_segment_ entry (char (*), ptr, fixed bin (35));
       36 dcl  ioa_$rsnnl entry () options (variable);
       37 dcl  iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35));
       38 dcl  task_alm_$task_overseer_tv entry;
       39 dcl  task_cl_intermediary_ entry;
       40 dcl  task_ctl_$death entry;
       41 
       42 dcl  task_name char (13);
       43 dcl  segno fixed bin (15);
       44 dcl  1 ai aligned like area_info;
       45 
       46 dcl  size builtin;
       47 
       48 	Task_data_ptr = null ();
       49 	Code = 0;
       50 
       51 	call get_temp_segment_ ("task_ctl_", sb, Code);	/* get a stack segment */
       52 	if Code ^= 0 then return;
       53 	task_data_ptr = pointer (sb, size (stack_header));
       54 	sp = addrel16 (task_data_ptr, size (task_data));
       55 	task_data.create_data = Task_create_data_ptr -> task_create_data;
       56 
       57 	if task_data.create_data.version = 2 then do;	/* upgrade from 2 to 3 */
       58 	     task_data.create_data.version = 3;
       59 	     string (task_data.create_data.flags) = ""b;
       60 	     task_data.create_data.top_level, task_data.create_data.shared_static = "1"b;
       61 	     end;
       62 
       63 	if task_data.create_data.version ^= task_create_data_version_3 then do;
       64 	     Code = error_table_$unimplemented_version;
       65 	     return;
       66 	     end;
       67 
       68 	if task_data.create_data.flags.top_level
       69 	then task_data.mother = addr (tasking_data.root_task_data);
       70 	else task_data.mother = pointer (stackbaseptr (), TASK_DP) -> based_ptr;
       71 
       72 	stack_header = task_data.mother -> task_data.sb -> stack_header;
       73 	stack_header.stack_begin_ptr, stack_header.bar_mode_sp = sp;
       74 	stack_header.stack_end_ptr = addrel16 (sp, (stack_frame_min_length));
       75 
       76 	if task_data.create_data.flags.shared_static	/* create new linkage area if necessary */
       77 	then task_data.task_area_ptr = null ();
       78 	else do;
       79 	     ai.version = area_info_version_1;
       80 	     string (ai.control) = ""b;
       81 	     ai.control.extend, ai.control.zero_on_alloc = "1"b;
       82 	     ai.owner = "task_create_";
       83 	     ai.size = sys_info$max_seg_size;
       84 	     ai.areap = null ();
       85 	     call define_area_ (addr (ai), Code);
       86 	     if Code ^= 0 then return;
       87 
       88 	     stack_header.combined_stat_ptr, stack_header.clr_ptr, stack_header.user_free_ptr, task_data.task_area_ptr =
       89 		ai.areap;
       90 
       91 	     allocate based_words in (task_area) set (lotp);
       92 	     allocate based_words in (task_area) set (isotp);
       93 	     lotp -> based_words = stack_header.lot_ptr -> based_words;
       94 	     isotp -> based_words = stack_header.isot_ptr -> based_words;
       95 	     do segno = active_all_rings_data$hcscnt + 1 to stack_header.cur_lot_size - 1;
       96 		if unspec (lot.lp (segno)) = ""b then unspec (lot.lp (segno)) = lot_fault;
       97 		if unspec (lot.lp (segno)) ^= lot_fault
       98 		then if ^lot.lp (segno) -> defptr_overlay.pps_sw then unspec (lot.lp (segno)) = lot_fault;
       99 	     end;
      100 	     stack_header.lot_ptr = lotp;
      101 	     stack_header.isot_ptr = isotp;
      102 	     end;
      103 
      104 	stack_frame.prev_sp = null ();
      105 	stack_frame.next_sp = stack_header.stack_end_ptr;
      106 	stack_frame.return_ptr = codeptr (task_alm_$task_overseer_tv);
      107 	stack_frame.operator_and_lp_ptr, stack_frame.arg_ptr = null ();
      108 	stack_frame.translator_id = "000001"b3;
      109 
      110 	pointer (sb, TASK_DP) -> based_ptr = task_data_ptr;
      111 
      112 	task_data.state = STOPPED;
      113 	task_data.sb = sb;
      114 	task_data.task_id = baseno (sb) || substr (bit (clock (), 72), 55, 18);
      115 	abort_label_overlay.code_ptr = codeptr (task_ctl_$death);
      116 	abort_label_overlay.env_ptr = stack_header.stack_begin_ptr;
      117 
      118 	task_data.youngest_daughter, task_data.elder_sister, task_data.younger_sister, task_data.ready_next,
      119 	     task_data.ready_last = null ();
      120 
      121 	call ioa_$rsnnl ("^w.", task_name, (0), task_data.task_id);
      122 	call iox_$attach_name (task_name || "user_input", task_data.ui_iocb, "syn_ user_i/o -inh close put_chars",
      123 	     null (), Code);
      124 	call iox_$attach_name (task_name || "user_output", task_data.uo_iocb,
      125 	     "syn_ user_i/o -inh close get_chars get_line", null (), Code);
      126 	call iox_$attach_name (task_name || "error_output", task_data.eo_iocb,
      127 	     "syn_ user_i/o -inh close get_chars get_line", null (), Code);
      128 
      129 	task_data.cl_intermediary = task_cl_intermediary_;
      130 	task_data.ips_mask = "777777777777"b3;
      131 
      132 	Task_data_ptr = task_data_ptr;
      133 	return;
      134 
      135 
      136 
      137 addrel16:
      138      procedure (Ptr, Offset) returns (ptr);
      139 dcl  Ptr ptr parameter;
      140 dcl  Offset fixed bin parameter;
      141 dcl  offset uns fixed bin (18);
      142 
      143 	offset = binary (rel (Ptr), 18) + Offset + 15;
      144 	return (pointer (Ptr, offset - mod (offset, 16)));
      145 
      146      end addrel16;
      147 
  1     1 /* ***********************************************************
  1     2*   *                                                         *
  1     3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
  1     4*   *                                                         *
  1     5*   *********************************************************** */
  1     6 /* Begin include file tasking_data.incl.pl1 */
  1     7 
  1     8 dcl  tasking_data_ptr_ ptr external init (null ());
  1     9 dcl  1 tasking_data aligned based (tasking_data_ptr_),
  1    10        2 (ready_head, ready_tail) ptr init (null ()),
  1    11        2 root_task_data like task_data,
  1    12        2 overhead_meters like task_data.meters,
  1    13        2 old_pu like task_data.meters,
  1    14        2 flags,
  1    15          3 dead_tasks bit (1) unaligned,
  1    16        2 valid_tasks (0:4092) bit (1) unaligned init ((4093) (1)"0"b);
  1    17 
  2     1 /* ***********************************************************
  2     2*   *                                                         *
  2     3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
  2     4*   *                                                         *
  2     5*   *********************************************************** */
  2     6 /* Begin include file task_data.incl.pl1 */
  2     7 
  2     8 declare task_data_ptr pointer automatic;
  2     9 declare 1 task_data aligned based (task_data_ptr),	/* information defining a task */
  2    10 	2 sb pointer,				/* stack base pointer */
  2    11 	2 abort variable label,			/* to abort task */
  2    12 	2 (elder_sister, younger_sister) pointer,	/* threaded list of all tasks */
  2    13 	2 (youngest_daughter, mother) pointer,		/* our inferiors */
  2    14 	2 (ready_next, ready_last) pointer,		/* list of ready tasks */
  2    15 	2 task_id bit (36) aligned,
  2    16 	2 state fixed bin,
  2    17 	2 create_data like task_create_data,
  2    18 	2 meters,
  2    19 	  3 (tcpu, vcpu) fixed bin (71),
  2    20 	  3 mem fixed bin (71),
  2    21 	  3 pf fixed bin (35),
  2    22 	2 (ui_iocb, uo_iocb, eo_iocb) ptr,
  2    23 	2 task_area_ptr ptr,
  2    24 	2 cl_intermediary entry,
  2    25 	2 ips_mask bit (36);
  2    26 
  2    27 declare (
  2    28         TASK_DP init (56),
  2    29         STOPPED init (1),
  2    30         BLOCKED init (2),
  2    31         READY init (3),
  2    32         DEAD init (4)
  2    33         ) static options (constant);
  2    34 
  2    35 /* End include file task_data.incl.pl1 */
  1    18 
  3     1 /* ***********************************************************
  3     2*   *                                                         *
  3     3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
  3     4*   *                                                         *
  3     5*   *********************************************************** */
  3     6 /* Begin include file task_create_data.incl.pl1 */
  3     7 
  3     8 declare  task_create_data_version_3 fixed bin static init (3) options (constant);
  3     9 declare  task_create_data_ptr pointer automatic;
  3    10 declare 1 task_create_data aligned based (task_create_data_ptr),
  3    11         2 version fixed bin,				/* this is version 3 */
  3    12         2 overseer variable entry (pointer),
  3    13         2 data_ptr pointer,				/* pointer to be passed to overseer */
  3    14         2 vcpu_limit fixed bin (71),			/* CPU limit if any */
  3    15         2 priority fixed bin,				/* for task scheduler */
  3    16         2 comment char (64),				/* for humans */
  3    17 						/* end of version 2 structure */
  3    18         2 flags,
  3    19           3 top_level bit (1) unaligned,		/* this is an independent task */
  3    20 	3 shared_static bit (1) unaligned;		/* shares static with creator */
  3    21 
  3    22 /* End include file task_create_data.incl.pl1 */
  1    19 
  1    20 
  1    21 /* End include file tasking_data */
      148 
  4     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  4     2 
  4     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  4     4 
  4     5 dcl  area_infop ptr;
  4     6 
  4     7 dcl 1 area_info aligned based (area_infop),
  4     8     2 version fixed bin,				/* version number for this structure is 1 */
  4     9     2 control aligned like area_control,		/* control bits for the area */
  4    10     2 owner char (32) unal,				/* creator of the area */
  4    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  4    12     2 size fixed bin (18),				/* size of the area in words */
  4    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  4    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  4    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  4    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  4    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  4    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  4    19 
  4    20 dcl 1 area_control aligned based,
  4    21     2 extend bit (1) unal,				/* says area is extensible */
  4    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  4    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  4    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  4    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  4    26     2 system bit (1) unal,				/* says area is managed by system */
  4    27     2 pad bit (30) unal;
  4    28 
  4    29 /* END INCLUDE FILE area_info.incl.pl1 */
      149 
  5     1 /* BEGIN INCLUDE FILE linkdcl.incl.pl1 --- last modified 15 Nov 1971 by C Garman */
  5     2 
  5     3 /* Last Modified (Date and Reason):
  5     4*   6/75 by M.Weaver to add virgin_linkage_header declaration
  5     5*   6/75 by S.Webber to comment existing structures better
  5     6*   9/77 by M. Weaver to add run_depth to link
  5     7*   2/83 by M. Weaver to add linkage header flags and change run_depth precision
  5     8**/
  5     9 
  5    10 /* format: style3 */
  5    11 dcl	1 link		based aligned,		/* link pair in linkage section */
  5    12 	  2 head_ptr	bit (18) unal,		/* rel pointer to beginning of linkage section */
  5    13 	  2 ringno	bit (3) unal,
  5    14 	  2 mbz		bit (6) unal,
  5    15 	  2 run_depth	fixed bin (2) unal,		/* run unit depth, filled when link is snapped */
  5    16 	  2 ft2		bit (6) unal,		/* fault tag. 46(8) if not snapped, 43(8) if snapped */
  5    17 	  2 exp_ptr	bit (18) unal,		/* pointer (rel to defs) of expression word */
  5    18 	  2 mbz2		bit (12) unal,
  5    19 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  5    20 
  5    21 dcl	1 exp_word	based aligned,		/* expression word in link definition */
  5    22 	  2 type_ptr	bit (18) unal,		/* pointer (rel to defs) of type pair structure */
  5    23 	  2 exp		bit (18) unal;		/* constant expression to be added in when snapping link */
  5    24 
  5    25 dcl	1 type_pair	based aligned,		/* type pair in link definition */
  5    26 	  2 type		bit (18) unal,		/* type of link. may be 1,2,3,4,5, or 6 */
  5    27 	  2 trap_ptr	bit (18) unal,		/* pointer (rel to defs) to the trap word */
  5    28 	  2 seg_ptr	bit (18) unal,		/* pointer to ACC reference name for segment referenced */
  5    29 	  2 ext_ptr	bit (18) unal;		/* pointer (rel to defs)  of ACC segdef name */
  5    30 
  5    31 dcl	1 header		based aligned,		/* linkage block header */
  5    32 	  2 def_ptr	ptr,			/* pointer to definition section */
  5    33 	  2 symbol_ptr	ptr unal,			/* pointer to symbol section in object segment */
  5    34 	  2 original_linkage_ptr
  5    35 			ptr unal,			/* pointer to linkage section in object segment */
  5    36 	  2 unused	bit (72),
  5    37 	  2 stats,
  5    38 	    3 begin_links	bit (18) unal,		/* offset (rel to this section) of first link */
  5    39 	    3 block_length	bit (18) unal,		/* number of words in this linkage section */
  5    40 	    3 segment_number
  5    41 			bit (18) unal,		/* text segment number associated with this section */
  5    42 	    3 static_length bit (18) unal;		/* number of words of static for this segment */
  5    43 
  5    44 dcl	1 linkage_header_flags
  5    45 			aligned based,		/* overlay of def_ptr for flags */
  5    46 	  2 pad1		bit (28) unaligned,		/* flags are in first word */
  5    47 	  2 static_vlas	bit (1) unaligned,		/* static section "owns" some LA/VLA segments */
  5    48 	  2 perprocess_static
  5    49 			bit (1) unaligned,		/* 1 copy of static section is used by all tasks/run units */
  5    50 	  2 pad2		bit (6) unaligned;
  5    51 
  5    52 dcl	1 virgin_linkage_header
  5    53 			aligned based,		/* template for linkage header in object segment */
  5    54 	  2 pad		bit (30) unaligned,		/* is filled in by linker */
  5    55 	  2 defs_in_link	bit (6) unaligned,		/* =o20 if defs in linkage (nonstandard) */
  5    56 	  2 def_offset	bit (18) unaligned,		/* offset of definition section */
  5    57 	  2 first_ref_relp	bit (18) unaligned,		/* offset of trap-at-first-reference offset array */
  5    58 	  2 filled_in_later bit (144),
  5    59 	  2 link_begin	bit (18) unaligned,		/* offset of first link */
  5    60 	  2 linkage_section_lng
  5    61 			bit (18) unaligned,		/* length of linkage section */
  5    62 	  2 segno_pad	bit (18) unaligned,		/* will be segment number of copied linkage */
  5    63 	  2 static_length	bit (18) unaligned;		/* length of static section */
  5    64 
  5    65 
  5    66 dcl	1 trap_word	based aligned,		/* trap word in link definition */
  5    67 	  2 call_ptr	bit (18) unal,		/* pointer (rel to link) of link to trap procedure */
  5    68 	  2 arg_ptr	bit (18) unal;		/* pointer (rel to link) of link to arg info for trap proc */
  5    69 
  5    70 dcl	1 name		based aligned,		/* storage of ASCII names in definitions */
  5    71 	  2 nchars	bit (9) unaligned,		/* number of characters in name */
  5    72 	  2 char_string	char (31) unaligned;	/* 31-character name */
  5    73 
  5    74 /* END INCLUDE FILE linkdcl.incl.pl1 */
      150 
  6     1 /* BEGIN INCLUDE FILE --  lot.incl.pl1   S.Webber 9/74, Modified by R. Bratt 04/76, modified by M. Weaver 7/76 */
  6     2 /* modified by M. Weaver 3/77 */
  6     3 
  6     4 dcl  lotp ptr;
  6     5 
  6     6 dcl 1 lot based (lotp) aligned,
  6     7     2 lp (0:9999) ptr unaligned;			/* array of packed pointers to linkage sections */
  6     8 
  6     9 dcl lot_fault bit (36) aligned static options (constant) init ("111000000000000000000000000000000000"b);
  6    10 						/* lot fault has fault code = 0 and offset = 0 */
  6    11 
  6    12 dcl  isotp ptr;
  6    13 dcl 1 isot based (isotp) aligned,
  6    14     2 isp (0:9999) ptr unaligned;
  6    15 
  6    16 dcl 1 isot1 (0 :9999) aligned based,
  6    17     2 flags unaligned,
  6    18       3 fault bit (2) unaligned,
  6    19       3 system bit (1) unaligned,
  6    20       3 mbz bit (6) unaligned,
  6    21     2 fault_code fixed bin (8) unaligned,
  6    22     2 static_offset bit (18) unaligned;
  6    23 
  6    24 
  6    25 /* END INCLUDE FILE  lot.incl.pl1 */
      151 
  7     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  7     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  7     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  7     4 /*	Modified April 1983 by C. Hornig for tasking */
  7     5 
  7     6 /****^  HISTORY COMMENTS:
  7     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  7     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  7     9*     added the heap_header_ptr definition.
  7    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  7    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  7    12*     Modified to support control point management.  These changes were actually
  7    13*     made in February 1985 by G. Palter.
  7    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  7    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  7    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  7    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  7    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  7    19*     (ITS pair).
  7    20*                                                   END HISTORY COMMENTS */
  7    21 
  7    22 /* format: style2 */
  7    23 
  7    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  7    25 
  7    26      dcl	   1 stack_header	      based (sb) aligned,
  7    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  7    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  7    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  7    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  7    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  7    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  7    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  7    34 	     2 pad4	      bit (2) unal,
  7    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  7    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  7    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  7    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  7    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  7    40 	     2 null_ptr	      ptr,		/*  (16)  */
  7    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  7    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  7    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  7    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  7    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  7    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  7    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  7    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  7    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  7    50 	     2 return_no_pop_op_ptr
  7    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  7    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  7    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  7    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  7    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  7    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  7    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  7    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  7    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  7    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  7    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  7    62 	     2 trace,
  7    63 	       3 frames,
  7    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  7    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  7    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  7    67 	     2 pad2	      bit (36),		/*  (61) */
  7    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  7    69 
  7    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  7    71 
  7    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  7    73 						/* (551) octal */
  7    74 
  7    75 
  7    76 /*	The following constants are offsets within this transfer vector table.  */
  7    77 
  7    78      dcl	   (
  7    79 	   call_offset	      fixed bin init (271),
  7    80 	   push_offset	      fixed bin init (272),
  7    81 	   return_offset	      fixed bin init (273),
  7    82 	   return_no_pop_offset   fixed bin init (274),
  7    83 	   entry_offset	      fixed bin init (275)
  7    84 	   )		      internal static;
  7    85 
  7    86 
  7    87 
  7    88 
  7    89 
  7    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  7    91*	move the whole stack header should use this overlay.
  7    92**/
  7    93 
  7    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  7    95 
  7    96 
  7    97 
  7    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      152 
  8     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  8     2 
  8     3 /* format: off */
  8     4 
  8     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  8     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  8     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  8     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  8     9 
  8    10 
  8    11 /****^  HISTORY COMMENTS:
  8    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  8    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  8    14*     Modified to add constants for the translator_id field in the stack_frame
  8    15*     structure.
  8    16*                                                   END HISTORY COMMENTS */
  8    17 
  8    18 
  8    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  8    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  8    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  8    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  8    23 
  8    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  8    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  8    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  8    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  8    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  8    29 
  8    30 
  8    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  8    32 
  8    33 dcl  stack_frame_min_length fixed bin static init(48);
  8    34 
  8    35 
  8    36 dcl 1 stack_frame based(sp) aligned,
  8    37     2 pointer_registers(0 : 7) ptr,
  8    38     2 prev_sp pointer,
  8    39     2 next_sp pointer,
  8    40     2 return_ptr pointer,
  8    41     2 entry_ptr pointer,
  8    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  8    43     2 arg_ptr pointer,
  8    44     2 static_ptr ptr unaligned,
  8    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  8    46     2 on_unit_relp1 bit(18) unaligned,
  8    47     2 on_unit_relp2 bit(18) unaligned,
  8    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  8    49*						   0 => PL/I version II
  8    50*						   1 => ALM
  8    51*						   2 => PL/I version I   
  8    52*						   3 => signal caller frame
  8    53*						   4 => signaller frame */
  8    54     2 operator_return_offset bit(18) unaligned,
  8    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  8    56     2 a bit(36),					/* accumulator */
  8    57     2 q bit(36),					/* q-register */
  8    58     2 e bit(36),					/* exponent */
  8    59     2 timer bit(27) unaligned,				/* timer */
  8    60     2 pad bit(6) unaligned,
  8    61     2 ring_alarm_reg bit(3) unaligned;
  8    62 
  8    63 
  8    64 dcl 1 stack_frame_flags based(sp) aligned,
  8    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  8    66     2 xx0 bit(22) unal,
  8    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  8    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  8    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  8    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  8    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  8    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  8    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  8    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  8    75     2 xx0a bit(6) unal,
  8    76     2 xx1 fixed bin,
  8    77     2 xx2 fixed bin,
  8    78     2 xx3 bit(25) unal,
  8    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  8    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  8    81     2 xx3a bit(9) unaligned,
  8    82     2 xx4(9) bit(72) aligned,
  8    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  8    84*						*  operator puts a pointer to the base of
  8    85*						*  the calling procedure here. (text base ptr)  */
  8    86     2 xx5 bit(72) aligned,
  8    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  8    88 
  8    89 /* format: on */
  8    90 
  8    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      153 
      154 
      155      end task_create_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/86  1034.1  task_create_.pl1                  >special_ldd>install>MR12.0-1206>task_create_.pl1
148          1    06/16/82  1317.6  tasking_data.incl.pl1             >ldd>include>tasking_data.incl.pl1
1-18         2    06/16/82  1317.7  task_data.incl.pl1                >ldd>include>task_data.incl.pl1
1-19         3    06/16/82  1317.8  task_create_data.incl.pl1         >ldd>include>task_create_data.incl.pl1
149          4    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
150          5    07/27/83  0910.0  linkdcl.incl.pl1                  >ldd>include>linkdcl.incl.pl1
151          6    08/05/77  1022.4  lot.incl.pl1                      >ldd>include>lot.incl.pl1
152          7    11/04/86  1324.3  stack_header.incl.pl1             >special_ldd>install>MR12.0-1206>stack_header.incl.pl1
153          8    11/03/86  1114.7  stack_frame.incl.pl1              >special_ldd>install>MR12.0-1206>stack_frame.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Code                                   parameter       fixed bin(35,0)          dcl 17 set ref 12 49* 51* 52 64* 85* 86 122* 124*
                                                                                  126*
Offset                                 parameter       fixed bin(17,0)          dcl 140 ref 137 143
Ptr                                    parameter       pointer                  dcl 139 ref 137 143 144
STOPPED                                constant        fixed bin(17,0)          initial dcl 2-27 ref 112
TASK_DP                                constant        fixed bin(17,0)          initial dcl 2-27 ref 70 110
Task_create_data_ptr                   parameter       pointer                  dcl 15 ref 12 55
Task_data_ptr                          parameter       pointer                  dcl 16 set ref 12 48* 132*
abort                     2            based           label variable           level 2 dcl 2-9 set ref 115 116
abort_label_overlay                    based           structure                level 1 dcl 19
active_all_rings_data$hcscnt    000010 external static fixed bin(15,0)          dcl 30 ref 95
ai                              000106 automatic       structure                level 1 dcl 44 set ref 85 85
area_control                           based           structure                level 1 dcl 4-20
area_info                              based           structure                level 1 dcl 4-7
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 4-3 ref 79
areap                    16     000106 automatic       pointer                  level 2 dcl 44 set ref 84* 88
arg_ptr                  32            based           pointer                  level 2 dcl 8-36 set ref 107*
bar_mode_sp              32            based           pointer                  level 2 dcl 7-26 set ref 73*
based_ptr                              based           pointer                  dcl 26 set ref 70 110*
based_words                            based           fixed bin(35,0)          array dcl 27 set ref 91 92 93* 93 94* 94
cl_intermediary         100            based           entry variable           level 2 dcl 2-9 set ref 129*
clr_ptr                  10            based           pointer                  level 2 dcl 7-26 set ref 88*
code_ptr                               based           pointer                  level 2 dcl 19 set ref 115*
combined_stat_ptr         6            based           pointer                  level 2 dcl 7-26 set ref 88*
control                   1     000106 automatic       structure                level 2 dcl 44 set ref 80*
create_data              24            based           structure                level 2 dcl 2-9 set ref 55*
cur_lot_size             13            based           fixed bin(17,0)          level 2 packed unaligned dcl 7-26 set ref 91 92 93
                                                                                  94 95
define_area_                    000016 constant        entry                    external dcl 34 ref 85
defptr_overlay                         based           structure                level 1 dcl 22
elder_sister              6            based           pointer                  level 2 dcl 2-9 set ref 118*
env_ptr                   2            based           pointer                  level 2 dcl 19 set ref 116*
eo_iocb                  74            based           pointer                  level 2 dcl 2-9 set ref 126*
error_table_$unimplemented_version
                                000012 external static fixed bin(35,0)          dcl 31 ref 64
extend                    1     000106 automatic       bit(1)                   level 3 packed unaligned dcl 44 set ref 81*
flags                    57            based           structure                level 3 dcl 2-9 set ref 59*
get_temp_segment_               000020 constant        entry                    external dcl 35 ref 51
ioa_$rsnnl                      000022 constant        entry                    external dcl 36 ref 121
iox_$attach_name                000024 constant        entry                    external dcl 37 ref 122 124 126
ips_mask                104            based           bit(36)                  level 2 dcl 2-9 set ref 130*
isot_ptr                 52            based           pointer                  level 2 dcl 7-26 set ref 94 101*
isotp                           000136 automatic       pointer                  dcl 6-12 set ref 92* 94 101
lot                                    based           structure                level 1 dcl 6-6
lot_fault                              constant        bit(36)                  initial dcl 6-9 ref 96 97 97
lot_ptr                  26            based           pointer                  level 2 dcl 7-26 set ref 93 100*
lotp                            000134 automatic       pointer                  dcl 6-4 set ref 91* 93 96 96 97 97 97 100
lp                                     based           pointer                  array level 2 packed unaligned dcl 6-6 set ref 96
                                                                                  96* 97 97 97*
meters                   60            based           structure                level 2 in structure "task_data" dcl 2-9
                                                                                  in procedure "task_create_"
meters                   64            based           structure                level 3 in structure "tasking_data" dcl 1-9
                                                                                  in procedure "task_create_"
mother                   14            based           pointer                  level 2 dcl 2-9 set ref 68* 70* 72
next_sp                  22            based           pointer                  level 2 dcl 8-36 set ref 105*
offset                          000154 automatic       fixed bin(18,0)          unsigned dcl 141 set ref 143* 144 144
operator_and_lp_ptr      30            based           pointer                  level 2 dcl 8-36 set ref 107*
owner                     2     000106 automatic       char(32)                 level 2 packed unaligned dcl 44 set ref 82*
pps_sw                    0(29)        based           bit(1)                   level 2 packed unaligned dcl 22 ref 97
prev_sp                  20            based           pointer                  level 2 dcl 8-36 set ref 104*
ready_last               20            based           pointer                  level 2 dcl 2-9 set ref 118*
ready_next               16            based           pointer                  level 2 dcl 2-9 set ref 118*
return_ptr               24            based           pointer                  level 2 dcl 8-36 set ref 106*
root_task_data            4            based           structure                level 2 dcl 1-9 set ref 68
sb                                     based           pointer                  level 2 in structure "task_data" dcl 2-9
                                                                                  in procedure "task_create_" set ref 72 113*
sb                              000140 automatic       pointer                  dcl 7-24 in procedure "task_create_" set ref 51* 53
                                                                                  53 72 73 73 74 88 88 88 91 92 93 93 94 94 95 100
                                                                                  101 105 110 113 114 116
segno                           000104 automatic       fixed bin(15,0)          dcl 43 set ref 95* 96 96 97 97 97*
shared_static            57(01)        based           bit(1)                   level 4 packed unaligned dcl 2-9 set ref 60* 76
size                                                   builtin function         dcl 46 in procedure "task_create_" ref 53 54 54
size                     13     000106 automatic       fixed bin(18,0)          level 2 in structure "ai" dcl 44 in procedure
                                                                                  "task_create_" set ref 83*
sp                              000142 automatic       pointer                  dcl 8-31 set ref 54* 73 74* 104 105 106 107 107 108
stack_begin_ptr          22            based           pointer                  level 2 dcl 7-26 set ref 73* 116
stack_end_ptr            24            based           pointer                  level 2 dcl 7-26 set ref 74* 105
stack_frame                            based           structure                level 1 dcl 8-36
stack_frame_min_length                 constant        fixed bin(17,0)          initial dcl 8-33 ref 74
stack_header                           based           structure                level 1 dcl 7-26 set ref 53 72* 72
state                    23            based           fixed bin(17,0)          level 2 dcl 2-9 set ref 112*
sys_info$max_seg_size           000014 external static fixed bin(19,0)          dcl 32 ref 83
task_alm_$task_overseer_tv      000026 constant        entry                    external dcl 38 ref 106
task_area                              based           area(1024)               dcl 28 ref 91 92
task_area_ptr            76            based           pointer                  level 2 dcl 2-9 set ref 76* 88* 91 92
task_cl_intermediary_           000030 constant        entry                    external dcl 39 ref 129
task_create_data                       based           structure                level 1 dcl 3-10 ref 55
task_create_data_version_3             constant        fixed bin(17,0)          initial dcl 3-8 ref 63
task_ctl_$death                 000032 constant        entry                    external dcl 40 ref 115
task_data                              based           structure                level 1 dcl 2-9 set ref 54 54
task_data_ptr                   000132 automatic       pointer                  dcl 2-8 set ref 53* 54* 54 54 55 57 58 59 60 60 63
                                                                                  68 68 70 72 76 76 88 91 92 110 112 113 114 115 116
                                                                                  118 118 118 118 118 121 122 124 126 129 130 132
task_id                  22            based           bit(36)                  level 2 dcl 2-9 set ref 114* 121*
task_name                       000100 automatic       char(13)                 unaligned dcl 42 set ref 121* 122 124 126
tasking_data                           based           structure                level 1 dcl 1-9
tasking_data_ptr_               000034 external static pointer                  initial dcl 1-8 ref 68
top_level                57            based           bit(1)                   level 4 packed unaligned dcl 2-9 set ref 60* 68
translator_id            37            based           bit(18)                  level 2 packed unaligned dcl 8-36 set ref 108*
ui_iocb                  70            based           pointer                  level 2 dcl 2-9 set ref 122*
uo_iocb                  72            based           pointer                  level 2 dcl 2-9 set ref 124*
user_free_ptr            16            based           pointer                  level 2 dcl 7-26 set ref 88*
version                  24            based           fixed bin(17,0)          level 3 in structure "task_data" dcl 2-9
                                                                                  in procedure "task_create_" set ref 57 58* 63
version                         000106 automatic       fixed bin(17,0)          level 2 in structure "ai" dcl 44 in procedure
                                                                                  "task_create_" set ref 79*
younger_sister           10            based           pointer                  level 2 dcl 2-9 set ref 118*
youngest_daughter        12            based           pointer                  level 2 dcl 2-9 set ref 118*
zero_on_alloc             1(01) 000106 automatic       bit(1)                   level 3 packed unaligned dcl 44 set ref 81*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BLOCKED                                internal static fixed bin(17,0)          initial dcl 2-27
DEAD                                   internal static fixed bin(17,0)          initial dcl 2-27
READY                                  internal static fixed bin(17,0)          initial dcl 2-27
RETURN_PTR_MASK                        internal static bit(72)                  initial unaligned dcl 8-19
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial unaligned dcl 8-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial unaligned dcl 8-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial unaligned dcl 8-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial unaligned dcl 8-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial unaligned dcl 8-27
area_infop                             automatic       pointer                  dcl 4-5
call_offset                            internal static fixed bin(17,0)          initial dcl 7-78
entry_offset                           internal static fixed bin(17,0)          initial dcl 7-78
exp_word                               based           structure                level 1 dcl 5-21
header                                 based           structure                level 1 dcl 5-31
isot                                   based           structure                level 1 dcl 6-13
isot1                                  based           structure                array level 1 dcl 6-16
link                                   based           structure                level 1 dcl 5-11
linkage_header_flags                   based           structure                level 1 dcl 5-44
name                                   based           structure                level 1 dcl 5-70
push_offset                            internal static fixed bin(17,0)          initial dcl 7-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 7-78
return_offset                          internal static fixed bin(17,0)          initial dcl 7-78
stack_frame_flags                      based           structure                level 1 dcl 8-64
stack_header_overlay                   based           fixed bin(17,0)          array dcl 7-94
task_create_data_ptr                   automatic       pointer                  dcl 3-9
trap_word                              based           structure                level 1 dcl 5-66
tv_offset                              internal static fixed bin(17,0)          initial dcl 7-72
type_pair                              based           structure                level 1 dcl 5-25
virgin_linkage_header                  based           structure                level 1 dcl 5-52

NAMES DECLARED BY EXPLICIT CONTEXT.
addrel16                        000701 constant        entry                    internal dcl 137 ref 54 74
task_create_                    000067 constant        entry                    external dcl 12

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 68 85 85 115 116
baseno                                                 builtin function         ref 114
binary                                                 builtin function         ref 143
bit                                                    builtin function         ref 114
clock                                                  builtin function         ref 114
codeptr                                                builtin function         ref 106 115
mod                                                    builtin function         ref 144
null                                                   builtin function         ref 48 76 84 104 107 118 122 122 124 124 126 126
pointer                                                builtin function         ref 53 70 110 144
rel                                                    builtin function         ref 143
stackbaseptr                                           builtin function         ref 70
string                                                 builtin function         set ref 59 80*
substr                                                 builtin function         ref 114
unspec                                                 builtin function         set ref 96 96* 97 97*

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1136        1174     740        1146
Length      1542     740        36         331     176           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
task_create_                        173 external procedure  is an external procedure.  
addrel16                                internal procedure  shares stack frame of external procedure task_create_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
task_create_             000100 task_name                   task_create_
                         000104 segno                       task_create_
                         000106 ai                          task_create_
                         000132 task_data_ptr               task_create_
                         000134 lotp                        task_create_
                         000136 isotp                       task_create_
                         000140 sb                          task_create_
                         000142 sp                          task_create_
                         000154 offset                      addrel16

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          mdfx1               ext_entry           op_alloc_
clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
define_area_                  get_temp_segment_             ioa_$rsnnl                    iox_$attach_name
task_alm_$task_overseer_tv    task_cl_intermediary_         task_ctl_$death

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
active_all_rings_data$hcscnt  error_table_$unimplemented_version                          sys_info$max_seg_size
tasking_data_ptr_




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000063        48 000074        49 000077        51 000100        52 000124        53 000127        54 000132
     55 000136        57 000145        58 000150        59 000152        60 000153        63 000157        64 000162
     65 000165        68 000166        70 000177        72 000205        73 000213        74 000216        76 000232
     79 000241        80 000243        81 000244        82 000250        83 000253        84 000256        85 000260
     86 000273        88 000276        91 000305        92 000315        93 000325        94 000337        95 000345
     96 000357        97 000363        99 000374       100 000376       101 000401       104 000403       105 000406
    106 000411       107 000414       108 000417       110 000421       112 000425       113 000427       114 000431
    115 000445       116 000450       118 000452       121 000460       122 000507       124 000554       126 000621
    129 000666       130 000674       132 000676       133 000700       137 000701       143 000703       144 000712


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
