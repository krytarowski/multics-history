	COMPILATION LISTING OF SEGMENT tedutil_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1127.90_Tue_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-08-03,RWaters), approve(88-08-03,MCR7950), audit(88-09-29,Huen),
       16*     install(88-10-07,MR12.2-1146):
       17*     Bug fixes for MR12.2.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /**** format: ind3,ll80,initcol6,indattr,^inddcls,dclind4,idind16	       */
       22 /**** format: struclvlind2,^ifthenstmt,^ifthendo,^ifthen,^indnoniterdo       */
       23 /**** format: ^inditerdo,^indnoniterend,^indthenelse,case,^indproc,^indend   */
       24 /**** format: ^delnl,^insnl,comcol41,^indcom,^indblkcom,linecom,^indcomtxt   */
       25 
       26 /*                                              _			       */
       27 /*    _|_              |          _|_     o      |		       */
       28 /*     |      _      _ |           |     __      |		       */
       29 /*     |     / \    / \|  |   |    |      |      |		       */
       30 /*     |    (__/   (   |  |   |    |      |      |		       */
       31 /*     \_    \_/    \_/|   \_/|    \_    _|_    _|_		       */
       32 /*                                                    -----		       */
       33 /*							       */
       34 
       35 /* Contains:	tedset_ptr_				       */
       36 /*		tedread_ptr_				       */
       37 /*		tederror_					       */
       38 /*		tedcall_					       */
       39 /*		tedresetread_				       */
       40 /*		tedend_buffer_				       */
       41 /*		tedcount_lines_				       */
       42 /*		tedck_ptr_				       */
       43 
       44 /* UPDATE HISTORY						       */
       45 /* EL#   date	TR	comments				       */
       46 /* ---		added debug output switch			       */
       47 /* 136 84-10-08 phx16686 don't lose input typed up to \b(not-exist)	       */
       48 /* 148 84-10-10 phx17488 "^>+1 r not-there" executes char after the NL       */
       49 /* 156 84-10-17 phx18195 prohibit 1) invoking buffer in INPUT mode	       */
       50 /*		              2) modifying buffer being executed.	       */
       51 /*		(Also renamed execute parameters to make things a little */
       52 /*		 easier to read)				       */
       53 /* 193 88-07-08 phx19382 RW "loc" may be zero & b_c(0) is a subscript error  */
       54 
       55 tedutil_:				/* just a pretty face	       */
       56    proc;
       57       return;
       58 
       59 dcl (tp, new_bp)	ptr,		/* temporary storage	       */
       60     (ti, tti, te, i, j, k, escl, srchl) fixed bin (21);
       61 dcl ii		fixed bin (21);
       62 dcl i21		fixed bin (21);
       63 dcl j24		fixed bin (21);
       64 dcl jj		fixed bin (21);
       65 dcl used		fixed bin (21);
       66 
       67 dcl concealsw	bit (1);
       68 dcl cu_$arg_ptr	entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
       69 dcl hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (21),
       70 		fixed bin (2), ptr, fixed bin (35));
       71 dcl com_err_	entry () options (variable);
       72 dcl ioa_		entry () options (variable);
       73 dcl cu_$af_arg_count entry (fixed bin, fixed bin (35));
       74 dcl cu_$cp	entry (ptr, fixed bin (21), fixed bin (35));
       75 dcl ioa_$nnl	entry () options (variable);
       76 dcl ioa_$ioa_switch entry () options (variable);
       77 dcl hcs_$get_uid_seg entry (ptr, bit (36), fixed bin (35));
       78 
       79 
       80 dcl NL		char (1) int static init ("
       81 ");
       82 
       83 
       84 dcl str		char (262144) based aligned;
       85 				/* for use w/substr&index functions  */
       86 dcl iox_$get_line	entry (ptr, ptr, fixed bin (21), fixed bin (21),
       87 		fixed bin (35));
       88 dcl iox_$user_input ptr ext static;
       89 dcl iox_$error_output ptr ext static;
       90 dcl iox_$control	entry (ptr, char (*), ptr, fixed bin (35));
       91 
       92 /* dcl 1 DATABASE	based (dbase_p),
       93*      2 zzzzzz	like dbase,
       94*      2 cb	(DATABASE.bufnum) like b; /* expands to arbitrary size   */
       95 
       96 /**** <<<<----- dcl_tedset_ptr_.incl.pl1 tedset_ptr_		       */
       97 tedset_ptr_:			/* find label in local buffer	       */
       98    entry (adb_p, kharv, kode);
       99 dcl (
      100     adb_p		ptr,		/* -> database		       */
      101     kharv		char (*),		/* label to find		       */
      102     kode		fixed bin (35)	/* return code		       */
      103     )		parm;		/* ----->>>>		       */
      104 
      105 dcl lab		char (20);
      106 dcl labl		fixed bin (21);
      107 
      108       dbase_p = adb_p;
      109       if (kharv = "BREAK")
      110       then do;
      111          kode = 0;
      112          return;
      113       end;
      114       if (dbase.at_break = 2)
      115       then do;
      116          dbase.at_break = 0;
      117          kode = 0;
      118          return;
      119       end;
      120       labl = 2 + length (kharv);
      121       substr (lab, 3) = kharv;
      122       substr (lab, 1, 1) = NL;
      123       substr (lab, 2, 1) = ":";
      124       bp = dbase.stk_info.curp;	/* current buffer control block      */
      125       if ^b.tw_sw
      126       then do;						/* #148*/
      127          if (ex_EOD = ex_last)	/* make whole buffer available       */
      128          then ex_EOD = b.b_.r.re;
      129          ex_last = b.b_.r.re;
      130       end;						/* #148*/
      131       if (substr (lab, 3, 2) = "+0")
      132       then substr (lab, 3, 1) = "-";
      133       if (substr (lab, 3, 1) = NL)	/* >\012 means last char of buffer   */
      134       then do;			/*  this may or may not be a NL      */
      135          if (ex_last = b.b_.r.re)	/* if end-range is end-buffer	       */
      136 	  & (b.b_.r.re < b.b_.r.le)	/* ..& right part is empty	       */
      137          then call set_exec (b.b_.l.re);/* ..set to end of left part	       */
      138          else call set_exec (ex_last);	/* ..otherwise use end-range	       */
      139          kode = 0;
      140          return;
      141       end;
      142       else if (substr (lab, 3, 1) = "+")
      143       then do;
      144          do i = 2 to index ("123456789", substr (lab, 4, 1));
      145 	  if (ex_next > ex_EOD)
      146 	  then j = 0;					/* #148*/
      147 	  else						/* #148*/
      148 	     j = index (substr (ex_s, ex_next), NL);
      149 	  if (j = 0)		/* didn't find it		       */
      150 	     & (ex_EOD ^= ex_last)	/* ..but range is split, look again  */
      151 	  then j = index (substr (b_s, b.b_.r.le, ex_last - b.b_.r.le + 1), NL);
      152 	  if (j = 0)
      153 	  then goto label_not_found;
      154 	  call set_exec (ex_next + j);
      155          end;
      156          kode = 0;
      157          return;
      158       end;
      159       else if (substr (lab, 3, 1) = "-")
      160       then do;
      161          jj = b.b_.r.le;		/* reference upper part	       */
      162          if (ex_next < jj)		/* if not executing there	       */
      163          then jj = 1;		/* ..then reference lower part       */
      164          do i = index ("0123456789", substr (lab, 4, 1)) to 0 by -1;
      165 	  j = index (reverse (substr (b_s, jj, ex_next - jj)), NL);
      166 	  if (j > 0)
      167 	  then call set_exec (ex_next - j);
      168 	  else do;
      169 	     if (i = 0)
      170 	     then do;
      171 	        ex_next = jj;
      172 	        kode = 1;
      173 	        return;
      174 	     end;
      175 	     if (ex_EOD = ex_last)	/* if in upper part		       */
      176 	     then do;		/* ..move to lower part	       */
      177 	        jj = 1;
      178 	        call set_exec (b.b_.l.re);
      179 	     end;
      180 	     else goto label_not_found;
      181 	  end;
      182          end;
      183          call set_exec (ex_next + 1);
      184          kode = 0;
      185          return;
      186       end;
      187       else do;
      188          j = 0;
      189          if (labl <= b.b_.l.re)
      190          then do;
      191 	  if (substr (b_s, 1, labl - 1) = substr (lab, 2, labl - 1))
      192 	  then do;		/* label at front of buffer,	       */
      193 	     call set_exec (1);	/*  then set to there.	       */
      194 	     kode = 0;
      195 	     return;
      196 	  end;
      197 				/* find label, (at begin of a line)  */
      198 	  j = index (substr (b_s, 1, b.b_.l.re), substr (lab, 1, labl));
      199          end;
      200          if (j = 0)
      201          then if (labl <= b.maxl - b.b_.r.le + 1)
      202 	    then do;
      203 	       if (substr (b_s, b.b_.r.le, labl - 1) = substr (lab, 2, labl - 1))
      204 	       then do;		/* label at front of part 2,	       */
      205 		call set_exec (b.b_.r.le); /*  then set to there.	       */
      206 		kode = 0;
      207 		return;
      208 	       end;
      209 				/* find label, (at begin of a line)  */
      210 	       j = index (substr (b_s, b.b_.r.le), substr (lab, 1, labl));
      211 	       if (j > 0)
      212 	       then j = j + b.b_.r.le - 1;
      213 	    end;
      214       end;
      215       if (j ^= 0)
      216       then do;
      217          call set_exec (j + 1);
      218          kode = 0;
      219          return;
      220       end;
      221       if (kode = 0)
      222       then do;
      223 label_not_found:
      224          msg = "Bgo) ";		/* :*** not defined in b(***).       */
      225          msg = msg || substr (lab, 2, labl - 1);
      226          msg = msg || " not defined in b(";
      227          msg = msg || substr (b.name, 1, index (char (b.name, 17), " ") - 1);
      228          msg = msg || ").";
      229          call tederror_ (dbase_p, msg);
      230          kode = 10;
      231       end;
      232       return; 




      233 /**** Rewrote this routine to try to make things work, then		/* #156*/
      234 /**** found that it couldn't be done.  So other places prohibit	/* #156*/
      235 /**** the attempt entirely.					/* #156*/
      236 
      237 init_exec: proc (left, right);				/* #156*/
      238 
      239 dcl (left, right)	fixed bin (21);				/* #156*/
      240 
      241       if  db_util & lg_util & ^b.tw_sw
      242       then call tedshow_ (bp, "> exI b_ ex");			/* #156*/
      243       ex_last = right;					/* #156*/
      244       ex_lre = min (b.b_.l.re, right);				/* #156*/
      245       if (left > ex_lre)
      246       then ex_EOD = ex_last;					/* #156*/
      247       else ex_EOD = ex_lre;					/* #156*/
      248       goto common;						/* #156*/
      249 
      250 set_exec: entry (left);					/* #156*/
      251 
      252       if  db_util & lg_util & ^b.tw_sw
      253       then call tedshow_ (bp, "> exS b_ ex");			/* #156*/
      254 common:
      255       ex_next = left;					/* #156*/
      256       if (ex_next <= b.b_.l.re)	/* if next is in lower part,	       */
      257       then ex_EOD =			/* ..then EOD must be also	       */
      258          min (b.b_.l.re, ex_last);	/* ..but only what's available   #156*/
      259       else do;
      260          ex_EOD = ex_last;		/* ..else EOD is up top	   #156*/
      261          if (ex_next = b.b_.l.re + 1)	/* if next just dropped out of       */
      262          then ex_next = b.b_.r.le;	/* ..of lower, move up top.	   #156*/
      263          if (ex_next < b.b_.r.le)	/* if next is below upper, current   */
      264          then do;			/* ...is within gap - tsk,tsk	   #156*/
      265 	  signal condition (ex_next_in_gap);
      266 dcl ex_next_in_gap	condition;
      267 	  ex_next = b.b_.r.le;
      268          end;
      269       end;						/* #148*/
      270       if  db_util & lg_util & ^b.tw_sw
      271       then call tedshow_ (bp, "< ex");				/* #156*/
      272    end init_exec; 




      273 tedwhere_: entry (adb_p);		/* +++ called by ted_eval_	       */
      274       dbase_p = adb_p;
      275       bp = dbase.stk_info.curp;
      276       call tedcount_lines_ (b.cur.sp, 1, ex_next - 1, j);
      277       call ioa_ ("b(^a), line ^d, level ^d[^a]", b.name, j,
      278          dbase.stk_info.level, dbase.recurs);
      279       return; 
      280 no_input: proc;
      281 
      282 dcl error_table_$end_of_info fixed bin (35) ext static;
      283 dcl error_table_$io_no_permission fixed bin (35) ext static;
      284 dcl timer_manager_$sleep entry (fixed bin (71), bit (2));
      285 
      286       if (code = error_table_$end_of_info)
      287       then ;
      288       else if (code = error_table_$io_no_permission)
      289       then call timer_manager_$sleep (10, "11"b);
      290       else call com_err_ (code, dbase.tedname, "Reading user_input");
      291 
      292    end no_input; 
      293 break_input:
      294       if (dbase.at_break = 1)
      295       then do;
      296          if (mode = "INPUT") | (mode = "BREAK")
      297          then goto reloop;
      298 re_break:
      299          call ioa_ ("**BREAK** (level,line,buffer). [Recursion=^i]",
      300 	  dbase.recurs);
      301          call tedcount_lines_ (bp, 1, ex_next - 1, j);
      302          call ioa_ ("^-^3i ^4i b(^a)", dbase.stk_info.level, j, b.name);
      303          if (dbase.at_break = 2)
      304          then do;
      305 	  k = index (reverse (substr (b_s, 1, ex_next - 1)), NL);
      306 	  if (k = 0)
      307 	  then k = 1;
      308 	  else k = ex_next - k + 1;
      309 dcl dec6		pic "zzzzz9";
      310 	  dec6 = j;
      311 	  msg = dec6 || "	";
      312 	  if (k < ex_next)
      313 	  then do;
      314 	     msg = msg || substr (b_s, k, ex_next - k + 1);
      315 	     msg = msg || "	";
      316 	  end;
      317 	  msg = msg || "<BREAK>
      318 	";
      319 	  k = index (substr (b_s, ex_next, 256), NL);
      320 	  msg = msg || substr (b_s, ex_next, k);
      321 	  call ioa_ ("^a", (msg));
      322          end;
      323          dbase.at_break = 2;
      324       end;
      325       dbase.err_go = "BREAK";
      326 /****    if (mode = "INPUT")
      327*         then do;
      328*	  call ioa_ ("BREAK: not allowed. INPUT MODE");
      329*	  substr (red_line, 1, 2) = "\f";
      330*	  nelemt = 2;
      331*	  return;
      332*         end;						       */
      333 bk_loop:
      334       call iox_$get_line (iox_$user_input, atp, ibe, nelemt, code);
      335       if (code ^= 0)
      336       then do;
      337          call no_input;
      338          goto bk_loop;
      339       end;
      340       if db_catch
      341       then call ioa_$ioa_switch_nnl (db_output,
      342          "====BRK^-^a", substr (red_line, 1, nelemt));
      343       if (nelemt = 3) & (substr (red_line, 1, 2) = "\?")
      344       then goto re_break;
      345       return;			/* tedset_ptr_ */
      346 /**** <<<<----- dcl_tedread_ptr_.incl.pl1 tedread_ptr_		       */
      347 tedread_ptr_:			/* read a line from input stream     */
      348    entry (adb_p, atp, ibi, ibe, nelemt, mode);
      349 dcl (
      350 /****adb_p	ptr,		/* -> database		       */
      351     atp		ptr,		/* -> input buffer		       */
      352     ibi		fixed bin (21),	/* last char in use in buffer	       */
      353     ibe		fixed bin (21),	/* last char useable in buffer       */
      354     nelemt	fixed bin (21),	/* last char filled in buffer  [OUT] */
      355     mode		char (5)		/* mode in which read is being done  */
      356     )		parm;		/* ----->>>>		       */
      357 dcl red_line	char (ibe) based (atp);
      358 dcl red_char	(ibe) char (1) based (atp);
      359 dcl tmode		char (5);
      360 dcl db_input	bit (1);
      361 
      362       tmode = mode;
      363       db_input = db_ted & ((tmode="INPUT")|(tmode="BULK"));
      364 reread:
      365       dbase_p = adb_p;
      366       concealsw = "0"b;
      367       bp = dbase.stk_info.curp;	/* get ptr to cur buffer ctl block   */
      368       nelemt = ibi;			/* make sure old line is gone	       */
      369       ti = ibi;
      370       te = ibe;
      371       if (dbase.at_break ^= 0)
      372       then goto break_input;
      373 reloop:
      374       if db_util & ^b.tw_sw
      375       then call tedshow_ (bp, "ex");
      376       tti = ti;
      377       do while (ti <= te);
      378 retry:
      379          if ex_next > ex_EOD		/* is part being read exhausted?     */
      380          then do;
      381 	  if b.tw_sw		/* coming from user_input?	       */
      382 	  then do;
      383 	     if (rdy.len > 0) & (ex_EOD ^= 1) & (tmode = "EDIT")
      384 	     then begin;
      385 dcl rdyline	char (rdy.len);
      386 	        rdyline = rdy_line;
      387 	        call cu_$cp (addr (rdyline), rdy.len, code);
      388 	     end;
      389 refresh:	     begin;
      390 
      391 	        if b.pseudo
      392 	        then do;
      393 		 b.b_.l.re = b.b_.l.le - 1;
      394 		 b.b_.r.le = b.b_.r.re + 1;  /* make it look empty       */
      395 		 call tedpromote_ (bp, 4069);
      396 				/* dbase.rl.part1 = b.cur;	       */
      397 	        end;
      398 
      399 	        b.b_.l.re = 0;
      400 loop:
      401 	        call iox_$get_line (iox_$user_input, b.cur.sp, b.maxl,
      402 		 b.b_.l.re, code);
      403 	        if (code ^= 0)
      404 	        then do;		/* not handling long records	       */
      405 		 call no_input;
      406 		 goto loop;
      407 	        end;
      408 	        if db_catch
      409 	        then call ioa_$ioa_switch_nnl (db_output,
      410 		 "====^a^-^a", tmode, substr (b_s, 1, b.b_.l.re));
      411 	        call init_exec (1, (b.b_.l.re));
      412 	        if (ex_EOD = 3) & (substr (b_s, 1, 3) = "\?
      413 ")
      414 	        then do;
      415 		 call tell_where (tmode);
      416 		 ex_EOD = 0;
      417 		 goto loop;	/* try again to get data for caller  */
      418 	        end;
      419 
      420 	     end refresh;
      421 	  end;
      422 	  else do;		/* here on end of buffer	       */
      423 	     call tedend_buffer_ (dbase_p, 0); /* pop level by 1	       */
      424 	     bp = dbase.stk_info.curp;/* re-establish prev buff ctl block  */
      425 	  end;
      426 	  goto retry;
      427          end;
      428          if (tmode = "EDIT") & (ti = 0) & (ex_EOD > ex_next)
      429          then if (substr (b_s, ex_next, 2) = "..")
      430 	    then do;		/* NEED TO HANDLE ARBITRARY LENGTH!  */
      431 	       call set_exec (ex_next + 2);
      432 	       tp = addr (ex_c (ex_next));
      433 	       kk = ex_EOD - ex_next + 1;
      434 	       i21 = index (substr (b_s, ex_next, kk), NL);
      435 	       if (i21 = 0)
      436 	       then do;
      437 		i21 = kk;
      438 		call set_exec (ex_next + i21);
      439 	       end;
      440 	       else call set_exec (ex_next + i21 - 1);
      441 	       call tedset_ck_ptr_ (dbase_p);
      442 	       call cu_$cp (tp, i21, code);
      443 dcl kk		fixed bin (21);
      444 	       tp = atp;
      445 	       substr (red_line, 1, 3) = "e";
      446 	       ti = 3;
      447 	       goto rdp (1);	/* add a NL		       */
      448 	    end;
      449          srchl = min (ex_EOD - ex_next + 1, te - ti + 1);
      450          if (tmode = "BULK")
      451          then do;
      452 	  if (substr (b_s, ex_next, 2) = ".
      453 ")	  then do;
      454 	     call set_exec (ex_next + 2);
      455 	     mode = "EOF";
      456 	     goto end_read;
      457 	  end;
      458 	  k = index (substr (b_s, ex_next, srchl), NL);
      459 				/* NEED to avoid line splitting?     */
      460          end;
      461 				/* find a char needing attention     */
      462          else k = search (substr (b_s, ex_next, srchl), hot_chars);
      463 
      464 dcl hot_chars	char (7) int static options (constant) init ("
      465 \");
      466 
      467          if (k = 0)
      468          then k = srchl;
      469          else k = k - 1;
      470          if (k > 0)			/* move intervening chars, if any    */
      471          then do;
      472 	  substr (red_line, ti + 1, k) = substr (b_s, ex_next, k);
      473 	  if db_input then call ioa_$ioa_switch (db_output, 
      474 	     "^a: (^p->red_line,ti+1(^i),^i)=^p->str,len=^i", tmode,
      475 	     addr(red_line), ti+1, k, addcharno (b.cur.sp, ex_next-1), ti+k);
      476 	  ti = ti + k;
      477 	  call set_exec (ex_next + k);
      478          end;
      479          if (ti > te)		/* caller's buffer full?	       */
      480          then goto end_read;		/*  YES			       */
      481          if (ex_next > ex_EOD)	/* source exhausted?	       */
      482          then goto retry;		/*  YES			       */
      483          k = index (hot_chars, substr (b_s, ex_next, 1));
      484          if (^dbase.old_style | b.tw_sw) & (k > 3)
      485          then do;
      486 	  if (tmode ^= "INPUT")
      487 	  then do;
      488 	     substr (red_line, ti + 1, 2) = "\c";
      489 	     ti = ti + 2;
      490 	  end;
      491 	  goto move_ch;
      492          end;
      493          goto rdp (k);
      494 
      495 rdp (1):				/* NL */
      496          ti = ti + 1;
      497          red_char (ti) = NL;
      498          if db_input then call ioa_$ioa_switch (db_output, 
      499 	  "^a: (^p->red_line,ti+1(^i),i)=NL,len=^i", tmode,
      500 	  addr(red_line), ti, ti);
      501          call set_exec (ex_next + 1);
      502          goto end_read; 





      503 dcl old_msg	char (47) int static options (constant) init (
      504 		"^/^a: b(^a) contains a \03^a (old-style \^a).^/");
      505 
      506 rdp (4):				/* \031 (old \c)		       */
      507          if b.tw_sw
      508          then goto move_ch;
      509          if ^b.bs.c
      510          then do;
      511 	  call ioa_ (old_msg, dbase.tedname, b.name, "1", "C");
      512 	  b.bs.c = "1"b;
      513          end;
      514          escl = 0;
      515 esc (1):				/* "\c"			       */
      516          if (tmode = "INPUT")
      517          then goto always_conceal;
      518          k = index (hot_chars, substr (b_s, ex_next + escl + 1, 1));
      519          if (k = 2)			/* "\"			       */
      520          then do;
      521 	  if (ex_next + escl < ex_EOD)	/* is there another char?      */
      522 	  then do;
      523 	     j = index (ESCAPES, substr (b_s, ex_next + escl + 2, 1));
      524 	     if (j > ESCmax)
      525 	     then j = j - ESCmax;
      526 	     k = j + 3;
      527 	  end;
      528 	  else k = 0;
      529          end;
      530          if (k = 0)			/* not of interest		       */
      531 	  | (k = 4)		/* \031 \c		       */
      532 	  | (k = 7)		/* \034 \f		       */
      533          then do;
      534 	  substr (red_line, ti + 1, escl + 2)
      535 	     = substr (b_s, ex_next, escl + 2);
      536 	  if db_input then call ioa_$ioa_switch (db_output, 
      537 	     "^a: (^p->red_line,ti+1(^i),^i)=^p->str,len=^i", tmode,
      538 	     addr(red_line), ti+1, escl + 2, addcharno (b.cur.sp, ex_next-1),
      539 	     ti + escl + 2);
      540 	  ti = ti + escl + 2;
      541          end;
      542          else do;
      543 always_conceal:
      544 	  if db_input then call ioa_$ioa_switch (db_output, 
      545 	     "^a: (^p->red_line,ti+1(^i),1)=^p->str,len=^i", tmode,
      546 	     addr(red_line), ti+1, addcharno (b.cur.sp, ex_next + escl), ti+1);
      547 	  ti = ti + 1;
      548 	  red_char (ti) = substr (b_s, ex_next + escl + 1, 1);
      549          end;
      550          call set_exec (ex_next + escl + 2);
      551          goto end_loop; 





      552 rdp (5):				/* \030 (old \b)		       */
      553          if b.tw_sw
      554          then goto move_ch;
      555          if ^b.bs.b
      556          then do;
      557 	  call ioa_ (old_msg, dbase.tedname, b.name, "0", "B");
      558 	  b.bs.b = "1"b;
      559          end;
      560          escl = 0;
      561 esc (2):				/* "\b"			       */
      562          call set_exec (ex_next + escl + 1);
      563 /**** Must the gap be accounted for here?			       */
      564          used = ex_EOD - ex_next + 1;
      565          call tedget_existing_buffer_ (dbase_p, addr (b_c (ex_next)),
      566 	  used, new_bp, msg);	/* try to find named buffer	       */
      567          call set_exec (ex_next + used);
      568          if (new_bp = null ())	/* error if named buffer does	       */
      569          then do;			/*   not already exist	       */
      570 rd_err:
      571 	  if (tmode = "INPUT")
      572 	  then msg = msg || "
      573 INPUT mode terminated.";					/* #136*/
      574 	  call tederror_ (dbase_p, msg);
      575 	  call tedresetread_ (dbase_p); /* reset back to level 0	       */
      576 	  if (tmode = "INPUT")
      577 	  then do;					/* #136*/
      578 	     mode = "EOF";					/* #136*/
      579 	     goto end_read;					/* #136*/
      580 	  end;						/* #136*/
      581 	  goto reread;		/* and reread this call from scratch */
      582          end;
      583          if new_bp -> b.INPUT
      584          then do;						/* #156*/
      585 	  msg = "Bmi) Cannot invoke b(";			/* #156*/
      586 	  msg = msg || rtrim (new_bp -> b.name);		/* #156*/
      587 	  msg = msg || "), it is in INPUT mode.";		/* #156*/
      588 	  goto rd_err;					/* #156*/
      589          end;						/* #156*/
      590          if (dbase.stk_info.level > 500)
      591          then do;
      592 	  msg = "Brc) Level > 500.";
      593 	  goto rd_err;		/* check buffer recursion level      */
      594          end;
      595          call push_one (dbase.stk_info.next);
      596          if (ex_next = 1) & (ex_last = b.maxl)
      597          then b.not_pasted = "0"b;
      598          goto retry; 





      599 rdp (6):				/* \036 (old \r)		       */
      600          if b.tw_sw
      601          then goto move_ch;
      602          if ^b.bs.r
      603          then do;
      604 	  call ioa_ (old_msg, dbase.tedname, b.name, "6", "R");
      605 	  b.bs.r = "1"b;
      606          end;
      607          escl = 0;
      608 esc (3):				/* "\r"			       */
      609          if (tmode = "INPUT")		/* in INPUT mode postpone the \r     */
      610          then do;			/* ..if there isn't a fair amount of */
      611 	  if (te - ti < 256)	/* ..space left in the file to       */
      612 	  then do;		/* ..receive it.		       */
      613 	     te = ti - 1;		/* force EOBuffer		       */
      614 	     goto end_read;
      615 	  end;
      616          end;
      617          call set_exec (ex_next + escl + 1);
      618 console_read:
      619          tp = addr (temp_fix);
      620 dcl temp_fix	char (512);
      621          call iox_$get_line (iox_$user_input, tp, length (temp_fix),
      622 	  j24, code);
      623          if (code ^= 0)
      624          then do;
      625 	  call no_input;
      626 	  goto console_read;
      627          end;
      628          if db_catch
      629          then call ioa_$ioa_switch_nnl (db_output,
      630 	  "====READ^-^a", substr (temp_fix, 1, j24));
      631          j24 = min (j24, te - ti);
      632          substr (red_line, ti + 1, j24) /* move line (as much as	       */
      633 	  = substr (tp -> str, 1, j24); /*  will fit) to caller's buffer  */
      634 	  if db_input then call ioa_$ioa_switch (db_output, 
      635 	     "^a: (^p->red_line,ti+1(^i),^i)=^p->str,len=^i", tmode,
      636 	     addr(red_line), ti+1, j24, tp, ti+j24);
      637          ti = ti + j24;
      638          if (dbase.tedname = "qedx")
      639          then goto end_read;		/* qedx quits right there	       */
      640          else do;
      641 	  if (red_char (ti) = NL)
      642 	  then ti = ti - 1;		/* ted doesn't give up so easily     */
      643          end;
      644          if (j24 = 3) & (substr (tp -> str, 1, 1) = "\")
      645          then do;
      646 	  if (substr (tp -> str, 2, 1) = "?")
      647 	  then do;
      648 	     call tell_where ("READ");
      649 	     goto console_read;
      650 	  end;
      651 	  if (index ("fF", substr (tp -> str, 2, 1)) ^= 0)
      652 	  then do;
      653 	     mode = "\R\F";
      654 	     goto read_exit;
      655 	  end;
      656          end;
      657          goto retry; 





      658 dcl ESCAPES	char (14) int static options (constant) init
      659 		("cbrfvx{[CBRFVX");
      660 dcl ESCmax	fixed bin int static init (8) options (constant);
      661 rdp (2):				/* "\"			       */
      662          j = index (ESCAPES, substr (b_s, ex_next + 1, 1));
      663          if (j = 0)
      664          then goto move_ch;
      665          if (j > ESCmax)
      666          then j = j - ESCmax;
      667          escl = 1;
      668          goto esc (j); 





      669 esc (5):				/* "\v"			       */
      670          if (substr (b_s, ex_next + 2, 1) = "{")
      671          then do;
      672 	  call set_exec (ex_next + 1);/* "\v{"			       */
      673 dcl 1 adr_hold	(0:2) like b.a_;
      674 esc (7):				/* "\{"			       */
      675 	  call set_exec (ex_next + 1);
      676 	  adr_hold = b.a_;		/* keep what is there right now      */
      677 	  b.present (1), b.present (2) = "0"b;
      678 	  used = ex_EOD - ex_next + 1;
      679 	  call tedeval_ (dbase_p, addr (b_c (ex_next)), used,
      680 	     bp, null (), -1, result, msg, code);
      681 	  call set_exec (ex_next + used);
      682 	  b.a_ = adr_hold;		/* someone else might need it	       */
      683 	  if (code ^= 0)
      684 	  then goto rd_err;
      685 	  j24 = min (length(result), te - ti);
      686 	  substr (red_line, ti + 1, j24) = result;
      687 	  if db_input then call ioa_$ioa_switch (db_output, 
      688 	     "^a: (^p->red_line,ti+1(^i),^i)=^p->str,len=^i", tmode,
      689 	     addr(red_line), ti+1, j24, addr (result), ti+j24);
      690 	  ti = ti + j24;
      691 	  goto retry;
      692          end;
      693 esc (8):				/* "\[" */
      694          j = verify (substr (b_s, ex_next + 2), "0123456789");
      695          if (substr (b_s, ex_next + 1 + j, 1) = "]")
      696          then do;			/* convert \[n].   to \x[n.]	       */
      697 				/* *    or \[n]\cx to \x[n"x"]       */
      698 				/* *    or \[n]x   to \x[n"x"]       */
      699 	  j24 = ti;
      700 	  substr (red_line, ti + 1, 3) = "\x[";
      701 	  ti = ti + 3;
      702 	  substr (red_line, ti + 1, j - 1) = substr (b_s, ex_next + 2, j - 1);
      703 	  ti = ti + j - 1;
      704 	  call set_exec (ex_next + j + 2);
      705 	  if (substr (b_s, ex_next, 1) = ".")
      706 	  then do;
      707 	     substr (red_line, ti + 1, 2) = ".]";
      708 	     ti = ti + 2;
      709 	  end;
      710 	  else do;
      711 	     if (substr (b_s, ex_next, 2) = "\c")
      712 	        | (substr (b_s, ex_next, 2) = "\C")
      713 	     then call set_exec (ex_next + 2);
      714 	     substr (red_line, ti + 1, 4) = """?""]";
      715 	     substr (red_line, ti + 2, 1) = substr (b_s, ex_next, 1);
      716 	     ti = ti + 4;
      717 	  end;
      718 	  if db_input
      719 	  then do;
      720 	     k = ti - j24;
      721 	     call ioa_$ioa_switch (db_output, 
      722 	        "^a: (^p->red_line,ti+1(^i),^i)=""^a"",len=^i", tmode,
      723 	     addr(red_line), j24+1, k, substr (red_line, j24+1, k), ti+k);
      724 	  end;
      725 	  call set_exec (ex_next + 1);
      726          end;
      727          else call ioa_ ("\[active_function] not implemented.");
      728 esc (6):				/* "\x[" (just passed thru)	       */
      729          goto move_ch;
      730 dcl result	char (500) var;
      731 dcl code		fixed bin (35); 





      732 rdp (3):				/* "\037" BREAK		       */
      733          if (tmode = "INPUT")
      734 	  | dbase.tedname = "qedx"
      735          then goto move_ch;
      736          call set_exec (ex_next + 1);
      737          if ^dbase.break_sw
      738          then goto end_loop;
      739          dbase.at_break = 1;
      740          red_char (ti + 1) = NL;
      741          goto end_read; 





      742 rdp (7):				/* \034 (old \f)		       */
      743          if b.tw_sw
      744          then goto move_ch;
      745          if ^b.bs.f
      746          then do;
      747 	  call ioa_ (old_msg, dbase.tedname, b.name, "4", "F");
      748 	  b.bs.f = "1"b;
      749          end;
      750          escl = 0;
      751 esc (4):				/* "\f"			       */
      752 rdp (0):
      753          if (tmode = "INPUT")
      754          then do;
      755 	  mode = "EOF";
      756 	  call set_exec (ex_next + 2);
      757 	  if (substr (b_s, ex_next, 1) = NL)
      758 	  then call set_exec (ex_next + 1);
      759 	  goto end_read;
      760          end;
      761 move_ch:
      762          ti = ti + 1;
      763          red_char (ti) = substr (b_s, ex_next, 1);
      764          call set_exec (ex_next + 1);
      765 end_loop:
      766       end;
      767 end_read:
      768 /**** INPUT/BULK modes will not return at EOline, they will return at EOinfo */
      769 /****  or EObuffer. Then last char used is updated for each line for -safe.  */
      770       nelemt = ti;			/* return last char in use	       */
      771 dcl EL_sw		bit(1);
      772 
      773       if (ti = 0)
      774       & (mode ^= "EOF")		/* this happens when \037 is first   */
      775       then goto reloop;		/* ..thing on a line.	       */
      776       if (ti = 0)			/* next statement will blow up if    */
      777       then EL_sw = "1"b;		/* ..ti=0, prevent that.	       */
      778       else EL_sw = (substr (red_line, ti, 1) ^= NL) | (mode = "EOF");
      779       if (tmode = "EDIT") & dbase.edit_sw
      780          | (tmode = "INPUT") & dbase.input_sw
      781       then call ioa_$nnl ("**^a**	^a^[^/^]", mode,
      782          substr (red_line, tti+1, ti-tti), EL_sw);
      783       if (osw_p ^= null())
      784       then if (tmode = osmode) | (osmode = "ALL")
      785       then call ioa_$ioa_switch_nnl (osw_p, "**^a**^-^a^[^/^]", mode,
      786          substr (red_line, tti+1, ti-tti), EL_sw);
      787       if (ti <= te)
      788       then if (mode = "INPUT") | (mode = "BULK")
      789       then goto reloop;
      790 read_exit:
      791       if db_ted
      792       then call ioa_$ioa_switch (db_output, "^a: ^i:^i:^i ^i", mode, ibi, ti, ibe, nelemt);
      793       return; 




      794 dcl osmode	char (8) int static init ("");
      795 dcl osw_p		ptr int static init (null());
      796 dcl iox_$look_iocb entry (char(*), ptr, fixed bin(35));
      797 dcl ioa_$ioa_switch_nnl entry() options(variable);
      798 dcl iox_$open	entry (ptr, fixed bin, bit(1) aligned, fixed bin(35));
      799 dcl error_table_$not_closed fixed bin(35) ext static;
      800 		
      801 osw: entry (p1, p2);
      802 dcl (p1,p2) char (*);
      803      call iox_$look_iocb (p1, osw_p, code);
      804      if (code ^= 0)
      805      then do;
      806         osw_p = null();
      807 osw_err:
      808         call com_err_ (code, "ted(osw)", "^a", p1);
      809         return;
      810      end;
      811      call iox_$open (osw_p, 2, ""b, code);
      812      if (code ^= 0)
      813      then do;
      814         if (code ^= error_table_$not_closed)
      815         then goto osw_err;
      816      end;
      817      osmode = p2;
      818      return; 



     
      819 tell_where: proc (mode);
      820 
      821 dcl mode		char (5);
      822 
      823       call ioa_ ("^a^[(^a)^;^s^]: ^a MODE[^i]^[safe^]",
      824          dbase.tedname, (dbase.tedname = "ted"), ted_vers, mode,
      825          dbase.recurs, (dbase.dir_db ^= ""));
      826 
      827    end tell_where;
      828 tederror_:			/* save {& print} an error message   */
      829    entry (adb_p, a_msg);
      830 dcl (
      831 /****adb_p	ptr,		/* -> dabatase		       */
      832     a_msg		char (168) var	/* error message		       */
      833     )		parm;
      834 
      835       dbase_p = adb_p;
      836       if (length (a_msg) < 6)
      837       then dbase.err_msg = "???) " || a_msg;
      838       else dbase.err_msg = a_msg;
      839       if (dbase.err_go = " ") | (dbase.at_break ^= 0)
      840       then do;
      841          if db_util
      842          then call ioa_$ioa_switch_nnl (iox_$error_output, "^a",
      843 	       substr (dbase.err_msg, 1, 5));
      844          call ioa_$ioa_switch_nnl (iox_$error_output, "^a^/",
      845 	  substr (dbase.err_msg, 6));
      846          if (osw_p ^= null())
      847          then call ioa_$ioa_switch_nnl (osw_p, "^a^/",
      848 	  substr (dbase.err_msg, 6));
      849       end;
      850       return;			/* tedread_ptr_ */




      851 /**** <<<<----- dcl_tedcall_.incl.pl1 tedcall_			       */
      852 tedcall_:				/* call a buffer		       */
      853    entry (adb_p, acode);
      854 dcl (
      855 /****adb_p	ptr,		/* -> database		       */
      856     acode		fixed bin (35)
      857     )		parm;		/* ----->>>>		       */
      858 
      859       acode = 0;
      860       dbase_p = adb_p;
      861       bp = dbase.stk_info.curp;
      862       used = rl_l - rl_i + 1;
      863       call tedget_existing_buffer_ (dbase_p, addr (rl_c (rl_i)),
      864          used, new_bp, msg);		/* try to find named buffer	       */
      865       rl_i = rl_i + used;
      866       if (new_bp = null ())		/* error if does not already exist   */
      867       then do;
      868          call tederror_ (dbase_p, msg);
      869          acode = 1;
      870          return;
      871       end;
      872       if (dbase.stk_info.level > 500)
      873       then do;
      874          msg = "Brc) Level > 500.";
      875          call tederror_ (dbase_p, msg);
      876          acode = 1;
      877          return;
      878       end;
      879       if (dbase.seg_p (3) = null())
      880       then call tedget_segment_ (dbase_p, null(), 3);
      881 /**** make room for argument string				       */
      882       pstrp = addr (call_stk.space (dbase.stk_info.next));
      883       pstrl = dbase.stk_info.next;
      884       i = rl_l - rl_i;
      885       dbase.stk_info.next = dbase.stk_info.next + divide (i + 7, 8, 24, 0);
      886       substr (pstrp -> str, 1, i) = substr (rl_s, rl_i, i);
      887       call push_one (pstrl);
      888       if (i > 0)			/* if argstring is non-null	       */
      889       then do;			/*  parse the arguments	       */
      890          sv.pp (0) = pstrp;
      891          sv.pl (0) = i;
      892          delim = pchar (1);
      893          sv.pn = 1;
      894          sv.pp (1) = addr (pchar (2));
      895          sv.pl (1) = 0;
      896          do ii = 2 to i;
      897 	  if (substr (pstrp -> str, ii, 2) = "\C")
      898 	     | (substr (pstrp -> str, ii, 2) = "\c")
      899 	  then do;
      900 	     if (pchar (ii + 2) = delim)
      901 	     then goto use_pch;
      902 	  end;
      903 	  if (pchar (ii) = delim)
      904 	  then do;
      905 	     sv.pn = sv.pn + 1;
      906 	     sv.pp (sv.pn) = addr (pchar (ii + 1));
      907 	     sv.pl (sv.pn) = 0;
      908 	  end;
      909 	  else do;
      910 use_pch:
      911 	     sv.pl (sv.pn) = sv.pl (sv.pn) + 1;
      912 	  end;
      913          end;
      914          dbase.stk_info.next = dbase.stk_info.next + sv.pn * 2 + 2;
      915       end;
      916       return /* tedcall_ */;
      917 dcl delim		char (1);
      918 dcl pstrp		ptr;
      919 dcl pchar		(1:2000) char (1) based (pstrp);
      920 dcl pstrl		fixed bin (21);
      921 /**** <<<<----- dcl_tedend_buffer_.incl.pl1 tedend_buffer_		       */
      922 tedend_buffer_:			/* pop buffer recursion 1 level      */
      923    entry (adb_p, ecode);
      924 dcl (
      925 /****adb_p	ptr,		/* -> database		       */
      926     ecode		fixed bin (35)	/* 1- already at level 0, 0- ok      */
      927     )		parm;		/* ----->>>>		       */
      928       i = ecode;
      929       dbase_p = adb_p;
      930       if (dbase.stk_info.level = 0)	/* check recursion level	       */
      931       then do;
      932          ecode = 1;			/* error if level already 0	       */
      933          return;			/* return error condition to caller  */
      934       end;
      935       call pop_one;
      936       if (i = COM) & (dbase.stk_info.level = 0)
      937       then ecode = 1;
      938       else ecode = 0;
      939       return;			/* and return to caller	       */




      940 
      941 pop_one: proc;
      942 
      943       if db_util
      944       then call tedshow_ (dbase_p, "stkall");
      945       bp = dbase.stk_info.curp;	/* current execution buffer	       */
      946       b.invoking = ""b;		/* clear execution range	       */
      947       unspec (b.ex) = unspec (tedcommon_$no_data);
      948       sv_p = dbase.stk_info.top;	/* pop a stack frame and restore...  */
      949       dbase.stk_info.top = sv.prev;	/* ...top of stack		       */
      950       dbase.stk_info.next = sv.this;	/* ...free location		       */
      951       dbase.stk_info.curp, bp = sv.bp;	/* ...buffer control block	       */
      952       b.ex = sv.ex;			/* ...read limits		       */
      953       b.invoking = (unspec (b.ex) ^= unspec (tedcommon_$no_data));
      954       b.a_ (0) = sv.a0;
      955       b.stackl = sv.stackl;
      956       dbase.stk_info.level = dbase.stk_info.level - 1;
      957 
      958    end pop_one; 
      959 push_one: proc (this);
      960 
      961 dcl this		fixed bin (21);
      962 
      963       dbase.stk_info.level
      964          = dbase.stk_info.level + 1;	/* bump recursion level	       */
      965       dbase.stk_info.curp = new_bp;	/* make new buffer current	       */
      966       if (dbase.seg_p (3) = null())
      967       then call tedget_segment_ (dbase_p, null(), 3);
      968       sv_p			/* create stack frame and save...    */
      969          = addr (call_stk.space (dbase.stk_info.next));
      970       sv.prev = dbase.stk_info.top;	/* ...current top of stack	       */
      971       sv.bp = bp;			/* ...current buffer control block   */
      972       sv.ex = b.ex;			/* ...execution limits	       */
      973       sv.a0 = b.a_ (0);		/* ..."." value		       */
      974       sv.stackl = b.stackl;		/* ...AND keep track of where this   */
      975       b.stackl = rel (sv_p);		/*    data is for relocation	       */
      976       sv.this = this;		/* ...free location		       */
      977       sv.pn = 0;			/* ...start as if no args	       */
      978       sv.pp (0) = null();
      979       sv.pl (0) = 0;
      980       dbase.stk_info.next = dbase.stk_info.next + size (sv);
      981       dbase.stk_info.top = sv_p;	/* push the stack frame	       */
      982       bp = dbase.stk_info.curp;	/* new current buffer	       */
      983       b.invoking = "1"b;					/* #156*/
      984       call init_exec (b.a_.l.re (1),  b.a_.r.le (2));		/* #156*/
      985       if db_util & lg_util
      986       then call tedshow_ (dbase_p, "stkall");
      987 
      988    end push_one; 




      989 tedresetread_:			/* abort to buffer level 0	       */
      990    entry (adb_p);
      991 
      992       dbase_p = adb_p;
      993       if dbase.stk_info.level ^= 0	/* if buffer recursion level > 0     */
      994       then do;
      995          call ioa_ ("Executing (level,line,buffer). [Recursion=^i]",
      996 	  dbase.recurs);
      997          bp = dbase.stk_info.curp;	/* current buffer		       */
      998          do while (dbase.stk_info.level ^= 0);/* release buff recursion stk  */
      999 	  call tedcount_lines_ (bp, 1, ex_next - 1, j);
     1000 	  call ioa_ ("^-^3i ^4i b(^a)", dbase.stk_info.level, j, b.name);
     1001 	  call pop_one;
     1002          end;
     1003       end;
     1004       bp = dbase.stk_info.curp;	/* get pointer to level 0 ctl block  */
     1005       ex_next = ex_last + 1;		/* set buffer exhausted	   #156*/
     1006       if reset_read
     1007       then call iox_$control (iox_$user_input, "resetread", null (), code);
     1008       return; 
     1009 set_req_line: entry;
     1010 
     1011       if (rdy.len ^= 0)
     1012       then do;
     1013          free rdy_line;
     1014          rdy.len = 0;
     1015       end;
     1016       call cu_$arg_ptr (1, tp, i21, code); dcl arg char (i21) based (tp);
     1017       if (code ^= 0)
     1018       then do;
     1019          return;
     1020       end;
     1021       rdy.len = i21;
     1022       allocate rdy_line;
     1023       rdy_line = arg;
     1024       return;
     1025 
     1026 dcl 1 rdy		int static,
     1027       2 len	fixed bin (21) init (0),
     1028       2 pt	ptr;
     1029 
     1030 dcl rdy_line	char (rdy.len) based (rdy.pt);
     1031 
     1032 get_req_line: entry;
     1033 
     1034       call cu_$af_arg_count (l, code);
     1035       if (code ^= 0)
     1036       then call ioa_ ("^a", rdy_line);
     1037       else do;
     1038 dcl cu_$af_return_arg entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
     1039 dcl af_val	char (af_len) var based (af_ptr);
     1040 dcl af_len	fixed bin (21);
     1041 dcl af_ptr	ptr;
     1042 dcl l		fixed bin;
     1043          call cu_$af_return_arg (l + 1, af_ptr, af_len, code);
     1044          af_val = rdy_line;
     1045       end;
     1046       return;			/* tedend_buffer_ */
     1047 
     1048 /**** <<<<----- dcl_tedcount_lines_.incl.pl1 tedcount_lines_	       */
     1049 tedcount_lines_:			/* return # lines in string	       */
     1050    entry (abp, asi, ase, alct);
     1051 dcl (
     1052     abp		ptr,		/* -> buffer in which to count       */
     1053     asi		fixed bin (21),	/* where string begins in segment    */
     1054     ase		fixed bin (21),	/* where string ends in segment      */
     1055     alct		fixed bin (21)	/* # lines		 [OUT] */
     1056     )		parm;		/* ----->>>>		       */
     1057 
     1058 dcl lct		fixed bin (21);
     1059 dcl loc		fixed bin (21);
     1060 
     1061       bp = abp;
     1062       lct = 0;
     1063       if db_util
     1064       then call ioa_$ioa_switch_nnl (db_output,
     1065          ".lct:sn=^i", b.cur.sn);
     1066       if (b.cur.sn ^= 0)		/* any data in buffer?	       */
     1067       then do;
     1068          call count ((asi), min (ase, b.b_.l.re));
     1069          call count (max (b.b_.r.le, asi), ase);
     1070          if (b.b_.r.re < b.b_.r.le)	/* upper part empty		       */
     1071          then loc = min (ase, b.b_.l.re);
     1072          else loc = ase;
     1073          
     1074 /* RW 88 */
     1075          if (loc ^= 0) then                                           /* #193*/
     1076              if (b_c (loc) ^= NL) then
     1077 		lct = lct + 1;
     1078       end;
     1079       alct = lct;
     1080       if db_util
     1081       then call ioa_$ioa_switch (db_output, " =^i", alct);
     1082       return;
     1083 
     1084 count: proc (ti, te);
     1085 dcl (ti		fixed bin (21),	/* beginning point		       */
     1086     te		fixed bin (21)	/* ending point		       */
     1087     )		parm;
     1088 
     1089 dcl lti		fixed bin (21);	/* local ti		       */
     1090 dcl str		char (te) based (b.cur.sp);
     1091 dcl II		fixed bin (21);
     1092 
     1093       lti = ti;
     1094       do while (lti <= te);
     1095          II = index (substr (str, lti), NL);
     1096          if (II ^= 0)		/* a NL found		       */
     1097          then do;
     1098 	  lct = lct + 1;		/* count one line		       */
     1099 	  lti = lti + II;		/* move past it		       */
     1100          end;
     1101          else lti = te + 1;
     1102       end;
     1103       if db_util
     1104       then call ioa_$ioa_switch_nnl (db_output, " ^i:^i ^i", ti, te, lct);
     1105 
     1106    end count; 
     1107 tedck_ptr_:			/* check on flagged ^read seg        */
     1108    entry (aabp);
     1109 dcl (
     1110     aabp		ptr		/* -> buffer control block	       */
     1111     )		parm;
     1112 
     1113 dcl error_table_$invalidsegno fixed bin (35) ext static;
     1114 dcl tuid		bit (36);
     1115 
     1116       bp = aabp;
     1117       call hcs_$get_uid_seg (b.cur.sp, tuid, code);
     1118       if (code = error_table_$invalidsegno)
     1119       then goto re_init;
     1120       if (code ^= 0)
     1121       then do;
     1122          call com_err_ (code, dbase.tedname,
     1123 	  "Checking on b(^a) segment ^a>^a", b.name, b.dname, b.ename);
     1124          goto re_init;
     1125       end;
     1126       if (tuid = b.uid)
     1127       then goto ck_out;
     1128 re_init:				/* assume can't do anything with     */
     1129 				/*  that pointer */
     1130       call hcs_$initiate_count (b.dname, b.ename, "", ii, 0, tp, code);
     1131       if (tp = null ())
     1132       then do;
     1133          b.b_ = tedcommon_$no_data;
     1134          dbase.not_read_ct = max (0, dbase.not_read_ct - 1);
     1135          call com_err_ (code, dbase.tedname,
     1136 	  "Trying to reconnect segment ^a>^a to b(^a)",
     1137 	  b.dname, b.ename, b.name);
     1138          b.dname = "";
     1139          b.file_sw = "0"b;
     1140          b.terminate = "0"b;
     1141          b.mod_sw = "0"b;
     1142          b.get_bit_count = "0"b;
     1143          b.not_pasted = "0"b;
     1144          goto ck_out;
     1145       end;
     1146       addr (b.cur.sp) -> its.segno = addr (tp) -> its.segno;
     1147       call hcs_$get_uid_seg (b.cur.sp, b.uid, code);
     1148       ii = divide (ii, 9, 24, 0);
     1149       if (ii ^= b.maxl)
     1150       then do;
     1151          call com_err_ (0, dbase.tedname,
     1152 	  "Segment ^a>^a connected to b(^a) changed size from ^i to ^i",
     1153 	  b.dname, b.ename, b.name, b.b_.r.re, ii);
     1154          b.maxl, b.b_.r.re, b.b_.l.re, b.b_.l.re = ii;
     1155          b.b_.l.le = 1;
     1156       end;
     1157 ck_out:
     1158       b.ck_ptr_sw = "0"b;
     1159       return; 
     1160 
     1161 dcl (
     1162     addcharno, addr, char, divide, index, length, max, min, null, rel, reverse,
     1163     rtrim, search, size, substr, unspec, verify
     1164     )		builtin;
     1165 
     1166 dcl (ex_next	defined b.ex.l.le,	/* next char to execute	       */
     1167     ex_EOD	defined b.ex.l.re,	/* last char in part to execute      */
     1168     ex_lre	defined b.ex.r.le,	/* last char in left part to execute */
     1169     ex_last	defined b.ex.r.re)	/* last char to execute	       */
     1170 		fixed bin (21);				/* #156*/
     1171 dcl ex_s		char (b.ex.l.re) based (b.cur.sp);
     1172 dcl ex_c		(b.ex.l.re) char (1) based (b.cur.sp);
  1     1 /* BEGIN INCLUDE FILE ..... tedbcb.incl.pl1 ..... 01/29/82 J Falksen	       */
  1     2 
  1     3 /* UPDATE HISTORY (finally)					       */
  1     4 /* EL#   date	TR	comments				       */
  1     5 /* --- 84-10-19 -------- add sws.INPUT				       */
  1     6 /* --- 84-10-29 -------- add sws.invoking			       */
  1     7 
  1     8 /* if the structure of buf_des changes, tedcommon_.alm and		       */
  1     9 /*  tedcommon.incl.pl1 must be appropriately changed		       */
  1    10 
  1    11 dcl 1 buf_des	(all_des) based (bp),  /* buffer part descriptor	       */
  1    12       2 l,			/* left end (LHE) data (see Note 1)  */
  1    13         3 ln	fixed bin (21),	/*  line number		       */
  1    14         3 le	fixed bin (21),	/*  left  end (LE) offset	       */
  1    15         3 re	fixed bin (21),	/*  right end (RE) offset	       */
  1    16       2 r		like buf_des.l;	/* right end (RHE) data	       */
  1    17 
  1    18 /* Note1:	buf_des describes 2 slightly different things, buffer parts and    */
  1    19 /* 	addresses. These are the circumstances:			       */
  1    20 /*							       */
  1    21 /*							       */
  1    22 /*		|...............<buffer>..........................|      */
  1    23 /*	  b.cur.sp|	|..........<window>...........|	|      */
  1    24 /*	Buffer:	xxxxxxxxxxwwwwwwwwwwwww...<hole>...wwwwwwxxxxxxxxxx      */
  1    25 /*			|	  |	     |	|	|      */
  1    26 /*	           b.b_.l.le|  b.b_.l.re|   b.b_.r.le|	|     maxl|      */
  1    27 /*		    	   b.b_.l.ln|	 b.b_.r.le|    maxln|      */
  1    28 /*					 b.b_.r.ln|	       */
  1    29 /*    b.b_.l.ln (if known) tells the # of lines in left part of window       */
  1    30 /*    b.b_.r.ln (if known) tells the # of lines the whole window	       */
  1    31 /*    b.maxln   (if known) tells the # of lines in the whole buffer	       */
  1    32 /*	Either left or right part may be null. A ^read file	       */
  1    33 /*	is in the right part. A file is always read at the	       */
  1    34 /*	upper end of the hole. This will usually minimize the	       */
  1    35 /*	amount of data movement during subsequent editing		       */
  1    36 /*	operations.					       */
  1    37 /*							       */
  1    38 /* Data movement which occurs within a request, for example substitute, can  */
  1    39 /*  cause an offset to temporarily point into the hole. This will clear up   */
  1    40 /*  before the operation is complete.				       */
  1    41 
  1    42 /*						N	       */
  1    43 /*	Address:	....xxxxxxxxxxsssss -- sssssssxxxxxxxxxxL....	       */
  1    44 /*		    |	    |	         |	|	       */
  1    45 /*		l.le|	l.re|	     r.le|      r.re|	       */
  1    46 /*			l.ln|		      r.ln|	       */
  1    47 /*	l.re is the beginning of the string addressed.		       */
  1    48 /*	l.le is the beginning of line containing location l.re	       */
  1    49 /*		Thus l.ln is related to both l.re and l.le	       */
  1    50 /*	r.re is the end of the string addressed.		       */
  1    51 /*	r.le is the end of line containing location r.re		       */
  1    52 /*		Thus r.ln is related to both r.re and r.le	       */
  1    53 /*	(l.le and r.le relate to the same line when 1 line is addressed)   */
  1    54 /* In line mode each request starts with     l.re=l.le   &   r.re=r.le       */
  1    55 /* In string mode a global request forces these conditions.		       */
  1    56 
  1    57 /*** b_c/b_s reference the string which represents the buffer data.	       */
  1    58 dcl b_c		(b.maxl) char (1) based (b.cur.sp);
  1    59 dcl b_s		char (b.maxl) based (b.cur.sp);
  1    60 
  1    61 dcl (live_des	init (8),
  1    62     all_des	init (13),
  1    63     reloc_first	init (2),		/* where to begin minus 1	       */
  1    64     reloc_last	init (8)		/* where to stop		       */
  1    65     )		fixed bin int static options (constant);
  1    66 dcl bp		ptr;
  1    67 dcl 1 b		based (bp),	/* ted buffer control block	       */
  1    68       2 b_	like buf_des,	/* defines buffer limits	       */
  1    69       2 newb	like buf_des,	/* pending buffer values	       */
  1    70       2 ex	like buf_des,	/* execution limits		       */
  1    71       2 a_	(0:2) like buf_des, /* address data		       */
  1    72 				/*  (0)  "cur location"	       */
  1    73 				/*  (1)  1st addr result	       */
  1    74 				/*  (2)  2nd addr result	       */
  1    75       2 cd	like buf_des,	/* copy destination		       */
  1    76       2 gb	like buf_des,	/* info for global processing	       */
  1    77       2 newa	like buf_des,	/* pending address values	       */
  1    78 				/*    ----limit of relocation----    */
  1    79 /* these are not relocated because they define the relocation data	       */
  1    80       2 rel_temp	like buf_des,	/* hold during relocation	       */
  1    81       2 temp	(0:2) like buf_des,	/* hold during [.]addr processing    */
  1    82       2 old,			/* where string used to be	       */
  1    83         3 (le,re)	fixed bin (21),	/*   ends of range		       */
  1    84       2 new	like b.old,	/* where string has gone to	       */
  1    85       2 test	like b.old,	/* allowable relocatable range       */
  1    86 				/* (may be 1 or 2 larger than b.old) */
  1    87       2 cur	like seg_des,	/* CURRENT buffer area info	       */
  1    88 				/*    (see note 2)		       */
  1    89       2 pend	like seg_des,	/* PENDING buffer area info	       */
  1    90       2 file_d,			/* file related data	       */
  1    91         3 dtcm	bit(36),		/* when read seg was modified	       */
  1    92         3 uid	bit(36),		/* unique ID of segment	       */
  1    93         3 dname	char(168),	/* directory of file	       */
  1    94         3 ename	char(32),		/* entry of file		       */
  1    95         3 cname	char(32),		/* component of file	       */
  1    96         3 kind	char(1)unal,	/* kind of component	       */
  1    97 				/* " "-none, ":"-archive	       */
  1    98 				/*  "|"-superfile		       */
  1    99         3 sws	unal,
  1   100           4 file_sw	        bit(1),	/* 1-file associated	       */
  1   101           4 trust_sw        bit(1),	/* 1-file name trustable	       */
  1   102           4 mod_sw	        bit(1),	/* 1-buffer has been modified	       */
  1   103           4 terminate       bit(1),	/* 1-dp points to file, terminate    */
  1   104           4 get_bit_count   bit(1),	/* 1-get_bit_count before using this */
  1   105 			/*  buffer, it may have been modified by       */
  1   106 			/*  externally via [ted$buffer xx] usage       */
  1   107           4 force_name      bit(1),	/* 1-name has been forced	       */
  1   108           4 no_io	        bit(1),	/* 1-no r w ^b allowed	       */
  1   109 				/*  (external string edit)	       */
  1   110           4 not_pasted      bit(1),	/* 1-data was moved into buffer but  */
  1   111 				/*  has not been read anywhere       */
  1   112           4 initiate        bit(1),	/* 1-must initiate on restart	       */
  1   113 				/*  (b% and b!)		       */
  1   114           4 ck_ptr_sw       bit(1),	/* 1-if segment is external, must    */
  1   115 				/*  check pointer before ref	       */
  1   116           4 pseudo	        bit (1),	/* 1-^read or read-only buffer       */
  1   117           4 INPUT	        bit (1),	/* 1-active INPUT mode on buffer     */
  1   118           4 invoking        bit (1),	/* 1-buffer being invoked	       */
  1   119           4 fill	        bit (14),
  1   120       2 name	char(16),		/* buffer name		       */
  1   121       2 fill	char(27),
  1   122       2 stackl	bit (18)aligned,	/* offset of list of stacked data    */
  1   123       2 stack_o	bit (18)aligned,	/* offset of data being relocated    */
  1   124       2 present	(0:2) bit(1),	/* 1 if addr present	       */
  1   125       2 tw_sw	      bit(1),	/* 1-typewriter buffer	       */
  1   126       2 bs,			/* Old-style escapes in this buffer  */
  1   127         3 (c,b,r,f)       bit(1),	/* 1-\031,\030,\036,\034 found       */
  1   128       2 noref	      bit(1),	/* 1-not ref'ed, don't list	       */
  1   129       2 maxl	fixed bin(21),	/* max buffer length in this AST     */
  1   130       2 maxln	fixed bin(21),	/* number of lines in buffer	       */
  1   131       2 state_r	fixed bin(21),	/* what state is request in	       */
  1   132       2 (N1,N2,N3)	fixed bin(21),	/* values kept for -safe_ty	       */
  1   133       2 state_b	fixed bin(21);	/* what state is buffer change in    */
  1   134 
  1   135 /* Note2:	sn=0	means empty because the database segment will never      */
  1   136 /*		contain a buffer holder			       */
  1   137 /* 	sn=-1 (&^b.terminate) means read-only data, if modification is     */
  1   138 /* 		done, a copy will be made.			       */
  1   139 /* 	sn=-1 (& b.terminate) means ^read file, if modification is done    */
  1   140 /* 		the file is read first			       */
  1   141 /* 	sn>0	means a buffer holder segment			       */
  1   142 
  1   143 /* END INCLUDE FILE ..... tedbcb.incl.pl1 ..... */
     1173 
  2     1 /* BEGIN INCLUDE FILE ..... tederror_.incl.pl1 ..... 09/02/76 J Falksen      */
  2     2 
  2     3 dcl tederror_	entry(ptr, char(168)var);
  2     4 dcl tederror_rc_	entry(ptr, char(168)var,fixed bin(35));
  2     5 
  2     6 dcl msg		char(168)var;
  2     7 dcl msg_ptr	ptr;
  2     8 
  2     9 /* END INCLUDE FILE ..... tederror_.incl.pl1 .....			       */
     1174 
  3     1 /* BEGIN INCLUDE FILE ..... tedstk.incl.pl1 ..... 04/16/76 J Falksen	       */
  3     2 
  3     3 dcl sv_p		ptr;
  3     4 dcl 1 sv		based (sv_p),
  3     5       2 prev	ptr,		/* ->previous frame		       */
  3     6       2 bp	ptr,		/* ->buffer control block last used  */
  3     7       2 ex	like b.ex,	/* execution limits in buffer	       */
  3     8       2 a0	like b.a_,	/* "." in buffer		       */
  3     9       2 stackl	bit (18)aligned,	/* linked list of occurances of same */
  3    10 				/*  buffer in the stack	       */
  3    11       2 fill	bit (36)aligned,
  3    12       2 this	fixed bin (21),	/* space index before this frame was */
  3    13 				/*  allocated		       */
  3    14       2 pn	fixed bin (21),	/* parameter number		       */
  3    15       2 pv (0:sv.pn),
  3    16         3 pp ptr,			/* pointer to parameter	       */
  3    17         3 pl fixed bin (21);		/* length of parameter	       */
  3    18 
  3    19 dcl  pstr		based char (256);
  3    20 
  3    21 dcl 1 call_stk	based (dbase.seg_p (3)),
  3    22       2 space	(2000) ptr;	/* place to put stack frames	       */
  3    23 
  3    24 /* END INCLUDE FILE ..... tedstk.incl.pl1 .....			       */
     1175 
  4     1 /* BEGIN INCLUDE FILE ..... tedbase.incl.pl1 ..... 02/09/82 J Falksen       */
  4     2 
  4     3 dcl NORMAL	fixed bin (24) int static init (0),
  4     4     SAFE		fixed bin (24) int static init (1),
  4     5     COM		fixed bin (24) int static init (2),
  4     6     RESTART	fixed bin (24) int static init (3);
  4     7 
  4     8 dcl rc_close	fixed bin (24) int static init (100);
  4     9 dcl rc_fail	fixed bin (24) int static init (10);
  4    10 dcl rc_nop	fixed bin (24) int static init (2);
  4    11 dcl rc_keyerr	fixed bin (24) int static init (1);
  4    12 
  4    13 /*** the request line as both string and character		       */
  4    14 dcl rl_b		fixed bin (21);	/* where current req begins	       */
  4    15 dcl rl_i		fixed bin (21) defined (dbase.rl.l.le);
  4    16 dcl rl_l		fixed bin (21) defined (dbase.rl.l.re);
  4    17 dcl rl_c		(rl_l) char (1) based (dbase.rl.sp);
  4    18 dcl rl_s		char (rl_l) based (dbase.rl.sp);
  4    19 
  4    20 dcl 1 seg_des	based,		/* segment descriptor	       */
  4    21       2 sp	ptr,		/* -> segment		       */
  4    22       2 sn	fixed bin,	/* sequence # in dbase	       */
  4    23       2 pn	fixed bin,	/* part #, if in pool	       */
  4    24       2 ast	fixed bin,	/* size of aste		       */
  4    25       2 mbz	fixed bin;	/* --reserved		       */
  4    26 
  4    27       
  4    28 
  4    29 dcl dbase_p	ptr;
  4    30 dcl dbase_vers_3	fixed bin int static init (3);
  4    31 dcl 1 dbase	based (dbase_p),
  4    32       2 version	fixed bin,
  4    33       2 recurs	fixed bin,	/* recursion level at which active   */
  4    34       2 bwd	ptr,		/* links active db's together	       */
  4    35       2 cba_p	ptr,		/* contains addr (cb (1))	       */
  4    36       2 eval_p	ptr,		/* contains cb (2).sp	       */
  4    37       2 rl,			/* describes the request buffer      */
  4    38         3 part1	like seg_des,	/* ..its segment		       */
  4    39         3 part2	like buf_des,	/* ..its limits		       */
  4    40       2 seg_p	(-1:72) ptr,	/* list of segment pointers	       */
  4    41 				/* seg_p(-1)is a temp for restart    */
  4    42 				/* seg_p(0) is the database	       */
  4    43 				/* seg_p(1) is the 1K/4K pool	       */
  4    44 				/* seg_p(2) is reserved for 16K pool */
  4    45 				/* seg_p(3) is reserved for call_stk */
  4    46       2 inuse_seg	bit (72) aligned,	/* which segments (1:72) are in use  */
  4    47 				/* seg_p(0) is ALWAYS in use	       */
  4    48       2 inuse_1K	bit (16) aligned,	/* which 1K buffers are in use       */
  4    49       2 inuse_4K	bit (12) aligned,	/* which 4K buffers are in use       */
  4    50       2 inuse_16K	bit (4) aligned,	/* which 16K buffers are in use      */
  4    51       2 reset	label,		/* where to go on a reset condition  */
  4    52       2 time	fixed bin (71),	/* time request id is based on       */
  4    53       2 seg_ct	fixed bin,	/* how many segments in use	       */
  4    54 				/* seg_p (0)--database	       */
  4    55 				/* seg_p (1)--4K pool (64K total)    */
  4    56 				/* seg_p (2)--16K pool (64K total)   */
  4    57       2 argct	fixed bin,	/* how many args to ted	       */
  4    58       2 S_count	fixed bin,	/* # matches on last substitute      */
  4    59       2 not_read_ct fixed bin,	/* how many "not-read" files	       */
  4    60       2 at_break	fixed bin,	/* 1-break pending, 2-break entered  */
  4    61       2 bufnum	fixed bin,	/* how many buffer control blocks    */
  4    62       2 lock        bit (36),		/* to find if active (set LAST!)     */
  4    63       2 cb_c_r	bit (18) aligned,	/* offset of current buffer	       */
  4    64       2 cb_w_r	bit (18) aligned,	/* offset of buffer being worked on  */
  4    65       2 sws,
  4    66         3 flow_sw	bit (1) unal,	/* -label specified		       */
  4    67         3 break_sw	bit (1) unal,	/* -break specified		       */
  4    68         3 edit_sw	bit (1) unal,	/* -trace_edit specified	       */
  4    69         3 input_sw	bit (1) unal,	/* -trace_input		       */
  4    70         3 old_style bit (1) unal,	/* 1-old-style escapes allowed       */
  4    71         3 remote_sw bit (1) unal,	/* 1-not in home_dir	       */
  4    72         3 read_sw   bit (1) unal,	/* 1-always read files	       */
  4    73         3 lit_sw    bit (1) unal,	/* 1-expressions are literal	       */
  4    74         3 fill	bit (28) unal,
  4    75       2 tedname	char (32) var,	/* name under which ted_ was called  */
  4    76       2 comment     char (256)var,	/* user ident of environment	       */
  4    77       2 err_msg	char (168)var,
  4    78       2 regexp	char (500),	/* holds the remembered regular expr */
  4    79 				/*  is placed here to get word       */
  4    80 				/*  alignment		       */
  4    81       2 dir_db	char (168),	/* where work segments live	       */
  4    82       2 person      char (22),	/* who started		       */
  4    83       2 project     char (9),		/* ...this environment	       */
  4    84       2 nulreq	char (2),		/* what is null request (p|P|!p)     */
  4    85       2 err_go	char (16),	/* label to go to on error	       */
  4    86       2 rq_id       char (19),	/* request id for this	       */
  4    87       2 stk_info,
  4    88         3 curp	ptr,		/* pointer to current buffer	       */
  4    89         3 top	ptr,		/* pointer to top of stack	       */
  4    90         3 level	fixed bin (21),	/* recursion depth		       */
  4    91         3 next	fixed bin (21);
  4    92       /* next space available in stack     */
  4    93       
  4    94 
  4    95 /* END INCLUDE FILE ..... tedbase.incl.pl1 .....			       */
     1176 
  5     1 /* BEGIN INCLUDE FILE ..... tedcommon_.incl.pl1 ..... 02/15/82 J Falksen */
  5     2 
  5     3 /*		         ted common data area			       */
  5     4 
  5     5 dcl 1 tedcommon_$id ext static,
  5     6       2 ted_vers char(12)var;		/*  version.revision	       */
  5     7 
  5     8 dcl 1 tedcommon_$no_data	like buf_des ext static;
  5     9 dcl 1 tedcommon_$no_seg	like seg_des ext static;
  5    10 
  5    11 dcl 1 tedcommon_$etc ext static,
  5    12       2 com_blank   bit(1)aligned,
  5    13       2 com1_blank  bit(1)aligned,
  5    14       2 caps	bit(1)aligned,
  5    15       2 reset_read	bit(1)aligned,
  5    16       2 sws,
  5    17         3 (db_ted, lg_ted)	bit(1)aligned,
  5    18         3 (db_addr, lg_addr)	bit(1)aligned,
  5    19         3 (db_eval, lg_eval)	bit(1)aligned,
  5    20         3 (db_sort, lg_sort)	bit(1)aligned,
  5    21         3 (db_gv, lg_gv)	bit(1)aligned,
  5    22         3 (db_util, lg_util)	bit(1)aligned,
  5    23         3 (db_srch, lg_srch)	bit(1)aligned,
  5    24         3 (db_glob, lg_glob)	bit(1)aligned,
  5    25         3 (db_trac, lg_sp4)	bit(1)aligned,
  5    26         3 (db_Ed, lg_sp3)	bit(1)aligned,
  5    27         3 (db_sp2, lg_sp2)	bit(1)aligned,
  5    28         3 (db_sp1, lg_sp1)	bit(1)aligned,
  5    29         3 (db_catch, lg_catch)bit(1)aligned,
  5    30       2 db_output ptr;
  5    31 
  5    32 /* END INCLUDE FILE ..... tedcommon_.incl.pl1 ..... */
     1177 
  6     1 /* BEGIN INCLUDE FILE its.incl.pl1
  6     2*   modified 27 July 79 by JRDavis to add its_unsigned
  6     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  6     4 
  6     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  6     6     2 pad1 bit (3) unaligned,
  6     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  6     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  6     9     2 pad2 bit (9) unaligned,
  6    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  6    11 
  6    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  6    13     2 pad3 bit (3) unaligned,
  6    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  6    15     2 pad4 bit (3) unaligned,
  6    16     2 mod bit (6) unaligned;				/* further modification */
  6    17 
  6    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  6    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  6    20     2 pad1 bit (27) unaligned,
  6    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  6    22 
  6    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  6    24     2 pad2 bit (3) unaligned,
  6    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  6    26     2 pad3 bit (3) unaligned,
  6    27     2 mod bit (6) unaligned;				/* further modification */
  6    28 
  6    29 
  6    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  6    31     2 pad1 bit (3) unaligned,
  6    32     2 segno fixed bin (15) unsigned unaligned,
  6    33     2 ringno fixed bin (3) unsigned unaligned,
  6    34     2 pad2 bit (9) unaligned,
  6    35     2 its_mod bit (6) unaligned,
  6    36 
  6    37     2 offset fixed bin (18) unsigned unaligned,
  6    38     2 pad3 bit (3) unaligned,
  6    39     2 bit_offset fixed bin (6) unsigned unaligned,
  6    40     2 pad4 bit (3) unaligned,
  6    41     2 mod bit (6) unaligned;
  6    42 
  6    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  6    44     2 pr_no fixed bin (3) unsigned unaligned,
  6    45     2 pad1 bit (27) unaligned,
  6    46     2 itp_mod bit (6) unaligned,
  6    47 
  6    48     2 offset fixed bin (18) unsigned unaligned,
  6    49     2 pad2 bit (3) unaligned,
  6    50     2 bit_offset fixed bin (6) unsigned unaligned,
  6    51     2 pad3 bit (3) unaligned,
  6    52     2 mod bit (6) unaligned;
  6    53 
  6    54 
  6    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  6    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  6    57 
  6    58 /* END INCLUDE FILE   its.incl.pl1 */
     1178 
     1179 dcl tedset_ck_ptr_	entry (ptr);
     1180 dcl tedget_existing_buffer_ entry (	/* find a named buffer	       */
     1181 		ptr,		/* -> database		       */
     1182 		ptr,		/* -> string containing buffer name  */
     1183 		fixed bin (21),	/*   length of string	  [IN] */
     1184 				/*   how much was used	 [OUT] */
     1185 		ptr,		/* buffer control block (OUT)        */
     1186 		char (168)var	/* error message text	       */
     1187 		);
     1188 
     1189 /*dcl tedget_buffer_entry (		/* find (or create) a buffer	       */
     1190 /*		ptr,		/* -> database		       */
     1191 /*		ptr,		/* -> string containing buffer name  */
     1192 /*		fixed bin (21),	/*   length of string	  [IN] */
     1193 /*				/*   how much was used	 [OUT] */
     1194 /*		ptr,		/* buffer control block (OUT)        */
     1195 /*		char (168)var	/* error message text	       */
     1196 /*		);					       */
     1197 
     1198 
     1199 dcl tedeval_	entry (		/* process evaluations	       */
     1200 		ptr,		/* -> database		       */
     1201 		ptr,		/* -> evaluation string	       */
     1202 		fixed bin (21),	/*   length thereof 	  [IN] */
     1203 				/*   amount used up 	 [OUT] */
     1204 		ptr,		/* -> buffer control block	       */
     1205 		ptr,		/* -> matched string in \g{...}      */
     1206 				/*    null otherwise	       */
     1207 		fixed bin (21),	/*  length of string in \g{...}      */
     1208 				/* <0 in \{...}, 0 otherwise	       */
     1209 		char (500) var,	/* output string, if any	       */
     1210 		char (168) var,	/* error message, if any	       */
     1211 		fixed bin (35)	/* return code		       */
     1212 		);
     1213 
     1214 
     1215 dcl tedshow_	entry options (variable);
  7     1 /* BEGIN INCLUDE FILE ..... tedsrch_.incl.pl1 ..... 10/21/82 J Falksen */
  7     2 
  7     3 dcl tedsrch_$init_exp entry (	/* initialize an expression area	       */
  7     4 	ptr,		/* -> compiled expression area	  [IN] */
  7     5 	fixed bin (21));	/*   length of area in words		  [IN] */
  7     6 
  7     7 dcl tedsrch_$compile entry (	/* compile a regular expression	       */
  7     8 	ptr,		/* -> regular expression to compile	  [IN] */
  7     9 	fixed bin (21),	/*   length thereof			  [IN] */
  7    10 	ptr,		/* -> compiled expression area	  [IN] */
  7    11 	bit (1)aligned,	/* 0- line mode	1- string mode	  [IN] */
  7    12 	bit (1)aligned,	/* 0- reg expr	1- literal expr	  [IN] */
  7    13 	char (168) var,	/* error message			 [OUT] */
  7    14 	fixed bin (35)	/* error status code		 [OUT] */
  7    15 		);
  7    16 
  7    17 dcl tedsrch_$search entry (	/* search for expression		       */
  7    18 	ptr,		/* -> compiled expression area	  [IN] */
  7    19 	ptr,		/* -> buffer ctl block for file	  [IN] */
  7    20 	fixed bin (21),	/* beginning of string to search in file  [IN] */
  7    21 	fixed bin (21),	/* end of string to search		  [IN] */
  7    22 	fixed bin (21),	/* beginning of match		 [OUT] */
  7    23 	fixed bin (21),	/* end of match			 [OUT] */
  7    24 	fixed bin (21),	/* end of string used for match	 [OUT] */
  7    25 	char (168)var,	/* error message return		 [OUT] */
  7    26 	fixed bin (35)	/* error status code		 [OUT] */
  7    27 		);
  7    28 
  7    29 
  7    30 /* END INCLUDE FILE ..... tedsrch_.incl.pl1 ..... */
     1216 
     1217 dcl tedget_segment_ entry (		/* get a segment to work in	       */
     1218 		ptr,		/* -> database		       */
     1219 		ptr,		/* -> gotten segment	 [OUT] */
     1220 		fixed bin,	/* sequence # of it         [IN/OUT] */
     1221 				/* if >0 upon entry, it will then    */
     1222 				/*  fill that entry in seg_p array   */
     1223 				/* otherwise it will take any one    */
     1224 		);
     1225 
     1226 
     1227 dcl tedpromote_	entry (		/* get a larger data buffer	       */
     1228 		ptr,		/* -> buffer to promote	       */
     1229 		fixed bin (21)	/* amount not fitting	       */
     1230 		);
     1231 
     1232 
     1233 
     1234    end tedutil_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1127.9  tedutil_.pl1                      >udd>sm>ds>w>ml>tedutil_.pl1
1173         1    12/18/84  1054.3  tedbcb.incl.pl1                   >ldd>incl>tedbcb.incl.pl1
1174         2    11/23/82  1424.7  tederror_.incl.pl1                >ldd>incl>tederror_.incl.pl1
1175         3    11/23/82  1424.7  tedstk.incl.pl1                   >ldd>incl>tedstk.incl.pl1
1176         4    11/23/82  1424.7  tedbase.incl.pl1                  >ldd>incl>tedbase.incl.pl1
1177         5    12/18/84  1054.3  tedcommon_.incl.pl1               >ldd>incl>tedcommon_.incl.pl1
1178         6    11/26/79  1420.6  its.incl.pl1                      >ldd>incl>its.incl.pl1
1216         7    12/10/82  1405.8  tedsrch_.incl.pl1                 >ldd>incl>tedsrch_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
COM                                    constant        fixed bin(24,0)          initial dcl 4-3 ref 936
EL_sw                           000557 automatic       bit(1)                   packed unaligned dcl 771 set ref 776* 778* 779* 783*
ESCAPES                         000020 constant        char(14)                 initial packed unaligned dcl 658 ref 523 661
ESCmax                                 constant        fixed bin(17,0)          initial dcl 660 ref 524 524 665 665
II                              000733 automatic       fixed bin(21,0)          dcl 1091 set ref 1095* 1096 1099
INPUT                   234(20)        based           bit(1)                   level 4 packed packed unaligned dcl 1-67 ref 583
NL                              011200 constant        char(1)                  initial packed unaligned dcl 80 ref 122 133 147 149
                                                                                  165 305 319 434 458 497 641 740 757 778 1075 1095
a0                       12            based           structure                level 2 unaligned dcl 3-4 set ref 954 973*
a_                       22            based           structure                array level 2 unaligned dcl 1-67 set ref 676 682*
                                                                                  954* 973
a_msg                                  parameter       varying char(168)        dcl 830 ref 828 836 836 838
aabp                                   parameter       pointer                  dcl 1109 ref 1107 1116
abp                                    parameter       pointer                  dcl 1051 ref 1049 1061
acode                                  parameter       fixed bin(35,0)          dcl 854 set ref 852 859* 869* 876*
adb_p                                  parameter       pointer                  dcl 99 ref 97 108 273 274 347 364 828 835 852 860
                                                                                  922 929 989 992
addcharno                                              builtin function         dcl 1161 ref 473 473 536 536 543 543
addr                                                   builtin function         dcl 1161 ref 387 387 432 473 473 498 498 536 536 543
                                                                                  543 565 565 618 634 634 679 679 687 687 687 687
                                                                                  721 721 863 863 882 894 906 968 1146 1146
adr_hold                        000336 automatic       structure                array level 1 unaligned dcl 673 set ref 676* 682
af_len                          000565 automatic       fixed bin(21,0)          dcl 1040 set ref 1043* 1044
af_ptr                          000566 automatic       pointer                  dcl 1041 set ref 1043* 1044
af_val                                 based           varying char             dcl 1039 set ref 1044*
alct                                   parameter       fixed bin(21,0)          dcl 1051 set ref 1049 1079* 1080*
arg                                    based           char                     packed unaligned dcl 1016 ref 1023
ase                                    parameter       fixed bin(21,0)          dcl 1051 set ref 1049 1068 1068 1069* 1070 1072
asi                                    parameter       fixed bin(21,0)          dcl 1051 ref 1049 1068 1069 1069
at_break                270            based           fixed bin(17,0)          level 2 dcl 4-31 set ref 114 116* 293 303 323* 371
                                                                                  739* 839
atp                                    parameter       pointer                  dcl 349 set ref 333* 340 340 343 347 444 445 472 473
                                                                                  473 488 497 498 498 534 536 536 543 543 548 632
                                                                                  634 634 641 686 687 687 700 702 707 714 715 721
                                                                                  721 721 721 740 763 778 779 779 783 783
b                                      based           structure                level 1 unaligned dcl 1-67 in procedure "tedutil_"
b                       252(05)        based           bit(1)                   level 3 in structure "b" packed packed unaligned
                                                                                  dcl 1-67 in procedure "tedutil_" set ref 555 558*
b_                                     based           structure                level 2 unaligned dcl 1-67 set ref 1133*
b_c                                    based           char(1)                  array packed unaligned dcl 1-58 set ref 565 565 679
                                                                                  679 1075
b_s                                    based           char                     packed unaligned dcl 1-59 ref 149 165 191 198 203
                                                                                  210 305 314 319 320 408 408 412 428 434 452 458
                                                                                  462 472 483 518 523 534 548 661 669 693 695 702
                                                                                  705 711 711 715 757 763
bp                        2            based           pointer                  level 2 in structure "sv" dcl 3-4 in procedure
                                                                                  "tedutil_" set ref 951 971*
bp                              000574 automatic       pointer                  dcl 1-66 in procedure "tedutil_" set ref 124* 125
                                                                                  127 127 127 127 129 129 135 135 135 135 135 138
                                                                                  145 145 147 147 147 149 149 149 149 149 149 149
                                                                                  154 161 162 165 165 165 166 171 175 175 178 183
                                                                                  189 191 191 198 198 198 200 200 203 203 203 205
                                                                                  210 210 210 211 227 227 241 241* 243 244 244 245
                                                                                  245 245 247 247 252 252* 254 256 256 256 256 256
                                                                                  260 260 261 261 261 261 263 263 267 267 270 270*
                                                                                  275* 276 276 277 301* 301 302 305 305 305 308 312
                                                                                  314 314 314 319 319 319 320 320 320 367* 373 373*
                                                                                  378 378 381 383 391 393 393 394 394 395* 399 400
                                                                                  400 400 408 408 408 408 408 408 411 412 412 412
                                                                                  416 424* 428 428 428 428 428 431 432 432 433 433
                                                                                  434 434 434 438 440 449 449 452 452 452 454 458
                                                                                  458 458 462 462 462 472 472 472 473 473 473 473
                                                                                  477 481 481 483 483 483 484 501 506 509 511 512
                                                                                  518 518 518 521 521 523 523 523 534 534 534 536
                                                                                  536 536 536 543 543 543 543 548 548 548 550 552
                                                                                  555 557 558 561 564 564 565 565 565 565 567 596
                                                                                  596 596 596 599 602 604 605 617 661 661 661 669
                                                                                  669 669 672 674 676 677 677 678 678 679 679 679
                                                                                  679 679* 681 682 693 693 693 695 695 695 702 702
                                                                                  702 704 705 705 705 711 711 711 711 711 711 711
                                                                                  715 715 715 725 736 742 745 747 748 756 757 757
                                                                                  757 757 763 763 763 764 861* 945* 946 947 951* 952
                                                                                  953 953 954 955 971 972 973 974 975 982* 983 984
                                                                                  984 997* 999* 999 1000 1004* 1005 1005 1061* 1063
                                                                                  1066 1068 1068 1069 1069 1070 1070 1070 1075 1095
                                                                                  1116* 1117 1122 1122 1122 1126 1128 1128 1133 1135
                                                                                  1135 1135 1138 1139 1140 1141 1142 1143 1146 1147
                                                                                  1147 1149 1151 1151 1151 1151 1154 1154 1154 1154
                                                                                  1155 1157
break_sw                275(01)        based           bit(1)                   level 3 packed packed unaligned dcl 4-31 ref 737
bs                      252(04)        based           structure                level 2 packed packed unaligned dcl 1-67
buf_des                                based           structure                array level 1 unaligned dcl 1-11
c                       252(04)        based           bit(1)                   level 3 packed packed unaligned dcl 1-67 set ref 509
                                                                                  512*
call_stk                               based           structure                level 1 unaligned dcl 3-21
char                                                   builtin function         dcl 1161 ref 227
ck_ptr_sw               234(18)        based           bit(1)                   level 4 packed packed unaligned dcl 1-67 set ref
                                                                                  1157*
code                            000556 automatic       fixed bin(35,0)          dcl 731 set ref 286 288 290* 333* 335 387* 400* 403
                                                                                  442* 621* 623 679* 683 803* 804 807* 811* 812 814
                                                                                  1006* 1016* 1017 1034* 1035 1043* 1117* 1118 1120
                                                                                  1122* 1128* 1135* 1147*
com_err_                        000024 constant        entry                    external dcl 71 ref 290 807 1122 1135 1151
concealsw                       000121 automatic       bit(1)                   packed unaligned dcl 67 set ref 366*
cu_$af_arg_count                000030 constant        entry                    external dcl 73 ref 1034
cu_$af_return_arg               000062 constant        entry                    external dcl 1038 ref 1043
cu_$arg_ptr                     000020 constant        entry                    external dcl 68 ref 1016
cu_$cp                          000032 constant        entry                    external dcl 74 ref 387 442
cur                     124            based           structure                level 2 unaligned dcl 1-67
curp                    754            based           pointer                  level 3 dcl 4-31 set ref 124 275 367 424 861 945
                                                                                  951* 965* 982 997 1004
db_catch                 34     000074 external static bit(1)                   level 3 dcl 5-11 ref 340 408 628
db_input                        000134 automatic       bit(1)                   packed unaligned dcl 360 set ref 363* 473 498 536
                                                                                  543 634 687 718
db_output                36     000074 external static pointer                  level 2 dcl 5-11 set ref 340* 408* 473* 498* 536*
                                                                                  543* 628* 634* 687* 721* 790* 1063* 1080* 1103*
db_ted                    4     000074 external static bit(1)                   level 3 dcl 5-11 ref 363 790
db_util                  16     000074 external static bit(1)                   level 3 dcl 5-11 ref 241 252 270 373 841 943 985
                                                                                  1063 1080 1103
dbase                                  based           structure                level 1 unaligned dcl 4-31
dbase_p                         000654 automatic       pointer                  dcl 4-29 set ref 108* 114 116 124 229* 274* 275 277
                                                                                  277 290 293 298 302 303 323 325 364* 367 371 423*
                                                                                  424 441* 484 511 557 565* 574* 575* 590 595 604
                                                                                  638 679* 732 737 739 747 779 779 823 823 823 823
                                                                                  835* 836 838 839 839 841 841 844 844 846 846 860*
                                                                                  861 862 862 863* 863 863 863 863 865 865 868* 872
                                                                                  875* 879 879* 882 882 883 884 884 885 885 886 886
                                                                                  886 914 914 929* 930 936 943* 945 948 949 950 951
                                                                                  956 956 963 963 965 966 966* 968 968 970 980 980
                                                                                  981 982 985* 992* 993 995 997 998 1000 1004 1122
                                                                                  1134 1134 1135 1151
dec6                            000130 automatic       picture(6)               packed unaligned dcl 309 set ref 310* 311
delim                           000560 automatic       char(1)                  packed unaligned dcl 917 set ref 892* 900 903
dir_db                  660            based           char(168)                level 2 packed packed unaligned dcl 4-31 ref 823
divide                                                 builtin function         dcl 1161 ref 885 1148
dname                   142            based           char(168)                level 3 packed packed unaligned dcl 1-67 set ref
                                                                                  1122* 1128* 1135* 1138* 1151*
ecode                                  parameter       fixed bin(35,0)          dcl 924 set ref 922 928 932* 936* 938*
edit_sw                 275(02)        based           bit(1)                   level 3 packed packed unaligned dcl 4-31 ref 779
ename                   214            based           char(32)                 level 3 packed packed unaligned dcl 1-67 set ref
                                                                                  1122* 1128* 1135* 1151*
err_go                  742(09)        based           char(16)                 level 2 packed packed unaligned dcl 4-31 set ref
                                                                                  325* 839
err_msg                 410            based           varying char(168)        level 2 dcl 4-31 set ref 836* 838* 841 841 844 844
                                                                                  846 846
error_table_$end_of_info        000112 external static fixed bin(35,0)          dcl 282 ref 286
error_table_$invalidsegno       000064 external static fixed bin(35,0)          dcl 1113 ref 1118
error_table_$io_no_permission   000114 external static fixed bin(35,0)          dcl 283 ref 288
error_table_$not_closed         000060 external static fixed bin(35,0)          dcl 799 ref 814
escl                            000112 automatic       fixed bin(21,0)          dcl 59 set ref 514* 518 521 523 534 534 536 536 540
                                                                                  543 543 548 550 560* 561 607* 617 667* 750*
ex                       14            based           structure                level 2 in structure "b" unaligned dcl 1-67
                                                                                  in procedure "tedutil_" set ref 947* 952* 953 972
ex                        4            based           structure                level 2 in structure "sv" unaligned dcl 3-4
                                                                                  in procedure "tedutil_" set ref 952 972*
ex_EOD                                 defined         fixed bin(21,0)          dcl 1166 set ref 127 127* 145 149 175 245* 247* 256*
                                                                                  260* 378 383 412 416* 428 433 449 481 521 564 678
ex_c                                   based           char(1)                  array packed unaligned dcl 1172 set ref 432
ex_last                                defined         fixed bin(21,0)          dcl 1166 set ref 127 129* 135 138* 149 149 175 243*
                                                                                  245 256 260 596 1005
ex_lre                                 defined         fixed bin(21,0)          dcl 1166 set ref 244* 245 247
ex_next                                defined         fixed bin(21,0)          dcl 1166 set ref 145 147 154 162 165 166 171* 183
                                                                                  254* 256 261 261* 263 267* 276 301 305 308 312 314
                                                                                  319 320 378 428 428 431 432 433 434 438 440 449
                                                                                  452 454 458 462 472 473 473 477 481 483 501 518
                                                                                  521 523 534 536 536 543 543 548 550 561 564 565
                                                                                  565 567 596 617 661 669 672 674 678 679 679 681
                                                                                  693 695 702 704 705 711 711 711 715 725 736 756
                                                                                  757 757 763 764 999 1005*
ex_next_in_gap                  000666 stack reference condition                dcl 266 ref 265
ex_s                                   based           char                     packed unaligned dcl 1171 ref 147
f                       252(07)        based           bit(1)                   level 3 packed packed unaligned dcl 1-67 set ref 745
                                                                                  748*
file_d                  140            based           structure                level 2 packed packed unaligned dcl 1-67
file_sw                 234(09)        based           bit(1)                   level 4 packed packed unaligned dcl 1-67 set ref
                                                                                  1139*
get_bit_count           234(13)        based           bit(1)                   level 4 packed packed unaligned dcl 1-67 set ref
                                                                                  1142*
hcs_$get_uid_seg                000040 constant        entry                    external dcl 77 ref 1117 1147
hcs_$initiate_count             000022 constant        entry                    external dcl 69 ref 1128
hot_chars                       000040 constant        char(7)                  initial packed unaligned dcl 464 ref 462 483 518
i                               000107 automatic       fixed bin(21,0)          dcl 59 set ref 144* 164* 169* 884* 885 886 886 888
                                                                                  891 896 928* 936
i21                             000115 automatic       fixed bin(21,0)          dcl 62 set ref 434* 435 437* 438 440 442* 1016* 1021
                                                                                  1023
ibe                                    parameter       fixed bin(21,0)          dcl 349 set ref 333* 340 340 343 347 370 445 472 473
                                                                                  473 488 498 498 534 536 536 543 543 632 634 634
                                                                                  686 687 687 700 702 707 714 715 721 721 721 721
                                                                                  778 779 779 783 783 790*
ibi                                    parameter       fixed bin(21,0)          dcl 349 set ref 347 368 369 790*
ii                              000114 automatic       fixed bin(21,0)          dcl 61 set ref 896* 897 897 900 903 906* 1128* 1148*
                                                                                  1148 1149 1151* 1154
index                                                  builtin function         dcl 1161 ref 144 147 149 164 165 198 210 227 305 319
                                                                                  434 458 483 518 523 651 661 1095
input_sw                275(03)        based           bit(1)                   level 3 packed packed unaligned dcl 4-31 ref 779
invoking                234(21)        based           bit(1)                   level 4 packed packed unaligned dcl 1-67 set ref
                                                                                  946* 953* 983*
ioa_                            000026 constant        entry                    external dcl 72 ref 277 298 302 321 511 557 604 727
                                                                                  747 823 995 1000 1035
ioa_$ioa_switch                 000036 constant        entry                    external dcl 76 ref 473 498 536 543 634 687 721 790
                                                                                  1080
ioa_$ioa_switch_nnl             000054 constant        entry                    external dcl 797 ref 340 408 628 783 841 844 846
                                                                                  1063 1103
ioa_$nnl                        000034 constant        entry                    external dcl 75 ref 779
iox_$control                    000050 constant        entry                    external dcl 90 ref 1006
iox_$error_output               000046 external static pointer                  dcl 89 set ref 841* 844*
iox_$get_line                   000042 constant        entry                    external dcl 86 ref 333 400 621
iox_$look_iocb                  000052 constant        entry                    external dcl 796 ref 803
iox_$open                       000056 constant        entry                    external dcl 798 ref 811
iox_$user_input                 000044 external static pointer                  dcl 88 set ref 333* 400* 621* 1006*
its                                    based           structure                level 1 dcl 6-5
j                               000110 automatic       fixed bin(21,0)          dcl 59 set ref 145* 147* 149 149* 152 154 165* 166
                                                                                  166 188* 198* 200 210* 211 211* 211 215 217 276*
                                                                                  277* 301* 302* 310 523* 524 524* 524 526 661* 663
                                                                                  665 665* 665 668 693* 695 702 702 703 704 999*
                                                                                  1000*
j24                             000116 automatic       fixed bin(21,0)          dcl 63 set ref 621* 628 628 631* 631 632 632 634*
                                                                                  634 637 644 685* 686 687* 687 690 699* 720 721 721
                                                                                  721
jj                              000117 automatic       fixed bin(21,0)          dcl 64 set ref 161* 162 162* 165 165 171 177*
k                               000111 automatic       fixed bin(21,0)          dcl 59 set ref 305* 306 306* 308* 308 312 314 314
                                                                                  319* 320 458* 462* 467 467* 469* 469 470 472 472
                                                                                  473* 473 476 477 483* 484 493 518* 519 526* 528*
                                                                                  530 530 530 720* 721* 721 721 721
kharv                                  parameter       char                     packed unaligned dcl 99 ref 97 109 120 121
kk                              000135 automatic       fixed bin(21,0)          dcl 443 set ref 433* 434 437
kode                                   parameter       fixed bin(35,0)          dcl 99 set ref 97 111* 117* 139* 156* 172* 184* 194*
                                                                                  206* 218* 221 230*
l                         4            based           structure                level 3 in structure "sv" unaligned dcl 3-4
                                                                                  in procedure "tedutil_"
l                               000570 automatic       fixed bin(17,0)          dcl 1042 in procedure "tedutil_" set ref 1034* 1043
l                                      based           structure                array level 2 in structure "buf_des" unaligned
                                                                                  dcl 1-11 in procedure "tedutil_"
l                        52            based           structure                level 3 in structure "b" unaligned dcl 1-67
                                                                                  in procedure "tedutil_"
l                        44            based           structure                level 3 in structure "b" unaligned dcl 1-67
                                                                                  in procedure "tedutil_"
l                        14            based           structure                level 3 in structure "b" unaligned dcl 1-67
                                                                                  in procedure "tedutil_"
l                               000336 automatic       structure                array level 2 in structure "adr_hold" unaligned
                                                                                  dcl 673 in procedure "tedutil_"
l                        12            based           structure                level 3 in structure "sv" unaligned dcl 3-4
                                                                                  in procedure "tedutil_"
l                        66            based           structure                level 3 in structure "b" unaligned dcl 1-67
                                                                                  in procedure "tedutil_"
l                               000072 external static structure                level 2 in structure "tedcommon_$no_data" unaligned
                                                                                  dcl 5-8 in procedure "tedutil_"
l                        60            based           structure                level 3 in structure "b" unaligned dcl 1-67
                                                                                  in procedure "tedutil_"
l                        22            based           structure                array level 3 in structure "b" unaligned dcl 1-67
                                                                                  in procedure "tedutil_"
l                         6            based           structure                level 3 in structure "b" unaligned dcl 1-67
                                                                                  in procedure "tedutil_"
l                        74            based           structure                array level 3 in structure "b" unaligned dcl 1-67
                                                                                  in procedure "tedutil_"
l                                      based           structure                level 3 in structure "b" unaligned dcl 1-67
                                                                                  in procedure "tedutil_"
l                        16            based           structure                level 4 in structure "dbase" unaligned dcl 4-31
                                                                                  in procedure "tedutil_"
lab                             000122 automatic       char(20)                 packed unaligned dcl 105 set ref 121* 122* 123* 131
                                                                                  131* 133 142 144 159 164 191 198 203 210 225
labl                            000127 automatic       fixed bin(21,0)          dcl 106 set ref 120* 189 191 191 198 200 203 203 210
                                                                                  225
lct                             000571 automatic       fixed bin(21,0)          dcl 1058 set ref 1062* 1075* 1075 1079 1098* 1098
                                                                                  1103*
le                        1            based           fixed bin(21,0)          level 4 in structure "b" dcl 1-67 in procedure
                                                                                  "tedutil_" set ref 393 1155*
le                       26            based           fixed bin(21,0)          array level 4 in structure "b" dcl 1-67 in procedure
                                                                                  "tedutil_" set ref 984*
le                       20            based           fixed bin(21,0)          level 4 in structure "b" dcl 1-67 in procedure
                                                                                  "tedutil_" set ref 244* 244 245 245 247 247
le                       15            based           fixed bin(21,0)          level 4 in structure "b" dcl 1-67 in procedure
                                                                                  "tedutil_" set ref 145 145 147 147 154 154 162 162
                                                                                  165 165 166 166 171* 171 183 183 254* 254 256 256
                                                                                  261 261 261* 261 263 263 267* 267 276 276 301 301
                                                                                  305 305 308 308 312 312 314 314 319 319 320 320
                                                                                  378 378 428 428 428 428 431 431 432 432 433 433
                                                                                  434 434 438 438 440 440 449 449 452 452 454 454
                                                                                  458 458 462 462 472 472 473 473 473 473 477 477
                                                                                  481 481 483 483 501 501 518 518 521 521 523 523
                                                                                  534 534 536 536 536 536 543 543 543 543 548 548
                                                                                  550 550 561 561 564 564 565 565 565 565 567 567
                                                                                  596 596 617 617 661 661 669 669 672 672 674 674
                                                                                  678 678 679 679 679 679 681 681 693 693 695 695
                                                                                  702 702 704 704 705 705 711 711 711 711 711 711
                                                                                  715 715 725 725 736 736 756 756 757 757 757 757
                                                                                  763 763 764 764 999 999 1005* 1005
le                        4            based           fixed bin(21,0)          level 4 in structure "b" dcl 1-67 in procedure
                                                                                  "tedutil_" set ref 135 149 149 161 200 203 205*
                                                                                  210 211 261 263 267 394* 1069 1069 1070
le                       17            based           fixed bin(21,0)          level 5 in structure "dbase" dcl 4-31 in procedure
                                                                                  "tedutil_" set ref 862 862 863 863 863 863 865*
                                                                                  865 865 865 884 884 886 886
left                                   parameter       fixed bin(21,0)          dcl 239 ref 237 245 250 254
len                             000014 internal static fixed bin(21,0)          initial level 2 dcl 1026 set ref 383 385 386 387*
                                                                                  1011 1013 1013 1014* 1021* 1022 1022 1023 1035
                                                                                  1035 1044
length                                                 builtin function         dcl 1161 ref 120 621 621 685 836
level                   760            based           fixed bin(21,0)          level 3 dcl 4-31 set ref 277* 302* 590 872 930 936
                                                                                  956* 956 963* 963 993 998 1000*
lg_util                  17     000074 external static bit(1)                   level 3 dcl 5-11 ref 241 252 270 985
loc                             000572 automatic       fixed bin(21,0)          dcl 1059 set ref 1070* 1072* 1075 1075
lti                             000732 automatic       fixed bin(21,0)          dcl 1089 set ref 1093* 1094 1095 1099* 1099 1101*
max                                                    builtin function         dcl 1161 ref 1069 1069 1134
maxl                    253            based           fixed bin(21,0)          level 2 dcl 1-67 set ref 149 165 191 198 200 203 210
                                                                                  305 314 319 320 400* 408 408 412 428 434 452 458
                                                                                  462 472 483 518 523 534 548 596 661 669 693 695
                                                                                  702 705 711 711 715 757 763 1149 1154*
min                                                    builtin function         dcl 1161 ref 244 256 449 631 685 1068 1068 1070
mod_sw                  234(11)        based           bit(1)                   level 4 packed packed unaligned dcl 1-67 set ref
                                                                                  1141*
mode                                   parameter       char(5)                  packed unaligned dcl 821 in procedure "tell_where"
                                                                                  set ref 819 823*
mode                                   parameter       char(5)                  packed unaligned dcl 349 in procedure "tedutil_" set
                                                                                  ref 296 296 347 362 455* 578* 653* 755* 773 778
                                                                                  779* 783* 787 787 790*
msg                             000576 automatic       varying char(168)        dcl 2-6 set ref 223* 225* 225 226* 226 227* 227 228*
                                                                                  228 229* 311* 314* 314 315* 315 317* 317 320* 320
                                                                                  321 565* 570* 570 574* 585* 586* 586 587* 587 592*
                                                                                  679* 863* 868* 874* 875*
name                    235            based           char(16)                 level 2 packed packed unaligned dcl 1-67 set ref 227
                                                                                  227 277* 302* 511* 557* 586 604* 747* 1000* 1122*
                                                                                  1135* 1151*
nelemt                                 parameter       fixed bin(21,0)          dcl 349 set ref 333* 340 340 343 347 368* 767* 790*
new_bp                          000102 automatic       pointer                  dcl 59 set ref 565* 568 583 586 863* 866 965
next                    761            based           fixed bin(21,0)          level 3 dcl 4-31 set ref 595* 882 883 885* 885 914*
                                                                                  914 950* 968 980* 980
not_pasted              234(16)        based           bit(1)                   level 4 packed packed unaligned dcl 1-67 set ref
                                                                                  596* 1143*
not_read_ct             267            based           fixed bin(17,0)          level 2 dcl 4-31 set ref 1134* 1134
null                                                   builtin function         dcl 1161 ref 568 679 679 783 806 846 866 879 879 879
                                                                                  966 966 966 978 1006 1006 1131
old                     116            based           structure                level 2 unaligned dcl 1-67
old_msg                         000024 constant        char(47)                 initial packed unaligned dcl 503 set ref 511* 557*
                                                                                  604* 747*
old_style               275(04)        based           bit(1)                   level 3 packed packed unaligned dcl 4-31 ref 484
osmode                          000010 internal static char(8)                  initial packed unaligned dcl 794 set ref 783 783
                                                                                  817*
osw_p                           000012 internal static pointer                  initial dcl 795 set ref 783 783* 803* 806* 811* 846
                                                                                  846*
p1                                     parameter       char                     packed unaligned dcl 802 set ref 801 803* 807*
p2                                     parameter       char                     packed unaligned dcl 802 ref 801 817
part1                    10            based           structure                level 3 unaligned dcl 4-31
part2                    16            based           structure                level 3 unaligned dcl 4-31
pchar                                  based           char(1)                  array packed unaligned dcl 919 set ref 892 894 900
                                                                                  903 906
pl                       26            based           fixed bin(21,0)          array level 3 dcl 3-4 set ref 891* 895* 907* 910*
                                                                                  910 979*
pn                       23            based           fixed bin(21,0)          level 2 dcl 3-4 set ref 893* 905* 905 906 907 910
                                                                                  910 914 977* 980
pp                       24            based           pointer                  array level 3 dcl 3-4 set ref 890* 894* 906* 978*
present                 252            based           bit(1)                   array level 2 packed packed unaligned dcl 1-67 set
                                                                                  ref 677* 677*
prev                                   based           pointer                  level 2 dcl 3-4 set ref 949 970*
pseudo                  234(19)        based           bit(1)                   level 4 packed packed unaligned dcl 1-67 ref 391
pstrl                           000564 automatic       fixed bin(21,0)          dcl 920 set ref 883* 887*
pstrp                           000562 automatic       pointer                  dcl 918 set ref 882* 886 890 892 894 897 897 900 903
                                                                                  906
pt                        2     000014 internal static pointer                  level 2 dcl 1026 set ref 386 1013 1022* 1023 1035
                                                                                  1044
pv                       24            based           structure                array level 2 unaligned dcl 3-4
r                         3            based           structure                level 3 in structure "b" unaligned dcl 1-67
                                                                                  in procedure "tedutil_"
r                        17            based           structure                level 3 in structure "b" unaligned dcl 1-67
                                                                                  in procedure "tedutil_"
r                       252(06)        based           bit(1)                   level 3 in structure "b" packed packed unaligned
                                                                                  dcl 1-67 in procedure "tedutil_" set ref 602 605*
r                        25            based           structure                array level 3 in structure "b" unaligned dcl 1-67
                                                                                  in procedure "tedutil_"
rdy                             000014 internal static structure                level 1 unaligned dcl 1026
rdy_line                               based           char                     packed unaligned dcl 1030 set ref 386 1013 1022
                                                                                  1023* 1035* 1044
rdyline                         000100 automatic       char                     packed unaligned dcl 385 set ref 386* 387 387
re                       24            based           fixed bin(21,0)          array level 4 in structure "b" dcl 1-67 in procedure
                                                                                  "tedutil_" set ref 984*
re                        5            based           fixed bin(21,0)          level 4 in structure "b" dcl 1-67 in procedure
                                                                                  "tedutil_" set ref 127 129 135 135 394 1070 1151*
                                                                                  1154*
re                        2            based           fixed bin(21,0)          level 4 in structure "b" dcl 1-67 in procedure
                                                                                  "tedutil_" set ref 135* 178* 189 198 244 256 256
                                                                                  261 393* 399* 400* 408 408 411 1068 1068 1070
                                                                                  1154* 1154*
re                       16            based           fixed bin(21,0)          level 4 in structure "b" dcl 1-67 in procedure
                                                                                  "tedutil_" set ref 127 127 127* 127 145 145 147
                                                                                  149 149 175 175 245* 245 247* 247 256* 256 260*
                                                                                  260 378 378 383 383 412 412 416* 416 428 428 433
                                                                                  433 449 449 481 481 521 521 564 564 678 678
re                       20            based           fixed bin(21,0)          level 5 in structure "dbase" dcl 4-31 in procedure
                                                                                  "tedutil_" ref 862 862 884 884 886 886
re                       21            based           fixed bin(21,0)          level 4 in structure "b" dcl 1-67 in procedure
                                                                                  "tedutil_" set ref 127 127 129* 129 135 135 138
                                                                                  138 149 149 149 149 175 175 243* 243 245 245 256
                                                                                  256 260 260 596 596 1005 1005
recurs                    1            based           fixed bin(17,0)          level 2 dcl 4-31 set ref 277* 298* 823* 995*
red_char                               based           char(1)                  array packed unaligned dcl 358 set ref 497* 548* 641
                                                                                  740* 763*
red_line                               based           char                     packed unaligned dcl 357 set ref 340 340 343 445*
                                                                                  472* 473 473 488* 498 498 534* 536 536 543 543
                                                                                  632* 634 634 686* 687 687 700* 702* 707* 714* 715*
                                                                                  721 721 721 721 778 779 779 783 783
rel                                                    builtin function         dcl 1161 ref 975
reset_read                3     000074 external static bit(1)                   level 2 dcl 5-11 ref 1006
result                          000360 automatic       varying char(500)        dcl 730 set ref 679* 685 686 687 687
reverse                                                builtin function         dcl 1161 ref 165 305
right                                  parameter       fixed bin(21,0)          dcl 239 ref 237 243 244
rl                       10            based           structure                level 2 unaligned dcl 4-31
rl_c                                   based           char(1)                  array packed unaligned dcl 4-17 set ref 863 863
rl_i                                   defined         fixed bin(21,0)          dcl 4-15 set ref 862 863 863 865* 865 884 886
rl_l                                   defined         fixed bin(21,0)          dcl 4-16 ref 862 884 886
rl_s                                   based           char                     packed unaligned dcl 4-18 ref 886
rtrim                                                  builtin function         dcl 1161 ref 586
search                                                 builtin function         dcl 1161 ref 462
seg_des                                based           structure                level 1 unaligned dcl 4-20
seg_p                    24            based           pointer                  array level 2 dcl 4-31 ref 879 882 966 968
segno                     0(03)        based           bit(15)                  level 2 packed packed unaligned dcl 6-5 set ref
                                                                                  1146* 1146
size                                                   builtin function         dcl 1161 ref 980
sn                      126            based           fixed bin(17,0)          level 3 dcl 1-67 set ref 1063* 1066
sp                      124            based           pointer                  level 3 in structure "b" dcl 1-67 in procedure
                                                                                  "tedutil_" set ref 147 149 165 191 198 203 210
                                                                                  276* 305 314 319 320 400* 408 408 412 428 432 434
                                                                                  452 458 462 472 473 473 483 518 523 534 536 536
                                                                                  543 543 548 565 565 661 669 679 679 693 695 702
                                                                                  705 711 711 715 757 763 1075 1095 1117* 1146 1147*
sp                       10            based           pointer                  level 4 in structure "dbase" dcl 4-31 in procedure
                                                                                  "tedutil_" ref 863 863 886
space                                  based           pointer                  array level 2 dcl 3-21 set ref 882 968
srchl                           000113 automatic       fixed bin(21,0)          dcl 59 set ref 449* 458 462 467
stackl                  250            based           bit(18)                  level 2 in structure "b" dcl 1-67 in procedure
                                                                                  "tedutil_" set ref 955* 974 975*
stackl                   20            based           bit(18)                  level 2 in structure "sv" dcl 3-4 in procedure
                                                                                  "tedutil_" set ref 955 974*
stk_info                754            based           structure                level 2 unaligned dcl 4-31
str                                    based           char                     packed unaligned dcl 1090 in procedure "count" ref
                                                                                  1095
str                                    based           char(262144)             dcl 84 in procedure "tedutil_" set ref 632 644 646
                                                                                  651 886* 897 897
substr                                                 builtin function         dcl 1161 set ref 121* 122* 123* 131 131* 133 142 144
                                                                                  147 149 159 164 165 191 191 198 198 203 203 210
                                                                                  210 225 227 305 314 319 320 340 340 343 408 408
                                                                                  412 428 434 445* 452 458 462 472* 472 483 488* 518
                                                                                  523 534* 534 548 628 628 632* 632 644 646 651 661
                                                                                  669 686* 693 695 700* 702* 702 705 707* 711 711
                                                                                  714* 715* 715 721 721 757 763 778 779 779 783 783
                                                                                  841 841 844 844 846 846 886* 886 897 897 1095
sv                                     based           structure                level 1 unaligned dcl 3-4 set ref 980
sv_p                            000652 automatic       pointer                  dcl 3-3 set ref 890 891 893 894 895 905 905 906 906
                                                                                  907 907 910 910 910 910 914 948* 949 950 951 952
                                                                                  954 955 968* 970 971 972 973 974 975 976 977 978
                                                                                  979 980 980 981
sws                       4     000074 external static structure                level 2 in structure "tedcommon_$etc" unaligned
                                                                                  dcl 5-11 in procedure "tedutil_"
sws                     275            based           structure                level 2 in structure "dbase" packed packed unaligned
                                                                                  dcl 4-31 in procedure "tedutil_"
sws                     234(09)        based           structure                level 3 in structure "b" packed packed unaligned
                                                                                  dcl 1-67 in procedure "tedutil_"
te                                     parameter       fixed bin(21,0)          dcl 1085 in procedure "count" set ref 1084 1094 1095
                                                                                  1101 1103*
te                              000106 automatic       fixed bin(21,0)          dcl 59 in procedure "tedutil_" set ref 370* 377 449
                                                                                  479 611 613* 631 685 787
ted_vers                        000070 external static varying char(12)         level 2 dcl 5-5 set ref 823*
tedcommon_$etc                  000074 external static structure                level 1 unaligned dcl 5-11
tedcommon_$id                   000070 external static structure                level 1 unaligned dcl 5-5
tedcommon_$no_data              000072 external static structure                level 1 unaligned dcl 5-8 ref 947 953 1133
tederror_                       000066 constant        entry                    external dcl 2-3 ref 229 574 868 875
tedeval_                        000102 constant        entry                    external dcl 1199 ref 679
tedget_existing_buffer_         000100 constant        entry                    external dcl 1180 ref 565 863
tedget_segment_                 000106 constant        entry                    external dcl 1217 ref 879 966
tedname                 276            based           varying char(32)         level 2 dcl 4-31 set ref 290* 511* 557* 604* 638 732
                                                                                  747* 823* 823 1122* 1135* 1151*
tedpromote_                     000110 constant        entry                    external dcl 1227 ref 395
tedset_ck_ptr_                  000076 constant        entry                    external dcl 1179 ref 441
tedshow_                        000104 constant        entry                    external dcl 1215 ref 241 252 270 373 943 985
temp_fix                        000136 automatic       char(512)                packed unaligned dcl 620 set ref 618 621 621 628 628
terminate               234(12)        based           bit(1)                   level 4 packed packed unaligned dcl 1-67 set ref
                                                                                  1140*
this                     22            based           fixed bin(21,0)          level 2 in structure "sv" dcl 3-4 in procedure
                                                                                  "tedutil_" set ref 950 976*
this                                   parameter       fixed bin(21,0)          dcl 961 in procedure "push_one" ref 959 976
ti                                     parameter       fixed bin(21,0)          dcl 1085 in procedure "count" set ref 1084 1093
                                                                                  1103*
ti                              000104 automatic       fixed bin(21,0)          dcl 59 in procedure "tedutil_" set ref 369* 376 377
                                                                                  428 446* 449 472 473 473 476* 476 479 488 489* 489
                                                                                  495* 495 497 498* 498* 534 536 536 540* 540 543
                                                                                  543 547* 547 548 611 613 631 632 634 634 637* 637
                                                                                  641 641* 641 685 686 687 687 690* 690 699 700 701*
                                                                                  701 702 703* 703 707 708* 708 714 715 716* 716 720
                                                                                  721 740 761* 761 763 767 773 776 778 779 779 783
                                                                                  783 787 790*
timer_manager_$sleep            000116 constant        entry                    external dcl 284 ref 288
tmode                           000132 automatic       char(5)                  packed unaligned dcl 359 set ref 362* 363 363 383
                                                                                  408* 415* 428 450 473* 486 498* 515 536* 543* 570
                                                                                  576 608 634* 687* 721* 732 751 779 779 783
top                     756            based           pointer                  level 3 dcl 4-31 set ref 948 949* 970 981*
tp                              000100 automatic       pointer                  dcl 59 set ref 432* 442* 444* 618* 621* 632 634* 644
                                                                                  646 651 1016* 1023 1128* 1131 1146
tti                             000105 automatic       fixed bin(21,0)          dcl 59 set ref 376* 779 779 779 779 783 783 783 783
tuid                            000573 automatic       bit(36)                  packed unaligned dcl 1114 set ref 1117* 1126
tw_sw                   252(03)        based           bit(1)                   level 2 packed packed unaligned dcl 1-67 ref 125 241
                                                                                  252 270 373 381 484 506 552 599 742
uid                     141            based           bit(36)                  level 3 packed packed unaligned dcl 1-67 set ref
                                                                                  1126 1147*
unspec                                                 builtin function         dcl 1161 set ref 947* 947 953 953
used                            000120 automatic       fixed bin(21,0)          dcl 65 set ref 564* 565* 567 678* 679* 681 862* 863*
                                                                                  865
verify                                                 builtin function         dcl 1161 ref 693

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ITP_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 6-56
ITS_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 6-55
NORMAL                                 internal static fixed bin(24,0)          initial dcl 4-3
RESTART                                internal static fixed bin(24,0)          initial dcl 4-3
SAFE                                   internal static fixed bin(24,0)          initial dcl 4-3
all_des                                internal static fixed bin(17,0)          initial dcl 1-61
dbase_vers_3                           internal static fixed bin(17,0)          initial dcl 4-30
itp                                    based           structure                level 1 dcl 6-18
itp_unsigned                           based           structure                level 1 dcl 6-43
its_unsigned                           based           structure                level 1 dcl 6-30
live_des                               internal static fixed bin(17,0)          initial dcl 1-61
msg_ptr                                automatic       pointer                  dcl 2-7
pstr                                   based           char(256)                packed unaligned dcl 3-19
rc_close                               internal static fixed bin(24,0)          initial dcl 4-8
rc_fail                                internal static fixed bin(24,0)          initial dcl 4-9
rc_keyerr                              internal static fixed bin(24,0)          initial dcl 4-11
rc_nop                                 internal static fixed bin(24,0)          initial dcl 4-10
reloc_first                            internal static fixed bin(17,0)          initial dcl 1-61
reloc_last                             internal static fixed bin(17,0)          initial dcl 1-61
rl_b                                   automatic       fixed bin(21,0)          dcl 4-14
tedcommon_$no_seg                      external static structure                level 1 unaligned dcl 5-9
tederror_rc_                    000000 constant        entry                    external dcl 2-4
tedsrch_$compile                000000 constant        entry                    external dcl 7-7
tedsrch_$init_exp               000000 constant        entry                    external dcl 7-3
tedsrch_$search                 000000 constant        entry                    external dcl 7-17

NAMES DECLARED BY EXPLICIT CONTEXT.
always_conceal                  003372 constant        label                    dcl 543 ref 515
bk_loop                         001731 constant        label                    dcl 333 ref 338
break_input                     001415 constant        label                    dcl 293 ref 371
ck_out                          007613 constant        label                    dcl 1157 ref 1126 1144
common                          007731 constant        label                    dcl 254 ref 248
console_read                    004066 constant        label                    dcl 618 ref 626 649
count                           010412 constant        entry                    internal dcl 1084 ref 1068 1069
end_loop                        005236 constant        label                    dcl 765 ref 551 737
end_read                        005237 constant        label                    dcl 767 ref 456 479 502 579 614 638 741 759
esc                             000010 constant        label                    array(8) dcl 515 ref 668
get_req_line                    006757 constant        entry                    external dcl 1032
init_exec                       007616 constant        entry                    internal dcl 237 ref 411 984
label_not_found                 001207 constant        label                    dcl 223 ref 152 175
loop                            002267 constant        label                    dcl 400 ref 406 417
move_ch                         005217 constant        label                    dcl 761 ref 491 506 552 599 663 728 732 742
no_input                        010020 constant        entry                    internal dcl 280 ref 337 405 625
osw                             005574 constant        entry                    external dcl 801
osw_err                         005644 constant        label                    dcl 807 ref 814
pop_one                         010156 constant        entry                    internal dcl 941 ref 935 1001
push_one                        010253 constant        entry                    internal dcl 959 ref 595 887
rd_err                          003623 constant        label                    dcl 570 ref 588 593 683
rdp                             000000 constant        label                    array(0:7) dcl 495 ref 447 493
re_break                        001433 constant        label                    dcl 298 ref 343
re_init                         007343 constant        label                    dcl 1128 ref 1118 1124
read_exit                       005517 constant        label                    dcl 790 ref 654
refresh                         002240 constant        label                    dcl 389
reloop                          002117 constant        label                    dcl 373 ref 296 773 787
reread                          002100 constant        label                    dcl 364 ref 581
retry                           002153 constant        label                    dcl 378 ref 426 481 598 657 691
set_exec                        007675 constant        entry                    internal dcl 250 ref 135 138 154 166 178 183 193 205
                                                                                  217 431 438 440 454 477 501 550 561 567 617 672
                                                                                  674 681 704 711 725 736 756 757 764
set_req_line                    006675 constant        entry                    external dcl 1009
tedcall_                        006153 constant        entry                    external dcl 852
tedck_ptr_                      007243 constant        entry                    external dcl 1107
tedcount_lines_                 007063 constant        entry                    external dcl 1049 ref 276 301 999
tedend_buffer_                  006446 constant        entry                    external dcl 922 ref 423
tederror_                       005742 constant        entry                    external dcl 828
tedread_ptr_                    002042 constant        entry                    external dcl 347
tedresetread_                   006506 constant        entry                    external dcl 989 ref 575
tedset_ptr_                     000520 constant        entry                    external dcl 97
tedutil_                        000506 constant        entry                    external dcl 55
tedwhere_                       001323 constant        entry                    external dcl 273
tell_where                      010072 constant        entry                    internal dcl 819 ref 415 648
use_pch                         006426 constant        label                    dcl 910 ref 900

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11672       12012   11216       11702
Length     12456   11216       120         427     454          10

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tedutil_                            742 external procedure  is an external procedure.  
init_exec                               internal procedure  shares stack frame of external procedure tedutil_.  
no_input                                internal procedure  shares stack frame of external procedure tedutil_.  
begin block on line 383              78 begin block         uses auto adjustable storage.  
begin block on line 389                 begin block         shares stack frame of external procedure tedutil_.  
tell_where                              internal procedure  shares stack frame of external procedure tedutil_.  
pop_one                                 internal procedure  shares stack frame of external procedure tedutil_.  
push_one                                internal procedure  shares stack frame of external procedure tedutil_.  
count                                   internal procedure  shares stack frame of external procedure tedutil_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 osmode                      tedutil_
000012 osw_p                       tedutil_
000014 rdy                         tedutil_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 383  000100 rdyline                     begin block on line 383
tedutil_                 000100 tp                          tedutil_
                         000102 new_bp                      tedutil_
                         000104 ti                          tedutil_
                         000105 tti                         tedutil_
                         000106 te                          tedutil_
                         000107 i                           tedutil_
                         000110 j                           tedutil_
                         000111 k                           tedutil_
                         000112 escl                        tedutil_
                         000113 srchl                       tedutil_
                         000114 ii                          tedutil_
                         000115 i21                         tedutil_
                         000116 j24                         tedutil_
                         000117 jj                          tedutil_
                         000120 used                        tedutil_
                         000121 concealsw                   tedutil_
                         000122 lab                         tedutil_
                         000127 labl                        tedutil_
                         000130 dec6                        tedutil_
                         000132 tmode                       tedutil_
                         000134 db_input                    tedutil_
                         000135 kk                          tedutil_
                         000136 temp_fix                    tedutil_
                         000336 adr_hold                    tedutil_
                         000360 result                      tedutil_
                         000556 code                        tedutil_
                         000557 EL_sw                       tedutil_
                         000560 delim                       tedutil_
                         000562 pstrp                       tedutil_
                         000564 pstrl                       tedutil_
                         000565 af_len                      tedutil_
                         000566 af_ptr                      tedutil_
                         000570 l                           tedutil_
                         000571 lct                         tedutil_
                         000572 loc                         tedutil_
                         000573 tuid                        tedutil_
                         000574 bp                          tedutil_
                         000576 msg                         tedutil_
                         000652 sv_p                        tedutil_
                         000654 dbase_p                     tedutil_
                         000732 lti                         count
                         000733 II                          count

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_char_temp     enter_begin_block   leave_begin_block   call_ext_in
call_ext_out_desc   call_ext_out        return_mac          alloc_auto_adj      signal_op           shorten_stack
ext_entry           ext_entry_desc      set_chars_eis       index_chars_eis     alloc_storage       op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$af_arg_count              cu_$af_return_arg             cu_$arg_ptr
cu_$cp                        hcs_$get_uid_seg              hcs_$initiate_count           ioa_
ioa_$ioa_switch               ioa_$ioa_switch_nnl           ioa_$nnl                      iox_$control
iox_$get_line                 iox_$look_iocb                iox_$open                     tederror_
tedeval_                      tedget_existing_buffer_       tedget_segment_               tedpromote_
tedset_ck_ptr_                tedshow_                      timer_manager_$sleep

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$end_of_info      error_table_$invalidsegno     error_table_$io_no_permission error_table_$not_closed
iox_$error_output             iox_$user_input               tedcommon_$etc                tedcommon_$id
tedcommon_$no_data




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     55 000505        57 000513        97 000514       108 000533       109 000537       111 000545       112 000546
    114 000547       116 000552       117 000553       118 000554       120 000555       121 000560       122 000563
    123 000565       124 000567       125 000571       127 000574       129 000601       131 000603       133 000611
    135 000617       138 000634       139 000642       140 000644       142 000645       144 000647       145 000665
    147 000673       149 000712       152 000735       154 000737       155 000743       156 000745       157 000747
    159 000750       161 000752       162 000754       164 000760       165 000774       166 001013       169 001022
    171 001024       172 001026       173 001031       175 001032       177 001035       178 001037       182 001045
    183 001050       184 001056       185 001060       188 001061       189 001062       191 001065       193 001100
    194 001104       195 001106       198 001107       200 001116       203 001125       205 001142       206 001150
    207 001152       210 001153       211 001170       215 001174       217 001176       218 001202       219 001204
    221 001205       223 001207       225 001214       226 001231       227 001243       228 001271       229 001303
    230 001314       232 001317       273 001320       274 001330       275 001334       276 001336       277 001357
    279 001414       293 001415       296 001421       298 001433       301 001454       302 001476       303 001532
    305 001536       306 001554       308 001560       310 001564       311 001574       312 001604       314 001607
    315 001626       317 001635       319 001647       320 001661       321 001673       322 001722       323 001723
    325 001726       333 001731       335 001751       337 001753       338 001754       340 001755       343 002020
    345 002033       347 002034       362 002047       363 002055       364 002100       366 002104       367 002105
    368 002107       369 002111       370 002113       371 002115       373 002117       376 002145       377 002147
    378 002153       381 002157       383 002162       385 002204       386 002214       387 002222       388 002237
    391 002240       393 002244       394 002247       395 002252       399 002265       400 002267       403 002307
    405 002311       406 002312       408 002313       411 002361       412 002371       415 002402       416 002404
    417 002406       421 002407       423 002410       424 002421       426 002424       428 002425       431 002451
    432 002456       433 002465       434 002471       435 002504       437 002505       438 002507       439 002513
    440 002514       441 002521       442 002530       444 002543       445 002547       446 002554       447 002556
    449 002557       450 002572       452 002603       454 002611       455 002616       456 002623       458 002624
    460 002636       462 002637       467 002654       469 002660       470 002662       472 002664       473 002700
    476 002764       477 002766       479 002773       481 002776       483 003002       484 003014       486 003030
    488 003034       489 003043       491 003045       493 003046       495 003050       497 003051       498 003060
    501 003122       502 003130       506 003131       509 003133       511 003136       512 003173       514 003176
    515 003177       518 003203       519 003221       521 003223       523 003226       524 003237       526 003243
    527 003246       528 003247       530 003250       534 003256       536 003275       540 003365       541 003371
    543 003372       547 003456       548 003457       550 003472       551 003501       552 003502       555 003504
    557 003507       558 003544       560 003547       561 003550       564 003557       565 003564       567 003611
    568 003617       570 003623       574 003641       575 003652       576 003660       578 003664       579 003671
    581 003672       583 003673       585 003677       586 003704       587 003730       588 003742       590 003743
    592 003747       593 003754       595 003755       596 003763       598 003774       599 003775       602 003777
    604 004002       605 004037       607 004042       608 004043       611 004047       613 004053       614 004056
    617 004057       618 004066       621 004070       623 004111       625 004113       626 004114       628 004115
    631 004154       632 004163       634 004173       637 004253       638 004255       641 004263       644 004275
    646 004304       648 004312       649 004316       651 004317       653 004330       654 004334       657 004335
    661 004336       663 004350       665 004351       667 004355       668 004357       669 004361       672 004365
    674 004372       676 004400       677 004404       678 004410       679 004414       681 004455       682 004463
    683 004467       685 004471       686 004477       687 004507       690 004571       691 004573       693 004574
    695 004613       699 004623       700 004625       701 004633       702 004635       703 004650       704 004653
    705 004662       707 004671       708 004700       709 004702       711 004703       714 004720       715 004727
    716 004735       718 004737       720 004741       721 004744       724 005034       725 005035       726 005043
    727 005044       728 005060       732 005061       736 005073       737 005100       739 005104       740 005106
    741 005115       742 005116       745 005120       747 005123       748 005160       750 005163       751 005164
    755 005170       756 005175       757 005202       759 005216       761 005217       763 005220       764 005232
    765 005236       767 005237       773 005242       776 005257       778 005264       779 005306       783 005402
    787 005475       790 005517       793 005567       801 005570       803 005614       804 005637       806 005641
    807 005644       809 005677       811 005700       812 005721       814 005723       817 005726       818 005735
    828 005736       835 005747       836 005753       838 006000       839 006006       841 006014       844 006046
    846 006103       849 006145       850 006146       852 006147       859 006160       860 006162       861 006165
    862 006167       863 006173       865 006220       866 006223       868 006227       869 006240       870 006243
    872 006244       874 006247       875 006254       876 006265       877 006270       879 006271       882 006314
    883 006322       884 006324       885 006327       886 006332       887 006340       888 006342       890 006344
    891 006347       892 006350       893 006354       894 006356       895 006362       896 006363       897 006373
    900 006404       903 006410       905 006414       906 006416       907 006424       908 006425       910 006426
    913 006432       914 006434       916 006443       922 006444       928 006453       929 006456       930 006461
    932 006463       933 006465       935 006466       936 006467       938 006501       939 006503       989 006504
    992 006513       993 006517       995 006521       997 006541       998 006544       999 006547      1000 006571
   1001 006625      1002 006626      1004 006627      1005 006632      1006 006635      1008 006673      1009 006674
   1011 006702      1013 006705      1014 006711      1016 006713      1017 006731      1019 006733      1021 006734
   1022 006737      1023 006747      1024 006755      1032 006756      1034 006764      1035 006775      1043 007022
   1044 007042      1046 007055      1049 007056      1061 007070      1062 007074      1063 007075      1066 007125
   1068 007130      1069 007142      1070 007161      1072 007174      1075 007177      1079 007207      1080 007212
   1082 007240      1107 007241      1116 007250      1117 007254      1118 007267      1120 007273      1122 007275
   1124 007336      1126 007337      1128 007343      1131 007406      1133 007412      1134 007420      1135 007427
   1138 007466      1139 007472      1140 007474      1141 007476      1142 007500      1143 007502      1144 007504
   1146 007505      1147 007512      1148 007525      1149 007530      1151 007533      1154 007604      1155 007611
   1157 007613      1159 007615       237 007616       241 007620       243 007653       244 007657       245 007664
    247 007672       248 007674       250 007675       252 007677       254 007731       256 007735       260 007746
    261 007750       263 007756       265 007761       267 007764       270 007767       272 010017       280 010020
    286 010021       288 010026       290 010045       292 010071       819 010072       823 010074       827 010155
    941 010156       943 010157       945 010201       946 010204       947 010206       948 010213       949 010216
    950 010221       951 010224       952 010227       953 010232       954 010242       955 010245       956 010247
    958 010252       959 010253       963 010255       965 010257       966 010261       968 010305       970 010313
    971 010315       972 010317       973 010323       974 010326       975 010330       976 010332       977 010335
    978 010336       979 010340       980 010341       981 010347       982 010350       983 010353       984 010355
    985 010365       988 010411      1084 010412      1093 010414      1094 010416      1095 010422      1096 010442
   1098 010443      1099 010444      1100 010445      1101 010446      1102 010451      1103 010452      1106 010510


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
