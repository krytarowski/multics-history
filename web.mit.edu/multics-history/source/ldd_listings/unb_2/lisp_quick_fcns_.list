ASSEMBLY LISTING OF SEGMENT >special_ldd>install>MR12.0-1206>lisp_quick_fcns_.alm            
ASSEMBLED ON:	11/05/86  1102.2 mst Wed
OPTIONS USED:	list 
ASSEMBLED BY:	ALM Version  6.7  October 1986  
ASSEMBLER CREATED:	10/08/86  1557.5 mst Wed

                                     1  " **************************************************************
                                     2  " *                                                            *
                                     3  " * Copyright, (C) Massachusetts Institute of Technology, 1973 *
                                     4  " *                                                            *
                                     5  " **************************************************************
                                     6  "
                                     7  "	Procedure lisp_quick_fcns_, which contains those functions which
                                     8  "	are optimally hand-coded for maximum interpreter speed.
                                     9  "
                                    10  "	DPR 14 August 72
                                    11  "
                                    12  
                                    13  	tempd	arg(2)
                                    14  	include	stack_header
                                   1-1  "	BEGIN INCLUDE FILE ... stack_header.incl.alm  3/72  Bill Silver
                                   1-2  "
                                   1-3  "	modified 7/76 by M. Weaver for *system links and more system use of areas
                                   1-4  "	modified 3/77 by M. Weaver  to add rnt_ptr
                                   1-5  "	modified 7/77 by S. Webber to add run_unit_depth and assign_linkage_ptr
                                   1-6  "	modified 6/83 by J. Ives to add trace_frames and in_trace.
                                   1-7  
                                   1-8  " HISTORY COMMENTS:
                                   1-9  "  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
                                  1-10  "     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
                                  1-11  "     added the heap_header_ptr definition
                                  1-12  "  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
                                  1-13  "     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
                                  1-14  "     Modified to support control point management.  These changes were
                                  1-15  "     actually made in February 1985 by G. Palter.
                                  1-16  "  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
                                  1-17  "     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
                                  1-18  "     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
                                  1-19  "     bit pad after cur_lot_size for the cpm_enabled. This was done to save
                                  1-20  "     some space int the stack header and change the cpd_ptr unal to
                                  1-21  "     cpm_data_ptr (ITS pair).
                                  1-22  "                                                      END HISTORY COMMENTS
                                  1-23  
                        000004    1-24  	equ	stack_header.cpm_data_ptr,4		ptr to control point for this stack
                        000006    1-25  	equ	stack_header.combined_stat_ptr,6	ptr to separate static area
                                  1-26  
                        000010    1-27  	equ	stack_header.clr_ptr,8		ptr to area containing linkage sections
                        000012    1-28  	equ	stack_header.max_lot_size,10		number of words allowed in lot (DU)
                        000012    1-29  	equ	stack_header.main_proc_invoked,10	nonzero if main proc was invoked in run unit (DL)
                        000012    1-30  	equ	stack_header.run_unit_depth,10	number of active run units stacked (DL)
                        000013    1-31  	equ	stack_header.cur_lot_size,11		DU number of words (entries) in lot
                        000013    1-32            equ	stack_header.cpm_enabled,11		DL  non-zero if control point management is enabled
                        000014    1-33  	equ	stack_header.system_free_ptr,12	ptr to system storage area
                        000016    1-34  	equ	stack_header.user_free_ptr,14		ptr to user storage area
                                  1-35  
                        000020    1-36  	equ	stack_header.parent_ptr,16		ptr to parent stack or null
                        000022    1-37  	equ	stack_header.stack_begin_ptr,18	ptr to first stack frame
                        000024    1-38  	equ	stack_header.stack_end_ptr,20		ptr to next useable stack frame
                        000026    1-39  	equ	stack_header.lot_ptr,22		ptr to the lot for the current ring
                                  1-40  
                        000030    1-41  	equ	stack_header.signal_ptr,24		ptr to signal proc for current ring
                        000032    1-42  	equ	stack_header.bar_mode_sp,26		value of sp before entering bar mode
                        000034    1-43  	equ	stack_header.pl1_operators_ptr,28	ptr: pl1_operators_$operator_table
                        000036    1-44  	equ	stack_header.call_op_ptr,30		ptr to standard call operator
                                  1-45  
                        000040    1-46  	equ	stack_header.push_op_ptr,32		ptr to standard push operator
                        000042    1-47  	equ	stack_header.return_op_ptr,34		ptr to standard return operator
                        000044    1-48  	equ	stack_header.ret_no_pop_op_ptr,36	ptr: stand. return/ no pop operator
                        000046    1-49  	equ	stack_header.entry_op_ptr,38		ptr to standard entry operator
                                  1-50  
                        000050    1-51  	equ	stack_header.trans_op_tv_ptr,40	ptr to table of translator operator ptrs
                        000052    1-52  	equ	stack_header.isot_ptr,42		pointer to ISOT
                        000054    1-53  	equ	stack_header.sct_ptr,44		pointer to System Condition Table
                        000056    1-54  	equ	stack_header.unwinder_ptr,46		pointer to unwinder for current ring
                                  1-55  
                        000060    1-56  	equ	stack_header.sys_link_info_ptr,48	ptr to *system link name table
                        000062    1-57  	equ	stack_header.rnt_ptr,50		ptr to reference name table
                        000064    1-58  	equ	stack_header.ect_ptr,52		ptr to event channel table
                        000066    1-59  	equ	stack_header.assign_linkage_ptr,54	ptr to area for hcs_$assign_linkage calls
                        000070    1-60  	equ	stack_header.heap_header_ptr,56	ptr to heap header.
                        000072    1-61  	equ	stack_header.trace_frames,58		stack of trace_catch_ frames
                        000073    1-62  	equ	stach_header.trace_top_ptr,59		trace pointer
                        000074    1-63  	equ	stack_header.in_trace,60		trace antirecurse bit
                        000100    1-64  	equ	stack_header_end,64			length of stack header
                                  1-65  
                                  1-66  
                                  1-67  
                                  1-68  
                        000000    1-69  	equ	trace_frames.count,0		number of trace frames on stack
                        000001    1-70  	equ	trace_frames.top_ptr,1		packed pointer to top one
                                  1-71  
                                  1-72  "	The  following constant is an offset within the  pl1  operators table.
                                  1-73  "	It  references a  transfer vector table.
                                  1-74  
                        000551    1-75  	bool	tv_offset,551
                                  1-76  
                                  1-77  
                                  1-78  "	The  following constants are offsets within this transfer vector table.
                                  1-79  
                        001170    1-80  	equ	call_offset,tv_offset+271
                        001171    1-81  	equ	push_offset,tv_offset+272
                        001172    1-82  	equ	return_offset,tv_offset+273
                        001173    1-83  	equ	return_no_pop_offset,tv_offset+274
                        001174    1-84  	equ	entry_offset,tv_offset+275
                                  1-85  
                                  1-86  
                                  1-87  " 	END INCLUDE FILE stack_header.incl.alm
                                    15  	include 	lisp_object_types
                                   2-1  
                                   2-2  " BEGIN INCLUDE FILE lisp_object_types.incl.alm
                                   2-3  "
                                   2-4  " D.A.Moon 14 July 72
                                   2-5  
                                   2-6  "These are bit masks used to check or set the type bits in lisp pointers
                                   2-7  "they should be used with cana instructions in the dl mode.
                                   2-8  "
                                   2-9  " Modified 1 Oct 1972 by Dan Bricklin to add bignum types.
                                  2-10  
                                  2-11  
                                  2-12  
                        077700    2-13  	bool	lisp_ptr.type,077700	"the whole type field
                                  2-14  
                        040000    2-15  	bool	Fixed,040000		"fixed number, stored in second word of ptr
                        020000    2-16  	bool	Float,020000		"floating number, stored in second word of ptr
                        061400    2-17  	bool	Numeric,061400		"fixed or float, big or little
                        010000    2-18  	bool	Atsym,010000		"Atomic symbol pointed at by ptr
                        077700    2-19  	bool	Atomic,077700		"any of these bits indicates an atom (non-list)
                        001000    2-20  	bool	Bignum,001000		"points to a bignum - fixed
                        060000    2-21  	bool	Uncollectable,060000	"not a pointer, also both bits on = "pdl_ptr"
                        004000    2-22  	bool	String,004000		"points at a lisp character string
                        002000    2-23  	bool	Subr,002000		"points at subr link
                        000400    2-24  	bool	System_Subr,000400		"marks a subr as being in the text of lisp bound seg.
                        000200    2-25  	bool	Array,000200		"points at an array,
                                  2-26  					" which is a special kind of subr
                        067500    2-27  	bool	Unevalable,067500		"any of these bits means
                                  2-28  					" does not have car and cdr
                        001000    2-29  	bool	Big_fixed,001000		"points to fixed bignum
                        000100    2-30  	bool	File,000100		"points to a file object (i.e. an iochan)
                                  2-31  
                                  2-32  "fields for making numbers, a fault tag is included in case someone takes the car or cdr of it
                                  2-33  
                        040047    2-34  	bool	fixnum_type,040047
                        020047    2-35  	bool	flonum_type,020047
                                  2-36  
                                  2-37  " END INCLUDE FILE: lisp_object_types.incl.alm
                                    16  	include 	lisp_stack_seg
                                   3-1  " BEGIN INCLUDE FILE lisp_stack_seg.incl.alm
                                   3-2  
                                   3-3  "	lisp stack segment header format
                                   3-4  "	Last modified by Reed 6/21/72
                                   3-5  "
                        000000     3-6  	equ	marked_stack_bottom,0	offset of ptr to bottom of marked stack
                        000002     3-7  	equ	unmkd_stack_bottom,2	offset of ptr to bottom of unmkd_stack
                        000004     3-8  	equ	stack_ptr_ptr,4		offset of ptr to lisp_static_vars_$stack_ptr
                        000006     3-9  	equ	unmkd_ptr_ptr,6		offset of ptr to lisp_static_vars_$unmkd_ptr's offset word
                        000010    3-10  	equ	array_pointer,8		points at cell of array most recently referenced
                        000012    3-11  	equ	nil,10			offset of cell containing pointer to nil...
                        000014    3-12  	equ	true,12			offset of cell containing pointer to t...
                        000016    3-13  	equ	in_pl1_code,14		offset of flag saying whether stack_ptr
                                  3-14  "					& unmkd_ptr or ap and ab|.,x7 are valid...if zero, ap,ab arevalid.
                                  3-15  " table of pointers to operators
                                  3-16  
                        000020    3-17  	equ	bind_op,16
                        000022    3-18  	equ	unbind_op,18
                        000024    3-19  	equ	errset1_op,20
                        000026    3-20  	equ	errset2_op,22
                        000030    3-21  	equ	unerrset_op,24
                        000032    3-22  	equ	call_op,26
                        000034    3-23  	equ	catch1_op,28
                        000036    3-24  	equ	catch2_op,30
                        000040    3-25  	equ	uncatch_op,32
                        000042    3-26  	equ	gensym_data,34	" data for gensym function
                                  3-27  
                        000044    3-28  	equ	system_lp,36		pointer to common linkage section for bound segment.
                        000046    3-29  	equ	iogbind_op,38		operator to help out with compiled iog.
                        000050    3-30  	equ	unseen_go_tag_op,40
                        000052    3-31  	equ	throw1_op,42
                        000054    3-32  	equ	throw2_op,44
                        000056    3-33  	equ	signp_op,46
                        000060    3-34  	equ	type_fields,48
                        000062    3-35  	equ	return_op,50
                        000064    3-36  	equ	err_op,52
                        000066    3-37  	equ	pl1_interface,54
                        000070    3-38  	equ	pl1_lsubr_interface,56
                        000072    3-39  	equ	cons_op,58		operator for compiled cons
                        000074    3-40  	equ	ncons_op,60		opeator for compiled cons with nil
                        000076    3-41  	equ	xcons_op,62		operator for compiled xcons
                        000100    3-42  	equ	begin_list_op,64		operator to begin compiled list code
                        000102    3-43  	equ	append_list_op,66		operator to get new list cell and hook on end
                        000104    3-44  	equ	terminate_list_op,68	operator to finish off list.
                        000106    3-45  	equ	compare_op,70
                        000110    3-46  	equ	link_opr,72
                        000112    3-47  	equ	array_operator,74
                        000114    3-48  	equ	dead_array_operator,76
                        000116    3-49  	equ	store_operator,78
                        000120    3-50  	equ	floating_store_operator,80
                        000122    3-51  	equ	array_info_for_store,82
                        000124    3-52  	equ	array_offset_for_store,84
                        000126    3-53  	equ	array_link_snap_opr,86
                        000130    3-54  	equ	create_string_desc_op,88	string desc for PL/I call
                        000132    3-55  	equ	create_array_desc_op,90	array desc for PL/I call
                        000134    3-56  	equ	pl1_call_op,92		PL/I call operator
                        000136    3-57  	equ	cons_string_op,94		operator to cons up a string
                        000140    3-58  	equ	create_varying_string_op,96
                        000142    3-59  	equ	unwp1_op,98		unwind-protect start
                        000144    3-60  	equ	unwp2_op,100		ditto, for compat.
                        000146    3-61  	equ	ununwp_op,102		End unwind-protect.
                        000150    3-62  	equ	irest_return_op,104 	Interrupt restore return
                        000152    3-63  	equ	pl1_call_nopop_op,106	PL1 call, dont pop PL1 frame
                        000154    3-64  	equ	rcv_char_star_op,108	Receive char * result, pop pl1frame
                                  3-65  	" spare 110
                        000174    3-66  	equ	begin_unmkd_stack,124	beginning of unmkd_stack
                                  3-67  
                                  3-68  " END INCLUDE FILE lisp_stack_seg.incl.alm
                                  3-69  
                                    17  	include 	lisp_error_codes
                                   4-1  
                                   4-2  " BEGIN INCLUDE FILE lisp_error_codes.incl.alm
                                   4-3  
                                   4-4  "This contains codes to be stored on the unmkd pdl before calling
                                   4-5  "lisp_error_.  These codes, at ab|-2,x7, are used by lisp_error_
                                   4-6  "as an index into lisp_error_table_.
                                   4-7  
                        000144     4-8  	equ	undefined_atom,100			- correctable
                        000145     4-9  	equ	undefined_function,101		- correctable
                        000146    4-10  	equ	too_many_args,102			uncorrectable 
                        000147    4-11  	equ	too_few_args,103			..
                        000150    4-12  	equ	file_system_error,104		(obsolete)
                        000151    4-13  	equ	bad_argument,105			uncorrectable arg reject
                        000152    4-14  	equ	undefined_subr,106
                        000153    4-15  	equ	bad_function,107			"bad functional form"
                        000154    4-16  	equ	bad_bv,108			attempt to bind non-variable
                        000155    4-17  	equ	unseen_go_tag,109			correctable -> unevaled new tag
                        000156    4-18  	equ	throw_to_no_catch,110		..
                        000157    4-19  	equ	nonfixedarg,111			correctable
                        000160    4-20  	equ	parenmissing,112			uncorr reader error
                        000161    4-21  	equ	doterror,113			..
                        000162    4-22  	equ	illobj,114			..
                        000163    4-23  	equ	badmacro,115			..
                        000164    4-24  	equ	shortreadlist,116			..
                        000165    4-25  	equ	badreadlist,117			..
                        000166    4-26  	equ	array_bound_error,118		corr -> (array sub1 sub2...)
                        000167    4-27  	equ	car_cdr_error,119			uncorr - car or cdr of number
                        000170    4-28  	equ	bad_arg_correctable,120		correctable arg reject
                        000171    4-29  	equ	bad_prog_op,121			uncorr fail-act: go or return
                        000172    4-30  	equ	no_lexpr,122			uncorr fail-act: args or setarg
                        000173    4-31  	equ	wrong_no_args,123			correctable wna -> new expr value
                        000174    4-32  	equ	bad_ibase,124			corr
                        000175    4-33  	equ	bad_base,125			corr
                        000176    4-34  	equ	bad_input_source,126		corr - retry i/o
                        000177    4-35  	equ	bad_output_dest,127			..
                        000200    4-36  	equ	nihil_ex_nihile,128			uncorr - attempt to setq nil
                        000203    4-37  	equ	not_pdl_ptr,131			corr arg reject - for pdl ptr args
                        000206    4-38  	equ	bad_f_fcn,134			compiled call to fsubr with evaled args
                        000207    4-39  	equ	overflow_err,135			arithmetic overflow.
                        000210    4-40  	equ	mismatch_super_parens,136		uncorr reader error
                        000211    4-41  	equ	no_left_super_paren,137		..
                        000212    4-42  	equ	flonum_too_big,138			..
                        000213    4-43  	equ	quoterror,139			..
                        000214    4-44  	equ	badreadtable,140			..
                        000215    4-45  	equ	badobarray,141			..
                        000216    4-46  	equ	atan_0_0_err,142			(atan 0 0) doesn't work
                        000217    4-47  	equ	unable_to_float,143			corr arg reject - (float x)
                        000220    4-48  	equ	division_by_zero,144		uncorr (should really be corr)
                        000221    4-49  	equ	eof_in_object,145			corr fail-act -> keep reading anyway
                        000222    4-50  	equ	cant_filepos,146			corr fail-act -> new expr value
                        000223    4-51  	equ	filepos_oob,147			..
                        000224    4-52  	equ	file_sys_fun_err,148		corr f.s. err -> new expr value
                        000225    4-53  	equ	stars_left_in_name,149		..
                        000226    4-54  	equ	io_wrong_direction,150		..
                        000227    4-55  	equ	file_is_closed,151			..
                        000230    4-56  	equ	reopen_inconsistent,152		..
                        000231    4-57  	equ	bad_entry_name,153			..
                        000232    4-58  	equ	bad_do_format,154			bad do format in interp.
                        000233    4-59  	equ	not_an_array,155			bad array-type arg
                        000234    4-60  	equ	not_alpha_array,156			bad all-alphabetic array
                        000235    4-61  	equ	include_file_error,157		%include barfed
                        000236    4-62  	equ	stack_loss_error,158		stack overflew
                        000237    4-63  	equ	underflow_fault,159
                        000240    4-64  	equ	zerodivide_fault,160
                        000241    4-65  	equ	bad_array_subscript,161
                        000242    4-66  	equ	store_not_allowed,162
                        000243    4-67  	equ	dead_array_reference,163
                        000244    4-68  	equ	cant_subscript_readtable,164
                        000245    4-69  	equ	not_same_type,165
                        000246    4-70  	equ	special_array_type,166
                        000247    4-71  	equ	array_too_big,167
                        000250    4-72  	equ	argument_must_be_array,168
                        000251    4-73  	equ	store_function_misused,169
                                  4-74  
                                  4-75  " END INCLUDE FILE lisp_error_codes.incl.alm
                                    18  	include	lisp_name_codes
                                   5-1  
                                   5-2  " BEGIN INCLUDE FILE lisp_name_codes.incl.alm
                                   5-3  
                                   5-4  " These are codes for the names of functions which are stored into ab|-1,x7 before
                                   5-5  " calling lisp_error_ for a bad_argument or bad_arg_correctable error. They
                                   5-6  " are used so that the name of the function which is rejecting its argument
                                   5-7  " can be printed.  Please note that all these codes are negative.
                                   5-8  
                 777777 777766     5-9  	equ	fn_do,-10
                 777777 777765    5-10  	equ	fn_arg,-11
                 777777 777764    5-11  	equ	fn_setarg,-12
                 777777 777763    5-12  	equ	fn_status,-13
                 777777 777762    5-13  	equ	fn_sstatus,-14
                 777777 777761    5-14  	equ	fn_errprint,-15
                 777777 777760    5-15  	equ	fn_errframe,-16
                 777777 777757    5-16  	equ	fn_evalframe,-17
                 777777 777756    5-17  	equ	fn_defaultf,-18
                 777777 777752    5-18  	equ	fn_tyo,-22
                 777777 777751    5-19  	equ	fn_ascii,-23
                 777777 777750    5-20  	equ	fn_rplaca,-24
                 777777 777747    5-21  	equ	fn_definedp,-25
                 777777 777746    5-22  	equ	fn_setq,-26
                 777777 777745    5-23  	equ	fn_set,-27
                 777777 777744    5-24  	equ	fn_delete,-28
                 777777 777743    5-25  	equ	fn_delq,-29
                 777777 777742    5-26  	equ	fn_stringlength,-30
                 777777 777741    5-27  	equ	fn_catenate,-31
                 777777 777740    5-28  	equ	fn_array,-32
                 777777 777737    5-29  	equ	fn_substr,-33
                 777777 777736    5-30  	equ	fn_index,-34
                 777777 777735    5-31  	equ	fn_get_pname,-35
                 777777 777734    5-32  	equ	fn_make_atom,-36
                 777777 777733    5-33  	equ	fn_ItoC,-37
                 777777 777732    5-34  	equ	fn_CtoI,-38
                 777777 777731    5-35  	equ	fn_defsubr,-39
                 777777 777730    5-36  	equ	fn_star_array,-40
                 777777 777727    5-37  	equ	fn_args,-41
                 777777 777726    5-38  	equ	fn_sysp,-42
                 777777 777725    5-39  	equ	fn_get,-43
                 777777 777724    5-40  	equ	fn_getl,-44
                 777777 777723    5-41  	equ	fn_putprop,-45
                 777777 777722    5-42  	equ	fn_remprop,-46
                 777777 777721    5-43  	equ	fn_save,-47
                 777777 777720    5-44  	equ	fn_add1,-48
                 777777 777717    5-45  	equ	fn_sub1,-49
                 777777 777716    5-46  	equ	fn_greaterp,-50
                 777777 777715    5-47  	equ	fn_lessp,-51
                 777777 777714    5-48  	equ	fn_minus,-52
                 777777 777713    5-49  	equ	fn_plus,-53
                 777777 777712    5-50  	equ	fn_times,-54
                 777777 777711    5-51  	equ	fn_difference,-55
                 777777 777710    5-52  	equ	fn_quotient,-56
                 777777 777707    5-53  	equ	fn_abs,-57
                 777777 777706    5-54  	equ	fn_expt,-58
                 777777 777705    5-55  	equ	fn_boole,-59
                 777777 777704    5-56  	equ	fn_rot,-60
                 777777 777703    5-57  	equ	fn_lsh,-61
                 777777 777702    5-58  	equ	fn_signp,-62
                 777777 777701    5-59  	equ	fn_fix,-63
                 777777 777700    5-60  	equ	fn_float,-64
                 777777 777677    5-61  	equ	fn_remainder,-65
                 777777 777676    5-62  	equ	fn_max,-66
                 777777 777675    5-63  	equ	fn_min,-67
                 777777 777674    5-64  	equ	fn_add1_fix,-68
                 777777 777673    5-65  	equ	fn_add1_flo,-69
                 777777 777672    5-66  	equ	fn_sub1_fix,-70
                 777777 777671    5-67  	equ	fn_sub1_flo,-71
                 777777 777670    5-68  	equ	fn_plus_fix,-72
                 777777 777667    5-69  	equ	fn_plus_flo,-73
                 777777 777666    5-70  	equ	fn_times_fix,-74
                 777777 777665    5-71  	equ	fn_times_flo,-75
                 777777 777664    5-72  	equ	fn_diff_fix,-76
                 777777 777663    5-73  	equ	fn_diff_flo,-77
                 777777 777662    5-74  	equ	fn_quot_fix,-78
                 777777 777661    5-75  	equ	fn_quot_flo,-79
                 777777 777660    5-76  	equ	fn_eval,-80
                 777777 777657    5-77  	equ	fn_apply,-81
                 777777 777656    5-78  	equ	fn_prog,-82
                 777777 777655    5-79  	equ	fn_errset,-83
                 777777 777654    5-80  	equ	fn_catch,-84
                 777777 777653    5-81  	equ	fn_throw,-85
                 777777 777652    5-82  	equ	fn_store,-86
                 777777 777651    5-83  	equ	fn_defun,-87
                 777777 777650    5-84  	equ	fn_baktrace,-88
                 777777 777647    5-85  	equ	fn_bltarray,-89
                 777777 777646    5-86  	equ	fn_star_rearray,-90
                 777777 777645    5-87  	equ	fn_gensym,-91
                 777777 777644    5-88  	equ	fn_makunbound,-92
                 777777 777643    5-89  	equ	fn_boundp,-93
                 777777 777642    5-90  	equ	fn_star_status,-94
                 777777 777641    5-91  	equ	fn_star_sstatus,-95
                 777777 777640    5-92  	equ	fn_freturn,-96
                 777777 777637    5-93  	equ	fn_cos,-97
                 777777 777636    5-94  	equ	fn_sin,-98
                 777777 777635    5-95  	equ	fn_exp,-99
                 777777 777634    5-96  	equ	fn_log,-100
                 777777 777633    5-97  	equ	fn_sqrt,-101
                 777777 777632    5-98  	equ	fn_isqrt,-102
                 777777 777631    5-99  	equ	fn_atan,-103
                 777777 777630   5-100  	equ	fn_sleep,-104
                 777777 777627   5-101  	equ	fn_oddp,-105
                 777777 777626   5-102  	equ	fn_tyipeek,-106
                 777777 777625   5-103  	equ	fn_alarmclock,-107
                 777777 777624   5-104  	equ	fn_plusp,-108
                 777777 777623   5-105  	equ	fn_minusp,-109
                 777777 777622   5-106  	equ	fn_ls,-110
                 777777 777621   5-107  	equ	fn_eql,-111
                 777777 777620   5-108  	equ	fn_gt,-112
                 777777 777617   5-109  	equ	fn_alphalessp,-113
                 777777 777616   5-110  	equ	fn_samepnamep,-114
                 777777 777615   5-111  	equ	fn_getchar,-115
                 777777 777614   5-112  	equ	fn_opena,-116
                 777777 777613   5-113  	equ	fn_sxhash,-117
                 777777 777612   5-114  	equ	fn_gcd,-118
                 777777 777611   5-115  	equ	fn_allfiles,-119
                 777777 777610   5-116  	equ	fn_chrct,-120
                 777777 777607   5-117  	equ	fn_close,-121
                 777777 777606   5-118  	equ	fn_deletef,-122
                 777777 777605   5-119  	equ	fn_eoffn,-123
                 777777 777604   5-120  	equ	fn_filepos,-124
                 777777 777603   5-121  	equ	fn_inpush,-125
                 777777 777602   5-122  	equ	fn_linel,-126
                 777777 777601   5-123  	equ	fn_mergef,-127
                 777777 777600   5-124  	equ	fn_namelist,-128
                 777777 777577   5-125  	equ	fn_names,-129
                 777777 777576   5-126  	equ	fn_namestring,-130
                 777777 777575   5-127  	equ	fn_openi,-131
                 777777 777574   5-128  	equ	fn_openo,-132
                 777777 777573   5-129  	equ	fn_prin1,-133
                 777777 777572   5-130  	equ	fn_princ,-134
                 777777 777571   5-131  	equ	fn_print,-135
                 777777 777570   5-132  	equ	fn_read,-136
                 777777 777567   5-133  	equ	fn_readch,-137
                 777777 777566   5-134  	equ	fn_readstring,-138
                 777777 777565   5-135  	equ	fn_rename,-139
                 777777 777564   5-136  	equ	fn_shortnamestring,-140
                 777777 777563   5-137  	equ	fn_tyi,-141
                 777777 777562   5-138  	equ	fn_setsyntax,-142
                 777777 777561   5-139  	equ	fn_cursorpos,-143
                 777777 777560   5-140  	equ	fn_force_output,-144
                 777777 777557   5-141  	equ	fn_clear_input,-145
                 777777 777556   5-142  	equ	fn_random,-146
                 777777 777555   5-143  	equ	fn_haulong,-147
                 777777 777554   5-144  	equ	fn_haipart,-148
                 777777 777553   5-145  	equ	fn_cline,-149
                 777777 777552   5-146  	equ	fn_fillarray,-150
                 777777 777551   5-147  	equ	fn_listarray,-151
                 777777 777550   5-148  	equ	fn_sort,-152
                 777777 777547   5-149  	equ	fn_sortcar,-153
                 777777 777546   5-150  	equ	fn_zerop,-154
                 777777 777545   5-151  	equ	fn_listify,-155
                 777777 777544   5-152  	equ	fn_charpos,-156
                 777777 777543   5-153  	equ	fn_pagel,-157
                 777777 777542   5-154  	equ	fn_linenum,-158
                 777777 777541   5-155  	equ	fn_pagenum,-159
                 777777 777540   5-156  	equ	fn_endpagefn,-160
                 777777 777537   5-157  	equ	fn_arraydims,-161
                 777777 777536   5-158  	equ	fn_loadarrays,-162
                 777777 777535   5-159  	equ	fn_dumparrays,-163
                 777777 777534   5-160  	equ	fn_expt_fix,-164
                 777777 777533   5-161  	equ	fn_expt_flo,-165
                 777777 777532   5-162  	equ	fn_nointerrupt,-166
                 777777 777531   5-163  	equ	fn_open,-167
                 777777 777530   5-164  	equ	fn_in,-168
                 777777 777527   5-165  	equ	fn_out,-169
                 777777 777526   5-166  	equ	fn_truename,-170
                 777777 777525   5-167  	equ	fn_ifix,-171
                 777777 777524   5-168  	equ	fn_fsc,-172
                 777777 777523   5-169  	equ	fn_progv,-173
                 777777 777522   5-170  	equ	fn_mapatoms,-174
                 777777 777521   5-171  	equ	fn_unwind_protect,-175
                 777777 777520   5-172  	equ	fn_eval_when,-176
                 777777 777517   5-173  	equ	fn_read_from_string,-177
                 777777 777516   5-174  	equ	fn_displace,-178
                 777777 777515   5-175  	equ	fn_nth,-179
                 777777 777514   5-176  	equ	fn_nthcdr,-180
                 777777 777513   5-177  	equ	fn_includef,-181
                                 5-178  
                                 5-179  " END INCLUDE FILE lisp_name_codes.incl.alm
                                    19  
                                    20  	even			some constants for numeric routines
    000000                          21  fixnum_zero:
    000000  aa   000000 040047      22  	vfd	36/fixnum_type
    000001  aa   000000 000000      23  	dec	0
    000002                          24  flonum_zero:
    000002  aa   000000 020047      25  	vfd	36/flonum_type
    000003  aa   400000 000000      26  	dec	0.0		good old floating point.
                                    27  
    000004  aa   000044 7770 00     28  float_q:	llr	36		convert to fixed double word.
    000005  aa   000044 7330 00     29  	lrs	36		extend sign.
    000006  aa   216000 4110 03     30  	lde	=71b25,du		load exponent with magic number
    000007  aa   400000 4750 03     31  	fad	=0.0,du		and normalize
    000010  aa   000000 7100 16     32  	tra	0,x6		return
                                    33  
                                    34  "	common code to return from a procedure which pushed its return address on
                                    35  "	the unmkd pdl.
                                    36  
    000011  aa  1 77776 3521 37     37  popj:	eppbp	ab|-2,x7*		reload bp from unmarked pdl
    000012  aa   777776 6270 17     38  	eax7	-2,x7		pop off pdl
    000013  aa  2 00000 7101 00     39  	tra	bp|0		and return
                                    40  
                                    41  "	standard return sequence for type 1 lisp subr. Such subrs
                                    42  "	have the caller's lp and the return address pushed on the unmkd
                                    43  "	pdl.
                                    44  
    000014  aa  1 77776 3521 37     45  retrn1:	eppbp	ab|-2,x7*		reload return address
    000015  aa  1 77774 3701 37     46  	epplp	ab|-4,x7*		and caller's lp
    000016  aa   777774 6270 17     47  	eax7	-4,x7		pop unmarked stack
    000017  aa  2 00000 7101 00     48  	tra	bp|0		and return to caller.
                                    49  "
                        000020      50  	segdef	null
    000020  aa  0 77776 2371 00     51  null:	ldaq	ap|-2		load argument
    000021  aa  0 77776 3501 00     52  	eppap	ap|-2		pop stack
    000022  aa  1 00012 1171 00     53  	cmpaq	ab|nil		see if arg is nil
    000023  aa   000003 6000 04     54  	tze	ret_t-*,ic	if so, return true.
    000024  aa  1 00012 2371 00     55  ret_nil:	ldaq	ab|nil		else return false.
    000025  aa  2 00000 7101 00     56  	tra	bp|0
    000026  aa  1 00014 2371 00     57  ret_t:	ldaq	ab|true
    000027  aa  2 00000 7101 00     58  	tra	bp|0
                                    59  
                        000030      60  	segdef	eq
    000030  aa  0 77774 2371 00     61  eq:	ldaq	ap|-4
    000031  aa  0 77776 1171 00     62  	cmpaq	ap|-2		compare 2 arguments as pointers.
    000032  aa  0 77774 3501 00     63  	eppap	ap|-4		pop stack, changing no indicators.
    000033  aa   777773 6000 04     64  	tze	ret_t-*,ic
    000034  aa   777770 7100 04     65  	tra	ret_nil-*,ic
                                    66  
                        000035      67  	segdef	atom
    000035  aa  0 77776 2351 00     68  atom:	lda	ap|-2		load type field
    000036  aa  0 77776 3501 00     69  	eppap	ap|-2		and pop off stack
    000037  aa   077700 3150 07     70  	cana	Atomic,dl
    000040  aa   777764 6000 04     71  	tze	ret_nil-*,ic
    000041  aa   777765 7100 04     72  	tra	ret_t-*,ic
                                    73  
                        000042      74  	segdef	numberp
    000042  aa  0 77776 2371 00     75  numberp:	ldaq	ap|-2
    000043  aa  0 77776 3501 00     76  	eppap	ap|-2
    000044  aa   061400 3150 07     77  	cana	Numeric,dl
    000045  aa   777757 6000 04     78  	tze	ret_nil-*,ic
    000046  aa   777760 7100 04     79  	tra	ret_t-*,ic
                                    80  
                        000047      81  	segdef	fixp
    000047  aa  0 77776 2371 00     82  fixp:	ldaq	ap|-2
    000050  aa  0 77776 3501 00     83  	eppap	ap|-2
    000051  aa   041000 3150 07     84  	cana	Fixed+Big_fixed,dl
    000052  aa   777754 6010 04     85  	tnz	ret_t-*,ic
    000053  aa   777751 7100 04     86  	tra	ret_nil-*,ic
                                    87  
                        000054      88  	segdef	smallnump
    000054  aa  0 77776 2371 00     89  smallnump:ldaq	ap|-2
    000055  aa  0 77776 3501 00     90  	eppap	ap|-2
    000056  aa   040047 1150 07     91  	cmpa	fixnum_type,dl	" only small fixnums match here.
    000057  aa   777747 6000 04     92  	tze	ret_t-*,ic
    000060  aa   777744 7100 04     93  	tra	ret_nil-*,ic
                                    94  
                        000061      95  	segdef	bigp
    000061  aa  0 77776 2371 00     96  bigp:	ldaq	ap|-2
    000062  aa  0 77776 3501 00     97  	eppap	ap|-2
    000063  aa   001000 3150 07     98  	cana	Big_fixed,dl
    000064  aa   777742 6010 04     99  	tnz 	ret_t-*,ic
    000065  aa   777737 7100 04    100  	tra	ret_nil-*,ic
                                   101  
                        000066     102  	segdef	floatp
    000066  aa  0 77776 2371 00    103  floatp:	ldaq	ap|-2
    000067  aa  0 77776 3501 00    104  	eppap	ap|-2
    000070  aa   020047 1150 07    105  	cmpa	flonum_type,dl
    000071  aa  2 00000 6001 00    106  	tze	bp|0
    000072  aa   777732 7100 04    107  	tra	ret_nil-*,ic
                                   108  
                        000073     109  	segdef	stringp
    000073  aa  0 77776 2371 00    110  stringp:	ldaq	ap|-2
    000074  aa  0 77776 3501 00    111  	eppap	ap|-2
    000075  aa   004000 3150 07    112  	cana	String,dl
    000076  aa   777730 6010 04    113  	tnz	ret_t-*,ic
    000077  aa   777725 7100 04    114  	tra	ret_nil-*,ic
                                   115  
                        000100     116  	segdef	subrp
    000100  aa  0 77776 2351 00    117  subrp:	lda	ap|-2
    000101  aa  0 77776 3501 00    118  	eppap	ap|-2
    000102  aa   002000 3150 07    119  	cana	Subr,dl
    000103  aa   777723 6010 04    120  	tnz	ret_t-*,ic
    000104  aa   777720 7100 04    121  	tra	ret_nil-*,ic
                                   122  
                        000105     123  	segdef	symbolp
    000105  aa  0 77776 2351 00    124  symbolp:	lda	ap|-2
    000106  aa  0 77776 3501 00    125  	eppap	ap|-2
    000107  aa   010000 3150 07    126  	cana	Atsym,dl
    000110  0a   000026 6010 00    127  	tnz	ret_t
    000111  0a   000024 7100 00    128  	tra	ret_nil
                                   129  
                        000112     130  	segdef	arrayp
    000112  aa  0 77776 2351 00    131  arrayp:	lda	ap|-2
    000113  aa  0 77776 3501 00    132  	eppap	ap|-2
    000114  aa   000200 3150 07    133  	cana	Array,dl
    000115  0a   000026 6010 00    134  	tnz	ret_t
    000116  0a   000024 7100 00    135  	tra	ret_nil
                                   136  
                        000117     137  	segdef	filep
    000117  aa  0 77776 2351 00    138  filep:	lda	ap|-2
    000120  aa  0 77776 3501 00    139  	eppap	ap|-2
    000121  aa   000100 3150 07    140  	cana	File,dl
    000122  0a   000026 6010 00    141  	tnz	ret_t
    000123  0a   000024 7100 00    142  	tra	ret_nil
                                   143  
                        000124     144  	segdef	zerop
    000124  aa  0 77776 2371 00    145  zerop:	ldaq	ap|-2
    000125  aa   061000 3150 07    146  	cana	Fixed+Float+Big_fixed,dl
    000126  aa   000005 6010 04    147  	tnz	5,ic
    000127  0a   000157 7040 00    148  	tsx4	push_ptrs
    000130                         149  zerop_tsx4:
    000130  0a   001332 7040 00    150  	tsx4	bad_arg
    000131  0a   000164 7040 00    151  	tsx4	pop_ptrs
    000132  0a   000124 7100 00    152  	tra	zerop
    000133  aa  0 77776 3501 00    153  	eppap	ap|-2		pop stack.
    000134  aa   777644 1170 04    154  	cmpaq	fixnum_zero-*,ic	see if fixed zero.
    000135  aa   777671 6000 04    155  	tze	ret_t-*,ic
    000136  aa   777644 1170 04    156  	cmpaq	flonum_zero-*,ic	see if float zero
    000137  aa   777667 6000 04    157  	tze	ret_t-*,ic
    000140  aa   777664 7100 04    158  	tra	ret_nil-*,ic
                                   159  
                        000141     160  	segdef	oddp		" determine if fixnum is odd.
    000141  aa  0 77776 2371 00    161  oddp:	ldaq	ap|-2		" check arg for fixnum
    000142  aa   001000 3150 07    162  	cana	Big_fixed,dl	" big case, must check least significant word.
    000143  aa   000006 6000 04    163  	tze	not_big-*,ic
    000144  aa  0 77776 2371 20    164  	ldaq	ap|-2,*		" load first two words of bignum.
    000145  aa  0 77776 3501 00    165  oddp_test:eppap	ap|-2
    000146  aa   000001 3160 07    166  	canq	1,dl		" least significant word is in q.
    000147  aa   777655 6000 04    167  	tze	ret_nil-*,ic
    000150  aa   777656 7100 04    168  	tra	ret_t-*,ic
                                   169  
    000151  aa   040047 1150 07    170  not_big:	cmpa	fixnum_type,dl	" must be fixnum arg.
    000152  aa   777773 6000 04    171  	tze	oddp_test-*,ic
                                   172  
    000153  0a   000157 7040 00    173  	tsx4	push_ptrs
    000154  0a   001332 7040 00    174  oddp_tsx4:tsx4	bad_arg
    000155  0a   000164 7040 00    175  	tsx4	pop_ptrs
    000156  aa   777763 7100 04    176  	tra	oddp-*,ic		" and try again.
                                   177  
    000157  aa   000004 6270 17    178  push_ptrs:	eax7	4,x7
    000160  aa  1 77774 6501 17    179  	sprilp	ab|-4,x7
    000161  aa  1 77776 2521 17    180  	spribp	ab|-2,x7
    000162  aa  1 00044 3701 20    181  	epplp	ab|system_lp,*	" get system lp.
    000163  aa   000000 7100 14    182  	tra	0,x4		return
    000164  aa  1 77774 3701 37    183  pop_ptrs:	epplp	ab|-4,x7*		" reload lp
    000165  aa  1 77776 3521 37    184  	eppbp	ab|-2,x7*
    000166  aa   777774 6270 17    185  	eax7	-4,x7		" and pop stack.
    000167  aa  0 77776 7571 00    186  	staq	ap|-2		" put new value back
    000170  aa   000000 7100 14    187  	tra	0,x4
                                   188  "
                        000171     189  	segdef	runtime
    000171  aa   000006 6270 17    190  runtime:	eax7	6,x7
    000172  aa  1 77772 6501 17    191  	sprilp	ab|-6,x7
    000173  aa  1 77774 2521 17    192  	spribp	ab|-4,x7
    000174  aa  1 00044 3701 20    193  	epplp	ab|system_lp,*	" get sytem lp, to save data for pl1.
    000175  4a  4 00010 2501 20    194  	spriap	<lisp_static_vars_>|[stack_ptr]
    000176  4a  4 00012 7471 20    195  	stx7	<lisp_static_vars_>|[unmkd_ptr]+1
    000177  aa  1 00016 5541 00    196  	stc1	ab|in_pl1_code
                                   197  
    000200  aa   000060 6270 00    198  	push			" get pl1 stack frame.
    000201  aa  7 00040 2721 20
    000202  4a  4 00014 3521 20    199  	eppbp	<lisp_static_vars_>|[unmkd_ptr],*
    000203  aa  2 77776 3521 00    200  	eppbp	bp|-2		" get place to put cpu time.
    000204  aa  6 00052 2521 00    201  	spribp	arg+2
    000205  aa   001123 2370 04    202  	ldaq	one_arg-*,ic
    000206  aa  6 00050 7571 00    203  	staq	arg
    000207  aa  6 00050 3501 00    204  	eppap	arg
    000210  4a  4 00016 3521 20    205  	short_call <hcs_>|[virtual_cpu_time_]
    000211  aa  7 00036 6701 20
    000212  aa  6 00030 3701 20
    000213  aa  6 00020 3521 20    206  	eppbp	sp|16,*		" pop stack frame off.
    000214  aa  7 00024 6521 00    207  	sprisp	sb|stack_header.stack_end_ptr
    000215  aa  2 00000 3721 00    208  	eppsp	bp|0
                                   209  
    000216  4a  4 00014 3511 20    210  	epbpab	<lisp_static_vars_>|[unmkd_ptr],*
    000217  4a  4 00020 3501 20    211  	eppap	<lisp_static_vars_>|[stack_ptr],*
    000220  4a  4 00012 2271 20    212  	ldx7	<lisp_static_vars_>|[unmkd_ptr]+1
    000221  aa  1 00016 4501 00    213  	stz	ab|in_pl1_code
    000222  aa  1 77777 2361 17    214  	ldq	ab|-1,x7		" get cpu time.
    000223  aa   040047 2350 07    215  	lda	fixnum_type,dl
    000224  aa  1 77774 3521 37    216  	eppbp	ab|-4,x7*
    000225  aa  1 77772 3701 37    217  	epplp	ab|-6,x7*
    000226  aa   777772 6270 17    218  	eax7	-6,x7
    000227  aa  2 00000 7101 00    219  	tra	bp|0		" return
                                   220  
                                   221  
                                   222  
                                   223  
                                   224  
                                   225  "
                                   226  
                                   227  "	fsubrs for comment and declare.
                                   228  
                        000230     229  	segdef	comment
    000230  4a  4 00022 2371 20    230  comment:	ldaq	<lisp_static_vars_>|[comment_atom]
    000231  aa  0 77776 3501 00    231  	eppap	ap|-2
    000232  aa   777562 7100 04    232  	tra	retrn1-*,ic
                                   233  
                        000233     234  	segdef	declare
    000233  4a  4 00024 2371 20    235  declare:	ldaq	<lisp_static_vars_>|[declare_atom]
    000234  aa  0 77776 3501 00    236  	eppap	ap|-2
    000235  aa   777557 7100 04    237  	tra	retrn1-*,ic
                                   238  "
                        000236     239  	segdef	length		computes length of list.
    000236  aa   777542 2370 04    240  length:	ldaq	fixnum_zero-*,ic	initial length is zero.
    000237  aa   000002 6270 17    241  	eax7	2,x7		save return address.
    000240  aa  1 77776 2521 17    242  	spribp	ab|-2,x7
    000241  aa  0 77774 3521 00    243  	eppbp	ap|-4		start list off right.
    000242  aa  2 00002 7201 00    244  len_loop:	lxl0	bp|2		see if any more
    000243  aa   077700 3000 03    245  	canx0	Atomic,du
    000244  aa   000004 6010 04    246  	tnz	ret_l-*,ic	if none, return aq
    000245  aa   000001 0760 07    247  	adq	1,dl		bump aq
    000246  aa  2 00002 3521 20    248  	eppbp	bp|2,*		go down cdr
    000247  aa   777773 7100 04    249  	tra	len_loop-*,ic	and try again.
    000250  aa  0 77776 3501 00    250  ret_l:	eppap	ap|-2		pop arg off stack
    000251  aa   777540 7100 04    251  	tra	popj-*,ic		and return to address saved on pdl
                                   252  
                        000252     253  	segdef	last
    000252  aa  0 77776 2371 00    254  last:	ldaq	ap|-2		result is arg if atomic
    000253  aa   000002 6270 17    255  	eax7	2,x7
    000254  aa  1 77776 2521 17    256  	spribp	ab|-2,x7		save return addr
    000255  aa  0 77774 3521 00    257  	eppbp	ap|-4		start list off right
    000256  aa  2 00002 7201 00    258  last_loop:lxl0	bp|2		get type of cdr
    000257  aa   077700 3000 03    259  	canx0	Atomic,du		see if atom,
    000260  aa   777770 6010 04    260  	tnz	ret_l-*,ic	return aq if so.
    000261  aa  2 00002 2371 00    261  	ldaq	bp|2		else load cdr into aq
    000262  aa  2 00002 3521 20    262  	eppbp	bp|2,*		and chase down list
    000263  aa   777773 7100 04    263  	tra	last_loop-*,ic
                                   264  
                                   265  "
                                   266  "	lisp function _e_q_u_a_l.
                                   267  "
                                   268  "	Other routines in this segment require that equal not change index register
                                   269  "	3 during its operation, as it is used as an internal procedure by some.
                                   270  "
                        000264     271  	segdef	equal
    000264  aa   000002 6270 17    272  equal:	eax7	2,x7		get space and
    000265  aa  1 77776 2521 17    273  	spribp	ab|-2,x7		save return address.
    000266  aa   000000 6200 00    274  	eax0	0		set recursion depth.
                                   275  
    000267  aa  0 77774 2371 00    276  eql_lp:	ldaq	ap|-4		first test for eq
    000270  aa  0 77776 1171 00    277  	cmpaq	ap|-2
    000271  aa   000067 6000 04    278  	tze	ret_t_eql-*,ic	and return true for this level if so.
    000272  aa   077700 3150 07    279  	cana	Atomic,dl		check for list
    000273  aa   000024 6000 04    280  	tze	list_eql-*,ic	and go to recursive equal
    000274  aa   072000 3150 07    281  	cana	Atsym+Subr+Fixed+Float,dl	these are equal iff eq.
    000275  aa   000060 6010 04    282  	tnz	ret_nil_eql-*,ic
    000276  aa   001000 3150 07    283  	cana	Big_fixed,dl	check for bignum
    000277  aa   000040 6010 04    284  	tnz	bignum_eql-*,ic
    000300  aa   004000 3150 07    285  	cana	String,dl		check for string
    000301  aa   000054 6000 04    286  	tze	ret_nil_eql-*,ic	and if not, unknown type.
                                   287  
                                   288  " 				string compare....
    000302  aa  0 77776 2351 00    289  	lda	ap|-2		load type field
    000303  aa   004000 3150 07    290  	cana	String,dl
    000304  aa   000051 6000 04    291  	tze	ret_nil_eql-*,ic
    000305  aa  0 77776 2351 20    292  	lda	ap|-2,*		load length
    000306  aa  0 77774 1151 20    293  	cmpa	ap|-4,*		and compare lengths.
    000307  aa   000046 6010 04    294  	tnz	ret_nil_eql-*,ic	if not equal, then complain.
    000310  aa  0 77776 3521 20    295  	eppbp	ap|-2,*		get ptrs to strings
    000311  aa  0 77774 3715 20    296  	epplb	ap|-4,*
    000312  aa  0 00140 1065 40    297  	cmpc	(pr,rl),(pr,rl)
    000313  aa   200001 000005     298  	desc9a	bp|1,al
    000314  aa   500001 000005     299  	desc9a	lb|1,al
    000315  aa   000043 6000 04    300  	tze	ret_t_eql-*,ic
    000316  aa   000037 7100 04    301  	tra	ret_nil_eql-*,ic
                                   302  
    000317  aa  0 77776 2351 00    303  list_eql:	lda	ap|-2		load type of second arg
    000320  aa   077700 3150 07    304  	cana	Atomic,dl		if atomic, then can't be a list
    000321  aa   000034 6010 04    305  	tnz	ret_nil_eql-*,ic
    000322  aa  0 00004 3501 00    306  	eppap	ap|4		get room to recurse
    000323  aa   777774 6200 10    307  	eax0	-4,x0		and bump recursion counter.
    000324  aa  0 77770 3521 20    308  	eppbp	ap|-8,*		get car and cdr of arg 1
    000325  aa  2 00000 2371 00    309  	ldaq	bp|0
    000326  aa  0 77774 7571 00    310  	staq	ap|-4		and pass to loop
    000327  aa  2 00002 2371 00    311  	ldaq	bp|2
    000330  aa  0 77770 7571 00    312  	staq	ap|-8
    000331  aa  0 77772 3521 20    313  	eppbp	ap|-6,*		get car and cdr of 2nd arg
    000332  aa  2 00000 2371 00    314  	ldaq	bp|0
    000333  aa  0 77776 7571 00    315  	staq	ap|-2
    000334  aa  2 00002 2371 00    316  	ldaq	bp|2
    000335  aa  0 77772 7571 00    317  	staq	ap|-6
    000336  aa   777731 7100 04    318  	tra	eql_lp-*,ic
                                   319  
    000337                         320  bignum_eql:			" first arg is bignum...
    000337  aa  0 77776 2351 00    321  	lda	ap|-2		load second arg type.
    000340  aa   001000 3150 07    322  	cana	Big_fixed,dl
    000341  aa   000014 6000 04    323  	tze	ret_nil_eql-*,ic
                                   324  
    000342  aa  0 77774 3521 20    325  	eppbp	ap|-4,*		get pointer to first bignum
    000343  aa  2 00000 2361 00    326  	ldq	bp|0		sign and length in q
    000344  aa  0 77776 3715 20    327  	epplb	ap|-2,*
    000345  aa  5 00000 1161 00    328  	cmpq	lb|0		compare sign and length with other value.
    000346  aa   000007 6010 04    329  	tnz	ret_nil_eql-*,ic	if sign or length differ, return nil
    000347  aa   000001 6360 06    330  	eaq	1,ql		get total length in qu and flush sign bits
    000350  aa   000002 7360 00    331  	qls	2		convert to characters
    000351  aa  0 00140 1065 40    332  	cmpc	(pr,rl),(pr,rl)
    000352  aa   200000 000002     333  	desc9a	bp|0,qu
    000353  aa   500000 000002     334  	desc9a	lb|0,qu
    000354  aa   000004 6000 04    335  	tze	ret_t_eql-*,ic
                                   336  "	tra	ret_nil_eql-*,ic
                                   337  
    000355                         338  ret_nil_eql:			" return nil, which propagates back...
    000355  aa  1 00012 2371 00    339  	ldaq	ab|nil
    000356  aa  0 77774 3501 10    340  	eppap	ap|-4,x0		and pop back all of stack stuff
    000357  aa   777432 7100 04    341  	tra	popj-*,ic
                                   342  
    000360  aa   000004 6200 10    343  ret_t_eql:eax0	4,x0		pop off recursion counter
    000361  aa   000002 6000 04    344  	tze	2,ic		this and next could be replaced by one inst.
    000362  aa   000003 6050 04    345  	tpl	ret_t_for_real-*,ic
    000363  aa  0 77774 3501 00    346  	eppap	ap|-4		pop off stack
    000364  aa   777703 7100 04    347  	tra	eql_lp-*,ic	and return, checking cdr.
    000365                         348  ret_t_for_real:
    000365  aa  0 77770 3501 10    349  	eppap	ap|-8,x0		pop stack
    000366  aa  1 00014 2371 00    350  	ldaq	ab|true
    000367  aa   777422 7100 04    351  	tra	popj-*,ic
                                   352  
                                   353  
                                   354  
                        000370     355  	segdef	alphalessp
    000370                         356  alphalessp:
    000370  0a   000405 7060 00    357  	tsx6	stringcmp
    000371  0a   000400 7100 00    358  	tra	true_return
    000372  0a   000402 7100 00    359  	tra	nil_return
    000373  0a   000402 7100 00    360  	tra	nil_return
                                   361  
                        000374     362  	segdef	samepnamep
    000374                         363  samepnamep:
    000374  0a   000405 7060 00    364  	tsx6	stringcmp
    000375  0a   000402 7100 00    365  	tra	nil_return
    000376  0a   000400 7100 00    366  	tra	true_return
    000377  0a   000402 7100 00    367  	tra	nil_return
                                   368  
    000400                         369  true_return:
    000400  aa  1 00014 2371 00    370  	ldaq	ab|true
    000401  aa   000002 7100 04    371  	tra	2,ic
    000402                         372  nil_return:
    000402  aa  1 00012 2371 00    373  	ldaq	ab|nil
    000403  aa  0 77774 3501 00    374  	eppap	ap|-4
    000404  0a   000014 7100 00    375  	tra	retrn1
                                   376  
    000405                         377  stringcmp:
    000405  aa  0 77774 2371 00    378  	ldaq	ap|-4		"  load  first arg.
    000406  aa   014000 3150 07    379  	cana	Atsym+String,dl
    000407  0a   000413 6010 00    380  	tnz	good_alpha1	" ok argument is string or atsym
    000410  0a   000450 7040 00    381  	tsx4	bad_string
    000411  aa  0 77774 7571 00    382  	staq	ap|-4
    000412  0a   000405 7100 00    383  	tra	stringcmp
                                   384  
    000413                         385  good_alpha1:
    000413  aa  0 77776 2371 00    386  	ldaq	ap|-2
    000414  aa   014000 3150 07    387  	cana	Atsym+String,dl	" check for  string or atsym.
    000415  0a   000421 6010 00    388  	tnz	good_alpha2
    000416  0a   000450 7040 00    389  	tsx4	bad_string
    000417  aa  0 77776 7571 00    390  	staq	ap|-2
    000420  0a   000413 7100 00    391  	tra	good_alpha1
                                   392  
    000421                         393  good_alpha2:
    000421  aa  0 77776 3715 20    394  	epplb	ap|-2,*	" get pointer to second arg.
    000422  aa   004000 3150 07    395  	cana	String,dl		" if string, ptr is right.
    000423  aa   000002 6010 04    396  	tnz	2,ic
    000424  aa  5 00004 3715 00    397  	epplb	lb|4		" otherwise bump pointer.
    000425  aa  0 77774 3521 20    398  	eppbp	ap|-4,*		" get pointer to first arg's ascii in bp
    000426  aa  0 77774 2351 00    399  	lda	ap|-4
    000427  aa   004000 3150 07    400  	cana	String,dl		" check for string.
    000430  aa   000002 6010 04    401  	tnz	2,ic
    000431  aa  2 00004 3521 00    402  	eppbp	bp|4		" otherwise bump bp to point at pname.
                                   403  
    000432  aa  2 00000 2351 00    404  	lda	bp|0
    000433  aa  5 00000 1151 00    405  	cmpa	lb|0		" get minimum length of args.
    000434  aa   000002 6040 04    406  	tmi	2,ic
    000435  aa  5 00000 2351 00    407  	lda	lb|0
    000436  aa  0 00140 1065 40    408  	cmpc	(pr,rl),(pr,rl)
    000437  aa   200001 000005     409  	desc9a	bp|1,al
    000440  aa   500001 000005     410  	desc9a	lb|1,al
    000441  aa   000000 6020 16    411  	tnc	0,x6		first < second
    000442  aa   000002 6010 16    412  	tnz	2,x6		first > second
                                   413  
                                   414  	" appear equal, check lengths
                                   415  
    000443  aa  2 00000 2351 00    416  	lda	bp|0
    000444  aa  5 00000 1151 00    417  	cmpa	lb|0
    000445  aa   000000 6040 16    418  	tmi	0,x6		second longer, it is >
    000446  aa   000001 6000 16    419  	tze	1,x6		same length, they are =
    000447  aa   000002 7100 16    420  	tra	2,x6		first longer, it is >
                                   421  
    000450                         422  bad_string:
    000450  aa  0 00002 3501 00    423  	eppap	ap|2
    000451  aa  0 77776 7571 00    424  	staq	ap|-2		" save losing arg.
    000452  aa   000004 6270 17    425  	eax7	4,x7		" save useful index regs.
    000453  aa  1 77775 7461 17    426  	stx6	ab|-3,x7
    000454  aa  1 77774 7441 17    427  	stx4	ab|-4,x7
    000455  0a   000371 1060 03    428  	cmpx6	alphalessp+1,du	" see which function we are.
    000456  aa   000003 6010 04    429  	tnz	3,ic
    000457  aa   000161 3360 07    430  	lcq	-fn_alphalessp,dl
    000460  0a   001356 7100 00    431  	tra	got_name		" jump into error code.
    000461  aa   000162 3360 07    432  	lcq	-fn_samepnamep,dl
    000462  0a   001356 7100 00    433  	tra	got_name
                                   434  
                        000463     435  	segdef	getcharn
    000463  aa   000002 7060 04    436  getcharn:	tsx6	2,ic		same as getchar but returns a fixnum
                                   437  
                        000464     438  	segdef	getchar		" routine to get nth char of pname atom or string.
    000464  aa   000000 6260 00    439  getchar:	eax6	0		set esw
                                   440  
                                   441  " getchar and getcharn join here.  x6 is nonzero for getcharn
                                   442  
    000465  aa  0 77774 2371 00    443  	ldaq	ap|-4		" validate arguments.
    000466  aa   014000 3150 07    444  	cana	Atsym+String,dl	" may be pname atom or string.
    000467  0a   000473 6010 00    445  	tnz	good_getch1
    000470  0a   001332 7040 00    446  getch_tsx4:tsx4	bad_arg		" bad first arg...
    000471  aa  0 77774 7571 00    447  	staq	ap|-4
    000472  0a   000465 7100 00    448  	tra	getchar+1		" retry with new value.
                                   449  
    000473                         450  good_getch1:			" validate second argument...must be fixnum.
    000473  aa  0 77776 2371 00    451  	ldaq	ap|-2		" second arg.
    000474  aa   040047 1150 07    452  	cmpa	fixnum_type,dl	" must compare exactly.
    000475  0a   000501 6000 00    453  	tze	good_getch2
    000476                         454  getch_tsx4_2:
    000476  0a   001332 7040 00    455  	tsx4	bad_arg
    000477  aa  0 77776 7571 00    456  	staq	ap|-2
    000500  0a   000473 7100 00    457  	tra	good_getch1	" retry with new value.
                                   458  
    000501                         459  good_getch2:			" now do the operation.
    000501  aa  0 77774 3521 20    460  	eppbp	ap|-4,*		" get pointer to string or atsym.
    000502  aa  0 77774 2351 00    461  	lda	ap|-4
    000503  aa   010000 3150 07    462  	cana	Atsym,dl		" if atsym, move pointer to point to name.
    000504  aa   000002 6000 04    463  	tze	2,ic
    000505  aa  2 00004 3521 00    464  	eppbp	bp|4		" name is 4 offset from beginning.
                                   465  
    000506  aa   000001 1760 07    466  	sbq	1,dl		" q register still contains second argument.
    000507  0a   000524 6040 00    467  	tmi	ret_nil_getch	" if <= 0 then return nil...out of range.
    000510  aa  2 00000 1161 00    468  	cmpq	bp|0		" if > than number of chars in name,
    000511  0a   000524 6050 00    469  	tpl	ret_nil_getch	" return nil for out of range.
    000512  aa  2 00001 5005 06    470  	a9bd	bp|1,ql		bp -> char.  necc. because what length to put in mrl?
    000513  aa  0 00100 1015 00    471  	mrl	(pr),(pr),fill(0)	unpack the character into a fixnum
    000514  aa   200000 000001     472  	desc9a	bp|0,1
    000515  aa   077777 000004     473  	desc9a	ap|-1,4
    000516  aa  0 77776 2371 00    474  	ldaq	ap|-2		pick up result, fixnum type already set from arg
    000517  aa   000000 6260 16    475  	eax6	0,x6
    000520  aa   000010 6010 04    476  	tnz	getcharn_return-*,ic
    000521  aa  0 77774 7571 00    477  	staq	ap|-4		make arg to call ascii with.
    000522  aa  0 77776 3501 00    478  	eppap	ap|-2		and pop off other arg.
    000523  4a  4 00026 7101 20    479  	tra	<lisp_reader_alm_>|[ascii_alm]
                                   480  
    000524                         481  ret_nil_getch:
    000524  aa  1 00012 2371 00    482  	ldaq	ab|nil		" return nil for out of bounds arguments.
    000525  aa   000000 6260 16    483  	eax6	0,x6
    000526  aa   000002 6000 04    484  	tze	2,ic
    000527  aa   777251 2370 04    485  	 ldaq	 fixnum_zero-*,ic
    000530                         486  getcharn_return:
    000530  aa  0 77774 3501 00    487  	eppap	ap|-4
    000531  0a   000014 7100 00    488  	tra	retrn1		" return as type 1 subr.
                                   489  
                        000532     490  	segdef	prog1		"10/8/80 -BSG
    000532  aa  0 00000 2371 15    491  prog1:	ldaq	ap|0,x5
    000533  aa  0 00000 3501 15    492  	eppap	ap|0,x5
    000534  aa  2 00000 7101 00    493  	tra	bp|0
                                   494  
                        000535     495  	segdef	prog2
    000535  aa  0 00002 2371 15    496  prog2:	ldaq	ap|2,x5		x5 contains -2*number of arguments.
    000536  aa  0 00000 3501 15    497  	eppap	ap|0,x5
    000537  aa  2 00000 7101 00    498  	tra	bp|0
                                   499  
                        000540     500  	segdef	progn
    000540  aa  0 77776 2371 00    501  progn:	ldaq	ap|-2
    000541  aa  0 00000 3501 15    502  	eppap	ap|0,x5
    000542  aa  2 00000 7101 00    503  	tra	bp|0
                                   504  
                                   505  "
                        000543     506  	segdef	and
    000543  aa  1 00014 2371 00    507  and:	ldaq	ab|true		preload for no arguments.
    000544  aa  0 77776 7201 00    508  and_loop:	lxl0	ap|-2
    000545  aa   077700 3000 03    509  	canx0	Atomic,du		test type of remaining frag of arg list.
    000546  aa   000016 6010 04    510  	tnz	and_done-*,ic
    000547  aa  0 00002 3501 00    511  	eppap	ap|2		get space for eval argument.
    000550  aa  0 77774 3521 20    512  	eppbp	ap|-4,*
    000551  aa  2 00000 2371 00    513  	ldaq	bp|0
    000552  aa  0 77776 7571 00    514  	staq	ap|-2
    000553  aa  2 00002 2371 00    515  	ldaq	bp|2
    000554  aa  0 77774 7571 00    516  	staq	ap|-4
    000555  aa   000004 6270 17    517  	eax7	4,x7		now call eval...
    000556  aa   777776 6250 00    518  	eax5	-2		1 argument.
    000557  aa  1 77774 6501 17    519  	sprilp	ab|-4,x7
    000560  aa  1 77776 3571 17    520  	stcd	ab|-2,x7		save return address.
    000561  4a  4 00030 7101 20    521  	tra	<lisp_>|[eval_]	KLUDGE. requires that eval_ be bound in with this proc.
    000562  aa  1 00012 1171 00    522  	cmpaq	ab|nil		check return val.
    000563  aa   777761 6010 04    523  	tnz	and_loop-*,ic	if nil, then we are done.
    000564  aa  0 77776 3501 00    524  and_done:	eppap	ap|-2		pop off rest of stuff on stack.
    000565  aa   777227 7100 04    525  	tra	retrn1-*,ic	return to caller
                                   526  
                        000566     527  	segdef	or
    000566  aa  1 00012 2371 00    528  or:	ldaq	ab|nil		preload or of no arguments.
    000567  aa  0 77776 7201 00    529  or_loop:	lxl0	ap|-2		check for atom at end of list.
    000570  aa   077700 3000 03    530  	canx0	Atomic,du
    000571  aa   777773 6010 04    531  	tnz	and_done-*,ic
    000572  aa  0 00002 3501 00    532  	eppap	ap|2
    000573  aa  0 77774 3521 20    533  	eppbp	ap|-4,*
    000574  aa  2 00000 2371 00    534  	ldaq	bp|0
    000575  aa  0 77776 7571 00    535  	staq	ap|-2
    000576  aa  2 00002 2371 00    536  	ldaq	bp|2
    000577  aa  0 77774 7571 00    537  	staq	ap|-4		and call eval now.
    000600  aa   000004 6270 17    538  	eax7	4,x7
    000601  aa   777776 6250 00    539  	eax5	-2		1 argument
    000602  aa  1 77774 6501 17    540  	sprilp	ab|-4,x7
    000603  aa  1 77776 3571 17    541  	stcd	ab|-2,x7
    000604  4a  4 00030 7101 20    542  	tra	<lisp_>|[eval_]	KLUDGE. (see and)
    000605  aa  1 00012 1171 00    543  	cmpaq	ab|nil
    000606  aa   777761 6000 04    544  	tze	or_loop-*,ic
    000607  aa   777755 7100 04    545  	tra	and_done-*,ic
                                   546  
                                   547  "
                        000610     548  	segdef	cond		" lisp conditional function.
    000610  aa  0 00004 3501 00    549  cond:	eppap	ap|4		get room for temps.
    000611  aa  1 00012 2371 00    550  	ldaq	ab|nil
    000612  aa  0 77776 7571 00    551  	staq	ap|-2
    000613  aa  0 77772 2351 00    552  cond_loop:lda	ap|-6		load type of cond list
    000614  aa   077700 3150 07    553  	cana	Atomic,dl		and check for end of list.
    000615  aa   000040 6010 04    554  	tnz	cond_done-*,ic
    000616  aa  0 77772 3521 20    555  	eppbp	ap|-6,*		get head of list
    000617  aa  2 00000 2371 00    556  	ldaq	bp|0
    000620  aa  0 77774 7571 00    557  	staq	ap|-4		and store it as the next phrase.
    000621  aa  2 00002 2371 00    558  	ldaq	bp|2		get cdr of cond list
    000622  aa  0 77772 7571 00    559  	staq	ap|-6		and save for next time.
    000623  aa  0 77774 2371 20    560  	ldaq	ap|-4,*		get predicate.
    000624  aa  0 77776 7571 00    561  	staq	ap|-2		and set it to be arg to eval
    000625  aa   000004 6270 17    562  	eax7	4,x7
    000626  aa   777776 6250 00    563  	eax5	-2		1 argument
    000627  aa  1 77774 6501 17    564  	sprilp	ab|-4,x7		set up call to eval...
    000630  aa  1 77776 3571 17    565  	stcd	ab|-2,x7
    000631  4a  4 00030 7101 20    566  	tra	<lisp_>|[eval_]	KLUDGE, requiring that cond be bound with eval.
    000632  aa  0 00002 3501 00    567  	eppap	ap|2		save result on stack
    000633  aa  0 77776 7571 00    568  	staq	ap|-2
    000634  aa  1 00012 1171 00    569  	cmpaq	ab|nil
    000635  aa   777756 6000 04    570  	tze	cond_loop-*,ic	loop back for next predicate.
    000636  aa  0 77774 3521 20    571  cond_ev:	eppbp	ap|-4,*		get phrase
    000637  aa  2 00002 2371 00    572  	ldaq	bp|2		load cdr of phrase
    000640  aa   077700 3150 07    573  	cana	Atomic,dl		check for end
    000641  aa   000014 6010 04    574  	tnz	cond_done-*,ic
    000642  aa  0 77774 7571 00    575  	staq	ap|-4		and store as rest of phrase
    000643  aa  0 77774 2371 20    576  	ldaq	ap|-4,*		load car of phrase
    000644  aa  0 77776 7571 00    577  	staq	ap|-2		and store as next thing.
    000645  aa   000004 6270 17    578  	eax7	4,x7
    000646  aa   777776 6250 00    579  	eax5	-2		1 argument.
    000647  aa  1 77774 6501 17    580  	sprilp	ab|-4,x7		save stuff for call to eval
    000650  aa  1 77776 3571 17    581  	stcd	ab|-2,x7
    000651  4a  4 00030 7101 20    582  	tra	<lisp_>|[eval_]	KLUDGE.
    000652  aa  0 00002 3501 00    583  	eppap	ap|2
    000653  aa  0 77776 7571 00    584  	staq	ap|-2		save result
    000654  aa   777762 7100 04    585  	tra	cond_ev-*,ic
    000655  aa  0 77776 2371 00    586  cond_done:ldaq	ap|-2		load last result
    000656  aa  0 77772 3501 00    587  	eppap	ap|-6		pop off stacks
    000657  aa   777135 7100 04    588  	tra	retrn1-*,ic	and go to return sequence.
                                   589  "
                                   590  
                        000660     591  	segdef	member
    000660  aa  0 77774 2351 00    592  member:	lda	ap|-4		if first arg atomic, turn into memq
    000661  aa   072000 3150 07    593  	cana	Atsym+Subr+Fixed+Float,dl	(see equal)
    000662  aa   000022 6010 04    594  	tnz	memq-*,ic
    000663  aa   000002 6270 17    595  	eax7	2,x7		save return address
    000664  aa  1 77776 2521 17    596  	spribp	ab|-2,x7
    000665  aa  0 77776 2351 00    597  	lda	ap|-2		load type of 2nd arg.
    000666  aa   077700 3150 07    598  memb_lp:	cana	Atomic,dl		see if end of list.
    000667  aa   000031 6010 04    599  	tnz	ret_mq-*,ic
    000670  aa  0 00004 3501 00    600  	eppap	ap|4		get room for args to equal.
    000671  aa  0 77770 2371 00    601  	ldaq	ap|-8		load our first arg.
    000672  aa  0 77774 7571 00    602  	staq	ap|-4		and make it first equal arg.
    000673  aa  0 77772 2371 20    603  	ldaq	ap|-6,*		get car of list remaining of 2nd arg
    000674  aa  0 77776 7571 00    604  	staq	ap|-2		and save it as secind equal arg.
    000675  aa   777367 2720 04    605  	tspbp	equal-*,ic	equal is a fast call subr.
    000676  aa  1 00012 1171 00    606  	cmpaq	ab|nil		check result,
    000677  aa   000023 6010 04    607  	tnz	ret_mq_obj-*,ic	and if truely equal, return list.
    000700  aa  0 77776 3521 20    608  	eppbp	ap|-2,*		else take cdr of list,
    000701  aa  2 00002 2371 00    609  	ldaq	bp|2
    000702  aa  0 77776 7571 00    610  	staq	ap|-2		and make it the current list.
    000703  aa   777763 7100 04    611  	tra	memb_lp-*,ic	and loop back to try again.
                                   612  
                        000704     613  	segdef	memq
    000704  aa  0 77776 2351 00    614  memq:	lda	ap|-2		check cdr of list
    000705  aa   000002 6270 17    615  	eax7	2,x7		get space and
    000706  aa  1 77776 2521 17    616  	spribp	ab|-2,x7		save return address.
    000707  aa   077700 3150 07    617  mq_lp:	cana	Atomic,dl
    000710  aa   000010 6010 04    618  	tnz	ret_mq-*,ic
    000711  aa  0 77776 3521 20    619  	eppbp	ap|-2,*		get car of it
    000712  aa  2 00000 2371 00    620  	ldaq	bp|0
    000713  aa  0 77774 1171 00    621  	cmpaq	ap|-4		see if eq to first arg
    000714  aa   000006 6000 04    622  	tze	ret_mq_obj-*,ic	and if so return ap|-2
    000715  aa  2 00002 2371 00    623  	ldaq	bp|2
    000716  aa  0 77776 7571 00    624  	staq	ap|-2		store cdr of list back
    000717  aa   777770 7100 04    625  	tra	mq_lp-*,ic
    000720  aa  1 00012 2371 00    626  ret_mq:	ldaq	ab|nil
    000721  aa   000002 7100 04    627  	tra	2,ic		skip to return sequence.
    000722  aa  0 77776 2371 00    628  ret_mq_obj:ldaq	ap|-2		load current object list
    000723  aa  0 77774 3501 00    629  	eppap	ap|-4		restore stack
    000724  aa   777065 7100 04    630  	tra	popj-*,ic
                                   631  "
                        000725     632  	segdef	sassoc
    000725  aa   777776 6230 00    633  sassoc:	eax3	-2		offset to assoc args from ap.
                                   634  				" NOTE: assumes x3 is not used by equal!
                                   635  				" do not change equal to use x3 or call out.
    000726  aa   000002 7100 04    636  	tra	assoc1-*,ic	jump into common code.
                                   637  
                        000727     638  	segdef	assoc
    000727  aa   000000 6230 00    639  assoc:	eax3	0		offset to assoc args from ap, see above
    000730  aa  0 77774 2371 13    640  assoc1:	ldaq	ap|-4,x3		pick up arg 1
    000731  aa   072000 3150 07    641  	cana	Atsym+Subr+Fixed+Float,dl
    000732  aa   000034 6010 04    642  	tnz	assq1-*,ic	if eq =_ equal, use assq or sassq
    000733  aa  0 00006 3501 00    643  	eppap	ap|6		get room for arg list to equal
    000734  aa   000002 6270 17    644  	eax7	2,x7		and get space to save ret addr
    000735  aa  1 77776 2521 17    645  	spribp	ab|-2,x7
    000736  aa  0 77770 2351 13    646  	lda	ap|-8,x3		load type of list arg 2
    000737  aa   077700 3150 07    647  ass_lp:	cana	Atomic,dl
    000740  aa   000021 6010 04    648  	tnz	ret_ass_nil-*,ic
    000741  aa  0 77770 2371 33    649  	ldaq	ap|-8,x3*		load car of arg 2
    000742  aa   077700 3150 07    650  	cana	Atomic,dl		either it is atom, and should be skipped
    000743  aa   000012 6010 04    651  	tnz	skip_ass-*,ic	or should look at its car
    000744  aa  0 77772 7571 00    652  	staq	ap|-6		and save as possible return value
    000745  aa  0 77772 2371 20    653  	ldaq	ap|-6,*		load car of that
    000746  aa  0 77776 7571 00    654  	staq	ap|-2		and make arg of call to equal
    000747  aa  0 77766 2371 13    655  	ldaq	ap|-10,x3		other arg is our first arg
    000750  aa  0 77774 7571 00    656  	staq	ap|-4
    000751  aa   777313 2720 04    657  	tspbp	equal-*,ic
    000752  aa  1 00012 1171 00    658  	cmpaq	ab|nil
    000753  aa   000034 6010 04    659  	tnz	assq_done-*,ic	if equal, then return value at ap|-2
    000754  aa  0 00004 3501 00    660  	eppap	ap|4		get back space lost by equal
    000755                         661  skip_ass:
    000755  aa  0 77770 3521 33    662  	eppbp	ap|-8,x3*		get cdr of arg 2
    000756  aa  2 00002 2371 00    663  	ldaq	bp|2
    000757  aa  0 77770 7571 13    664  	staq	ap|-8,x3		and save it
    000760  aa   777757 7100 04    665  	tra	ass_lp-*,ic
    000761                         666  ret_ass_nil:
    000761  aa  0 77774 3501 00    667  	eppap	ap|-4		pop some off stack
    000762  aa   000030 7100 04    668  	tra	ret_assq_nil-*,ic
                                   669  "
                        000763     670  	segdef	sassq
    000763  aa   777776 6230 00    671  sassq:	eax3	-2		offset of assoc args from ap.
    000764  aa   000002 7100 04    672  	tra	assq1-*,ic	get into common code.
                        000765     673  	segdef	assq
    000765  aa   000000 6230 00    674  assq:	eax3	0		offset of args from ap
    000766  aa  0 00002 3501 00    675  assq1:	eppap	ap|2
    000767  aa   000002 6270 17    676  	eax7	2,x7
    000770  aa  1 77776 2521 17    677  	spribp	ab|-2,x7
    000771  aa  0 77774 2351 13    678  	lda	ap|-4,x3
    000772  aa   077700 3150 07    679  assq_lp:	cana	Atomic,dl		check for end of lsit
    000773  aa   000017 6010 04    680  	tnz	ret_assq_nil-*,ic
    000774  aa  0 77774 3521 33    681  	eppbp	ap|-4,x3*		get car
    000775  aa  2 00000 2371 00    682  	ldaq	bp|0
    000776  aa   077700 3150 07    683  	cana	Atomic,dl
    000777  aa   000005 6010 04    684  	tnz	skip_assq-*,ic	skip atomic list element
    001000  aa  0 77776 7571 00    685  	staq	ap|-2		save list element
    001001  aa  0 77776 2371 20    686  	ldaq	ap|-2,*		and get its car
    001002  aa  0 77772 1171 13    687  	cmpaq	ap|-6,x3		compare with first arg
    001003  aa   000004 6000 04    688  	tze	assq_done-*,ic	and if eq, return ap|-2
    001004  aa  2 00002 2371 00    689  skip_assq:ldaq	bp|2		get cdr of list
    001005  aa  0 77774 7571 13    690  	staq	ap|-4,x3		and save it
    001006  aa   777764 7100 04    691  	tra	assq_lp-*,ic
    001007  aa  0 77776 2371 00    692  assq_done:ldaq	ap|-2		load result
    001010  aa  0 77772 3501 13    693  assq_ret:	eppap	ap|-6,x3		restore stack
    001011  aa   777000 7100 04    694  	tra	popj-*,ic
    001012                         695  ret_assq_nil:
    001012  aa  1 00012 2371 00    696  	ldaq	ab|nil
    001013  aa   000000 1030 03    697  	cmpx3	0,du		see which entry we came through.
    001014  aa   777774 6000 04    698  	tze	assq_ret-*,ic	if assoc or sassoc, just return nil
                                   699  " 				else want to apply third arg to nil.
    001015  aa  0 77774 7571 13    700  	staq	ap|-4,x3		store in second arg position for apply.
    001016  aa  0 77776 2371 13    701  	ldaq	ap|-2,x3		get function arg.
    001017  aa  0 77776 3501 13    702  	eppap	ap|-2,x3		and bump back the stack.
    001020  aa  0 77774 7571 00    703  	staq	ap|-4		save function as first arg to apply
    001021  aa   000002 6270 17    704  	eax7	2,x7		now set up call to apply.
    001022  aa  1 77774 2371 17    705  	ldaq	ab|-4,x7		load our old return address
    001023  aa  1 77776 7571 17    706  	staq	ab|-2,x7		and make it apply's return address!
    001024  aa  1 77774 6501 17    707  	sprilp	ab|-4,x7		save our caller's lp where apply will reload it
    001025  aa  1 00044 3701 20    708  	epplp	ab|system_lp,*	get our lp (which must be apply's also,
                                   709  				" since we are relying on fact that apply is bound in.)
    001026  aa   777774 6250 00    710  	eax5	-4		load lsubr arg count.
    001027  4a  4 00032 7101 20    711  	tra	<lisp_>|[apply_]	call apply who will return to our caller.
                                   712  "
                        001030     713  	segdef	delete
    001030  aa  0 00000 2371 15    714  delete:	ldaq	ap|0,x5		get first argument
    001031  aa   072000 3150 07    715  	cana	Atsym+Subr+Fixed+Float,dl	eq =_ equal for this?
    001032  aa   000066 6010 04    716  	tnz	delq-*,ic		yes, turn into delq
    001033  aa   777777 6230 00    717  	eax3	-1		load number for thing to be deleted as infinity.
    001034  aa   777774 1050 03    718  	cmpx5	-4,du		check for two args
    001035  aa   000003 6000 04    719  	tze	3,ic		if so, infinite number of deletions to be done.
    001036  aa   777744 6200 00    720  	eax0	fn_delete
    001037  aa   000166 7060 04    721  	tsx6	get_count-*,ic	else go to subroutine get count from third arg.
    001040  aa  0 00006 3501 00    722  	eppap	ap|6		get room for args to equal, and temp
    001041  aa   000000 1030 03    723  	cmpx3	0,du		check for no deletion case.
    001042  aa   000053 6000 04    724  	tze	ret_del-*,ic
    001043  aa  0 77770 2351 00    725  	lda	ap|-8		get second arg
    001044  aa   077700 3150 07    726  head_loop:cana	Atomic,dl		see if not list, return if not.
    001045  aa   000050 6010 04    727  	tnz	ret_del-*,ic
    001046  aa  0 77770 2371 20    728  	ldaq	ap|-8,*		get car of second arg
    001047  aa  0 77776 7571 00    729  	staq	ap|-2		make it arg to equal
    001050  aa  0 77766 2371 00    730  	ldaq	ap|-10		get our first arg
    001051  aa  0 77774 7571 00    731  	staq	ap|-4		make it equal's first
    001052  aa   777212 2720 04    732  	tspbp	equal-*,ic
    001053  aa  0 00004 3501 00    733  	eppap	ap|4		get back space
    001054  aa  1 00012 1171 00    734  	cmpaq	ab|nil
    001055  aa   000007 6000 04    735  	tze	end_head-*,ic	if not equal, then this phase is done.
    001056  aa  0 77770 3521 20    736  	eppbp	ap|-8,*		get pointer to list
    001057  aa  2 00002 2371 00    737  	ldaq	bp|2		load cdr
    001060  aa  0 77770 7571 00    738  	staq	ap|-8
    001061  aa   777777 6230 13    739  	eax3	-1,x3		decrement count of deleteions
    001062  aa   777762 6010 04    740  	tnz	head_loop-*,ic	and go back to try again.
    001063  aa   000032 7100 04    741  	tra	ret_del-*,ic
    001064  aa  0 77770 2371 00    742  end_head:	ldaq	ap|-8
    001065  aa  0 77772 7571 00    743  	staq	ap|-6		now we have to look at the cadr caddr ...
    001066  aa   000000 1030 03    744  del_loop:	cmpx3	0,du		see if no more deletions to be done.
    001067  aa   000026 6000 04    745  	tze	ret_del-*,ic
    001070  aa  0 77772 3521 20    746  del_loop1:eppbp	ap|-6,*		get pointer to list cell whose cadr we are checking.
    001071  aa  2 00002 2351 00    747  	lda	bp|2		see if there is a list at the cdr
    001072  aa   077700 3150 07    748  	cana	Atomic,dl
    001073  aa   000022 6010 04    749  	tnz	ret_del-*,ic	and if not, returm
    001074  aa  2 00002 2371 20    750  	ldaq	bp|2,*		load cadr of list
    001075  aa  0 77776 7571 00    751  	staq	ap|-2		and make it second arg to equal
    001076  aa  0 77766 2371 00    752  	ldaq	ap|-10		load our first arg,
    001077  aa  0 77774 7571 00    753  	staq	ap|-4		and make it equal's first
    001100  aa   777164 2720 04    754  	tspbp	equal-*,ic
    001101  aa  0 00004 3501 00    755  	eppap	ap|4		get back space
    001102  aa   000002 6220 00    756  	eax2	2		so cdr's can be easily accessed.
    001103  aa  1 00012 1171 00    757  	cmpaq	ab|nil		check result of equal call
    001104  aa   000006 6000 04    758  	tze	no_del-*,ic	if not equal, don't delete
    001105  aa  0 77772 3521 20    759  	eppbp	ap|-6,*		reload bp, clobbered by equal call
    001106  aa  2 00002 2371 72    760  	ldaq	bp|2,*2		get cddr of list,
    001107  aa  2 00002 7571 00    761  	staq	bp|2		and make it the cdr
    001110  aa   777777 6230 13    762  	eax3	-1,x3		decrement count
    001111  aa   777755 7100 04    763  	tra	del_loop-*,ic
    001112  aa  0 77772 2371 72    764  no_del:	ldaq	ap|-6,*2
    001113  aa  0 77772 7571 00    765  	staq	ap|-6		set result to cdr of result.
    001114  aa   777754 7100 04    766  	tra	del_loop1-*,ic
    001115  aa  0 77770 2371 00    767  ret_del:	ldaq	ap|-8
    001116  aa  0 77766 3501 00    768  	eppap	ap|-10		back up stack
    001117  aa   776675 7100 04    769  	tra	retrn1-*,ic
                                   770  
                        001120     771  	segdef	delq
    001120  aa   777777 6230 00    772  delq:	eax3	-1		load infinite deletion count
    001121  aa   777774 1050 03    773  	cmpx5	-4,du		see if we got more than two args
    001122  aa   000003 6000 04    774  	tze	3,ic		if not, don't check third arg.
    001123  aa   777743 6200 00    775  	eax0	fn_delq
    001124  aa   000101 7060 04    776  	tsx6	get_count-*,ic	get deletion count
    001125  aa  0 77776 3521 00    777  	eppbp	ap|-2		bp always points at thing to replace if car eq
                                   778  				" to deleted object.
    001126  aa   000002 6220 00    779  	eax2	2		allows cdrs to be easily taken.
    001127  aa   000000 1030 03    780  dloop:	cmpx3	0,du		see if any more are to be deleted.
    001130  aa   000015 6000 04    781  	tze	dq_end-*,ic	if no more, return.
    001131  aa  2 00000 2351 00    782  dloop1:	lda	bp|0		load type of current list position.
    001132  aa   077700 3150 07    783  	cana	Atomic,dl		see if we are at end of list.
    001133  aa   000012 6010 04    784  	tnz	dq_end-*,ic
    001134  aa  2 00000 2371 20    785  	ldaq	bp|0,*		load car of list
    001135  aa  0 77774 1171 00    786  	cmpaq	ap|-4		see if eq to our first arg
    001136  aa   000005 6010 04    787  	tnz	no_dq-*,ic	if no deletion to be done go to get cdr
    001137  aa  2 00000 2371 72    788  	ldaq	bp|0,*x2		load cdr of list
    001140  aa  2 00000 7571 00    789  	staq	bp|0		and make it current list, rplacd'ing in place.
    001141  aa   777777 6230 13    790  	eax3	-1,x3		decrement deletion counter
    001142  aa   777765 7100 04    791  	tra	dloop-*,ic	and loop back
    001143  aa  2 00000 3521 72    792  no_dq:	eppbp	bp|0,*2		go to cdr of list
    001144  aa   777765 7100 04    793  	tra	dloop1-*,ic	and loop back
    001145  aa  0 77776 2371 00    794  dq_end:	ldaq	ap|-2		load result
    001146  aa  0 77774 3501 00    795  	eppap	ap|-4		pop args off stack
    001147  aa   776645 7100 04    796  	tra	retrn1-*,ic	and return.
                                   797  "
                        001150     798  	segdef	rplaca
    001150  aa  0 77774 2371 00    799  rplaca:	ldaq	ap|-4		load first arg
    001151  aa   077700 3150 07    800  	cana	Atomic,dl		and check for valid rplaca
    001152  aa   000004 6000 04    801  	tze	replace-*,ic	if list, then go ahead.
    001153                         802  rplaca_tsx4:
    001153  aa   000157 7040 04    803  	tsx4	bad_arg-*,ic	signal error.
    001154  aa  0 77774 7571 00    804  	staq	ap|-4		replace argument,
    001155  aa   777773 7100 04    805  	tra	rplaca-*,ic	and retry.
    001156  aa  0 77776 2371 00    806  replace:	ldaq	ap|-2		load replacement
    001157  aa  0 77774 7571 20    807  	staq	ap|-4,*		and store in car of list
    001160  aa  0 77774 2371 00    808  	ldaq	ap|-4
    001161  aa  0 77774 3501 00    809  	eppap	ap|-4		pop back stack
    001162  aa   776632 7100 04    810  	tra	retrn1-*,ic	rplaca is type one subr.
                                   811  
                        001163     812  	segdef	rplacd
    001163  aa   000002 6220 00    813  rplacd:	eax2	2		we are to replace cdr. (no checking is done either)
    001164  aa  0 77776 2371 00    814  	ldaq	ap|-2		load replacement
    001165  aa  0 77774 7571 72    815  	staq	ap|-4,*x2		and zap it into cons.
    001166  aa  0 77774 2371 00    816  	ldaq	ap|-4		load result
    001167  aa  0 77774 3501 00    817  	eppap	ap|-4		pop stack,
    001170  aa  2 00000 7101 00    818  	tra	bp|0		and return.
                                   819  
                        001171     820  	segdef	displace
    001171  aa  0 77774 2351 00    821  displace:	lda	ap|-4		load first argument
    001172  aa   077700 3150 07    822  	cana	Atomic,dl		Make sure it's not atomic
    001173  aa   000004 6000 04    823  	tze	displace_ok-*,ic	OK, go ahead
    001174                         824  displace_tsx4:
    001174  aa   000136 7040 04    825  	tsx4	bad_arg-*,ic	signal error.
    001175  aa  0 77774 7571 00    826  	staq	ap|-4		replace argument,
    001176  aa   777773 7100 04    827  	tra	displace-*,ic	and retry.
    001177                         828  displace_ok:
    001177  aa  0 77776 2351 00    829  	lda	ap|-2		see if second argument is atomic
    001200  aa   077700 3150 07    830  	cana	Atomic,dl
    001201  0a   001212 6010 00    831  	tnz	displace_atom	if so, replace with `(progn (,y))
    001202  aa  0 77776 2371 20    832  	ldaq	ap|-2,*		otherwise, get (car y)
    001203  aa  0 77774 7571 20    833  	staq	ap|-4,*		(rplaca x (car y))
    001204  aa   000002 6220 00    834  	eax2	2		Now do the cdrs
    001205  aa  0 77776 2371 72    835  	ldaq	ap|-2,*x2		(cdr y)
    001206  aa  0 77774 7571 72    836  	staq	ap|-4,*x2		(rplacd x (cdr y))
    001207  aa  0 77774 2371 00    837  	ldaq	ap|-4		return new x
    001210  aa  0 77774 3501 00    838  	eppap	ap|-4
    001211  aa   776603 7100 04    839  	tra	retrn1-*,ic
                                   840  
    001212                         841  displace_atom:
    001212  4a  4 00034 2371 20    842  	ldaq	lisp_static_vars_$progn_atom
    001213  aa  0 77774 7571 20    843  	staq	ap|-4,*		(rplaca x 'progn)
    001214  aa   000004 6270 17    844  	eax7	4,x7		Make way for calling ncons
    001215  aa  1 77774 6501 17    845  	sprilp	ab|-4,x7		save lp
    001216  aa  1 77776 3571 17    846  	stcd	ab|-2,x7		and return location
    001217  4a  4 00036 7101 20    847  	tra	lisp_alloc_$ncons_ 
    001220  aa   000002 6220 00    848  	eax2	2		store in cdr
    001221  aa  0 77776 7571 72    849  	staq	ap|-2,*x2		(rplacd x (ncons y))
    001222  aa  0 77776 2371 00    850  	ldaq	ap|-2		return new x
    001223  aa  0 77776 3501 00    851  	eppap	ap|-2
    001224  aa   776570 7100 04    852  	tra	retrn1-*,ic
                                   853  
                                   854  "	routine to get 3rd arg as a fixed number in x3.
                                   855  "	it may signal a correctable error.
                                   856  "
    001225                         857  get_count:
    001225  aa  0 00006 3501 15    858  	eppap	ap|6,x5		make sure no more than three args exist.
    001226  aa  0 77776 2371 00    859  	ldaq	ap|-2		get count arg
    001227  aa  0 77776 3501 00    860  	eppap	ap|-2
    001230  aa   040047 1150 07    861  chk_count:cmpa	fixnum_type,dl
    001231  aa   000003 6010 04    862  	tnz	get_count_tsx4-*,ic
    001232  aa   000000 1160 07    863  	cmpq	0,dl		check for negative argument.
    001233  aa   000003 6050 04    864  	tpl	good_count-*,ic
    001234                         865  get_count_tsx4:
    001234  aa   000076 7040 04    866  	tsx4	bad_arg-*,ic	call bad argument signaller.
    001235  aa   777773 7100 04    867  	tra	chk_count-*,ic	and try again.
    001236                         868  good_count:
    001236  aa   000000 6230 06    869  	eax3	0,ql		get count in x3
    001237  aa   000000 7100 16    870  	tra	0,x6		return
                                   871  "
                        001240     872  	segdef	setq
    001240  aa  0 00004 3501 00    873  setq:	eppap	ap|4		get room
    001241  aa  1 00012 2371 00    874  	ldaq	ab|nil		get default return value.
    001242  aa  0 77772 7201 00    875  nxt_setq: lxl0	ap|-6		load type of fsubr arg.
    001243  aa   077700 3000 03    876  	canx0	Atomic,du		and check for end.
    001244  aa   000003 6000 04    877  	tze	more_setq-*,ic	if no end continue.
    001245  aa  0 77772 3501 00    878  	eppap	ap|-6		pop off stack
    001246  aa   776546 7100 04    879  	tra	retrn1-*,ic	and return
    001247  aa  0 77772 2371 20    880  more_setq:ldaq	ap|-6,*		load first of list.
    001250  aa   010000 3150 07    881  chk_name: cana	Atsym,dl		see if atomic.
    001251  aa   000003 6010 04    882  	tnz	good_atom-*,ic
    001252                         883  setq_tsx4:
    001252  aa   000060 7040 04    884  	tsx4	bad_arg-*,ic	signal bad argument.
    001253  aa   777775 7100 04    885  	tra	chk_name-*,ic	and retry if new value returned.
    001254  aa  1 00012 1171 00    886  good_atom:cmpaq	ab|nil		see if trying to setq nil.
    001255  aa   000034 6000 04    887  	tze	set_nil-*,ic	signal uncorrectable error if so.
    001256  aa  0 77774 7571 00    888  	staq	ap|-4		remember thing set.
    001257  aa  0 77772 3521 20    889  	eppbp	ap|-6,*		get next of list
    001260  aa  2 00002 3521 20    890  	eppbp	bp|2,*		..
    001261  aa  2 00000 2371 00    891  	ldaq	bp|0		get value
    001262  aa  0 77776 7571 00    892  	staq	ap|-2
    001263  aa  2 00002 2371 00    893  	ldaq	bp|2		get rest of list
    001264  aa  0 77772 7571 00    894  	staq	ap|-6		and leave for next time.
    001265  aa   000004 6270 17    895  	eax7	4,x7		get room for call to eval
    001266  aa   777776 6250 00    896  	eax5	-2		and set number of args
    001267  aa  1 77774 6501 17    897  	sprilp	ab|-4,x7		save our lp, which is same as eval's
    001270  aa  1 77776 3571 17    898  	stcd	ab|-2,x7		and save return address.
    001271  4a  4 00030 7101 20    899  	tra	<lisp_>|[eval_]	call eval
    001272  aa  0 77776 7571 20    900  	staq	ap|-2,*		setq the atom we saved.
    001273  aa  0 00002 3501 00    901  	eppap	ap|2		get back space for eval call.
    001274  aa   777746 7100 04    902  	tra	nxt_setq-*,ic
                                   903  
                        001275     904  	segdef	set
    001275  aa  0 77774 2371 00    905  set:	ldaq	ap|-4		load first arg.
    001276                         906  retry_set:
    001276  aa   010000 3150 07    907  	cana	Atsym,dl		check atom.
    001277  aa   000004 6010 04    908  	tnz	set_atm-*,ic
    001300                         909  set_tsx4:
    001300  aa   000032 7040 04    910  	tsx4	bad_arg-*,ic	signal correctable error
    001301  aa  0 77774 7571 00    911  	staq	ap|-4		reset arg.
    001302  aa   777774 7100 04    912  	tra	retry_set-*,ic	and try again
    001303  aa  1 00012 1171 00    913  set_atm:	cmpaq	ab|nil		check for set of nil.
    001304  aa   000005 6000 04    914  	tze	set_nil-*,ic	and signal error if so.
    001305  aa  0 77776 2371 00    915  	ldaq	ap|-2		load value.
    001306  aa  0 77774 7571 20    916  	staq	ap|-4,*		and store it
    001307  aa  0 77774 3501 00    917  	eppap	ap|-4		pop stack
    001310  aa   776504 7100 04    918  	tra	retrn1-*,ic
                                   919  
    001311  aa   000002 6270 17    920  set_nil:	eax7	2,x7		we want to signal error
    001312  aa   000200 2350 07    921  	lda	nihil_ex_nihile,dl
    001313  aa  1 77776 7551 17    922  	sta	ab|-2,x7		push code on stack
    001314  4a  4 00010 2501 20    923  	spriap	<lisp_static_vars_>|[stack_ptr]
    001315  4a  4 00012 7471 20    924  	stx7	<lisp_static_vars_>|[unmkd_ptr]+1
    001316  aa  1 00016 5541 00    925  	stc1	ab|in_pl1_code
    001317  aa   000060 6270 00    926  	push
    001320  aa  7 00040 2721 20
    001321  aa   000005 3500 04    927  	eppap	null_arg_list-*,ic
    001322  4a  4 00040 3521 20    928  	short_call 	<lisp_error_>|[lisp_error_]
    001323  aa  7 00036 6701 20
    001324  aa  6 00030 3701 20
    001325  aa   000000 0020 07    929  	drl	0,dl		should never get here.
                                   930  	even
    001326                         931  null_arg_list:
    001326  aa   000000 000004     932  	oct	4
    001327  aa   000000 000000     933  	oct	0
    001330                         934  one_arg:
    001330  aa   000002 000004     935  	oct	2000004,0
    001331  aa   000000 000000 
                                   936  "
                                   937  "	procedure to signal the correctable bad argument condition.
                                   938  "	called with tsx4, with aq containing bad argument,
                                   939  "	x6 containing data which needs to be saved (as perhaps a return address)
                                   940  "	and which returns with aq set to replacement value.
                                   941  "
    001332  aa  0 00002 3501 00    942  bad_arg:	eppap	ap|2		get room for arg to lisp_error_
    001333  aa  0 77776 7571 00    943  	staq	ap|-2		and save value.
    001334  aa   000004 6270 17    944  	eax7	4,x7		get some room on unmkd_pdl
    001335  aa  1 77775 7461 17    945  	stx6	ab|-3,x7		save x6 for caller.
    001336  aa  1 77775 4451 17    946  	sxl5	ab|-3,x7		also save x5 for lsubrs.
    001337  aa  1 77774 7441 17    947  	stx4	ab|-4,x7		save our return address
                                   948  
                                   949  	" get code for function name into q, based on our caller's
                                   950  	" address in x4, except when called from get_count in which
                                   951  	" case the value is already in x0 (with minus sign).
                                   952  
    001340  0a   001235 1040 03    953  	cmpx4	get_count_tsx4+1,du
    001341  aa   000004 6010 04    954  	tnz	get_my_name-*,ic
    001342  aa   000000 6360 10    955  	eaq	0,x0
    001343  aa   000022 7320 00    956  	qrs	18
    001344  aa   000012 7100 04    957  	tra	got_name-*,ic
                                   958  
    001345                         959  get_my_name:
    001345  aa   777767 6360 00    960  	eaq	-name_tbl_len	search table of tsx4 addresses.
    001346                         961  search_for_name:
    001346  0a   001471 1040 02    962  	cmpx4	name_tbl,qu
    001347  aa   000004 6000 04    963  	tze	4,ic		found it
    001350  aa   000001 6360 02    964  	eaq	1,qu		not found, keep looking
    001351  aa   777775 6010 04    965  	tnz	search_for_name-*,ic
    001352  aa   000004 7100 04    966  	tra	got_name-*,ic	" not found, will use zero
                                   967  				" should'nt happen anyway
    001353  0a   001471 2360 02    968  	ldq	name_tbl,qu	found, get code in low half
    001354  aa   000022 7360 00    969  	qls	18		extend sign bit
    001355  aa   000022 7320 00    970  	qrs	18
    001356                         971  got_name:
    001356  aa   000170 2350 07    972  	lda	bad_arg_correctable,dl	load error code
    001357  aa  1 77776 7571 17    973  	staq	ab|-2,x7		and push it
    001360  4a  4 00010 2501 20    974  	spriap	<lisp_static_vars_>|[stack_ptr]
    001361  4a  4 00012 7471 20    975  	stx7	<lisp_static_vars_>|[unmkd_ptr]+1
    001362  aa  1 00016 5541 00    976  	stc1	ab|in_pl1_code
    001363  aa   000060 6270 00    977  	push
    001364  aa  7 00040 2721 20
    001365  aa   777741 3500 04    978  	eppap	null_arg_list-*,ic
    001366  4a  4 00040 3521 20    979  	short_call	<lisp_error_>|[lisp_error_]
    001367  aa  7 00036 6701 20
    001370  aa  6 00030 3701 20
    001371  aa  6 00020 6351 20    980  	eaa	sp|16,*		back up stack
    001372  aa  7 00024 6521 00    981  	sprisp	sb|stack_header.stack_end_ptr
    001373  aa  7 00000 3721 01    982  	eppsp	sb|0,au
    001374  4a  4 00014 3511 20    983  	epbpab	<lisp_static_vars_>|[unmkd_ptr],*
    001375  4a  4 00012 2271 20    984  	ldx7	<lisp_static_vars_>|[unmkd_ptr]+1
    001376  4a  4 00020 3501 20    985  	eppap	<lisp_static_vars_>|[stack_ptr],*
    001377  aa  1 00016 4501 00    986  	stz	ab|in_pl1_code
    001400  aa  1 77776 2241 17    987  	ldx4	ab|-2,x7		reload return address
    001401  aa  1 77777 2261 17    988  	ldx6	ab|-1,x7		and x6 for caller.
    001402  aa  1 77777 7251 17    989  	lxl5	ab|-1,x7	also x5 for lsubrs.
    001403  aa   777776 6270 17    990  	eax7	-2,x7
    001404  aa  0 77776 2371 00    991  	ldaq	ap|-2		reload new value
    001405  aa  0 77776 3501 00    992  	eppap	ap|-2		and reset stack.
    001406  aa   000000 7100 14    993  	tra	0,x4		return to caller.
                                   994  
    001407  aa   000000 0110 03    995  	even
    001410                         996  random_init:
    001410  aa   267762 113337     997  	oct	267762113337,155256071112
    001411  aa   155256 071112 
                                   998  				"This is the initial value for the random number generator.
                        001412     999  	segdef	random		Lisp lsubr to return a random number.
                                  1000  				"With no args it returns a random number, with an arg it resets to inital value.
    001412  aa   000000 1050 03   1001  random:	cmpx5	0,du		See if there are any args (x5 contains -2*number_of_args).
    001413  aa   000016 6000 04   1002  	tze	random0-*,ic	If none, go to return a random number.
    001414  aa  0 00000 2371 15   1003  	ldaq	ap|0,x5		get argument.
    001415                        1004  chk_random:
    001415  aa  1 00012 1171 00   1005  	cmpaq	ab|nil
    001416  0a   001424 6000 00   1006  	tze	init_random	if nil, restart sequence
    001417  aa   040047 1150 07   1007  	cmpa	fixnum_type,dl	see if fixnum
    001420  0a   001441 6000 00   1008  	tze	random_bounded
    001421                        1009  random_tsx4:
    001421  0a   001332 7040 00   1010  	tsx4	bad_arg
    001422  aa  0 00000 7571 15   1011  	staq	ap|0,x5			store new val away.
    001423  0a   001415 7100 00   1012  	tra	chk_random
    001424                        1013  init_random:
    001424  0a   001410 2370 00   1014  	ldaq	random_init	get the initial value.
    001425  4a  4 00042 7571 20   1015  	staq	<lisp_static_vars_>|[hi_random]
                                  1016  				"And then store it.
    001426  aa  0 77776 2371 00   1017  	ldaq	ap|-2		Get the argument, to return it.
    001427  aa  0 00000 3501 15   1018  	eppap	ap|0,x5		Pop off the arg(s) from the marked pdl.
    001430  aa   776364 7100 04   1019  	tra	retrn1-*,ic	And go to the common return sequence.
    001431  0a   000014 6200 00   1020  random0:	eax0	retrn1		set return operator.
    001432  4a  4 00042 2371 20   1021  random1:	ldaq	<lisp_static_vars_>|[hi_random]
                                  1022  				"First load the aq with two numbers, H(q) and L(q).
    001433  4a  4 00044 7551 20   1023  	sta	<lisp_static_vars_>|[lo_random]
                                  1024  				"The next state for the low part, L(q+1), is just the high part, H(q).
    001434  aa   000001 7730 00   1025  	lrl	1		Now right shift everthing in the aq one cell.
    001435  4a  4 00044 6761 20   1026  	erq	<lisp_static_vars_>|[lo_random]
                                  1027  				"Do an exclusive or between H(q) and L(q) that has been right-shifted.
    001436  4a  4 00042 7561 20   1028  	stq	<lisp_static_vars_>|[hi_random]
                                  1029  				"And this becomes the high part.
                                  1030  				"Or H(q+1) = H(q) +O ((2**36)*H(q) + L(q))/2
    001437  aa   040047 2350 07   1031  	lda	fixnum_type,dl	We will return H(q+1) as a number.
    001440  aa   000000 7100 10   1032  	tra	0,x0		return to caller.
                                  1033  
    001441                        1034  random_bounded:
    001441  aa  0 00001 2351 15   1035  	lda	ap|1,x5		load argument.
    001442  aa   000002 1150 07   1036  	cmpa	2,dl
    001443  0a   001455 6040 00   1037  	tmi	ret_zero		if arg < 2 then always return zero.
    001444  0a   001432 7000 00   1038  	tsx0	random1
    001445  aa   000000 1160 07   1039  	cmpq	0,dl		check for negative result.
    001446  aa   000002 6050 04   1040  	tpl	2,ic
    001447  aa   000000 5330 00   1041  	negl	0		negate q...note that a cannot be 4000000000..
    001450  aa  0 00001 5061 15   1042  	div	ap|1,x5		divide by the argument.
    001451  aa   000044 7730 00   1043  	lrl	36		shift remainder to q
    001452  aa   040047 2350 07   1044  	lda	fixnum_type,dl
    001453  aa  0 00000 3501 15   1045  	eppap	ap|0,x5		pop stack
    001454  0a   000014 7100 00   1046  	tra	retrn1
    001455  0a   000000 2370 00   1047  ret_zero:	ldaq	fixnum_zero
    001456  aa  0 00000 3501 15   1048  	eppap	ap|0,x5
    001457  0a   000014 7100 00   1049  	tra	retrn1
                                  1050  
                                  1051  "
                                  1052  
                                  1053  " table of tsx4 addresses (du) and corresponding function name codes (dl)
                                  1054  
    001460  0a   001154 777750    1055  	zero	rplaca_tsx4+1,fn_rplaca
    001461  0a   001253 777746    1056  	zero	setq_tsx4+1,fn_setq
    001462  0a   001301 777745    1057  	zero	set_tsx4+1,fn_set
    001463  0a   000155 777627    1058  	zero	oddp_tsx4+1,fn_oddp
    001464  0a   001422 777556    1059  	zero	random_tsx4+1,fn_random
    001465  0a   000471 777615    1060  	zero	getch_tsx4+1,fn_getchar
    001466  0a   000477 777615    1061  	zero	getch_tsx4_2+1,fn_getchar
    001467  0a   000131 777546    1062  	zero	zerop_tsx4+1,fn_zerop
    001470  0a   001175 777516    1063  	zero	displace_tsx4+1,fn_displace
    001471                        1064  name_tbl:
                        000011    1065  	equ	name_tbl_len,9
                                  1066  
                                  1067  	end

NO LITERALS
     
NAME DEFINITIONS FOR ENTRY POINTS AND SEGDEFS

    001472  5a   000003 000000 
    001473  5a   000364 600000 
    001474  aa   000000 000000 
    001475  55   000013 000002 
    001476  5a   000002 400003 
    001477  55   000006 000013 
    001500  aa  020 154 151 163
    001501  aa  160 137 161 165
    001502  aa  151 143 153 137
    001503  aa  146 143 156 163
    001504  aa  137 000 000 000
    001505  55   000020 000003 
    001506  0a   001412 400000 
    001507  55   000016 000003 
    001510  aa  006 162 141 156         random
    001511  aa  144 157 155 000
    001512  55   000024 000013 
    001513  0a   001275 400000 
    001514  55   000023 000003 
    001515  aa  003 163 145 164         set
    001516  55   000031 000020 
    001517  0a   001240 400000 
    001520  55   000027 000003 
    001521  aa  004 163 145 164         setq
    001522  aa  161 000 000 000
    001523  55   000037 000024 
    001524  0a   001171 400000 
    001525  55   000034 000003 
    001526  aa  010 144 151 163         displace
    001527  aa  160 154 141 143
    001530  aa  145 000 000 000
    001531  55   000044 000031 
    001532  0a   001163 400000 
    001533  55   000042 000003 
    001534  aa  006 162 160 154         rplacd
    001535  aa  141 143 144 000
    001536  55   000051 000037 
    001537  0a   001150 400000 
    001540  55   000047 000003 
    001541  aa  006 162 160 154         rplaca
    001542  aa  141 143 141 000
    001543  55   000056 000044 
    001544  0a   001120 400000 
    001545  55   000054 000003 
    001546  aa  004 144 145 154         delq
    001547  aa  161 000 000 000
    001550  55   000063 000051 
    001551  0a   001030 400000 
    001552  55   000061 000003 
    001553  aa  006 144 145 154         delete
    001554  aa  145 164 145 000
    001555  55   000070 000056 
    001556  0a   000765 400000 
    001557  55   000066 000003 
    001560  aa  004 141 163 163         assq
    001561  aa  161 000 000 000
    001562  55   000075 000063 
    001563  0a   000763 400000 
    001564  55   000073 000003 
    001565  aa  005 163 141 163         sassq
    001566  aa  163 161 000 000
    001567  55   000102 000070 
    001570  0a   000727 400000 
    001571  55   000100 000003 
    001572  aa  005 141 163 163         assoc
    001573  aa  157 143 000 000
    001574  55   000107 000075 
    001575  0a   000725 400000 
    001576  55   000105 000003 
    001577  aa  006 163 141 163         sassoc
    001600  aa  163 157 143 000
    001601  55   000114 000102 
    001602  0a   000704 400000 
    001603  55   000112 000003 
    001604  aa  004 155 145 155         memq
    001605  aa  161 000 000 000
    001606  55   000121 000107 
    001607  0a   000660 400000 
    001610  55   000117 000003 
    001611  aa  006 155 145 155         member
    001612  aa  142 145 162 000
    001613  55   000126 000114 
    001614  0a   000610 400000 
    001615  55   000124 000003 
    001616  aa  004 143 157 156         cond
    001617  aa  144 000 000 000
    001620  55   000132 000121 
    001621  0a   000566 400000 
    001622  55   000131 000003 
    001623  aa  002 157 162 000         or
    001624  55   000136 000126 
    001625  0a   000543 400000 
    001626  55   000135 000003 
    001627  aa  003 141 156 144         and
    001630  55   000143 000132 
    001631  0a   000540 400000 
    001632  55   000141 000003 
    001633  aa  005 160 162 157         progn
    001634  aa  147 156 000 000
    001635  55   000150 000136 
    001636  0a   000535 400000 
    001637  55   000146 000003 
    001640  aa  005 160 162 157         prog2
    001641  aa  147 062 000 000
    001642  55   000155 000143 
    001643  0a   000532 400000 
    001644  55   000153 000003 
    001645  aa  005 160 162 157         prog1
    001646  aa  147 061 000 000
    001647  55   000162 000150 
    001650  0a   000464 400000 
    001651  55   000160 000003 
    001652  aa  007 147 145 164         getchar
    001653  aa  143 150 141 162
    001654  55   000170 000155 
    001655  0a   000463 400000 
    001656  55   000165 000003 
    001657  aa  010 147 145 164         getcharn
    001660  aa  143 150 141 162
    001661  aa  156 000 000 000
    001662  55   000176 000162 
    001663  0a   000374 400000 
    001664  55   000173 000003 
    001665  aa  012 163 141 155         samepnamep
    001666  aa  145 160 156 141
    001667  aa  155 145 160 000
    001670  55   000204 000170 
    001671  0a   000370 400000 
    001672  55   000201 000003 
    001673  aa  012 141 154 160         alphalessp
    001674  aa  150 141 154 145
    001675  aa  163 163 160 000
    001676  55   000211 000176 
    001677  0a   000264 400000 
    001700  55   000207 000003 
    001701  aa  005 145 161 165         equal
    001702  aa  141 154 000 000
    001703  55   000216 000204 
    001704  0a   000252 400000 
    001705  55   000214 000003 
    001706  aa  004 154 141 163         last
    001707  aa  164 000 000 000
    001710  55   000223 000211 
    001711  0a   000236 400000 
    001712  55   000221 000003 
    001713  aa  006 154 145 156         length
    001714  aa  147 164 150 000
    001715  55   000230 000216 
    001716  0a   000233 400000 
    001717  55   000226 000003 
    001720  aa  007 144 145 143         declare
    001721  aa  154 141 162 145
    001722  55   000235 000223 
    001723  0a   000230 400000 
    001724  55   000233 000003 
    001725  aa  007 143 157 155         comment
    001726  aa  155 145 156 164
    001727  55   000242 000230 
    001730  0a   000171 400000 
    001731  55   000240 000003 
    001732  aa  007 162 165 156         runtime
    001733  aa  164 151 155 145
    001734  55   000247 000235 
    001735  0a   000141 400000 
    001736  55   000245 000003 
    001737  aa  004 157 144 144         oddp
    001740  aa  160 000 000 000
    001741  55   000254 000242 
    001742  0a   000124 400000 
    001743  55   000252 000003 
    001744  aa  005 172 145 162         zerop
    001745  aa  157 160 000 000
    001746  55   000261 000247 
    001747  0a   000117 400000 
    001750  55   000257 000003 
    001751  aa  005 146 151 154         filep
    001752  aa  145 160 000 000
    001753  55   000266 000254 
    001754  0a   000112 400000 
    001755  55   000264 000003 
    001756  aa  006 141 162 162         arrayp
    001757  aa  141 171 160 000
    001760  55   000273 000261 
    001761  0a   000105 400000 
    001762  55   000271 000003 
    001763  aa  007 163 171 155         symbolp
    001764  aa  142 157 154 160
    001765  55   000300 000266 
    001766  0a   000100 400000 
    001767  55   000276 000003 
    001770  aa  005 163 165 142         subrp
    001771  aa  162 160 000 000
    001772  55   000305 000273 
    001773  0a   000073 400000 
    001774  55   000303 000003 
    001775  aa  007 163 164 162         stringp
    001776  aa  151 156 147 160
    001777  55   000312 000300 
    002000  0a   000066 400000 
    002001  55   000310 000003 
    002002  aa  006 146 154 157         floatp
    002003  aa  141 164 160 000
    002004  55   000317 000305 
    002005  0a   000061 400000 
    002006  55   000315 000003 
    002007  aa  004 142 151 147         bigp
    002010  aa  160 000 000 000
    002011  55   000325 000312 
    002012  0a   000054 400000 
    002013  55   000322 000003 
    002014  aa  011 163 155 141         smallnump
    002015  aa  154 154 156 165
    002016  aa  155 160 000 000
    002017  55   000332 000317 
    002020  0a   000047 400000 
    002021  55   000330 000003 
    002022  aa  004 146 151 170         fixp
    002023  aa  160 000 000 000
    002024  55   000337 000325 
    002025  0a   000042 400000 
    002026  55   000335 000003 
    002027  aa  007 156 165 155         numberp
    002030  aa  142 145 162 160
    002031  55   000344 000332 
    002032  0a   000035 400000 
    002033  55   000342 000003 
    002034  aa  004 141 164 157         atom
    002035  aa  155 000 000 000
    002036  55   000350 000337 
    002037  0a   000030 400000 
    002040  55   000347 000003 
    002041  aa  002 145 161 000         eq
    002042  55   000355 000344 
    002043  0a   000020 400000 
    002044  55   000353 000003 
    002045  aa  004 156 165 154         null
    002046  aa  154 000 000 000
    002047  55   000002 000350 
    002050  6a   000000 400002 
    002051  55   000360 000003 
    002052  aa  014 163 171 155         symbol_table
    002053  aa  142 157 154 137
    002054  aa  164 141 142 154
    002055  aa  145 000 000 000

DEFINITIONS HASH TABLE

    002056  aa   000000 000131 
    002057  aa   000000 000000 
    002060  aa   000000 000000 
    002061  5a   000332 000000 
    002062  5a   000031 000000 
    002063  5a   000344 000000 
    002064  5a   000355 000000 
    002065  aa   000000 000000 
    002066  5a   000211 000000 
    002067  aa   000000 000000 
    002070  aa   000000 000000 
    002071  aa   000000 000000 
    002072  aa   000000 000000 
    002073  aa   000000 000000 
    002074  aa   000000 000000 
    002075  aa   000000 000000 
    002076  5a   000024 000000 
    002077  5a   000075 000000 
    002100  5a   000114 000000 
    002101  5a   000126 000000 
    002102  aa   000000 000000 
    002103  5a   000056 000000 
    002104  5a   000170 000000 
    002105  5a   000266 000000 
    002106  aa   000000 000000 
    002107  aa   000000 000000 
    002110  aa   000000 000000 
    002111  aa   000000 000000 
    002112  aa   000000 000000 
    002113  aa   000000 000000 
    002114  aa   000000 000000 
    002115  aa   000000 000000 
    002116  5a   000162 000000 
    002117  aa   000000 000000 
    002120  5a   000013 000000 
    002121  5a   000273 000000 
    002122  aa   000000 000000 
    002123  5a   000305 000000 
    002124  aa   000000 000000 
    002125  aa   000000 000000 
    002126  5a   000204 000000 
    002127  aa   000000 000000 
    002130  5a   000107 000000 
    002131  aa   000000 000000 
    002132  5a   000223 000000 
    002133  5a   000242 000000 
    002134  5a   000051 000000 
    002135  5a   000070 000000 
    002136  5a   000132 000000 
    002137  5a   000300 000000 
    002140  5a   000325 000000 
    002141  5a   000337 000000 
    002142  5a   000247 000000 
    002143  5a   000312 000000 
    002144  aa   000000 000000 
    002145  aa   000000 000000 
    002146  5a   000121 000000 
    002147  aa   000000 000000 
    002150  5a   000037 000000 
    002151  5a   000044 000000 
    002152  5a   000176 000000 
    002153  aa   000000 000000 
    002154  5a   000230 000000 
    002155  aa   000000 000000 
    002156  aa   000000 000000 
    002157  aa   000000 000000 
    002160  aa   000000 000000 
    002161  aa   000000 000000 
    002162  5a   000216 000000 
    002163  5a   000254 000000 
    002164  5a   000261 000000 
    002165  5a   000235 000000 
    002166  5a   000317 000000 
    002167  5a   000020 000000 
    002170  5a   000063 000000 
    002171  aa   000000 000000 
    002172  aa   000000 000000 
    002173  aa   000000 000000 
    002174  5a   000102 000000 
    002175  aa   000000 000000 
    002176  aa   000000 000000 
    002177  aa   000000 000000 
    002200  aa   000000 000000 
    002201  aa   000000 000000 
    002202  5a   000350 000000 
    002203  5a   000136 000000 
    002204  5a   000143 000000 
    002205  5a   000150 000000 
    002206  aa   000000 000000 
    002207  5a   000155 000000 

EXTERNAL NAMES

    002210  aa  011 154 157 137         lo_random
    002211  aa  162 141 156 144
    002212  aa  157 155 000 000
    002213  aa  011 150 151 137         hi_random
    002214  aa  162 141 156 144
    002215  aa  157 155 000 000
    002216  aa  013 154 151 163         lisp_error_
    002217  aa  160 137 145 162
    002220  aa  162 157 162 137
    002221  aa  006 156 143 157         ncons_
    002222  aa  156 163 137 000
    002223  aa  013 154 151 163         lisp_alloc_
    002224  aa  160 137 141 154
    002225  aa  154 157 143 137
    002226  aa  012 160 162 157         progn_atom
    002227  aa  147 156 137 141
    002230  aa  164 157 155 000
    002231  aa  006 141 160 160         apply_
    002232  aa  154 171 137 000
    002233  aa  005 145 166 141         eval_
    002234  aa  154 137 000 000
    002235  aa  005 154 151 163         lisp_
    002236  aa  160 137 000 000
    002237  aa  011 141 163 143         ascii_alm
    002240  aa  151 151 137 141
    002241  aa  154 155 000 000
    002242  aa  020 154 151 163         lisp_reader_alm_
    002243  aa  160 137 162 145
    002244  aa  141 144 145 162
    002245  aa  137 141 154 155
    002246  aa  137 000 000 000
    002247  aa  014 144 145 143         declare_atom
    002250  aa  154 141 162 145
    002251  aa  137 141 164 157
    002252  aa  155 000 000 000
    002253  aa  014 143 157 155         comment_atom
    002254  aa  155 145 156 164
    002255  aa  137 141 164 157
    002256  aa  155 000 000 000
    002257  aa  021 166 151 162         virtual_cpu_time_
    002260  aa  164 165 141 154
    002261  aa  137 143 160 165
    002262  aa  137 164 151 155
    002263  aa  145 137 000 000
    002264  aa  004 150 143 163         hcs_
    002265  aa  137 000 000 000
    002266  aa  011 165 156 155         unmkd_ptr
    002267  aa  153 144 137 160
    002270  aa  164 162 000 000
    002271  aa  011 163 164 141         stack_ptr
    002272  aa  143 153 137 160
    002273  aa  164 162 000 000
    002274  aa  021 154 151 163         lisp_static_vars_
    002275  aa  160 137 163 164
    002276  aa  141 164 151 143
    002277  aa  137 166 141 162
    002300  aa  163 137 000 000

NO TRAP POINTER WORDS

TYPE PAIR BLOCKS

    002301  aa   000004 000000 
    002302  55   000602 000516 
    002303  aa   000004 000000 
    002304  55   000602 000521 
    002305  aa   000004 000000 
    002306  55   000524 000524 
    002307  aa   000004 000000 
    002310  55   000531 000527 
    002311  aa   000004 000000 
    002312  55   000602 000534 
    002313  aa   000004 000000 
    002314  55   000543 000537 
    002315  aa   000004 000000 
    002316  55   000543 000541 
    002317  aa   000004 000000 
    002320  55   000550 000545 
    002321  aa   000004 000000 
    002322  55   000602 000555 
    002323  aa   000004 000000 
    002324  55   000602 000561 
    002325  aa   000004 000000 
    002326  55   000572 000565 
    002327  aa   000004 000000 
    002330  55   000602 000574 
    002331  aa   000004 000000 
    002332  55   000602 000577 
    002333  aa   000001 000000 
    002334  aa   000000 000000 

INTERNAL EXPRESSION WORDS

    002335  5a   000607 000000 
    002336  5a   000611 000000 
    002337  5a   000613 000000 
    002340  5a   000615 000000 
    002341  5a   000617 000000 
    002342  5a   000621 000000 
    002343  5a   000623 000000 
    002344  5a   000625 000000 
    002345  5a   000627 000000 
    002346  5a   000631 000000 
    002347  5a   000633 000000 
    002350  5a   000635 000000 
    002351  5a   000635 000001 
    002352  5a   000637 000000 
    002353  aa   000000 000000 
LINKAGE INFORMATION
      
    000000  aa   000000 000000 
    000001  0a   001472 000000 
    000002  aa   000000 000000 
    000003  aa   000000 000000 
    000004  aa   000000 000000 
    000005  aa   000000 000000 
    000006  22   000010 000046 
    000007  a2   000000 000000 
    000010  9a   777770 0000 46         lisp_static_vars_|stack_ptr
    000011  5a   000660 0000 00
    000012  9a   777766 0000 46         lisp_static_vars_|unmkd_ptr
    000013  5a   000657 0000 00
    000014  9a   777764 0000 46         lisp_static_vars_|unmkd_ptr
    000015  5a   000656 0000 20
    000016  9a   777762 0000 46         hcs_|virtual_cpu_time_
    000017  5a   000655 0000 00
    000020  9a   777760 0000 46         lisp_static_vars_|stack_ptr
    000021  5a   000660 0000 20
    000022  9a   777756 0000 46         lisp_static_vars_|comment_atom
    000023  5a   000654 0000 00
    000024  9a   777754 0000 46         lisp_static_vars_|declare_atom
    000025  5a   000653 0000 00
    000026  9a   777752 0000 46         lisp_reader_alm_|ascii_alm
    000027  5a   000652 0000 00
    000030  9a   777750 0000 46         lisp_|eval_
    000031  5a   000651 0000 00
    000032  9a   777746 0000 46         lisp_|apply_
    000033  5a   000650 0000 00
    000034  9a   777744 0000 46         lisp_static_vars_|progn_atom
    000035  5a   000647 0000 00
    000036  9a   777742 0000 46         lisp_alloc_|ncons_
    000037  5a   000646 0000 00
    000040  9a   777740 0000 46         lisp_error_|lisp_error_
    000041  5a   000645 0000 00
    000042  9a   777736 0000 46         lisp_static_vars_|hi_random
    000043  5a   000644 0000 00
    000044  9a   777734 0000 46         lisp_static_vars_|lo_random
    000045  5a   000643 0000 00
SYMBOL INFORMATION
     
SYMBOL TABLE HEADER
     
    000000  aa   000000 000001 
    000001  aa   163171 155142 
    000002  aa   164162 145145 
    000003  aa   000000 000004 
    000004  aa   000000 114732 
    000005  aa   732732 062314 
    000006  aa   000000 114775 
    000007  aa   677274 667071 
    000010  aa   141154 155040 
    000011  aa   040040 040040 
    000012  aa   000024 000040 
    000013  aa   000034 000040 
    000014  aa   000044 000100 
    000015  aa   000002 000002 
    000016  aa   000064 000000 
    000017  aa   000000 000337 
    000020  aa   000000 000221 
    000021  aa   000000 000314 
    000022  aa   000324 000221 
    000023  aa   000064 000000 
    000024  aa   101114 115040 
    000025  aa   126145 162163 
    000026  aa   151157 156040 
    000027  aa   040066 056067 
    000030  aa   040040 117143 
    000031  aa   164157 142145 
    000032  aa   162040 061071 
    000033  aa   070066 040040 
    000034  aa   107112 157150 
    000035  aa   156163 157156 
    000036  aa   056123 171163 
    000037  aa   115141 151156 
    000040  aa   164056 141040 
    000041  aa   040040 040040 
    000042  aa   040040 040040 
    000043  aa   040040 040040 
    000044  aa   154151 163164 
    000045  aa   040040 040040 
    000046  aa   040040 040040 
    000047  aa   040040 040040 
    000050  aa   040040 040040 
    000051  aa   040040 040040 
    000052  aa   040040 040040 
    000053  aa   040040 040040 
    000054  aa   040040 040040 
    000055  aa   040040 040040 
    000056  aa   040040 040040 
    000057  aa   040040 040040 
    000060  aa   040040 040040 
    000061  aa   040040 040040 
    000062  aa   040040 040040 
    000063  aa   040040 040040 
    000064  aa   000000 000001 
    000065  aa   000000 000006 
    000066  aa   000116 000065 
    000067  aa   147740 446313 
    000070  aa   000000 114774 
    000071  aa   461260 200000 
    000072  aa   000134 000066 
    000073  aa   147714 750316 
    000074  aa   000000 114774 
    000075  aa   453561 000000 
    000076  aa   000152 000047 
    000077  aa   106701 741731 
    000100  aa   000000 110670 
    000101  aa   211444 000000 
    000102  aa   000164 000044 
    000103  aa   120017 346605 
    000104  aa   000000 112002 
    000105  aa   404115 200000 
    000106  aa   000175 000046 
    000107  aa   106701 741746 
    000110  aa   000000 110670 
    000111  aa   211450 600000 
    000112  aa   000207 000045 
    000113  aa   120017 346602 
    000114  aa   000000 112002 
    000115  aa   404115 000000 
    000116  aa   076163 160145          >special_ldd>install>MR12.0-1206>lisp_quick_fcns_.alm
    000117  aa   143151 141154 
    000120  aa   137154 144144 
    000121  aa   076151 156163 
    000122  aa   164141 154154 
    000123  aa   076115 122061 
    000124  aa   062056 060055 
    000125  aa   061062 060066 
    000126  aa   076154 151163 
    000127  aa   160137 161165 
    000130  aa   151143 153137 
    000131  aa   146143 156163 
    000132  aa   137056 141154 
    000133  aa   155040 040040 
    000134  aa   076163 160145          >special_ldd>install>MR12.0-1206>stack_header.incl.alm
    000135  aa   143151 141154 
    000136  aa   137154 144144 
    000137  aa   076151 156163 
    000140  aa   164141 154154 
    000141  aa   076115 122061 
    000142  aa   062056 060055 
    000143  aa   061062 060066 
    000144  aa   076163 164141 
    000145  aa   143153 137150 
    000146  aa   145141 144145 
    000147  aa   162056 151156 
    000150  aa   143154 056141 
    000151  aa   154155 040040 
    000152  aa   076154 144144          >ldd>include>lisp_object_types.incl.alm
    000153  aa   076151 156143 
    000154  aa   154165 144145 
    000155  aa   076154 151163 
    000156  aa   160137 157142 
    000157  aa   152145 143164 
    000160  aa   137164 171160 
    000161  aa   145163 056151 
    000162  aa   156143 154056 
    000163  aa   141154 155040 
    000164  aa   076154 144144          >ldd>include>lisp_stack_seg.incl.alm
    000165  aa   076151 156143 
    000166  aa   154165 144145 
    000167  aa   076154 151163 
    000170  aa   160137 163164 
    000171  aa   141143 153137 
    000172  aa   163145 147056 
    000173  aa   151156 143154 
    000174  aa   056141 154155 
    000175  aa   076154 144144          >ldd>include>lisp_error_codes.incl.alm
    000176  aa   076151 156143 
    000177  aa   154165 144145 
    000200  aa   076154 151163 
    000201  aa   160137 145162 
    000202  aa   162157 162137 
    000203  aa   143157 144145 
    000204  aa   163056 151156 
    000205  aa   143154 056141 
    000206  aa   154155 040040 
    000207  aa   076154 144144          >ldd>include>lisp_name_codes.incl.alm
    000210  aa   076151 156143 
    000211  aa   154165 144145 
    000212  aa   076154 151163 
    000213  aa   160137 156141 
    000214  aa   155145 137143 
    000215  aa   157144 145163 
    000216  aa   056151 156143 
    000217  aa   154056 141154 
    000220  aa   155040 040040 
               MULTICS ASSEMBLY CROSS REFERENCE LISTING

   Value        Symbol                   Source file   Line number

         370    alphalessp               lisp_quick_fcns_:   355,  356,  428.
         543    and                      lisp_quick_fcns_:   506,  507.
         564    and_done                 lisp_quick_fcns_:   510,  524,  531,  545.
         544    and_loop                 lisp_quick_fcns_:   508,  523.
         102    append_list_op           lisp_stack_seg:      43.
                apply_                   lisp_quick_fcns_:   711.
          50    arg                      lisp_quick_fcns_:    13,  201,  203,  204.
         250    argument_must_be_array   lisp_error_codes:    72.
         200    Array                    lisp_quick_fcns_:   133,
                                         lisp_object_types:   25.
         112    arrayp                   lisp_quick_fcns_:   130,  131.
         166    array_bound_error        lisp_error_codes:    26.
         122    array_info_for_store     lisp_stack_seg:      51.
         126    array_link_snap_opr      lisp_stack_seg:      53.
         124    array_offset_for_store   lisp_stack_seg:      52.
         112    array_operator           lisp_stack_seg:      47.
          10    array_pointer            lisp_stack_seg:      10.
         247    array_too_big            lisp_error_codes:    71.
                ascii_alm                lisp_quick_fcns_:   479.
         727    assoc                    lisp_quick_fcns_:   638,  639.
         730    assoc1                   lisp_quick_fcns_:   636,  640.
         765    assq                     lisp_quick_fcns_:   673,  674.
         766    assq1                    lisp_quick_fcns_:   642,  672,  675.
        1007    assq_done                lisp_quick_fcns_:   659,  688,  692.
         772    assq_lp                  lisp_quick_fcns_:   679,  691.
        1010    assq_ret                 lisp_quick_fcns_:   693,  698.
         737    ass_lp                   lisp_quick_fcns_:   647,  665.
         216    atan_0_0_err             lisp_error_codes:    46.
          35    atom                     lisp_quick_fcns_:    67,   68.
       77700    Atomic                   lisp_quick_fcns_:    70,  245,  259,  279,  304,  509,  530,  553,  573,  598,  617,
                                                             647,  650,  679,  683,  726,  748,  783,  800,  822,  830,  876,
                                         lisp_object_types:   19.
       10000    Atsym                    lisp_quick_fcns_:   126,  281,  379,  387,  444,  462,  593,  641,  715,  881,  907,
                                         lisp_object_types:   18.
         163    badmacro                 lisp_error_codes:    23.
         215    badobarray               lisp_error_codes:    45.
         165    badreadlist              lisp_error_codes:    25.
         214    badreadtable             lisp_error_codes:    44.
        1332    bad_arg                  lisp_quick_fcns_:   150,  174,  446,  455,  803,  825,  866,  884,  910,  942, 1010.
         151    bad_argument             lisp_error_codes:    13.
         170    bad_arg_correctable      lisp_quick_fcns_:   972,
                                         lisp_error_codes:    28.
         241    bad_array_subscript      lisp_error_codes:    65.
         175    bad_base                 lisp_error_codes:    33.
         154    bad_bv                   lisp_error_codes:    16.
         232    bad_do_format            lisp_error_codes:    58.
         231    bad_entry_name           lisp_error_codes:    57.
         153    bad_function             lisp_error_codes:    15.
         206    bad_f_fcn                lisp_error_codes:    38.
         174    bad_ibase                lisp_error_codes:    32.
         176    bad_input_source         lisp_error_codes:    34.
         177    bad_output_dest          lisp_error_codes:    35.
         171    bad_prog_op              lisp_error_codes:    29.
         450    bad_string               lisp_quick_fcns_:   381,  389,  422.
         100    begin_list_op            lisp_stack_seg:      42.
         174    begin_unmkd_stack        lisp_stack_seg:      66.
        1000    Bignum                   lisp_object_types:   20.
         337    bignum_eql               lisp_quick_fcns_:   284,  320.
          61    bigp                     lisp_quick_fcns_:    95,   96.
        1000    Big_fixed                lisp_quick_fcns_:    84,   98,  146,  162,  283,  322,
                                         lisp_object_types:   29.
          20    bind_op                  lisp_stack_seg:      17.
        1170    call_offset              stack_header:        80.
          32    call_op                  lisp_stack_seg:      22.
         222    cant_filepos             lisp_error_codes:    50.
         244    cant_subscript_readtable       lisp_error_codes:    68.
         167    car_cdr_error            lisp_error_codes:    27.
          34    catch1_op                lisp_stack_seg:      23.
          36    catch2_op                lisp_stack_seg:      24.
        1230    chk_count                lisp_quick_fcns_:   861,  867.
        1250    chk_name                 lisp_quick_fcns_:   881,  885.
        1415    chk_random               lisp_quick_fcns_:  1004, 1012.
         230    comment                  lisp_quick_fcns_:   229,  230.
                comment_atom             lisp_quick_fcns_:   230.
         106    compare_op               lisp_stack_seg:      45.
         610    cond                     lisp_quick_fcns_:   548,  549.
         655    cond_done                lisp_quick_fcns_:   554,  574,  586.
         636    cond_ev                  lisp_quick_fcns_:   571,  585.
         613    cond_loop                lisp_quick_fcns_:   552,  570.
          72    cons_op                  lisp_stack_seg:      39.
         136    cons_string_op           lisp_stack_seg:      57.
         132    create_array_desc_op     lisp_stack_seg:      55.
         130    create_string_desc_op    lisp_stack_seg:      54.
         140    create_varying_string_op       lisp_stack_seg:      58.
         114    dead_array_operator      lisp_stack_seg:      48.
         243    dead_array_reference     lisp_error_codes:    67.
         233    declare                  lisp_quick_fcns_:   234,  235.
                declare_atom             lisp_quick_fcns_:   235.
        1030    delete                   lisp_quick_fcns_:   713,  714.
        1120    delq                     lisp_quick_fcns_:   716,  771,  772.
        1066    del_loop                 lisp_quick_fcns_:   744,  763.
        1070    del_loop1                lisp_quick_fcns_:   746,  766.
        1171    displace                 lisp_quick_fcns_:   820,  821,  827.
        1212    displace_atom            lisp_quick_fcns_:   831,  841.
        1177    displace_ok              lisp_quick_fcns_:   823,  828.
        1174    displace_tsx4            lisp_quick_fcns_:   824, 1063.
         220    division_by_zero         lisp_error_codes:    48.
        1127    dloop                    lisp_quick_fcns_:   780,  791.
        1131    dloop1                   lisp_quick_fcns_:   782,  793.
         161    doterror                 lisp_error_codes:    21.
        1145    dq_end                   lisp_quick_fcns_:   781,  784,  794.
        1064    end_head                 lisp_quick_fcns_:   735,  742.
        1174    entry_offset             stack_header:        84.
         221    eof_in_object            lisp_error_codes:    49.
          30    eq                       lisp_quick_fcns_:    60,   61.
         267    eql_lp                   lisp_quick_fcns_:   276,  318,  347.
         264    equal                    lisp_quick_fcns_:   271,  272,  605,  657,  732,  754.
          24    errset1_op               lisp_stack_seg:      19.
          26    errset2_op               lisp_stack_seg:      20.
          64    err_op                   lisp_stack_seg:      36.
                eval_                    lisp_quick_fcns_:   521,  542,  566,  582,  899.
         100    File                     lisp_quick_fcns_:   140,
                                         lisp_object_types:   30.
         117    filep                    lisp_quick_fcns_:   137,  138.
         223    filepos_oob              lisp_error_codes:    51.
         227    file_is_closed           lisp_error_codes:    55.
         150    file_system_error        lisp_error_codes:    12.
         224    file_sys_fun_err         lisp_error_codes:    52.
       40000    Fixed                    lisp_quick_fcns_:    84,  146,  281,  593,  641,  715,
                                         lisp_object_types:   15.
       40047    fixnum_type              lisp_quick_fcns_:    22,   91,  170,  215,  452,  861, 1007, 1031, 1044,
                                         lisp_object_types:   34.
           0    fixnum_zero              lisp_quick_fcns_:    21,  154,  240,  485, 1047.
          47    fixp                     lisp_quick_fcns_:    81,   82.
       20000    Float                    lisp_quick_fcns_:   146,  281,  593,  641,  715,
                                         lisp_object_types:   16.
         120    floating_store_operator  lisp_stack_seg:      50.
          66    floatp                   lisp_quick_fcns_:   102,  103.
           4    float_q                  lisp_quick_fcns_:    28.
         212    flonum_too_big           lisp_error_codes:    42.
       20047    flonum_type              lisp_quick_fcns_:    25,  105,
                                         lisp_object_types:   35.
           2    flonum_zero              lisp_quick_fcns_:    24,  156.
      777707    fn_abs                   lisp_name_codes:     53.
      777720    fn_add1                  lisp_name_codes:     44.
      777674    fn_add1_fix              lisp_name_codes:     64.
      777673    fn_add1_flo              lisp_name_codes:     65.
      777625    fn_alarmclock            lisp_name_codes:    103.
      777611    fn_allfiles              lisp_name_codes:    115.
      777617    fn_alphalessp            lisp_quick_fcns_:   430,
                                         lisp_name_codes:    109.
      777657    fn_apply                 lisp_name_codes:     77.
      777765    fn_arg                   lisp_name_codes:     10.
      777727    fn_args                  lisp_name_codes:     37.
      777740    fn_array                 lisp_name_codes:     28.
      777537    fn_arraydims             lisp_name_codes:    157.
      777751    fn_ascii                 lisp_name_codes:     19.
      777631    fn_atan                  lisp_name_codes:     99.
      777650    fn_baktrace              lisp_name_codes:     84.
      777647    fn_bltarray              lisp_name_codes:     85.
      777705    fn_boole                 lisp_name_codes:     55.
      777643    fn_boundp                lisp_name_codes:     89.
      777654    fn_catch                 lisp_name_codes:     80.
      777741    fn_catenate              lisp_name_codes:     27.
      777544    fn_charpos               lisp_name_codes:    152.
      777610    fn_chrct                 lisp_name_codes:    116.
      777557    fn_clear_input           lisp_name_codes:    141.
      777553    fn_cline                 lisp_name_codes:    145.
      777607    fn_close                 lisp_name_codes:    117.
      777637    fn_cos                   lisp_name_codes:     93.
      777732    fn_CtoI                  lisp_name_codes:     34.
      777561    fn_cursorpos             lisp_name_codes:    139.
      777756    fn_defaultf              lisp_name_codes:     17.
      777747    fn_definedp              lisp_name_codes:     21.
      777731    fn_defsubr               lisp_name_codes:     35.
      777651    fn_defun                 lisp_name_codes:     83.
      777744    fn_delete                lisp_quick_fcns_:   720,
                                         lisp_name_codes:     24.
      777606    fn_deletef               lisp_name_codes:    118.
      777743    fn_delq                  lisp_quick_fcns_:   775,
                                         lisp_name_codes:     25.
      777711    fn_difference            lisp_name_codes:     51.
      777664    fn_diff_fix              lisp_name_codes:     72.
      777663    fn_diff_flo              lisp_name_codes:     73.
      777516    fn_displace              lisp_quick_fcns_:  1063,
                                         lisp_name_codes:    174.
      777766    fn_do                    lisp_name_codes:      9.
      777535    fn_dumparrays            lisp_name_codes:    159.
      777540    fn_endpagefn             lisp_name_codes:    156.
      777605    fn_eoffn                 lisp_name_codes:    119.
      777621    fn_eql                   lisp_name_codes:    107.
      777760    fn_errframe              lisp_name_codes:     15.
      777761    fn_errprint              lisp_name_codes:     14.
      777655    fn_errset                lisp_name_codes:     79.
      777660    fn_eval                  lisp_name_codes:     76.
      777757    fn_evalframe             lisp_name_codes:     16.
      777520    fn_eval_when             lisp_name_codes:    172.
      777635    fn_exp                   lisp_name_codes:     95.
      777706    fn_expt                  lisp_name_codes:     54.
      777534    fn_expt_fix              lisp_name_codes:    160.
      777533    fn_expt_flo              lisp_name_codes:    161.
      777604    fn_filepos               lisp_name_codes:    120.
      777552    fn_fillarray             lisp_name_codes:    146.
      777701    fn_fix                   lisp_name_codes:     59.
      777700    fn_float                 lisp_name_codes:     60.
      777560    fn_force_output          lisp_name_codes:    140.
      777640    fn_freturn               lisp_name_codes:     92.
      777524    fn_fsc                   lisp_name_codes:    168.
      777612    fn_gcd                   lisp_name_codes:    114.
      777645    fn_gensym                lisp_name_codes:     87.
      777725    fn_get                   lisp_name_codes:     39.
      777615    fn_getchar               lisp_quick_fcns_:  1060, 1061,
                                         lisp_name_codes:    111.
      777724    fn_getl                  lisp_name_codes:     40.
      777735    fn_get_pname             lisp_name_codes:     31.
      777716    fn_greaterp              lisp_name_codes:     46.
      777620    fn_gt                    lisp_name_codes:    108.
      777554    fn_haipart               lisp_name_codes:    144.
      777555    fn_haulong               lisp_name_codes:    143.
      777525    fn_ifix                  lisp_name_codes:    167.
      777530    fn_in                    lisp_name_codes:    164.
      777513    fn_includef              lisp_name_codes:    177.
      777736    fn_index                 lisp_name_codes:     30.
      777603    fn_inpush                lisp_name_codes:    121.
      777632    fn_isqrt                 lisp_name_codes:     98.
      777733    fn_ItoC                  lisp_name_codes:     33.
      777715    fn_lessp                 lisp_name_codes:     47.
      777602    fn_linel                 lisp_name_codes:    122.
      777542    fn_linenum               lisp_name_codes:    154.
      777551    fn_listarray             lisp_name_codes:    147.
      777545    fn_listify               lisp_name_codes:    151.
      777536    fn_loadarrays            lisp_name_codes:    158.
      777634    fn_log                   lisp_name_codes:     96.
      777622    fn_ls                    lisp_name_codes:    106.
      777703    fn_lsh                   lisp_name_codes:     57.
      777734    fn_make_atom             lisp_name_codes:     32.
      777644    fn_makunbound            lisp_name_codes:     88.
      777522    fn_mapatoms              lisp_name_codes:    170.
      777676    fn_max                   lisp_name_codes:     62.
      777601    fn_mergef                lisp_name_codes:    123.
      777675    fn_min                   lisp_name_codes:     63.
      777714    fn_minus                 lisp_name_codes:     48.
      777623    fn_minusp                lisp_name_codes:    105.
      777600    fn_namelist              lisp_name_codes:    124.
      777577    fn_names                 lisp_name_codes:    125.
      777576    fn_namestring            lisp_name_codes:    126.
      777532    fn_nointerrupt           lisp_name_codes:    162.
      777515    fn_nth                   lisp_name_codes:    175.
      777514    fn_nthcdr                lisp_name_codes:    176.
      777627    fn_oddp                  lisp_quick_fcns_:  1058,
                                         lisp_name_codes:    101.
      777531    fn_open                  lisp_name_codes:    163.
      777614    fn_opena                 lisp_name_codes:    112.
      777575    fn_openi                 lisp_name_codes:    127.
      777574    fn_openo                 lisp_name_codes:    128.
      777527    fn_out                   lisp_name_codes:    165.
      777543    fn_pagel                 lisp_name_codes:    153.
      777541    fn_pagenum               lisp_name_codes:    155.
      777713    fn_plus                  lisp_name_codes:     49.
      777624    fn_plusp                 lisp_name_codes:    104.
      777670    fn_plus_fix              lisp_name_codes:     68.
      777667    fn_plus_flo              lisp_name_codes:     69.
      777573    fn_prin1                 lisp_name_codes:    129.
      777572    fn_princ                 lisp_name_codes:    130.
      777571    fn_print                 lisp_name_codes:    131.
      777656    fn_prog                  lisp_name_codes:     78.
      777523    fn_progv                 lisp_name_codes:    169.
      777723    fn_putprop               lisp_name_codes:     41.
      777710    fn_quotient              lisp_name_codes:     52.
      777662    fn_quot_fix              lisp_name_codes:     74.
      777661    fn_quot_flo              lisp_name_codes:     75.
      777556    fn_random                lisp_quick_fcns_:  1059,
                                         lisp_name_codes:    142.
      777570    fn_read                  lisp_name_codes:    132.
      777567    fn_readch                lisp_name_codes:    133.
      777566    fn_readstring            lisp_name_codes:    134.
      777517    fn_read_from_string      lisp_name_codes:    173.
      777677    fn_remainder             lisp_name_codes:     61.
      777722    fn_remprop               lisp_name_codes:     42.
      777565    fn_rename                lisp_name_codes:    135.
      777704    fn_rot                   lisp_name_codes:     56.
      777750    fn_rplaca                lisp_quick_fcns_:  1055,
                                         lisp_name_codes:     20.
      777616    fn_samepnamep            lisp_quick_fcns_:   432,
                                         lisp_name_codes:    110.
      777721    fn_save                  lisp_name_codes:     43.
      777745    fn_set                   lisp_quick_fcns_:  1057,
                                         lisp_name_codes:     23.
      777764    fn_setarg                lisp_name_codes:     11.
      777746    fn_setq                  lisp_quick_fcns_:  1056,
                                         lisp_name_codes:     22.
      777562    fn_setsyntax             lisp_name_codes:    138.
      777564    fn_shortnamestring       lisp_name_codes:    136.
      777702    fn_signp                 lisp_name_codes:     58.
      777636    fn_sin                   lisp_name_codes:     94.
      777630    fn_sleep                 lisp_name_codes:    100.
      777550    fn_sort                  lisp_name_codes:    148.
      777547    fn_sortcar               lisp_name_codes:    149.
      777633    fn_sqrt                  lisp_name_codes:     97.
      777762    fn_sstatus               lisp_name_codes:     13.
      777730    fn_star_array            lisp_name_codes:     36.
      777646    fn_star_rearray          lisp_name_codes:     86.
      777641    fn_star_sstatus          lisp_name_codes:     91.
      777642    fn_star_status           lisp_name_codes:     90.
      777763    fn_status                lisp_name_codes:     12.
      777652    fn_store                 lisp_name_codes:     82.
      777742    fn_stringlength          lisp_name_codes:     26.
      777717    fn_sub1                  lisp_name_codes:     45.
      777672    fn_sub1_fix              lisp_name_codes:     66.
      777671    fn_sub1_flo              lisp_name_codes:     67.
      777737    fn_substr                lisp_name_codes:     29.
      777613    fn_sxhash                lisp_name_codes:    113.
      777726    fn_sysp                  lisp_name_codes:     38.
      777653    fn_throw                 lisp_name_codes:     81.
      777712    fn_times                 lisp_name_codes:     50.
      777666    fn_times_fix             lisp_name_codes:     70.
      777665    fn_times_flo             lisp_name_codes:     71.
      777526    fn_truename              lisp_name_codes:    166.
      777563    fn_tyi                   lisp_name_codes:    137.
      777626    fn_tyipeek               lisp_name_codes:    102.
      777752    fn_tyo                   lisp_name_codes:     18.
      777521    fn_unwind_protect        lisp_name_codes:    171.
      777546    fn_zerop                 lisp_quick_fcns_:  1062,
                                         lisp_name_codes:    150.
          42    gensym_data              lisp_stack_seg:      26.
         464    getchar                  lisp_quick_fcns_:   438,  439,  448.
         463    getcharn                 lisp_quick_fcns_:   435,  436.
         530    getcharn_return          lisp_quick_fcns_:   476,  486.
         470    getch_tsx4               lisp_quick_fcns_:   446, 1060.
         476    getch_tsx4_2             lisp_quick_fcns_:   454, 1061.
        1225    get_count                lisp_quick_fcns_:   721,  776,  857.
        1234    get_count_tsx4           lisp_quick_fcns_:   862,  865,  953.
        1345    get_my_name              lisp_quick_fcns_:   954,  959.
         413    good_alpha1              lisp_quick_fcns_:   380,  385,  391.
         421    good_alpha2              lisp_quick_fcns_:   388,  393.
        1254    good_atom                lisp_quick_fcns_:   882,  886.
        1236    good_count               lisp_quick_fcns_:   864,  868.
         473    good_getch1              lisp_quick_fcns_:   445,  450,  457.
         501    good_getch2              lisp_quick_fcns_:   453,  459.
        1356    got_name                 lisp_quick_fcns_:   431,  433,  957,  966,  971.
                hcs_                     lisp_quick_fcns_:   205.
        1044    head_loop                lisp_quick_fcns_:   726,  740.
                hi_random                lisp_quick_fcns_:  1015, 1021, 1028.
         162    illobj                   lisp_error_codes:    22.
         235    include_file_error       lisp_error_codes:    61.
        1424    init_random              lisp_quick_fcns_:  1006, 1013.
          16    in_pl1_code              lisp_quick_fcns_:   196,  213,  925,  976,  986,
                                         lisp_stack_seg:      13.
          46    iogbind_op               lisp_stack_seg:      29.
         226    io_wrong_direction       lisp_error_codes:    54.
         150    irest_return_op          lisp_stack_seg:      62.
         252    last                     lisp_quick_fcns_:   253,  254.
         256    last_loop                lisp_quick_fcns_:   258,  263.
         236    length                   lisp_quick_fcns_:   239,  240.
         242    len_loop                 lisp_quick_fcns_:   244,  249.
         110    link_opr                 lisp_stack_seg:      46.
                lisp_                    lisp_quick_fcns_:   521,  542,  566,  582,  711,  899.
                lisp_alloc_              lisp_quick_fcns_:   847.
                lisp_error_              lisp_quick_fcns_:   928,  979.
       77700    lisp_ptr.type            lisp_object_types:   13.
                lisp_reader_alm_         lisp_quick_fcns_:   479.
                lisp_static_vars_        lisp_quick_fcns_:   194,  195,  199,  210,  211,  212,  230,  235,  842,  923,  924,
                                                             974,  975,  983,  984,  985, 1015, 1021, 1023, 1026, 1028.
         317    list_eql                 lisp_quick_fcns_:   280,  303.
                lo_random                lisp_quick_fcns_:  1023, 1026.
           0    marked_stack_bottom      lisp_stack_seg:       6.
         660    member                   lisp_quick_fcns_:   591,  592.
         666    memb_lp                  lisp_quick_fcns_:   598,  611.
         704    memq                     lisp_quick_fcns_:   594,  613,  614.
         210    mismatch_super_parens    lisp_error_codes:    40.
        1247    more_setq                lisp_quick_fcns_:   877,  880.
         707    mq_lp                    lisp_quick_fcns_:   617,  625.
        1471    name_tbl                 lisp_quick_fcns_:   962,  968, 1064.
          11    name_tbl_len             lisp_quick_fcns_:   960, 1065.
                ncons_                   lisp_quick_fcns_:   847.
          74    ncons_op                 lisp_stack_seg:      40.
         200    nihil_ex_nihile          lisp_quick_fcns_:   921,
                                         lisp_error_codes:    36.
          12    nil                      lisp_quick_fcns_:    53,   55,  339,  373,  482,  522,  528,  543,  550,  569,  606,
                                                             626,  658,  696,  734,  757,  874,  886,  913, 1005,
                                         lisp_stack_seg:      11.
         402    nil_return               lisp_quick_fcns_:   359,  360,  365,  367,  372.
         157    nonfixedarg              lisp_error_codes:    19.
         234    not_alpha_array          lisp_error_codes:    60.
         233    not_an_array             lisp_error_codes:    59.
         151    not_big                  lisp_quick_fcns_:   163,  170.
         203    not_pdl_ptr              lisp_error_codes:    37.
         245    not_same_type            lisp_error_codes:    69.
        1112    no_del                   lisp_quick_fcns_:   758,  764.
        1143    no_dq                    lisp_quick_fcns_:   787,  792.
         211    no_left_super_paren      lisp_error_codes:    41.
         172    no_lexpr                 lisp_error_codes:    30.
          20    null                     lisp_quick_fcns_:    50,   51.
        1326    null_arg_list            lisp_quick_fcns_:   927,  931,  978.
          42    numberp                  lisp_quick_fcns_:    74,   75.
       61400    Numeric                  lisp_quick_fcns_:    77,
                                         lisp_object_types:   17.
        1242    nxt_setq                 lisp_quick_fcns_:   875,  902.
         141    oddp                     lisp_quick_fcns_:   160,  161,  176.
         145    oddp_test                lisp_quick_fcns_:   165,  171.
         154    oddp_tsx4                lisp_quick_fcns_:   174, 1058.
        1330    one_arg                  lisp_quick_fcns_:   202,  934.
         566    or                       lisp_quick_fcns_:   527,  528.
         567    or_loop                  lisp_quick_fcns_:   529,  544.
         207    overflow_err             lisp_error_codes:    39.
         160    parenmissing             lisp_error_codes:    20.
         152    pl1_call_nopop_op        lisp_stack_seg:      63.
         134    pl1_call_op              lisp_stack_seg:      56.
          66    pl1_interface            lisp_stack_seg:      37.
          70    pl1_lsubr_interface      lisp_stack_seg:      38.
          11    popj                     lisp_quick_fcns_:    37,  251,  341,  351,  630,  694.
         164    pop_ptrs                 lisp_quick_fcns_:   151,  175,  183.
         532    prog1                    lisp_quick_fcns_:   490,  491.
         535    prog2                    lisp_quick_fcns_:   495,  496.
         540    progn                    lisp_quick_fcns_:   500,  501.
                progn_atom               lisp_quick_fcns_:   842.
        1171    push_offset              stack_header:        81.
         157    push_ptrs                lisp_quick_fcns_:   148,  173,  178.
         213    quoterror                lisp_error_codes:    43.
        1412    random                   lisp_quick_fcns_:   999, 1001.
        1431    random0                  lisp_quick_fcns_:  1002, 1020.
        1432    random1                  lisp_quick_fcns_:  1021, 1038.
        1441    random_bounded           lisp_quick_fcns_:  1008, 1034.
        1410    random_init              lisp_quick_fcns_:   996, 1014.
        1421    random_tsx4              lisp_quick_fcns_:  1009, 1059.
         154    rcv_char_star_op         lisp_stack_seg:      64.
         230    reopen_inconsistent      lisp_error_codes:    56.
        1156    replace                  lisp_quick_fcns_:   801,  806.
          14    retrn1                   lisp_quick_fcns_:    45,  232,  237,  375,  488,  525,  588,  769,  796,  810,  839,
                                                             852,  879,  918, 1019, 1020, 1046, 1049.
        1276    retry_set                lisp_quick_fcns_:   906,  912.
        1173    return_no_pop_offset     stack_header:        83.
        1172    return_offset            stack_header:        82.
          62    return_op                lisp_stack_seg:      35.
        1012    ret_assq_nil             lisp_quick_fcns_:   668,  680,  695.
         761    ret_ass_nil              lisp_quick_fcns_:   648,  666.
        1115    ret_del                  lisp_quick_fcns_:   724,  727,  741,  745,  749,  767.
         250    ret_l                    lisp_quick_fcns_:   246,  250,  260.
         720    ret_mq                   lisp_quick_fcns_:   599,  618,  626.
         722    ret_mq_obj               lisp_quick_fcns_:   607,  622,  628.
          24    ret_nil                  lisp_quick_fcns_:    55,   65,   71,   78,   86,   93,  100,  107,  114,  121,  128,
                                                             135,  142,  158,  167.
         355    ret_nil_eql              lisp_quick_fcns_:   282,  286,  291,  294,  301,  305,  323,  329,  338.
         524    ret_nil_getch            lisp_quick_fcns_:   467,  469,  481.
          26    ret_t                    lisp_quick_fcns_:    54,   57,   64,   72,   79,   85,   92,   99,  113,  120,  127,
                                                             134,  141,  155,  157,  168.
         360    ret_t_eql                lisp_quick_fcns_:   278,  300,  335,  343.
         365    ret_t_for_real           lisp_quick_fcns_:   345,  348.
        1455    ret_zero                 lisp_quick_fcns_:  1037, 1047.
        1150    rplaca                   lisp_quick_fcns_:   798,  799,  805.
        1153    rplaca_tsx4              lisp_quick_fcns_:   802, 1055.
        1163    rplacd                   lisp_quick_fcns_:   812,  813.
         171    runtime                  lisp_quick_fcns_:   189,  190.
         374    samepnamep               lisp_quick_fcns_:   362,  363.
         725    sassoc                   lisp_quick_fcns_:   632,  633.
         763    sassq                    lisp_quick_fcns_:   670,  671.
        1346    search_for_name          lisp_quick_fcns_:   961,  965.
        1275    set                      lisp_quick_fcns_:   904,  905.
        1240    setq                     lisp_quick_fcns_:   872,  873.
        1252    setq_tsx4                lisp_quick_fcns_:   883, 1056.
        1303    set_atm                  lisp_quick_fcns_:   908,  913.
        1311    set_nil                  lisp_quick_fcns_:   887,  914,  920.
        1300    set_tsx4                 lisp_quick_fcns_:   909, 1057.
         164    shortreadlist            lisp_error_codes:    24.
          56    signp_op                 lisp_stack_seg:      33.
         755    skip_ass                 lisp_quick_fcns_:   651,  661.
        1004    skip_assq                lisp_quick_fcns_:   684,  689.
          54    smallnump                lisp_quick_fcns_:    88,   89.
         246    special_array_type       lisp_error_codes:    70.
          73    stach_header.trace_top_ptr     stack_header:        62.
          66    stack_header.assign_linkage_ptr      stack_header:        59.
          32    stack_header.bar_mode_sp       stack_header:        42.
          36    stack_header.call_op_ptr       stack_header:        44.
          10    stack_header.clr_ptr     stack_header:        27.
           6    stack_header.combined_stat_ptr       stack_header:        25.
           4    stack_header.cpm_data_ptr      stack_header:        24.
          13    stack_header.cpm_enabled       stack_header:        32.
          13    stack_header.cur_lot_size      stack_header:        31.
          64    stack_header.ect_ptr     stack_header:        58.
          46    stack_header.entry_op_ptr      stack_header:        49.
          70    stack_header.heap_header_ptr   stack_header:        60.
          74    stack_header.in_trace    stack_header:        63.
          52    stack_header.isot_ptr    stack_header:        52.
          26    stack_header.lot_ptr     stack_header:        39.
          12    stack_header.main_proc_invoked       stack_header:        29.
          12    stack_header.max_lot_size      stack_header:        28.
          20    stack_header.parent_ptr  stack_header:        36.
          34    stack_header.pl1_operators_ptr       stack_header:        43.
          40    stack_header.push_op_ptr       stack_header:        46.
          42    stack_header.return_op_ptr     stack_header:        47.
          44    stack_header.ret_no_pop_op_ptr       stack_header:        48.
          62    stack_header.rnt_ptr     stack_header:        57.
          12    stack_header.run_unit_depth    stack_header:        30.
          54    stack_header.sct_ptr     stack_header:        53.
          30    stack_header.signal_ptr  stack_header:        41.
          22    stack_header.stack_begin_ptr   stack_header:        37.
          24    stack_header.stack_end_ptr     lisp_quick_fcns_:   207,  981,
                                               stack_header:        38.
          14    stack_header.system_free_ptr   stack_header:        33.
          60    stack_header.sys_link_info_ptr       stack_header:        56.
          72    stack_header.trace_frames      stack_header:        61.
          50    stack_header.trans_op_tv_ptr   stack_header:        51.
          56    stack_header.unwinder_ptr      stack_header:        54.
          16    stack_header.user_free_ptr     stack_header:        34.
         100    stack_header_end         stack_header:        64.
         236    stack_loss_error         lisp_error_codes:    62.
                stack_ptr                lisp_quick_fcns_:   194,  211,  923,  974,  985.
           4    stack_ptr_ptr            lisp_stack_seg:       8.
         225    stars_left_in_name       lisp_error_codes:    53.
         251    store_function_misused   lisp_error_codes:    73.
         242    store_not_allowed        lisp_error_codes:    66.
         116    store_operator           lisp_stack_seg:      49.
        4000    String                   lisp_quick_fcns_:   112,  285,  290,  379,  387,  395,  400,  444,
                                         lisp_object_types:   22.
         405    stringcmp                lisp_quick_fcns_:   357,  364,  377,  383.
          73    stringp                  lisp_quick_fcns_:   109,  110.
        2000    Subr                     lisp_quick_fcns_:   119,  281,  593,  641,  715,
                                         lisp_object_types:   23.
         100    subrp                    lisp_quick_fcns_:   116,  117.
         105    symbolp                  lisp_quick_fcns_:   123,  124.
          44    system_lp                lisp_quick_fcns_:   181,  193,  708,
                                         lisp_stack_seg:      28.
         400    System_Subr              lisp_object_types:   24.
         104    terminate_list_op        lisp_stack_seg:      44.
          52    throw1_op                lisp_stack_seg:      31.
          54    throw2_op                lisp_stack_seg:      32.
         156    throw_to_no_catch        lisp_error_codes:    18.
         147    too_few_args             lisp_error_codes:    11.
         146    too_many_args            lisp_error_codes:    10.
           0    trace_frames.count       stack_header:        69.
           1    trace_frames.top_ptr     stack_header:        70.
          14    true                     lisp_quick_fcns_:    57,  350,  370,  507,
                                         lisp_stack_seg:      12.
         400    true_return              lisp_quick_fcns_:   358,  366,  369.
         551    tv_offset                stack_header:        75,   80,   81,   82,   83,   84.
          60    type_fields              lisp_stack_seg:      34.
         217    unable_to_float          lisp_error_codes:    47.
          22    unbind_op                lisp_stack_seg:      18.
          40    uncatch_op               lisp_stack_seg:      25.
       60000    Uncollectable            lisp_object_types:   21.
         144    undefined_atom           lisp_error_codes:     8.
         145    undefined_function       lisp_error_codes:     9.
         152    undefined_subr           lisp_error_codes:    14.
         237    underflow_fault          lisp_error_codes:    63.
          30    unerrset_op              lisp_stack_seg:      21.
       67500    Unevalable               lisp_object_types:   27.
                unmkd_ptr                lisp_quick_fcns_:   195,  199,  210,  212,  924,  975,  983,  984.
           6    unmkd_ptr_ptr            lisp_stack_seg:       9.
           2    unmkd_stack_bottom       lisp_stack_seg:       7.
         155    unseen_go_tag            lisp_error_codes:    17.
          50    unseen_go_tag_op         lisp_stack_seg:      30.
         146    ununwp_op                lisp_stack_seg:      61.
         142    unwp1_op                 lisp_stack_seg:      59.
         144    unwp2_op                 lisp_stack_seg:      60.
                virtual_cpu_time_        lisp_quick_fcns_:   205.
         173    wrong_no_args            lisp_error_codes:    31.
          76    xcons_op                 lisp_stack_seg:      41.
         240    zerodivide_fault         lisp_error_codes:    64.
         124    zerop                    lisp_quick_fcns_:   144,  145,  152.
         130    zerop_tsx4               lisp_quick_fcns_:   149, 1062.


NO FATAL ERRORS


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
