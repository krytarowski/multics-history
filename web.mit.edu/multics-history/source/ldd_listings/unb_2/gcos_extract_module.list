	COMPILATION LISTING OF SEGMENT gcos_extract_module
	Compiled by: Multics PL/I Compiler, Release 28b, of April 11, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 09/09/83  1058.5 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 gcos_extract_module: gcem: extract: proc;
        7 
        8 /* This procedure extracts one or more modules from a (tape format) GCOS
        9*   system loadable file, or a simulator format software library, placing them in
       10*   an output file. The names of the modules are given in a control file.
       11*
       12*   WARNING: This command can not be used to manipulate a random system loadable
       13*   file. For a detailed description of the differences
       14*   between a random system loadable file, a tape system loadable file, and a
       15*   simulator format software library see the simulator manual (AN05) and
       16*   the GCOS System Editor manual (DD30).
       17*
       18*   USAGE: gcem control_path input_path output_path -brief
       19*
       20*   control_path
       21*
       22*   is the pathname of a segment containing the names of the modules to be
       23*   extracted, in lower case ascii, each on a separate line. (Such a segment
       24*   can be created by the gcos_library_summary command, using the -brief control
       25*   argument, and preceeding it by the file_output command, and then editing the
       26*   resulting segment to remove the names of unwanted modules; or the
       27*   segment can be created directly by any of the Multics editors.)
       28*
       29*   input_path
       30*
       31*   is the pathname of a file containing gcos modules. It may be a file copied from
       32*   a GCOS total system tape, or it may be a simulator library, beginning with
       33*   a simulator-format catalog of the module names and locations. The file is
       34*   determined to be a native GCOS or simulator format file by inspection. The
       35*   -no_catalog  arg is no longer necessary.
       36*
       37*   output_path
       38*
       39*   is the pathname of the output file into which the extracted modules are to be
       40*   written. If the file already exists, it will be appended to, enabling the
       41*   construction of a single library from several smaller ones.
       42*
       43*   The names of each module copied will be printed on user_output,
       44*   unless the -brief control argument is given.  The names of any requested modules
       45*   that are not found in the input file will be printed on error_output.
       46*
       47*
       48*   WRITTEN BY DICK SNYDER .... 1971
       49*   MODIFIED BY T. CASEY JUNE 1974, AUGUST 1974
       50*  Change:	Ron Barstad  2.0 83-07-29  Repaired obsolete hcs_$initiate_count call
       51*                                     Removed need for -no_catalog
       52*
       53*   */
       54 
       55 
       56 
       57 
       58 /* 	D   E   C   L   A   R   A   T   I   O   N   S				 */
       59 
       60 
       61 
       62 
       63 /* 	External Entries						 */
       64 
       65 
       66 dcl  ios_$read ext entry (char (*) aligned, pointer, fixed bin, fixed bin, fixed bin, bit (72) aligned);
       67 dcl  ios_$write ext entry (char (*), pointer, fixed bin, fixed bin, fixed bin, bit (72) aligned);
       68 dcl  ios_$detach ext entry (char (*), char (*), char (*), bit (72) aligned);
       69 dcl  expand_path_ ext entry (pointer, fixed bin, pointer, pointer, fixed bin (35));
       70 dcl  hcs_$initiate_count ext entry (char (*), char (*), char (*), fixed bin, fixed bin, pointer, fixed bin (35));
       71 dcl  delete_$ptr ext entry (ptr, bit (6), char (*), fixed bin (35));
       72 dcl (ioa_, ioa_$nnl, ioa_$rsnnl, com_err_) ext entry options (variable);
       73 dcl  ios_$attach ext entry (char (*), char (*), char (*), char (*), bit (72) aligned);
       74 dcl  ios_$setsize ext entry (char (*), fixed bin, bit (72) aligned);
       75 dcl  ios_$seek ext entry (char (*), char (*), char (*), fixed bin(21), bit (72) aligned);
       76 dcl  gcos_cv_gebcd_ascii_ ext entry (pointer, fixed bin, pointer, fixed bin);
       77 dcl  cu_$arg_count ext entry (fixed bin);
       78 dcl  cu_$arg_ptr ext entry (fixed bin, ptr, fixed bin, fixed bin (35));
       79 dcl  get_temp_segment_ entry (char(*), ptr, fixed bin(35));
       80 dcl  release_temp_segment_ entry (char(*), ptr, fixed bin(35));
       81 
       82 /*  Work Variables */
       83 
       84 dcl  nargs fixed bin;
       85 dcl  argp ptr;
       86 dcl  argl fixed bin;
       87 dcl  arg char (argl) based (argp);
       88 dcl  argno fixed bin;
       89 
       90 dcl  cleanup condition;
       91 
       92 dcl  err_msg char (200) varying;
       93 
       94 
       95 dcl (i1, i2, i3, i4, pref_data, pref_reloc) fixed bin;
       96 dcl (i, j, word_no, bc, segl, doff) fixed bin;		/* temps */
       97 dcl  k fixed bin (21);
       98 dcl  control char (segl) based (temp_segp);
       99 dcl  temp_segp pointer;
      100 dcl  control_orig char (segl) based (segp);
      101 dcl  segp pointer;
      102 dcl  word_one fixed bin (35);			/* first word of input file */
      103 dcl  ename char (32);
      104 dcl  dir char (168);
      105 dcl  string char (6);
      106 
      107 dcl  st bit (72) aligned ;				/* ios status */
      108 
      109 dcl 1 status aligned based (addr (st)),			/* overlay for ios_ status */
      110     2 code fixed bin (35),				/* standard error code */
      111     2 fill bit (9) unaligned,
      112     2 eof bit (1) unaligned;				/* eof bit */
      113 
      114 dcl 1 preface aligned based (prefp),			/* model of preface record */
      115     2 data_check fixed bin,				/* checksum of following data words */
      116     2 rel_check fixed bin,				/* checksum of following reloc. words */
      117     2 rel_abs fixed bin,				/* 0=absolute|^0=relocatable */
      118     2 name bit (36) unaligned,			/* name of pgm */
      119     2 entry bit (18) unaligned,			/* entry address */
      120     2 origin bit (18) unaligned,			/* origin */
      121     2 reloc_words fixed bin (17) unaligned,		/* no. of relocation words */
      122     2 data_words fixed bin (17) unaligned,		/* no. of data words */
      123     2 dcws (ndcw) bit (36) unaligned;			/* dcw(s) to load following data records */
      124 dcl  prefp pointer;
      125 dcl  ndcw fixed bin;
      126 
      127 dcl (control_path, input_path, output_path, err_path) char (168);
      128 dcl (briefsw					/* omit printing of names of extracted modules */
      129      , nocatsw					/* file does not begin with a catalog */
      130      , usage_sw					/* print usage message if error on command line */
      131      ) bit (1) aligned init ("0"b);
      132 
      133 dcl  path_counter fixed bin init (0);
      134 
      135 dcl  me char (25) int static init ("gcos_extract_module (2.0)");
      136 
      137 dcl  ascii_newline char (1) int static init ("
      138 ");
      139 
      140 dcl (error_table_$badopt, error_table_$noarg) ext fixed bin (35);
      141 
      142 
      143 /* 	NOTE: Declaration of buffer should be last declaration in case	 */
      144 /* 	buffer should overflow.					 */
      145 
      146 dcl  buffer bit (131400);				/* preface and relocation blk buffer */
      147 
      148 dcl (addr, divide, index, mod, null, substr, translate) builtin;
      149 
      150 /*  */
      151 
      152 /*  P     R     O     C     E     D     U     R     E    */
      153 
      154 	on condition (cleanup) call cleanup_proc;
      155 
      156 	segp, temp_segp = null;
      157 
      158 	call cu_$arg_count (nargs);
      159 
      160 /* IF WRONG NUMBER OF ARGS, PRINT USAGE MESSAGE AND QUIT */
      161 
      162 	if nargs < 3 then
      163 print_usage:   do;
      164 	     call ioa_ ("Usage: gcem CONTROL_PATH INPUT_PATH OUTPUT_PATH {-brief}");
      165 exit:	     call cleanup_proc;
      166 	     return;
      167 	end print_usage;
      168 arg_loop:	do argno = 1 to nargs;
      169 
      170 	     call cu_$arg_ptr (argno, argp, argl, code);
      171 
      172 	     if code ^= 0 then do;
      173 		err_msg = arg;
      174 call_com_err:	call com_err_ (code, me, err_msg, err_path);
      175 		if usage_sw then goto print_usage;
      176 		else goto exit;
      177 	     end;
      178 
      179 
      180 	     err_path = arg;			/* in case of error, be ready */
      181 
      182 	     if substr (arg, 1, 1) ^= "-" then		/* if not control argument */
      183 get_path:		do;				/* must be pathname */
      184 		if path_counter = 0 then		/* which pathname? how many do we have already? */
      185 get_control:	     do;				/* if none, first one is control file */
      186 		     call expand_path_ (argp, argl, addr (dir), addr (ename), code);
      187 		     if code ^= 0 then do;
      188 			err_msg = "from expand_path_ ^a";
      189 			goto call_com_err;
      190 		     end;
      191 
      192 		     call ioa_$rsnnl ("^a>^a", control_path, bc, dir, ename); /* put pathname together */
      193 
      194 		     call hcs_$initiate_count (dir, ename, "", bc, 0, segp, code);
      195 
      196 		     if segp = null then do;
      197 			err_path = control_path;
      198 			err_msg = "from hcs_$initiate_count ^a";
      199 			goto call_com_err;
      200 		     end;
      201 
      202 		     segl = divide (bc, 9, 17, 0);
      203 
      204 		     call get_temp_segment_(me, temp_segp, code);
      205 		     if code ^= 0 then do;
      206 			call com_err_(code, me, "Unable to make temporary copy of input_path.");
      207 			goto exit;
      208 		     end;
      209 		     control = control_orig;		/* make a working copy */
      210 		     path_counter = 1;		/* remember that we have control_path */
      211 		end get_control;
      212 
      213 		else if path_counter = 1 then		/* if we already have control_path */
      214 get_input:	     do;				/* this must be input_path */
      215 		     input_path = arg;
      216 		     call ios_$attach ("gcem_input", "file_", input_path, "r", st);
      217 		     if code ^= 0 then do;
      218 attach_err:		err_msg = "from ios_$attach ^a";
      219 			goto call_com_err;
      220 		     end;
      221 
      222 		     call ios_$setsize ("gcem_input", 36, st);
      223 		     if code ^= 0 then do;
      224 setsize_err:		err_msg = "from ios_$setsize ^a";
      225 			goto call_com_err;
      226 		     end;
      227 
      228 		     path_counter = 2;		/* remember that we have input_path */
      229 		end get_input;
      230 
      231 		else if path_counter = 2 then		/* but if we have input path already */
      232 get_output:	     do;				/* this must be output_path */
      233 		     output_path = arg;
      234 		     call ios_$attach ("gcem_output", "file_", output_path, "", st);
      235 		     if code ^= 0 then
      236 			goto attach_err;
      237 
      238 		     call ios_$setsize ("gcem_output", 36, st);
      239 		     if code ^= 0 then
      240 			goto setsize_err;
      241 
      242 		     path_counter = 3;		/* remember that we have all 3 pathnames */
      243 		end get_output;
      244 
      245 		else do;				/* can't be a pathname - must be garbage */
      246 		     usage_sw = "1"b;		/* tell user how to use command */
      247 		     err_msg = "unidentified non-control argument: ^a";
      248 		     code = 0;
      249 		     goto call_com_err;
      250 		end;
      251 
      252 	     end get_path;
      253 
      254 	     else if arg = "-bf" | arg = "-brief" then
      255 		briefsw = "1"b;
      256 
      257 	     else if arg = "-no_catalog" then
      258 		nocatsw = "1"b;
      259 
      260 	     else do;
      261 		code = error_table_$badopt;
      262 		err_msg = "^a";
      263 		goto call_com_err;
      264 	     end;
      265 
      266 	end arg_loop;
      267 
      268 	if path_counter ^= 3 then do;			/* complain if all 3 pathnames not given */
      269 	     code = error_table_$noarg;
      270 	     err_msg = "";
      271 	     usage_sw = "1"b;
      272 	     goto call_com_err;
      273 	end;
      274 
      275 /* initialize */
      276 
      277 	prefp = addr (buffer);			/* pointer to buffer for ios_ */
      278 
      279 	k = 0;					/* offset of first preface record
      280*						   (relative to doff) */
      281 
      282 	err_path = input_path;			/* higher probablility of input errors */
      283 
      284 /* determine if the input file has a catalog:
      285*   if the first word of the file =0 then this is a simulator file with a catalog
      286*   if the first word not=0 then this is a native GCOS file without a catalog
      287**/
      288 	call ios_$seek ("gcem_input", "read", "first", 0, st);
      289 	if code ^= 0 then do;
      290 	     err_msg = "from ios_$seek read first word: ^a";
      291 	     goto call_com_err;
      292 	end;
      293 
      294 	call ios_$read ("gcem_input", addr(word_one), 0, 1, j, st);
      295 	if code ^= 0 then do;
      296 	     err_msg = "from ios_$read of word one: ^a";
      297 	     goto call_com_err;
      298 	end;
      299 
      300 	if word_one = 0
      301 	     then doff = 1000;		/* has catalog */
      302 	     else doff = 0;
      303 
      304 /* Main loop begins here */
      305 
      306 seek_preface: call ios_$seek ("gcem_input", "read", "first", k+doff, st);
      307 	if code ^= 0 then do;
      308 seek_err:	     err_msg = "from ios_$seek read start-of-preface ^a";
      309 	     goto call_com_err;
      310 	end;
      311 
      312 	if status.eof then do;			/* check for end of file */
      313 	     call ioa_ ("^/end of file");
      314 
      315 	     control = translate (control, "", " ");	/* translate blanks to fill (177) chars */
      316 	     call com_err_ (0, me, "Following modules not found in ^a^/^a", input_path, control);
      317 
      318 	     goto exit;
      319 	end;
      320 
      321 
      322 read:	call ios_$read ("gcem_input", prefp, 0, 3650, j, st); /* read preface record */
      323 	if code ^= 0 then do;
      324 read_err:	     err_msg = "from ios_$read ^a";
      325 	     goto call_com_err;
      326 	end;
      327 
      328 /* Count DCWs, by looking for one with action code = "000"b */
      329 
      330 	do ndcw = 1 to 58				/* there may be up to 58 of them in a block */
      331 		while (substr (preface.dcws (ndcw), 22, 3) ^= "000"b);
      332 	end;
      333 
      334 	pref_reloc = preface.reloc_words;		/* copy data from preface */
      335 	pref_data = preface.data_words;
      336 
      337 	i4 = pref_data + pref_reloc + 6 + ndcw;		/* compute number of words to copy */
      338 						/* (or to skip over, if this one not to be copied) */
      339 						/* NOTE that this number includes the preface record,
      340*						   which is copied along with the data */
      341 
      342 	call gcos_cv_gebcd_ascii_ (addr (preface.name), 6, addr (string), i); /* convert prog name to ascii */
      343 						/* and see if that name is in the control file */
      344 	i1 = index (string, " ");			/* find the end of it */
      345 	if i1 = 0 then i1 = 7;			/* if no trailing blank, must be 6 chars */
      346 
      347 	i3 = 1;					/* start search from beginning */
      348 search_control: i2 = index (substr (control, i3), substr (string, 1, i1-1)); /* look for the name in the control file */
      349 	if i2 ^= 0 then do;				/* if its there, extract the module - maybe */
      350 						/* Aviod extracting module "b" because "abc" occurs
      351*						   in the control file. Check that name in control file is
      352*						   delimited by blanks or newlines (or beginning of file) */
      353 	     if substr (control, i2+i1-1, 1) ^= ascii_newline then /* name must end in newline */
      354 		if substr (control, i2+i1-1, 1) ^= " " then /* or blank */
      355 		     goto keep_searching;		/* or we do not copy it */
      356 	     if i2 ^= 1 then			/* except for first name in control file */
      357 		if substr (control, i2-1, 1) ^= ascii_newline then /* name must begin with newline */
      358 		     if substr (control, i2-1, 1) ^= " " then /* or blank */
      359 keep_searching:		do;			/* or we do not copy it */
      360 			i3 = i2 + i1 - 1;		/* move search pointer past this name */
      361 			if i3 + i1 - 1 > segl then	/* if name is longer than remainder of file */
      362 			     goto next_preface;	/* give up and go look at next preface record */
      363 			else goto search_control;	/* else keep looking for it */
      364 		     end;
      365 
      366 	     if ^briefsw then			/* print name unless asked not to */
      367 		call ioa_ ("^a will be copied", string);
      368 
      369 	     substr (control, i2, i1) = "";		/* blank out name and trailing blank or newline */
      370 
      371 	     call ios_$seek ("gcem_input", "read", "read", -j, st); /* move read pointer back to beginning of preface */
      372 	     if code ^= 0 then goto seek_err;
      373 
      374 copyloop:	     if i4 < 3650 then i3 = i4;
      375 	     else i3 = 3650;
      376 	     call ios_$read ("gcem_input", prefp, 0, i3, j, st);
      377 	     if code ^= 0 then goto read_err;
      378 	     if i4 > j then i2 = j;
      379 	     else i2 = i4;
      380 	     call ios_$write ("gcem_output", prefp, 0, i2, i1, st);
      381 	     if code ^= 0 then do;
      382 		err_path = output_path;
      383 		err_msg = "from ios_$write ^a";
      384 		goto call_com_err;
      385 	     end;
      386 
      387 	     i4 = i4 -i1;
      388 	     if i4 > 0 then go to copyloop;
      389 	end;
      390 
      391 	if control = "" then do;			/* if all requested modules copied, quit */
      392 	     call ioa_ ("^/all requested modules copied");
      393 	     goto exit;
      394 	end;
      395 
      396 next_preface:
      397 	k = k+6+ndcw+pref_data+pref_reloc;		/* compute offset of next preface block */
      398 
      399 	goto seek_preface;				/* go seek to it */
      400 
      401 
      402 cleanup_proc: proc;
      403 	     call ios_$detach ("gcem_input", "", "", st);
      404 	     call ios_$detach ("gcem_output", "", "", st);
      405 	     if temp_segp ^= null then
      406 		call release_temp_segment_(me, temp_segp, code);
      407 
      408 	     return;
      409 	end cleanup_proc;
      410 
      411      end gcos_extract_module;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/09/83  1006.5  gcos_extract_module.pl1           >spec>on>09/07/83-gcos>gcos_extract_module.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 148 ref 170 172 174 186 186 186 186 186 187 194
                                                                                  204 205 206 217 223 235 239 248 261 269 277 289
                                                                                  294 294 295 307 312 323 342 342 342 342 372 377
                                                                                  381 405
arg                                    based           char                     unaligned dcl 87 ref 173 180 182 215 233 254 254 257
argl                            000104 automatic       fixed bin(17,0)          dcl 86 set ref 170* 173 180 182 186* 215 233 254 254
                                                                                  257
argno                           000105 automatic       fixed bin(17,0)          dcl 88 set ref 168* 170*
argp                            000102 automatic       pointer                  dcl 85 set ref 170* 173 180 182 186* 215 233 254 254
                                                                                  257
ascii_newline                          constant        char(1)                  initial unaligned dcl 137 ref 353 356
bc                              000207 automatic       fixed bin(17,0)          dcl 96 set ref 192* 194* 202
briefsw                         000563 automatic       bit(1)                   initial dcl 128 set ref 128* 254* 366
buffer                          000567 automatic       bit(131400)              unaligned dcl 146 set ref 277
cleanup                         000106 stack reference condition                dcl 90 ref 154
code                                   based           fixed bin(35,0)          level 2 dcl 109 set ref 170* 172 174* 186* 187 194*
                                                                                  204* 205 206* 217 223 235 239 248* 261* 269* 289
                                                                                  295 307 323 372 377 381 405*
com_err_                        000036 constant        entry                    external dcl 72 ref 174 206 316
control                                based           char                     unaligned dcl 98 set ref 209* 315* 315 316* 348 353
                                                                                  353 356 356 369* 391
control_orig                           based           char                     unaligned dcl 100 ref 209
control_path                    000313 automatic       char(168)                unaligned dcl 127 set ref 192* 197
cu_$arg_count                   000050 constant        entry                    external dcl 77 ref 158
cu_$arg_ptr                     000052 constant        entry                    external dcl 78 ref 170
data_words                5(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 114 ref 335
dcws                      6            based           bit(36)                  array level 2 packed unaligned dcl 114 ref 330
dir                             000231 automatic       char(168)                unaligned dcl 104 set ref 186 186 192* 194*
divide                                                 builtin function         dcl 148 ref 202
doff                            000211 automatic       fixed bin(17,0)          dcl 96 set ref 300* 302* 306
ename                           000221 automatic       char(32)                 unaligned dcl 103 set ref 186 186 192* 194*
eof                       1(09)        based           bit(1)                   level 2 packed unaligned dcl 109 ref 312
err_msg                         000114 automatic       varying char(200)        dcl 92 set ref 173* 174* 188* 198* 218* 224* 247*
                                                                                  262* 270* 290* 296* 308* 324* 383*
err_path                        000511 automatic       char(168)                unaligned dcl 127 set ref 174* 180* 197* 282* 382*
error_table_$badopt             000060 external static fixed bin(35,0)          dcl 140 ref 261
error_table_$noarg              000062 external static fixed bin(35,0)          dcl 140 ref 269
expand_path_                    000026 constant        entry                    external dcl 69 ref 186
gcos_cv_gebcd_ascii_            000046 constant        entry                    external dcl 76 ref 342
get_temp_segment_               000054 constant        entry                    external dcl 79 ref 204
hcs_$initiate_count             000030 constant        entry                    external dcl 70 ref 194
i                               000205 automatic       fixed bin(17,0)          dcl 96 set ref 342*
i1                              000177 automatic       fixed bin(17,0)          dcl 95 set ref 344* 345 345* 348 353 353 360 361 369
                                                                                  380* 387
i2                              000200 automatic       fixed bin(17,0)          dcl 95 set ref 348* 349 353 353 356 356 356 360 369
                                                                                  378* 379* 380*
i3                              000201 automatic       fixed bin(17,0)          dcl 95 set ref 347* 348 360* 361 374* 375* 376*
i4                              000202 automatic       fixed bin(17,0)          dcl 95 set ref 337* 374 374 378 379 387* 387 388
index                                                  builtin function         dcl 148 ref 344 348
input_path                      000365 automatic       char(168)                unaligned dcl 127 set ref 215* 216* 282 316*
ioa_                            000032 constant        entry                    external dcl 72 ref 164 313 366 392
ioa_$rsnnl                      000034 constant        entry                    external dcl 72 ref 192
ios_$attach                     000040 constant        entry                    external dcl 73 ref 216 234
ios_$detach                     000024 constant        entry                    external dcl 68 ref 403 404
ios_$read                       000020 constant        entry                    external dcl 66 ref 294 322 376
ios_$seek                       000044 constant        entry                    external dcl 75 ref 288 306 371
ios_$setsize                    000042 constant        entry                    external dcl 74 ref 222 238
ios_$write                      000022 constant        entry                    external dcl 67 ref 380
j                               000206 automatic       fixed bin(17,0)          dcl 96 set ref 294* 322* 371 376* 378 378
k                               000212 automatic       fixed bin(21,0)          dcl 97 set ref 279* 306 396* 396
me                              000010 internal static char(25)                 initial unaligned dcl 135 set ref 174* 204* 206*
                                                                                  316* 405*
name                      3            based           bit(36)                  level 2 packed unaligned dcl 114 set ref 342 342
nargs                           000100 automatic       fixed bin(17,0)          dcl 84 set ref 158* 162 168
ndcw                            000312 automatic       fixed bin(17,0)          dcl 125 set ref 330* 330* 337 396
nocatsw                         000564 automatic       bit(1)                   initial dcl 128 set ref 128* 257*
null                                                   builtin function         dcl 148 ref 156 196 405
output_path                     000437 automatic       char(168)                unaligned dcl 127 set ref 233* 234* 382
path_counter                    000566 automatic       fixed bin(17,0)          initial dcl 133 set ref 133* 184 210* 213 228* 231
                                                                                  242* 268
pref_data                       000203 automatic       fixed bin(17,0)          dcl 95 set ref 335* 337 396
pref_reloc                      000204 automatic       fixed bin(17,0)          dcl 95 set ref 334* 337 396
preface                                based           structure                level 1 dcl 114
prefp                           000310 automatic       pointer                  dcl 124 set ref 277* 322* 330 334 335 342 342 376*
                                                                                  380*
release_temp_segment_           000056 constant        entry                    external dcl 80 ref 405
reloc_words               5            based           fixed bin(17,0)          level 2 packed unaligned dcl 114 ref 334
segl                            000210 automatic       fixed bin(17,0)          dcl 96 set ref 202* 209 209 315 315 316 316 348 353
                                                                                  353 356 356 361 369 391
segp                            000216 automatic       pointer                  dcl 101 set ref 156* 194* 196 209
st                              000306 automatic       bit(72)                  dcl 107 set ref 170 172 174 186 187 194 204 205 206
                                                                                  216* 217 222* 223 234* 235 238* 239 248 261 269
                                                                                  288* 289 294* 295 306* 307 312 322* 323 371* 372
                                                                                  376* 377 380* 381 403* 404* 405
status                                 based           structure                level 1 dcl 109
string                          000304 automatic       char(6)                  unaligned dcl 105 set ref 342 342 344 348 366*
substr                                                 builtin function         dcl 148 set ref 182 330 348 348 353 353 356 356 369*
temp_segp                       000214 automatic       pointer                  dcl 99 set ref 156* 204* 209 315 315 316 348 353 353
                                                                                  356 356 369 391 405 405*
translate                                              builtin function         dcl 148 ref 315
usage_sw                        000565 automatic       bit(1)                   initial dcl 128 set ref 128* 175 246* 271*
word_one                        000220 automatic       fixed bin(35,0)          dcl 102 set ref 294 294 300

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
delete_$ptr                     000000 constant        entry                    external dcl 71
ioa_$nnl                        000000 constant        entry                    external dcl 72
mod                                                    builtin function         dcl 148
word_no                                automatic       fixed bin(17,0)          dcl 96

NAMES DECLARED BY EXPLICIT CONTEXT.
arg_loop                        000366 constant        label                    dcl 168
attach_err                      000772 constant        label                    dcl 218 ref 235
call_com_err                    000427 constant        label                    dcl 174 ref 189 199 219 225 249 263 272 291 297 309
                                                                                  325 384
cleanup_proc                    002257 constant        entry                    internal dcl 402 ref 154 165
copyloop                        002064 constant        label                    dcl 374 ref 388
exit                            000361 constant        label                    dcl 165 ref 176 207 318 393
extract                         000260 constant        entry                    external dcl 6
gcem                            000270 constant        entry                    external dcl 6
gcos_extract_module             000300 constant        entry                    external dcl 6
get_control                     000472 constant        label                    dcl 184
get_input                       000724 constant        label                    dcl 213
get_output                      001044 constant        label                    dcl 231
get_path                        000470 constant        label                    dcl 182
keep_searching                  001756 constant        label                    dcl 356 ref 353
next_preface                    002247 constant        label                    dcl 396 ref 361
print_usage                     000345 constant        label                    dcl 162 set ref 175
read                            001543 constant        label                    dcl 322
read_err                        001607 constant        label                    dcl 324 ref 377
search_control                  001706 constant        label                    dcl 348 ref 363
seek_err                        001440 constant        label                    dcl 308 ref 372
seek_preface                    001370 constant        label                    dcl 306 ref 399
setsize_err                     001031 constant        label                    dcl 224 ref 239

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3040        3124    2576        3050
Length      3344    2576        64         203     241          10

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
extract                            4130 external procedure  is an external procedure.  
on unit on line 154                  64 on unit               
cleanup_proc                         88 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 me                          extract

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
extract                  000100 nargs                       extract
                         000102 argp                        extract
                         000104 argl                        extract
                         000105 argno                       extract
                         000114 err_msg                     extract
                         000177 i1                          extract
                         000200 i2                          extract
                         000201 i3                          extract
                         000202 i4                          extract
                         000203 pref_data                   extract
                         000204 pref_reloc                  extract
                         000205 i                           extract
                         000206 j                           extract
                         000207 bc                          extract
                         000210 segl                        extract
                         000211 doff                        extract
                         000212 k                           extract
                         000214 temp_segp                   extract
                         000216 segp                        extract
                         000220 word_one                    extract
                         000221 ename                       extract
                         000231 dir                         extract
                         000304 string                      extract
                         000306 st                          extract
                         000310 prefp                       extract
                         000312 ndcw                        extract
                         000313 control_path                extract
                         000365 input_path                  extract
                         000437 output_path                 extract
                         000511 err_path                    extract
                         000563 briefsw                     extract
                         000564 nocatsw                     extract
                         000565 usage_sw                    extract
                         000566 path_counter                extract
                         000567 buffer                      extract

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return
enable              shorten_stack       ext_entry           int_entry           set_cs_eis          index_cs_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   expand_path_
gcos_cv_gebcd_ascii_          get_temp_segment_             hcs_$initiate_count           ioa_
ioa_$rsnnl                    ios_$attach                   ios_$detach                   ios_$read
ios_$seek                     ios_$setsize                  ios_$write                    release_temp_segment_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$noarg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    128 000251       133 000254         6 000257       154 000306       156 000330       158 000333       162 000342
    164 000345       165 000361       166 000365       168 000366       170 000375       172 000412       173 000416
    174 000427       175 000454       176 000456       180 000457       182 000464       184 000470       186 000472
    187 000515       188 000517       189 000524       192 000525       194 000557       196 000620       197 000624
    198 000627       199 000634       202 000635       204 000640       205 000661       206 000665       207 000710
    209 000711       210 000717       211 000721       213 000722       215 000724       216 000727       217 000770
    218 000772       219 000777       222 001000       223 001027       224 001031       225 001036       228 001037
    229 001041       231 001042       233 001044       234 001047       235 001107       238 001111       239 001141
    242 001143       243 001145       246 001146       247 001150       248 001155       249 001156       252 001157
    254 001160       257 001173       261 001202       262 001205       263 001211       266 001212       268 001214
    269 001217       270 001222       271 001223       272 001225       277 001226       279 001230       282 001231
    288 001234       289 001276       290 001300       291 001305       294 001306       295 001352       296 001354
    297 001361       300 001362       302 001367       306 001370       307 001434       308 001440       309 001445
    312 001446       313 001451       315 001470       316 001502       318 001542       322 001543       323 001605
    324 001607       325 001614       330 001615       332 001627       334 001631       335 001635       337 001641
    342 001645       344 001670       345 001701       347 001704       348 001706       349 001730       353 001731
    356 001743       360 001756       361 001761       363 001765       366 001766       369 002013       371 002021
    372 002062       374 002064       375 002071       376 002073       377 002133       378 002135       379 002143
    380 002144       381 002205       382 002207       383 002212       384 002217       387 002220       388 002222
    391 002224       392 002232       393 002246       396 002247       399 002255       402 002256       403 002264
    404 002314       405 002346       408 002374


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
